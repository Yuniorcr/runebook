<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="280e0dcd01a74e9f2971dc15e9ea5e4fed9ba1e7" translate="yes" xml:space="preserve">
          <source>GroupBy objects are returned by groupby calls: &lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt;&lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt;&lt;code&gt;pandas.Series.groupby()&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">GroupBy 객체는 &lt;a href=&quot;api/pandas.dataframe.groupby#pandas.DataFrame.groupby&quot;&gt; &lt;code&gt;pandas.DataFrame.groupby()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;api/pandas.series.groupby#pandas.Series.groupby&quot;&gt; &lt;code&gt;pandas.Series.groupby()&lt;/code&gt; &lt;/a&gt; 등의 그룹 호출로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef1b77e5d75adde3306a51cdd096ed01e94f4b14" translate="yes" xml:space="preserve">
          <source>GroupBy sorting</source>
          <target state="translated">GroupBy 정렬</target>
        </trans-unit>
        <trans-unit id="bf46240f856a5682954118b148c3e4fe55d034af" translate="yes" xml:space="preserve">
          <source>GroupBy with MultiIndex</source>
          <target state="translated">MultiIndex를 사용한 GroupBy</target>
        </trans-unit>
        <trans-unit id="32fdf78ac7e6bd8018e3271aa0c9d041f20f2211" translate="yes" xml:space="preserve">
          <source>Groupby a specific column with the desired frequency. This is like resampling.</source>
          <target state="translated">원하는 빈도로 특정 열을 기준으로 그룹화합니다. 이것은 리샘플링과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50ee04b10dd8ef682ca6c7cdb964b01ff1e4723f" translate="yes" xml:space="preserve">
          <source>Groupby also works with some plotting methods. For example, suppose we suspect that some features in a DataFrame may differ by group, in this case, the values in column 1 where the group is &amp;ldquo;B&amp;rdquo; are 3 higher on average.</source>
          <target state="translated">Groupby는 일부 플로팅 방법에서도 작동합니다. 예를 들어, DataFrame의 일부 기능이 그룹별로 다를 수 있다고 생각한다고 가정합니다.이 경우 그룹이 &quot;B&quot;인 열 1의 값은 평균 3 개 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="39c96bea6efc5cf3346c84735e823e0034188931" translate="yes" xml:space="preserve">
          <source>Groupby by indexer to &amp;lsquo;resample&amp;rsquo; data</source>
          <target state="translated">데이터를 '리샘플링'하기위한 인덱서 별 Groupby</target>
        </trans-unit>
        <trans-unit id="ab29307976ccacc26ac65efc4e37aa349c72454e" translate="yes" xml:space="preserve">
          <source>Groupby iterator.</source>
          <target state="translated">그룹 별 반복자.</target>
        </trans-unit>
        <trans-unit id="7b4bf5d82cf17787b55659f7a273347eac9f8902" translate="yes" xml:space="preserve">
          <source>Groupby key, which selects the grouping column of the target.</source>
          <target state="translated">대상의 그룹화 열을 선택하는 Groupby 키.</target>
        </trans-unit>
        <trans-unit id="918b5ad011a620824893a5734d02f858a6a13add" translate="yes" xml:space="preserve">
          <source>Groupby on a HDFStore with high group density</source>
          <target state="translated">그룹 밀도가 높은 HDFStore의 Groupby</target>
        </trans-unit>
        <trans-unit id="ddf0c2abdd85fb648361a521b0d32db681754f91" translate="yes" xml:space="preserve">
          <source>Groupby on a HDFStore with low group density</source>
          <target state="translated">그룹 밀도가 낮은 HDFStore의 Groupby</target>
        </trans-unit>
        <trans-unit id="e63f7dc74d42e24a6af9901ab8b42b7aa13d4a1a" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of only particular column in the group.</source>
          <target state="translated">하나의 열로 그룹화하고 그룹의 특정 열만 평균을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1791776b439188ec61725cdf5b05148568043324" translate="yes" xml:space="preserve">
          <source>Groupby one column and return the mean of the remaining columns in each group.</source>
          <target state="translated">하나의 열을 그룹화하고 각 그룹의 나머지 열의 평균을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c23dcbebf567a5f1cbcee4e7dadfd7904a8b5717" translate="yes" xml:space="preserve">
          <source>Groupby operations on the index will preserve the index nature as well.</source>
          <target state="translated">인덱스에 대한 Groupby 작업은 인덱스 특성도 보존합니다.</target>
        </trans-unit>
        <trans-unit id="d720fc80687d90ae00e0ff29c33e68654b9f8d9c" translate="yes" xml:space="preserve">
          <source>Groupby two columns and return the mean of the remaining column.</source>
          <target state="translated">두 개의 열을 그룹화하고 나머지 열의 평균을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7936f6ac97d94069c7eac9bde37e7210dab8305" translate="yes" xml:space="preserve">
          <source>Groupby will also show &amp;ldquo;unused&amp;rdquo; categories:</source>
          <target state="translated">Groupby는 &quot;미사용&quot;범주도 표시합니다.</target>
        </trans-unit>
        <trans-unit id="42c8f672af9a6da3268b6f4a99958d6e735607b1" translate="yes" xml:space="preserve">
          <source>Grouper</source>
          <target state="translated">Grouper</target>
        </trans-unit>
        <trans-unit id="439ef5b4855b51a20d486556cd3d53a3ceee4963" translate="yes" xml:space="preserve">
          <source>Grouper()</source>
          <target state="translated">Grouper()</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="bea5d4da543fa550ad0fc184bd837b179b3659cb" translate="yes" xml:space="preserve">
          <source>Grouping DataFrame with Index levels and columns</source>
          <target state="translated">인덱스 수준 및 열로 DataFrame 그룹화</target>
        </trans-unit>
        <trans-unit id="3360636443934b7226aa2d127f6a2ac58e7d4669" translate="yes" xml:space="preserve">
          <source>Grouping and summarizing</source>
          <target state="translated">그룹화 및 요약</target>
        </trans-unit>
        <trans-unit id="f8f359575ce3ab2a02a810c3b1782873145964fe" translate="yes" xml:space="preserve">
          <source>Grouping and then applying the &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; function to the resulting groups.</source>
          <target state="translated">그룹화 한 다음 결과 그룹에 &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; 함수를 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="afcadcfef8d4935dc588e61f6702eec50be51112" translate="yes" xml:space="preserve">
          <source>Grouping by a categorical column also shows empty categories.</source>
          <target state="translated">범주 형 열로 그룹화하면 빈 범주도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ac86dfd20ea0c35fb856dec7c01ef9c8dbf27fa3" translate="yes" xml:space="preserve">
          <source>Grouping by multiple columns forms a hierarchical index, and again we can apply the &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">여러 열로 그룹화하면 계층 적 인덱스가 형성되고 다시 &lt;a href=&quot;../reference/api/pandas.core.groupby.groupby.sum#pandas.core.groupby.GroupBy.sum&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; 함수를 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72a25e97424d28d2b53606830a675cb2c5765592" translate="yes" xml:space="preserve">
          <source>Grouping like Python&amp;rsquo;s itertools.groupby</source>
          <target state="translated">Python의 itertools.groupby와 같은 그룹화</target>
        </trans-unit>
        <trans-unit id="8c6d5986d1d0890c74650296e8acadfc61d984d3" translate="yes" xml:space="preserve">
          <source>Grouping using a MultiIndex</source>
          <target state="translated">MultiIndex를 사용하여 그룹화</target>
        </trans-unit>
        <trans-unit id="5125fd5e29c34786d3e8901ae40be86c001faeb2" translate="yes" xml:space="preserve">
          <source>Grouping with a grouper specification</source>
          <target state="translated">그룹화 사양으로 그룹화</target>
        </trans-unit>
        <trans-unit id="dbfa32bfae76816eb5fcd1ed109b80e107640b8d" translate="yes" xml:space="preserve">
          <source>Grouping with multiple levels is supported.</source>
          <target state="translated">여러 수준의 그룹화가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="12d0d69e2faac3cba479930cd6f20092c9c0ea1a" translate="yes" xml:space="preserve">
          <source>Grouping with ordered factors</source>
          <target state="translated">순서가 지정된 요인으로 그룹화</target>
        </trans-unit>
        <trans-unit id="79300cb379b299ff45fb8750bc24f22896f49f6d" translate="yes" xml:space="preserve">
          <source>Guaranteed return of an indexer even when non-unique.</source>
          <target state="translated">고유하지 않은 경우에도 인덱서의 반환을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7c1d0e621e0ca09058706d36a425fc4578904765" translate="yes" xml:space="preserve">
          <source>HDF5</source>
          <target state="translated">HDF5</target>
        </trans-unit>
        <trans-unit id="4d0784f9d9f96af76bb1f3d1e361bf164aa153e1" translate="yes" xml:space="preserve">
          <source>HDF5 (PyTables)</source>
          <target state="translated">HDF5 (PyTables)</target>
        </trans-unit>
        <trans-unit id="92aab64c23220250c4b7eff53be23edf32d43f26" translate="yes" xml:space="preserve">
          <source>HDF5 Format</source>
          <target state="translated">HDF5 형식</target>
        </trans-unit>
        <trans-unit id="13e3758fc9538b8efd6e347d1be18dbf1cbc68fd" translate="yes" xml:space="preserve">
          <source>HDF5 reading / writing</source>
          <target state="translated">HDF5 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="2042ab10d2a6b286f6f10f05830da036077c6714" translate="yes" xml:space="preserve">
          <source>HDF5-based reading / writing</source>
          <target state="translated">HDF5 기반 읽기 / 쓰기</target>
        </trans-unit>
        <trans-unit id="75fbd819b26ac15432c615f102871f48862eb405" translate="yes" xml:space="preserve">
          <source>HDFStore</source>
          <target state="translated">HDFStore</target>
        </trans-unit>
        <trans-unit id="1e6cc28b0699c70e48d3ba2bd954a3c1d6db4410" translate="yes" xml:space="preserve">
          <source>HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting &lt;code&gt;dropna=True&lt;/code&gt;.</source>
          <target state="translated">HDFStore는 기본적으로 모두 누락 된 행을 삭제하지 않습니다. 이 동작은 &lt;code&gt;dropna=True&lt;/code&gt; 설정하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2315b78c90521194806e6ff15e4519be29290f8e" translate="yes" xml:space="preserve">
          <source>HDFStore.append()</source>
          <target state="translated">HDFStore.append()</target>
        </trans-unit>
        <trans-unit id="3c06f7762f6274d7f755a35a5ece2d1938d4d16f" translate="yes" xml:space="preserve">
          <source>HDFStore.get()</source>
          <target state="translated">HDFStore.get()</target>
        </trans-unit>
        <trans-unit id="cf1d970069f4505ca66af47560075f080d7fdebb" translate="yes" xml:space="preserve">
          <source>HDFStore.groups()</source>
          <target state="translated">HDFStore.groups()</target>
        </trans-unit>
        <trans-unit id="2ac4435c6ecd4445adfd51cc1924d3128de8464c" translate="yes" xml:space="preserve">
          <source>HDFStore.info()</source>
          <target state="translated">HDFStore.info()</target>
        </trans-unit>
        <trans-unit id="a63dab9ef218085a01b08427a9709a9da31fdd26" translate="yes" xml:space="preserve">
          <source>HDFStore.keys()</source>
          <target state="translated">HDFStore.keys()</target>
        </trans-unit>
        <trans-unit id="3adc308c4363c6063de35b9f347d5df2b4b2dd55" translate="yes" xml:space="preserve">
          <source>HDFStore.put()</source>
          <target state="translated">HDFStore.put()</target>
        </trans-unit>
        <trans-unit id="f47662db7950975a5ae22dcd0f80f911933903e7" translate="yes" xml:space="preserve">
          <source>HDFStore.select()</source>
          <target state="translated">HDFStore.select()</target>
        </trans-unit>
        <trans-unit id="1832f491303fd89a2974748d322daf584ae70a42" translate="yes" xml:space="preserve">
          <source>HDFStore.walk()</source>
          <target state="translated">HDFStore.walk()</target>
        </trans-unit>
        <trans-unit id="a7b6ae83f2cc25f8ad0ff53d17f8388b4154d54e" translate="yes" xml:space="preserve">
          <source>HDFStore: PyTables (HDF5)</source>
          <target state="translated">HDFStore : PyTables (HDF5)</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="06c9f44f3e2be2f8c75b4052579d6903ad2edb30" translate="yes" xml:space="preserve">
          <source>HTML Table Parsing Gotchas</source>
          <target state="translated">HTML 테이블 구문 분석 문제</target>
        </trans-unit>
        <trans-unit id="bec8b87bbf1ceb04748df519c09bdd4a4242e7e8" translate="yes" xml:space="preserve">
          <source>HTML parser for read_html (see &lt;a href=&quot;#optional-html&quot;&gt;note&lt;/a&gt;)</source>
          <target state="translated">read_html 용 HTML 파서 (참고 &lt;a href=&quot;#optional-html&quot;&gt;사항&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="5bd8e02b619f57af85ab307312adff41f7e01a52" translate="yes" xml:space="preserve">
          <source>HTML result.</source>
          <target state="translated">HTML 결과.</target>
        </trans-unit>
        <trans-unit id="1d1bf76b1fca3d41efaf27152174bffcbb14206d" translate="yes" xml:space="preserve">
          <source>HTML result. These classes are added within specified</source>
          <target state="translated">HTML 결과. 이 클래스는 지정된 범위 내에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="11dc542c0ffeed8b41bad901e2044f438e4ab0e5" translate="yes" xml:space="preserve">
          <source>HTML:</source>
          <target state="translated">HTML:</target>
        </trans-unit>
        <trans-unit id="dc1a076811de9231220364407db78fe7dff1efa1" translate="yes" xml:space="preserve">
          <source>Hadley Wickham&amp;rsquo;s &lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; is a foundational exploratory visualization package for the R language. Based on &lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&amp;ldquo;The Grammar of Graphics&amp;rdquo;&lt;/a&gt; it provides a powerful, declarative and extremely general way to generate bespoke plots of any kind of data. It&amp;rsquo;s really quite incredible. Various implementations to other languages are available, but a faithful implementation for Python users has long been missing. Although still young (as of Jan-2014), the &lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat/ggpy&lt;/a&gt; project has been progressing quickly in that direction.</source>
          <target state="translated">Hadley Wickham의 &lt;a href=&quot;https://ggplot2.tidyverse.org/&quot;&gt;ggplot2&lt;/a&gt; 는 R 언어를위한 기본 탐색 시각화 패키지입니다. &lt;a href=&quot;https://www.cs.uic.edu/~wilkinson/TheGrammarOfGraphics/GOG.html&quot;&gt;&quot;그래픽 문법&quot;을&lt;/a&gt; 기반으로 모든 종류의 데이터에 대한 맞춤형 플롯을 생성하는 강력하고 선언적이며 매우 일반적인 방법을 제공합니다. 정말 대단합니다. 다른 언어에 대한 다양한 구현이 가능하지만 Python 사용자를위한 충실한 구현은 오랫동안 누락되었습니다. 아직은 젊지 만 (2014 년 1 월 현재) &lt;a href=&quot;https://github.com/yhat/ggpy&quot;&gt;yhat / ggpy&lt;/a&gt; 프로젝트는 그 방향으로 빠르게 진행되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="58e12ddb14f6f822bcd8d3ae4e6bb3cbe96c7a13" translate="yes" xml:space="preserve">
          <source>Handle these ambiguous times by specifying the following.</source>
          <target state="translated">다음을 지정하여 이러한 모호한 시간을 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="7c197bf13850693a62be0f9cbc4ad92a5ec806fd" translate="yes" xml:space="preserve">
          <source>Handler to call if object cannot otherwise be converted to a suitable format for JSON. Should receive a single argument which is the object to convert and return a serialisable object.</source>
          <target state="translated">그렇지 않으면 객체를 JSON에 적합한 형식으로 변환 할 수없는 경우 호출 할 핸들러입니다. 직렬화 가능한 객체를 변환하고 반환 할 객체 인 단일 인수를 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="1bc3b2505837662fcbdfc517f2a1895b70ef262d" translate="yes" xml:space="preserve">
          <source>Handles the leap year case as well:</source>
          <target state="translated">윤년 사례도 처리합니다.</target>
        </trans-unit>
        <trans-unit id="46d71ad7a53d41e7f92c55501ff895dde5287631" translate="yes" xml:space="preserve">
          <source>Handling &amp;ldquo;bad&amp;rdquo; lines</source>
          <target state="translated">&quot;불량&quot;라인 처리</target>
        </trans-unit>
        <trans-unit id="90545bb5835723940b207d6d85a9b68c0212d6c8" translate="yes" xml:space="preserve">
          <source>Handling column names</source>
          <target state="translated">열 이름 처리</target>
        </trans-unit>
        <trans-unit id="b705fcddebca8a2e54628df55916f3a124b0fddf" translate="yes" xml:space="preserve">
          <source>Handling indexes</source>
          <target state="translated">인덱스 처리</target>
        </trans-unit>
        <trans-unit id="804fe0806cf830f124c1462f636392df61b369ab" translate="yes" xml:space="preserve">
          <source>Handling of (un)observed Categorical values</source>
          <target state="translated">(비) 관찰 된 범주 형 값 처리</target>
        </trans-unit>
        <trans-unit id="8ebd411c16de03f824e7e963a0ca15fcfc23c034" translate="yes" xml:space="preserve">
          <source>Has no effect but is accepted for compatibility with numpy.</source>
          <target state="translated">효과는 없지만 numpy와의 호환성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3008b93348839f05f66696fd64d26af09f702629" translate="yes" xml:space="preserve">
          <source>Has the correct &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; class attributes set.</source>
          <target state="translated">올바른 &lt;code&gt;env&lt;/code&gt; 및 &lt;code&gt;template&lt;/code&gt; 클래스 속성이 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d2254d4a789d989c2b2664108442e3526a1101" translate="yes" xml:space="preserve">
          <source>Hash table-based unique.</source>
          <target state="translated">해시 테이블 기반 고유.</target>
        </trans-unit>
        <trans-unit id="6425f543a801b25f82203571fd175fdf4730a76a" translate="yes" xml:space="preserve">
          <source>Hash table-based unique. Uniques are returned in order of appearance. This does NOT sort.</source>
          <target state="translated">해시 테이블 기반 고유. 모양 순서대로 고유 항목이 반환됩니다. 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e193cbedf5e701ce24af4ab6f04e23203933d9e8" translate="yes" xml:space="preserve">
          <source>Hash_key for string key to encode.</source>
          <target state="translated">인코딩 할 문자열 키의 Hash_key입니다.</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="7ca230abf27a8d0783dda3e3a009514bc03f3dcc" translate="yes" xml:space="preserve">
          <source>Having a duplicated index will raise for a &lt;code&gt;.reindex()&lt;/code&gt;:</source>
          <target state="translated">중복 인덱스가 있으면 &lt;code&gt;.reindex()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="880b58b88e88151082e731678ce3c724dafb7219" translate="yes" xml:space="preserve">
          <source>Head and tail</source>
          <target state="translated">머리와 꼬리</target>
        </trans-unit>
        <trans-unit id="1bb6d883feee979d1e59b94e521dd11f3e0a12d1" translate="yes" xml:space="preserve">
          <source>Helper function to convert DataFrame and Series to matplotlib.table.</source>
          <target state="translated">DataFrame 및 Series를 matplotlib.table로 변환하는 도우미 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ef6feb04d2cc1517b1a7d23c7680888c4feb48d2" translate="yes" xml:space="preserve">
          <source>Helps style a DataFrame or Series according to the data with HTML and CSS.</source>
          <target state="translated">HTML 및 CSS를 사용하여 데이터에 따라 DataFrame 또는 Series의 스타일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="158ccd51d8c878205e5636d3f99db16bf05effe5" translate="yes" xml:space="preserve">
          <source>Here &amp;lsquo;c&amp;rsquo; and &amp;lsquo;f&amp;rsquo; are not represented in the data and will not be shown in the output because dropna is True by default. Set dropna=False to preserve categories with no data.</source>
          <target state="translated">여기서 'c'와 'f'는 데이터에 표시되지 않으며 dropna가 기본적으로 True이므로 출력에 표시되지 않습니다. 데이터가없는 카테고리를 유지하려면 dropna = False로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8619034f5d8a24bc1e04110edf64b5187717db5d" translate="yes" xml:space="preserve">
          <source>Here &lt;a href=&quot;../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform&quot;&gt;&lt;code&gt;transform()&lt;/code&gt;&lt;/a&gt; received a single function; this is equivalent to a &lt;a href=&quot;https://numpy.org/doc/stable/reference/ufuncs.html&quot;&gt;ufunc&lt;/a&gt; application.</source>
          <target state="translated">여기서 &lt;a href=&quot;../reference/api/pandas.dataframe.transform#pandas.DataFrame.transform&quot;&gt; &lt;code&gt;transform()&lt;/code&gt; &lt;/a&gt; 은 단일 함수를 받았습니다. 이것은 &lt;a href=&quot;https://numpy.org/doc/stable/reference/ufuncs.html&quot;&gt;ufunc&lt;/a&gt; 응용 프로그램 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="eb498dc0133a396e16fbab2a4cc64715ce635afe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;'type'&lt;/code&gt; is optional, and can be a nested pandas type specification here (but not categorical)</source>
          <target state="translated">여기서 &lt;code&gt;'type'&lt;/code&gt; 은 선택 사항이며 여기에서 중첩 팬더 유형 사양 일 수 있습니다 (단, 범주는 아님).</target>
        </trans-unit>
        <trans-unit id="1d0d20df741a19de9966e743d9965ede0d8c2325" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;origin&lt;/code&gt; is the default name given to your remote repository on GitHub. You can see the remote repositories:</source>
          <target state="translated">여기서 &lt;code&gt;origin&lt;/code&gt; 은 GitHub의 원격 저장소에 지정된 기본 이름입니다. 원격 저장소를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd7acc3d2934c47bf767aabcf0a0a1045090fcba" translate="yes" xml:space="preserve">
          <source>Here are a few interesting examples.</source>
          <target state="translated">다음은 몇 가지 흥미로운 예입니다.</target>
        </trans-unit>
        <trans-unit id="57c90bbd4cc0875781c24f250ae82def1a858909" translate="yes" xml:space="preserve">
          <source>Here are just a few of the things that pandas does well:</source>
          <target state="translated">팬더가 잘하는 몇 가지 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a48a53a3eeb7f35d9bd9ef58204ea375b22f3555" translate="yes" xml:space="preserve">
          <source>Here are some examples of datetime strings that can be guessed (All representing December 30th, 2011 at 00:00:00):</source>
          <target state="translated">다음은 추측 할 수있는 datetime 문자열의 몇 가지 예입니다 (모두 2011 년 12 월 30 일 00:00:00을 나타냄).</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b4aeaea13540388e074b786658dd6cb588265e66" translate="yes" xml:space="preserve">
          <source>Here is a basic tenet to keep in mind: &lt;strong&gt;data alignment is intrinsic&lt;/strong&gt;. The link between labels and data will not be broken unless done so explicitly by you.</source>
          <target state="translated">다음은 명심해야 할 기본 원칙입니다. &lt;strong&gt;데이터 정렬은 본질적&lt;/strong&gt; 입니다. 사용자가 명시 적으로하지 않으면 레이블과 데이터 간의 연결이 끊어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ea58d8d9e42af87e8caa9d68ed8a547761d5bb4" translate="yes" xml:space="preserve">
          <source>Here is a more complicated example with multiple join keys. Only the keys appearing in &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; are present (the intersection), since &lt;code&gt;how='inner'&lt;/code&gt; by default.</source>
          <target state="translated">다음은 여러 개의 조인 키가있는보다 복잡한 예입니다. 기본적으로 &lt;code&gt;how='inner'&lt;/code&gt; 이므로 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 나타나는 키만 있습니다 (교차점) .</target>
        </trans-unit>
        <trans-unit id="ab8e8ea95ae7bf0defacc7692b79888576dc32c3" translate="yes" xml:space="preserve">
          <source>Here is a quick reference summary table of common functions. Each also takes an optional &lt;code&gt;level&lt;/code&gt; parameter which applies only if the object has a &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical index&lt;/a&gt;.</source>
          <target state="translated">다음은 일반적인 기능에 대한 빠른 참조 요약 표입니다. 또한 각각 은 객체에 &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;계층 적 색인&lt;/a&gt; 이있는 경우에만 적용되는 선택적 &lt;code&gt;level&lt;/code&gt; 매개 변수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0d5643537f0f51a6854fc58eb3352e4428cfc1a6" translate="yes" xml:space="preserve">
          <source>Here is a real-world times-series example</source>
          <target state="translated">다음은 실제 시계열 예제입니다.</target>
        </trans-unit>
        <trans-unit id="2761aae2553cd60018f3fc88987941d00c347168" translate="yes" xml:space="preserve">
          <source>Here is a recipe for generating a query and using it to create equal sized return chunks.</source>
          <target state="translated">다음은 쿼리를 생성하고이를 사용하여 동일한 크기의 반환 청크를 만드는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="24a5d5de06a3beca2e7b0755d842882c6d86b038" translate="yes" xml:space="preserve">
          <source>Here is a sample (using 100 column x 100,000 row &lt;code&gt;DataFrames&lt;/code&gt;):</source>
          <target state="translated">다음은 샘플입니다 (100 개 열 x 100,000 개 행 &lt;code&gt;DataFrames&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="8cb9fc3a406988ae21b268f402abd1ae6f24810e" translate="yes" xml:space="preserve">
          <source>Here is a typical use-case for using this type of indexing. Imagine that you have a somewhat irregular timedelta-like indexing scheme, but the data is recorded as floats. This could, for example, be millisecond offsets.</source>
          <target state="translated">다음은 이러한 유형의 인덱싱을 사용하는 일반적인 사용 사례입니다. 다소 불규칙한 타임 델타와 같은 인덱싱 체계가 있지만 데이터는 부동 소수점으로 기록된다고 가정 해보십시오. 예를 들어 밀리 초 오프셋이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c821efcdfcf141472c6dc48cb7fc32b0aa88f1" translate="yes" xml:space="preserve">
          <source>Here is a typical usecase. You have comma separated strings in a column and want to expand this.</source>
          <target state="translated">다음은 일반적인 사용 사례입니다. 열에 쉼표로 구분 된 문자열이 있고이를 확장하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3f944828834dd16d5151a4915c604fb981122b37" translate="yes" xml:space="preserve">
          <source>Here is an example of a self-contained set of tests that illustrate multiple features that we like to use.</source>
          <target state="translated">다음은 우리가 사용하고자하는 여러 기능을 보여주는 자체 포함 된 테스트 세트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="23a618ab8a95adb5ee1b90429b7d557f8f970e97" translate="yes" xml:space="preserve">
          <source>Here is an example of each of these methods. First, the default &lt;code&gt;join='outer'&lt;/code&gt; behavior:</source>
          <target state="translated">다음은 이러한 각 방법의 예입니다. 먼저 기본 &lt;code&gt;join='outer'&lt;/code&gt; 동작 :</target>
        </trans-unit>
        <trans-unit id="f53355fe7427e04619d8bfd8d6d3f63a25299701" translate="yes" xml:space="preserve">
          <source>Here is an example of one way to easily plot group means with standard deviations from the raw data.</source>
          <target state="translated">다음은 원시 데이터의 표준 편차를 사용하여 그룹 평균을 쉽게 플로팅하는 한 가지 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="22ebc10164acf0daf0825fdd5c161702fb625bfa" translate="yes" xml:space="preserve">
          <source>Here is another example with duplicate join keys in DataFrames:</source>
          <target state="translated">다음은 DataFrames에 중복 조인 키가있는 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="f00ebbc96feac952e5b8441f93f7abf964a535a4" translate="yes" xml:space="preserve">
          <source>Here is how to view the top and bottom rows of the frame:</source>
          <target state="translated">프레임의 상단 및 하단 행을 보는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43a546924cfd7fc3d41ac31690e23053da201bb2" translate="yes" xml:space="preserve">
          <source>Here is the default behavior, notice how the x-axis tick labeling is performed:</source>
          <target state="translated">다음은 기본 동작입니다. x 축 눈금 레이블이 어떻게 수행되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ba4bad7934460a80f863bfdba98774b48472faf0" translate="yes" xml:space="preserve">
          <source>Here is the same thing with &lt;code&gt;join='inner'&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;join='inner'&lt;/code&gt; 와 같은 것입니다 .</target>
        </trans-unit>
        <trans-unit id="16c36edb11aab952de7238aea1b16530fc5cb8f5" translate="yes" xml:space="preserve">
          <source>Here we can see that, when setting &lt;code&gt;origin&lt;/code&gt; to &lt;code&gt;'epoch'&lt;/code&gt;, the result after &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; are identical depending on the start of time series:</source>
          <target state="translated">여기에서 &lt;code&gt;origin&lt;/code&gt; 을 &lt;code&gt;'epoch'&lt;/code&gt; 로 설정하면 시계열 시작에 따라 &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; 이후의 결과 가 동일 함을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e8b6e3df62487c5013989ae5875e737adce772" translate="yes" xml:space="preserve">
          <source>Here we can see that, when using &lt;code&gt;origin&lt;/code&gt; with its default value (&lt;code&gt;'start_day'&lt;/code&gt;), the result after &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; are not identical depending on the start of time series:</source>
          <target state="translated">여기에서 기본값 ( &lt;code&gt;'start_day'&lt;/code&gt; ) 으로 &lt;code&gt;origin&lt;/code&gt; 을 사용할 때 &lt;code&gt;'2000-10-02 00:00:00'&lt;/code&gt; 이후의 결과 는 시계열 시작에 따라 동일하지 않음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a130bb6d2b269db357d8376f97e1107e7ce04d4c" translate="yes" xml:space="preserve">
          <source>Here we construct a simple time series data set to use for illustrating the indexing functionality:</source>
          <target state="translated">다음은 인덱싱 기능을 설명하는 데 사용할 간단한 시계열 데이터 집합을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="fd9b2cf6332d18d9140f68e40ee723e9daac96ff" translate="yes" xml:space="preserve">
          <source>Here we discuss a lot of the essential functionality common to the pandas data structures. Here&amp;rsquo;s how to create some of the objects used in the examples from the previous section:</source>
          <target state="translated">여기서는 팬더 데이터 구조에 공통적 인 필수 기능을 많이 설명합니다. 이전 섹션의 예제에서 사용 된 일부 개체를 만드는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="520aaca96214b09c92db1a304a3c24a849e08087" translate="yes" xml:space="preserve">
          <source>Here we discuss a lot of the essential functionality common to the pandas data structures. To begin, let&amp;rsquo;s create some example objects like we did in the &lt;a href=&quot;10min#min&quot;&gt;10 minutes to pandas&lt;/a&gt; section:</source>
          <target state="translated">여기에서는 pandas 데이터 구조에 공통적 인 많은 필수 기능에 대해 설명합니다. 시작하려면 &lt;a href=&quot;10min#min&quot;&gt;10 분 동안 pandas&lt;/a&gt; 섹션 에서했던 것과 같은 몇 가지 예제 개체를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1962f1379801e34e3473e040d888c5d732cbc345" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with a Series.</source>
          <target state="translated">여기서는 DataFrame과 Series를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="217a16b260162c6b9ecb75aafaf0420285c29b8e" translate="yes" xml:space="preserve">
          <source>Here we multiply a DataFrame with another DataFrame.</source>
          <target state="translated">여기서는 DataFrame과 다른 DataFrame을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="901b74d6c5c2ab9f7fb4f6269ab16305edfca5b2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a boring example of rendering a DataFrame, without any (visible) styles:</source>
          <target state="translated">다음은 (보이는) 스타일없이 DataFrame을 렌더링하는 지루한 예입니다.</target>
        </trans-unit>
        <trans-unit id="ade488284bcb2d315b9857b5a71d06a045b7e2a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example implementation, which relies on casting the extension array to object dtype. This uses the helper method &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt;.</source>
          <target state="translated">다음은 확장 배열을 객체 dtype으로 캐스팅하는 구현 예제입니다. 이것은 도우미 메소드 &lt;code&gt;pandas.api.extensions.take()&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fa4e641ba9561c10a3cc502bc8073154340d3577" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of how the index metadata is structured in pyarrow:</source>
          <target state="translated">다음은 인덱스 메타 데이터가 pyarrow에서 어떻게 구성되는지에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="f572a71811f0f563fe73dd42aa90e9196d2abf9f" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you can change the above with the new &lt;code&gt;align='mid'&lt;/code&gt; option:</source>
          <target state="translated">새로운 &lt;code&gt;align='mid'&lt;/code&gt; 옵션으로 위의 내용을 변경하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ab62496d5c665ac1b5f50c1319d13221f4ea9788" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the function in pure Python:</source>
          <target state="translated">순수한 파이썬의 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d56691ee65295aa8cd217efc5f1fb0ec7a019f8" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the template structure:</source>
          <target state="translated">템플릿 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd5f260a168827626f78de5b53f7fbc115fd0ce9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; and so forth are dictionaries containing the metadata for each column, &lt;em&gt;including the index columns&lt;/em&gt;. This has JSON form:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;c0&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;ci0&amp;gt;&lt;/code&gt; &lt;em&gt;등은 인덱스 열을 포함하여&lt;/em&gt; 각 열의 메타 데이터를 포함하는 사전 입니다. 이것은 JSON 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ea88593cb4a459ae35a505f3a4797efa4ba41e7d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;data&lt;/code&gt; can be many different things:</source>
          <target state="translated">여기서 &lt;code&gt;data&lt;/code&gt; 는 여러 가지가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2209d4a279c0f96f254c0f3985cac25e0c79d658" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;f&lt;/code&gt; label was not contained in the Series and hence appears as &lt;code&gt;NaN&lt;/code&gt; in the result.</source>
          <target state="translated">여기서 &lt;code&gt;f&lt;/code&gt; 레이블은 시리즈에 포함되지 않았으므로 결과에 &lt;code&gt;NaN&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="367e96118a43c8abe35b5adc3684f98a88f4d169" translate="yes" xml:space="preserve">
          <source>Here, there are expressions on different lines, making it multiline, but the last line has no variable assigned to the output of</source>
          <target state="translated">여기에는 다른 줄에 여러 줄로 된 표현식이 있지만 마지막 줄에는 출력에 할당 된 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8578a243d227600659d59a488618d0fcbdeafb33" translate="yes" xml:space="preserve">
          <source>Here, there are expressions on different lines, making it multiline, but the last line has no variable assigned to the output of &lt;code&gt;a + 2&lt;/code&gt;.</source>
          <target state="translated">여기에는 여러 줄에 표현식이있어 여러 줄로 표시되지만 마지막 줄에는 &lt;code&gt;a + 2&lt;/code&gt; 의 출력에 지정된 변수가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="453713ccad6edfbc5405a61e004c0c1430893a5b" translate="yes" xml:space="preserve">
          <source>Hexagonal bin plot</source>
          <target state="translated">육각형 빈 플롯</target>
        </trans-unit>
        <trans-unit id="29aaaf58b1b7c87af3da68daa99b0dc678b41d70" translate="yes" xml:space="preserve">
          <source>Hexagonal binning plot using matplotlib, the matplotlib function that is used under the hood.</source>
          <target state="translated">후드 아래에서 사용되는 matplotlib 함수 인 matplotlib를 사용하는 6 각 비닝 플롯.</target>
        </trans-unit>
        <trans-unit id="e4ea59ac502bd091d6b3044bcc3a7e4faa7076ab" translate="yes" xml:space="preserve">
          <source>Hexbin</source>
          <target state="translated">Hexbin</target>
        </trans-unit>
        <trans-unit id="4b2faf5cd777f9e9a92fe8907b82dcdf0f0474e9" translate="yes" xml:space="preserve">
          <source>Hide any indices from rendering.</source>
          <target state="translated">렌더링에서 인덱스를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="78d0b0e4e9c34ece1c9f3157d86d6d1ecb4d874b" translate="yes" xml:space="preserve">
          <source>Hide columns from rendering.</source>
          <target state="translated">렌더링에서 열을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="bd353e1c956b727376767cec3296c124209a3bf3" translate="yes" xml:space="preserve">
          <source>Hiding the Index or Columns</source>
          <target state="translated">인덱스 또는 열 숨기기</target>
        </trans-unit>
        <trans-unit id="9bfcf47106d24e26c8f6da4717ec31b0b2fed3e9" translate="yes" xml:space="preserve">
          <source>Hierarchical / Multi-level indexing is very exciting as it opens the door to some quite sophisticated data analysis and manipulation, especially for working with higher dimensional data. In essence, it enables you to store and manipulate data with an arbitrary number of dimensions in lower dimensional data structures like &lt;code&gt;Series&lt;/code&gt; (1d) and &lt;code&gt;DataFrame&lt;/code&gt; (2d).</source>
          <target state="translated">계층 적 / 다중 레벨 인덱싱은 특히 더 높은 차원의 데이터로 작업 할 때 매우 정교한 데이터 분석 및 조작의 문을 열어 주므로 매우 흥미 롭습니다. 본질적으로 &lt;code&gt;Series&lt;/code&gt; (1d) 및 &lt;code&gt;DataFrame&lt;/code&gt; (2d) 와 같은 저 차원 데이터 구조에서 임의의 수의 차원으로 데이터를 저장하고 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26c08f6047ab488a2eab24b98eb1681296096769" translate="yes" xml:space="preserve">
          <source>Hierarchical Data Format (HDF) is self-describing, allowing an application to interpret the structure and contents of a file with no outside information. One HDF file can hold a mix of related objects which can be accessed as a group or as individual objects.</source>
          <target state="translated">HDF (Hierarchical Data Format)는 자체 설명이므로 응용 프로그램에서 외부 정보없이 파일의 구조와 내용을 해석 할 수 있습니다. 하나의 HDF 파일에는 그룹 또는 개별 객체로 액세스 할 수있는 관련 객체가 혼합되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67724216d805a96555340d07e6d2a1f2633c2f46" translate="yes" xml:space="preserve">
          <source>Hierarchical indexing (MultiIndex)</source>
          <target state="translated">계층 적 인덱싱 (MultiIndex)</target>
        </trans-unit>
        <trans-unit id="1a9f500d25e9b6e9fe7d2a3db8e7b8f2d7ac56fe" translate="yes" xml:space="preserve">
          <source>Hierarchical keys</source>
          <target state="translated">계층 적 키</target>
        </trans-unit>
        <trans-unit id="3e7fe953892ec885f20573b0003196c021532c0e" translate="yes" xml:space="preserve">
          <source>Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node.</source>
          <target state="translated">루트 노드 아래에 저장된 항목에 대해 위에서 설명한 것처럼 계층 적 키는 점 (속성) 액세스로 검색 할 수 없습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="b0d5447bdfc0df1a34b46d8a2d1ee8d33f0c163c" translate="yes" xml:space="preserve">
          <source>Hierarchical queries on a HDFStore</source>
          <target state="translated">HDFStore에 대한 계층 적 쿼리</target>
        </trans-unit>
        <trans-unit id="3837ce83f3d8a13c3570b62b1a2b446adaff328e" translate="yes" xml:space="preserve">
          <source>Highlight the maximum by shading the background.</source>
          <target state="translated">배경을 음영 처리하여 최대 값을 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="95eeff0d7f01c83d8e331dfa7e0642eef83365e6" translate="yes" xml:space="preserve">
          <source>Highlight the minimum by shading the background.</source>
          <target state="translated">배경을 음영 처리하여 최소값을 강조 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="28572094b6f31e2425178183c31a01aadfbfa89f" translate="yes" xml:space="preserve">
          <source>Hint to the hashtable sizer.</source>
          <target state="translated">해시 테이블 사이 저에 힌트</target>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="0535ab5fb89daffb4f49da30bceb3bd47fb53e02" translate="yes" xml:space="preserve">
          <source>Histogramming</source>
          <target state="translated">Histogramming</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="63bf65c682511a4e911a035e53ebaec3bd640815" translate="yes" xml:space="preserve">
          <source>Histograms can be drawn by using the &lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt;&lt;code&gt;DataFrame.plot.hist()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt;&lt;code&gt;Series.plot.hist()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">히스토그램은 &lt;a href=&quot;../reference/api/pandas.dataframe.plot.hist#pandas.DataFrame.plot.hist&quot;&gt; &lt;code&gt;DataFrame.plot.hist()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.series.plot.hist#pandas.Series.plot.hist&quot;&gt; &lt;code&gt;Series.plot.hist()&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하여 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27f0f11e6d450b6c48a57c7b24ced4711f75593d" translate="yes" xml:space="preserve">
          <source>Holiday calendars can be used to provide the list of holidays. See the &lt;a href=&quot;#timeseries-holiday&quot;&gt;holiday calendar&lt;/a&gt; section for more information.</source>
          <target state="translated">공휴일 캘린더를 사용하여 공휴일 목록을 제공 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#timeseries-holiday&quot;&gt;공휴일 캘린더&lt;/a&gt; 섹션을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="515694a72054239ce456c9d00c296205caabf8e9" translate="yes" xml:space="preserve">
          <source>Holidays / holiday calendars</source>
          <target state="translated">공휴일 / 공휴일 캘린더</target>
        </trans-unit>
        <trans-unit id="616d8701b286696dac56ea5e0564f7f0664ba1a3" translate="yes" xml:space="preserve">
          <source>Holidays and calendars provide a simple way to define holiday rules to be used with &lt;code&gt;CustomBusinessDay&lt;/code&gt; or in other analysis that requires a predefined set of holidays. The &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; class provides all the necessary methods to return a list of holidays and only &lt;code&gt;rules&lt;/code&gt; need to be defined in a specific holiday calendar class. Furthermore, the &lt;code&gt;start_date&lt;/code&gt; and &lt;code&gt;end_date&lt;/code&gt; class attributes determine over what date range holidays are generated. These should be overwritten on the &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; class to have the range apply to all calendar subclasses. &lt;code&gt;USFederalHolidayCalendar&lt;/code&gt; is the only calendar that exists and primarily serves as an example for developing other calendars.</source>
          <target state="translated">공휴일 및 달력은 &lt;code&gt;CustomBusinessDay&lt;/code&gt; 또는 미리 정의 된 공휴일 집합이 필요한 기타 분석에서 사용할 공휴일 규칙을 정의하는 간단한 방법을 제공합니다 . &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; 의 클래스는 휴일의 목록을 반환하는 데 필요한 모든 방법을 제공에만 &lt;code&gt;rules&lt;/code&gt; 특정 휴일 달력 클래스에 정의 할 필요가. 또한 &lt;code&gt;start_date&lt;/code&gt; 및 &lt;code&gt;end_date&lt;/code&gt; 클래스 속성은 휴일이 생성되는 날짜 범위를 결정합니다. 범위가 모든 달력 하위 클래스에 적용되도록 하려면 &lt;code&gt;AbstractHolidayCalendar&lt;/code&gt; 클래스에서 이를 덮어 써야합니다 . &lt;code&gt;USFederalHolidayCalendar&lt;/code&gt; 존재하는 유일한 달력이며 주로 다른 달력을 개발하기위한 예제로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9d332c80b88cbc5ba41e638f5ce24c1e73743a" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical error bars can be supplied to the &lt;code&gt;xerr&lt;/code&gt; and &lt;code&gt;yerr&lt;/code&gt; keyword arguments to &lt;a href=&quot;../reference/api/pandas.dataframe.plot#pandas.DataFrame.plot&quot;&gt;&lt;code&gt;plot()&lt;/code&gt;&lt;/a&gt;. The error values can be specified using a variety of formats:</source>
          <target state="translated">가로 및 세로 오차 막대는 &lt;a href=&quot;../reference/api/pandas.dataframe.plot#pandas.DataFrame.plot&quot;&gt; &lt;code&gt;plot()&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;code&gt;xerr&lt;/code&gt; 및 &lt;code&gt;yerr&lt;/code&gt; 키워드 인수에 제공 될 수 있습니다 . 다양한 형식을 사용하여 오류 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="798d45d4f1a4e0cb111c2c75f0fa48db95a41bbc" translate="yes" xml:space="preserve">
          <source>Horizontal bar plot.</source>
          <target state="translated">가로 막대 플롯.</target>
        </trans-unit>
        <trans-unit id="c37cf838b0b980da78f19ac1366359fb80951f62" translate="yes" xml:space="preserve">
          <source>Hour</source>
          <target state="translated">Hour</target>
        </trans-unit>
        <trans-unit id="425c6644ee61c9a230fcbf65d7494b117f494021" translate="yes" xml:space="preserve">
          <source>Hour (12-hour clock) as a decimal number [01,12].</source>
          <target state="translated">십진수로 표시되는 시간 (12 시간제) [01,12].</target>
        </trans-unit>
        <trans-unit id="fb9eb08a7d5aa5786e2bc10ef029f16e805c8a84" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) as a decimal number [00,23].</source>
          <target state="translated">십진수로 된 시간 (24 시간제) [00,23].</target>
        </trans-unit>
        <trans-unit id="03a69bfc0ec29e28cb09c485868505a4c11f3bca" translate="yes" xml:space="preserve">
          <source>Hour value of the period.</source>
          <target state="translated">기간의 시간 값입니다.</target>
        </trans-unit>
        <trans-unit id="53ac924a77d55d00e79592ebf70cc9ed9ee316d5" translate="yes" xml:space="preserve">
          <source>Hour.apply()</source>
          <target state="translated">Hour.apply()</target>
        </trans-unit>
        <trans-unit id="35bdb37831e82b82f92a864b1de84dce868b6263" translate="yes" xml:space="preserve">
          <source>Hour.apply_index()</source>
          <target state="translated">Hour.apply_index()</target>
        </trans-unit>
        <trans-unit id="1f7e570565de4188139ce1f495f0a4a767e428ee" translate="yes" xml:space="preserve">
          <source>Hour.base</source>
          <target state="translated">Hour.base</target>
        </trans-unit>
        <trans-unit id="8e585e3df04c4eec4de525fdca327fd2ba65e241" translate="yes" xml:space="preserve">
          <source>Hour.copy()</source>
          <target state="translated">Hour.copy()</target>
        </trans-unit>
        <trans-unit id="0b44862c33cc1a129b4117e0a1d4417ca66ca4c7" translate="yes" xml:space="preserve">
          <source>Hour.delta</source>
          <target state="translated">Hour.delta</target>
        </trans-unit>
        <trans-unit id="74c19e92ad107036eb344727623e1624200ae97c" translate="yes" xml:space="preserve">
          <source>Hour.freqstr</source>
          <target state="translated">Hour.freqstr</target>
        </trans-unit>
        <trans-unit id="691d0fbccd1823943092dfae8501b40efd199b1b" translate="yes" xml:space="preserve">
          <source>Hour.isAnchored()</source>
          <target state="translated">Hour.isAnchored()</target>
        </trans-unit>
        <trans-unit id="acea6d808fb787e2e979f0a7998c4c3df4d8fdd5" translate="yes" xml:space="preserve">
          <source>Hour.kwds</source>
          <target state="translated">Hour.kwds</target>
        </trans-unit>
        <trans-unit id="151d0e20cbd270cc7fb43e6f25553f0878a45a70" translate="yes" xml:space="preserve">
          <source>Hour.name</source>
          <target state="translated">Hour.name</target>
        </trans-unit>
        <trans-unit id="58d34fac168d93b38466a203549a3caebb9ae352" translate="yes" xml:space="preserve">
          <source>Hour.nanos</source>
          <target state="translated">Hour.nanos</target>
        </trans-unit>
        <trans-unit id="0105783696e6fdc9e5a7987c9699f50e93cff23e" translate="yes" xml:space="preserve">
          <source>Hour.normalize</source>
          <target state="translated">Hour.normalize</target>
        </trans-unit>
        <trans-unit id="739f2fb0b17377837145e941edbf36e33fdcc828" translate="yes" xml:space="preserve">
          <source>Hour.onOffset()</source>
          <target state="translated">Hour.onOffset()</target>
        </trans-unit>
        <trans-unit id="ef471ab00360fbd9ee97bd21ccfb08b1d39e4f2e" translate="yes" xml:space="preserve">
          <source>Hour.rollback()</source>
          <target state="translated">Hour.rollback()</target>
        </trans-unit>
        <trans-unit id="5f509dd688e4275ebcb58828f5df610b3c98968c" translate="yes" xml:space="preserve">
          <source>Hour.rollforward()</source>
          <target state="translated">Hour.rollforward()</target>
        </trans-unit>
        <trans-unit id="ab0f7f4231f94b918d559de375fb69ef0eca4951" translate="yes" xml:space="preserve">
          <source>Hour.rule_code</source>
          <target state="translated">Hour.rule_code</target>
        </trans-unit>
        <trans-unit id="2a3dfca25bfb019117c3cc536806011800c9abd7" translate="yes" xml:space="preserve">
          <source>Hours: &amp;lsquo;H&amp;rsquo;</source>
          <target state="translated">시간 : 'H'</target>
        </trans-unit>
        <trans-unit id="9242a5cf1124466c24859cdaf585816d21ba9d1b" translate="yes" xml:space="preserve">
          <source>Hover to highlight.</source>
          <target state="translated">강조 표시하려면 마우스를 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="a49764fca3c1e25986ac974c8d8c40659e3823f6" translate="yes" xml:space="preserve">
          <source>Hover to magnify</source>
          <target state="translated">마우스로 확대</target>
        </trans-unit>
        <trans-unit id="283b111b642f8a04124a8e358013df41d1234238" translate="yes" xml:space="preserve">
          <source>How to align the bars with the cells.</source>
          <target state="translated">막대를 셀에 맞추는 방법</target>
        </trans-unit>
        <trans-unit id="db6e9be9081ca92d77c03fe26dd79592e8be869b" translate="yes" xml:space="preserve">
          <source>How to behave if the table already exists.</source>
          <target state="translated">테이블이 이미 존재하는 경우 동작 방법</target>
        </trans-unit>
        <trans-unit id="5d737c62270b3a47acff25bef86300e61500eac8" translate="yes" xml:space="preserve">
          <source>How to build the pandas documentation</source>
          <target state="translated">팬더 문서를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="c0e83970905861dcc3c10030c88fffa02a03906c" translate="yes" xml:space="preserve">
          <source>How to find the values that will be replaced.</source>
          <target state="translated">대체 할 값을 찾는 방법</target>
        </trans-unit>
        <trans-unit id="ef1fa5b11035bf1f8ae6577f9a0c105ba2e2b145" translate="yes" xml:space="preserve">
          <source>How to handle NAs before computing percent changes.</source>
          <target state="translated">퍼센트 변경을 계산하기 전에 NA를 처리하는 방법.</target>
        </trans-unit>
        <trans-unit id="a27a42eb28b5e559a07433ac0d391873cf2dd91a" translate="yes" xml:space="preserve">
          <source>How to handle indexes on other axis (or axes).</source>
          <target state="translated">다른 축 (또는 축)에서 인덱스를 처리하는 방법.</target>
        </trans-unit>
        <trans-unit id="02c8e011c1a6a4bdf7e57bb059c9a9c96c0cbcdb" translate="yes" xml:space="preserve">
          <source>How to handle negative values in</source>
          <target state="translated">음수 값을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="f8266c50c74c6156dfafa87c97ec3af24485274c" translate="yes" xml:space="preserve">
          <source>How to handle negative values in &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">마이너스 값을 처리하는 방법 &lt;code&gt;indices&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a517432712fa10fd0ef073277ee02f0df0c11e06" translate="yes" xml:space="preserve">
          <source>How to handle non-NA values for overlapping keys:</source>
          <target state="translated">겹치는 키에 대해 비 NA 값을 처리하는 방법 :</target>
        </trans-unit>
        <trans-unit id="f43e18e889c91ca8e330be78e88e8778e041728c" translate="yes" xml:space="preserve">
          <source>How to handle the operation of the two objects.</source>
          <target state="translated">두 개체의 작동을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="4216b24f1023ffed1547bba13339a0671760163f" translate="yes" xml:space="preserve">
          <source>How to justify the column labels. If None uses the option from the print configuration (controlled by set_option), &amp;lsquo;right&amp;rsquo; out of the box. Valid values are</source>
          <target state="translated">열 레이블을 정당화하는 방법. 없음이 인쇄 구성의 옵션 (set_option으로 제어)을 사용하는 경우 상자에서 '오른쪽'. 유효한 값은</target>
        </trans-unit>
        <trans-unit id="02811e68280934a244076bbee273988252e2decb" translate="yes" xml:space="preserve">
          <source>How to rank NaN values:</source>
          <target state="translated">NaN 값 순위를 매기는 방법 :</target>
        </trans-unit>
        <trans-unit id="c81e5ee5f61ddfa3a78d5f341fad4ecdb5dbf234" translate="yes" xml:space="preserve">
          <source>How to rank the group of records that have the same value (i.e. ties):</source>
          <target state="translated">동일한 값 (예 : 동점)을 가진 레코드 그룹의 순위를 매기는 방법 :</target>
        </trans-unit>
        <trans-unit id="996d750728af9280fc018cea501ee9ee8bf33d71" translate="yes" xml:space="preserve">
          <source>How to represent null values as str. Not allowed with append=True.</source>
          <target state="translated">null 값을 str로 표현하는 방법. append = True에는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c6355c14b385846a9957518e259e8b8d6d85c59" translate="yes" xml:space="preserve">
          <source>How to set the index and join</source>
          <target state="translated">인덱스 설정 및 조인 방법</target>
        </trans-unit>
        <trans-unit id="471a170bf31c512c1a494dec35601a8a64ba6702" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; can directly also support the time component as data itself.</source>
          <target state="translated">그러나 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 은 시간 구성 요소를 데이터 자체로 직접 지원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c0b091654e5dfa38cb05b8014dccae44bda9da" translate="yes" xml:space="preserve">
          <source>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="translated">그러나 많은 응용 분야의 경우 추정 공분산 행렬이 양의 반정의 값을 보장하지 않기 때문에이 추정치는 허용되지 않을 수 있습니다. 이는 1보다 큰 절대 값 및 / 또는 비가역 공분산 행렬을 갖는 상관을 추정 할 수있다. 자세한 내용 &lt;a href=&quot;http://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;은 공분산 행렬 추정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f30dd2978cd54ab19f166292391c83028de9bc4" translate="yes" xml:space="preserve">
          <source>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;Estimation of covariance matrices&lt;/a&gt; for more details.</source>
          <target state="translated">그러나 많은 응용 프로그램의 경우 추정 공분산 행렬이 양의 반 정확성이 보장되지 않기 때문에이 추정이 허용되지 않을 수 있습니다. 이것은 1보다 큰 절대 값 및 / 또는 비가 역적 공분산 행렬을 갖는 상관 관계를 추정 할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_matrices&quot;&gt;은 공분산 행렬 추정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cea8c38f3625a97d53eaf6bdfdf954504f10d29b" translate="yes" xml:space="preserve">
          <source>However, if at least one of the two is absent &lt;em&gt;and&lt;/em&gt; the index is not sorted, an error will be raised (since doing otherwise would be computationally expensive, as well as potentially ambiguous for mixed type indexes). For instance, in the above example, &lt;code&gt;s.loc[1:6]&lt;/code&gt; would raise &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="translated">둘 중 적어도 하나가없는 경우, &lt;em&gt;그리고&lt;/em&gt; 인덱스가 정렬되지 않습니다 (특별히 다른 것이 혼합 된 유형의 인덱스에 대한 계산 비용뿐만 아니라 잠재적으로 모호한 것 때문에) 오류가 발생합니다. 예를 들어, 위의 예에서 &lt;code&gt;s.loc[1:6]&lt;/code&gt; 은 &lt;code&gt;KeyError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="97abfa2058c4b2b46bd77047bcea7c55ad0f19cb" translate="yes" xml:space="preserve">
          <source>However, if the same element in both dataframes is None, that None is preserved</source>
          <target state="translated">그러나 두 데이터 프레임에서 동일한 요소가 None이면 None이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3a03dd4a4919d77e193bdd2d0336e4f5f7cdca3c" translate="yes" xml:space="preserve">
          <source>However, if the string is treated as an exact match, the selection in &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s &lt;code&gt;[]&lt;/code&gt; will be column-wise and not row-wise, see &lt;a href=&quot;indexing#indexing-basics&quot;&gt;Indexing Basics&lt;/a&gt;. For example &lt;code&gt;dft_minute['2011-12-31 23:59']&lt;/code&gt; will raise &lt;code&gt;KeyError&lt;/code&gt; as &lt;code&gt;'2012-12-31 23:59'&lt;/code&gt; has the same resolution as the index and there is no column with such name:</source>
          <target state="translated">그러나 문자열이 정확히 일치하는 것으로 취급되는 경우 &lt;code&gt;DataFrame&lt;/code&gt; 의 &lt;code&gt;[]&lt;/code&gt; 선택 항목은 행 방식이 아니라 열 방식이 됩니다. &lt;a href=&quot;indexing#indexing-basics&quot;&gt;색인 생성 기본 사항을&lt;/a&gt; 참조하세요 . 예를 들어 &lt;code&gt;dft_minute['2011-12-31 23:59']&lt;/code&gt; 올릴 &lt;code&gt;KeyError&lt;/code&gt; 를를 로 &lt;code&gt;'2012-12-31 23:59'&lt;/code&gt; 인덱스와 동일한 해상도를 가지며, 같은 이름을 가진 열이 없다 :</target>
        </trans-unit>
        <trans-unit id="fa5d15a357f215082d304b7f83dbf3174f57094b" translate="yes" xml:space="preserve">
          <source>However, if you have bs4 and html5lib installed and pass &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;['lxml',
'bs4']&lt;/code&gt; then the parse will most likely succeed. Note that &lt;em&gt;as soon as a parse succeeds, the function will return&lt;/em&gt;.</source>
          <target state="translated">그러나 bs4 및 html5lib가 설치되어 있고 &lt;code&gt;None&lt;/code&gt; 또는 &lt;code&gt;['lxml', 'bs4']&lt;/code&gt; 를 전달하면 구문 분석이 성공할 가능성이 높습니다. 참고 &lt;em&gt;즉시 구문 분석이 성공으로, 함수가 반환됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4ba5f87176c631128dde92954aea07df8626e674" translate="yes" xml:space="preserve">
          <source>However, if you only had &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt;, determining the next element in the index can be somewhat complicated. For example, the following does not work:</source>
          <target state="translated">그러나 &lt;code&gt;c&lt;/code&gt; 와 &lt;code&gt;e&lt;/code&gt; 만 있으면 인덱스의 다음 요소를 결정하는 것이 다소 복잡 할 수 있습니다. 예를 들어 다음은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f99ae8e704303cfb147ca20954e7c5d706c860d9" translate="yes" xml:space="preserve">
          <source>However, if you want an actual NumPy &lt;code&gt;datetime64[ns]&lt;/code&gt; array (with the values converted to UTC) instead of an array of objects, you can specify the &lt;code&gt;dtype&lt;/code&gt; argument:</source>
          <target state="translated">그러나 객체 배열 대신 실제 NumPy &lt;code&gt;datetime64[ns]&lt;/code&gt; 배열 (값이 UTC로 변환 됨)을 원하는 경우 &lt;code&gt;dtype&lt;/code&gt; 인수를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8586709902eda78307d43fe1d0d6e66bde6ac09" translate="yes" xml:space="preserve">
          <source>However, in many cases it is more natural to associate things like change variables with a time span instead. The span represented by &lt;code&gt;Period&lt;/code&gt; can be specified explicitly, or inferred from datetime string format.</source>
          <target state="translated">그러나 대부분의 경우 변경 변수와 같은 것을 시간 범위와 연결하는 것이 더 자연 스럽습니다. &lt;code&gt;Period&lt;/code&gt; 로 표시되는 범위는 명시 적으로 지정하거나 datetime 문자열 형식에서 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="742d8f13359fd0f11624a3ccb6310e89fb9120cd" translate="yes" xml:space="preserve">
          <source>However, instantiating StringArrays directly with non-strings will raise an error.</source>
          <target state="translated">그러나 문자열이 아닌 문자열로 직접 StringArray를 인스턴스화하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d16b5b78eb22ffbe381a9afe057b0f7ef78e76bb" translate="yes" xml:space="preserve">
          <source>However, it comes with it a couple of trade-offs which I most certainly have not ignored.</source>
          <target state="translated">그러나 그것은 내가 가장 확실히 무시하지 않은 몇 가지 절충안과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9268bff9bf083e3d79e17753e03c59437d23b40c" translate="yes" xml:space="preserve">
          <source>However, setting this option incorrectly for your terminal will cause these characters to be aligned incorrectly:</source>
          <target state="translated">그러나 터미널에 대해이 옵션을 잘못 설정하면 다음 문자가 잘못 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="81f0e71582f79bc80ae9961177bfc8e3b8868102" translate="yes" xml:space="preserve">
          <source>However, their presence is indicated in the</source>
          <target state="translated">그러나 그들의 존재는</target>
        </trans-unit>
        <trans-unit id="069df0e9a71bb80b7b5eae23852a6a27ea3af22b" translate="yes" xml:space="preserve">
          <source>However, these can be filled in using &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt;&lt;code&gt;fillna()&lt;/code&gt;&lt;/a&gt; and it will work fine:</source>
          <target state="translated">그러나 &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt; &lt;code&gt;fillna()&lt;/code&gt; &lt;/a&gt; 를 사용하여 채울 수 있으며 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c113642dd4aea7e48ebcf42a5463be4a78e7eb62" translate="yes" xml:space="preserve">
          <source>However, this would &lt;em&gt;still&lt;/em&gt; raise if your resulting index is duplicated.</source>
          <target state="translated">그러나 결과 색인이 중복되면 &lt;em&gt;여전히&lt;/em&gt; 증가합니다.</target>
        </trans-unit>
        <trans-unit id="3c40de3c7cecbc0d644bc9d73ad07fe90fe31ba6" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;to_string&lt;/code&gt; will return a string representation of the DataFrame in tabular form, though it won&amp;rsquo;t always fit the console width:</source>
          <target state="translated">그러나 &lt;code&gt;to_string&lt;/code&gt; 을 사용하면 DataFrame 의 문자열 표현이 테이블 형식으로 반환되지만 항상 콘솔 너비에 맞지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba7929059d6edf0d7eddc551cc797b90990c10c2" translate="yes" xml:space="preserve">
          <source>However, when an axis is integer based, ONLY label based access and not positional access is supported. Thus, in such cases, it&amp;rsquo;s usually better to be explicit and use &lt;code&gt;.iloc&lt;/code&gt; or &lt;code&gt;.loc&lt;/code&gt;.</source>
          <target state="translated">그러나 축이 정수 기반 인 경우 위치 기반 액세스가 아닌 레이블 기반 액세스 만 지원됩니다. 따라서 이러한 경우 일반적으로 명시 적이며 &lt;code&gt;.iloc&lt;/code&gt; 또는 &lt;code&gt;.loc&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bffc9ca5ad36fbad3b3a0f25c38eeb95a3771bef" translate="yes" xml:space="preserve">
          <source>However, you can do (notice the comment that needs to be added)</source>
          <target state="translated">그러나 할 수 있습니다 (추가해야 할 주석에 유의하십시오)</target>
        </trans-unit>
        <trans-unit id="f8ac6f61c1aa59daf66de62601615682e1049435" translate="yes" xml:space="preserve">
          <source>Hypothesis is a library for property-based testing. Instead of explicitly parametrizing a test, you can describe &lt;em&gt;all&lt;/em&gt; valid inputs and let Hypothesis try to find a failing input. Even better, no matter how many random examples it tries, Hypothesis always reports a single minimal counterexample to your assertions - often an example that you would never have thought to test.</source>
          <target state="translated">가설은 속성 기반 테스트를위한 라이브러리입니다. 테스트를 명시 적으로 매개 변수화하는 대신 &lt;em&gt;모든&lt;/em&gt; 유효한 입력을 설명 하고 가설이 실패한 입력을 찾으려고 시도 할 수 있습니다. 더 좋은 방법은 시도하는 임의의 예제 수에 관계없이 가설에 항상 하나의 최소 반례를보고하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b4059c9b5820041f826f688b6e57c7201e42d5f" translate="yes" xml:space="preserve">
          <source>IDE</source>
          <target state="translated">IDE</target>
        </trans-unit>
        <trans-unit id="f8fd4493c0520c4dc8242f0098e35eb107cc179d" translate="yes" xml:space="preserve">
          <source>IEX</source>
          <target state="translated">IEX</target>
        </trans-unit>
        <trans-unit id="ca6691485e94f29b172edd1428309ac2c47100cc" translate="yes" xml:space="preserve">
          <source>IO tools</source>
          <target state="translated">IO 도구</target>
        </trans-unit>
        <trans-unit id="a462e1e327253efa119d5a0e2286d8d8d84ef77d" translate="yes" xml:space="preserve">
          <source>IO tools (text, CSV, HDF5, &amp;hellip;)</source>
          <target state="translated">IO 도구 (텍스트, CSV, HDF5 등)</target>
        </trans-unit>
        <trans-unit id="571ae8f12e56e6a82f24791cda171d0b8fd05d68" translate="yes" xml:space="preserve">
          <source>IPython</source>
          <target state="translated">IPython</target>
        </trans-unit>
        <trans-unit id="e81acf4cb4ac2f9dfa0516461c3ce5a6c992dff8" translate="yes" xml:space="preserve">
          <source>IPython Vega</source>
          <target state="translated">IPython 베가</target>
        </trans-unit>
        <trans-unit id="991bf056dd16995f47856efd54d6471c32029dfb" translate="yes" xml:space="preserve">
          <source>IPython is an interactive command shell and distributed computing environment. IPython tab completion works with Pandas methods and also attributes like DataFrame columns.</source>
          <target state="translated">IPython은 대화식 명령 셸 및 분산 컴퓨팅 환경입니다. IPython 탭 완성은 Pandas 메소드 및 DataFrame 열과 같은 속성과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ce0c669ac9952944e64534615185377818bf4dd" translate="yes" xml:space="preserve">
          <source>IX indexer is deprecated</source>
          <target state="translated">IX 인덱서가 더 이상 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="837958207e911e1a986e234409c61e629d2c52b7" translate="yes" xml:space="preserve">
          <source>Ideally, the attributes in &lt;code&gt;_metadata&lt;/code&gt; will match the parameters to your &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; (if any). If any of the attributes in &lt;code&gt;_metadata&lt;/code&gt; don&amp;rsquo;t implement the standard &lt;code&gt;__eq__&lt;/code&gt; or &lt;code&gt;__hash__&lt;/code&gt;, the default implementations here will not work.</source>
          <target state="translated">이상적으로 &lt;code&gt;_metadata&lt;/code&gt; 의 속성 은 매개 변수를 &lt;code&gt;ExtensionDtype.__init__&lt;/code&gt; (있는 경우) 와 일치시킵니다 . &lt;code&gt;_metadata&lt;/code&gt; 의 속성 중 하나라도 표준 &lt;code&gt;__eq__&lt;/code&gt; 또는 &lt;code&gt;__hash__&lt;/code&gt; 를 구현하지 않으면 기본 구현이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca9b496aede42137d37ed26eee610c0663585a70" translate="yes" xml:space="preserve">
          <source>Identical method.</source>
          <target state="translated">동일한 방법.</target>
        </trans-unit>
        <trans-unit id="ed000ba923e4837b5f64d072ac83b369b8bbc564" translate="yes" xml:space="preserve">
          <source>Identifier for the group in the store.</source>
          <target state="translated">상점에서 그룹의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="cc70bdac5409cb9636fe71b4171d38f1636e5344" translate="yes" xml:space="preserve">
          <source>Identifier of column that should be used as index of the DataFrame.</source>
          <target state="translated">DataFrame의 인덱스로 사용해야하는 열의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="d1693517b90bc1546304cd1fb892ae941d720a6b" translate="yes" xml:space="preserve">
          <source>Identifies data (i.e. provides &lt;em&gt;metadata&lt;/em&gt;) using known indicators, important for analysis, visualization, and interactive console display.</source>
          <target state="translated">분석, 시각화 및 대화식 콘솔 디스플레이에 중요한 알려진 지표를 사용하여 데이터를 식별합니다 (즉, &lt;em&gt;메타 데이터&lt;/em&gt; 제공 ).</target>
        </trans-unit>
        <trans-unit id="7b2b315db6cb8b61d91ac6d610561c15d151098e" translate="yes" xml:space="preserve">
          <source>Identity method.</source>
          <target state="translated">신원 방법.</target>
        </trans-unit>
        <trans-unit id="ec04bd386a626dbd6df1f3954dfd578f058ce091" translate="yes" xml:space="preserve">
          <source>Idioms</source>
          <target state="translated">Idioms</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="f6003bd8eabce8b7ff3690312b777fcfeb97f5b7" translate="yes" xml:space="preserve">
          <source>If #1 fails, &lt;code&gt;date_parser&lt;/code&gt; is called with all the columns concatenated row-wise into a single array (e.g., &lt;code&gt;date_parser(['2013 1', '2013 2'])&lt;/code&gt;).</source>
          <target state="translated"># 1이 실패하면 &lt;code&gt;date_parser&lt;/code&gt; 가 호출되고 모든 열이 행 방향으로 단일 배열로 연결됩니다 (예 : &lt;code&gt;date_parser(['2013 1', '2013 2'])&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e8cae4bf30e27a1848901c64267dcac0e2ff75cd" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaN</source>
          <target state="translated">'강제'인 경우 유효하지 않은 구문 분석이 NaN으로 설정됩니다</target>
        </trans-unit>
        <trans-unit id="16bba9351b97f05aabf6f317cfe45f93cda01afb" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaN.</source>
          <target state="translated">'강제'인 경우 잘못된 구문 분석이 NaN으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6702a592aaa4545f91194718e2267ecc33a26886" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT</source>
          <target state="translated">'강제'인 경우 유효하지 않은 구문 분석이 NaT로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e327c3620244d73e8137e7777edd3944c79b840d" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;coerce&amp;rsquo;, then invalid parsing will be set as NaT.</source>
          <target state="translated">'강제'인 경우 유효하지 않은 구문 분석이 NaT로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8cc6e9c326cf3572f065a17f177306c8775d049" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;first&amp;rsquo; puts NaNs at the beginning, &amp;lsquo;last&amp;rsquo; puts NaNs at the end. Not implemented for MultiIndex.</source>
          <target state="translated">'first'가 NaN을 처음에 놓으면 'last'는 NaN을 끝에 놓습니다. MultiIndex에는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="85a05c0ef3ed46dcadbc8af33ffe40bbea47052f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NA values, without passing them to the mapping correspondence.</source>
          <target state="translated">'무시'인 경우 NA 값을 매핑 통신에 전달하지 않고 전파합니다.</target>
        </trans-unit>
        <trans-unit id="1287f6267e3f7063b36811426aebcc8a1b393699" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NaN values, without passing them to func.</source>
          <target state="translated">'무시'인 경우 NaN 값을 func에 전달하지 않고 전파하십시오.</target>
        </trans-unit>
        <trans-unit id="66b7f9b117c829902f069c8250ee1dcbed71f06f" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, propagate NaN values, without passing them to the mapping correspondence.</source>
          <target state="translated">'무시'인 경우 NaN 값을 매핑 대응으로 전달하지 않고 전파합니다.</target>
        </trans-unit>
        <trans-unit id="22afdde341e33ad8a79ea55dc5be1cbcc7e96d01" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and existing labels are dropped.</source>
          <target state="translated">'무시'이면 오류를 억제하고 기존 레이블을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="d430013a0236928d816f5189528441973b498e09" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, suppress error and only existing labels are dropped.</source>
          <target state="translated">'무시'인 경우 오류를 억제하고 기존 레이블 만 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="55ef49bb1d9190e26977a4e97151c2887af3928e" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input</source>
          <target state="translated">'무시'인 경우 유효하지 않은 구문 분석은 입력을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd3b02bde7d23065b5493af3d78edab92d8661c6" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;ignore&amp;rsquo;, then invalid parsing will return the input.</source>
          <target state="translated">'무시'인 경우 유효하지 않은 구문 분석은 입력을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1dc7b9597b7436e84a9fd5cd7c267d98ceeb4c95" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;infer&amp;rsquo; and &amp;lsquo;path_or_url&amp;rsquo; is path-like, then detect compression from the following extensions: &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;.xz&amp;rsquo; (otherwise no compression) If &amp;lsquo;infer&amp;rsquo; and &amp;lsquo;path_or_url&amp;rsquo; is not path-like, then use None (= no decompression).</source>
          <target state="translated">'infer'및 'path_or_url'이 경로와 유사한 경우 '.gz', '.bz2', '.zip'또는 '.xz'(그렇지 않으면 압축 없음) 확장자에서 압축을 감지합니다. 'path_or_url'은 경로와 유사하지 않은 경우 None (= 압축 해제 없음)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ff34e86f499a6da13800cd52b6acf8d0206bc8b4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;julian&amp;rsquo;, unit must be &amp;lsquo;D&amp;rsquo;, and origin is set to beginning of Julian Calendar. Julian day number 0 is assigned to the day starting at noon on January 1, 4713 BC.</source>
          <target state="translated">'julian'인 경우 단위는 'D'여야하며 원점은 Julian Calendar의 시작으로 설정됩니다. Julian 일 번호 0은 BC 4713 년 1 월 1 일 정오에 시작하는 날에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="b2092bae9f0ce3fc3810aa44034eb94fcaaf590d" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;label&amp;rsquo; does not exist in DataFrame.</source>
          <target state="translated">DataFrame에 'label'이없는 경우.</target>
        </trans-unit>
        <trans-unit id="b20de98cc6d0b1c8d0f7085d3b7e17aedbf78e9b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of</source>
          <target state="translated">'left'이면 처음으로 찾은 적절한 위치의 색인이 제공됩니다. '올바른'경우 마지막 색인을 반환합니다. 적합한 인덱스가 없으면 0 또는 N을 반환합니다 (여기서 N은</target>
        </trans-unit>
        <trans-unit id="3b55e654d50b8ad774057f6ba47ce5789398ba97" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;self&lt;/code&gt;).</source>
          <target state="translated">'왼쪽'이면 발견 된 첫 번째 적합한 위치의 색인이 제공됩니다. 'right'이면 마지막 인덱스를 반환하십시오. 적합한 색인이 없으면 0 또는 N을 리턴하십시오 (여기서 N은 &lt;code&gt;self&lt;/code&gt; 의 길이 임 ).</target>
        </trans-unit>
        <trans-unit id="14c9113bf406806dfc7fa4d776177c7889c78c60" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;limit&amp;rsquo; is not specified:</source>
          <target state="translated">'제한'이 지정되지 않은 경우 :</target>
        </trans-unit>
        <trans-unit id="2cc24626be3d05b2f4b9cd06416847f88949fd27" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;backfill&amp;rsquo; or &amp;lsquo;bfill&amp;rsquo;, &amp;lsquo;limit_direction&amp;rsquo; must be &amp;lsquo;backwards&amp;rsquo;.</source>
          <target state="translated">'method'가 'backfill'또는 'bfill'인 경우 'limit_direction'은 'backwards'여야합니다.</target>
        </trans-unit>
        <trans-unit id="198a8a08aee1bff5568a3c9bfad2801313ba81bb" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;backfill&amp;rsquo; or &amp;lsquo;bfill&amp;rsquo;, the default is &amp;lsquo;backward&amp;rsquo;</source>
          <target state="translated">'method'가 'backfill'또는 'bfill'인 경우 기본값은 'backward'입니다.</target>
        </trans-unit>
        <trans-unit id="970a0920f7495cbfcd494a86c1c52c95ec206136" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;method&amp;rsquo; is &amp;lsquo;pad&amp;rsquo; or &amp;lsquo;ffill&amp;rsquo;, &amp;lsquo;limit_direction&amp;rsquo; must be &amp;lsquo;forward&amp;rsquo;.</source>
          <target state="translated">'method'가 'pad'또는 'ffill'인 경우 'limit_direction'은 'forward'여야합니다.</target>
        </trans-unit>
        <trans-unit id="199d3e9cf5e8512896d9d482541e87cadcde8682" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;orient&amp;rsquo; is &amp;lsquo;records&amp;rsquo; write out line delimited json format. Will throw ValueError if incorrect &amp;lsquo;orient&amp;rsquo; since others are not list like.</source>
          <target state="translated">'orient'가 'records'인 경우 행으로 구분 된 json 형식을 작성하십시오. 다른 사람들이 목록에 없기 때문에 잘못된 '동향'인 경우 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="efece3541c7fce3c755b622642e6e00a9f5917b5" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, raise a</source>
          <target state="translated">'레이즈'인 경우</target>
        </trans-unit>
        <trans-unit id="7a715eced952aac9082838419cee8dbd64346a0c" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, raise a &lt;code&gt;KeyError&lt;/code&gt; when a dict-like &lt;code&gt;mapper&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, or &lt;code&gt;columns&lt;/code&gt; contains labels that are not present in the Index being transformed. If &amp;lsquo;ignore&amp;rsquo;, existing keys will be renamed and extra keys will be ignored.</source>
          <target state="translated">' &lt;code&gt;KeyError&lt;/code&gt; ' dict-like &lt;code&gt;mapper&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; 또는 &lt;code&gt;columns&lt;/code&gt; 변환중인 인덱스에없는 레이블이 포함 된 경우 KeyError를 발생 시킵니다. '무시'하면 기존 키의 이름이 바뀌고 추가 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0485157b5ba13ba379ff6892b6733f96842f0855" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception</source>
          <target state="translated">'일어남'이면 유효하지 않은 구문 분석에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="00849af26e0f3b9e37f7a382187cd7e59f774f16" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, then invalid parsing will raise an exception.</source>
          <target state="translated">'일으키면'유효하지 않은 구문 분석은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="4e71c458e98a0c8dc01eef2182556595f5c145b3" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, will raise a ValueError if the DataFrame and</source>
          <target state="translated">'raise'인 경우 DataFrame 및</target>
        </trans-unit>
        <trans-unit id="3839ee4020555f4a90cf6574c343569184832636" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;raise&amp;rsquo;, will raise a ValueError if the DataFrame and &lt;code&gt;other&lt;/code&gt; both contain non-NA data in the same place.</source>
          <target state="translated">'수행'하면 DataFrame과 &lt;code&gt;other&lt;/code&gt; 둘 다 같은 장소에 비 NA 데이터가 포함 된 경우 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3dcbf99c91197fe50065b8c2d1bbfb5fb4697702" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;unix&amp;rsquo; (or POSIX) time; origin is set to 1970-01-01.</source>
          <target state="translated">'유닉스'(또는 POSIX) 시간 인 경우; 원점은 1970-01-01로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d61e029440c96cda1e26ffdb0c5f6446bc64ce" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo; counts are generated for each column. If 1 or &amp;lsquo;columns&amp;rsquo; counts are generated for each &lt;strong&gt;row&lt;/strong&gt;.</source>
          <target state="translated">각 열에 대해 0 또는 '인덱스'수가 생성되는 경우 각 &lt;strong&gt;행&lt;/strong&gt; 에 대해 1 또는 '열'수가 생성되는 경우 .</target>
        </trans-unit>
        <trans-unit id="38c6dad808791fe5af42cd8974e115c8505961be" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo; counts are generated for each column. If 1 or &amp;lsquo;columns&amp;rsquo; counts are generated for each row.</source>
          <target state="translated">각 열에 대해 0 또는 '인덱스'카운트가 생성되는 경우. 각 행에 대해 1 개 또는 '열'개수가 생성되는 경우.</target>
        </trans-unit>
        <trans-unit id="6e7da5c288c9e6258ab4bc7bde9bc7e6455b66f5" translate="yes" xml:space="preserve">
          <source>If 0 or &amp;lsquo;index&amp;rsquo;: apply function to each column. If 1 or &amp;lsquo;columns&amp;rsquo;: apply function to each row.</source>
          <target state="translated">0 또는 'index'인 경우 : 각 열에 함수를 적용하십시오. 1 또는 '열'인 경우 : 각 행에 기능을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ae3f7be53f938183a6a6a7495ab5b0abb73ba73" translate="yes" xml:space="preserve">
          <source>If 1-D array like, a sequence with the same shape as the observations.</source>
          <target state="translated">1 차원 배열이 같은 경우 관측치와 모양이 같은 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="d3d4cb4694f132bb429f38f873d8a3b68e48888e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt; is installed as an optional dependency, the &lt;code&gt;transform&lt;/code&gt; and &lt;code&gt;aggregate&lt;/code&gt; methods support &lt;code&gt;engine='numba'&lt;/code&gt; and &lt;code&gt;engine_kwargs&lt;/code&gt; arguments. The &lt;code&gt;engine_kwargs&lt;/code&gt; argument is a dictionary of keyword arguments that will be passed into the &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#numba.jit&quot;&gt;numba.jit decorator&lt;/a&gt;. These keyword arguments will be applied to the passed function. Currently only &lt;code&gt;nogil&lt;/code&gt;, &lt;code&gt;nopython&lt;/code&gt;, and &lt;code&gt;parallel&lt;/code&gt; are supported, and their default values are set to &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;a href=&quot;https://numba.pydata.org/&quot;&gt;Numba&lt;/a&gt; 가 선택적 종속성으로 설치된 경우 &lt;code&gt;transform&lt;/code&gt; 및 &lt;code&gt;aggregate&lt;/code&gt; 메서드는 &lt;code&gt;engine='numba'&lt;/code&gt; 및 &lt;code&gt;engine_kwargs&lt;/code&gt; 인수를 지원합니다. &lt;code&gt;engine_kwargs&lt;/code&gt; 의 인수는으로 전달되는 키워드 인자의 사전입니다 &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#numba.jit&quot;&gt;numba.jit 데코레이터&lt;/a&gt; . 이러한 키워드 인수는 전달 된 함수에 적용됩니다. 현재 &lt;code&gt;nogil&lt;/code&gt; , &lt;code&gt;nopython&lt;/code&gt; 및 &lt;code&gt;parallel&lt;/code&gt; 만 지원되며 기본값은 각각 &lt;code&gt;False&lt;/code&gt; , &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="e78b0523719ecd8724561c4f3f88618255a6a160" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt;&lt;code&gt;CategoricalDtype&lt;/code&gt;&lt;/a&gt;, cannot be used together with</source>
          <target state="translated">&lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt; &lt;code&gt;CategoricalDtype&lt;/code&gt; &lt;/a&gt; 인 경우 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9100712e07a1a3144bf279ca0131c5328bb20fae" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt;&lt;code&gt;CategoricalDtype&lt;/code&gt;&lt;/a&gt;, cannot be used together with &lt;code&gt;categories&lt;/code&gt; or &lt;code&gt;ordered&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;pandas.categoricaldtype#pandas.CategoricalDtype&quot;&gt; &lt;code&gt;CategoricalDtype&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 없습니다 &lt;code&gt;categories&lt;/code&gt; 또는 &lt;code&gt;ordered&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="957f4921f3fe1f14cc5e0972c2a9f63db875fa60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is specified, specifies values at given coordinates &lt;code&gt;(x[i], y[i])&lt;/code&gt;. These values are accumulated for each hexagonal bin and then reduced according to &lt;code&gt;reduce_C_function&lt;/code&gt;, having as default the NumPy&amp;rsquo;s mean function (&lt;code&gt;numpy.mean()&lt;/code&gt;). (If &lt;code&gt;C&lt;/code&gt; is specified, it must also be a 1-D sequence of the same length as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or a column label.)</source>
          <target state="translated">경우 &lt;code&gt;C&lt;/code&gt; 는 , 주어진 좌표 지정 값 지정되어 &lt;code&gt;(x[i], y[i])&lt;/code&gt; . 이 값은 각 육각형 &lt;code&gt;reduce_C_function&lt;/code&gt; 에 대해 누적 된 다음 기본적으로 NumPy의 평균 함수 ( &lt;code&gt;numpy.mean()&lt;/code&gt; )를 갖는 reduce_C_function 에 따라 줄어 듭니다 . ( &lt;code&gt;C&lt;/code&gt; 가 지정된 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 와 길이가 같은 1 차원 시퀀스 이거나 열 레이블 이어야합니다 .)</target>
        </trans-unit>
        <trans-unit id="6499e3dc9a031482752c69e5eecddd3f70eff0f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, return Series/Index, containing lists of strings.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 인 경우 문자열 목록이 포함 된 Series / Index를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="085b836cec77eb5bb263be486be44249eef786e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the resulting index will not drop any level.</source>
          <target state="translated">경우 &lt;code&gt;False&lt;/code&gt; , 결과 지수는 어떤 수준을 떨어 뜨리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da8ba51c7b0b90045082965fc49ef9200c0d1945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; is one of the accepted values, it always needs to be the last in the list.</source>
          <target state="translated">경우 &lt;code&gt;None&lt;/code&gt; 허용되는 값 중 하나입니다, 항상 목록의 마지막이 될 필요가있다.</target>
        </trans-unit>
        <trans-unit id="4f8282afef3786c655e62035f97e7e04ec1fca5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Period&lt;/code&gt; freq is daily or higher (&lt;code&gt;D&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;), &lt;code&gt;offsets&lt;/code&gt; and &lt;code&gt;timedelta&lt;/code&gt;-like can be added if the result can have the same freq. Otherwise, &lt;code&gt;ValueError&lt;/code&gt; will be raised.</source>
          <target state="translated">&lt;code&gt;Period&lt;/code&gt; 주파수가 매일 이상 이면 ( &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; ), 결과가 동일한 주파수를 가질 수 있으면 &lt;code&gt;offsets&lt;/code&gt; 및 &lt;code&gt;timedelta&lt;/code&gt; 유사를 추가 할 수 있습니다. 그렇지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da2cedf361e06add2c01f64839ff01dfc5bc08b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Period&lt;/code&gt; has other frequencies, only the same &lt;code&gt;offsets&lt;/code&gt; can be added. Otherwise, &lt;code&gt;ValueError&lt;/code&gt; will be raised.</source>
          <target state="translated">경우 &lt;code&gt;Period&lt;/code&gt; 다른 주파수를 가지고 만 같은 &lt;code&gt;offsets&lt;/code&gt; 을 추가 할 수 있습니다. 그렇지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="29422fd31262e0e9fc4f8605659e8b004decc893" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; -&amp;gt; try parsing the index.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 -&amp;gt; 인덱스 구문 분석을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="5d0c1bf5aebde721450027a33154f95136617245" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; 과 parse_dates이 열 활성화되어, 처리 속도를 위해 날짜 형식을 추론하는 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a6363a0cc564b7e07b8b809c7a41ba46945ef3ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt; and parse_dates specifies combining multiple columns then keep the original columns.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; 과 parse_dates 지정 여러 열을 결합 후 원래의 열을 유지한다.</target>
        </trans-unit>
        <trans-unit id="4c1aba1752b18100abe103f9924f71075d0ee20b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, include the dataframe&amp;rsquo;s index(es) in the file output. If &lt;code&gt;False&lt;/code&gt;, they will not be written to the file. If &lt;code&gt;None&lt;/code&gt;, similar to &lt;code&gt;True&lt;/code&gt; the dataframe&amp;rsquo;s index(es) will be saved. However, instead of being saved as values, the RangeIndex will be stored as a range in the metadata so it doesn&amp;rsquo;t require much space and is faster. Other indexes will be included as columns in the file output.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; , 파일 출력에 dataframe의 인덱스 (들)을 포함한다. 경우 &lt;code&gt;False&lt;/code&gt; , 그들은 파일에 기록되지 않습니다. 경우 &lt;code&gt;None&lt;/code&gt; 유사, &lt;code&gt;True&lt;/code&gt; dataframe의 인덱스 (들)은 저장되지 않습니다. 그러나 RangeIndex는 값으로 저장되는 대신 메타 데이터에 범위로 저장되므로 많은 공간이 필요하지 않고 더 빠릅니다. 다른 인덱스는 파일 출력에 열로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d31355248f274c3070a84b13f60346c84b6ae353" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, include the dataframe&amp;rsquo;s index(es) in the file output. If &lt;code&gt;False&lt;/code&gt;, they will not be written to the file. If &lt;code&gt;None&lt;/code&gt;, the behavior depends on the chosen engine.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 파일 출력에 데이터 프레임의 인덱스를 포함시킵니다. &lt;code&gt;False&lt;/code&gt; 인 경우 파일에 기록되지 않습니다. 경우 &lt;code&gt;None&lt;/code&gt; , 동작은 선택한 엔진에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="db9c68e2c0847c2648159936067c9e97bd68d778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, performs operation inplace and returns None.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 작업을 수행하고 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cb94c12a9c4ef4e915d043b0131ab965753c6c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, return DataFrame/MultiIndex expanding dimensionality.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 DataFrame / MultiIndex 확장 차원을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="517a8e80d621d1f11e0a5937c0b56cff33456958" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, skip over blank lines rather than interpreting as NaN values.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; , 오히려 NaN의 값으로 해석보다 빈 줄을 건너.</target>
        </trans-unit>
        <trans-unit id="e6e2f07bf71d2ba4698109742fc9a9a2f3add4c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[1, 2, 3]&lt;/code&gt; -&amp;gt; try parsing columns 1, 2, 3 each as a separate date column.</source>
          <target state="translated">만약 &lt;code&gt;[1, 2, 3]&lt;/code&gt; -&amp;gt; 별도의 날짜 열로서 열 1, 2, 3 각각의 파싱보십시오.</target>
        </trans-unit>
        <trans-unit id="184af077a3aa944d3aa6d28e063d05e84f7b5e9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[[1, 3]]&lt;/code&gt; -&amp;gt; combine columns 1 and 3 and parse as a single date column.</source>
          <target state="translated">경우 &lt;code&gt;[[1, 3]]&lt;/code&gt; -&amp;gt; 단일 날짜 열로서 열 1,3 파싱을 결합한다.</target>
        </trans-unit>
        <trans-unit id="970376fd9f251fcf7442a3e8dc1c7f205bfd8a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; and/or &lt;code&gt;level&lt;/code&gt; are passed as keywords to both &lt;code&gt;Grouper&lt;/code&gt; and &lt;code&gt;groupby&lt;/code&gt;, the values passed to &lt;code&gt;Grouper&lt;/code&gt; take precedence.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 및 / 또는 &lt;code&gt;level&lt;/code&gt; 모두 키워드로 전달되는 &lt;code&gt;Grouper&lt;/code&gt; 및 &lt;code&gt;groupby&lt;/code&gt; , 값이 전달 &lt;code&gt;Grouper&lt;/code&gt; 보다 우선.</target>
        </trans-unit>
        <trans-unit id="937f7d2a44b813e6b8d92c1002659f32d8844922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;complib&lt;/code&gt; is defined as something other than the listed libraries a &lt;code&gt;ValueError&lt;/code&gt; exception is issued.</source>
          <target state="translated">경우 &lt;code&gt;complib&lt;/code&gt; 은 상기 열거 된 라이브러리가 아닌 다른 무언가로 정의된다 &lt;code&gt;ValueError&lt;/code&gt; 예외가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="b5f1537f9831fb3154a33d877feb6f73352a3d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;crosstab&lt;/code&gt; receives only two Series, it will provide a frequency table.</source>
          <target state="translated">경우 &lt;code&gt;crosstab&lt;/code&gt; 두 시리즈를 수신, 그것은 주파수 테이블을 제공 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="db32402bbe8a4f901a9b37cd1cc804bf16b8f6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is a scalar value, an index must be provided. The value will be repeated to match the length of &lt;strong&gt;index&lt;/strong&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 스칼라 값 인덱스가 제공되어야한다. &lt;strong&gt;index&lt;/strong&gt; 의 길이와 일치하도록 값이 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3bd838dfe683144e93c449ff32d03c1dfd018a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is an ndarray, &lt;strong&gt;index&lt;/strong&gt; must be the same length as &lt;strong&gt;data&lt;/strong&gt;. If no index is passed, one will be created having values &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; ndarray이며, &lt;strong&gt;지수는&lt;/strong&gt; 같은 길이해야합니다 &lt;strong&gt;데이터&lt;/strong&gt; . 인덱스가 전달되지 않으면 &lt;code&gt;[0, ..., len(data) - 1]&lt;/code&gt; 값을 갖는 인덱스가 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="256b2ec2109a10c2b922ec284f2aa6d0f4996ee1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dropna&lt;/code&gt; is False, &lt;strong&gt;THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES&lt;/strong&gt;. Remember that entirely &lt;code&gt;np.Nan&lt;/code&gt; rows are not written to the HDFStore, so if you choose to call &lt;code&gt;dropna=False&lt;/code&gt;, some tables may have more rows than others, and therefore &lt;code&gt;select_as_multiple&lt;/code&gt; may not work or it may return unexpected results.</source>
          <target state="translated">경우 &lt;code&gt;dropna&lt;/code&gt; 가 거짓이고, &lt;strong&gt;사용자가 테이블을 동기화 부담입니다&lt;/strong&gt; . 완전히 &lt;code&gt;np.Nan&lt;/code&gt; 행은 HDFStore에 기록되지 않으므로 &lt;code&gt;dropna=False&lt;/code&gt; 를 호출하도록 선택하면 일부 테이블에 다른 테이블보다 많은 행이 있을 수 있으므로 &lt;code&gt;select_as_multiple&lt;/code&gt; 이 작동하지 않거나 예기치 않은 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4efc8cfad113907e0158cf2bc9289ac516eb7f46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;formatter&lt;/code&gt; is None, the default formatter is used.</source>
          <target state="translated">경우 &lt;code&gt;formatter&lt;/code&gt; 없음입니다, 기본 포맷이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9939487b947ef8676c1bc3bbe3735bce7e975089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is a standard Python function, the engine will &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/overview.html&quot;&gt;JIT&lt;/a&gt; the passed function. &lt;code&gt;func&lt;/code&gt; can also be a JITed function in which case the engine will not JIT the function again.</source>
          <target state="translated">경우 &lt;code&gt;func&lt;/code&gt; 표준 파이썬 함수, 엔진이됩니다 &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/overview.html&quot;&gt;JIT&lt;/a&gt; 전달 기능을. &lt;code&gt;func&lt;/code&gt; 는 JIT 기능이 될 수도 있습니다.이 경우 엔진이 기능을 다시 JIT하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ab813b7fd3b3d65ecd4fb06b280ae7968617f53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; have overlapping elements</source>
          <target state="translated">경우 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 요소에 중복</target>
        </trans-unit>
        <trans-unit id="a7da045296675e29f8161fcdf9df7881d520bb33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;join != &amp;lsquo;left&amp;rsquo;&lt;/code&gt; 하면 ! = 'left'</target>
        </trans-unit>
        <trans-unit id="e408e50f4efff0be75273835ecad495f9e1afc4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are not specified, no strings will be parsed as NaN.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; , 그리고 &lt;code&gt;na_values&lt;/code&gt; 가 지정되지 않은 어떤 문자열은 NaN의로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd73a654c84b29616fb9b65fd07e1551ee72e146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are specified, only the NaN values specified &lt;code&gt;na_values&lt;/code&gt; are used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; , 그리고 &lt;code&gt;na_values&lt;/code&gt; 가 지정, 지정 만의 NaN 값 &lt;code&gt;na_values&lt;/code&gt; 는 구문 분석에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a4e153f94488bea1392d12a65c1e2c2599e5594" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are not specified, only the default NaN values are used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; , 그리고 &lt;code&gt;na_values&lt;/code&gt; 이 지정되지 않은, 단지 기본 NaN의 값은 구문 분석에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e25908c5c32fc206359705ce5477202d627c658a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, and &lt;code&gt;na_values&lt;/code&gt; are specified, &lt;code&gt;na_values&lt;/code&gt; is appended to the default NaN values used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; , 그리고 &lt;code&gt;na_values&lt;/code&gt; 가 지정되어, &lt;code&gt;na_values&lt;/code&gt; 는 NaN의 구문 분석을 위해 사용하는 값 기본에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f265a8f044bf232fffa85812d820574c8444bbe7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are not specified, no strings will be parsed as NaN.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 은 거짓이며, &lt;code&gt;na_values&lt;/code&gt; 가 지정되지 않은 어떤 문자열은 NaN의로 해석되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a282745eb357ce0d97179f43d5f0ca158631ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is False, and &lt;code&gt;na_values&lt;/code&gt; are specified, only the NaN values specified &lt;code&gt;na_values&lt;/code&gt; are used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 은 거짓이며, &lt;code&gt;na_values&lt;/code&gt; 가 지정, 지정 만의 NaN 값 &lt;code&gt;na_values&lt;/code&gt; 는 구문 분석에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8ef3b4bb67919e2a3c220c269aec10ecbb92263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are not specified, only the default NaN values are used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 는 사실이며, &lt;code&gt;na_values&lt;/code&gt; 이 지정되지 않은, 단지 기본 NaN의 값은 구문 분석에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4119b503697716799e0d3d53bb23a09257bc768a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keep_default_na&lt;/code&gt; is True, and &lt;code&gt;na_values&lt;/code&gt; are specified, &lt;code&gt;na_values&lt;/code&gt; is appended to the default NaN values used for parsing.</source>
          <target state="translated">경우 &lt;code&gt;keep_default_na&lt;/code&gt; 는 사실이며, &lt;code&gt;na_values&lt;/code&gt; 가 지정되어, &lt;code&gt;na_values&lt;/code&gt; 는 NaN의 구문 분석을 위해 사용하는 값 기본에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="14eafb6125c72331ed6931749a85a2bfe869b0fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is not set, all levels are removed from the Index.</source>
          <target state="translated">경우 &lt;code&gt;level&lt;/code&gt; 설정되어 있지 않은 모든 수준은 인덱스에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb5a110126584a428bb870b81494275cb5c1371" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;level&lt;/code&gt; is specified:</source>
          <target state="translated">만약 &lt;code&gt;level&lt;/code&gt; 지정됩니다</target>
        </trans-unit>
        <trans-unit id="60f1e6635b0a341e3238693e8e1f6f09613ae56b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is None, missing values in the Series/Index are omitted from the result.</source>
          <target state="translated">경우 &lt;code&gt;na_rep&lt;/code&gt; 은 아무도 없으며, &lt;code&gt;others&lt;/code&gt; 아무도 없다, 시리즈 / 인덱스에서 누락 된 값은 결과에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="444db6399518d3b249738d624701c4ac6b47e94e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;na_rep&lt;/code&gt; is None, and &lt;code&gt;others&lt;/code&gt; is not None, a row containing a missing value in any of the columns (before concatenation) will have a missing value in the result.</source>
          <target state="translated">경우 &lt;code&gt;na_rep&lt;/code&gt; 는 것도없고, &lt;code&gt;others&lt;/code&gt; 없음], (연결) 전에 모든 열에서 누락 값을 포함하는 행이 결과에서 누락 값을 가질 것이다.</target>
        </trans-unit>
        <trans-unit id="c1f385438de08840651ce957815b6972e0f16406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;numpy=True&lt;/code&gt; is passed to &lt;code&gt;read_json&lt;/code&gt; an attempt will be made to sniff an appropriate dtype during deserialization and to subsequently decode directly to NumPy arrays, bypassing the need for intermediate Python objects.</source>
          <target state="translated">경우 &lt;code&gt;numpy=True&lt;/code&gt; 전달됩니다 &lt;code&gt;read_json&lt;/code&gt; 시도가 중간 파이썬은 객체의 필요성을 거치지 않고 직접 NumPy와 배열에 직렬화 복원시에 적절한 DTYPE 냄새를 만들어 연속적으로 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b7230c53dd34c840119bd5592d141943fc9eb82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original Series.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; NaN이 포함되어 있으면 해당 값이 원래 시리즈에서 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="deb8809ee611aa9a981b6b0843436b17f4eb152b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains NaNs the corresponding values are not updated in the original dataframe.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 에 NaN이 포함되어 있으면 해당 값이 원래 데이터 프레임에서 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25b2a3bb2e641aa80e4bd798d256b6357269c5bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is None, &lt;code&gt;str&lt;/code&gt; is returned, otherwise a &lt;code&gt;Series/Index&lt;/code&gt; (same type as caller) of objects is returned.</source>
          <target state="translated">경우 &lt;code&gt;others&lt;/code&gt; 없음이다 &lt;code&gt;str&lt;/code&gt; 반환되지 않습니다, 그렇지 않으면 &lt;code&gt;Series/Index&lt;/code&gt; 오브젝트 (호출자와 같은 종류)가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="09719fe597a3b1238ba510411ad64aa8b9b27a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, corresponding values are concatenated with the separator. Result will be a Series of strings.</source>
          <target state="translated">경우 &lt;code&gt;others&lt;/code&gt; 지정되고, 대응하는 값은 분리기와 연결되어있다. 결과는 일련의 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="403aef7dbc0efb83661ae14475ba2c1f617d536d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;others&lt;/code&gt; is specified, this function concatenates the Series/Index and elements of &lt;code&gt;others&lt;/code&gt; element-wise. If &lt;code&gt;others&lt;/code&gt; is not passed, then all values in the Series/Index are concatenated into a single string with a given &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;others&lt;/code&gt; 지정되어,이 함수는 시리즈 / 지수와의 요소를 연결 한 &lt;code&gt;others&lt;/code&gt; 요소 현명한. 경우 &lt;code&gt;others&lt;/code&gt; 전달되지 다음 시리즈 / 색인의 모든 값은 주어진 단일 문자열로 연결됩니다 &lt;code&gt;sep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1abddbde8315f2084021872e6073c1be66d77681" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path_or_buffer&lt;/code&gt; is an OpenDocument format (.odf, .ods, .odt), then &lt;a href=&quot;https://pypi.org/project/odfpy/&quot;&gt;odf&lt;/a&gt; will be used.</source>
          <target state="translated">경우 &lt;code&gt;path_or_buffer&lt;/code&gt; 가 도큐먼트 포맷 (.odf, .ODS, .ODT)이며, 다음 &lt;a href=&quot;https://pypi.org/project/odfpy/&quot;&gt;ODF가&lt;/a&gt; 사용될 것이다.</target>
        </trans-unit>
        <trans-unit id="3baa765246b3745f60bd4ee59b2f98ce470debc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt;, then an array of size len(self) is returned, with all values filled with &lt;code&gt;self.dtype.na_value&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;periods &amp;gt; len(self)&lt;/code&gt; , 다음 (자기) 렌 크기의 배열로 채워진 모든 값으로 반환된다 &lt;code&gt;self.dtype.na_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c112aa6403a164634d1416141466a683b493a868" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a float, a Series will be returned where the</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 는 부동이다, 일련의 위치를 반환합니다</target>
        </trans-unit>
        <trans-unit id="6ea206fbf912a77c2c5baccfb75902c0063d921d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is an array, a DataFrame will be returned where the</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 는 배열 인하는 DataFrame 어디 반환되는</target>
        </trans-unit>
        <trans-unit id="961740cc92f0fc03f28c95a8a238e4dbbce71c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is an array, a Series will be returned where the index is &lt;code&gt;q&lt;/code&gt; and the values are the quantiles, otherwise a float will be returned.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 배열하고, 일련의 인덱스이고 반환한다 &lt;code&gt;q&lt;/code&gt; 는 상기 값을, 그렇지 않은 플로트 반환 될 분위수이다.</target>
        </trans-unit>
        <trans-unit id="50282aa940212018e61f3deecb959d20f87fb9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;regex&lt;/code&gt; is not a &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;to_replace&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;regex&lt;/code&gt; 되지 &lt;code&gt;bool&lt;/code&gt; 및 &lt;code&gt;to_replace&lt;/code&gt; 은 하지 않습니다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b41c22f4efb9468b1cb6a930f4d6611ab107c8d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is</source>
          <target state="translated">경우 &lt;code&gt;return_type&lt;/code&gt; 은 이다</target>
        </trans-unit>
        <trans-unit id="81766fdd49633266642838e7da2bdf12aca59fae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;return_type&lt;/code&gt; 가 없는 &lt;code&gt;None&lt;/code&gt; , 동일한 형상으로되는 축 NumPy와 어레이 &lt;code&gt;layout&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="f81d6e8038a65cfec7ed666581c73e2227881317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_type&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, a NumPy array of axes with the same shape as &lt;code&gt;layout&lt;/code&gt; is returned:</source>
          <target state="translated">경우 &lt;code&gt;return_type&lt;/code&gt; 가 없는 &lt;code&gt;None&lt;/code&gt; , 동일한 형상으로되는 축 NumPy와 배열로 &lt;code&gt;layout&lt;/code&gt; 반환된다 :</target>
        </trans-unit>
        <trans-unit id="9403f65e0291ebfce3b893ca7ef9f39c4702bafd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is empty or &lt;code&gt;periods&lt;/code&gt; is 0, a copy of &lt;code&gt;self&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;self&lt;/code&gt; 비어 있거나 &lt;code&gt;periods&lt;/code&gt; 0의 사본 &lt;code&gt;self&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6c9ebf0aff8358da4c22aadcc4e5af5797dd0abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified, the values are concatenated without separation.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 지정되지 않은 숫자가 분리없이 연결된다.</target>
        </trans-unit>
        <trans-unit id="42e82e5988245d4a3bb290ebd363efd4d9efea4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skip_blank_lines=False&lt;/code&gt;, then &lt;code&gt;read_csv&lt;/code&gt; will not ignore blank lines:</source>
          <target state="translated">만약 &lt;code&gt;skip_blank_lines=False&lt;/code&gt; , 다음 &lt;code&gt;read_csv&lt;/code&gt; 빈 줄을 무시하지 않을 것이다 :</target>
        </trans-unit>
        <trans-unit id="be88e00b6cd2ee9590d0a2d751007eb4876a853c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipna&lt;/code&gt; is False and there is an NA value in the data, the function returns &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;skipna&lt;/code&gt; 가 False 인 데이터의 NA의 값이 함수는 반환 &lt;code&gt;nan&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8565c59edb64329c1ca271f30471849138be0bff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;Period&lt;/code&gt; objects, they will be used as anchor endpoints for a &lt;code&gt;PeriodIndex&lt;/code&gt; with frequency matching that of the &lt;code&gt;PeriodIndex&lt;/code&gt; constructor.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 있는 &lt;code&gt;Period&lt;/code&gt; 목적, 이들은 앵커에 대한 엔드 포인트로 사용될 &lt;code&gt;PeriodIndex&lt;/code&gt; 의 해당 주파수 일치 &lt;code&gt;PeriodIndex&lt;/code&gt; 의 생성자.</target>
        </trans-unit>
        <trans-unit id="d07c799aa985555aa80944ae394ade3e6e41e965" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; are &lt;code&gt;Period&lt;/code&gt; objects, they will be used as anchor endpoints for a &lt;code&gt;PeriodIndex&lt;/code&gt; with frequency matching that of the &lt;code&gt;period_range&lt;/code&gt; constructor.</source>
          <target state="translated">경우 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 있는 &lt;code&gt;Period&lt;/code&gt; 목적, 이들은 앵커에 대한 엔드 포인트로 사용될 &lt;code&gt;PeriodIndex&lt;/code&gt; 그 주파수 일치 &lt;code&gt;period_range&lt;/code&gt; 의 생성자.</target>
        </trans-unit>
        <trans-unit id="b7b0a663d9250908bec356033f00f39037ab14b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;target&lt;/code&gt; is provided, and the expression mutates &lt;code&gt;target&lt;/code&gt;, whether to modify &lt;code&gt;target&lt;/code&gt; inplace. Otherwise, return a copy of &lt;code&gt;target&lt;/code&gt; with the mutation.</source>
          <target state="translated">경우 &lt;code&gt;target&lt;/code&gt; 제공되고 발현 변이는 &lt;code&gt;target&lt;/code&gt; 수정 여부, &lt;code&gt;target&lt;/code&gt; 인플레 이스를. 그렇지 않으면 돌연변이가있는 &lt;code&gt;target&lt;/code&gt; 의 사본을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1e7c5e72393131f2654387c48d329fe2921498d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;text_color_threshold&lt;/code&gt; is not a value from 0 to 1.</source>
          <target state="translated">&lt;code&gt;text_color_threshold&lt;/code&gt; 가 0에서 1 사이의 값이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="535b234a64529b3677378d8dfde02546b2a249b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;times&lt;/code&gt; is specified, the time unit (str or timedelta) over which an observation decays to half its value. Only applicable to &lt;code&gt;mean()&lt;/code&gt; and halflife value will not apply to the other functions.</source>
          <target state="translated">&lt;code&gt;times&lt;/code&gt; 이 지정된 경우 관측치가 값의 절반으로 감소하는 시간 단위 (str 또는 timedelta)입니다. &lt;code&gt;mean()&lt;/code&gt; 에만 적용 되며 반감기 값은 다른 함수에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="704cdb74002773b3b579c1c3d6d7936011db63ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;regex&lt;/code&gt; is not compilable into a regular expression or is a list, dict, ndarray, or Series.</source>
          <target state="translated">경우 &lt;code&gt;to_replace&lt;/code&gt; 는 없다 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;regex&lt;/code&gt; 정규 표현식으로 컴파일 가능한 없거나 목록, 딕셔너리, ndarray, 또는 시리즈입니다.</target>
        </trans-unit>
        <trans-unit id="d03447781d080adef5a2a9380fc861eeabc92417" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to_replace&lt;/code&gt; is a &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; is not a &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;ndarray&lt;/code&gt;, or &lt;code&gt;Series&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;to_replace&lt;/code&gt; 는 A는 &lt;code&gt;dict&lt;/code&gt; 하고 &lt;code&gt;value&lt;/code&gt; 하지 않은 것입니다 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;ndarray&lt;/code&gt; , 또는 &lt;code&gt;Series&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a1caaa2d26334416b23c7630389d536a0fad7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is a list of integers, then it is assumed to be the file column indices to be parsed.</source>
          <target state="translated">경우 &lt;code&gt;usecols&lt;/code&gt; 은 정수의리스트는, 다음을 파싱하는 파일 열 색인 것으로 가정한다.</target>
        </trans-unit>
        <trans-unit id="6ac4edea12a43fd31cf9476433f0b0a1a854909b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in &lt;code&gt;names&lt;/code&gt; or inferred from the document header row(s). Those strings define which columns will be parsed:</source>
          <target state="translated">&lt;code&gt;usecols&lt;/code&gt; 가 문자열 목록 인 경우 각 문자열은 사용자가 &lt;code&gt;names&lt;/code&gt; 제공하거나 문서 헤더 행에서 유추 한 열 이름에 해당한다고 가정합니다 . 이러한 문자열은 구문 분석 할 열을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e01b5dff3b67b87609e0579db43ccbda944e4e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;usecols&lt;/code&gt; is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;usecols&lt;/code&gt; 가 호출되면, 호출 함수가 호출 기능으로 평가 곳에 이름을 반환 열 이름에 대해 평가됩니다 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a1de8e0a85b6ff84557f7ecae5437820577f3a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uuid&lt;/code&gt; is not specified, the length of the &lt;code&gt;uuid&lt;/code&gt; to randomly generate expressed in hex characters, in range [0, 32].</source>
          <target state="translated">경우 &lt;code&gt;uuid&lt;/code&gt; 지정하지 않은 경우의 길이 &lt;code&gt;uuid&lt;/code&gt; 임의로 행은 [32, 0]의 범위에 육각 문자 표현 생성한다.</target>
        </trans-unit>
        <trans-unit id="c278841e9bef34e1e1bd4a72a3426ae68586bd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is a string</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 문자열입니다</target>
        </trans-unit>
        <trans-unit id="d9b7a5e40e9f52d62b19692bf3dcad2166cfe945" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;win_type=None&lt;/code&gt; all points are evenly weighted. To learn more about different window types see &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;scipy.signal window functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;win_type=None&lt;/code&gt; 이면 모든 포인트에 균등 한 가중치가 적용됩니다. 다른 창 유형에 대한 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.html#window-functions&quot;&gt;scipy.signal 창 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7762da07ec115be44fc02765f9d76407b7404d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;win_type=None&lt;/code&gt;, all points are evenly weighted; otherwise, &lt;code&gt;win_type&lt;/code&gt; can accept a string of any &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&quot;&gt;scipy.signal window function&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;win_type=None&lt;/code&gt; , 모든 지점이 균일하게 가중된다; 그렇지 않으면 &lt;code&gt;win_type&lt;/code&gt; 은 모든 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&quot;&gt;scipy.signal 창 함수&lt;/a&gt; 의 문자열을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a71b0b95595f61d6f49ae04391e762a1155d81ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{'foo': [1, 3]}&lt;/code&gt; -&amp;gt; parse columns 1, 3 as date and call result &amp;lsquo;foo&amp;rsquo;. A fast-path exists for iso8601-formatted dates.</source>
          <target state="translated">만약 &lt;code&gt;{'foo': [1, 3]}&lt;/code&gt; -&amp;gt; 구문 분석 열 날짜와 통화 결과 'foo는'같은 1, 3. iso8601 형식의 날짜에 대한 빠른 경로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a6323b295fa22008498d6df468eee6b83c1cb8" translate="yes" xml:space="preserve">
          <source>If DataFrame contains only NaNs, it is still not considered empty. See the example below.</source>
          <target state="translated">DataFrame에 NaN 만 포함되어 있으면 여전히 비어있는 것으로 간주되지 않습니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc64a7e5f7b013c75ec87dad61798a0bf364de27" translate="yes" xml:space="preserve">
          <source>If DataFrame is empty, return True, if not return False.</source>
          <target state="translated">DataFrame이 비어 있으면 False를 반환하지 않으면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9db46c5d4b42b8c5a58b772328c51b664e184ae7" translate="yes" xml:space="preserve">
          <source>If Datetime Array/Index is tz-naive.</source>
          <target state="translated">Datetime Array / Index가 tz-naive 인 경우</target>
        </trans-unit>
        <trans-unit id="d1f885919f4b6084a26832cb39a10a880fe30e9f" translate="yes" xml:space="preserve">
          <source>If False (default), the SparseSeries index consists of only the coords of the non-null entries of the original coo_matrix. If True, the SparseSeries index consists of the full sorted (row, col) coordinates of the coo_matrix.</source>
          <target state="translated">False (기본값) 인 경우 SparseSeries 색인은 원래 coo_matrix의 널이 아닌 항목의 좌표만으로 구성됩니다. True 인 경우 SparseSeries 인덱스는 coo_matrix의 전체 정렬 (행, 열) 좌표로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="af4968ab538593a91313d8dbcdb3666d290ea5ad" translate="yes" xml:space="preserve">
          <source>If False returns a numpy.timedelta64 or numpy.darray of values of dtype timedelta64[ns].</source>
          <target state="translated">False가 dtype timedelta64 [ns] 값의 numpy.timedelta64 또는 numpy.darray를 리턴하는 경우</target>
        </trans-unit>
        <trans-unit id="19cb14e4bedf8bda1fb770c21ea9563b40397a07" translate="yes" xml:space="preserve">
          <source>If False returns ndarray of values.</source>
          <target state="translated">False가 ndarray 값을 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="c4ef3d2ab2c9c4543800461df47e4edf64d59fdc" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndex DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">False이면 self와 other 사이의 일치하는 열만 사용되며 출력은 DataFrame이됩니다. True이면 모든 쌍 조합이 계산되고 DataFrame 입력의 경우 출력이 MultiIndex DataFrame이됩니다. 요소가 누락 된 경우 완전한 쌍별 관측치 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a787dc4a36cd7a1fb843fad1ef9b45ebd6788d" translate="yes" xml:space="preserve">
          <source>If False then only matching columns between self and other will be used and the output will be a DataFrame. If True then all pairwise combinations will be calculated and the output will be a MultiIndexed DataFrame in the case of DataFrame inputs. In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">False이면 self와 other 사이의 일치하는 열만 사용되며 출력은 DataFrame이됩니다. True 인 경우 모든 쌍별 조합이 계산되고 DataFrame 입력의 경우 출력이 MultiIndexed DataFrame이됩니다. 요소가 누락 된 경우 완전한 쌍별 관측치 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a089d4a3cab4ec051531af18ca8716ac15f227f1" translate="yes" xml:space="preserve">
          <source>If False then underlying input data is not copied.</source>
          <target state="translated">False이면 기본 입력 데이터가 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f4768ce69348aa654b6f78c372d4c73bce62c22" translate="yes" xml:space="preserve">
          <source>If False, allow the format to match anywhere in the target string.</source>
          <target state="translated">False이면 형식이 대상 문자열의 임의의 위치와 일치하게하십시오.</target>
        </trans-unit>
        <trans-unit id="30010fa9b0dacd4bae2d42840bc8bc8330f1bc61" translate="yes" xml:space="preserve">
          <source>If False, avoid copy if possible.</source>
          <target state="translated">False이면 가능하면 복사하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="291d4f114810ff3b85734eb9c885f67fb9461220" translate="yes" xml:space="preserve">
          <source>If False, do not copy data unnecessarily.</source>
          <target state="translated">False이면 불필요하게 데이터를 복사하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="713b0af025da394c1dfc7bcc4b8e6a4fc01b89b5" translate="yes" xml:space="preserve">
          <source>If False, don&amp;rsquo;t match the same &amp;lsquo;on&amp;rsquo; value (i.e., strictly less-than / strictly greater-than)</source>
          <target state="translated">False 인 경우 동일한 'on'값과 일치하지 않습니다 (즉,보다 작게 /보다 크게 초과)</target>
        </trans-unit>
        <trans-unit id="e90b5bec78f4ab7a4fe30e4eff0e3912178db8a9" translate="yes" xml:space="preserve">
          <source>If False, don&amp;rsquo;t match the same &amp;lsquo;on&amp;rsquo; value (i.e., strictly less-than / strictly greater-than).</source>
          <target state="translated">False 인 경우 동일한 'on'값과 일치하지 않습니다 (즉,보다 작음 /보다 큼).</target>
        </trans-unit>
        <trans-unit id="6b84b5f31bb2d6147a51b4eadc91b3e249c42dd9" translate="yes" xml:space="preserve">
          <source>If False, groups that evaluate False are filled with NaNs.</source>
          <target state="translated">False이면 False로 평가되는 그룹이 NaN으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="6b2899b63827cccc80ce7f0849090ad8a00a13fe" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from length of group - 1 to 0.</source>
          <target state="translated">False이면 그룹의 길이-1에서 0까지 역순으로 번호를 매 깁니다.</target>
        </trans-unit>
        <trans-unit id="18d85815ef65505f4da3c47d9d292cf07677ec50" translate="yes" xml:space="preserve">
          <source>If False, number in reverse, from number of group - 1 to 0.</source>
          <target state="translated">False이면 그룹 수-1에서 0까지 역순으로 번호를 매 깁니다.</target>
        </trans-unit>
        <trans-unit id="c66981ba95dd5d03a5bf5f115c2c1e1bc6df4b6d" translate="yes" xml:space="preserve">
          <source>If False, outputs info in a human readable form to the console.</source>
          <target state="translated">False 인 경우 콘솔에 사람이 읽을 수있는 형식으로 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="fb6ee337b37c7d79d6ff069d1d6be9c1ee63f16e" translate="yes" xml:space="preserve">
          <source>If False, return a copy. Otherwise, do operation inplace and return None.</source>
          <target state="translated">False이면 복사본을 반환합니다. 그렇지 않으면 내부 작업을 수행하고 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eee400988b3add06c7b8d82d92a5db12cafc5df8" translate="yes" xml:space="preserve">
          <source>If False, returns object with same levels as self.</source>
          <target state="translated">False이면 self와 동일한 수준의 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93f8cbc94b6ecff2910e70c613725fd41f719aa1" translate="yes" xml:space="preserve">
          <source>If False, the quantile of datetime and timedelta data will be computed as well.</source>
          <target state="translated">False이면 날짜 / 시간 델타 데이터의 Quantile도 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="1a855233ec9b42057ad4f3f0a22d197f5cc6c27a" translate="yes" xml:space="preserve">
          <source>If False, treats the pat as a literal string.</source>
          <target state="translated">False이면 pat을 리터럴 문자열로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="d42e87de00086a1c6e6f625064f6fded12c14393" translate="yes" xml:space="preserve">
          <source>If False, treats the pattern as a literal string</source>
          <target state="translated">False 인 경우 패턴을 리터럴 문자열로 처리</target>
        </trans-unit>
        <trans-unit id="386a8df84344bc31d4acd3d0513c6b8223ed5e6c" translate="yes" xml:space="preserve">
          <source>If NaN is in the values, and we want to include NaN in the uniques of the values, it can be achieved by setting &lt;code&gt;na_sentinel=None&lt;/code&gt;.</source>
          <target state="translated">NaN이 값에 있고 값의 고유 항목에 NaN을 포함하려는 경우 &lt;code&gt;na_sentinel=None&lt;/code&gt; 을 설정하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6823fe124c6d762f846db12c9b7eb432cef57e38" translate="yes" xml:space="preserve">
          <source>If None, defaults to 1</source>
          <target state="translated">None이면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="0f5d6d9a47683654054d53fe83da6d519ea96659" translate="yes" xml:space="preserve">
          <source>If None, defaults to 1.</source>
          <target state="translated">없음 인 경우 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="7a198b80d00181744c0b52dce1e2d43c14c2ff18" translate="yes" xml:space="preserve">
          <source>If None, defaults to the beginning</source>
          <target state="translated">None 인 경우 기본값은 시작입니다</target>
        </trans-unit>
        <trans-unit id="2228cf54c4d2a4d2730b3b9a52429df0614dd9bd" translate="yes" xml:space="preserve">
          <source>If None, defaults to the beginning.</source>
          <target state="translated">없음 인 경우 기본값은 시작입니다.</target>
        </trans-unit>
        <trans-unit id="d75f9174710ceedaeffa648b72cbbd3e8b87a0b5" translate="yes" xml:space="preserve">
          <source>If None, defaults to the end</source>
          <target state="translated">None 인 경우 기본적으로 끝</target>
        </trans-unit>
        <trans-unit id="ed03605cbabb4c3045d9b32daba224dab5b90b57" translate="yes" xml:space="preserve">
          <source>If None, defaults to the end.</source>
          <target state="translated">없음 인 경우 기본값은 끝입니다.</target>
        </trans-unit>
        <trans-unit id="99befa70db36b844698b11450c67335fe8946fc0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred</source>
          <target state="translated">None이면 dtype이 유추됩니다</target>
        </trans-unit>
        <trans-unit id="305e45bf0f534becf08e10a608173f7b64e54cf0" translate="yes" xml:space="preserve">
          <source>If None, dtype will be inferred.</source>
          <target state="translated">None이면 dtype이 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="33245c017268287ad9b24177b04ead223d178eae" translate="yes" xml:space="preserve">
          <source>If None, file format is inferred from file extension. If &amp;lsquo;xport&amp;rsquo; or &amp;lsquo;sas7bdat&amp;rsquo;, uses the corresponding format.</source>
          <target state="translated">None이면 파일 형식에서 파일 형식이 유추됩니다. 'xport'또는 'sas7bdat'인 경우 해당 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e4bd68ed52ae06d305e0f091922ac01ec8be5f11" translate="yes" xml:space="preserve">
          <source>If None, pd.get_option(&amp;lsquo;io.hdf.default_format&amp;rsquo;) is checked, followed by fallback to &amp;ldquo;fixed&amp;rdquo;</source>
          <target state="translated">None이면 pd.get_option ( 'io.hdf.default_format')을 확인한 다음 &quot;fixed&quot;로 폴백합니다.</target>
        </trans-unit>
        <trans-unit id="f40dfbb91453fe35b8691d9034b77ccdc78058b8" translate="yes" xml:space="preserve">
          <source>If None, return all columns, otherwise, returns specified columns.</source>
          <target state="translated">None이면 모든 열을 반환하고, 그렇지 않으면 지정된 열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d3b9a2dcf0b8b571245f92f0d02282c76972d82" translate="yes" xml:space="preserve">
          <source>If None, then parse all columns.</source>
          <target state="translated">None이면 모든 열을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="cede37750460f29cb4fa52c7fec665577cfd52b2" translate="yes" xml:space="preserve">
          <source>If Numba is passed a function that includes something it doesn&amp;rsquo;t know how to work with &amp;ndash; a category that currently includes sets, lists, dictionaries, or string functions &amp;ndash; it will revert to &lt;code&gt;object mode&lt;/code&gt;. In &lt;code&gt;object mode&lt;/code&gt;, Numba will execute but your code will not speed up significantly. If you would prefer that Numba throw an error if it cannot compile a function in a way that speeds up your code, pass Numba the argument &lt;code&gt;nopython=True&lt;/code&gt; (e.g. &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt;). For more on troubleshooting Numba modes, see the &lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba troubleshooting page&lt;/a&gt;.</source>
          <target state="translated">Numba에 무언가를 포함하는 함수가 전달되면, 현재 세트, 목록, 사전 또는 문자열 함수를 포함하는 범주와 함께 작동하는 방법을 모르는 &lt;code&gt;object mode&lt;/code&gt; 돌아갑니다 . 에서 &lt;code&gt;object mode&lt;/code&gt; , Numba는 실행되지만 코드는 크게 속도를하지 않습니다. 코드 속도를 &lt;code&gt;nopython=True&lt;/code&gt; 방식으로 함수를 컴파일 할 수없는 경우 Numba에서 오류를 발생 시키려면 nopython = True 인수 (예 : &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt; )를 Numba에 전달하십시오 . Numba 모드 문제 해결에 대한 자세한 내용은 &lt;a href=&quot;http://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba 문제 해결 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf83492c2f7d9b62bbeb8e6388f30b8fbfed606" translate="yes" xml:space="preserve">
          <source>If Numba is passed a function that includes something it doesn&amp;rsquo;t know how to work with &amp;ndash; a category that currently includes sets, lists, dictionaries, or string functions &amp;ndash; it will revert to &lt;code&gt;object mode&lt;/code&gt;. In &lt;code&gt;object mode&lt;/code&gt;, Numba will execute but your code will not speed up significantly. If you would prefer that Numba throw an error if it cannot compile a function in a way that speeds up your code, pass Numba the argument &lt;code&gt;nopython=True&lt;/code&gt; (e.g. &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt;). For more on troubleshooting Numba modes, see the &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba troubleshooting page&lt;/a&gt;.</source>
          <target state="translated">Numba가 작업 방법을 모르는 함수 (현재 집합, 목록, 사전 또는 문자열 함수를 포함하는 범주)를 전달하면 &lt;code&gt;object mode&lt;/code&gt; 되돌아갑니다 . 에서 &lt;code&gt;object mode&lt;/code&gt; , Numba는 실행되지만 코드는 크게 속도를하지 않습니다. 코드 속도를 &lt;code&gt;nopython=True&lt;/code&gt; 방식으로 함수를 컴파일 할 수없는 경우 Numba에서 오류가 발생하도록하려면 Numba에 nopython = True 인수를 전달하십시오 (예 : &lt;code&gt;@numba.jit(nopython=True)&lt;/code&gt; ). Numba 모드 문제 해결에 대한 자세한 내용은 &lt;a href=&quot;https://numba.pydata.org/numba-doc/latest/user/troubleshoot.html#the-compiled-code-is-too-slow&quot;&gt;Numba 문제 해결 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21738859f1a9792d732c95f50fc39e869d10cb29" translate="yes" xml:space="preserve">
          <source>If SQLAlchemy is not installed, a fallback is only provided for sqlite (and for mysql for backwards compatibility, but this is deprecated and will be removed in a future version). This mode requires a Python database adapter which respect the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB-API&lt;/a&gt;.</source>
          <target state="translated">SQLAlchemy가 설치되지 않은 경우, 대체는 sqlite에 대해서만 제공됩니다 (및 이전 버전과의 호환성을 위해 mysql에 대해 제공되지만 이는 더 이상 사용되지 않으며 향후 버전에서 제거 될 예정입니다). 이 모드에는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB-API를 준수&lt;/a&gt; 하는 Python 데이터베이스 어댑터가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="3c1f8f822f180177bfde53d3b1ec7bf4e05cab5e" translate="yes" xml:space="preserve">
          <source>If Timestamp convertible, origin is set to Timestamp identified by origin.</source>
          <target state="translated">타임 스탬프가 변환 가능한 경우 오리진은 오리진으로 식별 된 타임 스탬프로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="302ec23d134fa94295f5a5b21bbe57333cc5ba71" translate="yes" xml:space="preserve">
          <source>If Timestamp is tz-naive.</source>
          <target state="translated">타임 스탬프가 tz-naive 인 경우</target>
        </trans-unit>
        <trans-unit id="877daf2c60c584794d63f9ddbf4bb796256b13ee" translate="yes" xml:space="preserve">
          <source>If True (default) the description(s) will be printed to stdout. Otherwise, the description(s) will be returned as a unicode string (for testing).</source>
          <target state="translated">True (기본값)이면 설명이 표준 출력으로 인쇄됩니다. 그렇지 않으면 설명이 유니 코드 문자열로 반환됩니다 (테스트 용).</target>
        </trans-unit>
        <trans-unit id="79279f7b5a78bfc09767977781bcb3e7ef19efbc" translate="yes" xml:space="preserve">
          <source>If True and</source>
          <target state="translated">True이고</target>
        </trans-unit>
        <trans-unit id="6d916b7ecf5b34c978b87a1cac148ea4e85e0797" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; is enabled, pandas will attempt to infer the format of the datetime strings in the columns, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by 5-10x.</source>
          <target state="translated">True 및 &lt;code&gt;parse_dates&lt;/code&gt; 를 사용하면 팬더가 열에서 날짜 시간 문자열의 형식을 유추하려고 시도하고 추론 가능한 경우 더 빠른 구문 분석 방법으로 전환합니다. 경우에 따라 파싱 속도가 5-10 배 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6c1e57d23e26869dc0e2062acc23c857f4141f1" translate="yes" xml:space="preserve">
          <source>If True and &lt;code&gt;parse_dates&lt;/code&gt; specifies combining multiple columns then keep the original columns.</source>
          <target state="translated">True 및 &lt;code&gt;parse_dates&lt;/code&gt; 가 여러 열 결합을 지정하면 원래 열을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="b1ba3921dc01d9fac0f5e6f97a8d6ec85f39852c" translate="yes" xml:space="preserve">
          <source>If True and no</source>
          <target state="translated">True이고 아니오 인 경우</target>
        </trans-unit>
        <trans-unit id="cdbd44edb95eb1919d0e70e68013314a95652069" translate="yes" xml:space="preserve">
          <source>If True and no &lt;code&gt;format&lt;/code&gt; is given, attempt to infer the format of the datetime strings, and if it can be inferred, switch to a faster method of parsing them. In some cases this can increase the parsing speed by ~5-10x.</source>
          <target state="translated">True이고 &lt;code&gt;format&lt;/code&gt; 이 지정 되지 않은 경우 날짜 시간 문자열의 형식을 유추하려고 시도하고 유추 할 수있는 경우 더 빠른 구문 분석 방법으로 전환하십시오. 경우에 따라 파싱 속도가 ~ 5-10 배 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ce3205c3816ae877ac9af3cf60622cf6b06aa7" translate="yes" xml:space="preserve">
          <source>If True and sorting by level and index is multilevel, sort by other levels too (in order) after sorting by specified level.</source>
          <target state="translated">True 및 수준 및 색인을 기준으로 정렬이 다중 수준 인 경우 지정된 수준을 기준으로 정렬 한 후 다른 수준도 순서대로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="c4da65c79c92e3c24cfc8f74ebd023389cdd2b17" translate="yes" xml:space="preserve">
          <source>If True parse dates in</source>
          <target state="translated">True 인 경우 날짜를 파싱합니다.</target>
        </trans-unit>
        <trans-unit id="262d40ea87b315db865b2f76fe9cef275e5b9327" translate="yes" xml:space="preserve">
          <source>If True parse dates in &lt;code&gt;data&lt;/code&gt; with the year first order</source>
          <target state="translated">True가 첫 번째 연도의 &lt;code&gt;data&lt;/code&gt; 로 날짜를 구문 분석하는 경우</target>
        </trans-unit>
        <trans-unit id="d875c9e78a8f10c4070a76617db0aea9c9581c5c" translate="yes" xml:space="preserve">
          <source>If True parses dates with the year first, eg 10/11/12 is parsed as 2010-11-12.</source>
          <target state="translated">True가 연도를 기준으로 날짜를 구문 분석하는 경우 (예 : 10/11/12)는 2010-11-12로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="bb627fc931d5d5697f56d7a0202d4eeb9eb2c217" translate="yes" xml:space="preserve">
          <source>If True returns a DatetimeIndex or Index-like object</source>
          <target state="translated">True가 DatetimeIndex 또는 Index-like 객체를 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="e55faf7a09074a6a866ad052dfba8d934e2a620c" translate="yes" xml:space="preserve">
          <source>If True returns a Timedelta/TimedeltaIndex of the results.</source>
          <target state="translated">True이면 결과의 Timedelta / TimedeltaIndex를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50b84049db5e2134804159a690e8517ba44f78e8" translate="yes" xml:space="preserve">
          <source>If True then default datelike columns may be converted (depending on keep_default_dates). If False, no dates will be converted. If a list of column names, then those columns will be converted and default datelike columns may also be converted (depending on keep_default_dates).</source>
          <target state="translated">True이면 기본 datelike 열이 변환 될 수 있습니다 (keep_default_dates에 따라 다름). False이면 날짜가 변환되지 않습니다. 열 이름 목록이 있으면 해당 열이 변환되고 기본 datelike 열도 변환 될 수 있습니다 (keep_default_dates에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="460a87b8b136bb4a2b3c54602f91c633b0e77bca" translate="yes" xml:space="preserve">
          <source>If True then the object returned will contain the relative frequencies of the unique values.</source>
          <target state="translated">True이면 반환 된 객체에 고유 값의 상대 빈도가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2f6899875f0d289bc3d7921ca50f8266c60d0690" translate="yes" xml:space="preserve">
          <source>If True, adds a column to output DataFrame called &amp;ldquo;_merge&amp;rdquo; with information on the source of each row. If string, column with information on source of each row will be added to output DataFrame, and column will be named value of string. Information column is Categorical-type and takes on a value of &amp;ldquo;left_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;left&amp;rsquo; DataFrame, &amp;ldquo;right_only&amp;rdquo; for observations whose merge key only appears in &amp;lsquo;right&amp;rsquo; DataFrame, and &amp;ldquo;both&amp;rdquo; if the observation&amp;rsquo;s merge key is found in both.</source>
          <target state="translated">True 인 경우 각 행의 소스에 대한 정보와 함께 &quot;_merge&quot;라는 출력 DataFrame에 열을 추가합니다. 문자열 인 경우 각 행의 소스에 대한 정보가있는 열이 출력 DataFrame에 추가되고 열의 이름은 string의 값입니다. 정보 열은 범주 형이며 병합 키가 'left'DataFrame에만 나타나는 관측에 대해서는 &quot;left_only&quot;값을 취하고, 병합 키가 'right'DataFrame에만 나타나는 관측에 대해서는&amp;ldquo;right_only&amp;rdquo;를, 관측치의 병합 키는 둘 다에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f47a60165f80019a2aacb8f49d7ce550df20d9ae" translate="yes" xml:space="preserve">
          <source>If True, adds a column to the output DataFrame called &amp;ldquo;_merge&amp;rdquo; with information on the source of each row. The column can be given a different name by providing a string argument. The column will have a Categorical type with the value of &amp;ldquo;left_only&amp;rdquo; for observations whose merge key only appears in the left DataFrame, &amp;ldquo;right_only&amp;rdquo; for observations whose merge key only appears in the right DataFrame, and &amp;ldquo;both&amp;rdquo; if the observation&amp;rsquo;s merge key is found in both DataFrames.</source>
          <target state="translated">True 인 경우 각 행의 소스에 대한 정보와 함께 &quot;_merge&quot;라는 출력 데이터 프레임에 열을 추가합니다. 문자열 인수를 제공하여 열에 다른 이름을 지정할 수 있습니다. 열은 병합 키가 왼쪽 DataFrame에만 나타나는 관찰에 대해 &quot;left_only&quot;값을 가진 범주 형 유형, 병합 키가 오른쪽 DataFrame에만 나타나는 관찰에 대해 &quot;right_only&quot;, 관찰의 병합 키에 &quot;both&quot;가 있습니다. 두 DataFrames에서 모두 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="54a0d8d2165cdc25ae287fecadf2dc5419cb8c90" translate="yes" xml:space="preserve">
          <source>If True, allow matching with the same &amp;lsquo;on&amp;rsquo; value (i.e. less-than-or-equal-to / greater-than-or-equal-to)</source>
          <target state="translated">True 인 경우 동일한 'on'값 (예 :보다 작거나 같음 /보다 크거나 같음)과 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1954fe0d26126090114d61aee388af1ae86e3bf1" translate="yes" xml:space="preserve">
          <source>If True, and if group keys contain NA values, NA values together with row/column will be dropped. If False, NA values will also be treated as the key in groups</source>
          <target state="translated">True이고 그룹 키에 NA 값이 포함 된 경우 행 / 열과 함께 NA 값이 삭제됩니다. False이면 NA 값도 그룹의 키로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1d19895ec0d15a9331df9ff0f2a55c57a6a58746" translate="yes" xml:space="preserve">
          <source>If True, and if group keys contain NA values, NA values together with row/column will be dropped. If False, NA values will also be treated as the key in groups.</source>
          <target state="translated">True이고 그룹 키에 NA 값이 포함 된 경우 행 / 열과 함께 NA 값이 삭제됩니다. False이면 NA 값도 그룹의 키로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4660645b9175a4b6c992d8f895126a90fe4a50a3" translate="yes" xml:space="preserve">
          <source>If True, assumes the passed-in pattern is a regular expression.</source>
          <target state="translated">True 인 경우 전달 된 패턴이 정규식이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1e74a09f271b28537768cc8961b39d335e31e6de" translate="yes" xml:space="preserve">
          <source>If True, assumes the pat is a regular expression.</source>
          <target state="translated">True이면 pat이 정규식이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="467512e132775d71f6afd4e58bafe55b86f48864" translate="yes" xml:space="preserve">
          <source>If True, boolean values can be plotted.</source>
          <target state="translated">True이면 부울 값을 플로팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f3e2f20afae1e95c8a12af9612d6d458bd5a5a" translate="yes" xml:space="preserve">
          <source>If True, case sensitive (the default if</source>
          <target state="translated">True이면 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="7fc051579ade2d30effac2d7f975b7af0eaf1117" translate="yes" xml:space="preserve">
          <source>If True, case sensitive (the default if &lt;code&gt;pat&lt;/code&gt; is a string)</source>
          <target state="translated">True 인 경우 대소 문자 구분 ( &lt;code&gt;pat&lt;/code&gt; 가 문자열 인 경우 기본값 )</target>
        </trans-unit>
        <trans-unit id="9f69db8a36129425d43c6f59fe632f1d4ad16ea5" translate="yes" xml:space="preserve">
          <source>If True, case sensitive.</source>
          <target state="translated">True이면 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="849117a9db8ed6e6e51890ffed8b4fd6a41700fb" translate="yes" xml:space="preserve">
          <source>If True, checks that levels and codes are compatible.</source>
          <target state="translated">True이면 레벨과 코드가 호환되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d154f805b1bfe50fc4462690ece065dd32c399b0" translate="yes" xml:space="preserve">
          <source>If True, columns in</source>
          <target state="translated">True 인 경우</target>
        </trans-unit>
        <trans-unit id="963a559726df468b6da10ccb14a21fec119cd396" translate="yes" xml:space="preserve">
          <source>If True, columns in &lt;code&gt;self&lt;/code&gt; that do not exist in &lt;code&gt;other&lt;/code&gt; will be overwritten with NaNs.</source>
          <target state="translated">True이면 &lt;code&gt;other&lt;/code&gt; 곳에 존재하지 않는 &lt;code&gt;self&lt;/code&gt; 열은 NaN으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="0072997ec6faf6f05624c4fd43f7c2c5957f60e6" translate="yes" xml:space="preserve">
          <source>If True, copy the underlying data.</source>
          <target state="translated">True 인 경우 기본 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="3b1dcb5dd58fb08e7346d27ce52d23be1c63ae1c" translate="yes" xml:space="preserve">
          <source>If True, create stacked plot.</source>
          <target state="translated">True이면 누적 플롯을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="beef21df15134efbd5ef8eaa6cfbb8bd6ce0957e" translate="yes" xml:space="preserve">
          <source>If True, do not use the index labels.</source>
          <target state="translated">True 인 경우 색인 레이블을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="39eabebf10ef842b50bf2b46f976dd96a678bf6f" translate="yes" xml:space="preserve">
          <source>If True, do not use the index values along the concatenation axis. The resulting axis will be labeled 0, &amp;hellip;, n - 1. This is useful if you are concatenating objects where the concatenation axis does not have meaningful indexing information. Note the index values on the other axes are still respected in the join.</source>
          <target state="translated">True 인 경우 연결 축을 따라 인덱스 값을 사용하지 마십시오. 결과 축에는 0,&amp;hellip;, n-1로 레이블이 지정됩니다. 이는 연결 축에 의미있는 색인 정보가없는 개체를 연결하는 경우에 유용합니다. 다른 축의 인덱스 값은 여전히 ​​조인에서 존중됩니다.</target>
        </trans-unit>
        <trans-unit id="2be78667d971f765edd09b5dcf231a83202213b7" translate="yes" xml:space="preserve">
          <source>If True, do operation inplace and return None.</source>
          <target state="translated">True이면 작업을 수행하고 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02a05fbc517d0938e12546e82b1fa2c67e2f36f4" translate="yes" xml:space="preserve">
          <source>If True, draw a table using the data in the DataFrame and the data will be transposed to meet matplotlib&amp;rsquo;s default layout. If a Series or DataFrame is passed, use passed data to draw a table.</source>
          <target state="translated">True 인 경우 DataFrame의 데이터를 사용하여 테이블을 그리면 데이터가 matplotlib의 기본 레이아웃을 충족하도록 전치됩니다. Series 또는 DataFrame이 전달되면 전달 된 데이터를 사용하여 테이블을 그립니다.</target>
        </trans-unit>
        <trans-unit id="28b1d2c85f895aef12f78ff43875c24af96a30a5" translate="yes" xml:space="preserve">
          <source>If True, each cell will have an &lt;code&gt;id&lt;/code&gt; attribute in their HTML tag. The &lt;code&gt;id&lt;/code&gt; takes the form &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; where &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; is the unique identifier, &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; is the row number and &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; is the column number.</source>
          <target state="translated">True이면 각 셀 의 HTML 태그에 &lt;code&gt;id&lt;/code&gt; 속성 이 있습니다 . &lt;code&gt;id&lt;/code&gt; 형태를 취 &lt;code&gt;T_&amp;lt;uuid&amp;gt;_row&amp;lt;num_row&amp;gt;_col&amp;lt;num_col&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;uuid&amp;gt;&lt;/code&gt; 고유 식별자 인 &lt;code&gt;&amp;lt;num_row&amp;gt;&lt;/code&gt; 행 번호이고 &lt;code&gt;&amp;lt;num_col&amp;gt;&lt;/code&gt; 열 번호이다.</target>
        </trans-unit>
        <trans-unit id="c187de18efb1034db0f173b43d135203505eb0f2" translate="yes" xml:space="preserve">
          <source>If True, each whitespace character (as defined by string.whitespace) remaining after tab expansion will be replaced by a single space (default: True).</source>
          <target state="translated">True 인 경우 탭 확장 후 남은 각 공백 문자 (string.whitespace로 정의 됨)는 단일 공백 ​​(기본값 : True)으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="7bc41a15bead4034e53881eb90092ca96d9054c1" translate="yes" xml:space="preserve">
          <source>If True, fill in-place. Note: this will modify any other views on this object (e.g., a no-copy slice for a column in a DataFrame).</source>
          <target state="translated">True 인 경우 제자리에 채우십시오. 참고 :이 객체의 다른보기 (예 : DataFrame의 열에 대한 무 복사 슬라이스)가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="779f470c819fe4b8c76c9ffe041585b2a57ed854" translate="yes" xml:space="preserve">
          <source>If True, ignore the order of index &amp;amp; columns. Note: index labels must match their respective rows (same as in columns) - same labels must be with the same data.</source>
          <target state="translated">True 인 경우 인덱스 및 열 순서를 무시하십시오. 참고 : 색인 레이블은 각 행과 일치해야합니다 (열과 동일). 동일한 레이블은 동일한 데이터를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="c1fb42cadb1475602cce6ec757150306fd56fb02" translate="yes" xml:space="preserve">
          <source>If True, in place. Note: this will modify any other views on this object (e.g. a column from a DataFrame). Returns the caller if this is True.</source>
          <target state="translated">True 인 경우 참고 :이 객체의 다른보기 (예 : DataFrame의 열)가 수정됩니다. 이것이 참이면 발신자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f32cc95594d1282134f1d68f351ad29dfeba40d" translate="yes" xml:space="preserve">
          <source>If True, infer dtypes; if a dict of column to dtype, then use those; if False, then don&amp;rsquo;t infer dtypes at all, applies only to the data.</source>
          <target state="translated">True이면 dtypes를 유추합니다. 열에 대한 ddict가 dtype 인 경우이를 사용하십시오. False이면 dtype을 전혀 추론하지 않고 데이터에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7997ecfa519f0e9d11e8ccfaf5aa7070e2ac85d4" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating</source>
          <target state="translated">True 인 경우 심문하여 데이터를 자세히 조사합니다.</target>
        </trans-unit>
        <trans-unit id="28a638dbfeb78f983bc652085d7b9c8a2d0bd1c8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned value.</source>
          <target state="translated">True 인 경우, 시스템 레벨 메모리 소비에 대해 &lt;code&gt;object&lt;/code&gt; dtype을 조사하여 데이터를 자세히 조사 하고 리턴 된 값에 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="11c935c8f1af11c12f350eee790d77bcc513b2a8" translate="yes" xml:space="preserve">
          <source>If True, introspect the data deeply by interrogating &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption, and include it in the returned values.</source>
          <target state="translated">True 인 경우, 시스템 레벨 메모리 소비에 대해 &lt;code&gt;object&lt;/code&gt; dtype을 조사하여 데이터를 자세히 조사 하고 리턴 된 값에 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="c8196976ac650ceea0e3a5f6ce68de3af78ca762" translate="yes" xml:space="preserve">
          <source>If True, modifies the DataFrame in place (do not create a new object).</source>
          <target state="translated">True 인 경우 DataFrame을 제자리에서 수정합니다 (새 개체를 만들지 않음).</target>
        </trans-unit>
        <trans-unit id="75f616449e447dd01e651b655bec89b32f9f161a" translate="yes" xml:space="preserve">
          <source>If True, mutates in place.</source>
          <target state="translated">True 인 경우 제자리에서 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e79427f24ce68d71e994b467383dc8a5a268616c" translate="yes" xml:space="preserve">
          <source>If True, only apply to numeric columns.</source>
          <target state="translated">True 인 경우 숫자 열에 만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="35ec09831bdd6b8649e000f3fff40e0f896b2493" translate="yes" xml:space="preserve">
          <source>If True, original index is ignored. If False, the original index is retained. Index labels will be repeated as necessary.</source>
          <target state="translated">True이면 원래 색인이 무시됩니다. False이면 원래 인덱스가 유지됩니다. 색인 레이블은 필요에 따라 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="7ead6d9026e6e44fe03446f442da04f5bbd5558f" translate="yes" xml:space="preserve">
          <source>If True, outputs info in JSON format to the console.</source>
          <target state="translated">True 인 경우 정보를 JSON 형식으로 콘솔에 출력합니다.</target>
        </trans-unit>
        <trans-unit id="b35ba5920ddefac79cf35ea89415ec6c3aaa7827" translate="yes" xml:space="preserve">
          <source>If True, parse dates in</source>
          <target state="translated">True이면 날짜를 파싱합니다.</target>
        </trans-unit>
        <trans-unit id="12c714b402a0f7d59a93c0a1d85e385c49190143" translate="yes" xml:space="preserve">
          <source>If True, parse dates in &lt;code&gt;data&lt;/code&gt; with the day first order</source>
          <target state="translated">True 인 경우 &lt;code&gt;data&lt;/code&gt; 에서 날짜를 첫 번째 날짜 순서로 구문 분석 하십시오.</target>
        </trans-unit>
        <trans-unit id="11a6adfd18dc986d6ff6528d42e29ae888e6d526" translate="yes" xml:space="preserve">
          <source>If True, perform operation in-place.</source>
          <target state="translated">True 인 경우 작업을 제자리에서 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="52083255d0c1625b5421b918b643ad39c3d91f57" translate="yes" xml:space="preserve">
          <source>If True, plot colorbar (only relevant for &amp;lsquo;scatter&amp;rsquo; and &amp;lsquo;hexbin&amp;rsquo; plots).</source>
          <target state="translated">True 인 경우 컬러 바를 플로팅합니다 ( 'scatter'및 'hexbin'플롯에만 관련됨).</target>
        </trans-unit>
        <trans-unit id="7b35ea2160939c711232caacbe9ffc59471f5f6b" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if meta is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">True 인 경우 접두사가 붙은 (?) 경로가있는 레코드를 접두어로 붙입니다 (예 : meta가 [ 'foo', 'bar'] 인 경우 foo.bar.field).</target>
        </trans-unit>
        <trans-unit id="918691faec44a66f1b1c5ddaf68832370f5563d0" translate="yes" xml:space="preserve">
          <source>If True, prefix records with dotted (?) path, e.g. foo.bar.field if path to records is [&amp;lsquo;foo&amp;rsquo;, &amp;lsquo;bar&amp;rsquo;].</source>
          <target state="translated">True 인 경우 점으로 구분 된 (?) 경로가있는 레코드를 접 두부로 사용하십시오 (예 : 레코드 경로가 [ 'foo', 'bar'] 인 경우 foo.bar.field).</target>
        </trans-unit>
        <trans-unit id="1b787f2412a9a56f4f2d0a2789a8e490bc7bd97a" translate="yes" xml:space="preserve">
          <source>If True, raise Exception on creating index with duplicates.</source>
          <target state="translated">True 인 경우 중복 인덱스 생성시 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f92c7eaff72b81ab6a7f6f3c046d665142253fca" translate="yes" xml:space="preserve">
          <source>If True, raise ValueError on creating index with duplicates.</source>
          <target state="translated">True 인 경우 중복 인덱스 생성시 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="65688aa40ea915fb917db04985ab684fb4b0d10f" translate="yes" xml:space="preserve">
          <source>If True, require an exact format match.</source>
          <target state="translated">True 인 경우 정확한 형식 일치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a51ee754f13842cc1c7503238049ba90f6317028" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame with one column per capture group. If False, return a Series/Index if there is one capture group or DataFrame if there are multiple capture groups.</source>
          <target state="translated">True 인 경우 캡처 그룹당 하나의 열이있는 DataFrame을 반환합니다. False이면 캡처 그룹이 하나 있으면 Series / Index를, 캡처 그룹이 여러 개이면 DataFrame을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="752a06fc414514adb4cbae9fe15c30471375abcf" translate="yes" xml:space="preserve">
          <source>If True, return DataFrame/MultiIndex expanding dimensionality. If False, return Series/Index.</source>
          <target state="translated">True 인 경우 DataFrame / MultiIndex 확장 차원을 반환합니다. False이면 Series / Index를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fceb9f4dd2f49705ce97835f6760fabf3db79d64" translate="yes" xml:space="preserve">
          <source>If True, return the index as the first element of the tuple.</source>
          <target state="translated">True 인 경우 인덱스를 튜플의 첫 번째 요소로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="db6a2a7946d7a74ee079d7db1cd5033117192d16" translate="yes" xml:space="preserve">
          <source>If True, returns an iterator for reading the file incrementally.</source>
          <target state="translated">True 인 경우 파일을 점차적으로 읽는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e9f098b0cebf828eaf4b7145977c959411d29fa" translate="yes" xml:space="preserve">
          <source>If True, skip NaN values.</source>
          <target state="translated">True이면 NaN 값을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="2c7785df59be40ed32a0a30ad986c482f4b9104c" translate="yes" xml:space="preserve">
          <source>If True, skip over blank lines rather than interpreting as NaN values.</source>
          <target state="translated">True 인 경우 NaN 값으로 해석하지 않고 빈 줄을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="45dc4286e28963ebfaf419f2ca82e19caa47ad55" translate="yes" xml:space="preserve">
          <source>If True, sort values in ascending order, otherwise descending.</source>
          <target state="translated">True이면 값을 오름차순으로 정렬하고 그렇지 않으면 내림차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="b4c0dbb1de303429c5f1585939b0e85294386572" translate="yes" xml:space="preserve">
          <source>If True, tab characters will be expanded to spaces (default: True).</source>
          <target state="translated">True이면 탭 문자가 공백으로 확장됩니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="f9b43baf827304c498c502484b0f8be2d39c6d28" translate="yes" xml:space="preserve">
          <source>If True, the resulting axis will be labeled 0, 1, &amp;hellip;, n - 1.</source>
          <target state="translated">True 인 경우 결과 축은 0, 1,&amp;hellip;, n-1로 레이블이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d21f7b111187cb1a3ffe644e0758fb4ee939e9" translate="yes" xml:space="preserve">
          <source>If True, the resulting index will be labeled 0, 1, &amp;hellip;, n - 1.</source>
          <target state="translated">True 인 경우 결과 색인은 0, 1,&amp;hellip;, n-1로 레이블이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="c4133671064687e871d2078ebf94e5b70a1263d8" translate="yes" xml:space="preserve">
          <source>If True, the underlying data is copied. Otherwise (default), no copy is made if possible.</source>
          <target state="translated">True 인 경우 기본 데이터가 복사됩니다. 그렇지 않으면 (기본값) 가능한 경우 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdead9bb7da05f8a6a1234e7274e5a9b654351b0" translate="yes" xml:space="preserve">
          <source>If True, then words longer than width will be broken in order to ensure that no lines are longer than width. If it is false, long words will not be broken, and some lines may be longer than width (default: True).</source>
          <target state="translated">True 인 경우 너비보다 긴 선이 없도록 너비보다 긴 단어가 분리됩니다. False 인 경우 긴 단어가 깨지지 않으며 일부 줄이 너비보다 길 수 있습니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="96caf78b1c5986e9400372061306220c9af20aa7" translate="yes" xml:space="preserve">
          <source>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.</source>
          <target state="translated">True 인 경우 변환 된 고유 한 날짜 캐시를 사용하여 날짜 / 시간 변환을 적용하십시오. 중복 날짜 문자열, 특히 시간대 오프셋이있는 문자열을 구문 분석 할 때 속도가 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="850369ac77e896e440c30d1b4a94fb2f6cbfc17a" translate="yes" xml:space="preserve">
          <source>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets. The cache is only used when there are at least 50 values. The presence of out-of-bounds values will render the cache unusable and may slow down parsing.</source>
          <target state="translated">True 인 경우 고유하고 변환 된 날짜의 캐시를 사용하여 날짜 / 시간 변환을 적용합니다. 중복 날짜 문자열, 특히 시간대 오프셋이있는 문자열을 구문 분석 할 때 속도가 크게 향상 될 수 있습니다. 캐시는 값이 50 개 이상인 경우에만 사용됩니다. 범위를 벗어난 값이 있으면 캐시를 사용할 수 없게되고 구문 분석 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbf45354c267296e53e87ec9ae9077df026352c" translate="yes" xml:space="preserve">
          <source>If True, use dtypes that use &lt;code&gt;pd.NA&lt;/code&gt; as missing value indicator for the resulting DataFrame (only applicable for &lt;code&gt;engine=&quot;pyarrow&quot;&lt;/code&gt;). As new dtypes are added that support &lt;code&gt;pd.NA&lt;/code&gt; in the future, the output with this option will change to use those dtypes. Note: this is an experimental option, and behaviour (e.g. additional support dtypes) may change without notice.</source>
          <target state="translated">true의 경우, 사용 사용 dtypes &lt;code&gt;pd.NA&lt;/code&gt; 을 (에만 적용 결과 DataFrame에 대한 값을 표시 누락으로 &lt;code&gt;engine=&quot;pyarrow&quot;&lt;/code&gt; ). 앞으로 &lt;code&gt;pd.NA&lt;/code&gt; 를 지원하는 새로운 dtype이 추가되면 이 옵션이있는 출력은 해당 dtype을 사용하도록 변경됩니다. 참고 : 이것은 실험적인 옵션이며 동작 (예 : 추가 지원 dtypes)은 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc5966567744c9deec0817e54ad119ae9eb8051" translate="yes" xml:space="preserve">
          <source>If True, whitespace that, after wrapping, happens to end up at the beginning or end of a line is dropped (default: True).</source>
          <target state="translated">True 인 경우 줄 바꿈 후 줄의 시작 또는 끝에서 발생하는 공백이 삭제됩니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="af63c1972ac9e275096f086bf4dbabfd22a77fc3" translate="yes" xml:space="preserve">
          <source>If True, wrapping will occur preferably on whitespace and right after hyphens in compound words, as it is customary in English. If false, only whitespaces will be considered as potentially good places for line breaks, but you need to set break_long_words to false if you want truly insecable words (default: True).</source>
          <target state="translated">True 인 경우 줄 바꿈은 영어에서 관례 적으로 복합 단어에서 공백과 하이픈 바로 뒤에 발생하는 것이 좋습니다. false 인 경우 공백 만 줄 바꿈에 적합한 위치로 간주되지만 실제로 절제 할 수없는 단어를 원할 경우 break_long_words를 false로 설정해야합니다 (기본값 : True).</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="60a23d3725070e24cb533dd92a64738f0efc9eeb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DataFrame&lt;/code&gt; does not have a datetimelike index, but instead you want to resample based on datetimelike column in the frame, it can passed to the &lt;code&gt;on&lt;/code&gt; keyword.</source>
          <target state="translated">경우 &lt;code&gt;DataFrame&lt;/code&gt; 가 datetimelike 지수는 없지만, 대신에 당신이 프레임에 datetimelike 열을 기반으로 리샘플링하고 싶은, 그것은 전달 수 &lt;code&gt;on&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="b671a6d1db2b1bde6a5afb6d8028d31c59543e99" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; is used, all unmapped categories are mapped to &lt;code&gt;NaN&lt;/code&gt; and the result is an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경우 &lt;code&gt;dict&lt;/code&gt; 사용하는 모든 매핑되지 않은 범주에 매핑되는 &lt;code&gt;NaN&lt;/code&gt; 를 하고 결과는이다 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3fc417177302a9cebffe9152263446b535b47d84" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;dict&lt;/code&gt; or &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; is used any unmapped category is mapped to &lt;code&gt;NaN&lt;/code&gt;. Note that if this happens an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;dict&lt;/code&gt; 또는 &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 가 사용 되면 매핑되지 않은 범주가 &lt;code&gt;NaN&lt;/code&gt; 에 매핑됩니다 . 이런 일이 발생하면 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5a13d756489055d99c339c198cd08b153d3f1acb" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;list&lt;/code&gt; or an &lt;code&gt;ndarray&lt;/code&gt; is passed to</source>
          <target state="translated">경우 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;ndarray&lt;/code&gt; 이 전달됩니다</target>
        </trans-unit>
        <trans-unit id="4cbad76c3179a700e058557a45022426a6d90e9b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;list&lt;/code&gt; or an &lt;code&gt;ndarray&lt;/code&gt; is passed to &lt;code&gt;to_replace&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; but they are not the same length.</source>
          <target state="translated">경우 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;ndarray&lt;/code&gt; 이 전달됩니다 &lt;code&gt;to_replace&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 하지만 그들은 같은 길이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0839be279acdfe99dee443052560f05d4bdcf1b9" translate="yes" xml:space="preserve">
          <source>If a BaseIndexer subclass is passed, calculates the window boundaries based on the defined &lt;code&gt;get_window_bounds&lt;/code&gt; method. Additional rolling keyword arguments, namely</source>
          <target state="translated">BaseIndexer 하위 클래스가 전달되면 정의 된 &lt;code&gt;get_window_bounds&lt;/code&gt; 메서드를 기반으로 창 경계를 계산합니다 . 추가 롤링 키워드 인수, 즉</target>
        </trans-unit>
        <trans-unit id="22fc0dda91ce0c6cfb03015af03fb9aeb3abddac" translate="yes" xml:space="preserve">
          <source>If a DataFrame column label is a valid Python variable name, the column can be accessed like an attribute:</source>
          <target state="translated">DataFrame 열 레이블이 유효한 Python 변수 이름 인 경우 열은 속성처럼 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ecaf8e0ca6ae047a74668fa9ea2d262449f1084" translate="yes" xml:space="preserve">
          <source>If a DataFrame contains homogeneously-typed data, the ndarray can actually be modified in-place, and the changes will be reflected in the data structure. For heterogeneous data (e.g. some of the DataFrame&amp;rsquo;s columns are not all the same dtype), this will not be the case. The values attribute itself, unlike the axis labels, cannot be assigned to.</source>
          <target state="translated">DataFrame에 동종 형식의 데이터가 포함 된 경우 ndarray는 실제로 제자리에서 수정 될 수 있으며 변경 사항은 데이터 구조에 반영됩니다. 이기종 데이터 (예 : DataFrame의 일부 열이 모두 동일한 dtype이 아님)의 경우에는 그렇지 않습니다. 값 속성 자체는 축 레이블과 달리 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5059a3623e6ca9dc7f9b266d2608545843106902" translate="yes" xml:space="preserve">
          <source>If a class cannot be constructed from this &amp;lsquo;string&amp;rsquo;.</source>
          <target state="translated">이 '문자열'에서 클래스를 구성 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="f9cedd3dcea3a4e2001323d4fb82c0c2fdae21be" translate="yes" xml:space="preserve">
          <source>If a column or index cannot be represented as an array of datetimes, say because of an unparsable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;. To parse an index or column with a mixture of timezones, specify &lt;code&gt;date_parser&lt;/code&gt; to be a partially-applied &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;utc=True&lt;/code&gt;. See &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;Parsing a CSV with mixed timezones&lt;/a&gt; for more.</source>
          <target state="translated">예를 들어 구문 분석 할 수없는 값이나 시간대의 혼합으로 인해 열 또는 인덱스를 날짜 / 시간의 배열로 표현할 수없는 경우 해당 열 또는 인덱스는 개체 데이터 형식으로 변경되지 않은 상태로 반환됩니다. 비표준 datetime 구문 분석의 경우 &lt;code&gt;pd.to_datetime&lt;/code&gt; 다음에 &lt;code&gt;pd.read_csv&lt;/code&gt; 사용 하십시오 . 시간대의 혼합물 또는 열 인덱스를 파싱 지정 &lt;code&gt;date_parser&lt;/code&gt; 가 부분적으로 적용 할 &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;utc=True&lt;/code&gt; . 자세한 내용 &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;은 혼합 시간대로 CSV 구문 분석을&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="c8c5f0454c9ec1fde1714f17e1d952b9f7a5cc52" translate="yes" xml:space="preserve">
          <source>If a column or index cannot be represented as an array of datetimes, say because of an unparseable value or a mixture of timezones, the column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;. To parse an index or column with a mixture of timezones, specify &lt;code&gt;date_parser&lt;/code&gt; to be a partially-applied &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;utc=True&lt;/code&gt;. See &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;Parsing a CSV with mixed timezones&lt;/a&gt; for more.</source>
          <target state="translated">열 또는 인덱스를 날짜 시간 배열로 표현할 수없는 경우 (예 : 구문 분석 할 수없는 값 또는 시간대 혼합으로 인해) 열 또는 인덱스는 변경되지 않은 개체 데이터 형식으로 반환됩니다. 비표준 날짜 시간 구문 분석의 경우 &lt;code&gt;pd.to_datetime&lt;/code&gt; 뒤에 &lt;code&gt;pd.read_csv&lt;/code&gt; 사용 하십시오 . 시간대를 혼합하여 인덱스 또는 열을 구문 분석하려면 &lt;code&gt;date_parser&lt;/code&gt; 를 &lt;code&gt;utc=True&lt;/code&gt; 와 함께 부분적으로 적용되는 &lt;a href=&quot;pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; &lt;/a&gt; 으로 지정 하십시오 . 자세한 내용은 &lt;a href=&quot;../../user_guide/io#io-csv-mixed-timezones&quot;&gt;시간대가 혼합 된 CSV 구문 분석을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb05dbd1a0c1f92f0ac524caef14f441578726d7" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;to_datetime()&lt;/code&gt;&lt;/a&gt; after &lt;code&gt;pd.read_csv&lt;/code&gt;.</source>
          <target state="translated">열 또는 인덱스에 구문 분석 할 수없는 날짜가 포함 된 경우 전체 열 또는 인덱스가 개체 데이터 형식으로 변경되지 않고 반환됩니다. 비표준 datetime 구문 분석의 경우 &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;to_datetime()&lt;/code&gt; &lt;/a&gt; 뒤에 &lt;code&gt;pd.read_csv&lt;/code&gt; () 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="024994997113b185624470243df16f27242d166f" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_excel&lt;/code&gt;.</source>
          <target state="translated">열 또는 인덱스에 구문 분석 할 수없는 날짜가 포함되어 있으면 전체 열 또는 인덱스가 변경되지 않은 상태로 개체 데이터 형식으로 반환됩니다. 비표준 날짜 시간 구문 분석의 경우 &lt;code&gt;pd.to_datetime&lt;/code&gt; 뒤에 &lt;code&gt;pd.read_excel&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e3d1c1348b7e96001002741ab684587a40cbd98" translate="yes" xml:space="preserve">
          <source>If a column or index contains an unparseable date, the entire column or index will be returned unaltered as an object data type. If you don`t want to parse some cells as date just change their type in Excel to &amp;ldquo;Text&amp;rdquo;. For non-standard datetime parsing, use &lt;code&gt;pd.to_datetime&lt;/code&gt; after &lt;code&gt;pd.read_excel&lt;/code&gt;.</source>
          <target state="translated">열 또는 인덱스에 구문 분석 할 수없는 날짜가 포함 된 경우 전체 열 또는 인덱스가 개체 데이터 형식으로 변경되지 않고 반환됩니다. 날짜로 일부 셀을 구문 분석하지 않으려면 Excel에서 해당 유형을 &quot;텍스트&quot;로 변경하십시오. 비표준 datetime 구문 분석의 경우 &lt;code&gt;pd.to_datetime&lt;/code&gt; 다음에 &lt;code&gt;pd.read_excel&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d2a0936634decaa45bcdb1077adb50caa2399d8" translate="yes" xml:space="preserve">
          <source>If a date does not meet the &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;timestamp limitations&lt;/a&gt;, passing errors=&amp;rsquo;ignore&amp;rsquo; will return the original input instead of raising any exception.</source>
          <target state="translated">날짜가 &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;타임 스탬프 제한을&lt;/a&gt; 충족하지 않으면 errors = 'ignore'를 전달하면 예외가 발생하지 않고 원래 입력이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="26d1dfa4eb8f3f636141624b253418278cce2bf6" translate="yes" xml:space="preserve">
          <source>If a date does not meet the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;timestamp limitations&lt;/a&gt;, passing errors=&amp;rsquo;ignore&amp;rsquo; will return the original input instead of raising any exception.</source>
          <target state="translated">날짜가 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#timeseries-timestamp-limits&quot;&gt;타임 스탬프 제한을&lt;/a&gt; 충족하지 않는 경우 errors = 'ignore'를 전달하면 예외가 발생하는 대신 원래 입력이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="78077d7035e3e1bf386c562ad6a6026d3c197e60" translate="yes" xml:space="preserve">
          <source>If a date is not on a valid date, the rollback and rollforward methods can be used to roll the date to the nearest valid date before/after the date.</source>
          <target state="translated">날짜가 유효한 날짜가 아닌 경우 롤백 및 롤 포워드 방법을 사용하여 날짜 전 / 후에 가장 가까운 유효한 날짜로 날짜를 롤백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d1bab9d594a6b54ccef73be2232f54e1cae5a4c" translate="yes" xml:space="preserve">
          <source>If a dict is passed, the sorted keys will be used as the &lt;code&gt;keys&lt;/code&gt; argument, unless it is passed, in which case the values will be selected (see below). Any None objects will be dropped silently unless they are all None in which case a ValueError will be raised.</source>
          <target state="translated">dict가 전달되면 정렬 된 키 가 전달되지 않으면 &lt;code&gt;keys&lt;/code&gt; 인수 로 사용되며, 이 경우 값이 선택됩니다 (아래 참조). 모든 None 객체는 모두 None이 아니면 자동으로 삭제됩니다.이 경우 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c64f440bc1e2f9dad75b50704b6ed07e14d9e40e" translate="yes" xml:space="preserve">
          <source>If a dtype is not specified, &lt;code&gt;data&lt;/code&gt; is passed through to &lt;code&gt;numpy.array()&lt;/code&gt;, and a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">dtype을 지정하지 않으면 &lt;code&gt;data&lt;/code&gt; 가 &lt;code&gt;numpy.array()&lt;/code&gt; 전달 되고 &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt; &lt;code&gt;arrays.PandasArray&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a750fe1b1c8b035fa42fb2c24abeccf5e0da7e3" translate="yes" xml:space="preserve">
          <source>If a dtype is not specified, pandas will infer the best dtype from the values. See the description of</source>
          <target state="translated">dtype이 지정되지 않은 경우 pandas는 값에서 최상의 dtype을 유추합니다. 설명 참조</target>
        </trans-unit>
        <trans-unit id="d9fe46615783e09d1c274ff3a49d146beb787260" translate="yes" xml:space="preserve">
          <source>If a file has one more column of data than the number of column names, the first column will be used as the &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s row names:</source>
          <target state="translated">파일에 열 이름 수보다 데이터 열이 하나 더있는 경우 첫 번째 열이 &lt;code&gt;DataFrame&lt;/code&gt; 의 행 이름 으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a7d71bcc1d2c6a1d61b732ec612b9df1bce2c33" translate="yes" xml:space="preserve">
          <source>If a filepath is provided for</source>
          <target state="translated">파일 경로가 제공된 경우</target>
        </trans-unit>
        <trans-unit id="a4a6eb6c7d1e4657646b6302b848a8747082bbc0" translate="yes" xml:space="preserve">
          <source>If a filepath is provided for &lt;code&gt;filepath_or_buffer&lt;/code&gt;, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</source>
          <target state="translated">파일 경로가 제공되면 &lt;code&gt;filepath_or_buffer&lt;/code&gt; , 메모리에 직접 파일 객체를지도하고 거기에서 데이터를 직접 액세스 할 수 있습니다. 이 옵션을 사용하면 더 이상 I / O 오버 헤드가 없으므로 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5b0e7c1c6bb842c26a2ad6521207d7b659ebca7" translate="yes" xml:space="preserve">
          <source>If a function with the same arguments as the one being deprecated exist, you can use the &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt;:</source>
          <target state="translated">더 이상 사용되지 않는 것과 동일한 인수를 가진 함수가 존재하면 &lt;code&gt;pandas.util._decorators.deprecate&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a55f5c7d16f500e6da16614d2adb42965248f34" translate="yes" xml:space="preserve">
          <source>If a label is in several intervals, you get the locations of all the relevant intervals.</source>
          <target state="translated">레이블이 여러 간격으로 있으면 모든 관련 간격의 위치를 ​​얻습니다.</target>
        </trans-unit>
        <trans-unit id="4f47b003de0809072edf3c049a0ce30a21e507fa" translate="yes" xml:space="preserve">
          <source>If a label is not contained, an exception is raised:</source>
          <target state="translated">레이블이 포함되지 않은 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f0da20aab515eb31a5cffcf23bf1728563e5abe6" translate="yes" xml:space="preserve">
          <source>If a list of dict/series is passed and the keys are all contained in the DataFrame&amp;rsquo;s index, the order of the columns in the resulting DataFrame will be unchanged.</source>
          <target state="translated">dict / series 목록이 전달되고 키가 모두 DataFrame의 색인에 포함 된 경우 결과 DataFrame의 열 순서는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2084be9d8e5985ceb2c1bbb180f91068c44c3ca" translate="yes" xml:space="preserve">
          <source>If a list/tuple of expressions is passed they will be combined via &lt;code&gt;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">표현식 목록 / 튜플이 전달되면 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 통해 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="e233f630f6e64777b8004e8848b98a69ced310c3" translate="yes" xml:space="preserve">
          <source>If a mapping is passed, the sorted keys will be used as the</source>
          <target state="translated">매핑이 전달되면 정렬 된 키가</target>
        </trans-unit>
        <trans-unit id="a57b14a0144398613fa46db6a643212d87f9fab6" translate="yes" xml:space="preserve">
          <source>If a non-default &lt;code&gt;orient&lt;/code&gt; was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see &lt;a href=&quot;#orient-options&quot;&gt;Orient Options&lt;/a&gt; for an overview.</source>
          <target state="translated">JSON으로 인코딩 할 때 기본이 아닌 &lt;code&gt;orient&lt;/code&gt; 이 사용 된 경우 디코딩이 합리적인 결과를 생성 할 수 있도록 여기에서 동일한 옵션을 전달해야합니다 . 개요는 방향 &lt;a href=&quot;#orient-options&quot;&gt;옵션&lt;/a&gt; 을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="30f27dc120bd0cd0936d6ea3e2605fa14175aaad" translate="yes" xml:space="preserve">
          <source>If a pandas object contains data with multiple dtypes &lt;em&gt;in a single column&lt;/em&gt;, the dtype of the column will be chosen to accommodate all of the data types (&lt;code&gt;object&lt;/code&gt; is the most general).</source>
          <target state="translated">pandas 객체가 &lt;em&gt;단일 열에&lt;/em&gt; 여러 dtype &lt;em&gt;을&lt;/em&gt; 가진 데이터를 포함하는 경우 모든 데이터 유형을 수용하도록 열의 dtype이 선택됩니다 ( &lt;code&gt;object&lt;/code&gt; 가 가장 일반적 임).</target>
        </trans-unit>
        <trans-unit id="3a932b347122ba17dc03c8f35de7e3581545858f" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed it is used to fill all missing values. Alternatively, an array-like &amp;lsquo;value&amp;rsquo; can be given. It&amp;rsquo;s expected that the array-like have the same length as &amp;lsquo;self&amp;rsquo;.</source>
          <target state="translated">스칼라 값이 전달되면 누락 된 모든 값을 채우는 데 사용됩니다. 또는 배열과 같은 '값'을 지정할 수 있습니다. 배열과 같은 길이는 'self'와 동일한 길이를 가질 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="f43ebe72554d837c1947c44cf9fbf7743e493fcf" translate="yes" xml:space="preserve">
          <source>If a str is passed, the color is the same for both negative and positive numbers. If 2-tuple/list is used, the first element is the color_negative and the second is the color_positive (eg: [&amp;lsquo;#d65f5f&amp;rsquo;, &amp;lsquo;#5fba7d&amp;rsquo;]).</source>
          <target state="translated">str이 전달되면 색상은 음수와 양수 모두 동일합니다. 2- 튜플 /리스트를 사용하는 경우 첫 번째 요소는 color_negative이고 두 번째 요소는 color_positive입니다 (예 : [ '# d65f5f', '# 5fba7d']).</target>
        </trans-unit>
        <trans-unit id="664c221db1d1a044cd6be831ba5898cec1c6e906" translate="yes" xml:space="preserve">
          <source>If a string is given, must be a name of the level If list-like must be names or ints of levels.</source>
          <target state="translated">문자열이 제공되면 레벨의 이름이어야합니다.리스트와 같은 경우 이름 또는 레벨의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cafbad4f4c6b2e30bd77049a6387059a8f8a90f9" translate="yes" xml:space="preserve">
          <source>If a string is given, must be a name of the level. If list-like must be names or ints of levels.</source>
          <target state="translated">문자열이 제공되면 레벨의 이름이어야합니다. list-like는 레벨의 이름 또는 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a1949bae823faece7ef8021ce74e5c7a237a24cd" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or indexes of levels.</source>
          <target state="translated">문자열이 제공되면 레벨의 이름이어야합니다. 목록과 같은 경우 요소는 이름 또는 레벨의 인덱스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2bd170078f20dc52e06bd86e8da7a8f33d73c15a" translate="yes" xml:space="preserve">
          <source>If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels.</source>
          <target state="translated">문자열이 제공되면 레벨의 이름이어야합니다. 목록과 같은 경우 요소는 이름 또는 레벨의 위치 인덱스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0e11c8b3b91fdf70e4a950b5de81db4fc235d3c5" translate="yes" xml:space="preserve">
          <source>If a string matches both a column name and an index level name then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</source>
          <target state="translated">문자열이 열 이름 및 인덱스 수준 이름과 모두 일치하면 경고가 발생하고 열이 우선합니다. 이로 인해 향후 버전에서 모호성 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7917632f71f22a6298fe99afe8da3a61861e243" translate="yes" xml:space="preserve">
          <source>If a string matches both a column name and an index level name, then a warning is issued and the column takes precedence. This will result in an ambiguity error in a future version.</source>
          <target state="translated">문자열이 열 이름 및 인덱스 수준 이름과 모두 일치하면 경고가 발생하고 열이 우선합니다. 이로 인해 향후 버전에서 모호성 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ab59153983f88bd3ac8734604519b5c38d644805" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all columns. If a dictionary, a mapping of column names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">문자열 또는 유형 인 경우 모든 열을 저장할 데이터 유형입니다. 사전 인 경우 열 이름 및 인덱스 (인덱싱 된)를 특정 데이터 유형에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="2cbe87791c4a51a042d70e2afa4264d8fe2def9f" translate="yes" xml:space="preserve">
          <source>If a string or type, the data type to store all index levels. If a dictionary, a mapping of index level names and indices (zero-indexed) to specific data types.</source>
          <target state="translated">문자열 또는 유형 인 경우 모든 색인 레벨을 저장할 데이터 유형입니다. 사전 인 경우 색인 레벨 이름 및 색인 (0 색인)을 특정 데이터 유형에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="55a5950721810aaccc29839d233355a54a0b4274" translate="yes" xml:space="preserve">
          <source>If a string, it will be used as Root Directory path when writing a partitioned dataset. By file-like object, we refer to objects with a write() method, such as a file handle (e.g. via builtin open function) or io.BytesIO. The engine fastparquet does not accept file-like objects. If path is None, a bytes object is returned.</source>
          <target state="translated">문자열 인 경우 파티션 된 데이터 세트를 작성할 때 루트 디렉토리 경로로 사용됩니다. 파일 류 객체로 우리는 파일 핸들 (예 : 내장 된 열기 함수를 통해) 또는 io.BytesIO와 같은 write () 메서드를 사용하여 객체를 참조합니다. 엔진 fastparquet는 파일 류 객체를 허용하지 않습니다. 경로가 None이면 bytes 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d189c526d90e423b055887f39bc14e0c56d23d2a" translate="yes" xml:space="preserve">
          <source>If a string, it will be used as Root Directory path.</source>
          <target state="translated">문자열 인 경우 루트 디렉토리 경로로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5aa15d15858711058094f491e41747189d9c0b7" translate="yes" xml:space="preserve">
          <source>If a subset of data is being parsed using the &lt;code&gt;usecols&lt;/code&gt; option, the &lt;code&gt;index_col&lt;/code&gt; specification is based on that subset, not the original data.</source>
          <target state="translated">&lt;code&gt;usecols&lt;/code&gt; 옵션을 사용하여 데이터 하위 집합을 구문 분석하는 경우 &lt;code&gt;index_col&lt;/code&gt; 사양은 원본 데이터가 아닌 해당 하위 집합을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="17ceab91a6aa8289bb5b8021e866580a53c5a0f2" translate="yes" xml:space="preserve">
          <source>If all elements are non-NA/null, returns None. Also returns None for empty Series/DataFrame.</source>
          <target state="translated">모든 요소가 NA / Null이 아닌 경우 None을 반환합니다. 빈 Series / DataFrame에 대해서도 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ff697a66f776f6bf9d5cb31605d3eecae945555" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than a label in</source>
          <target state="translated">색인의 모든 레이블이</target>
        </trans-unit>
        <trans-unit id="7703cb2a81c8223e4ff309ac97d763111e01337d" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than a label in &lt;code&gt;where&lt;/code&gt;, -1 is returned.</source>
          <target state="translated">색인의 모든 레이블이 &lt;code&gt;where&lt;/code&gt; 의 레이블보다 늦으면 -1이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ba174535c6272f0b997374d38b2209ea810429e1" translate="yes" xml:space="preserve">
          <source>If all of the labels in the index are later than the passed label, NaN is returned.</source>
          <target state="translated">인덱스의 모든 레이블이 전달 된 레이블보다 늦으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c1e29cecb8deb1bb9249dfbe69e58b24b5165bd3" translate="yes" xml:space="preserve">
          <source>If allow_fill=True and fill_value is not None, indices specified by -1 is regarded as NA. If Index doesn&amp;rsquo;t hold NA, raise ValueError</source>
          <target state="translated">allow_fill = True이고 fill_value가 None이 아닌 경우, -1로 지정된 인덱스는 NA로 간주됩니다. 인덱스가 NA를 보유하지 않으면 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1054a2c112cb5a2006f1be297346faf1ff6466b" translate="yes" xml:space="preserve">
          <source>If allow_fill=True and fill_value is not None, indices specified by -1 is regarded as NA. If Index doesn&amp;rsquo;t hold NA, raise ValueError.</source>
          <target state="translated">allow_fill = True이고 fill_value가 None이 아닌 경우 -1로 지정된 인덱스는 NA로 간주됩니다. Index에 NA가 없으면 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ff14634826d79012ed764cfa8de5a9838978cc57" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table column. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">배열이 전달되면 데이터와 길이가 같아야합니다. 목록은 다른 유형을 포함 할 수 있습니다 (목록 제외). 피벗 테이블 열에서 그룹화 할 키입니다. 배열이 전달되면 열 값과 같은 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c5ee36569ccce557bf8297b686d33c4ab619682" translate="yes" xml:space="preserve">
          <source>If an array is passed, it must be the same length as the data. The list can contain any of the other types (except list). Keys to group by on the pivot table index. If an array is passed, it is being used as the same manner as column values.</source>
          <target state="translated">배열이 전달되면 데이터와 길이가 같아야합니다. 목록은 다른 유형을 포함 할 수 있습니다 (목록 제외). 피벗 테이블 인덱스에서 그룹화 할 키입니다. 배열이 전달되면 열 값과 같은 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e71a78ce13f5e4a60eac8f95606f6a518f5b879" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;code&gt;ordered=True&lt;/code&gt; is given but no</source>
          <target state="translated">명시 적 &lt;code&gt;ordered=True&lt;/code&gt; 가 주어졌지만 그렇지 않은 경우</target>
        </trans-unit>
        <trans-unit id="af8c676f3147891a205dd28d61aaddbbe77519ec" translate="yes" xml:space="preserve">
          <source>If an explicit &lt;code&gt;ordered=True&lt;/code&gt; is given but no &lt;code&gt;categories&lt;/code&gt; and the &lt;code&gt;values&lt;/code&gt; are not sortable.</source>
          <target state="translated">명시 적 경우 &lt;code&gt;ordered=True&lt;/code&gt; 주어진다하지만 &lt;code&gt;categories&lt;/code&gt; 와 &lt;code&gt;values&lt;/code&gt; 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e237695f0996c6449ac5d388a3e4cbbe78266cb" translate="yes" xml:space="preserve">
          <source>If an index is passed, the values in data corresponding to the labels in the index will be pulled out.</source>
          <target state="translated">인덱스가 전달되면 인덱스의 레이블에 해당하는 데이터의 값이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8259a6d68eab8c19d5e0eabd67405da8ab57b1f5" translate="yes" xml:space="preserve">
          <source>If an indexed key is passed and its index is unalignable to the frame index.</source>
          <target state="translated">인덱싱 된 키가 전달되고 인덱스가 프레임 인덱스에 맞지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="66446b4ed963dd0e69016b68d9c4e0f33d4ddf75" translate="yes" xml:space="preserve">
          <source>If any items are not found.</source>
          <target state="translated">항목을 찾을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="a811d63c53b8811ca58b647eaf1fc34cafb5488e" translate="yes" xml:space="preserve">
          <source>If any kind of string dtype is passed in.</source>
          <target state="translated">문자열 dtype이 전달 된 경우</target>
        </trans-unit>
        <trans-unit id="737e8df6f3276db9f6615ef85a21d500c5c61d47" translate="yes" xml:space="preserve">
          <source>If any method argument other than the default of None is specified as these are not yet implemented.</source>
          <target state="translated">기본값 None이 아닌 메소드 인수가 아직 구현되지 않았으므로 지정된 경우.</target>
        </trans-unit>
        <trans-unit id="70c61d6e01ff0aae044349ecdba7bbb1250fe8c6" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis and &amp;ldquo;errors=&amp;rsquo;raise&amp;rsquo;&amp;rdquo;.</source>
          <target state="translated">선택한 축에 레이블이 없으면 &quot;errors = 'raise'&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f11beca5c6ae8017f4b7406cc4296549080b22d3" translate="yes" xml:space="preserve">
          <source>If any of the labels is not found in the selected axis.</source>
          <target state="translated">선택한 축에 레이블이없는 경우.</target>
        </trans-unit>
        <trans-unit id="2320b14f67eb9ec3b540a8bb24814b91f5c2d50d" translate="yes" xml:space="preserve">
          <source>If any of the levels passed to &lt;code&gt;set_levels()&lt;/code&gt; exceeds the existing length, all of the values from that argument will be stored in the MultiIndex levels, though the values will be truncated in the MultiIndex output.</source>
          <target state="translated">&lt;code&gt;set_levels()&lt;/code&gt; 전달 된 수준 중 하나가 기존 길이를 초과하는 경우 해당 인수의 모든 값은 MultiIndex 출력에서 ​​잘리지 만 MultiIndex 수준에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="98671b51d92b145da7c4a68f0d6180b02179c533" translate="yes" xml:space="preserve">
          <source>If any of the list items is not a string object, the result of the join will be</source>
          <target state="translated">목록 항목이 문자열 개체가 아닌 경우 조인 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47983fc844672129f9ac1881a49d6e66e982428b" translate="yes" xml:space="preserve">
          <source>If any of the list items is not a string object, the result of the join will be &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">목록 항목 중 하나라도 문자열 객체가 아닌 경우 결합 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74b321536b7a61a75e369e0d3490288a3ea2fe2a" translate="yes" xml:space="preserve">
          <source>If any of these defaults are not what you want, or if you want to be explicit about how missing values are handled, consider using &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt;&lt;code&gt;fillna()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe.dropna#pandas.DataFrame.dropna&quot;&gt;&lt;code&gt;dropna()&lt;/code&gt;&lt;/a&gt; before plotting.</source>
          <target state="translated">이러한 기본값 중 하나라도 원하는 것이 아니거나 누락 된 값을 처리하는 방법을 명시하려면 플로팅하기 전에 &lt;a href=&quot;../reference/api/pandas.dataframe.fillna#pandas.DataFrame.fillna&quot;&gt; &lt;code&gt;fillna()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/api/pandas.dataframe.dropna#pandas.DataFrame.dropna&quot;&gt; &lt;code&gt;dropna()&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="abc14636cf1e86ec565e13cf216055ad1c0f39df" translate="yes" xml:space="preserve">
          <source>If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with</source>
          <target state="translated">접두사를 추가하는 경우 사용할 구분 기호 / 구분 기호입니다. 또는 목록이나 사전을 다음과 같이 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="1979d89f7de4b9fbb39ec05f540083098724a80f" translate="yes" xml:space="preserve">
          <source>If appending prefix, separator/delimiter to use. Or pass a list or dictionary as with &lt;code&gt;prefix&lt;/code&gt;.</source>
          <target state="translated">접두사를 추가하는 경우 사용할 구분 기호 / 구분 기호입니다. 또는 &lt;code&gt;prefix&lt;/code&gt; 와 같이 목록이나 사전을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="a11a511e2ae2cc8424f72edc278dc39628207610" translate="yes" xml:space="preserve">
          <source>If applicable, we highly recommend that you implement &lt;code&gt;__array_ufunc__&lt;/code&gt; in your extension array to avoid coercion to an ndarray. See &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;the numpy documentation&lt;/a&gt; for an example.</source>
          <target state="translated">해당되는 경우 확장 배열에 &lt;code&gt;__array_ufunc__&lt;/code&gt; 를 구현하여 ndarray 에 대한 강제를 피하는 것이 좋습니다 . 예제 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html&quot;&gt;는 numpy 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="072e26cb4593102e0bb6adf3546c35bd36d7bb05" translate="yes" xml:space="preserve">
          <source>If applying compression use the fletcher32 checksum.</source>
          <target state="translated">압축을 적용하는 경우 fletcher32 체크섬을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53cfe1a79643b5445944cea852309386c3712f73" translate="yes" xml:space="preserve">
          <source>If at least one of the two is absent, but the index is sorted, and can be compared against start and stop labels, then slicing will still work as expected, by selecting labels which &lt;em&gt;rank&lt;/em&gt; between the two:</source>
          <target state="translated">둘 중 하나 이상이 없지만 인덱스가 정렬되어 있고 시작 및 중지 레이블과 비교할 수있는 경우 둘 사이에 &lt;em&gt;순위&lt;/em&gt; 를 &lt;em&gt;매기&lt;/em&gt; 는 레이블을 선택하여 슬라이싱이 예상대로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="9f8772725018c792397868923cdb717ae3175a40" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, convert a specific level. Otherwise must be None</source>
          <target state="translated">축이 다중 인덱스 인 경우 특정 수준을 변환합니다. 그렇지 않으면 없음이어야합니다</target>
        </trans-unit>
        <trans-unit id="87391f1e1e648bf058bee7a9654161130eecfc7b" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, localize a specific level. Otherwise must be None</source>
          <target state="translated">축이 다중 인덱스 인 경우 특정 수준을 지역화합니다. 그렇지 않으면 없음이어야합니다</target>
        </trans-unit>
        <trans-unit id="8a50a2305a89159f20c3e526bded6db5fec79fba" translate="yes" xml:space="preserve">
          <source>If axis ia a MultiIndex, localize a specific level. Otherwise must be None.</source>
          <target state="translated">축이 MultiIndex 인 경우 특정 수준을 지역화합니다. 그렇지 않으면 None이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4e1261ab8f79e64a44def90e5c786465d95ec434" translate="yes" xml:space="preserve">
          <source>If axis is 0 or &amp;lsquo;index&amp;rsquo; the result will be a Series. The resulting index will be a MultiIndex with &amp;lsquo;self&amp;rsquo; and &amp;lsquo;other&amp;rsquo; stacked alternately at the inner level.</source>
          <target state="translated">축이 0 또는 '인덱스'이면 결과는 시리즈가됩니다. 결과 인덱스는 내부 수준에서 'self'와 'other'가 교대로 쌓인 MultiIndex가됩니다.</target>
        </trans-unit>
        <trans-unit id="ba63f643d6684b1fc4f7718c26beec37bedbe5f2" translate="yes" xml:space="preserve">
          <source>If axis is 1 or &amp;lsquo;columns&amp;rsquo; the result will be a DataFrame. It will have two columns namely &amp;lsquo;self&amp;rsquo; and &amp;lsquo;other&amp;rsquo;.</source>
          <target state="translated">축이 1 또는 '열'이면 결과는 DataFrame이됩니다. 'self'와 'other'라는 두 개의 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dca845052cf9e007f580b3f733e1fac9e0281428" translate="yes" xml:space="preserve">
          <source>If axis is a MultiIndex, convert a specific level. Otherwise must be None.</source>
          <target state="translated">축이 MultiIndex이면 특정 수준을 변환합니다. 그렇지 않으면 None이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3d63325924797f142a9e6c13d5c6dd030cce6e4" translate="yes" xml:space="preserve">
          <source>If axis labels are not passed, they will be constructed from the input data based on common sense rules.</source>
          <target state="translated">축 레이블이 전달되지 않으면 상식 규칙에 따라 입력 데이터에서 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e69e66617e975b4f927b06bc80c35783ba32c625" translate="yes" xml:space="preserve">
          <source>If bin edges are not unique, raise ValueError or drop non-uniques.</source>
          <target state="translated">빈 가장자리가 고유하지 않으면 ValueError를 높이거나 고유하지 않은 것을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="8999a3f1324f4044aba9bb76851d3a780b4c0b9d" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;header&lt;/code&gt; and &lt;code&gt;skiprows&lt;/code&gt; are specified, &lt;code&gt;header&lt;/code&gt; will be relative to the end of &lt;code&gt;skiprows&lt;/code&gt;. For example:</source>
          <target state="translated">두 경우 &lt;code&gt;header&lt;/code&gt; 와 &lt;code&gt;skiprows&lt;/code&gt; 가 지정, &lt;code&gt;header&lt;/code&gt; 의 끝을 기준으로 할 것이다 &lt;code&gt;skiprows&lt;/code&gt; . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="253d364dc8215c289f304194e1235e5c7cb7fc6c" translate="yes" xml:space="preserve">
          <source>If both dayfirst and yearfirst are True, yearfirst is preceded (same as dateutil).</source>
          <target state="translated">dayfirst와 yearfirst가 모두 True이면 yearfirst가 선행됩니다 (dateutil과 동일).</target>
        </trans-unit>
        <trans-unit id="20ec4100e04e070e2add532e3371209cd96960d1" translate="yes" xml:space="preserve">
          <source>If both of &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; are empty</source>
          <target state="translated">모두 경우 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 비어 있습니다</target>
        </trans-unit>
        <trans-unit id="cc54c1baccafe31b1df94f88241fa0c566479663" translate="yes" xml:space="preserve">
          <source>If buf is None, returns the result as a string. Otherwise returns None.</source>
          <target state="translated">buf가 None이면 결과를 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ab952ef7ef22e79ae1ce8234aa416ed5979fad75" translate="yes" xml:space="preserve">
          <source>If buf is None, returns the resulting LateX format as a string. Otherwise returns None.</source>
          <target state="translated">buf가 None이면 결과 LateX 형식을 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9d07940e53f336322c19c2cd577417a583dce50" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True. An example of a valid callable argument would be &lt;code&gt;lambda x: x.upper() in
['AAA', 'BBB', 'DDD']&lt;/code&gt;. Using this parameter results in much faster parsing time and lower memory usage.</source>
          <target state="translated">호출 가능하면 호출 가능 함수는 열 이름과 비교하여 호출 가능 함수가 True로 평가되는 이름을 리턴합니다. 유효한 호출 가능한 인수의 예는 &lt;code&gt;lambda x: x.upper() in ['AAA', 'BBB', 'DDD']&lt;/code&gt; . 이 매개 변수를 사용하면 구문 분석 시간이 훨씬 빨라지고 메모리 사용량이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="f28da403364b3ca9b72b658dafe69a7d983229a8" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:</source>
          <target state="translated">호출 가능하면 호출 가능 함수는 열 이름과 비교하여 호출 가능 함수가 True로 평가되는 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9cc56eeda19feaa07d8092a737946e7c1b49b405" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt;.</source>
          <target state="translated">호출 가능하면 호출 가능 함수는 행 인덱스에 대해 평가되어 행을 건너 뛰어야하면 True를, 그렇지 않으면 False를 리턴합니다. 유효한 호출 가능한 인수의 예는 &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e005dc46520dc329b9e3c5ee6c0162eb68f3a28a" translate="yes" xml:space="preserve">
          <source>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise:</source>
          <target state="translated">호출 가능한 경우 호출 가능한 함수는 행 인덱스에 대해 평가되며 행을 건너 뛰어야하는 경우 True를 반환하고 그렇지 않으면 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="513ede3f3a8cf7e7586af86037ccc686ffc6ba4a" translate="yes" xml:space="preserve">
          <source>If callable, then evaluate each column name against it and parse the column if the callable returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">호출 가능하면 각 열 이름을 평가하고 호출 가능이 &lt;code&gt;True&lt;/code&gt; 를 리턴하면 열을 구문 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="51a1daa823350ace6cba99a153f88fcde66e034b" translate="yes" xml:space="preserve">
          <source>If categorical data is ordered (&lt;code&gt;s.cat.ordered == True&lt;/code&gt;), then the order of the categories has a meaning and certain operations are possible. If the categorical is unordered, &lt;code&gt;.min()/.max()&lt;/code&gt; will raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">범주 형 데이터가 정렬 된 경우 ( &lt;code&gt;s.cat.ordered == True&lt;/code&gt; ) 범주의 순서에는 의미가 있으며 특정 작업이 가능합니다. 범주가 정렬되지 않은 경우 &lt;code&gt;.min()/.max()&lt;/code&gt; 는 &lt;code&gt;TypeError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="685d3f02d43beae9f293bf9f8747df3c13b4c5c6" translate="yes" xml:space="preserve">
          <source>If columns are a MultiIndex then use this level to melt.</source>
          <target state="translated">열이 다중 인덱스 인 경우이 수준을 사용하여 녹입니다.</target>
        </trans-unit>
        <trans-unit id="73f524f5a96443526a0f752ccc0a0f45d33e2689" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timedelta data.</source>
          <target state="translated">데이터가 없음 인 경우 일반 타임 델타 데이터 생성시 시작점으로 시작이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff093965800686fc456d1ec74cddd873c03a2a06" translate="yes" xml:space="preserve">
          <source>If data is None, start is used as the start point in generating regular timestamp data.</source>
          <target state="translated">데이터가 없음 인 경우 일반 타임 스탬프 데이터를 생성 할 때 시작점이 시작으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dae62288e37f2c075b791322d9beac67a5a2965c" translate="yes" xml:space="preserve">
          <source>If data is None, used as the start point in generating regular period data.</source>
          <target state="translated">데이터가 없음 인 경우 정규 기간 데이터 생성시 시작점으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f945356c77bbf782bb9b78eeeea13f0a8f770df9" translate="yes" xml:space="preserve">
          <source>If datetimes contain timezone information</source>
          <target state="translated">날짜 시간에 시간대 정보가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="151a8d67020136db3746f6fd54d019f0751e502a" translate="yes" xml:space="preserve">
          <source>If dropna, will take the nth non-null row, dropna is either &amp;lsquo;all&amp;rsquo; or &amp;lsquo;any&amp;rsquo;; this is equivalent to calling dropna(how=dropna) before the groupby.</source>
          <target state="translated">dropna가 null이 아닌 n 번째 행을 취하는 경우 dropna는 'all'또는 'any'입니다. 이것은 그룹별로 dropna (how = dropna)를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec063cf3e1fb3772513c2c6ae92ef2ab32d9ee75" translate="yes" xml:space="preserve">
          <source>If dtype is None, we find the dtype that best fits the data. If an actual dtype is provided, we coerce to that dtype if it&amp;rsquo;s safe. Otherwise, an error will be raised.</source>
          <target state="translated">dtype이 None이면 데이터에 가장 적합한 dtype을 찾습니다. 실제 dtype이 제공되면 안전하다면 dtype으로 강제 변환합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c23c90863643c36250aa1190db0145034944681e" translate="yes" xml:space="preserve">
          <source>If error_bad_lines is &lt;code&gt;False&lt;/code&gt;, and warn_bad_lines is &lt;code&gt;True&lt;/code&gt;, a warning for each &amp;ldquo;bad line&amp;rdquo; will be output.</source>
          <target state="translated">error_bad_lines가 &lt;code&gt;False&lt;/code&gt; 이고 warn_bad_lines가 &lt;code&gt;True&lt;/code&gt; 이면 각 &quot;불량 라인&quot;에 대한 경고가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="5291444796253761cd9ba2fe4457299e7f8a08a6" translate="yes" xml:space="preserve">
          <source>If error_bad_lines is False, and warn_bad_lines is True, a warning for each &amp;ldquo;bad line&amp;rdquo; will be output.</source>
          <target state="translated">error_bad_lines가 False이고 warn_bad_lines가 True 인 경우 각&amp;ldquo;잘못된 라인&amp;rdquo;에 대한 경고가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c76ec1a67aef33e908ab260e62c8b2c8f08ade" translate="yes" xml:space="preserve">
          <source>If everything looks good, you are ready to make a pull request. A pull request is how code from a local repository becomes available to the GitHub community and can be looked at and eventually merged into the master version. This pull request and its associated changes will eventually be committed to the master branch and available in the next release. To submit a pull request:</source>
          <target state="translated">모든 것이 좋아 보인다면, 풀 요청을 할 준비가 된 것입니다. 풀 요청은 로컬 리포지토리의 코드를 GitHub 커뮤니티에서 사용할 수있게되어 마스터 버전으로보고 병합 될 수있는 방법입니다. 이 풀 요청 및 관련 변경 사항은 결국 마스터 브랜치에 커밋되어 다음 릴리스에서 사용할 수 있습니다. 풀 요청을 제출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6d2b4f1f9225dd4aceca893c869ab3d65bdb1668" translate="yes" xml:space="preserve">
          <source>If for a certain row the number of found splits &amp;lt;</source>
          <target state="translated">특정 행에 대해 발견 된 분할 수가 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="23c9060c54c6bb6c39f0e98425258486180b9e59" translate="yes" xml:space="preserve">
          <source>If for a certain row the number of found splits &amp;lt; &lt;code&gt;n&lt;/code&gt;, append &lt;code&gt;None&lt;/code&gt; for padding up to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;expand=True&lt;/code&gt;</source>
          <target state="translated">특정 행에 대해 발견 된 분할 수가 &amp;lt; &lt;code&gt;n&lt;/code&gt; 인 경우 &lt;code&gt;expand=True&lt;/code&gt; 인 경우 최대 &lt;code&gt;n&lt;/code&gt; 까지 채우기 위해 &lt;code&gt;None&lt;/code&gt; 을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4f1bbf12bd4be481a7b76931c444ac723ac7f23e" translate="yes" xml:space="preserve">
          <source>If for some reason you have a column named &lt;code&gt;index&lt;/code&gt;, then you can refer to the index as &lt;code&gt;ilevel_0&lt;/code&gt; as well, but at this point you should consider renaming your columns to something less ambiguous.</source>
          <target state="translated">어떤 이유로 &lt;code&gt;index&lt;/code&gt; 라는 열이있는 경우 인덱스를 &lt;code&gt;ilevel_0&lt;/code&gt; 로 참조 할 수도 있지만이 시점에서 열 이름을 덜 모호한 것으로 바꾸는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="332a16903c151c1ecb224e10fcac795483da5669" translate="yes" xml:space="preserve">
          <source>If found splits &amp;gt;</source>
          <target state="translated">분할이 발견 된 경우&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6211ffb8fa3fb2fd37ec09f2b6296b76ea53b066" translate="yes" xml:space="preserve">
          <source>If found splits &amp;gt; &lt;code&gt;n&lt;/code&gt;, make first &lt;code&gt;n&lt;/code&gt; splits only</source>
          <target state="translated">찾은 splits&amp;gt; &lt;code&gt;n&lt;/code&gt; 이면 처음 &lt;code&gt;n&lt;/code&gt; 개의 분할 만 만듭니다.</target>
        </trans-unit>
        <trans-unit id="967baafdae5ca9570712f0e926ab45321d817a83" translate="yes" xml:space="preserve">
          <source>If found splits &amp;lt;=</source>
          <target state="translated">발견 된 경우 분할 &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="b37fc31feaa05a56a504bc57a3dc5a6d1aa79bdc" translate="yes" xml:space="preserve">
          <source>If found splits &amp;lt;= &lt;code&gt;n&lt;/code&gt;, make all splits</source>
          <target state="translated">발견 된 분할이 &amp;lt;= &lt;code&gt;n&lt;/code&gt; 이면 모든 분할을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="faedb07d74ab41f0e6f62f0f259b9779f728a236" translate="yes" xml:space="preserve">
          <source>If freq is an invalid frequency</source>
          <target state="translated">주파수가 유효하지 않은 주파수 인 경우</target>
        </trans-unit>
        <trans-unit id="803c3a3090c279b46259470fbbb792974d7f901b" translate="yes" xml:space="preserve">
          <source>If freq is not specified then tries to use the freq or inferred_freq attributes of the index. If neither of those attributes exist, a ValueError is thrown</source>
          <target state="translated">freq를 지정하지 않으면 인덱스의 freq 또는 inferred_freq 속성을 사용하려고합니다. 이러한 속성 중 어느 것도 존재하지 않으면 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="913b44532f3a53f43a3f8beb187957afcd4c09d7" translate="yes" xml:space="preserve">
          <source>If freq is passed, the index will be increased using the periods and the freq.</source>
          <target state="translated">freq가 전달되면 지수는 마침표와 빈도를 사용하여 증가합니다.</target>
        </trans-unit>
        <trans-unit id="cd7e199c3229ad1a29b7396ccb73cb9b8b33ec4f" translate="yes" xml:space="preserve">
          <source>If func returns a Series object the result will be a DataFrame.</source>
          <target state="translated">func이 Series 객체를 반환하면 결과는 DataFrame이됩니다.</target>
        </trans-unit>
        <trans-unit id="e05cd03bb9478611824232e1b320bc090b5b4903" translate="yes" xml:space="preserve">
          <source>If given, it will use the</source>
          <target state="translated">주어진 경우</target>
        </trans-unit>
        <trans-unit id="97e40162438268f3434fb42f4961c0381c5a410b" translate="yes" xml:space="preserve">
          <source>If given, it will use the &lt;code&gt;fig&lt;/code&gt; reference for plotting instead of creating a new one with default parameters.</source>
          <target state="translated">주어진 경우, 기본 매개 변수로 새 참조를 작성하는 대신 플로팅에 &lt;code&gt;fig&lt;/code&gt; 참조를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7c905670577eb23cd045f70e74e41dc154603058" translate="yes" xml:space="preserve">
          <source>If grouper is PeriodIndex and</source>
          <target state="translated">grouper가 PeriodIndex이고</target>
        </trans-unit>
        <trans-unit id="4f948fed8d6912efb15a4f875d827717c7e831f0" translate="yes" xml:space="preserve">
          <source>If grouper is PeriodIndex and &lt;code&gt;freq&lt;/code&gt; parameter is passed.</source>
          <target state="translated">그룹화가 PeriodIndex이고 &lt;code&gt;freq&lt;/code&gt; 매개 변수가 전달 된 경우.</target>
        </trans-unit>
        <trans-unit id="2153311a52299005ad6b900f85d75a5bc89c102d" translate="yes" xml:space="preserve">
          <source>If implementing NumPy&amp;rsquo;s &lt;code&gt;__array_ufunc__&lt;/code&gt; interface, pandas expects that</source>
          <target state="translated">NumPy의 &lt;code&gt;__array_ufunc__&lt;/code&gt; 인터페이스를 구현하면 팬더는 다음을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="40c691f0e2bf83f7f8c92678a022cd114c946bdb" translate="yes" xml:space="preserve">
          <source>If index resolution is second, then the minute-accurate timestamp gives a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">인덱스 해상도가 초인 경우 분 단위의 정확한 타임 스탬프는 &lt;code&gt;Series&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b739f8adfb8ff0aa6b270221577514d1891e01fa" translate="yes" xml:space="preserve">
          <source>If instead you don&amp;rsquo;t want to or cannot name your index, you can use the name &lt;code&gt;index&lt;/code&gt; in your query expression:</source>
          <target state="translated">대신 색인 이름을 지정하지 않거나 할 수없는 경우 쿼리 표현식에서 이름 &lt;code&gt;index&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b5b6c6275ac36d8c29c9ef0f491f5feaa9d6ffc" translate="yes" xml:space="preserve">
          <source>If int and &amp;ldquo;stop&amp;rdquo; is not given, interpreted as &amp;ldquo;stop&amp;rdquo; instead.</source>
          <target state="translated">int 및 &quot;stop&quot;이 제공되지 않으면 대신 &quot;stop&quot;으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="6ef44adf7e998129a0e17630965a27165eef6f11" translate="yes" xml:space="preserve">
          <source>If int, array-like, or BitGenerator (NumPy&amp;gt;=1.17), seed for random number generator If np.random.RandomState, use as numpy RandomState object.</source>
          <target state="translated">int, array-like 또는 BitGenerator (NumPy&amp;gt; = 1.17) 인 경우 난수 생성기의 시드 np.random.RandomState 인 경우 numpy RandomState 객체로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3b7b2547e4136f8605b954d25571fea98abec426" translate="yes" xml:space="preserve">
          <source>If int, then indicates last column to be parsed.</source>
          <target state="translated">int이면 구문 분석 할 마지막 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3bb72fad3e82acae71dc7993a1447557d62c8a5b" translate="yes" xml:space="preserve">
          <source>If io is not a buffer or path, this must be set to identify io. Acceptable values are None or xlrd.</source>
          <target state="translated">io가 버퍼 또는 경로가 아닌 경우 io를 식별하도록 설정해야합니다. 허용 가능한 값은 None 또는 xlrd입니다.</target>
        </trans-unit>
        <trans-unit id="9263cf78203e7295e057b98deb02db9d1dd510c4" translate="yes" xml:space="preserve">
          <source>If io is not a buffer or path, this must be set to identify io. Supported engines: &amp;ldquo;xlrd&amp;rdquo;, &amp;ldquo;openpyxl&amp;rdquo;, &amp;ldquo;odf&amp;rdquo;, &amp;ldquo;pyxlsb&amp;rdquo;. Engine compatibility :</source>
          <target state="translated">io가 버퍼 또는 경로가 아닌 경우 io를 식별하도록 설정해야합니다. 지원되는 엔진 : &quot;xlrd&quot;, &quot;openpyxl&quot;, &quot;odf&quot;, &quot;pyxlsb&quot;. 엔진 호환성 :</target>
        </trans-unit>
        <trans-unit id="43ca6d2682f5657f7e98ea4373774e219e824496" translate="yes" xml:space="preserve">
          <source>If its an offset then this will be the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes.</source>
          <target state="translated">오프셋이면 각 창의 기간이됩니다. 각 창은 기간에 포함 된 관측치를 기반으로 크기가 가변됩니다. 이것은 datetimelike 인덱스에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e7b90b33df08c56801541d97b52863d5cc1a2208" translate="yes" xml:space="preserve">
          <source>If its an offset then this will be the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes. This is new in 0.19.0</source>
          <target state="translated">오프셋이면 각 창의 시간이됩니다. 각 기간은 기간에 포함 된 관측치에 따라 다양한 크기로 조정됩니다. datetimelike 인덱스에만 유효합니다. 0.19.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="ad91bd2fcbc8853d5dc9cba2938f0dd911cf8a6d" translate="yes" xml:space="preserve">
          <source>If keep_tz is False:</source>
          <target state="translated">keep_tz가 False 인 경우 :</target>
        </trans-unit>
        <trans-unit id="baf1483fae1fac9f24a7c2ddac2906ea600716bb" translate="yes" xml:space="preserve">
          <source>If keep_tz is True:</source>
          <target state="translated">keep_tz가 True 인 경우 :</target>
        </trans-unit>
        <trans-unit id="5bb59e5d8fa791e8b043037739659a61a93a3a51" translate="yes" xml:space="preserve">
          <source>If label is contained, will be reference to calling Series, otherwise a new object.</source>
          <target state="translated">label이 포함 된 경우 Series 호출에 대한 참조이며, 그렇지 않으면 새 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d8f134714528b444920506c4fe5aa496b4202bff" translate="yes" xml:space="preserve">
          <source>If label is not contained, a new object is created with the label placed at the end of the result index.</source>
          <target state="translated">label이 포함되어 있지 않으면 결과 색인의 끝에 레이블이있는 새 오브젝트가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a824931c7f88c06d3b1aacfaeeb1337548e955e0" translate="yes" xml:space="preserve">
          <source>If label pair is contained, will be reference to calling DataFrame, otherwise a new object.</source>
          <target state="translated">레이블 쌍이 포함 된 경우 DataFrame 호출에 대한 참조이며 그렇지 않으면 새 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c00e1450820324efbc32fd35d064eb356db799b1" translate="yes" xml:space="preserve">
          <source>If level is specified, then, DataFrame is returned; otherwise, Series is returned.</source>
          <target state="translated">레벨이 지정되면 DataFrame이 리턴됩니다. 그렇지 않으면 Series가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7877da1e50e258680542b6af26d6fd85ecae2065" translate="yes" xml:space="preserve">
          <source>If level is specified, then, Series is returned; otherwise, scalar is returned.</source>
          <target state="translated">레벨이 지정되면 Series가 리턴됩니다. 그렇지 않으면 스칼라가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ca17fab71c58fc25bab74d5c9db224c9c0dc9b57" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled in this direction.</source>
          <target state="translated">제한이 지정되면 연속 NaN이이 방향으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="eed73a2e297bebfb2ce480434de0e2542a0badfc" translate="yes" xml:space="preserve">
          <source>If limit is specified, consecutive NaNs will be filled with this restriction.</source>
          <target state="translated">제한이 지정되면 연속 NaN이이 제한으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="88c5560ab95765eb920a208bc7fb13404935ff90" translate="yes" xml:space="preserve">
          <source>If limit is specified:</source>
          <target state="translated">제한이 지정된 경우 :</target>
        </trans-unit>
        <trans-unit id="7caf98f1a23fbe99f3eecc43311325e017b47681" translate="yes" xml:space="preserve">
          <source>If list of functions passed, the resulting pivot table will have hierarchical columns whose top level are the function names (inferred from the function objects themselves) If dict is passed, the key is column to aggregate and value is function or list of functions</source>
          <target state="translated">함수 목록이 전달되면 결과 피벗 테이블에는 최상위 수준이 함수 이름 인 계층 열이 있습니다 (함수 개체 자체에서 유추 됨) dict가 전달되면 키는 집계 할 열이고 값은 함수 또는 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="50b3274a3da951ffb461e11c79f73edf459c48e7" translate="yes" xml:space="preserve">
          <source>If list of functions passed, the resulting pivot table will have hierarchical columns whose top level are the function names (inferred from the function objects themselves) If dict is passed, the key is column to aggregate and value is function or list of functions.</source>
          <target state="translated">함수 목록이 전달되면 결과 피벗 테이블에는 최상위 수준이 함수 이름 (함수 개체 자체에서 유추 됨) 인 계층 적 열이 있습니다. dict가 전달되면 키는 집계 할 열이고 값은 함수 또는 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1d66f9c3628338003e89214bb889ccfda13c37c0" translate="yes" xml:space="preserve">
          <source>If list of int, then indicates list of column numbers to be parsed.</source>
          <target state="translated">int의 목록 인 경우 구문 분석 할 열 번호 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5fe49dea595acc90377978d171ab9c0a0e7439a2" translate="yes" xml:space="preserve">
          <source>If list of string, then indicates list of column names to be parsed.</source>
          <target state="translated">문자열 목록 인 경우 구문 분석 할 열 이름 목록을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="68825ea1972a721fb38b022bcfd56c301bc54df2" translate="yes" xml:space="preserve">
          <source>If margins is</source>
          <target state="translated">여백이</target>
        </trans-unit>
        <trans-unit id="0d433683ef161d07d541b7f8a919bcca2325d430" translate="yes" xml:space="preserve">
          <source>If margins is &lt;code&gt;True&lt;/code&gt;, will also normalize margin values.</source>
          <target state="translated">여백이 &lt;code&gt;True&lt;/code&gt; 이면 여백 값도 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="62646e174920cf65de16aa9a88e993e7c1b80354" translate="yes" xml:space="preserve">
          <source>If max_cols is exceeded, switch to truncate view. Depending on</source>
          <target state="translated">max_cols를 초과하면 자르기보기로 전환합니다. 에 따라</target>
        </trans-unit>
        <trans-unit id="db9fb1c596d81c3f532c5167f5855674a6532345" translate="yes" xml:space="preserve">
          <source>If max_rows is exceeded, switch to truncate view. Depending on</source>
          <target state="translated">max_rows가 초과되면 자르기보기로 전환하십시오. 에 따라</target>
        </trans-unit>
        <trans-unit id="2a02a553bcee455a6ab31e5dbd189b43939c5bad" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled.</source>
          <target state="translated">method가 지정되면, 앞으로 / 뒤로 채울 최대 연속 NaN 값 수입니다. 즉,이 수의 연속 NaN보다 많은 간격이 있으면 부분적으로 만 채워집니다. method가 지정되지 않은 경우 NaN이 채워지는 전체 축을 따라 최대 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="64b5d3200781c8ed371e1e797a995a4f75b1dcb3" translate="yes" xml:space="preserve">
          <source>If method is specified, this is the maximum number of consecutive NaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None.</source>
          <target state="translated">method가 지정되면, 앞으로 / 뒤로 채울 최대 연속 NaN 값 수입니다. 즉,이 수의 연속 NaN보다 많은 간격이 있으면 부분적으로 만 채워집니다. method가 지정되지 않은 경우 NaN이 채워지는 전체 축을 따라 최대 항목 수입니다. None이 아닌 경우 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="7f7d613c787dbb21e15f1dcf963bf265292c5edc" translate="yes" xml:space="preserve">
          <source>If more than one type is accepted, separate them by commas, except the last two types, that need to be separated by the word &amp;lsquo;or&amp;rsquo;:</source>
          <target state="translated">둘 이상의 유형이 허용되는 경우 마지막 두 유형을 제외하고 'or'라는 단어로 구분해야하는 쉼표로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="052f2f856a6dfb7a8830bd4e0484cb7b2be454e4" translate="yes" xml:space="preserve">
          <source>If multiple levels passed, should contain tuples. Construct hierarchical index using the passed keys as the outermost level.</source>
          <target state="translated">여러 레벨이 통과 한 경우 튜플을 포함해야합니다. 전달 된 키를 최 외곽 레벨로 사용하여 계층 적 인덱스를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6501af21994846ec90e14ed89e7a813350f8d52c" translate="yes" xml:space="preserve">
          <source>If multiple object values have the highest count, then the &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;top&lt;/code&gt; results will be arbitrarily chosen from among those with the highest count.</source>
          <target state="translated">여러 개체 값이 가장 높은 개수를 가진 경우 가장 높은 개수의 개체 중에서 &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;top&lt;/code&gt; 결과가 임의로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="34d7f3599c01ed87631ef489cca8da2b4308aa21" translate="yes" xml:space="preserve">
          <source>If multiple values equal the maximum, the first row label with that value is returned.</source>
          <target state="translated">여러 값이 최대 값과 같으면 해당 값을 가진 첫 번째 행 레이블이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12828981e6321f886a33ba30627df341eba8d652" translate="yes" xml:space="preserve">
          <source>If multiple values equal the minimum, the first row label with that value is returned.</source>
          <target state="translated">여러 값이 최소값과 같으면 해당 값을 가진 첫 번째 행 레이블이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="22f182e9b6624459ce684e4c8ed64ff090a2529a" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to</source>
          <target state="translated">na_values가 지정되고 keep_default_na가 False이면 기본 NaN 값이 재정의됩니다. 그렇지 않으면 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a517305158ceac1628f92ad56b945b90297339" translate="yes" xml:space="preserve">
          <source>If na_values are specified and keep_default_na is False the default NaN values are overridden, otherwise they&amp;rsquo;re appended to.</source>
          <target state="translated">na_values가 지정되고 keep_default_na가 False이면 기본 NaN 값이 재정의되고 그렇지 않으면 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f762185f104435345c74d2cdd090da0e1d42ac15" translate="yes" xml:space="preserve">
          <source>If ndarray-like but cannot infer the dtype</source>
          <target state="translated">ndarray와 비슷하지만 dtype을 추론 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="e23113f2a52942ee42c83e1b254e8235537f3f63" translate="yes" xml:space="preserve">
          <source>If needed you can explicitly specify a format string, or a dict of arguments to pass to &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">필요한 경우 &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt; &lt;code&gt;pandas.to_datetime()&lt;/code&gt; &lt;/a&gt; 에 전달할 형식 문자열 또는 인수 사전을 명시 적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f4eb2917c5222b0d337bae6fbff3ef21460ab9a" translate="yes" xml:space="preserve">
          <source>If needed you can just adjust the bins with an &lt;code&gt;offset&lt;/code&gt; Timedelta that would be added to the default &lt;code&gt;origin&lt;/code&gt;. Those two examples are equivalent for this time series:</source>
          <target state="translated">필요한 경우 기본 &lt;code&gt;origin&lt;/code&gt; 추가 되는 &lt;code&gt;offset&lt;/code&gt; Timedelta로 빈을 조정할 수 있습니다 . 이 두 가지 예는이 시계열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="637d5696700a6df0a8baf6d3b140ebe5aff89341" translate="yes" xml:space="preserve">
          <source>If needed you can use a custom timestamp for &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">필요한 경우 &lt;code&gt;origin&lt;/code&gt; 대한 사용자 지정 타임 스탬프를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7000054cf48292d0455a5b9aca5bf89643b6c472" translate="yes" xml:space="preserve">
          <source>If new categories are list-like and do not have the same number of items than the current categories or do not validate as categories</source>
          <target state="translated">새 카테고리가 목록과 유사하고 현재 카테고리와 동일한 수의 항목이 없거나 카테고리로 유효성 검증되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="56ab769c4964e541ce9265684d378bc3a0d09287" translate="yes" xml:space="preserve">
          <source>If new_categories does not validate as categories</source>
          <target state="translated">new_categories가 카테고리로 유효하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="cbed0bbea58dcdb206a837899ad95a4ba77dcd33" translate="yes" xml:space="preserve">
          <source>If no names are provided, use the column names, or tuple of column names if the columns is a MultiIndex. If a sequence, overwrite names with the given sequence.</source>
          <target state="translated">이름이 제공되지 않으면 열 이름을 사용하거나 열이 MultiIndex 인 경우 열 이름 튜플을 사용하십시오. 시퀀스 인 경우 지정된 시퀀스로 이름을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="5a5bad26bee04e3ba222956c2c796e863be42591" translate="yes" xml:space="preserve">
          <source>If none of the labels are found in the index.</source>
          <target state="translated">색인에 레이블이없는 경우</target>
        </trans-unit>
        <trans-unit id="27841c0014abcd0463ff2861c53f354a6a34facc" translate="yes" xml:space="preserve">
          <source>If not None, and if the data has been successfully cast to a numerical dtype (or if the data was numeric to begin with), downcast that resulting data to the smallest numerical dtype possible according to the following rules:</source>
          <target state="translated">None이 아니고 데이터가 숫자 dtype으로 성공적으로 캐스트 된 경우 (또는 데이터가 숫자로 시작하는 경우) 다음 규칙에 따라 결과 데이터를 가능한 가장 작은 숫자 dtype으로 다운 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="1e307ecdc7ecd59bd95757600bace6779421241e" translate="yes" xml:space="preserve">
          <source>If not None, apply the key function to the index values before sorting. This is similar to the</source>
          <target state="translated">None이 아닌 경우 정렬하기 전에 인덱스 값에 키 기능을 적용하십시오. 이것은</target>
        </trans-unit>
        <trans-unit id="66ebf1d3140f80342f207320ff26cd6b1a32ef4f" translate="yes" xml:space="preserve">
          <source>If not None, apply the key function to the series values before sorting. This is similar to the</source>
          <target state="translated">없음이 아닌 경우 정렬하기 전에 계열 값에 키 기능을 적용하십시오. 이것은</target>
        </trans-unit>
        <trans-unit id="e361817d859e555a419bc1371e6268617ba32d96" translate="yes" xml:space="preserve">
          <source>If not None, only these columns will be read from the file.</source>
          <target state="translated">None이 아닌 경우 파일에서이 열만 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cfe9cce3f8330a3251ed95d788697677222e7323" translate="yes" xml:space="preserve">
          <source>If not None, sort on values in specified index level(s).</source>
          <target state="translated">None이 아닌 경우 지정된 인덱스 수준에서 값을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="9376aca00f183cc74c267ce0caa80bff2fb817d1" translate="yes" xml:space="preserve">
          <source>If not all of the labels are found in the selected axis</source>
          <target state="translated">선택한 축에 모든 레이블이없는 경우</target>
        </trans-unit>
        <trans-unit id="d0a22f48a5959f07a3692660fc0f335e8e4e36ac" translate="yes" xml:space="preserve">
          <source>If not passed, uses gca()</source>
          <target state="translated">전달되지 않으면 gca ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c241cd23cfdf52a4bd48350a73a6738548d9b996" translate="yes" xml:space="preserve">
          <source>If not passed, uses gca().</source>
          <target state="translated">전달되지 않으면 gca ()를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="605ce58ce37edd99b2cbc7ee655fc1a9f67c5f6c" translate="yes" xml:space="preserve">
          <source>If not provided, all columns are read.</source>
          <target state="translated">제공하지 않으면 모든 열을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c7adf8e39eb0b3d72eaf0f61526432eb5bfe7de6" translate="yes" xml:space="preserve">
          <source>If not specified, the keyword &lt;code&gt;sep&lt;/code&gt; for the separator defaults to the empty string, &lt;code&gt;sep=''&lt;/code&gt;:</source>
          <target state="translated">지정되지 않은 경우 구분 기호 의 키워드 &lt;code&gt;sep&lt;/code&gt; 는 기본적으로 빈 문자열 인 &lt;code&gt;sep=''&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a29100beab681308f154ad5a4be5b3b89fb544c7" translate="yes" xml:space="preserve">
          <source>If not specified, there are two possibilities:</source>
          <target state="translated">지정하지 않으면 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="67d8b502538e17d92597d391d70ada0247caada5" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self and produce pairwise output.</source>
          <target state="translated">제공되지 않으면 기본값은 자체로 설정되고 쌍별 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="17e1ffdad774475011f6787cf4716965a7dadec6" translate="yes" xml:space="preserve">
          <source>If not supplied then will default to self.</source>
          <target state="translated">제공되지 않으면 기본값은 self입니다.</target>
        </trans-unit>
        <trans-unit id="a7b3cbcd2ecfdfe645e2c20769e281ebccbcc3e3" translate="yes" xml:space="preserve">
          <source>If other is a Series, return the matrix product between self and other as a Serie. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</source>
          <target state="translated">other가 Series 인 경우, 자기 자신과 다른 사람 사이의 매트릭스 제품을 Serie로 반환하십시오. other가 DataFrame 또는 numpy.array 인 경우 self 및 other의 행렬 곱을 np.array의 DataFrame에 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="43623d69404123e7a6aac874029d1b30acdfa12e" translate="yes" xml:space="preserve">
          <source>If other is a Series, return the matrix product between self and other as a Series. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</source>
          <target state="translated">other가 Series이면 self와 other 사이의 행렬 곱을 Series로 반환합니다. other가 DataFrame 또는 numpy.array이면 np.array의 DataFrame에서 self와 other의 행렬 곱을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="236a44b890a6ba0afca4e7206977a422c9384304" translate="yes" xml:space="preserve">
          <source>If others is None, the method returns the concatenation of all strings in the calling Series/Index.</source>
          <target state="translated">others가 None 인 경우, 메소드는 호출하는 Series / Index에있는 모든 문자열의 연결을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b6f15e903f0777b1e7f0e9efd0f00fdc7d5f16dc" translate="yes" xml:space="preserve">
          <source>If others is a list-like that contains a combination of Series, Index or np.ndarray (1-dim), then all elements will be unpacked and must satisfy the above criteria individually.</source>
          <target state="translated">다른 요소가 Series, Index 또는 np.ndarray (1dim)의 조합을 포함하는 목록과 같은 경우 모든 요소의 압축이 풀리고 위의 기준을 개별적으로 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="44aa5702e4b920b2bf468228e7acc9cc6e30a8d3" translate="yes" xml:space="preserve">
          <source>If pandas does not infer a dedicated extension type a &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt;&lt;code&gt;arrays.PandasArray&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">pandas가 전용 확장 유형을 유추하지 않으면 &lt;a href=&quot;pandas.arrays.pandasarray#pandas.arrays.PandasArray&quot;&gt; &lt;code&gt;arrays.PandasArray&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63d6f5378543f5ad0bc487858af5d8d984e37eb8" translate="yes" xml:space="preserve">
          <source>If parsing dates (convert_dates is not False), then try to parse the default datelike columns. A column label is datelike if</source>
          <target state="translated">날짜를 구문 분석하는 경우 (convert_dates가 False가 아님) 기본 datelike 열을 구문 분석해보십시오. 열 레이블은 다음과 같은 경우 날짜와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7aa4696f9d9f11d69bd7c0bc73e4bd0736b1ad80" translate="yes" xml:space="preserve">
          <source>If parsing dates, then parse the default datelike columns.</source>
          <target state="translated">날짜를 구문 분석하는 경우 기본 날짜 유사 열을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="4884f91f4d98371473cdc16c244105fb8fec04f3" translate="yes" xml:space="preserve">
          <source>If parsing succeeded. Return type depends on input:</source>
          <target state="translated">구문 분석이 성공한 경우. 반환 유형은 입력에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="72335770581c60c00751461ab89cd0b5ee370293" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;all&amp;rsquo; or</source>
          <target state="translated">'all'또는</target>
        </trans-unit>
        <trans-unit id="6ab98323b9cd6c707ec25d2e47620cf585b844dc" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;all&amp;rsquo; or &lt;code&gt;True&lt;/code&gt;, will normalize over all values.</source>
          <target state="translated">'all'또는 &lt;code&gt;True&lt;/code&gt; 를 전달하면 모든 값에서 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a89a0012ee03a22f72bd2860e27eba43a13982b3" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;columns&amp;rsquo; will normalize over each column.</source>
          <target state="translated">통과되면 '열'이 각 열에서 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="e234887ca1ae0a80fa1868664dd0238d5d04ba79" translate="yes" xml:space="preserve">
          <source>If passed &amp;lsquo;index&amp;rsquo; will normalize over each row.</source>
          <target state="translated">'index'를 전달하면 각 행에서 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="95e50caaa0069694aa1cc539c06f69fd598085ff" translate="yes" xml:space="preserve">
          <source>If passed a Series will use the values of the series (NOT THE INDEX).</source>
          <target state="translated">통과되면 시리즈는 시리즈의 값을 사용합니다 (인덱스가 아님).</target>
        </trans-unit>
        <trans-unit id="cdbafc7d17980ded598ce2f6b941b4de6b162f7f" translate="yes" xml:space="preserve">
          <source>If passed, must match number of column arrays passed.</source>
          <target state="translated">전달 된 경우 전달 된 열 배열 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f97f42e1389db9548ed46ba6d3fe5d917a8fa133" translate="yes" xml:space="preserve">
          <source>If passed, must match number of row arrays passed.</source>
          <target state="translated">전달 된 경우 전달 된 행 배열 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fa12f2a0ca4016bad2139234c3a9ac376f53792" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups</source>
          <target state="translated">통과하면 별도의 그룹에 대한 히스토그램을 형성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a4b782f57e19abcb2aa77b54645db0e489c6b42" translate="yes" xml:space="preserve">
          <source>If passed, then used to form histograms for separate groups.</source>
          <target state="translated">통과하면 별도의 그룹에 대한 히스토그램을 형성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1c91474589b55c524f8116422575c56dae40f7" translate="yes" xml:space="preserve">
          <source>If passed, will be used to limit data to a subset of columns.</source>
          <target state="translated">전달되면 데이터를 열의 하위 집합으로 제한하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf13cb19b460c1c30c4e0e63d016fc04e393c052" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting csv format as a string. Otherwise returns None.</source>
          <target state="translated">path_or_buf가 None이면 결과 csv 형식을 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="467786b2cc9f24142a326f141e5e9998e551f79b" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting json format as a string. Otherwise returns None.</source>
          <target state="translated">path_or_buf가 None이면 결과 json 형식을 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ab35a4e69cd5e00e62bc40ef695d80398b3047f" translate="yes" xml:space="preserve">
          <source>If path_or_buf is None, returns the resulting msgpack format as a byte string. Otherwise returns None.</source>
          <target state="translated">path_or_buf가 None이면 결과 msgpack 형식을 바이트 문자열로 반환합니다. 그렇지 않으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0fe82b619e0bf64745c86d941d95a0506e74aff0" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming period on or just past end argument</source>
          <target state="translated">기간이 없으면 생성 된 색인은 첫 번째 인수 기간 또는 종료 시점의 첫 번째 준수 기간으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="d32965fa894336b076cce4f85e7e48d5894d1d82" translate="yes" xml:space="preserve">
          <source>If periods is none, generated index will extend to first conforming time on or just past end argument</source>
          <target state="translated">마침표가 없으면 생성 된 색인은 첫 번째 인수 시점 또는 종료 시점의 첫 번째 준수 시간으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="9dd9779620b8974ba66618f8372fc57e4f8ce556" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters:</source>
          <target state="translated">제공되는 경우이 매개 변수는 다음 매개 변수의 값 (기본값 또는 아님)을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="71f980c4e25c4e9da56d7674ad6dffd737c076ee" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters: &lt;code&gt;delimiter&lt;/code&gt;, &lt;code&gt;doublequote&lt;/code&gt;, &lt;code&gt;escapechar&lt;/code&gt;, &lt;code&gt;skipinitialspace&lt;/code&gt;, &lt;code&gt;quotechar&lt;/code&gt;, and &lt;code&gt;quoting&lt;/code&gt;. If it is necessary to override values, a ParserWarning will be issued. See &lt;a href=&quot;https://docs.python.org/3/library/csv.html#csv.Dialect&quot;&gt;&lt;code&gt;csv.Dialect&lt;/code&gt;&lt;/a&gt; documentation for more details.</source>
          <target state="translated">: 제공 한 경우,이 매개 변수는 다음 매개 변수의 값 (디폴트 여부를) 무시합니다 &lt;code&gt;delimiter&lt;/code&gt; , &lt;code&gt;doublequote&lt;/code&gt; , &lt;code&gt;escapechar&lt;/code&gt; , &lt;code&gt;skipinitialspace&lt;/code&gt; , &lt;code&gt;quotechar&lt;/code&gt; 및 &lt;code&gt;quoting&lt;/code&gt; . 값을 재정의해야하는 경우 ParserWarning이 발행됩니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/csv.html#csv.Dialect&quot;&gt; &lt;code&gt;csv.Dialect&lt;/code&gt; &lt;/a&gt; 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="be9cd18b4c26564dea3305689f1e4726a3a1fb03" translate="yes" xml:space="preserve">
          <source>If provided, this parameter will override values (default or not) for the following parameters: &lt;code&gt;delimiter&lt;/code&gt;, &lt;code&gt;doublequote&lt;/code&gt;, &lt;code&gt;escapechar&lt;/code&gt;, &lt;code&gt;skipinitialspace&lt;/code&gt;, &lt;code&gt;quotechar&lt;/code&gt;, and &lt;code&gt;quoting&lt;/code&gt;. If it is necessary to override values, a ParserWarning will be issued. See csv.Dialect documentation for more details.</source>
          <target state="translated">: 제공 한 경우,이 매개 변수는 다음 매개 변수의 값 (디폴트 여부를) 무시합니다 &lt;code&gt;delimiter&lt;/code&gt; , &lt;code&gt;doublequote&lt;/code&gt; , &lt;code&gt;escapechar&lt;/code&gt; , &lt;code&gt;skipinitialspace&lt;/code&gt; , &lt;code&gt;quotechar&lt;/code&gt; 및 &lt;code&gt;quoting&lt;/code&gt; . 값을 대체해야하는 경우 ParserWarning이 발행됩니다. 자세한 내용은 csv.Dialect 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a05339991167e0e6c730f03164ad020504ffa9b3" translate="yes" xml:space="preserve">
          <source>If resulting index has only 1 level left, the result will be of Index type, not MultiIndex.</source>
          <target state="translated">결과 색인에 1 레벨 만 남으면 결과는 다중 색인이 아닌 색인 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1d17d6d3193f2c431cd73525c42fc1232029c3d2" translate="yes" xml:space="preserve">
          <source>If returning an ExtensionArray, then</source>
          <target state="translated">ExtensionArray를 반환하면</target>
        </trans-unit>
        <trans-unit id="3e064bce4d5d267a12f81f957574e39d35faa28b" translate="yes" xml:space="preserve">
          <source>If set to None, the number of items to be printed is unlimited. [default: 100] [currently: 100]</source>
          <target state="translated">없음으로 설정하면 인쇄 할 항목 수에 제한이 없습니다. [기본값 : 100] [현재 : 100]</target>
        </trans-unit>
        <trans-unit id="881d4fbdc1e7a8b7ba5ab81f1479cb45ced59e14" translate="yes" xml:space="preserve">
          <source>If set to None, the number of items to be printed is unlimited. [default: 100] [currently: 100]display.memory_usage : bool, string or None This specifies if the memory usage of a DataFrame should be displayed when df.info() is called. Valid values True,False,&amp;rsquo;deep&amp;rsquo; [default: True] [currently: True]display.min_rows : int The numbers of rows to show in a truncated view (when &lt;code&gt;max_rows&lt;/code&gt; is exceeded). Ignored when &lt;code&gt;max_rows&lt;/code&gt; is set to None or 0. When set to None, follows the value of &lt;code&gt;max_rows&lt;/code&gt;. [default: 10] [currently: 10]display.multi_sparse : boolean &amp;ldquo;sparsify&amp;rdquo; MultiIndex display (don&amp;rsquo;t display repeated elements in outer levels within groups) [default: True] [currently: True]display.notebook_repr_html : boolean When True, IPython notebook will use html representation for pandas objects (if it is available). [default: True] [currently: True]display.pprint_nest_depth : int Controls the number of nested levels to process when pretty-printing [default: 3] [currently: 3]display.precision : int Floating point output precision (number of significant digits). This is only a suggestion [default: 6] [currently: 6]display.show_dimensions : boolean or &amp;lsquo;truncate&amp;rsquo; Whether to print out dimensions at the end of DataFrame repr. If &amp;lsquo;truncate&amp;rsquo; is specified, only print out the dimensions if the frame is truncated (e.g. not display all rows and/or columns) [default: truncate] [currently: truncate]display.unicode.ambiguous_as_wide : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.unicode.east_asian_width : boolean Whether to use the Unicode East Asian Width to calculate the display text width. Enabling this may affect to the performance (default: False) [default: False] [currently: False]display.width : int Width of the display in characters. In case python/IPython is running in a terminal this can be set to None and pandas will correctly auto-detect the width. Note that the IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to correctly detect the width. [default: 80] [currently: 80]io.excel.ods.reader : string The default Excel reader engine for &amp;lsquo;ods&amp;rsquo; files. Available options: auto, odf. [default: auto] [currently: auto]io.excel.xls.reader : string The default Excel reader engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlrd. [default: auto] [currently: auto]io.excel.xls.writer : string The default Excel writer engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlwt. [default: auto] [currently: auto]io.excel.xlsm.reader : string The default Excel reader engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsm.writer : string The default Excel writer engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.reader : string The default Excel reader engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]io.excel.xlsx.writer : string The default Excel writer engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, openpyxl, xlsxwriter. [default: auto] [currently: auto]io.hdf.default_format : format default format writing format, if None, then put will default to &amp;lsquo;fixed&amp;rsquo; and append will default to &amp;lsquo;table&amp;rsquo; [default: None] [currently: None]io.hdf.dropna_table : boolean drop ALL nan rows when appending to a table [default: False] [currently: False]io.parquet.engine : string The default parquet reader/writer engine. Available options: &amp;lsquo;auto&amp;rsquo;, &amp;lsquo;pyarrow&amp;rsquo;, &amp;lsquo;fastparquet&amp;rsquo;, the default is &amp;lsquo;auto&amp;rsquo; [default: auto] [currently: auto]mode.chained_assignment : string Raise an exception, warn, or no action if trying to use chained assignment, The default is warn [default: warn] [currently: warn]mode.sim_interactive : boolean Whether to simulate interactive mode for purposes of testing [default: False] [currently: False]mode.use_inf_as_na : boolean True means treat None, NaN, INF, -INF as NA (old way), False means None and NaN are null, but INF, -INF are not NA (new way). [default: False] [currently: False]mode.use_inf_as_null : boolean use_inf_as_null had been deprecated and will be removed in a future version. Use &lt;code&gt;use_inf_as_na&lt;/code&gt; instead. [default: False] [currently: False] (Deprecated, use &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; instead.)plotting.backend : str The plotting backend to use. The default value is &amp;ldquo;matplotlib&amp;rdquo;, the backend provided with pandas. Other backends can be specified by prodiving the name of the module that implements the backend. [default: matplotlib] [currently: matplotlib]plotting.matplotlib.register_converters : bool Whether to register converters with matplotlib&amp;rsquo;s units registry for dates, times, datetimes, and Periods. Toggling to False will remove the converters, restoring any converters that pandas overwrote. [default: True] [currently: True]</source>
          <target state="translated">없음으로 설정하면 인쇄 할 항목 수는 무제한입니다. [default : 100] [현재 : 100] display.memory_usage : bool, string 또는 None df.info ()를 호출 할 때 DataFrame의 메모리 사용량을 표시해야하는지 여부를 지정합니다. 유효한 값 True, False, 'deep'[기본값 : True] [현재 : True] display.min_rows : int 잘린 뷰에 표시 할 행 수입니다 ( &lt;code&gt;max_rows&lt;/code&gt; 를 초과 한 경우). 때 무시 &lt;code&gt;max_rows&lt;/code&gt; 없음으로 설정되면 유료 또는 0으로 설정되고, 다음의 값 &lt;code&gt;max_rows&lt;/code&gt; . [default : 10] [현재 : 10] display.multi_sparse : 부울 &quot;스파 르즈&quot;다중 인덱스 표시 (그룹 내에서 외부 레벨에 반복 된 요소를 표시하지 않음) [default : True] [현재 : True] display.notebook_repr_html : 부울 True 일 때 IPython 노트북은 팬더 객체에 html 표현을 사용합니다 (가능한 경우). [default : True] [현재 : True] display.pprint_nest_depth : int 예쁜 인쇄시 처리 할 중첩 레벨 수를 제어합니다. [default : 3] [현재 : 3] display.precision : int 부동 소수점 출력 정밀도 (유의 한 수) 자릿수). 이것은 단지 제안 일뿐입니다 [기본값 : 6] [현재 : 6] display.show_dimensions : 부울 또는 '잘라 내기'DataFrame repr의 끝에서 치수를 인쇄할지 여부입니다. '잘라 내기'가 지정된 경우 프레임이 잘린 경우에만 치수를 인쇄하십시오 (예 :모든 행 및 / 또는 열을 표시하지 않음) [기본값 : truncate] [현재 : truncate] display.unicode.ambiguous_as_wide : boolean 유니 코드 동아시아 너비를 사용하여 표시 텍스트 너비를 계산할지 여부입니다. 이를 사용하면 성능에 영향을 줄 수 있습니다 (기본값 : False) [default : False] [현재 : False] display.unicode.east_asian_width : boolean 유니 코드 동아시아 너비를 사용하여 표시 텍스트 너비를 계산할지 여부입니다. 이 기능을 사용하면 성능에 영향을 줄 수 있습니다 (기본값 : False) [default : False] [현재 : False] display.width : int 문자의 디스플레이 너비입니다. python / IPython이 터미널에서 실행되는 경우 None으로 설정 될 수 있으며 팬더는 너비를 올바르게 자동 감지합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 너비를 올바르게 감지 할 수 없습니다. [기본:80] [현재 : 80] io.excel.ods.reader : string 'ods'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, odf. [default : auto] [현재 : auto] io.excel.xls.reader : string 'xls'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, xlrd. [default : auto] [현재 : auto] io.excel.xls.writer : string 'xls'파일의 기본 Excel 작성기 엔진입니다. 사용 가능한 옵션 : auto, xlwt. [default : auto] [현재 : auto] io.excel.xlsm.reader : string 'xlsm'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, xlrd, openpyxl. [default : auto] [현재 : auto] io.excel.xlsm.writer : string 'xlsm'파일의 기본 Excel 작성기 엔진입니다. 사용 가능한 옵션 : 자동, openpyxl. [default : auto] [현재 : auto] io.excel.xlsx.reader : string 'xlsx'파일의 기본 Excel 리더 엔진입니다. 사용 가능한 옵션 : auto, xlrd,openpyxl. [default : auto] [현재 : auto] io.excel.xlsx.writer : string 'xlsx'파일의 기본 Excel 작성기 엔진입니다. 사용 가능한 옵션 : 자동, openpyxl, xlsxwriter. [default : auto] [현재 : auto] io.hdf.default_format : 형식 기본 형식 쓰기 형식 (없음 인 경우)은 기본적으로 '고정'으로, 추가는 기본적으로 '테이블'로 설정됩니다. [기본값 : 없음] [현재 : 없음 ] io.hdf.dropna_table : 테이블에 추가 할 때 nanlean 모든 nan 행을 삭제합니다. [default : False] [현재 : False] io.parquet.engine : string 기본 마루 판독기 / 작성기 엔진입니다. 사용 가능한 옵션 : 'auto', 'pyarrow', 'fastparquet', 기본값은 'auto'입니다. [default : auto] [현재 : auto] mode.chained_assignment : string 연결을 사용하려는 경우 예외를 발생 시키거나 경고하거나 조치를 수행하지 않습니다. 할당, 기본값은 경고입니다 [기본값 : 경고] [현재 : 경고] mode.sim_interactive :boolean 테스트 목적으로 대화식 모드를 시뮬레이트할지 여부 [default : False] [현재 : False] mode.use_inf_as_na : boolean True는 None, NaN, INF, -INF를 NA (old way)로 처리하고 False는 None 및 NaN이 null임을 의미합니다. , 그러나 INF, -INF는 NA (새로운 방법)가 아닙니다. [default : False] [현재 : False] mode.use_inf_as_null : 부울 use_inf_as_null은 더 이상 사용되지 않으며 향후 버전에서 제거 될 예정입니다. 사용하다 &lt;code&gt;use_inf_as_na&lt;/code&gt; 대신 use_inf_as_na를 사용하십시오. [default : False] [현재 : False] (더 이상 사용되지 않음, 대신 &lt;code&gt;mode.use_inf_as_na&lt;/code&gt; 를 사용하십시오.) plotting.backend : str 사용할 플로팅 백엔드. 기본값은 팬더와 함께 제공되는 백엔드 인&amp;ldquo;matplotlib&amp;rdquo;입니다. 백엔드를 구현하는 모듈의 이름을 제공하여 다른 백엔드를 지정할 수 있습니다. [default : matplotlib] [현재 : matplotlib] plotting.matplotlib.register_converters : bool matplotlib의 단위 레지스트리를 사용하여 날짜, 시간, 날짜 시간 및 기간에 변환기를 등록할지 여부. False로 전환하면 변환기가 제거되어 팬더가 덮어 쓴 변환기가 복원됩니다. [기본값 : True] [현재 : True]</target>
        </trans-unit>
        <trans-unit id="4983fff342fff2155fda50539177d2d395cc41ca" translate="yes" xml:space="preserve">
          <source>If set to a float value, all float values smaller then the given threshold will be displayed as exactly 0 by repr and friends.</source>
          <target state="translated">float 값으로 설정하면 주어진 임계 값보다 작은 모든 float 값이 repr과 친구들에 의해 정확히 0으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae05e640370b98c99c2eb61bf5fe03e0f6a770c7" translate="yes" xml:space="preserve">
          <source>If set, limit the maximum number of rows to fetch from the query results.</source>
          <target state="translated">설정된 경우 쿼리 결과에서 가져올 최대 행 수를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="db0453700b5f3a81a6b68576ac4ef69d3f6c097f" translate="yes" xml:space="preserve">
          <source>If set, use the &lt;a href=&quot;https://tqdm.github.io/&quot;&gt;tqdm&lt;/a&gt; library to display a progress bar while the data downloads. Install the &lt;code&gt;tqdm&lt;/code&gt; package to use this feature.</source>
          <target state="translated">설정된 경우 &lt;a href=&quot;https://tqdm.github.io/&quot;&gt;tqdm&lt;/a&gt; 라이브러리를 사용 하여 데이터를 다운로드하는 동안 진행률 표시 줄을 표시합니다. 이 기능을 사용 하려면 &lt;code&gt;tqdm&lt;/code&gt; 패키지를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa12ba58c2be2f71104408a510d4489d9b0c6ffa" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size</source>
          <target state="translated">지정된 경우 x 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="97863624dbef3656142375cfc414d8c6db270d6b" translate="yes" xml:space="preserve">
          <source>If specified changes the x-axis label size.</source>
          <target state="translated">지정된 경우 x 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7873740ccf0410b3fb0bea93346ff13ec92e92" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size</source>
          <target state="translated">지정된 경우 y 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="581f8ddceda8e96b28aea9467091a054fc8fcba4" translate="yes" xml:space="preserve">
          <source>If specified changes the y-axis label size.</source>
          <target state="translated">지정된 경우 y 축 레이블 크기가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3648b96e279d94f92a6ee0971122e6704390a3" translate="yes" xml:space="preserve">
          <source>If specified only options matching</source>
          <target state="translated">지정된 경우에만 일치하는 옵션</target>
        </trans-unit>
        <trans-unit id="7820aaef54858d9fe6f835280f13f8d7b53a28bd" translate="yes" xml:space="preserve">
          <source>If specified only options matching &lt;code&gt;prefix*&lt;/code&gt; will be reset. Note: partial matches are supported for convenience, but unless you use the full option name (e.g. x.y.z.option_name), your code may break in future versions if new options with similar names are introduced.</source>
          <target state="translated">지정된 경우 &lt;code&gt;prefix*&lt;/code&gt; 일치하는 옵션 만 재설정됩니다. 참고 : 편의상 부분 일치가 지원되지만 전체 옵션 이름 (egxyzoption_name)을 사용하지 않으면 유사한 이름의 새 옵션이 도입되면 이후 버전에서 코드가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbfd3a88eab2f247413e17f672c68ad4e5e49adc" translate="yes" xml:space="preserve">
          <source>If specified, &lt;strong&gt;fill&lt;/strong&gt; data for missing labels using logic (highly relevant to working with time series data)</source>
          <target state="translated">지정된 경우 논리를 사용하여 누락 된 레이블에 대한 데이터를 &lt;strong&gt;채 웁니다&lt;/strong&gt; (시계열 데이터 작업과 매우 관련 있음).</target>
        </trans-unit>
        <trans-unit id="1e2fd14b30360e01bd1925a87fecdb829dae8c45" translate="yes" xml:space="preserve">
          <source>If specified, checks if merge is of specified type.</source>
          <target state="translated">지정된 경우 병합이 지정된 유형인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="72c2f9cefac58e113fc2c842ab3415610081df06" translate="yes" xml:space="preserve">
          <source>If specified, requires</source>
          <target state="translated">지정된 경우</target>
        </trans-unit>
        <trans-unit id="195f4d58de033a32ef9e0ed103f9771ba227ede5" translate="yes" xml:space="preserve">
          <source>If specified, requires &lt;code&gt;values&lt;/code&gt; be specified as well.</source>
          <target state="translated">지정된 경우 &lt;code&gt;values&lt;/code&gt; 도 지정 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="b8ff89eb07dddd54f2f0304a34009cfe5e81e653" translate="yes" xml:space="preserve">
          <source>If specified, return an iterator where</source>
          <target state="translated">지정된 경우 반복기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50b212e57ff80a7164ca948bedf3a2c591bca4f5" translate="yes" xml:space="preserve">
          <source>If specified, return an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">지정된 경우 &lt;code&gt;chunksize&lt;/code&gt; 가 각 청크에 포함 할 행 수인 반복자를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="0082373421092da175dee8a9b93a4ccc4f6ac2a4" translate="yes" xml:space="preserve">
          <source>If specified, returns an iterator where</source>
          <target state="translated">지정된 경우 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78439b54e5e60a975149f48cea5f22c188ad305b" translate="yes" xml:space="preserve">
          <source>If specified, returns an iterator where &lt;code&gt;chunksize&lt;/code&gt; is the number of rows to include in each chunk.</source>
          <target state="translated">지정된 경우 &lt;code&gt;chunksize&lt;/code&gt; 가 각 청크에 포함 할 행 수인 반복자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="999348edd253a275c024b1092f6c830ad7d41693" translate="yes" xml:space="preserve">
          <source>If str, it will be considered as a path to a file. Info will be written to that file in JSON format.</source>
          <target state="translated">str이면 파일 경로로 간주됩니다. 정보는 JSON 형식으로 해당 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4ce81a105f24afb5e0f2c0a1d42b5a9e99140d42" translate="yes" xml:space="preserve">
          <source>If str, represents compression mode. If dict, value at &amp;lsquo;method&amp;rsquo; is the compression mode. Compression mode may be any of the following possible values: {&amp;lsquo;infer&amp;rsquo;, &amp;lsquo;gzip&amp;rsquo;, &amp;lsquo;bz2&amp;rsquo;, &amp;lsquo;zip&amp;rsquo;, &amp;lsquo;xz&amp;rsquo;, None}. If compression mode is &amp;lsquo;infer&amp;rsquo; and</source>
          <target state="translated">str이면 압축 모드를 나타냅니다. dict 인 경우 'method'의 값이 압축 모드입니다. 압축 모드는 { 'infer', 'gzip', 'bz2', 'zip', 'xz', None}과 같은 가능한 값 중 하나 일 수 있습니다. 압축 모드가 '추론'이고</target>
        </trans-unit>
        <trans-unit id="657e48eb3a4d68a611327f580edbd21c7f670eb9" translate="yes" xml:space="preserve">
          <source>If str, the name of the column in the DataFrame representing the times.</source>
          <target state="translated">str 인 경우 시간을 나타내는 DataFrame의 열 이름입니다.</target>
        </trans-unit>
        <trans-unit id="04bcdac7e76a787e1fbea8ae01f3869fac3ea6f8" translate="yes" xml:space="preserve">
          <source>If str, then indicates comma separated list of Excel column letters and column ranges (e.g. &amp;ldquo;A:E&amp;rdquo; or &amp;ldquo;A,C,E:F&amp;rdquo;). Ranges are inclusive of both sides.</source>
          <target state="translated">str 인 경우 쉼표로 구분 된 Excel 열 문자 및 열 범위 목록을 나타냅니다 (예 : &quot;A : E&quot;또는 &quot;A, C, E : F&quot;). 범위는 양쪽을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9da6ca18cdc6eec7c4db6f8861692e993483053b" translate="yes" xml:space="preserve">
          <source>If such a function works, please file a bug at &lt;a href=&quot;https://github.com/pandas-dev/pandas&quot;&gt;https://github.com/pandas-dev/pandas&lt;/a&gt;!</source>
          <target state="translated">이러한 기능이 작동하면 &lt;a href=&quot;https://github.com/pandas-dev/pandas&quot;&gt;https://github.com/pandas-dev/pandas&lt;/a&gt; 에서 버그를 신고하세요 !</target>
        </trans-unit>
        <trans-unit id="00eda6030f8870181f3ae042945f9f88a8227cb5" translate="yes" xml:space="preserve">
          <source>If supplying a list, each individual table_style should be a dictionary with &lt;code&gt;selector&lt;/code&gt; and &lt;code&gt;props&lt;/code&gt; keys. &lt;code&gt;selector&lt;/code&gt; should be a CSS selector that the style will be applied to (automatically prefixed by the table&amp;rsquo;s UUID) and &lt;code&gt;props&lt;/code&gt; should be a list of tuples with &lt;code&gt;(attribute, value)&lt;/code&gt;. If supplying a dict, the dict keys should correspond to column names or index values, depending upon the specified</source>
          <target state="translated">목록을 제공하는 경우 각 개별 table_style은 &lt;code&gt;selector&lt;/code&gt; 및 &lt;code&gt;props&lt;/code&gt; 키 가있는 사전이어야 합니다. &lt;code&gt;selector&lt;/code&gt; 는 스타일이 적용될 CSS 선택자 (테이블의 UUID가 자동으로 접두사로 지정됨) 여야하며 &lt;code&gt;props&lt;/code&gt; 는 &lt;code&gt;(attribute, value)&lt;/code&gt; 가있는 튜플 목록이어야합니다 . dict를 제공하는 경우 dict 키는 지정된 항목에 따라 열 이름 또는 인덱스 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6e8edc6bf86da535a40f6cb6e96a6e8c7af0dcb" translate="yes" xml:space="preserve">
          <source>If table exists raise pandas_gbq.gbq.TableCreationError.</source>
          <target state="translated">테이블이 있으면 pandas_gbq.gbq.TableCreationError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f4a7f4d474e4d7426374eb27e2b8239df04809bb" translate="yes" xml:space="preserve">
          <source>If table exists, do nothing.</source>
          <target state="translated">테이블이 존재하면 아무것도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2ca3b25179b041d34301bc35b333ae308c33e09c" translate="yes" xml:space="preserve">
          <source>If table exists, drop it, recreate it, and insert data.</source>
          <target state="translated">테이블이 존재하면 테이블을 삭제하고 다시 작성하고 데이터를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="8c60747c3d8c8c498c4f7ba4c804063996419ee9" translate="yes" xml:space="preserve">
          <source>If table exists, insert data. Create if does not exist.</source>
          <target state="translated">테이블이 존재하면 데이터를 삽입하십시오. 존재하지 않는 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2042ba3d5eaacecb710b9e13fa4e5db8076a696a" translate="yes" xml:space="preserve">
          <source>If that condition is not satisfied, a join with two multi-indexes can be done using the following code.</source>
          <target state="translated">해당 조건이 충족되지 않으면 다음 코드를 사용하여 두 개의 다중 인덱스를 사용한 조인을 수행 할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="7806b6b94836ae0ac10b4b506a0d107772af3b21" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;'numba'&lt;/code&gt; engine is chosen, the function must be a user defined function with &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; as the first and second arguments respectively in the function signature. Each group&amp;rsquo;s index will be passed to the user defined function and optionally available for use.</source>
          <target state="translated">경우] &lt;code&gt;'numba'&lt;/code&gt; 엔진이 선택되면, 기능이있는 사용자 정의 함수이어야 &lt;code&gt;values&lt;/code&gt; 과 &lt;code&gt;index&lt;/code&gt; 함수 서명에 각각 제 1 및 제 2 인수로. 각 그룹의 색인은 사용자 정의 함수로 전달되며 선택적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbdf454f40b0c45a027c499e77bdb6113f2b6c7d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Categorical&lt;/code&gt; is not ordered, &lt;a href=&quot;../reference/api/pandas.series.min#pandas.Series.min&quot;&gt;&lt;code&gt;Series.min()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.max#pandas.Series.max&quot;&gt;&lt;code&gt;Series.max()&lt;/code&gt;&lt;/a&gt; will raise &lt;code&gt;TypeError&lt;/code&gt;. Numeric operations like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; and operations based on them (e.g. &lt;a href=&quot;../reference/api/pandas.series.median#pandas.Series.median&quot;&gt;&lt;code&gt;Series.median()&lt;/code&gt;&lt;/a&gt;, which would need to compute the mean between two values if the length of an array is even) do not work and raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Categorical&lt;/code&gt; 이 정렬되지 않은 경우 &lt;a href=&quot;../reference/api/pandas.series.min#pandas.Series.min&quot;&gt; &lt;code&gt;Series.min()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.series.max#pandas.Series.max&quot;&gt; &lt;code&gt;Series.max()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;TypeError&lt;/code&gt; 를 발생 시킵니다. &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 와 같은 숫자 연산과 이를 기반으로하는 연산 (예 : &lt;a href=&quot;../reference/api/pandas.series.median#pandas.Series.median&quot;&gt; &lt;code&gt;Series.median()&lt;/code&gt; &lt;/a&gt; , 배열의 길이가 짝수 인 경우 두 값 사이의 평균을 계산해야 함)은 작동하지 않고 &lt;code&gt;TypeError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="5d3f807d7903fe4db8bb66d5321128e42d669a89" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MultiIndex&lt;/code&gt; levels names are &lt;code&gt;None&lt;/code&gt;, the levels are automatically made available via the &lt;code&gt;level_n&lt;/code&gt; keyword with &lt;code&gt;n&lt;/code&gt; the level of the &lt;code&gt;MultiIndex&lt;/code&gt; you want to select from.</source>
          <target state="translated">는 IF &lt;code&gt;MultiIndex&lt;/code&gt; 의 수준 이름이없는 &lt;code&gt;None&lt;/code&gt; , 레벨이 자동으로 통해 사용할 수 있습니다 &lt;code&gt;level_n&lt;/code&gt; 의 와 키워드 &lt;code&gt;n&lt;/code&gt; 의 수준 &lt;code&gt;MultiIndex&lt;/code&gt; 이 선택하고자합니다.</target>
        </trans-unit>
        <trans-unit id="c8c94091f3e6317915c8bf08e4e19200411544ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;bins&lt;/code&gt; keyword is an &lt;code&gt;IntervalIndex&lt;/code&gt;, then these will be used to bin the passed data.:</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 입니다 키워드 &lt;code&gt;IntervalIndex&lt;/code&gt; 은 , 다음이 전달 된 데이터 빈에 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="4e6fc9dc69af6ac9bd02208d524cc26f9590d304" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;bins&lt;/code&gt; keyword is an integer, then equal-width bins are formed. Alternatively we can specify custom bin-edges:</source>
          <target state="translated">경우] &lt;code&gt;bins&lt;/code&gt; 정수 키워드 후 동등한 폭 빈들이 형성된다. 또는 사용자 정의 bin-edges를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2283dad6d1e4f0ad9f7a475c923728b16127b882" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;comment&lt;/code&gt; parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well.</source>
          <target state="translated">는 IF &lt;code&gt;comment&lt;/code&gt; 매개 변수를 지정하면 완전히 주석 행은 무시됩니다. 기본적으로 완전히 빈 줄도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="398ce981deb02bcf84891cf39753b3a46345bf90" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;join&lt;/code&gt; keyword is not passed, the method &lt;a href=&quot;../reference/api/pandas.series.str.cat#pandas.Series.str.cat&quot;&gt;&lt;code&gt;cat()&lt;/code&gt;&lt;/a&gt; will currently fall back to the behavior before version 0.23.0 (i.e. no alignment), but a &lt;code&gt;FutureWarning&lt;/code&gt; will be raised if any of the involved indexes differ, since this default will change to &lt;code&gt;join='left'&lt;/code&gt; in a future version.</source>
          <target state="translated">(가) 경우 &lt;code&gt;join&lt;/code&gt; 전달되지 키워드, 메소드 &lt;a href=&quot;../reference/api/pandas.series.str.cat#pandas.Series.str.cat&quot;&gt; &lt;code&gt;cat()&lt;/code&gt; &lt;/a&gt; 현재 버전 0.23.0 전에 행동 (즉, 어떤 정렬)로 다시 떨어질 것이다,하지만 &lt;code&gt;FutureWarning&lt;/code&gt; 은 침범 된 인덱스의 다른 경우이 기본값이 변경됩니다 때문에 발생합니다 에 &lt;code&gt;join='left'&lt;/code&gt; 미래 버전.</target>
        </trans-unit>
        <trans-unit id="cb65b84a0ed9ca7d9ee485a9567cc369b8c9fcac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;values&lt;/code&gt; argument is omitted, and the input &lt;code&gt;DataFrame&lt;/code&gt; has more than one column of values which are not used as column or index inputs to &lt;code&gt;pivot&lt;/code&gt;, then the resulting &amp;ldquo;pivoted&amp;rdquo; &lt;code&gt;DataFrame&lt;/code&gt; will have &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;hierarchical columns&lt;/a&gt; whose topmost level indicates the respective value column:</source>
          <target state="translated">상기 중간 &lt;code&gt;values&lt;/code&gt; 인수가 생략되고, 상기 입력 &lt;code&gt;DataFrame&lt;/code&gt; 는 에 컬럼 인덱스 입력으로 사용되지 않는 값 이상의 열 보유 &lt;code&gt;pivot&lt;/code&gt; 다음은 &quot;요동&quot;얻어진 &lt;code&gt;DataFrame&lt;/code&gt; 는 것이다 &lt;a href=&quot;advanced#advanced-hierarchical&quot;&gt;계층 열&lt;/a&gt; 그 최상위 레벨의 각 값의 열을 나타냄을 :</target>
        </trans-unit>
        <trans-unit id="fa8a2744eb24887cc6fb10a04b4424c9fbb9186e" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backward with a timedelta object or</source>
          <target state="translated">DST 전환으로 인해 존재하지 않는 시간이 발생하면 timedelta 개체를 사용하여 이러한 날짜를 앞뒤로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6472e80c2a9dc53f51fd601d89084b2d1b47e172" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or</source>
          <target state="translated">DST 전환으로 인해 시간이 존재하지 않는 경우 timedelta 개체를 사용하여 이러한 날짜를 앞뒤로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ecf87fc244588bee56119972b559fcabe156fa" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.Series(range(2), index=pd.DatetimeIndex([ &amp;hellip; &amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 2015-03-29 03:00:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 2015-03-29 01:59:59.999999999+01:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 2015-03-29 03:30:00+02:00 0 2015-03-29 03:30:00+02:00 1 dtype: int64</source>
          <target state="translated">DST 전환으로 인해 존재하지 않는 시간이 발생하면 &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; 객체 또는 'shift_forward' 또는 &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; 이러한 날짜를 앞뒤로 이동할 수 있습니다 . &amp;gt;&amp;gt;&amp;gt; s = pd.Series (range (2), index = pd.DatetimeIndex ([&amp;hellip; '2015-03-29 02:30:00',&amp;hellip; '2015-03-29 03:30:00']) ) &amp;gt;&amp;gt;&amp;gt; s.tz_localize ( '유럽 / 전세계', 존재하지 않는 = 'shift_forward') 2015-03-29 03 : 00 : 00 + 02 : 00 0 2015-03-29 03 : 30 : 00 + 02 : 00 1 dtype : int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize ( 'Europe / Warsaw', nonexistent = 'shift_backward') 2015-03-29 01 : 59 : 59.999999999 + 01 : 00 0 2015-03-29 03 : 30 : 00 + 02 : 00 1 dtype : int64 &amp;gt;&amp;gt;&amp;gt; s.tz_localize ( 'Europe / Warsaw', nonexistent = pd. Timedelta ( '1H')) 2015-03-29 03 : 30 : 00 + 02 : 00 0 2015-03-29 03 : 30 : 00 + 02 : 00 1 dtype : int64</target>
        </trans-unit>
        <trans-unit id="1efef3e25f01393c1708b5d04424ad93e6acad6e" translate="yes" xml:space="preserve">
          <source>If the DST transition causes nonexistent times, you can shift these dates forward or backwards with a timedelta object or &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt;. &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime(pd.Series([&amp;lsquo;2015-03-29 02:30:00&amp;rsquo;, &amp;hellip; &amp;lsquo;2015-03-29 03:30:00&amp;rsquo;])) &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_forward&amp;rsquo;) 0 2015-03-29 03:00:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=&amp;rsquo;shift_backward&amp;rsquo;) 0 2015-03-29 01:59:59.999999999+01:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize(&amp;lsquo;Europe/Warsaw&amp;rsquo;, nonexistent=pd.Timedelta(&amp;lsquo;1H&amp;rsquo;)) 0 2015-03-29 03:30:00+02:00 1 2015-03-29 03:30:00+02:00 dtype: datetime64[ns, &amp;lsquo;Europe/Warsaw&amp;rsquo;]</source>
          <target state="translated">DST 전환으로 인해 존재하지 않는 시간이 발생하면 &lt;code&gt;&amp;lsquo;shift_forward&amp;rsquo;&lt;/code&gt; 객체 또는 'shift_forward' 또는 &lt;code&gt;&amp;lsquo;shift_backwards&amp;rsquo;&lt;/code&gt; 이러한 날짜를 앞뒤로 이동할 수 있습니다 . &amp;gt;&amp;gt;&amp;gt; s = pd.to_datetime (pd.Series ([ '2015-03-29 02:30:00',&amp;hellip; '2015-03-29 03:30:00'])) &amp;gt;&amp;gt;&amp;gt; s.dt. tz_localize ( 'Europe / Warsaw', nonexistent = 'shift_forward') 0 2015-03-29 03 : 00 : 00 + 02 : 00 1 2015-03-29 03 : 30 : 00 + 02 : 00 dtype : datetime64 [ns, 'Europe / Warsaw'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize ( 'Europe / Warsaw', 존재하지 않음 = 'shift_backward') 0 2015-03-29 01 : 59 : 59.999999999 + 01 : 00 1 2015-03-29 03 : 30 : 00 + 02 : 00 dtype : datetime64 [ns, 'Europe / Warsaw'] &amp;gt;&amp;gt;&amp;gt; s.dt.tz_localize ( 'Europe / Warsaw', nonexistent = pd.Timedelta ( '1H')) 0 2015-03- 29 03 : 30 : 00 + 02 : 00 1 2015-03-29 03 : 30 : 00 + 02 : 00 dtype : datetime64 [ns, '유럽 / 바르샤바']</target>
        </trans-unit>
        <trans-unit id="0cded44943bc29f11107a3fa48812fe3fd18029d" translate="yes" xml:space="preserve">
          <source>If the DataFrame index has no label then the recarray field name is set to &amp;lsquo;index&amp;rsquo;. If the index has a label then this is used as the field name:</source>
          <target state="translated">DataFrame 색인에 레이블이 없으면 recarray 필드 이름이 'index'로 설정됩니다. 색인에 레이블이 있으면 필드 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d214ff5505dcc3df58ad0b05017eb7e67d620183" translate="yes" xml:space="preserve">
          <source>If the Datetime Array/Index is tz-aware and tz is not None.</source>
          <target state="translated">Datetime Array / Index가 tz를 인식하고 tz가 None이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="b9d9791f0508f684363d699b80bee52d000f007a" translate="yes" xml:space="preserve">
          <source>If the Index is a MultiIndex, drop the value when any or all levels are NaN.</source>
          <target state="translated">색인이 다중 색인 인 경우, 일부 또는 모든 레벨이 NaN 인 경우 값을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="be05eaa0dbbfb873520e230604c6d5204e61826b" translate="yes" xml:space="preserve">
          <source>If the Index objects are incompatible, both Index objects will be cast to dtype(&amp;lsquo;object&amp;rsquo;) first.</source>
          <target state="translated">Index 객체가 호환되지 않으면 두 Index 객체 모두 먼저 dtype ( 'object')로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="33e611dc7e8a5693ba6d67785cded9a86565fe9b" translate="yes" xml:space="preserve">
          <source>If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:</source>
          <target state="translated">JSON serializer가 컨테이너 콘텐츠를 직접 처리 할 수없는 경우 다음과 같은 방식으로 폴백됩니다.</target>
        </trans-unit>
        <trans-unit id="40eecad766d670f6843c3a0267a49f5717901b35" translate="yes" xml:space="preserve">
          <source>If the MultiIndex has names specified, these can be passed instead of the level number:</source>
          <target state="translated">MultiIndex에 지정된 이름이 있으면 레벨 번호 대신 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6155bdd87909d66e388cdbb2e09aeed48e81654e" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined return &amp;lsquo;NaN&amp;rsquo;.</source>
          <target state="translated">Pearson 상관 관계가 제대로 정의되지 않은 경우 'NaN'을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5ef45e6ec64f5bd071dc24f8d1e69cc1e5cd8b83" translate="yes" xml:space="preserve">
          <source>If the Pearson correlation is not well defined, then &amp;lsquo;NaN&amp;rsquo; is returned.</source>
          <target state="translated">Pearson 상관 관계가 제대로 정의되지 않으면 'NaN'이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="93c56163ba997d495339f68cf9109d1071720ba6" translate="yes" xml:space="preserve">
          <source>If the Series is empty.</source>
          <target state="translated">시리즈가 비어있는 경우.</target>
        </trans-unit>
        <trans-unit id="a8f2ab2c508af24c8a42b9be04bbb0ee02647fda" translate="yes" xml:space="preserve">
          <source>If the Series is of dtype &lt;code&gt;CategoricalDtype&lt;/code&gt;, &lt;code&gt;Series.cat&lt;/code&gt; can be used to change the categorical data. See &lt;a href=&quot;series#api-series-cat&quot;&gt;Categorical accessor&lt;/a&gt; for more.</source>
          <target state="translated">Series가 dtype &lt;code&gt;CategoricalDtype&lt;/code&gt; 인 경우 &lt;code&gt;Series.cat&lt;/code&gt; 을 사용하여 범주 형 데이터를 변경할 수 있습니다. 자세한 내용은 &lt;a href=&quot;series#api-series-cat&quot;&gt;범주 형 접근&lt;/a&gt; 자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c83fd268af8fe1a16e48c3a1ab2791b08629b1d" translate="yes" xml:space="preserve">
          <source>If the TimeSeries is tz-aware and tz is not None.</source>
          <target state="translated">TimeSeries가 tz를 인식하고 tz가 None이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="166773b46d18bb469c09bcac6b289439b56e7d14" translate="yes" xml:space="preserve">
          <source>If the Timestamp is tz-aware and tz is not None.</source>
          <target state="translated">타임 스탬프가 tz를 인식하고 tz가 None이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="ed9393b2d06f7ca7196058734584b10915f7b7ef" translate="yes" xml:space="preserve">
          <source>If the applied function returns a &lt;code&gt;Series&lt;/code&gt;, the final output is a &lt;code&gt;DataFrame&lt;/code&gt;. The columns match the index of the &lt;code&gt;Series&lt;/code&gt; returned by the applied function.</source>
          <target state="translated">적용된 함수가 &lt;code&gt;Series&lt;/code&gt; 를 반환 하면 최종 출력은 &lt;code&gt;DataFrame&lt;/code&gt; 입니다. 열 은 적용된 함수에서 반환 된 &lt;code&gt;Series&lt;/code&gt; 의 인덱스와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c7c554cfb74ad16eb30cb8acf707f73662f04504" translate="yes" xml:space="preserve">
          <source>If the applied function returns any other type, the final output is a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">적용된 함수가 다른 유형을 반환하는 경우 최종 출력은 &lt;code&gt;Series&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57492f8aeb84c4c11084b50073db14b29faccfda" translate="yes" xml:space="preserve">
          <source>If the axis is a</source>
          <target state="translated">축이</target>
        </trans-unit>
        <trans-unit id="31df692ed74865cf46655ed034fdaf4f052a8d85" translate="yes" xml:space="preserve">
          <source>If the axis is a &lt;code&gt;MultiIndex&lt;/code&gt; (hierarchical), count along a particular &lt;code&gt;level&lt;/code&gt;, collapsing into a &lt;code&gt;DataFrame&lt;/code&gt;. A &lt;code&gt;str&lt;/code&gt; specifies the level name.</source>
          <target state="translated">축이 &lt;code&gt;MultiIndex&lt;/code&gt; (계층 적) 인 경우 특정 &lt;code&gt;level&lt;/code&gt; 따라 계산 하여 &lt;code&gt;DataFrame&lt;/code&gt; 으로 축소합니다 . &lt;code&gt;str&lt;/code&gt; 수준 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cb176b6dcd2c00fd60079bc8af02e9483c7b2358" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 카운트하여 시리즈로 축소</target>
        </trans-unit>
        <trans-unit id="769c2b618c37d94ee04a6ed2f86ca3697aa771ee" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a Series.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 시리즈로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="5c874bca9b0f22f8a1cb6ace88f3bf9ba4eb54d3" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 스칼라로 축소</target>
        </trans-unit>
        <trans-unit id="9cfa60e80d738cd1ce2e3e1ca125d513cb5b51b9" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a scalar.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 스칼라로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="acc1c61e1d22ff923e52dd41f329881f26c8cde0" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a smaller Series.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준을 따라 작은 시리즈로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="4bde74fe49512814aa9175078e647d0e2833dc88" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), count along a particular level, collapsing into a {name1}.</source>
          <target state="translated">축이 MultiIndex (계층) 인 경우 특정 수준을 따라 계산하여 {name1}로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="67fb26f3d36635371a47ec0c1a6253a35906fe24" translate="yes" xml:space="preserve">
          <source>If the axis is a MultiIndex (hierarchical), group by a particular level or levels.</source>
          <target state="translated">축이 다중 인덱스 (계층 적) 인 경우 특정 수준으로 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="b5361e8b12cba57093a4bca7b1ba4eecbc07f527" translate="yes" xml:space="preserve">
          <source>If the axis is tz-naive.</source>
          <target state="translated">축이 tz-naive 인 경우.</target>
        </trans-unit>
        <trans-unit id="b60526c69422bc15a4ea3ceaf37ce27ebe587a8b" translate="yes" xml:space="preserve">
          <source>If the backend is not the default matplotlib one, the return value will be the object returned by the backend.</source>
          <target state="translated">백엔드가 기본 matplotlib가 아닌 경우 반환 값은 백엔드에서 반환 된 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="aeceb5d896fc9cb6f840f781402681ca9e0cca6b" translate="yes" xml:space="preserve">
          <source>If the caller is heterogeneous and contains booleans or objects, the result will be of dtype=object. See Notes.</source>
          <target state="translated">호출자가 이기종이고 부울 또는 오브젝트를 포함하는 경우 결과는 dtype = object입니다. 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="78dfb04301d7d11f06e3b14acf5990d58d0a43a0" translate="yes" xml:space="preserve">
          <source>If the categories do not validate.</source>
          <target state="translated">카테고리가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="37b7a652ec11f0c6a680c6d296b342bf36963ce7" translate="yes" xml:space="preserve">
          <source>If the columns have a &lt;code&gt;MultiIndex&lt;/code&gt;, you can choose which level to stack. The stacked level becomes the new lowest level in a &lt;code&gt;MultiIndex&lt;/code&gt; on the columns:</source>
          <target state="translated">열에 &lt;code&gt;MultiIndex&lt;/code&gt; 가있는 경우 스택 할 수준을 선택할 수 있습니다. 누적 수준은 열의 &lt;code&gt;MultiIndex&lt;/code&gt; 에서 새로운 최저 수준이됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6bab78d983e5853d00e346d9f3278a1b337046e" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines how the other levels are named. If None then the index name is repeated.</source>
          <target state="translated">열에 여러 수준이있는 경우 다른 수준의 이름을 지정하는 방법을 결정합니다. None이면 인덱스 이름이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="16f324de3f6d44a6d155ca6a0800716c76d8fdf8" translate="yes" xml:space="preserve">
          <source>If the columns have multiple levels, determines which level the labels are inserted into. By default it is inserted into the first level.</source>
          <target state="translated">열에 여러 수준이있는 경우 레이블을 삽입 할 수준을 결정합니다. 기본적으로 첫 번째 레벨에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="b46261a6c2734b27734de6d0fcc60d9a4f9f2be6" translate="yes" xml:space="preserve">
          <source>If the data are all NA, the result will be 0.</source>
          <target state="translated">데이터가 모두 NA이면 결과는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="2a8d59c818fd41f1886de03e2a0e8206d7189f0d" translate="yes" xml:space="preserve">
          <source>If the data are tz-aware, then every value in the array must have the same timezone.</source>
          <target state="translated">데이터가 tz를 인식하는 경우 배열의 모든 값은 동일한 시간대를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="751891dab5d046525fc44f6b2e68f95c51bfff3b" translate="yes" xml:space="preserve">
          <source>If the data is not length-1.</source>
          <target state="translated">데이터가 길이 -1이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="d39bced8875c9d4daed1623756606adbd29a4918" translate="yes" xml:space="preserve">
          <source>If the default template doesn&amp;rsquo;t quite suit your needs, you can subclass Styler and extend or override the template. We&amp;rsquo;ll show an example of extending the default template to insert a custom header before each table.</source>
          <target state="translated">기본 템플릿이 사용자 요구에 맞지 않으면 스타일러를 서브 클래 싱하고 템플릿을 확장하거나 재정의 할 수 있습니다. 기본 템플릿을 확장하여 각 테이블 앞에 사용자 지정 헤더를 삽입하는 예를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="6fd8fd90d6a0d1abee70b7276ea680c627a14212" translate="yes" xml:space="preserve">
          <source>If the dtype is integer, convert to an appropriate integer extension type.</source>
          <target state="translated">dtype이 정수이면 적절한 정수 확장 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9934081d7cb4f95460aa7414ef39e9099336c32f" translate="yes" xml:space="preserve">
          <source>If the dtype is numeric, and consists of all integers, convert to an appropriate integer extension type. Otherwise, convert to an appropriate floating extension type.</source>
          <target state="translated">dtype이 숫자이고 모든 정수로 구성된 경우 적절한 정수 확장 유형으로 변환합니다. 그렇지 않으면 적절한 부동 확장 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="b474e8292463ff3d6dc397cb12f9e866f037fd93" translate="yes" xml:space="preserve">
          <source>If the elements of a Series are lists themselves, join the content of these lists using the delimiter passed to the function. This function is an equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Series의 요소 자체가 목록 인 경우 함수에 전달 된 구분 기호를 사용하여 이러한 목록의 컨텐츠를 결합하십시오. 이 함수는 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b5cd27d9aa0745a9023fb6c25cf1ae1d3bf731d3" translate="yes" xml:space="preserve">
          <source>If the exact type is not relevant, but must be compatible with a numpy array, array-like can be specified. If Any type that can be iterated is accepted, iterable can be used:</source>
          <target state="translated">정확한 유형이 관련이 없지만 numpy 배열과 호환되어야하는 경우 배열과 같이 지정할 수 있습니다. 반복 할 수있는 모든 유형이 승인되면 반복 가능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be5ff8f8c878d0a8afe3f068aed76c34baa9e8b2" translate="yes" xml:space="preserve">
          <source>If the expression contains an assignment, whether to perform the operation inplace and mutate the existing DataFrame. Otherwise, a new DataFrame is returned.</source>
          <target state="translated">식에 대입이 포함 된 경우 작업을 수행하고 기존 DataFrame을 변경하는지 여부입니다. 그렇지 않으면 새 DataFrame이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d26e067e645ae141c3a27a1e812db05453a5ed1b" translate="yes" xml:space="preserve">
          <source>If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data:</source>
          <target state="translated">파일 또는 헤더에 중복 된 이름이 포함 된 경우 Pandas는 기본적으로 데이터를 덮어 쓰지 않도록 이름을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="58976636f12bfa2b230629347f075b16cf9d94be" translate="yes" xml:space="preserve">
          <source>If the fiscal year starts in April (</source>
          <target state="translated">회계 연도가 4 월에 시작하는 경우 (</target>
        </trans-unit>
        <trans-unit id="b7ff9c19369126c9e7394a827328229c91b340d6" translate="yes" xml:space="preserve">
          <source>If the fiscal year starts in April (&lt;code&gt;Q-MAR&lt;/code&gt;), the first quarter of 2018 will start in April 2017. &lt;code&gt;year&lt;/code&gt; will then be 2018, but &lt;code&gt;qyear&lt;/code&gt; will be the fiscal year, 2018.</source>
          <target state="translated">회계 연도가 4 월에 시작되면 ( &lt;code&gt;Q-MAR&lt;/code&gt; ) 2018 년 1 분기는 2017 &lt;code&gt;year&lt;/code&gt; 4 월에 시작합니다. 연도 는 2018이지만, &lt;code&gt;qyear&lt;/code&gt; 는 2018 회계 연도입니다.</target>
        </trans-unit>
        <trans-unit id="b59db1d7abf5d61294ac0431e0b446551a515714" translate="yes" xml:space="preserve">
          <source>If the frequency is higher than daily (e.g. monthly), the last day of the period is used.</source>
          <target state="translated">빈도가 매일 (예 : 월간)보다 높으면 기간의 마지막 날이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cbee9b96a09f286deac2451511a01eaea475791a" translate="yes" xml:space="preserve">
          <source>If the given date &lt;em&gt;is&lt;/em&gt; on an anchor point, it is moved &lt;code&gt;|n|&lt;/code&gt; points forwards or backwards.</source>
          <target state="translated">주어진 날짜 &lt;em&gt;가&lt;/em&gt; 앵커 포인트에 있으면 이동됩니다. &lt;code&gt;|n|&lt;/code&gt; 앞으로 또는 뒤로 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="251850cb5f40595dbfbfb399f7a94595a96e86d5" translate="yes" xml:space="preserve">
          <source>If the header is in a row other than the first, pass the row number to &lt;code&gt;header&lt;/code&gt;. This will skip the preceding rows:</source>
          <target state="translated">헤더가 첫 번째 행이 아닌 행에있는 경우 행 번호를 &lt;code&gt;header&lt;/code&gt; 에 전달하십시오 . 이전 행을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e95726e1713352efccbe37d7bda0327d4e035e6e" translate="yes" xml:space="preserve">
          <source>If the index being truncated contains only datetime values,</source>
          <target state="translated">잘리는 인덱스에 날짜 / 시간 값만 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="d726bbcf68dc737c3aca6d41e599a28b3f5d3ff8" translate="yes" xml:space="preserve">
          <source>If the index being truncated contains only datetime values, &lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; may be specified as strings instead of Timestamps.</source>
          <target state="translated">잘리지 인덱스 만 날짜 값을 포함 할 경우 &lt;code&gt;before&lt;/code&gt; 및 &lt;code&gt;after&lt;/code&gt; 대신에 타임 스탬프 문자열로 지정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="26ab44fcadd1b6b21a6d87e3f94d723582cab96b" translate="yes" xml:space="preserve">
          <source>If the index consists of dates, it calls &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt;&lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt;&lt;/a&gt; to try to format the x-axis nicely as per above.</source>
          <target state="translated">인덱스가 날짜로 구성된 경우 &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.autofmt_xdate&quot;&gt; &lt;code&gt;gcf().autofmt_xdate()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 위와 같이 x 축을 멋지게 형식화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2264c92998892aeab7e100ff43c608c30c0b3eaf" translate="yes" xml:space="preserve">
          <source>If the index has level names, they will parsed as well, using the same parameters.</source>
          <target state="translated">인덱스에 레벨 이름이있는 경우 동일한 매개 변수를 사용하여 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="62bf561852f13e8a7992a8390ffa6b918215b325" translate="yes" xml:space="preserve">
          <source>If the index has multiple levels, we can reset a subset of them:</source>
          <target state="translated">인덱스에 여러 수준이있는 경우 하위 집합을 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda1d90ab4aeda16d9fd7875489389b8cf6ae137" translate="yes" xml:space="preserve">
          <source>If the index is a MultiIndex, level(s) to set (None for all levels). Otherwise level must be None.</source>
          <target state="translated">인덱스가 다중 인덱스 인 경우 설정할 수준 (모든 수준에 대해 없음)입니다. 그렇지 않으면 레벨은 없음이어야합니다.</target>
        </trans-unit>
        <trans-unit id="067743019a50efb3de30de5e7db206d81efd2bfc" translate="yes" xml:space="preserve">
          <source>If the index is not a &lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt;&lt;code&gt;DatetimeIndex&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">인덱스가 &lt;a href=&quot;pandas.datetimeindex#pandas.DatetimeIndex&quot;&gt; &lt;code&gt;DatetimeIndex&lt;/code&gt; &lt;/a&gt; 가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="1927dd8f9c19eb08ec5a860837248b90f251a58b" translate="yes" xml:space="preserve">
          <source>If the index is not a MultiIndex, the output will be a Series (the analogue of stack when the columns are not a MultiIndex).</source>
          <target state="translated">인덱스가 MultiIndex가 아닌 경우 출력은 Series (컬럼이 MultiIndex가 아닌 경우 스택의 아날로그)가됩니다.</target>
        </trans-unit>
        <trans-unit id="30fd49a077ae8a3b14098e6244c90ec8aaa36f10" translate="yes" xml:space="preserve">
          <source>If the index is not datetime-like.</source>
          <target state="translated">인덱스가 datetime과 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="0474835e1da4e14d4e8fd21bedd592901f57b6d7" translate="yes" xml:space="preserve">
          <source>If the index is not sorted, an error is raised.</source>
          <target state="translated">인덱스가 정렬되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91a507c7cc7e55eec65d8adcd1430cebef29fade" translate="yes" xml:space="preserve">
          <source>If the index of a &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt; is monotonically increasing or decreasing, then the bounds of a label-based slice can be outside the range of the index, much like slice indexing a normal Python &lt;code&gt;list&lt;/code&gt;. Monotonicity of an index can be tested with the &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_increasing#pandas.Index.is_monotonic_increasing&quot;&gt;&lt;code&gt;is_monotonic_increasing()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_decreasing#pandas.Index.is_monotonic_decreasing&quot;&gt;&lt;code&gt;is_monotonic_decreasing()&lt;/code&gt;&lt;/a&gt; attributes.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 또는 &lt;code&gt;DataFrame&lt;/code&gt; 의 인덱스 가 단조롭게 증가하거나 감소하는 경우 레이블 기반 슬라이스의 경계는 일반 Python &lt;code&gt;list&lt;/code&gt; 슬라이스 인덱싱과 마찬가지로 인덱스 범위 밖에있을 수 있습니다 . 인덱스의 단 조성은 &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_increasing#pandas.Index.is_monotonic_increasing&quot;&gt; &lt;code&gt;is_monotonic_increasing()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.index.is_monotonic_decreasing#pandas.Index.is_monotonic_decreasing&quot;&gt; &lt;code&gt;is_monotonic_decreasing()&lt;/code&gt; &lt;/a&gt; 속성 으로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48b9e82a9c1b991449ed1f9627ad743db7ae93ac" translate="yes" xml:space="preserve">
          <source>If the indexes have names, you can use the level names instead of specifying the level numbers:</source>
          <target state="translated">인덱스에 이름이있는 경우 레벨 번호를 지정하는 대신 레벨 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab6a27e99c67cc04b243466ae25a20129613f55a" translate="yes" xml:space="preserve">
          <source>If the key is past the lexsort depth, the return may be a boolean mask array, otherwise it is always a slice or int.</source>
          <target state="translated">키가 lexsort 심도를 지난 경우 반환 값은 부울 마스크 배열 일 수 있으며, 그렇지 않으면 항상 슬라이스 또는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="23363d65d1a6bf0f3c3353ab3f1570ee49ce97bd" translate="yes" xml:space="preserve">
          <source>If the label is in the index, the method returns the passed label.</source>
          <target state="translated">레이블이 색인에 있으면이 메소드는 전달 된 레이블을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="62728247d7d94b3cd5df3bfeeee148f0c1c53570" translate="yes" xml:space="preserve">
          <source>If the levels of the &lt;code&gt;MultiIndex&lt;/code&gt; are unnamed, you can refer to them using special names:</source>
          <target state="translated">&lt;code&gt;MultiIndex&lt;/code&gt; 의 레벨 이 이름이 지정되지 않은 경우 특수 이름을 사용하여 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bace5351497c6afbd0b965925661935f3882c76" translate="yes" xml:space="preserve">
          <source>If the library specified with the &lt;code&gt;complib&lt;/code&gt; option is missing on your platform, compression defaults to &lt;code&gt;zlib&lt;/code&gt; without further ado.</source>
          <target state="translated">플랫폼에 &lt;code&gt;complib&lt;/code&gt; 옵션으로 지정된 라이브러리 가없는 경우 압축은 기본적으로 &lt;code&gt;zlib&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="621ef692e94d8c2c7ed3c141b773d4670d1901fd" translate="yes" xml:space="preserve">
          <source>If the mapping doesn&amp;rsquo;t include a column/index label, it isn&amp;rsquo;t renamed. Note that extra labels in the mapping don&amp;rsquo;t throw an error.</source>
          <target state="translated">매핑에 열 / 인덱스 레이블이 포함되지 않은 경우 이름이 변경되지 않습니다. 매핑의 추가 레이블은 오류를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22dfc540b19512c01f76cdc319937a5edf13e1d7" translate="yes" xml:space="preserve">
          <source>If the mapping is not one-to-one an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; is returned:</source>
          <target state="translated">맵핑이 일대일이 아닌 경우 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f30e3b28f5a53e1916fb432f6e3f20ec400af36a" translate="yes" xml:space="preserve">
          <source>If the mapping is one-to-one the ordering of the categories is preserved:</source>
          <target state="translated">매핑이 일대일이면 범주의 순서가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a768d5fc9004a5e554c6076edc84eab413d78b6d" translate="yes" xml:space="preserve">
          <source>If the maximum is achieved in multiple locations, the first row position is returned.</source>
          <target state="translated">여러 위치에서 최대 값에 도달하면 첫 번째 행 위치가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="29594b7fad55aba80e626335052ebbda64589beb" translate="yes" xml:space="preserve">
          <source>If the method returns a value, it will be documented in this section. Also if the method yields its output.</source>
          <target state="translated">메소드가 값을 리턴하면이 섹션에 문서화됩니다. 또한 메소드가 출력을 생성하는 경우.</target>
        </trans-unit>
        <trans-unit id="1c7fa85a4950fc4db50e956b853116480dbe2810" translate="yes" xml:space="preserve">
          <source>If the method yields its value:</source>
          <target state="translated">메소드가 그 값을 산출하는 경우 :</target>
        </trans-unit>
        <trans-unit id="6ea0723c633b98419ce3a16ae4f68fc08bf4f8d0" translate="yes" xml:space="preserve">
          <source>If the minimum is achieved in multiple locations, the first row position is returned.</source>
          <target state="translated">여러 위치에서 최소값이 달성되면 첫 번째 행 위치가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb76a7d2f4b9a5dfe28cdf6f1774a0fbdbb4d8d" translate="yes" xml:space="preserve">
          <source>If the name of your index overlaps with a column name, the column name is given precedence. For example,</source>
          <target state="translated">색인 이름이 열 이름과 겹치는 경우 열 이름이 우선합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="90b88b10d573c557d524dfc87fd5f8d2b05a6035" translate="yes" xml:space="preserve">
          <source>If the natural and fiscal year are the same,</source>
          <target state="translated">자연 연도와 회계 연도가 같으면</target>
        </trans-unit>
        <trans-unit id="2be314f975c703a2d0fb14d5a08ed837b5ac3d17" translate="yes" xml:space="preserve">
          <source>If the natural and fiscal year are the same, &lt;code&gt;qyear&lt;/code&gt; and &lt;code&gt;year&lt;/code&gt; will be the same.</source>
          <target state="translated">자연과 회계 연도가 같은 경우, &lt;code&gt;qyear&lt;/code&gt; 와 &lt;code&gt;year&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c2d7883a841125b807eecd00b3c3af4f438f2ede" translate="yes" xml:space="preserve">
          <source>If the new categories do not contain all old category items or any new ones</source>
          <target state="translated">새 범주에 이전 범주 항목이 모두 포함되어 있지 않거나 새 범주가없는 경우</target>
        </trans-unit>
        <trans-unit id="b8ff9a9bc1a204944889d9f9ab64cff13098ce04" translate="yes" xml:space="preserve">
          <source>If the new categories do not validate as categories or if the number of new categories is unequal the number of old categories</source>
          <target state="translated">새 범주가 범주로 유효하지 않거나 새 범주의 수가 같지 않은 경우 이전 범주의 수</target>
        </trans-unit>
        <trans-unit id="e5bb30293ce2058c6ee007b1c0630a5f11c11af8" translate="yes" xml:space="preserve">
          <source>If the new categories include old categories or do not validate as categories</source>
          <target state="translated">새 카테고리에 이전 카테고리가 포함되거나 카테고리로 검증되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="fe951dca7785cedc66869cdb77e398f6c9c6fc86" translate="yes" xml:space="preserve">
          <source>If the number of categories approaches the length of the data, the &lt;code&gt;Categorical&lt;/code&gt; will use nearly the same or more memory than an equivalent &lt;code&gt;object&lt;/code&gt; dtype representation.</source>
          <target state="translated">범주 수가 데이터 길이에 가까워지면 &lt;code&gt;Categorical&lt;/code&gt; 은 동등한 &lt;code&gt;object&lt;/code&gt; dtype 표현 과 거의 동일하거나 더 많은 메모리를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6d42972fb825ba15c0b8fbd39cf2275d1d47464c" translate="yes" xml:space="preserve">
          <source>If the offset class maps directly to a &lt;code&gt;Timedelta&lt;/code&gt; (&lt;code&gt;Day&lt;/code&gt;, &lt;code&gt;Hour&lt;/code&gt;, &lt;code&gt;Minute&lt;/code&gt;, &lt;code&gt;Second&lt;/code&gt;, &lt;code&gt;Micro&lt;/code&gt;, &lt;code&gt;Milli&lt;/code&gt;, &lt;code&gt;Nano&lt;/code&gt;) it can be used exactly like a &lt;code&gt;Timedelta&lt;/code&gt; - see the &lt;a href=&quot;timedeltas#timedeltas-operations&quot;&gt;Timedelta section&lt;/a&gt; for more examples.</source>
          <target state="translated">오프셋 클래스가 직접 매핑하는 경우 &lt;code&gt;Timedelta&lt;/code&gt; ( &lt;code&gt;Day&lt;/code&gt; , &lt;code&gt;Hour&lt;/code&gt; , &lt;code&gt;Minute&lt;/code&gt; , &lt;code&gt;Second&lt;/code&gt; , &lt;code&gt;Micro&lt;/code&gt; , &lt;code&gt;Milli&lt;/code&gt; , &lt;code&gt;Nano&lt;/code&gt; 는 정확히처럼 사용할 수 있습니다) &lt;code&gt;Timedelta&lt;/code&gt; - 투시 &lt;a href=&quot;timedeltas#timedeltas-operations&quot;&gt;Timedelta 섹션&lt;/a&gt; 더 많은 예제를 들어.</target>
        </trans-unit>
        <trans-unit id="aa4e627ef93053b4aa69b81750fbb56a233374ba" translate="yes" xml:space="preserve">
          <source>If the parsed data only contains one column then return a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">구문 분석 된 데이터에 하나의 열만 포함 된 경우 &lt;code&gt;Series&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc97c541d898a4ba589bd072c2b06a7b9a9ba55c" translate="yes" xml:space="preserve">
          <source>If the parsed data only contains one column then return a Series.</source>
          <target state="translated">구문 분석 된 데이터에 열이 하나만 있으면 Series를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fce5176c2e9226fd8f8db2e0305dd4e81c28cba" translate="yes" xml:space="preserve">
          <source>If the pattern is found more than once in the same string, then a list of multiple strings is returned:</source>
          <target state="translated">동일한 문자열에서 패턴이 두 번 이상 발견되면 여러 문자열 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="862fb94e4f74981a38a343060cd76373e4ac1593" translate="yes" xml:space="preserve">
          <source>If the period frequency is lower than daily (e.g. hourly), and the period spans over multiple days, the day at the start of the period is used.</source>
          <target state="translated">기간 빈도가 매일 (예 : 시간별)보다 낮고 기간이 여러 날에 걸쳐 있으면 기간 시작 날짜가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afacabf141fdf1a3c0b0db32b0df85742991ee4b" translate="yes" xml:space="preserve">
          <source>If the precision is higher than nanoseconds, the precision of the duration is truncated to nanoseconds for string inputs.</source>
          <target state="translated">정밀도가 나노초보다 높으면 지속 시간의 정밀도는 문자열 입력에 대해 나노초로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="0dc1edffb0f31fc99e3c48d2e32580c307e64c9a" translate="yes" xml:space="preserve">
          <source>If the precision is higher than nanoseconds, the precision of the duration is truncated to nanoseconds.</source>
          <target state="translated">정밀도가 나노초보다 높으면 지속 시간의 정밀도가 나노초로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="24931cba16f8d7d23729af82afc7b5cf33a8ab54" translate="yes" xml:space="preserve">
          <source>If the removals are not contained in the categories</source>
          <target state="translated">제거가 카테고리에 포함되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="a91b79ba0a48641f561804353a8466ad061c6ff1" translate="yes" xml:space="preserve">
          <source>If the row/column is empty</source>
          <target state="translated">행 / 열이 비어있는 경우</target>
        </trans-unit>
        <trans-unit id="c1275c4e20323c10096aa977b7395839bb87cb2c" translate="yes" xml:space="preserve">
          <source>If the slicing operation returns either a &lt;code&gt;DataFrame&lt;/code&gt; or a column of type &lt;code&gt;Series&lt;/code&gt;, the &lt;code&gt;category&lt;/code&gt; dtype is preserved.</source>
          <target state="translated">슬라이싱 작업을 리턴하거나 경우 &lt;code&gt;DataFrame&lt;/code&gt; 또는 형식의 열 &lt;code&gt;Series&lt;/code&gt; 의 &lt;code&gt;category&lt;/code&gt; DTYPE은 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="5afed770bb40cdc080e4e911d978019b4cc3a824" translate="yes" xml:space="preserve">
          <source>If the source file has both &lt;code&gt;MultiIndex&lt;/code&gt; index and columns, lists specifying each should be passed to &lt;code&gt;index_col&lt;/code&gt; and &lt;code&gt;header&lt;/code&gt;:</source>
          <target state="translated">소스 파일에 &lt;code&gt;MultiIndex&lt;/code&gt; 색인과 열 이 모두있는 경우 각각을 지정하는 목록을 &lt;code&gt;index_col&lt;/code&gt; 및 &lt;code&gt;header&lt;/code&gt; 로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d2fbbcf4ba212002b0c61ef4fa072fb2a25199bd" translate="yes" xml:space="preserve">
          <source>If the supplied Series contains neither strings nor lists.</source>
          <target state="translated">제공된 시리즈에 문자열이나 목록이없는 경우.</target>
        </trans-unit>
        <trans-unit id="e0f175e63735de751d2d7b89f97ca4eea1b0abeb" translate="yes" xml:space="preserve">
          <source>If the test generates a warning of class &lt;code&gt;category&lt;/code&gt; whose message starts with &lt;code&gt;msg&lt;/code&gt;, the warning will be ignored and the test will pass.</source>
          <target state="translated">테스트에서 메시지가 &lt;code&gt;msg&lt;/code&gt; 로 시작하는 클래스 &lt;code&gt;category&lt;/code&gt; 의 경고를 생성하면 경고 가 무시되고 테스트가 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="e13fc8bacc6ba344e6b7c59f5500846f60bb9f0f" translate="yes" xml:space="preserve">
          <source>If the timestamp string is treated as a slice, it can be used to index &lt;code&gt;DataFrame&lt;/code&gt; with &lt;code&gt;.loc[]&lt;/code&gt; as well.</source>
          <target state="translated">타임 스탬프 문자열을 슬라이스로 처리되는 경우, 인덱스로 사용될 수 &lt;code&gt;DataFrame&lt;/code&gt; 으로 &lt;code&gt;.loc[]&lt;/code&gt; 아니라.</target>
        </trans-unit>
        <trans-unit id="14413eaf87552171ee2c64255914c3d985a6b0cb" translate="yes" xml:space="preserve">
          <source>If the timezone is not set, the resulting Series will have a datetime64[ns] dtype.</source>
          <target state="translated">시간대가 설정되지 않은 경우 결과 시리즈에는 datetime64 [ns] dtype이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55f68536b5e696d5ad33c88c279512e394794e07" translate="yes" xml:space="preserve">
          <source>If the type is a pandas type, also specify pandas except for Series and DataFrame:</source>
          <target state="translated">유형이 팬더 유형 인 경우 Series 및 DataFrame을 제외하고 팬더도 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2c463cab0f756d454178e69be623cfa933046f80" translate="yes" xml:space="preserve">
          <source>If the type is defined in a Python module, the module must be specified:</source>
          <target state="translated">유형이 Python 모듈에 정의 된 경우 모듈을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa3ae3c0858082628b417918cb8ce07cd4ca5f45" translate="yes" xml:space="preserve">
          <source>If the type is in a package, the module must be also specified:</source>
          <target state="translated">유형이 패키지에있는 경우 모듈도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a03f05686c0d02f3139ecf76b3027fa808e62cc" translate="yes" xml:space="preserve">
          <source>If the user is aware of the duplicates in the right &lt;code&gt;DataFrame&lt;/code&gt; but wants to ensure there are no duplicates in the left DataFrame, one can use the &lt;code&gt;validate='one_to_many'&lt;/code&gt; argument instead, which will not raise an exception.</source>
          <target state="translated">사용자가 오른쪽 &lt;code&gt;DataFrame&lt;/code&gt; 의 중복을 알고 있지만 왼쪽 DataFrame에 중복이 없는지 확인하려는 경우 &lt;code&gt;validate='one_to_many'&lt;/code&gt; 인수를 대신 사용할 수 있으며 예외는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40e3ffe708d7d382314e21166febe6fa597c1764" translate="yes" xml:space="preserve">
          <source>If the values are not monotonically sorted, wrong locations may be returned:</source>
          <target state="translated">값이 단조롭게 정렬되지 않으면 잘못된 위치가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8116189ef90a7c0ac0c0a3c8ff175ce609f080fc" translate="yes" xml:space="preserve">
          <source>If there are any NaN or NaT values in the grouping key, these will be automatically excluded. In other words, there will never be an &amp;ldquo;NA group&amp;rdquo; or &amp;ldquo;NaT group&amp;rdquo;. This was not the case in older versions of pandas, but users were generally discarding the NA group anyway (and supporting it was an implementation headache).</source>
          <target state="translated">그룹화 키에 NaN 또는 NaT 값이 있으면 자동으로 제외됩니다. 즉, &quot;NA 그룹&quot;또는 &quot;NaT 그룹&quot;이 없을 것입니다. 이것은 이전 버전의 pandas에는 해당되지 않았지만 사용자는 일반적으로 어쨌든 NA 그룹을 버리고있었습니다 (그리고이를 지원하는 것은 구현 문제였습니다).</target>
        </trans-unit>
        <trans-unit id="682fbbd327f7dba66b881174932070842597549b" translate="yes" xml:space="preserve">
          <source>If there are fewer than three values.</source>
          <target state="translated">값이 3 개 미만인 경우.</target>
        </trans-unit>
        <trans-unit id="46f25d66dfb27cdf7e82e3397b599f84e8bbd166" translate="yes" xml:space="preserve">
          <source>If there are merge conflicts, you need to solve those conflicts. See for example at &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt; for an explanation on how to do this. Once the conflicts are merged and the files where the conflicts were solved are added, you can run &lt;code&gt;git commit&lt;/code&gt; to save those fixes.</source>
          <target state="translated">병합 충돌이있는 경우 해당 충돌을 해결해야합니다. 이를 수행하는 방법에 대한 설명 은 &lt;a href=&quot;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&quot;&gt;https://help.github.com/articles/resolving-a-merge-conflict-using-the-command-line/&lt;/a&gt; 을 참조하십시오 . 충돌이 병합되고 충돌이 해결 된 파일이 추가되면 &lt;code&gt;git commit&lt;/code&gt; 을 실행 하여 해당 수정 사항을 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f267a36da468b5ae5ceb8cafd473d483c3fe55df" translate="yes" xml:space="preserve">
          <source>If there are no conflicts (or they could be fixed automatically), a file with a default commit message will open, and you can simply save and quit this file.</source>
          <target state="translated">충돌이없는 경우 (또는 자동으로 수정 될 수있는 경우) 기본 커밋 메시지가있는 파일이 열리므로이 파일을 저장하고 종료하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f642e67158a066fd10cb787b665aedb36dbf5c3d" translate="yes" xml:space="preserve">
          <source>If there are people interested in continued support for Python 2.7 past December 31, 2018 (either backporting bug fixes or funding) please reach out to the maintainers on the issue tracker.</source>
          <target state="translated">2018 년 12 월 31 일 이후 Python 2.7에 대한 지속적인 지원 (백 포트 버그 수정 또는 자금 지원)에 관심이있는 사람이있는 경우 이슈 트래커의 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="df8b99601c3ccae4df1dcef1c8a935236cdb7582" translate="yes" xml:space="preserve">
          <source>If there is a small part of the result that can vary (e.g. a hash in an object representation), you can use &lt;code&gt;...&lt;/code&gt; to represent this part.</source>
          <target state="translated">결과의 일부가 다를 수있는 경우 (예 : 객체 표현의 해시), &lt;code&gt;...&lt;/code&gt; 을 사용 하여이 부분을 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79166ffe4f486692983ad25c9bb5a734e08993de" translate="yes" xml:space="preserve">
          <source>If there is no good value, NaN is returned for a Series or a Series of NaN values for a DataFrame</source>
          <target state="translated">적절한 값이 없으면 DataFrame의 Series 또는 Series의 NaN 값에 대해 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9a50506ea7c3939131db7d78d6afca01537a49a9" translate="yes" xml:space="preserve">
          <source>If this behavior is surprising, keep in mind that using &lt;code&gt;in&lt;/code&gt; on a Python dictionary tests keys, not values, and &lt;code&gt;Series&lt;/code&gt; are dict-like. To test for membership in the values, use the method &lt;a href=&quot;../reference/api/pandas.series.isin#pandas.Series.isin&quot;&gt;&lt;code&gt;isin()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 동작이 놀라운 경우 Python 사전 &lt;code&gt;in&lt;/code&gt; 을 사용 하면 값이 아닌 키가 테스트되고 &lt;code&gt;Series&lt;/code&gt; 는 dict와 유사 하다는 점을 명심하십시오 . 값의 멤버 자격을 테스트하려면 &lt;a href=&quot;../reference/api/pandas.series.isin#pandas.Series.isin&quot;&gt; &lt;code&gt;isin()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c4e4a825180bf8808a64195ae6d697226e17fa3" translate="yes" xml:space="preserve">
          <source>If this parameter is False, sets will not be considered list-like</source>
          <target state="translated">이 매개 변수가 False이면 세트는 목록과 같은 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="407299ada9b8eb20aa8ecf277a6368180bf252b5" translate="yes" xml:space="preserve">
          <source>If this parameter is False, sets will not be considered list-like.</source>
          <target state="translated">이 매개 변수가 False이면 세트는 목록과 유사한 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cde86769fd29b3bc205b6c427ec8870bad01f3ff" translate="yes" xml:space="preserve">
          <source>If true, ALL nan rows will not be written to store.</source>
          <target state="translated">true이면 모든 nan 행이 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47999fb8ac96a558b41fd99b5e696eccf4732cbe" translate="yes" xml:space="preserve">
          <source>If true, all rows and columns are kept. Otherwise, only the ones with different values are kept.</source>
          <target state="translated">true이면 모든 행과 열이 유지됩니다. 그렇지 않으면 값이 다른 항목 만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3282649a37ac55c74db8a5a1b1a27ca8c630f36d" translate="yes" xml:space="preserve">
          <source>If true, columns will be used as xticks</source>
          <target state="translated">true 인 경우 열이 xticks로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a143ef8b9e23894e4227d511a2a634fc694a65a" translate="yes" xml:space="preserve">
          <source>If true, columns will be used as xticks.</source>
          <target state="translated">참이면 열이 xtick로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a761e46b1b0da1fd384002ba5d9bdd4de4efda77" translate="yes" xml:space="preserve">
          <source>If true, resulting categories will be lexsorted, otherwise they will be ordered as they appear in the data.</source>
          <target state="translated">true 인 경우 결과 카테고리가 어휘 분류되며 그렇지 않으면 데이터에 표시되는대로 순서가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4fcaa7b2fe91e543e75e6441530fd4b5d810bb7f" translate="yes" xml:space="preserve">
          <source>If true, the ordered attribute of the Categoricals will be ignored. Results in an unordered categorical.</source>
          <target state="translated">true 인 경우 범주의 정렬 된 속성이 무시됩니다. 정렬되지 않은 범주 형이됩니다.</target>
        </trans-unit>
        <trans-unit id="bcaaeba8088f223fce415445cc2fe59773a45d3f" translate="yes" xml:space="preserve">
          <source>If true, the result keeps values that are equal. Otherwise, equal values are shown as NaNs.</source>
          <target state="translated">참이면 결과는 동일한 값을 유지합니다. 그렇지 않으면 동일한 값이 NaN으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1fe920431a3d41d651dfbcc77af70b504aee8c8" translate="yes" xml:space="preserve">
          <source>If true, vertical lines will be added at each xtick</source>
          <target state="translated">true 인 경우 각 xtick에 세로선이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c27e3a5063b9b94517959af47c02a3dd19fa2c3" translate="yes" xml:space="preserve">
          <source>If true, vertical lines will be added at each xtick.</source>
          <target state="translated">참이면 각 xtick에 수직선이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ce59a050f48126ce6320c30610faaa9c86fc199e" translate="yes" xml:space="preserve">
          <source>If two CategoricalIndex objects have equal elements True, otherwise False.</source>
          <target state="translated">두 CategoricalIndex 객체에 동일한 요소 True가 있으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="d639547142f390403b221695989f0de239dbb7b1" translate="yes" xml:space="preserve">
          <source>If two Index objects have equal elements and same type True, otherwise False.</source>
          <target state="translated">두 개의 Index 객체에 동일한 요소와 동일한 유형의 True가 있으면 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="626c6821778795ed6605d4fcfb4d554d4bb3ee62" translate="yes" xml:space="preserve">
          <source>If unnamed &lt;code&gt;Series&lt;/code&gt; are passed they will be numbered consecutively.</source>
          <target state="translated">명명되지 않은 &lt;code&gt;Series&lt;/code&gt; 가 전달되면 연속적으로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="952e2dee711cdb4ef88782a2cd0578a6a6843049" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;expand=True&lt;/code&gt;, Series and Index callers return DataFrame and MultiIndex objects, respectively.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;expand=True&lt;/code&gt; , 시리즈 및 색인 발신자가 DataFrame 및 MultiIndex 각각 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4055d83a079c44709ace2481bdd4e3c1f48c7657" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;join='right'&lt;/code&gt; on a list-like of &lt;code&gt;others&lt;/code&gt; that contains different indexes, the union of these indexes will be used as the basis for the final concatenation:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;join='right'&lt;/code&gt; A의리스트처럼의 &lt;code&gt;others&lt;/code&gt; 다른 인덱스를 포함,이 인덱스의 조합은 최종 연결에 대한 기준으로 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="a1cf23a69f82311296b7504255332812bccf16b4" translate="yes" xml:space="preserve">
          <source>If using in the Jupyter notebook, Styler has defined a &lt;code&gt;_repr_html_&lt;/code&gt; to automatically render itself. Otherwise call Styler.render to get the generated HTML.</source>
          <target state="translated">Jupyter 노트북에서 사용하는 경우 Styler는 자동으로 렌더링 &lt;code&gt;_repr_html_&lt;/code&gt; 을 정의했습니다 . 그렇지 않으면 Styler.render를 호출하여 생성 된 HTML을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="302e92543f3f0f75ce924bc7f9f8aa88c440b3a5" translate="yes" xml:space="preserve">
          <source>If warn=True, issue a warning if nanoseconds is nonzero.</source>
          <target state="translated">warn = True 인 경우 나노초가 0이 아닌 경우 경고를 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="260f17759a03e9b11140d2b1e686eb99c682c39b" translate="yes" xml:space="preserve">
          <source>If we also have a MultiIndex on columns &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, we can group by all but the specified columns</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 열에 MultiIndex가있는 경우 지정된 열을 제외한 모든 열을 기준으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82061eba4d9b00cf01b3ade310c01171b0a5cc2f" translate="yes" xml:space="preserve">
          <source>If we are not dropping the index, by default, it is placed in the top level. We can place it in another level:</source>
          <target state="translated">인덱스를 삭제하지 않으면 기본적으로 최상위 레벨에 배치됩니다. 다른 레벨에 배치 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b79fd67d25657db5cfcdb0ceff92c9e8f9633182" translate="yes" xml:space="preserve">
          <source>If we have many columns, we could also use a regex to find our stubnames and pass that list on to wide_to_long</source>
          <target state="translated">열이 많은 경우 정규식을 사용하여 스텁 이름을 찾아 해당 목록을 wide_to_long에 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7958cdd41a3b26aba9f751c1c05f025c55b1c42f" translate="yes" xml:space="preserve">
          <source>If we need intervals on a regular frequency, we can use the &lt;a href=&quot;../reference/api/pandas.interval_range#pandas.interval_range&quot;&gt;&lt;code&gt;interval_range()&lt;/code&gt;&lt;/a&gt; function to create an &lt;code&gt;IntervalIndex&lt;/code&gt; using various combinations of &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;periods&lt;/code&gt;. The default frequency for &lt;code&gt;interval_range&lt;/code&gt; is a 1 for numeric intervals, and calendar day for datetime-like intervals:</source>
          <target state="translated">일정한 빈도의 간격이 필요한 경우 &lt;a href=&quot;../reference/api/pandas.interval_range#pandas.interval_range&quot;&gt; &lt;code&gt;interval_range()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;periods&lt;/code&gt; 의 다양한 조합을 사용하여 &lt;code&gt;IntervalIndex&lt;/code&gt; 를 만들 수 있습니다 . &lt;code&gt;interval_range&lt;/code&gt; 의 기본 빈도 는 숫자 간격의 경우 1이고 datetime과 유사한 간격의 경우 달력 일입니다.</target>
        </trans-unit>
        <trans-unit id="f3059eebcb64938e4b7a073e1ffb4bda57975fc0" translate="yes" xml:space="preserve">
          <source>If we only have NaNs in our DataFrame, it is not considered empty! We will need to drop the NaNs to make the DataFrame empty:</source>
          <target state="translated">DataFrame에 NaN 만있는 경우 비어있는 것으로 간주되지 않습니다! DataFrame을 비우려면 NaN을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="71867c41ff101e2dd9ed7493912c5eb77334366c" translate="yes" xml:space="preserve">
          <source>If we only want consecutive gaps filled up to a certain number of data points, we can use the &lt;code&gt;limit&lt;/code&gt; keyword:</source>
          <target state="translated">특정 수의 데이터 포인트까지만 연속적인 간격을 채우려면 &lt;code&gt;limit&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="968348830bc4858358f68548de84b2c5a80500f0" translate="yes" xml:space="preserve">
          <source>If we specify a nonexistent level for</source>
          <target state="translated">존재하지 않는 수준을 지정하면</target>
        </trans-unit>
        <trans-unit id="c7bb5bb11f2ff2055c13b48cfec8d32f8a45a2e2" translate="yes" xml:space="preserve">
          <source>If we specify a nonexistent level for &lt;code&gt;col_fill&lt;/code&gt;, it is created:</source>
          <target state="translated">&lt;code&gt;col_fill&lt;/code&gt; 에 존재하지 않는 레벨을 지정하면 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f00dc1db037371153c550cb158eb937061016aea" translate="yes" xml:space="preserve">
          <source>If we want to join using the key columns, we need to set key to be the index in both</source>
          <target state="translated">키 열을 사용하여 조인하려면 키를 둘 다의 인덱스로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ebde3340d88dc78a7515ebac165ad4cba048950" translate="yes" xml:space="preserve">
          <source>If we want to join using the key columns, we need to set key to be the index in both &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. The joined DataFrame will have key as its index.</source>
          <target state="translated">키 열을 사용하여 결합하려면 key를 &lt;code&gt;df&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 모두의 인덱스로 설정해야합니다 . 결합 된 DataFrame은 키로 색인을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9837dbf801ccbd6d7e3a0358e252af7c064b1881" translate="yes" xml:space="preserve">
          <source>If we want to resample to the full range of the series:</source>
          <target state="translated">시리즈의 전체 범위로 리샘플링하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="116d297e0a504b613424946f4af9dc6593eaa9dd" translate="yes" xml:space="preserve">
          <source>If we were to measure the memory usage of the two calls, we&amp;rsquo;d see that specifying &lt;code&gt;columns&lt;/code&gt; uses about 1/10th the memory in this case.</source>
          <target state="translated">두 호출의 메모리 사용량을 측정하면 이 경우 &lt;code&gt;columns&lt;/code&gt; 을 지정 하면 메모리의 약 1/10이 사용 된다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e711c3bc9df9cb81190099d32dcc6f9c71c2292f" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;must&lt;/em&gt; interpolate, use the &lt;code&gt;'%r'&lt;/code&gt; format specifier</source>
          <target state="translated">보간 &lt;em&gt;해야하는&lt;/em&gt; 경우 &lt;code&gt;'%r'&lt;/code&gt; 형식 지정자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3f5b50b561b3e7aa33c127ffbfebf0a7133f79a8" translate="yes" xml:space="preserve">
          <source>If you added the upstream repository as described above you will see something like:</source>
          <target state="translated">위에서 설명한대로 업스트림 저장소를 추가 한 경우 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6dcbc8930cebc1be87b34e4cba1b548ad13195a7" translate="yes" xml:space="preserve">
          <source>If you already have &lt;code&gt;codes&lt;/code&gt; and &lt;code&gt;categories&lt;/code&gt;, you can use the &lt;a href=&quot;../reference/api/pandas.categorical.from_codes#pandas.Categorical.from_codes&quot;&gt;&lt;code&gt;from_codes()&lt;/code&gt;&lt;/a&gt; constructor to save the factorize step during normal constructor mode:</source>
          <target state="translated">당신이 이미있는 경우 &lt;code&gt;codes&lt;/code&gt; 와 &lt;code&gt;categories&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;a href=&quot;../reference/api/pandas.categorical.from_codes#pandas.Categorical.from_codes&quot;&gt; &lt;code&gt;from_codes()&lt;/code&gt; &lt;/a&gt; 정상 생성자 모드 중에 인수 분해 단계를 저장하는 생성자를 :</target>
        </trans-unit>
        <trans-unit id="d5c85b3d61764da8be18d5d777eb530f704213c9" translate="yes" xml:space="preserve">
          <source>If you also want to index a specific column with &lt;code&gt;.loc&lt;/code&gt;, you must use a tuple like this:</source>
          <target state="translated">&lt;code&gt;.loc&lt;/code&gt; 으로 특정 열을 인덱싱 하려면 다음과 같은 튜플을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="65afa83f1a217fb5a6797c63c1a0429f4d6825c0" translate="yes" xml:space="preserve">
          <source>If you are attempting to perform an operation you might see an exception like:</source>
          <target state="translated">작업을 수행하려는 경우 다음과 같은 예외가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a901823fe7ea06c8a1cd9a222f4bb095acb15157" translate="yes" xml:space="preserve">
          <source>If you are brand new to pandas or open-source development, we recommend going through the &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;GitHub &amp;ldquo;issues&amp;rdquo; tab&lt;/a&gt; to find issues that interest you. There are a number of issues listed under &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;Docs&lt;/a&gt; and &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;good first issue&lt;/a&gt; where you could start out. Once you&amp;rsquo;ve found an interesting issue, you can return here to get your development environment setup.</source>
          <target state="translated">팬더 또는 오픈 소스 개발에 &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;익숙하지 않은&lt;/a&gt; 경우 GitHub&amp;ldquo;문제&amp;rdquo;탭 을 통해 관심있는 문제를 찾으십시오. 아래에 나열된 문제가 있습니다 &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=Docs&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;문서 도구&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues?labels=good+first+issue&amp;amp;sort=updated&amp;amp;state=open&quot;&gt;좋은 첫 번째 문제&lt;/a&gt; 당신이 밖으로 시작할 수 있습니다. 흥미로운 문제가 발견되면 여기로 돌아와 개발 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="465f837f95ed9e96291bb7885669730c62809aef" translate="yes" xml:space="preserve">
          <source>If you are dealing with a time series that is growing at an increasing rate, &lt;code&gt;method='quadratic'&lt;/code&gt; may be appropriate.</source>
          <target state="translated">증가하는 속도로 증가하는 시계열을 다루는 경우 &lt;code&gt;method='quadratic'&lt;/code&gt; 이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca624ad660100e102682b9a51c3848478a72f2ee" translate="yes" xml:space="preserve">
          <source>If you are not passing any &lt;code&gt;data_columns&lt;/code&gt;, then the &lt;code&gt;min_itemsize&lt;/code&gt; will be the maximum of the length of any string passed</source>
          <target state="translated">당신이 어떤 통과하지 않는 경우 &lt;code&gt;data_columns&lt;/code&gt; 을 다음 &lt;code&gt;min_itemsize&lt;/code&gt; 는 전달 된 문자열의 길이의 최대 될 것입니다</target>
        </trans-unit>
        <trans-unit id="c15a6f9c5535245e9be6fcbd4d03ed646264a348" translate="yes" xml:space="preserve">
          <source>If you are using Python &amp;lt; 3.6 or pandas &amp;lt; 0.23, and &lt;code&gt;columns&lt;/code&gt; is not specified, the &lt;code&gt;DataFrame&lt;/code&gt; columns will be the lexically ordered list of dict keys.</source>
          <target state="translated">Python &amp;lt;3.6 또는 pandas &amp;lt;0.23을 사용하고 &lt;code&gt;columns&lt;/code&gt; 이 지정되지 않은 경우 &lt;code&gt;DataFrame&lt;/code&gt; 열은 사전 순으로 정렬 된 사전 키 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="b1734348d69969fd360e31fd62aca6442bca44f8" translate="yes" xml:space="preserve">
          <source>If you are using dates beyond 2038-01-18, due to current deficiencies in the underlying libraries caused by the year 2038 problem, daylight saving time (DST) adjustments to timezone aware dates will not be applied. If and when the underlying libraries are fixed, the DST transitions will be applied.</source>
          <target state="translated">2038-01-18 이후의 날짜를 사용하는 경우 2038 년 문제로 인한 기본 라이브러리의 현재 결함으로 인해 시간대 인식 날짜에 대한 일광 절약 시간 (DST) 조정이 적용되지 않습니다. 기본 라이브러리가 수정되면 DST 전환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b96b99bd90b15f960a8a1d823fd7572e68539985" translate="yes" xml:space="preserve">
          <source>If you are using the IPython environment, you may also use tab-completion to see these accessible attributes.</source>
          <target state="translated">IPython 환경을 사용하는 경우 탭 완성 기능을 사용하여 이러한 액세스 가능한 속성을 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="104adf5a4c3ea5cc99dad3c496195368e599955a" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t using conda for your development environment, follow these instructions. You&amp;rsquo;ll need to have at least python3.5 installed on your system.</source>
          <target state="translated">개발 환경에 conda를 사용하지 않는 경우 다음 지침을 따르십시오. 시스템에 python3.5 이상이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5a95ce05a5137b543597ab970b813363417ec7" translate="yes" xml:space="preserve">
          <source>If you build a great library on top of this, let us know and we&amp;rsquo;ll &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;link&lt;/a&gt; to it.</source>
          <target state="translated">이 위에 훌륭한 라이브러리를 구축하면 알려 주시면 &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;링크&lt;/a&gt; 해 드리겠습니다 .</target>
        </trans-unit>
        <trans-unit id="67704c3d1919945e86ee78d09fa2f38a50a2066f" translate="yes" xml:space="preserve">
          <source>If you build a great library on top of this, let us know and we&amp;rsquo;ll &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;link&lt;/a&gt; to it.</source>
          <target state="translated">이 위에 훌륭한 라이브러리를 구축하신다면 저희에게 알려 주시면 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/ecosystem.html&quot;&gt;링크&lt;/a&gt; 해 드리겠습니다 .</target>
        </trans-unit>
        <trans-unit id="741a6d65c45aabc2da8321ecddb112f34bdca128" translate="yes" xml:space="preserve">
          <source>If you create an index yourself, you can just assign it to the &lt;code&gt;index&lt;/code&gt; field:</source>
          <target state="translated">직접 색인을 생성하는 경우 &lt;code&gt;index&lt;/code&gt; 필드에 할당 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2610e8594483b112bc2ba67861d9a8abeac5ec9c" translate="yes" xml:space="preserve">
          <source>If you do wish to include decimal or object columns in an aggregation with other non-nuisance data types, you must do so explicitly.</source>
          <target state="translated">방해가되지 않는 다른 데이터 유형이있는 집계에 십진수 또는 개체 열을 포함하려면 명시 적으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd6076bc560cf97aea736a51a15e40cbe385b624" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like the default colours, you can specify how you&amp;rsquo;d like each column to be colored.</source>
          <target state="translated">기본 색상이 마음에 들지 않으면 각 열에 색상을 지정하는 방법을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a1d9ea7791dacf7b9c85b45bf9ae6bfbc250a85" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t prefix the local variable with &lt;code&gt;@&lt;/code&gt;, pandas will raise an exception telling you the variable is undefined.</source>
          <target state="translated">지역 변수에 &lt;code&gt;@&lt;/code&gt; 접두사를 붙이지 않으면 pandas는 변수가 정의되지 않았다는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="417bb3c329e071119224d529f869bb0141b6dcf0" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;parse_dates&lt;/code&gt; enabled for some or all of your columns, and your datetime strings are all formatted the same way, you may get a large speed up by setting &lt;code&gt;infer_datetime_format=True&lt;/code&gt;. If set, pandas will attempt to guess the format of your datetime strings, and then use a faster means of parsing the strings. 5-10x parsing speeds have been observed. pandas will fallback to the usual parsing if either the format cannot be guessed or the format that was guessed cannot properly parse the entire column of strings. So in general, &lt;code&gt;infer_datetime_format&lt;/code&gt; should not have any negative consequences if enabled.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;parse_dates&lt;/code&gt; 이 당신의 열의 일부 또는 전부를 사용할 수, 당신의 날짜 문자열이 모두 같은 방식으로 포맷되어, 당신은 설정하여 큰 속도를 얻을 수 있습니다 &lt;code&gt;infer_datetime_format=True&lt;/code&gt; . 설정된 경우 pandas는 datetime 문자열의 형식을 추측 한 다음 문자열을 구문 분석하는 더 빠른 방법을 사용합니다. 5 ~ 10 배의 구문 분석 속도가 관찰되었습니다. pandas는 형식을 추측 할 수 없거나 추측 된 형식이 문자열의 전체 열을 제대로 구문 분석 할 수없는 경우 일반적인 구문 분석으로 대체합니다. 따라서 일반적으로 &lt;code&gt;infer_datetime_format&lt;/code&gt; 은 활성화 된 경우 부정적인 결과를 가져서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="121f2b3e5cfa3e20d0594c4ac58f6710888524e4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;Series&lt;/code&gt; where lots of elements are repeated (i.e. the number of unique elements in the &lt;code&gt;Series&lt;/code&gt; is a lot smaller than the length of the &lt;code&gt;Series&lt;/code&gt;), it can be faster to convert the original &lt;code&gt;Series&lt;/code&gt; to one of type &lt;code&gt;category&lt;/code&gt; and then use &lt;code&gt;.str.&amp;lt;method&amp;gt;&lt;/code&gt; or &lt;code&gt;.dt.&amp;lt;property&amp;gt;&lt;/code&gt; on that. The performance difference comes from the fact that, for &lt;code&gt;Series&lt;/code&gt; of type &lt;code&gt;category&lt;/code&gt;, the string operations are done on the &lt;code&gt;.categories&lt;/code&gt; and not on each element of the &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;Series&lt;/code&gt; 요소를 많이 반복된다 (즉,이 독특한 요소의 개수 &lt;code&gt;Series&lt;/code&gt; 의 길이보다 훨씬 작은 &lt;code&gt;Series&lt;/code&gt; , 더 빨리 될 수있는 원래의 변환) &lt;code&gt;Series&lt;/code&gt; 형식 중 하나로 &lt;code&gt;category&lt;/code&gt; 한 후 사용 &lt;code&gt;.str.&amp;lt;method&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;.dt.&amp;lt;property&amp;gt;&lt;/code&gt; . 성능 차이는 &lt;code&gt;Series&lt;/code&gt; 유형 &lt;code&gt;category&lt;/code&gt; 의 경우 문자열 연산이 &lt;code&gt;Series&lt;/code&gt; 의 각 요소가 아니라 &lt;code&gt;.categories&lt;/code&gt; 에서 수행 된다는 사실에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="c991175b9cdf3e6da785720a9bef9cdc38f17c27" translate="yes" xml:space="preserve">
          <source>If you have a DataFrame or Series using traditional types that have missing data represented using &lt;code&gt;np.nan&lt;/code&gt;, there are convenience methods &lt;a href=&quot;../reference/api/pandas.series.convert_dtypes#pandas.Series.convert_dtypes&quot;&gt;&lt;code&gt;convert_dtypes()&lt;/code&gt;&lt;/a&gt; in Series and &lt;a href=&quot;../reference/api/pandas.dataframe.convert_dtypes#pandas.DataFrame.convert_dtypes&quot;&gt;&lt;code&gt;convert_dtypes()&lt;/code&gt;&lt;/a&gt; in DataFrame that can convert data to use the newer dtypes for integers, strings and booleans listed &lt;a href=&quot;basics#basics-dtypes&quot;&gt;here&lt;/a&gt;. This is especially helpful after reading in data sets when letting the readers such as &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.read_excel#pandas.read_excel&quot;&gt;&lt;code&gt;read_excel()&lt;/code&gt;&lt;/a&gt; infer default dtypes.</source>
          <target state="translated">당신은 DataFrame 또는 시리즈를 사용하여 표시 누락 된 데이터를 한 전통적인 유형 사용하는 경우 &lt;code&gt;np.nan&lt;/code&gt; 을 편리 메소드가, &lt;a href=&quot;../reference/api/pandas.series.convert_dtypes#pandas.Series.convert_dtypes&quot;&gt; &lt;code&gt;convert_dtypes()&lt;/code&gt; &lt;/a&gt; 시리즈와의 &lt;a href=&quot;../reference/api/pandas.dataframe.convert_dtypes#pandas.DataFrame.convert_dtypes&quot;&gt; &lt;code&gt;convert_dtypes()&lt;/code&gt; &lt;/a&gt; 정수, 문자열 및 부울에 대한 새로운 dtypes를 사용하여 데이터를 변환 할 수 있습니다 DataFrame에서 &lt;a href=&quot;basics#basics-dtypes&quot;&gt;여기에&lt;/a&gt; 나열 됩니다 . 이것은 &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.read_excel#pandas.read_excel&quot;&gt; &lt;code&gt;read_excel()&lt;/code&gt; &lt;/a&gt; 과 같은 판독기가 기본 dtype을 추론 할 때 데이터 세트를 읽은 후 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="a6d12092a100fe501656091bdf566b30b2ed9abe" translate="yes" xml:space="preserve">
          <source>If you have a code snippet that wraps multiple lines, you need to use &amp;lsquo;&amp;hellip;&amp;rsquo; on the continued lines:</source>
          <target state="translated">여러 줄을 감싸는 코드 스 니펫이 있으면 계속 줄에 '&amp;hellip;'를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce1c3f4a8b1303b2233ce9f8b61542133b12817a" translate="yes" xml:space="preserve">
          <source>If you have a function that takes the data as (say) the second argument, pass a tuple indicating which keyword expects the data. For example, suppose &lt;code&gt;f&lt;/code&gt; takes its data as &lt;code&gt;arg2&lt;/code&gt;:</source>
          <target state="translated">데이터를 두 번째 인수로 사용하는 함수가 있으면 데이터를 기대하는 키워드를 나타내는 튜플을 전달하십시오. 예를 들어, 가정하자 &lt;code&gt;f&lt;/code&gt; 로 데이터를 얻어 &lt;code&gt;arg2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56a4c8962933a12e5a9e2a5d7dffcb9394a6134b" translate="yes" xml:space="preserve">
          <source>If you have a really non-standard format, use a custom &lt;code&gt;date_parser&lt;/code&gt; function. For optimal performance, this should be vectorized, i.e., it should accept arrays as arguments.</source>
          <target state="translated">정말 비표준 형식이있는 경우 사용자 지정 &lt;code&gt;date_parser&lt;/code&gt; 함수를 사용하십시오. 최적의 성능을 위해 이것은 벡터화되어야합니다. 즉, 배열을 인수로 받아 들여야합니다.</target>
        </trans-unit>
        <trans-unit id="4bce04d77a3695fe541ba97dbace1da91706c1a3" translate="yes" xml:space="preserve">
          <source>If you have a test that would emit a warning, but you aren&amp;rsquo;t actually testing the warning itself (say because it&amp;rsquo;s going to be removed in the future, or because we&amp;rsquo;re matching a 3rd-party library&amp;rsquo;s behavior), then use &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; to ignore the error.</source>
          <target state="translated">경고를 발생시키는 테스트가 있지만 실제로 경고 자체를 테스트하지 않는 경우 (예 : 향후 제거 될 예정이거나 타사 라이브러리의 동작과 일치하기 때문에) &lt;code&gt;pytest.mark.filterwarnings&lt;/code&gt; 를 사용 하십시오. .mark.filterwarnings 는 오류를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="71117c5bba102f9e8b43378fc40f53207cd5d122" translate="yes" xml:space="preserve">
          <source>If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions</source>
          <target state="translated">데이터베이스에 대한 SQLAlchemy 설명이있는 경우 SQLAlchemy 표현식을 사용하여 조건을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e53b0f81dd0d27916b9567f3537fac3de69986c" translate="yes" xml:space="preserve">
          <source>If you have created a new file, it is not being tracked by git. Add it by typing:</source>
          <target state="translated">새 파일을 만든 경우 git에서 파일을 추적하지 않습니다. 다음을 입력하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="15be1e2a8dd36c4d3fa91d03c09bda6ba985f358" translate="yes" xml:space="preserve">
          <source>If you have data that is outside of the &lt;code&gt;Timestamp&lt;/code&gt; bounds, see &lt;a href=&quot;#timeseries-timestamp-limits&quot;&gt;Timestamp limitations&lt;/a&gt;, then you can use a &lt;code&gt;PeriodIndex&lt;/code&gt; and/or &lt;code&gt;Series&lt;/code&gt; of &lt;code&gt;Periods&lt;/code&gt; to do computations.</source>
          <target state="translated">&lt;code&gt;Timestamp&lt;/code&gt; 경계를 벗어난 데이터가있는 경우 &lt;a href=&quot;#timeseries-timestamp-limits&quot;&gt;타임 스탬프 제한 사항을&lt;/a&gt; 참조하십시오 . 그런 다음 &lt;code&gt;PeriodIndex&lt;/code&gt; 및 / 또는 &lt;code&gt;Series&lt;/code&gt; 의 &lt;code&gt;Periods&lt;/code&gt; 을 사용하여 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd3e79e7aaca2c9a3799bfafe49c89cd6d0b4f3" translate="yes" xml:space="preserve">
          <source>If you have more than one plot that needs to be suppressed, the &lt;code&gt;use&lt;/code&gt; method in &lt;code&gt;pandas.plotting.plot_params&lt;/code&gt; can be used in a &lt;code&gt;with&lt;/code&gt; statement:</source>
          <target state="translated">억제해야하는 플롯이 두 개 이상있는 &lt;code&gt;use&lt;/code&gt; &lt;code&gt;pandas.plotting.plot_params&lt;/code&gt; 의 use 메서드를 &lt;code&gt;with&lt;/code&gt; 문 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88a4ccdcf75e8833f91575d8840de48cc6dfbca8" translate="yes" xml:space="preserve">
          <source>If you have multi-index columns:</source>
          <target state="translated">다중 색인 열이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="1610c5a9f274b426003a33163f560701a7d5688a" translate="yes" xml:space="preserve">
          <source>If you have multiple conditions, you can use &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select&quot;&gt;&lt;code&gt;numpy.select()&lt;/code&gt;&lt;/a&gt; to achieve that. Say corresponding to three conditions there are three choice of colors, with a fourth color as a fallback, you can do the following.</source>
          <target state="translated">여러 조건이있는 경우 &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select&quot;&gt; &lt;code&gt;numpy.select()&lt;/code&gt; &lt;/a&gt; 를 사용 하여이를 달성 할 수 있습니다 . 세 가지 조건에 따라 세 가지 색상을 선택하고 네 번째 색상을 폴백으로 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ad80e0520119e0bea6b4d13398628db73a1bdcc" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes at the moment you want to update the branch with master, you will need to &lt;code&gt;stash&lt;/code&gt; them prior to updating (see the &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;stash docs&lt;/a&gt;). This will effectively store your changes and they can be reapplied after updating.</source>
          <target state="translated">master로 분기를 업데이트하려는 시점에 커밋되지 않은 변경 사항이있는 경우 &lt;code&gt;stash&lt;/code&gt; 하기 전에 합니다 ( &lt;a href=&quot;https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning&quot;&gt;stash docs&lt;/a&gt; 참조 ). 이렇게하면 변경 사항이 효과적으로 저장되며 업데이트 후에 다시 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="247d69c8f2cc4de2283149f111517ab75bb87577" translate="yes" xml:space="preserve">
          <source>If you have values approximating a cumulative distribution function, then &lt;code&gt;method='pchip'&lt;/code&gt; should work well.</source>
          <target state="translated">누적 분포 함수에 가까운 값이 있으면 &lt;code&gt;method='pchip'&lt;/code&gt; 이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="71d3bbb491c7ab50f4e3fb55087b95818a33a2bf" translate="yes" xml:space="preserve">
          <source>If you just want to handle one column as a categorical variable (like R&amp;rsquo;s factor), you can use &lt;code&gt;df[&quot;cat_col&quot;] = pd.Categorical(df[&quot;col&quot;])&lt;/code&gt; or &lt;code&gt;df[&quot;cat_col&quot;] = df[&quot;col&quot;].astype(&quot;category&quot;)&lt;/code&gt;. For full docs on &lt;a href=&quot;../reference/api/pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt;, see the &lt;a href=&quot;categorical#categorical&quot;&gt;Categorical introduction&lt;/a&gt; and the &lt;a href=&quot;../reference/arrays#api-arrays-categorical&quot;&gt;API documentation&lt;/a&gt;.</source>
          <target state="translated">R의 인수와 같은 범주 형 변수로 하나의 열을 처리하려는 경우 &lt;code&gt;df[&quot;cat_col&quot;] = pd.Categorical(df[&quot;col&quot;])&lt;/code&gt; 또는 &lt;code&gt;df[&quot;cat_col&quot;] = df[&quot;col&quot;].astype(&quot;category&quot;)&lt;/code&gt; . &lt;a href=&quot;../reference/api/pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; &lt;/a&gt; 에 대한 전체 문서 는 &lt;a href=&quot;categorical#categorical&quot;&gt;범주 형 소개&lt;/a&gt; 및 &lt;a href=&quot;../reference/arrays#api-arrays-categorical&quot;&gt;API 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9ea4b81cff5c89da5d8728c0c720182331aed2b" translate="yes" xml:space="preserve">
          <source>If you know the format, use &lt;code&gt;pd.to_datetime()&lt;/code&gt;: &lt;code&gt;date_parser=lambda x: pd.to_datetime(x, format=...)&lt;/code&gt;.</source>
          <target state="translated">형식을 알고 있다면 &lt;code&gt;pd.to_datetime()&lt;/code&gt; : &lt;code&gt;date_parser=lambda x: pd.to_datetime(x, format=...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a716fc818c498688ccdf097fd60bb57e60c32a5" translate="yes" xml:space="preserve">
          <source>If you know you need a NumPy array, use &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;to_numpy()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;numpy.asarray()&lt;/code&gt;.</source>
          <target state="translated">NumPy 배열이 필요하다는 것을 알고 있다면 &lt;a href=&quot;../reference/api/pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;to_numpy()&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;numpy.asarray()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eadfdb34403ad34e86a99ae41be9ea1264eab6e2" translate="yes" xml:space="preserve">
          <source>If you need additional logic to handle duplicate labels, rather than just dropping the repeats, using &lt;code&gt;groupby()&lt;/code&gt; on the index is a common trick. For example, we&amp;rsquo;ll resolve duplicates by taking the average of all rows with the same label.</source>
          <target state="translated">중복 레이블을 처리하기위한 추가 논리가 필요한 경우 , 인덱스에 &lt;code&gt;groupby()&lt;/code&gt; 를 사용 하는 것이 일반적인 트릭입니다. 예를 들어 동일한 레이블을 가진 모든 행의 평균을 구하여 중복을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="1285b10e07e025b0f5ded4a959a18da26d5f6127" translate="yes" xml:space="preserve">
          <source>If you need finer-grained control, you can use Python&amp;rsquo;s usual &lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt;warnings module&lt;/a&gt; to control whether a warning is ignored / raised at different places within a single test.</source>
          <target state="translated">더 세밀한 제어가 필요한 경우 Python의 평소와 같이 사용할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3/library/warnings.html&quot;&gt; 경고 모듈&lt;/a&gt; 을 하여 단일 테스트 내의 다른 위치에서 경고를 무시 / 발생 시킬지 여부를 제어 .</target>
        </trans-unit>
        <trans-unit id="56e5fa9a528ad91081e25594019830af1e89d7a2" translate="yes" xml:space="preserve">
          <source>If you need integer based selection, you should use &lt;code&gt;iloc&lt;/code&gt;:</source>
          <target state="translated">정수 기반 선택이 필요한 경우 &lt;code&gt;iloc&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9abdfc1c00b5fd40564a95fa7255b69eb7054961" translate="yes" xml:space="preserve">
          <source>If you need packages that are available to pip but not conda, then install pip, and then use pip to install those packages:</source>
          <target state="translated">pip에는 사용할 수 있지만 conda에는없는 패키지가 필요한 경우 pip를 설치 한 다음 pip를 사용하여 해당 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="f1e4f52552e9e7307e462d0dc56ddd6709abf810" translate="yes" xml:space="preserve">
          <source>If you need the actual array backing a &lt;code&gt;Series&lt;/code&gt;, use &lt;a href=&quot;../reference/api/pandas.series.array#pandas.Series.array&quot;&gt;&lt;code&gt;Series.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 를 지원하는 실제 어레이가 필요하면 &lt;a href=&quot;../reference/api/pandas.series.array#pandas.Series.array&quot;&gt; &lt;code&gt;Series.array&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3bc12041bab368ec20ccfaba0caed898614b818" translate="yes" xml:space="preserve">
          <source>If you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the &lt;a href=&quot;enhancingperf#enhancingperf&quot;&gt;enhancing performance&lt;/a&gt; section for some examples of this approach.</source>
          <target state="translated">값에 대해 반복적 인 조작이 필요하지만 성능이 중요한 경우 cython 또는 numba를 사용하여 내부 루프를 작성하는 것이 좋습니다. 이 접근 방식의 몇 가지 예는 &lt;a href=&quot;enhancingperf#enhancingperf&quot;&gt;성능 향상&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2163ffd026f03007f2657d1aa45cced3b636cb62" translate="yes" xml:space="preserve">
          <source>If you need to represent integers with possibly missing values, use one of the nullable-integer extension dtypes provided by pandas</source>
          <target state="translated">누락 된 값이있는 정수를 나타내야하는 경우 pandas에서 제공하는 nullable 정수 확장 dtype 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6464b5756b83cd90f8547c8b9746a2e4119403d" translate="yes" xml:space="preserve">
          <source>If you need to run a benchmark, change your directory to &lt;code&gt;asv_bench/&lt;/code&gt; and run:</source>
          <target state="translated">벤치 마크를 실행해야하는 경우 디렉토리를 &lt;code&gt;asv_bench/&lt;/code&gt; 변경하십시오. 하고 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="5cd75591fba8c48a6ec96f77cf45ec1114588623" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;margins=True&lt;/code&gt; to &lt;code&gt;pivot_table&lt;/code&gt;, special &lt;code&gt;All&lt;/code&gt; columns and rows will be added with partial group aggregates across the categories on the rows and columns:</source>
          <target state="translated">&lt;code&gt;margins=True&lt;/code&gt; 를 &lt;code&gt;pivot_table&lt;/code&gt; 에 전달하면 특수한 &lt;code&gt;All&lt;/code&gt; 열과 행이 행과 열의 범주에 걸쳐 부분 그룹 집계와 함께 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="976af2f6fab5f0ae12fdcf76be0120e4404254cf" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;orient='index'&lt;/code&gt;, the keys will be the row labels. In this case, you can also pass the desired column names:</source>
          <target state="translated">&lt;code&gt;orient='index'&lt;/code&gt; 를 전달 하면 키가 행 레이블이됩니다. 이 경우 원하는 열 이름을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b70868c4ee48742da635c260d8cd9f3a080b210" translate="yes" xml:space="preserve">
          <source>If you pass a Series to &lt;a href=&quot;../reference/api/pandas.dataframe.align#pandas.DataFrame.align&quot;&gt;&lt;code&gt;DataFrame.align()&lt;/code&gt;&lt;/a&gt;, you can choose to align both objects either on the DataFrame&amp;rsquo;s index or columns using the &lt;code&gt;axis&lt;/code&gt; argument:</source>
          <target state="translated">Series를 &lt;a href=&quot;../reference/api/pandas.dataframe.align#pandas.DataFrame.align&quot;&gt; &lt;code&gt;DataFrame.align()&lt;/code&gt; &lt;/a&gt; 전달 하면 &lt;code&gt;axis&lt;/code&gt; 인수를 사용하여 DataFrame의 인덱스 또는 열에서 두 개체를 모두 정렬하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b0a373c7cc571366c10185793baa20f98905f8d" translate="yes" xml:space="preserve">
          <source>If you pass a function, it must return a value when called with any of the labels (and must produce a set of unique values). A dict or Series can also be used:</source>
          <target state="translated">함수를 전달하는 경우 레이블과 함께 호출 될 때 값을 반환해야합니다 (고유 값 집합을 생성해야 함). dict 또는 Series를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c6e882d9eb5401127c01282e6bbb98c5ee31ca" translate="yes" xml:space="preserve">
          <source>If you pass a single string to &lt;code&gt;to_datetime&lt;/code&gt;, it returns a single &lt;code&gt;Timestamp&lt;/code&gt;. &lt;code&gt;Timestamp&lt;/code&gt; can also accept string input, but it doesn&amp;rsquo;t accept string parsing options like &lt;code&gt;dayfirst&lt;/code&gt; or &lt;code&gt;format&lt;/code&gt;, so use &lt;code&gt;to_datetime&lt;/code&gt; if these are required.</source>
          <target state="translated">&lt;code&gt;to_datetime&lt;/code&gt; 에 단일 문자열을 전달 하면 단일 &lt;code&gt;Timestamp&lt;/code&gt; 를 반환합니다 . &lt;code&gt;Timestamp&lt;/code&gt; 는 문자열 입력도 허용 할 수 있지만 &lt;code&gt;dayfirst&lt;/code&gt; 또는 &lt;code&gt;format&lt;/code&gt; 과 같은 문자열 구문 분석 옵션을 허용하지 않으므로 필요한 경우 &lt;code&gt;to_datetime&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="8f45d99e2ee0921bed375bc8861439fdec9a9792" translate="yes" xml:space="preserve">
          <source>If you pass values whose sum total is less than 1.0, matplotlib draws a semicircle.</source>
          <target state="translated">합계가 1.0 미만인 값을 전달하면 matplotlib는 반원을 그립니다.</target>
        </trans-unit>
        <trans-unit id="632406b5aa18fdb674faf69296473f0d12e452b9" translate="yes" xml:space="preserve">
          <source>If you see output like the below in &lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; checks:</source>
          <target state="translated">&lt;a href=&quot;#contributing-ci&quot;&gt;Continuous Integration&lt;/a&gt; 에서 다음과 같은 출력이 표시되는 경우 검사 :</target>
        </trans-unit>
        <trans-unit id="288307bac0582bc58303b0b714a45cbb853bef32" translate="yes" xml:space="preserve">
          <source>If you select a label &lt;em&gt;contained&lt;/em&gt; within an interval, this will also select the interval.</source>
          <target state="translated">간격 내에 &lt;em&gt;포함&lt;/em&gt; 된 레이블 을 선택하면 간격도 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="97fe72667c3b81a7bfa27ffdd0cd1ec5b244cfc6" translate="yes" xml:space="preserve">
          <source>If you use dates which start with the day first (i.e. European style), you can pass the &lt;code&gt;dayfirst&lt;/code&gt; flag:</source>
          <target state="translated">첫날 (예 : 유럽식)로 시작하는 날짜를 사용하는 경우 &lt;code&gt;dayfirst&lt;/code&gt; 플래그를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="826366db7d9516e4c1549c46a4ef6fe02c423fcb" translate="yes" xml:space="preserve">
          <source>If you use locks to manage write access between multiple processes, you may want to use &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fsync&quot;&gt;&lt;code&gt;fsync()&lt;/code&gt;&lt;/a&gt; before releasing write locks. For convenience you can use &lt;code&gt;store.flush(fsync=True)&lt;/code&gt; to do this for you.</source>
          <target state="translated">잠금을 사용하여 여러 프로세스 간의 쓰기 액세스를 관리하는 경우 쓰기 잠금을 해제하기 전에 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fsync&quot;&gt; &lt;code&gt;fsync()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 . 편의를 위해 &lt;code&gt;store.flush(fsync=True)&lt;/code&gt; 를 사용 하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b6748b33160c9896abd9c3b4018432b2fa8ff70" translate="yes" xml:space="preserve">
          <source>If you want a</source>
          <target state="translated">원하는 경우</target>
        </trans-unit>
        <trans-unit id="30ed4c27edf0b54fe936d124ccd9179b9a98665c" translate="yes" xml:space="preserve">
          <source>If you want a &lt;code&gt;defaultdict&lt;/code&gt;, you need to initialize it:</source>
          <target state="translated">당신이 &lt;code&gt;defaultdict&lt;/code&gt; 를 원한다면 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="da78135cd296f262655fefcba77395d1f17b8c5b" translate="yes" xml:space="preserve">
          <source>If you want literal replacement of a string (equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.replace&quot;&gt;&lt;code&gt;str.replace()&lt;/code&gt;&lt;/a&gt;), you can set the optional &lt;code&gt;regex&lt;/code&gt; parameter to &lt;code&gt;False&lt;/code&gt;, rather than escaping each character. In this case both &lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;repl&lt;/code&gt; must be strings:</source>
          <target state="translated">문자열의 리터럴 교체 ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.replace&quot;&gt; &lt;code&gt;str.replace()&lt;/code&gt; &lt;/a&gt; 와 동일 )를 원한다면 , 각 문자를 이스케이프하는 대신 선택적 &lt;code&gt;regex&lt;/code&gt; 매개 변수를 &lt;code&gt;False&lt;/code&gt; 로 설정할 수 있습니다 . 이 경우 &lt;code&gt;pat&lt;/code&gt; 과 &lt;code&gt;repl&lt;/code&gt; 은 모두 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e6b94aa79bc7cda927f9dd9bef83486c02c863c7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the maximum, use &lt;code&gt;idxmax&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;em&gt;색인&lt;/em&gt; 을 원하면 &lt;code&gt;idxmax&lt;/code&gt; 를 사용 하십시오 . 이것은 &lt;code&gt;numpy.ndarray&lt;/code&gt; 메소드 &lt;code&gt;argmax&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="da99536b7cebadbafed991dfc4d1e9297843d4f2" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the maximum, use &lt;code&gt;idxmax&lt;/code&gt;. This isthe equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="translated">최대 &lt;em&gt;인덱스&lt;/em&gt; 를 원하면 &lt;code&gt;idxmax&lt;/code&gt; 를 사용 하십시오 . 이것은 &lt;code&gt;numpy.ndarray&lt;/code&gt; 메소드 &lt;code&gt;argmax&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9b950797521b756aeaf591d6f6cec56c5160f174" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the minimum, use &lt;code&gt;idxmin&lt;/code&gt;. This is the equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">최소 &lt;em&gt;인덱스&lt;/em&gt; 를 원하면 &lt;code&gt;idxmin&lt;/code&gt; 을 사용 하십시오 . 이것은 &lt;code&gt;numpy.ndarray&lt;/code&gt; 메소드 &lt;code&gt;argmin&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4215c4240d2b96b95049f942871fecaec754b8c9" translate="yes" xml:space="preserve">
          <source>If you want the &lt;em&gt;index&lt;/em&gt; of the minimum, use &lt;code&gt;idxmin&lt;/code&gt;. This isthe equivalent of the &lt;code&gt;numpy.ndarray&lt;/code&gt; method &lt;code&gt;argmin&lt;/code&gt;.</source>
          <target state="translated">최소 &lt;em&gt;인덱스&lt;/em&gt; 를 원하면 &lt;code&gt;idxmin&lt;/code&gt; 을 사용 하십시오 . 이것은 &lt;code&gt;numpy.ndarray&lt;/code&gt; 메소드 &lt;code&gt;argmin&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="324b614ff3eac5f57300aa2b07bed38fd549fbcf" translate="yes" xml:space="preserve">
          <source>If you want to adjust the start of the bins based on a fixed timestamp:</source>
          <target state="translated">고정 된 타임 스탬프를 기반으로 빈의 시작을 조정하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="d48bf81b5b17c8f77d08206ccd9d4824d6c3996e" translate="yes" xml:space="preserve">
          <source>If you want to adjust the start of the bins with an</source>
          <target state="translated">빈의 시작을 조정하려면</target>
        </trans-unit>
        <trans-unit id="38c72be389f57078f7031a3f750835e41af8a1e4" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories,</source>
          <target state="translated">범주가 같을 필요는없는 범주를 결합하려는 경우</target>
        </trans-unit>
        <trans-unit id="90ceed891230ae542e55ffbac52ad427e321e79a" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories, &lt;code&gt;union_categoricals&lt;/code&gt; will combine a list-like of categoricals. The new categories will be the union of the categories being combined.</source>
          <target state="translated">동일한 범주를 가질 필요가없는 범주를 결합하려는 경우 &lt;code&gt;union_categoricals&lt;/code&gt; 는 목록과 같은 범주를 결합합니다. 새로운 범주는 결합되는 범주의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="f70b3672763179b3ba5414e9cc915c8902e77cfd" translate="yes" xml:space="preserve">
          <source>If you want to combine categoricals that do not necessarily have the same categories, the &lt;a href=&quot;../reference/api/pandas.api.types.union_categoricals#pandas.api.types.union_categoricals&quot;&gt;&lt;code&gt;union_categoricals()&lt;/code&gt;&lt;/a&gt; function will combine a list-like of categoricals. The new categories will be the union of the categories being combined.</source>
          <target state="translated">동일한 범주를 가질 필요가없는 범주를 결합하려는 경우 &lt;a href=&quot;../reference/api/pandas.api.types.union_categoricals#pandas.api.types.union_categoricals&quot;&gt; &lt;code&gt;union_categoricals()&lt;/code&gt; &lt;/a&gt; 함수는 목록과 유사한 범주를 결합합니다. 새로운 카테고리는 결합되는 카테고리의 조합이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb077c2288f1403c4b0ecbd42403a54af7be64aa" translate="yes" xml:space="preserve">
          <source>If you want to consider &lt;code&gt;inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; to be &amp;ldquo;NA&amp;rdquo; in computations, you can set &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt;.</source>
          <target state="translated">계산에서 &lt;code&gt;inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 를 &quot;NA&quot; 로 간주 하려면 다음을 설정할 수 있습니다. &lt;code&gt;pandas.options.mode.use_inf_as_na = True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="105ffd39b32076ebf1ebd3d7165f004063f83832" translate="yes" xml:space="preserve">
          <source>If you want to do a &amp;ldquo;non-equality&amp;rdquo; comparison of a categorical series with a list-like object which is not categorical data, you need to be explicit and convert the categorical data back to the original values:</source>
          <target state="translated">범주 형 데이터가 아닌 목록 형 개체와 범주 형 시리즈의 &quot;비동 등&quot;비교를 수행하려면 명시 적이어야하며 범주 형 데이터를 다시 원래 값으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a494419aff90e75a65fca5fcb99703bd1e43872" translate="yes" xml:space="preserve">
          <source>If you want to do a full clean build, do:</source>
          <target state="translated">완전히 깨끗하게 빌드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9364d4a7de813e6cc040e7514a87f830c1e52fa7" translate="yes" xml:space="preserve">
          <source>If you want to do remove and add new categories in one step (which has some speed advantage), or simply set the categories to a predefined scale, use &lt;code&gt;set_categories()&lt;/code&gt;.</source>
          <target state="translated">한 번에 새 카테고리를 제거하고 추가하려면 (일부 속도 이점이 있음) 또는 단순히 카테고리를 사전 정의 된 척도로 설정하려면 &lt;code&gt;set_categories()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="496ed137ac195eaa0b96ba47dbede5d3d45026e0" translate="yes" xml:space="preserve">
          <source>If you want to get a buffer to the parquet content you can use a io.BytesIO object, as long as you don&amp;rsquo;t use partition_cols, which creates multiple files.</source>
          <target state="translated">parquet 콘텐츠에 대한 버퍼를 얻으려면 여러 파일을 만드는 partition_cols를 사용하지 않는 한 io.BytesIO 개체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca2aaf5871712e332fd47e4529e86f2d40fbf9d" translate="yes" xml:space="preserve">
          <source>If you want to have more control on which packages, or have a limited internet bandwidth, then installing pandas with &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; may be a better solution.</source>
          <target state="translated">어떤 패키지를 더 많이 제어하거나 인터넷 대역폭이 제한적인 경우 &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; 를 사용하여 팬더를 설치하십시오. 하는 것이 더 나은 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e630d4535a19d2c51476c3a14031d74da486a01" translate="yes" xml:space="preserve">
          <source>If you want to hide wedge labels, specify &lt;code&gt;labels=None&lt;/code&gt;. If &lt;code&gt;fontsize&lt;/code&gt; is specified, the value will be applied to wedge labels. Also, other keywords supported by &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie&quot;&gt;&lt;code&gt;matplotlib.pyplot.pie()&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="translated">쐐기 레이블을 숨기려면 &lt;code&gt;labels=None&lt;/code&gt; 을 지정하십시오 . 경우 &lt;code&gt;fontsize&lt;/code&gt; 지정되면, 값은 쐐기 라벨에 적용됩니다. 또한 &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.pie.html#matplotlib.pyplot.pie&quot;&gt; &lt;code&gt;matplotlib.pyplot.pie()&lt;/code&gt; &lt;/a&gt; 지원하는 다른 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="838c6416400ccef4da44e58e719db49e883edf34" translate="yes" xml:space="preserve">
          <source>If you want to identify and remove duplicate rows in a DataFrame, there are two methods that will help: &lt;code&gt;duplicated&lt;/code&gt; and &lt;code&gt;drop_duplicates&lt;/code&gt;. Each takes as an argument the columns to use to identify duplicated rows.</source>
          <target state="translated">DataFrame에서 중복 행을 식별하고 제거하려면 &lt;code&gt;duplicated&lt;/code&gt; 및 &lt;code&gt;drop_duplicates&lt;/code&gt; 두 가지 방법이 있습니다. 각각은 중복 된 행을 식별하는 데 사용할 열을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a59364a4030877526c3fb43a1076dbe047f4ce00" translate="yes" xml:space="preserve">
          <source>If you want to include &lt;strong&gt;all&lt;/strong&gt; of data categories even if the actual data does not contain any instances of a particular category, you should set &lt;code&gt;dropna=False&lt;/code&gt;.</source>
          <target state="translated">실제 데이터에 특정 범주의 인스턴스가 포함되어 있지 않더라도 &lt;strong&gt;모든&lt;/strong&gt; 데이터 범주 를 포함 하려면 &lt;code&gt;dropna=False&lt;/code&gt; 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba39bcec7f6db4e1b09827720ef4bb35fbb65050" translate="yes" xml:space="preserve">
          <source>If you want to inspect the stored object, retrieve via &lt;code&gt;get_storer&lt;/code&gt;. You could use this programmatically to say get the number of rows in an object.</source>
          <target state="translated">저장된 객체를 검사하려면 &lt;code&gt;get_storer&lt;/code&gt; 를 통해 검색 하십시오 . 이를 프로그래밍 방식으로 사용하여 개체의 행 수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0960af5a9c3a1fb441fc7e6e682d503ea6726c" translate="yes" xml:space="preserve">
          <source>If you want to manage your own connections you can pass one of those instead:</source>
          <target state="translated">자신의 연결을 관리하려면 대신 다음 중 하나를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95a5a881302f9b77f030472899c0c61a452bf781" translate="yes" xml:space="preserve">
          <source>If you want to omit a dataframe&amp;rsquo;s indexes when writing, pass &lt;code&gt;index=False&lt;/code&gt; to &lt;a href=&quot;../reference/api/pandas.dataframe.to_parquet#pandas.DataFrame.to_parquet&quot;&gt;&lt;code&gt;to_parquet()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">쓸 때 데이터 프레임의 인덱스를 생략하려면 &lt;code&gt;index=False&lt;/code&gt; 를 &lt;a href=&quot;../reference/api/pandas.dataframe.to_parquet#pandas.DataFrame.to_parquet&quot;&gt; &lt;code&gt;to_parquet()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f39c7a5a2ebd376e45bc4789c9e32d770747fa47" translate="yes" xml:space="preserve">
          <source>If you want to only run a specific group of tests from a file, you can do it using &lt;code&gt;.&lt;/code&gt; as a separator. For example:</source>
          <target state="translated">파일에서 특정 그룹의 테스트 만 실행하려면을 사용하여 수행 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 분리기로. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="431c2f4b44553a66b404402f29529cfcdabf6d56" translate="yes" xml:space="preserve">
          <source>If you want to pass in a path object, pandas accepts any &lt;code&gt;os.PathLike&lt;/code&gt;.</source>
          <target state="translated">경로 객체를 전달하려는 경우 pandas는 &lt;code&gt;os.PathLike&lt;/code&gt; 를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="260a6b638018f13e44320b83a5f3393470170f1f" translate="yes" xml:space="preserve">
          <source>If you want to select the nth not-null item, use the &lt;code&gt;dropna&lt;/code&gt; kwarg. For a DataFrame this should be either &lt;code&gt;'any'&lt;/code&gt; or &lt;code&gt;'all'&lt;/code&gt; just like you would pass to dropna:</source>
          <target state="translated">Null이 아닌 n 번째 항목을 선택하려면 &lt;code&gt;dropna&lt;/code&gt; kwarg를 사용합니다 . DataFrame의 경우 dropna에 전달하는 것처럼 &lt;code&gt;'any'&lt;/code&gt; 또는 &lt;code&gt;'all'&lt;/code&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8e69cf53c2f90f63fca612ceaf55108d6a7645de" translate="yes" xml:space="preserve">
          <source>If you want to show a case where an exception is raised, you can do:</source>
          <target state="translated">예외가 발생한 경우를 표시하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3444f60978a55340c6fd4266fe2afeb502624670" translate="yes" xml:space="preserve">
          <source>If you want to show that &lt;code&gt;s.plot()&lt;/code&gt; returns a matplotlib AxesSubplot object, this will fail the doctest</source>
          <target state="translated">&lt;code&gt;s.plot()&lt;/code&gt; 이 matplotlib AxesSubplot 객체를 반환 한다는 것을 보여 주려면 doctest가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8341aec896361ab00c05ae9a1482550fce8e4f42" translate="yes" xml:space="preserve">
          <source>If you wish to get the 0th and the 2nd elements from the index in the &amp;lsquo;A&amp;rsquo; column, you can do:</source>
          <target state="translated">'A'열의 색인에서 0 번째 및 2 번째 요소를 얻으려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b6a034b92c3c225415a2cbf07b02e0810a9cdc" translate="yes" xml:space="preserve">
          <source>If you wish to keep all original rows and columns, set &lt;code&gt;keep_shape&lt;/code&gt; argument to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">모든 원래 행과 열을 유지하려면 &lt;code&gt;keep_shape&lt;/code&gt; 인수를 &lt;code&gt;True&lt;/code&gt; 로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6fca580ca146fe1287a019a063eff316214cd98" translate="yes" xml:space="preserve">
          <source>If you wish to specify other levels (as will occasionally be the case), you can do so using the &lt;code&gt;levels&lt;/code&gt; argument:</source>
          <target state="translated">경우에 따라 다른 수준을 지정하려면 &lt;code&gt;levels&lt;/code&gt; 인수를 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5357656a53a0ea6cda290cc82e0cca1c51833255" translate="yes" xml:space="preserve">
          <source>If you wish to write to more than one sheet in the workbook, it is necessary to specify an ExcelWriter object:</source>
          <target state="translated">통합 문서에서 둘 이상의 시트에 쓰려면 ExcelWriter 개체를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0ac4887afa33726cb4047a790d5d629409d0a01" translate="yes" xml:space="preserve">
          <source>If you wish, you may choose to stack the differences on rows.</source>
          <target state="translated">원하는 경우 행에 차이를 누적하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55c38761c27fc078a6f71bc308a6215ee7bb40a4" translate="yes" xml:space="preserve">
          <source>If you would like pandas to be more or less trusting about assignment to a chained indexing expression, you can set the &lt;a href=&quot;options#options&quot;&gt;option&lt;/a&gt;&lt;code&gt;mode.chained_assignment&lt;/code&gt; to one of these values:</source>
          <target state="translated">pandas가 체인 인덱싱 표현식에 대한 할당에 대해 어느 정도 신뢰하도록하려면 &lt;code&gt;mode.chained_assignment&lt;/code&gt; &lt;a href=&quot;options#options&quot;&gt;옵션&lt;/a&gt; 을 다음 값 중 하나로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a6f96245d6df3c307f3f4bfc1f0124b3effe146" translate="yes" xml:space="preserve">
          <source>If you would prefer to keep the &lt;code&gt;NA&lt;/code&gt; values you can manually fill them with &lt;code&gt;fillna(True)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NA&lt;/code&gt; 값 을 유지하려면 수동으로 &lt;code&gt;fillna(True)&lt;/code&gt; 채울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="603667115b7f0addd355740b600caf5f30806f25" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building a library that implements the interface, please publicize it on &lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;Extension data types&lt;/a&gt;.</source>
          <target state="translated">인터페이스를 구현하는 라이브러리를 구축하는 경우 &lt;a href=&quot;../ecosystem#ecosystem-extensions&quot;&gt;Extension 데이터 유형&lt;/a&gt; 에 공개하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6c8245d9d9f1878751eb8d7ab972407703ff1cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re having trouble pasting the above into your ipython, you may need to be using bleeding edge IPython for paste to play well with cell magics.</source>
          <target state="translated">위의 내용을 ipython에 붙여 넣는 데 문제가있는 경우 붙여 넣기에 블리딩 에지 ​​IPython을 사용하여 셀 마법과 잘 어울릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab47c63b2d6927d1db8e796a8720b53461c8e93d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re having trouble pasting the above into your ipython, you may need to be using bleeding edge ipython for paste to play well with cell magics.</source>
          <target state="translated">위의 내용을 ipython에 붙여 넣는 데 문제가있는 경우 셀 마법과 잘 어울리려면 블리딩 엣지 ipython을 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8179681b12d1079bcde2bda507f3523470acc9a8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in contributing, please visit the &lt;a href=&quot;../development/contributing#contributing&quot;&gt;contributing guide&lt;/a&gt;.</source>
          <target state="translated">기고에 관심이 있다면 &lt;a href=&quot;../development/contributing#contributing&quot;&gt;기고 가이드&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="954e9c7dcd852245711eafdd97aac0e41254af2a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re new to pandas, you might want to first read through &lt;a href=&quot;../10min#min&quot;&gt;10 Minutes to pandas&lt;/a&gt; to familiarize yourself with the library.</source>
          <target state="translated">팬더를 처음 사용하는 경우 먼저 &lt;a href=&quot;../10min#min&quot;&gt;팬더에게 10 분을&lt;/a&gt; 읽는 것이 좋습니다. 에게 라이브러리에 익숙해지는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cf4479cf67c908330f3502d0976c6b8c094f6f72" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here&amp;rsquo;s a subset of the attributes that will be completed:</source>
          <target state="translated">IPython을 사용하는 경우 열 이름 (공용 속성)에 대한 탭 완성이 자동으로 활성화됩니다. 완료 될 속성의 하위 집합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20447cc89f3341970de8f262a8187e6f8b87da3f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Python &amp;lt; 3.6 or pandas &amp;lt; 0.23, and an index is not passed, the &lt;code&gt;Series&lt;/code&gt; index will be the lexically ordered list of dict keys.</source>
          <target state="translated">Python &amp;lt;3.6 또는 pandas &amp;lt;0.23을 사용하고 인덱스가 전달되지 않은 경우 &lt;code&gt;Series&lt;/code&gt; 인덱스는 사전 순서가 지정된 사전 키 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="ea10e2f23c35ab01a19875e0da269fdf0c5585fe" translate="yes" xml:space="preserve">
          <source>If your change involves checking that a warning is actually emitted, use &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt;.</source>
          <target state="translated">변경 사항에 실제로 경고가 표시 &lt;code&gt;tm.assert_produces_warning(ExpectedWarning)&lt;/code&gt; 확인하는 경우 tm.assert_produces_warning (ExpectedWarning)을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="55c057d9cb3f679f9d738d6ec8fbd7a104357a59" translate="yes" xml:space="preserve">
          <source>If your code is an enhancement, it is most likely necessary to add usage examples to the existing documentation. This can be done following the section regarding documentation &lt;a href=&quot;#contributing-documentation&quot;&gt;above&lt;/a&gt;. Further, to let users know when this feature was added, the &lt;code&gt;versionadded&lt;/code&gt; directive is used. The sphinx syntax for that is:</source>
          <target state="translated">코드가 개선 된 경우 기존 문서에 사용 예제를 추가해야합니다. 이 작업은 &lt;a href=&quot;#contributing-documentation&quot;&gt;위의&lt;/a&gt; 문서 관련 섹션에 따라 수행 할 수 있습니다 . 또한이 기능이 추가 된시기를 사용자에게 알리기 위해 &lt;code&gt;versionadded&lt;/code&gt; 지시문이 사용됩니다. 스핑크스 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17297cf285c7c41a2305959b1d4993f6c38dfb8b" translate="yes" xml:space="preserve">
          <source>If your data does not follow this convention, please use the normal constructor.</source>
          <target state="translated">데이터가이 규칙을 따르지 않으면 일반 생성자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24ad4ea1217ea5f3ca6628c5a502cceebb4edfb0" translate="yes" xml:space="preserve">
          <source>If your desired output column names are not valid Python keywords, construct a dictionary and unpack the keyword arguments</source>
          <target state="translated">원하는 출력 열 이름이 유효한 Python 키워드가 아닌 경우 사전을 구성하고 키워드 인수의 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="98cbab20b6fb2abfa92fdc4fc1f66575059d0c3b" translate="yes" xml:space="preserve">
          <source>If your style function uses a &lt;code&gt;subset&lt;/code&gt; or &lt;code&gt;axis&lt;/code&gt; keyword argument, consider wrapping your function in a &lt;code&gt;functools.partial&lt;/code&gt;, partialing out that keyword.</source>
          <target state="translated">스타일 함수가 &lt;code&gt;subset&lt;/code&gt; 또는 &lt;code&gt;axis&lt;/code&gt; 키워드 인수를 사용하는 경우 해당 키워드를 &lt;code&gt;functools.partial&lt;/code&gt; 감싸는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="0577eb9b0205a991abdc93cdc5c980e96a949c1e" translate="yes" xml:space="preserve">
          <source>If/then logic</source>
          <target state="translated">논리</target>
        </trans-unit>
        <trans-unit id="537a32d1d7729f25747f50cd67c683b5fa307d78" translate="yes" xml:space="preserve">
          <source>Ignore NaN values when inferring the type.</source>
          <target state="translated">유형을 유추 할 때 NaN 값을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="0a84d018aa4bed7f09ba656bc9b54ababd117230" translate="yes" xml:space="preserve">
          <source>Ignore differing dtypes in columns with check_dtype.</source>
          <target state="translated">check_dtype이있는 열에서 다른 dtype을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="ad9ed1e274f3db919ec0acff031892fd9c7b7466" translate="yes" xml:space="preserve">
          <source>Ignore missing values when calculating weights; specify &lt;code&gt;True&lt;/code&gt; to reproduce pre-0.15.0 behavior.</source>
          <target state="translated">가중치를 계산할 때 누락 된 값을 무시하십시오. 0.15.0 이전 동작을 재현하려면 &lt;code&gt;True&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="2705a7c2d2d0fbc6c769f7fda4a47ca8dc459762" translate="yes" xml:space="preserve">
          <source>Ignore missing values when calculating weights; specify True to reproduce pre-0.15.0 behavior.</source>
          <target state="translated">가중치를 계산할 때 결 측값을 무시하십시오. 0.15.0 이전의 동작을 재현하려면 True를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c0ff52c3b715a732da704fc6f3adeec3e1261b21" translate="yes" xml:space="preserve">
          <source>Ignoring case sensitivity using</source>
          <target state="translated">다음을 사용하여 대소 문자 구분 무시</target>
        </trans-unit>
        <trans-unit id="9ea19abc80c5f9b9a3d69ac6d138608e64b4eae7" translate="yes" xml:space="preserve">
          <source>Ignoring case sensitivity using &lt;code&gt;flags&lt;/code&gt; with regex.</source>
          <target state="translated">정규식에 &lt;code&gt;flags&lt;/code&gt; 를 사용하여 대소 문자 구분을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="15a016f34e155f11682e304c096f6e7fed15242d" translate="yes" xml:space="preserve">
          <source>Ignoring indexes on the concatenation axis</source>
          <target state="translated">연결 축에서 인덱스 무시</target>
        </trans-unit>
        <trans-unit id="9ffd813cd81894c96ceecf900ec3ac39d754ec33" translate="yes" xml:space="preserve">
          <source>Ignoring line comments and empty lines</source>
          <target state="translated">줄 주석 및 빈 줄 무시</target>
        </trans-unit>
        <trans-unit id="c48163e8e369cc932393aa060be7a71ab51f15db" translate="yes" xml:space="preserve">
          <source>Immutable Index for period data.</source>
          <target state="translated">기간 데이터에 대한 불변 색인.</target>
        </trans-unit>
        <trans-unit id="fa675f0928ac3d188978d143601cfaef0581eebe" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing a monotonic integer range.</source>
          <target state="translated">단조 정수 범위를 구현하는 불변 인덱스.</target>
        </trans-unit>
        <trans-unit id="77bb5b08e773dcc647c2137be13943f11993af3a" translate="yes" xml:space="preserve">
          <source>Immutable Index implementing an ordered, sliceable set.</source>
          <target state="translated">정렬 가능하고 슬라이스 가능한 순서를 구현하는 불변 인덱스.</target>
        </trans-unit>
        <trans-unit id="09666a0d15aa17eade5da13deaf4058fff5e91c0" translate="yes" xml:space="preserve">
          <source>Immutable index of intervals that are closed on the same side.</source>
          <target state="translated">같은 쪽에서 닫힌 간격의 불변 인덱스.</target>
        </trans-unit>
        <trans-unit id="322432105222ac065c39c51c46ac7e62258f855b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values indicating regular periods in time such as particular years, quarters, months, etc.</source>
          <target state="translated">특정 연도, 분기, 월 등과 같은 일정한 시간을 나타내는 서수 값을 보유하는 불변의 ndarray</target>
        </trans-unit>
        <trans-unit id="337daa08831acb19d7ba65d5abaa56b4ada8d9e9" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values indicating regular periods in time.</source>
          <target state="translated">일정 기간을 나타내는 서수 값을 포함하는 변경 불가능한 ndarray입니다.</target>
        </trans-unit>
        <trans-unit id="95ddec45685f37191edce0f9c049167f337a12e2" translate="yes" xml:space="preserve">
          <source>Immutable ndarray holding ordinal values.</source>
          <target state="translated">서수 값을 보유하는 불변의 ndarray.</target>
        </trans-unit>
        <trans-unit id="ff5fce9b61c2b7d306def659869f8a2d0e740987" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray.</target>
        </trans-unit>
        <trans-unit id="632aea5fb4e51ab537ce029dad7185968ea1903b" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a1d7735d372421181df84b4198539d11f0bd5288" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Float64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely float labels.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다. Float64Index는 순수 부동 레이블 이있는 &lt;code&gt;Index&lt;/code&gt; 의 특수한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="a63505fab2255dbaad9e67cc969dee30b7999644" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. Int64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely integer labels.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다. Int64Index는 순수한 정수 레이블을 가진 특별한 &lt;code&gt;Index&lt;/code&gt; 사례입니다 .</target>
        </trans-unit>
        <trans-unit id="e2a7d783a146ccf2aebd945545d5c4801e5a2997" translate="yes" xml:space="preserve">
          <source>Immutable ndarray implementing an ordered, sliceable set. The basic object storing axis labels for all pandas objects. UInt64Index is a special case of &lt;code&gt;Index&lt;/code&gt; with purely unsigned integer labels.</source>
          <target state="translated">순서가 있고 슬라이스 가능한 세트를 구현하는 불변의 ndarray. 모든 팬더 객체의 축 레이블을 저장하는 기본 객체입니다. UInt64Index는 순수하게 부호없는 정수 레이블 이있는 특별한 &lt;code&gt;Index&lt;/code&gt; 케이스입니다 .</target>
        </trans-unit>
        <trans-unit id="3f9f35d14ce44451d11a45398cd4e7e33b22d52e" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of datetime64 data, represented internally as int64, and which can be boxed to Timestamp objects that are subclasses of datetime and carry metadata such as frequency information.</source>
          <target state="translated">내부적으로 int64로 표시되고 datetime의 서브 클래스 인 Timestamp 객체에 박스로 표시 될 수 있고 빈도 정보와 같은 메타 데이터를 전달할 수있는 datetime64 데이터의 변경 불가능한 ndarray입니다.</target>
        </trans-unit>
        <trans-unit id="a0c7ddd23ba079b38767357bd06b67a58ed2ef16" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects</source>
          <target state="translated">내부적으로 int64로 표시되고 timedelta 객체로 상자에 넣을 수있는 timedelta64 데이터의 변경 불가능한 ndarray</target>
        </trans-unit>
        <trans-unit id="5398d1add4bca5f5b7f2b03337b3d627dd293318" translate="yes" xml:space="preserve">
          <source>Immutable ndarray of timedelta64 data, represented internally as int64, and which can be boxed to timedelta objects.</source>
          <target state="translated">timedelta64 데이터의 변경 불가능한 ndarray는 내부적으로 int64로 표시되며 timedelta 객체에 boxing 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d546a7e1c870efa75e1e47b90e1203b5c50b7ac2" translate="yes" xml:space="preserve">
          <source>Immutable ndarray-like of datetime64 data.</source>
          <target state="translated">datetime64 데이터의 변경 불가능한 ndarray와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="5d4d9fb600d19bd44b1d23393cd235ddaf172e07" translate="yes" xml:space="preserve">
          <source>Immutable object implementing an Interval, a bounded slice-like interval.</source>
          <target state="translated">경계 슬라이스 유사 간격 인 Interval을 구현하는 불변 객체.</target>
        </trans-unit>
        <trans-unit id="505bb48d000edeee874dc5be5afd4732ecdf5ebd" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment.</source>
          <target state="translated">인덱싱 및 정렬에 사용되는 변경 불가능한 시퀀스.</target>
        </trans-unit>
        <trans-unit id="127cfce9c5b60f47493c14c12a2d15589ccdb84e" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects.</source>
          <target state="translated">인덱싱 및 정렬에 사용되는 변경 불가능한 시퀀스. 모든 pandas 객체에 대한 축 레이블을 저장하는 기본 객체입니다.</target>
        </trans-unit>
        <trans-unit id="0f38f448ebc934c19cecd4c61d947b66ce618345" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. Float64Index is a special case of</source>
          <target state="translated">인덱싱 및 정렬에 사용되는 변경 불가능한 시퀀스. 모든 pandas 객체에 대한 축 레이블을 저장하는 기본 객체입니다. Float64Index는</target>
        </trans-unit>
        <trans-unit id="0b9732e001aecfcbbba7d1d2226b813ee863d077" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. Int64Index is a special case of</source>
          <target state="translated">인덱싱 및 정렬에 사용되는 변경 불가능한 시퀀스. 모든 pandas 객체에 대한 축 레이블을 저장하는 기본 객체입니다. Int64Index는</target>
        </trans-unit>
        <trans-unit id="a8d0cee96f82a003d95761bdb1bea6e5c8b8bb2c" translate="yes" xml:space="preserve">
          <source>Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. UInt64Index is a special case of</source>
          <target state="translated">인덱싱 및 정렬에 사용되는 변경 불가능한 시퀀스. 모든 pandas 객체에 대한 축 레이블을 저장하는 기본 객체입니다. UInt64Index는</target>
        </trans-unit>
        <trans-unit id="31b7603ab9e328ac9ecd3a57b22b14f6ba634622" translate="yes" xml:space="preserve">
          <source>Implement the sparse version of the DataFrame meaning that any data matching a specific value it&amp;rsquo;s omitted in the representation. The sparse DataFrame allows for a more efficient storage.</source>
          <target state="translated">DataFrame의 희소 버전을 구현하여 특정 값과 일치하는 데이터가 표현에서 생략됨을 의미합니다. 스파 스 DataFrame을 사용하면보다 효율적인 스토리지가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="10a2799ea91e51525dea53960078f9f6f3203aa1" translate="yes" xml:space="preserve">
          <source>Implements datetime.replace, handles nanoseconds.</source>
          <target state="translated">datetime.replace를 구현하고 나노초를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c6745b96941850a92b0edba7a6c22b838293d405" translate="yes" xml:space="preserve">
          <source>Import Stata data files.</source>
          <target state="translated">Stata 데이터 파일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1e5491997dd74b680ce524f97d0882e687569640" translate="yes" xml:space="preserve">
          <source>Import all needed libraries (except for pandas and numpy, those are already imported as &lt;code&gt;import pandas as pd&lt;/code&gt; and &lt;code&gt;import numpy as np&lt;/code&gt;) and define all variables you use in the example.</source>
          <target state="translated">필요한 모든 라이브러리를 가져 오십시오 (팬더 및 numpy 제외). 이미 &lt;code&gt;import pandas as pd&lt;/code&gt; 로 &lt;code&gt;import numpy as np&lt;/code&gt; ) 예제에서 사용하는 모든 변수를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="d23dd8370347a27e8c15358e5d3021400237aac7" translate="yes" xml:space="preserve">
          <source>Import formatting</source>
          <target state="translated">가져 오기 형식</target>
        </trans-unit>
        <trans-unit id="72cab777e486bd355797f7e6fdade33e9f41fd52" translate="yes" xml:space="preserve">
          <source>Import required libraries (except &lt;code&gt;numpy&lt;/code&gt; and &lt;code&gt;pandas&lt;/code&gt;)</source>
          <target state="translated">필요한 라이브러리 가져 오기 ( &lt;code&gt;numpy&lt;/code&gt; 및 &lt;code&gt;pandas&lt;/code&gt; 제외 )</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="8e9f5299061cd70fa083abaf2a821d53b2bf0a35" translate="yes" xml:space="preserve">
          <source>Important to notice that &lt;code&gt;df2&lt;/code&gt; will contain both</source>
          <target state="translated">것을 통지에 중요 &lt;code&gt;df2&lt;/code&gt; 모두 포함됩니다</target>
        </trans-unit>
        <trans-unit id="8caa460d7e776f14562e9da5c4c08d479a40d0c1" translate="yes" xml:space="preserve">
          <source>Important to notice that &lt;code&gt;df2&lt;/code&gt; will contain both &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; for the same input, &amp;lsquo;1&amp;rsquo;.</source>
          <target state="translated">것을 통지에 중요 &lt;code&gt;df2&lt;/code&gt; 모두 포함됩니다 &lt;code&gt;str&lt;/code&gt; 과 &lt;code&gt;int&lt;/code&gt; 동일한 입력, '1'을 위해.</target>
        </trans-unit>
        <trans-unit id="5f3ec8323e548daf8dafc731adcf0f495f9f93cb" translate="yes" xml:space="preserve">
          <source>Importantly, a list of tuples indexes several complete &lt;code&gt;MultiIndex&lt;/code&gt; keys, whereas a tuple of lists refer to several values within a level:</source>
          <target state="translated">중요한 점은 튜플 목록은 여러 개의 완전한 &lt;code&gt;MultiIndex&lt;/code&gt; 키를 인덱싱 하는 반면 목록 튜플은 한 수준 내의 여러 값을 참조한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4595506130e2cf8db40b1b6430ef7e36fa5cf73" translate="yes" xml:space="preserve">
          <source>Imports are alphabetically sorted within these sections.</source>
          <target state="translated">가져 오기는이 섹션 내에서 사전 순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8982a4b2f79ddf31cda90fa02617abd56244f09b" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;missing_data#missing-data&quot;&gt;Working with missing data&lt;/a&gt;, we saw that pandas primarily uses &lt;code&gt;NaN&lt;/code&gt; to represent missing data. Because &lt;code&gt;NaN&lt;/code&gt; is a float, this forces an array of integers with any missing values to become floating point. In some cases, this may not matter much. But if your integer column is, say, an identifier, casting to float can be problematic. Some integers cannot even be represented as floating point numbers.</source>
          <target state="translated">에서 &lt;a href=&quot;missing_data#missing-data&quot;&gt;누락 된 데이터 작업&lt;/a&gt; , 우리는 팬더가 주로 사용하는 것을보고 &lt;code&gt;NaN&lt;/code&gt; 이를 누락 된 데이터를 나타냅니다. &lt;code&gt;NaN&lt;/code&gt; 은 부동 소수점 이므로 결 측값이있는 정수 배열이 부동 소수점이되도록합니다. 경우에 따라 별 문제가되지 않을 수도 있습니다. 그러나 정수 열이 식별자 인 경우 float로 캐스팅하면 문제가 될 수 있습니다. 일부 정수는 부동 소수점 숫자로 표현할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="555d2dfae47903c8bd58329d13a61da63add288b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;and&lt;/code&gt;</source>
          <target state="translated">에서 &lt;code&gt;and&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e52f1bacd4f24deb022009e6cbcfc6777c66aa9" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;boxplot&lt;/code&gt;, the return type can be controlled by the &lt;code&gt;return_type&lt;/code&gt;, keyword. The valid choices are &lt;code&gt;{&quot;axes&quot;, &quot;dict&quot;, &quot;both&quot;, None}&lt;/code&gt;. Faceting, created by &lt;code&gt;DataFrame.boxplot&lt;/code&gt; with the &lt;code&gt;by&lt;/code&gt; keyword, will affect the output type as well:</source>
          <target state="translated">에서 &lt;code&gt;boxplot&lt;/code&gt; , 반환 형식은 제어 할 수 있습니다 &lt;code&gt;return_type&lt;/code&gt; , 키워드. 유효한 선택은 &lt;code&gt;{&quot;axes&quot;, &quot;dict&quot;, &quot;both&quot;, None}&lt;/code&gt; 입니다. &lt;code&gt;by&lt;/code&gt; 키워드를 사용하여 &lt;code&gt;DataFrame.boxplot&lt;/code&gt; 에서 만든 패싯 은 출력 유형에도 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0a852e68eeb631ade0cef03cf874abce1f81c9e7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;or&lt;/code&gt;</source>
          <target state="translated">에서 &lt;code&gt;or&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="097ba133ee7ab96717f7a5a56ab8a4beb1aa23eb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;pytz&lt;/code&gt; you can find a list of common (and less common) time zones using &lt;code&gt;from pytz import common_timezones, all_timezones&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pytz&lt;/code&gt; 에서는 &lt;code&gt;from pytz import common_timezones, all_timezones&lt;/code&gt; 사용하여 일반적인 (그리고 덜 일반적인) 시간대 목록을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbe401f5c64aba5b5ac112f3a745ea229c800ebf" translate="yes" xml:space="preserve">
          <source>In Python 2 replacing the &lt;code&gt;range&lt;/code&gt; with its generator counterpart (&lt;code&gt;xrange&lt;/code&gt;) would mean the &lt;code&gt;range&lt;/code&gt; line would vanish. In Python 3 &lt;code&gt;range&lt;/code&gt; is already a generator.</source>
          <target state="translated">파이썬 2에서 &lt;code&gt;range&lt;/code&gt; 를 생성기 대응 물 ( &lt;code&gt;xrange&lt;/code&gt; )로 바꾸면 &lt;code&gt;range&lt;/code&gt; 줄이 사라질 것입니다. 파이썬 3에서 &lt;code&gt;range&lt;/code&gt; 는 이미 발전기입니다.</target>
        </trans-unit>
        <trans-unit id="da0a8b268dc3a515b0c25d7910a12354f6dbce4d" translate="yes" xml:space="preserve">
          <source>In Python 3.6+, you can create multiple columns within the same assign where one of the columns depends on another one defined within the same assign:</source>
          <target state="translated">Python 3.6 이상에서는 동일한 할당 내에 여러 열을 만들 수 있습니다. 여기서 열 중 하나는 동일한 할당 내에 정의 된 다른 열에 종속됩니다.</target>
        </trans-unit>
        <trans-unit id="907e8abd6c8723d202c63be6f377cf83483ea444" translate="yes" xml:space="preserve">
          <source>In R this file can be read into a &lt;code&gt;data.frame&lt;/code&gt; object using the &lt;code&gt;rhdf5&lt;/code&gt; library. The following example function reads the corresponding column names and data values from the values and assembles them into a &lt;code&gt;data.frame&lt;/code&gt;:</source>
          <target state="translated">R에서이 파일은로 읽을 수 &lt;code&gt;data.frame&lt;/code&gt; 의 사용하여 객체 &lt;code&gt;rhdf5&lt;/code&gt; 의 라이브러리를. 다음 예제 함수는 값에서 해당 열 이름과 데이터 값을 읽고이를 &lt;code&gt;data.frame&lt;/code&gt; 으로 어셈블합니다 .</target>
        </trans-unit>
        <trans-unit id="01750648f39249d22ad4fc3c3a3a8334f0b9fee0" translate="yes" xml:space="preserve">
          <source>In SAS, if/then logic can be used to create new columns.</source>
          <target state="translated">SAS에서는 if / then 논리를 사용하여 새 열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca39c6fc3d7d80268fd46f392c1dc4b249e34950" translate="yes" xml:space="preserve">
          <source>In SQL, selection is done using a comma-separated list of columns you&amp;rsquo;d like to select (or a &lt;code&gt;*&lt;/code&gt; to select all columns):</source>
          <target state="translated">SQL에서는 선택하려는 쉼표로 구분 된 열 목록 (또는 &lt;code&gt;*&lt;/code&gt; 를 선택 하여 *) 을 사용하여 선택합니다.</target>
        </trans-unit>
        <trans-unit id="877c9547b65141215299da5fbdfe17f3178aa51f" translate="yes" xml:space="preserve">
          <source>In Series and DataFrame, the arithmetic functions have the option of inputting a &lt;em&gt;fill_value&lt;/em&gt;, namely a value to substitute when at most one of the values at a location are missing. For example, when adding two DataFrame objects, you may wish to treat NaN as 0 unless both DataFrames are missing that value, in which case the result will be NaN (you can later replace NaN with some other value using &lt;code&gt;fillna&lt;/code&gt; if you wish).</source>
          <target state="translated">Series 및 DataFrame에서 산술 함수에는 &lt;em&gt;fill_value&lt;/em&gt; , 즉 한 위치의 값 중 최대 하나가 누락 된 경우 대체 할 값을 입력하는 옵션이 있습니다. 예를 들어, 두 개의 DataFrame 객체를 추가 할 때 두 DataFrame 모두에 해당 값이 누락되지 않는 한 NaN을 0으로 처리 할 수 ​​있습니다.이 경우 결과는 NaN이됩니다 ( 원하는 경우 나중에 &lt;code&gt;fillna&lt;/code&gt; 를 사용하여 NaN을 다른 값으로 대체 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="dc2683c2af6d69c783f5e1c2c60c2fb95add6385" translate="yes" xml:space="preserve">
          <source>In Stata, an &lt;code&gt;if&lt;/code&gt; clause can also be used to create new columns.</source>
          <target state="translated">Stata에서는 &lt;code&gt;if&lt;/code&gt; 절을 사용하여 새 열을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fca911336b8e64fe53b3d338ac822c1038ec5cd" translate="yes" xml:space="preserve">
          <source>In Stata, arbitrary math expressions can be used with the &lt;code&gt;generate&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; commands on new or existing columns. The &lt;code&gt;drop&lt;/code&gt; command drops the column from the data set.</source>
          <target state="translated">Stata에서는 임의의 수학 표현식 을 새 열 또는 기존 열의 &lt;code&gt;generate&lt;/code&gt; 및 &lt;code&gt;replace&lt;/code&gt; 명령 과 함께 사용할 수 있습니다 . &lt;code&gt;drop&lt;/code&gt; 명령은 데이터 세트에서 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a485b7b38ddc54d065958b69c383566407ee3e76" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;SparseDataFrame&lt;/code&gt;, &lt;em&gt;all&lt;/em&gt; columns were sparse. A &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; can have a mixture of sparse and dense columns. As a consequence, assigning new columns to a &lt;code&gt;DataFrame&lt;/code&gt; with sparse values will not automatically convert the input to be sparse.</source>
          <target state="translated">A의 &lt;code&gt;SparseDataFrame&lt;/code&gt; , &lt;em&gt;모든&lt;/em&gt; 열이 드문 드문 있었다. &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 는&lt;/a&gt; 스파 스 및 조밀 한 컬럼의 혼합물을 가질 수 있습니다. 결과적 으로 희소 값이 있는 &lt;code&gt;DataFrame&lt;/code&gt; 에 새 열을 할당 하면 입력이 희소로 자동 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25885b0cb342fdce61ba57e7af9bc59a044474ea" translate="yes" xml:space="preserve">
          <source>In a current or later Python session, you can retrieve stored objects:</source>
          <target state="translated">현재 또는 이후 Python 세션에서 저장된 객체를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29c635720f72e69b069f2ad905af2503cd996e22" translate="yes" xml:space="preserve">
          <source>In a special case, quotes that make a pair around a backtick can confuse the parser. For example, &lt;code&gt;`it's` &amp;gt; `that's`&lt;/code&gt; will raise an error, as it forms a quoted string (&lt;code&gt;'s &amp;gt; `that'&lt;/code&gt;) with a backtick inside.</source>
          <target state="translated">특별한 경우에 백틱 주위에 쌍을 이루는 따옴표는 파서를 혼동 할 수 있습니다. 예를 들어 &lt;code&gt;`it's` &amp;gt; `that's`&lt;/code&gt; 는 내부에 백틱이있는 따옴표 로 묶인 문자열 ( &lt;code&gt;'s &amp;gt; `that'&lt;/code&gt; )을 형성하므로 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c92016604a38d8c1c1b602e884aa0580151d6703" translate="yes" xml:space="preserve">
          <source>In addition to accepting an integer or offset as a &lt;code&gt;window&lt;/code&gt; argument, &lt;code&gt;rolling&lt;/code&gt; also accepts a &lt;code&gt;BaseIndexer&lt;/code&gt; subclass that allows a user to define a custom method for calculating window bounds. The &lt;code&gt;BaseIndexer&lt;/code&gt; subclass will need to define a &lt;code&gt;get_window_bounds&lt;/code&gt; method that returns a tuple of two arrays, the first being the starting indices of the windows and second being the ending indices of the windows. Additionally, &lt;code&gt;num_values&lt;/code&gt;, &lt;code&gt;min_periods&lt;/code&gt;, &lt;code&gt;center&lt;/code&gt;, &lt;code&gt;closed&lt;/code&gt; and will automatically be passed to &lt;code&gt;get_window_bounds&lt;/code&gt; and the defined method must always accept these arguments.</source>
          <target state="translated">&lt;code&gt;rolling&lt;/code&gt; 은 정수 또는 오프셋을 &lt;code&gt;window&lt;/code&gt; 인수로 허용하는 것 &lt;code&gt;BaseIndexer&lt;/code&gt; 사용자가 창 경계를 계산하기위한 사용자 지정 메서드를 정의 할 수 있도록하는 BaseIndexer 하위 클래스 도 허용 합니다. &lt;code&gt;BaseIndexer&lt;/code&gt; 의 서브 클래스는 정의해야합니다 &lt;code&gt;get_window_bounds&lt;/code&gt; 의 수익률이 개 배열의 튜플의 첫 번째 윈도우의 시작 인덱스 인과 두 번째 윈도우의 종료 인덱스 인 것을 방법. 또한 &lt;code&gt;num_values&lt;/code&gt; , &lt;code&gt;min_periods&lt;/code&gt; , &lt;code&gt;center&lt;/code&gt; , &lt;code&gt;closed&lt;/code&gt; 및 자동으로 &lt;code&gt;get_window_bounds&lt;/code&gt; 로 전달되며 정의 된 메서드는 항상 이러한 인수를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="936eee8f2267eff6f3fed4ea5b56ef617d250c89" translate="yes" xml:space="preserve">
          <source>In addition to following the steps in this tutorial, users interested in enhancing performance are highly encouraged to install the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/getting_started/install.html#install-recommended-dependencies&quot;&gt;recommended dependencies&lt;/a&gt; for pandas. These dependencies are often not installed by default, but will offer speed improvements if present.</source>
          <target state="translated">이 자습서의 단계를 따르는 것 외에도 성능 향상에 관심이있는 사용자 는 pandas에 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/getting_started/install.html#install-recommended-dependencies&quot;&gt;권장되는 종속성&lt;/a&gt; 을 설치하는 것이 좋습니다 . 이러한 종속성은 종종 기본적으로 설치되지 않지만있는 경우 속도 향상을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e63de287fe4a4658bb5a80280e4fa5c2bfd3ca20" translate="yes" xml:space="preserve">
          <source>In addition to object conversion, &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt;&lt;code&gt;to_numeric()&lt;/code&gt;&lt;/a&gt; provides another argument &lt;code&gt;downcast&lt;/code&gt;, which gives the option of downcasting the newly (or already) numeric data to a smaller dtype, which can conserve memory:</source>
          <target state="translated">객체 변환 외에도 &lt;a href=&quot;../reference/api/pandas.to_numeric#pandas.to_numeric&quot;&gt; &lt;code&gt;to_numeric()&lt;/code&gt; &lt;/a&gt; 은 새로운 (또는 이미) 숫자 데이터를 더 작은 dtype으로 다운 캐스트하여 메모리를 절약 할 수있는 옵션을 제공하는 또 다른 인수 &lt;code&gt;downcast&lt;/code&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88d11d83548d7a8bd3e2260ac358ac93abc83c24" translate="yes" xml:space="preserve">
          <source>In addition to text/csv and Stata files, pandas supports a variety of other data formats such as Excel, SAS, HDF5, Parquet, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">text / csv 및 Stata 파일 외에도 Pandas는 Excel, SAS, HDF5, Parquet 및 SQL 데이터베이스와 같은 다양한 기타 데이터 형식을 지원합니다. 이것들은 모두 &lt;code&gt;pd.read_*&lt;/code&gt; 함수 를 통해 읽습니다 . 자세한 내용은 &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b35d4c53f87e1ec5baecbdbc6b0b27f79f9dad9" translate="yes" xml:space="preserve">
          <source>In addition to text/csv, pandas supports a variety of other data formats such as Excel, HDF5, and SQL databases. These are all read via a &lt;code&gt;pd.read_*&lt;/code&gt; function. See the &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO documentation&lt;/a&gt; for more details.</source>
          <target state="translated">text / csv 외에도 pandas는 Excel, HDF5 및 SQL 데이터베이스와 같은 다양한 기타 데이터 형식을 지원합니다. 이것들은 모두 &lt;code&gt;pd.read_*&lt;/code&gt; 함수 를 통해 읽습니다 . 자세한 내용은 &lt;a href=&quot;../../user_guide/io#io&quot;&gt;IO 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2fa15bcbd59eff23d62eafdefa1f3a939cba9e8d" translate="yes" xml:space="preserve">
          <source>In addition to that, &lt;code&gt;MultiIndex&lt;/code&gt; allows selecting a separate level to use in the membership check:</source>
          <target state="translated">또한 &lt;code&gt;MultiIndex&lt;/code&gt; 를 사용하면 멤버십 확인에 사용할 별도의 레벨을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e488502fc61ee071297be900543941c302873763" translate="yes" xml:space="preserve">
          <source>In addition to the required datetime string, a &lt;code&gt;format&lt;/code&gt; argument can be passed to ensure specific parsing. This could also potentially speed up the conversion considerably.</source>
          <target state="translated">필수 datetime 문자열 외에도 특정 구문 분석을 보장하기 위해 &lt;code&gt;format&lt;/code&gt; 인수를 전달할 수 있습니다. 이것은 잠재적으로 변환 속도를 상당히 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f194ff577d3246f42a365dc02ca65f2f46a8b57" translate="yes" xml:space="preserve">
          <source>In addition to the top level &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; function you can also evaluate an expression in the &amp;ldquo;context&amp;rdquo; of a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">상위 레벨에 추가 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 함수를 당신은 또한의 &quot;환경&quot;의 표현 평가할 수 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="344220efeaea8bac8f88606648dc5f32ff74a82e" translate="yes" xml:space="preserve">
          <source>In addition to these &lt;code&gt;kind&lt;/code&gt; s, there are the &lt;a href=&quot;#visualization-hist&quot;&gt;DataFrame.hist()&lt;/a&gt;, and &lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot()&lt;/a&gt; methods, which use a separate interface.</source>
          <target state="translated">이 외에도 &lt;code&gt;kind&lt;/code&gt; 의 상기있다 &lt;a href=&quot;#visualization-hist&quot;&gt;DataFrame.hist ()&lt;/a&gt; 및 &lt;a href=&quot;#visualization-box&quot;&gt;DataFrame.boxplot ()&lt;/a&gt; 별도의 인터페이스를 사용하는 방법.</target>
        </trans-unit>
        <trans-unit id="2ef7225efe8be70a38588aff72833171774ac432" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;where&lt;/code&gt; takes an optional &lt;code&gt;other&lt;/code&gt; argument for replacement of values where the condition is False, in the returned copy.</source>
          <target state="translated">또한 &lt;code&gt;where&lt;/code&gt; 는 반환 된 복사본에서 조건이 False 인 값을 대체하기 위해 선택적 &lt;code&gt;other&lt;/code&gt; 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d7ff888cd67986fa3c15b5083cd5f831adcd6a1" translate="yes" xml:space="preserve">
          <source>In addition, Unicode characters whose width is &amp;ldquo;Ambiguous&amp;rdquo; can either be 1 or 2 characters wide depending on the terminal setting or encoding. The option &lt;code&gt;display.unicode.ambiguous_as_wide&lt;/code&gt; can be used to handle the ambiguity.</source>
          <target state="translated">또한 너비가 &quot;모호함&quot;인 유니 코드 문자는 터미널 설정 또는 인코딩에 따라 너비가 1 자 또는 2 자일 수 있습니다. &lt;code&gt;display.unicode.ambiguous_as_wide&lt;/code&gt; 옵션을 사용하여 모호성을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="461cd1c60765166195c8d8ff831032d5cc889866" translate="yes" xml:space="preserve">
          <source>In addition, because a lot of people use our library, it is important that we do not make sudden changes to the code that could have the potential to break a lot of user code as a result, that is, we need it to be as &lt;em&gt;backwards compatible&lt;/em&gt; as possible to avoid mass breakages.</source>
          <target state="translated">또한 많은 사람들이 라이브러리를 사용하기 때문에 결과적으로 많은 사용자 코드를 손상시킬 수있는 코드를 갑자기 변경하지 않는 것이 중요합니다. 대량 파손을 피하기 위해 가능한 &lt;em&gt;역 호환성&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec024bfe3b45af422e3ecb72973bb611c9bf681" translate="yes" xml:space="preserve">
          <source>In addition, downcasting will only occur if the size of the resulting data&amp;rsquo;s dtype is strictly larger than the dtype it is to be cast to, so if none of the dtypes checked satisfy that specification, no downcasting will be performed on the data.</source>
          <target state="translated">또한 다운 캐스팅은 결과 데이터의 dtype의 크기가 캐스트 할 dtype보다 엄격하게 큰 경우에만 발생하므로 확인 된 dtype이 해당 사양을 충족하지 않으면 데이터에 대한 다운 캐스팅이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fc9b4cee9d4013aab9b23ecb620605ef783cea3" translate="yes" xml:space="preserve">
          <source>In addition, pandas also provides utilities to compare two Series or DataFrame and summarize their differences.</source>
          <target state="translated">또한 pandas는 두 Series 또는 DataFrame을 비교하고 차이점을 요약하는 유틸리티도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28dd64e14727048112de8dad7d43482313ba396c" translate="yes" xml:space="preserve">
          <source>In addition, you can perform assignment of columns within an expression. This allows for &lt;em&gt;formulaic evaluation&lt;/em&gt;. The assignment target can be a new column name or an existing column name, and it must be a valid Python identifier.</source>
          <target state="translated">또한 식 내에서 열을 할당 할 수 있습니다. 이를 통해 &lt;em&gt;공식 평가가 가능&lt;/em&gt; 합니다. 할당 대상은 새 열 이름이거나 기존 열 이름 일 수 있으며 유효한 Python 식별자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cbe0930be96da940e74db577618b77c18b9ac4bd" translate="yes" xml:space="preserve">
          <source>In all, we&amp;rsquo;ve reduced the in-memory footprint of this dataset to 1/5 of its original size.</source>
          <target state="translated">전체적으로이 데이터 세트의 메모리 내 공간을 원래 크기의 1/5로 줄였습니다.</target>
        </trans-unit>
        <trans-unit id="3f5ff527a5832e386d2fa919bb55a7946b3f099b" translate="yes" xml:space="preserve">
          <source>In any of these cases, standard indexing will still work, e.g. &lt;code&gt;s['1']&lt;/code&gt;, &lt;code&gt;s['min']&lt;/code&gt;, and &lt;code&gt;s['index']&lt;/code&gt; will access the corresponding element or column.</source>
          <target state="translated">이러한 경우 표준 인덱싱은 계속 작동합니다. 예를 들어 &lt;code&gt;s['1']&lt;/code&gt; , &lt;code&gt;s['min']&lt;/code&gt; , &lt;code&gt;s['index']&lt;/code&gt; 는 해당 요소 또는 열에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="d37f34cfe50312c2a03cda42e1c85d47a9f3b53e" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;subplots=True&lt;/code&gt;, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in; Be aware, that passing in both an ax and &lt;code&gt;sharex=True&lt;/code&gt; will alter all x axis labels for all axis in a figure.</source>
          <target state="translated">&lt;code&gt;subplots=True&lt;/code&gt; 인 경우 x 축을 공유하고 일부 x 축 레이블을 보이지 않게 설정하십시오. ax가 None이면 기본값은 True이고 그렇지 않으면 ax가 전달되면 False입니다. ax와 &lt;code&gt;sharex=True&lt;/code&gt; 를 모두 전달 하면 Figure의 모든 축에 대한 모든 x 축 레이블이 변경 된다는 점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="259ff876d5b3d5405f39041292d56dab1977340a" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;subplots=True&lt;/code&gt;, share y axis and set some y axis labels to invisible.</source>
          <target state="translated">&lt;code&gt;subplots=True&lt;/code&gt; 인 경우 y 축을 공유하고 일부 y 축 레이블을 보이지 않게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cd532ff8699d514dc2c1ce70655231461c01cdd0" translate="yes" xml:space="preserve">
          <source>In case of a MultiIndex, only rename labels in the specified level.</source>
          <target state="translated">다중 색인의 경우 지정된 레벨의 레이블 만 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="82d44e95df31ef34cd50671cd671f7030bd91cea" translate="yes" xml:space="preserve">
          <source>In case of a key partially contained in a MultiIndex, indicate which levels are used. Levels can be referred by label or position.</source>
          <target state="translated">다중 색인에 부분적으로 포함 된 키의 경우 어떤 레벨이 사용되는지 표시하십시오. 레벨은 레이블 또는 위치로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb7330f48df29ed5326f3bb15396cd90585fabe1" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and</source>
          <target state="translated">파이썬 / IPython이 터미널에서 실행 중이고</target>
        </trans-unit>
        <trans-unit id="1052f0d8e2c2e12c931a4c0074d4560c46bfb585" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the height of the terminal and print a truncated object which fits the screen height. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 60] [currently: 15]display.max_seq_items : int or None when pretty-printing a long sequence, no more then &lt;code&gt;max_seq_items&lt;/code&gt; will be printed. If items are omitted, they will be denoted by the addition of &amp;ldquo;&amp;hellip;&amp;rdquo; to the resulting string.</source>
          <target state="translated">python / IPython이 터미널에서 실행 중이고 &lt;code&gt;large_repr&lt;/code&gt; 이 'truncate'와 같으면 이것을 0으로 설정할 수 있으며 팬더는 터미널의 높이를 자동 감지하고 화면 높이에 맞는 잘린 객체를 인쇄합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 올바른 자동 감지를 수행 할 수 없습니다. [default : 60] [현재 : 15] display.max_seq_items : int 또는 None 긴 시퀀스를 예쁘게 인쇄 할 경우 &lt;code&gt;max_seq_items&lt;/code&gt; 가 더 이상 인쇄되지 않습니다 . 항목을 생략하면 결과 문자열에 &quot;&amp;hellip;&quot;가 추가되어 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88dc0ceb9b4e5ade156f2fb19973b762c584b547" translate="yes" xml:space="preserve">
          <source>In case python/IPython is running in a terminal and &lt;code&gt;large_repr&lt;/code&gt; equals &amp;lsquo;truncate&amp;rsquo; this can be set to 0 and pandas will auto-detect the width of the terminal and print a truncated object which fits the screen width. The IPython notebook, IPython qtconsole, or IDLE do not run in a terminal and hence it is not possible to do correct auto-detection. [default: 0] [currently: 0]display.max_colwidth : int The maximum width in characters of a column in the repr of a pandas data structure. When the column overflows, a &amp;ldquo;&amp;hellip;&amp;rdquo; placeholder is embedded in the output. [default: 50] [currently: 50]display.max_info_columns : int max_info_columns is used in DataFrame.info method to decide if per column information will be printed. [default: 100] [currently: 100]display.max_info_rows : int or None df.info() will usually show null-counts for each column. For large frames this can be quite slow. max_info_rows and max_info_cols limit this null check only to frames with smaller dimensions than specified. [default: 1690785] [currently: 1690785]display.max_rows : int If max_rows is exceeded, switch to truncate view. Depending on &lt;code&gt;large_repr&lt;/code&gt;, objects are either centrally truncated or printed as a summary view. &amp;lsquo;None&amp;rsquo; value means unlimited.</source>
          <target state="translated">python / IPython이 터미널에서 실행되고 &lt;code&gt;large_repr&lt;/code&gt; 인 경우'잘림'과 같음이 값은 0으로 설정 될 수 있으며 팬더는 터미널 너비를 자동 감지하고 화면 너비에 맞는 잘린 객체를 인쇄합니다. IPython 노트북, IPython qtconsole 또는 IDLE은 터미널에서 실행되지 않으므로 올바른 자동 감지를 수행 할 수 없습니다. [default : 0] [현재 : 0] display.max_colwidth : int 팬더 데이터 구조의 repr에서 열의 최대 문자 수를 나타냅니다. 열이 오버플로되면 &quot;&amp;hellip;&quot;자리 표시자가 출력에 포함됩니다. [default : 50] [현재 : 50] display.max_info_columns : int max_info_columns는 DataFrame.info 메서드에서 열별 정보를 인쇄할지 여부를 결정하는 데 사용됩니다. [default : 100] [현재 : 100] display.max_info_rows : int 또는 None df.info ()는 일반적으로 각 열의 null 수를 표시합니다. 큰 프레임의 경우 상당히 느릴 수 있습니다.max_info_rows 및 max_info_cols는이 널 검사를 지정된 크기보다 작은 크기의 프레임으로 만 제한합니다. [default : 1690785] [현재 : 1690785] display.max_rows : int max_rows를 초과하면 잘림보기로 전환하십시오. 에 따라 &lt;code&gt;large_repr&lt;/code&gt; 이면 객체가 중앙에서 잘 리거나 요약보기로 인쇄됩니다. '없음'값은 무제한을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8e35d288cb0c579433cc89556209e4bed46e672a" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share x axis and set some x axis labels to invisible; defaults to True if ax is None otherwise False if an ax is passed in. Note that passing in both an ax and sharex=True will alter all x axis labels for all subplots in a figure.</source>
          <target state="translated">subplots = True 인 경우 x 축을 공유하고 일부 x 축 레이블을 보이지 않게 설정하십시오. ax가 None이면 기본값은 True입니다. 그렇지 않으면 ax가 전달되면 False입니다. ax와 sharex = True를 모두 전달하면 그림의 모든 하위 그림에 대한 모든 x 축 레이블이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="13d4a95cd38f900c3ec733f1670b49419dc85c00" translate="yes" xml:space="preserve">
          <source>In case subplots=True, share y axis and set some y axis labels to invisible.</source>
          <target state="translated">subplots = True 인 경우 y 축을 공유하고 일부 y 축 레이블을 보이지 않게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0d9d818756c135822b8f3d3ecf8891eb81a47a9f" translate="yes" xml:space="preserve">
          <source>In case there is a tie, the lexicographical sorting looks at the next level of the MultiIndex.</source>
          <target state="translated">동점이있는 경우 사전 식 정렬은 MultiIndex의 다음 수준을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cde29dc4b9128386ba4e2d708cd826477c4917e9" translate="yes" xml:space="preserve">
          <source>In case when it is not possible to return designated types (e.g. when any element of input is before Timestamp.min or after Timestamp.max) return will have datetime.datetime type (or corresponding array/Series).</source>
          <target state="translated">지정된 유형을 리턴 할 수없는 경우 (예 : 입력 요소가 Timestamp.min 이전 또는 Timestamp.max 이후 인 경우) 리턴에는 datetime.datetime 유형 (또는 해당 배열 / 시리즈)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d98b509261df46a77d5170a3ea614953001361f" translate="yes" xml:space="preserve">
          <source>In case where there are just a set of values allowed, list them in curly brackets and separated by commas (followed by a space). If the values are ordinal and they have an order, list them in this order. Otherwise, list the default value first, if there is one:</source>
          <target state="translated">허용되는 값 집합이있는 경우 중괄호로 묶고 쉼표로 구분합니다 (공백). 값이 순서적이고 순서가 있으면이 순서대로 나열하십시오. 그렇지 않은 경우 기본값이 있으면 먼저 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="3faa60af9b3f807fffd055e96cd73d0da7d66524" translate="yes" xml:space="preserve">
          <source>In cases where the default value is &lt;code&gt;None&lt;/code&gt;, meaning that the value will not be used. Instead of &amp;ldquo;str, default None&amp;rdquo;, it is preferred to write &amp;ldquo;str, optional&amp;rdquo;. When &lt;code&gt;None&lt;/code&gt; is a value being used, we will keep the form &amp;ldquo;str, default None&amp;rdquo;. For example, in &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is not a value being used, but means that compression is optional, and no compression is being used if not provided. In this case we will use &lt;code&gt;str, optional&lt;/code&gt;. Only in cases like &lt;code&gt;func(value=None)&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt; is being used in the same way as &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;foo&lt;/code&gt; would be used, then we will specify &amp;ldquo;str, int or None, default None&amp;rdquo;.</source>
          <target state="translated">기본값이 &lt;code&gt;None&lt;/code&gt; 인 경우 값이 사용 되지 않음 을 의미합니다. &quot;str, default None&quot;대신 &quot;str, optional&quot;을 쓰는 것이 좋습니다. 때 &lt;code&gt;None&lt;/code&gt; 사용되는 값입니다, 우리는 형태 &quot;STR, 기본 없음&quot;을 유지합니다. 예를 들어, &lt;code&gt;df.to_csv(compression=None)&lt;/code&gt; 에서 &lt;code&gt;None&lt;/code&gt; 은 사용되는 값이 아니지만 압축은 선택 사항이며 제공되지 않은 경우 압축이 사용되지 않음을 의미합니다. 이 경우 &lt;code&gt;str, optional&lt;/code&gt; 합니다. 단지 같은 경우에 &lt;code&gt;func(value=None)&lt;/code&gt; 및 &lt;code&gt;None&lt;/code&gt; 과 같은 방법으로 사용되는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;foo&lt;/code&gt; 는이 우리가 &quot;STR, INT 또는 없음, 기본 없음&quot;을 지정합니다 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31fa9361b97b46ead5543693c00a21a41800c4f9" translate="yes" xml:space="preserve">
          <source>In comparison operations, &lt;a href=&quot;../reference/api/pandas.arrays.stringarray#pandas.arrays.StringArray&quot;&gt;&lt;code&gt;arrays.StringArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;Series&lt;/code&gt; backed by a &lt;code&gt;StringArray&lt;/code&gt; will return an object with &lt;a href=&quot;../reference/api/pandas.booleandtype#pandas.BooleanDtype&quot;&gt;&lt;code&gt;BooleanDtype&lt;/code&gt;&lt;/a&gt;, rather than a &lt;code&gt;bool&lt;/code&gt; dtype object. Missing values in a &lt;code&gt;StringArray&lt;/code&gt; will propagate in comparison operations, rather than always comparing unequal like &lt;code&gt;numpy.nan&lt;/code&gt;.</source>
          <target state="translated">비교 작업에서 &lt;code&gt;StringArray&lt;/code&gt; 가 지원하는 &lt;a href=&quot;../reference/api/pandas.arrays.stringarray#pandas.arrays.StringArray&quot;&gt; &lt;code&gt;arrays.StringArray&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;Series&lt;/code&gt; 는 &lt;code&gt;bool&lt;/code&gt; dtype 개체가 아닌 &lt;a href=&quot;../reference/api/pandas.booleandtype#pandas.BooleanDtype&quot;&gt; &lt;code&gt;BooleanDtype&lt;/code&gt; 을 사용&lt;/a&gt; 하여 개체를 반환 합니다. &lt;code&gt;StringArray&lt;/code&gt; 에서 누락 된 값은 &lt;code&gt;numpy.nan&lt;/code&gt; 과 같이 항상 같지 않은 것을 비교하는 것이 아니라 비교 작업에서 전파됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
