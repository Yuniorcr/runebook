<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="63cbbd558380fee23b151e484617601ec31b95ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; parameter can be used to limit the number of splits on the delimiter. The outputs of &lt;code&gt;split&lt;/code&gt; and &lt;code&gt;rsplit&lt;/code&gt; are different.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개의 매개 변수는 구분에 분할의 수를 제한 할 수 있습니다. &lt;code&gt;split&lt;/code&gt; 및 &lt;code&gt;rsplit&lt;/code&gt; 의 출력 이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6ffcb34d74226ed55703c1c7d8d5c1733dee5082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; smallest elements where &lt;code&gt;n=3&lt;/code&gt; and keeping the last duplicates. Anguilla and Tuvalu will be kept since they are the last with value 11300 based on the index order.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 최소 요소 여기서 &lt;code&gt;n=3&lt;/code&gt; 및 마지막 유지 중복. 앵 gu 라와 투발루는 인덱스 순서에 따라 값이 11300 인 마지막이므로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="17f918ade5db0c33a6a0ede1016c0810e5bcef3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; smallest elements where &lt;code&gt;n=3&lt;/code&gt; with all duplicates kept. Note that the returned Series has four elements due to the three duplicates.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 작은 원소 &lt;code&gt;n=3&lt;/code&gt; 의 모든 중복 결과가 있었다. 반환 된 시리즈에는 3 개의 중복으로 인해 4 개의 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab5ceedccec77462ef0a28e9f7eb4c151f0bf40c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; smallest elements where &lt;code&gt;n=3&lt;/code&gt;. Default &lt;code&gt;keep&lt;/code&gt; value is &amp;lsquo;first&amp;rsquo; so Nauru and Tuvalu will be kept.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 최소 요소 여기서 &lt;code&gt;n=3&lt;/code&gt; . 기본 &lt;code&gt;keep&lt;/code&gt; 값은 'first'이므로 Nauru 및 Tuvalu가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8058d54ef17067fd2d241a18b5bab7e6bed155be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; smallest elements where &lt;code&gt;n=5&lt;/code&gt; by default.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 최소 요소 여기서 &lt;code&gt;n=5&lt;/code&gt; 기본적.</target>
        </trans-unit>
        <trans-unit id="91343d985727347205d77764fb14c516e01c3f07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; smallest values in the Series, sorted in increasing order.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 시리즈의 가장 작은 값이 증가하는 순서로 정렬.</target>
        </trans-unit>
        <trans-unit id="f55fbb131df261019ca89818e346f6d73b4425ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;na_value&lt;/code&gt; class attribute can be used to set the default NA value for this type. &lt;code&gt;numpy.nan&lt;/code&gt; is used by default.</source>
          <target state="translated">&lt;code&gt;na_value&lt;/code&gt; 클래스 속성은이 유형의 기본 NA 값을 설정하는 데 사용할 수 있습니다. &lt;code&gt;numpy.nan&lt;/code&gt; 이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1812d70e571d17b2364923397bbe7d74ad353ca7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; column is taking up much more memory than any other. It has just a few unique values, so it&amp;rsquo;s a good candidate for converting to a &lt;code&gt;Categorical&lt;/code&gt;. With a Categorical, we store each unique name once and use space-efficient integers to know which specific name is used in each row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c48b28e12e93becf2c5256895235344ce2ba1da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nlargest&lt;/code&gt; and &lt;code&gt;nsmallest&lt;/code&gt; methods work on &lt;code&gt;Series&lt;/code&gt; style groupbys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c117a8a59f446bf2efc7b68b1c213b0e3796836" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; option will be effective for addition and subtraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0af24fd1a5aafb2362ff9509275a7cd73053563" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy_type&lt;/code&gt; is the physical storage type of the column, which is the result of &lt;code&gt;str(dtype)&lt;/code&gt; for the underlying NumPy array that holds the data. So for &lt;code&gt;datetimetz&lt;/code&gt; this is &lt;code&gt;datetime64[ns]&lt;/code&gt; and for categorical, it may be any of the supported integer categorical types.</source>
          <target state="translated">&lt;code&gt;numpy_type&lt;/code&gt; 은 의 결과 열, 물리적 스토리지 유형 &lt;code&gt;str(dtype)&lt;/code&gt; 데이터를 보유 기본 NumPy와 어레이. 따라서 &lt;code&gt;datetimetz&lt;/code&gt; 의 경우 &lt;code&gt;datetime64[ns]&lt;/code&gt; 이며 범주 형의 경우 지원되는 정수 범주 형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecc51ad6079c522f844461c4b3513eab7ff10288" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pandas-gbq&lt;/code&gt; package provides functionality to read/write from Google BigQuery.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="868f255ac25f6448480e591707396924a45a8722" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pandas.core&lt;/code&gt;, &lt;code&gt;pandas.compat&lt;/code&gt;, and &lt;code&gt;pandas.util&lt;/code&gt; top-level modules are PRIVATE. Stable functionality in such modules is not guaranteed.</source>
          <target state="translated">&lt;code&gt;pandas.core&lt;/code&gt; , &lt;code&gt;pandas.compat&lt;/code&gt; 및 &lt;code&gt;pandas.util&lt;/code&gt; 최상위 모듈은 개인이다. 이러한 모듈의 안정적인 기능은 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54cdd58c993586d738820232f282f46b8e02e342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pandas.io.sql&lt;/code&gt; module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API. Database abstraction is provided by SQLAlchemy if installed. In addition you will need a driver library for your database. Examples of such drivers are &lt;a href=&quot;http://initd.org/psycopg/&quot;&gt;psycopg2&lt;/a&gt; for PostgreSQL or &lt;a href=&quot;https://github.com/PyMySQL/PyMySQL&quot;&gt;pymysql&lt;/a&gt; for MySQL. For &lt;a href=&quot;https://docs.python.org/3/library/sqlite3.html&quot;&gt;SQLite&lt;/a&gt; this is included in Python&amp;rsquo;s standard library by default. You can find an overview of supported drivers for each SQL dialect in the &lt;a href=&quot;https://docs.sqlalchemy.org/en/latest/dialects/index.html&quot;&gt;SQLAlchemy docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194ef88af088ec3ce4a49f3007e83cd32955b0df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pandas.util.testing&lt;/code&gt; module has many special &lt;code&gt;assert&lt;/code&gt; functions that make it easier to make statements about whether Series or DataFrame objects are equivalent. The easiest way to verify that your code is correct is to explicitly construct the result you expect, then compare the actual result to the expected correct result:</source>
          <target state="translated">&lt;code&gt;pandas.util.testing&lt;/code&gt; 모듈은 많은 특별한이 &lt;code&gt;assert&lt;/code&gt; 쉽게 시리즈 또는 DataFrame 객체가 동일 여부에 대한 진술을 할 수 있도록 기능을. 코드가 올바른지 확인하는 가장 쉬운 방법은 원하는 결과를 명시 적으로 구성한 다음 실제 결과와 예상되는 정확한 결과를 비교하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="902877ab6bb9ca63e3609e978cfbb19d875cca96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pat&lt;/code&gt; parameter can be used to split by other characters.</source>
          <target state="translated">&lt;code&gt;pat&lt;/code&gt; 매개 변수는 다른 문자로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a33f74dbb0bf7c9931ac92bec1c3580393a7ae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; specifies the parent directory to which data will be saved. The &lt;code&gt;partition_cols&lt;/code&gt; are the column names by which the dataset will be partitioned. Columns are partitioned in the order they are given. The partition splits are determined by the unique values in the partition columns. The above example creates a partitioned dataset that may look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16801eb26dd8972c740d37b9cb3b4d338a86e30c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;period&lt;/code&gt; dtype can be used in &lt;code&gt;.astype(...)&lt;/code&gt;. It allows one to change the &lt;code&gt;freq&lt;/code&gt; of a &lt;code&gt;PeriodIndex&lt;/code&gt; like &lt;code&gt;.asfreq()&lt;/code&gt; and convert a &lt;code&gt;DatetimeIndex&lt;/code&gt; to &lt;code&gt;PeriodIndex&lt;/code&gt; like &lt;code&gt;to_period()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0302e0027ff6466f2779937cbb63bbd4fd6cf145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;period&lt;/code&gt; dtype holds the &lt;code&gt;freq&lt;/code&gt; attribute and is represented with &lt;code&gt;period[freq]&lt;/code&gt; like &lt;code&gt;period[D]&lt;/code&gt; or &lt;code&gt;period[M]&lt;/code&gt;, using &lt;a href=&quot;#timeseries-offset-aliases&quot;&gt;frequency strings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db443bed6efe5679193ee751071207c605b5d821" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plot&lt;/code&gt; method on Series and DataFrame is just a simple wrapper around &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot&quot;&gt;&lt;code&gt;plt.plot()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Series와 DataFrame 의 &lt;code&gt;plot&lt;/code&gt; 메소드는 &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot&quot;&gt; &lt;code&gt;plt.plot()&lt;/code&gt; &lt;/a&gt; 주위의 간단한 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="7f47abbe4d843dc34fc6e1dd140f01df75f0dadf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;primaryKey&lt;/code&gt; behavior is the same with MultiIndexes, but in this case the &lt;code&gt;primaryKey&lt;/code&gt; is an array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1112399739336c191053c39e328f251916853dc0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pyarrow&lt;/code&gt; engine always writes the index to the output, but &lt;code&gt;fastparquet&lt;/code&gt; only writes non-default indexes. This extra column can cause problems for non-pandas consumers that are not expecting it. You can force including or omitting indexes with the &lt;code&gt;index&lt;/code&gt; argument, regardless of the underlying engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e3a705807777cb169cd6b524d7bf2d8a4265b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pyarrow&lt;/code&gt; engine preserves extension data types such as the nullable integer and string data type (requiring pyarrow &amp;gt;= 0.16.0, and requiring the extension type to implement the needed protocols, see the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/development/extending.html#extending-extension-arrow&quot;&gt;extension types documentation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694813b3c5e9f98c94175f36b4973a58c4524e94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pyarrow&lt;/code&gt; engine preserves the &lt;code&gt;ordered&lt;/code&gt; flag of categorical dtypes with string types. &lt;code&gt;fastparquet&lt;/code&gt; does not preserve the &lt;code&gt;ordered&lt;/code&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65d036c5492ddfb7f3762952e5dfe3430bd7251" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query()&lt;/code&gt; Method</source>
          <target state="translated">&lt;code&gt;query()&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="8fc1590c326389129a5f938083a1ed0449f634dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query&lt;/code&gt; method has a &lt;code&gt;inplace&lt;/code&gt; keyword which determines whether the query modifies the original frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b4c4284dacf4f9d70b5e9580be493b374957042" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; parameter is required and will show a FutureWarning if not passed. In the future &lt;code&gt;raw&lt;/code&gt; will default to False.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 매개 변수가 필요하고 통과하지 않으면 FutureWarning 표시됩니다. 앞으로 &lt;code&gt;raw&lt;/code&gt; 는 기본적으로 False로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1f80d30b1af7131649524ee12a5fb1a81139881f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_pickle&lt;/code&gt; function in the &lt;code&gt;pandas&lt;/code&gt; namespace can be used to load any pickled pandas object (or any other pickled object) from file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a8a21e32cf9b2380a56d405d31323f2fe5c513" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render_links&lt;/code&gt; argument provides the ability to add hyperlinks to cells that contain URLs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e98aa139f9055f41bf43fcc5074680e5f017e0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace&lt;/code&gt; method also accepts a compiled regular expression object from &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; as a pattern. All flags should be included in the compiled regular expression object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8665afbd3c3d7d969d79b44284cff87af7a2a23e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace&lt;/code&gt; method can also take a callable as replacement. It is called on every &lt;code&gt;pat&lt;/code&gt; using &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.sub&quot;&gt;&lt;code&gt;re.sub()&lt;/code&gt;&lt;/a&gt;. The callable should expect one positional argument (a regex object) and return a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4927d6ed6ea7847a99957870ecc3153c7dfde92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resample()&lt;/code&gt; method can be used directly from &lt;code&gt;DataFrameGroupBy&lt;/code&gt; objects, see the &lt;a href=&quot;groupby#groupby-transform-window-resample&quot;&gt;groupby docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8344fb167c0ca19e5c7c555e7ec71268b1d9625e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resample&lt;/code&gt; function is very flexible and allows you to specify many different parameters to control the frequency conversion and resampling operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d5b88d1dff9d3f85d182137c95da1875c025ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;row0_col2&lt;/code&gt; is the identifier for that particular cell. We&amp;rsquo;ve also prepended each row/column identifier with a UUID unique to each DataFrame so that the style from one doesn&amp;rsquo;t collide with the styling from another within the same notebook or page (you can set the &lt;code&gt;uuid&lt;/code&gt; if you&amp;rsquo;d like to tie together the styling of two DataFrames).</source>
          <target state="translated">&lt;code&gt;row0_col2&lt;/code&gt; 는 그 특정 셀에 대한 식별자이다. 또한 각 행 / 열 식별자 앞에 각 DataFrame에 고유 한 UUID를 추가하여 하나의 스타일이 동일한 노트북 또는 페이지 내의 다른 스타일과 충돌하지 않도록합니다 ( 원하는 경우 &lt;code&gt;uuid&lt;/code&gt; 를 설정할 수 있음) 두 DataFrame의 스타일을 함께 묶으십시오).</target>
        </trans-unit>
        <trans-unit id="6f93fbb9132467f8baed429a1b41097fd068d0ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s.str.isdigit&lt;/code&gt; method is the same as &lt;code&gt;s3.str.isdecimal&lt;/code&gt; but also includes special digits, like superscripted and subscripted digits in unicode.</source>
          <target state="translated">&lt;code&gt;s.str.isdigit&lt;/code&gt; 방법과 동일 &lt;code&gt;s3.str.isdecimal&lt;/code&gt; 뿐만 아니라 유니 코드에서 상 첨부와 첨자 숫자 같은 특별한 자리가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="23b42709b4813e4ab22b64388ed9ae3e5a68f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s.str.isnumeric&lt;/code&gt; method is the same as &lt;code&gt;s3.str.isdigit&lt;/code&gt; but also includes other characters that can represent quantities such as unicode fractions.</source>
          <target state="translated">&lt;code&gt;s.str.isnumeric&lt;/code&gt; 방법과 동일 &lt;code&gt;s3.str.isdigit&lt;/code&gt; 뿐만 아니라, 유니 분획물로 수량을 나타낼 수있는 다른 특성을 포함한다.</target>
        </trans-unit>
        <trans-unit id="e044074625f34c4d4a2c5a88a124aff393d65971" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s3.str.isdecimal&lt;/code&gt; method checks for characters used to form numbers in base 10.</source>
          <target state="translated">&lt;code&gt;s3.str.isdecimal&lt;/code&gt; 베이스 (10)의 형식 번호를 사용하는 문자의 확인 방법.</target>
        </trans-unit>
        <trans-unit id="c8ac3bb363d0be9f46fe308ae1d2d4b4c73246af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s5.str.istitle&lt;/code&gt; method checks for whether all words are in title case (whether only the first letter of each word is capitalized). Words are assumed to be as any sequence of non-numeric characters separated by whitespace characters.</source>
          <target state="translated">&lt;code&gt;s5.str.istitle&lt;/code&gt; 모든 단어의 표제 경우인지에 대한 검사 방법 (각 단어의 첫 글자는 대문자 여부). 단어는 공백 문자로 구분 된 숫자가 아닌 문자 시퀀스로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d18678c4bb8488906ce96e58fac7aeb5e2cd2455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schema&lt;/code&gt; field contains the &lt;code&gt;fields&lt;/code&gt; key, which itself contains a list of column name to type pairs, including the &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;MultiIndex&lt;/code&gt; (see below for a list of types). The &lt;code&gt;schema&lt;/code&gt; field also contains a &lt;code&gt;primaryKey&lt;/code&gt; field if the (Multi)index is unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a17be9b3050aec82fde2a86c19464096895a91" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schema&lt;/code&gt; object contains a &lt;code&gt;pandas_version&lt;/code&gt; field. This contains the version of pandas&amp;rsquo; dialect of the schema, and will be incremented with each revision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbf254b1fdf6634db59728719cc08aa9dd683dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sheet_names&lt;/code&gt; property will generate a list of the sheet names in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05246d9bea4ff967ebe49730a32a500e90c33bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shift&lt;/code&gt; method accepts an &lt;code&gt;freq&lt;/code&gt; argument which can accept a &lt;code&gt;DateOffset&lt;/code&gt; class or other &lt;code&gt;timedelta&lt;/code&gt;-like object or also an &lt;a href=&quot;#timeseries-offset-aliases&quot;&gt;offset alias&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a8c68f95547249b7a6cec641d49ffc2151fdc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stack&lt;/code&gt; function &amp;ldquo;compresses&amp;rdquo; a level in the &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s columns to produce either:</source>
          <target state="translated">&lt;code&gt;stack&lt;/code&gt; 기능 &quot;습포의&quot;에서 레벨 &lt;code&gt;DataFrame&lt;/code&gt; 하거나 생산할의 컬럼 :</target>
        </trans-unit>
        <trans-unit id="baac5e4b4315eb8dc7b0d5f79883cd77dc00302a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subplots=False&lt;/code&gt; option shows the boxplots in a single figure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73a7a61e7e0cfa7bee8f50fd99c8112dadb3040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thousands&lt;/code&gt; keyword allows integers to be parsed correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd8848ea504503de00653efaab8a5e23764e295" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_clipboard&lt;/code&gt; method can be used to write the contents of a &lt;code&gt;DataFrame&lt;/code&gt; to the clipboard. Following which you can paste the clipboard contents into other applications (CTRL-V on many operating systems). Here we illustrate writing a &lt;code&gt;DataFrame&lt;/code&gt; into clipboard and reading it back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af9e9ba04e6b63f1282333fb01ef7736c20c04b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transform&lt;/code&gt; method returns an object that is indexed the same (same size) as the one being grouped. The transform function must:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fb566130657eb68ebd815740a628399fbbcd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unit&lt;/code&gt; keyword argument specifies the unit of the Timedelta:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af24764f17ab707aa44beaaf41db3f4c9295f5a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unit&lt;/code&gt; parameter does not use the same strings as the &lt;code&gt;format&lt;/code&gt; parameter that was discussed &lt;a href=&quot;#timeseries-converting-format&quot;&gt;above&lt;/a&gt;). The available units are listed on the documentation for &lt;a href=&quot;../reference/api/pandas.to_datetime#pandas.to_datetime&quot;&gt;&lt;code&gt;pandas.to_datetime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5d1aa31924825449d5551012555157205659bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usecols&lt;/code&gt; argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e9fec622d16e5a3fc8e3c104465dff3b6f613e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usecols&lt;/code&gt; argument can also be used to specify which columns not to use in the final result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46aec8939087b5d75c804c97e982b38e2e859d7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;var()&lt;/code&gt;, &lt;code&gt;std()&lt;/code&gt;, and &lt;code&gt;cov()&lt;/code&gt; functions have a &lt;code&gt;bias&lt;/code&gt; argument, specifying whether the result should contain biased or unbiased statistics. For example, if &lt;code&gt;bias=True&lt;/code&gt;, &lt;code&gt;ewmvar(x)&lt;/code&gt; is calculated as &lt;code&gt;ewmvar(x) = ewma(x**2) - ewma(x)**2&lt;/code&gt;; whereas if &lt;code&gt;bias=False&lt;/code&gt; (the default), the biased variance statistics are scaled by debiasing factors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c444d892e28d64467b5531636f35d0cccf5c77f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where()&lt;/code&gt; Method and Masking</source>
          <target state="translated">&lt;code&gt;where()&lt;/code&gt; 메소드와 마스크</target>
        </trans-unit>
        <trans-unit id="6fa8c8053ff42a72b7fea6607471ec585ff25425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; group itself is listed first (preorder), then each of its child groups (following an alphanumerical order) is also traversed, following the same procedure.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 그룹 자체는 (숫자 식 순서에 따라) 하위 그룹들 각각은 동일한 절차에 따라, 이송되고, 제 (선주문)를 나열한다.</target>
        </trans-unit>
        <trans-unit id="edc154331c38bdf85a50728707a7305a0b0eede9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;win_type&lt;/code&gt; argument in &lt;code&gt;.rolling&lt;/code&gt; generates a weighted windows that are commonly used in filtering and spectral estimation. &lt;code&gt;win_type&lt;/code&gt; must be string that corresponds to a &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&quot;&gt;scipy.signal window function&lt;/a&gt;. Scipy must be installed in order to use these windows, and supplementary arguments that the Scipy window methods take must be specified in the aggregation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc850e8ddcc798bcc6e060199ead1d2dae8c8f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;year&lt;/code&gt; and the &lt;code&gt;qyear&lt;/code&gt; of the period will be the same if the fiscal and calendar years are the same. When they are not, the fiscal year can be different from the calendar year of the period.</source>
          <target state="translated">&lt;code&gt;year&lt;/code&gt; 과 &lt;code&gt;qyear&lt;/code&gt; 회계 및 일정 년 같은 경우 기간은 동일합니다. 그렇지 않은 경우 회계 연도는 해당 기간의 연도와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0e28485c133706d7fe39a00936eea1e57a6289" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Stata&lt;/em&gt; writer gracefully handles other data types including &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt; by casting to the smallest supported type that can represent the data. For example, data with a type of &lt;code&gt;uint8&lt;/code&gt; will be cast to &lt;code&gt;int8&lt;/code&gt; if all values are less than 100 (the upper bound for non-missing &lt;code&gt;int8&lt;/code&gt; data in &lt;em&gt;Stata&lt;/em&gt;), or, if values are outside of this range, the variable is cast to &lt;code&gt;int16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70da7c1723970edaec8d3559b2f6d62818446eb7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;pandas&lt;/em&gt; documentation consists of two parts: the docstrings in the code itself and the docs in this folder &lt;code&gt;doc/&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;팬더&lt;/em&gt; 코드 자체의 문서화 문자열이 폴더에있는 문서 : 문서는 두 부분으로 구성 &lt;code&gt;doc/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9081969c25c824dd4f015d503392d9d527ff3836" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;pandas&lt;/em&gt; test suite will run automatically on &lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis-CI&lt;/a&gt; and &lt;a href=&quot;https://azure.microsoft.com/en-us/services/devops/pipelines/&quot;&gt;Azure Pipelines&lt;/a&gt; continuous integration services, once your pull request is submitted. However, if you wish to run the test suite on a branch prior to submitting the pull request, then the continuous integration services need to be hooked to your GitHub repository. Instructions are here for &lt;a href=&quot;http://about.travis-ci.org/docs/user/getting-started/&quot;&gt;Travis-CI&lt;/a&gt; and &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/devops/pipelines/&quot;&gt;Azure Pipelines&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;팬더의&lt;/em&gt; 테스트 스위트가 자동으로 실행됩니다 &lt;a href=&quot;https://travis-ci.org/&quot;&gt;트래비스 - CI&lt;/a&gt; 및 &lt;a href=&quot;https://azure.microsoft.com/en-us/services/devops/pipelines/&quot;&gt;푸른 파이프 라인&lt;/a&gt; 하여 풀 요청이 제출되면, 지속적인 통합 서비스를 제공합니다. 그러나 풀 요청을 제출하기 전에 지점에서 테스트 스위트를 실행하려면 지속적인 통합 서비스를 GitHub 리포지토리에 연결해야합니다. &lt;a href=&quot;http://about.travis-ci.org/docs/user/getting-started/&quot;&gt;Travis-CI&lt;/a&gt; 및 &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/devops/pipelines/&quot;&gt;Azure Pipelines에&lt;/a&gt; 대한 지침이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="626acaa168d3c79c66e9fc96883f2e0ccf667c5d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;ufunc&lt;/em&gt; is also applied to &lt;code&gt;fill_value&lt;/code&gt;. This is needed to get the correct dense result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943977cbe2a5528ad4253969c9ea2103a078e2c1" translate="yes" xml:space="preserve">
          <source>The API is composed of 5 relevant functions, available directly from the &lt;code&gt;pandas&lt;/code&gt; namespace:</source>
          <target state="translated">API는 &lt;code&gt;pandas&lt;/code&gt; 네임 스페이스 에서 직접 사용할 수있는 5 가지 관련 함수로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ef7c61751d225e67a4e2a48c738daf6965844ec" translate="yes" xml:space="preserve">
          <source>The DataFrame columns must be unique for orients &lt;code&gt;'index'&lt;/code&gt;, &lt;code&gt;'columns'&lt;/code&gt;, and &lt;code&gt;'records'&lt;/code&gt;.</source>
          <target state="translated">DataFrame 열은 &lt;code&gt;'index'&lt;/code&gt; , &lt;code&gt;'columns'&lt;/code&gt; 및 &lt;code&gt;'records'&lt;/code&gt; 방향에 대해 고유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ce36c670ab5aad0655cc5a390a4c5aa18f07210" translate="yes" xml:space="preserve">
          <source>The DataFrame index must be unique for orients &lt;code&gt;'index'&lt;/code&gt; and &lt;code&gt;'columns'&lt;/code&gt;.</source>
          <target state="translated">DataFrame 인덱스는 &lt;code&gt;'index'&lt;/code&gt; 및 &lt;code&gt;'columns'&lt;/code&gt; 방향에 대해 고유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6bbbf9a7db8fe3586b53ab0950d81ac6d394717" translate="yes" xml:space="preserve">
          <source>The DataFrame to merge column-wise.</source>
          <target state="translated">열 단위로 병합 할 DataFrame입니다.</target>
        </trans-unit>
        <trans-unit id="4122bfd8165fe06f0f2d4432ca3ab0fda7544723" translate="yes" xml:space="preserve">
          <source>The DataFrame to take the DataFrame out of. If it is None, the object groupby was called on will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcad6c645beec0a97692e6f8ced0b5cba822b91" translate="yes" xml:space="preserve">
          <source>The DataFrame&amp;rsquo;s length does not increase as a result of the update, only values at matching index/column labels are updated.</source>
          <target state="translated">업데이트 결과 DataFrame의 길이는 증가하지 않으며 일치하는 인덱스 / 열 레이블의 값만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9828ef8b67f6aa79befab1148b0889fe00f45cdc" translate="yes" xml:space="preserve">
          <source>The DataFrame.eval method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca51ccbfbf64efd333176175a5bb65de48dcf75" translate="yes" xml:space="preserve">
          <source>The EW functions support two variants of exponential weights. The default, &lt;code&gt;adjust=True&lt;/code&gt;, uses the weights \(w_i = (1 - \alpha)^i\) which gives</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9743583cb56703445e98aca9acf720c007efca7" translate="yes" xml:space="preserve">
          <source>The ExtensionArray of the data backing this Series or Index.</source>
          <target state="translated">이 시리즈 또는 인덱스를 지원하는 데이터의 ExtensionArray입니다.</target>
        </trans-unit>
        <trans-unit id="e511277b43773fba45eea7c311490d70ddf77e90" translate="yes" xml:space="preserve">
          <source>The Index &lt;em&gt;must&lt;/em&gt; be monotonically sorted, otherwise wrong locations will likely be returned. Pandas does &lt;em&gt;not&lt;/em&gt; check this for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1489df313ed3738cb2a7d33ad1ff937b27976c79" translate="yes" xml:space="preserve">
          <source>The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0b60260ab4d408db1bcc05d49dfad703362da7" translate="yes" xml:space="preserve">
          <source>The LaTeX label to be placed inside &lt;code&gt;\label{}&lt;/code&gt; in the output. This is used with &lt;code&gt;\ref{}&lt;/code&gt; in the main &lt;code&gt;.tex&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4031d4285b89bf3436ddeeba7b42ed30b881710" translate="yes" xml:space="preserve">
          <source>The LaTeX positional argument for tables, to be placed after &lt;code&gt;\begin{}&lt;/code&gt; in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907582ab048253d02e4abfecf71a5a3635ecf88a" translate="yes" xml:space="preserve">
          <source>The MultiIndex created has levels that are constructed from the passed keys and the index of the &lt;code&gt;DataFrame&lt;/code&gt; pieces:</source>
          <target state="translated">생성 된 MultiIndex에는 전달 된 키와 &lt;code&gt;DataFrame&lt;/code&gt; 조각 의 인덱스로 구성된 수준이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78e0901e5da3a74b665c21bd125d31851109c12e" translate="yes" xml:space="preserve">
          <source>The MultiIndex representation of the given DataFrame.</source>
          <target state="translated">지정된 DataFrame의 MultiIndex 표현입니다.</target>
        </trans-unit>
        <trans-unit id="ab6c365728d20ef00257699e38f3c7840a8be1f2" translate="yes" xml:space="preserve">
          <source>The NumPy ndarray to wrap. Must be 1-dimensional.</source>
          <target state="translated">포장 할 NumPy ndarray. 1 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6adca67ad7953d89386aa9d62ba8dc3f82cf46a" translate="yes" xml:space="preserve">
          <source>The Numpy parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0f8078848d7bf1b78fddfd26f1b23b1befaab9" translate="yes" xml:space="preserve">
          <source>The Pearson correlation between self and self.shift(lag).</source>
          <target state="translated">self와 self.shift (lag) 사이의 Pearson 상관 관계</target>
        </trans-unit>
        <trans-unit id="03419fef33bfe9a27c674ff387984d386fcd91cf" translate="yes" xml:space="preserve">
          <source>The Python and NumPy indexing operators &lt;code&gt;[]&lt;/code&gt; and attribute operator &lt;code&gt;.&lt;/code&gt; provide quick and easy access to pandas data structures across a wide range of use cases. This makes interactive work intuitive, as there&amp;rsquo;s little new to learn if you already know how to deal with Python dictionaries and NumPy arrays. However, since the type of the data to be accessed isn&amp;rsquo;t known in advance, directly using standard operators has some optimization limits. For production code, we recommended that you take advantage of the optimized pandas data access methods exposed in this chapter.</source>
          <target state="translated">파이썬과 NumPy와 인덱싱 연산자 &lt;code&gt;[]&lt;/code&gt; 및 속성 연산자 &lt;code&gt;.&lt;/code&gt; 광범위한 사용 사례에서 팬더 데이터 구조에 빠르고 쉽게 액세스 할 수 있습니다. 파이썬 사전과 NumPy 배열을 다루는 방법을 이미 알고 있다면 배우는 것이 거의 없으므로 대화식 작업이 직관적입니다. 그러나 액세스 할 데이터 유형은 미리 알려져 있지 않기 때문에 표준 연산자를 직접 사용하면 일부 최적화 한계가 있습니다. 생산 코드의 경우이 장에 나와있는 최적화 된 팬더 데이터 액세스 방법을 활용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f311a1f768c5c458d3d379085c59d9eb46bd10c8" translate="yes" xml:space="preserve">
          <source>The Python core team plans to stop supporting Python 2.7 on January 1st, 2020. In line with &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/neps/nep-0014-dropping-python2.7-proposal.rst#plan-for-dropping-python-27-support&quot;&gt;NumPy&amp;rsquo;s plans&lt;/a&gt;, all pandas releases through December 31, 2018 will support Python 2.</source>
          <target state="translated">Python 핵심 팀은 2020 년 1 월 1 일에 Python 2.7 지원을 중단 할 계획입니다. &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/neps/nep-0014-dropping-python2.7-proposal.rst#plan-for-dropping-python-27-support&quot;&gt;NumPy의 계획&lt;/a&gt; 에 따라 2018 년 12 월 31 일까지 모든 팬더 릴리스는 Python 2를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fba097d46288079cad81ca75d3c5385d9addd3b6" translate="yes" xml:space="preserve">
          <source>The R function lists the entire HDF5 file&amp;rsquo;s contents and assembles the &lt;code&gt;data.frame&lt;/code&gt; object from all matching nodes, so use this only as a starting point if you have stored multiple &lt;code&gt;DataFrame&lt;/code&gt; objects to a single HDF5 file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d2bcdadca7e1f3b4698068bdd8754328b29681" translate="yes" xml:space="preserve">
          <source>The R language, by contrast, only has a handful of built-in data types: &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;numeric&lt;/code&gt; (floating-point), &lt;code&gt;character&lt;/code&gt;, and &lt;code&gt;boolean&lt;/code&gt;. &lt;code&gt;NA&lt;/code&gt; types are implemented by reserving special bit patterns for each type to be used as the missing value. While doing this with the full NumPy type hierarchy would be possible, it would be a more substantial trade-off (especially for the 8- and 16-bit data types) and implementation undertaking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bbafccd21b835456769faac176dbf993473eb22" translate="yes" xml:space="preserve">
          <source>The Series &lt;code&gt;name&lt;/code&gt; will be assigned automatically in many cases, in particular when taking 1D slices of DataFrame as you will see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f5439a6a487ae79ed48434801ec809e658f977" translate="yes" xml:space="preserve">
          <source>The Series &lt;em&gt;must&lt;/em&gt; be monotonically sorted, otherwise wrong locations will likely be returned. Pandas does &lt;em&gt;not&lt;/em&gt; check this for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31eb8d2f2787419decaad3ed2cff5f945848896" translate="yes" xml:space="preserve">
          <source>The Series and other has to share the same index if other is a Series or a DataFrame.</source>
          <target state="translated">다른 것이 Series 또는 DataFrame 인 경우 Series와 기타는 동일한 인덱스를 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fd86e3017a1d6ffb84c415d6f9c05bf90f50764" translate="yes" xml:space="preserve">
          <source>The Series index must be unique for orient &lt;code&gt;'index'&lt;/code&gt;.</source>
          <target state="translated">시리즈 색인은 &lt;code&gt;'index'&lt;/code&gt; 방향에 대해 고유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7b2af894ad230654303493d0c063a6c5930d6e51" translate="yes" xml:space="preserve">
          <source>The Series name can be set initially when calling the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54c988e6bb0a0dcd40e13aacac15e7e1168b3a9" translate="yes" xml:space="preserve">
          <source>The User Guide covers all of pandas by topic area. Each of the subsections introduces a topic (such as &amp;ldquo;working with missing data&amp;rdquo;), and discusses how pandas approaches the problem, with many examples throughout.</source>
          <target state="translated">사용자 안내서는 주제 영역별로 모든 팬더를 다룹니다. 각 하위 섹션에서는 주제 (예 : &quot;누락 된 데이터 작업&quot;)를 소개하고 팬더가 문제에 어떻게 접근하는지에 대해 여러 예제를 통해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6e8e123970e7e1b85aacb3b2421a27496dff0719" translate="yes" xml:space="preserve">
          <source>The above can be simplified to:</source>
          <target state="translated">위와 같이 단순화 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f74cbc2281521d26b7640aa3c7630b3892bae3e8" translate="yes" xml:space="preserve">
          <source>The above code will raise a &lt;code&gt;TypeError&lt;/code&gt; if the call to &lt;code&gt;sort_index&lt;/code&gt; is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4622137ba0480c03abc0f1aa98a744e4667f5582" translate="yes" xml:space="preserve">
          <source>The above example is identical to using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0fe539cb4d3f8bb4ea6ca372742f582df30218" translate="yes" xml:space="preserve">
          <source>The above issues hold here as well since &lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup&quot;&gt;&lt;strong&gt;BeautifulSoup4&lt;/strong&gt;&lt;/a&gt; is essentially just a wrapper around a parser backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="160b8d6bd88d2d58b089d1dfb8b97e6e7a9a1204" translate="yes" xml:space="preserve">
          <source>The above output looks very similar to the standard DataFrame HTML representation. But we&amp;rsquo;ve done some work behind the scenes to attach CSS classes to each cell. We can view these by calling the &lt;code&gt;.render&lt;/code&gt; method.</source>
          <target state="translated">위의 출력은 표준 DataFrame HTML 표현과 매우 유사합니다. 그러나 CSS 클래스를 각 셀에 첨부하기 위해 몇 가지 작업을 수행했습니다. 우리는 &lt;code&gt;.render&lt;/code&gt; 메소드 를 호출하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c36e58d4e0016c9b6fe81f470f4d60ec68913ae4" translate="yes" xml:space="preserve">
          <source>The above statement is simply passing a &lt;code&gt;Series&lt;/code&gt; of True/False objects to the DataFrame, returning all rows with True.</source>
          <target state="translated">위의 문장은 단순히 &lt;code&gt;Series&lt;/code&gt; 의 True / False 객체를 DataFrame에 전달하여 True를 사용하여 모든 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8a6b355afdd75a8e4cc0a3129e0ef5618b94f94" translate="yes" xml:space="preserve">
          <source>The accessors &lt;code&gt;.dt&lt;/code&gt; and &lt;code&gt;.str&lt;/code&gt; will work if the &lt;code&gt;s.cat.categories&lt;/code&gt; are of an appropriate type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fe288576805aa448e289b778969f21b4ca6db1" translate="yes" xml:space="preserve">
          <source>The aggregating functions above will exclude NA values. Any function which reduces a &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; to a scalar value is an aggregation function and will work, a trivial example is &lt;code&gt;df.groupby('A').agg(lambda ser: 1)&lt;/code&gt;. Note that &lt;code&gt;nth()&lt;/code&gt; can act as a reducer &lt;em&gt;or&lt;/em&gt; a filter, see &lt;a href=&quot;#groupby-nth&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aaedffa69c0beb1bfe0b3923a3d5d3c28d076d0" translate="yes" xml:space="preserve">
          <source>The aggregation API allows one to express possibly multiple aggregation operations in a single concise way. This API is similar across pandas objects, see &lt;a href=&quot;groupby#groupby-aggregate&quot;&gt;groupby API&lt;/a&gt;, the &lt;a href=&quot;window#window-overview&quot;&gt;window API&lt;/a&gt;, and the &lt;a href=&quot;timeseries#timeseries-aggregate&quot;&gt;resample API&lt;/a&gt;. The entry point for aggregation is &lt;a href=&quot;../reference/api/pandas.dataframe.aggregate#pandas.DataFrame.aggregate&quot;&gt;&lt;code&gt;DataFrame.aggregate()&lt;/code&gt;&lt;/a&gt;, or the alias &lt;a href=&quot;../reference/api/pandas.dataframe.agg#pandas.DataFrame.agg&quot;&gt;&lt;code&gt;DataFrame.agg()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfba7b309213f140ca327732c446b5c080a9653" translate="yes" xml:space="preserve">
          <source>The aggregation functions such as &lt;code&gt;sum&lt;/code&gt; will take the level parameter directly. Additionally, the resulting index will be named according to the chosen level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4773f3d845d0689e34eb349791cfc427008657" translate="yes" xml:space="preserve">
          <source>The aggregation is for each column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ce3422a02e2526b40cb3b5ee108e178d7077164" translate="yes" xml:space="preserve">
          <source>The aggregation operations are always performed over an axis, either the</source>
          <target state="translated">집계 작업은 항상 축을 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="80d52d66af7f41b512ececc660a1e19ec1e580b9" translate="yes" xml:space="preserve">
          <source>The alignment for multicolumns, similar to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30ba6acf0ec9dd6c9673cbaada8122a50988653" translate="yes" xml:space="preserve">
          <source>The alignment for multicolumns, similar to &lt;code&gt;column_format&lt;/code&gt; The default will be read from the config module.</source>
          <target state="translated">&lt;code&gt;column_format&lt;/code&gt; 과 유사한 다중 열의 정렬 기본값은 구성 모듈에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0f92770ced52cdc33af4b178da6f106d0147ed18" translate="yes" xml:space="preserve">
          <source>The allowed and default values depend on the value of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3322fbee683e22d15eb9dd422f6bf81856fae98" translate="yes" xml:space="preserve">
          <source>The allowed and default values depend on the value of the &lt;code&gt;typ&lt;/code&gt; parameter.</source>
          <target state="translated">허용되는 기본값은 &lt;code&gt;typ&lt;/code&gt; 매개 변수 의 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9634a7f3ab931d2d9d65624f09ffa66c83f405af" translate="yes" xml:space="preserve">
          <source>The alternative &lt;a href=&quot;api/pandas.categorical.from_codes#pandas.Categorical.from_codes&quot;&gt;&lt;code&gt;Categorical.from_codes()&lt;/code&gt;&lt;/a&gt; constructor can be used when you have the categories and integer codes already:</source>
          <target state="translated">카테고리와 정수 코드가 이미있는 경우 대체 &lt;a href=&quot;api/pandas.categorical.from_codes#pandas.Categorical.from_codes&quot;&gt; &lt;code&gt;Categorical.from_codes()&lt;/code&gt; &lt;/a&gt; 생성자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da7be28eb71e03d81282ab60d4b99037f9edc34" translate="yes" xml:space="preserve">
          <source>The argument of &lt;code&gt;filter&lt;/code&gt; must be a function that, applied to the group as a whole, returns &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed14375860cb9cf62ffe247d7b4a6e7bd8aad19" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;sheet_name&lt;/code&gt; allows specifying the sheet or sheets to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099554c4c4547cd31169cb4fb1269c40d6ad2d54" translate="yes" xml:space="preserve">
          <source>The array of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d3fabba253d79d7e0f869ce57480b1b95e4dcc" translate="yes" xml:space="preserve">
          <source>The array or dtype to check.</source>
          <target state="translated">확인할 배열 또는 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="ab30e204266591487d00744af500f08cdf0b0691" translate="yes" xml:space="preserve">
          <source>The array that is being indexed (only used for the length).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51567e9923a5b31a4db9b65260aa4d00e65b2315" translate="yes" xml:space="preserve">
          <source>The array-like or dtype to check.</source>
          <target state="translated">확인할 배열과 같은 또는 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="089a684c545a15045012a0ef2296bca90733bee3" translate="yes" xml:space="preserve">
          <source>The array-like that&amp;rsquo;s used to index. List-like input that is not yet a numpy array or an ExtensionArray is converted to one. Other input types are passed through as is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6df26f2a3e60eaf0c41fdd82cf68d1ce6eaf0b4" translate="yes" xml:space="preserve">
          <source>The array-like to check.</source>
          <target state="translated">확인할 배열과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de6e01ae2379a962cd80bab74bc4d51e151456f9" translate="yes" xml:space="preserve">
          <source>The assigned value has to be a list-like object. All items must be unique and the number of items in the new categories must be the same as the number of items in the old categories.</source>
          <target state="translated">할당 된 값은 목록과 같은 객체 여야합니다. 모든 항목은 고유해야하며 새 범주의 항목 수는 이전 범주의 항목 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="e77ce643b876fe1237ed1869adaf6c1cc6fab9d1" translate="yes" xml:space="preserve">
          <source>The attribute that get_values wraps.</source>
          <target state="translated">get_values가 랩핑하는 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9f7de876ca88bcd6ab031dce4e40009cf9e370cc" translate="yes" xml:space="preserve">
          <source>The attribute will not be available if it conflicts with an existing method name, e.g. &lt;code&gt;s.min&lt;/code&gt; is not allowed, but &lt;code&gt;s['min']&lt;/code&gt; is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec75239599e68226797a53b6c042c3978f24334" translate="yes" xml:space="preserve">
          <source>The available flags are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5c5c84398ab44dd2b453f5b7aeebde5fa39f59d" translate="yes" xml:space="preserve">
          <source>The available options with its descriptions:</source>
          <target state="translated">설명과 함께 사용 가능한 옵션 :</target>
        </trans-unit>
        <trans-unit id="4cb6f7dca3c72097b5306cc57d310ff0892c03f7" translate="yes" xml:space="preserve">
          <source>The axes to plot the histogram on.</source>
          <target state="translated">히스토그램을 표시 할 축입니다.</target>
        </trans-unit>
        <trans-unit id="7d789121fd7a2947bd0359b47d68eaff9fcab102" translate="yes" xml:space="preserve">
          <source>The axis along which to sort. The value 0 identifies the rows, and 1 identifies the columns.</source>
          <target state="translated">정렬 할 축입니다. 값 0은 행을 식별하고 1은 열을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="4226784681e9fba870fdfcdfe1ead37c856c575b" translate="yes" xml:space="preserve">
          <source>The axis labeling information in pandas objects serves many purposes:</source>
          <target state="translated">pandas 객체의 축 레이블 정보는 여러 가지 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5b0c1ebfd9634de3941c55dfaf6517f434adc07" translate="yes" xml:space="preserve">
          <source>The axis of the object over which to compute the rank.</source>
          <target state="translated">순위를 계산할 객체의 축입니다.</target>
        </trans-unit>
        <trans-unit id="0953de10e0196346c62012e9a524ec8d64d0968f" translate="yes" xml:space="preserve">
          <source>The axis on which to select elements. &lt;code&gt;0&lt;/code&gt; means that we are selecting rows, &lt;code&gt;1&lt;/code&gt; means that we are selecting columns.</source>
          <target state="translated">요소를 선택할 축입니다. &lt;code&gt;0&lt;/code&gt; 은 행을 선택하고 &lt;code&gt;1&lt;/code&gt; 은 열을 선택한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="3c916def9a65c257e95d00cc554d25479a76a082" translate="yes" xml:space="preserve">
          <source>The axis over which to select values, always 0.</source>
          <target state="translated">값을 선택할 축으로 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="59a36ecc99cc9dbf73d56a2e1632ae067d6767b6" translate="yes" xml:space="preserve">
          <source>The axis to concatenate along.</source>
          <target state="translated">연결할 축입니다.</target>
        </trans-unit>
        <trans-unit id="7849b15daecc88739a78174a8b9961c3ba77fbe0" translate="yes" xml:space="preserve">
          <source>The axis to convert (the index by default).</source>
          <target state="translated">변환 할 축 (기본적으로 인덱스)</target>
        </trans-unit>
        <trans-unit id="530df50921cf9a0666d4ba36a6b0de0e0c7d24ce" translate="yes" xml:space="preserve">
          <source>The axis to filter on, expressed either as an index (int) or axis name (str). By default this is the info axis, &amp;lsquo;index&amp;rsquo; for Series, &amp;lsquo;columns&amp;rsquo; for DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617c4e799cb940ef82c46d1cd3dde4d47688a497" translate="yes" xml:space="preserve">
          <source>The axis to filter on. By default this is the info axis, &amp;lsquo;index&amp;rsquo; for Series, &amp;lsquo;columns&amp;rsquo; for DataFrame.</source>
          <target state="translated">필터링 할 축입니다. 기본적으로 이것은 정보 축, Series의 경우 '인덱스', DataFrame의 경우 '열'입니다.</target>
        </trans-unit>
        <trans-unit id="1243c2a6fe64f4147c08752739863d4fbafd64fa" translate="yes" xml:space="preserve">
          <source>The axis to iterate over while searching for the mode:</source>
          <target state="translated">모드를 검색하는 동안 반복 할 축 :</target>
        </trans-unit>
        <trans-unit id="062381d2bab7cf2774a3e169172bb3b09f12a191" translate="yes" xml:space="preserve">
          <source>The axis to rename.</source>
          <target state="translated">이름을 바꿀 축입니다.</target>
        </trans-unit>
        <trans-unit id="c98ae65c6442aafdf05c18ae4ab7677b4bf927b8" translate="yes" xml:space="preserve">
          <source>The axis to swap levels on. 0 or &amp;lsquo;index&amp;rsquo; for row-wise, 1 or &amp;lsquo;columns&amp;rsquo; for column-wise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc6bcfcb9673122d073fe944710ca418de39ee4" translate="yes" xml:space="preserve">
          <source>The axis to update. The value 0 identifies the rows, and 1 identifies the columns.</source>
          <target state="translated">업데이트 할 축입니다. 값 0은 행을 식별하고 1은 열을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="1eeab9f1d519d45f8cc439ce433620136c18af34" translate="yes" xml:space="preserve">
          <source>The axis to update. The value 0 identifies the rows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f02ec70adb648c619bba9c8381c148049b81c51" translate="yes" xml:space="preserve">
          <source>The axis to use. 0 or &amp;lsquo;index&amp;rsquo; for row-wise, 1 or &amp;lsquo;columns&amp;rsquo; for column-wise.</source>
          <target state="translated">사용할 축입니다. 행 단위의 경우 0 또는 '색인', 열 단위의 경우 1 또는 '열'.</target>
        </trans-unit>
        <trans-unit id="4c64beaaf0afa44cf44258f6f2f8813cb55a49ce" translate="yes" xml:space="preserve">
          <source>The axis to use. 0 or &amp;lsquo;index&amp;rsquo; to compute column-wise, 1 or &amp;lsquo;columns&amp;rsquo; for row-wise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42278d9800c74796740df55c085822dda417ea8b" translate="yes" xml:space="preserve">
          <source>The axis to use. The value 0 identifies the rows, and 1 identifies the columns.</source>
          <target state="translated">사용할 축입니다. 값 0은 행을 식별하고 1은 열을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="e8654139201e980e0b15318fe15dafc47fb2959e" translate="yes" xml:space="preserve">
          <source>The backend module can then use other visualization tools (Bokeh, Altair, hvplot,&amp;hellip;) to generate the plots. Some libraries implementing a backend for pandas are listed on the ecosystem &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/1.2.0/ecosystem.html#ecosystem-visualization&quot;&gt;Visualization&lt;/a&gt; page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a845f39ad44c7ea5c36b661ccf9335e0180112c" translate="yes" xml:space="preserve">
          <source>The backend module can then use other visualization tools (Bokeh, Altair,&amp;hellip;) to generate the plots.</source>
          <target state="translated">그런 다음 백엔드 모듈은 다른 시각화 도구 (Bokeh, Altair 등)를 사용하여 플롯을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e39081bec86a8cfd5d99706a1d6516fce6fc196" translate="yes" xml:space="preserve">
          <source>The background color is determined according to the data in each column (optionally row). Requires matplotlib.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0f3a088a1421033ee6663032966e8a343cfca4" translate="yes" xml:space="preserve">
          <source>The base pandas Index type.</source>
          <target state="translated">기본 팬더 색인 유형입니다.</target>
        </trans-unit>
        <trans-unit id="de4a335a31f98039c555810167580a6d9b6b0b8b" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;DateOffset&lt;/code&gt; acts similar to &lt;code&gt;dateutil.relativedelta&lt;/code&gt; (&lt;a href=&quot;https://dateutil.readthedocs.io/en/stable/relativedelta.html&quot;&gt;relativedelta documentation&lt;/a&gt;) that shifts a date time by the corresponding calendar duration specified. The arithmetic operator (&lt;code&gt;+&lt;/code&gt;) or the &lt;code&gt;apply&lt;/code&gt; method can be used to perform the shift.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1197c2202520730269e894d690a1f733d54101" translate="yes" xml:space="preserve">
          <source>The basics of indexing are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fd329b7e8ee3bfdaf431a851607c95c9f9bfb8" translate="yes" xml:space="preserve">
          <source>The behavior is as follows:</source>
          <target state="translated">동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffa1e34c2a61ff50e9184dc020fe8ffc1df8f78b" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;indent=0&lt;/code&gt; varies from the stdlib, which does not indent the output but does insert newlines. Currently, &lt;code&gt;indent=0&lt;/code&gt; and the default &lt;code&gt;indent=None&lt;/code&gt; are equivalent in pandas, though this may change in a future release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a591a1428c9c253145871e441c6317179376a4" translate="yes" xml:space="preserve">
          <source>The behavior of basic iteration over pandas objects depends on the type. When iterating over a Series, it is regarded as array-like, and basic iteration produces the values. DataFrames follow the dict-like convention of iterating over the &amp;ldquo;keys&amp;rdquo; of the objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e092d4ce6b496049b3ffd1ddaf35699d4c548b4" translate="yes" xml:space="preserve">
          <source>The behaviour of the logical &amp;ldquo;and&amp;rdquo; operation (&lt;code&gt;&amp;amp;&lt;/code&gt;) can be derived using similar logic (where now &lt;code&gt;pd.NA&lt;/code&gt; will not propagate if one of the operands is already &lt;code&gt;False&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbf72311894064e12974abf94ebac96f1ca81b5" translate="yes" xml:space="preserve">
          <source>The below example shows a rolling calculation with a window size of four matching the equivalent function call using &lt;code&gt;numpy.corrcoef()&lt;/code&gt;.</source>
          <target state="translated">아래 예제는 &lt;code&gt;numpy.corrcoef()&lt;/code&gt; 사용하여 동등한 함수 호출과 일치하는 창 크기가 4 인 롤링 계산을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="72f44b1a8792b73f93c95ddff614ef1605f01172" translate="yes" xml:space="preserve">
          <source>The below example shows a similar rolling calculation on a DataFrame using the pairwise option.</source>
          <target state="translated">아래 예제는 pairwise 옵션을 사용하여 DataFrame에서 유사한 롤링 계산을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e06240461be9074d7005f98b7f76400c75ecc500" translate="yes" xml:space="preserve">
          <source>The below example shows how we can downsample by consolidation of samples into fewer samples. Here by using &lt;strong&gt;df.index // 5&lt;/strong&gt;, we are aggregating the samples in bins. By applying &lt;strong&gt;std()&lt;/strong&gt; function, we aggregate the information contained in many samples into a small subset of values which is their standard deviation thereby reducing the number of samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600970eb9e7d2e56ee3ebdce80c6533c1b316427" translate="yes" xml:space="preserve">
          <source>The below examples will show rolling mean calculations with window sizes of two and three, respectively.</source>
          <target state="translated">아래 예제는 각각 창 크기가 2와 3 인 롤링 평균 계산을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d66164a37f63537c7a1c561add9960d4fe103668" translate="yes" xml:space="preserve">
          <source>The below raises &lt;code&gt;TypeError&lt;/code&gt; because the categories are ordered and not identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebdc04a265a22f038191af6d73e81b818cd022c" translate="yes" xml:space="preserve">
          <source>The best method to use depends on the context. Use the &lt;code&gt;Styler&lt;/code&gt; constructor when building many styled DataFrames that should all share the same properties. For interactive use, the&lt;code&gt;.set_&lt;/code&gt; and &lt;code&gt;.hide_&lt;/code&gt; methods are more convenient.</source>
          <target state="translated">사용하는 가장 좋은 방법은 상황에 따라 다릅니다. 모두 동일한 속성을 공유해야하는 많은 스타일이 지정된 DataFrame을 빌드 할 때 &lt;code&gt;Styler&lt;/code&gt; 생성자를 사용하십시오 . 대화식으로 사용하려면 &lt;code&gt;.set_&lt;/code&gt; 및 &lt;code&gt;.hide_&lt;/code&gt; 메소드가 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="5be58bd9e43fae91d3f684a3efa25473ef68334d" translate="yes" xml:space="preserve">
          <source>The best way to combine multiple files into a single DataFrame is to read the individual frames one by one, put all of the individual frames into a list, and then combine the frames in the list using &lt;code&gt;pd.concat()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f495801aafce3160ffcbe88810eb851e2b06c1" translate="yes" xml:space="preserve">
          <source>The best way to think about the pandas data structures is as flexible containers for lower dimensional data. For example, DataFrame is a container for Series, and Series is a container for scalars. We would like to be able to insert and remove objects from these containers in a dictionary-like fashion.</source>
          <target state="translated">팬더 데이터 구조를 생각하는 가장 좋은 방법은 저 차원 데이터를위한 유연한 컨테이너입니다. 예를 들어, DataFrame은 Series의 컨테이너이고 Series는 스칼라의 컨테이너입니다. 이러한 컨테이너에서 사전과 같은 방식으로 개체를 삽입하고 제거 할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="8fb9af0b82006c5dc7c6ad371de2c19a7a2dcf61" translate="yes" xml:space="preserve">
          <source>The biggest drawback to using &lt;a href=&quot;https://github.com/html5lib/html5lib-python&quot;&gt;&lt;strong&gt;html5lib&lt;/strong&gt;&lt;/a&gt; is that it is slow as molasses. However consider the fact that many tables on the web are not big enough for the parsing algorithm runtime to matter. It is more likely that the bottleneck will be in the process of reading the raw text from the URL over the web, i.e., IO (input-output). For very large tables, this might not be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c99c5757879369557f71c34714dceb7b94e8fb8" translate="yes" xml:space="preserve">
          <source>The bins of the grouping are adjusted based on the beginning of the day of the time series starting point. This works well with frequencies that are multiples of a day (like &lt;code&gt;30D&lt;/code&gt;) or that divide a day evenly (like &lt;code&gt;90s&lt;/code&gt; or &lt;code&gt;1min&lt;/code&gt;). This can create inconsistencies with some frequencies that do not meet this criteria. To change this behavior you can specify a fixed Timestamp with the argument &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad049ae6944e5504850c45d9e9dceb2b865368b" translate="yes" xml:space="preserve">
          <source>The boolean dtype (with the alias &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;) provides support for storing boolean data (True, False values) with missing values, which is not possible with a bool &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588808fbd7bbcc5f419a351c1ee5165b35abf3ea" translate="yes" xml:space="preserve">
          <source>The bootstrap plot is used to estimate the uncertainty of a statistic by relaying on random sampling with replacement &lt;a href=&quot;#r11075647b7c8-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. This function will generate bootstrapping plots for mean, median and mid-range statistics for the given number of samples of the given size.</source>
          <target state="translated">부트 스트랩 플롯은 랜덤 샘플링을 대체하여 릴레이하여 통계의 불확실성을 추정하는 데 사용됩니다 &lt;a href=&quot;#r11075647b7c8-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 이 함수는 주어진 크기의 주어진 샘플 수에 대한 평균, 중간 및 중간 범위 통계에 대한 부트 스트랩 플롯을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a470a4671ee8442874175278b709a2f5dc63940b" translate="yes" xml:space="preserve">
          <source>The branch will still exist on GitHub, so to delete it there do:</source>
          <target state="translated">지점은 여전히 ​​GitHub에 존재하므로 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="36281ec0ffa1ebc809be2c9c9bcff98308e72f4c" translate="yes" xml:space="preserve">
          <source>The callable should accept a floating point number and return a string with the desired format of the number. This is used in some places like SeriesFormatter. See core.format.EngFormatter for an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8252fa2350a1a65a2f3526e49864b8b0e61a23a9" translate="yes" xml:space="preserve">
          <source>The callable should accept a floating point number and return a string with the desired format of the number. This is used in some places like SeriesFormatter. See formats.format.EngFormatter for an example. [default: None] [currently: None]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44ef9943538bfa4adca5d29238f26f740ab84cf" translate="yes" xml:space="preserve">
          <source>The categorical data type is useful in the following cases:</source>
          <target state="translated">범주 형 데이터 유형은 다음과 같은 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="76e015b72ddefcfeaba3e8ff971650b50f930e8b" translate="yes" xml:space="preserve">
          <source>The categories for the categorical. Items need to be unique. If the categories are not given here (and also not in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e04066206c6e50fc4fd13bb5c96b07f814b14e97" translate="yes" xml:space="preserve">
          <source>The categories for the categorical. Items need to be unique. If the categories are not given here (and also not in &lt;code&gt;dtype&lt;/code&gt;), they will be inferred from the &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">범주의 범주입니다. 아이템은 고유해야합니다. 여기에 범주가 제공되지 않은 경우 (및 &lt;code&gt;dtype&lt;/code&gt; 도 제공되지 않은 경우) &lt;code&gt;data&lt;/code&gt; 에서 추론됩니다 .</target>
        </trans-unit>
        <trans-unit id="43b2622c8ce2764c7195be77b1361e55601ef898" translate="yes" xml:space="preserve">
          <source>The categories for the categorical. Items need to be unique. If the categories are not given here, then they must be provided in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd1f578fc078e58b7aa82c55530e13bf12aa7e71" translate="yes" xml:space="preserve">
          <source>The categories for the categorical. Items need to be unique. If the categories are not given here, then they must be provided in &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">범주의 범주입니다. 아이템은 고유해야합니다. 여기에 카테고리가 제공되지 않으면 &lt;code&gt;dtype&lt;/code&gt; 으로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="878e56ad5f7e7fd7a1f83386da6ec9557fa6c4ee" translate="yes" xml:space="preserve">
          <source>The categories in new order.</source>
          <target state="translated">새로운 순서의 카테고리.</target>
        </trans-unit>
        <trans-unit id="e63f5263dca62a1a41fb98737e313c4966d6bb1f" translate="yes" xml:space="preserve">
          <source>The categories of this categorical.</source>
          <target state="translated">이 범주의 범주입니다.</target>
        </trans-unit>
        <trans-unit id="6b97eddff0c0010f556ecc62e6d860d566ed34a4" translate="yes" xml:space="preserve">
          <source>The categories which should be removed.</source>
          <target state="translated">제거해야 할 범주</target>
        </trans-unit>
        <trans-unit id="39d280c538d9d63cf5e3155da5f98d20ebdeb44c" translate="yes" xml:space="preserve">
          <source>The category codes of this categorical.</source>
          <target state="translated">이 범주의 카테고리 코드.</target>
        </trans-unit>
        <trans-unit id="9fec8b14fc65615469e140d82b4d8cee31fdaa65" translate="yes" xml:space="preserve">
          <source>The category dtypes must be &lt;em&gt;exactly&lt;/em&gt; the same, meaning the same categories and the ordered attribute. Otherwise the result will coerce to the categories&amp;rsquo; dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19f79ba4561384be099b829098a2fe19b7429cf" translate="yes" xml:space="preserve">
          <source>The chained assignment warnings / exceptions are aiming to inform the user of a possibly invalid assignment. There may be false positives; situations where a chained assignment is inadvertently reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5571259d06c00d0cc7ec372fb183e16a2a68f71" translate="yes" xml:space="preserve">
          <source>The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored.</source>
          <target state="translated">인용 된 항목의 시작과 끝을 나타내는 데 사용되는 문자입니다. 인용 된 항목은 구분자를 포함 할 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b6b936303a3065e9ff6e48098e73cadb4616ce6e" translate="yes" xml:space="preserve">
          <source>The choice of using &lt;code&gt;NaN&lt;/code&gt; internally to denote missing data was largely for simplicity and performance reasons. It differs from the MaskedArray approach of, for example, &lt;code&gt;scikits.timeseries&lt;/code&gt;. We are hopeful that NumPy will soon be able to provide a native NA type solution (similar to R) performant enough to be used in pandas.</source>
          <target state="translated">누락 된 데이터를 나타 내기 위해 &lt;code&gt;NaN&lt;/code&gt; 을 내부적 으로 사용하는 선택 은 주로 단순성과 성능상의 이유로 이루어졌습니다. 그것은 예를 들어,의 MaskedArray 접근 방식에서 차이가 &lt;code&gt;scikits.timeseries&lt;/code&gt; . NumPy가 곧 판다에 사용하기에 충분한 네이티브 NA 형 솔루션 (R과 유사한) 성능을 제공 할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="4c04f61c71ae200111c36d1b418132cdb8f3edf8" translate="yes" xml:space="preserve">
          <source>The choice of using &lt;code&gt;NaN&lt;/code&gt; internally to denote missing data was largely for simplicity and performance reasons. Starting from pandas 1.0, some optional data types start experimenting with a native &lt;code&gt;NA&lt;/code&gt; scalar using a mask-based approach. See &lt;a href=&quot;#missing-data-na&quot;&gt;here&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8279c2d7c14754c63179329e6ba101acf8fe70" translate="yes" xml:space="preserve">
          <source>The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a42b83fb80ae7724d84a0b045e01bfc04250ba7" translate="yes" xml:space="preserve">
          <source>The clearest way to explain is by example. Let&amp;rsquo;s take a prior example data set from the hierarchical indexing section:</source>
          <target state="translated">가장 명확한 설명 방법은 예입니다. 계층 적 인덱싱 섹션에서 이전 예제 데이터 세트를 보자.</target>
        </trans-unit>
        <trans-unit id="ecdbbd9d6b8e55abf1599979e04485dc5e58e767" translate="yes" xml:space="preserve">
          <source>The code is hosted on &lt;a href=&quot;https://www.github.com/pandas-dev/pandas&quot;&gt;GitHub&lt;/a&gt;. To contribute you will need to sign up for a &lt;a href=&quot;https://github.com/signup/free&quot;&gt;free GitHub account&lt;/a&gt;. We use &lt;a href=&quot;http://git-scm.com/&quot;&gt;Git&lt;/a&gt; for version control to allow many people to work together on the project.</source>
          <target state="translated">코드는 &lt;a href=&quot;https://www.github.com/pandas-dev/pandas&quot;&gt;GitHub에서&lt;/a&gt; 호스팅됩니다 . 기고하려면 &lt;a href=&quot;https://github.com/signup/free&quot;&gt;무료 GitHub 계정&lt;/a&gt; 에 가입해야 합니다 . 우리는 &lt;a href=&quot;http://git-scm.com/&quot;&gt;Git&lt;/a&gt; 을 버전 관리에 사용하여 많은 사람들이 프로젝트에서 함께 작업 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="acad627096cc18a3027643ecc34e5706862e601e" translate="yes" xml:space="preserve">
          <source>The collections.abc.Mapping subclass to use as the return object. Can be the actual class or an empty instance of the mapping type you want. If you want a collections.defaultdict, you must pass it initialized.</source>
          <target state="translated">반환 객체로 사용할 collections.abc.Mapping 서브 클래스. 실제 클래스이거나 원하는 매핑 유형의 빈 인스턴스 일 수 있습니다. collections.defaultdict를 원하면 초기화 된 상태로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="10a4624c39a7dce04ebb2c125610a154cb93ec0d" translate="yes" xml:space="preserve">
          <source>The collections.abc.Mapping subclass used for all Mappings in the return value. Can be the actual class or an empty instance of the mapping type you want. If you want a collections.defaultdict, you must pass it initialized.</source>
          <target state="translated">반환 값의 모든 매핑에 사용되는 collections.abc.Mapping 서브 클래스 실제 클래스이거나 원하는 매핑 유형의 빈 인스턴스 일 수 있습니다. collections.defaultdict를 원하면 초기화 된 상태로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="24286507404775fdddf9415dbefb9b09bc859ccc" translate="yes" xml:space="preserve">
          <source>The color for each of the DataFrame&amp;rsquo;s columns. Possible values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4070ed3a628b337f16889a17018ec04a508e19d" translate="yes" xml:space="preserve">
          <source>The color of each point. Possible values are:</source>
          <target state="translated">각 점의 색입니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c26802e3db39eebbc91c3bbb4b5e0ce702f0c22" translate="yes" xml:space="preserve">
          <source>The colors are applied to every boxes to be drawn. If you want more complicated colorization, you can get each drawn artists by passing &lt;a href=&quot;#visualization-box-return&quot;&gt;return_type&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1e6cd6aae24ea702c7a0a06fdb24e4a93446be" translate="yes" xml:space="preserve">
          <source>The column (or list of columns) to use to create the index.</source>
          <target state="translated">인덱스를 만드는 데 사용할 열 또는 열 목록입니다.</target>
        </trans-unit>
        <trans-unit id="eb6473d47aaca0f2137ec3c177359184e3c73dfe" translate="yes" xml:space="preserve">
          <source>The column entries belonging to each label, as a Series.</source>
          <target state="translated">각 레이블에 속하는 열 항목은 Series입니다.</target>
        </trans-unit>
        <trans-unit id="2ee79f93080a08ef4cb620252f367393d4c0985f" translate="yes" xml:space="preserve">
          <source>The column label or position for the value of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5247231fe8ba626fad6c7129666bfdd61ca95182" translate="yes" xml:space="preserve">
          <source>The column label or position for the value of &lt;code&gt;(x, y)&lt;/code&gt; point.</source>
          <target state="translated">&lt;code&gt;(x, y)&lt;/code&gt; 포인트 값의 열 레이블 또는 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="588a7572b3d95f0a5a89edd12686f9709564f7e0" translate="yes" xml:space="preserve">
          <source>The column label or position for x points.</source>
          <target state="translated">x 포인트의 열 레이블 또는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="dd04eb366aaa57d6e315c3a1e94ab9f7318810bc" translate="yes" xml:space="preserve">
          <source>The column label or position for y points.</source>
          <target state="translated">y 포인트의 열 레이블 또는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="496e27668915d93b6710a7a05d5ea08bff64b1ae" translate="yes" xml:space="preserve">
          <source>The column labels of the DataFrame.</source>
          <target state="translated">DataFrame의 열 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="53b9fba64509719cf5ad7f0c1a2cb207fda1fb8c" translate="yes" xml:space="preserve">
          <source>The column labels to use for lookup</source>
          <target state="translated">조회에 사용할 열 레이블</target>
        </trans-unit>
        <trans-unit id="6952801d944bdc987dacf2eb214fb2bb1ef95679" translate="yes" xml:space="preserve">
          <source>The column labels to use for lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dfb14b3ada372347000f14ab85ce77ffeba9515" translate="yes" xml:space="preserve">
          <source>The column name or column position to be used as horizontal coordinates for each point.</source>
          <target state="translated">각 점의 가로 좌표로 사용할 열 이름 또는 열 위치입니다.</target>
        </trans-unit>
        <trans-unit id="dead56ca8e6ddd00554b4b4f1e7ee1e2a270386c" translate="yes" xml:space="preserve">
          <source>The column name or column position to be used as vertical coordinates for each point.</source>
          <target state="translated">각 점의 수직 좌표로 사용될 열 이름 또는 열 위치입니다.</target>
        </trans-unit>
        <trans-unit id="eee0aac1a66b1eb12cc233d6e565a565a5e17be1" translate="yes" xml:space="preserve">
          <source>The column names are keywords. If the values are callable, they are computed on the DataFrame and assigned to the new columns. The callable must not change input DataFrame (though pandas doesn&amp;rsquo;t check it). If the values are not callable, (e.g. a Series, scalar, or array), they are simply assigned.</source>
          <target state="translated">열 이름은 키워드입니다. 값을 호출 할 수 있으면 DataFrame에서 계산되어 새 열에 할당됩니다. 콜 러블은 입력 DataFrame을 변경해서는 안됩니다 (팬더가 확인하지는 않지만). 값을 호출 할 수없는 경우 (예 : Series, 스칼라 또는 배열) 간단히 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="603734f565e92028236a1b4fe637c22d25fc6e01" translate="yes" xml:space="preserve">
          <source>The column names for the DataFrame being iterated over.</source>
          <target state="translated">반복되는 DataFrame의 열 이름입니다.</target>
        </trans-unit>
        <trans-unit id="870ff757e4e91aad23f52ffdc896f9551473c0bb" translate="yes" xml:space="preserve">
          <source>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. On python versions &amp;lt; 3.7 regular tuples are returned for DataFrames with a large number of columns (&amp;gt;254).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa69217c71a367fe16c4cc1ccc96790a0adb7696" translate="yes" xml:space="preserve">
          <source>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (&amp;gt;255), regular tuples are returned.</source>
          <target state="translated">열 이름이 유효하지 않은 파이썬 식별자이거나 반복되거나 밑줄로 시작하면 위치 이름으로 이름이 바뀝니다. 많은 수의 열 (&amp;gt; 255)을 사용하면 일반 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5f679ef9ebaa7d2b04aa98be85e6636aa31ff3bf" translate="yes" xml:space="preserve">
          <source>The columns are also connected to the &lt;a href=&quot;https://ipython.org&quot;&gt;IPython&lt;/a&gt; completion mechanism so they can be tab-completed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="859771c148cd64679e8dceac54e1cc27b8350574" translate="yes" xml:space="preserve">
          <source>The columns format as specified in &lt;a href=&quot;https://en.wikibooks.org/wiki/LaTeX/Tables&quot;&gt;LaTeX table format&lt;/a&gt; e.g. &amp;lsquo;rcl&amp;rsquo; for 3 columns. By default, &amp;lsquo;l&amp;rsquo; will be used for all columns except columns of numbers, which default to &amp;lsquo;r&amp;rsquo;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikibooks.org/wiki/LaTeX/Tables&quot;&gt;LaTeX 테이블 형식에&lt;/a&gt; 지정된 열 형식 ( 예 : 3 열의 경우 'rcl') 기본적으로 'l'은 숫자 열을 제외한 모든 열에 사용되며 기본값은 'r'입니다.</target>
        </trans-unit>
        <trans-unit id="6dbd27c2ff108d01264dc15b0442c92c0cca12e6" translate="yes" xml:space="preserve">
          <source>The columns of a DataFrame can be truncated.</source>
          <target state="translated">DataFrame의 열이 잘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec97de9cd1aba0041f871e06acd5d7c9cbe8e8a" translate="yes" xml:space="preserve">
          <source>The columns of the resulting &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; have different &lt;a href=&quot;basics#basics-dtypes&quot;&gt;dtypes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="339f715add5fbbc8584cd6799003eff7b617ff9e" translate="yes" xml:space="preserve">
          <source>The columns of the resulting &lt;code&gt;DataFrame&lt;/code&gt; have different &lt;a href=&quot;basics#basics-dtypes&quot;&gt;dtypes&lt;/a&gt;.</source>
          <target state="translated">결과 &lt;code&gt;DataFrame&lt;/code&gt; 의 열 은 서로 다른 &lt;a href=&quot;basics#basics-dtypes&quot;&gt;dtype을 갖습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc50b11821758054ff914defeebe1a2bda60d3f4" translate="yes" xml:space="preserve">
          <source>The commands in this table will install pandas for Python 3 from your distribution. To install pandas for Python 2, you may need to use the &lt;code&gt;python-pandas&lt;/code&gt; package.</source>
          <target state="translated">이 테이블의 명령은 배포판에서 Python 3 용 팬더를 설치합니다. Python 2 용 팬더를 설치하려면 &lt;code&gt;python-pandas&lt;/code&gt; 패키지 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d500eab0d0204258ee58bc569775fbec95554d2" translate="yes" xml:space="preserve">
          <source>The common values &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;TRUE&lt;/code&gt;, and &lt;code&gt;FALSE&lt;/code&gt; are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the &lt;code&gt;true_values&lt;/code&gt; and &lt;code&gt;false_values&lt;/code&gt; options as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c906834668fd7851bcb200ee81dcddeaf753422" translate="yes" xml:space="preserve">
          <source>The completion value of evaluating the given code or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84bb9b551fbadf92772361ae93cc2f308c54d7d" translate="yes" xml:space="preserve">
          <source>The compression parameter can also be a &lt;code&gt;dict&lt;/code&gt; in order to pass options to the compression protocol. It must have a &lt;code&gt;'method'&lt;/code&gt; key set to the name of the compression protocol, which must be one of {&lt;code&gt;'zip'&lt;/code&gt;, &lt;code&gt;'gzip'&lt;/code&gt;, &lt;code&gt;'bz2'&lt;/code&gt;}. All other key-value pairs are passed to the underlying compression library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025c5f71624497a85e7a6388aeb5594c55ceba5a" translate="yes" xml:space="preserve">
          <source>The compression type can be an explicit parameter or be inferred from the file extension. If &amp;lsquo;infer&amp;rsquo;, then use &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bz2&lt;/code&gt;, &lt;code&gt;zip&lt;/code&gt;, or &lt;code&gt;xz&lt;/code&gt; if filename ends in &lt;code&gt;'.gz'&lt;/code&gt;, &lt;code&gt;'.bz2'&lt;/code&gt;, &lt;code&gt;'.zip'&lt;/code&gt;, or &lt;code&gt;'.xz'&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f76dd0b00cb8ce12babae3aaab3975584e61633" translate="yes" xml:space="preserve">
          <source>The computed or specified bins. Only returned when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70591e847b5c74a3726e37e861f369edd688f5f4" translate="yes" xml:space="preserve">
          <source>The computed or specified bins. Only returned when &lt;code&gt;retbins=True&lt;/code&gt;. For scalar or sequence &lt;code&gt;bins&lt;/code&gt;, this is an ndarray with the computed bins. If set &lt;code&gt;duplicates=drop&lt;/code&gt;, &lt;code&gt;bins&lt;/code&gt; will drop non-unique bin. For an IntervalIndex &lt;code&gt;bins&lt;/code&gt;, this is equal to &lt;code&gt;bins&lt;/code&gt;.</source>
          <target state="translated">계산되거나 지정된 구간입니다. &lt;code&gt;retbins=True&lt;/code&gt; 일 때만 반환됩니다 . 스칼라 또는 시퀀스 &lt;code&gt;bins&lt;/code&gt; 경우 계산 빈이있는 ndarray입니다. 설정된 경우 &lt;code&gt;duplicates=drop&lt;/code&gt; , &lt;code&gt;bins&lt;/code&gt; 고유하지 않은 빈 떨어질 것이다. IntervalIndex &lt;code&gt;bins&lt;/code&gt; 경우 &lt;code&gt;bins&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="272619cbb9905160cb5aa85e1c18ec1e10d80522" translate="yes" xml:space="preserve">
          <source>The content of a &lt;code&gt;Series&lt;/code&gt; (or &lt;code&gt;Index&lt;/code&gt;) can be concatenated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a3c185de6a683c9b6ab54effd811f3730b1885" translate="yes" xml:space="preserve">
          <source>The convention is &lt;code&gt;ilevel_0&lt;/code&gt;, which means &amp;ldquo;index level 0&amp;rdquo; for the 0th level of the &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27b16e3506e4d5e764bdd0fc01e6ae2ae9ea014" translate="yes" xml:space="preserve">
          <source>The coordinates of each point are defined by two dataframe columns and filled circles are used to represent each point. This kind of plot is useful to see complex correlations between two variables. Points could be for instance natural 2D coordinates like longitude and latitude in a map or, in general, any pair of metrics that can be plotted against each other.</source>
          <target state="translated">각 점의 좌표는 두 개의 데이터 프레임 열로 정의되며 채워진 원은 각 점을 나타내는 데 사용됩니다. 이 종류의 플롯은 두 변수 사이의 복잡한 상관 관계를 보는 데 유용합니다. 포인트는 예를 들어 맵의 경도 및 위도와 같은 자연적인 2D 좌표이거나 일반적으로 서로에 대해 플롯 할 수있는 모든 메트릭 쌍이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea625acdc6781dba4bd58f2fe461a519a41789a" translate="yes" xml:space="preserve">
          <source>The core of pandas is, and will remain, its &amp;ldquo;high-performance, easy-to-use data structures&amp;rdquo;. With that in mind, we hope that &lt;code&gt;DataFrame.style&lt;/code&gt; accomplishes two goals</source>
          <target state="translated">팬더의 핵심은 &quot;고성능의 사용하기 쉬운 데이터 구조&quot;이며 앞으로도 계속 유지 될 것입니다. 이를 염두에두고 &lt;code&gt;DataFrame.style&lt;/code&gt; 이 두 가지 목표를 달성 하기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="cc064b3b484c00d883640426c2a68b9f0a3aee7a" translate="yes" xml:space="preserve">
          <source>The correct way to swap column values is by using raw values:</source>
          <target state="translated">열 값을 바꾸는 올바른 방법은 원시 값을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f8af154a6b9e34bedc69749c5aa9b60a2b078b6" translate="yes" xml:space="preserve">
          <source>The corresponding functions in the &lt;code&gt;re&lt;/code&gt; package for these three match modes are &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.fullmatch&quot;&gt;re.fullmatch&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.match&quot;&gt;re.match&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/3/library/re.html#re.search&quot;&gt;re.search&lt;/a&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33941291fb1e0c87c285a16385fb41a48a48869c" translate="yes" xml:space="preserve">
          <source>The corresponding method for IntervalArray.</source>
          <target state="translated">IntervalArray에 해당하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="b4cc88d788cc98fbbbad671f4927ba403ca319d7" translate="yes" xml:space="preserve">
          <source>The corresponding method for IntervalIndex.</source>
          <target state="translated">IntervalIndex에 해당하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="360f341ef6ba381134393b1594fbaa54a41a7d0f" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the series of the DataFrame.</source>
          <target state="translated">일련의 DataFrame의 공분산 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="a592412f98c5b4e9930d12bb8c333597743f24ee" translate="yes" xml:space="preserve">
          <source>The criteria to bin by.</source>
          <target state="translated">비닝 기준.</target>
        </trans-unit>
        <trans-unit id="e5a1e60fd2064a78005124353880ad6d5666032a" translate="yes" xml:space="preserve">
          <source>The current behaviour of &amp;lsquo;Series.argmax&amp;rsquo; is deprecated, use &amp;lsquo;idxmax&amp;rsquo; instead. The behavior of &amp;lsquo;argmax&amp;rsquo; will be corrected to return the positional maximum in the future. For now, use &amp;lsquo;series.values.argmax&amp;rsquo; or &amp;lsquo;np.argmax(np.array(values))&amp;rsquo; to get the position of the maximum row.</source>
          <target state="translated">'Series.argmax'의 현재 동작은 더 이상 사용되지 않으며 대신 'idxmax'를 사용하십시오. 'argmax'의 동작은 향후 위치 최대 값을 반환하도록 수정됩니다. 지금은 'series.values.argmax'또는 'np.argmax (np.array (values))'를 사용하여 최대 행의 위치를 ​​가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a9fc8d61f6758f12be787f7649ece0afcd26009d" translate="yes" xml:space="preserve">
          <source>The current behaviour of &amp;lsquo;Series.argmin&amp;rsquo; is deprecated, use &amp;lsquo;idxmin&amp;rsquo; instead. The behavior of &amp;lsquo;argmin&amp;rsquo; will be corrected to return the positional minimum in the future. For now, use &amp;lsquo;series.values.argmin&amp;rsquo; or &amp;lsquo;np.argmin(np.array(values))&amp;rsquo; to get the position of the minimum row.</source>
          <target state="translated">'Series.argmin'의 현재 동작은 더 이상 사용되지 않으며 대신 'idxmin'을 사용하십시오. 'argmin'의 동작은 향후 위치 최소값을 반환하도록 수정됩니다. 지금은 'series.values.argmin'또는 'np.argmin (np.array (values))'를 사용하여 최소 행의 위치를 ​​가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c89bcb430fefe333466b2e0f5047debe5eea54c9" translate="yes" xml:space="preserve">
          <source>The current implementation imposes three requirements on f:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e943872400ae36f28011d0370082235c723268eb" translate="yes" xml:space="preserve">
          <source>The dashed line is 99% confidence band.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c05761a8cf8776548117ff664c8ffe301cfa9c" translate="yes" xml:space="preserve">
          <source>The data alignment here is on the indexes (row labels). This same behavior can be achieved using &lt;code&gt;merge&lt;/code&gt; plus additional arguments instructing it to use the indexes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b5a2dafdd8088817ccb88c6ba1e26e6f40f1369" translate="yes" xml:space="preserve">
          <source>The data from the above URL changes every Monday so the resulting data above and the data below may be slightly different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c8fc67ca0e8e554fcdfc4a52b37e930aedd5ec7" translate="yes" xml:space="preserve">
          <source>The data of the row as a Series.</source>
          <target state="translated">행으로서의 데이터.</target>
        </trans-unit>
        <trans-unit id="1b46a6371a5e32d7201212d06d795417e7d9ba46" translate="yes" xml:space="preserve">
          <source>The data to append.</source>
          <target state="translated">추가 할 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="cc8912934a8248c83b94d53606fdaa96ab458a7a" translate="yes" xml:space="preserve">
          <source>The data to be converted to timedelta.</source>
          <target state="translated">타임 델타로 변환 할 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="a87796e0cfeef9524ea3664b9dca8f23ae53dd1c" translate="yes" xml:space="preserve">
          <source>The data to store. These should be arrays that can be directly converted to ordinals without inference or copy (PeriodArray, ndarray[int64]), or a box around such an array (Series[period], PeriodIndex).</source>
          <target state="translated">저장할 데이터입니다. 이들은 추론이나 복사 (PeriodArray, ndarray [int64]) 또는 그러한 배열 주위의 상자 (Series [period], PeriodIndex)없이 서수로 직접 변환 할 수있는 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a98ea2aca679e0f46d91ae4b2e92996b8664b8c" translate="yes" xml:space="preserve">
          <source>The data type and indication of sparse/dense of each column.</source>
          <target state="translated">각 열의 데이터 유형 및 스파 스 / 밀도 밀도 표시</target>
        </trans-unit>
        <trans-unit id="347c2710a27722538431cd66497ed229ece2a685" translate="yes" xml:space="preserve">
          <source>The data type of each column.</source>
          <target state="translated">각 열의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="fea04a1b2d966d6e26bb9950ad49a3987df38f25" translate="yes" xml:space="preserve">
          <source>The datetime data.</source>
          <target state="translated">날짜 / 시간 데이터</target>
        </trans-unit>
        <trans-unit id="a6c1f76b87dfc3bb77c3abb379dc4ef5b6edeba8" translate="yes" xml:space="preserve">
          <source>The day (calendar) is the default frequency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e09257721aa282ef5eff3f9e99015ad3ec76cb" translate="yes" xml:space="preserve">
          <source>The day of the datetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a72d66aa4679137482bf814ae1b74976918804" translate="yes" xml:space="preserve">
          <source>The day of the week with Monday=0, Sunday=6</source>
          <target state="translated">월요일 = 0, 일요일 = 6 인 요일</target>
        </trans-unit>
        <trans-unit id="554072b7cbe5efba256068dc7290ad0703cd1845" translate="yes" xml:space="preserve">
          <source>The day of the week with Monday=0, Sunday=6.</source>
          <target state="translated">월요일 = 0, 일요일 = 6 인 요일.</target>
        </trans-unit>
        <trans-unit id="64648e620fd79a164edd40b92246b3c3aebed464" translate="yes" xml:space="preserve">
          <source>The day of year.</source>
          <target state="translated">일.</target>
        </trans-unit>
        <trans-unit id="2a365d5a5aa1bd95bbece5bf6740fa258a1329bb" translate="yes" xml:space="preserve">
          <source>The days of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5989e13a431b85456adef20a1f2cc995bfa0c5" translate="yes" xml:space="preserve">
          <source>The days of the datetime.</source>
          <target state="translated">날짜 / 시간</target>
        </trans-unit>
        <trans-unit id="a7b7ac5eaf6043bcc3bcfcf646acc5681f932ee0" translate="yes" xml:space="preserve">
          <source>The days of the period</source>
          <target state="translated">기간의 일</target>
        </trans-unit>
        <trans-unit id="8ed8771c0136670aee5697cde5f9337cb3c542d7" translate="yes" xml:space="preserve">
          <source>The days of the period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="539622d22b3611e1a0d2bdec661bbb3d138ab211" translate="yes" xml:space="preserve">
          <source>The default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465ed9c51fe2ea4cb677946a9bdf6b974a7e53a2" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;'pandas'&lt;/code&gt; parser allows a more intuitive syntax for expressing query-like operations (comparisons, conjunctions and disjunctions). In particular, the precedence of the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; operators is made equal to the precedence of the corresponding boolean operations &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250a6fe5596f17f6e4cfbb290ed5a31cd6dc3490" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;NaN&lt;/code&gt; recognized values are &lt;code&gt;['-1.#IND', '1.#QNAN', '1.#IND', '-1.#QNAN', '#N/A N/A', '#N/A', 'N/A',
'n/a', 'NA', '&amp;lt;NA&amp;gt;', '#NA', 'NULL', 'null', 'NaN', '-NaN', 'nan', '-nan', '']&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c64834671b77cc191d56a17247fdc8dd9dd171b" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;ddof&lt;/code&gt; of 1 used in &lt;code&gt;Series.var()&lt;/code&gt; is different than the default &lt;code&gt;ddof&lt;/code&gt; of 0 in &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html#numpy.var&quot;&gt;&lt;code&gt;numpy.var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Series.var()&lt;/code&gt; 에서 사용되는 기본 &lt;code&gt;ddof&lt;/code&gt; 1은 numpy.var () 에서 기본 &lt;code&gt;ddof&lt;/code&gt; 0과 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html#numpy.var&quot;&gt; &lt;code&gt;numpy.var()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b449264054f856d7a4023d0b4c9e6fb5386e6683" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;ddof&lt;/code&gt; of 1 used in Series.std is different than the default &lt;code&gt;ddof&lt;/code&gt; of 0 in numpy.std.</source>
          <target state="translated">&lt;code&gt;ddof&lt;/code&gt; 에서 사용되는 기본 ddof 1은 numpy.std의 기본 &lt;code&gt;ddof&lt;/code&gt; 0과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2dc4a53f92781a9eaa072ad810a06f953aec7318" translate="yes" xml:space="preserve">
          <source>The default Excel reader engine for &amp;lsquo;ods&amp;rsquo; files. Available options: auto, odf. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8d71966c2838c4209e5b9fb8f73437fd508fc6" translate="yes" xml:space="preserve">
          <source>The default Excel reader engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlrd. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9045bfe475923c00bb76bb5dce9a5de5ad222" translate="yes" xml:space="preserve">
          <source>The default Excel reader engine for &amp;lsquo;xlsb&amp;rsquo; files. Available options: auto, pyxlsb. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3473742f08c39d6822661483c4ed7ce0d346db4e" translate="yes" xml:space="preserve">
          <source>The default Excel reader engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9868fd4425aceae48ebb0fbe0991534129bb1fd7" translate="yes" xml:space="preserve">
          <source>The default Excel reader engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, xlrd, openpyxl. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79f9f43434044c9fcd9e4c6318d386ad9474cfe7" translate="yes" xml:space="preserve">
          <source>The default Excel writer engine for &amp;lsquo;ods&amp;rsquo; files. Available options: auto, odf. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e080c137788494722de338c286ce03d5008320" translate="yes" xml:space="preserve">
          <source>The default Excel writer engine for &amp;lsquo;xls&amp;rsquo; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d385bec812a4e03681424f424a20db2907cb1a19" translate="yes" xml:space="preserve">
          <source>The default Excel writer engine for &amp;lsquo;xls&amp;rsquo; files. Available options: auto, xlwt. [default: auto] [currently: auto] (Deprecated, use `` instead.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6aeaf0c9b630c3d0be445dc1aa52d924930b2e2" translate="yes" xml:space="preserve">
          <source>The default Excel writer engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: &amp;lsquo;openpyxl&amp;rsquo; (the default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7304f8c716031935b1808380b88d3e98fffc52" translate="yes" xml:space="preserve">
          <source>The default Excel writer engine for &amp;lsquo;xlsm&amp;rsquo; files. Available options: auto, openpyxl. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763b951b66366fba99847ee32ec55d29776a88bf" translate="yes" xml:space="preserve">
          <source>The default Excel writer engine for &amp;lsquo;xlsx&amp;rsquo; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775c4a86b09b6b5e2181267f882683b4f3c656a8" translate="yes" xml:space="preserve">
          <source>The default Excel writer engine for &amp;lsquo;xlsx&amp;rsquo; files. Available options: auto, openpyxl, xlsxwriter. [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fd908016d3b540a47b93342aa0688d8fbf144e" translate="yes" xml:space="preserve">
          <source>The default behavior with &lt;code&gt;join='outer'&lt;/code&gt; is to sort the other axis (columns in this case). In a future version of pandas, the default will be to not sort. We specified &lt;code&gt;sort=False&lt;/code&gt; to opt in to the new behavior now.</source>
          <target state="translated">&lt;code&gt;join='outer'&lt;/code&gt; 의 기본 동작 은 다른 축 (이 경우 열)을 정렬하는 것입니다. 이후 버전의 팬더에서는 기본값이 정렬되지 않습니다. 우리는 지금 새로운 행동을 선택하기 위해 &lt;code&gt;sort=False&lt;/code&gt; 를 지정했습니다 .</target>
        </trans-unit>
        <trans-unit id="686826a1f5ce6dd3540284f1ade9b597a3f1298a" translate="yes" xml:space="preserve">
          <source>The default behavior, &lt;code&gt;errors='raise'&lt;/code&gt;, is to raise when unparsable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c5e86fc863dd44dac93b88a70fd9d945bd63c1" translate="yes" xml:space="preserve">
          <source>The default behaviour (None) depends on the return value of the applied function: list-like results will be returned as a Series of those. However if the apply function returns a Series these are expanded to columns.</source>
          <target state="translated">기본 동작 (없음)은 적용된 함수의 반환 값에 따라 다릅니다. 목록과 유사한 결과가 일련의 결과로 반환됩니다. 그러나 apply 함수가 Series를 반환하면 열로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="6f23c8f151cd3c3f458c861bc9341db211a5097b" translate="yes" xml:space="preserve">
          <source>The default behaviour (with &lt;code&gt;dense_index=False&lt;/code&gt;) simply returns a &lt;code&gt;Series&lt;/code&gt; containing only the non-null entries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94deb1ef9aac8ee5071d97b435dad0d700758516" translate="yes" xml:space="preserve">
          <source>The default display value for numeric values is the &amp;ldquo;general&amp;rdquo; (&lt;code&gt;g&lt;/code&gt;) format with &lt;code&gt;pd.options.display.precision&lt;/code&gt; precision.</source>
          <target state="translated">숫자 값의 기본 표시 값은 &lt;code&gt;pd.options.display.precision&lt;/code&gt; 정밀도를 가진 &quot;일반&quot;( &lt;code&gt;g&lt;/code&gt; ) 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="0b0c47ffcabc3f23ad23a7c9a784a7ceb809b7dd" translate="yes" xml:space="preserve">
          <source>The default for &lt;code&gt;DataFrame.join&lt;/code&gt; is to perform a left join (essentially a &amp;ldquo;VLOOKUP&amp;rdquo; operation, for Excel users), which uses only the keys found in the calling DataFrame. Other join types, for example inner join, can be just as easily performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3838a96a5c86ae28010187dde5f06778bf3ce890" translate="yes" xml:space="preserve">
          <source>The default implementation is True if</source>
          <target state="translated">기본 구현은 True</target>
        </trans-unit>
        <trans-unit id="4a033c15dcd83543f554bceedc2b3fd44d9f85d1" translate="yes" xml:space="preserve">
          <source>The default is &amp;ldquo;backward&amp;rdquo; and is compatible in versions below 0.20.0. The direction parameter was added in version 0.20.0 and introduces &amp;ldquo;forward&amp;rdquo; and &amp;ldquo;nearest&amp;rdquo;.</source>
          <target state="translated">기본값은 &quot;뒤로&quot;이며 0.20.0 이하 버전에서 호환됩니다. 방향 매개 변수는 버전 0.20.0에서 추가되었으며&amp;ldquo;앞으로&amp;rdquo;및&amp;ldquo;가장 가까운&amp;rdquo;을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="6fd5d335f7c8914146a7ed31639c73f8be2455a1" translate="yes" xml:space="preserve">
          <source>The default is set at &lt;code&gt;origin='unix'&lt;/code&gt;, which defaults to &lt;code&gt;1970-01-01 00:00:00&lt;/code&gt;. Commonly called &amp;lsquo;unix epoch&amp;rsquo; or POSIX time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0da428da5593078768c17e8f70e02f69ea614a73" translate="yes" xml:space="preserve">
          <source>The default is to &amp;lsquo;infer&amp;rsquo;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c865743c00536196724bb599b1f047c8427bfcb" translate="yes" xml:space="preserve">
          <source>The default naming roughly follows these rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c112529ea43b53b9e7b00a7abe9a9e341334a5" translate="yes" xml:space="preserve">
          <source>The default of &lt;code&gt;convert_axes=True&lt;/code&gt;, &lt;code&gt;dtype=True&lt;/code&gt;, and &lt;code&gt;convert_dates=True&lt;/code&gt; will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to &lt;code&gt;dtype&lt;/code&gt;. &lt;code&gt;convert_axes&lt;/code&gt; should only be set to &lt;code&gt;False&lt;/code&gt; if you need to preserve string-like numbers (e.g. &amp;lsquo;1&amp;rsquo;, &amp;lsquo;2&amp;rsquo;) in an axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8bf5c99577c69e7ba32aaecbbbcad80e66518cd" translate="yes" xml:space="preserve">
          <source>The default pandas data types are not the most memory efficient. This is especially true for text data columns with relatively few unique values (commonly referred to as &amp;ldquo;low-cardinality&amp;rdquo; data). By using more efficient data types, you can store larger datasets in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac918f51a3ee13be9824c12a850992912682d07" translate="yes" xml:space="preserve">
          <source>The default parquet reader/writer engine. Available options: &amp;lsquo;auto&amp;rsquo;, &amp;lsquo;pyarrow&amp;rsquo;, &amp;lsquo;fastparquet&amp;rsquo;, the default is &amp;lsquo;auto&amp;rsquo; [default: auto] [currently: auto]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7211034c85c337418abb966a57c8b29f46750d2b" translate="yes" xml:space="preserve">
          <source>The default return dtype is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2de7bbeecaccacc960723e631406a8183d969f2" translate="yes" xml:space="preserve">
          <source>The default return dtype is &lt;code&gt;float64&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt; depending on the data supplied. Use the &lt;code&gt;downcast&lt;/code&gt; parameter to obtain other dtypes.</source>
          <target state="translated">기본 리턴 dtype은 제공된 데이터에 따라 &lt;code&gt;float64&lt;/code&gt; 또는 &lt;code&gt;int64&lt;/code&gt; 입니다. &lt;code&gt;downcast&lt;/code&gt; 매개 변수를 사용하여 다른 dtype을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="4a94272dfba9cb7cce6b9cea34aa191a82933121" translate="yes" xml:space="preserve">
          <source>The default setting of &lt;code&gt;dropna&lt;/code&gt; argument is &lt;code&gt;True&lt;/code&gt; which means &lt;code&gt;NA&lt;/code&gt; are not included in group keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51102fcdd78ad1ff2846475c383da2914fab1633" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;sheet_name&lt;/code&gt; is 0, indicating to read the first sheet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e10b70eb2ab52eda4f5a8166c4b5ef135a758fd" translate="yes" xml:space="preserve">
          <source>The default value may be overridden by specifying a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3d8de5175ba758737fc415e86d3b36b7a518880" translate="yes" xml:space="preserve">
          <source>The default value may be overridden by specifying a &lt;code&gt;fill_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 를 지정하여 기본값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="433ed18bebab1f00726f6c869a1d16f8912515cd" translate="yes" xml:space="preserve">
          <source>The default value of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff67c5e5957bdad7df1e4c720b86432f83ab4020" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;None&lt;/code&gt; instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used. If it is one larger, then the first field is used as an index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7a08b440290c21cffc0816bc4e51145b744da7" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;freq&lt;/code&gt; is the &lt;code&gt;freq&lt;/code&gt; attribute of the index, which is &amp;lsquo;MS&amp;rsquo; (month start) in this example.</source>
          <target state="translated">&lt;code&gt;freq&lt;/code&gt; 의 기본값 은이 예에서 'MS'(월 시작) 인 인덱스 의 &lt;code&gt;freq&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="f9acce6813507f757db0a8bfa10b11c99f0e963a" translate="yes" xml:space="preserve">
          <source>The default values for &lt;code&gt;label&lt;/code&gt; and &lt;code&gt;closed&lt;/code&gt; is &amp;lsquo;&lt;strong&gt;left&lt;/strong&gt;&amp;rsquo; for all frequency offsets except for &amp;lsquo;M&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, &amp;lsquo;Q&amp;rsquo;, &amp;lsquo;BM&amp;rsquo;, &amp;lsquo;BA&amp;rsquo;, &amp;lsquo;BQ&amp;rsquo;, and &amp;lsquo;W&amp;rsquo; which all have a default of &amp;lsquo;right&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5436c507f00fd23193fe4be1314bba401846f8" translate="yes" xml:space="preserve">
          <source>The default values, in addition to the string &lt;code&gt;&quot;Nope&quot;&lt;/code&gt; are recognized as &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706c9475778585d0de595433e5fe4844699e8e9f" translate="yes" xml:space="preserve">
          <source>The default will be read from the config module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13fcc7e663bbc25fee99c7c86cb17fc1b01917a" translate="yes" xml:space="preserve">
          <source>The descriptive statistics and computational methods discussed in the &lt;a href=&quot;basics#basics-stats&quot;&gt;data structure overview&lt;/a&gt; (and listed &lt;a href=&quot;../reference/series#api-series-stats&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;../reference/frame#api-dataframe-stats&quot;&gt;here&lt;/a&gt;) are all written to account for missing data. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60e909231b68e28bd138e81b555fb3de9216a755" translate="yes" xml:space="preserve">
          <source>The desired frequency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="073f912a2527ac0aff9cae70c295331d17e13f52" translate="yes" xml:space="preserve">
          <source>The details of the parameters will be added in this section. This section has the title &amp;ldquo;Parameters&amp;rdquo;, followed by a line with a hyphen under each letter of the word &amp;ldquo;Parameters&amp;rdquo;. A blank line is left before the section title, but not after, and not between the line with the word &amp;ldquo;Parameters&amp;rdquo; and the one with the hyphens.</source>
          <target state="translated">매개 변수의 세부 사항이이 섹션에 추가됩니다. 이 섹션에는&amp;ldquo;매개 변수&amp;rdquo;라는 제목이 있고&amp;ldquo;매개 변수&amp;rdquo;라는 단어의 각 문자 아래에 하이픈이있는 줄이 있습니다. 섹션 제목 앞에 빈 줄이 남지만 &quot;Parameters&quot;라는 단어가있는 줄과 하이픈이있는 줄 사이에는 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52d5c6408ba18c3368471dd2ca2fa812d9493aa8" translate="yes" xml:space="preserve">
          <source>The difference between the above two variants arises because we are dealing with series which have finite history. Consider a series of infinite history, with &lt;code&gt;adjust=True&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e0d0ec63462380b055dc2244e690fd4fd0186f" translate="yes" xml:space="preserve">
          <source>The different indexing operation can potentially change the dtype of a &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a6e278c3b09ad107583a9b50b976e83542830e" translate="yes" xml:space="preserve">
          <source>The dimension of the returned result can also change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3e1a1b7aac1fcca4093b60b1bdc23a103805f9" translate="yes" xml:space="preserve">
          <source>The dimensions of DataFrame and other must be compatible in order to compute the matrix multiplication. In addition, the column names of DataFrame and the index of other must contain the same values, as they will be aligned prior to the multiplication.</source>
          <target state="translated">행렬 곱셈을 계산하려면 DataFrame 및 기타의 차원이 호환 가능해야합니다. 또한 DataFrame의 열 이름과 other의 인덱스는 곱하기 전에 정렬되므로 동일한 값을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="db36d98c25853eba699e8e9416c998a4f305eaa3" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;fullmatch&lt;/code&gt;, and &lt;code&gt;contains&lt;/code&gt; is strictness: &lt;code&gt;fullmatch&lt;/code&gt; tests whether the entire string matches the regular expression; &lt;code&gt;match&lt;/code&gt; tests whether there is a match of the regular expression that begins at the first character of the string; and &lt;code&gt;contains&lt;/code&gt; tests whether there is a match of the regular expression at any position within the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a3f344332215ad709e515143729ea445ed320f" translate="yes" xml:space="preserve">
          <source>The docstrings follow a pandas convention, based on the &lt;strong&gt;Numpy Docstring Standard&lt;/strong&gt;. Follow the &lt;a href=&quot;contributing_docstring#docstring&quot;&gt;pandas docstring guide&lt;/a&gt; for detailed instructions on how to write a correct docstring.</source>
          <target state="translated">docstring은 &lt;strong&gt;Numpy Docstring Standard&lt;/strong&gt; 기반의 팬더 규칙을 따릅니다 . 올바른 docstring을 작성하는 방법에 대한 자세한 지시 사항 은 &lt;a href=&quot;contributing_docstring#docstring&quot;&gt;pandas docstring 안내서&lt;/a&gt; 를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="8bfb4c304f228aaff2dc1cec19b6c50daf45cbce" translate="yes" xml:space="preserve">
          <source>The docstrings provide a clear explanation of the usage of the individual functions, while the documentation in this folder consists of tutorial-like overviews per topic together with some other information (what&amp;rsquo;s new, installation, etc).</source>
          <target state="translated">docstring은 개별 기능의 사용법에 대한 명확한 설명을 제공하는 반면이 폴더의 문서는 주제별 튜토리얼 개요와 다른 정보 (새로운 기능, 설치 등)로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84c5f6ccef319a39910bac9f2c169b3f9186cb6f" translate="yes" xml:space="preserve">
          <source>The documentation is written in &lt;strong&gt;reStructuredText&lt;/strong&gt;, which is almost like writing in plain English, and built using &lt;a href=&quot;http://sphinx.pocoo.org/&quot;&gt;Sphinx&lt;/a&gt;. The Sphinx Documentation has an excellent &lt;a href=&quot;http://sphinx.pocoo.org/rest.html&quot;&gt;introduction to reST&lt;/a&gt;. Review the Sphinx docs to perform more complex changes to the documentation as well.</source>
          <target state="translated">이 문서는 &lt;strong&gt;reStructuredText&lt;/strong&gt; 로 작성되었으며 , 일반 영어로 작성하는 것과 거의 비슷하며 &lt;a href=&quot;http://sphinx.pocoo.org/&quot;&gt;Sphinx를&lt;/a&gt; 사용하여 작성되었습니다 . 스핑크스 문서에는 &lt;a href=&quot;http://sphinx.pocoo.org/rest.html&quot;&gt;reST에&lt;/a&gt; 대한 훌륭한 소개가 있습니다 . Sphinx 문서를 검토하여 문서에 대한보다 복잡한 변경도 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c7aac8846f37474850cb16c3310b007bad268e00" translate="yes" xml:space="preserve">
          <source>The documentation of the return is also similar to the parameters. But in this case, no name will be provided, unless the method returns or yields more than one value (a tuple of values).</source>
          <target state="translated">반품에 대한 문서도 매개 변수와 유사합니다. 그러나이 경우 메소드가 둘 이상의 값 (튜플 값)을 리턴하거나 생성하지 않으면 이름이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0897b2a7a0fa02adf7a30f758cef844f21a9515b" translate="yes" xml:space="preserve">
          <source>The dot method for Series computes the inner product, instead of the matrix product here.</source>
          <target state="translated">Series의 도트 방법은 여기서 매트릭스 곱 대신 내부 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ea1c32fe7462d36538b25efd37151d511037fd38" translate="yes" xml:space="preserve">
          <source>The dot method works also if other is an np.array.</source>
          <target state="translated">도트 방법은 다른 것이 np.array 인 경우에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3b16eb53f1a75de548a6bde9f0180712536d3878" translate="yes" xml:space="preserve">
          <source>The dtype information is available on the &lt;code&gt;Categorical&lt;/code&gt;</source>
          <target state="translated">dtype 정보는 &lt;code&gt;Categorical&lt;/code&gt; 형에서 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c4d158a15c4acfcaeb0752cb4f9f44e3157db15a" translate="yes" xml:space="preserve">
          <source>The dtype is &lt;em&gt;not&lt;/em&gt; compared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ef1002ce728cf60a393377668f0b603a0d1851" translate="yes" xml:space="preserve">
          <source>The dtype of the Interval bounds.</source>
          <target state="translated">간격 범위의 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="d662a0ee3a479b7774f6ee1be90b8c751195f6f1" translate="yes" xml:space="preserve">
          <source>The dtype of the non-sparse values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dff788d41d8864ac91966b175d1157885276dca0" translate="yes" xml:space="preserve">
          <source>The dtype of the underlying array storing the non-fill value values.</source>
          <target state="translated">채워지지 않은 값을 저장하는 기본 배열의 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="afbba94d5d0f6fe486cbede799aa9eeb41861faa" translate="yes" xml:space="preserve">
          <source>The dtype to pass to &lt;code&gt;numpy.asarray()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.asarray()&lt;/code&gt; 에 전달할 dtype</target>
        </trans-unit>
        <trans-unit id="5094d945c3a648835306c96a11da9ec1506dd5d7" translate="yes" xml:space="preserve">
          <source>The dtype to pass to &lt;code&gt;numpy.asarray()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9b06fe3766e5f16050e4f74023856c774e7894" translate="yes" xml:space="preserve">
          <source>The dtype to use for the SparseArray. For numpy dtypes, this determines the dtype of &lt;code&gt;self.sp_values&lt;/code&gt;. For SparseDtype, this determines &lt;code&gt;self.sp_values&lt;/code&gt; and &lt;code&gt;self.fill_value&lt;/code&gt;.</source>
          <target state="translated">SparseArray에 사용할 dtype입니다. numpy dtypes의 경우 이는 self.sp_values의 &lt;code&gt;self.sp_values&lt;/code&gt; 결정합니다 . SparseDtype의 경우 &lt;code&gt;self.sp_values&lt;/code&gt; 및 &lt;code&gt;self.fill_value&lt;/code&gt; 가 결정 됩니다.</target>
        </trans-unit>
        <trans-unit id="00b6a8e1948b82a08d11d2de9bd673b8427920e0" translate="yes" xml:space="preserve">
          <source>The dtype to use for the array. This may be a NumPy dtype or an extension type registered with pandas using &lt;a href=&quot;pandas.api.extensions.register_extension_dtype#pandas.api.extensions.register_extension_dtype&quot;&gt;&lt;code&gt;pandas.api.extensions.register_extension_dtype()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에 사용할 dtype입니다. NumPy dtype 또는 &lt;a href=&quot;pandas.api.extensions.register_extension_dtype#pandas.api.extensions.register_extension_dtype&quot;&gt; &lt;code&gt;pandas.api.extensions.register_extension_dtype()&lt;/code&gt; &lt;/a&gt; 사용하여 pandas에 등록 된 확장 유형 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02ea048dc012eb95095f8ab5d95b81d6eb184e13" translate="yes" xml:space="preserve">
          <source>The dtype to use for the resulting NumPy array. By default, the dtype is inferred from the data.</source>
          <target state="translated">결과 NumPy 배열에 사용할 dtype입니다. 기본적으로 dtype은 데이터에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="6033055f888ffc49ce021fe4ea924eeb6a1ca8fc" translate="yes" xml:space="preserve">
          <source>The dtype will be a lower-common-denominator dtype (implicit upcasting); that is to say if the dtypes (even of numeric types) are mixed, the one that accommodates all will be chosen. Use this with care if you are not dealing with the blocks.</source>
          <target state="translated">dtype은 하위 공통 분모 dtype (암시 적 업 캐스팅)입니다. 즉, dtypes (숫자 유형의 경우에도)가 혼합되어 있으면 모두를 수용하는 것이 선택됩니다. 블록을 다루지 않으면 조심해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e4aa7d097e60914e63897751105b93d3c2677d31" translate="yes" xml:space="preserve">
          <source>The dtype will be based on the type of the Index values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c13bbf31ea8747d061e25366430476499754944" translate="yes" xml:space="preserve">
          <source>The dtype will be the lowest-common-denominator type (implicit upcasting); that is to say if the dtypes (even of numeric types) are mixed, the one that accommodates all will be chosen.</source>
          <target state="translated">dtype은 최저 공통 분모 유형이됩니다 (암시 적 업 캐스팅). 즉, dtypes (숫자 유형의 경우에도)가 혼합되어 있으면 모두를 수용하는 것이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="402e9b51868b17efec48f2c06546f86e2dff706d" translate="yes" xml:space="preserve">
          <source>The earliest supported pytest version is 4.0.2.</source>
          <target state="translated">가장 초기에 지원되는 pytest 버전은 4.0.2입니다.</target>
        </trans-unit>
        <trans-unit id="0bb0f16c4fefb50922eb2b1990a8580cecff19f2" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with:</source>
          <target state="translated">가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f0ad6e9cac2ca0b5372b00d829b0b91de65b0fa" translate="yes" xml:space="preserve">
          <source>The easiest way to install pandas is to install it as part of the &lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;Anaconda&lt;/a&gt; distribution, a cross platform distribution for data analysis and scientific computing. This is the recommended installation method for most users.</source>
          <target state="translated">팬더를 설치하는 가장 쉬운 방법 은 데이터 분석 및 과학 컴퓨팅을위한 크로스 플랫폼 배포판 인 &lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;Anaconda&lt;/a&gt; 배포판의 일부로 팬더를 설치하는 것 입니다. 대부분의 사용자에게 권장되는 설치 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b650319adfe1ed32a1f1377b197e48496b603f37" translate="yes" xml:space="preserve">
          <source>The element may be a sequence (such as a string, tuple or list) or a collection (such as a dictionary).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f4268709553dbe6c53fb03dc8b7831bab1250c" translate="yes" xml:space="preserve">
          <source>The elements inside are compared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca593b489a228a66f221e64b1d0f6556b4f93c6" translate="yes" xml:space="preserve">
          <source>The elements inside the Index object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d9c7e68a4be8ac43994ec948a0e91a3a55e18b" translate="yes" xml:space="preserve">
          <source>The encoding is optional, and if not present is UTF-8</source>
          <target state="translated">인코딩은 선택 사항이며 존재하지 않는 경우 UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="db57f3fbdbb4b27ae5e007ca3b428007e12954fd" translate="yes" xml:space="preserve">
          <source>The encoding to use to decode py3 bytes.</source>
          <target state="translated">py3 바이트를 디코딩하는 데 사용되는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="ff0ef74d1b7270d348ed7ec1b2a914da574e4151" translate="yes" xml:space="preserve">
          <source>The encoding used to decode the web page. Defaults to &lt;code&gt;None&lt;/code&gt;.``None`` preserves the previous encoding behavior, which depends on the underlying parser library (e.g., the parser library will try to use the encoding provided by the document).</source>
          <target state="translated">웹 페이지를 디코딩하는 데 사용되는 인코딩입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; .``None``는 기본 파서 라이브러리에 따라 이전 인코딩 동작을 유지 (예를 들어, 파서 라이브러리 문서에서 제공하는 인코딩을 사용하려고합니다).</target>
        </trans-unit>
        <trans-unit id="c569790c9082bb2392651e09844c4c9544b0ea85" translate="yes" xml:space="preserve">
          <source>The engine to use as a default for parquet reading and writing. If None then try &amp;lsquo;pyarrow&amp;rsquo; and &amp;lsquo;fastparquet&amp;rsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424f85d5be8114e5f2c73b85d3deae13c2984340" translate="yes" xml:space="preserve">
          <source>The engine used to evaluate the expression. Supported engines are</source>
          <target state="translated">식을 평가하는 데 사용 된 엔진. 지원되는 엔진은</target>
        </trans-unit>
        <trans-unit id="147dc2ef722dcc0c3cbc3225c04f0561a3472271" translate="yes" xml:space="preserve">
          <source>The engine will JIT the for loop where the apply function is applied to each window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026424f27c591f64e9ae53ca01390954a08e4f1d" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;code&gt;re&lt;/code&gt; function to all non-overlapping matches of pattern or regular expression in string, as a list of strings.</source>
          <target state="translated">등가 &lt;code&gt;re&lt;/code&gt; 스트링의 목록과 같은 패턴 또는 문자열 정규식 모두 겹치지 일치하는 기능.</target>
        </trans-unit>
        <trans-unit id="8898ad52e811654e2e3423b1a572244bf0b28e08" translate="yes" xml:space="preserve">
          <source>The equivalent in standard Python would be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cca18a7b50ea3cff102bf5cc96e6beeeadd235c" translate="yes" xml:space="preserve">
          <source>The equivalent pandas operations are shown below. In addition to these functions pandas supports other Time Series features not available in Base SAS (such as resampling and custom offsets) - see the &lt;a href=&quot;../../user_guide/timeseries#timeseries&quot;&gt;timeseries documentation&lt;/a&gt; for more details.</source>
          <target state="translated">해당 팬더 조작은 다음과 같습니다. 팬더는 이러한 기능 외에도 기본 SAS에서 사용할 수없는 다른 시계열 기능 (예 : 리샘플링 및 사용자 지정 오프셋)을 지원 합니다. 자세한 내용 은 &lt;a href=&quot;../../user_guide/timeseries#timeseries&quot;&gt;시계열 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="909b95a2338903f93c09ad033d48e2e6e9142b94" translate="yes" xml:space="preserve">
          <source>The equivalent pandas operations are shown below. In addition to these functions, pandas supports other Time Series features not available in Stata (such as time zone handling and custom offsets) &amp;ndash; see the &lt;a href=&quot;../../user_guide/timeseries#timeseries&quot;&gt;timeseries documentation&lt;/a&gt; for more details.</source>
          <target state="translated">해당 팬더 조작은 다음과 같습니다. 이 기능 외에도 팬더는 Stata에서 제공하지 않는 다른 시계열 기능 (예 : 시간대 처리 및 사용자 지정 오프셋)을 지원 합니다. 자세한 내용 은 &lt;a href=&quot;../../user_guide/timeseries#timeseries&quot;&gt;시계열 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="caa3d37f1d4f94d55650bec4344fd8fd6efd4893" translate="yes" xml:space="preserve">
          <source>The example below will apply the &lt;code&gt;rolling()&lt;/code&gt; method on the samples of the column B based on the groups of column A.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6311c7dde7baa968bb7c8743e9441d9babb2e9d" translate="yes" xml:space="preserve">
          <source>The example below will show a rolling calculation with a window size of four matching the equivalent function call using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="762c00e158f42e7f982d68b65ca7ff4693d06ee8" translate="yes" xml:space="preserve">
          <source>The example below will show a rolling calculation with a window size of four matching the equivalent function call using &lt;code&gt;scipy.stats&lt;/code&gt;.</source>
          <target state="translated">아래 예제는 &lt;code&gt;scipy.stats&lt;/code&gt; 를 사용하여 동등한 함수 호출과 일치하는 창 크기가 4 인 롤링 계산을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ae186f1cbcd220a88d9af058acd6c813227f6c27" translate="yes" xml:space="preserve">
          <source>The example below will show an expanding calculation with a window size of four matching the equivalent function call using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329bff10d2656acb920b02e499aad4d54df51037" translate="yes" xml:space="preserve">
          <source>The example below will show an expanding calculation with a window size of four matching the equivalent function call using &lt;code&gt;scipy.stats&lt;/code&gt;.</source>
          <target state="translated">아래 예제는 &lt;code&gt;scipy.stats&lt;/code&gt; 를 사용하여 동등한 함수 호출과 일치하는 창 크기가 4 인 확장 계산을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="45e5437c4b6f31cb966fcd38b40b6e3b2a6d323a" translate="yes" xml:space="preserve">
          <source>The examples above show storing using &lt;code&gt;put&lt;/code&gt;, which write the HDF5 to &lt;code&gt;PyTables&lt;/code&gt; in a fixed array format, called the &lt;code&gt;fixed&lt;/code&gt; format. These types of stores are &lt;strong&gt;not&lt;/strong&gt; appendable once written (though you can simply remove them and rewrite). Nor are they &lt;strong&gt;queryable&lt;/strong&gt;; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The &lt;code&gt;fixed&lt;/code&gt; format stores offer very fast writing and slightly faster reading than &lt;code&gt;table&lt;/code&gt; stores. This format is specified by default when using &lt;code&gt;put&lt;/code&gt; or &lt;code&gt;to_hdf&lt;/code&gt; or by &lt;code&gt;format='fixed'&lt;/code&gt; or &lt;code&gt;format='f'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587a9a62e057904337faca887667080313d4abe6" translate="yes" xml:space="preserve">
          <source>The examples in the docstring (&amp;lsquo;doctests&amp;rsquo;) must be valid Python code, that in a deterministic way returns the presented output, and that can be copied and run by users. This can be checked with the script above, and is also tested on Travis. A failing doctest will be a blocker for merging a PR. Check the &lt;a href=&quot;contributing_docstring#docstring-examples&quot;&gt;examples&lt;/a&gt; section in the docstring guide for some tips and tricks to get the doctests passing.</source>
          <target state="translated">docstring의 예제 ( 'doctests')는 유효한 파이썬 코드 여야하며 결정적인 방식으로 제시된 출력을 리턴하며 사용자가 복사하여 실행할 수 있습니다. 이것은 위의 스크립트로 확인할 수 있으며 Travis에서도 테스트되었습니다. 실패한 doctest는 PR 병합을위한 차단제가 될 것입니다. docstring 안내서 의 &lt;a href=&quot;contributing_docstring#docstring-examples&quot;&gt;예제&lt;/a&gt; 섹션에서 doctest를 통과시키는 몇 가지 팁과 요령을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1aa239efa3bb9c50d52785b92c6e393285c774b8" translate="yes" xml:space="preserve">
          <source>The examples should be as concise as possible. In cases where the complexity of the function requires long examples, is recommended to use blocks with headers in bold. Use double star &lt;code&gt;**&lt;/code&gt; to make a text bold, like in &lt;code&gt;**this example**&lt;/code&gt;.</source>
          <target state="translated">예는 가능한 한 간결해야합니다. 함수의 복잡성에 긴 예제가 필요한 경우 굵은 글씨로 된 블록을 사용하는 것이 좋습니다. &lt;code&gt;**this example**&lt;/code&gt; 와 같이 이중 별표 &lt;code&gt;**&lt;/code&gt; 를 사용하여 텍스트를 굵게 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5faee4e82814f88550e50e28de4301f3fc10466" translate="yes" xml:space="preserve">
          <source>The existing interface &lt;code&gt;DataFrame.boxplot&lt;/code&gt; to plot boxplot still can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88da40f5219334609e93cf1aa5d6a14e48582fe2" translate="yes" xml:space="preserve">
          <source>The existing interface &lt;code&gt;DataFrame.hist&lt;/code&gt; to plot histogram still can be used.</source>
          <target state="translated">히스토그램을 플롯하기 위한 기존 인터페이스 &lt;code&gt;DataFrame.hist&lt;/code&gt; 를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a2342a38bccf11c8abb08a1819a87deccf8cd5f" translate="yes" xml:space="preserve">
          <source>The expanding count of any non-NaN observations inside the window.</source>
          <target state="translated">창 내부의 비 NaN 관측치의 확장 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="6b32a0ed467b4a9f8e2f67e863af9abfbaf3e912" translate="yes" xml:space="preserve">
          <source>The expanding function&amp;rsquo;s apply function.</source>
          <target state="translated">확장 기능의 적용 기능.</target>
        </trans-unit>
        <trans-unit id="02e744e9642d17219b2c910b06c32657e8b5a055" translate="yes" xml:space="preserve">
          <source>The expectation is that this is cheap to compute, and is primarily used for interacting with our indexers.</source>
          <target state="translated">이것은 계산하기에 저렴하며 주로 인덱서와 상호 작용하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5bdba721808815dbebc8ea526518e9c3f52cff5" translate="yes" xml:space="preserve">
          <source>The expression is multiline, but not all them have item assignment. An example of such an arrangement is this:</source>
          <target state="translated">표현식은 여러 줄이지 만 모든 항목에 항목이 할당 된 것은 아닙니다. 그러한 배치의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="101e1eea0b49b333be0d7d368f0b89b605bfccb1" translate="yes" xml:space="preserve">
          <source>The expression string to evaluate.</source>
          <target state="translated">평가할 표현식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c0aae65ec71dd7be215782f754fd2bbc1b2542d6" translate="yes" xml:space="preserve">
          <source>The expression to evaluate. This string cannot contain any Python &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#simple-statements&quot;&gt;statements&lt;/a&gt;, only Python &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#expression-statements&quot;&gt;expressions&lt;/a&gt;.</source>
          <target state="translated">평가할 표현식입니다. 이 문자열에는 Python &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#simple-statements&quot;&gt;문만&lt;/a&gt; 포함 할 수 없으며 Python &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#expression-statements&quot;&gt;식만&lt;/a&gt; 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="558df34336f39c16d87f38320c19b5b9f32306f7" translate="yes" xml:space="preserve">
          <source>The extended summary provides details on what the function does. It should not go into the details of the parameters, or discuss implementation notes, which go in other sections.</source>
          <target state="translated">확장 요약은 기능이 수행하는 작업에 대한 세부 사항을 제공합니다. 매개 변수의 세부 사항으로 들어가거나 다른 섹션에있는 구현 참고 사항을 논의해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="807e1cb761a84abbb752537840c6bb9987d2f3b2" translate="yes" xml:space="preserve">
          <source>The extended summary should provide details on why the function is useful and their use cases, if it is not too generic.</source>
          <target state="translated">확장 된 요약은 함수가 유용한 이유 및 사용 사례가 너무 일반적이지 않은 경우에 대한 세부 사항을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4654310579c98deafd6716d45522cddf3bd3360a" translate="yes" xml:space="preserve">
          <source>The field names of the first &lt;code&gt;namedtuple&lt;/code&gt; in the list determine the columns of the &lt;code&gt;DataFrame&lt;/code&gt;. The remaining namedtuples (or tuples) are simply unpacked and their values are fed into the rows of the &lt;code&gt;DataFrame&lt;/code&gt;. If any of those tuples is shorter than the first &lt;code&gt;namedtuple&lt;/code&gt; then the later columns in the corresponding row are marked as missing values. If any are longer than the first &lt;code&gt;namedtuple&lt;/code&gt;, a &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04933d90d214ab309930e41f4edfdfdc733cc857" translate="yes" xml:space="preserve">
          <source>The file can be read using the file name as string or an open file object:</source>
          <target state="translated">파일 이름을 문자열 또는 열린 파일 객체로 사용하여 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc231e608cc0633b5668cc8bf5593b18de2181cb" translate="yes" xml:space="preserve">
          <source>The files &lt;code&gt;test.pkl.compress&lt;/code&gt;, &lt;code&gt;test.parquet&lt;/code&gt; and &lt;code&gt;test.feather&lt;/code&gt; took the least space on disk (in bytes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c29dd765ea137d3dc7140e87e273412157a076c" translate="yes" xml:space="preserve">
          <source>The fill value is potentially specified in three ways. In order of precedence, these are</source>
          <target state="translated">채우기 값은 세 가지 방법으로 지정 될 수 있습니다. 우선 순위에 따라</target>
        </trans-unit>
        <trans-unit id="95722d1fb8d2a0701797550a2d84789cc28d3ca5" translate="yes" xml:space="preserve">
          <source>The final step required is to install pandas. This can be done with the following command:</source>
          <target state="translated">필요한 마지막 단계는 팬더를 설치하는 것입니다. 다음 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="957dc77c438abefa8c77eaf7563108a790ce4d94" translate="yes" xml:space="preserve">
          <source>The first</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bd7c869ab9197b160461618d612bb6b14e967c" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;n&lt;/code&gt; rows of the caller object.</source>
          <target state="translated">호출자 객체 의 첫 &lt;code&gt;n&lt;/code&gt; 행.</target>
        </trans-unit>
        <trans-unit id="00c7aa608513ba45af36ee3f7cdd9b2429f03fd4" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;n&lt;/code&gt; rows ordered by the given columns in descending order.</source>
          <target state="translated">주어진 열을 기준으로 내림차순으로 정렬 된 첫 &lt;code&gt;n&lt;/code&gt; 행.</target>
        </trans-unit>
        <trans-unit id="8d0d8b7e44cf75418e8555e294df31cf37de9b76" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../reference/api/pandas.series.str.cat#pandas.Series.str.cat&quot;&gt;&lt;code&gt;cat()&lt;/code&gt;&lt;/a&gt; can be a list-like object, provided that it matches the length of the calling &lt;code&gt;Series&lt;/code&gt; (or &lt;code&gt;Index&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47c9bad9a0d50e16efb914a6f0b10aec458889a" translate="yes" xml:space="preserve">
          <source>The first calling convention will only modify the names of the index and/or the names of the Index object that is the columns. In this case, the parameter &lt;code&gt;copy&lt;/code&gt; is ignored.</source>
          <target state="translated">첫 번째 호출 규칙은 인덱스 이름 및 / 또는 열인 Index 개체의 이름 만 수정합니다. 이 경우 매개 변수 &lt;code&gt;copy&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="779a2b640512545f25945cac2a8661ad6babf108" translate="yes" xml:space="preserve">
          <source>The first conventions every Python docstring should follow are defined in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0257/&quot;&gt;PEP-257&lt;/a&gt;.</source>
          <target state="translated">모든 파이썬 docstring이 따라야 할 첫 번째 규칙은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0257/&quot;&gt;PEP-257에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9314c9bffbf2dd99ccd9114dcf5744aabcbbe8" translate="yes" xml:space="preserve">
          <source>The first element of %(klass)s.</source>
          <target state="translated">% (klass) s의 첫 번째 요소</target>
        </trans-unit>
        <trans-unit id="29278a8b619c88bc62033e996de5fc561a3ccbd2" translate="yes" xml:space="preserve">
          <source>The first parameter controls which level or levels are stacked:</source>
          <target state="translated">첫 번째 매개 변수는 쌓이는 레벨을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="6f9781f90d582a93f78605c8d0d7b934e5a8d289" translate="yes" xml:space="preserve">
          <source>The first stop for pandas issues and ideas is the &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;Github Issue Tracker&lt;/a&gt;. If you have a general question, pandas community experts can answer through &lt;a href=&quot;https://stackoverflow.com/questions/tagged/pandas&quot;&gt;Stack Overflow&lt;/a&gt;.</source>
          <target state="translated">팬더 이슈와 아이디어를위한 첫 번째 장소는 &lt;a href=&quot;https://github.com/pandas-dev/pandas/issues&quot;&gt;Github 이슈 트래커&lt;/a&gt; 입니다. 일반적인 질문이있는 경우 팬더 커뮤니티 전문가가 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/pandas&quot;&gt;Stack Overflow를&lt;/a&gt; 통해 답변을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a078fd004b71d4a005de8f56fbf891bf67bbd92" translate="yes" xml:space="preserve">
          <source>The first time you build the docs, it will take quite a while because it has to run all the code examples and build all the generated docstring pages. In subsequent evocations, sphinx will try to only build the pages that have been modified.</source>
          <target state="translated">처음으로 문서를 작성할 때는 모든 코드 예제를 실행하고 생성 된 모든 docstring 페이지를 빌드해야하므로 시간이 오래 걸립니다. 후속 호출에서 스핑크스는 수정 된 페이지 만 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ce52aec2aff5d463ae59e14588dc17c6431070ed" translate="yes" xml:space="preserve">
          <source>The fiscal year of the period.</source>
          <target state="translated">해당 기간의 회계 연도입니다.</target>
        </trans-unit>
        <trans-unit id="2513bb910f64f1ecc4e155068410a00b32a5716d" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;numpy.unique&lt;/code&gt; will fail under Python 3 with a &lt;code&gt;TypeError&lt;/code&gt; because of an ordering bug. See also &lt;a href=&quot;https://github.com/numpy/numpy/issues/641&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36b3200f2a94de03b608386d79c46f26d1143bf" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;can&lt;/em&gt; work at times, but it is not guaranteed to, and therefore should be avoided:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6454638366bf09df88785d3ab73be788bd14b4" translate="yes" xml:space="preserve">
          <source>The following are valid expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7032dfe99bbe1c7f8f414fc8f35f2d0c54a6e413" translate="yes" xml:space="preserve">
          <source>The following arithmetic operations are supported: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt; (python engine only) along with the following boolean operations: &lt;code&gt;|&lt;/code&gt; (or), &lt;code&gt;&amp;amp;&lt;/code&gt; (and), and &lt;code&gt;~&lt;/code&gt; (not). Additionally, the &lt;code&gt;'pandas'&lt;/code&gt; parser allows the use of &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#and&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#or&quot;&gt;&lt;code&gt;or&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not&quot;&gt;&lt;code&gt;not&lt;/code&gt;&lt;/a&gt; with the same semantics as the corresponding bitwise operators. &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; objects are supported and behave as they would with plain ol&amp;rsquo; Python evaluation.</source>
          <target state="translated">다음과 같은 산술 연산이 지원됩니다. &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; (파이썬 엔진 만 해당) 및 다음 부울 연산 : &lt;code&gt;|&lt;/code&gt; (또는), &lt;code&gt;&amp;amp;&lt;/code&gt; (and) 및 &lt;code&gt;~&lt;/code&gt; (not)입니다. 또한, &lt;code&gt;'pandas'&lt;/code&gt; 파서의 사용을 허용 &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#and&quot;&gt; &lt;code&gt;and&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#or&quot;&gt; &lt;code&gt;or&lt;/code&gt; &lt;/a&gt; ,과 &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not&quot;&gt; &lt;code&gt;not&lt;/code&gt; &lt;/a&gt; 대응 비트 연산자와 동일한 의미로한다. &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 객체는 일반 Python 평가에서와 같이 지원되고 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc30c65333c271955e6d6bc0e44232514dee9832" translate="yes" xml:space="preserve">
          <source>The following attributes and methods influence the behavior of the dtype in pandas operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0062ecb43b3cfa305fca5641333b41553178ebc" translate="yes" xml:space="preserve">
          <source>The following attributes influence the behavior of the dtype in pandas operations</source>
          <target state="translated">다음 속성은 팬더 조작에서 dtype의 동작에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="6601f74b97be707651a5acd1f1378b954b1e39bc" translate="yes" xml:space="preserve">
          <source>The following data feeds are available:</source>
          <target state="translated">다음과 같은 데이터 피드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cef8c1f15945c2dc0fe193b45c515a3e1f3136f" translate="yes" xml:space="preserve">
          <source>The following defines how a commit message should be structured. Please reference the relevant GitHub issues in your commit message using GH1234 or #1234. Either style is fine, but the former is generally preferred:</source>
          <target state="translated">다음은 커밋 메시지를 구성하는 방법을 정의합니다. GH1234 또는 # 1234를 사용하여 커밋 메시지에서 관련 GitHub 문제를 참조하십시오. 어느 스타일이든 괜찮지 만 전자가 일반적으로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="f74fa4dbe5820cd80d4bc35530b432e594cd481d" translate="yes" xml:space="preserve">
          <source>The following differences to R&amp;rsquo;s factor functions can be observed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a03e9488990819bd5ae0b54d4c51731730d9ddd0" translate="yes" xml:space="preserve">
          <source>The following example aims to give a highlight of the behavior of the new align options:</source>
          <target state="translated">다음 예제는 새로운 정렬 옵션의 동작을 강조 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="187ed70d6b20ed60d1f249f9e865f562c6b3488e" translate="yes" xml:space="preserve">
          <source>The following example groups &lt;code&gt;df&lt;/code&gt; by the &lt;code&gt;second&lt;/code&gt; index level and the &lt;code&gt;A&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b7594ffcb2281c06a127b4176c59b4f5b0433d" translate="yes" xml:space="preserve">
          <source>The following example shows how the method behaves with the above parameters:</source>
          <target state="translated">다음 예제는 메소드가 위의 매개 변수로 작동하는 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b75ab12ec0f0a50840334286859cdb21e807d00b" translate="yes" xml:space="preserve">
          <source>The following example shows the populations for some animals over the years.</source>
          <target state="translated">다음 예는 몇 년 동안 일부 동물의 인구를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2520eebde8aaa316871d7ad4e41e7a6b820b1640" translate="yes" xml:space="preserve">
          <source>The following example shows the relationship between both populations.</source>
          <target state="translated">다음 예는 두 모집단 간의 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fece5f2121f168ba82ac1e775fd1e283c02a0d3b" translate="yes" xml:space="preserve">
          <source>The following examples are generated with random data from a normal distribution.</source>
          <target state="translated">다음 예는 정규 분포의 랜덤 데이터로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="abdf1caf2165a0287edbd7d01f0b65bd220c02d2" translate="yes" xml:space="preserve">
          <source>The following examples are not run by the IPython evaluator due to the fact that having so many network-accessing functions slows down the documentation build. If you spot an error or an example that doesn&amp;rsquo;t run, please do not hesitate to report it over on &lt;a href=&quot;https://www.github.com/pandas-dev/pandas/issues&quot;&gt;pandas GitHub issues page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f79bc6e8315970938cef67aeee80489dee77616" translate="yes" xml:space="preserve">
          <source>The following formula is used to compute exponentially weighted mean with an input vector of times:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e5348e260475d15b7a537ae363e1fdd455a1b4" translate="yes" xml:space="preserve">
          <source>The following functions are available for one dimensional object arrays or scalars to perform hard conversion of objects to a specified type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687aa7699cc4e28054e99e5f501bba469edaf71a" translate="yes" xml:space="preserve">
          <source>The following functions are contained in the &lt;code&gt;pandas.plotting&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;pandas.plotting&lt;/code&gt; 모듈 에는 다음 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0543d6d52b0c31f007d1bbde23bd57aca5cb0454" translate="yes" xml:space="preserve">
          <source>The following is a walk-through of the more frequently used display options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5476c7d4994608eaad843c46ed06053c7ecacb79" translate="yes" xml:space="preserve">
          <source>The following is the recommended access method using &lt;code&gt;.loc&lt;/code&gt; for multiple items (using &lt;code&gt;mask&lt;/code&gt;) and a single item using a fixed index:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faaa2feec4dd9e1f0ff47108b7da498e64ffde68" translate="yes" xml:space="preserve">
          <source>The following methods are available in both &lt;code&gt;SeriesGroupBy&lt;/code&gt; and &lt;code&gt;DataFrameGroupBy&lt;/code&gt; objects, but may differ slightly, usually in that the &lt;code&gt;DataFrameGroupBy&lt;/code&gt; version usually permits the specification of an axis argument, and often an argument indicating whether to restrict application to columns of a specific data type.</source>
          <target state="translated">다음 메소드는 &lt;code&gt;SeriesGroupBy&lt;/code&gt; 및 &lt;code&gt;DataFrameGroupBy&lt;/code&gt; 오브젝트 모두에서 사용 가능 하지만 &lt;code&gt;DataFrameGroupBy&lt;/code&gt; 버전은 일반적으로 축 인수 지정을 허용하고 종종 특정 데이터 유형의 열로 애플리케이션을 제한할지 여부를 나타내는 인수에서 허용되므로 약간 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47fffb253b4aaeb6acea14045c4996a29875275c" translate="yes" xml:space="preserve">
          <source>The following methods are available only for &lt;code&gt;DataFrameGroupBy&lt;/code&gt; objects.</source>
          <target state="translated">다음 메소드는 &lt;code&gt;DataFrameGroupBy&lt;/code&gt; 오브젝트 에만 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="0903a8cb8025a1c959967330557f9a473e10f8a4" translate="yes" xml:space="preserve">
          <source>The following methods are available only for &lt;code&gt;SeriesGroupBy&lt;/code&gt; objects.</source>
          <target state="translated">다음 메소드는 &lt;code&gt;SeriesGroupBy&lt;/code&gt; 오브젝트 에만 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5ffe8149cda0851680e06a560efc5c8ccdb2df81" translate="yes" xml:space="preserve">
          <source>The following pseudo CSS properties are also available to set excel specific style properties:</source>
          <target state="translated">다음과 같은 의사 CSS 속성을 사용하여 Excel 특정 스타일 속성을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d6a1914a206045647d3529adff7d8b882b8c917" translate="yes" xml:space="preserve">
          <source>The following table lists all of pandas extension types. For methods requiring &lt;code&gt;dtype&lt;/code&gt; arguments, strings can be specified as indicated. See the respective documentation sections for more on each type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bea3b09e1c8966eedbe5441e0860b6df7be600c" translate="yes" xml:space="preserve">
          <source>The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e537a7bbc860a12bf99f3833000d5d900df0aefc" translate="yes" xml:space="preserve">
          <source>The following table summarizes the results of merging &lt;code&gt;Categoricals&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0df33443ffeaa2db43cf4ea6a7db639284dff61" translate="yes" xml:space="preserve">
          <source>The following test functions will be used below to compare the performance of several IO methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8aa6e01797f7df97d025b6c6a59c54f2b6b5469" translate="yes" xml:space="preserve">
          <source>The following will &lt;strong&gt;not work&lt;/strong&gt; because it matches multiple option names, e.g. &lt;code&gt;display.max_colwidth&lt;/code&gt;, &lt;code&gt;display.max_rows&lt;/code&gt;, &lt;code&gt;display.max_columns&lt;/code&gt;:</source>
          <target state="translated">다음은 여러 옵션 이름과 일치하므로 &lt;strong&gt;작동하지 않습니다 (&lt;/strong&gt; 예 : &lt;code&gt;display.max_colwidth&lt;/code&gt; , &lt;code&gt;display.max_rows&lt;/code&gt; , &lt;code&gt;display.max_columns&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="e8bd108ab633267cf55a00790d8cf9ecfbe4e1a3" translate="yes" xml:space="preserve">
          <source>The following, while not recommended methods for generating DataFrames, show two ways to generate a DataFrame from multiple data sources.</source>
          <target state="translated">다음은 DataFrame 생성을위한 권장 방법은 아니지만 여러 데이터 소스에서 DataFrame을 생성하는 두 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="138e170da5c426d60332c6449e5ce83e935b8ded" translate="yes" xml:space="preserve">
          <source>The format of the JSON string</source>
          <target state="translated">JSON 문자열의 형식</target>
        </trans-unit>
        <trans-unit id="4e9c19173417a1cdddd3d41add25a52bc97392fc" translate="yes" xml:space="preserve">
          <source>The format of the JSON string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af3b5b13b432fd75bd2221a806f9ee0cd60a5ae" translate="yes" xml:space="preserve">
          <source>The format used to represent date-like values</source>
          <target state="translated">날짜와 같은 값을 나타내는 데 사용되는 형식</target>
        </trans-unit>
        <trans-unit id="c1a7302d2538143927226fbc361598a2b06b5edf" translate="yes" xml:space="preserve">
          <source>The format used to represent date-like values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54074a31a2d51bf3a08ee1f6079ebd827c1523d3" translate="yes" xml:space="preserve">
          <source>The format will NOT write an &lt;code&gt;Index&lt;/code&gt;, or &lt;code&gt;MultiIndex&lt;/code&gt; for the &lt;code&gt;DataFrame&lt;/code&gt; and will raise an error if a non-default one is provided. You can &lt;code&gt;.reset_index()&lt;/code&gt; to store the index or &lt;code&gt;.reset_index(drop=True)&lt;/code&gt; to ignore it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1aa7f259f576c08abf9b9c79f7b4063d7b0d3f" translate="yes" xml:space="preserve">
          <source>The found values</source>
          <target state="translated">발견 된 값</target>
        </trans-unit>
        <trans-unit id="aa04a17ec91bdd0026d7b56b8ee4083d15a2e245" translate="yes" xml:space="preserve">
          <source>The found values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe1aff200bf29f7034eb0886628017c034090de" translate="yes" xml:space="preserve">
          <source>The frequency level to ceil the index to. Must be a fixed frequency like &amp;lsquo;S&amp;rsquo; (second) not &amp;lsquo;ME&amp;rsquo; (month end). See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;frequency aliases&lt;/a&gt; for a list of possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0e4ba98c3158e3606f5527ed8083a30732806c" translate="yes" xml:space="preserve">
          <source>The frequency level to ceil the index to. Must be a fixed frequency like &amp;lsquo;S&amp;rsquo; (second) not &amp;lsquo;ME&amp;rsquo; (month end). See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;frequency aliases&lt;/a&gt; for a list of possible &lt;code&gt;freq&lt;/code&gt; values.</source>
          <target state="translated">인덱스를 중단 할 빈도 수준입니다. 'ME'(월말)가 아닌 'S'(초)와 같은 고정 빈도 여야합니다. 가능한 &lt;code&gt;freq&lt;/code&gt; 값 목록은 &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;주파수 별명&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c42c3941b04224a733e93639eb918795585499c" translate="yes" xml:space="preserve">
          <source>The frequency level to floor the index to. Must be a fixed frequency like &amp;lsquo;S&amp;rsquo; (second) not &amp;lsquo;ME&amp;rsquo; (month end). See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;frequency aliases&lt;/a&gt; for a list of possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d87dcb2bb1749deba7a582bb80a8ba7924f35d" translate="yes" xml:space="preserve">
          <source>The frequency level to floor the index to. Must be a fixed frequency like &amp;lsquo;S&amp;rsquo; (second) not &amp;lsquo;ME&amp;rsquo; (month end). See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;frequency aliases&lt;/a&gt; for a list of possible &lt;code&gt;freq&lt;/code&gt; values.</source>
          <target state="translated">지수를 계산할 빈도 수준입니다. 'ME'(월말)가 아닌 'S'(초)와 같은 고정 빈도 여야합니다. 가능한 &lt;code&gt;freq&lt;/code&gt; 값 목록은 &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;주파수 별명&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4585b4476c056fd6c536003eb297fd3ef4762f0" translate="yes" xml:space="preserve">
          <source>The frequency level to round the index to. Must be a fixed frequency like &amp;lsquo;S&amp;rsquo; (second) not &amp;lsquo;ME&amp;rsquo; (month end). See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;frequency aliases&lt;/a&gt; for a list of possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33f682f2e5e962b5a982acb833a76873c9bf33b" translate="yes" xml:space="preserve">
          <source>The frequency level to round the index to. Must be a fixed frequency like &amp;lsquo;S&amp;rsquo; (second) not &amp;lsquo;ME&amp;rsquo; (month end). See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;frequency aliases&lt;/a&gt; for a list of possible &lt;code&gt;freq&lt;/code&gt; values.</source>
          <target state="translated">인덱스를 반올림 할 빈도 수준입니다. 'ME'(월말)가 아닌 'S'(초)와 같은 고정 빈도 여야합니다. 가능한 &lt;code&gt;freq&lt;/code&gt; 값 목록은 &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;주파수 별명&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37dfbbe311edc5ab1fa0e3eea87add9013d0c913" translate="yes" xml:space="preserve">
          <source>The frequency object of this PeriodDtype.</source>
          <target state="translated">이 PeriodDtype의 빈도 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ab329ae9212f72b063f0bee1451a6cea553d7f37" translate="yes" xml:space="preserve">
          <source>The frequency of &lt;code&gt;Period&lt;/code&gt; and &lt;code&gt;PeriodIndex&lt;/code&gt; can be converted via the &lt;code&gt;asfreq&lt;/code&gt; method. Let&amp;rsquo;s start with the fiscal year 2011, ending in December:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34efcd6f14262e812d82d4f486748c8245af8384" translate="yes" xml:space="preserve">
          <source>The frequency of this PeriodDtype</source>
          <target state="translated">이 PeriodDtype의 빈도</target>
        </trans-unit>
        <trans-unit id="b1ce7fbadbb5696ee11504a1bc5e1d5d3900306b" translate="yes" xml:space="preserve">
          <source>The frequency of this PeriodDtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19a548a9bf09f79e90424b69d43f08cc0c4a583" translate="yes" xml:space="preserve">
          <source>The frequency string &amp;lsquo;C&amp;rsquo; is used to indicate that a CustomBusinessDay DateOffset is used, it is important to note that since CustomBusinessDay is a parameterised type, instances of CustomBusinessDay may differ and this is not detectable from the &amp;lsquo;C&amp;rsquo; frequency string. The user therefore needs to ensure that the &amp;lsquo;C&amp;rsquo; frequency string is used consistently within the user&amp;rsquo;s application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0ed5334b4cb5fdb0661fc9f28ac9a136ca9685" translate="yes" xml:space="preserve">
          <source>The frequency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db91e48f8f6098c5b1c6182933dab6c86b662181" translate="yes" xml:space="preserve">
          <source>The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c309ca26a1e20e7bbca7a0e3439f38bfe29a4d" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/api/pandas.pivot_table#pandas.pivot_table&quot;&gt;&lt;code&gt;pivot_table()&lt;/code&gt;&lt;/a&gt; can be used to create spreadsheet-style pivot tables. See the &lt;a href=&quot;cookbook#cookbook-pivot&quot;&gt;cookbook&lt;/a&gt; for some advanced strategies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d33967348b4a42d85ca1ab7d6df3ac3fbf58ee5" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/api/pandas.read_sql#pandas.read_sql&quot;&gt;&lt;code&gt;read_sql()&lt;/code&gt;&lt;/a&gt; is a convenience wrapper around &lt;a href=&quot;../reference/api/pandas.read_sql_table#pandas.read_sql_table&quot;&gt;&lt;code&gt;read_sql_table()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.read_sql_query#pandas.read_sql_query&quot;&gt;&lt;code&gt;read_sql_query()&lt;/code&gt;&lt;/a&gt; (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75632130c3c856285cecc0b4b5525010239f00a" translate="yes" xml:space="preserve">
          <source>The function is named by analogy with a collection of books being reorganized from being side by side on a horizontal position (the columns of the dataframe) to being stacked vertically on top of each other (in the index of the dataframe).</source>
          <target state="translated">이 기능은 수평 위치 (데이터 프레임의 열)에서 나란히 정렬되고 (데이터 프레임의 인덱스에서) 서로 수직으로 쌓 이도록 재구성 된 책 모음과 유사하게 명명됩니다.</target>
        </trans-unit>
        <trans-unit id="197a8a6b46a544f933cfc8f6e213009969d02ef3" translate="yes" xml:space="preserve">
          <source>The function names can also be strings. In order for a string to be valid it must be either implemented on GroupBy or available via &lt;a href=&quot;#groupby-dispatch&quot;&gt;dispatching&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d6d43783f9418d069b18f18e2dce8215f5366d" translate="yes" xml:space="preserve">
          <source>The function names can also be strings. In order for a string to be valid it must be implemented on the resampled object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f20d074489a3eb40ef8ed0314978204abd1561c" translate="yes" xml:space="preserve">
          <source>The function passed to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8976b7a90b34a2f85d49407412f19a0a3a04b2c" translate="yes" xml:space="preserve">
          <source>The function passed to &lt;code&gt;apply&lt;/code&gt; must take a dataframe as its first argument and return a DataFrame, Series or scalar. &lt;code&gt;apply&lt;/code&gt; will then take care of combining the results back together into a single dataframe or series. &lt;code&gt;apply&lt;/code&gt; is therefore a highly flexible grouping method.</source>
          <target state="translated">&lt;code&gt;apply&lt;/code&gt; 하기 위해 전달 된 함수 는 첫 번째 인수로 데이터 프레임을 가져 와서 DataFrame, Series 또는 스칼라를 반환해야합니다. &lt;code&gt;apply&lt;/code&gt; 는 결과를 다시 단일 데이터 프레임 또는 시리즈로 결합하는 작업을 처리합니다. 따라서 &lt;code&gt;apply&lt;/code&gt; 는 매우 유연한 그룹화 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e53bec5c5f213a397ae330f0acc85fd6c81a0532" translate="yes" xml:space="preserve">
          <source>The function signature for &lt;code&gt;assign&lt;/code&gt; is simply &lt;code&gt;**kwargs&lt;/code&gt;. The keys are the column names for the new fields, and the values are either a value to be inserted (for example, a &lt;code&gt;Series&lt;/code&gt; or NumPy array), or a function of one argument to be called on the &lt;code&gt;DataFrame&lt;/code&gt;. A &lt;em&gt;copy&lt;/em&gt; of the original DataFrame is returned, with the new values inserted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3e9a9917c8fa12660a673dbf47adb117aec2c5" translate="yes" xml:space="preserve">
          <source>The function signature must start with &lt;code&gt;values, index&lt;/code&gt;&lt;strong&gt;exactly&lt;/strong&gt; as the data belonging to each group will be passed into &lt;code&gt;values&lt;/code&gt;, and the group index will be passed into &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b69b3c0102590605bd7e8e837d4b1e093e1d1ea" translate="yes" xml:space="preserve">
          <source>The get_loc method for (single-level) index.</source>
          <target state="translated">(단일 레벨) 인덱스에 대한 get_loc 메소드.</target>
        </trans-unit>
        <trans-unit id="f2dc645af25d04f27ad234f140fa8f84d104caf1" translate="yes" xml:space="preserve">
          <source>The goal of &lt;code&gt;pd.NA&lt;/code&gt; is provide a &amp;ldquo;missing&amp;rdquo; indicator that can be used consistently across data types (instead of &lt;code&gt;np.nan&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;pd.NaT&lt;/code&gt; depending on the data type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d8aafaea3c3d69409a22c423740c84afb9df16" translate="yes" xml:space="preserve">
          <source>The goal of this 2015 cookbook (by &lt;a href=&quot;http://jvns.ca&quot;&gt;Julia Evans&lt;/a&gt;) is to give you some concrete examples for getting started with pandas. These are examples with real-world data, and all the bugs and weirdness that entails. For the table of contents, see the &lt;a href=&quot;http://github.com/jvns/pandas-cookbook&quot;&gt;pandas-cookbook GitHub repository&lt;/a&gt;.</source>
          <target state="translated">2015 년 요리 책 ( &lt;a href=&quot;http://jvns.ca&quot;&gt;줄리아 에반스&lt;/a&gt; ( Julia Evans )) 의 목표는 팬더를 시작하기위한 구체적인 예를 제공하는 것입니다. 이들은 실제 데이터와 관련된 모든 버그와 기묘한 예입니다. 목차는 &lt;a href=&quot;http://github.com/jvns/pandas-cookbook&quot;&gt;pandas-cookbook GitHub 리포지토리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19332c0506dbe50b87c4f31bdc88435bd2d3123e" translate="yes" xml:space="preserve">
          <source>The governance process that pandas project has used informally since its inception in 2008 is formalized in &lt;a href=&quot;https://github.com/pandas-dev/pandas-governance&quot;&gt;Project Governance documents&lt;/a&gt;. The documents clarify how decisions are made and how the various elements of our community interact, including the relationship between open source collaborative development and work that may be funded by for-profit or non-profit entities.</source>
          <target state="translated">판다 프로젝트가 2008 년에 시작된 이래 비공식적으로 사용 된 거버넌스 프로세스는 &lt;a href=&quot;https://github.com/pandas-dev/pandas-governance&quot;&gt;프로젝트 거버넌스 문서에&lt;/a&gt; 공식화되어있다 . 이 문서는 오픈 소스 협업 개발과 영리 또는 비영리 단체가 자금을 제공 할 수있는 업무 간의 관계를 포함하여 의사 결정 방법과 커뮤니티의 다양한 요소가 상호 작용하는 방식을 명확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="232a69f69639ba586fe33201064da64251d4167a" translate="yes" xml:space="preserve">
          <source>The group identifier in the store. Can be omitted if the HDF file contains a single pandas object.</source>
          <target state="translated">상점의 그룹 식별자 HDF 파일에 단일 팬더 객체가 포함 된 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec179e92047e88b7d043ca09a259d35af39180b" translate="yes" xml:space="preserve">
          <source>The grouping and aggregation is done out-of-core and in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd03b47b88c4b0e2d1397451516e04cdc145caee" translate="yes" xml:space="preserve">
          <source>The handling of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ad8b2660d1ba73cc19d194aee74c66d6e9d468" translate="yes" xml:space="preserve">
          <source>The handling of the &lt;code&gt;n&lt;/code&gt; keyword depends on the number of found splits:</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 키워드 의 처리는 발견 된 분할 수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5a74ef898a80d4d455e122ed4927689913e11f17" translate="yes" xml:space="preserve">
          <source>The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. &lt;code&gt;[0,1,3]&lt;/code&gt;. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if &lt;code&gt;skip_blank_lines=True&lt;/code&gt;, so header=0 denotes the first line of data rather than the first line of the file.</source>
          <target state="translated">헤더는 열에서 MultiIndex의 행 위치를 지정하는 정수 목록입니다 (예 : &lt;code&gt;[0,1,3]&lt;/code&gt; 0,1,3 ]) . 지정되지 않은 중간 행은 건너 뜁니다 (예 :이 예에서 2는 건너 뜁니다). &lt;code&gt;skip_blank_lines=True&lt;/code&gt; 인 경우이 매개 변수는 주석 처리 된 행과 빈 행을 무시 하므로 header = 0은 파일의 첫 번째 행이 아니라 첫 번째 데이터 행을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01df2f98c70f7b1d95f5303b82e50f4a1564ae5c" translate="yes" xml:space="preserve">
          <source>The horizontal lines in the plot correspond to 95% and 99% confidence bands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f4baf24f68ab228a5a404e9d9cc4d088867fbb" translate="yes" xml:space="preserve">
          <source>The hour as an integer, between 0 and 23.</source>
          <target state="translated">시간은 0에서 23 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e04661026ed56189397ad0d4de8e0deeccdc7124" translate="yes" xml:space="preserve">
          <source>The hour of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db25a06996e277d4bea2b4dac8e1692a6f17ef7" translate="yes" xml:space="preserve">
          <source>The hour of the period</source>
          <target state="translated">기간의 시간</target>
        </trans-unit>
        <trans-unit id="0717e803e2754705ed7c6e278ed551dffef54810" translate="yes" xml:space="preserve">
          <source>The hour of the period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a558f8a93d4938b56e04a424fd7904b0273baeb" translate="yes" xml:space="preserve">
          <source>The hours of the datetime.</source>
          <target state="translated">날짜 시간의 시간</target>
        </trans-unit>
        <trans-unit id="4c77d71ae855f7126f7e5e2e28b33635f861ff14" translate="yes" xml:space="preserve">
          <source>The idiomatic way to achieve selecting potentially not-found elements is via &lt;code&gt;.reindex()&lt;/code&gt;. See also the section on &lt;a href=&quot;basics#basics-reindexing&quot;&gt;reindexing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d687cf27a3f5579822cef10d318f3f8abbf491" translate="yes" xml:space="preserve">
          <source>The implementation is simple, it creates an array of zeros and loops over the rows, applying our &lt;code&gt;integrate_f_typed&lt;/code&gt;, and putting this in the zeros array.</source>
          <target state="translated">구현은 우리의 적용 행을 통해 0과 루프의 배열을 만들고, 간단 &lt;code&gt;integrate_f_typed&lt;/code&gt; 을 하고 제로의 배열이 퍼팅.</target>
        </trans-unit>
        <trans-unit id="37c8547543c40f0173f601533e7e7b4806fe1d0c" translate="yes" xml:space="preserve">
          <source>The in and not in operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb66268fe9dbba5410b16baa804cc718ecb4c24d" translate="yes" xml:space="preserve">
          <source>The inclusion of the interval endpoints in rolling window calculations can be specified with the &lt;code&gt;closed&lt;/code&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8190ac8baba140ed31d4583440808af18e02f95f" translate="yes" xml:space="preserve">
          <source>The index (axis labels) of the Series.</source>
          <target state="translated">시리즈의 인덱스 (축 레이블)입니다.</target>
        </trans-unit>
        <trans-unit id="a36ba98a948575d24887853f618dd8e8e83a90b2" translate="yes" xml:space="preserve">
          <source>The index (row labels) of the DataFrame.</source>
          <target state="translated">DataFrame의 인덱스 (행 레이블)입니다.</target>
        </trans-unit>
        <trans-unit id="a9122a14b107cebdcfe40b681209cd301a00852d" translate="yes" xml:space="preserve">
          <source>The index and columns must be unique</source>
          <target state="translated">색인과 열은 고유해야합니다</target>
        </trans-unit>
        <trans-unit id="59062eb4825de615d29dc8e3b0cd8a69b5fb8df6" translate="yes" xml:space="preserve">
          <source>The index can be excluded from the record array:</source>
          <target state="translated">레코드 배열에서 인덱스를 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d1896cc8ebc830ad64f7b6e2154c37ba025c90e" translate="yes" xml:space="preserve">
          <source>The index can be hidden from rendering by calling &lt;code&gt;Styler.hide_index&lt;/code&gt;. Columns can be hidden from rendering by calling &lt;code&gt;Styler.hide_columns&lt;/code&gt; and passing in the name of a column, or a slice of columns.</source>
          <target state="translated">&lt;code&gt;Styler.hide_index&lt;/code&gt; 를 호출하여 인덱스를 렌더링에서 숨길 수 있습니다 . &lt;code&gt;Styler.hide_columns&lt;/code&gt; 를 호출 하고 열 이름 또는 열 조각을 전달하여 열 을 렌더링에서 숨길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfe4edf24f7574a811ec87e2a658b5b261aa3e27" translate="yes" xml:space="preserve">
          <source>The index entries that did not have a value in the original data frame (for example, &amp;lsquo;2009-12-29&amp;rsquo;) are by default filled with &lt;code&gt;NaN&lt;/code&gt;. If desired, we can fill in the missing values using one of several options.</source>
          <target state="translated">원래 데이터 프레임에 값이없는 인덱스 항목 (예 : '2009-12-29')은 기본적으로 &lt;code&gt;NaN&lt;/code&gt; 으로 채워집니다 . 원하는 경우 여러 옵션 중 하나를 사용하여 결 측값을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c50b16c1b447db7348df48223741ce20ca63557f" translate="yes" xml:space="preserve">
          <source>The index of the row. A tuple for a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b5a3924b493782a39b6ba185a3a5364a20052a8" translate="yes" xml:space="preserve">
          <source>The index of the row. A tuple for a &lt;code&gt;MultiIndex&lt;/code&gt;.</source>
          <target state="translated">행의 인덱스 &lt;code&gt;MultiIndex&lt;/code&gt; 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="4dbdc15e2f83ddfab85ad87c91f4fc5a615e620d" translate="yes" xml:space="preserve">
          <source>The index or the name of the axis. 0 is equivalent to None or &amp;lsquo;index&amp;rsquo;.</source>
          <target state="translated">축의 인덱스 또는 이름입니다. 0은 None 또는 'index'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="48b1e70683e9844c48722360acd2efc0c0f8d07b" translate="yes" xml:space="preserve">
          <source>The index values in &lt;code&gt;truncate&lt;/code&gt; can be datetimes or string dates.</source>
          <target state="translated">&lt;code&gt;truncate&lt;/code&gt; 의 인덱스 값은 날짜 시간 또는 문자열 날짜 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b35ec512367929a41d9cd3282c0a0784665a65d3" translate="yes" xml:space="preserve">
          <source>The indices that the index itself was sorted by.</source>
          <target state="translated">인덱스 자체가 정렬 된 지수입니다.</target>
        </trans-unit>
        <trans-unit id="caef1481fbf805c88176474592de5e74c7a1810c" translate="yes" xml:space="preserve">
          <source>The information about current institutional partners can be found on &lt;a href=&quot;https://pandas.pydata.org/about.html&quot;&gt;pandas website page&lt;/a&gt;.</source>
          <target state="translated">현재 기관 파트너에 대한 정보는 &lt;a href=&quot;https://pandas.pydata.org/about.html&quot;&gt;pandas 웹 사이트 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59fc2c649fa1012f5055918636463936f4bc3232" translate="yes" xml:space="preserve">
          <source>The input array to be binned. Must be 1-dimensional.</source>
          <target state="translated">비닝 할 입력 배열입니다. 1 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="939bc92c43eb914a9ff7e2b31825e59bbf957184" translate="yes" xml:space="preserve">
          <source>The interface consists of two classes.</source>
          <target state="translated">인터페이스는 두 가지 클래스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4ebdeb522381b87dc7e3a8c93703238ac4bbd117" translate="yes" xml:space="preserve">
          <source>The interface includes the following abstract methods that must be implemented by subclasses:</source>
          <target state="translated">인터페이스에는 서브 클래스로 구현해야하는 다음과 같은 추상 메소드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9595c46e2aad2cb0eba723cfa14958cd1dab93ff" translate="yes" xml:space="preserve">
          <source>The interval to check against for an overlap.</source>
          <target state="translated">겹침을 확인할 간격입니다.</target>
        </trans-unit>
        <trans-unit id="679b60de5244590df99de7a1234df7c3a80f3a9f" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;PROC IMPORT&lt;/code&gt; in SAS is &lt;code&gt;PROC EXPORT&lt;/code&gt;</source>
          <target state="translated">SAS에서 &lt;code&gt;PROC IMPORT&lt;/code&gt; 의 역 은 &lt;code&gt;PROC EXPORT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7288f71c3c88367eb035402444927c74971369dc" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;import delimited&lt;/code&gt; in Stata is &lt;code&gt;export delimited&lt;/code&gt;</source>
          <target state="translated">Stata에서 &lt;code&gt;import delimited&lt;/code&gt; 된 수입 역수 는 &lt;code&gt;export delimited&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70b3a2d82c0a0cb47b363909f6c055ba9bc79154" translate="yes" xml:space="preserve">
          <source>The is in contrast to R&amp;rsquo;s &lt;code&gt;factor&lt;/code&gt; function, where &lt;code&gt;factor(c(1,2,3))[1]&lt;/code&gt; returns a single value &lt;code&gt;factor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313b28e6f6728c561db11e61f5fb0d2105366e45" translate="yes" xml:space="preserve">
          <source>The issue will then show up to the &lt;em&gt;pandas&lt;/em&gt; community and be open to comments/ideas from others.</source>
          <target state="translated">문제는 &lt;em&gt;팬더&lt;/em&gt; 커뮤니티에 표시 되며 다른 사람들의 의견 / 아이디어에 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="4c27f6a853017c9057339758d810961d340ee40b" translate="yes" xml:space="preserve">
          <source>The join is done on columns or indexes. If joining columns on columns, the DataFrame indexes &lt;em&gt;will be ignored&lt;/em&gt;. Otherwise if joining indexes on indexes or indexes on a column or columns, the index will be passed on.</source>
          <target state="translated">조인은 열 또는 인덱스에서 수행됩니다. 열의 열을 조인하는 경우 DataFrame 인덱스 &lt;em&gt;는 무시&lt;/em&gt; 됩니다. 그렇지 않으면 인덱스의 인덱스 또는 열의 인덱스를 조인하면 인덱스가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="02dda5e65aa15cad74f80bef212692b53ca07a46" translate="yes" xml:space="preserve">
          <source>The join is done on columns or indexes. If joining columns on columns, the DataFrame indexes &lt;em&gt;will be ignored&lt;/em&gt;. Otherwise if joining indexes on indexes or indexes on a column or columns, the index will be passed on. When performing a cross merge, no column specifications to merge on are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0852ad2ea480c885870153a0bf834fcf8801e230" translate="yes" xml:space="preserve">
          <source>The key cannot be a slice, list of same-level labels, a boolean mask, or a sequence of such. If you want to use those, use &lt;a href=&quot;pandas.multiindex.get_locs#pandas.MultiIndex.get_locs&quot;&gt;&lt;code&gt;MultiIndex.get_locs()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abb206db4949ca2e24e37998f63833bd3967d84" translate="yes" xml:space="preserve">
          <source>The key cannot be a slice, list of same-level labels, a boolean mask, or a sequence of such. If you want to use those, use &lt;code&gt;MultiIndex.get_locs()&lt;/code&gt; instead.</source>
          <target state="translated">키는 슬라이스, 동일한 레벨 레이블 목록, 부울 마스크 또는 이와 같은 시퀀스 일 수 없습니다. 이를 사용하려면 &lt;code&gt;MultiIndex.get_locs()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="13801fd1e97390df2ceaa91222219dea28695177" translate="yes" xml:space="preserve">
          <source>The key functions are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aad223c6c3dcc2ea92c03949d42f4faafc91db3" translate="yes" xml:space="preserve">
          <source>The keys, levels, and names arguments are all optional.</source>
          <target state="translated">키, 레벨 및 이름 인수는 모두 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e3aa0a1b85f05845d6e05682af6db229125ec5bf" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;c&lt;/code&gt; may be given as the name of a column to provide colors for each point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae925ef1bdbe61f7877b1046c5d4d8cc743fee8b" translate="yes" xml:space="preserve">
          <source>The keywords are the &lt;em&gt;output&lt;/em&gt; column names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951814611f4e360846716f735741d1e9644f8173" translate="yes" xml:space="preserve">
          <source>The kind of object to return. The default is &lt;code&gt;axes&lt;/code&gt;.</source>
          <target state="translated">반환 할 객체의 종류입니다. 기본값은 &lt;code&gt;axes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="46f43f45c55d4c23b76d0c84cc8f23828f2aeb80" translate="yes" xml:space="preserve">
          <source>The kind of plot to produce:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af15498936f18bd892da0ef57995d7f1bf96d74a" translate="yes" xml:space="preserve">
          <source>The kind of the SparseIndex tracking where data is not equal to the fill value:</source>
          <target state="translated">데이터가 채우기 값과 같지 않은 SparseIndex 추적의 종류 :</target>
        </trans-unit>
        <trans-unit id="2ef108c8900d997517b5f403d5feb4f143582a97" translate="yes" xml:space="preserve">
          <source>The label up to which the method returns the latest index label.</source>
          <target state="translated">메소드가 최신 색인 레이블을 리턴 할 때까지의 레이블</target>
        </trans-unit>
        <trans-unit id="a6a098a22fc68b503c2403e750a32b4de2259c84" translate="yes" xml:space="preserve">
          <source>The larger the frame and the larger the expression the more speedup you will see from using &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프레임이 클수록 표현식이 클수록 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 을 사용하면 속도가 향상됩니다 .</target>
        </trans-unit>
        <trans-unit id="88a7e776b65a937667815eb3a6eaf67a01ff78ce" translate="yes" xml:space="preserve">
          <source>The last</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f8520c0395f8e9f9b233b2f21bf28007c037e3" translate="yes" xml:space="preserve">
          <source>The last &lt;code&gt;n&lt;/code&gt; rows of the caller object.</source>
          <target state="translated">호출자 객체 의 마지막 &lt;code&gt;n&lt;/code&gt; 행</target>
        </trans-unit>
        <trans-unit id="54c878637bb70a5be8464e71eab067343faac183" translate="yes" xml:space="preserve">
          <source>The last row (for each element in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c20769b8994ed13551ec27ff10252f9e33f5f7" translate="yes" xml:space="preserve">
          <source>The last row (for each element in &lt;code&gt;where&lt;/code&gt;, if list) without any NaN is taken. In case of a &lt;a href=&quot;pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;, the last row without NaN considering only the subset of columns (if not &lt;code&gt;None&lt;/code&gt;)</source>
          <target state="translated">NaN이없는 마지막 행 ( &lt;code&gt;where&lt;/code&gt; in , list의 각 요소에 대해 )이 사용됩니다. &lt;a href=&quot;pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 의&lt;/a&gt; 경우 NaN이없는 마지막 행은 열의 하위 집합 만 고려합니다 ( &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 ).</target>
        </trans-unit>
        <trans-unit id="78f919c58efd1cf4931635be562316d68c0b8632" translate="yes" xml:space="preserve">
          <source>The latter will &lt;strong&gt;not&lt;/strong&gt; work and will raise a &lt;code&gt;SyntaxError&lt;/code&gt;.Note that there&amp;rsquo;s a single quote followed by a double quote in the &lt;code&gt;string&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d815cfd6047037d06e9eee748eac1835bce3ae" translate="yes" xml:space="preserve">
          <source>The layout of boxplot can be adjusted giving a tuple to &lt;code&gt;layout&lt;/code&gt;:</source>
          <target state="translated">상자 그림의 레이아웃에 튜플주는 조정할 수 있습니다 &lt;code&gt;layout&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b90c9b7a58a656155407459276f3bbaaad962e9" translate="yes" xml:space="preserve">
          <source>The layout of subplots can be specified by the &lt;code&gt;layout&lt;/code&gt; keyword. It can accept &lt;code&gt;(rows, columns)&lt;/code&gt;. The &lt;code&gt;layout&lt;/code&gt; keyword can be used in &lt;code&gt;hist&lt;/code&gt; and &lt;code&gt;boxplot&lt;/code&gt; also. If the input is invalid, a &lt;code&gt;ValueError&lt;/code&gt; will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f4aa43f8ce5c65e6bd50a95a55f7663dbd861c" translate="yes" xml:space="preserve">
          <source>The layout of the plot: (rows, columns).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97bd184ff51b4e41c890c2fea383a5da3a16b96" translate="yes" xml:space="preserve">
          <source>The left frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8401f09b226e3214786958d2dbddb1dfa5036b" translate="yes" xml:space="preserve">
          <source>The length of each interval. Must be consistent with the type of start and end, e.g. 2 for numeric, or &amp;lsquo;5H&amp;rsquo; for datetime-like. Default is 1 for numeric and &amp;lsquo;D&amp;rsquo; for datetime-like.</source>
          <target state="translated">각 간격의 길이입니다. 시작 및 종료 유형과 일치해야합니다 (예 : 숫자의 경우 2, 날짜 시간과 같은 경우 '5H'). 숫자의 경우 기본값은 1이고 날짜 / 시간과 같은 경우 'D'입니다.</target>
        </trans-unit>
        <trans-unit id="44cba7cb93c1588b0db57d208e58bfcef6a7397b" translate="yes" xml:space="preserve">
          <source>The level for the target index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e91ea6b0b59b4bcc64e521a015d379bca65c08" translate="yes" xml:space="preserve">
          <source>The level involved will automatically get sorted.</source>
          <target state="translated">관련된 레벨이 자동으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff9961dd2316dd9f9d0d89cedaaf5e0a47c52d3" translate="yes" xml:space="preserve">
          <source>The levels in the pivot table will be stored in MultiIndex objects (hierarchical indexes) on the index and columns of the result DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923397953bf0e0a0c6ac5f6fd247ba650564a521" translate="yes" xml:space="preserve">
          <source>The lexical order of a variable is not the same as the logical order (&amp;ldquo;one&amp;rdquo;, &amp;ldquo;two&amp;rdquo;, &amp;ldquo;three&amp;rdquo;). By converting to a categorical and specifying an order on the categories, sorting and min/max will use the logical order instead of the lexical order, see &lt;a href=&quot;#categorical-sort&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">변수의 어휘 순서는 논리 순서와 동일하지 않습니다 ( &quot;1&quot;, &quot;2&quot;, &quot;3&quot;). 범주로 변환하고 범주에 순서를 지정하면 sorting 및 min / max는 어휘 순서 대신 논리 순서를 사용합니다 ( &lt;a href=&quot;#categorical-sort&quot;&gt;여기&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="72287d147df163783c823c0184c573bf64db5394" translate="yes" xml:space="preserve">
          <source>The list entries concatenated by intervening occurrences of the delimiter.</source>
          <target state="translated">목록 항목은 분리 문자가 개입하여 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1310236f2b93b90720db6dc578ae9c6b5f37c9" translate="yes" xml:space="preserve">
          <source>The list of levels can contain either level names or level numbers (but not a mixture of the two).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47e542600352d25d6ddfd94c61674f43cba5fd0" translate="yes" xml:space="preserve">
          <source>The list of the Core Team members and more detailed information can be found on the &lt;a href=&quot;https://github.com/pandas-dev/pandas-governance/blob/master/people.md&quot;&gt;people&amp;rsquo;s page&lt;/a&gt; of the governance repo.</source>
          <target state="translated">핵심 팀 구성원 목록과 자세한 정보는 거버넌스 리포지토리 의 &lt;a href=&quot;https://github.com/pandas-dev/pandas-governance/blob/master/people.md&quot;&gt;사람들 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e26b9d784ba10733f43c30ec58a07891a67b2c42" translate="yes" xml:space="preserve">
          <source>The location is returned as an integer/slice or boolean mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e793c848d7878a260abd9641105b2d24ada7bf03" translate="yes" xml:space="preserve">
          <source>The longest component is days, whose value may be larger than 365. Every component is always included, even if its value is 0. Pandas uses nanosecond precision, so up to 9 decimal places may be included in the seconds component. Trailing 0&amp;rsquo;s are removed from the seconds component after the decimal. We do not 0 pad components, so it&amp;rsquo;s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9274648371818371d893056c89f147ca18a6f3e8" translate="yes" xml:space="preserve">
          <source>The longest component is days, whose value may be larger than 365. Every component is always included, even if its value is 0. Pandas uses nanosecond precision, so up to 9 decimal places may be included in the seconds component. Trailing 0&amp;rsquo;s are removed from the seconds component after the decimal. We do not 0 pad components, so it&amp;rsquo;s &lt;code&gt;&amp;hellip;T5H&amp;hellip;&lt;/code&gt;, not &lt;code&gt;&amp;hellip;T05H&amp;hellip;&lt;/code&gt;</source>
          <target state="translated">가장 긴 구성 요소는 일이며, 값이 365보다 클 수 있습니다. 값이 0 인 경우에도 모든 구성 요소가 항상 포함됩니다. Pandas는 나노초 정밀도를 사용하므로 초 구성 요소에 소수점 이하 9 자리까지 포함될 수 있습니다. 소수점 이하의 초 구성 요소에서 후행 0이 제거됩니다. 우리는 패드 구성 요소가 0이 아니므로 &lt;code&gt;&amp;hellip;T5H&amp;hellip;&lt;/code&gt; 가 아니라 &lt;code&gt;&amp;hellip;T05H&amp;hellip;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aa951ef4e3e7f574dd3deca941f04c70d8f1a923" translate="yes" xml:space="preserve">
          <source>The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s &lt;code&gt;to_excel&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c728f93b883de72b79e28ad92ba813b31b463a5" translate="yes" xml:space="preserve">
          <source>The mapping can be specified many different ways:</source>
          <target state="translated">매핑은 여러 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff4b4f2631ec3cfe6a26f42b88b893989f74b624" translate="yes" xml:space="preserve">
          <source>The mask method is an application of the if-then idiom. For each element in the calling DataFrame, if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; the element is used; otherwise the corresponding element from the DataFrame &lt;code&gt;other&lt;/code&gt; is used.</source>
          <target state="translated">마스크 방법은 if-then 관용구의 응용입니다. 호출하는 DataFrame의 각 요소에 대해 &lt;code&gt;cond&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 이면 요소가 사용됩니다. 그렇지 않으면 &lt;code&gt;other&lt;/code&gt; DataFrame의 해당 요소 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f683ea0e33c9b081b109d32451e952a52170df95" translate="yes" xml:space="preserve">
          <source>The matplotlib &lt;code&gt;Axes&lt;/code&gt; on which the hexbin is plotted.</source>
          <target state="translated">hexbin이 그려지는 matplotlib &lt;code&gt;Axes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="007eeaca8c931c91d02270e3528b200a70a07108" translate="yes" xml:space="preserve">
          <source>The matplotlib axes to be used by boxplot.</source>
          <target state="translated">boxplot에서 사용할 matplotlib 축입니다.</target>
        </trans-unit>
        <trans-unit id="bd1e225aaf7ddd8f493a2a58788cf77f84d51d56" translate="yes" xml:space="preserve">
          <source>The matplotlib line style per column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b97444b21b5a0a2e1891de162c63f205efd94c0" translate="yes" xml:space="preserve">
          <source>The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b55e702ae9ad132593dcd2411af88282d4313f" translate="yes" xml:space="preserve">
          <source>The maximum cereal calories is the third element and the minimum cereal calories is the first element, since series is zero-indexed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5aaa1626a185e33bac04fe19f00e671f201b0c" translate="yes" xml:space="preserve">
          <source>The maximum width in characters of a column in the repr of a pandas data structure. When the column overflows, a &amp;ldquo;&amp;hellip;&amp;rdquo; placeholder is embedded in the output. &amp;lsquo;None&amp;rsquo; value means unlimited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d3c073abd3432be0c7333e59a0c1e6c372804e" translate="yes" xml:space="preserve">
          <source>The maximum width in characters of a column in the repr of a pandas data structure. When the column overflows, a &amp;ldquo;&amp;hellip;&amp;rdquo; placeholder is embedded in the output. A &amp;lsquo;None&amp;rsquo; value means unlimited. [default: 50] [currently: 50]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ead8ca2fb7f7394f038d545f8cbc6e80c48781" translate="yes" xml:space="preserve">
          <source>The memory footprint of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0af9e9b25ef45e044d35ed7e881ae3674bbfe3" translate="yes" xml:space="preserve">
          <source>The memory footprint of &lt;code&gt;object&lt;/code&gt; dtype columns is ignored by default:</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; dtype 열의 메모리 사용량은 기본적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0214e7feec3bad341c731865c5487378d7ab650e" translate="yes" xml:space="preserve">
          <source>The memory footprint of &lt;code&gt;object&lt;/code&gt; values is ignored by default:</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 값 의 메모리 사용량은 기본적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfc984e48bd3f6c0217d25b3596fb3247797e39" translate="yes" xml:space="preserve">
          <source>The memory usage can optionally include the contribution of the index and elements of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c540b53855deddb53265b98976538482e503032" translate="yes" xml:space="preserve">
          <source>The memory usage can optionally include the contribution of the index and elements of &lt;code&gt;object&lt;/code&gt; dtype.</source>
          <target state="translated">메모리 사용은 선택적으로 인덱스 및 &lt;code&gt;object&lt;/code&gt; dtype 요소의 기여를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="052df9d0916f7dbfcdee2fc9d4b19762cc5ae5c3" translate="yes" xml:space="preserve">
          <source>The memory usage can optionally include the contribution of the index and of elements of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0ba044a0ffd110ecb44cb2f0d845d7c268c084" translate="yes" xml:space="preserve">
          <source>The memory usage can optionally include the contribution of the index and of elements of &lt;code&gt;object&lt;/code&gt; dtype.</source>
          <target state="translated">메모리 사용은 선택적으로 인덱스 및 &lt;code&gt;object&lt;/code&gt; dtype 요소의 기여를 포함 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="3c50bb157950ede3677059bb720d9930d7170e44" translate="yes" xml:space="preserve">
          <source>The memory usage displayed by the &lt;a href=&quot;../reference/api/pandas.dataframe.info#pandas.DataFrame.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt; method utilizes the &lt;a href=&quot;../reference/api/pandas.dataframe.memory_usage#pandas.DataFrame.memory_usage&quot;&gt;&lt;code&gt;memory_usage()&lt;/code&gt;&lt;/a&gt; method to determine the memory usage of a &lt;code&gt;DataFrame&lt;/code&gt; while also formatting the output in human-readable units (base-2 representation; i.e. 1KB = 1024 bytes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c004b5e72e81db9156ac6c7a81f919b185d8ec4" translate="yes" xml:space="preserve">
          <source>The memory usage of a &lt;code&gt;Categorical&lt;/code&gt; is proportional to the number of categories plus the length of the data. In contrast, an &lt;code&gt;object&lt;/code&gt; dtype is a constant times the length of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8efe100654f820b1306b703c822fc9e107704e" translate="yes" xml:space="preserve">
          <source>The memory usage of a &lt;code&gt;DataFrame&lt;/code&gt; (including the index) is shown when calling the &lt;a href=&quot;../reference/api/pandas.dataframe.info#pandas.DataFrame.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;. A configuration option, &lt;code&gt;display.memory_usage&lt;/code&gt; (see &lt;a href=&quot;options#options-available&quot;&gt;the list of options&lt;/a&gt;), specifies if the &lt;code&gt;DataFrame&lt;/code&gt;&amp;rsquo;s memory usage will be displayed when invoking the &lt;code&gt;df.info()&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.dataframe.info#pandas.DataFrame.info&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; 호출 할 때 &lt;code&gt;DataFrame&lt;/code&gt; (인덱스 포함) 의 메모리 사용량 이 표시됩니다 . 구성 옵션 &lt;code&gt;display.memory_usage&lt;/code&gt; ( &lt;a href=&quot;options#options-available&quot;&gt;옵션 목록&lt;/a&gt; 참조 ) 는 &lt;code&gt;df.info()&lt;/code&gt; 메소드를 호출 할 때 &lt;code&gt;DataFrame&lt;/code&gt; 의 메모리 사용량이 표시 되는지 여부를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e454ea062689a6ea4be7d10a964b4d915596a3a9" translate="yes" xml:space="preserve">
          <source>The memory usage of each column can be found by calling the &lt;a href=&quot;../reference/api/pandas.dataframe.memory_usage#pandas.DataFrame.memory_usage&quot;&gt;&lt;code&gt;memory_usage()&lt;/code&gt;&lt;/a&gt; method. This returns a &lt;code&gt;Series&lt;/code&gt; with an index represented by column names and memory usage of each column shown in bytes. For the &lt;code&gt;DataFrame&lt;/code&gt; above, the memory usage of each column and the total memory usage can be found with the &lt;code&gt;memory_usage&lt;/code&gt; method:</source>
          <target state="translated">각 열의 메모리 사용량은 &lt;a href=&quot;../reference/api/pandas.dataframe.memory_usage#pandas.DataFrame.memory_usage&quot;&gt; &lt;code&gt;memory_usage()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 찾을 수 있습니다 . 이것은 열 이름으로 표시되는 인덱스와 바이트 단위로 표시된 각 열의 메모리 사용량으로 &lt;code&gt;Series&lt;/code&gt; 를 리턴 합니다. 위 의 &lt;code&gt;DataFrame&lt;/code&gt; 의 경우 각 열의 메모리 사용량과 총 메모리 사용량은 &lt;code&gt;memory_usage&lt;/code&gt; 메소드를 사용하여 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4be15c30f544c953a895edcafe9733a29a94095e" translate="yes" xml:space="preserve">
          <source>The merge &lt;code&gt;suffixes&lt;/code&gt; argument takes a tuple of list of strings to append to overlapping column names in the input &lt;code&gt;DataFrame&lt;/code&gt;s to disambiguate the result columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a09de75ad6a3109448ec9417a65d598d7929935" translate="yes" xml:space="preserve">
          <source>The merge indicator</source>
          <target state="translated">병합 표시기</target>
        </trans-unit>
        <trans-unit id="b8d747c5ef136d5ea46c8d2feb930009f4dc88df" translate="yes" xml:space="preserve">
          <source>The merged DataFrame output type will the be same as &amp;lsquo;left&amp;rsquo;, if it is a subclass of DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0692a6c8455fe78a9cb56e55921c11d1c10d74c2" translate="yes" xml:space="preserve">
          <source>The merged result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40778c5a75b2b4cd4e886d308e6958de0eb0f7a9" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;../reference/api/pandas.multiindex.get_level_values#pandas.MultiIndex.get_level_values&quot;&gt;&lt;code&gt;get_level_values()&lt;/code&gt;&lt;/a&gt; will return a vector of the labels for each location at a particular level:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3233d431ccd88c3149a5bc89dff1209c9f6cf9" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;to_stata()&lt;/code&gt; will write a DataFrame into a .dta file. The format version of this file is always 115 (Stata 12).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c407494a8c6947c9e91a182d9e85570a9292a94" translate="yes" xml:space="preserve">
          <source>The method requires a &lt;code&gt;MultiIndex&lt;/code&gt; with two or more levels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76fc2e27a39fd2c3936391b1883610500ff0c27a" translate="yes" xml:space="preserve">
          <source>The method to use when for replacement, when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ed563f7347f457619184de905ac4a1eee8c1ac4" translate="yes" xml:space="preserve">
          <source>The method to use when for replacement, when &lt;code&gt;to_replace&lt;/code&gt; is a scalar, list or tuple and &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">대체 할 때, &lt;code&gt;to_replace&lt;/code&gt; 가 스칼라, 목록 또는 튜플이고 &lt;code&gt;value&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; 인 경우 사용할 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="f42604281a85ffbc5487df96190a6679c606b6dc" translate="yes" xml:space="preserve">
          <source>The method used to calculate the estimator bandwidth. This can be &amp;lsquo;scott&amp;rsquo;, &amp;lsquo;silverman&amp;rsquo;, a scalar constant or a callable. If None (default), &amp;lsquo;scott&amp;rsquo; is used. See &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde&quot;&gt;&lt;code&gt;scipy.stats.gaussian_kde&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">추정기 대역폭을 계산하는 데 사용되는 방법입니다. 이것은 'scott', 'silverman', 스칼라 상수 또는 호출 가능일 수 있습니다. None (기본값)이면 'scott'이 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde&quot;&gt; &lt;code&gt;scipy.stats.gaussian_kde&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11b10e303915b144e9ab563f0a000a31656168b8" translate="yes" xml:space="preserve">
          <source>The method will only work for single element objects with a boolean value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405cf28d1739b085b8b3502a67281b31d59ce333" translate="yes" xml:space="preserve">
          <source>The methods &lt;a href=&quot;../reference/api/pandas.dataframe.rename_axis#pandas.DataFrame.rename_axis&quot;&gt;&lt;code&gt;DataFrame.rename_axis()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.series.rename_axis#pandas.Series.rename_axis&quot;&gt;&lt;code&gt;Series.rename_axis()&lt;/code&gt;&lt;/a&gt; allow specific names of a &lt;code&gt;MultiIndex&lt;/code&gt; to be changed (as opposed to the labels).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6991f2e032b81237fb6c5f2324d0d6d6f07c9492" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;append_to_multiple&lt;/code&gt; and &lt;code&gt;select_as_multiple&lt;/code&gt; can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table&amp;rsquo;s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93939d8fefe05780516929a523b276279efe4a10" translate="yes" xml:space="preserve">
          <source>The microseconds of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af81d793e1f816ba33cae3ca0b660a651e3cc2fc" translate="yes" xml:space="preserve">
          <source>The microseconds of the datetime.</source>
          <target state="translated">날짜 시간의 마이크로 초입니다.</target>
        </trans-unit>
        <trans-unit id="03b14d66a9b4c3410fe8bb69c7d38e82bbb524fe" translate="yes" xml:space="preserve">
          <source>The minimum width of each column in CSS length units. An int is assumed to be px units.</source>
          <target state="translated">CSS 길이 단위의 각 열의 최소 너비입니다. int는 px 단위 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b477ed2789039a264b6454f7f01b7aa1a10ad55a" translate="yes" xml:space="preserve">
          <source>The minimum width of each column.</source>
          <target state="translated">각 열의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="cc637b15b2cb592a407cc548be20ddebd2120986" translate="yes" xml:space="preserve">
          <source>The minute as an integer, between 0 and 59.</source>
          <target state="translated">0에서 59 사이의 정수로 표시되는 분입니다.</target>
        </trans-unit>
        <trans-unit id="f6569764e9b9a662ba23cc896ab1ccee1749b5df" translate="yes" xml:space="preserve">
          <source>The minute of the period</source>
          <target state="translated">기간의 분</target>
        </trans-unit>
        <trans-unit id="2148627d75e427c55e6afb021aafbe7487cc6de3" translate="yes" xml:space="preserve">
          <source>The minute of the period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81504286834d9ed4659f6581a94edcff7ea59399" translate="yes" xml:space="preserve">
          <source>The minutes of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32b6cde1157adaa24fcd29957c296f6f0a6bb56" translate="yes" xml:space="preserve">
          <source>The minutes of the datetime.</source>
          <target state="translated">날짜 시간의 분입니다.</target>
        </trans-unit>
        <trans-unit id="b9a7953bdc294a3b50e73f2958369039ea8d89b0" translate="yes" xml:space="preserve">
          <source>The mod (%) and divmod operations are defined for &lt;code&gt;Timedelta&lt;/code&gt; when operating with another timedelta-like or with a numeric argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6db59b204250b5a9883eff2339519b8d961e3c" translate="yes" xml:space="preserve">
          <source>The mode is the value that appears most often. There can be multiple modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9453d4e70dcfbf1bc833a33630c19578c80af0f" translate="yes" xml:space="preserve">
          <source>The mode of a set of values is the value that appears most often. It can be multiple values.</source>
          <target state="translated">값 집합의 모드는 가장 자주 나타나는 값입니다. 여러 값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a90411c9b4858260f7b81fc226825a712f494fb" translate="yes" xml:space="preserve">
          <source>The modes of each column or row.</source>
          <target state="translated">각 열 또는 행의 모드</target>
        </trans-unit>
        <trans-unit id="468c34cf153e19b52c3bb16ae3154400817f1fbb" translate="yes" xml:space="preserve">
          <source>The month as January=1, December=12</source>
          <target state="translated">1 월 = 1, 12 월 = 12 인 달</target>
        </trans-unit>
        <trans-unit id="a097b9d836b42484bc515fa475f70544735b5a66" translate="yes" xml:space="preserve">
          <source>The month as January=1, December=12.</source>
          <target state="translated">1 월 = 1, 12 월 = 12 인 월입니다.</target>
        </trans-unit>
        <trans-unit id="009f10a10af80a34db8a952dcfc500b776d0dec9" translate="yes" xml:space="preserve">
          <source>The month in which fiscal years end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02de196383e594c542f195a961a057f8e6449e22" translate="yes" xml:space="preserve">
          <source>The month in which the fiscal year ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea243181fed21a8b5144a40b5de6c392c48d07c" translate="yes" xml:space="preserve">
          <source>The month of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5bee22ac86e8f171e345660f86e093a10ee4c4" translate="yes" xml:space="preserve">
          <source>The most robust and consistent way of slicing ranges along arbitrary axes is described in the &lt;a href=&quot;#indexing-integer&quot;&gt;Selection by Position&lt;/a&gt; section detailing the &lt;code&gt;.iloc&lt;/code&gt; method. For now, we explain the semantics of slicing using the &lt;code&gt;[]&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7eaa2bd11f9b9f190bdd4cc5ec85fdb69b4226" translate="yes" xml:space="preserve">
          <source>The motivation for having an &lt;code&gt;Index&lt;/code&gt; class in the first place was to enable different implementations of indexing. This means that it&amp;rsquo;s possible for you, the user, to implement a custom &lt;code&gt;Index&lt;/code&gt; subclass that may be better suited to a particular application than the ones provided in pandas.</source>
          <target state="translated">처음에 &lt;code&gt;Index&lt;/code&gt; 클래스 를 사용하려는 동기는 다른 인덱싱 구현을 가능하게하는 것이 었습니다. 즉, 사용자 는 팬더에서 제공되는 것보다 특정 응용 프로그램에 더 적합한 사용자 정의 &lt;code&gt;Index&lt;/code&gt; 하위 클래스 를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f41627f476384b2ab2cbaef95683bc31fd6a59b" translate="yes" xml:space="preserve">
          <source>The name of a Series becomes its index or column name if it is used to form a DataFrame. It is also used whenever displaying the Series using the interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7af703f921cf00ccb71eba49d658f48a0679e1" translate="yes" xml:space="preserve">
          <source>The name of a Series within a DataFrame is its column name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869e8364ba8283da06dc221a0d84a58861751c37" translate="yes" xml:space="preserve">
          <source>The name of a parameter</source>
          <target state="translated">매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="34f72243191d2ac1946ae823cc807c2537058e81" translate="yes" xml:space="preserve">
          <source>The name of the Series, also the column name if part of a DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f6a5b9a4e927067f7dee56fc7dbecf8bb6b1d8" translate="yes" xml:space="preserve">
          <source>The name of the group to get as a DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4c4358e73923051c0853434d9775952656c918b" translate="yes" xml:space="preserve">
          <source>The name of the returned namedtuples or None to return regular tuples.</source>
          <target state="translated">반환 된 명명 된 튜플의 이름 또는 일반 튜플을 반환하려면 없음입니다.</target>
        </trans-unit>
        <trans-unit id="472c1ceac59fe82e62dfcc918e65363ff2e634ad" translate="yes" xml:space="preserve">
          <source>The name of the sub-observation variable. What you wish to name your suffix in the long format.</source>
          <target state="translated">하위 관측치 변수의 이름입니다. 긴 형식으로 접미사 이름을 지정하려는 항목.</target>
        </trans-unit>
        <trans-unit id="9022eabcad504511f5abf1f9dc89bd3029a0dc24" translate="yes" xml:space="preserve">
          <source>The name of the type, for example &lt;code&gt;category&lt;/code&gt;.</source>
          <target state="translated">예를 들어의 형태의 이름 &lt;code&gt;category&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72302eab9186006403abb103dc39c1d9e9197b81" translate="yes" xml:space="preserve">
          <source>The name or type of each column can be used to apply different functions to different columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4390279bbdf129e3af0371814a4e96fec50d2e0e" translate="yes" xml:space="preserve">
          <source>The name to give to the Series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb27c9092f4dab3db3b33d7628632c5d03db529" translate="yes" xml:space="preserve">
          <source>The name to use for the column containing the original Series values. Uses &lt;code&gt;self.name&lt;/code&gt; by default. This argument is ignored when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942c1cfbb5da607b3a224c0a214a3c2bf10eceae" translate="yes" xml:space="preserve">
          <source>The name to use for the column containing the original Series values. Uses &lt;code&gt;self.name&lt;/code&gt; by default. This argument is ignored when &lt;code&gt;drop&lt;/code&gt; is True.</source>
          <target state="translated">원래 Series 값을 포함하는 열에 사용할 이름입니다. 기본적으로 &lt;code&gt;self.name&lt;/code&gt; 을 사용합니다 . &lt;code&gt;drop&lt;/code&gt; 이 True 이면이 인수는 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad4dde04cd86526215bf4e5ab26899352532a5e5" translate="yes" xml:space="preserve">
          <source>The name, if set, will be shown in the console display:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74239ff4fa8be7affb888e52da014078dda191b5" translate="yes" xml:space="preserve">
          <source>The names of &amp;lsquo;variable&amp;rsquo; and &amp;lsquo;value&amp;rsquo; columns can be customized:</source>
          <target state="translated">'변수'및 '값'열의 이름을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6951c8032bfb9edd6e42ace70cf55e742fc6df3d" translate="yes" xml:space="preserve">
          <source>The nanoseconds of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af7e13eaa1ef6335d5434c4021b6dd9107a7a3c" translate="yes" xml:space="preserve">
          <source>The nanoseconds of the datetime.</source>
          <target state="translated">날짜 시간의 나노초입니다.</target>
        </trans-unit>
        <trans-unit id="158ab48ead613f75778b6055a078b4049e7e733d" translate="yes" xml:space="preserve">
          <source>The ndarrays must all be the same length. If an index is passed, it must clearly also be the same length as the arrays. If no index is passed, the result will be &lt;code&gt;range(n)&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the array length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cae4b888b7c8563b57ebe398e6c20091b3b1d7" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;DataFrame&lt;/code&gt; returned is a view on the same data as the old &lt;code&gt;DataFrame&lt;/code&gt;. Or the property can just be set directly on the same object</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b78ec60325da96866bc27e5cc194a495e3ab1d" translate="yes" xml:space="preserve">
          <source>The new categories to be included.</source>
          <target state="translated">포함 할 새로운 카테고리.</target>
        </trans-unit>
        <trans-unit id="f3c9cbf54a80ec100f92ef66a99e0ca44b52fe4b" translate="yes" xml:space="preserve">
          <source>The new index levels are sorted.</source>
          <target state="translated">새로운 색인 수준이 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="1d99b6ce679786109de8995af6a1aad600fce3cd" translate="yes" xml:space="preserve">
          <source>The newline character or character sequence to use in the output file. Defaults to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205f307e9a241cd14826e510387b412f0d55cd86" translate="yes" xml:space="preserve">
          <source>The newline character or character sequence to use in the output file. Defaults to &lt;code&gt;os.linesep&lt;/code&gt;, which depends on the OS in which this method is called (&amp;lsquo;n&amp;rsquo; for linux, &amp;lsquo;rn&amp;rsquo; for Windows, i.e.).</source>
          <target state="translated">출력 파일에서 사용할 줄 바꿈 문자 또는 문자 순서. 기본적으로 &lt;code&gt;os.linesep&lt;/code&gt; 로 설정 되는데 ,이 메소드가 호출되는 OS에 따라 다릅니다 (Linux의 경우 'n', Windows의 경우 'rn').</target>
        </trans-unit>
        <trans-unit id="ee288780b01526bd96fb1c5f783e3b6474da3457" translate="yes" xml:space="preserve">
          <source>The newly created array.</source>
          <target state="translated">새로 생성 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="9b621c7227283172c772038d67552683c1b91d4b" translate="yes" xml:space="preserve">
          <source>The next example aggregates by taking the mean across multiple columns.</source>
          <target state="translated">다음 예는 여러 열에서 평균을 취하여 집계합니다.</target>
        </trans-unit>
        <trans-unit id="1b9dcf15b941294bd59eb65546647e1cbef50c00" translate="yes" xml:space="preserve">
          <source>The next example uses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f8b2d37abcfbdaffc0a10e0a64eda118a2b79c" translate="yes" xml:space="preserve">
          <source>The next example uses &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;np.sum&lt;/code&gt; as &lt;code&gt;reduce_C_function&lt;/code&gt;. Note that &lt;code&gt;&amp;lsquo;observations&amp;rsquo;&lt;/code&gt; values ranges from 1 to 5 but the result plot shows values up to more than 25. This is because of the &lt;code&gt;reduce_C_function&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;np.sum&lt;/code&gt; 을 &lt;code&gt;reduce_C_function&lt;/code&gt; 으로 사용 합니다. 참고는 &lt;code&gt;&amp;lsquo;observations&amp;rsquo;&lt;/code&gt; 1 내지 5의 값 범위하지만 결과 플롯 도시 이상 25 최대 값이 때문이다 &lt;code&gt;reduce_C_function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b967a5fa1a011bbfd961f33404c5262271129e3d" translate="yes" xml:space="preserve">
          <source>The next four examples generate the same</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b031439e6ccffa0c8703f18995c3a3820bcf596" translate="yes" xml:space="preserve">
          <source>The next four examples generate the same &lt;code&gt;DatetimeIndex&lt;/code&gt;, but vary the combination of &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt; and &lt;code&gt;periods&lt;/code&gt;.</source>
          <target state="translated">다음 네 개의 예제는 동일한 &lt;code&gt;DatetimeIndex&lt;/code&gt; 를 생성 하지만 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;periods&lt;/code&gt; 의 조합은 다양합니다 .</target>
        </trans-unit>
        <trans-unit id="c7430b8c0329d244783a6cf8cd4d6ed2ff742a72" translate="yes" xml:space="preserve">
          <source>The next option you have are &amp;ldquo;table styles&amp;rdquo;. These are styles that apply to the table as a whole, but don&amp;rsquo;t look at the data. Certain stylings, including pseudo-selectors like &lt;code&gt;:hover&lt;/code&gt; can only be used this way. These can also be used to set specific row or column based class selectors, as will be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a2021d890a177f83b098297bbb2ff685cfe3065" translate="yes" xml:space="preserve">
          <source>The next option you have are &amp;ldquo;table styles&amp;rdquo;. These are styles that apply to the table as a whole, but don&amp;rsquo;t look at the data. Certain sytlings, including pseudo-selectors like &lt;code&gt;:hover&lt;/code&gt; can only be used this way.</source>
          <target state="translated">다음 옵션은&amp;ldquo;테이블 스타일&amp;rdquo;입니다. 이것들은 테이블 전체에 적용되는 스타일이지만 데이터를 보지 않습니다. &lt;code&gt;:hover&lt;/code&gt; 와 같은 의사 선택기를 포함한 특정 sytling 은이 방법으로 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38e6b0921919b371dddbe756a710788e70568ef3" translate="yes" xml:space="preserve">
          <source>The next step is to create a new conda environment. A conda environment is like a virtualenv that allows you to specify a specific version of Python and set of libraries. Run the following commands from a terminal window:</source>
          <target state="translated">다음 단계는 새로운 콘다 환경을 만드는 것입니다. conda 환경은 특정 버전의 Python 및 라이브러리 세트를 지정할 수있는 virtualenv와 같습니다. 터미널 창에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="708e9af6b7959cd0e92ac582cf8777dd7c093d18" translate="yes" xml:space="preserve">
          <source>The number of axes which can be contained by rows x columns specified by &lt;code&gt;layout&lt;/code&gt; must be larger than the number of required subplots. If layout can contain more axes than required, blank axes are not drawn. Similar to a NumPy array&amp;rsquo;s &lt;code&gt;reshape&lt;/code&gt; method, you can use &lt;code&gt;-1&lt;/code&gt; for one dimension to automatically calculate the number of rows or columns needed, given the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d80f9cc40118d8c7d54d8a9cd4e2489b0bbabe3" translate="yes" xml:space="preserve">
          <source>The number of bytes needed to store this object in memory.</source>
          <target state="translated">이 객체를 메모리에 저장하는 데 필요한 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="42e15d59370cbb318b7a6be40128b4d0c9535586" translate="yes" xml:space="preserve">
          <source>The number of columns of each type in a &lt;code&gt;DataFrame&lt;/code&gt; can be found by calling &lt;code&gt;DataFrame.dtypes.value_counts()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435559aa14bf09863b43d95c15f10f77dd1771bd" translate="yes" xml:space="preserve">
          <source>The number of consecutive NAs to fill before stopping.</source>
          <target state="translated">중지하기 전에 채울 연속적인 NA 수입니다.</target>
        </trans-unit>
        <trans-unit id="bcd503654d0bf114a58a10a419a9d56d4f338738" translate="yes" xml:space="preserve">
          <source>The number of days in the month</source>
          <target state="translated">해당 월의 일수</target>
        </trans-unit>
        <trans-unit id="ec3251dc4393af1444eddc3b72d0d3a1e57433f8" translate="yes" xml:space="preserve">
          <source>The number of days in the month of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff056a9dfe8558b99cb3b232a0c622c8e50a37c0" translate="yes" xml:space="preserve">
          <source>The number of days in the month.</source>
          <target state="translated">해당 월의 일수입니다.</target>
        </trans-unit>
        <trans-unit id="042cf84840f3ad0e37dca4bf11dc79f2d9d819fc" translate="yes" xml:space="preserve">
          <source>The number of decimal places to use when encoding floating point values.</source>
          <target state="translated">부동 소수점 값을 인코딩 할 때 사용할 소수 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="2a7e5b093d75f7dd7088ba954f14126edea257a6" translate="yes" xml:space="preserve">
          <source>The number of hexagons in the x-direction. The corresponding number of hexagons in the y-direction is chosen in a way that the hexagons are approximately regular. Alternatively, gridsize can be a tuple with two elements specifying the number of hexagons in the x-direction and the y-direction.</source>
          <target state="translated">x 방향의 육각형 수입니다. y- 방향의 대응하는 육각형 수는 육각형이 대략 규칙적인 방식으로 선택된다. 대안 적으로, 그리드 크기는 x- 방향 및 y- 방향으로 육각의 수를 지정하는 2 개의 요소를 갖는 튜플 일 수있다.</target>
        </trans-unit>
        <trans-unit id="4ac8db86e3f74c71699ec9a1eb9dcf4122ce02e4" translate="yes" xml:space="preserve">
          <source>The number of lines from the line-delimited jsonfile that has to be read. This can only be passed if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623e138181076d7c469bdcdf969917b5b9ba4d48" translate="yes" xml:space="preserve">
          <source>The number of months represented.</source>
          <target state="translated">월 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eefce58ca8c26ddb87cc7e8e49ce6014bf02f8ae" translate="yes" xml:space="preserve">
          <source>The number of non- &lt;code&gt;fill_value&lt;/code&gt; points.</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 가 아닌 포인트 의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="98f6e149d0997c359c5c6df0f702f5ed9a7db96c" translate="yes" xml:space="preserve">
          <source>The number of periods to shift. Negative values are allowed for shifting backwards.</source>
          <target state="translated">이동할 기간 수입니다. 음수 값은 뒤로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02738e140e509b547c333b961f33715cd1337362" translate="yes" xml:space="preserve">
          <source>The number of prior stack frames to traverse and add to the current scope. Most users will &lt;strong&gt;not&lt;/strong&gt; need to change this parameter.</source>
          <target state="translated">트래버스하여 현재 범위에 추가 할 이전 스택 프레임 수입니다. 대부분의 사용자는 이 매개 변수를 변경할 필요 가 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="47006074a4284de2d08115410e184f4134b3b4db" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. This should be a non-negative integer. Repeating 0 times will return an empty ExtensionArray.</source>
          <target state="translated">각 요소의 반복 횟수입니다. 음수가 아닌 정수 여야합니다. 0 번 반복하면 빈 ExtensionArray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e3d76fa5776dde4dda59b5857a1bba329a8a6b46" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. This should be a non-negative integer. Repeating 0 times will return an empty Index.</source>
          <target state="translated">각 요소의 반복 횟수입니다. 음수가 아닌 정수 여야합니다. 0 번 반복하면 빈 인덱스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="15edcd8a5a75ce34ddea34f766d0880ac228660a" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. This should be a non-negative integer. Repeating 0 times will return an empty Series.</source>
          <target state="translated">각 요소의 반복 횟수입니다. 음수가 아닌 정수 여야합니다. 0 번 반복하면 빈 시리즈가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="40ae1a37a68dd5ec1c2246d5ac317882309f2584" translate="yes" xml:space="preserve">
          <source>The number of rows to consider when letting the parser determine the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="959cc306d091367005395eec44ce05de49afa0f0" translate="yes" xml:space="preserve">
          <source>The number of rows to consider when letting the parser determine the &lt;code&gt;colspecs&lt;/code&gt;.</source>
          <target state="translated">파서가 &lt;code&gt;colspecs&lt;/code&gt; 를 결정할 때 고려할 행 수입니다 .</target>
        </trans-unit>
        <trans-unit id="82e164ec32726845601d2f74d0095ffcf8ffbe63" translate="yes" xml:space="preserve">
          <source>The number of rows to display in a truncated repr (when number of rows is above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92cfdb40506fd700fbb3f177793a4c6a457e3f5b" translate="yes" xml:space="preserve">
          <source>The number of rows to display in a truncated repr (when number of rows is above &lt;code&gt;max_rows&lt;/code&gt;).</source>
          <target state="translated">잘린 repr에 표시 할 행 수입니다 (행 수가 &lt;code&gt;max_rows&lt;/code&gt; 이상인 경우 ).</target>
        </trans-unit>
        <trans-unit id="8a0bd3a75794aff026881f916cdb87a80dc3bbab" translate="yes" xml:space="preserve">
          <source>The number of rows to display in the console in a truncated repr (when number of rows is above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae1f3ee233b89ab1b1a8eab54193e4f076d6e08" translate="yes" xml:space="preserve">
          <source>The number of rows to display in the console in a truncated repr (when number of rows is above &lt;code&gt;max_rows&lt;/code&gt;).</source>
          <target state="translated">콘솔에서 잘린 repr로 표시 할 행 수 (행 수가 &lt;code&gt;max_rows&lt;/code&gt; 이상인 경우 ).</target>
        </trans-unit>
        <trans-unit id="a161bdb7369b6797458c67801620fde2ecf83c3c" translate="yes" xml:space="preserve">
          <source>The number of the day of the week with Monday=0, Sunday=6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b38bd2f621d285d5c32cfcb37c37dc75f5b0052" translate="yes" xml:space="preserve">
          <source>The number of time periods the offset represents.</source>
          <target state="translated">오프셋이 나타내는 기간 수입니다.</target>
        </trans-unit>
        <trans-unit id="196627d39b3cb5f267e1f505601c220ca4958a82" translate="yes" xml:space="preserve">
          <source>The numbers of rows to show in a truncated repr (when &lt;code&gt;max_rows&lt;/code&gt; is exceeded). Ignored when &lt;code&gt;max_rows&lt;/code&gt; is set to None or 0. When set to None, follows the value of &lt;code&gt;max_rows&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464804744c7a5c0df622b4227eb4da30b7d3fa83" translate="yes" xml:space="preserve">
          <source>The numbers of rows to show in a truncated view (when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1351c99b7c959f89e54be94d2e1a1265070c0fe9" translate="yes" xml:space="preserve">
          <source>The numpy array interface.</source>
          <target state="translated">numpy 배열 인터페이스</target>
        </trans-unit>
        <trans-unit id="ee9d1ccbf76a8d92ad13842bb5d7bc2d95dab9da" translate="yes" xml:space="preserve">
          <source>The object for which the method is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d087a2185f9f2ce2d51d8e471c6b5735ce7a26eb" translate="yes" xml:space="preserve">
          <source>The object need not be a DatetimeIndex object. It just needs to have a dtype which has a timezone component.</source>
          <target state="translated">개체는 DatetimeIndex 개체 일 필요는 없습니다. 시간대 구성 요소가있는 dtype 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="7713e2048c0ec33d45f46762ede0a79ced9e7895" translate="yes" xml:space="preserve">
          <source>The object these flags are associated with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34e5f6f8853c4283e277968c201ce55d1d5f4d0" translate="yes" xml:space="preserve">
          <source>The object to check if is a number.</source>
          <target state="translated">확인할 객체가 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">확인할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9599253c71c374e636b175945937c556da3c792f" translate="yes" xml:space="preserve">
          <source>The object to convert to a datetime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab711c3e787b5164596a39faf31e9719e30d3b07" translate="yes" xml:space="preserve">
          <source>The offset length of the data that will be selected. For instance, &amp;lsquo;1M&amp;rsquo; will display all the rows having their index within the first month.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5473dabe137342dc567403171ff1aad8b6eebb" translate="yes" xml:space="preserve">
          <source>The offset length of the data that will be selected. For instance, &amp;lsquo;3D&amp;rsquo; will display all the rows having their index within the last 3 days.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b3057e6bef7de938da21b166ce3aa9f4c7c09f" translate="yes" xml:space="preserve">
          <source>The offset string or object representing target conversion.</source>
          <target state="translated">대상 변환을 나타내는 오프셋 문자열 또는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7fd06064d787a7bd93ef1a68f6a0a95bc7a6e9c0" translate="yes" xml:space="preserve">
          <source>The offset string or object representing target grouper conversion.</source>
          <target state="translated">대상 그룹화 변환을 나타내는 오프셋 문자열 또는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3b933a40b6644b1bc0ddd4d2c057d1d0c206332d" translate="yes" xml:space="preserve">
          <source>The offsets of the structure elements may be different depending on the architecture of the machine on which the file was created. Using a raw binary file format like this for general data storage is not recommended, as it is not cross platform. We recommended either HDF5 or parquet, both of which are supported by pandas&amp;rsquo; IO facilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa0fa3ce7fd23b1da15fa94cc8fb27100a7d952" translate="yes" xml:space="preserve">
          <source>The only positional indexing is via &lt;code&gt;iloc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4285a3753b6a4efedaa88014021aac24c26c3812" translate="yes" xml:space="preserve">
          <source>The optimized pandas data access methods &lt;code&gt;.loc&lt;/code&gt;, &lt;code&gt;.iloc&lt;/code&gt;, &lt;code&gt;.at&lt;/code&gt;, and &lt;code&gt;.iat&lt;/code&gt;, work as normal. The only difference is the return type (for getting) and that only values already in &lt;code&gt;categories&lt;/code&gt; can be assigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd4e4422bb66aa83975f998149f8b7eca42e213" translate="yes" xml:space="preserve">
          <source>The order is compared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9440d8a8ada22ec84a687cd7169bba0dc85c22" translate="yes" xml:space="preserve">
          <source>The order of the elements inside the Index object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12d7e3c7c46ccf79e518acf06683097f613c9c8" translate="yes" xml:space="preserve">
          <source>The ordinal day of the year</source>
          <target state="translated">연중 서부</target>
        </trans-unit>
        <trans-unit id="781d9d01ec66b9cf0b9b4b4fdfeadd723a7bfb88" translate="yes" xml:space="preserve">
          <source>The ordinal day of the year.</source>
          <target state="translated">연중 서부.</target>
        </trans-unit>
        <trans-unit id="dfffa32aeb8954cbca687d59d4e7aef4bc8e3901" translate="yes" xml:space="preserve">
          <source>The ordinal day of year</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42528dea8f596eb563751beb98944a2b556e2d2e" translate="yes" xml:space="preserve">
          <source>The original DataFrame sorted by the labels or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0558fc0b8332a66277879215002dcadd7579df5" translate="yes" xml:space="preserve">
          <source>The original ExtensionArray that factorize was called on.</source>
          <target state="translated">인수 분해 한 원래 ExtensionArray가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="7d4ccecdcedf6da45722ccaa2132ec9ba8e20790" translate="yes" xml:space="preserve">
          <source>The original Series sorted by the labels or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbdfe923514d50323bc3f52e5130523c675102b" translate="yes" xml:space="preserve">
          <source>The original Series sorted by the labels.</source>
          <target state="translated">레이블별로 정렬 된 원본 시리즈.</target>
        </trans-unit>
        <trans-unit id="0cf55ba53e8c3dd53f183f3a8e7ca54290f40243" translate="yes" xml:space="preserve">
          <source>The original object is not modified.</source>
          <target state="translated">원본 객체는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a23319e86098d86b6acc1057eda024f34da7959" translate="yes" xml:space="preserve">
          <source>The other Series or DataFrame to be compared with the first.</source>
          <target state="translated">다른 시리즈 또는 DataFrame은 첫 번째와 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="9e3c04ca7e25e85a7da10f2194d5eb699a35186b" translate="yes" xml:space="preserve">
          <source>The other object to compare against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0abc2dee3a83ba247c229eafab56dca3ed8e94" translate="yes" xml:space="preserve">
          <source>The other object to compute the dot product with its columns.</source>
          <target state="translated">열이있는 내적을 계산하는 다른 객체입니다.</target>
        </trans-unit>
        <trans-unit id="f1f1a6652562ca3f7dcdff42637ec365c0a715b0" translate="yes" xml:space="preserve">
          <source>The other object to compute the matrix product with.</source>
          <target state="translated">행렬 곱을 계산할 다른 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5bbc32ae89dfeeb2ac48cddaabb50db5baf7b5af" translate="yes" xml:space="preserve">
          <source>The other two forms mimic the parameters from &lt;code&gt;datetime.datetime&lt;/code&gt;. They can be passed by either position or keyword, but not both mixed together.</source>
          <target state="translated">다른 두 형식은 &lt;code&gt;datetime.datetime&lt;/code&gt; 의 매개 변수를 모방합니다 . 위치 나 키워드로 전달할 수 있지만 둘 다 혼합하여 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="38b4ff1309a0934f0c1c55a49d5cfff7a97c49b6" translate="yes" xml:space="preserve">
          <source>The output column names can be controlled by passing the desired column names and aggregations as keyword arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1eb51db48fd9e9413b65967398c8f8edb48e68" translate="yes" xml:space="preserve">
          <source>The output is more similar to a SQL table or a record array. The names for the columns derived from the index are the ones stored in the &lt;code&gt;names&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97428b0ccfaabfd8d098101e4400a125a4770266" translate="yes" xml:space="preserve">
          <source>The output of the mapping function applied to the index. If the function returns a tuple with more than one element a MultiIndex will be returned.</source>
          <target state="translated">색인에 적용된 맵핑 기능의 출력. 함수가 둘 이상의 요소를 가진 튜플을 반환하면 MultiIndex가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d34a0f3f2187a703d1f898f84a7d13bbbe6f96e8" translate="yes" xml:space="preserve">
          <source>The output shape of &lt;code&gt;func&lt;/code&gt; should match the input, i.e. if &lt;code&gt;x&lt;/code&gt; is the input row, column, or table (depending on &lt;code&gt;axis&lt;/code&gt;), then &lt;code&gt;func(x).shape == x.shape&lt;/code&gt; should be true.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 의 출력 모양은 입력과 일치해야합니다. 즉 &lt;code&gt;x&lt;/code&gt; 가 입력 행, 열 또는 테이블 인 경우 ( &lt;code&gt;axis&lt;/code&gt; 에 따라 ) &lt;code&gt;func(x).shape == x.shape&lt;/code&gt; 는 true 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d32a8e52ecf350f3d5a747b3c786e8bd6035a2e2" translate="yes" xml:space="preserve">
          <source>The output type will the be same as &amp;lsquo;left&amp;rsquo;, if it is a subclass of DataFrame.</source>
          <target state="translated">출력 유형이 DataFrame의 서브 클래스 인 경우 '왼쪽'과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a7e7e819cd5efa7bef2e642f3b82ef86112898d3" translate="yes" xml:space="preserve">
          <source>The pandas &lt;a href=&quot;../reference/api/pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; class and its subclasses can be viewed as implementing an &lt;em&gt;ordered multiset&lt;/em&gt;. Duplicates are allowed. However, if you try to convert an &lt;a href=&quot;../reference/api/pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; object with duplicate entries into a &lt;code&gt;set&lt;/code&gt;, an exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cc42eb84f71abb1f9799ed9c9d77f6c6cc8249" translate="yes" xml:space="preserve">
          <source>The pandas I/O API is a set of top level &lt;code&gt;reader&lt;/code&gt; functions accessed like &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;pandas.read_csv()&lt;/code&gt;&lt;/a&gt; that generally return a pandas object. The corresponding &lt;code&gt;writer&lt;/code&gt; functions are object methods that are accessed like &lt;a href=&quot;../reference/api/pandas.dataframe.to_csv#pandas.DataFrame.to_csv&quot;&gt;&lt;code&gt;DataFrame.to_csv()&lt;/code&gt;&lt;/a&gt;. Below is a table containing available &lt;code&gt;readers&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;.</source>
          <target state="translated">pandas I / O API는 일반적으로 pandas 객체를 반환하는 &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;pandas.read_csv()&lt;/code&gt; &lt;/a&gt; 와 같이 액세스되는 최상위 &lt;code&gt;reader&lt;/code&gt; 함수 세트입니다 . 해당 &lt;code&gt;writer&lt;/code&gt; 함수는 &lt;a href=&quot;../reference/api/pandas.dataframe.to_csv#pandas.DataFrame.to_csv&quot;&gt; &lt;code&gt;DataFrame.to_csv()&lt;/code&gt; &lt;/a&gt; 와 같이 액세스되는 객체 메소드입니다 . 다음은 사용 가능한 &lt;code&gt;readers&lt;/code&gt; 및 &lt;code&gt;writers&lt;/code&gt; 포함 된 표 입니다.</target>
        </trans-unit>
        <trans-unit id="ffdd816d618d71e3a0349561b67330e4d60ca510" translate="yes" xml:space="preserve">
          <source>The pandas method is &lt;a href=&quot;../../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt;, which works similarly.</source>
          <target state="translated">팬더 메소드는 &lt;a href=&quot;../../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt; 이며 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0c86bf97eefb0d383638157467b99c72d6c94a5e" translate="yes" xml:space="preserve">
          <source>The pandas method is &lt;a href=&quot;../../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt;, which works similarly. Additionally, it will automatically download the data set if presented with a url.</source>
          <target state="translated">팬더 메소드는 &lt;a href=&quot;../../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt; 이며 비슷하게 작동합니다. 또한 URL이 표시되면 데이터 세트를 자동으로 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="4214f7cb13c02200fc758d1ba653c7d3d2925135" translate="yes" xml:space="preserve">
          <source>The pandas object holding the data.</source>
          <target state="translated">데이터를 보유한 팬더 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9423579239adc49531138fc2ec69de376aff78d0" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;convert_categoricals&lt;/code&gt; indicates whether value labels should be read and used to create a &lt;code&gt;Categorical&lt;/code&gt; variable from them. Value labels can also be retrieved by the function &lt;code&gt;value_labels&lt;/code&gt;, which requires &lt;code&gt;read()&lt;/code&gt; to be called before use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdba1a6251a31d1d11915e8180ab555b9696f5e3" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;convert_missing&lt;/code&gt; indicates whether missing value representations in Stata should be preserved. If &lt;code&gt;False&lt;/code&gt; (the default), missing values are represented as &lt;code&gt;np.nan&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, missing values are represented using &lt;code&gt;StataMissingValue&lt;/code&gt; objects, and columns containing missing values will have &lt;code&gt;object&lt;/code&gt; data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154fc9da5946e72198b285401320afba7c319ce2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;float_precision&lt;/code&gt; can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0285bcf1631d4ffef7c8a713f91f06b76e207112" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;method&lt;/code&gt; controls the SQL insertion clause used. Possible values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39afd6ba609cb97c86b015c9b46c5cff79483803" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;others&lt;/code&gt; can also be two-dimensional. In this case, the number or rows must match the lengths of the calling &lt;code&gt;Series&lt;/code&gt; (or &lt;code&gt;Index&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ae859983ab7a49dbacf853ce7c16f74b170e40" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;return_type&lt;/code&gt; can be used to select the type of element returned by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b6a6580ef831365238a7968b818ece9e94c9ff3" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;return_type&lt;/code&gt; can be used to select the type of element returned by &lt;code&gt;boxplot&lt;/code&gt;. When &lt;code&gt;return_type='axes'&lt;/code&gt; is selected, the matplotlib axes on which the boxplot is drawn are returned:</source>
          <target state="translated">&lt;code&gt;return_type&lt;/code&gt; 매개 변수를 사용하여 &lt;code&gt;boxplot&lt;/code&gt; 이 리턴 한 요소 유형을 선택할 수 있습니다 . 경우 &lt;code&gt;return_type='axes'&lt;/code&gt; 선택하면, 상자 그림이 그려되는하기 matplotlib 축은 반환 :</target>
        </trans-unit>
        <trans-unit id="694b17a392c48aafa85d73c8f3addc51dc5351be" translate="yes" xml:space="preserve">
          <source>The parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5de879fb78cb203c4db8224a59c88f7e55e095" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; must be from the same type, you must be able to compare them and they must satisfy &lt;code&gt;left &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 의 매개 변수 는 같은 유형이어야하고, 비교할 수 있어야하고 &lt;code&gt;left &amp;lt;= right&lt;/code&gt; 만족시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="79a3658c4ab640187d72027736edb717444f98b3" translate="yes" xml:space="preserve">
          <source>The parameters are defined by their name, followed by a space, a colon, another space, and the type (or types). Note that the space between the name and the colon is important. Types are not defined for &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kwargs&lt;/code&gt;, but must be defined for all other parameters. After the parameter definition, it is required to have a line with the parameter description, which is indented, and can have multiple lines. The description must start with a capital letter, and finish with a dot.</source>
          <target state="translated">매개 변수는 이름, 공백, 콜론, 다른 공백 및 유형으로 정의됩니다. 이름과 콜론 사이의 공백이 중요합니다. 유형은 &lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kwargs&lt;/code&gt; 에 대해서는 정의되지 않지만 다른 모든 매개 변수에 대해서는 정의되어야합니다. 매개 변수 정의 후에는 들여 쓰기되고 여러 행을 가질 수있는 매개 변수 설명이있는 행이 있어야합니다. 설명은 대문자로 시작하고 점으로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="4c4021e99fcfe389611b00fa1e1e375ef6c28bda" translate="yes" xml:space="preserve">
          <source>The parser to use to construct the syntax tree from the expression. The default of &lt;code&gt;'pandas'&lt;/code&gt; parses code slightly different than standard Python. Alternatively, you can parse an expression using the &lt;code&gt;'python'&lt;/code&gt; parser to retain strict Python semantics. See the &lt;a href=&quot;../../user_guide/enhancingperf#enhancingperf-eval&quot;&gt;enhancing performance&lt;/a&gt; documentation for more details.</source>
          <target state="translated">표현식에서 구문 트리를 구성하는 데 사용할 구문 분석기입니다. &lt;code&gt;'pandas'&lt;/code&gt; 의 기본값은 표준 Python과 약간 다른 코드를 구문 분석합니다. 또는 &lt;code&gt;'python'&lt;/code&gt; 구문 분석기를 사용하여 표현식을 구문 분석하여 엄격한 Python 의미를 유지할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../../user_guide/enhancingperf#enhancingperf-eval&quot;&gt;성능 향상&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e40bf18b6f32cb437bd627807c3e78d0e7d6585b" translate="yes" xml:space="preserve">
          <source>The parser will raise one of &lt;code&gt;ValueError/TypeError/AssertionError&lt;/code&gt; if the JSON is not parseable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e46a74552f949a64566f1991bbf1f938044ecf48" translate="yes" xml:space="preserve">
          <source>The parser will take care of extra white spaces around the columns so it&amp;rsquo;s ok to have extra separation between the columns in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f93d00465af6bd614ffcd340267e10a825729a" translate="yes" xml:space="preserve">
          <source>The parsers make every attempt to &amp;ldquo;do the right thing&amp;rdquo; and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fd82d8138c348a77074696421439c48a77dec69" translate="yes" xml:space="preserve">
          <source>The parsing engine to use. &amp;lsquo;bs4&amp;rsquo; and &amp;lsquo;html5lib&amp;rsquo; are synonymous with each other, they are both there for backwards compatibility. The default of &lt;code&gt;None&lt;/code&gt; tries to use &lt;code&gt;lxml&lt;/code&gt; to parse and if that fails it falls back on &lt;code&gt;bs4&lt;/code&gt; + &lt;code&gt;html5lib&lt;/code&gt;.</source>
          <target state="translated">사용할 구문 분석 엔진 'bs4'와 'html5lib'는 서로 동의어이며 이전 버전과의 호환성을 위해 모두 있습니다. 기본값 &lt;code&gt;None&lt;/code&gt; 은 &lt;code&gt;lxml&lt;/code&gt; 을 사용 하여 구문 분석을 시도 하고 실패하면 &lt;code&gt;bs4&lt;/code&gt; + &lt;code&gt;html5lib&lt;/code&gt; 로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b8df3a595f6ce7aed51bebb759002941b8cca21" translate="yes" xml:space="preserve">
          <source>The partitions and divisions are how Dask parallelizes computation. A &lt;strong&gt;Dask&lt;/strong&gt; DataFrame is made up of many pandas DataFrames. A single method call on a Dask DataFrame ends up making many pandas method calls, and Dask knows how to coordinate everything to get the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d333f158e14ba9fe626200bbefd9154d8bcd52ff" translate="yes" xml:space="preserve">
          <source>The passed &lt;strong&gt;index&lt;/strong&gt; is a list of axis labels. Thus, this separates into a few cases depending on what &lt;strong&gt;data is&lt;/strong&gt;:</source>
          <target state="translated">전달 된 &lt;strong&gt;인덱스&lt;/strong&gt; 는 축 레이블 목록입니다. 따라서 이것은 &lt;strong&gt;데이터가&lt;/strong&gt; 무엇인지에 따라 몇 가지 경우로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab167ef68a23d1be76388d892b529c17afcd9ebd" translate="yes" xml:space="preserve">
          <source>The passed label if it is in the index. The previous label if the passed label is not in the sorted index or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae38d74ee55d7f4c3dcc093fdb2b6aaa449cd98b" translate="yes" xml:space="preserve">
          <source>The passed label if it is in the index. The previous label if the passed label is not in the sorted index or &lt;code&gt;NaN&lt;/code&gt; if there is no such label.</source>
          <target state="translated">전달 된 레이블이 색인에있는 경우 전달 된 레이블이 정렬 된 색인에없는 경우 이전 레이블 또는 해당 레이블이없는 경우 &lt;code&gt;NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4c9f0fbbfe09095e9388851be75453c8753da328" translate="yes" xml:space="preserve">
          <source>The passed name should substitute for the index name (if it has one).</source>
          <target state="translated">전달 된 이름은 색인 이름 (있는 경우)을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="7528c46a5415db3abf012226858d0ddd9a61d62c" translate="yes" xml:space="preserve">
          <source>The passed name should substitute for the series name (if it has one).</source>
          <target state="translated">전달 된 이름은 시리즈 이름 (있는 경우)을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0ad366f06aef948abcea11f57c9964c6207634e" translate="yes" xml:space="preserve">
          <source>The passed names should substitute index level names.</source>
          <target state="translated">전달 된 이름은 색인 레벨 이름을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="5617c3e9d3f80c864d2c7cb3cfff079617786cf3" translate="yes" xml:space="preserve">
          <source>The percent of non- &lt;code&gt;fill_value&lt;/code&gt; points, as decimal.</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 가 아닌 포인트 의 백분율 ( 10 진수)입니다.</target>
        </trans-unit>
        <trans-unit id="d7ecf9686ef63612456cba84e32f6d437116ce9e" translate="yes" xml:space="preserve">
          <source>The percentiles to include in the output. All should fall between 0 and 1. The default is &lt;code&gt;[.25, .5, .75]&lt;/code&gt;, which returns the 25th, 50th, and 75th percentiles.</source>
          <target state="translated">출력에 포함 할 백분위 수입니다. 모두 0과 1 사이 여야합니다. 기본값은 &lt;code&gt;[.25, .5, .75]&lt;/code&gt; 이며 25 번째, 50 번째 및 75 번째 백분위 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dd63300f51773c071035d8bd3b0bee2f2acf252" translate="yes" xml:space="preserve">
          <source>The period offset from the proleptic Gregorian epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498861ee03f506257904c047b87d22d1704fa649" translate="yes" xml:space="preserve">
          <source>The pipe method is inspired by unix pipes and more recently &lt;a href=&quot;https://github.com/hadley/dplyr&quot;&gt;dplyr&lt;/a&gt; and &lt;a href=&quot;https://github.com/smbache/magrittr&quot;&gt;magrittr&lt;/a&gt;, which have introduced the popular &lt;code&gt;(%&amp;gt;%)&lt;/code&gt; (read pipe) operator for &lt;a href=&quot;https://www.r-project.org&quot;&gt;R&lt;/a&gt;. The implementation of &lt;code&gt;pipe&lt;/code&gt; here is quite clean and feels right at home in Python. We encourage you to view the source code of &lt;a href=&quot;../reference/api/pandas.dataframe.pipe#pandas.DataFrame.pipe&quot;&gt;&lt;code&gt;pipe()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2a540928cdd1f3c06c973c8332b64d9d5993d7" translate="yes" xml:space="preserve">
          <source>The plotting backend to use. The default value is &amp;ldquo;matplotlib&amp;rdquo;, the backend provided with pandas. Other backends can be specified by providing the name of the module that implements the backend. [default: matplotlib] [currently: matplotlib]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83557ad7c919ab9a9b1f712d2de2ea1ff06a50b2" translate="yes" xml:space="preserve">
          <source>The point of using &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; for expression evaluation rather than plain Python is two-fold: 1) large &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; objects are evaluated more efficiently and 2) large arithmetic and boolean expressions are evaluated all at once by the underlying engine (by default &lt;code&gt;numexpr&lt;/code&gt; is used for evaluation).</source>
          <target state="translated">일반 파이썬이 아닌 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 을 표현식 평가 에 사용하는 요점 은 두 가지입니다. 1) 큰 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 객체가보다 효율적으로 평가되고 2) 큰 산술 및 부울 표현식이 기본 엔진에 의해 한 번에 모두 평가됩니다 (기본적으로 &lt;code&gt;numexpr&lt;/code&gt; 은 평가에 사용).</target>
        </trans-unit>
        <trans-unit id="be427a8952488ee8f61241c6ad57d3b3b2d3167c" translate="yes" xml:space="preserve">
          <source>The precision at which to store and display the bins labels</source>
          <target state="translated">쓰레기통 레이블을 저장하고 표시하는 정밀도</target>
        </trans-unit>
        <trans-unit id="57429d5886e7ba042042f676a2b920c29c33e221" translate="yes" xml:space="preserve">
          <source>The precision at which to store and display the bins labels.</source>
          <target state="translated">빈 레이블을 저장하고 표시 할 정밀도입니다.</target>
        </trans-unit>
        <trans-unit id="de5d4bb5543f5a8133d26857a4c1e4e955e527c5" translate="yes" xml:space="preserve">
          <source>The precision of the datetime data.</source>
          <target state="translated">날짜 / 시간 데이터의 정밀도</target>
        </trans-unit>
        <trans-unit id="f9710306c5002505d79c0c09a6d07b88cc1b7396" translate="yes" xml:space="preserve">
          <source>The precision of the datetime data. Currently limited to &lt;code&gt;&quot;ns&quot;&lt;/code&gt;.</source>
          <target state="translated">날짜 / 시간 데이터의 정밀도 현재 &lt;code&gt;&quot;ns&quot;&lt;/code&gt; 로 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2dfb1ac164a40993bcb469925530fa7677de1a0" translate="yes" xml:space="preserve">
          <source>The presence of ignored lines might create ambiguities involving line numbers; the parameter &lt;code&gt;header&lt;/code&gt; uses row numbers (ignoring commented/empty lines), while &lt;code&gt;skiprows&lt;/code&gt; uses line numbers (including commented/empty lines):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f000a4fda3527c7e5a6de47aae328431a119eb01" translate="yes" xml:space="preserve">
          <source>The previous expression is equivalent to</source>
          <target state="translated">이전 식은</target>
        </trans-unit>
        <trans-unit id="81571d6fe4da0960d36d1e4460bed6c0e62846b7" translate="yes" xml:space="preserve">
          <source>The previous section outlined how to get pandas installed as part of the &lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;Anaconda&lt;/a&gt; distribution. However this approach means you will install well over one hundred packages and involves downloading the installer which is a few hundred megabytes in size.</source>
          <target state="translated">이전 섹션에서는 &lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;Anaconda&lt;/a&gt; 배포판의 일부로 팬더를 설치하는 방법을 설명했습니다 . 그러나이 방법은 100 개가 넘는 패키지를 설치하고 수백 메가 바이트 크기의 설치 프로그램을 다운로드하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2c4f33eac36d7d1cf8e9af8a61eec0c8e5105cd6" translate="yes" xml:space="preserve">
          <source>The primary function for changing frequencies is the &lt;a href=&quot;../reference/api/pandas.series.asfreq#pandas.Series.asfreq&quot;&gt;&lt;code&gt;asfreq()&lt;/code&gt;&lt;/a&gt; method. For a &lt;code&gt;DatetimeIndex&lt;/code&gt;, this is basically just a thin, but convenient wrapper around &lt;a href=&quot;../reference/api/pandas.series.reindex#pandas.Series.reindex&quot;&gt;&lt;code&gt;reindex()&lt;/code&gt;&lt;/a&gt; which generates a &lt;code&gt;date_range&lt;/code&gt; and calls &lt;code&gt;reindex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67d5185f11003735d7d2d9c662740dd3c5f8d8f" translate="yes" xml:space="preserve">
          <source>The primary use-case for an &lt;code&gt;ExcelFile&lt;/code&gt; is parsing multiple sheets with different parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15e4aeffc28fdbd20d778af18415dcababb42a8" translate="yes" xml:space="preserve">
          <source>The problem in the previous section is just a performance issue. What&amp;rsquo;s up with the &lt;code&gt;SettingWithCopy&lt;/code&gt; warning? We don&amp;rsquo;t &lt;strong&gt;usually&lt;/strong&gt; throw warnings around when you do something that might cost a few extra milliseconds!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e64a5d07441d316eb5582810d9adcc8b0cbef3" translate="yes" xml:space="preserve">
          <source>The product of an empty or all-NA Series or column of a DataFrame is 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b6372f8ba5918b2514ba3de128789845449131c" translate="yes" xml:space="preserve">
          <source>The projection after squeezing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6cbf36401a0168146dab10473ea89163457e025" translate="yes" xml:space="preserve">
          <source>The projection after squeezing &lt;code&gt;axis&lt;/code&gt; or all the axes.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 또는 모든 축을 압착 한 후의 투영 입니다.</target>
        </trans-unit>
        <trans-unit id="83b2b6ccd17651243ca689f0aff2ceb8f5876883" translate="yes" xml:space="preserve">
          <source>The quantile(s) to compute, which can lie in range: 0 &amp;lt;= q &amp;lt;= 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba0468015416064736b88ddb16912307af4c5cd4" translate="yes" xml:space="preserve">
          <source>The quarter number that has the leap or 14 week when needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81acc1e74b2d94e9cf84073a96c1a2a569b64f34" translate="yes" xml:space="preserve">
          <source>The quarter of the date</source>
          <target state="translated">날짜의 분기</target>
        </trans-unit>
        <trans-unit id="fb1ac70a76670d547fc833eee5881cc01f39bb40" translate="yes" xml:space="preserve">
          <source>The quarter of the date.</source>
          <target state="translated">날짜의 분기입니다.</target>
        </trans-unit>
        <trans-unit id="ed6a95641faa4360749c47adbedb6f267d1e7629" translate="yes" xml:space="preserve">
          <source>The query string to evaluate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b89ca2fbea8da348417aafb60e88f9bb50c32f" translate="yes" xml:space="preserve">
          <source>The query string to evaluate. You can refer to variables in the environment by prefixing them with an &amp;lsquo;@&amp;rsquo; character like &lt;code&gt;@a + b&lt;/code&gt;.</source>
          <target state="translated">평가할 쿼리 문자열입니다. &lt;code&gt;@a + b&lt;/code&gt; 와 같은 '@'문자를 접두어로 붙여 환경에서 변수를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccbedc4fae33867a448a75b731505e79e7da4275" translate="yes" xml:space="preserve">
          <source>The query() Method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396c61e446d440b8a9522c2879a8becaf9230655" translate="yes" xml:space="preserve">
          <source>The range really is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;61&lt;/code&gt;; this accounts for leap seconds and the (very rare) double leap seconds.</source>
          <target state="translated">범위는 실제로 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;61&lt;/code&gt; 입니다 . 이것은 윤초와 (매우 드문) 이중 윤초를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cf8c568c4446072ef4ab5af22af744498002448c" translate="yes" xml:space="preserve">
          <source>The reason that the &lt;code&gt;MultiIndex&lt;/code&gt; matters is that it can allow you to do grouping, selection, and reshaping operations as we will describe below and in subsequent areas of the documentation. As you will see in later sections, you can find yourself working with hierarchically-indexed data without creating a &lt;code&gt;MultiIndex&lt;/code&gt; explicitly yourself. However, when loading data from a file, you may wish to generate your own &lt;code&gt;MultiIndex&lt;/code&gt; when preparing the data set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd668de4a29e13c343aa508392a3bbec94aae6dd" translate="yes" xml:space="preserve">
          <source>The recognized win_types are:</source>
          <target state="translated">인식되는 win_type은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa0bd697b5dab0a14a15490a3d7a3ae0844e8f85" translate="yes" xml:space="preserve">
          <source>The recommended function for creating a StringArray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3979c99cb21827cf224bc9fc57bef9660f460a9c" translate="yes" xml:space="preserve">
          <source>The reference guide contains a detailed description of the pandas API. The reference describes how the methods work and which parameters can be used. It assumes that you have an understanding of the key concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61e5f62bbdecf31b9d993a940bedbe8bfcd96e83" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;../reference/api/pandas.dataframe.join#pandas.DataFrame.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method, uses &lt;code&gt;merge&lt;/code&gt; internally for the index-on-index (by default) and column(s)-on-index join. If you are joining on index only, you may wish to use &lt;code&gt;DataFrame.join&lt;/code&gt; to save yourself some typing.</source>
          <target state="translated">관련 &lt;a href=&quot;../reference/api/pandas.dataframe.join#pandas.DataFrame.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 메서드 는 인덱스에 대한 인덱스 (기본적으로)와 인덱스에 대한 열에 대해 내부적으로 &lt;code&gt;merge&lt;/code&gt; 사용합니다 . 인덱스에만 참여하는 경우 &lt;code&gt;DataFrame.join&lt;/code&gt; 을 사용 하여 입력 내용 을 저장 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f89fac8b115ae5f611e3c15c9a2a689bab87c2e" translate="yes" xml:space="preserve">
          <source>The relativedelta type is designed to be applied to an existing datetime an can replace specific components of that datetime, or represents an interval of time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f69cafc1b64f0d14abd5ded16ab91ecf8785eb" translate="yes" xml:space="preserve">
          <source>The remaining methods implemented on this class should be performant, as they only compose abstract methods. Still, a more efficient implementation may be available, and these methods can be overridden.</source>
          <target state="translated">이 클래스에서 구현 된 나머지 메소드는 추상 메소드 만 작성하므로 성능이 우수해야합니다. 여전히 더 효율적인 구현이 가능할 수 있으며 이러한 방법을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b47d0d9e49c48dd6e7ef5093ac4fd92844e9343" translate="yes" xml:space="preserve">
          <source>The rendered HTML.</source>
          <target state="translated">렌더링 된 HTML.</target>
        </trans-unit>
        <trans-unit id="0c1c63f1968f84668b48e66abc28dfad0698e93a" translate="yes" xml:space="preserve">
          <source>The replacement is taken from other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc977d020d40ed896df75cc3efc5b723d20f579" translate="yes" xml:space="preserve">
          <source>The required number of columns (3) is inferred from the number of series to plot and the given number of rows (2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8cf862416c25604a0aebe9bb600983f9f3ab55" translate="yes" xml:space="preserve">
          <source>The required number of valid values to perform the operation. If fewer than &lt;code&gt;min_count&lt;/code&gt; non-NA values are present the result will be NA.</source>
          <target state="translated">작업을 수행하는 데 필요한 유효한 값 수입니다. 비 NA 값이 &lt;code&gt;min_count&lt;/code&gt; 보다 적 으면 결과는 NA입니다.</target>
        </trans-unit>
        <trans-unit id="77121a6f2e4e9ea8aefafc47f9e2107160a25003" translate="yes" xml:space="preserve">
          <source>The rest of this document will summarize all the above guides, and will provide additional convention specific to the pandas project.</source>
          <target state="translated">이 문서의 나머지 부분은 위의 모든 가이드를 요약하고 팬더 프로젝트에 특정한 추가 규칙을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f507b83bbd19dd93de0c570db561ae474ad2f17" translate="yes" xml:space="preserve">
          <source>The result object is a &lt;code&gt;DataFrame&lt;/code&gt; having potentially hierarchical indexes on the rows and columns. If the &lt;code&gt;values&lt;/code&gt; column name is not given, the pivot table will include all of the data that can be aggregated in an additional level of hierarchy in the columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f753708e872b43ec2446dd45b5054da7f9094ca6" translate="yes" xml:space="preserve">
          <source>The result of &lt;a href=&quot;../reference/api/pandas.series.unique#pandas.Series.unique&quot;&gt;&lt;code&gt;unique()&lt;/code&gt;&lt;/a&gt; is not always the same as &lt;code&gt;Series.cat.categories&lt;/code&gt;, because &lt;code&gt;Series.unique()&lt;/code&gt; has a couple of guarantees, namely that it returns categories in the order of appearance, and it only includes values that are actually present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4428ffc81a2892f8a933e9f33183d4e545f3dd1b" translate="yes" xml:space="preserve">
          <source>The result of an operation between unaligned Series will have the &lt;strong&gt;union&lt;/strong&gt; of the indexes involved. If a label is not found in one Series or the other, the result will be marked as missing &lt;code&gt;NaN&lt;/code&gt;. Being able to write code without doing any explicit data alignment grants immense freedom and flexibility in interactive data analysis and research. The integrated data alignment features of the pandas data structures set pandas apart from the majority of related tools for working with labeled data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e41e5807a4424c226250fdf6422f0b21e3839b" translate="yes" xml:space="preserve">
          <source>The result of calling &lt;code&gt;boxplot&lt;/code&gt; is a dictionary whose keys are the values of our grouping column &lt;code&gt;g&lt;/code&gt; (&amp;ldquo;A&amp;rdquo; and &amp;ldquo;B&amp;rdquo;). The values of the resulting dictionary can be controlled by the &lt;code&gt;return_type&lt;/code&gt; keyword of &lt;code&gt;boxplot&lt;/code&gt;. See the &lt;a href=&quot;visualization#visualization-box&quot;&gt;visualization documentation&lt;/a&gt; for more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d2e0bdb9f8e4d995d148a9da5086f6251f488b" translate="yes" xml:space="preserve">
          <source>The result of combining the Series with the other object.</source>
          <target state="translated">Series를 다른 객체와 결합한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="7828da3cdb6360b2d1e00710bcb0b180c180a45d" translate="yes" xml:space="preserve">
          <source>The result of the evaluation of this expression is first passed to &lt;a href=&quot;pandas.dataframe.loc#pandas.DataFrame.loc&quot;&gt;&lt;code&gt;DataFrame.loc&lt;/code&gt;&lt;/a&gt; and if that fails because of a multidimensional key (e.g., a DataFrame) then the result will be passed to &lt;code&gt;DataFrame.__getitem__()&lt;/code&gt;.</source>
          <target state="translated">이 표현식의 평가 결과는 먼저 &lt;a href=&quot;pandas.dataframe.loc#pandas.DataFrame.loc&quot;&gt; &lt;code&gt;DataFrame.loc&lt;/code&gt; 에&lt;/a&gt; 전달되고 다차원 키 (예 : DataFrame)로 인해 실패하면 결과는 &lt;code&gt;DataFrame.__getitem__()&lt;/code&gt; 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="d66b88fc77a0c492a747d9bf0c572452d1024c9f" translate="yes" xml:space="preserve">
          <source>The result of the evaluation or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5a5f27b55d1f0280a61cdc1b3a967d55f8456f" translate="yes" xml:space="preserve">
          <source>The result of the evaluation.</source>
          <target state="translated">평가 결과.</target>
        </trans-unit>
        <trans-unit id="5b1c264300cd8b658cc8b4e315b7758a06a23af7" translate="yes" xml:space="preserve">
          <source>The result of the operation.</source>
          <target state="translated">작업 결과.</target>
        </trans-unit>
        <trans-unit id="25bf033f760c5bfd2c2566086601887f701fdc3f" translate="yes" xml:space="preserve">
          <source>The result of the prior setting operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4f0a92a01eb8eaf27e7204ab4ea21eee0a6872" translate="yes" xml:space="preserve">
          <source>The result will be a DataFrame with the same index as the input Series, and with one column whose name is the original name of the Series (only if no other column name provided).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48bf7f15ffb2daed9751bcf55c501148cd5600c1" translate="yes" xml:space="preserve">
          <source>The result will only be true at a location if all the labels match. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55bcf90539d00645ed644427ca20760852c7ac2c" translate="yes" xml:space="preserve">
          <source>The result will only be true at a location if all the labels match. If &lt;code&gt;values&lt;/code&gt; is a Series, that&amp;rsquo;s the index. If &lt;code&gt;values&lt;/code&gt; is a dict, the keys must be the column names, which must match. If &lt;code&gt;values&lt;/code&gt; is a DataFrame, then both the index and column labels must match.</source>
          <target state="translated">모든 레이블이 일치하는 경우에만 결과가 적용됩니다. 경우 &lt;code&gt;values&lt;/code&gt; 일련의, 즉 인덱스입니다. 경우 &lt;code&gt;values&lt;/code&gt; 사전인가이며, 키는 일치해야합니다 열 이름이어야합니다. 경우 &lt;code&gt;values&lt;/code&gt; DataFrame이며, 다음 인덱스 및 열 레이블 모두 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="72edb09d1d54732565c113dbc37ba4fe13169bfe" translate="yes" xml:space="preserve">
          <source>The result will respect the original ordering of the associated factor at that level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f7e4b6a9222a047c23851b51f8d2aa36ff1ea1f" translate="yes" xml:space="preserve">
          <source>The resulting &lt;strong&gt;index&lt;/strong&gt; will be the &lt;strong&gt;union&lt;/strong&gt; of the indexes of the various Series. If there are any nested dicts, these will first be converted to Series. If no columns are passed, the columns will be the ordered list of dict keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a81bc866c8cf80d7ed032edef232760b9f8c3550" translate="yes" xml:space="preserve">
          <source>The resulting MultiIndex will have the same outward appearance, meaning the same .values and ordering. It will also be .equals() to the original.</source>
          <target state="translated">결과 MultiIndex는 동일한 외형을 가지므로 동일한 .values ​​및 순서를 의미합니다. 또한 원본과 .equals ()가됩니다.</target>
        </trans-unit>
        <trans-unit id="816ce3359ab0d5319372a173543ecf1df4f117e7" translate="yes" xml:space="preserve">
          <source>The resulting aggregations are named for the functions themselves. If you need to rename, then you can add in a chained operation for a &lt;code&gt;Series&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1d81e9fcc51e7155d40abe62aa6a16ff8d1006" translate="yes" xml:space="preserve">
          <source>The resulting docstrings are</source>
          <target state="translated">결과 docstring은</target>
        </trans-unit>
        <trans-unit id="5ad58e47f121a34aa29c576caac543e0fef337a8" translate="yes" xml:space="preserve">
          <source>The resulting index from a set operation will be sorted in ascending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45dc11790bba48a466676e29a59569e109b61ea8" translate="yes" xml:space="preserve">
          <source>The resulting index will be a MultiIndex with &amp;lsquo;self&amp;rsquo; and &amp;lsquo;other&amp;rsquo; stacked alternately at the inner level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8366275c19d6dbfefea3e3555fd2ab1c88ed49" translate="yes" xml:space="preserve">
          <source>The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default.</source>
          <target state="translated">결과 개체는 내림차순으로되어 첫 번째 요소가 가장 자주 발생하는 요소입니다. 기본적으로 NA 값을 제외합니다.</target>
        </trans-unit>
        <trans-unit id="1490e9a7fc98d64acac99d497e98444507d28fbd" translate="yes" xml:space="preserve">
          <source>The return can be:</source>
          <target state="translated">반품은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7b85b33b7c02a04deda36103dc52578bc9f0295" translate="yes" xml:space="preserve">
          <source>The return type (Categorical or Series) depends on the input: a Series of type category if input is a Series else Categorical. Bins are represented as categories when categorical data is returned.</source>
          <target state="translated">반환 유형 (범주 또는 시리즈)은 입력에 따라 달라집니다. 입력이 시리즈 인 경우 범주 유형 인 시리즈 범주입니다. 범주 형 데이터가 반환되면 빈은 범주로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="462063dedec304bf5591f9de7894de01c3b3449c" translate="yes" xml:space="preserve">
          <source>The return type depends on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1627476263193587edd221c596b8faa83658a58f" translate="yes" xml:space="preserve">
          <source>The return type depends on the &lt;code&gt;return_type&lt;/code&gt; parameter:</source>
          <target state="translated">리턴 유형은 &lt;code&gt;return_type&lt;/code&gt; 매개 변수 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6fc03cf5512dfead4a071ad0851e52519788f49d" translate="yes" xml:space="preserve">
          <source>The return type here may change to return a different array type in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b0b8b7a1793e7f1af6d8f6d3829a5059ac4f7a" translate="yes" xml:space="preserve">
          <source>The return type of the function passed to &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; affects the type of the final output from &lt;code&gt;DataFrame.apply&lt;/code&gt; for the default behaviour:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992ffa7f4ae029ba5642dde9b52cccad7cbc2cfd" translate="yes" xml:space="preserve">
          <source>The return type will be the same as &lt;code&gt;left&lt;/code&gt;. If &lt;code&gt;left&lt;/code&gt; is a &lt;code&gt;DataFrame&lt;/code&gt; or named &lt;code&gt;Series&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; is a subclass of &lt;code&gt;DataFrame&lt;/code&gt;, the return type will still be &lt;code&gt;DataFrame&lt;/code&gt;.</source>
          <target state="translated">반환 유형은 &lt;code&gt;left&lt;/code&gt; 와 동일합니다 . 경우 &lt;code&gt;left&lt;/code&gt; A는 &lt;code&gt;DataFrame&lt;/code&gt; 또는 명명 된 &lt;code&gt;Series&lt;/code&gt; 와 &lt;code&gt;right&lt;/code&gt; 의 서브 클래스입니다 &lt;code&gt;DataFrame&lt;/code&gt; , 반환 형식은 여전히 것 &lt;code&gt;DataFrame&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19eac7fe642bd7922cc180e34397455a3373d440" translate="yes" xml:space="preserve">
          <source>The returned &lt;code&gt;Series&lt;/code&gt; (or &lt;code&gt;DataFrame&lt;/code&gt;) is of the same type as if you used the &lt;code&gt;.str.&amp;lt;method&amp;gt;&lt;/code&gt; / &lt;code&gt;.dt.&amp;lt;method&amp;gt;&lt;/code&gt; on a &lt;code&gt;Series&lt;/code&gt; of that type (and not of type &lt;code&gt;category&lt;/code&gt;!).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69caeadfc4994089f42006f4a6d4646ee6d8c17" translate="yes" xml:space="preserve">
          <source>The returned Series will have a MultiIndex with one level per input column. By default, rows that contain any NA values are omitted from the result. By default, the resulting Series will be in descending order so that the first element is the most frequently-occurring row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a41179e8e7fd829f59f3d3ce3001a941aba613" translate="yes" xml:space="preserve">
          <source>The returned array will be the same up to equality (values equal in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed476228c85f69922821770cf70d3b9926420909" translate="yes" xml:space="preserve">
          <source>The returned array will be the same up to equality (values equal in &lt;code&gt;self&lt;/code&gt; will be equal in the returned array; likewise for values that are not equal). When &lt;code&gt;self&lt;/code&gt; contains an ExtensionArray, the dtype may be different. For example, for a category-dtype Series, &lt;code&gt;to_numpy()&lt;/code&gt; will return a NumPy array and the categorical dtype will be lost.</source>
          <target state="translated">반환 된 배열은 동일성까지 동일합니다 ( &lt;code&gt;self&lt;/code&gt; 와 같은 값 은 반환 된 배열에서 동일합니다; 같은 값이 아닌 경우). 때 &lt;code&gt;self&lt;/code&gt; ExtensionArray을 포함는 DTYPE 다를 수 있습니다. 예를 들어, category-dtype Series의 경우 &lt;code&gt;to_numpy()&lt;/code&gt; 는 NumPy 배열을 반환하고 categorical 형 dtype은 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="1d90add3c23a71c8a50369e9c916a879637fb926" translate="yes" xml:space="preserve">
          <source>The returned dtype of the grouped will &lt;em&gt;always&lt;/em&gt; include &lt;em&gt;all&lt;/em&gt; of the categories that were grouped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc63ad043059ec87269a3f973d4a64c262c4a5a" translate="yes" xml:space="preserve">
          <source>The right frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97070018703d1892bcbc77658f21f57665590a38" translate="yes" xml:space="preserve">
          <source>The right-hand side of the sub-expression (after a comparison operator) can be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a9b245b6b6f3094e60c2559a8e59157767111b" translate="yes" xml:space="preserve">
          <source>The rolling count of any non-NaN observations inside the window.</source>
          <target state="translated">창 내부의 비 NaN 관측치의 롤링 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="17c3af82d229d6f5306c8ce848fa78bfd222ec1f" translate="yes" xml:space="preserve">
          <source>The rolling function&amp;rsquo;s apply function.</source>
          <target state="translated">롤링 기능의 적용 기능.</target>
        </trans-unit>
        <trans-unit id="2c72e549282f6aa72b084cdbb9c83b3d9574f499" translate="yes" xml:space="preserve">
          <source>The rotation angle of labels (in degrees) with respect to the screen coordinate system.</source>
          <target state="translated">화면 좌표계에 대한 레이블의 회전 각도 (도)입니다.</target>
        </trans-unit>
        <trans-unit id="c0b6193d2f72888279a1fdbd1c9a96e81e230f67" translate="yes" xml:space="preserve">
          <source>The row (or list of rows for a &lt;a href=&quot;pandas.multiindex#pandas.MultiIndex&quot;&gt;&lt;code&gt;MultiIndex&lt;/code&gt;&lt;/a&gt;) to use to make the columns headers.</source>
          <target state="translated">열 머리글을 만드는 데 사용할 행 또는 &lt;a href=&quot;pandas.multiindex#pandas.MultiIndex&quot;&gt; &lt;code&gt;MultiIndex&lt;/code&gt; &lt;/a&gt; 의 행 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="05644d7a93bdd0e01e7f9ad3b24ac1b682051e67" translate="yes" xml:space="preserve">
          <source>The row and column labels can be accessed respectively by accessing the &lt;strong&gt;index&lt;/strong&gt; and &lt;strong&gt;columns&lt;/strong&gt; attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f5302b7291118fbb4dbdbea0ca878bb4c42a01" translate="yes" xml:space="preserve">
          <source>The row labels to use for lookup</source>
          <target state="translated">조회에 사용할 행 레이블</target>
        </trans-unit>
        <trans-unit id="4b68bed8715612a80adeba131d3174d5a494ef62" translate="yes" xml:space="preserve">
          <source>The row labels to use for lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c22c406ec31cff4ceff340a2e4e272f75b08b81" translate="yes" xml:space="preserve">
          <source>The row/column index do not need to have the same type, as long as the values are considered equal. Corresponding columns must be of the same dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5a8d2bcf85aa0f93fd842db77e3c9d45bfdd7e" translate="yes" xml:space="preserve">
          <source>The same alignment can be used when &lt;code&gt;others&lt;/code&gt; is a &lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67330693d3bb863416fb8a4c93c3e6c8ae5c5b0a" translate="yes" xml:space="preserve">
          <source>The same as above, but with &lt;code&gt;how='inner'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d67548ce33d87067f8a4dbe7d0fe1b0b23e7238" translate="yes" xml:space="preserve">
          <source>The same expression can be &amp;ldquo;anded&amp;rdquo; together with the word &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#and&quot;&gt;&lt;code&gt;and&lt;/code&gt;&lt;/a&gt; as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac3c60bbe9f4ba8822cd1fa9905352887893505" translate="yes" xml:space="preserve">
          <source>The same holds for writing to a SQL database with &lt;code&gt;to_sql&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33834171e7bb7daf6dbbf7d464ba98f1f6bf0d4b" translate="yes" xml:space="preserve">
          <source>The same method is available for &lt;code&gt;Index&lt;/code&gt; objects and is useful for the cases when you don&amp;rsquo;t know which of the sought labels are in fact present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ed927022d23f68868325e3665965a9704bad19" translate="yes" xml:space="preserve">
          <source>The same operation in pandas can be accomplished using the &lt;code&gt;where&lt;/code&gt; method from &lt;code&gt;numpy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numpy&lt;/code&gt; 의 &lt;code&gt;where&lt;/code&gt; 메소드를 사용하여 팬더에서 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ce2662e1d97b02d60bc4c1a7b9ba6899f6bf524" translate="yes" xml:space="preserve">
          <source>The same operations are expressed in pandas below.</source>
          <target state="translated">동일한 작업이 아래 팬더로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dafc67ac697fccf7f09cb94d41ef73e708f72b36" translate="yes" xml:space="preserve">
          <source>The same operations are expressed in pandas below. Note that in contrast to Stata, these operations do not happen in place. To make these changes persist, assign the operation back to a variable.</source>
          <target state="translated">동일한 작업이 아래 팬더로 표시됩니다. Stata와 달리 이러한 작업은 수행되지 않습니다. 이러한 변경 사항을 유지하려면 작업을 변수에 다시 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="b619d64cb5bbd09fa2b34f9b097a172788750135" translate="yes" xml:space="preserve">
          <source>The same string used as an indexing parameter can be treated either as a slice or as an exact match depending on the resolution of the index. If the string is less accurate than the index, it will be treated as a slice, otherwise as an exact match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c58708e3e3fba35ca4dbb71be213768210f6fea" translate="yes" xml:space="preserve">
          <source>The same type as the caller or None if &lt;code&gt;inplace&lt;/code&gt; is True.</source>
          <target state="translated">발신자와 동일한 유형이거나 &lt;code&gt;inplace&lt;/code&gt; 가 True 인 경우 없음 입니다.</target>
        </trans-unit>
        <trans-unit id="7169ea2b33ae81985df552d9380c64d8054c9ff6" translate="yes" xml:space="preserve">
          <source>The same type as the caller or None if &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2def2a71e9091c25f4bd78f38c1a40f038788cc3" translate="yes" xml:space="preserve">
          <source>The same type as the caller or None if inplace is True.</source>
          <target state="translated">발신자와 동일한 유형이거나 내부가 True 인 경우 없음입니다.</target>
        </trans-unit>
        <trans-unit id="dfceee1030c2e014080cf766cc5aca8ed23ad2fc" translate="yes" xml:space="preserve">
          <source>The same type as the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76721095f49027e5d5ed7d0c406345eb56ad4a10" translate="yes" xml:space="preserve">
          <source>The same type as the calling object.</source>
          <target state="translated">호출 객체와 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7d3ae2acaf1f2f03ee68f1176046396918ed9196" translate="yes" xml:space="preserve">
          <source>The same type as the original data with boolean values. Series will have the same name and index. DatetimeIndex will have the same name.</source>
          <target state="translated">부울 값이있는 원래 데이터와 동일한 유형입니다. 시리즈의 이름과 색인은 동일합니다. DatetimeIndex의 이름은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e524037682385113145ba1a6cfa1ec7a2b8cf010" translate="yes" xml:space="preserve">
          <source>The same type as the original data. Series will have the same name and index. DatetimeIndex will have the same name.</source>
          <target state="translated">원본 데이터와 동일한 유형입니다. 시리즈의 이름과 색인은 동일합니다. DatetimeIndex의 이름은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0b081816c89d86a8ebcce6b7631f9e7a90b78ccb" translate="yes" xml:space="preserve">
          <source>The scalar fill value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969186d0efcdfa245b2cc072d16a13c0ed6d9422" translate="yes" xml:space="preserve">
          <source>The scalar type for the array, e.g.</source>
          <target state="translated">배열의 스칼라 타입</target>
        </trans-unit>
        <trans-unit id="6cf6b0ba062bda0294a4cc687f93e7ec0c48bff7" translate="yes" xml:space="preserve">
          <source>The scalar type for the array, e.g. &lt;code&gt;int&lt;/code&gt;</source>
          <target state="translated">배열의 스칼라 형식 (예 : &lt;code&gt;int&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="33f33206a8b39c0c8d06952dc1d65c7aef9861e5" translate="yes" xml:space="preserve">
          <source>The scalar value not stored in the SparseArray. By default, this depends on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59a0191d22d6c839516b1560d1e8d4049142780b" translate="yes" xml:space="preserve">
          <source>The scalar value not stored in the SparseArray. By default, this depends on &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">스칼라 값이 SparseArray에 저장되지 않았습니다. 기본적으로 이것은 &lt;code&gt;dtype&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6e0482321604d069759152b59a7e63107414cc4a" translate="yes" xml:space="preserve">
          <source>The scalar value to use for newly introduced missing values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b1d771ab2f0aa3d89199585b56883e43ca8f70" translate="yes" xml:space="preserve">
          <source>The scalar value to use for newly introduced missing values. The default is &lt;code&gt;self.dtype.na_value&lt;/code&gt;</source>
          <target state="translated">새로 도입 된 결 측값에 사용할 스칼라 값입니다. 기본값은 &lt;code&gt;self.dtype.na_value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59cb6101dfe2a91b01c6772614d91a9201b1534f" translate="yes" xml:space="preserve">
          <source>The scalar value to use for newly introduced missing values. The default is &lt;code&gt;self.dtype.na_value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9702ede5559c6092747b01ffa4d36aff9618bfa6" translate="yes" xml:space="preserve">
          <source>The scalar value to use for newly introduced missing values. the default depends on the dtype of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a091cef3cca53dec3318d7dad8abe0239c9140e7" translate="yes" xml:space="preserve">
          <source>The scalar value to use for newly introduced missing values. the default depends on the dtype of &lt;code&gt;self&lt;/code&gt;. For numeric data, &lt;code&gt;np.nan&lt;/code&gt; is used. For datetime, timedelta, or period data, etc. &lt;code&gt;NaT&lt;/code&gt; is used. For extension dtypes, &lt;code&gt;self.dtype.na_value&lt;/code&gt; is used.</source>
          <target state="translated">새로 도입 된 결 측값에 사용할 스칼라 값입니다. 기본값은 &lt;code&gt;self&lt;/code&gt; 의 dtype에 따라 다릅니다 . 숫자 데이터의 경우 &lt;code&gt;np.nan&lt;/code&gt; 이 사용됩니다. 날짜 시간, 타임 델타 또는 기간 데이터 등의 경우 &lt;code&gt;NaT&lt;/code&gt; 가 사용됩니다. 확장 dtype의 경우 &lt;code&gt;self.dtype.na_value&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd1b2f99ef6b33ef2e9dae57ba8be1de006f898" translate="yes" xml:space="preserve">
          <source>The scalars inside</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a770eefca45b5b72cb7aed7f41dc5b3b5e9faffe" translate="yes" xml:space="preserve">
          <source>The scalars inside &lt;code&gt;data&lt;/code&gt; should be instances of the scalar type for &lt;code&gt;dtype&lt;/code&gt;. It&amp;rsquo;s expected that &lt;code&gt;data&lt;/code&gt; represents a 1-dimensional array of data.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 내부 의 스칼라는 &lt;code&gt;dtype&lt;/code&gt; 에 대한 스칼라 유형의 인스턴스 여야합니다 . &lt;code&gt;data&lt;/code&gt; 는 1 차원 데이터 배열을 나타내는 것으로 예상 됩니다.</target>
        </trans-unit>
        <trans-unit id="6da03a0d2aa81134a8747096e5636bd439b2dcc2" translate="yes" xml:space="preserve">
          <source>The script verifies the linting of code files, it looks for common mistake patterns (like missing spaces around sphinx directives that make the documentation not being rendered properly) and it also validates the doctests. It is possible to run the checks independently by using the parameters &lt;code&gt;lint&lt;/code&gt;, &lt;code&gt;patterns&lt;/code&gt; and &lt;code&gt;doctests&lt;/code&gt; (e.g. &lt;code&gt;./ci/code_checks.sh lint&lt;/code&gt;).</source>
          <target state="translated">이 스크립트는 코드 파일의 보푸라기를 확인하고, 일반적인 실수 패턴 (문서가 올바르게 렌더링되지 않도록하는 스핑크스 지시문 주위의 누락 된 공간)을 찾고 문서 검사를 검증합니다. &lt;code&gt;lint&lt;/code&gt; , &lt;code&gt;patterns&lt;/code&gt; 및 &lt;code&gt;doctests&lt;/code&gt; 매개 변수 (예 : &lt;code&gt;./ci/code_checks.sh lint&lt;/code&gt; ) 를 사용하여 독립적으로 검사를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdc31b4660a8563222bb0144021e41774b0c7364" translate="yes" xml:space="preserve">
          <source>The search for the pattern &amp;lsquo;Monkey&amp;rsquo; returns one match:</source>
          <target state="translated">패턴 'Monkey'를 검색하면 하나의 일치 항목이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a405dfb764231139a687e0c98e53959c00b35247" translate="yes" xml:space="preserve">
          <source>The second approach assumes that the underlying elements (i.e., scalar type) of the &lt;code&gt;ExtensionArray&lt;/code&gt; have the individual operators already defined. In other words, if your &lt;code&gt;ExtensionArray&lt;/code&gt; named &lt;code&gt;MyExtensionArray&lt;/code&gt; is implemented so that each element is an instance of the class &lt;code&gt;MyExtensionElement&lt;/code&gt;, then if the operators are defined for &lt;code&gt;MyExtensionElement&lt;/code&gt;, the second approach will automatically define the operators for &lt;code&gt;MyExtensionArray&lt;/code&gt;.</source>
          <target state="translated">두 번째 방법은 &lt;code&gt;ExtensionArray&lt;/code&gt; 의 기본 요소 (예 : 스칼라 유형)에 개별 연산자가 이미 정의되어 있다고 가정합니다 . 귀하의 경우 즉, &lt;code&gt;ExtensionArray&lt;/code&gt; 이름 &lt;code&gt;MyExtensionArray&lt;/code&gt; 는 각각의 요소는 클래스의 인스턴스이다 구현 &lt;code&gt;MyExtensionElement&lt;/code&gt; 연산자가 정의되어 있다면, &lt;code&gt;MyExtensionElement&lt;/code&gt; , 두 번째 방법은 자동으로의 운영자 정의합니다 &lt;code&gt;MyExtensionArray&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="ce22c3d75627eac730bb497bb6b1db829d3abf79" translate="yes" xml:space="preserve">
          <source>The second argument is &lt;code&gt;sheet_name&lt;/code&gt;, not to be confused with &lt;code&gt;ExcelFile.sheet_names&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6529adc320db4b51995c0a488dbac6f07c7a4c" translate="yes" xml:space="preserve">
          <source>The second calling convention will modify the names of the corresponding index if mapper is a list or a scalar. However, if mapper is dict-like or a function, it will use the deprecated behavior of modifying the axis &lt;em&gt;labels&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca52b010fa605f2ee4f369f8cb284449e3e438f6" translate="yes" xml:space="preserve">
          <source>The second calling convention will modify the names of the the corresponding index if mapper is a list or a scalar. However, if mapper is dict-like or a function, it will use the deprecated behavior of modifying the axis &lt;em&gt;labels&lt;/em&gt;.</source>
          <target state="translated">매퍼가 목록 또는 스칼라 인 경우 두 번째 호출 규칙은 해당 인덱스의 이름을 수정합니다. 그러나 매퍼가 dict-like 또는 함수 인 경우 축 &lt;em&gt;레이블&lt;/em&gt; 을 수정하는 더 이상 사용되지 않는 동작을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="20cf86ed12883db56bee543431ec72b9c320a05c" translate="yes" xml:space="preserve">
          <source>The second field, &lt;code&gt;data&lt;/code&gt;, contains the serialized data with the &lt;code&gt;records&lt;/code&gt; orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf780186b806afbce21ef49aef1ed5b9ec915424" translate="yes" xml:space="preserve">
          <source>The second of the Period (ranges from 0 to 59).</source>
          <target state="translated">기간의 두 번째 (0-59 범위)</target>
        </trans-unit>
        <trans-unit id="b472b678a28517514097b064aeba5a58ced4265f" translate="yes" xml:space="preserve">
          <source>The second of the period</source>
          <target state="translated">기간의 두 번째</target>
        </trans-unit>
        <trans-unit id="d9cb19cbb4f738ad9c53c0fb9dd4efd10d5d780b" translate="yes" xml:space="preserve">
          <source>The second of the period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161a425167b938cf9b6ea3da9a1ca7786b69f189" translate="yes" xml:space="preserve">
          <source>The seconds of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5943d41ff125fb9b0a9be1fb0bab2715346540" translate="yes" xml:space="preserve">
          <source>The seconds of the datetime.</source>
          <target state="translated">날짜 시간의 초입니다.</target>
        </trans-unit>
        <trans-unit id="a9792f4cc99b9e9433600b925b441c008f8dec71" translate="yes" xml:space="preserve">
          <source>The selected object</source>
          <target state="translated">선택된 개체</target>
        </trans-unit>
        <trans-unit id="1885cda70a693e6364cfa8821b2ce9a251f3c509" translate="yes" xml:space="preserve">
          <source>The selected object. Return type depends on the object stored.</source>
          <target state="translated">선택된 객체. 반환 유형은 저장된 객체에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6f096a589404b0f7d892fa987b34705168322fa5" translate="yes" xml:space="preserve">
          <source>The sentinel &lt;code&gt;pandas.api.extensions.no_default&lt;/code&gt; is used as the default value in some methods. Use an &lt;code&gt;is&lt;/code&gt; comparison to check if the user provides a non-default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb8beac10a213cb79dd5e3765a93bcbe4de6398" translate="yes" xml:space="preserve">
          <source>The separator between the different elements/columns. By default the empty string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad769e26717baa8515cdc19a2f2284a46a175a8" translate="yes" xml:space="preserve">
          <source>The separator between the different elements/columns. By default the empty string &lt;code&gt;&amp;lsquo;&amp;rsquo;&lt;/code&gt; is used.</source>
          <target state="translated">다른 요소 / 열 사이의 구분 기호입니다. 기본적으로 빈 문자열 &lt;code&gt;&amp;lsquo;&amp;rsquo;&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4398e142a656cf9e480c3f6602870954fcb067b2" translate="yes" xml:space="preserve">
          <source>The sequence of values to test. Passing in a single string will raise a &lt;code&gt;TypeError&lt;/code&gt;. Instead, turn a single string into a list of one element.</source>
          <target state="translated">테스트 할 값의 순서입니다. 단일 문자열을 전달하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생 합니다. 대신 단일 문자열을 하나의 요소 목록으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="6449473cbc55300f624baf6317ec0107782fd312" translate="yes" xml:space="preserve">
          <source>The set of tables containing text matching this regex or string will be returned. Unless the HTML is extremely simple you will probably need to pass a non-empty string here. Defaults to &amp;lsquo;.+&amp;rsquo; (match any non-empty string). The default value will return all tables contained on a page. This value is converted to a regular expression so that there is consistent behavior between Beautiful Soup and lxml.</source>
          <target state="translated">이 정규식 또는 문자열과 일치하는 텍스트가 포함 된 테이블 집합이 반환됩니다. HTML이 매우 단순하지 않으면 비어 있지 않은 문자열을 여기에 전달해야합니다. 기본값은 '. +'입니다 (빈 문자열이 아닌 문자열과 일치). 기본값은 페이지에 포함 된 모든 테이블을 반환합니다. 이 값은 정규 표현식으로 변환되어 Beautiful Soup과 lxml간에 일관된 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f5bd8d0dc32dcec6e6de368b7412f98affbe15" translate="yes" xml:space="preserve">
          <source>The short summary is a single sentence that expresses what the function does in a concise way.</source>
          <target state="translated">짧은 요약은 함수가하는 일을 간결하게 표현하는 한 문장입니다.</target>
        </trans-unit>
        <trans-unit id="1a871becb3793790d2424c4ec96b5ddbba1d1a6b" translate="yes" xml:space="preserve">
          <source>The short summary must start with a capital letter, end with a dot, and fit in a single line. It needs to express what the object does without providing details. For functions and methods, the short summary must start with an infinitive verb.</source>
          <target state="translated">짧은 요약은 대문자로 시작하고 점으로 끝나고 한 줄에 맞아야합니다. 세부 사항을 제공하지 않고 객체의 기능을 표현해야합니다. 함수와 메소드의 경우 짧은 요약은 부정사로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6150e4ec28654d176310ec4f54aa268555d2133" translate="yes" xml:space="preserve">
          <source>The shorthands &amp;lsquo;s&amp;rsquo; and &amp;lsquo;e&amp;rsquo; are provided for convenience:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e2cd4be526759f8759f0ec9f7bdd368cb0c45f" translate="yes" xml:space="preserve">
          <source>The signature for &lt;a href=&quot;#pandas.DataFrame.where&quot;&gt;&lt;code&gt;DataFrame.where()&lt;/code&gt;&lt;/a&gt; differs from &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where&quot;&gt;&lt;code&gt;numpy.where()&lt;/code&gt;&lt;/a&gt;. Roughly &lt;code&gt;df1.where(m, df2)&lt;/code&gt; is equivalent to &lt;code&gt;np.where(m, df1, df2)&lt;/code&gt;.</source>
          <target state="translated">대한 서명 &lt;a href=&quot;#pandas.DataFrame.where&quot;&gt; &lt;code&gt;DataFrame.where()&lt;/code&gt; &lt;/a&gt; 다르다 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where&quot;&gt; &lt;code&gt;numpy.where()&lt;/code&gt; &lt;/a&gt; . 대략 &lt;code&gt;df1.where(m, df2)&lt;/code&gt; 하는 것과 동일 &lt;code&gt;np.where(m, df1, df2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf7ac616a994db9bf4551e0bd1547558bfcd86d0" translate="yes" xml:space="preserve">
          <source>The signature for &lt;a href=&quot;#pandas.DataFrame.where&quot;&gt;&lt;code&gt;DataFrame.where()&lt;/code&gt;&lt;/a&gt; differs from &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where&quot;&gt;&lt;code&gt;numpy.where()&lt;/code&gt;&lt;/a&gt;. Roughly &lt;code&gt;df1.where(m, df2)&lt;/code&gt; is equivalent to &lt;code&gt;np.where(m, df1, df2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705e09423e3739fc7350ae5a367e60e82a939e9a" translate="yes" xml:space="preserve">
          <source>The signature for &lt;a href=&quot;../reference/api/pandas.dataframe.where#pandas.DataFrame.where&quot;&gt;&lt;code&gt;DataFrame.where()&lt;/code&gt;&lt;/a&gt; differs from &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where&quot;&gt;&lt;code&gt;numpy.where()&lt;/code&gt;&lt;/a&gt;. Roughly &lt;code&gt;df1.where(m, df2)&lt;/code&gt; is equivalent to &lt;code&gt;np.where(m, df1, df2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ffe018315752fd3ac08196adfc88ff2920411e" translate="yes" xml:space="preserve">
          <source>The signature for &lt;a href=&quot;pandas.dataframe.where#pandas.DataFrame.where&quot;&gt;&lt;code&gt;DataFrame.where()&lt;/code&gt;&lt;/a&gt; differs from &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where&quot;&gt;&lt;code&gt;numpy.where()&lt;/code&gt;&lt;/a&gt;. Roughly &lt;code&gt;df1.where(m, df2)&lt;/code&gt; is equivalent to &lt;code&gt;np.where(m, df1, df2)&lt;/code&gt;.</source>
          <target state="translated">대한 서명 &lt;a href=&quot;pandas.dataframe.where#pandas.DataFrame.where&quot;&gt; &lt;code&gt;DataFrame.where()&lt;/code&gt; &lt;/a&gt; 다르다 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html#numpy.where&quot;&gt; &lt;code&gt;numpy.where()&lt;/code&gt; &lt;/a&gt; . 대략 &lt;code&gt;df1.where(m, df2)&lt;/code&gt; 는 &lt;code&gt;np.where(m, df1, df2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb8c170fd66a4fe034726bc59b75fa9317d48824" translate="yes" xml:space="preserve">
          <source>The signature for &lt;a href=&quot;pandas.dataframe.where#pandas.DataFrame.where&quot;&gt;&lt;code&gt;DataFrame.where()&lt;/code&gt;&lt;/a&gt; differs from &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where&quot;&gt;&lt;code&gt;numpy.where()&lt;/code&gt;&lt;/a&gt;. Roughly &lt;code&gt;df1.where(m, df2)&lt;/code&gt; is equivalent to &lt;code&gt;np.where(m, df1, df2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f0e456562deff5fd168dd3c5bee9309941635d" translate="yes" xml:space="preserve">
          <source>The simplest case is to just pass in &lt;code&gt;parse_dates=True&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e83009ed13e6b800b3d0b66b63aef94ce3a4a83" translate="yes" xml:space="preserve">
          <source>The simplest way to install not only pandas, but Python and the most popular packages that make up the &lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; stack (&lt;a href=&quot;http://ipython.org/&quot;&gt;IPython&lt;/a&gt;, &lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt;, &lt;a href=&quot;http://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;, &amp;hellip;) is with &lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;Anaconda&lt;/a&gt;, a cross-platform (Linux, Mac OS X, Windows) Python distribution for data analytics and scientific computing.</source>
          <target state="translated">팬더뿐만 아니라 Python 및 &lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; 스택 을 구성하는 가장 인기있는 패키지 ( &lt;a href=&quot;http://ipython.org/&quot;&gt;IPython&lt;/a&gt; , &lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; , &lt;a href=&quot;http://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt; ...) 를 설치하는 가장 간단한 방법 은&lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;&lt;/a&gt; 은 크로스 플랫폼 (Linux, Mac OS X, Windows) Python 배포판 인 Anaconda 데이터 분석 및 과학 컴퓨팅 용.</target>
        </trans-unit>
        <trans-unit id="6084268f233e1450833b27bd478bea44ec0b0aaf" translate="yes" xml:space="preserve">
          <source>The size in inches of the figure to create. Uses the value in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89006e04fb6ae06ee69fd7e1cbc4ebb84ff9c33" translate="yes" xml:space="preserve">
          <source>The size in inches of the figure to create. Uses the value in &lt;code&gt;matplotlib.rcParams&lt;/code&gt; by default.</source>
          <target state="translated">만들 그림의 크기 (인치)입니다. 의 값을 사용합니다 &lt;code&gt;matplotlib.rcParams&lt;/code&gt; 을 기본적으로 .</target>
        </trans-unit>
        <trans-unit id="53f7fb3bd331e115151c971690f334a92a305fd6" translate="yes" xml:space="preserve">
          <source>The size of each point. Possible values are:</source>
          <target state="translated">각 점의 크기입니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14c9c83909e4848a4c6d5e202dfef089c8a143a6" translate="yes" xml:space="preserve">
          <source>The size of the figure to create in matplotlib.</source>
          <target state="translated">matplotlib에서 작성할 그림의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5ff105db7b62462e2a7db748acf24891a045782b" translate="yes" xml:space="preserve">
          <source>The sparse objects exist for memory efficiency reasons. Suppose you had a large, mostly NA &lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="translated">희소 오브젝트는 메모리 효율성 이유로 존재합니다. 주로 NA &lt;code&gt;DataFrame&lt;/code&gt; 이 큰 것으로 가정하십시오. .</target>
        </trans-unit>
        <trans-unit id="21491ee1e399c47977d700d8c4fc58f6ab7cf717" translate="yes" xml:space="preserve">
          <source>The sparse representation of the DataFrame.</source>
          <target state="translated">DataFrame의 스파 스 표현입니다.</target>
        </trans-unit>
        <trans-unit id="b6ce02e970660791adeb2a1b77033fc6e43f7a8e" translate="yes" xml:space="preserve">
          <source>The specific value that should be omitted in the representation.</source>
          <target state="translated">표현에서 생략해야하는 특정 값입니다.</target>
        </trans-unit>
        <trans-unit id="992bb47a1a1917911b8cb193e543bbaa905be0d6" translate="yes" xml:space="preserve">
          <source>The speedup is less noticeable for smaller datasets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed464cacc736babb9a482e5c2b4bdbde5f5886b2" translate="yes" xml:space="preserve">
          <source>The standard uses reStructuredText (reST). reStructuredText is a markup language that allows encoding styles in plain text files. Documentation about reStructuredText can be found in:</source>
          <target state="translated">표준은 reST (reStructuredText)를 사용합니다. reStructuredText는 일반 텍스트 파일에서 스타일을 인코딩 할 수있는 마크 업 언어입니다. reStructuredText에 대한 문서는 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb6df5de7403c8e074d4cf96020630dc5553f71f" translate="yes" xml:space="preserve">
          <source>The strftime to parse time, eg &amp;ldquo;%d/%m/%Y&amp;rdquo;, note that &amp;ldquo;%f&amp;rdquo; will parse all the way up to nanoseconds. See strftime documentation for more information on choices: &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7938de812df15b4c7f2dff2b2bc6d499384b5d54" translate="yes" xml:space="preserve">
          <source>The string &amp;lsquo;infer&amp;rsquo; can be passed in order to set the frequency of the index as the inferred frequency upon creation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ae224e1ad2ce0d741cc3dd98863178b4269431" translate="yes" xml:space="preserve">
          <source>The string methods are available on Series backed by a StringArray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a0024707ce6e868dc8e2ee7584df319e601097" translate="yes" xml:space="preserve">
          <source>The string methods on Index are especially useful for cleaning up or transforming DataFrame columns. For instance, you may have columns with leading or trailing whitespace:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6171a4b413ddb813b8222a05f0e307ce39e3d30d" translate="yes" xml:space="preserve">
          <source>The string to add after each label.</source>
          <target state="translated">각 레이블 다음에 추가 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="20eea1819d2cfaf5ede1b0c9dddb5e2987931f2d" translate="yes" xml:space="preserve">
          <source>The string to add before each label.</source>
          <target state="translated">각 레이블 앞에 추가 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e2a7787c19da5d9e4b440b588d51994c786871e2" translate="yes" xml:space="preserve">
          <source>The stub name(s). The wide format variables are assumed to start with the stub names.</source>
          <target state="translated">스텁 이름 와이드 형식 변수는 스텁 이름으로 시작한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cb0480a8d28f11c46cb6415359fbce5045ea3ab1" translate="yes" xml:space="preserve">
          <source>The styling is accomplished using CSS. You write &amp;ldquo;style functions&amp;rdquo; that take scalars, &lt;code&gt;DataFrame&lt;/code&gt;s or &lt;code&gt;Series&lt;/code&gt;, and return &lt;em&gt;like-indexed&lt;/em&gt; DataFrames or Series with CSS &lt;code&gt;&quot;attribute: value&quot;&lt;/code&gt; pairs for the values. These functions can be incrementally passed to the &lt;code&gt;Styler&lt;/code&gt; which collects the styles before rendering.</source>
          <target state="translated">스타일링은 CSS를 사용하여 수행됩니다. 스칼라, &lt;code&gt;DataFrame&lt;/code&gt; 또는 &lt;code&gt;Series&lt;/code&gt; 를 사용 하는 &quot;스타일 함수&quot;를 작성 하고 값에 대해 CSS &lt;code&gt;&quot;attribute: value&quot;&lt;/code&gt; 쌍을 사용하여 &lt;em&gt;유사 색인화 된&lt;/em&gt; DataFrame 또는 Series를 반환 합니다. 이 함수들은 점차 &lt;code&gt;Styler&lt;/code&gt; 전달 될 수 있습니다 렌더링 전에 스타일을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="f362be9a6fc2af852ab14b2442846ba0b909bd74" translate="yes" xml:space="preserve">
          <source>The subplots above are split by the numeric columns first, then the value of the &lt;code&gt;g&lt;/code&gt; column. Below the subplots are first split by the value of &lt;code&gt;g&lt;/code&gt;, then by the numeric columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfa745d900c548f7039279ba3cb8ff238739a67" translate="yes" xml:space="preserve">
          <source>The subset of columns to write. Writes all columns by default.</source>
          <target state="translated">쓸 열의 하위 집합입니다. 기본적으로 모든 열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="4f66cf675d25a00e7660e8f4a72e9879d1b16c49" translate="yes" xml:space="preserve">
          <source>The subset of the frame including the dtypes in &lt;code&gt;include&lt;/code&gt; and excluding the dtypes in &lt;code&gt;exclude&lt;/code&gt;.</source>
          <target state="translated">dtype을 &lt;code&gt;include&lt;/code&gt; 하는 프레임의 부분 집합은 include 의 dtype을 &lt;code&gt;exclude&lt;/code&gt; 하고 제외 합니다.</target>
        </trans-unit>
        <trans-unit id="7f64cc0217ebadf278338340fd7545b83ba5b572" translate="yes" xml:space="preserve">
          <source>The sum of an empty or all-NA Series or column of a DataFrame is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9ee7c4f1ccacaeccbb7145f0c75c07626d0acd" translate="yes" xml:space="preserve">
          <source>The table below summarizes the behavior of &lt;code&gt;extract(expand=False)&lt;/code&gt; (input subject in first column, number of groups in regex in first row)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafdc56f2bad794cd13f6d56f11b1618571b6a78" translate="yes" xml:space="preserve">
          <source>The tests can then be run directly inside your Git clone (without having to install &lt;em&gt;pandas&lt;/em&gt;) by typing:</source>
          <target state="translated">그런 다음 다음 을 입력 하여 Git 복제본 내에서 직접 &lt;em&gt;판다&lt;/em&gt; 를 설치할 필요없이 테스트를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c6514c43ab66f1cedea6c97f6a9816832c61bb4" translate="yes" xml:space="preserve">
          <source>The tests suite is exhaustive and takes around 20 minutes to run. Often it is worth running only a subset of tests first around your changes before running the entire suite.</source>
          <target state="translated">테스트 스위트는 철저하며 실행하는 데 약 20 분이 걸립니다. 전체 제품군을 실행하기 전에 변경 사항에 대해 먼저 테스트 하위 집합 만 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c835b3919e5ffc758acddd29f1e42650751cca0f" translate="yes" xml:space="preserve">
          <source>The things that are being compared are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f12ff793291a6139a55f35cafd81cc03023aee1" translate="yes" xml:space="preserve">
          <source>The time component of the date-time is converted to midnight i.e. 00:00:00. This is useful in cases, when the time does not matter. Length is unaltered. The timezones are unaffected.</source>
          <target state="translated">날짜-시간의 시간 구성 요소는 자정 (예 : 00:00:00)으로 변환됩니다. 시간이 중요하지 않은 경우에 유용합니다. 길이는 변경되지 않습니다. 시간대는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4e10232a5d9217463d843a989410e61594a3162" translate="yes" xml:space="preserve">
          <source>The time period represented (e.g., &amp;lsquo;4Q2005&amp;rsquo;)</source>
          <target state="translated">표현 된 기간 (예 : '4Q2005')</target>
        </trans-unit>
        <trans-unit id="1a0d9bbbf2eeeb4b61d86e9605784356233b98e3" translate="yes" xml:space="preserve">
          <source>The time period represented (e.g., &amp;lsquo;4Q2005&amp;rsquo;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aca2bb6fbf1021901f563fbb0adfed6ab2e42c3" translate="yes" xml:space="preserve">
          <source>The time unit to encode to, governs timestamp and ISO8601 precision. One of &amp;lsquo;s&amp;rsquo;, &amp;lsquo;ms&amp;rsquo;, &amp;lsquo;us&amp;rsquo;, &amp;lsquo;ns&amp;rsquo; for second, millisecond, microsecond, and nanosecond respectively.</source>
          <target state="translated">인코딩 할 시간 단위는 타임 스탬프 및 ISO8601 정밀도를 제어합니다. 's', 'ms', 'us', 'ns'는 각각 초, 밀리 초, 마이크로 초 및 나노초입니다.</target>
        </trans-unit>
        <trans-unit id="99c96d9925eb2e486400896a41e7e9e0e6c3dc2d" translate="yes" xml:space="preserve">
          <source>The timedelta data.</source>
          <target state="translated">타임 델타 데이터.</target>
        </trans-unit>
        <trans-unit id="c4bd16b06415404dc0750cae0a3d7d3977217855" translate="yes" xml:space="preserve">
          <source>The timestamp on which to adjust the grouping. The timezone of origin must match the timezone of the index. If a timestamp is not used, these values are also supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="008f8045b2c87cc99a6d58ebc6aebfb93fd88c32" translate="yes" xml:space="preserve">
          <source>The timestamp unit to detect if converting dates. The default behaviour is to try and detect the correct precision, but if this is not desired then pass one of &amp;lsquo;s&amp;rsquo;, &amp;lsquo;ms&amp;rsquo;, &amp;lsquo;us&amp;rsquo; or &amp;lsquo;ns&amp;rsquo; to force parsing only seconds, milliseconds, microseconds or nanoseconds respectively.</source>
          <target state="translated">날짜 변환 여부를 감지 할 타임 스탬프 단위입니다. 기본 동작은 정확한 정밀도를 시도하고 감지하는 것이지만 이것이 바람직하지 않은 경우 's', 'ms', 'us'또는 'ns'중 하나를 전달하여 각각 초, 밀리 초, 마이크로 초 또는 나노초 만 구문 분석하도록합니다.</target>
        </trans-unit>
        <trans-unit id="40192af83c21441509117fb84b2b969ad948f740" translate="yes" xml:space="preserve">
          <source>The timezone.</source>
          <target state="translated">시간대.</target>
        </trans-unit>
        <trans-unit id="b8f276c3d93dd614dc3db7bfa9287b5a4a3cd326" translate="yes" xml:space="preserve">
          <source>The title of the section will be defined in the same way as the &amp;ldquo;Parameters&amp;rdquo;. With the names &amp;ldquo;Returns&amp;rdquo; or &amp;ldquo;Yields&amp;rdquo; followed by a line with as many hyphens as the letters in the preceding word.</source>
          <target state="translated">섹션의 제목은&amp;ldquo;매개 변수&amp;rdquo;와 같은 방식으로 정의됩니다. &amp;ldquo;Returns&amp;rdquo;또는&amp;ldquo;Yields&amp;rdquo;라는 이름과 함께 앞 단어의 글자 수만큼 하이픈이있는 줄이옵니다.</target>
        </trans-unit>
        <trans-unit id="097184ed57c2e9a4751aef2afb198e97f525b3a5" translate="yes" xml:space="preserve">
          <source>The top-level &lt;a href=&quot;../reference/api/pandas.melt#pandas.melt&quot;&gt;&lt;code&gt;melt()&lt;/code&gt;&lt;/a&gt; function and the corresponding &lt;a href=&quot;../reference/api/pandas.dataframe.melt#pandas.DataFrame.melt&quot;&gt;&lt;code&gt;DataFrame.melt()&lt;/code&gt;&lt;/a&gt; are useful to massage a &lt;code&gt;DataFrame&lt;/code&gt; into a format where one or more columns are &lt;em&gt;identifier variables&lt;/em&gt;, while all other columns, considered &lt;em&gt;measured variables&lt;/em&gt;, are &amp;ldquo;unpivoted&amp;rdquo; to the row axis, leaving just two non-identifier columns, &amp;ldquo;variable&amp;rdquo; and &amp;ldquo;value&amp;rdquo;. The names of those columns can be customized by supplying the &lt;code&gt;var_name&lt;/code&gt; and &lt;code&gt;value_name&lt;/code&gt; parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e652b677dcedacedf57b2f867d7fd1af99deca7" translate="yes" xml:space="preserve">
          <source>The top-level &lt;code&gt;read_html()&lt;/code&gt; function can accept an HTML string/file/URL and will parse HTML tables into list of pandas &lt;code&gt;DataFrames&lt;/code&gt;. Let&amp;rsquo;s look at a few examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f6cab82becc4967939d1cdc4d8722ad1f8bb50" translate="yes" xml:space="preserve">
          <source>The top-level function &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; implements expression evaluation of &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">최상위 함수 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 객체 의 표현식 평가를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="470963f117d67eea955cb345d31d411c701c62c0" translate="yes" xml:space="preserve">
          <source>The top-level function &lt;a href=&quot;../reference/api/pandas.read_sas#pandas.read_sas&quot;&gt;&lt;code&gt;read_sas()&lt;/code&gt;&lt;/a&gt; can read (but not write) SAS XPORT (.xpt) and (since &lt;em&gt;v0.18.0&lt;/em&gt;) SAS7BDAT (.sas7bdat) format files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad3218927c7e6076f13de7b3f8d9af21c0cf12f" translate="yes" xml:space="preserve">
          <source>The top-level function &lt;a href=&quot;../reference/api/pandas.read_spss#pandas.read_spss&quot;&gt;&lt;code&gt;read_spss()&lt;/code&gt;&lt;/a&gt; can read (but not write) SPSS SAV (.sav) and ZSAV (.zsav) format files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916f32999bcf9bb7d6f0ad9a9f3f68f6c237fa12" translate="yes" xml:space="preserve">
          <source>The top-level function &lt;code&gt;read_stata&lt;/code&gt; will read a dta file and return either a &lt;code&gt;DataFrame&lt;/code&gt; or a &lt;code&gt;StataReader&lt;/code&gt; that can be used to read the file incrementally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9313258cf31294cf78f2d7a82a367b9d96411090" translate="yes" xml:space="preserve">
          <source>The transformed values should maintain the ordering between values within the array.</source>
          <target state="translated">변환 된 값은 배열 내 값 사이의 순서를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="cea1b44d768d7ebd55958215afdd1402a550788d" translate="yes" xml:space="preserve">
          <source>The transposed DataFrame.</source>
          <target state="translated">전치 된 DataFrame입니다.</target>
        </trans-unit>
        <trans-unit id="0927348f5c944712027e84fbf0c644bbc38a20ec" translate="yes" xml:space="preserve">
          <source>The truncated Series or DataFrame.</source>
          <target state="translated">잘린 Series 또는 DataFrame입니다.</target>
        </trans-unit>
        <trans-unit id="f214cb7ca5640a92eef9de5b786b5636fb3c19f3" translate="yes" xml:space="preserve">
          <source>The tutorials make heavy use of the &lt;a href=&quot;http://matplotlib.org/sampledoc/ipython_directive.html&quot;&gt;ipython directive&lt;/a&gt; sphinx extension. This directive lets you put code in the documentation which will be run during the doc build. For example:</source>
          <target state="translated">튜토리얼은 &lt;a href=&quot;http://matplotlib.org/sampledoc/ipython_directive.html&quot;&gt;ipython 지시문&lt;/a&gt; 스핑크스 확장 을 많이 사용 합니다. 이 지시문을 사용하면 문서 빌드 중에 실행될 문서에 코드를 넣을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e67faa044eb2259bf3cbe0652f863ad1fd82067b" translate="yes" xml:space="preserve">
          <source>The two arrays to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d16833f874ca6074686de27136ae10e3b28f38" translate="yes" xml:space="preserve">
          <source>The two main operations are &lt;code&gt;union&lt;/code&gt; and &lt;code&gt;intersection&lt;/code&gt;. Difference is provided via the &lt;code&gt;.difference()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6697bde0ca2f6191e57083935504137a053b9a" translate="yes" xml:space="preserve">
          <source>The two primary data structures of pandas, &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; (1-dimensional) and &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; (2-dimensional), handle the vast majority of typical use cases in finance, statistics, social science, and many areas of engineering. For R users, &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; provides everything that R&amp;rsquo;s &lt;code&gt;data.frame&lt;/code&gt; provides and much more. pandas is built on top of &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; and is intended to integrate well within a scientific computing environment with many other 3rd party libraries.</source>
          <target state="translated">팬더의 두 가지 기본 데이터 구조 인 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; (1 차원) 및 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; (2 차원)은 재무, 통계, 사회 과학 및 많은 엔지니어링 분야에서 대부분의 일반적인 사용 사례를 처리합니다. R 사용자의 경우, &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 는&lt;/a&gt; R의 것을 모든 것을 제공 &lt;code&gt;data.frame&lt;/code&gt; 가 제공하고 훨씬 더. 팬더는 &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; 위에 지어졌습니다. 과학 컴퓨팅 환경 내에서 다른 많은 타사 라이브러리와 잘 통합되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4483ecf6dccbe41d8d496dd2dba08db239fb56cb" translate="yes" xml:space="preserve">
          <source>The type of object to recover.</source>
          <target state="translated">복구 할 개체의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c0f751f50f1e8f430845fcaf196d804307d2dcd8" translate="yes" xml:space="preserve">
          <source>The type of storage for sparse locations.</source>
          <target state="translated">스파 스 위치에 대한 스토리지 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ee0c4e99099b234804f97860719695612087ef15" translate="yes" xml:space="preserve">
          <source>The type of the key-value pairs can be customized with the parameters (see below).</source>
          <target state="translated">키-값 쌍의 유형은 매개 변수를 사용하여 사용자 정의 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="51ce993717bf6a0143c5b2be7356acd1a26b073c" translate="yes" xml:space="preserve">
          <source>The type returned depends on the value of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03145edb4e266b12a866409268ef31378abd1db6" translate="yes" xml:space="preserve">
          <source>The type returned depends on the value of &lt;code&gt;typ&lt;/code&gt;.</source>
          <target state="translated">리턴되는 유형은 &lt;code&gt;typ&lt;/code&gt; 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="f79f3a757f52d5cea4cc7929ece04e1bd225bf11" translate="yes" xml:space="preserve">
          <source>The types for &amp;ldquo;Returns&amp;rdquo; and &amp;ldquo;Yields&amp;rdquo; are the same as the ones for the &amp;ldquo;Parameters&amp;rdquo;. Also, the description must finish with a dot.</source>
          <target state="translated">&quot;반품&quot;및 &quot;수율&quot;의 유형은 &quot;매개 변수&quot;의 유형과 동일합니다. 또한 설명은 점으로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="7390dce93e11b2c5a46389b86d7a5fcfa0707ea4" translate="yes" xml:space="preserve">
          <source>The ufunc is applied to the underlying array in a Series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fa2bd7b9e3bbec157e62a46f20bed976ba098f" translate="yes" xml:space="preserve">
          <source>The underlying implementation of &lt;code&gt;HDFStore&lt;/code&gt; uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the &lt;code&gt;HDFStore&lt;/code&gt;, &lt;strong&gt;in the first append&lt;/strong&gt;. Subsequent appends, may introduce a string for a column &lt;strong&gt;larger&lt;/strong&gt; than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26146c287b2bf60e2d9b7d9ae8c527a09d664476" translate="yes" xml:space="preserve">
          <source>The unique categories for this categorical. If not given, the categories are assumed to be the unique values of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee3f92abb3e238573e261de20c106235e1e0f37" translate="yes" xml:space="preserve">
          <source>The unique categories for this categorical. If not given, the categories are assumed to be the unique values of &lt;code&gt;values&lt;/code&gt; (sorted, if possible, otherwise in the order in which they appear).</source>
          <target state="translated">이 범주에 대한 고유 범주입니다. 지정하지 않으면 범주는 고유 한 값 값으로 간주 &lt;code&gt;values&lt;/code&gt; (가능한 경우 정렬 된 순서대로 정렬 됨).</target>
        </trans-unit>
        <trans-unit id="08d5b21a76a03bb3da817e49568cf4247697ea7c" translate="yes" xml:space="preserve">
          <source>The unique labels for each level.</source>
          <target state="translated">각 레벨의 고유 레이블.</target>
        </trans-unit>
        <trans-unit id="c3b29002b5317b79b16cd878ea7e075240e5d237" translate="yes" xml:space="preserve">
          <source>The unique valid values. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516ddbe4ee77da3873adf520bce750390d2937e5" translate="yes" xml:space="preserve">
          <source>The unique valid values. When &lt;code&gt;values&lt;/code&gt; is Categorical, &lt;code&gt;uniques&lt;/code&gt; is a Categorical. When &lt;code&gt;values&lt;/code&gt; is some other pandas object, an &lt;code&gt;Index&lt;/code&gt; is returned. Otherwise, a 1-D ndarray is returned.</source>
          <target state="translated">고유 한 유효한 값입니다. 때 &lt;code&gt;values&lt;/code&gt; 범주이며, &lt;code&gt;uniques&lt;/code&gt; 범주 형이다. 때 &lt;code&gt;values&lt;/code&gt; 다른 판다 개체입니다, &lt;code&gt;Index&lt;/code&gt; 반환됩니다. 그렇지 않으면 1 차원 ndarray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba287563afabc6c7654180c7256a6438ab828132" translate="yes" xml:space="preserve">
          <source>The unique values returned as a NumPy array. See Notes.</source>
          <target state="translated">고유 한 값은 NumPy 배열로 반환됩니다. 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f845d8b4d75698888ed01568a8cb1c5763870db5" translate="yes" xml:space="preserve">
          <source>The unit of the arg (D,s,ms,us,ns) denote the unit, which is an integer or float number. This will be based off the origin. Example, with unit=&amp;rsquo;ms&amp;rsquo; and origin=&amp;rsquo;unix&amp;rsquo; (the default), this would calculate the number of milliseconds to the unix epoch start.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11196d06d4838462c29ff673bdd8756793a3daff" translate="yes" xml:space="preserve">
          <source>The upshot is that this &lt;em&gt;only&lt;/em&gt; applies to object-dtype expressions. So, if you have an expression&amp;ndash;for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429c63fef3666e40b2424a5ce51a07b638b6ff7b" translate="yes" xml:space="preserve">
          <source>The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249/&quot;&gt;Python DB-API&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8692d927db78d08a82e6412d4c2a612e4cedd5b4" translate="yes" xml:space="preserve">
          <source>The user guide provides in-depth information on the key concepts of pandas with useful background information and explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16757d9761bab66aa59f454abb1d50d839900340" translate="yes" xml:space="preserve">
          <source>The user-defined &lt;code&gt;format_conversion&lt;/code&gt; function above can be called within a sequence of other style modifications:</source>
          <target state="translated">위의 사용자 정의 &lt;code&gt;format_conversion&lt;/code&gt; 함수는 다른 스타일 수정 시퀀스 내에서 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78ad780f79e3a5ad6efc9ee27e78102cf58c8f22" translate="yes" xml:space="preserve">
          <source>The usual options are available for &lt;code&gt;join&lt;/code&gt; (one of &lt;code&gt;'left', 'outer', 'inner', 'right'&lt;/code&gt;). In particular, alignment also means that the different lengths do not need to coincide anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c668b160a4f7fd0b0c56252f618ffdb9fba4a5f5" translate="yes" xml:space="preserve">
          <source>The utility script &lt;code&gt;scripts/validate_docstrings.py&lt;/code&gt; can be used to get a csv summary of the API documentation. And also validate common errors in the docstring of a specific class, function or method. The summary also compares the list of methods documented in &lt;code&gt;doc/source/api.rst&lt;/code&gt; (which is used to generate the &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/api.html&quot;&gt;API Reference&lt;/a&gt; page) and the actual public methods. This will identify methods documented in &lt;code&gt;doc/source/api.rst&lt;/code&gt; that are not actually class methods, and existing methods that are not documented in &lt;code&gt;doc/source/api.rst&lt;/code&gt;.</source>
          <target state="translated">유틸리티 스크립트 &lt;code&gt;scripts/validate_docstrings.py&lt;/code&gt; 를 사용하여 API 문서의 csv 요약을 얻을 수 있습니다. 또한 특정 클래스, 함수 또는 메서드의 docstring에서 일반적인 오류의 유효성을 검사합니다. 요약은 또한 &lt;code&gt;doc/source/api.rst&lt;/code&gt; ( &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/api.html&quot;&gt;API 참조&lt;/a&gt; 페이지 생성에 사용됨)에 문서화 된 메소드 목록 과 실제 공용 메소드를 비교합니다. 이것은에서 설명하는 방법을 식별 할 &lt;code&gt;doc/source/api.rst&lt;/code&gt; 실제로 클래스 메소드, 그리고에서 설명하지 않은 기존의 방법 &lt;code&gt;doc/source/api.rst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e4a451c0a8263738ed40500d427ad796d89648" translate="yes" xml:space="preserve">
          <source>The validated indexer as a numpy array that can be used to index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ffb665ad37c0a99bc893f4692cf6f388438a79" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;last&amp;rsquo; for parameter &amp;lsquo;keep&amp;rsquo; keeps the last occurrence for each set of duplicated entries.</source>
          <target state="translated">'keep'매개 변수의 'last'값은 각 중복 항목 세트의 마지막 항목을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f4783e916c879475221a6dd330847cb7047a8f09" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;last&amp;rsquo; keeps the last occurrence for each set of duplicated entries.</source>
          <target state="translated">'last'값은 각 중복 항목 세트에 대한 마지막 발생을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1fa1c5b121c9318d42b117b1d9f27d18cfb737d2" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;False&lt;/code&gt; discards all sets of duplicated entries.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 값 은 모든 중복 항목 세트를 버립니다.</target>
        </trans-unit>
        <trans-unit id="cfdd62044c55b5c0bde5b6cdafae8d31138392bc" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;False&lt;/code&gt; for parameter &amp;lsquo;keep&amp;rsquo; discards all sets of duplicated entries. Setting the value of &amp;lsquo;inplace&amp;rsquo; to &lt;code&gt;True&lt;/code&gt; performs the operation inplace and returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">'keep'매개 변수의 &lt;code&gt;False&lt;/code&gt; 값 은 모든 중복 항목 세트를 버립니다. 'inplace'값을 &lt;code&gt;True&lt;/code&gt; 로 설정하면 작업이 수행되고 &lt;code&gt;None&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="0e25171e265f406107b005e481efa2280ea90d5f" translate="yes" xml:space="preserve">
          <source>The value in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b91316e4cabdee709646e506bcc62a06d21b71b5" translate="yes" xml:space="preserve">
          <source>The value in &lt;code&gt;values&lt;/code&gt; to consider missing. This will be treated as NA in the factorization routines, so it will be coded as &lt;code&gt;na_sentinal&lt;/code&gt; and not included in &lt;code&gt;uniques&lt;/code&gt;. By default, &lt;code&gt;np.nan&lt;/code&gt; is used.</source>
          <target state="translated">누락 된 것으로 간주 되는 &lt;code&gt;values&lt;/code&gt; 입니다. 그것으로 부호화 될 수 있도록 이것은 분해 루틴 NA로 처리한다 &lt;code&gt;na_sentinal&lt;/code&gt; 및 포함되지 &lt;code&gt;uniques&lt;/code&gt; . 기본적으로 &lt;code&gt;np.nan&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c97997fa5b94290c27d53056b8dcfdd9c74c2147" translate="yes" xml:space="preserve">
          <source>The value in the Series or DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c1cdba3a8acef681606512f4cdff2bb03f5d89" translate="yes" xml:space="preserve">
          <source>The value of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="082c1a19087cf5c8c94a26d4f654224c6ea31d68" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;start&lt;/code&gt; parameter (&lt;code&gt;0&lt;/code&gt; if this was not supplied)</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 매개 변수 의 값 ( 제공되지 않은 경우 &lt;code&gt;0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dca210000aadee57e0cd1a5a787d605c678627e4" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;step&lt;/code&gt; parameter (&lt;code&gt;1&lt;/code&gt; if this was not supplied)</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 매개 변수 의 값 ( 제공되지 않은 경우 &lt;code&gt;1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="675ea6e7709763e0978f0b4c9ee60c1c151e6625" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;stop&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 매개 변수 의 값</target>
        </trans-unit>
        <trans-unit id="273a96f5b91494b14bcdc3ab415562c8e1811f92" translate="yes" xml:space="preserve">
          <source>The value or values in a set of duplicates to mark as missing.</source>
          <target state="translated">중복 세트의 값이 누락 된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6e8036a7dd8b89ee59719d91c7a95ab47dccc119" translate="yes" xml:space="preserve">
          <source>The value passed to &lt;code&gt;subset&lt;/code&gt; behaves similar to slicing a DataFrame.</source>
          <target state="translated">&lt;code&gt;subset&lt;/code&gt; 전달 된 값 은 DataFrame을 슬라이스하는 것과 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ec1cec649c0500439dfbd7da81e021781c85c3d6" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 가 반환 한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="bd2388952019119001154f5073cb74304c73d791" translate="yes" xml:space="preserve">
          <source>The value that serves as a placeholder for NULL values</source>
          <target state="translated">NULL 값의 자리 표시 자 역할을하는 값</target>
        </trans-unit>
        <trans-unit id="f1c98005d15357096e93c7269c6ecd647b8a2f1c" translate="yes" xml:space="preserve">
          <source>The value to assume when an index is missing from one Series or the other. The default specifies to use the appropriate NaN value for the underlying dtype of the Series.</source>
          <target state="translated">한 시리즈 또는 다른 시리즈에서 인덱스가 누락 될 때 가정하는 값입니다. 기본값은 Series의 기본 dtype에 적절한 NaN 값을 사용하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c38ddad2d4a4fa0877c749c7f336e97b4951b359" translate="yes" xml:space="preserve">
          <source>The value to check whether it is contained in the Intervals.</source>
          <target state="translated">간격에 포함되는지 여부를 확인하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="0c732ffeccd3e9064b80fedd884c706842eef979" translate="yes" xml:space="preserve">
          <source>The value to fill NaNs with prior to passing any column to the merge func.</source>
          <target state="translated">열을 병합 기능에 전달하기 전에 NaN을 채울 값입니다.</target>
        </trans-unit>
        <trans-unit id="3ad5c54194e8da483f70bccdf1223ae9d1722018" translate="yes" xml:space="preserve">
          <source>The value to use for missing values. The default value depends on</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffaf1ceec77e8bd0d2ae83389c37f099506d47e6" translate="yes" xml:space="preserve">
          <source>The value(s) to be combined with the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b22b563a657f00dc600a72cc3c6301ec831bdb" translate="yes" xml:space="preserve">
          <source>The value(s) to be combined with the &lt;code&gt;Series&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 와 결합 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="856ff1c455f48a237943ab6df74433baf27c0533" translate="yes" xml:space="preserve">
          <source>The values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8bb6b48a81fc8c24477536c8076653aa0b8de8" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;NaT&lt;/code&gt;, and optionally &lt;code&gt;numpy.inf&lt;/code&gt; (depending on &lt;code&gt;pandas.options.mode.use_inf_as_na&lt;/code&gt;) are considered NA.</source>
          <target state="translated">값의 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 가 , &lt;code&gt;NaT&lt;/code&gt; 및 임의로 &lt;code&gt;numpy.inf&lt;/code&gt; 은 (에 따라 &lt;code&gt;pandas.options.mode.use_inf_as_na&lt;/code&gt; ) NA로 간주되지 않는다.</target>
        </trans-unit>
        <trans-unit id="7bfe044fe8a7353ae44591174229f93b595a9229" translate="yes" xml:space="preserve">
          <source>The values are physically stored as a 1-D ndarray of integers. These are called &amp;ldquo;ordinals&amp;rdquo; and represent some kind of offset from a base.</source>
          <target state="translated">값은 1 차원 정수의 정수로 물리적으로 저장됩니다. 이것을 &quot;기수&quot;라고하며베이스와의 오프셋을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1c85d746628dd6c378cb8e64c80e5e03482a2a37" translate="yes" xml:space="preserve">
          <source>The values are tuples whose first element is the column to select and the second element is the aggregation to apply to that column. Pandas provides the &lt;code&gt;pandas.NamedAgg&lt;/code&gt; namedtuple with the fields &lt;code&gt;['column', 'aggfunc']&lt;/code&gt; to make it clearer what the arguments are. As usual, the aggregation can be a callable or a string alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e64fe12192ab691299ffacd812e78934046522c" translate="yes" xml:space="preserve">
          <source>The values are tuples whose first element is the column to select and the second element is the aggregation to apply to that column. pandas provides the &lt;code&gt;pandas.NamedAgg&lt;/code&gt; namedtuple with the fields &lt;code&gt;['column', 'aggfunc']&lt;/code&gt; to make it clearer what the arguments are. As usual, the aggregation can be a callable or a string alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a1d83c4d98819c93429c70e53814cbb56c2445" translate="yes" xml:space="preserve">
          <source>The values for the new index.</source>
          <target state="translated">새 색인의 값입니다.</target>
        </trans-unit>
        <trans-unit id="9c6150c4faf8a56f8d7726510dd323dca7e2d6f4" translate="yes" xml:space="preserve">
          <source>The values in the series converted to a &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; with the specified</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a751025f587cb83a5859c11bc9eb06adf29de990" translate="yes" xml:space="preserve">
          <source>The values in the series converted to a &lt;code&gt;numpy.ndarary&lt;/code&gt; with the specified &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">시리즈의 값 은 지정된 &lt;code&gt;dtype&lt;/code&gt; 을 사용하여 &lt;code&gt;numpy.ndarary&lt;/code&gt; 로 변환되었습니다 .</target>
        </trans-unit>
        <trans-unit id="657bd4d9ae8e395ab5fab2517b5f25b9e924f6ae" translate="yes" xml:space="preserve">
          <source>The values of the DataFrame.</source>
          <target state="translated">DataFrame의 값입니다.</target>
        </trans-unit>
        <trans-unit id="8d75f0367fc527d1a7e820ee03697f95cc796dff" translate="yes" xml:space="preserve">
          <source>The values of the categorical. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bd988d8d8c28417a2a4dcb63cc638a69452728" translate="yes" xml:space="preserve">
          <source>The values of the categorical. If &lt;code&gt;categories&lt;/code&gt; are given, values not in &lt;code&gt;categories&lt;/code&gt; will be replaced with NaN.</source>
          <target state="translated">범주 형 값입니다. 경우 &lt;code&gt;categories&lt;/code&gt; 주어진,하지의 값 &lt;code&gt;categories&lt;/code&gt; NaN의로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="65d6aab699700d286d1bd641a2d94003b833630b" translate="yes" xml:space="preserve">
          <source>The values of the categorical. If categories are given, values not in categories will be replaced with NaN.</source>
          <target state="translated">범주 형 값입니다. 범주가 제공되면 범주에없는 값은 NaN으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0ca8f39f1756e5478294ae57b376365d6ab92671" translate="yes" xml:space="preserve">
          <source>The values returned by this method are also used in &lt;a href=&quot;pandas.util.hash_pandas_object#pandas.util.hash_pandas_object&quot;&gt;&lt;code&gt;pandas.util.hash_pandas_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드에 의해 리턴 된 값은 &lt;a href=&quot;pandas.util.hash_pandas_object#pandas.util.hash_pandas_object&quot;&gt; &lt;code&gt;pandas.util.hash_pandas_object()&lt;/code&gt; &lt;/a&gt; 에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="538882f2dae2d1b315b7d468413ec9e83b912deb" translate="yes" xml:space="preserve">
          <source>The values to be plotted. Either the location or the label of the columns to be used. By default, it will use the remaining DataFrame numeric columns.</source>
          <target state="translated">플롯 할 값입니다. 사용할 열의 위치 또는 레이블입니다. 기본적으로 나머지 DataFrame 숫자 열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d05ee150cfb9c7545a4078b6f06d3c4a5a3481e4" translate="yes" xml:space="preserve">
          <source>The views share the same underlying values:</source>
          <target state="translated">뷰는 동일한 기본 값을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="09d61fad1053f65f85b3ed3593319fd596059f2c" translate="yes" xml:space="preserve">
          <source>The warning can be avoided by adding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fd4d6810e5af8a60892e6e28d843eef4ac0a8c" translate="yes" xml:space="preserve">
          <source>The warning can be avoided by adding &lt;code&gt;engine=&amp;rsquo;python&amp;rsquo;&lt;/code&gt; as a parameter in &lt;code&gt;pd.read_csv&lt;/code&gt; and &lt;code&gt;pd.read_table&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;pd.read_csv&lt;/code&gt; 및 &lt;code&gt;pd.read_table&lt;/code&gt; 메소드 에서 &lt;code&gt;engine=&amp;rsquo;python&amp;rsquo;&lt;/code&gt; 을 매개 변수로 추가하면 경고를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b734efe785a84887a8bf2dead9db1ae8624267b" translate="yes" xml:space="preserve">
          <source>The way to present examples is as follows:</source>
          <target state="translated">예제를 제시하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="303fe67581ba287d82bd9df663498cc9915672d7" translate="yes" xml:space="preserve">
          <source>The week ordinal of the year</source>
          <target state="translated">올해의 서수</target>
        </trans-unit>
        <trans-unit id="4a2bfce7c1d756677b1c22b6223b9eca74118105" translate="yes" xml:space="preserve">
          <source>The week ordinal of the year.</source>
          <target state="translated">연중 주 서수입니다.</target>
        </trans-unit>
        <trans-unit id="24f8ec6c1b239864ebd4a14533ca7acc4b8ec2d0" translate="yes" xml:space="preserve">
          <source>The where method is an application of the if-then idiom. For each element in the calling DataFrame, if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; the element is used; otherwise the corresponding element from the DataFrame &lt;code&gt;other&lt;/code&gt; is used.</source>
          <target state="translated">where 메소드는 if-then 관용구의 적용입니다. 호출하는 DataFrame의 각 요소에 대해 &lt;code&gt;cond&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 이면 요소가 사용됩니다. 그렇지 않으면 &lt;code&gt;other&lt;/code&gt; DataFrame의 해당 요소 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc9956d52e5a77906b96814aaf5b8ce432286e5a" translate="yes" xml:space="preserve">
          <source>The where() Method and Masking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb497ee397b034145981944802072ba5c6ec7a1" translate="yes" xml:space="preserve">
          <source>The wide-format DataFrame</source>
          <target state="translated">와이드 포맷 DataFrame</target>
        </trans-unit>
        <trans-unit id="8684c2d1f9294612d48ce0270cce0aa04ced135d" translate="yes" xml:space="preserve">
          <source>The wide-format DataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d069b19d205a8a544e27821fd41d9bbd388fff" translate="yes" xml:space="preserve">
          <source>The windows are comprised by looking back the length of the window from the current observation. The result above can be derived by taking the sum of the following windowed partitions of data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0149f39742913affe90746efaec2a66a152a22a" translate="yes" xml:space="preserve">
          <source>The work is done on the &lt;code&gt;categories&lt;/code&gt; and then a new &lt;code&gt;Series&lt;/code&gt; is constructed. This has some performance implication if you have a &lt;code&gt;Series&lt;/code&gt; of type string, where lots of elements are repeated (i.e. the number of unique elements in the &lt;code&gt;Series&lt;/code&gt; is a lot smaller than the length of the &lt;code&gt;Series&lt;/code&gt;). In this case it can be faster to convert the original &lt;code&gt;Series&lt;/code&gt; to one of type &lt;code&gt;category&lt;/code&gt; and use &lt;code&gt;.str.&amp;lt;method&amp;gt;&lt;/code&gt; or &lt;code&gt;.dt.&amp;lt;property&amp;gt;&lt;/code&gt; on that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828a37f745e274a94e922c45d297d2f30237b424" translate="yes" xml:space="preserve">
          <source>The workhorse function for reading text files (a.k.a. flat files) is &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;cookbook#cookbook-csv&quot;&gt;cookbook&lt;/a&gt; for some advanced strategies.</source>
          <target state="translated">텍스트 파일 (일명 플랫 파일)을 읽는 주력 함수는 &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt; 입니다. 고급 전략에 대해서는 &lt;a href=&quot;cookbook#cookbook-csv&quot;&gt;요리 책&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee39f68620752ce16aae6bcca3a91d96231da7a9" translate="yes" xml:space="preserve">
          <source>The writer should be used as a context manager. Otherwise, call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236866461b45064b3e3f412016802fdd048c304d" translate="yes" xml:space="preserve">
          <source>The year may either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031078724d277958b364494e4ebc13bb46ac0dbf" translate="yes" xml:space="preserve">
          <source>The year may either: - end on the last X day of the Y month. - end on the last X day closest to the last day of the Y month.</source>
          <target state="translated">연도는 다음 중 하나 일 수 있습니다.-Y 개월의 마지막 X 일에 끝납니다. -Y 월의 마지막 날과 가장 가까운 마지막 X 일에 끝납니다.</target>
        </trans-unit>
        <trans-unit id="a3c96ebde83662fd58cd37be6e90dcb312f62ee0" translate="yes" xml:space="preserve">
          <source>The year of the datetime</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d52f0e9ac072d8b6d237d59b7699e96a60edf7" translate="yes" xml:space="preserve">
          <source>The year of the datetime.</source>
          <target state="translated">날짜 시간의 연도입니다.</target>
        </trans-unit>
        <trans-unit id="6fa9865ec03ed677708dbbf78d6c8d0a954c69a7" translate="yes" xml:space="preserve">
          <source>The year of the period</source>
          <target state="translated">기간의 해</target>
        </trans-unit>
        <trans-unit id="ddc192cd564946529042d5cf61e72832243635f0" translate="yes" xml:space="preserve">
          <source>The year of the period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c331bfc525db38fd972e9e4dd7fcfe3a1764767e" translate="yes" xml:space="preserve">
          <source>Then create the index when finished appending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae352b4b0774bf484badc28da965d2cbabad72c" translate="yes" xml:space="preserve">
          <source>Then modify the file to ensure that any indentation width parameters are at least four. Once configured, you can run the tool as follows:</source>
          <target state="translated">그런 다음 들여 쓰기 너비 매개 변수가 4 이상이되도록 파일을 수정하십시오. 일단 구성되면 다음과 같이 도구를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeae1384b2f94311d0148155d4105806167ce513" translate="yes" xml:space="preserve">
          <source>Then you can do:</source>
          <target state="translated">그럼 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="66ca81fab19a798d8365820a52c9af42f39fbf73" translate="yes" xml:space="preserve">
          <source>Then you can find the HTML output in the folder &lt;code&gt;doc/build/html/&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;doc/build/html/&lt;/code&gt; 폴더에서 HTML 출력을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a1b49b36300bc3d8ff1537265db5a6d00d7e13f" translate="yes" xml:space="preserve">
          <source>There also exists a helper function &lt;code&gt;pandas.plotting.table&lt;/code&gt;, which creates a table from &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;, and adds it to an &lt;code&gt;matplotlib.Axes&lt;/code&gt; instance. This function can accept keywords which the matplotlib &lt;a href=&quot;https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes.table&quot;&gt;table&lt;/a&gt; has.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e2743fb6ce07c815312b02a2ba8118e68e6385" translate="yes" xml:space="preserve">
          <source>There are 2 explicit slicing methods, with a third general case</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0742f13ef772bb4d4475e2ccb17f15f08843c6f1" translate="yes" xml:space="preserve">
          <source>There are 3 constructor properties to be defined:</source>
          <target state="translated">정의 할 생성자 속성은 3 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a954573aa9ef06434c08330a3ba7627d32c102b" translate="yes" xml:space="preserve">
          <source>There are a few special cases when the result is known, even when one of the operands is &lt;code&gt;NA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7edbdbd83f29ae8e4508ca35443e5b335ad6db01" translate="yes" xml:space="preserve">
          <source>There are a number of different options for the format of the resulting JSON file / string. Consider the following &lt;code&gt;DataFrame&lt;/code&gt; and &lt;code&gt;Series&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785caed00ed8e63af9b33d9f9f7b66f20f09dbf9" translate="yes" xml:space="preserve">
          <source>There are essentially three calling conventions for the constructor. The primary form accepts four parameters. They can be passed by position or keyword.</source>
          <target state="translated">생성자에는 기본적으로 세 가지 호출 규칙이 있습니다. 기본 형식은 네 가지 매개 변수를 사용합니다. 위치 나 키워드로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2edb329c1cbdc3f18c0639e94dd0d510bcc5d8d5" translate="yes" xml:space="preserve">
          <source>There are familiar attributes like &lt;code&gt;.columns&lt;/code&gt; and &lt;code&gt;.dtypes&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8debe341ae95fe174e1f209686ea6496727ae913" translate="yes" xml:space="preserve">
          <source>There are familiar methods like &lt;code&gt;.groupby&lt;/code&gt;, &lt;code&gt;.sum&lt;/code&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c574453dc604bff13ca2bb408bbcc26a6770608a" translate="yes" xml:space="preserve">
          <source>There are functions that make the creation of a regular index easy:</source>
          <target state="translated">일반 색인을 쉽게 만들 수있는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95434a6520f7d506cea6f3c335bbf3cf86fe8db" translate="yes" xml:space="preserve">
          <source>There are many instances where such an error can be raised:</source>
          <target state="translated">이러한 오류가 발생할 수있는 많은 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b7998ed39e33ea63cd489d80d79cb3a7f1ace3" translate="yes" xml:space="preserve">
          <source>There are new attributes like &lt;code&gt;.npartitions&lt;/code&gt; and &lt;code&gt;.divisions&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5aff5ca4d9c081f86be824ca4f3781825014bca" translate="yes" xml:space="preserve">
          <source>There are several different but overlapping sets of numeric characters that can be checked for.</source>
          <target state="translated">확인할 수있는 서로 다르지만 겹치는 숫자 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2364e59f9a38d863102157af6371ae5bdf2a71d8" translate="yes" xml:space="preserve">
          <source>There are several time/date properties that one can access from &lt;code&gt;Timestamp&lt;/code&gt; or a collection of timestamps like a &lt;code&gt;DatetimeIndex&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e71a838d34739fbd8365098b54c1dd1cb21cee63" translate="yes" xml:space="preserve">
          <source>There are several ways to concatenate a &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;Index&lt;/code&gt;, either with itself or others, all based on &lt;a href=&quot;../reference/api/pandas.series.str.cat#pandas.Series.str.cat&quot;&gt;&lt;code&gt;cat()&lt;/code&gt;&lt;/a&gt;, resp. &lt;code&gt;Index.str.cat&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e8aeb0491c1efe1b7f37ad6ed7fde8dc589b6d" translate="yes" xml:space="preserve">
          <source>There are some easier alternatives before considering subclassing &lt;code&gt;pandas&lt;/code&gt; data structures.</source>
          <target state="translated">&lt;code&gt;pandas&lt;/code&gt; 데이터 구조 서브 클래 싱을 고려하기 전에 더 쉬운 대안이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="415e12d860cb63e0fe918f67eb2ae9a3475d2576" translate="yes" xml:space="preserve">
          <source>There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass &lt;code&gt;index_col=False&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290cab346508a7f862a676451dfc29426ec813da" translate="yes" xml:space="preserve">
          <source>There are some methods in pandas returning plots. To render the plots generated by the examples in the documentation, the &lt;code&gt;.. plot::&lt;/code&gt; directive exists.</source>
          <target state="translated">팬더에는 플롯을 반환하는 몇 가지 방법이 있습니다. 문서의 예제에서 생성 된 플롯을 렌더링하기 위해 &lt;code&gt;.. plot::&lt;/code&gt; 지시문이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="99b02bdad6f77a2d37b3fde8be68cee19b222e8f" translate="yes" xml:space="preserve">
          <source>There are some versioning issues surrounding the libraries that are used to parse HTML tables in the top-level pandas io function &lt;code&gt;read_html&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8543214c45e5a10b45bf735f9d6b580c52c0ef4d" translate="yes" xml:space="preserve">
          <source>There are two components to a PeriodArray</source>
          <target state="translated">PeriodArray에는 두 가지 구성 요소가 있습니다</target>
        </trans-unit>
        <trans-unit id="2d1d0b9cd20372c38b2e7f926b7bd104d60d80cc" translate="yes" xml:space="preserve">
          <source>There are two different parsers and two different engines you can use as the backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae190879413ade07ba36b2387fc5a5c492aaf709" translate="yes" xml:space="preserve">
          <source>There are two options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64808115c45b21eaac32871afe0c252fe05d4f00" translate="yes" xml:space="preserve">
          <source>There are two ways to store text data in pandas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdbbea058f75868403d8cd6a1c6c6f84901350b" translate="yes" xml:space="preserve">
          <source>There exists a large number of methods for computing descriptive statistics and other related operations on &lt;a href=&quot;../reference/series#api-series-stats&quot;&gt;Series&lt;/a&gt;, &lt;a href=&quot;../reference/frame#api-dataframe-stats&quot;&gt;DataFrame&lt;/a&gt;. Most of these are aggregations (hence producing a lower-dimensional result) like &lt;a href=&quot;../reference/api/pandas.dataframe.sum#pandas.DataFrame.sum&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.dataframe.mean#pandas.DataFrame.mean&quot;&gt;&lt;code&gt;mean()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/api/pandas.dataframe.quantile#pandas.DataFrame.quantile&quot;&gt;&lt;code&gt;quantile()&lt;/code&gt;&lt;/a&gt;, but some of them, like &lt;a href=&quot;../reference/api/pandas.dataframe.cumsum#pandas.DataFrame.cumsum&quot;&gt;&lt;code&gt;cumsum()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.dataframe.cumprod#pandas.DataFrame.cumprod&quot;&gt;&lt;code&gt;cumprod()&lt;/code&gt;&lt;/a&gt;, produce an object of the same size. Generally speaking, these methods take an &lt;strong&gt;axis&lt;/strong&gt; argument, just like &lt;em&gt;ndarray.{sum, std, &amp;hellip;}&lt;/em&gt;, but the axis can be specified by name or integer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff118a8c035ed3d2bebe57bc89bbf24721fa0291" translate="yes" xml:space="preserve">
          <source>There is a convenient &lt;a href=&quot;../reference/api/pandas.dataframe.describe#pandas.DataFrame.describe&quot;&gt;&lt;code&gt;describe()&lt;/code&gt;&lt;/a&gt; function which computes a variety of summary statistics about a Series or the columns of a DataFrame (excluding NAs of course):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056d870a9c1b7c3f76dfc0e9b3a6280767ff9dfe" translate="yes" xml:space="preserve">
          <source>There is a tool in pandas to help contributors verify their changes before contributing them to the project:</source>
          <target state="translated">팬더에는 기여자가 프로젝트에 기여하기 전에 변경 사항을 확인하는 데 도움이되는 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec264699cd727e2f9b50f15e9b024bc407e8ca0c" translate="yes" xml:space="preserve">
          <source>There is no more duplicate data because &lt;code&gt;mangle_dupe_cols=True&lt;/code&gt; by default, which modifies a series of duplicate columns &amp;lsquo;X&amp;rsquo;, &amp;hellip;, &amp;lsquo;X&amp;rsquo; to become &amp;lsquo;X&amp;rsquo;, &amp;lsquo;X.1&amp;rsquo;, &amp;hellip;, &amp;lsquo;X.N&amp;rsquo;. If &lt;code&gt;mangle_dupe_cols=False&lt;/code&gt;, duplicate data can arise:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198c3adc114b44d2dd641831b489bd600ab9e1a0" translate="yes" xml:space="preserve">
          <source>There is no setter, use the other categorical methods and the normal item setter to change values in the categorical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce4567ae9b0d78f15ec488b4864341b4cf64bc5" translate="yes" xml:space="preserve">
          <source>There is not setter, use the other categorical methods and the normal item setter to change values in the categorical.</source>
          <target state="translated">세터가 없으며 다른 범주 방법과 일반 항목 세터를 사용하여 범주의 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="555ad54203baf89b44bad176441beceee8a413b3" translate="yes" xml:space="preserve">
          <source>There is only one axis to drop values from.</source>
          <target state="translated">값을 제거 할 축은 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="2f536d298fb9a4135f591523b6d64a4e27a6d829" translate="yes" xml:space="preserve">
          <source>There is some performance degradation by making lots of columns into &lt;code&gt;data columns&lt;/code&gt;, so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a81aa3a7361c854caa86c4ab347fd6d28612c1" translate="yes" xml:space="preserve">
          <source>There is still hope for improvement. Here&amp;rsquo;s an example of using some more advanced Cython techniques:</source>
          <target state="translated">여전히 개선의 희망이 있습니다. 다음은 고급 Cython 기술을 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="23070a717ac66a5b7aa94edc1e1314056a7e6e25" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;code&gt;.highlight_min&lt;/code&gt; and &lt;code&gt;.highlight_max&lt;/code&gt;.</source>
          <target state="translated">도 있습니다 &lt;code&gt;.highlight_min&lt;/code&gt; 및 &lt;code&gt;.highlight_max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f175fbc6ea0af11dc87a7cfcac4ea4b8938adc" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also the option to make &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; operate identical to plain ol&amp;rsquo; Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0250e5cff75fc35d857d3f7fc5836b7b74c49b75" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no performance or memory penalty to using a Series or DataFrame with sparse values, rather than a SparseSeries or SparseDataFrame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54cad1aea65882e10c3168aff926ab32ab19a08" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;Timestamp&lt;/code&gt; and &lt;code&gt;datetime&lt;/code&gt; objects have exact &lt;code&gt;hours, minutes,&lt;/code&gt; and &lt;code&gt;seconds&lt;/code&gt;, even though they were not explicitly specified (they are &lt;code&gt;0&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1917e18b60facbf52a2b29119efa9efae22b106e" translate="yes" xml:space="preserve">
          <source>These Dask examples have all be done using multiple processes on a single machine. Dask can be &lt;a href=&quot;https://docs.dask.org/en/latest/setup.html&quot;&gt;deployed on a cluster&lt;/a&gt; to scale up to even larger datasets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c32aa45519f2bf0c9d50c145b055468434919b0" translate="yes" xml:space="preserve">
          <source>These are both enabled to be used by default, you can control this by setting the options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ffd0fe953f3d6d866e4777a0a6b1a642ccc510" translate="yes" xml:space="preserve">
          <source>These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period)</source>
          <target state="translated">이들은 각각 스칼라 유형으로, 파이썬 스칼라 (str, int, float의 경우) 또는 팬더 스칼라 (Timestamp / Timedelta / Interval / Period의 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="a33a648a93aed042f3d0bcfc9fab52aa0a265119" translate="yes" xml:space="preserve">
          <source>These are placed in a &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; tag before the generated HTML table.</source>
          <target state="translated">이들은 생성 된 HTML 테이블 전에 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e17aa1a4f6a6ad5a1454f5855b6f5930c541ab0" translate="yes" xml:space="preserve">
          <source>These are places where the behavior of &lt;code&gt;StringDtype&lt;/code&gt; objects differ from &lt;code&gt;object&lt;/code&gt; dtype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eac1b0bc68248b72f4980c1bd88fdc45dc8fefa6" translate="yes" xml:space="preserve">
          <source>These are primarily intended for library authors looking to extend pandas objects.</source>
          <target state="translated">이들은 주로 팬더 객체를 확장하려는 라이브러리 작성자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="6f755c151c45b04dfbfdf817c9cb0dfe2c3dfa91" translate="yes" xml:space="preserve">
          <source>These are some neat pandas &lt;code&gt;idioms&lt;/code&gt;</source>
          <target state="translated">이것들은 깔끔한 팬더 &lt;code&gt;idioms&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b77f80ea79d81cc6efd8510216c46bf27faa920d" translate="yes" xml:space="preserve">
          <source>These are the items that show up in the opening &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; tag in addition to automatic (by default) id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cecf62e082001231e2b801b3e4a06d8333e0429" translate="yes" xml:space="preserve">
          <source>These are the items that show up in the opening &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; tag in addition to to automatic (by default) id.</source>
          <target state="translated">자동 (기본) ID 외에 여는 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 태그에 표시되는 항목입니다 .</target>
        </trans-unit>
        <trans-unit id="123948791e13f6c698da40aee09b9aebb83cbd9f" translate="yes" xml:space="preserve">
          <source>These both yield the same results, so which should you use? It is instructive to understand the order of operations on these and why method 2 (&lt;code&gt;.loc&lt;/code&gt;) is much preferred over method 1 (chained &lt;code&gt;[]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617102c5ee884ed6343c2f8b61b1c82e7d01598c" translate="yes" xml:space="preserve">
          <source>These can be used as arguments to &lt;code&gt;date_range&lt;/code&gt;, &lt;code&gt;bdate_range&lt;/code&gt;, constructors for &lt;code&gt;DatetimeIndex&lt;/code&gt;, as well as various other timeseries-related functions in pandas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c8356ee311940026bbcc0a181c1f039e543430" translate="yes" xml:space="preserve">
          <source>These can easily be converted to a &lt;code&gt;PeriodIndex&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23f8e456012d539a15500f376b66757eb1261be" translate="yes" xml:space="preserve">
          <source>These dates can be overwritten by setting the attributes as datetime/Timestamp/string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f01838b58173cbb9d45785ba1864e30c038943" translate="yes" xml:space="preserve">
          <source>These dtypes can be merged &amp;amp; reshaped &amp;amp; casted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1397158d7e7424f34157b373d126fdc5f306af7a" translate="yes" xml:space="preserve">
          <source>These dtypes can operate as part of &lt;code&gt;DataFrame&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1593bedeaf530680709c2c6eaf8ac46fb1b59e1d" translate="yes" xml:space="preserve">
          <source>These engines are very similar and should read/write nearly identical parquet format files. Currently &lt;code&gt;pyarrow&lt;/code&gt; does not support timedelta data, &lt;code&gt;fastparquet&amp;gt;=0.1.4&lt;/code&gt; supports timezone aware datetimes. These libraries differ by having different underlying dependencies (&lt;code&gt;fastparquet&lt;/code&gt; by using &lt;code&gt;numba&lt;/code&gt;, while &lt;code&gt;pyarrow&lt;/code&gt; uses a c-library).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c9c0752a150b92ea399d7f70549be4d037079d" translate="yes" xml:space="preserve">
          <source>These equations are sometimes written in terms of \(\alpha' = 1 - \alpha\), e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66eba5aaff5afc0267e2d6dbd80c69a1b836960a" translate="yes" xml:space="preserve">
          <source>These examples all show factorize as a top-level method like &lt;code&gt;pd.factorize(values)&lt;/code&gt;. The results are identical for methods like &lt;a href=&quot;#pandas.Series.factorize&quot;&gt;&lt;code&gt;Series.factorize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 예제는 모두 &lt;code&gt;pd.factorize(values)&lt;/code&gt; 와 같은 최상위 방법으로 factorize를 보여줍니다 . &lt;a href=&quot;#pandas.Series.factorize&quot;&gt; &lt;code&gt;Series.factorize()&lt;/code&gt; &lt;/a&gt; 와 같은 메소드의 결과는 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fc113faeeaabe0934fe79a9f5063bb0726c4b38e" translate="yes" xml:space="preserve">
          <source>These examples all show factorize as a top-level method like &lt;code&gt;pd.factorize(values)&lt;/code&gt;. The results are identical for methods like &lt;a href=&quot;pandas.series.factorize#pandas.Series.factorize&quot;&gt;&lt;code&gt;Series.factorize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 예제는 모두 &lt;code&gt;pd.factorize(values)&lt;/code&gt; 와 같은 최상위 방법으로 factorize를 보여줍니다 . &lt;a href=&quot;pandas.series.factorize#pandas.Series.factorize&quot;&gt; &lt;code&gt;Series.factorize()&lt;/code&gt; &lt;/a&gt; 와 같은 메소드의 결과는 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a23aa5a6987da34b0e0f37052f29312ce3beaf41" translate="yes" xml:space="preserve">
          <source>These examples are written for Python 3. Minor tweaks might be necessary for earlier python versions.</source>
          <target state="translated">이 예제는 Python 3 용으로 작성된 것입니다. 이전 Python 버전에는 약간의 조정이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="696be80742b766e104e77e27e98abbff7fe5927f" translate="yes" xml:space="preserve">
          <source>These formatting techniques can be used in combination with styling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73be07b0d9f510adff580f4a0d1bd76fc05cb3b3" translate="yes" xml:space="preserve">
          <source>These frequency strings map to a &lt;code&gt;DateOffset&lt;/code&gt; object and its subclasses. A &lt;code&gt;DateOffset&lt;/code&gt; is similar to a &lt;a href=&quot;../reference/api/pandas.timedelta#pandas.Timedelta&quot;&gt;&lt;code&gt;Timedelta&lt;/code&gt;&lt;/a&gt; that represents a duration of time but follows specific calendar duration rules. For example, a &lt;a href=&quot;../reference/api/pandas.timedelta#pandas.Timedelta&quot;&gt;&lt;code&gt;Timedelta&lt;/code&gt;&lt;/a&gt; day will always increment &lt;code&gt;datetimes&lt;/code&gt; by 24 hours, while a &lt;code&gt;DateOffset&lt;/code&gt; day will increment &lt;code&gt;datetimes&lt;/code&gt; to the same time the next day whether a day represents 23, 24 or 25 hours due to daylight savings time. However, all &lt;code&gt;DateOffset&lt;/code&gt; subclasses that are an hour or smaller (&lt;code&gt;Hour&lt;/code&gt;, &lt;code&gt;Minute&lt;/code&gt;, &lt;code&gt;Second&lt;/code&gt;, &lt;code&gt;Milli&lt;/code&gt;, &lt;code&gt;Micro&lt;/code&gt;, &lt;code&gt;Nano&lt;/code&gt;) behave like &lt;a href=&quot;../reference/api/pandas.timedelta#pandas.Timedelta&quot;&gt;&lt;code&gt;Timedelta&lt;/code&gt;&lt;/a&gt; and respect absolute time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93308444a645b65f63cd6ea0276c98c9e0ec5b37" translate="yes" xml:space="preserve">
          <source>These functions are intelligent about handling missing data and do not expect each subgroup within the hierarchical index to have the same set of labels. They also can handle the index being unsorted (but you can make it sorted by calling &lt;code&gt;sort_index&lt;/code&gt;, of course). Here is a more complex example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e10e95a6b5ae0be0fa4940d192b24e99fd4ff9" translate="yes" xml:space="preserve">
          <source>These functions can be imported from &lt;code&gt;pandas.plotting&lt;/code&gt; and take a &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e510dfda36a0d3aebf4705c068ba1dd16ff2b5f" translate="yes" xml:space="preserve">
          <source>These libraries are especially useful when dealing with large data sets, and provide large speedups. &lt;code&gt;numexpr&lt;/code&gt; uses smart chunking, caching, and multiple cores. &lt;code&gt;bottleneck&lt;/code&gt; is a set of specialized cython routines that are especially fast when dealing with arrays that have &lt;code&gt;nans&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4e40d75953176c10d68109473a1b0afc30f7b6" translate="yes" xml:space="preserve">
          <source>These methods have special treatment of NA values via the &lt;code&gt;na_position&lt;/code&gt; argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0062882123ec243f6bc67ba23f0532e65d9940e4" translate="yes" xml:space="preserve">
          <source>These methods require &lt;code&gt;scipy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62a7a97ccac0bbd24997411c4a7b9c0ffab1c1c" translate="yes" xml:space="preserve">
          <source>These methods require that the indexes are &lt;strong&gt;ordered&lt;/strong&gt; increasing or decreasing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fccfe905597818e9b3a8dd216568247c9eb3a4" translate="yes" xml:space="preserve">
          <source>These only act when &lt;code&gt;axis=1&lt;/code&gt; (columns):</source>
          <target state="translated">이들은 &lt;code&gt;axis=1&lt;/code&gt; (열) 인 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f2ac1425acbec711e87ef450ba202235fce5763b" translate="yes" xml:space="preserve">
          <source>These operations are supported by &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 작업은 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="aecd1b14ed0d0c0542d051a642f8a1374b4258e0" translate="yes" xml:space="preserve">
          <source>These operations can also be directly accessed via the &lt;code&gt;.dt&lt;/code&gt; property of the &lt;code&gt;Series&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
