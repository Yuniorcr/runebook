<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="ca2610e9715c8a2e569bd7aa53c90f724ac46b62" translate="yes" xml:space="preserve">
          <source>In contrast to R&amp;rsquo;s &lt;code&gt;factor&lt;/code&gt; function, categorical data is not converting input values to strings; categories will end up the same data type as the original values.</source>
          <target state="translated">R의 &lt;code&gt;factor&lt;/code&gt; 함수 와 달리 범주 형 데이터는 입력 값을 문자열로 변환하지 않습니다. 범주는 원래 값과 동일한 데이터 유형이됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ffe52cd255342dbe3e03a3e2e80eff91ce1577" translate="yes" xml:space="preserve">
          <source>In contrast to R&amp;rsquo;s &lt;code&gt;factor&lt;/code&gt; function, there is currently no way to assign/change labels at creation time. Use &lt;code&gt;categories&lt;/code&gt; to change the categories after creation time.</source>
          <target state="translated">R의 &lt;code&gt;factor&lt;/code&gt; 함수 와 달리 현재는 생성시 레이블을 할당 / 변경할 수있는 방법이 없습니다. 생성 시간 후에 &lt;code&gt;categories&lt;/code&gt; 를 사용하여 카테고리 를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="39d4f8a61ecbf2bcb69e5aced952fcd24459e903" translate="yes" xml:space="preserve">
          <source>In contrast to R&amp;rsquo;s &lt;code&gt;factor&lt;/code&gt; function, using categorical data as the sole input to create a new categorical series will &lt;em&gt;not&lt;/em&gt; remove unused categories but create a new categorical series which is equal to the passed in one!</source>
          <target state="translated">R의 대조적 &lt;code&gt;factor&lt;/code&gt; 기능하는 새로운 범주 시리즈를 생성하는 유일한 입력으로 범주 데이터를 사용 &lt;em&gt;하지&lt;/em&gt; 하나에 전달되는 동일한 미사용 카테고리를 제거하지만 새로운 범주 시리즈를 생성!</target>
        </trans-unit>
        <trans-unit id="dec16f53339f26b0f39b23039c2408ac910c490b" translate="yes" xml:space="preserve">
          <source>In contrast to R&amp;rsquo;s &lt;code&gt;factor&lt;/code&gt;, categorical data can have categories of other types than string.</source>
          <target state="translated">R의 &lt;code&gt;factor&lt;/code&gt; 과 달리 범주 형 데이터에는 문자열이 아닌 다른 유형의 범주가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="171fdac7381916cc04649667798a64026a33e0ff" translate="yes" xml:space="preserve">
          <source>In contrast to statistical categorical variables, categorical data might have an order (e.g. &amp;lsquo;strongly agree&amp;rsquo; vs &amp;lsquo;agree&amp;rsquo; or &amp;lsquo;first observation&amp;rsquo; vs. &amp;lsquo;second observation&amp;rsquo;), but numerical operations (additions, divisions, &amp;hellip;) are not possible.</source>
          <target state="translated">통계적 범주 형 변수와 달리 범주 형 데이터는 순서가있을 수 있지만 (예 : '강하게 동의'vs '동의'또는 '첫 번째 관찰'대 '두 번째 관찰') 수치 연산 (추가, 나누기 등)은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="228452be40c39717913267320e658f2f730c3fc3" translate="yes" xml:space="preserve">
          <source>In contrast, tolerance specifies the maximum distance between the index and indexer values:</source>
          <target state="translated">반대로 허용 오차는 인덱스와 인덱서 값 사이의 최대 거리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b6a0f915345f85f58ff060f5f118ec3bd98c58db" translate="yes" xml:space="preserve">
          <source>In equality and comparison operations, &lt;code&gt;pd.NA&lt;/code&gt; also propagates. This deviates from the behaviour of &lt;code&gt;np.nan&lt;/code&gt;, where comparisons with &lt;code&gt;np.nan&lt;/code&gt; always return &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">동등 및 비교 연산에서 &lt;code&gt;pd.NA&lt;/code&gt; 도 전파됩니다. 이것은 &lt;code&gt;np.nan&lt;/code&gt; 과의 비교가 항상 &lt;code&gt;False&lt;/code&gt; 를 반환 하는 &lt;code&gt;np.nan&lt;/code&gt; 의 동작에서 벗어납니다 .</target>
        </trans-unit>
        <trans-unit id="b1b5ddaa97f0d572d522131bb8f9e951e8621568" translate="yes" xml:space="preserve">
          <source>In financial data analysis and other fields it&amp;rsquo;s common to compute covariance and correlation matrices for a collection of time series. Often one is also interested in moving-window covariance and correlation matrices. This can be done by passing the &lt;code&gt;pairwise&lt;/code&gt; keyword argument, which in the case of &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; inputs will yield a MultiIndexed &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;index&lt;/code&gt; are the dates in question. In the case of a single DataFrame argument the &lt;code&gt;pairwise&lt;/code&gt; argument can even be omitted:</source>
          <target state="translated">재무 데이터 분석 및 기타 필드에서는 시계열 모음에 대한 공분산 및 상관 행렬을 계산하는 것이 일반적입니다. 종종 이동 창 공분산 및 상관 행렬에도 관심이 있습니다. 이는 &lt;code&gt;pairwise&lt;/code&gt; 키워드 인수 를 전달하여 수행 할 수 있으며 , &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 입력 의 경우 &lt;code&gt;index&lt;/code&gt; 이 문제의 날짜 인 MultiIndexed &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 을 생성 합니다. 단일 DataFrame 인수의 경우 &lt;code&gt;pairwise&lt;/code&gt; 인수를 생략 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4082d9202bbb1d702927d6e271d66b5021c5c8fc" translate="yes" xml:space="preserve">
          <source>In float indexes, slicing using floats is allowed.</source>
          <target state="translated">플로트 인덱스에서는 플로트를 사용한 슬라이싱이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c44ad03a36728d64708c34517ecc015d3724fc8" translate="yes" xml:space="preserve">
          <source>In general the best approach for unsupported objects or dtypes is to provide a &lt;code&gt;default_handler&lt;/code&gt;. For example:</source>
          <target state="translated">일반적으로 지원되지 않는 개체 또는 dtype에 대한 가장 좋은 방법은 &lt;code&gt;default_handler&lt;/code&gt; 를 제공하는 것 입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c1dc61019df58ed6d600f5cf8abb4edcc1f978a5" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;../reference/api/pandas.dataframe.query#pandas.DataFrame.query&quot;&gt;&lt;code&gt;DataFrame.query()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; will evaluate the subexpressions that &lt;em&gt;can&lt;/em&gt; be evaluated by &lt;code&gt;numexpr&lt;/code&gt; and those that must be evaluated in Python space transparently to the user. This is done by inferring the result type of an expression from its arguments and operators.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../reference/api/pandas.dataframe.query#pandas.DataFrame.query&quot;&gt; &lt;code&gt;DataFrame.query()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 은 numexpr 로 평가할 &lt;em&gt;수&lt;/em&gt; 있는 하위 표현식 과 사용자에게 투명하게 Python 공간에서 평가 &lt;code&gt;numexpr&lt;/code&gt; 하위 표현식을 평가 합니다. 이는 인수와 연산자에서 표현식의 결과 유형을 유추하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d063b2fde754e7562bff93f40fddcb10c7ecbb69" translate="yes" xml:space="preserve">
          <source>In general, a weighted moving average is calculated as</source>
          <target state="translated">일반적으로 가중 이동 평균은 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a838a69403fce5acf1e2c17335602c6cf991a2" translate="yes" xml:space="preserve">
          <source>In general, disallowing duplicates is &amp;ldquo;sticky&amp;rdquo;. It&amp;rsquo;s preserved through operations.</source>
          <target state="translated">일반적으로 중복을 허용하지 않는 것은 &quot;고정&quot;입니다. 운영을 통해 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="259650fe97ba99ec76dacb5a90539a73222f2839" translate="yes" xml:space="preserve">
          <source>In general, missing values &lt;em&gt;propagate&lt;/em&gt; in operations involving &lt;code&gt;pd.NA&lt;/code&gt;. When one of the operands is unknown, the outcome of the operation is also unknown.</source>
          <target state="translated">일반적으로 누락 된 값 은 &lt;code&gt;pd.NA&lt;/code&gt; 와 관련된 연산에서 &lt;em&gt;전파&lt;/em&gt; 됩니다 . 피연산자 중 하나를 알 수없는 경우 연산 결과도 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b08f4506892da7e04758915cce5b780f6b7d87c" translate="yes" xml:space="preserve">
          <source>In general, the output column names should be unique. You can&amp;rsquo;t apply the same function (or two functions with the same name) to the same column.</source>
          <target state="translated">일반적으로 출력 열 이름은 고유해야합니다. 동일한 열에 동일한 함수 (또는 동일한 이름의 두 함수)를 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="78749b6f08092f1ce25cbd71c63280ae51354419" translate="yes" xml:space="preserve">
          <source>In general, we chose to make the default result of operations between differently indexed objects yield the &lt;strong&gt;union&lt;/strong&gt; of the indexes in order to avoid loss of information. Having an index label, though the data is missing, is typically important information as part of a computation. You of course have the option of dropping labels with missing data via the &lt;strong&gt;dropna&lt;/strong&gt; function.</source>
          <target state="translated">일반적으로 우리는 정보 손실을 방지하기 위해 서로 다른 인덱싱 된 객체 간의 작업의 기본 결과가 인덱스의 &lt;strong&gt;합집합&lt;/strong&gt; 을 생성하도록 선택했습니다 . 인덱스 레이블을 갖는 것은 데이터가 누락되었지만 일반적으로 계산의 일부로 중요한 정보입니다. 물론 &lt;strong&gt;dropna&lt;/strong&gt; 함수 를 통해 누락 된 데이터가있는 레이블을 &lt;strong&gt;삭제할 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="da480b7f2afde37d30a2d3c3628e54abc05ecdd5" translate="yes" xml:space="preserve">
          <source>In light of the above, we have chosen to allow you, the user, to use the &lt;a href=&quot;https://lxml.de&quot;&gt;&lt;strong&gt;lxml&lt;/strong&gt;&lt;/a&gt; backend, but &lt;strong&gt;this backend will use&lt;/strong&gt;&lt;a href=&quot;https://github.com/html5lib/html5lib-python&quot;&gt;&lt;strong&gt;html5lib&lt;/strong&gt;&lt;/a&gt; if &lt;a href=&quot;https://lxml.de&quot;&gt;&lt;strong&gt;lxml&lt;/strong&gt;&lt;/a&gt; fails to parse</source>
          <target state="translated">위의 관점에서, 우리는, 사용자가 사용 할 수 있도록 선택한 &lt;a href=&quot;https://lxml.de&quot;&gt;&lt;strong&gt;LXML의&lt;/strong&gt;&lt;/a&gt; 백엔드를하지만, &lt;strong&gt;이 백엔드를 사용 &lt;/strong&gt;&lt;a href=&quot;https://github.com/html5lib/html5lib-python&quot;&gt;&lt;strong&gt;html5lib을&lt;/strong&gt;&lt;/a&gt; 경우 &lt;a href=&quot;https://lxml.de&quot;&gt;&lt;strong&gt;LXML는&lt;/strong&gt;&lt;/a&gt; 구문 분석에 실패</target>
        </trans-unit>
        <trans-unit id="f9f73b63ad75a78f67b079f95c8d6f90b73e6e7d" translate="yes" xml:space="preserve">
          <source>In most cases &amp;lsquo;block&amp;rsquo; is recommended, since it&amp;rsquo;s more memory efficient.</source>
          <target state="translated">대부분의 경우 메모리 효율이 높기 때문에 'block'이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="8336ab4b3b13dbcf220d99ce0876af633024c8e4" translate="yes" xml:space="preserve">
          <source>In most cases, there should be no functional difference from using &lt;code&gt;deep&lt;/code&gt;, but if &lt;code&gt;deep&lt;/code&gt; is passed it will attempt to deepcopy.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;deep&lt;/code&gt; 을 사용하는 것과 기능상의 차이가 없어야 하지만 &lt;code&gt;deep&lt;/code&gt; 이 전달 되면 deepcopy를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="e7236bf78d95a69537f8d46ae9cbc58792f758fb" translate="yes" xml:space="preserve">
          <source>In most cases, this should return a NumPy ndarray. For exceptional cases like &lt;code&gt;SparseArray&lt;/code&gt;, where returning an ndarray would be expensive, an ExtensionArray may be returned.</source>
          <target state="translated">대부분의 경우 NumPy ndarray를 반환해야합니다. 같은 예외적 인 경우를 들어 &lt;code&gt;SparseArray&lt;/code&gt; ndarray를 반환하는 것은 비싼 것, ExtensionArray가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe70f0710a5d456f37bf36546298c73bcb3224c1" translate="yes" xml:space="preserve">
          <source>In non-float indexes, slicing using floats will raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">non-float 인덱스에서 float를 사용하여 슬라이싱하면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="eb4978a8a882d0859681db3419e727cf4c1588e0" translate="yes" xml:space="preserve">
          <source>In older versions of pandas, the &lt;code&gt;SparseSeries&lt;/code&gt; and &lt;code&gt;SparseDataFrame&lt;/code&gt; classes (documented below) were the preferred way to work with sparse data. With the advent of extension arrays, these subclasses are no longer needed. Their purpose is better served by using a regular Series or DataFrame with sparse values instead.</source>
          <target state="translated">이전 버전의 &lt;code&gt;SparseSeries&lt;/code&gt; 에서는 SparseSeries 및 &lt;code&gt;SparseDataFrame&lt;/code&gt; 클래스 (아래에 문서화 됨)가 희소 데이터로 작업하는 데 선호되는 방법이었습니다. 확장 배열의 출현으로 이러한 하위 클래스는 더 이상 필요하지 않습니다. 그 목적은 대신 희소 값이있는 일반 Series 또는 DataFrame을 사용하는 것이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="232fa83c2f577f58ba8577c3e595c730f748ca9b" translate="yes" xml:space="preserve">
          <source>In order to add another DataFrame or Series to an existing HDF file please use append mode and a different a key.</source>
          <target state="translated">기존 HDF 파일에 다른 DataFrame 또는 Series를 추가하려면 추가 모드와 다른 키를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1b0afa3d6d26046ee6452876661c15d2f2382218" translate="yes" xml:space="preserve">
          <source>In order to parse this file into a &lt;code&gt;DataFrame&lt;/code&gt;, we simply need to supply the column specifications to the &lt;code&gt;read_fwf&lt;/code&gt; function along with the file name:</source>
          <target state="translated">이 파일을 &lt;code&gt;DataFrame&lt;/code&gt; 으로 파싱 하려면 파일 이름과 함께 &lt;code&gt;read_fwf&lt;/code&gt; 함수에 열 사양을 제공하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="341d1b0692859d5a9b5538d1b0f8b6894fa1d38c" translate="yes" xml:space="preserve">
          <source>In order to resample to work on indices that are non-datetimelike, the following procedure can be utilized.</source>
          <target state="translated">날짜 시간과 다른 인덱스에 대해 작업하기 위해 리샘플링하려면 다음 절차를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c67e9d7bf7291459bbafc885937d9138dcad0d8" translate="yes" xml:space="preserve">
          <source>In order to use &lt;a href=&quot;../reference/api/pandas.read_sql_table#pandas.read_sql_table&quot;&gt;&lt;code&gt;read_sql_table()&lt;/code&gt;&lt;/a&gt;, you &lt;strong&gt;must&lt;/strong&gt; have the SQLAlchemy optional dependency installed.</source>
          <target state="translated">사용하려면 &lt;a href=&quot;../reference/api/pandas.read_sql_table#pandas.read_sql_table&quot;&gt; &lt;code&gt;read_sql_table()&lt;/code&gt; &lt;/a&gt; , 당신은 &lt;strong&gt;해야한다&lt;/strong&gt; SQLAlchemy의 옵션 의존성이 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf4d6d851cc83c991a7ffa70015127baf12f5309" translate="yes" xml:space="preserve">
          <source>In order to write separate &lt;code&gt;DataFrames&lt;/code&gt; to separate sheets in a single Excel file, one can pass an &lt;code&gt;ExcelWriter&lt;/code&gt;.</source>
          <target state="translated">단일 Excel 파일의 개별 시트에 별도의 &lt;code&gt;DataFrames&lt;/code&gt; 을 작성 하려면 &lt;code&gt;ExcelWriter&lt;/code&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b94d9410b50138773dd5dd1be3cf191c15835cf7" translate="yes" xml:space="preserve">
          <source>In pandas there are a few objects implemented which can serve as valid containers for the axis labels:</source>
          <target state="translated">팬더에는 축 레이블의 유효한 컨테이너 역할을 할 수있는 몇 가지 객체가 구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="208f80104ac64839558570440d5448887e455fb3" translate="yes" xml:space="preserve">
          <source>In pandas, if no index is specified, an integer index is also used by default (first row = 0, second row = 1, and so on). While using a labeled &lt;code&gt;Index&lt;/code&gt; or &lt;code&gt;MultiIndex&lt;/code&gt; can enable sophisticated analyses and is ultimately an important part of pandas to understand, for this comparison we will essentially ignore the &lt;code&gt;Index&lt;/code&gt; and just treat the &lt;code&gt;DataFrame&lt;/code&gt; as a collection of columns. Please see the &lt;a href=&quot;../../user_guide/indexing#indexing&quot;&gt;indexing documentation&lt;/a&gt; for much more on how to use an &lt;code&gt;Index&lt;/code&gt; effectively.</source>
          <target state="translated">팬더에서 인덱스를 지정하지 않으면 기본적으로 정수 인덱스도 사용됩니다 (첫 번째 행 = 0, 두 번째 행 = 1 등). 레이블이있는 &lt;code&gt;Index&lt;/code&gt; 또는 &lt;code&gt;MultiIndex&lt;/code&gt; 를 사용하면 정교한 분석이 가능하고 궁극적으로 팬더가 이해하는 데 중요한 부분이지만,이 비교를 위해 우리는 본질적으로 &lt;code&gt;Index&lt;/code&gt; 를 무시 하고 &lt;code&gt;DataFrame&lt;/code&gt; 을 열 컬렉션으로 취급합니다 . &lt;code&gt;Index&lt;/code&gt; 효과적으로 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;../../user_guide/indexing#indexing&quot;&gt;색인 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="111bed95681d0ed9357d61fc09163726d2a62557" translate="yes" xml:space="preserve">
          <source>In particular, StringDtype.na_value may change to no longer be &lt;code&gt;numpy.nan&lt;/code&gt;.</source>
          <target state="translated">특히 StringDtype.na_value가 더 이상 &lt;code&gt;numpy.nan&lt;/code&gt; 이되지 않도록 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edb6b540969823ae01a77803b2362941a5666f2e" translate="yes" xml:space="preserve">
          <source>In particular, this allows users to define functions that take a styler object, along with other parameters, and return the styler after making styling changes (such as calling &lt;a href=&quot;pandas.io.formats.style.styler.apply#pandas.io.formats.style.Styler.apply&quot;&gt;&lt;code&gt;Styler.apply()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;pandas.io.formats.style.styler.set_properties#pandas.io.formats.style.Styler.set_properties&quot;&gt;&lt;code&gt;Styler.set_properties()&lt;/code&gt;&lt;/a&gt;). Using &lt;code&gt;.pipe&lt;/code&gt;, these user-defined style &amp;ldquo;transformations&amp;rdquo; can be interleaved with calls to the built-in Styler interface.</source>
          <target state="translated">특히,이를 통해 사용자는 다른 매개 변수와 함께 스타일러 객체를 사용하고 스타일을 변경 한 후 (예 : &lt;a href=&quot;pandas.io.formats.style.styler.apply#pandas.io.formats.style.Styler.apply&quot;&gt; &lt;code&gt;Styler.apply()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;pandas.io.formats.style.styler.set_properties#pandas.io.formats.style.Styler.set_properties&quot;&gt; &lt;code&gt;Styler.set_properties()&lt;/code&gt; &lt;/a&gt; 호출 ) 스타일러를 반환하는 함수를 정의 할 수 있습니다 . &lt;code&gt;.pipe&lt;/code&gt; 를 사용하면 이러한 사용자 정의 스타일 &quot;변환&quot;을 내장 스타일러 인터페이스에 대한 호출과 함께 인터리브 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee158349efaa8f54191cd70ad5a2ac1fb3f0ce29" translate="yes" xml:space="preserve">
          <source>In practice this becomes very cumbersome because we often need a very long index with a large number of timestamps. If we need timestamps on a regular frequency, we can use the &lt;a href=&quot;../reference/api/pandas.date_range#pandas.date_range&quot;&gt;&lt;code&gt;date_range()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/api/pandas.bdate_range#pandas.bdate_range&quot;&gt;&lt;code&gt;bdate_range()&lt;/code&gt;&lt;/a&gt; functions to create a &lt;code&gt;DatetimeIndex&lt;/code&gt;. The default frequency for &lt;code&gt;date_range&lt;/code&gt; is a &lt;strong&gt;calendar day&lt;/strong&gt; while the default for &lt;code&gt;bdate_range&lt;/code&gt; is a &lt;strong&gt;business day&lt;/strong&gt;:</source>
          <target state="translated">실제로 많은 수의 타임 스탬프가있는 매우 긴 인덱스가 필요한 경우가 많기 때문에 이것은 매우 번거 롭습니다. 일정한 빈도의 타임 스탬프가 필요한 경우 &lt;a href=&quot;../reference/api/pandas.date_range#pandas.date_range&quot;&gt; &lt;code&gt;date_range()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.bdate_range#pandas.bdate_range&quot;&gt; &lt;code&gt;bdate_range()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 &lt;code&gt;DatetimeIndex&lt;/code&gt; 를 만들 수 있습니다 . &lt;code&gt;date_range&lt;/code&gt; 의 기본 빈도 는 &lt;strong&gt;달력 일&lt;/strong&gt; 이고 &lt;code&gt;bdate_range&lt;/code&gt; 의 기본값 은 &lt;strong&gt;영업일입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3607b1c4296c5afb091a5295f0b11cfaf0b37dcc" translate="yes" xml:space="preserve">
          <source>In prior versions, using &lt;code&gt;.loc[list-of-labels]&lt;/code&gt; would work as long as &lt;em&gt;at least 1&lt;/em&gt; of the keys was found (otherwise it would raise a &lt;code&gt;KeyError&lt;/code&gt;). This behavior was changed and will now raise a &lt;code&gt;KeyError&lt;/code&gt; if at least one label is missing. The recommended alternative is to use &lt;code&gt;.reindex()&lt;/code&gt;.</source>
          <target state="translated">이전 버전에서 &lt;code&gt;.loc[list-of-labels]&lt;/code&gt; 은 키 &lt;em&gt;중 하나 이상&lt;/em&gt; 이 발견되는 한 작동합니다 (그렇지 않으면 &lt;code&gt;KeyError&lt;/code&gt; 를 발생 시킵니다). 이 동작은 변경되었으며 이제 하나 이상의 레이블이 누락 된 경우 &lt;code&gt;KeyError&lt;/code&gt; 를 발생시킵니다. 권장되는 대안은 &lt;code&gt;.reindex()&lt;/code&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6aef9cc62198b3171fb1e517275a75345d3d9d0b" translate="yes" xml:space="preserve">
          <source>In rare occasions reST styles like bold text or italics will be used in docstrings, but is it common to have inline code, which is presented between backticks. It is considered inline code:</source>
          <target state="translated">드문 경우지만 굵은 텍스트 나 이탤릭체와 같은 reST 스타일이 docstring에 사용되지만 인라인 코드를 사용하는 것이 일반적이며 백틱 사이에 표시됩니다. 인라인 코드로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a95c7b0e602d68a0efa9cfdaa2ff21908ff334ab" translate="yes" xml:space="preserve">
          <source>In short, basic iteration (&lt;code&gt;for i in object&lt;/code&gt;) produces:</source>
          <target state="translated">간단히 말해, 기본 반복 ( &lt;code&gt;for i in object&lt;/code&gt; )은 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7f193164f8ff830f495338165002ed0df364bcce" translate="yes" xml:space="preserve">
          <source>In some cases, inferring the DST is impossible. In such cases, you can pass an ndarray to the ambiguous parameter to set the DST explicitly</source>
          <target state="translated">어떤 경우에는 DST를 유추하는 것이 불가능합니다. 이러한 경우 NST를 모호한 매개 변수에 전달하여 DST를 명시 적으로 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="617add62147541c41e4cc987404e47efd9b2c702" translate="yes" xml:space="preserve">
          <source>In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example,</source>
          <target state="translated">경우에 따라 혼합 된 dtype이 포함 된 열이있는 비정상 데이터를 읽으면 데이터 세트가 일치하지 않게됩니다. 열의 dtype을 추론하기 위해 pandas에 의존하는 경우 파싱 엔진은 한 번에 전체 데이터 세트가 아닌 데이터의 다른 청크에 대한 dtype을 추론합니다. 결과적으로 혼합 된 dtype이있는 열로 끝날 수 있습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="7a355a2574a3b984a4c5cca59d1dd36b469b10cb" translate="yes" xml:space="preserve">
          <source>In some situations it may still be preferable or necessary to prepare plots directly with matplotlib, for instance when a certain type of plot or customization is not (yet) supported by pandas. &lt;code&gt;Series&lt;/code&gt; and &lt;code&gt;DataFrame&lt;/code&gt; objects behave like arrays and can therefore be passed directly to matplotlib functions without explicit casts.</source>
          <target state="translated">일부 상황에서는 특정 유형의 플롯 또는 사용자 정의가 (아직) Pandas에서 지원되지 않는 경우와 같이 matplotlib로 직접 플롯을 준비하는 것이 더 바람직하거나 필요할 수 있습니다. &lt;code&gt;Series&lt;/code&gt; 및 &lt;code&gt;DataFrame&lt;/code&gt; 객체는 배열처럼 작동하므로 명시 적 캐스트없이 matplotlib 함수에 직접 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b41f8a671dcb59bac9331a53cb4c0003fd8ac2d" translate="yes" xml:space="preserve">
          <source>In statistics, &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_density_estimation&quot;&gt;kernel density estimation&lt;/a&gt; (KDE) is a non-parametric way to estimate the probability density function (PDF) of a random variable. This function uses Gaussian kernels and includes automatic bandwidth determination.</source>
          <target state="translated">통계에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_density_estimation&quot;&gt;커널 밀도 추정&lt;/a&gt; (KDE)은 랜덤 변수의 확률 밀도 함수 (PDF)를 추정하는 비모수 적 방법입니다. 이 기능은 가우스 커널을 사용하며 자동 대역폭 결정을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="259e03c33747a655ccf113b4924898904644dca6" translate="yes" xml:space="preserve">
          <source>In statistics, imputation is the process of replacing missing data with substituted values &lt;a href=&quot;#r26d0aea2a9b7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency).</source>
          <target state="translated">통계에서 대치 란 결측 데이터를 대체 된 값으로 대체하는 프로세스입니다 &lt;a href=&quot;#r26d0aea2a9b7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 데이터를 리샘플링 할 때 결 측값이 나타날 수 있습니다 (예 : 리샘플링 주파수가 원래 주파수보다 높을 때).</target>
        </trans-unit>
        <trans-unit id="d0491d129e4f29db5d2c69ef3a8023377ee66007" translate="yes" xml:space="preserve">
          <source>In statistics, imputation is the process of replacing missing data with substituted values &lt;a href=&quot;#r3ead377f0eb9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency). The backward fill will replace NaN values that appeared in the resampled data with the next value in the original sequence. Missing values that existed in the original data will not be modified.</source>
          <target state="translated">통계에서 대치 란 결측 데이터를 대체 된 값으로 대체하는 프로세스입니다 &lt;a href=&quot;#r3ead377f0eb9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 데이터를 리샘플링 할 때 결 측값이 나타날 수 있습니다 (예 : 리샘플링 주파수가 원래 주파수보다 높을 때). 뒤로 채우기는 재 샘플링 된 데이터에 나타난 NaN 값을 원래 순서의 다음 값으로 바꿉니다. 원래 데이터에 존재했던 결 측값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="365ec27a333aa600790256c375c2a9d1f665b634" translate="yes" xml:space="preserve">
          <source>In statistics, imputation is the process of replacing missing data with substituted values &lt;a href=&quot;#rbbbeff54acb7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. When resampling data, missing values may appear (e.g., when the resampling frequency is higher than the original frequency). The backward fill will replace NaN values that appeared in the resampled data with the next value in the original sequence. Missing values that existed in the original data will not be modified.</source>
          <target state="translated">통계에서 대치 란 결측 데이터를 대체 된 값으로 대체하는 프로세스입니다 &lt;a href=&quot;#rbbbeff54acb7-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 데이터를 리샘플링 할 때 결 측값이 나타날 수 있습니다 (예 : 리샘플링 주파수가 원래 주파수보다 높을 때). 뒤로 채우기는 재 샘플링 된 데이터에 나타난 NaN 값을 원래 순서의 다음 값으로 바꿉니다. 원래 데이터에 존재했던 결 측값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="374e59aeb9e272874547c17798f8ea92262e4441" translate="yes" xml:space="preserve">
          <source>In terms of performance, &lt;strong&gt;the first time a function is run using the Numba engine will be slow&lt;/strong&gt; as Numba will have some function compilation overhead. However, the compiled functions are cached, and subsequent calls will be fast. In general, the Numba engine is performant with a larger amount of data points (e.g. 1+ million).</source>
          <target state="translated">성능 측면 &lt;strong&gt;에서 Numba 엔진을 사용하여 함수를 처음 실행하면 Numba&lt;/strong&gt; 가 약간의 함수 컴파일 오버 헤드를 가지 &lt;strong&gt;므로 속도가 느려집니다&lt;/strong&gt; . 그러나 컴파일 된 함수는 캐시되고 후속 호출은 빠릅니다. 일반적으로 Numba 엔진은 더 많은 양의 데이터 포인트 (예 : 1 백만 이상)에서 성능이 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="f180f96592c966e9d354895961cc77b54f367f90" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;DATA&lt;/code&gt; step, arbitrary math expressions can be used on new or existing columns.</source>
          <target state="translated">에서 &lt;code&gt;DATA&lt;/code&gt; 단계, 임의 연산 표현식은 신규 또는 기존 열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df65d95ebbd2e2600fc4f4e540a8437a5d89f88a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Series&lt;/code&gt; case this is effectively an appending operation.</source>
          <target state="translated">에서 &lt;code&gt;Series&lt;/code&gt; 경우이 효과적으로 추기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="c834f0b0defa5dd6dad9cc79a23846d158a35cec" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;pyarrow&lt;/code&gt; engine, categorical dtypes for non-string types can be serialized to parquet, but will de-serialize as their primitive dtype.</source>
          <target state="translated">에서 &lt;code&gt;pyarrow&lt;/code&gt; 의 엔진, 문자열이 아닌 유형의 범주 dtypes는 마루에 직렬화 할 수 있지만, 역 직렬화를합니다 그들의 원시적 DTYPE한다.</target>
        </trans-unit>
        <trans-unit id="c1e9516f84b5cd57b51a1a7fc9435ddc0c15d29c" translate="yes" xml:space="preserve">
          <source>In the absence of high performance &lt;code&gt;NA&lt;/code&gt; support being built into NumPy from the ground up, the primary casualty is the ability to represent NAs in integer arrays. For example:</source>
          <target state="translated">처음부터 NumPy에 고성능 &lt;code&gt;NA&lt;/code&gt; 지원이 구축되지 않은 경우, 주요 피해는 NA를 정수 배열로 표현할 수있는 능력입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f36ea6a18bdd557fb07ea425002b7742c741b5b0" translate="yes" xml:space="preserve">
          <source>In the below examples, the first level of the MultiIndex is sorted because a&amp;lt;b&amp;lt;c, so there is no need to look at the next level.</source>
          <target state="translated">아래 예에서 MultiIndex의 첫 번째 수준은 a &amp;lt;b &amp;lt;c이기 때문에 정렬되므로 다음 수준을 볼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c18c64769dd7f0d0d990c0a999da9c6309f9c36" translate="yes" xml:space="preserve">
          <source>In the case of</source>
          <target state="translated">의 경우</target>
        </trans-unit>
        <trans-unit id="f7b145dc931b9b0873d88038293a88e6162dbf31" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;DataFrame&lt;/code&gt;, the indexes must be disjoint but the columns do not need to be:</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 의 경우 인덱스는 분리되어야하지만 열은 다음과 같을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="76a837351c5dbce74c7205b080161bdf34badf75" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;MultiIndex&lt;/code&gt; you must either specify &lt;code&gt;values&lt;/code&gt; as a list-like object containing tuples that are the same length as the number of levels, or specify &lt;code&gt;level&lt;/code&gt;. Otherwise it will raise a &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="translated">의 경우 &lt;code&gt;MultiIndex&lt;/code&gt; 당신이 중 하나를 지정해야합니다 &lt;code&gt;values&lt;/code&gt; 레벨의 수와 같은 길이 있습니다 목록과 같은 오브젝트가 포함 튜플로, 또는 지정 &lt;code&gt;level&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="1eb45768c0db923de91d976966e4ce4de72b6814" translate="yes" xml:space="preserve">
          <source>In the case of grouping by multiple keys, the group name will be a tuple:</source>
          <target state="translated">여러 키로 그룹화하는 경우 그룹 이름은 튜플이됩니다.</target>
        </trans-unit>
        <trans-unit id="f42e5a7b12d256c55fa2906b61eb1a41a8c27f43" translate="yes" xml:space="preserve">
          <source>In the case of missing elements, only complete pairwise observations will be used.</source>
          <target state="translated">요소가 누락 된 경우 완전한 쌍별 관측치 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93c3a3c7e5f7f8c6cc129267a8f0244664f6c030" translate="yes" xml:space="preserve">
          <source>In the current implementation apply calls &lt;code&gt;func&lt;/code&gt; twice on the first column/row to decide whether it can take a fast or slow code path. This can lead to unexpected behavior if &lt;code&gt;func&lt;/code&gt; has side-effects, as they will take effect twice for the first column/row.</source>
          <target state="translated">현재 구현 에서는 첫 번째 열 / 행에서 &lt;code&gt;func&lt;/code&gt; 를 두 번 적용 하여 코드 경로가 빠르거나 느린 지 여부를 결정합니다. &lt;code&gt;func&lt;/code&gt; 에 부작용이있는 경우 첫 번째 열 / 행에 대해 두 번 적용되므로 예기치 않은 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb59999cec8f71616204455442b4171be5f75280" translate="yes" xml:space="preserve">
          <source>In the current implementation applymap calls &lt;code&gt;func&lt;/code&gt; twice on the first column/row to decide whether it can take a fast or slow code path. This can lead to unexpected behavior if &lt;code&gt;func&lt;/code&gt; has side-effects, as they will take effect twice for the first column/row.</source>
          <target state="translated">현재 구현에서 applymap 은 첫 번째 열 / 행에서 &lt;code&gt;func&lt;/code&gt; 를 두 번 호출 하여 빠른 또는 느린 코드 경로를 사용할 수 있는지 여부를 결정합니다. &lt;code&gt;func&lt;/code&gt; 에 부작용이있는 경우 첫 번째 열 / 행에 대해 두 번 적용되므로 예기치 않은 동작이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e51e88b817ad3bcafc0c9fc36ef12166900cc138" translate="yes" xml:space="preserve">
          <source>In the default setting, the string is split by whitespace.</source>
          <target state="translated">기본 설정에서 문자열은 공백으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="4d5874c08a93fe7637eb607b79d1f52f99c5603f" translate="yes" xml:space="preserve">
          <source>In the event that there aren&amp;rsquo;t overlapping indexes an empty DataFrame will be returned.</source>
          <target state="translated">겹치는 인덱스가없는 경우 빈 DataFrame이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a5777b9ed7829ebd0c8b5358f54760cae6af6f09" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;5.0&lt;/code&gt; will be recognized as &lt;code&gt;NaN&lt;/code&gt;, in addition to the defaults. A string will first be interpreted as a numerical &lt;code&gt;5&lt;/code&gt;, then as a &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;5&lt;/code&gt; 와 &lt;code&gt;5.0&lt;/code&gt; 은 기본값 외에도 &lt;code&gt;NaN&lt;/code&gt; 으로 인식됩니다 . 문자열은 먼저 숫자 &lt;code&gt;5&lt;/code&gt; 로 해석 된 다음 &lt;code&gt;NaN&lt;/code&gt; 으로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="e75d6df5005f2fe21ff1befe0bcc75d5b1cbbf47" translate="yes" xml:space="preserve">
          <source>In the example above, if you were on a Python version lower than 3.6 or a pandas version lower than 0.23, the &lt;code&gt;Series&lt;/code&gt; would be ordered by the lexical order of the dict keys (i.e. &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; rather than &lt;code&gt;['b', 'a', 'c']&lt;/code&gt;).</source>
          <target state="translated">위의 예에서 3.6 미만의 Python 버전 또는 0.23 미만의 pandas 버전을 사용하는 경우 &lt;code&gt;Series&lt;/code&gt; 는 사전 키의 어휘 순서 (예 : &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; 에 따라 정렬됩니다. ] 대신 &lt;code&gt;['b', 'a', 'c']&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1dde277c7382d4ae5f38cf47f494f05ce168e8e" translate="yes" xml:space="preserve">
          <source>In the example above, the functions &lt;code&gt;extract_city_name&lt;/code&gt; and &lt;code&gt;add_country_name&lt;/code&gt; each expected a &lt;code&gt;DataFrame&lt;/code&gt; as the first positional argument. What if the function you wish to apply takes its data as, say, the second argument? In this case, provide &lt;code&gt;pipe&lt;/code&gt; with a tuple of &lt;code&gt;(callable, data_keyword)&lt;/code&gt;. &lt;code&gt;.pipe&lt;/code&gt; will route the &lt;code&gt;DataFrame&lt;/code&gt; to the argument specified in the tuple.</source>
          <target state="translated">위의 예에서 &lt;code&gt;extract_city_name&lt;/code&gt; 및 &lt;code&gt;add_country_name&lt;/code&gt; 함수는 각각 첫 번째 위치 인수로 &lt;code&gt;DataFrame&lt;/code&gt; 을 예상했습니다 . 적용하려는 함수가 데이터를 두 번째 인수로 사용하면 어떻게 될까요? 이 경우 &lt;code&gt;pipe&lt;/code&gt; 에 &lt;code&gt;(callable, data_keyword)&lt;/code&gt; 튜플을 제공하십시오 . &lt;code&gt;.pipe&lt;/code&gt; 는 &lt;code&gt;DataFrame&lt;/code&gt; 을 튜플에 지정된 인수로 라우팅합니다 .</target>
        </trans-unit>
        <trans-unit id="77e7c1f9b1b324cdde10962f89d1425e0096b371" translate="yes" xml:space="preserve">
          <source>In the example above, we inserted a precomputed value. We can also pass in a function of one argument to be evaluated on the DataFrame being assigned to.</source>
          <target state="translated">위의 예에서는 미리 계산 된 값을 삽입했습니다. 할당되는 DataFrame에서 평가할 하나의 인수 함수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="17eaeae90e1b643c48789a2e25b2527a1eae0445" translate="yes" xml:space="preserve">
          <source>In the example below we have a DataFrame with the information about planet&amp;rsquo;s mass and radius. We pass the &amp;lsquo;mass&amp;rsquo; column to the pie function to get a pie plot.</source>
          <target state="translated">아래 예에는 행성의 질량과 반지름에 대한 정보가 포함 된 DataFrame이 있습니다. 파이 플롯을 얻기 위해 '질량'열을 파이 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="6053812ef83ad3af3bf5390b7deb7bf927dbe97a" translate="yes" xml:space="preserve">
          <source>In the example below we have a DataFrame with the information about planet&amp;rsquo;s mass and radius. We pass the the &amp;lsquo;mass&amp;rsquo; column to the pie function to get a pie plot.</source>
          <target state="translated">아래 예제에는 행성의 질량과 반경에 대한 정보가있는 DataFrame이 있습니다. 파이 질량을 얻기 위해 '질량'열을 파이 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9166af0daf87385f45c0c7517450bf89ed4441bf" translate="yes" xml:space="preserve">
          <source>In the example below, we transform the &lt;code&gt;Series&lt;/code&gt; to a sparse representation of a 2-d array by specifying that the first and second &lt;code&gt;MultiIndex&lt;/code&gt; levels define labels for the rows and the third and fourth levels define labels for the columns. We also specify that the column and row labels should be sorted in the final sparse representation.</source>
          <target state="translated">아래 예에서는 첫 번째 및 두 번째 &lt;code&gt;MultiIndex&lt;/code&gt; 수준이 행에 대한 레이블을 정의하고 세 번째 및 네 번째 수준이 열에 대한 레이블을 정의 하도록 지정 하여 &lt;code&gt;Series&lt;/code&gt; 를 2 차원 배열의 희소 표현으로 변환합니다 . 또한 열 및 행 레이블이 최종 희소 표현으로 정렬되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c05d0c8cefe1a8e069cd89dca3a7b65e36a26f75" translate="yes" xml:space="preserve">
          <source>In the examples above where we passed &lt;code&gt;dtype='category'&lt;/code&gt;, we used the default behavior:</source>
          <target state="translated">&lt;code&gt;dtype='category'&lt;/code&gt; 를 전달한 위의 예에서는 기본 동작을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="bebe01532250910835b2b2fabdcc554f6b7127b8" translate="yes" xml:space="preserve">
          <source>In the following example, there are duplicate values of &lt;code&gt;B&lt;/code&gt; in the right &lt;code&gt;DataFrame&lt;/code&gt;. As this is not a one-to-one merge &amp;ndash; as specified in the &lt;code&gt;validate&lt;/code&gt; argument &amp;ndash; an exception will be raised.</source>
          <target state="translated">다음 예제에서는 오른쪽 &lt;code&gt;DataFrame&lt;/code&gt; 에 중복 된 &lt;code&gt;B&lt;/code&gt; 값이 있습니다. &lt;code&gt;validate&lt;/code&gt; 인수에 지정된 일대일 병합이 아니기 때문에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa442983b6a44794cf5c6d987a5a2c9d34caa5bb" translate="yes" xml:space="preserve">
          <source>In the following example, we use the &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;SQlite&lt;/a&gt; SQL database engine. You can use a temporary SQLite database where data are stored in &amp;ldquo;memory&amp;rdquo;.</source>
          <target state="translated">다음 예에서는 &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;SQlite&lt;/a&gt; SQL 데이터베이스 엔진을 사용합니다 . 데이터가 &quot;메모리&quot;에 저장되는 임시 SQLite 데이터베이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c78f24c44017f391c8bd0a0453e4110abf6899" translate="yes" xml:space="preserve">
          <source>In the following example, we will use &lt;code&gt;nlargest&lt;/code&gt; to select the three rows having the largest values in column &amp;ldquo;population&amp;rdquo;.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;nlargest&lt;/code&gt; 를 사용 하여&amp;ldquo;population&amp;rdquo;열에서 가장 큰 값을 가진 3 개의 행을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3aa4c18ddfff7abd52cefa162c779546126fccb6" translate="yes" xml:space="preserve">
          <source>In the following example, we will use &lt;code&gt;nsmallest&lt;/code&gt; to select the three rows having the smallest values in column &amp;ldquo;a&amp;rdquo;.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;nsmallest&lt;/code&gt; 를 사용 하여&amp;ldquo;a&amp;rdquo;열에서 가장 작은 값을 가진 3 개의 행을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="74119509e91e7b82dfd9057bd94f64fcb898b1b8" translate="yes" xml:space="preserve">
          <source>In the following example, we will use &lt;code&gt;nsmallest&lt;/code&gt; to select the three rows having the smallest values in column &amp;ldquo;population&amp;rdquo;.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;nsmallest&lt;/code&gt; 를 사용 하여 &quot;population&quot;열에서 가장 작은 값을 가진 3 개의 행을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5d23322a45ea5c7c01acbb75f4ab73ae0e050883" translate="yes" xml:space="preserve">
          <source>In the following examples, &lt;strong&gt;df.index // 5&lt;/strong&gt; returns a binary array which is used to determine what gets selected for the groupby operation.</source>
          <target state="translated">다음 예에서 &lt;strong&gt;df.index // 5&lt;/strong&gt; 는 groupby 작업에 대해 선택되는 항목을 결정하는 데 사용되는 이진 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7a3bc009a766f26328d46a5e52c0bd852ea0d66" translate="yes" xml:space="preserve">
          <source>In the following sub-sections we will highlight some other index types.</source>
          <target state="translated">다음 하위 섹션에서는 몇 가지 다른 인덱스 유형을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="89d62d2b055a58010c61f758ad207c83aae7b942" translate="yes" xml:space="preserve">
          <source>In the future, as new dtypes are added that support &lt;code&gt;pd.NA&lt;/code&gt;, the results of this method will change to support those new dtypes.</source>
          <target state="translated">새로운 dtypes가 지원하는 추가되는 미래에 &lt;code&gt;pd.NA&lt;/code&gt; 을 ,이 방법의 결과는 그 새로운 dtypes을 지원하기 위해 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cdb05e1d57b2e1300e54b55c509ba2fad3a4bfb3" translate="yes" xml:space="preserve">
          <source>In the future, we may provide an option for &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; to infer a nullable-integer dtype.</source>
          <target state="translated">향후에는 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 가 nullable-integer dtype을 추론 하는 옵션을 제공 할 수 있습니다 . ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="9a2a4afb7bc64d9f387b41f3f07550809b3eb5d3" translate="yes" xml:space="preserve">
          <source>In the most basic use-case, &lt;code&gt;read_excel&lt;/code&gt; takes a path to an Excel file, and the &lt;code&gt;sheet_name&lt;/code&gt; indicating which sheet to parse.</source>
          <target state="translated">가장 기본적인 사용 사례에서 &lt;code&gt;read_excel&lt;/code&gt; 은 Excel 파일의 경로와 구문 분석 할 시트를 나타내는 &lt;code&gt;sheet_name&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08e30d2ced03ecc282e576f7d7d31b4cdf990d3b" translate="yes" xml:space="preserve">
          <source>In the past, pandas recommended &lt;a href=&quot;../reference/api/pandas.series.values#pandas.Series.values&quot;&gt;&lt;code&gt;Series.values&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe.values#pandas.DataFrame.values&quot;&gt;&lt;code&gt;DataFrame.values&lt;/code&gt;&lt;/a&gt; for extracting the data from a Series or DataFrame. You&amp;rsquo;ll still find references to these in old code bases and online. Going forward, we recommend avoiding &lt;code&gt;.values&lt;/code&gt; and using &lt;code&gt;.array&lt;/code&gt; or &lt;code&gt;.to_numpy()&lt;/code&gt;. &lt;code&gt;.values&lt;/code&gt; has the following drawbacks:</source>
          <target state="translated">과거에 &lt;a href=&quot;../reference/api/pandas.series.values#pandas.Series.values&quot;&gt; &lt;code&gt;Series.values&lt;/code&gt; &lt;/a&gt; 는 Series 또는 DataFrame에서 데이터를 추출하기 위해 Series.values 또는 &lt;a href=&quot;../reference/api/pandas.dataframe.values#pandas.DataFrame.values&quot;&gt; &lt;code&gt;DataFrame.values&lt;/code&gt; &lt;/a&gt; 를 권장 했습니다. 이전 코드베이스와 온라인에서 여전히 이들에 대한 참조를 찾을 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 앞으로는 &lt;code&gt;.values&lt;/code&gt; 를 피하고 &lt;code&gt;.array&lt;/code&gt; 또는 &lt;code&gt;.to_numpy()&lt;/code&gt; 사용하는 것이 좋습니다 . &lt;code&gt;.values&lt;/code&gt; 에는 다음과 같은 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="76a502ee5e15ede96777e89789dba9cb526898f5" translate="yes" xml:space="preserve">
          <source>In the preceding examples, frequency strings (e.g. &lt;code&gt;'D'&lt;/code&gt;) were used to specify a frequency that defined:</source>
          <target state="translated">앞의 예에서 주파수 문자열 (예 : &lt;code&gt;'D'&lt;/code&gt; )은 다음을 정의하는 주파수를 지정하는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a8d37ff91777bc82ff2a7c2702d2ea571e879266" translate="yes" xml:space="preserve">
          <source>In the previous example, the resulting value for duck is missing, because the maximum of a NaN and a float is a NaN. So, in the example, we set &lt;code&gt;fill_value=0&lt;/code&gt;, so the maximum value returned will be the value from some dataset.</source>
          <target state="translated">이전 예에서 NaN 및 부동 소수점 최대 값이 NaN이므로 duck의 결과 값이 누락되었습니다. 따라서이 예에서는 &lt;code&gt;fill_value=0&lt;/code&gt; 을 설정 하므로 반환되는 최대 값은 일부 데이터 세트의 값입니다.</target>
        </trans-unit>
        <trans-unit id="473f5d078fd028f0ed65d8ad425df3522514dc38" translate="yes" xml:space="preserve">
          <source>In the second expression, &lt;code&gt;x['C']&lt;/code&gt; will refer to the newly created column, that&amp;rsquo;s equal to &lt;code&gt;dfa['A'] + dfa['B']&lt;/code&gt;.</source>
          <target state="translated">두 번째 표현식에서 &lt;code&gt;x['C']&lt;/code&gt; 는 새로 생성 된 열을 참조하며 이는 &lt;code&gt;dfa['A'] + dfa['B']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afe33c5f4d23d2808699d27c791aaa9952e2622a" translate="yes" xml:space="preserve">
          <source>In this case the input is a &lt;code&gt;Series&lt;/code&gt;, one column at a time. Notice that the output shape of &lt;code&gt;highlight_max&lt;/code&gt; matches the input shape, an array with &lt;code&gt;len(s)&lt;/code&gt; items.</source>
          <target state="translated">이 경우 입력은 한 번에 하나의 열인 &lt;code&gt;Series&lt;/code&gt; 입니다. &lt;code&gt;highlight_max&lt;/code&gt; 의 출력 모양은 &lt;code&gt;len(s)&lt;/code&gt; 항목이 있는 배열 인 입력 모양과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="9b3a509c455234e1c3e05693d38433368296bb28" translate="yes" xml:space="preserve">
          <source>In this case, the callable is specifying that we exclude the &amp;ldquo;a&amp;rdquo; and &amp;ldquo;c&amp;rdquo; columns from the output.</source>
          <target state="translated">이 경우 콜 러블은 출력에서 ​​&quot;a&quot;및 &quot;c&quot;열을 제외하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3aef7feee0929f190d963f63e0387a5d7d3d15b6" translate="yes" xml:space="preserve">
          <source>In this case, the cell&amp;rsquo;s style depends only on it&amp;rsquo;s own value. That means we should use the &lt;code&gt;Styler.applymap&lt;/code&gt; method which works elementwise.</source>
          <target state="translated">이 경우 셀 스타일은 자체 값에만 의존합니다. 즉, 요소별로 작동 하는 &lt;code&gt;Styler.applymap&lt;/code&gt; 메소드를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ad06842c389a571f0235f579a49f4f73cb7ed48e" translate="yes" xml:space="preserve">
          <source>In this case, the cell&amp;rsquo;s style depends only on its own value. That means we should use the &lt;code&gt;Styler.applymap&lt;/code&gt; method which works elementwise.</source>
          <target state="translated">이 경우 셀의 스타일은 자체 값에만 의존합니다. 즉, 요소별로 작동 하는 &lt;code&gt;Styler.applymap&lt;/code&gt; 메서드를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="57ba1c1a450e40b49d89a7bd4623ca53a6ec1435" translate="yes" xml:space="preserve">
          <source>In this case, you should simply refer to the variables like you would in standard Python.</source>
          <target state="translated">이 경우 표준 Python 에서처럼 변수를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="02ff908c94702a05c583a3f40f7d9e3bed0dd0c0" translate="yes" xml:space="preserve">
          <source>In this example, using Numba was faster than Cython.</source>
          <target state="translated">이 예에서 Numba를 사용하는 것이 Cython보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="a7d2a651a577c11740c930fb23047a99aa3158e8" translate="yes" xml:space="preserve">
          <source>In this example, we chopped the collection of time series into yearly chunks then independently called &lt;a href=&quot;missing_data#missing-data-fillna&quot;&gt;fillna&lt;/a&gt; on the groups.</source>
          <target state="translated">이 예에서는 시계열 컬렉션을 연간 청크로 &lt;a href=&quot;missing_data#missing-data-fillna&quot;&gt;분할&lt;/a&gt; 한 다음 그룹에서 독립적으로 fillna 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="b3da24a14dac99c2ce666c7fcf23f280f2f0a9bd" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll create a parent docstring normally (this is like &lt;code&gt;pandas.core.generic.NDFrame&lt;/code&gt;. Then we&amp;rsquo;ll have two children (like &lt;code&gt;pandas.core.series.Series&lt;/code&gt; and &lt;code&gt;pandas.core.frame.DataFrame&lt;/code&gt;). We&amp;rsquo;ll substitute the children&amp;rsquo;s class names in this docstring.</source>
          <target state="translated">이 예제에서, 우리는이처럼 (일반적으로 문서화 문자열 부모를 만듭니다 &lt;code&gt;pandas.core.generic.NDFrame&lt;/code&gt; . 그리고 우리가 같은 두 아이 (해야 &lt;code&gt;pandas.core.series.Series&lt;/code&gt; 및 &lt;code&gt;pandas.core.frame.DataFrame&lt;/code&gt; 을 ). 이 docstring에서 어린이 클래스 이름을 대체 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bbfbfe1d873ec17ab2dac03fab01451c14e40df9" translate="yes" xml:space="preserve">
          <source>In this example, while the dtypes of all columns are changed, we show the results for the first 10 columns.</source>
          <target state="translated">이 예에서는 모든 열의 dtype이 변경되는 동안 처음 10 개의 열에 대한 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="72373ffd4fe7734ddc860b3c260bb5bc238b113d" translate="yes" xml:space="preserve">
          <source>In this part of the tutorial, we will investigate how to speed up certain functions operating on pandas &lt;code&gt;DataFrames&lt;/code&gt; using three different techniques: Cython, Numba and &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt;. We will see a speed improvement of ~200 when we use Cython and Numba on a test function operating row-wise on the &lt;code&gt;DataFrame&lt;/code&gt;. Using &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;pandas.eval()&lt;/code&gt;&lt;/a&gt; we will speed up a sum by an order of ~2.</source>
          <target state="translated">튜토리얼의이 부분에서는 Cython, Numba 및 &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 세 가지 기술을 사용하여 팬더 &lt;code&gt;DataFrames&lt;/code&gt; 작동하는 특정 함수의 속도를 높이는 방법을 조사합니다 . &lt;code&gt;DataFrame&lt;/code&gt; 에서 행 단위로 작동하는 테스트 함수에서 Cython 및 Numba를 사용하면 속도가 ~ 200으로 향상됩니다 . &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;pandas.eval()&lt;/code&gt; &lt;/a&gt; 을 사용하면 ~ 2의 순서로 합을 가속화합니다.</target>
        </trans-unit>
        <trans-unit id="9bf63141c08371784983bff76853f338b3b741d6" translate="yes" xml:space="preserve">
          <source>In this section, we will discuss missing (also referred to as NA) values in pandas.</source>
          <target state="translated">이 섹션에서는 팬더에서 누락 된 (NA라고도 함) 값에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="73225e5cff6b5571285560e386bca15e86dff2c4" translate="yes" xml:space="preserve">
          <source>In this section, we will focus on the final point: namely, how to slice, dice, and generally get and set subsets of pandas objects. The primary focus will be on Series and DataFrame as they have received more development attention in this area.</source>
          <target state="translated">이 섹션에서는 최종 요점, 즉 팬더 객체의 하위 집합을 슬라이스, 주사위로 만들고 일반적으로 가져오고 설정하는 방법에 중점을 둘 것입니다. 이 영역에서 더 많은 개발 관심을 받았기 때문에 Series와 DataFrame에 중점을 둘 것입니다.</target>
        </trans-unit>
        <trans-unit id="03a5b73370240444b3aa9f3ef282c53148b5a8a7" translate="yes" xml:space="preserve">
          <source>In this section, we will review frequently asked questions and examples. The column names and relevant column values are named to correspond with how this DataFrame will be pivoted in the answers below.</source>
          <target state="translated">이 섹션에서는 자주 묻는 질문과 예를 검토합니다. 열 이름과 관련 열 값은 아래 답변에서이 DataFrame이 피벗되는 방식과 일치하도록 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="e76aae5e31e8e88b73aff1a30b64467dd9d3ff24" translate="yes" xml:space="preserve">
          <source>In this section, we will show what exactly we mean by &amp;ldquo;hierarchical&amp;rdquo; indexing and how it integrates with all of the pandas indexing functionality described above and in prior sections. Later, when discussing &lt;a href=&quot;groupby#groupby&quot;&gt;group by&lt;/a&gt; and &lt;a href=&quot;reshaping#reshaping&quot;&gt;pivoting and reshaping data&lt;/a&gt;, we&amp;rsquo;ll show non-trivial applications to illustrate how it aids in structuring data for analysis.</source>
          <target state="translated">이 섹션에서는 &quot;계층 적&quot;인덱싱이 정확히 무엇을 의미하는지와 위에서 설명한 이전 판과 모든 팬더 인덱싱 기능과 어떻게 통합되는지 보여줍니다. 논의 할 때 이후 &lt;a href=&quot;groupby#groupby&quot;&gt;로 그룹&lt;/a&gt; 및 &lt;a href=&quot;reshaping#reshaping&quot;&gt;데이터를 피벗 및 재편&lt;/a&gt; , 우리는 분석을 위해 구조화 데이터를 보조하는 방법을 설명하기 위해 적지 않은 응용 프로그램을 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="f47dd17ead344d61ee2c5373f8689404db3aa3d7" translate="yes" xml:space="preserve">
          <source>In this special case, &lt;code&gt;read_csv&lt;/code&gt; assumes that the first column is to be used as the index of the &lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="translated">이 특별한 경우에 &lt;code&gt;read_csv&lt;/code&gt; 는 첫 번째 열이 &lt;code&gt;DataFrame&lt;/code&gt; 의 인덱스로 사용된다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="b30b00491d28032f2327d689459c13f6ce6da19e" translate="yes" xml:space="preserve">
          <source>In your library code:</source>
          <target state="translated">도서관 코드에서 :</target>
        </trans-unit>
        <trans-unit id="db347a62c1cb84befcabc203e401873d7bf60b05" translate="yes" xml:space="preserve">
          <source>Include a short, self-contained Python snippet reproducing the problem. You can format the code nicely by using &lt;a href=&quot;http://github.github.com/github-flavored-markdown/&quot;&gt;GitHub Flavored Markdown&lt;/a&gt;:</source>
          <target state="translated">문제를 재현하는 짧고 독립적 인 Python 스 니펫을 포함시킵니다. &lt;a href=&quot;http://github.github.com/github-flavored-markdown/&quot;&gt;GitHub Flavored Markdown&lt;/a&gt; 을 사용하여 코드를 멋지게 포맷 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b691f63704db590222c5a5a428645689bef5660" translate="yes" xml:space="preserve">
          <source>Include boundaries.</source>
          <target state="translated">경계를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="31a6ee06df15416ef3720c1aa78c55050baa48f0" translate="yes" xml:space="preserve">
          <source>Include index in resulting record array, stored in &amp;lsquo;index&amp;rsquo; field or using the index label, if set.</source>
          <target state="translated">'index'필드에 저장되거나 설정된 경우 인덱스 레이블을 사용하여 결과 레코드 배열에 인덱스를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="126f0c2a40a169ffec85464bf4d3a095399d9320" translate="yes" xml:space="preserve">
          <source>Include only</source>
          <target state="translated">포함 만</target>
        </trans-unit>
        <trans-unit id="ce7b2669a3c04046d4fe20cebca986183f8d25ac" translate="yes" xml:space="preserve">
          <source>Include only &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;boolean&lt;/code&gt; data.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;boolean&lt;/code&gt; 데이터 만 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ec733e2bb248ecf061bdc5fc52a0929cda839cd" translate="yes" xml:space="preserve">
          <source>Include only boolean columns. If None, will attempt to use everything, then use only boolean data. Not implemented for Series.</source>
          <target state="translated">부울 열만 포함하십시오. None이면 모든 것을 사용하려고 시도하고 부울 데이터 만 사용합니다. 시리즈에는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="089a2b3c877830b57c8fdb29b364e82cc863914a" translate="yes" xml:space="preserve">
          <source>Include only float, int, boolean columns. If None, will attempt to use everything, then use only numeric data.</source>
          <target state="translated">float, int, boolean 열만 포함합니다. None이면 모든 것을 사용하려고 시도한 다음 숫자 데이터 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5b12a929622185e9bb288fead08323d30697638a" translate="yes" xml:space="preserve">
          <source>Include only float, int, boolean columns. If None, will attempt to use everything, then use only numeric data. Not implemented for Series.</source>
          <target state="translated">float, int, boolean 열만 포함하십시오. None이면 모든 것을 사용하려고 시도하고 숫자 데이터 만 사용합니다. 시리즈에는 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ff085c898322da90e160c2330dcbbead8b3b2174" translate="yes" xml:space="preserve">
          <source>Include the full version string of &lt;em&gt;pandas&lt;/em&gt; and its dependencies. You can use the built-in function:</source>
          <target state="translated">&lt;em&gt;판다&lt;/em&gt; 의 풀 버전 문자열 과 그 의존성을 포함하십시오. 내장 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcf69b9cbc8ef695372516d0e93443e29183fb35" translate="yes" xml:space="preserve">
          <source>Include the index in the hash (if Series/DataFrame).</source>
          <target state="translated">해시에 인덱스를 포함합니다 (Series / DataFrame 인 경우).</target>
        </trans-unit>
        <trans-unit id="163b333f27b7f4615562825a8ccc5332d6454f10" translate="yes" xml:space="preserve">
          <source>Including a &lt;code&gt;flags&lt;/code&gt; argument when calling &lt;code&gt;replace&lt;/code&gt; with a compiled regular expression object will raise a &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 정규 표현식 객체로 &lt;code&gt;replace&lt;/code&gt; 를 호출 할 때 &lt;code&gt;flags&lt;/code&gt; 인수를 포함하면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ff01bc684733280abdc6a33c3e1f0a40ff87a068" translate="yes" xml:space="preserve">
          <source>Including only categorical columns from a &lt;code&gt;DataFrame&lt;/code&gt; description.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 설명의 범주 열만 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="6b121e08046c26a73fd33f3a182f76a2ff41c033" translate="yes" xml:space="preserve">
          <source>Including only numeric columns in a &lt;code&gt;DataFrame&lt;/code&gt; description.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 설명 에 숫자 열만 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="3d6a3ced182d9ff7c047d6e408a1ae0d73dfdb24" translate="yes" xml:space="preserve">
          <source>Including only string columns in a &lt;code&gt;DataFrame&lt;/code&gt; description.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 설명 에 문자열 열만 포함</target>
        </trans-unit>
        <trans-unit id="13b5fc6793c568e32ad19498d5f921c75fa49a73" translate="yes" xml:space="preserve">
          <source>Increasingly, packages are being built on top of pandas to address specific needs in data preparation, analysis and visualization. This is encouraging because it means pandas is not only helping users to handle their data tasks but also that it provides a better starting point for developers to build powerful and more focused data tools. The creation of libraries that complement pandas&amp;rsquo; functionality also allows pandas development to remain focused around it&amp;rsquo;s original requirements.</source>
          <target state="translated">데이터 준비, 분석 및 시각화의 특정 요구를 해결하기 위해 팬더 위에 패키지가 점점 더 많이 구축되고 있습니다. 이는 팬더가 사용자가 데이터 작업을 처리하는 데 도움을 줄뿐만 아니라 개발자가 강력하고보다 집중된 데이터 도구를 구축 할 수있는 더 나은 출발점을 제공한다는 것을 의미하기 때문에 고무적입니다. 팬더의 기능을 보완하는 라이브러리를 만들면 팬더 개발이 원래 요구 사항에 계속 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dcd27a303504423a9e88ac04a13ca65377d4179" translate="yes" xml:space="preserve">
          <source>Increasingly, packages are being built on top of pandas to address specific needs in data preparation, analysis and visualization. Vaex is a python library for Out-of-Core DataFrames (similar to Pandas), to visualize and explore big tabular datasets. It can calculate statistics such as mean, sum, count, standard deviation etc, on an N-dimensional grid up to a billion (10&lt;sup&gt;9&lt;/sup&gt;) objects/rows per second. Visualization is done using histograms, density plots and 3d volume rendering, allowing interactive exploration of big data. Vaex uses memory mapping, zero memory copy policy and lazy computations for best performance (no memory wasted).</source>
          <target state="translated">데이터 준비, 분석 및 시각화의 특정 요구를 해결하기 위해 팬더 위에 패키지가 점점 더 많이 구축되고 있습니다. Vaex는 Out-of-Core DataFrames (Pandas와 유사)를위한 파이썬 라이브러리로, 큰 테이블 형식의 데이터 세트를 시각화하고 탐색합니다. 최대 10 억 (10 &lt;sup&gt;9&lt;/sup&gt; )의 객체 / 초당 N 차원 그리드에서 평균, 합계, 개수, 표준 편차 등과 같은 통계를 계산할 수 있습니다 . 히스토그램, 밀도 플롯 및 3D 볼륨 렌더링을 사용하여 시각화를 수행하여 빅 데이터를 대화식으로 탐색 할 수 있습니다. Vaex는 최고의 성능을 위해 메모리 매핑, 제로 메모리 카피 정책 및 지연 계산을 사용합니다 (메모리 낭비 없음).</target>
        </trans-unit>
        <trans-unit id="26db5789a3db307320ead6289a9397c138320990" translate="yes" xml:space="preserve">
          <source>Increment to use from the tseries module or time rule (e.g. &amp;lsquo;EOM&amp;rsquo;)</source>
          <target state="translated">tseries 모듈 또는 시간 규칙에서 사용 증가 (예 : 'EOM')</target>
        </trans-unit>
        <trans-unit id="74f0dd9f3b0843b773618aee7a8ce2a25d60d752" translate="yes" xml:space="preserve">
          <source>Increment to use from the tseries module or time rule expressed as a string (e.g. &amp;lsquo;EOM&amp;rsquo;).</source>
          <target state="translated">tseries 모듈에서 사용할 증분 또는 문자열로 표현 된 시간 규칙 (예 : 'EOM').</target>
        </trans-unit>
        <trans-unit id="0b5df5508ba7385b434e62a6961ca6857f44c6b0" translate="yes" xml:space="preserve">
          <source>Increment to use from time series API (e.g. &amp;lsquo;M&amp;rsquo; or BDay()).</source>
          <target state="translated">시계열 API에서 사용하도록 증가합니다 (예 : 'M'또는 BDay ()).</target>
        </trans-unit>
        <trans-unit id="231c7f38ec6d94dc007935acbe384cf0282d72db" translate="yes" xml:space="preserve">
          <source>Increments between beginning of month dates.</source>
          <target state="translated">월 시작일 사이의 증분.</target>
        </trans-unit>
        <trans-unit id="b95c16a9ac51c0f7e39f7810c8313f53c219821f" translate="yes" xml:space="preserve">
          <source>Increments between end of month dates.</source>
          <target state="translated">월말 날짜 사이의 증분.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="7affb9402f6d37743f08a62c03631098654cdc31" translate="yes" xml:space="preserve">
          <source>Index (same behavior as &lt;code&gt;df.reindex&lt;/code&gt;)</source>
          <target state="translated">인덱스 ( &lt;code&gt;df.reindex&lt;/code&gt; 와 동일한 동작 )</target>
        </trans-unit>
        <trans-unit id="2a44add6bb3ea93789807b6f66b9387cf8a079a5" translate="yes" xml:space="preserve">
          <source>Index : when the input is an Index</source>
          <target state="translated">색인 : 입력이 색인 인 경우</target>
        </trans-unit>
        <trans-unit id="82103998d207b862a86dc4cbf6b45d479ad4ef92" translate="yes" xml:space="preserve">
          <source>Index and Column names include &lt;code&gt;index_name&lt;/code&gt; and &lt;code&gt;level&amp;lt;k&amp;gt;&lt;/code&gt; where</source>
          <target state="translated">인덱스 및 열 이름에는 &lt;code&gt;index_name&lt;/code&gt; 및 &lt;code&gt;level&amp;lt;k&amp;gt;&lt;/code&gt; 여기서</target>
        </trans-unit>
        <trans-unit id="0c8a552055cf4b1af8a6fef51686733239357ecb" translate="yes" xml:space="preserve">
          <source>Index and Column names include &lt;code&gt;index_name&lt;/code&gt; and &lt;code&gt;level&amp;lt;k&amp;gt;&lt;/code&gt; where &lt;code&gt;k&lt;/code&gt; is its level in a MultiIndex</source>
          <target state="translated">인덱스 및 열 이름에는 &lt;code&gt;index_name&lt;/code&gt; 및 &lt;code&gt;level&amp;lt;k&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;k&lt;/code&gt; 는 MultiIndex의 수준입니다.</target>
        </trans-unit>
        <trans-unit id="e51d371566560cba756deba05c83ffca1dc839f5" translate="yes" xml:space="preserve">
          <source>Index and header can be specified via the</source>
          <target state="translated">색인과 헤더는</target>
        </trans-unit>
        <trans-unit id="cd6ac17dc682d2c38066a77b16e976ff3c2ce09c" translate="yes" xml:space="preserve">
          <source>Index and header can be specified via the &lt;code&gt;index_col&lt;/code&gt; and &lt;code&gt;header&lt;/code&gt; arguments</source>
          <target state="translated">&lt;code&gt;index_col&lt;/code&gt; 및 &lt;code&gt;header&lt;/code&gt; 인수 를 통해 인덱스 및 헤더를 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2587f44432040cac42b068d4fe1ec270fddbdd32" translate="yes" xml:space="preserve">
          <source>Index aware interpolation is available via the &lt;code&gt;method&lt;/code&gt; keyword:</source>
          <target state="translated">인덱스 인식 보간은 &lt;code&gt;method&lt;/code&gt; 키워드 를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34faad5d858d4b7e89884a89d083ed8f33017377" translate="yes" xml:space="preserve">
          <source>Index based on an underlying &lt;a href=&quot;api/pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;api/pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; &lt;/a&gt; 기반 인덱스 .</target>
        </trans-unit>
        <trans-unit id="af92f271aa69cd2c937dff42ef9cde6ee37cdfe5" translate="yes" xml:space="preserve">
          <source>Index based on an underlying &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; &lt;/a&gt; 기반 인덱스 .</target>
        </trans-unit>
        <trans-unit id="9d4a7200e79d65773386087c17ce85d75fcc7f11" translate="yes" xml:space="preserve">
          <source>Index columns and trailing delimiters</source>
          <target state="translated">인덱스 열 및 후행 구분 기호</target>
        </trans-unit>
        <trans-unit id="946046b78b463294cbaa6a4234c5d937620c8c0f" translate="yes" xml:space="preserve">
          <source>Index for Interval objects.</source>
          <target state="translated">Interval 개체에 대한 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="adcb0c3d4f7b1a49941419accde10d7a93229a9a" translate="yes" xml:space="preserve">
          <source>Index for categorical data.</source>
          <target state="translated">범주 형 데이터에 대한 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="3a188639fe43a0a79a0742948b8551c1bd78cba5" translate="yes" xml:space="preserve">
          <source>Index implementing a monotonic integer range.</source>
          <target state="translated">단조 정수 범위를 구현하는 인덱스.</target>
        </trans-unit>
        <trans-unit id="e6e4731fc450fe8cce633fcded5cb9d920523b49" translate="yes" xml:space="preserve">
          <source>Index into each element (retrieve i-th element)</source>
          <target state="translated">각 요소에 대한 인덱스 (i 번째 요소 검색)</target>
        </trans-unit>
        <trans-unit id="842f096c24508918264d80e1c30ea189df13e9e8" translate="yes" xml:space="preserve">
          <source>Index keys are boxed to Period objects which carries the metadata (eg, frequency information).</source>
          <target state="translated">인덱스 키는 메타 데이터 (예 : 빈도 정보)를 전달하는 Period 객체에 박스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e277bfe290c28ec18c340b1a44e035c492f87f2b" translate="yes" xml:space="preserve">
          <source>Index label cells include</source>
          <target state="translated">인덱스 라벨 셀 포함</target>
        </trans-unit>
        <trans-unit id="fdca8fb2dd0723d97ecfeb0107e6b5a8a3a1793b" translate="yes" xml:space="preserve">
          <source>Index labels to drop.</source>
          <target state="translated">제거 할 색인 레이블.</target>
        </trans-unit>
        <trans-unit id="e4d27cbaf08eb67eb8b633eb503847e596a0b5c8" translate="yes" xml:space="preserve">
          <source>Index level names may be specified as keys directly to &lt;code&gt;groupby&lt;/code&gt;.</source>
          <target state="translated">인덱스 레벨 이름은 &lt;code&gt;groupby&lt;/code&gt; 에 대한 키로 직접 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7ea719cc1174f2215272b792d2c8a5c2526d4eb" translate="yes" xml:space="preserve">
          <source>Index level names may be supplied as keys.</source>
          <target state="translated">인덱스 레벨 이름은 키로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b1487150ef120bbc3db423a49593f8c76c50d56" translate="yes" xml:space="preserve">
          <source>Index level names, if specified, must be strings.</source>
          <target state="translated">인덱스 레벨 이름은 지정된 경우 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb05c23d2119d08953101523abd6c4d02b724e9d" translate="yes" xml:space="preserve">
          <source>Index levels may also be specified by name.</source>
          <target state="translated">인덱스 수준은 이름으로도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d56a166da3ce50aea7c651c2cdb629a5e0eaea" translate="yes" xml:space="preserve">
          <source>Index needs to be ordered and unique.</source>
          <target state="translated">인덱스는 순서가 있고 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="0666ee788b7f8718ba82db947fe0d30b9c20f60a" translate="yes" xml:space="preserve">
          <source>Index objects</source>
          <target state="translated">인덱스 객체</target>
        </trans-unit>
        <trans-unit id="f53cbdff8dd5cb499d7d24d1af81e5a33703f965" translate="yes" xml:space="preserve">
          <source>Index of &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt;&lt;code&gt;Categorical&lt;/code&gt;&lt;/a&gt; s.</source>
          <target state="translated">색인 &lt;a href=&quot;pandas.categorical#pandas.Categorical&quot;&gt; &lt;code&gt;Categorical&lt;/code&gt; &lt;/a&gt; 의.</target>
        </trans-unit>
        <trans-unit id="56770e0bd43ee73f2eba8f0a730ea0c8e7920d9e" translate="yes" xml:space="preserve">
          <source>Index of Period data.</source>
          <target state="translated">기간 데이터 색인.</target>
        </trans-unit>
        <trans-unit id="9a66650f241bc1ae4f60df99a17e67b4b5bec78d" translate="yes" xml:space="preserve">
          <source>Index of datetime64 data.</source>
          <target state="translated">datetime64 데이터의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="8ca96bcaaba03554972454c50b497525d42f034c" translate="yes" xml:space="preserve">
          <source>Index of day names.</source>
          <target state="translated">요일 이름의 색인.</target>
        </trans-unit>
        <trans-unit id="faadd88f578df6cee31871b7dda874b805055e46" translate="yes" xml:space="preserve">
          <source>Index of formatted strings.</source>
          <target state="translated">형식화 된 문자열의 색인.</target>
        </trans-unit>
        <trans-unit id="583e9f80010c3027edc79dd38d334f00da629044" translate="yes" xml:space="preserve">
          <source>Index of int64 data.</source>
          <target state="translated">int64 데이터의 인덱스</target>
        </trans-unit>
        <trans-unit id="bc67cbdd4848572296e5148b9e3e23202fe8ceeb" translate="yes" xml:space="preserve">
          <source>Index of label.</source>
          <target state="translated">라벨 색인.</target>
        </trans-unit>
        <trans-unit id="04d5ecedec5046742ff05155de5e428f370ea349" translate="yes" xml:space="preserve">
          <source>Index of min/max values</source>
          <target state="translated">최소 / 최대 값 인덱스</target>
        </trans-unit>
        <trans-unit id="2fa0e28586d25c85134d44435d18bc8a10b262f8" translate="yes" xml:space="preserve">
          <source>Index of month names.</source>
          <target state="translated">월 이름의 색인.</target>
        </trans-unit>
        <trans-unit id="098d3068e27babe7c7cd9fc68c4d3474bceb865d" translate="yes" xml:space="preserve">
          <source>Index of resulting Series. If None, defaults to original index.</source>
          <target state="translated">결과 시리즈의 색인. 없음 인 경우 기본값은 원래 색인입니다.</target>
        </trans-unit>
        <trans-unit id="7281850e680339a57853dba6d9c857e51597144f" translate="yes" xml:space="preserve">
          <source>Index of the Series.</source>
          <target state="translated">시리즈의 색인.</target>
        </trans-unit>
        <trans-unit id="1785b2774d37659f913018e41ecbb4a3b8d3d7e5" translate="yes" xml:space="preserve">
          <source>Index of the element that needs to be removed.</source>
          <target state="translated">제거해야하는 요소의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="c9f9f6a193b584c9a8e98b4efaf44235dd250eff" translate="yes" xml:space="preserve">
          <source>Index of the same type for a DatetimeIndex or TimedeltaIndex, or a Series with the same index for a Series.</source>
          <target state="translated">DatetimeIndex 또는 TimedeltaIndex에 대해 동일한 유형의 인덱스 또는 Series에 대해 동일한 인덱스를 가진 시리즈.</target>
        </trans-unit>
        <trans-unit id="019826cdb3fb98643542304c348378eec49fdfb1" translate="yes" xml:space="preserve">
          <source>Index of timedelta64 data.</source>
          <target state="translated">timedelta64 데이터의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="fbd9313d6091ac96c839a913f1173699a8ebc6ec" translate="yes" xml:space="preserve">
          <source>Index or MultiIndex</source>
          <target state="translated">인덱스 또는 다중 인덱스</target>
        </trans-unit>
        <trans-unit id="17ea23cb6e41bf5302e68e1f20af90b0b743eae6" translate="yes" xml:space="preserve">
          <source>Index or None</source>
          <target state="translated">색인 또는 없음</target>
        </trans-unit>
        <trans-unit id="c875ef463fe284c143c8419c48f808383a7de6f9" translate="yes" xml:space="preserve">
          <source>Index or column labels to drop.</source>
          <target state="translated">제거 할 인덱스 또는 열 레이블.</target>
        </trans-unit>
        <trans-unit id="366dfa4b94a62899d16072768c9382cb21b4d11d" translate="yes" xml:space="preserve">
          <source>Index refer to new object which is a copy of this object.</source>
          <target state="translated">인덱스는이 개체의 복사 본인 새 개체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="37ec8b0d3c027864c82264f650e37bc45231f7c7" translate="yes" xml:space="preserve">
          <source>Index should be similar to one of the columns in this one. If a Series is passed, its name attribute must be set, and that will be used as the column name in the resulting joined DataFrame.</source>
          <target state="translated">인덱스는이 열 중 하나와 유사해야합니다. Series가 전달되면 이름 속성을 설정해야하며 결합 된 결과 DataFrame에서 열 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ea0c4acf4b23e40bdc6027bb925e7ece4846f20" translate="yes" xml:space="preserve">
          <source>Index to direct ranking.</source>
          <target state="translated">직접 순위에 대한 인덱스.</target>
        </trans-unit>
        <trans-unit id="e4e1575f2335a404e29fd2d44ad28ac2eb63c3c0" translate="yes" xml:space="preserve">
          <source>Index to use for resulting frame. Will default to RangeIndex if no indexing information part of input data and no index provided</source>
          <target state="translated">결과 프레임에 사용할 인덱스. 입력 데이터의 색인 정보가없고 색인이 제공되지 않은 경우 기본적으로 RangeIndex가됩니다.</target>
        </trans-unit>
        <trans-unit id="501364aae54ad57a548ada79dd2d3a5140378e60" translate="yes" xml:space="preserve">
          <source>Index to use for resulting frame. Will default to RangeIndex if no indexing information part of input data and no index provided.</source>
          <target state="translated">결과 프레임에 사용할 인덱스입니다. 입력 데이터의 색인 정보 부분이없고 제공된 색인이없는 경우 기본값은 RangeIndex입니다.</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">색인 유형</target>
        </trans-unit>
        <trans-unit id="132263ca33fe499e1fefbd5f4ab52b57901c7c9d" translate="yes" xml:space="preserve">
          <source>Index will be included as the first field of the record array if requested.</source>
          <target state="translated">요청 된 경우 인덱스는 레코드 배열의 첫 번째 필드로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f4acecef33c224b834072adfb597a584368d0111" translate="yes" xml:space="preserve">
          <source>Index with datetime64 data.</source>
          <target state="translated">datetime64 데이터가 포함 된 인덱스</target>
        </trans-unit>
        <trans-unit id="d0f9ff03291ad7359cbe79c48807f59ae4bcb3d2" translate="yes" xml:space="preserve">
          <source>Index with the MultiIndex data represented in Tuples.</source>
          <target state="translated">Tuples로 표현 된 MultiIndex 데이터가있는 인덱스.</target>
        </trans-unit>
        <trans-unit id="2ae08452578221ac3ac96025e8fed3975af4b6fa" translate="yes" xml:space="preserve">
          <source>Index with values cast to specified dtype.</source>
          <target state="translated">지정된 dtype으로 캐스트 된 값이있는 인덱스</target>
        </trans-unit>
        <trans-unit id="6f89f1a8c4667749cd92a6f58c4201c42a229c3b" translate="yes" xml:space="preserve">
          <source>Index without duplicates</source>
          <target state="translated">중복없는 인덱스</target>
        </trans-unit>
        <trans-unit id="cdd71cd80c9d290c9a468dd9efa26b99b7ff2f8e" translate="yes" xml:space="preserve">
          <source>Index.T</source>
          <target state="translated">Index.T</target>
        </trans-unit>
        <trans-unit id="2db29e878e755947750a5416d6b29533d2d0f198" translate="yes" xml:space="preserve">
          <source>Index.all()</source>
          <target state="translated">Index.all()</target>
        </trans-unit>
        <trans-unit id="d42ccb1f02636a49f8b538e866d20b0f09ff7c4b" translate="yes" xml:space="preserve">
          <source>Index.any()</source>
          <target state="translated">Index.any()</target>
        </trans-unit>
        <trans-unit id="6643fe7b7406dbfa6af1b4565aeb2bbea3dac495" translate="yes" xml:space="preserve">
          <source>Index.append()</source>
          <target state="translated">Index.append()</target>
        </trans-unit>
        <trans-unit id="42a541775b6a11203a670551f7268a4814869896" translate="yes" xml:space="preserve">
          <source>Index.argmax()</source>
          <target state="translated">Index.argmax()</target>
        </trans-unit>
        <trans-unit id="87d989474d5559d3b36dd5800160bf3f9656a45e" translate="yes" xml:space="preserve">
          <source>Index.argmin()</source>
          <target state="translated">Index.argmin()</target>
        </trans-unit>
        <trans-unit id="8f552266a485dababae443a6fae2c3e9e83e11d1" translate="yes" xml:space="preserve">
          <source>Index.argsort()</source>
          <target state="translated">Index.argsort()</target>
        </trans-unit>
        <trans-unit id="a1fdb30d81bf0936fabfcab27c0303027f81892f" translate="yes" xml:space="preserve">
          <source>Index.array</source>
          <target state="translated">Index.array</target>
        </trans-unit>
        <trans-unit id="eed754ce326634c3140873727f5ea593fe2f35c4" translate="yes" xml:space="preserve">
          <source>Index.asi8</source>
          <target state="translated">Index.asi8</target>
        </trans-unit>
        <trans-unit id="a15053de986d6afda7ed2cca11daa3775c96cc23" translate="yes" xml:space="preserve">
          <source>Index.asof</source>
          <target state="translated">Index.asof</target>
        </trans-unit>
        <trans-unit id="d2cd29cb21401d11ea21f4cb41f8076e382966e6" translate="yes" xml:space="preserve">
          <source>Index.asof()</source>
          <target state="translated">Index.asof()</target>
        </trans-unit>
        <trans-unit id="199c20dd07d482f95cbf220ca2a7f42e74b379ba" translate="yes" xml:space="preserve">
          <source>Index.asof_locs()</source>
          <target state="translated">Index.asof_locs()</target>
        </trans-unit>
        <trans-unit id="41fd7d714455935421f5f4d9b47b8d2026a11eba" translate="yes" xml:space="preserve">
          <source>Index.astype()</source>
          <target state="translated">Index.astype()</target>
        </trans-unit>
        <trans-unit id="9695198546dd84741c60d2dc2e5f7927808bd80a" translate="yes" xml:space="preserve">
          <source>Index.base</source>
          <target state="translated">Index.base</target>
        </trans-unit>
        <trans-unit id="df3ceb7d36bffd44f156dbe30a939980f01c33fa" translate="yes" xml:space="preserve">
          <source>Index.contains()</source>
          <target state="translated">Index.contains()</target>
        </trans-unit>
        <trans-unit id="712612b1213ae7041ba7988df4918024034c21a1" translate="yes" xml:space="preserve">
          <source>Index.copy()</source>
          <target state="translated">Index.copy()</target>
        </trans-unit>
        <trans-unit id="7ad80e864f56fa9470edbc146fd372634069a3f4" translate="yes" xml:space="preserve">
          <source>Index.data</source>
          <target state="translated">Index.data</target>
        </trans-unit>
        <trans-unit id="ec91ad1c05256197f8c60f2da281fa396f0c6d9a" translate="yes" xml:space="preserve">
          <source>Index.delete()</source>
          <target state="translated">Index.delete()</target>
        </trans-unit>
        <trans-unit id="faf5b9b1f8570d369d4feb19d5c7852044b85934" translate="yes" xml:space="preserve">
          <source>Index.difference()</source>
          <target state="translated">Index.difference()</target>
        </trans-unit>
        <trans-unit id="42e7f9946dde54a45485adc101d97d6b16f7f409" translate="yes" xml:space="preserve">
          <source>Index.drop()</source>
          <target state="translated">Index.drop()</target>
        </trans-unit>
        <trans-unit id="0be051cd040eb2ec264d5b55580f51c8f599142b" translate="yes" xml:space="preserve">
          <source>Index.drop_duplicates()</source>
          <target state="translated">Index.drop_duplicates()</target>
        </trans-unit>
        <trans-unit id="2b12ad26e40306a335584618e9e8765839b15473" translate="yes" xml:space="preserve">
          <source>Index.droplevel()</source>
          <target state="translated">Index.droplevel()</target>
        </trans-unit>
        <trans-unit id="ed56b4f3a37cb253fdbe696af0f9d3014c831a3f" translate="yes" xml:space="preserve">
          <source>Index.dropna()</source>
          <target state="translated">Index.dropna()</target>
        </trans-unit>
        <trans-unit id="2b62528d4f5863f0eeed7a099cc5534488cbd1d7" translate="yes" xml:space="preserve">
          <source>Index.dtype</source>
          <target state="translated">Index.dtype</target>
        </trans-unit>
        <trans-unit id="4513ac87f55238987e3a62cfbcedb7736932e245" translate="yes" xml:space="preserve">
          <source>Index.dtype_str</source>
          <target state="translated">Index.dtype_str</target>
        </trans-unit>
        <trans-unit id="d126bba86106473c9aa6a8b507775593026a97fd" translate="yes" xml:space="preserve">
          <source>Index.duplicated()</source>
          <target state="translated">Index.duplicated()</target>
        </trans-unit>
        <trans-unit id="5d5ea543fea0e857f502b16d3d674ccfb9b37508" translate="yes" xml:space="preserve">
          <source>Index.empty</source>
          <target state="translated">Index.empty</target>
        </trans-unit>
        <trans-unit id="bbdd3262c5c824b5fc57e63e2024b274b8943447" translate="yes" xml:space="preserve">
          <source>Index.equals()</source>
          <target state="translated">Index.equals()</target>
        </trans-unit>
        <trans-unit id="7537cb7f2fb87bd7032798127b3fa14e4a87094c" translate="yes" xml:space="preserve">
          <source>Index.factorize()</source>
          <target state="translated">Index.factorize()</target>
        </trans-unit>
        <trans-unit id="3ad6d001e975cf52226968186ab8b929f1b2f34f" translate="yes" xml:space="preserve">
          <source>Index.fillna()</source>
          <target state="translated">Index.fillna()</target>
        </trans-unit>
        <trans-unit id="ca4c733dafa063111d3e1917deb861415c7dca7c" translate="yes" xml:space="preserve">
          <source>Index.flags</source>
          <target state="translated">Index.flags</target>
        </trans-unit>
        <trans-unit id="af04b167762ec954b256ede5966e65f06105980a" translate="yes" xml:space="preserve">
          <source>Index.format()</source>
          <target state="translated">Index.format()</target>
        </trans-unit>
        <trans-unit id="1a9aa2833bb0c1cc0b29b18ea52b274174f03095" translate="yes" xml:space="preserve">
          <source>Index.get_duplicates()</source>
          <target state="translated">Index.get_duplicates()</target>
        </trans-unit>
        <trans-unit id="86e80431dc8f6826d3a34fe6db19828973819c93" translate="yes" xml:space="preserve">
          <source>Index.get_indexer()</source>
          <target state="translated">Index.get_indexer()</target>
        </trans-unit>
        <trans-unit id="f04d404f4cdf74490fb1f5a9104d19eb0d5f6e6f" translate="yes" xml:space="preserve">
          <source>Index.get_indexer_for()</source>
          <target state="translated">Index.get_indexer_for()</target>
        </trans-unit>
        <trans-unit id="5590565b7ccce2eef74c22a12c42c9beb46890de" translate="yes" xml:space="preserve">
          <source>Index.get_indexer_non_unique()</source>
          <target state="translated">Index.get_indexer_non_unique()</target>
        </trans-unit>
        <trans-unit id="45e66bf229ef2853f0289b5ac5364d6839ea8b89" translate="yes" xml:space="preserve">
          <source>Index.get_level_values()</source>
          <target state="translated">Index.get_level_values()</target>
        </trans-unit>
        <trans-unit id="40e81e0c37a06638511ca2044947682ad788e95e" translate="yes" xml:space="preserve">
          <source>Index.get_loc()</source>
          <target state="translated">Index.get_loc()</target>
        </trans-unit>
        <trans-unit id="e06f31d250898f5e50f5313baa35f7d686f97ea7" translate="yes" xml:space="preserve">
          <source>Index.get_slice_bound()</source>
          <target state="translated">Index.get_slice_bound()</target>
        </trans-unit>
        <trans-unit id="a017c762db08e6652e606ada349388f6358ea1c0" translate="yes" xml:space="preserve">
          <source>Index.get_value()</source>
          <target state="translated">Index.get_value()</target>
        </trans-unit>
        <trans-unit id="3412f5093e174de9e668739be7bdaadbd39eb65d" translate="yes" xml:space="preserve">
          <source>Index.get_values()</source>
          <target state="translated">Index.get_values()</target>
        </trans-unit>
        <trans-unit id="5c64f9e8369fe01023f29790c28cdfdaf854182f" translate="yes" xml:space="preserve">
          <source>Index.groupby()</source>
          <target state="translated">Index.groupby()</target>
        </trans-unit>
        <trans-unit id="6d0086d9449b0f2970b1a1002559afa8be4edcc0" translate="yes" xml:space="preserve">
          <source>Index.has_duplicates</source>
          <target state="translated">Index.has_duplicates</target>
        </trans-unit>
        <trans-unit id="609ed6a9294ca8a4c59b782af30bcb4bcbfa4334" translate="yes" xml:space="preserve">
          <source>Index.hasnans</source>
          <target state="translated">Index.hasnans</target>
        </trans-unit>
        <trans-unit id="256e409ba208654bae279d531c4437036a30c3c6" translate="yes" xml:space="preserve">
          <source>Index.holds_integer()</source>
          <target state="translated">Index.holds_integer()</target>
        </trans-unit>
        <trans-unit id="27c912b1b841464548a4368b28293c6998002fa6" translate="yes" xml:space="preserve">
          <source>Index.identical()</source>
          <target state="translated">Index.identical()</target>
        </trans-unit>
        <trans-unit id="0d9cd7f3b930250338bd29771718bdadf9c52edc" translate="yes" xml:space="preserve">
          <source>Index.inferred_type</source>
          <target state="translated">Index.inferred_type</target>
        </trans-unit>
        <trans-unit id="a7c9b79b50642bfe91d87a4142b36f2acec3f301" translate="yes" xml:space="preserve">
          <source>Index.insert()</source>
          <target state="translated">Index.insert()</target>
        </trans-unit>
        <trans-unit id="383740534f674f58776d2a1d93221a9eecf0d257" translate="yes" xml:space="preserve">
          <source>Index.intersection()</source>
          <target state="translated">Index.intersection()</target>
        </trans-unit>
        <trans-unit id="cf31e7ef599ab41687ad8068a1433fd6b3634170" translate="yes" xml:space="preserve">
          <source>Index.is_()</source>
          <target state="translated">Index.is_()</target>
        </trans-unit>
        <trans-unit id="32e7b9aee15ec011aea6101aa6fd4fe3371b0113" translate="yes" xml:space="preserve">
          <source>Index.is_all_dates</source>
          <target state="translated">Index.is_all_dates</target>
        </trans-unit>
        <trans-unit id="518a358e7c6917d3e80097c35681c703d8cda02b" translate="yes" xml:space="preserve">
          <source>Index.is_boolean()</source>
          <target state="translated">Index.is_boolean()</target>
        </trans-unit>
        <trans-unit id="4ef0bbc93946d57f4d3c198be80d494d743e92ed" translate="yes" xml:space="preserve">
          <source>Index.is_categorical()</source>
          <target state="translated">Index.is_categorical()</target>
        </trans-unit>
        <trans-unit id="e422be1fa0c5049f72e6fcf32c4cd90a6b79db36" translate="yes" xml:space="preserve">
          <source>Index.is_floating()</source>
          <target state="translated">Index.is_floating()</target>
        </trans-unit>
        <trans-unit id="eedd61d66278556890bd1ef4984458d134824180" translate="yes" xml:space="preserve">
          <source>Index.is_integer()</source>
          <target state="translated">Index.is_integer()</target>
        </trans-unit>
        <trans-unit id="3449dc3646f5663091d66253c629e81ea33613a4" translate="yes" xml:space="preserve">
          <source>Index.is_interval()</source>
          <target state="translated">Index.is_interval()</target>
        </trans-unit>
        <trans-unit id="91565ce426e539ec67932b0347b377b031b9adc0" translate="yes" xml:space="preserve">
          <source>Index.is_lexsorted_for_tuple()</source>
          <target state="translated">Index.is_lexsorted_for_tuple()</target>
        </trans-unit>
        <trans-unit id="1093e68ed67b6291a2f3e105590479a859fe584f" translate="yes" xml:space="preserve">
          <source>Index.is_mixed()</source>
          <target state="translated">Index.is_mixed()</target>
        </trans-unit>
        <trans-unit id="e81c8d4943551219dae0256b5fac5fa8d60fe8c3" translate="yes" xml:space="preserve">
          <source>Index.is_monotonic</source>
          <target state="translated">Index.is_monotonic</target>
        </trans-unit>
        <trans-unit id="234edfe9fa6e9d453a6c5f2296f7489cbdbcb562" translate="yes" xml:space="preserve">
          <source>Index.is_monotonic_decreasing</source>
          <target state="translated">Index.is_monotonic_decreasing</target>
        </trans-unit>
        <trans-unit id="32e344e2f5d4359c74e4c5388e4e65939090fef2" translate="yes" xml:space="preserve">
          <source>Index.is_monotonic_increasing</source>
          <target state="translated">Index.is_monotonic_increasing</target>
        </trans-unit>
        <trans-unit id="178025556525fb6fbfce91b30d313f3f582c2a97" translate="yes" xml:space="preserve">
          <source>Index.is_numeric()</source>
          <target state="translated">Index.is_numeric()</target>
        </trans-unit>
        <trans-unit id="3cc6d8a931c9fee208b8f3cf19d76d713c89dc5d" translate="yes" xml:space="preserve">
          <source>Index.is_object()</source>
          <target state="translated">Index.is_object()</target>
        </trans-unit>
        <trans-unit id="4525d0b8709d619a431b65c20da8bc6ba09b1a44" translate="yes" xml:space="preserve">
          <source>Index.is_type_compatible()</source>
          <target state="translated">Index.is_type_compatible()</target>
        </trans-unit>
        <trans-unit id="6740ddea5faa07de307632b937a998c94ca6a63a" translate="yes" xml:space="preserve">
          <source>Index.is_unique</source>
          <target state="translated">Index.is_unique</target>
        </trans-unit>
        <trans-unit id="674032d065981e78e8cd136b81b44eb45a598207" translate="yes" xml:space="preserve">
          <source>Index.isin()</source>
          <target state="translated">Index.isin()</target>
        </trans-unit>
        <trans-unit id="8f9d27858d48386a4761bc707ce7819b553d0bc3" translate="yes" xml:space="preserve">
          <source>Index.isna()</source>
          <target state="translated">Index.isna()</target>
        </trans-unit>
        <trans-unit id="5d851a0e9d76585e1b7920ebbb548a67d160c48a" translate="yes" xml:space="preserve">
          <source>Index.isnull()</source>
          <target state="translated">Index.isnull()</target>
        </trans-unit>
        <trans-unit id="c8892d9fcf76b93c0f0f4c39d6048b496935f67b" translate="yes" xml:space="preserve">
          <source>Index.item()</source>
          <target state="translated">Index.item()</target>
        </trans-unit>
        <trans-unit id="e8ea8d058133355dab3f96a87fc9ec7429cc9203" translate="yes" xml:space="preserve">
          <source>Index.itemsize</source>
          <target state="translated">Index.itemsize</target>
        </trans-unit>
        <trans-unit id="8ab0214eec07aa3bc9fcd14199b90eb2806c2746" translate="yes" xml:space="preserve">
          <source>Index.join()</source>
          <target state="translated">Index.join()</target>
        </trans-unit>
        <trans-unit id="b45fb2874f4e6a47bc1a8c669598c02756198ff8" translate="yes" xml:space="preserve">
          <source>Index.map()</source>
          <target state="translated">Index.map()</target>
        </trans-unit>
        <trans-unit id="bf243747f281253b63548f651a488e9104e5566e" translate="yes" xml:space="preserve">
          <source>Index.max()</source>
          <target state="translated">Index.max()</target>
        </trans-unit>
        <trans-unit id="dad05f0e4cf78f12f0df0617b2eca51ad76f1e3e" translate="yes" xml:space="preserve">
          <source>Index.memory_usage()</source>
          <target state="translated">Index.memory_usage()</target>
        </trans-unit>
        <trans-unit id="6f3ff971904fc6d7253ec3e53ce502d7c2bb01b0" translate="yes" xml:space="preserve">
          <source>Index.min()</source>
          <target state="translated">Index.min()</target>
        </trans-unit>
        <trans-unit id="a81409d1833143080fa7467f35ac07337a7dc88b" translate="yes" xml:space="preserve">
          <source>Index.name</source>
          <target state="translated">Index.name</target>
        </trans-unit>
        <trans-unit id="0967056855c1ae1ff95d670362e8b9cb745929aa" translate="yes" xml:space="preserve">
          <source>Index.names</source>
          <target state="translated">Index.names</target>
        </trans-unit>
        <trans-unit id="9b8bbf4a1d3548f84736a16d908199ad102ca7d1" translate="yes" xml:space="preserve">
          <source>Index.nbytes</source>
          <target state="translated">Index.nbytes</target>
        </trans-unit>
        <trans-unit id="015335b73fb556a0a95f7477349f31835996bc0e" translate="yes" xml:space="preserve">
          <source>Index.ndim</source>
          <target state="translated">Index.ndim</target>
        </trans-unit>
        <trans-unit id="1d16a9b86b35376b0fe2ceb694e880dccd624087" translate="yes" xml:space="preserve">
          <source>Index.nlevels</source>
          <target state="translated">Index.nlevels</target>
        </trans-unit>
        <trans-unit id="7aa616075b64c7fe50d3485e7309af78d33685e4" translate="yes" xml:space="preserve">
          <source>Index.notna()</source>
          <target state="translated">Index.notna()</target>
        </trans-unit>
        <trans-unit id="c054c04dd3852d7befee485647c33564f0e9c6de" translate="yes" xml:space="preserve">
          <source>Index.notnull()</source>
          <target state="translated">Index.notnull()</target>
        </trans-unit>
        <trans-unit id="95141a09ec236ad88338a788ae9bda71d9f7b6ab" translate="yes" xml:space="preserve">
          <source>Index.nunique()</source>
          <target state="translated">Index.nunique()</target>
        </trans-unit>
        <trans-unit id="732ef5ab848fd1322c65183d205ae49fe28c4ac1" translate="yes" xml:space="preserve">
          <source>Index.putmask()</source>
          <target state="translated">Index.putmask()</target>
        </trans-unit>
        <trans-unit id="0ed3c46ffc0bac1516958f6f397676c802f24042" translate="yes" xml:space="preserve">
          <source>Index.ravel()</source>
          <target state="translated">Index.ravel()</target>
        </trans-unit>
        <trans-unit id="a1497db1d34f7e9354a66c83ae2d2ac605c6bdd8" translate="yes" xml:space="preserve">
          <source>Index.reindex()</source>
          <target state="translated">Index.reindex()</target>
        </trans-unit>
        <trans-unit id="01e1d0c95c6feb54b63adae1c6464c50b621266b" translate="yes" xml:space="preserve">
          <source>Index.rename()</source>
          <target state="translated">Index.rename()</target>
        </trans-unit>
        <trans-unit id="77c10629020e8a6aa514d1106ba620916dac587c" translate="yes" xml:space="preserve">
          <source>Index.repeat()</source>
          <target state="translated">Index.repeat()</target>
        </trans-unit>
        <trans-unit id="d69eefbd97fa6081331925aba573779e7e832287" translate="yes" xml:space="preserve">
          <source>Index.searchsorted()</source>
          <target state="translated">Index.searchsorted()</target>
        </trans-unit>
        <trans-unit id="a57478d81d0711e85d7c2a0858e822448ec6cc93" translate="yes" xml:space="preserve">
          <source>Index.set_names()</source>
          <target state="translated">Index.set_names()</target>
        </trans-unit>
        <trans-unit id="624e7ac5391fcc29bb760b6f942218dfa03b0b17" translate="yes" xml:space="preserve">
          <source>Index.set_value()</source>
          <target state="translated">Index.set_value()</target>
        </trans-unit>
        <trans-unit id="9c921b4b894047ddf6a39ab0881e37296631f609" translate="yes" xml:space="preserve">
          <source>Index.shape</source>
          <target state="translated">Index.shape</target>
        </trans-unit>
        <trans-unit id="46400b31e771f708ca74d273f325af855ea6d991" translate="yes" xml:space="preserve">
          <source>Index.shift()</source>
          <target state="translated">Index.shift()</target>
        </trans-unit>
        <trans-unit id="472cefee5f15b86396f78a3a8e6aea60b8a75015" translate="yes" xml:space="preserve">
          <source>Index.size</source>
          <target state="translated">Index.size</target>
        </trans-unit>
        <trans-unit id="1df9304b1390f9267e3c387c34aac0979af35b7e" translate="yes" xml:space="preserve">
          <source>Index.slice_indexer()</source>
          <target state="translated">Index.slice_indexer()</target>
        </trans-unit>
        <trans-unit id="d662c5067630e7b727eb6b33d7ac91db2f6ee08c" translate="yes" xml:space="preserve">
          <source>Index.slice_locs()</source>
          <target state="translated">Index.slice_locs()</target>
        </trans-unit>
        <trans-unit id="db5c1e805ea14b67fd3c52e4f99be0f6a1b90b89" translate="yes" xml:space="preserve">
          <source>Index.sort()</source>
          <target state="translated">Index.sort()</target>
        </trans-unit>
        <trans-unit id="913cf43e3772ed2a8fe03575229daa1bc50dbdc4" translate="yes" xml:space="preserve">
          <source>Index.sort_values()</source>
          <target state="translated">Index.sort_values()</target>
        </trans-unit>
        <trans-unit id="10a67806a9d5ae0108e6749e42319b1d50a16e91" translate="yes" xml:space="preserve">
          <source>Index.sortlevel()</source>
          <target state="translated">Index.sortlevel()</target>
        </trans-unit>
        <trans-unit id="29905bdb7228280b70783d506e68b98b08a339d8" translate="yes" xml:space="preserve">
          <source>Index.str()</source>
          <target state="translated">Index.str()</target>
        </trans-unit>
        <trans-unit id="b6fdc18bb263150a4ad7d892c1a5003bf55ffe18" translate="yes" xml:space="preserve">
          <source>Index.strides</source>
          <target state="translated">Index.strides</target>
        </trans-unit>
        <trans-unit id="0c2e8faf628230a46079a42262caae6249c92330" translate="yes" xml:space="preserve">
          <source>Index.summary()</source>
          <target state="translated">Index.summary()</target>
        </trans-unit>
        <trans-unit id="6c359d26f9e8b4a6ae1a1bb0e579d679a3efe088" translate="yes" xml:space="preserve">
          <source>Index.symmetric_difference()</source>
          <target state="translated">Index.symmetric_difference()</target>
        </trans-unit>
        <trans-unit id="0a2d36df3c300cf03da7892aaaa6880925ff0fc9" translate="yes" xml:space="preserve">
          <source>Index.take()</source>
          <target state="translated">Index.take()</target>
        </trans-unit>
        <trans-unit id="f11c8e81df55d1f42a6f42fb91e0b97e515e05a5" translate="yes" xml:space="preserve">
          <source>Index.to_flat_index()</source>
          <target state="translated">Index.to_flat_index()</target>
        </trans-unit>
        <trans-unit id="03814309dee37171aba0b16696172d33d4843467" translate="yes" xml:space="preserve">
          <source>Index.to_frame()</source>
          <target state="translated">Index.to_frame()</target>
        </trans-unit>
        <trans-unit id="d7c3198d7a0a47fb102b0eb4cc06e0c1974be7e2" translate="yes" xml:space="preserve">
          <source>Index.to_list()</source>
          <target state="translated">Index.to_list()</target>
        </trans-unit>
        <trans-unit id="14f135849706060fa985d034963b41e30cf82edc" translate="yes" xml:space="preserve">
          <source>Index.to_native_types()</source>
          <target state="translated">Index.to_native_types()</target>
        </trans-unit>
        <trans-unit id="a7a7b8e1441200237b2eb67298f893b68a949543" translate="yes" xml:space="preserve">
          <source>Index.to_numpy()</source>
          <target state="translated">Index.to_numpy()</target>
        </trans-unit>
        <trans-unit id="f1b91a93545715d89971596ea7597761d4daba90" translate="yes" xml:space="preserve">
          <source>Index.to_series()</source>
          <target state="translated">Index.to_series()</target>
        </trans-unit>
        <trans-unit id="21ffe541020f68b3a2191ce5cf614066555559e2" translate="yes" xml:space="preserve">
          <source>Index.tolist()</source>
          <target state="translated">Index.tolist()</target>
        </trans-unit>
        <trans-unit id="f2e873abb94cdf33a2f49dc0fb75572620dcc543" translate="yes" xml:space="preserve">
          <source>Index.transpose()</source>
          <target state="translated">Index.transpose()</target>
        </trans-unit>
        <trans-unit id="9385040f7213ca66ce15f470a8df4608d6267a6d" translate="yes" xml:space="preserve">
          <source>Index.union()</source>
          <target state="translated">Index.union()</target>
        </trans-unit>
        <trans-unit id="b3be4dea29e108b703f80b3eff1819418cd6b571" translate="yes" xml:space="preserve">
          <source>Index.unique()</source>
          <target state="translated">Index.unique()</target>
        </trans-unit>
        <trans-unit id="d3528d02b2d70089f66c85f31826c0b1595b7aa7" translate="yes" xml:space="preserve">
          <source>Index.value_counts()</source>
          <target state="translated">Index.value_counts()</target>
        </trans-unit>
        <trans-unit id="9e2e912fc95eed694641b734351b380ab9ad639d" translate="yes" xml:space="preserve">
          <source>Index.values</source>
          <target state="translated">Index.values</target>
        </trans-unit>
        <trans-unit id="b447cdd7372fa3537bde218070ec8ad24d699cff" translate="yes" xml:space="preserve">
          <source>Index.view()</source>
          <target state="translated">Index.view()</target>
        </trans-unit>
        <trans-unit id="32e4ea3e5a968af1c610bdf04cdae77b045bb6f7" translate="yes" xml:space="preserve">
          <source>Index.where()</source>
          <target state="translated">Index.where()</target>
        </trans-unit>
        <trans-unit id="383b324a3291b51f1e54ef9c0d763010fbc5e171" translate="yes" xml:space="preserve">
          <source>IndexError</source>
          <target state="translated">IndexError</target>
        </trans-unit>
        <trans-unit id="7d7226da6286148fdf79035eb7b3a52e9d60aac0" translate="yes" xml:space="preserve">
          <source>Index[source]</source>
          <target state="translated">Index[source]</target>
        </trans-unit>
        <trans-unit id="b96291f27fc9dd4e3ab5ae2408092218f17dc66e" translate="yes" xml:space="preserve">
          <source>Indexers</source>
          <target state="translated">Indexers</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="1654275433623c2178f491b9d20b06fd4b1528ca" translate="yes" xml:space="preserve">
          <source>Indexes are &amp;ldquo;mostly immutable&amp;rdquo;, but it is possible to set and change their &lt;code&gt;name&lt;/code&gt; attribute. You can use the &lt;code&gt;rename&lt;/code&gt;, &lt;code&gt;set_names&lt;/code&gt; to set these attributes directly, and they default to returning a copy.</source>
          <target state="translated">인덱스는 &quot;대부분 변경 불가능&quot;하지만 &lt;code&gt;name&lt;/code&gt; 속성 을 설정하고 변경할 수 있습니다. &lt;code&gt;rename&lt;/code&gt; , &lt;code&gt;set_names&lt;/code&gt; 를 사용하여 이러한 속성을 직접 설정할 수 있으며 기본값은 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f7203e4e11564f9c251f805a1bccda9ffd2205c3" translate="yes" xml:space="preserve">
          <source>Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing &lt;code&gt;index=False&lt;/code&gt; to &lt;code&gt;append&lt;/code&gt;.</source>
          <target state="translated">인덱스는 인덱싱 가능한 항목과 지정한 모든 데이터 열에 자동으로 생성됩니다. 이 동작은 &lt;code&gt;index=False&lt;/code&gt; 를 전달 하여 &lt;code&gt;append&lt;/code&gt; 하여 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dc39c1b8db3d43206b15c448a7fd6b1ce759333" translate="yes" xml:space="preserve">
          <source>Indexes for column or row labels can be changed by assigning a list-like or Index.</source>
          <target state="translated">목록 또는 색인을 지정하여 열 또는 행 레이블의 색인을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f49dfc8c61b51189d6ab59d7f385a3a879f8793a" translate="yes" xml:space="preserve">
          <source>Indexes for row labels can be changed by assigning a list-like or Index.</source>
          <target state="translated">행 레이블의 색인은 목록과 같은 색인 또는 색인을 지정하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="261127cfc0860801b50cb78ae34269f7b441bd78" translate="yes" xml:space="preserve">
          <source>Indexes of maxima along the specified axis.</source>
          <target state="translated">지정된 축을 따라 최대 인덱스.</target>
        </trans-unit>
        <trans-unit id="f9c577f244d008018cf13eba366449dac99c2c09" translate="yes" xml:space="preserve">
          <source>Indexes of minima along the specified axis.</source>
          <target state="translated">지정된 축을 따른 최소 인덱스.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="64a8f190026642d34ee0932a0637568dcdb3ccae" translate="yes" xml:space="preserve">
          <source>Indexing / selection</source>
          <target state="translated">인덱싱 / 선택</target>
        </trans-unit>
        <trans-unit id="954fb2979a6c90527a96c2cd304dd5f40a44a2ce" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;DataFrame&lt;/code&gt; rows with a &lt;em&gt;single&lt;/em&gt; string with getitem (e.g. &lt;code&gt;frame[dtstring]&lt;/code&gt;) is deprecated starting with pandas 1.2.0 (given the ambiguity whether it is indexing the rows or selecting a column) and will be removed in a future version. The equivalent with &lt;code&gt;.loc&lt;/code&gt; (e.g. &lt;code&gt;frame.loc[dtstring]&lt;/code&gt;) is still supported.</source>
          <target state="translated">getitem (예 : &lt;code&gt;frame[dtstring]&lt;/code&gt; )을 사용 하여 &lt;em&gt;단일&lt;/em&gt; 문자열로 &lt;code&gt;DataFrame&lt;/code&gt; 행을 인덱싱하는 것은 pandas 1.2.0부터 더 이상 사용되지 않으며 (행을 인덱싱하거나 열을 선택하는지 여부가 모호한 경우) 향후 버전에서 제거 될 예정입니다. &lt;code&gt;.loc&lt;/code&gt; (예 : &lt;code&gt;frame.loc[dtstring]&lt;/code&gt; ) 과 동일한 기능 이 계속 지원됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b089d781eb00ac22ab922c9f5a58a1fe43d806d8" translate="yes" xml:space="preserve">
          <source>Indexing and selecting data</source>
          <target state="translated">데이터 인덱싱 및 선택</target>
        </trans-unit>
        <trans-unit id="07a480ea6e6d5122adc6862adbf5c4b6683a5b86" translate="yes" xml:space="preserve">
          <source>Indexing on an integer-based Index with floats has been clarified in 0.18.0, for a summary of the changes, see &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/0.25.0/whatsnew/v0.18.0.html#whatsnew-0180-float-indexers&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">float를 사용한 정수 기반 인덱스의 인덱싱은 0.18.0에서 명확하게 변경 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/version/0.25.0/whatsnew/v0.18.0.html#whatsnew-0180-float-indexers&quot;&gt;되었습니다&lt;/a&gt; . 변경 사항에 대한 요약은 여기를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="712853c81a36b089c8f4f7c4ea60ce6faae607df" translate="yes" xml:space="preserve">
          <source>Indexing potentially changes underlying Series dtype</source>
          <target state="translated">인덱싱은 잠재적으로 기본 시리즈 dtype을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="06d09ba5c0ee869c93be108fdba54e0802e8c1f6" translate="yes" xml:space="preserve">
          <source>Indexing will work even if the data are not sorted, but will be rather inefficient (and show a &lt;code&gt;PerformanceWarning&lt;/code&gt;). It will also return a copy of the data rather than a view:</source>
          <target state="translated">인덱싱은 데이터가 정렬되지 않은 경우에도 작동하지만 다소 비효율적입니다 ( &lt;code&gt;PerformanceWarning&lt;/code&gt; 표시 ). 또한 뷰가 아닌 데이터 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85eb152abcef7f61fd369e631b87fae689316ea6" translate="yes" xml:space="preserve">
          <source>Indexing with .str</source>
          <target state="translated">.str로 인덱싱</target>
        </trans-unit>
        <trans-unit id="ffbb57593d7a03297a48e2a428bee98623ce344d" translate="yes" xml:space="preserve">
          <source>Indexing with &lt;code&gt;.str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.str&lt;/code&gt; 을 사용한 인덱싱</target>
        </trans-unit>
        <trans-unit id="56169232bdc05a63e6e835c8bd693f3fc5a85460" translate="yes" xml:space="preserve">
          <source>Indexing with &lt;code&gt;__getitem__/.iloc/.loc&lt;/code&gt; works similarly to an &lt;code&gt;Index&lt;/code&gt; with duplicates. The indexers &lt;strong&gt;must&lt;/strong&gt; be in the category or the operation will raise a &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="translated">와 색인 &lt;code&gt;__getitem__/.iloc/.loc&lt;/code&gt; 비슷하게 작동 &lt;code&gt;Index&lt;/code&gt; 중복으로. 인덱서 &lt;strong&gt;는&lt;/strong&gt; 범주에 &lt;strong&gt;있어야&lt;/strong&gt; 하며 그렇지 않으면 작업에서 &lt;code&gt;KeyError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="2c8d5f8af95dccd225177d0ae706a0efc5f531eb" translate="yes" xml:space="preserve">
          <source>Indexing with NA values</source>
          <target state="translated">NA 값으로 인덱싱</target>
        </trans-unit>
        <trans-unit id="65b0c36092d1e7a95960f6706b377ee27df88793" translate="yes" xml:space="preserve">
          <source>Indexing with an &lt;code&gt;IntervalIndex&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IntervalIndex&lt;/code&gt; 로 인덱싱</target>
        </trans-unit>
        <trans-unit id="2d36e94a5f4799d0f4fc7c19d047efbe7bc3dc1e" translate="yes" xml:space="preserve">
          <source>Indexing with an IntervalIndex</source>
          <target state="translated">IntervalIndex로 인덱싱</target>
        </trans-unit>
        <trans-unit id="ab3a3da7a43a7231c1d6af67741740bc73274e65" translate="yes" xml:space="preserve">
          <source>Indexing with isin</source>
          <target state="translated">isin으로 인덱싱</target>
        </trans-unit>
        <trans-unit id="a51e031249850631af1137765b16b2c632cdfb2d" translate="yes" xml:space="preserve">
          <source>Indexing with list with missing labels is deprecated</source>
          <target state="translated">레이블이없는 목록을 사용한 색인 생성은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fd53627c6e95c899f3d79ebd4fe195698c5b149" translate="yes" xml:space="preserve">
          <source>Indexing, iteration</source>
          <target state="translated">인덱싱, 반복</target>
        </trans-unit>
        <trans-unit id="a8b3f82335a105363bef7fd4d84c4b4be9f5c015" translate="yes" xml:space="preserve">
          <source>IndexingError</source>
          <target state="translated">IndexingError</target>
        </trans-unit>
        <trans-unit id="7f54556ae4d27c8bc55f6c40d19e954c68d1b45e" translate="yes" xml:space="preserve">
          <source>Indicate duplicate Series values.</source>
          <target state="translated">중복 Series 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bb099e3d5476f718918db888a764a5ce26386e0b" translate="yes" xml:space="preserve">
          <source>Indicate duplicate index values.</source>
          <target state="translated">중복 인덱스 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a1aad309f01d5b8f096c3ff64948e51a5cd89e0c" translate="yes" xml:space="preserve">
          <source>Indicate existing (non-missing) values.</source>
          <target state="translated">기존 (비결 측) 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="59cf7e51c8b6d4f7715593e7e8f08b2ec9a7eff2" translate="yes" xml:space="preserve">
          <source>Indicate missing values.</source>
          <target state="translated">결 측값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3650cb93a385cf9888f3ceaca0c62d4076dee4a6" translate="yes" xml:space="preserve">
          <source>Indicate number of NA values placed in non-numeric columns.</source>
          <target state="translated">숫자가 아닌 열에 배치 된 NA 값의 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0417f6473590efe4f3ab5432a361cd947985b49a" translate="yes" xml:space="preserve">
          <source>Indicate whether the date is the first day of a year.</source>
          <target state="translated">날짜가 1 년의 첫날인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1efbd0ef001e741395838a5b2081f1cca86ca78b" translate="yes" xml:space="preserve">
          <source>Indicate whether the date is the last day of the year.</source>
          <target state="translated">날짜가 해당 연도의 마지막 날인지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="41f134ef9128fc53dda2ad19c443db04d6cf1f02" translate="yes" xml:space="preserve">
          <source>Indicate which axis or axes should be reduced.</source>
          <target state="translated">축을 줄여야하는 축을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="27f5c8d0195c4771f4b71590789d79e3339db7a6" translate="yes" xml:space="preserve">
          <source>Indicates if an interval is empty, meaning it contains no points.</source>
          <target state="translated">간격이 비어 있는지 여부를 나타냅니다. 즉, 간격이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0737cea69711bfcb55bd38a6b8c60950c1870160" translate="yes" xml:space="preserve">
          <source>Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as &lt;code&gt;skip_blank_lines=True&lt;/code&gt;), fully commented lines are ignored by the parameter</source>
          <target state="translated">나머지 줄을 구문 분석하지 않아야 함을 나타냅니다. 줄의 시작 부분에있는 경우 해당 줄은 모두 무시됩니다. 이 매개 변수는 단일 문자 여야합니다. 빈 줄 ( &lt;code&gt;skip_blank_lines=True&lt;/code&gt; ) 과 마찬가지로 완전히 주석 처리 된 줄은 매개 변수에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="86b9d846cb91bc7ce4849211ef218e20b5aa9bcc" translate="yes" xml:space="preserve">
          <source>Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as &lt;code&gt;skip_blank_lines=True&lt;/code&gt;), fully commented lines are ignored by the parameter &lt;code&gt;header&lt;/code&gt; but not by &lt;code&gt;skiprows&lt;/code&gt;. For example, if &lt;code&gt;comment='#'&lt;/code&gt;, parsing &amp;lsquo;#empty\na,b,c\n1,2,3&amp;rsquo; with &lt;code&gt;header=0&lt;/code&gt; will result in &amp;lsquo;a,b,c&amp;rsquo; being treated as the header.</source>
          <target state="translated">나머지 줄을 구문 분석하지 않아야 함을 나타냅니다. 줄의 시작 부분에있는 경우 해당 줄은 모두 무시됩니다. 이 매개 변수는 단일 문자 여야합니다. 빈 줄 ( &lt;code&gt;skip_blank_lines=True&lt;/code&gt; ) 과 마찬가지로 완전히 주석 처리 된 줄은 매개 변수 &lt;code&gt;header&lt;/code&gt; 무시 되지만 &lt;code&gt;skiprows&lt;/code&gt; 에서는 무시됩니다 . 예를 들어 &lt;code&gt;comment='#'&lt;/code&gt; 인 경우 '#empty \ na, b, c \ n1,2,3'을 &lt;code&gt;header=0&lt;/code&gt; 으로 구문 분석 하면 'a, b, c'가 헤더로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9fef8046d654078260e60dd16c8b98f7f04028" translate="yes" xml:space="preserve">
          <source>Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as &lt;code&gt;skip_blank_lines=True&lt;/code&gt;), fully commented lines are ignored by the parameter &lt;code&gt;header&lt;/code&gt; but not by &lt;code&gt;skiprows&lt;/code&gt;. For example, if &lt;code&gt;comment='#'&lt;/code&gt;, parsing &lt;code&gt;#empty\na,b,c\n1,2,3&lt;/code&gt; with &lt;code&gt;header=0&lt;/code&gt; will result in &amp;lsquo;a,b,c&amp;rsquo; being treated as the header.</source>
          <target state="translated">나머지 행을 구문 분석하지 않아야 함을 나타냅니다. 줄의 시작 부분에서 발견되면 해당 줄은 모두 무시됩니다. 이 매개 변수는 단일 문자 여야합니다. 빈 줄처럼 ( &lt;code&gt;skip_blank_lines=True&lt;/code&gt; 이면 ), 완전히 주석 처리 된 줄은 매개 변수 &lt;code&gt;header&lt;/code&gt; 의해 무시 되지만 &lt;code&gt;skiprows&lt;/code&gt; 에 의해 무시 되지 않습니다 . 예를 들어, &lt;code&gt;comment='#'&lt;/code&gt; 이면 &lt;code&gt;header=0&lt;/code&gt; &lt;code&gt;#empty\na,b,c\n1,2,3&lt;/code&gt; 을 구문 분석 하면 'a, b, c'가 헤더로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="37178d062a8850434d361891e62062e3d48426a8" translate="yes" xml:space="preserve">
          <source>Indicates whether</source>
          <target state="translated">여부를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="7e45d53abdb49adffe38de1e35288e8c32d96812" translate="yes" xml:space="preserve">
          <source>Indicates whether &lt;code&gt;bins&lt;/code&gt; includes the rightmost edge or not. If &lt;code&gt;right == True&lt;/code&gt; (the default), then the &lt;code&gt;bins&lt;/code&gt;&lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; indicate (1,2], (2,3], (3,4]. This argument is ignored when &lt;code&gt;bins&lt;/code&gt; is an IntervalIndex.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; 에 가장 오른쪽 가장자리가 포함 되는지 여부를 나타냅니다 . 경우 &lt;code&gt;right == True&lt;/code&gt; (디폴트), 다음 &lt;code&gt;bins&lt;/code&gt; &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; (1,2, (2,3, (3,4]를 나타낸다.이 때 인수는 무시 &lt;code&gt;bins&lt;/code&gt; IntervalIndex 인 .</target>
        </trans-unit>
        <trans-unit id="cf260f41e072fcbd89a72d9b30c84ee00d6e82c9" translate="yes" xml:space="preserve">
          <source>Indicates whether the date is the first day of the month.</source>
          <target state="translated">날짜가 해당 월의 첫 번째 날짜인지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e90bdacf40e11c066770b4e726fbd75ab88843c3" translate="yes" xml:space="preserve">
          <source>Indicates whether the date is the last day of the month.</source>
          <target state="translated">날짜가 해당 월의 마지막 날인지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f8a785464e31d60b6cc6e202514d9c1c5e025ffa" translate="yes" xml:space="preserve">
          <source>Indication of expected JSON string format.</source>
          <target state="translated">예상되는 JSON 문자열 형식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="71a80d13bea9cc4642366f9557c290130446684f" translate="yes" xml:space="preserve">
          <source>Indication of expected JSON string format. Compatible JSON strings can be produced by &lt;code&gt;to_json()&lt;/code&gt; with a corresponding orient value. The set of possible orients is:</source>
          <target state="translated">예상되는 JSON 문자열 형식을 나타냅니다. 호환되는 JSON 값 은 &lt;code&gt;to_json()&lt;/code&gt; 에 의해 해당 동양 값 으로 생성 될 수 있습니다 . 가능한 방향 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b8d16260e41af9b7d8a4f13f724a0dafd8ca750" translate="yes" xml:space="preserve">
          <source>Indicator for whether the date is the first day of a quarter.</source>
          <target state="translated">날짜가 분기의 첫 번째 날짜인지 여부를 나타내는 표시기입니다.</target>
        </trans-unit>
        <trans-unit id="4cc72059c84c25c333d3b463c2f85be31a1eab0e" translate="yes" xml:space="preserve">
          <source>Indicator for whether the date is the last day of a quarter.</source>
          <target state="translated">날짜가 분기의 마지막 날인지 여부를 나타내는 표시기입니다.</target>
        </trans-unit>
        <trans-unit id="cc4e5a27c1c9daa14b5f22a7bffa0238bed8ddcd" translate="yes" xml:space="preserve">
          <source>Indicator whether DataFrame is empty.</source>
          <target state="translated">DataFrame이 비어 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">0이 아닌 요소의 인덱스.</target>
        </trans-unit>
        <trans-unit id="b6e7fc4e1853ed95233a37a8a0630372238f21be" translate="yes" xml:space="preserve">
          <source>Indices of output values in original index.</source>
          <target state="translated">원래 색인의 출력 값 색인</target>
        </trans-unit>
        <trans-unit id="451187d824e09416bdf5b3908b3cf382c5a8971b" translate="yes" xml:space="preserve">
          <source>Indices of the maximum values.</source>
          <target state="translated">최대 값의 지표.</target>
        </trans-unit>
        <trans-unit id="671f02f5501dbd35768ce8e054521fd7202e9630" translate="yes" xml:space="preserve">
          <source>Indices to be taken</source>
          <target state="translated">취해야 할 지표</target>
        </trans-unit>
        <trans-unit id="765d15efc7dbbed5015c9a713a5b1c0c8459c275" translate="yes" xml:space="preserve">
          <source>Indices to be taken.</source>
          <target state="translated">취해야 할 지표.</target>
        </trans-unit>
        <trans-unit id="24d1e1e23cae94b254fcd89e183af0d271a7ace0" translate="yes" xml:space="preserve">
          <source>Individual columns can be parsed as a &lt;code&gt;Categorical&lt;/code&gt; using a dict specification:</source>
          <target state="translated">dict 사양을 사용하여 개별 열을 &lt;code&gt;Categorical&lt;/code&gt; 으로 구문 분석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8637dc6e6c9f39b4fcce0cf4f97d9db0eea9f29e" translate="yes" xml:space="preserve">
          <source>Infer dtypes of objects.</source>
          <target state="translated">객체의 dtype을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="8434622ac8eac0882326c9ab5a5c41164f50c0fd" translate="yes" xml:space="preserve">
          <source>Infer the daily frequency</source>
          <target state="translated">일일 빈도 추론</target>
        </trans-unit>
        <trans-unit id="363372827cd3b32ddd9a3a8675e99b905f524ba6" translate="yes" xml:space="preserve">
          <source>Infer the most likely frequency given the input index.</source>
          <target state="translated">입력 지수가 주어질 가능성이 가장 높은 빈도를 유추하십시오.</target>
        </trans-unit>
        <trans-unit id="7807d84d229a37fd3e20c242a6cdca8d89fecc48" translate="yes" xml:space="preserve">
          <source>Infer the most likely frequency given the input index. If the frequency is uncertain, a warning will be printed.</source>
          <target state="translated">입력 지수가 주어질 가능성이 가장 높은 빈도를 유추하십시오. 주파수가 확실하지 않으면 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="753eae3d8ed4b5cddc125b4e743027a905a18560" translate="yes" xml:space="preserve">
          <source>Inferring compression type from the extension:</source>
          <target state="translated">확장에서 압축 유형 유추 :</target>
        </trans-unit>
        <trans-unit id="0455e326e5aee06b2d1ce576468f8e3bb488040b" translate="yes" xml:space="preserve">
          <source>Inferring datetime format</source>
          <target state="translated">날짜 시간 형식 추론</target>
        </trans-unit>
        <trans-unit id="4e19e46d3f94319f04a718815abd73462d2a3bbb" translate="yes" xml:space="preserve">
          <source>Inferring dtypes from a file</source>
          <target state="translated">파일에서 dtype 추론</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="fbddd963d15d26d77d59f9d3be6bc55e6795591e" translate="yes" xml:space="preserve">
          <source>Info axis as iterator.</source>
          <target state="translated">반복자로서의 정보 축.</target>
        </trans-unit>
        <trans-unit id="5a8c1212f08f942348685bd2905c281c8d0d0d7f" translate="yes" xml:space="preserve">
          <source>Info axis.</source>
          <target state="translated">정보 축.</target>
        </trans-unit>
        <trans-unit id="88d92b7702e8e4bfada4dbe18f226a864d45fd31" translate="yes" xml:space="preserve">
          <source>Information on how to write a benchmark and how to use asv can be found in the &lt;a href=&quot;https://asv.readthedocs.io/en/latest/writing_benchmarks.html&quot;&gt;asv documentation&lt;/a&gt;.</source>
          <target state="translated">벤치 마크 작성 방법 및 asv 사용 방법에 대한 정보는 &lt;a href=&quot;https://asv.readthedocs.io/en/latest/writing_benchmarks.html&quot;&gt;asv 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1eaf4350f8cf8f6673f1be29ab6e74ef9bbfec" translate="yes" xml:space="preserve">
          <source>Initial time as a time filter limit.</source>
          <target state="translated">시간 필터 제한으로서의 초기 시간.</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="4327baddf5584e43c8649f4219ef37730642d44d" translate="yes" xml:space="preserve">
          <source>Insert column into DataFrame at specified location.</source>
          <target state="translated">지정된 위치에서 DataFrame에 열을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="de176dd0eaae0ed88f07320897cc04f27deb5819" translate="yes" xml:space="preserve">
          <source>Inserting missing data</source>
          <target state="translated">누락 된 데이터 삽입</target>
        </trans-unit>
        <trans-unit id="9b52384c683f95697370e3a274caf6af2eb81610" translate="yes" xml:space="preserve">
          <source>Inserting, deleting, or modifying a column.</source>
          <target state="translated">열 삽입, 삭제 또는 수정.</target>
        </trans-unit>
        <trans-unit id="87c49654ea19620bd0183d7ec81e3e943b2cb4db" translate="yes" xml:space="preserve">
          <source>Insertion index. Must verify 0 &amp;lt;= loc &amp;lt;= len(columns)</source>
          <target state="translated">삽입 지수. 0 &amp;lt;= loc &amp;lt;= len (열)을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a4705a1a35af666b60e370235470e2bf0e9d4bb" translate="yes" xml:space="preserve">
          <source>Insertion index. Must verify 0 &amp;lt;= loc &amp;lt;= len(columns).</source>
          <target state="translated">삽입 색인. 0 &amp;lt;= loc &amp;lt;= len (열)을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f12f9baf05bbedf5aa0725d6bdaf1d05d3c557f5" translate="yes" xml:space="preserve">
          <source>Insertion method</source>
          <target state="translated">삽입 방법</target>
        </trans-unit>
        <trans-unit id="68d16fffa10ac7263d479c95d49da2993d72198d" translate="yes" xml:space="preserve">
          <source>Inserts missing value (NA) markers in label locations where no data for that label existed</source>
          <target state="translated">해당 레이블에 대한 데이터가 존재하지 않는 레이블 위치에 결 측값 (NA) 마커를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="23a7b5c230cae2890fcefc3e883c71a9e2a6049b" translate="yes" xml:space="preserve">
          <source>Inspecting the &lt;code&gt;ddf&lt;/code&gt; object, we see a few things</source>
          <target state="translated">검사 용 &lt;code&gt;ddf&lt;/code&gt; 객체를, 우리는 몇 가지를 참조</target>
        </trans-unit>
        <trans-unit id="81f21d3d7019e69ec35daca85d304077436b5cf3" translate="yes" xml:space="preserve">
          <source>Inspired by &lt;a href=&quot;https://dplyr.tidyverse.org/reference/mutate.html&quot;&gt;dplyr&amp;rsquo;s&lt;/a&gt;&lt;code&gt;mutate&lt;/code&gt; verb, DataFrame has an &lt;a href=&quot;../reference/api/pandas.dataframe.assign#pandas.DataFrame.assign&quot;&gt;&lt;code&gt;assign()&lt;/code&gt;&lt;/a&gt; method that allows you to easily create new columns that are potentially derived from existing columns.</source>
          <target state="translated">&lt;a href=&quot;https://dplyr.tidyverse.org/reference/mutate.html&quot;&gt;dplyr의 &lt;/a&gt; &lt;code&gt;mutate&lt;/code&gt; 동사에서 영감을 얻은 DataFrame에는 기존 열에서 잠재적으로 파생 된 새 열을 쉽게 만들 수 있는 &lt;a href=&quot;../reference/api/pandas.dataframe.assign#pandas.DataFrame.assign&quot;&gt; &lt;code&gt;assign()&lt;/code&gt; &lt;/a&gt; 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc47878c483b474a961eaafad1f880068f7f351" translate="yes" xml:space="preserve">
          <source>Install either &lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;Anaconda&lt;/a&gt; or &lt;a href=&quot;https://conda.io/miniconda.html&quot;&gt;miniconda&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;Anaconda&lt;/a&gt; 또는 &lt;a href=&quot;https://conda.io/miniconda.html&quot;&gt;miniconda를&lt;/a&gt; 설치 하십시오</target>
        </trans-unit>
        <trans-unit id="39201eac5cffcef98c1628bbd3cccf56fb269fc8" translate="yes" xml:space="preserve">
          <source>Install method</source>
          <target state="translated">설치 방법</target>
        </trans-unit>
        <trans-unit id="fe5a87f5ebb613029dde59600ce8e8791e3a20a0" translate="yes" xml:space="preserve">
          <source>Install the build dependencies</source>
          <target state="translated">빌드 종속성 설치</target>
        </trans-unit>
        <trans-unit id="57be28d780b1b49499404c3bcd5eac13de1c75ec" translate="yes" xml:space="preserve">
          <source>Install the optional dependencies</source>
          <target state="translated">선택적 종속성을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="08c42aaa0fd546650d2b78988b0844eb377772d5" translate="yes" xml:space="preserve">
          <source>Installation instructions for &lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;Anaconda&lt;/a&gt;&lt;a href=&quot;http://docs.continuum.io/anaconda/install.html&quot;&gt;can be found here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.continuum.io/anaconda/&quot;&gt;Anaconda의&lt;/a&gt; 설치 지침은 &lt;a href=&quot;http://docs.continuum.io/anaconda/install.html&quot;&gt;여기에서 찾을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6297c1543458e61b1bdc95d60229abdef0beedfa" translate="yes" xml:space="preserve">
          <source>Installation instructions for &lt;a href=&quot;https://www.activestate.com/activepython&quot;&gt;ActivePython&lt;/a&gt; can be found &lt;a href=&quot;https://www.activestate.com/activepython/downloads&quot;&gt;here&lt;/a&gt;. Versions 2.7 and 3.5 include pandas.</source>
          <target state="translated">&lt;a href=&quot;https://www.activestate.com/activepython&quot;&gt;ActivePython의&lt;/a&gt; 설치 지침은 &lt;a href=&quot;https://www.activestate.com/activepython/downloads&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다. . 버전 2.7 및 3.5에는 팬더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d9c4fdf2d01b4e05daebe6eb281974167b29ba39" translate="yes" xml:space="preserve">
          <source>Installing a C compiler</source>
          <target state="translated">C 컴파일러 설치</target>
        </trans-unit>
        <trans-unit id="b18e57b632a145ef125d8087b991254aaba98bc7" translate="yes" xml:space="preserve">
          <source>Installing from PyPI</source>
          <target state="translated">PyPI에서 설치</target>
        </trans-unit>
        <trans-unit id="25698238529e36c36bbff9a1cf8864afeb7e862b" translate="yes" xml:space="preserve">
          <source>Installing from source</source>
          <target state="translated">소스에서 설치</target>
        </trans-unit>
        <trans-unit id="0de282a6de265deb1a924220a987f4ad0ff8218d" translate="yes" xml:space="preserve">
          <source>Installing pandas</source>
          <target state="translated">팬더 설치</target>
        </trans-unit>
        <trans-unit id="5e5045def9e10f096e07985111ae59fc624ea826" translate="yes" xml:space="preserve">
          <source>Installing pandas and the rest of the &lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; and &lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; stack can be a little difficult for inexperienced users.</source>
          <target state="translated">경험이없는 사용자에게는 팬더와 나머지 &lt;a href=&quot;http://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; 및 &lt;a href=&quot;http://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; 스택을 설치하는 것이 약간 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d39f488f01f5bac7b409b3776f37a438828a38af" translate="yes" xml:space="preserve">
          <source>Installing using your Linux distribution&amp;rsquo;s package manager.</source>
          <target state="translated">Linux 배포판의 패키지 관리자를 사용하여 설치</target>
        </trans-unit>
        <trans-unit id="65c9b0a459f284587dd1cfd66ffc61a6bdbd86b0" translate="yes" xml:space="preserve">
          <source>Installing with ActivePython</source>
          <target state="translated">ActivePython으로 설치</target>
        </trans-unit>
        <trans-unit id="15c5345ff436236c4c6879659dd4eae1b06d0445" translate="yes" xml:space="preserve">
          <source>Installing with Anaconda</source>
          <target state="translated">Anaconda로 설치</target>
        </trans-unit>
        <trans-unit id="c441a6d58ef8a1d14081772e2d3329107fda6577" translate="yes" xml:space="preserve">
          <source>Installing with Miniconda</source>
          <target state="translated">Miniconda로 설치</target>
        </trans-unit>
        <trans-unit id="96a6052c798a2f4dc326b18a86979e4d5f3fb697" translate="yes" xml:space="preserve">
          <source>Instance of the dtype.</source>
          <target state="translated">dtype의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="ba00d53c2b90eed1a390bfaa5799e05045a2a028" translate="yes" xml:space="preserve">
          <source>Instead of nesting, the figure can be split by column with &lt;code&gt;subplots=True&lt;/code&gt;. In this case, a &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes&quot;&gt;&lt;code&gt;matplotlib.axes.Axes&lt;/code&gt;&lt;/a&gt; are returned.</source>
          <target state="translated">중첩 대신 그림을 &lt;code&gt;subplots=True&lt;/code&gt; 로 열별로 분할 할 수 있습니다 . 이 경우, &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes&quot;&gt; &lt;code&gt;matplotlib.axes.Axes&lt;/code&gt; 이&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a584698588777df450ba1802fbc64e715996ea7" translate="yes" xml:space="preserve">
          <source>Instead of nesting, the figure can be split by column with &lt;code&gt;subplots=True&lt;/code&gt;. In this case, a &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes&quot;&gt;&lt;code&gt;matplotlib.axes.Axes&lt;/code&gt;&lt;/a&gt; are returned.</source>
          <target state="translated">중첩하는 대신 &lt;code&gt;subplots=True&lt;/code&gt; 를 사용 하여 그림을 열별로 분할 할 수 있습니다 . 이 경우, &lt;a href=&quot;https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes&quot;&gt; &lt;code&gt;matplotlib.axes.Axes&lt;/code&gt; 이&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ae88169118a216ec792184d9fc15a46283f5b2af" translate="yes" xml:space="preserve">
          <source>Instead of replacing with specified values, you can treat all given values as missing and interpolate over them:</source>
          <target state="translated">지정된 값으로 바꾸는 대신 주어진 모든 값을 결 측값으로 처리하고 그 위에 보간 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a3fa1f19e7e80069c5151243dd68d47bd30af67" translate="yes" xml:space="preserve">
          <source>Instead, use explicit string based keys:</source>
          <target state="translated">대신 명시적인 문자열 기반 키를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a89d5e5adc7fd48a31c08ba36c7c91e5cb6f89b1" translate="yes" xml:space="preserve">
          <source>Instead, you&amp;rsquo;ll need to ensure that the values being assigned are sparse</source>
          <target state="translated">대신 할당되는 값이 희소한지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fbfc2aa3f64c2d954ce8ce07cbbf2db93da6914" translate="yes" xml:space="preserve">
          <source>Institutional partners</source>
          <target state="translated">기관 파트너</target>
        </trans-unit>
        <trans-unit id="24009271c7b262236f31adb1fa5bdcc3dd0497e6" translate="yes" xml:space="preserve">
          <source>Instructions for installing from source, &lt;a href=&quot;https://pypi.org/project/pandas&quot;&gt;PyPI&lt;/a&gt;, &lt;a href=&quot;https://www.activestate.com/activepython/downloads&quot;&gt;ActivePython&lt;/a&gt;, various Linux distributions, or a &lt;a href=&quot;http://github.com/pandas-dev/pandas&quot;&gt;development version&lt;/a&gt; are also provided.</source>
          <target state="translated">소스, &lt;a href=&quot;https://pypi.org/project/pandas&quot;&gt;PyPI&lt;/a&gt; , &lt;a href=&quot;https://www.activestate.com/activepython/downloads&quot;&gt;ActivePython&lt;/a&gt; , 다양한 Linux 배포판 또는 &lt;a href=&quot;http://github.com/pandas-dev/pandas&quot;&gt;개발 버전&lt;/a&gt; 에서 설치하기위한 지침 도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c7b38b9ef59141df261a2c85df142aa9a24814" translate="yes" xml:space="preserve">
          <source>Int which indicates which protocol should be used by the pickler, default HIGHEST_PROTOCOL (see &lt;a href=&quot;#r9a0a8647c05c-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; paragraph 12.1.2). The possible values are 0, 1, 2, 3, 4, 5. A negative value for the protocol parameter is equivalent to setting its value to HIGHEST_PROTOCOL.</source>
          <target state="translated">피클 러가 사용해야하는 프로토콜을 나타내는 Int, 기본값 HIGHEST_PROTOCOL ( &lt;a href=&quot;#r9a0a8647c05c-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 단락 12.1.2 참조) 가능한 값은 0, 1, 2, 3, 4, 5입니다. 프로토콜 매개 변수의 음수 값은 값을 HIGHEST_PROTOCOL로 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e41e945425bff7155af46bfb2d7009c63a104f12" translate="yes" xml:space="preserve">
          <source>Int which indicates which protocol should be used by the pickler, default HIGHEST_PROTOCOL (see &lt;a href=&quot;#r9a0a8647c05c-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; paragraph 12.1.2). The possible values are 0, 1, 2, 3, 4. A negative value for the protocol parameter is equivalent to setting its value to HIGHEST_PROTOCOL.</source>
          <target state="translated">선택기에서 사용해야하는 프로토콜을 나타내는 Int, 기본값은 HIGHEST_PROTOCOL입니다 ( &lt;a href=&quot;#r9a0a8647c05c-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 12.1.2 항 참조 ). 가능한 값은 0, 1, 2, 3, 4입니다. 프로토콜 매개 변수의 음수 값은 값을 HIGHEST_PROTOCOL로 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b84c40c11828847b734cb5c2d31b35ec26b00d63" translate="yes" xml:space="preserve">
          <source>Int which indicates which protocol should be used by the pickler, default HIGHEST_PROTOCOL (see &lt;a href=&quot;#rc4e85fbd536b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; paragraph 12.1.2). The possible values are 0, 1, 2, 3, 4, 5. A negative value for the protocol parameter is equivalent to setting its value to HIGHEST_PROTOCOL.</source>
          <target state="translated">피클 러가 사용해야하는 프로토콜을 나타내는 Int, 기본값 HIGHEST_PROTOCOL ( &lt;a href=&quot;#rc4e85fbd536b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 단락 12.1.2 참조) 가능한 값은 0, 1, 2, 3, 4, 5입니다. 프로토콜 매개 변수의 음수 값은 값을 HIGHEST_PROTOCOL로 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b729c65994630b2d9dffe12bec53a355f78594a" translate="yes" xml:space="preserve">
          <source>Int which indicates which protocol should be used by the pickler, default HIGHEST_PROTOCOL (see &lt;a href=&quot;#rc4e85fbd536b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; paragraph 12.1.2). The possible values are 0, 1, 2, 3, 4. A negative value for the protocol parameter is equivalent to setting its value to HIGHEST_PROTOCOL.</source>
          <target state="translated">선택기에서 사용해야하는 프로토콜을 나타내는 Int, 기본값은 HIGHEST_PROTOCOL입니다 ( &lt;a href=&quot;#rc4e85fbd536b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 12.1.2 항 참조 ). 가능한 값은 0, 1, 2, 3, 4입니다. 프로토콜 매개 변수의 음수 값은 값을 HIGHEST_PROTOCOL로 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fb0e92254ad1be1e1f06659aa5f70f7e2efc3a7" translate="yes" xml:space="preserve">
          <source>Int16Dtype[source]</source>
          <target state="translated">Int16Dtype[source]</target>
        </trans-unit>
        <trans-unit id="e9268a255723b03ccd7474cc600ddfae02f7ce3c" translate="yes" xml:space="preserve">
          <source>Int32Dtype[source]</source>
          <target state="translated">Int32Dtype[source]</target>
        </trans-unit>
        <trans-unit id="8b86334ea2a62fe66435f4a079dbcc1351380b5c" translate="yes" xml:space="preserve">
          <source>Int64Dtype[source]</source>
          <target state="translated">Int64Dtype[source]</target>
        </trans-unit>
        <trans-unit id="2560cfc4a5245c03b2db5c4eaec45e01b7fb5eb1" translate="yes" xml:space="preserve">
          <source>Int64Index and RangeIndex</source>
          <target state="translated">Int64Index 및 RangeIndex</target>
        </trans-unit>
        <trans-unit id="dc8a885be5915510654c358283589f5d52ca3983" translate="yes" xml:space="preserve">
          <source>Int64Index[source]</source>
          <target state="translated">Int64Index[source]</target>
        </trans-unit>
        <trans-unit id="fdc3d18b69c0fe9eafe06b78242aed1c198d78a7" translate="yes" xml:space="preserve">
          <source>Int8Dtype[source]</source>
          <target state="translated">Int8Dtype[source]</target>
        </trans-unit>
        <trans-unit id="a155d332309cae284be3d3e2e396e9f852ef1b8f" translate="yes" xml:space="preserve">
          <source>Integer dtypes and missing data</source>
          <target state="translated">정수 dtype 및 누락 된 데이터</target>
        </trans-unit>
        <trans-unit id="d67c637e4843347ae6ad1205d87858945769f9a5" translate="yes" xml:space="preserve">
          <source>Integer indexing</source>
          <target state="translated">정수 인덱싱</target>
        </trans-unit>
        <trans-unit id="fecdd294069d10f65fb2cb6c4194ce71c994ded6" translate="yes" xml:space="preserve">
          <source>Integer indices that would sort the index if used as an indexer.</source>
          <target state="translated">인덱서로 사용되는 경우 인덱스를 정렬하는 정수 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="c3ba6e74ae4d3503ea9ae5fd16b284bd1c03c87c" translate="yes" xml:space="preserve">
          <source>Integer number of levels in this MultiIndex.</source>
          <target state="translated">이 MultiIndex의 정수 레벨 수입니다.</target>
        </trans-unit>
        <trans-unit id="ac2b22702d7f931ce3e140c1357824fa15b2f80a" translate="yes" xml:space="preserve">
          <source>Integer representation of the values.</source>
          <target state="translated">값의 정수 표현.</target>
        </trans-unit>
        <trans-unit id="835cfc63f84a93524879d15ed6f8d95b8c9c173a" translate="yes" xml:space="preserve">
          <source>Integer-location based indexing for selecting Series.</source>
          <target state="translated">시리즈를 선택하기위한 정수 위치 기반 인덱싱</target>
        </trans-unit>
        <trans-unit id="938e65e953d6c5f1d2fb4dfae2ee38e6c85c658b" translate="yes" xml:space="preserve">
          <source>Integer-location based indexing for selecting scalars.</source>
          <target state="translated">스칼라 선택을위한 정수 위치 기반 인덱싱</target>
        </trans-unit>
        <trans-unit id="35035903c859e314e5552b0e3cc310f6acb72097" translate="yes" xml:space="preserve">
          <source>IntegerArray</source>
          <target state="translated">IntegerArray</target>
        </trans-unit>
        <trans-unit id="a0d7c747c78109f78235954620ad1d3e190f00fd" translate="yes" xml:space="preserve">
          <source>IntegerArray is currently experimental, and its API or internal implementation may change without warning.</source>
          <target state="translated">IntegerArray는 현재 실험 중이며 API 또는 내부 구현이 경고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2e36973f5eae0835cc5fa4a2333f985b3caf66" translate="yes" xml:space="preserve">
          <source>IntegerArray is currently experimental. Its API or implementation may change without warning.</source>
          <target state="translated">IntegerArray는 현재 실험 중입니다. API 또는 구현은 경고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="097950ded27901f97126cff3fa2ab29251b5cd64" translate="yes" xml:space="preserve">
          <source>IntegerNA</source>
          <target state="translated">IntegerNA</target>
        </trans-unit>
        <trans-unit id="d5c174f2ed7e51cccbb95705d757b2ddf8935fde" translate="yes" xml:space="preserve">
          <source>Integers for each level designating which label at each location.</source>
          <target state="translated">각 위치의 레이블을 지정하는 각 수준의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e627bdfae73d31ed6df0b62e98e3536911ccb032" translate="yes" xml:space="preserve">
          <source>Integers from 0 to n - 1 indicating that the index at these positions matches the corresponding target values. Missing values in the target are marked by -1.</source>
          <target state="translated">이 위치의 인덱스가 해당 대상 값과 일치 함을 나타내는 0에서 n-1 사이의 정수입니다. 대상에서 누락 된 값은 -1로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad916d621fd3e7fa446d6d6e3a53d4367d223c36" translate="yes" xml:space="preserve">
          <source>Integers: &lt;code&gt;'int8', 'int16', 'int32', 'int64', 'uint8', 'uint16', 'uint32', 'uint64'&lt;/code&gt;</source>
          <target state="translated">정수 : &lt;code&gt;'int8', 'int16', 'int32', 'int64', 'uint8', 'uint16', 'uint32', 'uint64'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a55b418f944f0d314c5f1d3389f7b2c36d32ac87" translate="yes" xml:space="preserve">
          <source>Intelligent label-based &lt;strong&gt;slicing&lt;/strong&gt;, &lt;strong&gt;fancy indexing&lt;/strong&gt;, and &lt;strong&gt;subsetting&lt;/strong&gt; of large data sets</source>
          <target state="translated">대용량 데이터 세트의 지능형 레이블 기반 &lt;strong&gt;슬라이싱&lt;/strong&gt; , &lt;strong&gt;고급 인덱싱&lt;/strong&gt; 및 &lt;strong&gt;하위&lt;/strong&gt; 설정</target>
        </trans-unit>
        <trans-unit id="70a819e62bb719ee596c8338dd06b78db14eb43b" translate="yes" xml:space="preserve">
          <source>Interaction with scipy.sparse</source>
          <target state="translated">scipy.sparse와의 상호 작용</target>
        </trans-unit>
        <trans-unit id="25081f2955f07c84d66330debfdde0bf66459c94" translate="yes" xml:space="preserve">
          <source>Interchange axes and swap values axes appropriately.</source>
          <target state="translated">축과 교환 축을 적절히 교환하십시오.</target>
        </trans-unit>
        <trans-unit id="f78cb79531d5c9403c70e99a47e3870324236762" translate="yes" xml:space="preserve">
          <source>Internal guides</source>
          <target state="translated">내부 가이드</target>
        </trans-unit>
        <trans-unit id="b82f9e7907571f6d77c6a3a819bd0c0682ca3bc3" translate="yes" xml:space="preserve">
          <source>Internal pandas method for lossy conversion to a NumPy ndarray.</source>
          <target state="translated">NumPy ndarray 로의 손실 변환을위한 내부 팬더 방법.</target>
        </trans-unit>
        <trans-unit id="276f8e50ac42590856b6c99a95104f3d1881fd37" translate="yes" xml:space="preserve">
          <source>Internal property, property synonym for as_blocks().</source>
          <target state="translated">내부 속성, as_blocks ()의 속성 동의어</target>
        </trans-unit>
        <trans-unit id="f2de282e4a0af99847b9afb982349e4a1ecc96cf" translate="yes" xml:space="preserve">
          <source>Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set &lt;code&gt;False&lt;/code&gt;, or specify the type with the &lt;code&gt;dtype&lt;/code&gt; parameter. Note that the entire file is read into a single &lt;code&gt;DataFrame&lt;/code&gt; regardless, use the &lt;code&gt;chunksize&lt;/code&gt; or &lt;code&gt;iterator&lt;/code&gt; parameter to return the data in chunks. (Only valid with C parser)</source>
          <target state="translated">내부적으로 파일을 청크로 처리하면 구문 분석 중 메모리 사용량이 줄어들지 만 유형 추론이 혼합 될 수 있습니다. 혼합 유형이 없도록하려면 &lt;code&gt;False&lt;/code&gt; 를 설정 하거나 &lt;code&gt;dtype&lt;/code&gt; 매개 변수로 유형을 지정하십시오 . 전체 파일은 상관없이 단일 &lt;code&gt;DataFrame&lt;/code&gt; 으로 읽혀 지므로 &lt;code&gt;chunksize&lt;/code&gt; 또는 &lt;code&gt;iterator&lt;/code&gt; 매개 변수를 사용하여 데이터를 청크로 반환합니다. (C 파서에서만 유효 함)</target>
        </trans-unit>
        <trans-unit id="b775b768a01449956096e99bf980afbf32d2e012" translate="yes" xml:space="preserve">
          <source>Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set False, or specify the type with the</source>
          <target state="translated">내부적으로 파일을 청크로 처리하면 구문 분석 중 메모리 사용량이 줄어들지 만 유형 추론이 혼합 될 수 있습니다. 혼합 유형이 없도록하려면 False로 설정하거나</target>
        </trans-unit>
        <trans-unit id="64f8cb10e2d93fffc43b79575bd8ff9fd8adc5fc" translate="yes" xml:space="preserve">
          <source>Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set False, or specify the type with the &lt;code&gt;dtype&lt;/code&gt; parameter. Note that the entire file is read into a single DataFrame regardless, use the &lt;code&gt;chunksize&lt;/code&gt; or &lt;code&gt;iterator&lt;/code&gt; parameter to return the data in chunks. (Only valid with C parser).</source>
          <target state="translated">내부적으로 파일을 청크로 처리하여 구문 분석하는 동안 메모리 사용이 줄어들지 만 혼합 된 유형 유추가 가능합니다. 혼합 유형이 없는지 확인하려면 False를 설정하거나 &lt;code&gt;dtype&lt;/code&gt; 매개 변수로 유형을 지정하십시오 . 전체 파일을 단일 DataFrame으로 읽은 경우 &lt;code&gt;chunksize&lt;/code&gt; 또는 &lt;code&gt;iterator&lt;/code&gt; 매개 변수를 사용하여 청크 단위로 데이터를 리턴하십시오. (C 파서에서만 유효합니다).</target>
        </trans-unit>
        <trans-unit id="1c1c8b7f15a5e3e5a2d9c35e10bfd8db48c2aa6f" translate="yes" xml:space="preserve">
          <source>Internally, the &lt;code&gt;MultiIndex&lt;/code&gt; consists of a few things: the &lt;strong&gt;levels&lt;/strong&gt;, the integer &lt;strong&gt;codes&lt;/strong&gt; (until version 0.24 named &lt;em&gt;labels&lt;/em&gt;), and the level &lt;strong&gt;names&lt;/strong&gt;:</source>
          <target state="translated">내부적으로 &lt;code&gt;MultiIndex&lt;/code&gt; 는 &lt;strong&gt;레벨&lt;/strong&gt; , 정수 &lt;strong&gt;코드&lt;/strong&gt; (버전 0.24라는 &lt;em&gt;레이블&lt;/em&gt; 이 붙을 때까지 ) 및 레벨 &lt;strong&gt;이름으로 구성됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f2ee1b2535a76de4700d8bc664c864e34c040cac" translate="yes" xml:space="preserve">
          <source>Internally, this method uses a &lt;a href=&quot;https://docs.python.org/3/library/textwrap.html#textwrap.TextWrapper&quot;&gt;&lt;code&gt;textwrap.TextWrapper&lt;/code&gt;&lt;/a&gt; instance with default settings. To achieve behavior matching R&amp;rsquo;s stringr library str_wrap function, use the arguments:</source>
          <target state="translated">내부적으로이 메서드는 기본 설정으로 &lt;a href=&quot;https://docs.python.org/3/library/textwrap.html#textwrap.TextWrapper&quot;&gt; &lt;code&gt;textwrap.TextWrapper&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용합니다 . R의 stringr 라이브러리 str_wrap 함수와 일치하는 동작을 달성하려면 인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="5f83d8cca85030f2a2c81016b6a23527829feffb" translate="yes" xml:space="preserve">
          <source>International date formats</source>
          <target state="translated">국제 날짜 형식</target>
        </trans-unit>
        <trans-unit id="8157249a785cb2aaed094f5b845a9181e0cc968d" translate="yes" xml:space="preserve">
          <source>Interpolate a 1-D function.</source>
          <target state="translated">1 차원 함수를 보간합니다.</target>
        </trans-unit>
        <trans-unit id="181d912e530f568442a4560713f48c8720c82454" translate="yes" xml:space="preserve">
          <source>Interpolate polynomial (Krogh interpolator).</source>
          <target state="translated">다항식을 보간합니다 (Krogh 보간 기).</target>
        </trans-unit>
        <trans-unit id="438dad55423914229df0d0b297aa3a56186799ae" translate="yes" xml:space="preserve">
          <source>Interpolate values according to different methods.</source>
          <target state="translated">다른 방법에 따라 값을 보간합니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="dfd6c31cf97ad2b4ee0e41b73d0807a4fb9c4a8b" translate="yes" xml:space="preserve">
          <source>Interpolation limits</source>
          <target state="translated">보간 한계</target>
        </trans-unit>
        <trans-unit id="5547a8c7c7e3256a4f08c1d4ae79db40eddf1eb9" translate="yes" xml:space="preserve">
          <source>Interpolation method for data</source>
          <target state="translated">데이터 보간법</target>
        </trans-unit>
        <trans-unit id="642b5d608dcbf52f516b4e6dc13fcbb045828924" translate="yes" xml:space="preserve">
          <source>Interpolation method for data.</source>
          <target state="translated">데이터에 대한 보간 방법.</target>
        </trans-unit>
        <trans-unit id="e78b9a9859fa602c1b36af4c672b2509a5dd2d88" translate="yes" xml:space="preserve">
          <source>Interpolation technique to use. One of:</source>
          <target state="translated">사용할 보간 기술. 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="011efcd591019b5969a332a24dff728a8107dbe2" translate="yes" xml:space="preserve">
          <source>Interval</source>
          <target state="translated">Interval</target>
        </trans-unit>
        <trans-unit id="6cac75ed68ea193e878d46565e5026f099a06de0" translate="yes" xml:space="preserve">
          <source>Interval boundary to use for labeling. Only when</source>
          <target state="translated">레이블 지정에 사용할 간격 경계입니다. 일 때만</target>
        </trans-unit>
        <trans-unit id="efe5fdfe3c729530e6a719b9a53472e5765ff4bc" translate="yes" xml:space="preserve">
          <source>Interval boundary to use for labeling. Only when &lt;code&gt;freq&lt;/code&gt; parameter is passed.</source>
          <target state="translated">라벨링에 사용할 간격 경계. &lt;code&gt;freq&lt;/code&gt; 매개 변수가 전달 된 경우에만 .</target>
        </trans-unit>
        <trans-unit id="83097b8c3b593ab73f275b7d5515f8755ff674a6" translate="yes" xml:space="preserve">
          <source>Interval data</source>
          <target state="translated">간격 데이터</target>
        </trans-unit>
        <trans-unit id="28d7c04c49002fe644278afa17e14d7dda221def" translate="yes" xml:space="preserve">
          <source>Interval to check against for an overlap.</source>
          <target state="translated">오버랩을 확인하는 간격입니다.</target>
        </trans-unit>
        <trans-unit id="611829ae6077c85cf56e8806ce01ac0728df6b37" translate="yes" xml:space="preserve">
          <source>Interval.closed</source>
          <target state="translated">Interval.closed</target>
        </trans-unit>
        <trans-unit id="561aa5ce32935cabab80e4c26ddc23333df82a84" translate="yes" xml:space="preserve">
          <source>Interval.closed_left</source>
          <target state="translated">Interval.closed_left</target>
        </trans-unit>
        <trans-unit id="565536b81c6114e9186d2cc58d91a1916792bc01" translate="yes" xml:space="preserve">
          <source>Interval.closed_right</source>
          <target state="translated">Interval.closed_right</target>
        </trans-unit>
        <trans-unit id="160657135e5ad3de2d9eec9e1159d0526ea349e9" translate="yes" xml:space="preserve">
          <source>Interval.is_empty</source>
          <target state="translated">Interval.is_empty</target>
        </trans-unit>
        <trans-unit id="0828b891d4816cbd3cfa05d2895163db4fb9bfbf" translate="yes" xml:space="preserve">
          <source>Interval.left</source>
          <target state="translated">Interval.left</target>
        </trans-unit>
        <trans-unit id="c00ba439018539313e4846ace1f3e9a3d93a933b" translate="yes" xml:space="preserve">
          <source>Interval.length</source>
          <target state="translated">Interval.length</target>
        </trans-unit>
        <trans-unit id="8053193e40a7ee975d2b0fe2a8613730496c0c71" translate="yes" xml:space="preserve">
          <source>Interval.mid</source>
          <target state="translated">Interval.mid</target>
        </trans-unit>
        <trans-unit id="c1c5cfb7f671f2562bf0d87c645a989a946862ad" translate="yes" xml:space="preserve">
          <source>Interval.open_left</source>
          <target state="translated">Interval.open_left</target>
        </trans-unit>
        <trans-unit id="af63d285218cdcdbdb505eba40eab3f25ee25ef2" translate="yes" xml:space="preserve">
          <source>Interval.open_right</source>
          <target state="translated">Interval.open_right</target>
        </trans-unit>
        <trans-unit id="c8ed73cff2476bea0994642ec9a5ccc7007f6cdc" translate="yes" xml:space="preserve">
          <source>Interval.overlaps()</source>
          <target state="translated">Interval.overlaps()</target>
        </trans-unit>
        <trans-unit id="02ec4b476f6a897b1a10a06468ee5d7a534b56ae" translate="yes" xml:space="preserve">
          <source>Interval.right</source>
          <target state="translated">Interval.right</target>
        </trans-unit>
        <trans-unit id="fd2aa684d23710fa19162e0673f8201705bdd79b" translate="yes" xml:space="preserve">
          <source>IntervalArray</source>
          <target state="translated">IntervalArray</target>
        </trans-unit>
        <trans-unit id="0e82ecfc4c65554f1246b328977be52c5d28079c" translate="yes" xml:space="preserve">
          <source>IntervalArray.closed</source>
          <target state="translated">IntervalArray.closed</target>
        </trans-unit>
        <trans-unit id="07b6e0ffe7dd648086649af59d4890b9b20f83ba" translate="yes" xml:space="preserve">
          <source>IntervalArray.contains()</source>
          <target state="translated">IntervalArray.contains()</target>
        </trans-unit>
        <trans-unit id="e4f2c1a9f42547dca85d593fa87fcf407389907d" translate="yes" xml:space="preserve">
          <source>IntervalArray.from_arrays()</source>
          <target state="translated">IntervalArray.from_arrays()</target>
        </trans-unit>
        <trans-unit id="be6ce0db6fce6964f38de8a86aa7ee24d9c90ec4" translate="yes" xml:space="preserve">
          <source>IntervalArray.from_breaks()</source>
          <target state="translated">IntervalArray.from_breaks()</target>
        </trans-unit>
        <trans-unit id="33695bc2d443eaaefa7f2aac0d2f656c9b24b550" translate="yes" xml:space="preserve">
          <source>IntervalArray.from_tuples()</source>
          <target state="translated">IntervalArray.from_tuples()</target>
        </trans-unit>
        <trans-unit id="7a618362bbd799b51383957016ac0d5ba553e4b0" translate="yes" xml:space="preserve">
          <source>IntervalArray.is_empty</source>
          <target state="translated">IntervalArray.is_empty</target>
        </trans-unit>
        <trans-unit id="5aeb49b0239bae09765767acacb7e1708e69ab5a" translate="yes" xml:space="preserve">
          <source>IntervalArray.is_non_overlapping_monotonic</source>
          <target state="translated">IntervalArray.is_non_overlapping_monotonic</target>
        </trans-unit>
        <trans-unit id="0e87e816e4d1fe63f06b6dc7dda04f4a21476e91" translate="yes" xml:space="preserve">
          <source>IntervalArray.left</source>
          <target state="translated">IntervalArray.left</target>
        </trans-unit>
        <trans-unit id="5e9eccbdaa57fe426e552a5adfccbaec7cf08506" translate="yes" xml:space="preserve">
          <source>IntervalArray.length</source>
          <target state="translated">IntervalArray.length</target>
        </trans-unit>
        <trans-unit id="b6689570ee3e28f6070c232ca0a6ffe00279adca" translate="yes" xml:space="preserve">
          <source>IntervalArray.mid</source>
          <target state="translated">IntervalArray.mid</target>
        </trans-unit>
        <trans-unit id="36c11e96ecde68c346bde1f9a2d00af301cffde8" translate="yes" xml:space="preserve">
          <source>IntervalArray.overlaps()</source>
          <target state="translated">IntervalArray.overlaps()</target>
        </trans-unit>
        <trans-unit id="2bb141cd3d612e1c1456d892656ce44813f0ab44" translate="yes" xml:space="preserve">
          <source>IntervalArray.right</source>
          <target state="translated">IntervalArray.right</target>
        </trans-unit>
        <trans-unit id="5ca7feaa3dc4fda97165e771b04809b0b95ed080" translate="yes" xml:space="preserve">
          <source>IntervalArray.set_closed()</source>
          <target state="translated">IntervalArray.set_closed()</target>
        </trans-unit>
        <trans-unit id="a69615c38a6a2c471f3a870b18017ccf3d4a01cc" translate="yes" xml:space="preserve">
          <source>IntervalArray.to_tuples()</source>
          <target state="translated">IntervalArray.to_tuples()</target>
        </trans-unit>
        <trans-unit id="2af1eb6a50b73ef7c131a9459830842c1f901482" translate="yes" xml:space="preserve">
          <source>IntervalDtype.subtype</source>
          <target state="translated">IntervalDtype.subtype</target>
        </trans-unit>
        <trans-unit id="8bf5e364c5a5027649e4c323e3910d7fe6a1f3ed" translate="yes" xml:space="preserve">
          <source>IntervalDtype[source]</source>
          <target state="translated">IntervalDtype[source]</target>
        </trans-unit>
        <trans-unit id="dca5e044d02555cd3d54854bb330d78ba61268c2" translate="yes" xml:space="preserve">
          <source>IntervalIndex</source>
          <target state="translated">IntervalIndex</target>
        </trans-unit>
        <trans-unit id="8587202f9201737e441696a0f5edc984254faf26" translate="yes" xml:space="preserve">
          <source>IntervalIndex : Defines the exact bins to be used. Note that IntervalIndex for</source>
          <target state="translated">IntervalIndex : 사용할 정확한 빈을 정의합니다. IntervalIndex에 대한</target>
        </trans-unit>
        <trans-unit id="8e22b1caf5f2342f4c94ddf4f37859b2b5521179" translate="yes" xml:space="preserve">
          <source>IntervalIndex : Defines the exact bins to be used. Note that IntervalIndex for &lt;code&gt;bins&lt;/code&gt; must be non-overlapping.</source>
          <target state="translated">IntervalIndex : 사용할 정확한 구간을 정의합니다. &lt;code&gt;bins&lt;/code&gt; IntervalIndex는 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0627eb8d723b6bffecf7020d135a971314f715f4" translate="yes" xml:space="preserve">
          <source>IntervalIndex components</source>
          <target state="translated">IntervalIndex 구성 요소</target>
        </trans-unit>
        <trans-unit id="b3400bf1be26036cabc32d765cea3de1b322709e" translate="yes" xml:space="preserve">
          <source>IntervalIndex.closed</source>
          <target state="translated">IntervalIndex.closed</target>
        </trans-unit>
        <trans-unit id="64aa7e43d414902cd67b0bc90032567dfe9a5cce" translate="yes" xml:space="preserve">
          <source>IntervalIndex.contains()</source>
          <target state="translated">IntervalIndex.contains()</target>
        </trans-unit>
        <trans-unit id="15886e6c75567dee04f2f5dd51d519c741c0f429" translate="yes" xml:space="preserve">
          <source>IntervalIndex.from_arrays()</source>
          <target state="translated">IntervalIndex.from_arrays()</target>
        </trans-unit>
        <trans-unit id="8c8b9a5fbe9d244a7c808ba6e77e5f78580db8fa" translate="yes" xml:space="preserve">
          <source>IntervalIndex.from_breaks()</source>
          <target state="translated">IntervalIndex.from_breaks()</target>
        </trans-unit>
        <trans-unit id="d0f83f33b6e0fd30d6ce0db459ecb9dc05fc6468" translate="yes" xml:space="preserve">
          <source>IntervalIndex.from_tuples()</source>
          <target state="translated">IntervalIndex.from_tuples()</target>
        </trans-unit>
        <trans-unit id="2a030b12ed9f2caed7d264ee94a6f1ee8129885f" translate="yes" xml:space="preserve">
          <source>IntervalIndex.get_indexer()</source>
          <target state="translated">IntervalIndex.get_indexer()</target>
        </trans-unit>
        <trans-unit id="8b0294e0ba714eeed56b6b8b081acc161f7c53fc" translate="yes" xml:space="preserve">
          <source>IntervalIndex.get_loc()</source>
          <target state="translated">IntervalIndex.get_loc()</target>
        </trans-unit>
        <trans-unit id="86f6a4023d32e1343469a9a45def1137de2bb103" translate="yes" xml:space="preserve">
          <source>IntervalIndex.is_empty</source>
          <target state="translated">IntervalIndex.is_empty</target>
        </trans-unit>
        <trans-unit id="1044b19f681ca66c0157dd20864bbbf1668aa932" translate="yes" xml:space="preserve">
          <source>IntervalIndex.is_non_overlapping_monotonic</source>
          <target state="translated">IntervalIndex.is_non_overlapping_monotonic</target>
        </trans-unit>
        <trans-unit id="7e71d4b955b550723a15df05cd4d3310d093ede3" translate="yes" xml:space="preserve">
          <source>IntervalIndex.is_overlapping</source>
          <target state="translated">IntervalIndex.is_overlapping</target>
        </trans-unit>
        <trans-unit id="ea520b5b20b771603daa4b129a1607b3a5cbd62a" translate="yes" xml:space="preserve">
          <source>IntervalIndex.left</source>
          <target state="translated">IntervalIndex.left</target>
        </trans-unit>
        <trans-unit id="02acd8724a97e5cc00b49b262a766d2b36c84a31" translate="yes" xml:space="preserve">
          <source>IntervalIndex.length</source>
          <target state="translated">IntervalIndex.length</target>
        </trans-unit>
        <trans-unit id="c5cdbb716e932b7e8b4035045d5768cbf7ee3577" translate="yes" xml:space="preserve">
          <source>IntervalIndex.mid</source>
          <target state="translated">IntervalIndex.mid</target>
        </trans-unit>
        <trans-unit id="2e1041618077823e767819c546bb70efb79daa91" translate="yes" xml:space="preserve">
          <source>IntervalIndex.overlaps()</source>
          <target state="translated">IntervalIndex.overlaps()</target>
        </trans-unit>
        <trans-unit id="a37c0ba96c8814c6943101b8673391e9cc26ee1b" translate="yes" xml:space="preserve">
          <source>IntervalIndex.right</source>
          <target state="translated">IntervalIndex.right</target>
        </trans-unit>
        <trans-unit id="3ccb379333e10d062197d41dfce4e67294c0feed" translate="yes" xml:space="preserve">
          <source>IntervalIndex.set_closed()</source>
          <target state="translated">IntervalIndex.set_closed()</target>
        </trans-unit>
        <trans-unit id="70ad5d670ae293049e41569b175e925263cca805" translate="yes" xml:space="preserve">
          <source>IntervalIndex.to_tuples()</source>
          <target state="translated">IntervalIndex.to_tuples()</target>
        </trans-unit>
        <trans-unit id="e51cd688868c6e31661b250e79b5c9ee25d45800" translate="yes" xml:space="preserve">
          <source>IntervalIndex.values</source>
          <target state="translated">IntervalIndex.values</target>
        </trans-unit>
        <trans-unit id="2e45ad9833e54b5a95cffb1a6d75c669070984d0" translate="yes" xml:space="preserve">
          <source>IntervalIndex[source]</source>
          <target state="translated">IntervalIndex[source]</target>
        </trans-unit>
        <trans-unit id="99267cc8937fb84d59bd60cc8326f8d752393db1" translate="yes" xml:space="preserve">
          <source>Intervals</source>
          <target state="translated">Intervals</target>
        </trans-unit>
        <trans-unit id="f914a9254e0df52fc99e182c3a247611439cd038" translate="yes" xml:space="preserve">
          <source>Intervals that only have an open endpoint in common do not overlap:</source>
          <target state="translated">공통 엔드 포인트 만있는 간격은 겹치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="046e05e92c867fcd7fe0e034d8463610f1f90f0a" translate="yes" xml:space="preserve">
          <source>Intervals that share closed endpoints overlap:</source>
          <target state="translated">닫힌 끝점을 공유하는 간격이 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="16ab833a1b62c1e352db9cd104aa6510ffa72e6c" translate="yes" xml:space="preserve">
          <source>Intro to data structures</source>
          <target state="translated">데이터 구조 소개</target>
        </trans-unit>
        <trans-unit id="04af3b830174d871b2537725573c6b32e40ffe22" translate="yes" xml:space="preserve">
          <source>Intro to pandas data structures, by Greg Reda</source>
          <target state="translated">Greg Reda의 팬더 데이터 구조 소개</target>
        </trans-unit>
        <trans-unit id="8d8b12a1b8fad8a954d19d380a53d0e32a7b2a61" translate="yes" xml:space="preserve">
          <source>Introspect the data deeply, interrogate</source>
          <target state="translated">데이터를 깊이 조사하고 심문하십시오.</target>
        </trans-unit>
        <trans-unit id="f478112ac03ff0b30a79a1b3bacd408da36f3147" translate="yes" xml:space="preserve">
          <source>Introspect the data deeply, interrogate &lt;code&gt;object&lt;/code&gt; dtypes for system-level memory consumption</source>
          <target state="translated">데이터를 심층적으로 조사 하고 시스템 레벨 메모리 소비에 대한 &lt;code&gt;object&lt;/code&gt; dtype 조사</target>
        </trans-unit>
        <trans-unit id="18647f2856109eab6741380adf9d4b1cfc6a7dc8" translate="yes" xml:space="preserve">
          <source>Intuitive &lt;strong&gt;merging&lt;/strong&gt; and &lt;strong&gt;joining&lt;/strong&gt; data sets</source>
          <target state="translated">직관적 인 &lt;strong&gt;병합&lt;/strong&gt; 및 &lt;strong&gt;결합&lt;/strong&gt; 데이터 세트</target>
        </trans-unit>
        <trans-unit id="0de700c837994deac0f71db131be20824aec05ea" translate="yes" xml:space="preserve">
          <source>Invalid data</source>
          <target state="translated">유효하지 않은 데이터</target>
        </trans-unit>
        <trans-unit id="7cc054a8a14a9df996bdff4f66bcfae98815bf64" translate="yes" xml:space="preserve">
          <source>Inverse of DataFrame.squeeze for a single-column DataFrame.</source>
          <target state="translated">단일 열 DataFrame에 대한 DataFrame.squeeze와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="d690b290c1d9f204aba4c8da17d652dd67780ada" translate="yes" xml:space="preserve">
          <source>Inverse of notna.</source>
          <target state="translated">notna의 반대.</target>
        </trans-unit>
        <trans-unit id="40c85f2aa31e61c387db262d5d29d99841fb3d6e" translate="yes" xml:space="preserve">
          <source>Invoke function on a DataFrame.</source>
          <target state="translated">DataFrame에서 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d3eba4a72537b40ba55a9a002c7e8d0dcbed2eb3" translate="yes" xml:space="preserve">
          <source>Invoke function on a Series.</source>
          <target state="translated">시리즈에서 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="a4f1b06c5d6153d9b3232dab43627c47b17ae991" translate="yes" xml:space="preserve">
          <source>Invoke function on values of Series.</source>
          <target state="translated">Series의 값에 대해 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">다음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a9c6619af47fb5c7ef3fe542a82fff1059aa247b" translate="yes" xml:space="preserve">
          <source>It also accepts a function:</source>
          <target state="translated">또한 함수를 받아들입니다 :</target>
        </trans-unit>
        <trans-unit id="44b08baebf66e0ec997fa1261237b3b2c4390d2f" translate="yes" xml:space="preserve">
          <source>It can also be called using</source>
          <target state="translated">다음을 사용하여 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9adb6d06d998589f99169fb64c8fd5ada7fda5d" translate="yes" xml:space="preserve">
          <source>It can also be called using &lt;code&gt;self @ other&lt;/code&gt; in Python &amp;gt;= 3.5.</source>
          <target state="translated">Python&amp;gt; = 3.5에서 &lt;code&gt;self @ other&lt;/code&gt; 를 사용하여 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5675034e6262a96842b16420f5246ac9e63a2bac" translate="yes" xml:space="preserve">
          <source>It comprises info about hosting operation system, pandas version, and versions of other installed relative packages.</source>
          <target state="translated">호스팅 운영 체제, pandas 버전 및 설치된 기타 관련 패키지 버전에 대한 정보로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f47cf4ff5ccb9c9767c8153eafcd69b36fe1a6b4" translate="yes" xml:space="preserve">
          <source>It happens due to a lack of support or functionality for parsing a particular attribute of a CSV file with the requested engine.</source>
          <target state="translated">요청 된 엔진으로 CSV 파일의 특정 속성을 구문 분석하기위한 지원 또는 기능이 없기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa96e1d3ca6bfa9dac9d1de8e26946bb72dcb049" translate="yes" xml:space="preserve">
          <source>It has the row axis labels and column axis labels as the only members. They are returned in that order.</source>
          <target state="translated">행 축 레이블과 열 축 레이블이 유일한 멤버입니다. 순서대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cada045892761ae7c694658c4bd800b3a75e5b62" translate="yes" xml:space="preserve">
          <source>It is a method of managing accounting periods. It is a common calendar structure for some industries, such as retail, manufacturing and parking industry.</source>
          <target state="translated">회계 기간을 관리하는 방법입니다. 소매, 제조 및 주차 산업과 같은 일부 산업에서 공통적 인 달력 구조입니다.</target>
        </trans-unit>
        <trans-unit id="c0e8f0b4cc4c5ed8b297115ebfed0788f0cd941d" translate="yes" xml:space="preserve">
          <source>It is also possible to limit the number of splits:</source>
          <target state="translated">분할 수를 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e24e86445944e8ead3d97ed22a9314144854fb9" translate="yes" xml:space="preserve">
          <source>It is also possible to write data to and reading data from &lt;em&gt;Stata&lt;/em&gt; format files. See &lt;a href=&quot;io#io-stata-categorical&quot;&gt;here&lt;/a&gt; for an example and caveats.</source>
          <target state="translated">&lt;em&gt;Stata&lt;/em&gt; 형식 파일에 데이터를 쓰고 읽을 수도 있습니다 . 예와주의 사항 은 &lt;a href=&quot;io#io-stata-categorical&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1435317d2f10cd5e8612788542b4b8c2dde550b" translate="yes" xml:space="preserve">
          <source>It is common to have missing values when stacking a dataframe with multi-level columns, as the stacked dataframe typically has more values than the original dataframe. Missing values are filled with NaNs:</source>
          <target state="translated">쌓인 데이터 프레임은 일반적으로 원래 데이터 프레임보다 많은 값을 가지므로 다중 레벨 열로 데이터 프레임을 쌓을 때 결 측값이있는 것이 일반적입니다. 결 측값은 NaN으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="10af35212d670a59176d058c901f602e8e4be48b" translate="yes" xml:space="preserve">
          <source>It is easy to expand this to return a DataFrame using &lt;code&gt;expand&lt;/code&gt;.</source>
          <target state="translated">사용 DataFrame을 반환하려면이 옵션을 확장하기 쉽고 &lt;code&gt;expand&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="176ebc53b273d38c1c21081b5f01e60bdfa5792d" translate="yes" xml:space="preserve">
          <source>It is either the integer position or the name of the level.</source>
          <target state="translated">정수 위치 또는 레벨 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b120554c49e9baff61149785918279c7280f5c7b" translate="yes" xml:space="preserve">
          <source>It is essential to include the &amp;ldquo;Traceback (most recent call last):&amp;rdquo;, but for the actual error only the error name is sufficient.</source>
          <target state="translated">&amp;ldquo;Traceback (가장 최근 호출) :&amp;rdquo;을 포함해야하지만 실제 오류의 경우 오류 이름만으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="0c4e4afe2a289ec5a6b6091cc3fe64e6b9e19c2a" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;take&lt;/code&gt; method on pandas objects are not intended to work on boolean indices and may return unexpected results.</source>
          <target state="translated">pandas 객체 의 &lt;code&gt;take&lt;/code&gt; 메소드는 부울 인덱스에서 작동하지 않으며 예기치 않은 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc93790d379bc9a34625341d2edf23981d69536" translate="yes" xml:space="preserve">
          <source>It is important to note that tuples and lists are not treated identically in pandas when it comes to indexing. Whereas a tuple is interpreted as one multi-level key, a list is used to specify several keys. Or in other words, tuples go horizontally (traversing levels), lists go vertically (scanning levels).</source>
          <target state="translated">인덱싱과 관련하여 튜플과 목록은 Pandas에서 동일하게 취급되지 않는다는 점에 유의해야합니다. 튜플은 하나의 다중 레벨 키로 해석되는 반면, 목록은 여러 키를 지정하는 데 사용됩니다. 즉, 튜플은 수평 (레벨 순회), 목록은 수직 (스캔 레벨)으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="a3ad71aaa1000d3d060b10677c25f08a15e453f4" translate="yes" xml:space="preserve">
          <source>It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The &lt;code&gt;index_col&lt;/code&gt; specification is based off of this new set of columns rather than the original data columns:</source>
          <target state="translated">여러 텍스트 열을 단일 날짜 열로 구문 분석 할 경우 새 열이 데이터 앞에 추가된다는 점을 기억하는 것이 중요합니다. &lt;code&gt;index_col&lt;/code&gt; 의 사양은 열이 아닌 원래의 데이터 열이 새로운 세트 기반으로한다 :</target>
        </trans-unit>
        <trans-unit id="cbe82361f15f2a4645d7faaceda05abd36de180b" translate="yes" xml:space="preserve">
          <source>It is not possible to export missing data values for integer data types.</source>
          <target state="translated">정수 데이터 유형에 대해 누락 된 데이터 값을 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a44115bc32ce2fff47d51f5ea8647a954094c26" translate="yes" xml:space="preserve">
          <source>It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. &lt;code&gt;read_excel&lt;/code&gt; takes a &lt;code&gt;usecols&lt;/code&gt; keyword to allow you to specify a subset of columns to parse.</source>
          <target state="translated">사용자가 Excel에서 임시 계산을 수행하기 위해 열을 삽입하는 경우가 많으며 해당 열을 읽고 싶지 않을 수 있습니다. &lt;code&gt;read_excel&lt;/code&gt; 은 구문 분석 할 열의 하위 집합을 지정할 수 있도록 &lt;code&gt;usecols&lt;/code&gt; 키워드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf65d18ef9dce768a829e470e14e677ca80e0f44" translate="yes" xml:space="preserve">
          <source>It is often the case that we may want to store date and time data separately, or store various date fields separately. the &lt;code&gt;parse_dates&lt;/code&gt; keyword can be used to specify a combination of columns to parse the dates and/or times from.</source>
          <target state="translated">날짜 및 시간 데이터를 별도로 저장하거나 다양한 날짜 필드를 별도로 저장하려는 경우가 종종 있습니다. &lt;code&gt;parse_dates&lt;/code&gt; 키워드에서 날짜 및 / 또는 시간을 구문 분석하는 열 조합을 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cf20a9a97f2b931f240e87d620d37af27ccae64" translate="yes" xml:space="preserve">
          <source>It is possible to build Intervals of different types, like numeric ones:</source>
          <target state="translated">숫자와 같은 다른 유형의 간격을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47534cfb6d93e22f8fc966a14d48f559d192943" translate="yes" xml:space="preserve">
          <source>It is possible to perform quite complicated selections using this method on multiple axes at the same time.</source>
          <target state="translated">이 방법을 사용하여 여러 축에서 동시에 매우 복잡한 선택을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1acbb5570e1ee54d1345609bd18996911df52322" translate="yes" xml:space="preserve">
          <source>It is possible to transform the contents of Excel cells via the &lt;code&gt;converters&lt;/code&gt; option. For instance, to convert a column to boolean:</source>
          <target state="translated">&lt;code&gt;converters&lt;/code&gt; 옵션을 통해 Excel 셀의 내용을 변환 할 수 있습니다. 예를 들어 열을 부울로 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="face2cae8856d82f87a552ddec8622867741ca2a" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;resample()&lt;/code&gt;, &lt;code&gt;expanding()&lt;/code&gt; and &lt;code&gt;rolling()&lt;/code&gt; as methods on groupbys.</source>
          <target state="translated">사용하는 것이 가능하다 &lt;code&gt;resample()&lt;/code&gt; , &lt;code&gt;expanding()&lt;/code&gt; 및 &lt;code&gt;rolling()&lt;/code&gt; groupbys 방법에있다.</target>
        </trans-unit>
        <trans-unit id="56b17dd85fbdb40bba9ba1372950d7bf6e98ddb5" translate="yes" xml:space="preserve">
          <source>It is possible to write an &lt;code&gt;HDFStore&lt;/code&gt; object that can easily be imported into &lt;code&gt;R&lt;/code&gt; using the &lt;code&gt;rhdf5&lt;/code&gt; library (&lt;a href=&quot;https://www.bioconductor.org/packages/release/bioc/html/rhdf5.html&quot;&gt;Package website&lt;/a&gt;). Create a table format store like this:</source>
          <target state="translated">&lt;code&gt;rhdf5&lt;/code&gt; 라이브러리 ( &lt;a href=&quot;https://www.bioconductor.org/packages/release/bioc/html/rhdf5.html&quot;&gt;패키지 웹 사이트&lt;/a&gt; )를 사용하여 &lt;code&gt;R&lt;/code&gt; 로 쉽게 가져올 수 있는 &lt;code&gt;HDFStore&lt;/code&gt; 객체를 작성할 수 있습니다 . 다음과 같은 테이블 형식 저장소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b62847387767a7afc5ad5291db471feec4822d63" translate="yes" xml:space="preserve">
          <source>It is therefore &lt;em&gt;highly recommended&lt;/em&gt; that you install both &lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup&quot;&gt;&lt;strong&gt;BeautifulSoup4&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/html5lib/html5lib-python&quot;&gt;&lt;strong&gt;html5lib&lt;/strong&gt;&lt;/a&gt;, so that you will still get a valid result (provided everything else is valid) even if &lt;a href=&quot;https://lxml.de&quot;&gt;&lt;strong&gt;lxml&lt;/strong&gt;&lt;/a&gt; fails.</source>
          <target state="translated">따라서 &lt;a href=&quot;https://www.crummy.com/software/BeautifulSoup&quot;&gt;&lt;strong&gt;BeautifulSoup4&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/html5lib/html5lib-python&quot;&gt;&lt;strong&gt;html5lib를&lt;/strong&gt;&lt;/a&gt; 모두 설치 &lt;em&gt;하는 것이 좋습니다&lt;/em&gt; . 그래야 &lt;a href=&quot;https://lxml.de&quot;&gt;&lt;strong&gt;lxml&lt;/strong&gt;&lt;/a&gt; 이 실패 하더라도 유효한 결과 (다른 모든 것이 유효한 경우)를 얻을 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="adf50fe891b0debf64c1e6afa77c7a39270fd607" translate="yes" xml:space="preserve">
          <source>It is used by companies that desire that their fiscal year always end on the same day of the week.</source>
          <target state="translated">회계 연도가 항상 같은 요일에 끝나기를 원하는 회사에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0f6ba4f80185b4f99c031219bda9ccf98d608e8" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;a href=&quot;../reference/api/pandas.concat#pandas.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; (and therefore &lt;code&gt;append()&lt;/code&gt;) makes a full copy of the data, and that constantly reusing this function can create a significant performance hit. If you need to use the operation over several datasets, use a list comprehension.</source>
          <target state="translated">그것은 가치가 지적입니다 &lt;a href=&quot;../reference/api/pandas.concat#pandas.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt; (그리고 따라서 &lt;code&gt;append()&lt;/code&gt; 데이터의 전체 복사본을 만들고, 지속적으로이 기능을 재사용하는 것은 상당한 성능 저하를 만들 수 있습니다). 여러 데이터 세트에서 작업을 사용해야하는 경우 목록 이해를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eaa4934a12e443f7dbe57f0ca725c8df9fab291f" translate="yes" xml:space="preserve">
          <source>It is worth spending some time understanding the result of the &lt;strong&gt;many-to-many&lt;/strong&gt; join case. In SQL / standard relational algebra, if a key combination appears more than once in both tables, the resulting table will have the &lt;strong&gt;Cartesian product&lt;/strong&gt; of the associated data. Here is a very basic example with one unique key combination:</source>
          <target state="translated">다 &lt;strong&gt;대다&lt;/strong&gt; 조인 사례 의 결과를 이해하는 데 시간을 할애 할 가치가 있습니다 . SQL / 표준 관계형 대수에서 키 조합이 두 테이블에 두 번 이상 나타나면 결과 테이블 에 연관된 데이터 의 &lt;strong&gt;데카르트 곱이&lt;/strong&gt; 있습니다. 다음은 하나의 고유 한 키 조합이있는 매우 기본적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="6a91907e88be15224f38fbd89163c5e494f3683e" translate="yes" xml:space="preserve">
          <source>It may also be constructed using one of the constructor methods: &lt;a href=&quot;pandas.arrays.intervalarray.from_arrays#pandas.arrays.IntervalArray.from_arrays&quot;&gt;&lt;code&gt;IntervalArray.from_arrays()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pandas.arrays.intervalarray.from_breaks#pandas.arrays.IntervalArray.from_breaks&quot;&gt;&lt;code&gt;IntervalArray.from_breaks()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pandas.arrays.intervalarray.from_tuples#pandas.arrays.IntervalArray.from_tuples&quot;&gt;&lt;code&gt;IntervalArray.from_tuples()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;pandas.arrays.intervalarray.from_arrays#pandas.arrays.IntervalArray.from_arrays&quot;&gt; &lt;code&gt;IntervalArray.from_arrays()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pandas.arrays.intervalarray.from_breaks#pandas.arrays.IntervalArray.from_breaks&quot;&gt; &lt;code&gt;IntervalArray.from_breaks()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pandas.arrays.intervalarray.from_tuples#pandas.arrays.IntervalArray.from_tuples&quot;&gt; &lt;code&gt;IntervalArray.from_tuples()&lt;/code&gt; &lt;/a&gt; 생성자 메소드 중 하나를 사용하여 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e89f669ea2f289b1ebf71793b7280cf4814ffece" translate="yes" xml:space="preserve">
          <source>It may also be constructed using one of the constructor methods: &lt;a href=&quot;pandas.intervalindex.from_arrays#pandas.IntervalIndex.from_arrays&quot;&gt;&lt;code&gt;IntervalIndex.from_arrays()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pandas.intervalindex.from_breaks#pandas.IntervalIndex.from_breaks&quot;&gt;&lt;code&gt;IntervalIndex.from_breaks()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;pandas.intervalindex.from_tuples#pandas.IntervalIndex.from_tuples&quot;&gt;&lt;code&gt;IntervalIndex.from_tuples()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pandas.intervalindex.from_arrays#pandas.IntervalIndex.from_arrays&quot;&gt; &lt;code&gt;IntervalIndex.from_arrays()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pandas.intervalindex.from_breaks#pandas.IntervalIndex.from_breaks&quot;&gt; &lt;code&gt;IntervalIndex.from_breaks()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;pandas.intervalindex.from_tuples#pandas.IntervalIndex.from_tuples&quot;&gt; &lt;code&gt;IntervalIndex.from_tuples()&lt;/code&gt; &lt;/a&gt; 생성자 메소드 중 하나를 사용하여 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b9f501078cf4368e7d70cfba16ee7bd61fadfce" translate="yes" xml:space="preserve">
          <source>It raises &lt;code&gt;ValueError&lt;/code&gt; if &lt;code&gt;expand=False&lt;/code&gt;.</source>
          <target state="translated">그것은 제기 &lt;code&gt;ValueError&lt;/code&gt; 하는 경우 &lt;code&gt;expand=False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c9e72c397399760ba97009c7aec0d45b4773cf4" translate="yes" xml:space="preserve">
          <source>It returns a Series if &lt;code&gt;expand=False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expand=False&lt;/code&gt; 인 경우 Series를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1965168c6ad3d2b2d00cfe7cb6d868859c6e1cf0" translate="yes" xml:space="preserve">
          <source>It returns a tuple with both of the reindexed Series:</source>
          <target state="translated">재 인덱싱 된 시리즈가 모두 포함 된 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8aee877c6750a1db56ba234e0ede192f8d280e0" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;Index&lt;/code&gt; if &lt;code&gt;expand=False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;expand=False&lt;/code&gt; 인 경우 &lt;code&gt;Index&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5b60c6531f9dcd59ce94db4d583a6d22c8ef5f95" translate="yes" xml:space="preserve">
          <source>It should be clear that a delete operation on the &lt;code&gt;major_axis&lt;/code&gt; will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the &lt;code&gt;minor_axis&lt;/code&gt; will be very expensive. In this case it would almost certainly be faster to rewrite the table using a &lt;code&gt;where&lt;/code&gt; that selects all but the missing data.</source>
          <target state="translated">하나의 청크가 제거되고 다음 데이터가 이동 하므로 &lt;code&gt;major_axis&lt;/code&gt; 의 삭제 작업 이 상당히 빠르다 는 점이 분명해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 반면에 &lt;code&gt;minor_axis&lt;/code&gt; 에 대한 삭제 작업은 비용이 많이 듭니다. 이 경우 누락 된 데이터를 제외한 모든 항목을 선택 하는 &lt;code&gt;where&lt;/code&gt; 를 사용하여 테이블을 다시 작성하는 것이 거의 확실합니다 .</target>
        </trans-unit>
        <trans-unit id="f4f902fc990aa7cc18eb45b140ab7705616e4efc" translate="yes" xml:space="preserve">
          <source>It should be no shock that combining &lt;code&gt;pivot&lt;/code&gt; / &lt;code&gt;stack&lt;/code&gt; / &lt;code&gt;unstack&lt;/code&gt; with GroupBy and the basic Series and DataFrame statistical functions can produce some very expressive and fast data manipulations.</source>
          <target state="translated">&lt;code&gt;pivot&lt;/code&gt; / &lt;code&gt;stack&lt;/code&gt; / &lt;code&gt;unstack&lt;/code&gt; 을 GroupBy 및 기본 Series 및 DataFrame 통계 기능과 결합하여 매우 표현적이고 빠른 데이터 조작을 생성 할 수 있다는 것은 충격이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="64734278bc40eead4242df2ed6009ad15db5c0f8" translate="yes" xml:space="preserve">
          <source>It takes a number of arguments</source>
          <target state="translated">여러 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6172f9d0a37257b3cd71558e4cc581197b27469d" translate="yes" xml:space="preserve">
          <source>It takes a number of arguments:</source>
          <target state="translated">여러 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="74d9442d18382737e05716e7365d40e909103230" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to pass in the categories in a specific order:</source>
          <target state="translated">특정 순서로 카테고리를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a22f7b9673efd4bdca1a8204626e4cecca8c8438" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to reset multiple options at once (using a regex):</source>
          <target state="translated">정규식을 사용하여 한 번에 여러 옵션을 재설정 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d903bf37e5033b95bb15d23458bf8dd3b7b9fb7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to use &lt;a href=&quot;../reference/api/pandas.concat#pandas.concat&quot;&gt;&lt;code&gt;concat()&lt;/code&gt;&lt;/a&gt; to combine multiple files. See the &lt;a href=&quot;cookbook#cookbook-csv-multiple-files&quot;&gt;cookbook&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.concat#pandas.concat&quot;&gt; &lt;code&gt;concat()&lt;/code&gt; &lt;/a&gt; 을 사용하여 여러 파일을 결합하는 것이 가장 좋습니다 . 예제 는 &lt;a href=&quot;cookbook#cookbook-csv-multiple-files&quot;&gt;요리 책&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fde18c5154934d38ec54fad83f0a306e78baec06" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s calling series&amp;hellip; a lot! It&amp;rsquo;s creating a Series from each row, and get-ting from both the index and the series (three times for each row). Function calls are expensive in Python, so maybe we could minimize these by cythonizing the apply part.</source>
          <target state="translated">그것은 시리즈를 부르고있다. .. 많은! 각 행에서 시리즈를 만들고 인덱스와 시리즈 모두에서 가져옵니다 (각 행에 대해 세 번). 함수 호출은 파이썬에서 비싸기 때문에 apply 부분을 cythonizing하여이를 최소화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="633acfa7a5bf5c0d9c2c531e7d5e157154240e8a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s expected &lt;code&gt;ExtensionArray[item]&lt;/code&gt; returns an instance of &lt;code&gt;ExtensionDtype.type&lt;/code&gt; for scalar &lt;code&gt;item&lt;/code&gt;, assuming that value is valid (not NA). NA values do not need to be instances of</source>
          <target state="translated">예상되는 &lt;code&gt;ExtensionArray[item]&lt;/code&gt; 은 값이 유효하다고 가정하고 (NA가 아님) 스칼라 &lt;code&gt;item&lt;/code&gt; 대한 &lt;code&gt;ExtensionDtype.type&lt;/code&gt; 의 인스턴스를 반환합니다 . NA 값은 다음의 인스턴스 일 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df0d3a5efe04f2e2491accd44fecd68fa3e8bf5c" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s expected &lt;code&gt;ExtensionArray[item]&lt;/code&gt; returns an instance of &lt;code&gt;ExtensionDtype.type&lt;/code&gt; for scalar &lt;code&gt;item&lt;/code&gt;, assuming that value is valid (not NA). NA values do not need to be instances of &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">예상되는 &lt;code&gt;ExtensionArray[item]&lt;/code&gt; 은 값이 유효하다고 가정하고 (NA가 아님) 스칼라 &lt;code&gt;item&lt;/code&gt; 에 대한 &lt;code&gt;ExtensionDtype.type&lt;/code&gt; 인스턴스를 리턴합니다 . NA 값은 &lt;code&gt;type&lt;/code&gt; 인스턴스 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="98b2cf4ca3f071ebc59b98ae6a34b34954209985" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not a stretch to see how this can be very useful. More detail on this functionality below.</source>
          <target state="translated">이것이 매우 유용한 방법을 보는 것은 그리 쉬운 일이 아닙니다. 이 기능에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d6eac4cd916d0a348f38d74d4e531d9ded33f95" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not possible to specify labels at creation time. Use &lt;code&gt;s.cat.rename_categories(new_labels)&lt;/code&gt; afterwards.</source>
          <target state="translated">생성시 라벨을 지정할 수 없습니다. 나중에 &lt;code&gt;s.cat.rename_categories(new_labels)&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c768bde3eb58561665998b83f874ea6333cf11b1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth keeping in mind that there&amp;rsquo;s nothing preventing you from using tuples as atomic labels on an axis:</source>
          <target state="translated">축에서 튜플을 원자 레이블로 사용하는 것을 막는 것은 없다는 것을 명심할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7a417ea7902b5fff6f2786510694bba49116e00" translate="yes" xml:space="preserve">
          <source>Item assignment is provided and</source>
          <target state="translated">항목 할당이 제공되고</target>
        </trans-unit>
        <trans-unit id="2a3c510821ad1e4e27fe02ed3acba5ab52a50ac0" translate="yes" xml:space="preserve">
          <source>Item assignment is provided and &lt;code&gt;inplace=False&lt;/code&gt;, but the &lt;code&gt;target&lt;/code&gt; does not support the &lt;code&gt;.copy()&lt;/code&gt; method</source>
          <target state="translated">항목 할당이 제공되고 &lt;code&gt;inplace=False&lt;/code&gt; 이지만 &lt;code&gt;target&lt;/code&gt; 이 &lt;code&gt;.copy()&lt;/code&gt; 메서드를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="feaca6646435491aa2a386bb679999923e6e5aa6" translate="yes" xml:space="preserve">
          <source>Item assignment is provided, but the</source>
          <target state="translated">항목 할당이 제공되지만</target>
        </trans-unit>
        <trans-unit id="c287aea392c82443836cfc718b8654886670c06d" translate="yes" xml:space="preserve">
          <source>Item assignment is provided, but the &lt;code&gt;target&lt;/code&gt; does not support string item assignment.</source>
          <target state="translated">항목 지정이 제공되었지만 &lt;code&gt;target&lt;/code&gt; 이 문자열 항목 지정을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d1507856c15bff65884562b15f521215dbcf61f" translate="yes" xml:space="preserve">
          <source>Items that show up in the opening &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; tag in addition to automatic (by default) id.</source>
          <target state="translated">자동 (기본값) ID 외에 여는 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 태그에 표시되는 항목입니다 .</target>
        </trans-unit>
        <trans-unit id="68f5dc3cadaa2af15a2ba031585953c2abcd47a7" translate="yes" xml:space="preserve">
          <source>Iterable introspection</source>
          <target state="translated">반복 가능한 내성</target>
        </trans-unit>
        <trans-unit id="5eac16a547e2f931b2e9f446f41c0857079799ae" translate="yes" xml:space="preserve">
          <source>Iterable of tuples containing the (index, value) pairs from a Series.</source>
          <target state="translated">Series의 (인덱스, 값) 쌍을 포함하는 튜플을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102a4b85399f6757563e9f3de3984b8f8ded48e5" translate="yes" xml:space="preserve">
          <source>Iterate over (column name, Series) pairs.</source>
          <target state="translated">(열 이름, 시리즈) 쌍을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="312810442c6cae3171af42900d398712647519ee" translate="yes" xml:space="preserve">
          <source>Iterate over DataFrame rows as (index, Series) pairs.</source>
          <target state="translated">DataFrame 행을 (인덱스, 시리즈) 쌍으로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="2c3371ca132475cd8741cdd3198d6ce789891aa0" translate="yes" xml:space="preserve">
          <source>Iterate over DataFrame rows as namedtuples of the values.</source>
          <target state="translated">명명 된 튜플 값으로 DataFrame 행을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="1b4f5ac41bf10f19897db9cff2541f559fd3e17c" translate="yes" xml:space="preserve">
          <source>Iterate over DataFrame rows as namedtuples.</source>
          <target state="translated">명명 된 튜플로 DataFrame 행을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="6050b81fdd2d2486ae1ccd50aea127aa5ddaf879" translate="yes" xml:space="preserve">
          <source>Iterate over info axis.</source>
          <target state="translated">정보 축을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="c303304ed8c81f3dcd00ea91d77064a996a41e5a" translate="yes" xml:space="preserve">
          <source>Iterates over the DataFrame columns, returning a tuple with the column name and the content as a Series.</source>
          <target state="translated">DataFrame 열을 반복하여 열 이름과 내용이 포함 된 튜플을 Series로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd51d9a61fa63b238945eb94ec8ef1e47118fe8c" translate="yes" xml:space="preserve">
          <source>Iterating through files chunk by chunk</source>
          <target state="translated">청크 단위로 파일 청크 반복</target>
        </trans-unit>
        <trans-unit id="d956311afd85fb48f06f7756942d752b970d7921" translate="yes" xml:space="preserve">
          <source>Iterating through groups</source>
          <target state="translated">그룹 반복</target>
        </trans-unit>
        <trans-unit id="60ffbf2958ea85c040366bceddbbdb8adc6aecb2" translate="yes" xml:space="preserve">
          <source>Iterating through pandas objects is generally &lt;strong&gt;slow&lt;/strong&gt;. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:</source>
          <target state="translated">pandas 객체를 반복하는 것은 일반적으로 &lt;strong&gt;느립니다&lt;/strong&gt; . 대부분의 경우 행을 수동으로 반복 할 필요가 없으며 다음 방법 중 하나를 사용하여 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="3d786ab990cb68937c979af669132a6fff465c2e" translate="yes" xml:space="preserve">
          <source>Iteratively appending rows to a DataFrame can be more computationally intensive than a single concatenate. A better solution is to append those rows to a list and then concatenate the list with the original DataFrame all at once.</source>
          <target state="translated">반복적으로 DataFrame에 행을 추가하는 것은 단일 연결보다 계산 집약적 일 수 있습니다. 더 나은 해결책은 해당 행을 목록에 추가 한 다음 목록을 원래 DataFrame과 한 번에 연결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="85d3a7e41c4c159c394df7e13d5aabafb4a54d84" translate="yes" xml:space="preserve">
          <source>Iteratively appending to a Series can be more computationally intensive than a single concatenate. A better solution is to append values to a list and then concatenate the list with the original Series all at once.</source>
          <target state="translated">반복적으로 Series에 추가하는 것은 단일 연결보다 계산 집약적 일 수 있습니다. 더 나은 해결책은 값을 목록에 추가 한 다음 목록을 원래 시리즈와 한 번에 연결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="1ac9d6f2837ffeca47fa8ed574cad7d73a9ebb27" translate="yes" xml:space="preserve">
          <source>Iterator over (column name, Series) pairs.</source>
          <target state="translated">반복자 (열 이름, 시리즈) 쌍.</target>
        </trans-unit>
        <trans-unit id="9c0c781aaf9628673ff5ee1fdf35e3d17aa036a0" translate="yes" xml:space="preserve">
          <source>Its &lt;a href=&quot;https://docs.spyder-ide.org/variableexplorer.html&quot;&gt;Variable Explorer&lt;/a&gt; allows users to view, manipulate and edit pandas &lt;code&gt;Index&lt;/code&gt;, &lt;code&gt;Series&lt;/code&gt;, and &lt;code&gt;DataFrame&lt;/code&gt; objects like a &amp;ldquo;spreadsheet&amp;rdquo;, including copying and modifying values, sorting, displaying a &amp;ldquo;heatmap&amp;rdquo;, converting data types and more. Pandas objects can also be renamed, duplicated, new columns added, copyed/pasted to/from the clipboard (as TSV), and saved/loaded to/from a file. Spyder can also import data from a variety of plain text and binary files or the clipboard into a new pandas DataFrame via a sophisticated import wizard.</source>
          <target state="translated">그 &lt;a href=&quot;https://docs.spyder-ide.org/variableexplorer.html&quot;&gt;변수 탐색기&lt;/a&gt; 보기에 사용자가 조작하고 팬더 편집 할 수 있습니다 &lt;code&gt;Index&lt;/code&gt; , &lt;code&gt;Series&lt;/code&gt; 및 &lt;code&gt;DataFrame&lt;/code&gt; 는 복사 값을 수정, 정렬은 &quot;히트 맵&quot;을 표시, 더 많은 데이터 형식을 변환 포함하여 &quot;스프레드 시트&quot;와 같은 객체. 또한 Pandas 객체의 이름을 바꾸고, 복제하고, 새 열을 추가하고, 클립 보드에서 (TSV로) 복사 / 붙여 넣기 및 파일로 /로드 할 수 있습니다. Spyder는 정교한 가져 오기 마법사를 통해 다양한 일반 텍스트 및 이진 파일 또는 클립 보드에서 새 팬더 DataFrame으로 데이터를 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="636770bef69ef6eca66b715de8caeca99098c690" translate="yes" xml:space="preserve">
          <source>Its row and column indices are used to define the new indices of this object.</source>
          <target state="translated">행 및 열 인덱스는이 개체의 새 인덱스를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="58a3481320054de4482f5fe977bc4804abd5d7bd" translate="yes" xml:space="preserve">
          <source>January 31st (&amp;lsquo;END&amp;rsquo;) vs. January 1st (&amp;lsquo;START&amp;rsquo;) for example.</source>
          <target state="translated">예를 들어 1 월 31 일 ( 'END') 대 1 월 1 일 ( 'START')입니다.</target>
        </trans-unit>
        <trans-unit id="55bd9f644ed1879ac807b80efec3b8546a247ed4" translate="yes" xml:space="preserve">
          <source>Jinja2</source>
          <target state="translated">Jinja2</target>
        </trans-unit>
        <trans-unit id="e1f9a9fc7e35bca9a1c70dd51f9727e338f07aad" translate="yes" xml:space="preserve">
          <source>Jit</source>
          <target state="translated">Jit</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="fbf76ec8bd2376ecc55d846ec46090ec2415b49d" translate="yes" xml:space="preserve">
          <source>Join DataFrames using indexes.</source>
          <target state="translated">인덱스를 사용하여 DataFrames에 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="fb22fde5735d985c24376dbc60298adb2c414047" translate="yes" xml:space="preserve">
          <source>Join DataFrames using their indexes.</source>
          <target state="translated">인덱스를 사용하여 DataFrames에 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="882338627d29897ec99fb741b7ba17cf79a1b429" translate="yes" xml:space="preserve">
          <source>Join all lists using a &amp;lsquo;-&amp;lsquo;. The lists containing object(s) of types other than str will produce a NaN.</source>
          <target state="translated">'-'를 사용하여 모든 목록에 참여하십시오. str 이외의 유형의 객체를 포함하는 목록은 NaN을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e298a89c4477958b4df27704021f2a2b868c7fb6" translate="yes" xml:space="preserve">
          <source>Join columns of another DataFrame.</source>
          <target state="translated">다른 DataFrame의 열을 조인합니다.</target>
        </trans-unit>
        <trans-unit id="fdef4175d4dbabfe1c9ba53ac6c4f10d064b043e" translate="yes" xml:space="preserve">
          <source>Join columns with</source>
          <target state="translated">열 결합</target>
        </trans-unit>
        <trans-unit id="e37f45376f01df0c556006f00d48938002e3c92e" translate="yes" xml:space="preserve">
          <source>Join columns with &lt;code&gt;other&lt;/code&gt; DataFrame either on index or on a key column. Efficiently join multiple DataFrame objects by index at once by passing a list.</source>
          <target state="translated">인덱스 또는 키 열에서 &lt;code&gt;other&lt;/code&gt; DataFrame 과 열을 조인 합니다. 목록을 전달하여 인덱스별로 여러 DataFrame 개체를 한 번에 효율적으로 조인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c997f74be0e40b5971f87acfbf88aeafaa677b94" translate="yes" xml:space="preserve">
          <source>Join lists contained as elements in the Series/Index with passed delimiter.</source>
          <target state="translated">구분 기호를 전달하여 Series / Index에 요소로 포함 된 결합 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9b74f7ea6bc290c72144e1b009ae3ba3a446e210" translate="yes" xml:space="preserve">
          <source>Join lists contained as elements in the Series/Index.</source>
          <target state="translated">시리즈 / 인덱스에 요소로 포함 된 조인 목록.</target>
        </trans-unit>
        <trans-unit id="be3b005444fd89aee662ae556eb126d898e27c23" translate="yes" xml:space="preserve">
          <source>Join method is specified for each axis Index.</source>
          <target state="translated">각 축 Index에 결합 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fd1916758377e680785c70f3c9a212b3b143b916" translate="yes" xml:space="preserve">
          <source>Join strings in each element of the Series with passed separator</source>
          <target state="translated">전달 된 구분 기호를 사용하여 시리즈의 각 요소에있는 문자열 결합</target>
        </trans-unit>
        <trans-unit id="1b9547f774a84d34dcc49b0d035b187cc047c5a1" translate="yes" xml:space="preserve">
          <source>Join with a criteria based on the values</source>
          <target state="translated">값을 기반으로 한 기준과 결합</target>
        </trans-unit>
        <trans-unit id="cce34900917db8feee75789b2905238ac3a987eb" translate="yes" xml:space="preserve">
          <source>Joining / merging on duplicate keys can cause a returned frame that is the multiplication of the row dimensions, which may result in memory overflow. It is the user&amp;rsquo; s responsibility to manage duplicate values in keys before joining large DataFrames.</source>
          <target state="translated">중복 키를 결합 / 병합하면 반환되는 프레임에 행 크기가 곱 해져 메모리 오버플로가 발생할 수 있습니다. 큰 DataFrame에 가입하기 전에 키의 중복 값을 관리하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="1aaf9a1f1049451f216efd0387ee8b1776a0e2c6" translate="yes" xml:space="preserve">
          <source>Joining a single Index to a MultiIndex</source>
          <target state="translated">단일 인덱스를 다중 인덱스에 결합</target>
        </trans-unit>
        <trans-unit id="3bed6c821aa405f5d3b527e1d145e9bfc5b047ed" translate="yes" xml:space="preserve">
          <source>Joining key columns on an index</source>
          <target state="translated">인덱스에서 키 열 결합</target>
        </trans-unit>
        <trans-unit id="49561ecf6909a253bf1355674051150554400159" translate="yes" xml:space="preserve">
          <source>Joining multiple DataFrames</source>
          <target state="translated">여러 DataFrame 결합</target>
        </trans-unit>
        <trans-unit id="bf30d69b54a517e80d30a5c6f37c70898547e5ae" translate="yes" xml:space="preserve">
          <source>Joining on index</source>
          <target state="translated">색인에 결합</target>
        </trans-unit>
        <trans-unit id="3f136e637a0a57072f38a8867f7c27190885bbc8" translate="yes" xml:space="preserve">
          <source>Joining with two MultiIndexes</source>
          <target state="translated">두 개의 MultiIndex로 결합</target>
        </trans-unit>
        <trans-unit id="36203f35f42db555dc5bbef7dc0fd1a0b4670df8" translate="yes" xml:space="preserve">
          <source>Jupyter Notebook / Jupyter Lab</source>
          <target state="translated">Jupyter Notebook / Jupyter Lab</target>
        </trans-unit>
        <trans-unit id="568f57357effa4372f3f919abc2e99f3803359ba" translate="yes" xml:space="preserve">
          <source>Jupyter Notebook is a web application for creating Jupyter notebooks. A Jupyter notebook is a JSON document containing an ordered list of input/output cells which can contain code, text, mathematics, plots and rich media. Jupyter notebooks can be converted to a number of open standard output formats (HTML, HTML presentation slides, LaTeX, PDF, ReStructuredText, Markdown, Python) through &amp;lsquo;Download As&amp;rsquo; in the web interface and &lt;code&gt;jupyter convert&lt;/code&gt; in a shell.</source>
          <target state="translated">Jupyter Notebook은 Jupyter 노트북을 만들기위한 웹 응용 프로그램입니다. Jupyter 노트북은 코드, 텍스트, 수학, 플롯 및 리치 미디어를 포함 할 수있는 정렬 된 입력 / 출력 셀 목록이 포함 된 JSON 문서입니다. Jupyter 노트북은 웹 인터페이스의 '다른 이름으로 다운로드'를 통해 개방형 표준 출력 형식 (HTML, HTML 프리젠 테이션 슬라이드, LaTeX, PDF, ReStructuredText, Markdown, Python)으로 &lt;code&gt;jupyter convert&lt;/code&gt; 있으며 셸에서 Jupyter 변환 을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bda8873caae09d45fbb07657aa82533424515ef" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;DatetimeIndex&lt;/code&gt;, a &lt;code&gt;PeriodIndex&lt;/code&gt; can also be used to index pandas objects:</source>
          <target state="translated">그냥 같은 &lt;code&gt;DatetimeIndex&lt;/code&gt; 하는 &lt;code&gt;PeriodIndex&lt;/code&gt; 은 또한 인덱스 팬더 객체에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="de08fbe3f7acf40b96e47634a280b0d9f354d60d" translate="yes" xml:space="preserve">
          <source>Just like for a DataFrame or Series you can call head and tail on a groupby:</source>
          <target state="translated">DataFrame 또는 Series와 마찬가지로 groupby에서 head 및 tail을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6efc3e93d93667c747948a5979f077716e5d42d" translate="yes" xml:space="preserve">
          <source>Just reset the index, without inserting it as a column in the new DataFrame.</source>
          <target state="translated">새 DataFrame에서 열로 삽입하지 않고 인덱스를 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d5d42afc7cb04b03088f64ac2ef30153ed952c79" translate="yes" xml:space="preserve">
          <source>Just slicing without replacement.</source>
          <target state="translated">교체없이 썰기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d6875d4a085a012ba2ce664f1f3a15d0acb6d85d" translate="yes" xml:space="preserve">
          <source>KDB like asof join</source>
          <target state="translated">asof 조인과 같은 KDB</target>
        </trans-unit>
        <trans-unit id="b4621d6841f56c8aecb7eab95c28aa5a33dc41e0" translate="yes" xml:space="preserve">
          <source>KDE</source>
          <target state="translated">KDE</target>
        </trans-unit>
        <trans-unit id="92164114d978ebdee29a46030047588d1c6dfcec" translate="yes" xml:space="preserve">
          <source>Keep all original rows</source>
          <target state="translated">모든 원래 행 유지</target>
        </trans-unit>
        <trans-unit id="c2fafe44942675b8b76e69078266116e7330a338" translate="yes" xml:space="preserve">
          <source>Keep all original rows and also all original values</source>
          <target state="translated">모든 원래 행과 모든 원래 값 유지</target>
        </trans-unit>
        <trans-unit id="a15e01303b38364ed1682dd0b8805dc66179de2c" translate="yes" xml:space="preserve">
          <source>Keep all original rows and columns</source>
          <target state="translated">모든 원래 행과 열 유지</target>
        </trans-unit>
        <trans-unit id="159d098ff79b1e0e7968dbbcf9647003b0cccbcc" translate="yes" xml:space="preserve">
          <source>Keep all original rows and columns and also all original values</source>
          <target state="translated">모든 원래 행과 열 및 모든 원래 값 유지</target>
        </trans-unit>
        <trans-unit id="5cb944356d960a8e872e407ef82d00669d9eac1e" translate="yes" xml:space="preserve">
          <source>Keep labels from axis for which &amp;ldquo;like in label == True&amp;rdquo;.</source>
          <target state="translated">&quot;label == True&quot;와 같은 축에서 레이블을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="e573145f509f9b3394a77bfe9afb2d201ba08310" translate="yes" xml:space="preserve">
          <source>Keep labels from axis for which re.search(regex, label) == True.</source>
          <target state="translated">re.search (regex, label) == True 인 축에서 레이블을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="7177dff1e598659f3641f9154581ff2e0e1ee47d" translate="yes" xml:space="preserve">
          <source>Keep labels from axis which are in items.</source>
          <target state="translated">항목에있는 축의 레이블을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="597d747eb72ca09cf3654d4dc386e49f21b4bd19" translate="yes" xml:space="preserve">
          <source>Keep only the rows with at least 2 non-NA values.</source>
          <target state="translated">비 NA 값이 2 개 이상인 행만 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="49f6767309c6515a1b3932a35c6b237971659750" translate="yes" xml:space="preserve">
          <source>Keep other columns when using min() with groupby</source>
          <target state="translated">groupby와 함께 min ()을 사용할 때 다른 열 유지</target>
        </trans-unit>
        <trans-unit id="162be66324fa12a2ec251bc8210895db9520b1ac" translate="yes" xml:space="preserve">
          <source>Keep style fixes to a separate commit to make your pull request more readable.</source>
          <target state="translated">풀 요청을 더 읽기 쉽게하려면 스타일 수정을 별도의 커밋으로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="1194ae05fcf2fd9f429a91dd1a6004ef41fd2e6e" translate="yes" xml:space="preserve">
          <source>Keep the DataFrame with valid entries in the same variable.</source>
          <target state="translated">유효한 변수가있는 DataFrame을 동일한 변수에 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="b3e717fb938ce18c04eb5f43e45d5a84cd6a4060" translate="yes" xml:space="preserve">
          <source>Keep the Series with valid entries in the same variable.</source>
          <target state="translated">유효한 변수가있는 Series를 동일한 변수에 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="496ac683e0021004f0854bfef8606ff4f3ca9c72" translate="yes" xml:space="preserve">
          <source>Keep the equal values</source>
          <target state="translated">동일한 값 유지</target>
        </trans-unit>
        <trans-unit id="d3efb43537a407e2b7346a112b7047b1e0f6443b" translate="yes" xml:space="preserve">
          <source>Kendall Tau correlation coefficient</source>
          <target state="translated">Kendall Tau 상관 계수</target>
        </trans-unit>
        <trans-unit id="8bfdceb95cc6bb17e6394823d3c4c3175815f258" translate="yes" xml:space="preserve">
          <source>Kendall rank correlation coefficient</source>
          <target state="translated">Kendall 순위 상관 계수</target>
        </trans-unit>
        <trans-unit id="2d66f420769053d53f233ca2cb66a70e0a195177" translate="yes" xml:space="preserve">
          <source>Kept for compatibility with MultiIndex. Should not be used.</source>
          <target state="translated">MultiIndex와의 호환성을 위해 유지되었습니다. 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="bbf9689c9765bc864b5609b5afaf0790b140407c" translate="yes" xml:space="preserve">
          <source>Key-value representation of Series.</source>
          <target state="translated">시리즈의 키-값 표현.</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="0c73c5da661d43089ff827571cb5b299bb39aaf3" translate="yes" xml:space="preserve">
          <source>KeyError:</source>
          <target state="translated">KeyError:</target>
        </trans-unit>
        <trans-unit id="a314199b9cf6da244be1be86e61bcabb1bd81df5" translate="yes" xml:space="preserve">
          <source>Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. &lt;code&gt;foo/bar/bah&lt;/code&gt;), which will generate a hierarchy of sub-stores (or &lt;code&gt;Groups&lt;/code&gt; in PyTables parlance). Keys can be specified without the leading &amp;lsquo;/&amp;rsquo; and are &lt;strong&gt;always&lt;/strong&gt; absolute (e.g. &amp;lsquo;foo&amp;rsquo; refers to &amp;lsquo;/foo&amp;rsquo;). Removal operations can remove everything in the sub-store and &lt;strong&gt;below&lt;/strong&gt;, so be &lt;em&gt;careful&lt;/em&gt;.</source>
          <target state="translated">상점에 대한 키는 문자열로 지정할 수 있습니다. 이는 형식 (예 : &lt;code&gt;foo/bar/bah&lt;/code&gt; ) 과 같은 계층 적 경로 이름 일 수 있으며 , 하위 저장소 (또는 PyTables 용어로 &lt;code&gt;Groups&lt;/code&gt; 의 계층 구조를 생성합니다 . 키는 선행 '/'없이 지정 될 수 있으며 &lt;strong&gt;항상&lt;/strong&gt; 절대적입니다 (예 : 'foo'는 '/ foo'를 나타냄). 제거 작업은 하위 저장소 및 그 &lt;strong&gt;아래&lt;/strong&gt; 의 모든 항목을 제거 할 수 있으므로 &lt;em&gt;주의하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f5bd7c1e3bd420fe9b0bc72c44fb644a63b07026" translate="yes" xml:space="preserve">
          <source>Keyword arguments to be passed into func.</source>
          <target state="translated">func에 전달할 키워드 인수.</target>
        </trans-unit>
        <trans-unit id="906bdc5926a91c099428c405a99abb6e5be99460" translate="yes" xml:space="preserve">
          <source>Keyword arguments to be passed to hist function.</source>
          <target state="translated">hist 함수에 전달할 키워드 인수입니다.</target>
        </trans-unit>
        <trans-unit id="a5ebdda4099121b4fc33e16a7cb88fda106d6ab7" translate="yes" xml:space="preserve">
          <source>Keyword arguments to be passed to kernel density estimate plot.</source>
          <target state="translated">커널 밀도 추정 플롯에 전달할 키워드 인수입니다.</target>
        </trans-unit>
        <trans-unit id="bea41d64849fc67faded481cc9b307ec7496790d" translate="yes" xml:space="preserve">
          <source>Keyword arguments to be passed to matplotlib.table.table. If</source>
          <target state="translated">matplotlib.table.table에 전달할 키워드 인수입니다. 만약</target>
        </trans-unit>
        <trans-unit id="695c951d72ea95ea3979e3cfc3d49cc434530dbf" translate="yes" xml:space="preserve">
          <source>Keyword arguments to be passed to scatter function.</source>
          <target state="translated">분산 함수에 전달할 키워드 인수입니다.</target>
        </trans-unit>
        <trans-unit id="e7cf5255d9ccf93c28767b4b12e034779b47e798" translate="yes" xml:space="preserve">
          <source>Keyword arguments to pass on to &lt;a href=&quot;pandas.dataframe.plot#pandas.DataFrame.plot&quot;&gt;&lt;code&gt;DataFrame.plot()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pandas.dataframe.plot#pandas.DataFrame.plot&quot;&gt; &lt;code&gt;DataFrame.plot()&lt;/code&gt; &lt;/a&gt; 에 전달할 키워드 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="b27249ce776ae92fd332bc046726fa997294ec48" translate="yes" xml:space="preserve">
          <source>Keyword arguments to pass on to the interpolating function.</source>
          <target state="translated">보간 함수에 전달할 키워드 인수.</target>
        </trans-unit>
        <trans-unit id="c52f1d088d5757bf2dfdb56bb475f8e9d957abc1" translate="yes" xml:space="preserve">
          <source>Keyword arguments to pass to</source>
          <target state="translated">전달할 키워드 인수</target>
        </trans-unit>
        <trans-unit id="06d23cde6551ec047458dff3ea9953074353411a" translate="yes" xml:space="preserve">
          <source>Keyword arguments to pass to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 에 전달할 키워드 인수 .</target>
        </trans-unit>
        <trans-unit id="9b3d684842fcd4c876a4d96144408d928e08d0e4" translate="yes" xml:space="preserve">
          <source>Kind of Data</source>
          <target state="translated">데이터 종류</target>
        </trans-unit>
        <trans-unit id="8947d21b132c3b2ea9866c11de9378719cff9533" translate="yes" xml:space="preserve">
          <source>Kleene logical operations</source>
          <target state="translated">Kleene 논리적 작업</target>
        </trans-unit>
        <trans-unit id="296689fc2df214d907fc533246fca505b2995265" translate="yes" xml:space="preserve">
          <source>Koalas</source>
          <target state="translated">Koalas</target>
        </trans-unit>
        <trans-unit id="feee637174522efa0c10f14f4ba84c841a0fa747" translate="yes" xml:space="preserve">
          <source>Koalas provides a familiar pandas DataFrame interface on top of Apache Spark. It enables users to leverage multi-cores on one machine or a cluster of machines to speed up or scale their DataFrame code.</source>
          <target state="translated">Koalas는 Apache Spark 위에 친숙한 팬더 DataFrame 인터페이스를 제공합니다. 사용자는 하나의 머신 또는 머신 클러스터에서 멀티 코어를 활용하여 DataFrame 코드의 속도를 높이거나 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e32f431c01c4c3625a2a09b78cd105c1d29cc99b" translate="yes" xml:space="preserve">
          <source>Kurtosis obtained using Fisher&amp;rsquo;s definition of kurtosis (kurtosis of normal == 0.0). Normalized by N-1.</source>
          <target state="translated">Fisher의 첨도 정의를 사용하여 얻은 첨도 (정규 첨도 == 0.0). N-1로 정규화되었습니다.</target>
        </trans-unit>
        <trans-unit id="3003f4fdc250e03e1420ddaa0c6423f67a77a398" translate="yes" xml:space="preserve">
          <source>L, ms</source>
          <target state="translated">L, ms</target>
        </trans-unit>
        <trans-unit id="49907e3f0c170d46d89ef7a6a2966fff69e05893" translate="yes" xml:space="preserve">
          <source>Label based indexing via &lt;code&gt;.loc&lt;/code&gt; along the edges of an interval works as you would expect, selecting that particular interval.</source>
          <target state="translated">간격의 가장자리를 따라 &lt;code&gt;.loc&lt;/code&gt; 을 통한 레이블 기반 인덱싱 은 특정 간격을 선택하여 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f546cf634f61e41cd3c821c8196689e0334aad2e" translate="yes" xml:space="preserve">
          <source>Label contained in the index, or partially in a MultiIndex.</source>
          <target state="translated">인덱스에 포함되거나 부분적으로 MultiIndex에 포함 된 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="8ca56da815deb3e387dba7b617c038b79af0ff75" translate="yes" xml:space="preserve">
          <source>Label of column to be popped.</source>
          <target state="translated">팝업되는 열의 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="07635dfd561688138ad91cdafbf65eee0cf006fd" translate="yes" xml:space="preserve">
          <source>Label of the inserted column.</source>
          <target state="translated">삽입 된 열의 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="5ea431278fde26527cc80d26224150a043737b30" translate="yes" xml:space="preserve">
          <source>Label of the maximum value.</source>
          <target state="translated">최대 값의 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="cf07653f71fe6e6876dc9c3bf3aa1a7cfe7da910" translate="yes" xml:space="preserve">
          <source>Label of the minimum value.</source>
          <target state="translated">최소값의 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="60872aece191ce2d85bdc5e9a67f1f6bd98bd0c8" translate="yes" xml:space="preserve">
          <source>Label or position of the column to plot. If not provided, &lt;code&gt;subplots=True&lt;/code&gt; argument must be passed.</source>
          <target state="translated">플롯 할 열의 레이블 또는 위치입니다. 제공되지 않은 경우 &lt;code&gt;subplots=True&lt;/code&gt; 인수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f8a68a09e89c796204cb1c56a44ec08146b0a1d" translate="yes" xml:space="preserve">
          <source>Label the index keys you create with the &lt;code&gt;names&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 옵션으로 작성한 색인 키에 레이블을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf17f3c3e3738ebfe0c533d59ca3eec535fb1e80" translate="yes" xml:space="preserve">
          <source>Label-based &amp;ldquo;fancy indexing&amp;rdquo; function for DataFrame.</source>
          <target state="translated">DataFrame에 대한 레이블 기반 &quot;팬시 색인&quot;기능.</target>
        </trans-unit>
        <trans-unit id="6ffb93b357a1f9637afaf69a6ca8826fafcfba4e" translate="yes" xml:space="preserve">
          <source>Label-based &amp;ldquo;fancy indexing&amp;rdquo; function for DataFrame. Given equal-length arrays of row and column labels, return an array of the values corresponding to each (row, col) pair.</source>
          <target state="translated">DataFrame에 대한 레이블 기반 &quot;팬시 인덱싱&quot;기능. 행 및 열 레이블의 길이가 같은 배열이 주어지면 각 (row, col) 쌍에 해당하는 값의 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c773b57c0430277d39aac60b8983cc35648b03fd" translate="yes" xml:space="preserve">
          <source>Label-based indexing with integer axis labels is a thorny topic. It has been discussed heavily on mailing lists and among various members of the scientific Python community. In pandas, our general viewpoint is that labels matter more than integer locations. Therefore, with an integer axis index &lt;em&gt;only&lt;/em&gt; label-based indexing is possible with the standard tools like &lt;code&gt;.loc&lt;/code&gt;. The following code will generate exceptions:</source>
          <target state="translated">정수 축 레이블을 사용한 레이블 기반 인덱싱은 어려운 주제입니다. 메일 링리스트와 과학 파이썬 커뮤니티의 다양한 구성원들 사이에서 많이 논의되었습니다. Pandas에서 우리의 일반적인 관점은 레이블이 정수 위치보다 중요하다는 것입니다. 따라서, 정수 축 인덱스 &lt;em&gt;에만&lt;/em&gt; 레이블 기반 인덱싱과 같은 표준 도구를 사용하여 가능하다 &lt;code&gt;.loc&lt;/code&gt; . 다음 코드는 예외를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="010c74474755642681defb2191d7a55a8b3f452b" translate="yes" xml:space="preserve">
          <source>Label-location based indexer for selection by label.</source>
          <target state="translated">레이블별로 선택할 수있는 레이블 위치 기반 인덱서</target>
        </trans-unit>
        <trans-unit id="a882fe9be2e4ce65e4c1c43be155e728809e1ac9" translate="yes" xml:space="preserve">
          <source>Label-oriented (Non-Python slicing style : inclusive of end)</source>
          <target state="translated">레이블 지향 (비 Python 슬라이싱 스타일 : 끝 포함)</target>
        </trans-unit>
        <trans-unit id="e5a29afa37e54ea8b4fcfcc627be13f69b301e28" translate="yes" xml:space="preserve">
          <source>Labeled data can similarly be imported from &lt;em&gt;Stata&lt;/em&gt; data files as &lt;code&gt;Categorical&lt;/code&gt; variables using the keyword argument &lt;code&gt;convert_categoricals&lt;/code&gt; (&lt;code&gt;True&lt;/code&gt; by default). The keyword argument &lt;code&gt;order_categoricals&lt;/code&gt; (&lt;code&gt;True&lt;/code&gt; by default) determines whether imported &lt;code&gt;Categorical&lt;/code&gt; variables are ordered.</source>
          <target state="translated">레이블이 지정된 데이터 는 키워드 인수 &lt;code&gt;convert_categoricals&lt;/code&gt; ( 기본값은 &lt;code&gt;True&lt;/code&gt; ) 를 사용하여 &lt;em&gt;Stata&lt;/em&gt; 데이터 파일에서 &lt;code&gt;Categorical&lt;/code&gt; 변수 로 유사하게 가져올 수 있습니다 . 키워드 인수 &lt;code&gt;order_categoricals&lt;/code&gt; ( 기본값은 &lt;code&gt;True&lt;/code&gt; )는 가져온 &lt;code&gt;Categorical&lt;/code&gt; 변수의 정렬 여부를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="875f5c5462eeb482dc23b0483a0db7e2f9d429de" translate="yes" xml:space="preserve">
          <source>Labels along other axis to consider, e.g. if you are dropping rows these would be a list of columns to include.</source>
          <target state="translated">고려할 다른 축을 따라 레이블을 지정합니다. 예를 들어 행을 삭제하는 경우 포함 할 열 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="535dc5a21ed50a7df7720d7b6315402b6b98ba4b" translate="yes" xml:space="preserve">
          <source>Labels need not be unique but must be a hashable type. The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index. Statistical methods from ndarray have been overridden to automatically exclude missing data (currently represented as NaN).</source>
          <target state="translated">레이블은 고유 할 필요는 없지만 해시 가능한 유형이어야합니다. 이 개체는 정수 및 레이블 기반 인덱싱을 모두 지원하며 인덱스와 관련된 작업을 수행하기위한 다양한 방법을 제공합니다. 누락 된 데이터 (현재 NaN으로 표시)를 자동으로 제외하도록 ndarray의 통계 방법이 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="cba1c1b5ddf24c95de14d835b1e647d85b3afb6c" translate="yes" xml:space="preserve">
          <source>Lag Plot</source>
          <target state="translated">래그 플롯</target>
        </trans-unit>
        <trans-unit id="2a869e50a0c6d33ad4084a4a7d2047b0fb517072" translate="yes" xml:space="preserve">
          <source>Lag plot</source>
          <target state="translated">지연 플롯</target>
        </trans-unit>
        <trans-unit id="f3239a901a7dbaf494a7643a85b74f9fc9ef91be" translate="yes" xml:space="preserve">
          <source>Lag plot for time series.</source>
          <target state="translated">시계열에 대한 래그 플롯.</target>
        </trans-unit>
        <trans-unit id="b79b6c9fc6b3a4689effa7f64893bb4892857884" translate="yes" xml:space="preserve">
          <source>Lag plots are most commonly used to look for patterns in time series data.</source>
          <target state="translated">지연 플롯은 시계열 데이터에서 패턴을 찾는 데 가장 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4695a6e637f9bfc6f42211a79dd6885b76eeaf33" translate="yes" xml:space="preserve">
          <source>Lag plots are used to check if a data set or time series is random. Random data should not exhibit any structure in the lag plot. Non-random structure implies that the underlying data are not random. The &lt;code&gt;lag&lt;/code&gt; argument may be passed, and when &lt;code&gt;lag=1&lt;/code&gt; the plot is essentially &lt;code&gt;data[:-1]&lt;/code&gt; vs. &lt;code&gt;data[1:]&lt;/code&gt;.</source>
          <target state="translated">지연 플롯은 데이터 세트 또는 시계열이 랜덤인지 확인하는 데 사용됩니다. 랜덤 데이터는 지연 플롯에서 어떤 구조도 나타내지 않아야합니다. 무작위가 아닌 구조는 기본 데이터가 무작위가 아님을 의미합니다. &lt;code&gt;lag&lt;/code&gt; 인수 전달 때 될 수 &lt;code&gt;lag=1&lt;/code&gt; 플롯은 본질적으로 &lt;code&gt;data[:-1]&lt;/code&gt; 대 &lt;code&gt;data[1:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb330b9975008309c55ac6d1f927e11398701830" translate="yes" xml:space="preserve">
          <source>Large Data work flows</source>
          <target state="translated">대용량 데이터 워크 플로우</target>
        </trans-unit>
        <trans-unit id="634993fe47efbc0cc36bc9f423ce21f1437f6e01" translate="yes" xml:space="preserve">
          <source>Large integer values may be converted to dates if &lt;code&gt;convert_dates=True&lt;/code&gt; and the data and / or column labels appear &amp;lsquo;date-like&amp;rsquo;. The exact threshold depends on the &lt;code&gt;date_unit&lt;/code&gt; specified. &amp;lsquo;date-like&amp;rsquo; means that the column label meets one of the following criteria:</source>
          <target state="translated">&lt;code&gt;convert_dates=True&lt;/code&gt; 이고 데이터 및 / 또는 열 레이블이 '날짜와 유사'하게 표시 되면 큰 정수 값이 날짜로 변환 될 수 있습니다 . 정확한 임계 값은 지정된 &lt;code&gt;date_unit&lt;/code&gt; 에 따라 다릅니다 . '날짜 유사'는 열 레이블이 다음 기준 중 하나를 충족 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5e71ec4a409736074fa92c01d7ff1e115cffb023" translate="yes" xml:space="preserve">
          <source>Last, the subsequent example will &lt;strong&gt;not&lt;/strong&gt; work at all, and so should be avoided:</source>
          <target state="translated">마지막으로, 후속 예제는 &lt;strong&gt;전혀&lt;/strong&gt; 작동 &lt;strong&gt;하지 않으므로&lt;/strong&gt; 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="5734d8adec39085a9ea03e2a8333fd2004bda2d5" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth</source>
          <target state="translated">LastWeekOfMonth</target>
        </trans-unit>
        <trans-unit id="9270da2447f02f68eac75f5da4e0d94febbfc294" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.apply()</source>
          <target state="translated">LastWeekOfMonth.apply()</target>
        </trans-unit>
        <trans-unit id="403f7dda41533b1459f015f4fcd05885a0b9d76e" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.apply_index()</source>
          <target state="translated">LastWeekOfMonth.apply_index()</target>
        </trans-unit>
        <trans-unit id="7cbb0fcc4157bff44d2c06f0270546e26574a694" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.base</source>
          <target state="translated">LastWeekOfMonth.base</target>
        </trans-unit>
        <trans-unit id="d87629f579f227cd21db2b812cd740b9344fc95a" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.copy()</source>
          <target state="translated">LastWeekOfMonth.copy()</target>
        </trans-unit>
        <trans-unit id="ea4c4e0c315c9a523196ab488279f3bd637b2ad9" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.freqstr</source>
          <target state="translated">LastWeekOfMonth.freqstr</target>
        </trans-unit>
        <trans-unit id="5588ebc7301a9a344b69d667fa58372c13eee6e5" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.isAnchored()</source>
          <target state="translated">LastWeekOfMonth.isAnchored()</target>
        </trans-unit>
        <trans-unit id="c1d68ef7afdda829cb24caa96687bf568647ab73" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.kwds</source>
          <target state="translated">LastWeekOfMonth.kwds</target>
        </trans-unit>
        <trans-unit id="ecbf85495771797cafcf8425afe5f03490fa3193" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.name</source>
          <target state="translated">LastWeekOfMonth.name</target>
        </trans-unit>
        <trans-unit id="5641a4ff5655ba641edd6cd4cba06a504c1f7f87" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.nanos</source>
          <target state="translated">LastWeekOfMonth.nanos</target>
        </trans-unit>
        <trans-unit id="ab74e77c75a9835627d2ce498af17765a0261509" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.normalize</source>
          <target state="translated">LastWeekOfMonth.normalize</target>
        </trans-unit>
        <trans-unit id="052a4915d5f46fc3f5e2602b40a65fe1a6663ae8" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.onOffset()</source>
          <target state="translated">LastWeekOfMonth.onOffset()</target>
        </trans-unit>
        <trans-unit id="b94d23b499e4ad05e463949edca95b07f5dcb15e" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.rollback()</source>
          <target state="translated">LastWeekOfMonth.rollback()</target>
        </trans-unit>
        <trans-unit id="c6286ffb4b15af95562a86c7c3f9231dfdf7ba5f" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.rollforward()</source>
          <target state="translated">LastWeekOfMonth.rollforward()</target>
        </trans-unit>
        <trans-unit id="4896ddb8d740daf4084a9cc7854c6be1ac7ea08f" translate="yes" xml:space="preserve">
          <source>LastWeekOfMonth.rule_code</source>
          <target state="translated">LastWeekOfMonth.rule_code</target>
        </trans-unit>
        <trans-unit id="5f6cf4d7772c1050ecb59185fbf5bb476b0af56e" translate="yes" xml:space="preserve">
          <source>Lastly, pandas represents null date times, time deltas, and time spans as &lt;code&gt;NaT&lt;/code&gt; which is useful for representing missing or null date like values and behaves similar as &lt;code&gt;np.nan&lt;/code&gt; does for float data.</source>
          <target state="translated">마지막으로 pandas는 null 날짜 시간, 시간 델타 및 시간 범위를 &lt;code&gt;NaT&lt;/code&gt; 로 나타내며 이는 값과 같은 누락 또는 null 날짜를 나타내는 데 유용하며 &lt;code&gt;np.nan&lt;/code&gt; 이 부동 데이터에 대해 수행하는 것과 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="098cc4a9e03125188f95c2aaa1041c7222aab137" translate="yes" xml:space="preserve">
          <source>Lastly, suppose we just wanted to reuse the &lt;em&gt;exact index&lt;/em&gt; from the original DataFrame:</source>
          <target state="translated">마지막으로 원본 DataFrame 의 &lt;em&gt;정확한 색인&lt;/em&gt; 을 재사용하려고한다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="a1470d53cd0e587de15b5c0e410300ec9a790048" translate="yes" xml:space="preserve">
          <source>Lazily iterate over (index, value) tuples.</source>
          <target state="translated">(색인, 값) 튜플을 느리게 반복합니다.</target>
        </trans-unit>
        <trans-unit id="a2e72eca667915ff7dcbe2ce58a594258d23698b" translate="yes" xml:space="preserve">
          <source>Learn Pandas by Hernan Rojas</source>
          <target state="translated">Hernan Rojas의 판다 배우기</target>
        </trans-unit>
        <trans-unit id="cdfc340ad39fd2855ef24a0f41acb376700f8f0b" translate="yes" xml:space="preserve">
          <source>Leave gaps at NaNs</source>
          <target state="translated">NaN에 간격을 두십시오.</target>
        </trans-unit>
        <trans-unit id="f0c67cb65078bc453500166bb2484973cd440118" translate="yes" xml:space="preserve">
          <source>Left and right bounds for each interval.</source>
          <target state="translated">각 간격의 왼쪽 및 오른쪽 경계.</target>
        </trans-unit>
        <trans-unit id="f446f324754ea443ed5aedceda4caa3681e18655" translate="yes" xml:space="preserve">
          <source>Left bound for generating dates.</source>
          <target state="translated">날짜 생성을위한 왼쪽 경계.</target>
        </trans-unit>
        <trans-unit id="4445a93b082d48246a8328be6ee8bbdaeaadc3ce" translate="yes" xml:space="preserve">
          <source>Left bound for generating intervals</source>
          <target state="translated">구간 생성을위한 왼쪽 경계</target>
        </trans-unit>
        <trans-unit id="ef7232e88bf37653f13a804a2acbede39c998c7c" translate="yes" xml:space="preserve">
          <source>Left bound for generating intervals.</source>
          <target state="translated">간격 생성을위한 왼쪽 경계입니다.</target>
        </trans-unit>
        <trans-unit id="bb3727d4161790d0c4678366dbdf0e0518df8bb1" translate="yes" xml:space="preserve">
          <source>Left bound for generating periods</source>
          <target state="translated">기간 생성을위한 왼쪽 경계</target>
        </trans-unit>
        <trans-unit id="f15db5636e769071f728a5118566422f68497553" translate="yes" xml:space="preserve">
          <source>Left bound for generating periods.</source>
          <target state="translated">기간 생성을위한 왼쪽 경계입니다.</target>
        </trans-unit>
        <trans-unit id="bf5be7c8e2b5043b39b7e96073ffed33fe56623c" translate="yes" xml:space="preserve">
          <source>Left bound for generating timedeltas</source>
          <target state="translated">타임 델타 생성을위한 왼쪽 경계</target>
        </trans-unit>
        <trans-unit id="8335098a9079a769b1fb18920e965e459f52e39e" translate="yes" xml:space="preserve">
          <source>Left bound for generating timedeltas.</source>
          <target state="translated">타임 델타 생성을위한 왼쪽 경계입니다.</target>
        </trans-unit>
        <trans-unit id="94a1ee71660016e1013c4038e8c0eeb6a71b6f4c" translate="yes" xml:space="preserve">
          <source>Left bound for the interval</source>
          <target state="translated">간격 동안 왼쪽 경계</target>
        </trans-unit>
        <trans-unit id="7f55d3e90174f52da0d19b1e6ce4938131d7fd0c" translate="yes" xml:space="preserve">
          <source>Left bound for the interval.</source>
          <target state="translated">간격 동안 왼쪽 경계.</target>
        </trans-unit>
        <trans-unit id="4bd7d636cb49e55e44a33ae940154c82eaa879a9" translate="yes" xml:space="preserve">
          <source>Left boundary.</source>
          <target state="translated">왼쪽 경계.</target>
        </trans-unit>
        <trans-unit id="f550d89488d055016186dbca3eb42ac347ed41a0" translate="yes" xml:space="preserve">
          <source>Left bounds for each interval.</source>
          <target state="translated">각 간격의 왼쪽 경계.</target>
        </trans-unit>
        <trans-unit id="272c6c2916524d96d220905b80db9167c07a296f" translate="yes" xml:space="preserve">
          <source>Left edge index</source>
          <target state="translated">왼쪽 가장자리 색인</target>
        </trans-unit>
        <trans-unit id="0f9536b486083c08a5363d9a2d92019c6cde7556" translate="yes" xml:space="preserve">
          <source>Left edge index.</source>
          <target state="translated">왼쪽 가장자리 인덱스.</target>
        </trans-unit>
        <trans-unit id="32183405775ebd721bff29b509a53b88f2f1a381" translate="yes" xml:space="preserve">
          <source>Left index position to use for the slice. If not specified (None), the slice is unbounded on the left, i.e. slice from the start of the string.</source>
          <target state="translated">슬라이스에 사용할 왼쪽 인덱스 위치. 지정하지 않으면 (없음) 슬라이스가 왼쪽에서 바인드 해제됩니다 (예 : 문자열 시작 부분에서 슬라이스).</target>
        </trans-unit>
        <trans-unit id="4e59edd3be5f8fe396c32b6eccef6ec7184cfbf9" translate="yes" xml:space="preserve">
          <source>Length of returned vector is equal to the length of the index.</source>
          <target state="translated">반환 된 벡터의 길이는 인덱스의 길이와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b9111e4ea5522029cf27f4b697c7d0963100203" translate="yes" xml:space="preserve">
          <source>Length of whitespace used to indent each record.</source>
          <target state="translated">각 레코드를 들여 쓰는 데 사용되는 공백의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="98b1784e2bbbe222b04ea571ced9d1ea20ce6922" translate="yes" xml:space="preserve">
          <source>Less efficient:</source>
          <target state="translated">덜 효율적 :</target>
        </trans-unit>
        <trans-unit id="a2aabbda1aad768051850ab31f9429c881554ded" translate="yes" xml:space="preserve">
          <source>Less than of series and other.</source>
          <target state="translated">시리즈와 다른 것보다 적습니다.</target>
        </trans-unit>
        <trans-unit id="83a49c80be1cbd06c318d87dd01d1527be82948f" translate="yes" xml:space="preserve">
          <source>Less wieldy column names are also handled</source>
          <target state="translated">덜 까다로운 열 이름도 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fbff4a7d8501a73cffba7104bdea4495d6acafe3" translate="yes" xml:space="preserve">
          <source>Let us consider some examples:</source>
          <target state="translated">몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6f0928b95284c1cfcd4d8618aff890f47fae6a6c" translate="yes" xml:space="preserve">
          <source>Let us know if you have any difficulties by opening an issue or reaching out on &lt;a href=&quot;https://gitter.im/pydata/pandas&quot;&gt;Gitter&lt;/a&gt;.</source>
          <target state="translated">문제를 열거 나 &lt;a href=&quot;https://gitter.im/pydata/pandas&quot;&gt;Gitter&lt;/a&gt; 에 연락하여 어려움이 있으면 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="3979e37bcb47902217a553d7681ccc29bd64b88a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a variation of the very first example presented:</source>
          <target state="translated">제시된 첫 번째 예제의 변형을 고려해 봅시다.</target>
        </trans-unit>
        <trans-unit id="e23b2d59e2fcd5a198f51a64688d1fd1c56b83cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a Series with a two-level &lt;code&gt;MultiIndex&lt;/code&gt;.</source>
          <target state="translated">2 단계 &lt;code&gt;MultiIndex&lt;/code&gt; 를 사용하여 Series를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4c67217b24d3f9f991ce7ccb0b97f362e0b2bee4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s map to the weekday names:</source>
          <target state="translated">평일 이름에 매핑 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c29d28327ebb7e0d4de057d151a7b3ad078980c6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s repeat the same example, but specifying colors for each column (in this case, for each animal).</source>
          <target state="translated">같은 예를 반복하되 각 열 (이 경우 각 동물)에 색상을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f7f86c0d225e25157bce799efb51b891355c2fee" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how to draw a scatter plot using coordinates from the values in a DataFrame&amp;rsquo;s columns.</source>
          <target state="translated">DataFrame 열의 값에서 좌표를 사용하여 산점도를 그리는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9948d618f8aa7df6b7264b60348519ab0d12b147" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see some examples.</source>
          <target state="translated">몇 가지 예를 봅시다.</target>
        </trans-unit>
        <trans-unit id="ae2ef1b6ad1699d737218a224f0d82d3c3c2f840" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a simple style function that will color negative numbers red and positive numbers black.</source>
          <target state="translated">음수는 빨간색과 양수는 검은 색으로 표시되는 간단한 스타일 함수를 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="8d1514f31f9f4ce966ea914a0f73995808118f93" translate="yes" xml:space="preserve">
          <source>Level codes are an array if integer which are the positions of the real values in the categories array.</source>
          <target state="translated">레벨 코드는 카테고리 배열에서 실제 값의 위치 인 정수인 경우 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7154eea8edd8af4f8792bce8e3dec89c2d311ffa" translate="yes" xml:space="preserve">
          <source>Level of index to be swapped. Can pass level name as string.</source>
          <target state="translated">교환 될 인덱스 레벨. 레벨 이름을 문자열로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e43866cc9550fa180e21691e288aa5cb21d242" translate="yes" xml:space="preserve">
          <source>Level of sortedness (must be lexicographically sorted by that level).</source>
          <target state="translated">정렬 수준 (사 전적으로 해당 수준별로 정렬해야 함)</target>
        </trans-unit>
        <trans-unit id="d21790600e480b7bf1be1c3d4fb415fb14d80642" translate="yes" xml:space="preserve">
          <source>Level of the indices to be swapped. Can pass level name as string.</source>
          <target state="translated">스왑 할 인덱스의 수준입니다. 레벨 이름을 문자열로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06980b49f3fae40fab33fdf8badad7d335907616" translate="yes" xml:space="preserve">
          <source>Level(s) of index to unstack, can pass level name</source>
          <target state="translated">언 스택 할 인덱스 레벨, 레벨 이름 전달 가능</target>
        </trans-unit>
        <trans-unit id="76dad9c9f9d42ffe577080ab25d6fa58a9c00043" translate="yes" xml:space="preserve">
          <source>Level(s) of index to unstack, can pass level name.</source>
          <target state="translated">스택 해제 할 인덱스 레벨, 레벨 이름을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db03e806ee4c0652b4e4fa3bd418e9a5a21ab62c" translate="yes" xml:space="preserve">
          <source>Level(s) to set (None for all levels).</source>
          <target state="translated">설정할 레벨 (모든 레벨에 대해 없음).</target>
        </trans-unit>
        <trans-unit id="b38f523f5cb34d36d4eb7c216816f9e93d36aa44" translate="yes" xml:space="preserve">
          <source>Level(s) to stack from the column axis onto the index axis, defined as one index or label, or a list of indices or labels.</source>
          <target state="translated">열 축에서 인덱스 축으로 스택 할 수준으로, 하나의 인덱스 또는 레이블 또는 인덱스 또는 레이블 목록으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="be8aaa4012a1990994221f6bf524cb886018bd62" translate="yes" xml:space="preserve">
          <source>Level(s) to unstack, can pass level name.</source>
          <target state="translated">언 스택 할 레벨은 레벨 이름을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="6a6c29740f0e5a9b5e7bfe525ae26e12a71787b8" translate="yes" xml:space="preserve">
          <source>Levels of the indices to be swapped. Can pass level name as string.</source>
          <target state="translated">스왑 할 인덱스의 수준입니다. 레벨 이름을 문자열로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b5330f6c863bdd13ed163d81b643b9bd353979" translate="yes" xml:space="preserve">
          <source>Libraries can define a custom array and data type. When pandas encounters these objects, they will be handled properly (i.e. not converted to an ndarray of objects). Many methods like &lt;a href=&quot;../reference/api/pandas.isna#pandas.isna&quot;&gt;&lt;code&gt;pandas.isna()&lt;/code&gt;&lt;/a&gt; will dispatch to the extension type&amp;rsquo;s implementation.</source>
          <target state="translated">라이브러리는 사용자 정의 배열 및 데이터 유형을 정의 할 수 있습니다. 팬더가 이러한 객체를 만나면 올바르게 처리됩니다 (즉, 객체의 ndarray로 변환되지 않음). &lt;a href=&quot;../reference/api/pandas.isna#pandas.isna&quot;&gt; &lt;code&gt;pandas.isna()&lt;/code&gt; &lt;/a&gt; 와 같은 많은 메소드 는 확장 유형의 구현으로 디스패치합니다.</target>
        </trans-unit>
        <trans-unit id="d40d8fab3048b5d17db7d043730115bf3e2eace1" translate="yes" xml:space="preserve">
          <source>Libraries can use the decorators &lt;a href=&quot;../reference/api/pandas.api.extensions.register_dataframe_accessor#pandas.api.extensions.register_dataframe_accessor&quot;&gt;&lt;code&gt;pandas.api.extensions.register_dataframe_accessor()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.api.extensions.register_series_accessor#pandas.api.extensions.register_series_accessor&quot;&gt;&lt;code&gt;pandas.api.extensions.register_series_accessor()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/api/pandas.api.extensions.register_index_accessor#pandas.api.extensions.register_index_accessor&quot;&gt;&lt;code&gt;pandas.api.extensions.register_index_accessor()&lt;/code&gt;&lt;/a&gt;, to add additional &amp;ldquo;namespaces&amp;rdquo; to pandas objects. All of these follow a similar convention: you decorate a class, providing the name of attribute to add. The class&amp;rsquo;s &lt;code&gt;__init__&lt;/code&gt; method gets the object being decorated. For example:</source>
          <target state="translated">라이브러리는 데코레이터 &lt;a href=&quot;../reference/api/pandas.api.extensions.register_dataframe_accessor#pandas.api.extensions.register_dataframe_accessor&quot;&gt; &lt;code&gt;pandas.api.extensions.register_dataframe_accessor()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.api.extensions.register_series_accessor#pandas.api.extensions.register_series_accessor&quot;&gt; &lt;code&gt;pandas.api.extensions.register_series_accessor()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/api/pandas.api.extensions.register_index_accessor#pandas.api.extensions.register_index_accessor&quot;&gt; &lt;code&gt;pandas.api.extensions.register_index_accessor()&lt;/code&gt; &lt;/a&gt; 를 사용하여 팬더 객체에 추가&amp;ldquo;네임 스페이스&amp;rdquo;를 추가 할 수 있습니다. 이들 모두 비슷한 규칙을 따릅니다. 클래스를 장식하고 추가 할 속성 이름을 제공합니다. 클래스의 &lt;code&gt;__init__&lt;/code&gt; 메소드는 장식중인 객체를 가져옵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8100f5ba8bd048a7cf11d116fbbd73130c3c6f5" translate="yes" xml:space="preserve">
          <source>Library</source>
          <target state="translated">Library</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="538c09161b8497f998404cafc34964ed3a445575" translate="yes" xml:space="preserve">
          <source>Licensed under the 3-clause BSD License.</source>
          <target state="translated">3 절 BSD 라이센스에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="4a9eaf345db8e86f88302f41de98e9c23f4293ed" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;DataFrame.pipe()&lt;/code&gt;, this method can simplify the application of several user-defined functions to a styler. Instead of writing:</source>
          <target state="translated">&lt;code&gt;DataFrame.pipe()&lt;/code&gt; 와 마찬가지로이 메소드는 여러 사용자 정의 함수를 스타일러에 적용하는 것을 단순화 할 수 있습니다. 글을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="d8ea994b3c31137e734903a5767a48832f2e3f48" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;PROC IMPORT&lt;/code&gt;, &lt;code&gt;read_csv&lt;/code&gt; can take a number of parameters to specify how the data should be parsed. For example, if the data was instead tab delimited, and did not have column names, the pandas command would be:</source>
          <target state="translated">마찬가지로 &lt;code&gt;PROC IMPORT&lt;/code&gt; , &lt;code&gt;read_csv&lt;/code&gt; 은 데이터를 구문 분석하는 방법을 지정하는 매개 변수의 숫자를 취할 수 있습니다. 예를 들어, 데이터가 탭으로 구분되고 열 이름이없는 경우 pandas 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1defc62afbb2d7875f6102565027ebaacacfac8" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;cov&lt;/code&gt;, &lt;code&gt;corr&lt;/code&gt; also supports the optional &lt;code&gt;min_periods&lt;/code&gt; keyword:</source>
          <target state="translated">마찬가지로 &lt;code&gt;cov&lt;/code&gt; , &lt;code&gt;corr&lt;/code&gt; 선택 사양 인 지원 &lt;code&gt;min_periods&lt;/code&gt; 가 키워드 :</target>
        </trans-unit>
        <trans-unit id="99afd092c4c4d91f996c298831aaa2c351b5a90e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;import delimited&lt;/code&gt;, &lt;a href=&quot;../../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt; can take a number of parameters to specify how the data should be parsed. For example, if the data were instead tab delimited, did not have column names, and existed in the current working directory, the pandas command would be:</source>
          <target state="translated">마찬가지로 &lt;code&gt;import delimited&lt;/code&gt; , &lt;a href=&quot;../../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt; 데이터를 구문 분석하는 방법을 지정하는 매개 변수의 숫자를 취할 수 있습니다. 예를 들어, 데이터가 탭으로 구분되고 열 이름이없고 현재 작업 디렉토리에 존재하는 경우 pandas 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cadb2a4d1609f5827133becf173fa04c47f9aa39" translate="yes" xml:space="preserve">
          <source>Like SAS, pandas provides utilities for reading in data from many formats. The &lt;code&gt;tips&lt;/code&gt; dataset, found within the pandas tests (&lt;a href=&quot;https://raw.github.com/pandas-dev/pandas/master/pandas/tests/data/tips.csv&quot;&gt;csv&lt;/a&gt;) will be used in many of the following examples.</source>
          <target state="translated">SAS와 마찬가지로 pandas는 다양한 형식의 데이터를 읽을 수있는 유틸리티를 제공합니다. 팬더 테스트 ( &lt;a href=&quot;https://raw.github.com/pandas-dev/pandas/master/pandas/tests/data/tips.csv&quot;&gt;csv&lt;/a&gt; ) 내에서 발견 되는 &lt;code&gt;tips&lt;/code&gt; 데이터 세트 는 다음 예에서 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d786f1888f60f0a1dbb055919a0b92d55082860" translate="yes" xml:space="preserve">
          <source>Like Series.map, NA values can be ignored:</source>
          <target state="translated">Series.map과 마찬가지로 NA 값은 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2c5f398c380d97ef0da4ae53b87eea08b937eb6" translate="yes" xml:space="preserve">
          <source>Like Stata, pandas provides utilities for reading in data from many formats. The &lt;code&gt;tips&lt;/code&gt; data set, found within the pandas tests (&lt;a href=&quot;https://raw.github.com/pandas-dev/pandas/master/pandas/tests/data/tips.csv&quot;&gt;csv&lt;/a&gt;) will be used in many of the following examples.</source>
          <target state="translated">Stata와 마찬가지로 pandas는 다양한 형식의 데이터를 읽을 수있는 유틸리티를 제공합니다. &lt;code&gt;tips&lt;/code&gt; 팬더 시험 (세트 내에있는 데이터, &lt;a href=&quot;https://raw.github.com/pandas-dev/pandas/master/pandas/tests/data/tips.csv&quot;&gt;CSV는&lt;/a&gt; ) 이하의 실시 예 대부분에서 이용된다.</target>
        </trans-unit>
        <trans-unit id="1abca33317bb8275ae2539cf7a683a71fcc98327" translate="yes" xml:space="preserve">
          <source>Like a NumPy array, a pandas Series has a &lt;a href=&quot;../reference/api/pandas.series.dtype#pandas.Series.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 배열과 마찬가지로 pandas 시리즈에는 &lt;a href=&quot;../reference/api/pandas.series.dtype#pandas.Series.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; 이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a050b34e1a8643615a34fa0e19c6c8ed0f51b8d1" translate="yes" xml:space="preserve">
          <source>Like assert_series_equal, but targets DataFrames.</source>
          <target state="translated">assert_series_equal과 비슷하지만 DataFrame을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="d4cfdb22d89be47598a2d6e8307a12d2192dc24e" translate="yes" xml:space="preserve">
          <source>Like its sibling function on ndarrays, &lt;code&gt;numpy.concatenate&lt;/code&gt;, &lt;code&gt;pandas.concat&lt;/code&gt; takes a list or dict of homogeneously-typed objects and concatenates them with some configurable handling of &amp;ldquo;what to do with the other axes&amp;rdquo;:</source>
          <target state="translated">ndarrays에 그 형제 기능과 마찬가지로, &lt;code&gt;numpy.concatenate&lt;/code&gt; 는 , &lt;code&gt;pandas.concat&lt;/code&gt; 는 균일 형식의 개체 목록 또는 DICT를 받아 &quot;다른 축으로 무엇을 수행하는&quot;일부 설정 처리로를 연결합니다 :</target>
        </trans-unit>
        <trans-unit id="5d9e9b7939451456ec497e8ee98bec7e0fca2055" translate="yes" xml:space="preserve">
          <source>Like many packages, &lt;em&gt;pandas&lt;/em&gt; uses &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; and the convenient extensions in &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/routines.testing.html&quot;&gt;numpy.testing&lt;/a&gt;.</source>
          <target state="translated">많은 패키지와 마찬가지로 &lt;em&gt;팬더&lt;/em&gt; 는 &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; 및 numpy.testing 의 편리한 확장을 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/reference/routines.testing.html&quot;&gt;사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="85e24442504aa9b7793cbf180502252cc7ef558b" translate="yes" xml:space="preserve">
          <source>Like other pandas fill methods, &lt;a href=&quot;../reference/api/pandas.dataframe.interpolate#pandas.DataFrame.interpolate&quot;&gt;&lt;code&gt;interpolate()&lt;/code&gt;&lt;/a&gt; accepts a &lt;code&gt;limit&lt;/code&gt; keyword argument. Use this argument to limit the number of consecutive &lt;code&gt;NaN&lt;/code&gt; values filled since the last valid observation:</source>
          <target state="translated">다른 팬더 채우기 메서드와 마찬가지로 &lt;a href=&quot;../reference/api/pandas.dataframe.interpolate#pandas.DataFrame.interpolate&quot;&gt; &lt;code&gt;interpolate()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;limit&lt;/code&gt; 키워드 인수를 허용합니다 . 마지막 유효한 관찰 이후로 채워지 는 연속 &lt;code&gt;NaN&lt;/code&gt; 값 의 수를 제한하려면이 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3939952ffe3e359679dca7e22107cd3f476af37" translate="yes" xml:space="preserve">
          <source>Like other parts of the library, pandas will automatically align labeled inputs as part of a ufunc with multiple inputs. For example, using &lt;code&gt;numpy.remainder()&lt;/code&gt; on two &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; with differently ordered labels will align before the operation.</source>
          <target state="translated">라이브러리의 다른 부분과 마찬가지로 Pandas는 레이블이 지정된 입력을 여러 입력이있는 ufunc의 일부로 자동 정렬합니다. 예를 들어, 순서가 다른 두 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 에 &lt;code&gt;numpy.remainder()&lt;/code&gt; 를 사용 하면 작업 전에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="bf55d787d79b52b4bc5319dd4cb5b14feb2dbfd2" translate="yes" xml:space="preserve">
          <source>Likewise, datetime containers will always use &lt;code&gt;NaT&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 datetime 컨테이너는 항상 &lt;code&gt;NaT&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="4f0a2161dfea1b1befdc507778c2c2269cb2fa30" translate="yes" xml:space="preserve">
          <source>Limit number of splits in output. &lt;code&gt;None&lt;/code&gt;, 0 and -1 will be interpreted as return all splits.</source>
          <target state="translated">출력 분할 수를 제한합니다. &lt;code&gt;None&lt;/code&gt; , 0 및 -1은 모든 스플릿을 반환하는 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="41dcc2fd18df07ad4358d2d7b13696c3d2d323e9" translate="yes" xml:space="preserve">
          <source>Limit of how many consecutive missing values to fill.</source>
          <target state="translated">채울 연속 결 측값 수의 한계.</target>
        </trans-unit>
        <trans-unit id="c9f5e7eed157d31ab5cf08de75cd7b58cd10c155" translate="yes" xml:space="preserve">
          <source>Limit of how many values to fill.</source>
          <target state="translated">채울 값 수의 한계.</target>
        </trans-unit>
        <trans-unit id="c96e889f5cc76fc0414793332ea09256976d9e4e" translate="yes" xml:space="preserve">
          <source>Limit the number of upsampled values imputed by the nearest:</source>
          <target state="translated">가장 가까운 것으로 계산 된 업 샘플링 된 값의 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="384b5b3eb5625c5d506ef477b7fa428a44e459d0" translate="yes" xml:space="preserve">
          <source>Limits on filling while reindexing</source>
          <target state="translated">재색 인화 중 채우기 제한</target>
        </trans-unit>
        <trans-unit id="ea9676003762818513c636984faeaa0ae356839a" translate="yes" xml:space="preserve">
          <source>Line</source>
          <target state="translated">Line</target>
        </trans-unit>
        <trans-unit id="c9bbdf8484dd4f7c0eb66ed7ca5b28883b9b4994" translate="yes" xml:space="preserve">
          <source>Line (stacked)</source>
          <target state="translated">라인 (스택)</target>
        </trans-unit>
        <trans-unit id="65621fc000cdcfbf4371faa9957ade0165afa710" translate="yes" xml:space="preserve">
          <source>Line delimited json</source>
          <target state="translated">줄로 구분 된 JSON</target>
        </trans-unit>
        <trans-unit id="5cd0f3bb2b4d802866af2ab823db6715d2c959c1" translate="yes" xml:space="preserve">
          <source>Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file.</source>
          <target state="translated">파일 시작시 건너 뛸 행 번호 (0 색인) 또는 건너 뛸 행 수 (int)입니다.</target>
        </trans-unit>
        <trans-unit id="790b685667ebc398404f175b0c718e23ed76aa9b" translate="yes" xml:space="preserve">
          <source>Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file. If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise. An example of a valid callable argument would be &lt;code&gt;lambda
x: x in [0, 2]&lt;/code&gt;.</source>
          <target state="translated">건너 뛸 줄 번호 (0- 인덱싱) 또는 파일 시작 부분에서 건너 뛸 줄 수 (int). 호출 가능한 경우 호출 가능한 함수는 행 인덱스에 대해 평가되며 행을 건너 뛰어야하는 경우 True를 반환하고 그렇지 않으면 False를 반환합니다. 유효한 호출 가능 인수의 예는 &lt;code&gt;lambda x: x in [0, 2]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="746d2ca58e15f19755368cca88af3d6f2f76678a" translate="yes" xml:space="preserve">
          <source>Lines with too many fields (e.g. a csv line with too many commas) will by default cause an exception to be raised, and no &lt;code&gt;DataFrame&lt;/code&gt; will be returned. If &lt;code&gt;False&lt;/code&gt;, then these &amp;ldquo;bad lines&amp;rdquo; will dropped from the &lt;code&gt;DataFrame&lt;/code&gt; that is returned. See &lt;a href=&quot;#io-bad-lines&quot;&gt;bad lines&lt;/a&gt; below.</source>
          <target state="translated">필드가 너무 많은 줄 (예 : 쉼표가 너무 많은 csv 줄)은 기본적으로 예외가 발생하고 &lt;code&gt;DataFrame&lt;/code&gt; 이 반환 되지 않습니다 . 경우 &lt;code&gt;False&lt;/code&gt; , 다음이 &quot;나쁜 라인&quot;은에서 제외됩니다 &lt;code&gt;DataFrame&lt;/code&gt; 반환됩니다. 아래의 &lt;a href=&quot;#io-bad-lines&quot;&gt;잘못된 줄을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2735e2f0b65f13fe368da1a952ac9f3d73537734" translate="yes" xml:space="preserve">
          <source>Lines with too many fields (e.g. a csv line with too many commas) will by default cause an exception to be raised, and no DataFrame will be returned. If False, then these &amp;ldquo;bad lines&amp;rdquo; will dropped from the DataFrame that is returned.</source>
          <target state="translated">필드가 너무 많은 행 (예 : 쉼표가 너무 많은 csv 행)은 기본적으로 예외가 발생하고 DataFrame이 반환되지 않습니다. False이면 이러한 &quot;나쁜 라인&quot;이 반환 된 DataFrame에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="593ca12c3dd199ce0ff86b80b5904476c47d2ae4" translate="yes" xml:space="preserve">
          <source>Linux :</source>
          <target state="translated">Linux :</target>
        </trans-unit>
        <trans-unit id="4f29f9da0620164df8b6a3b66e6b6749e879f8a1" translate="yes" xml:space="preserve">
          <source>Linux : &lt;code&gt;xclip&lt;/code&gt;, or &lt;code&gt;xsel&lt;/code&gt; (with &lt;code&gt;PyQt4&lt;/code&gt; modules)</source>
          <target state="translated">Linux : &lt;code&gt;xclip&lt;/code&gt; 또는 &lt;code&gt;xsel&lt;/code&gt; ( &lt;code&gt;PyQt4&lt;/code&gt; 모듈 사용)</target>
        </trans-unit>
        <trans-unit id="9fa6ec7958490a9301cfc1ff8c1f5c9f109e5d85" translate="yes" xml:space="preserve">
          <source>List comprehensions and the &lt;code&gt;map&lt;/code&gt; method of Series can also be used to produce more complex criteria:</source>
          <target state="translated">목록 이해와 Series &lt;code&gt;map&lt;/code&gt; 방법을 사용하여 더 복잡한 기준을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c517cd0c5ddf2237ec89017580280db415b95c35" translate="yes" xml:space="preserve">
          <source>List of ABSOLUTE path-names (e.g. have the leading &amp;lsquo;/&amp;rsquo;).</source>
          <target state="translated">ABSOLUTE 경로 이름 목록 (예 : 앞에 '/'가 있음).</target>
        </trans-unit>
        <trans-unit id="bbc37dda0623f999de3ec722821cc5271251f228" translate="yes" xml:space="preserve">
          <source>List of BigQuery column names in the desired order for results DataFrame.</source>
          <target state="translated">결과 DataFrame에 대해 원하는 순서로 BigQuery 열 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="dde678695c3accba4cb10a45f8f1cb2839de2263" translate="yes" xml:space="preserve">
          <source>List of BigQuery table fields to which according DataFrame columns conform to, e.g. &lt;code&gt;[{'name': 'col1', 'type':
'STRING'},...]&lt;/code&gt;. If schema is not provided, it will be generated according to dtypes of DataFrame columns. See BigQuery API documentation on available names of a field.</source>
          <target state="translated">DataFrame 열을 따라되는 BigQuery에 테이블 필드 목록 준수에, 예를 들어, &lt;code&gt;[{'name': 'col1', 'type': 'STRING'},...]&lt;/code&gt; . 스키마가 제공되지 않으면 DataFrame 열의 dtype에 따라 생성됩니다. 사용 가능한 필드 이름에 대한 BigQuery API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="edb5fe51b903e7cd08d9307f06690ae2c676059f" translate="yes" xml:space="preserve">
          <source>List of Term (or convertible) objects, optional.</source>
          <target state="translated">용어 (또는 변환 가능) 개체 목록, 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7c55687d8fb058fed55e6bacd45c1a678aacd4d9" translate="yes" xml:space="preserve">
          <source>List of column names to convert to string columns to Stata StrL format. Only available if version is 117. Storing strings in the StrL format can produce smaller dta files if strings have more than 8 characters and values are repeated.</source>
          <target state="translated">문자열 열을 Stata StrL 형식으로 변환 할 열 이름 목록입니다. 버전이 117 인 경우에만 사용 가능합니다. StrL 형식으로 문자열을 저장하면 문자열에 8 자 이상이 있고 값이 반복되는 경우 더 작은 dta 파일이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c67fa53c6c2fddf9b272b8284d5c123b582c4b" translate="yes" xml:space="preserve">
          <source>List of column names to parse as dates.</source>
          <target state="translated">날짜로 구문 분석 할 열 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fb132c853ee51a23b80702370baa336fcfd0c459" translate="yes" xml:space="preserve">
          <source>List of column names to select from SQL table (only used when reading a table).</source>
          <target state="translated">SQL 테이블에서 선택할 열 이름 목록 (테이블을 읽을 때만 사용됨)</target>
        </trans-unit>
        <trans-unit id="b427d6bbda9602a9597a14786d295aa0c20835e0" translate="yes" xml:space="preserve">
          <source>List of column names to select from SQL table.</source>
          <target state="translated">SQL 테이블에서 선택할 열 이름 목록.</target>
        </trans-unit>
        <trans-unit id="03c204a9d52930190bcf9c11308fb3e06b63eadd" translate="yes" xml:space="preserve">
          <source>List of column names to use. If file contains no header row, then you should explicitly pass &lt;code&gt;header=None&lt;/code&gt;. Duplicates in this list are not allowed.</source>
          <target state="translated">사용할 열 이름 목록. 파일에 헤더 행이 없으면 명시 적으로 &lt;code&gt;header=None&lt;/code&gt; 을 전달해야합니다 . 이 목록의 중복은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e93dd20018bba43b647c17e84433099317b42f2" translate="yes" xml:space="preserve">
          <source>List of column names to use. If file contains no header row, then you should explicitly pass header=None.</source>
          <target state="translated">사용할 열 이름 목록. 파일에 헤더 행이 없으면 명시 적으로 header = None을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="cd7e54afe855c4b9f4ec7143fec1c2da4ad7503a" translate="yes" xml:space="preserve">
          <source>List of column names to use. If the file contains a header row, then you should explicitly pass &lt;code&gt;header=0&lt;/code&gt; to override the column names. Duplicates in this list are not allowed.</source>
          <target state="translated">사용할 열 이름 목록입니다. 파일에 헤더 행이 포함 된 경우 &lt;code&gt;header=0&lt;/code&gt; 을 명시 적으로 전달 하여 열 이름을 재정의해야합니다. 이 목록의 중복은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b9f2e1c3b49e51dae2a9554da76c6e227534bc9" translate="yes" xml:space="preserve">
          <source>List of columns to create as data columns, or True to use all columns. See &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#query-via-data-columns&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">데이터 열로 만들 열 목록 또는 모든 열을 사용하려면 True입니다. 를 참조하십시오 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#query-via-data-columns&quot;&gt;여기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00fcd6eb4bb84bfcee61ba65220ace635e52239a" translate="yes" xml:space="preserve">
          <source>List of columns to create as indexed data columns for on-disk queries, or True to use all columns. By default only the axes of the object are indexed. See &lt;a href=&quot;../../user_guide/io#io-hdf5-query-data-columns&quot;&gt;Query via data columns&lt;/a&gt;. Applicable only to format=&amp;rsquo;table&amp;rsquo;.</source>
          <target state="translated">온 디스크 쿼리에 대해 인덱스 된 데이터 열로 만들 열 목록 또는 모든 열을 사용하려면 True입니다. 기본적으로 개체의 축만 인덱싱됩니다. &lt;a href=&quot;../../user_guide/io#io-hdf5-query-data-columns&quot;&gt;데이터 열을 통한 쿼리를&lt;/a&gt; 참조하십시오 . format = 'table'에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="06a7ca198b84c4057ce4fd41a57e4016a998207b" translate="yes" xml:space="preserve">
          <source>List of columns to create as indexed data columns for on-disk queries, or True to use all columns. By default only the axes of the object are indexed. See &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#query-via-data-columns&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">온 디스크 쿼리에 대해 인덱스 된 데이터 열로 만들 열 목록 또는 모든 열을 사용하려면 True입니다. 기본적으로 개체의 축만 인덱싱됩니다. &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#query-via-data-columns&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c773df14bc18636388545caf84d25f6b502ca4f8" translate="yes" xml:space="preserve">
          <source>List of columns to create as indexed data columns for on-disk queries, or True to use all columns. By default only the axes of the object are indexed. See &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#query-via-data-columns&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">온 디스크 쿼리에 대해 인덱싱 된 데이터 열로 만들 열 목록 또는 모든 열을 사용하려면 True입니다. 기본적으로 객체의 축만 인덱싱됩니다. 를 참조하십시오 &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#query-via-data-columns&quot;&gt;여기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3b57c3dc8fc931f40098f72e1b308716ff57631" translate="yes" xml:space="preserve">
          <source>List of columns to parse for dates. If True, then try to parse datelike columns. A column label is datelike if</source>
          <target state="translated">날짜를 구문 분석 할 열 목록입니다. True이면 날짜와 같은 열을 구문 분석하십시오. 열 레이블은 날짜와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a6c22cace0516463001431de8a56fd35ec1de57f" translate="yes" xml:space="preserve">
          <source>List of duplicated indexes.</source>
          <target state="translated">중복 된 인덱스 목록.</target>
        </trans-unit>
        <trans-unit id="ff42f851d224c877a9a4e1bb1472e06d7605bb66" translate="yes" xml:space="preserve">
          <source>List of indices.</source>
          <target state="translated">지수 목록.</target>
        </trans-unit>
        <trans-unit id="81ec3bcfa311adcc640bd2b76cd66999d1dd692a" translate="yes" xml:space="preserve">
          <source>List of labels. Note using &lt;code&gt;[[]]&lt;/code&gt; returns a DataFrame.</source>
          <target state="translated">라벨 목록. &lt;code&gt;[[]]&lt;/code&gt; 를 사용 하면 DataFrame이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdafc5c4a9bc1e52cdf40eecbbf935c1457058e" translate="yes" xml:space="preserve">
          <source>List of objects.</source>
          <target state="translated">개체 목록.</target>
        </trans-unit>
        <trans-unit id="b0c8ae43e2f0a8c928122a3adc0bcd6802147406" translate="yes" xml:space="preserve">
          <source>List of parameters to pass to execute method. The syntax used to pass parameters is database driver dependent. Check your database driver documentation for which of the five syntax styles, described in PEP 249&amp;rsquo;s paramstyle, is supported. Eg. for psycopg2, uses %(name)s so use params={&amp;lsquo;name&amp;rsquo; : &amp;lsquo;value&amp;rsquo;}</source>
          <target state="translated">메소드를 실행하기 위해 전달할 매개 변수 목록입니다. 매개 변수를 전달하는 데 사용되는 구문은 데이터베이스 드라이버에 따라 다릅니다. PEP 249의 paramstyle에 설명 된 5 가지 구문 스타일 중 지원되는 데이터베이스 드라이버 문서를 확인하십시오. 예 : psycopg2의 경우 % (name)을 사용하므로 params = { 'name': 'value'}를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd4420c26069521c591311cbfde8e546e7d36c63" translate="yes" xml:space="preserve">
          <source>List of parameters to pass to execute method. The syntax used to pass parameters is database driver dependent. Check your database driver documentation for which of the five syntax styles, described in PEP 249&amp;rsquo;s paramstyle, is supported. Eg. for psycopg2, uses %(name)s so use params={&amp;lsquo;name&amp;rsquo; : &amp;lsquo;value&amp;rsquo;}.</source>
          <target state="translated">메소드를 실행하기 위해 전달할 매개 변수 목록입니다. 매개 변수를 전달하는 데 사용되는 구문은 데이터베이스 드라이버에 따라 다릅니다. PEP 249의 paramstyle에 설명 된 5 가지 구문 스타일 중 어떤 것이 지원되는지 데이터베이스 드라이버 설명서를 확인하십시오. 예 : psycopg2의 경우 % (name) s를 사용하므로 params = { 'name': 'value'}를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9564b21ad2c7acf8d949df21a05690d4fe4c426" translate="yes" xml:space="preserve">
          <source>List of style functions.</source>
          <target state="translated">스타일 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="490da488d4c44e79b006b4325a79bfd51ff323d9" translate="yes" xml:space="preserve">
          <source>List of {selector: (attr, value)} dicts; see Notes.</source>
          <target state="translated">{selector : (attr, value)} 사전 목록; 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59c158f1678194bf35298c8eefc4b475e044d405" translate="yes" xml:space="preserve">
          <source>List representing new level order. Reference level by number (position) or by key (label).</source>
          <target state="translated">새로운 레벨 순서를 나타내는 목록. 숫자 (위치) 또는 키 (라벨) 별 기준 레벨.</target>
        </trans-unit>
        <trans-unit id="01b4c9f8196324c7f81ad70722455cc2d32edd87" translate="yes" xml:space="preserve">
          <source>List/array of dates to exclude from the set of valid business days, passed to &lt;code&gt;numpy.busdaycalendar&lt;/code&gt;.</source>
          <target state="translated">유효한 영업일 세트에서 제외 할 날짜 목록 / 배열이며 &lt;code&gt;numpy.busdaycalendar&lt;/code&gt; 에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d940c35ee767ff7efb070890d377081210a6a28" translate="yes" xml:space="preserve">
          <source>Literal &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; expressions</source>
          <target state="translated">리터럴 &lt;code&gt;dict&lt;/code&gt; 및 식 &lt;code&gt;set&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb84ab8dd130506078543a15edf0f34385a62c73" translate="yes" xml:space="preserve">
          <source>Load a CSV file into a DataFrame.</source>
          <target state="translated">CSV 파일을 DataFrame에로드하십시오.</target>
        </trans-unit>
        <trans-unit id="13992891783bd18afe8b716115882c1b9c4ad5c8" translate="yes" xml:space="preserve">
          <source>Load a feather-format object from the file path.</source>
          <target state="translated">파일 경로에서 페더 형식 개체를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="fc98eda68d0d39d61eda4e11da20b8a2f18b6007" translate="yes" xml:space="preserve">
          <source>Load a parquet object from the file path, returning a DataFrame.</source>
          <target state="translated">파일 경로에서 쪽모이 세공 객체를로드하고 DataFrame을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f04966e05efa2f08fa0b6dae8894188c52348fca" translate="yes" xml:space="preserve">
          <source>Load a parquet object, returning a DataFrame.</source>
          <target state="translated">쪽 모음 객체를로드하여 DataFrame을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="edffabd5de6da1738b99cf9763cb6b45b92f312a" translate="yes" xml:space="preserve">
          <source>Load an ORC object from the file path, returning a DataFrame.</source>
          <target state="translated">파일 경로에서 ORC 개체를로드하여 DataFrame을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69621193b200ad3eb0f06a1946f149532f1eb5a7" translate="yes" xml:space="preserve">
          <source>Load an SPSS file from the file path, returning a DataFrame.</source>
          <target state="translated">파일 경로에서 SPSS 파일을로드하여 DataFrame을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf9ead5fe556b964d1272c16d5a06fb26507c893" translate="yes" xml:space="preserve">
          <source>Load data from Google BigQuery.</source>
          <target state="translated">Google BigQuery에서 데이터를로드합니다.</target>
        </trans-unit>
        <trans-unit id="77bca3c3b38a490b888b424846a7e89e8956b6d9" translate="yes" xml:space="preserve">
          <source>Load less data</source>
          <target state="translated">적은 데이터로드</target>
        </trans-unit>
        <trans-unit id="f07acf9f204c5f6a330e54a951b57556327270b2" translate="yes" xml:space="preserve">
          <source>Load msgpack pandas object from the specified file path.</source>
          <target state="translated">지정된 파일 경로에서 msgpack pandas 오브젝트를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="1b93c924c47fa818820e255a4bfb2e78cf78ebb6" translate="yes" xml:space="preserve">
          <source>Load pickled pandas object (or any object) from file.</source>
          <target state="translated">파일에서 절인 팬더 객체 (또는 모든 객체)를로드합니다.</target>
        </trans-unit>
        <trans-unit id="5a2410f88b68f00104e635cd0a75031342199c33" translate="yes" xml:space="preserve">
          <source>Loading pickled data received from untrusted sources can be unsafe.</source>
          <target state="translated">신뢰할 수없는 출처에서받은 절인 데이터를로드하는 것은 안전하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75625df061596d3920c9c39f679af068cf05fef7" translate="yes" xml:space="preserve">
          <source>Loading pickled data received from untrusted sources can be unsafe. See &lt;a href=&quot;https://docs.python.org/3/library/pickle.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">신뢰할 수없는 출처에서받은 절인 데이터를로드하는 것은 안전하지 않을 수 있습니다. &lt;a href=&quot;https://docs.python.org/3/library/pickle.html&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b265a63cc95e7f71d856c34a6711394c7a6bd3f4" translate="yes" xml:space="preserve">
          <source>Local application/library specific imports</source>
          <target state="translated">로컬 애플리케이션 / 라이브러리 특정 가져 오기</target>
        </trans-unit>
        <trans-unit id="72dccf01d2822e02fcc5909d5688faca92ab38d0" translate="yes" xml:space="preserve">
          <source>Local clipboard</source>
          <target state="translated">로컬 클립 보드</target>
        </trans-unit>
        <trans-unit id="573faf18825a085ecfb3336ef224bcc2ae1d82cf" translate="yes" xml:space="preserve">
          <source>Local variables</source>
          <target state="translated">지역 변수</target>
        </trans-unit>
        <trans-unit id="87adaaf1b7684da0ba34d59bcf28d64d0f50ab50" translate="yes" xml:space="preserve">
          <source>Locale determining the language in which to return the day name.</source>
          <target state="translated">요일 이름을 반환 할 언어를 결정하는 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="bedf43902ca4162cb840274437622e0d6bcf6237" translate="yes" xml:space="preserve">
          <source>Locale determining the language in which to return the day name. Default is English locale.</source>
          <target state="translated">요일 이름을 반환 할 언어를 결정하는 로캘입니다. 기본값은 영어 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="9d74d5599256964c0be62bc8eedb16acb3527035" translate="yes" xml:space="preserve">
          <source>Locale determining the language in which to return the month name.</source>
          <target state="translated">월 이름을 반환 할 언어를 결정하는 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="ba41d1597c5be6bf923475989beaec85e164c449" translate="yes" xml:space="preserve">
          <source>Locale determining the language in which to return the month name. Default is English locale.</source>
          <target state="translated">월 이름을 반환 할 언어를 결정하는 로캘입니다. 기본값은 영어 로캘입니다.</target>
        </trans-unit>
        <trans-unit id="73b793f3c64332c43debe3f45fccfa2080cec4a8" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s abbreviated month name.</source>
          <target state="translated">로케일의 약식 월 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c9afac89d2e328ab0ed56be9db5cfa0260851bff" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s abbreviated weekday name.</source>
          <target state="translated">로케일의 약식 요일 이름.</target>
        </trans-unit>
        <trans-unit id="46905c93036f1fc91beab4f6536669f4aa997a97" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s appropriate date and time representation.</source>
          <target state="translated">로케일의 적절한 날짜 및 시간 표현</target>
        </trans-unit>
        <trans-unit id="13dd4044599b17dfb922c37d1bc883f07809d332" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s appropriate date representation.</source>
          <target state="translated">로케일의 적절한 날짜 표현.</target>
        </trans-unit>
        <trans-unit id="36487e73126def0235c7c9de6ec2356b44418976" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s appropriate time representation.</source>
          <target state="translated">로케일의 적절한 시간 표현.</target>
        </trans-unit>
        <trans-unit id="f2fefc48256fa82bb994918d97f4d1273ceaaa82" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s equivalent of either AM or PM.</source>
          <target state="translated">로케일은 AM 또는 PM에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="6fd390382c5edc4503dc946a153a0cfc7197d046" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s full month name.</source>
          <target state="translated">로캘의 전체 월 이름입니다.</target>
        </trans-unit>
        <trans-unit id="07ec6fcd65ab62d1a5fc3d4b40fc1f0d429bee74" translate="yes" xml:space="preserve">
          <source>Locale&amp;rsquo;s full weekday name.</source>
          <target state="translated">로케일의 전체 요일 이름.</target>
        </trans-unit>
        <trans-unit id="3813ae033ccf32018cf51dde5963f65226ad853e" translate="yes" xml:space="preserve">
          <source>Localization of nonexistent times will raise an error by default.</source>
          <target state="translated">존재하지 않는 시간의 현지화는 기본적으로 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c3929ec567919d3ec847eca27be0e62dd4823048" translate="yes" xml:space="preserve">
          <source>Localize DatetimeIndex in US/Eastern time zone:</source>
          <target state="translated">미국 / 동부 표준시로 DatetimeIndex 현지화 :</target>
        </trans-unit>
        <trans-unit id="cbd3d21820c096c7f6342c7d000f3600b60dd30f" translate="yes" xml:space="preserve">
          <source>Localize local times:</source>
          <target state="translated">현지 시간 현지화 :</target>
        </trans-unit>
        <trans-unit id="c01c12fec580fd0ae5983d8fd8c23618c033b693" translate="yes" xml:space="preserve">
          <source>Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index.</source>
          <target state="translated">tz 순진 날짜 시간 배열 / 인덱스를 tz 인식 날짜 시간 배열 / 인덱스로 지역화하십시오.</target>
        </trans-unit>
        <trans-unit id="fb3e8de07a001e83d1584bf642e3b7f5b39caf74" translate="yes" xml:space="preserve">
          <source>Localize tz-naive DatetimeIndex to a given time zone, or remove timezone from a tz-aware DatetimeIndex.</source>
          <target state="translated">tz 순진 DatetimeIndex를 지정된 시간대로 현지화하거나 tz 인식 DatetimeIndex에서 시간대를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e3011dd11bab32bdd0107cb24c5bdaa8446b4000" translate="yes" xml:space="preserve">
          <source>Localize tz-naive index of a Series or DataFrame to target time zone.</source>
          <target state="translated">시간대를 대상으로 Series 또는 DataFrame의 tz 순진 색인을 현지화합니다.</target>
        </trans-unit>
        <trans-unit id="5c6d1d9f75d09ee9cdf6c7dd11b4f9a5369cd9d4" translate="yes" xml:space="preserve">
          <source>Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time.</source>
          <target state="translated">삭제할 항목의 위치입니다. 위치 목록을 사용하여 동시에 둘 이상의 값을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="ef6a9dc9e1a0da653f20e4de4d80cfcb525b32c8" translate="yes" xml:space="preserve">
          <source>Location where the load job should run. See the &lt;a href=&quot;https://cloud.google.com/bigquery/docs/dataset-locations&quot;&gt;BigQuery locations documentation&lt;/a&gt; for a list of available locations. The location must match that of the target dataset.</source>
          <target state="translated">로드 작업을 실행할 위치입니다. 사용 가능한 위치 목록은 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/dataset-locations&quot;&gt;BigQuery 위치 문서&lt;/a&gt; 를 참조하십시오 . 위치는 대상 데이터 세트의 위치와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0f52f86321e0bebd96ceacce69113e297e1d891" translate="yes" xml:space="preserve">
          <source>Location where the query job should run. See the &lt;a href=&quot;https://cloud.google.com/bigquery/docs/dataset-locations&quot;&gt;BigQuery locations documentation&lt;/a&gt; for a list of available locations. The location must match that of any datasets used in the query.</source>
          <target state="translated">쿼리 작업을 실행할 위치입니다. 사용 가능한 위치 목록은 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/dataset-locations&quot;&gt;BigQuery 위치 문서&lt;/a&gt; 를 참조하십시오 . 위치는 쿼리에 사용 된 모든 데이터 세트의 위치와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="189fd1f17597f249dfc1bdb5b480bef4ff0880f6" translate="yes" xml:space="preserve">
          <source>Logical indicating if first day of month (defined by frequency)</source>
          <target state="translated">월의 1 일을 나타내는 논리 (빈도에 의해 정의 됨)</target>
        </trans-unit>
        <trans-unit id="c843d0679ed9030f0e798e11b30fe61ee9d969a6" translate="yes" xml:space="preserve">
          <source>Logical indicating if first day of quarter (defined by frequency)</source>
          <target state="translated">분기의 첫날을 나타내는 논리 (빈도에 의해 정의 됨)</target>
        </trans-unit>
        <trans-unit id="66de0c0d518763168fb48a377b719f70dc48109a" translate="yes" xml:space="preserve">
          <source>Logical indicating if first day of year (defined by frequency)</source>
          <target state="translated">연의 첫날을 나타내는 논리 (빈도에 의해 정의 됨)</target>
        </trans-unit>
        <trans-unit id="30135f00f1cfcdaf43c9f0151f7be24b1b06e641" translate="yes" xml:space="preserve">
          <source>Logical indicating if last day of month (defined by frequency)</source>
          <target state="translated">월의 말일을 나타내는 논리 (빈도에 의해 정의 됨)</target>
        </trans-unit>
        <trans-unit id="f67bc96f1bf1850038ec4b4142e1e5b7a0d50fff" translate="yes" xml:space="preserve">
          <source>Logical indicating if last day of quarter (defined by frequency)</source>
          <target state="translated">분기의 마지막 날을 나타내는 논리 (빈도에 의해 정의 됨)</target>
        </trans-unit>
        <trans-unit id="72d5530eb65ab5579d2001b933faa57a3091c3d4" translate="yes" xml:space="preserve">
          <source>Logical indicating if last day of year (defined by frequency)</source>
          <target state="translated">연도의 마지막 날을 나타내는 논리 (빈도에 의해 정의 됨)</target>
        </trans-unit>
        <trans-unit id="45fbe46d29c9c73b9f156dbad324936633700b83" translate="yes" xml:space="preserve">
          <source>Logical indicating if the date belongs to a leap year</source>
          <target state="translated">날짜가 윤년에 속하는지 여부를 나타내는 논리</target>
        </trans-unit>
        <trans-unit id="8c7e17f8415033aec14c25b2ad88f077fc97a88c" translate="yes" xml:space="preserve">
          <source>Logical indicating if the date belongs to a leap year.</source>
          <target state="translated">날짜가 윤년에 속하는지 여부를 나타내는 논리적입니다.</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">논리적 작업</target>
        </trans-unit>
        <trans-unit id="7509f1d0dbaccb8bfb89dc8e3d05acd95dfcfe48" translate="yes" xml:space="preserve">
          <source>Look for a &lt;em&gt;vectorized&lt;/em&gt; solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, &amp;hellip;</source>
          <target state="translated">&lt;em&gt;벡터화 된&lt;/em&gt; 솔루션을 찾으십시오 . 내장 메서드 또는 NumPy 함수, (부울) 인덱싱을 사용하여 많은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0724af5846b9c4e39e31c0d27a012270ac0033b6" translate="yes" xml:space="preserve">
          <source>Looking up values by index/column labels</source>
          <target state="translated">색인 / 열 레이블로 값 찾기</target>
        </trans-unit>
        <trans-unit id="515bbd1e58f574887fffef456fae09a122bf2727" translate="yes" xml:space="preserve">
          <source>Loops like this would be &lt;em&gt;extremely&lt;/em&gt; slow in Python, but in Cython looping over NumPy arrays is &lt;em&gt;fast&lt;/em&gt;.</source>
          <target state="translated">이와 같은 루프 는 Python에서 &lt;em&gt;매우&lt;/em&gt; 느리지 만 Cython에서는 NumPy 배열을 통한 루프가 &lt;em&gt;빠릅니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cbadcaaf6ba6d204aee48d0a0e73f5233d69e9ad" translate="yes" xml:space="preserve">
          <source>Low-level access to HDF files.</source>
          <target state="translated">HDF 파일에 대한 저수준 액세스.</target>
        </trans-unit>
        <trans-unit id="2f3aa84345665a423ec0df865522e37c834723ea" translate="yes" xml:space="preserve">
          <source>Low-level reader for Stata data files.</source>
          <target state="translated">Stata 데이터 파일을위한 저수준 리더.</target>
        </trans-unit>
        <trans-unit id="b1c16094a41aa0f5f74c08c0e2d136bc4ff4bb65" translate="yes" xml:space="preserve">
          <source>Low-level writer for Stata data files.</source>
          <target state="translated">Stata 데이터 파일 용 저수준 작성기.</target>
        </trans-unit>
        <trans-unit id="d97d8514b543ee86bf986454ef2387af13c3fc9c" translate="yes" xml:space="preserve">
          <source>Low-level writer for version 117 files.</source>
          <target state="translated">버전 117 파일 용 저수준 작성기.</target>
        </trans-unit>
        <trans-unit id="610ff4d66bb1c6eca92b623c6506a9236d410efa" translate="yes" xml:space="preserve">
          <source>Luminance threshold for determining text color. Facilitates text visibility across varying background colors. From 0 to 1. 0 = all text is dark colored, 1 = all text is light colored.</source>
          <target state="translated">텍스트 색상을 결정하기위한 휘도 임계 값입니다. 다양한 배경 색상에서 텍스트 가시성을 용이하게합니다. 0부터 1까지 0 = 모든 텍스트가 어두운 색상, 1 = 모든 텍스트가 밝은 색상입니다.</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="b8a812ac59db64674f090a63169af644e96f3c0d" translate="yes" xml:space="preserve">
          <source>MOEX Data</source>
          <target state="translated">MOEX 데이터</target>
        </trans-unit>
        <trans-unit id="0f249e4e5aa1c61aec7276f8653a07588c89789c" translate="yes" xml:space="preserve">
          <source>MS</source>
          <target state="translated">MS</target>
        </trans-unit>
        <trans-unit id="459a0ec6ebf159c332cee0efc88508fadb84cf9b" translate="yes" xml:space="preserve">
          <source>MS Excel</source>
          <target state="translated">MS 엑셀</target>
        </trans-unit>
        <trans-unit id="2f09b5650d98f41c66f8010e1c633e17b9b924ec" translate="yes" xml:space="preserve">
          <source>Make Matplotlib look like R</source>
          <target state="translated">Matplotlib를 R처럼 보이게 만들기</target>
        </trans-unit>
        <trans-unit id="3cb77df18ef50a2e8cab1a9f5a9fc5833aa2cb02" translate="yes" xml:space="preserve">
          <source>Make a Categorical type from codes and categories or dtype.</source>
          <target state="translated">코드와 범주 또는 dtype에서 범주 유형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="764daf8d9a5851019edc3b7ceb9e99e63bdb7a4b" translate="yes" xml:space="preserve">
          <source>Make a MultiIndex from a DataFrame.</source>
          <target state="translated">DataFrame에서 MultiIndex를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7240de296c27f47ab3d071be9fb3aba24ab7c117" translate="yes" xml:space="preserve">
          <source>Make a MultiIndex from cartesian product of iterables.</source>
          <target state="translated">이터 러블의 데카르트 곱으로 다중 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b03916ef37aea64fd6ea1d199d8cc65435e7475d" translate="yes" xml:space="preserve">
          <source>Make a MultiIndex from the cartesian product of multiple iterables.</source>
          <target state="translated">다중 iterable의 데카르트 곱으로 MultiIndex를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e6f5cabc3606442bef31e4bd40d3cfd66fec88c8" translate="yes" xml:space="preserve">
          <source>Make a bar plot with matplotlib.</source>
          <target state="translated">matplotlib로 막대 플롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e002f32a908c7792fa4d8dc84d8e81c61b865d22" translate="yes" xml:space="preserve">
          <source>Make a box plot from DataFrame columns.</source>
          <target state="translated">DataFrame 열에서 상자 그림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1edda5085c85abc224ea0c8448b25abbe07f2a43" translate="yes" xml:space="preserve">
          <source>Make a box plot of the DataFrame columns.</source>
          <target state="translated">DataFrame 열의 상자 그림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cbbcfe46774ff64f6b04ace0c029723d6d55eafc" translate="yes" xml:space="preserve">
          <source>Make a box-and-whisker plot from DataFrame columns, optionally grouped by some other columns. A box plot is a method for graphically depicting groups of numerical data through their quartiles. The box extends from the Q1 to Q3 quartile values of the data, with a line at the median (Q2). The whiskers extend from the edges of box to show the range of the data. By default, they extend no more than</source>
          <target state="translated">선택적으로 다른 열로 그룹화 된 DataFrame 열에서 상자 및 수염 플롯을 만듭니다. 상자 그림은 사 분위수를 통해 숫자 데이터 그룹을 그래픽으로 묘사하는 방법입니다. 상자는 데이터의 Q1에서 Q3 사 분위수 값까지 확장되며 중앙값 (Q2)에 선이 있습니다. 수염은 상자 가장자리에서 확장되어 데이터 범위를 표시합니다. 기본적으로 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00ef28f45ef01017894a1ea1aece5c8b18a16735" translate="yes" xml:space="preserve">
          <source>Make a box-and-whisker plot from DataFrame columns, optionally grouped by some other columns. A box plot is a method for graphically depicting groups of numerical data through their quartiles. The box extends from the Q1 to Q3 quartile values of the data, with a line at the median (Q2). The whiskers extend from the edges of box to show the range of the data. The position of the whiskers is set by default to &lt;code&gt;1.5 * IQR (IQR = Q3 - Q1)&lt;/code&gt; from the edges of the box. Outlier points are those past the end of the whiskers.</source>
          <target state="translated">선택적으로 다른 열로 그룹화되어 DataFrame 열에서 상자와 수염 그림을 만듭니다. 상자 그림은 사 분위수를 통해 숫자 데이터 그룹을 그래픽으로 표시하는 방법입니다. 상자는 데이터의 Q1에서 Q3 사 분위수 값까지 연장되며 중앙값 (Q2)에 선이 있습니다. 수염은 상자의 가장자리에서 연장되어 데이터의 범위를 보여줍니다. 수염의 위치는 기본적으로 상자 가장자리에서 &lt;code&gt;1.5 * IQR (IQR = Q3 - Q1)&lt;/code&gt; 됩니다. 특이점은 수염의 끝을 지난 점입니다.</target>
        </trans-unit>
        <trans-unit id="52abb21400eda82f13a4c6f2b2c2b2e8d243f815" translate="yes" xml:space="preserve">
          <source>Make a copy of input ndarray</source>
          <target state="translated">입력 ndarray의 사본을 만드십시오</target>
        </trans-unit>
        <trans-unit id="775a3bec904a387798a898e804fc0394d96d77d3" translate="yes" xml:space="preserve">
          <source>Make a copy of input ndarray.</source>
          <target state="translated">입력 ndarray의 사본을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="27e13f202379190aff5ad22e04e642c18a09f342" translate="yes" xml:space="preserve">
          <source>Make a copy of this object&amp;rsquo;s indices and data.</source>
          <target state="translated">이 개체의 인덱스와 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="763ae4a8a7aa823a9f3fa26d309f57a675e60322" translate="yes" xml:space="preserve">
          <source>Make a copy of this object.</source>
          <target state="translated">이 개체를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="eeec3b35b074f97c5675091c6065be0ab25338cd" translate="yes" xml:space="preserve">
          <source>Make a copy of this object. Name and dtype sets those attributes on the new object.</source>
          <target state="translated">이 개체를 복사하십시오. 이름 및 dtype은 새 객체에서 해당 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7c48bd342906d999dcc0057044b146f1b4d4e30e" translate="yes" xml:space="preserve">
          <source>Make a deep copy, including a copy of the data and the indices. With &lt;code&gt;deep=False&lt;/code&gt; neither the indices nor the data are copied.</source>
          <target state="translated">데이터 및 색인 사본을 포함하여 심층 사본을 작성하십시오. &lt;code&gt;deep=False&lt;/code&gt; 를 사용 하면 인덱스 나 데이터가 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e00e4c5f7833c8d641e93cef27426a0bce9e6f3" translate="yes" xml:space="preserve">
          <source>Make a histogram of the DataFrame&amp;rsquo;s.</source>
          <target state="translated">DataFrame 히스토그램을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9d4ab9be67e2cb0e5f66d527b5e3e2d3d1bab32c" translate="yes" xml:space="preserve">
          <source>Make a histogram.</source>
          <target state="translated">히스토그램을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f301da3dd0b191ab853eb367fe0430b17cc1635e" translate="yes" xml:space="preserve">
          <source>Make a horizontal bar plot.</source>
          <target state="translated">가로 막대 플롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="50bb78886ee862878c346b7663fa03b743bbd930" translate="yes" xml:space="preserve">
          <source>Make box plots from DataFrameGroupBy data.</source>
          <target state="translated">DataFrameGroupBy 데이터에서 상자 그림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7f938108147f9e42ef5ef20109c54632949a6ad8" translate="yes" xml:space="preserve">
          <source>Make it &lt;strong&gt;easy to convert&lt;/strong&gt; ragged, differently-indexed data in other Python and NumPy data structures into DataFrame objects</source>
          <target state="translated">다른 Python 및 NumPy 데이터 구조의 비정형, 다르게 인덱스 된 데이터를 DataFrame 객체 &lt;strong&gt;로 쉽게 변환&lt;/strong&gt; 할 &lt;strong&gt;수 있도록&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2741349f960382c92ba4dd0f537d4712defd7cec" translate="yes" xml:space="preserve">
          <source>Make new Index inserting new item at location.</source>
          <target state="translated">새 인덱스를 위치에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="2b6b026ce83ce59b76e0a5ede9f0339c2e22346c" translate="yes" xml:space="preserve">
          <source>Make new Index with passed list of labels deleted.</source>
          <target state="translated">전달 된 레이블 목록이있는 새 색인을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="691df04a7be6abcefa85c95315030fc9ca8514a7" translate="yes" xml:space="preserve">
          <source>Make new Index with passed location(-s) deleted.</source>
          <target state="translated">전달 된 위치 (-s)가있는 새 색인을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="c25f905a40d43fb7c7182723691f7d0f04a2cb09" translate="yes" xml:space="preserve">
          <source>Make plots of DataFrame using matplotlib / pylab.</source>
          <target state="translated">matplotlib / pylab을 사용하여 DataFrame의 플롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7afc6d8048c5d98180314522501819892b5e8136" translate="yes" xml:space="preserve">
          <source>Make plots of DataFrame using matplotlib.</source>
          <target state="translated">matplotlib을 사용하여 DataFrame의 플롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b6cb38c611ec1a4b29b2b6eb04e1d558248780da" translate="yes" xml:space="preserve">
          <source>Make plots of Series or DataFrame.</source>
          <target state="translated">Series 또는 DataFrame의 플롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="40da5a84bf16428fb85fe7e515947de7945d7238" translate="yes" xml:space="preserve">
          <source>Make plots of a DataFrame.</source>
          <target state="translated">DataFrame의 플롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="34ce1b287e3b8f9d087228f1d6a71f7d42d1238f" translate="yes" xml:space="preserve">
          <source>Make separate subplots for each column.</source>
          <target state="translated">각 열에 대해 별도의 서브 플롯을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="be2d579dc2d38ffc1791d8a72e92589f458ecae3" translate="yes" xml:space="preserve">
          <source>Make sure that you have &lt;a href=&quot;#contributing-forking&quot;&gt;cloned the repository&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#contributing-forking&quot;&gt;저장소를 복제&lt;/a&gt; 했는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="a4d39f6a3ada43ed41567c12d60224ac68ee701a" translate="yes" xml:space="preserve">
          <source>Make sure you use a lower-case &lt;code&gt;-d&lt;/code&gt;, or else git won&amp;rsquo;t warn you if your feature branch has not actually been merged.</source>
          <target state="translated">소문자 &lt;code&gt;-d&lt;/code&gt; 를 사용하십시오. 그렇지 않으면 기능 분기가 실제로 병합되지 않은 경우 git에서 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ed544a1c884b2389e8a7f53326c3a35e5ec8124" translate="yes" xml:space="preserve">
          <source>Make sure your conda is up to date (&lt;code&gt;conda update conda&lt;/code&gt;)</source>
          <target state="translated">콘 다가 최신인지 확인하십시오 ( &lt;code&gt;conda update conda&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b43bb0e8f75d35631a6e779a8a36c42c44205ba7" translate="yes" xml:space="preserve">
          <source>Make the interval closed on the &amp;lsquo;right&amp;rsquo;, &amp;lsquo;left&amp;rsquo;, &amp;lsquo;both&amp;rsquo; or &amp;lsquo;neither&amp;rsquo; endpoints. Defaults to &amp;lsquo;right&amp;rsquo;.</source>
          <target state="translated">'오른쪽', '왼쪽', '둘 다'또는 '둘 다 아님'끝점에서 간격을 닫으십시오. 기본값은 '오른쪽'입니다.</target>
        </trans-unit>
        <trans-unit id="27e2c593efc25f1feed4c1504c08c82402153d5e" translate="yes" xml:space="preserve">
          <source>Make the interval closed on the &amp;lsquo;right&amp;rsquo;, &amp;lsquo;left&amp;rsquo;, &amp;lsquo;both&amp;rsquo; or &amp;lsquo;neither&amp;rsquo; endpoints. For offset-based windows, it defaults to &amp;lsquo;right&amp;rsquo;. For fixed windows, defaults to &amp;lsquo;both&amp;rsquo;. Remaining cases not implemented for fixed windows.</source>
          <target state="translated">'오른쪽', '왼쪽', '둘 다'또는 '아무도'엔드 포인트에서 간격을 닫으십시오. 오프셋 기반 윈도우의 경우 기본값은 '오른쪽'입니다. 고정 된 창의 경우 기본값은 'both'입니다. 고정 된 창에 대해서는 나머지 사례가 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="93a4f9f2b2274804f0a126eddda2e27b2bf68967" translate="yes" xml:space="preserve">
          <source>Make the interval closed with respect to the given frequency to the &amp;lsquo;left&amp;rsquo;, &amp;lsquo;right&amp;rsquo;, or both sides (None)</source>
          <target state="translated">주어진 주파수와 관련하여 '왼쪽', '오른쪽'또는 양쪽에 간격을 닫습니다 (없음).</target>
        </trans-unit>
        <trans-unit id="44d1913bb002919604b78317a13c3c73b8965ac7" translate="yes" xml:space="preserve">
          <source>Make the interval closed with respect to the given frequency to the &amp;lsquo;left&amp;rsquo;, &amp;lsquo;right&amp;rsquo;, or both sides (None).</source>
          <target state="translated">주어진 주파수와 관련하여 '왼쪽', '오른쪽'또는 양쪽에 간격을 닫습니다 (없음).</target>
        </trans-unit>
        <trans-unit id="adc3f741208653c69e9d6b1c6da34a4bc5ac84ba" translate="yes" xml:space="preserve">
          <source>Make the interval closed with respect to the given frequency to the &amp;lsquo;left&amp;rsquo;, &amp;lsquo;right&amp;rsquo;, or both sides (None, the default).</source>
          <target state="translated">주어진 주파수와 관련하여 '왼쪽', '오른쪽'또는 양쪽에 간격을 닫습니다 (기본값은 없음).</target>
        </trans-unit>
        <trans-unit id="b1ea41d8b0fe30644222c4b91746b1e6b0449e38" translate="yes" xml:space="preserve">
          <source>Make the row labels bold in the output.</source>
          <target state="translated">출력에서 행 레이블을 굵게 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="87958213720eac9603b861cff4b359aabed947cc" translate="yes" xml:space="preserve">
          <source>Managing heterogeneous data using a linked multiple table hierarchy</source>
          <target state="translated">연결된 다중 테이블 계층을 사용하여 이기종 데이터 관리</target>
        </trans-unit>
        <trans-unit id="eea63d25b415667952399f44dbc3545dc469a106" translate="yes" xml:space="preserve">
          <source>Manipulating and converting date times with timezone information</source>
          <target state="translated">시간대 정보를 사용하여 날짜 시간 조작 및 변환</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="b651298c7b8138ae81a7819de085cb6d0f3031f6" translate="yes" xml:space="preserve">
          <source>Manually chunking is an OK option for workflows that don&amp;rsquo;t require too sophisticated of operations. Some operations, like &lt;code&gt;groupby&lt;/code&gt;, are much harder to do chunkwise. In these cases, you may be better switching to a different library that implements these out-of-core algorithms for you.</source>
          <target state="translated">수동 청킹은 너무 복잡한 작업이 필요하지 않은 워크 플로에 적합한 옵션입니다. &lt;code&gt;groupby&lt;/code&gt; 와 같은 일부 작업 은 청크 단위로 수행하기가 훨씬 더 어렵습니다. 이러한 경우에는 이러한 out-of-core 알고리즘을 구현하는 다른 라이브러리로 전환하는 것이 더 나을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d72250d07b01c2aa825c6968a3fcb6f3af7fbb7" translate="yes" xml:space="preserve">
          <source>Many kinds of complicated data manipulations can be expressed in terms of GroupBy operations (though can&amp;rsquo;t be guaranteed to be the most efficient). You can get quite creative with the label mapping functions.</source>
          <target state="translated">많은 종류의 복잡한 데이터 조작을 GroupBy 작업으로 표현할 수 있습니다 (가장 효율적이라고 보장 할 수는 없음). 라벨 매핑 기능을 사용하면 상당히 창의적인 결과를 얻을 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="1edbd39b7836a0ac2bd498ee95282b3be0cb7cb4" translate="yes" xml:space="preserve">
          <source>Many of these principles are here to address the shortcomings frequently experienced using other languages / scientific research environments. For data scientists, working with data is typically divided into multiple stages: munging and cleaning data, analyzing / modeling it, then organizing the results of the analysis into a form suitable for plotting or tabular display. pandas is the ideal tool for all of these tasks.</source>
          <target state="translated">이러한 원칙 중 많은 부분이 다른 언어 / 과학 연구 환경에서 자주 경험하는 단점을 해결하기 위해 여기에 있습니다. 데이터 과학자의 경우 데이터 작업은 일반적으로 여러 단계로 나뉩니다. 데이터를 정리하고 정리하고, 분석 / 모델링 한 다음 분석 결과를 플로팅 또는 테이블 표시에 적합한 형식으로 구성합니다. 팬더는 이러한 모든 작업에 이상적인 도구입니다.</target>
        </trans-unit>
        <trans-unit id="80f69fabddf0abec62aa0ce5a113241069aa0e16" translate="yes" xml:space="preserve">
          <source>Many people have suggested that NumPy should simply emulate the &lt;code&gt;NA&lt;/code&gt; support present in the more domain-specific statistical programming language &lt;a href=&quot;https://r-project.org&quot;&gt;R&lt;/a&gt;. Part of the reason is the NumPy type hierarchy:</source>
          <target state="translated">많은 사람들이 NumPy가 더 많은 도메인 별 통계 프로그래밍 언어 &lt;a href=&quot;https://r-project.org&quot;&gt;R에&lt;/a&gt; 있는 &lt;code&gt;NA&lt;/code&gt; 지원을 단순히 에뮬레이트해야한다고 제안했습니다 . 그 이유 중 일부는 NumPy 유형 계층입니다.</target>
        </trans-unit>
        <trans-unit id="d57acf70da5cc61b2277e74c007004475e04fb46" translate="yes" xml:space="preserve">
          <source>Many workflows involve a large amount of data and processing it in a way that reduces the size to something that fits in memory. In this case, we&amp;rsquo;ll resample to daily frequency and take the mean. Once we&amp;rsquo;ve taken the mean, we know the results will fit in memory, so we can safely call &lt;code&gt;compute&lt;/code&gt; without running out of memory. At that point it&amp;rsquo;s just a regular pandas object.</source>
          <target state="translated">많은 워크 플로는 많은 양의 데이터를 포함하고 메모리에 맞는 크기로 크기를 줄이는 방식으로 처리합니다. 이 경우 일일 빈도로 다시 샘플링하고 평균을 취합니다. 평균을 취하면 결과가 메모리에 적합하므로 메모리 부족 없이 안전하게 &lt;code&gt;compute&lt;/code&gt; 를 호출 할 수 있습니다 . 그 시점에서 그것은 단지 일반 pandas 객체입니다.</target>
        </trans-unit>
        <trans-unit id="802c18a1cf0c44f734082ef97e3c673abf8fa5fb" translate="yes" xml:space="preserve">
          <source>Map all characters in the string through the given mapping table.</source>
          <target state="translated">주어진 맵핑 테이블을 통해 문자열의 모든 문자를 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="bd4b7c75bbd0319321fddb2ef6076406d9936674" translate="yes" xml:space="preserve">
          <source>Map all characters in the string through the given mapping table. Equivalent to standard &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.translate&quot;&gt;&lt;code&gt;str.translate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 맵핑 테이블을 통해 문자열의 모든 문자를 맵핑하십시오. 표준 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.translate&quot;&gt; &lt;code&gt;str.translate()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0d9e47d52aa4abe16a1659682eb822ded1d1421e" translate="yes" xml:space="preserve">
          <source>Map column names to minimum string sizes for columns.</source>
          <target state="translated">열 이름을 열의 최소 문자열 크기에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="786b1ebb50e5d5006cb007533ecaa8b5920c4e6f" translate="yes" xml:space="preserve">
          <source>Map values of Series according to input correspondence.</source>
          <target state="translated">입력 대응에 따른 Series의 맵 값.</target>
        </trans-unit>
        <trans-unit id="86439a8fa1612920b5b5a0fe98e7fba1f2cc3ed7" translate="yes" xml:space="preserve">
          <source>Map values using input correspondence (a dict, Series, or function).</source>
          <target state="translated">입력 대응 (dict, Series 또는 함수)을 사용하여 값을 맵핑하십시오.</target>
        </trans-unit>
        <trans-unit id="77bd2ad3d849345d18408522edfdfe17449329a3" translate="yes" xml:space="preserve">
          <source>Mapped index.</source>
          <target state="translated">매핑 된 인덱스.</target>
        </trans-unit>
        <trans-unit id="da3c937b48929eec61dc0bf7e2c26b0d8391269e" translate="yes" xml:space="preserve">
          <source>Mapping correspondence.</source>
          <target state="translated">대응 통신.</target>
        </trans-unit>
        <trans-unit id="fd05a1c6e1dee8e70ace209fe5ea9bc2e7b028db" translate="yes" xml:space="preserve">
          <source>Maps the values (their categories, not the codes) of the index to new categories. If the mapping correspondence is one-to-one the result is a &lt;a href=&quot;pandas.categoricalindex#pandas.CategoricalIndex&quot;&gt;&lt;code&gt;CategoricalIndex&lt;/code&gt;&lt;/a&gt; which has the same order property as the original, otherwise an &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">색인의 값 (코드가 아닌 범주)을 새 범주에 매핑합니다. 매핑 대응 관계가 일대일이면 결과는 원본과 동일한 order 속성을 가진 &lt;a href=&quot;pandas.categoricalindex#pandas.CategoricalIndex&quot;&gt; &lt;code&gt;CategoricalIndex&lt;/code&gt; &lt;/a&gt; 이며 그렇지 않으면 &lt;a href=&quot;pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8aadf1657da58cb6e5ae063fb1322736bf6002e4" translate="yes" xml:space="preserve">
          <source>Mask</source>
          <target state="translated">Mask</target>
        </trans-unit>
        <trans-unit id="1d40e31ac98d463e5e9e157373da4c4bdaf59bf7" translate="yes" xml:space="preserve">
          <source>Mask of bool values for each element in DataFrame that indicates whether an element is an NA value.</source>
          <target state="translated">요소가 NA 값인지 여부를 나타내는 DataFrame의 각 요소에 대한 부울 값 마스크입니다.</target>
        </trans-unit>
        <trans-unit id="3fb2d754cae3572c10e6aac228b71d990a412353" translate="yes" xml:space="preserve">
          <source>Mask of bool values for each element in DataFrame that indicates whether an element is not an NA value.</source>
          <target state="translated">요소가 NA 값이 아닌지 여부를 나타내는 DataFrame의 각 요소에 대한 부울 값의 마스크입니다.</target>
        </trans-unit>
        <trans-unit id="acf74b398a35aa0bf65ff5bc34f520e63631b303" translate="yes" xml:space="preserve">
          <source>Mask of bool values for each element in Series that indicates whether an element is an NA value.</source>
          <target state="translated">요소가 NA 값인지 여부를 나타내는 Series의 각 요소에 대한 부울 값 마스크입니다.</target>
        </trans-unit>
        <trans-unit id="93a9d20a3d0fed432d5098dca9aa3d9d6d587dc2" translate="yes" xml:space="preserve">
          <source>Mask of bool values for each element in Series that indicates whether an element is not an NA value.</source>
          <target state="translated">요소가 NA 값이 아닌지 여부를 나타내는 Series의 각 요소에 대한 부울 값 마스크입니다.</target>
        </trans-unit>
        <trans-unit id="70d1b338d5725d1c22c2eb001ab794dc19d7be20" translate="yes" xml:space="preserve">
          <source>Match on these columns before performing merge operation.</source>
          <target state="translated">병합 작업을 수행하기 전에이 열에서 일치하십시오.</target>
        </trans-unit>
        <trans-unit id="6b27b16a0e6e728c36f9396b9defe894bb1848af" translate="yes" xml:space="preserve">
          <source>Matching / broadcasting behavior</source>
          <target state="translated">매칭 / 방송 행동</target>
        </trans-unit>
        <trans-unit id="4bfe27a493af2dfedc15f7f1ea88b1cf88c1ec5b" translate="yes" xml:space="preserve">
          <source>Matching NaNs will not appear as a difference.</source>
          <target state="translated">일치하는 NaN은 차이로 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="627fb2d6e25a0e2642c928a36f85dac792afc05c" translate="yes" xml:space="preserve">
          <source>Math functions: &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;arcsin&lt;/code&gt;, &lt;code&gt;arccos&lt;/code&gt;, &lt;code&gt;arctan&lt;/code&gt;, &lt;code&gt;arccosh&lt;/code&gt;, &lt;code&gt;arcsinh&lt;/code&gt;, &lt;code&gt;arctanh&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;arctan2&lt;/code&gt; and &lt;code&gt;log10&lt;/code&gt;.</source>
          <target state="translated">수학 함수 : &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt; , &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;expm1&lt;/code&gt; , &lt;code&gt;log1p&lt;/code&gt; , &lt;code&gt;sqrt&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;arcsin&lt;/code&gt; , &lt;code&gt;arccos&lt;/code&gt; , &lt;code&gt;arctan&lt;/code&gt; , &lt;code&gt;arccosh&lt;/code&gt; , &lt;code&gt;arcsinh&lt;/code&gt; , &lt;code&gt;arctanh&lt;/code&gt; , &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;arctan2&lt;/code&gt; 및 &lt;code&gt;log10&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec898e422ec2cb07d53aee0a31d0dcb7e23b229" translate="yes" xml:space="preserve">
          <source>Matplotlib axis object.</source>
          <target state="translated">Matplotlib 축 객체.</target>
        </trans-unit>
        <trans-unit id="6a6f342a7dcdcbb50fd0b28567858e5aeec1e2e0" translate="yes" xml:space="preserve">
          <source>Matplotlib colormap.</source>
          <target state="translated">Matplotlib 컬러 맵.</target>
        </trans-unit>
        <trans-unit id="d4a589efb01782a915792fc9de33faf470381535" translate="yes" xml:space="preserve">
          <source>Matplotlib equivalent plot.</source>
          <target state="translated">Matplotlib 등가 그림.</target>
        </trans-unit>
        <trans-unit id="a55fce45322800818875d0bb4c5eb12a1b4e1360" translate="yes" xml:space="preserve">
          <source>Matplotlib figure.</source>
          <target state="translated">Matplotlib 그림.</target>
        </trans-unit>
        <trans-unit id="f70a4e8005ffff52e713830b3d9775241e2be4a3" translate="yes" xml:space="preserve">
          <source>Matplotlib marker type, default &amp;lsquo;.&amp;rsquo;</source>
          <target state="translated">Matplotlib 마커 유형, 기본 '.'</target>
        </trans-unit>
        <trans-unit id="49d3d16afd72b17ff2e438be476eb66cca91c514" translate="yes" xml:space="preserve">
          <source>Matplotlib marker type, default &amp;lsquo;.&amp;rsquo;.</source>
          <target state="translated">Matplotlib 마커 유형, 기본값은 '.'입니다.</target>
        </trans-unit>
        <trans-unit id="791a6a4924d75e87138709bcf267db7d332396ec" translate="yes" xml:space="preserve">
          <source>Matplotlib scatter method keyword arguments.</source>
          <target state="translated">Matplotlib 분산 메서드 키워드 인수.</target>
        </trans-unit>
        <trans-unit id="c8fc2a0699601253f4189fe6478e36465e556e65" translate="yes" xml:space="preserve">
          <source>Matthew Brett&amp;rsquo;s &lt;a href=&quot;http://matthew-brett.github.com/pydagogue/&quot;&gt;Pydagogue&lt;/a&gt;.</source>
          <target state="translated">마태 복음 브렛의 &lt;a href=&quot;http://matthew-brett.github.com/pydagogue/&quot;&gt;Pydagogue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="223a8ef1456324f63029534180c62625b6187647" translate="yes" xml:space="preserve">
          <source>Max number of levels(depth of dict) to normalize. if None, normalizes all levels.</source>
          <target state="translated">정규화 할 최대 레벨 수 (dict of depth)입니다. None이면 모든 레벨을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="de1e500d79fd449eb3506542b58a0778926d409b" translate="yes" xml:space="preserve">
          <source>Max using level names, as well as indices.</source>
          <target state="translated">레벨 이름과 인덱스를 사용하여 최대 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="fa874811248a2656a7de6e8536358c1ca459ccca" translate="yes" xml:space="preserve">
          <source>Max width to truncate each column in characters. By default, no limit.</source>
          <target state="translated">문자 단위로 각 열을자를 최대 너비입니다. 기본적으로 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8df2fec28d8948a0326722029c7492b88ee4fbe" translate="yes" xml:space="preserve">
          <source>Maximum</source>
          <target state="translated">Maximum</target>
        </trans-unit>
        <trans-unit id="a4f91748cd36b6d1a5c07d5455167920822713f6" translate="yes" xml:space="preserve">
          <source>Maximum bar value, defining the right hand limit of the bar drawing range, higher values are clipped to</source>
          <target state="translated">바 그리기 범위의 오른손 한계를 정의하는 최대 바 값, 더 높은 값은</target>
        </trans-unit>
        <trans-unit id="c62fce6caba6e50a9433e6ff1d33022c5803e693" translate="yes" xml:space="preserve">
          <source>Maximum bar value, defining the right hand limit of the bar drawing range, higher values are clipped to &lt;code&gt;vmax&lt;/code&gt;. When None (default): the maximum value of the data will be used.</source>
          <target state="translated">막대 그리기 범위의 오른쪽 한계를 정의하는 최대 막대 값은 높은 값이 &lt;code&gt;vmax&lt;/code&gt; 로 잘립니다 . None (기본값) : 데이터의 최대 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a336916816ed278f1ba463ae521c573484934861" translate="yes" xml:space="preserve">
          <source>Maximum data value that corresponds to colormap maximum value. When None (default): the maximum value of the data will be used.</source>
          <target state="translated">컬러 맵 최대 값에 해당하는 최대 데이터 값입니다. 없음 (기본값) : 데이터의 최대 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="006aae1f5c2490eb90b0bfffb2ca55b0c27cbbfe" translate="yes" xml:space="preserve">
          <source>Maximum distance between original and new labels for inexact matches. The values of the index at the matching locations most satisfy the equation &lt;code&gt;abs(index[indexer] - target) &amp;lt;= tolerance&lt;/code&gt;.</source>
          <target state="translated">일치하지 않는 원본과 새 레이블 사이의 최대 거리. 일치하는 위치의 지수 값은 방정식 &lt;code&gt;abs(index[indexer] - target) &amp;lt;= tolerance&lt;/code&gt; 가장 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="87b2faf9a9285e370b981fe8b04843567aa1ac4f" translate="yes" xml:space="preserve">
          <source>Maximum distance between original and new labels for inexact matches. The values of the index at the matching locations must satisfy the equation &lt;code&gt;abs(index[indexer] - target) &amp;lt;= tolerance&lt;/code&gt;.</source>
          <target state="translated">정확하지 않은 일치에 대한 원본 레이블과 새 레이블 사이의 최대 거리를 지정합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 일치하는 위치의 인덱스 값은 방정식 &lt;code&gt;abs(index[indexer] - target) &amp;lt;= tolerance&lt;/code&gt; 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6aa08a53c954aef98ce5c6712749dbcf90855b04" translate="yes" xml:space="preserve">
          <source>Maximum distance from index value for inexact matches. The value of the index at the matching location most satisfy the equation &lt;code&gt;abs(index[loc] - key) &amp;lt;= tolerance&lt;/code&gt;.</source>
          <target state="translated">부정확 한 일치에 대한 색인 값과의 최대 거리. 일치하는 위치의 색인 값은 방정식 &lt;code&gt;abs(index[loc] - key) &amp;lt;= tolerance&lt;/code&gt; 가장 충족시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4e14b7c05a3c00b8c680f780fdb19f6a93e3c06e" translate="yes" xml:space="preserve">
          <source>Maximum distance from index value for inexact matches. The value of the index at the matching location must satisfy the equation &lt;code&gt;abs(index[loc] - key) &amp;lt;= tolerance&lt;/code&gt;.</source>
          <target state="translated">정확하지 않은 일치에 대한 인덱스 값과의 최대 거리입니다. 일치하는 위치의 인덱스 값은 방정식 &lt;code&gt;abs(index[loc] - key) &amp;lt;= tolerance&lt;/code&gt; 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="82a9b94d76c868082f5441ac7aefae65f8fb9890" translate="yes" xml:space="preserve">
          <source>Maximum line width.</source>
          <target state="translated">최대 선 너비</target>
        </trans-unit>
        <trans-unit id="5ef946ff338c09c8ee8703cbcf64323ce97b7427" translate="yes" xml:space="preserve">
          <source>Maximum number of columns to display in the console.</source>
          <target state="translated">콘솔에 표시 할 최대 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="9766c3b3b4cf2806a8ff7f9bcc1b6da151af5246" translate="yes" xml:space="preserve">
          <source>Maximum number of consecutive NaNs to fill. Must be greater than 0.</source>
          <target state="translated">채울 최대 연속 NaN 수입니다. 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="f3d2de1edb941d11b55b6b64a93b8bb214242c55" translate="yes" xml:space="preserve">
          <source>Maximum number of consecutive elements to forward or backward fill.</source>
          <target state="translated">앞으로 또는 뒤로 채울 최대 연속 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="eccd51990aa7079ed2e7c9db8f44a6677dd615e9" translate="yes" xml:space="preserve">
          <source>Maximum number of consecutive labels in &lt;code&gt;target&lt;/code&gt; to match for inexact matches.</source>
          <target state="translated">정확하지 않은 일치와 일치하는 &lt;code&gt;target&lt;/code&gt; 의 최대 연속 레이블 수입니다 .</target>
        </trans-unit>
        <trans-unit id="4f8def9e942670802b32d39dee817725b24be970" translate="yes" xml:space="preserve">
          <source>Maximum number of consecutive labels to fill for inexact matches.</source>
          <target state="translated">부정확 한 일치를 위해 채울 최대 연속 레이블 수입니다.</target>
        </trans-unit>
        <trans-unit id="d82bb57c99ebb2c25d9ee4e74b1788b31628c21d" translate="yes" xml:space="preserve">
          <source>Maximum number of rows to display in the console.</source>
          <target state="translated">콘솔에 표시 할 최대 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="418d3bce4b128e946d1d305406f5df081d424e27" translate="yes" xml:space="preserve">
          <source>Maximum number of rows to show before truncating. If None, show all.</source>
          <target state="translated">자르기 전에 표시 할 최대 행 수입니다. 없음 인 경우 모두 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="502b064e66333dfd10e1b396ba227bd2b2a38ba0" translate="yes" xml:space="preserve">
          <source>Maximum of the values in the object.</source>
          <target state="translated">객체의 최대 값.</target>
        </trans-unit>
        <trans-unit id="9738919c60a7925d571911736b422fc6caf6e4d9" translate="yes" xml:space="preserve">
          <source>Maximum size gap to forward or backward fill.</source>
          <target state="translated">앞으로 또는 뒤로 채우기위한 최대 크기 간격.</target>
        </trans-unit>
        <trans-unit id="032e5bd972c9ecfc8dcf78d961ed253e491959eb" translate="yes" xml:space="preserve">
          <source>Maximum size gap when reindexing with &lt;code&gt;fill_method&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fill_method&lt;/code&gt; 로 재색 인화 할 때 최대 크기 간격 .</target>
        </trans-unit>
        <trans-unit id="4f5bb496068a5308705ad8df99b731220915bf60" translate="yes" xml:space="preserve">
          <source>Maximum threshold value. All values above this threshold will be set to it.</source>
          <target state="translated">최대 임계 값. 이 임계 값을 초과하는 모든 값이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bcd3a6f550f9ac8e74b63166554eed081d66bcb9" translate="yes" xml:space="preserve">
          <source>Maximum value allowed. All values above threshold will be set to this value.</source>
          <target state="translated">최대 값이 허용됩니다. 임계 값을 초과하는 모든 값은이 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f40216b2881d06021d975a03d7b5087b46e8a3c1" translate="yes" xml:space="preserve">
          <source>Maximum value.</source>
          <target state="translated">최대 값.</target>
        </trans-unit>
        <trans-unit id="97db58e401ba076427c80f0b61778795760c1c50" translate="yes" xml:space="preserve">
          <source>May not drop or duplicate levels.</source>
          <target state="translated">레벨을 삭제하거나 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b8a07f2c795ff5a90bb5855b481a32d82a6aa31" translate="yes" xml:space="preserve">
          <source>Mean absolute deviation</source>
          <target state="translated">평균 절대 편차</target>
        </trans-unit>
        <trans-unit id="f608a79e9624d729b9ab7850245c5425dcbbb12d" translate="yes" xml:space="preserve">
          <source>Mean of the values.</source>
          <target state="translated">값의 평균</target>
        </trans-unit>
        <trans-unit id="6ca3d4c6016ceebec6e37437b1c8ab754354e9e2" translate="yes" xml:space="preserve">
          <source>Mean of values</source>
          <target state="translated">가치의 평균</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="184a55138e168af7c826df8d3d990f3022559e8e" translate="yes" xml:space="preserve">
          <source>Median of values within each group.</source>
          <target state="translated">각 그룹 내 값의 중앙값.</target>
        </trans-unit>
        <trans-unit id="530f6ddbe6f5cabf01f18a63d450d84bd827f45b" translate="yes" xml:space="preserve">
          <source>Memory usage</source>
          <target state="translated">메모리 사용량</target>
        </trans-unit>
        <trans-unit id="f6604d915cb4701d18878bc8e218fe06061af645" translate="yes" xml:space="preserve">
          <source>Memory usage does not include memory consumed by elements that are not components of the array if deep=False or if used on PyPy</source>
          <target state="translated">메모리 사용량에는 deep = False 또는 PyPy에서 사용되는 경우 배열의 구성 요소가 아닌 요소가 사용하는 메모리는 포함되지 않습니다</target>
        </trans-unit>
        <trans-unit id="9e1639694c6ae0aa57453530525b6e8358dfa718" translate="yes" xml:space="preserve">
          <source>Memory usage of DataFrame columns.</source>
          <target state="translated">DataFrame 열의 메모리 사용량</target>
        </trans-unit>
        <trans-unit id="03b754e55629f3753daf4fb3537cdbdf920272f5" translate="yes" xml:space="preserve">
          <source>Memory usage of the values</source>
          <target state="translated">값의 메모리 사용량</target>
        </trans-unit>
        <trans-unit id="ccf85b6633688a0e938e3f20d9cf6e3e258590c5" translate="yes" xml:space="preserve">
          <source>Memory usage of the values.</source>
          <target state="translated">값의 메모리 사용량.</target>
        </trans-unit>
        <trans-unit id="4d323cbad58202f968b3b89aab283115566d69ee" translate="yes" xml:space="preserve">
          <source>Memory-efficient array for string values with many repeated values.</source>
          <target state="translated">반복되는 값이 많은 문자열 값에 대한 메모리 효율적인 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ea8f0d02371e3267b086392b1f463d0c520d86e5" translate="yes" xml:space="preserve">
          <source>Merge</source>
          <target state="translated">Merge</target>
        </trans-unit>
        <trans-unit id="386f7c51f645d3dfedfffa603ac18b8693cd1568" translate="yes" xml:space="preserve">
          <source>Merge DataFrame or named Series objects with a database-style join.</source>
          <target state="translated">데이터베이스 스타일 조인으로 DataFrame 또는 명명 된 Series 개체를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="5724d0395b1fc76d60acb59b537d2d62ea9a7b26" translate="yes" xml:space="preserve">
          <source>Merge DataFrames by indexes or columns.</source>
          <target state="translated">인덱스 또는 열별로 DataFrames를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="384581d790dc95194440ce6e590b73dcb545fa7b" translate="yes" xml:space="preserve">
          <source>Merge DataFrames df1 and df2 with specified left and right suffixes appended to any overlapping columns.</source>
          <target state="translated">겹치는 열에 추가 된 지정된 왼쪽 및 오른쪽 접미사를 사용하여 DataFrames df1 및 df2를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4db973e14af2a2be8a7014d16d4a61e85905d1" translate="yes" xml:space="preserve">
          <source>Merge DataFrames df1 and df2, but raise an exception if the DataFrames have any overlapping columns.</source>
          <target state="translated">DataFrames df1 및 df2를 병합하지만 DataFrame에 겹치는 열이 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0743992ec8c8a8c51fed841133c86b69e0ef2631" translate="yes" xml:space="preserve">
          <source>Merge df1 and df2 on the lkey and rkey columns. The value columns have the default suffixes, _x and _y, appended.</source>
          <target state="translated">lkey 및 rkey 열에서 df1 및 df2를 병합하십시오. 값 열에는 기본 접미사 _x 및 _y가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="efa1027ff9139afebde7e268acb413c006b7960d" translate="yes" xml:space="preserve">
          <source>Merge dtypes</source>
          <target state="translated">dtypes 병합</target>
        </trans-unit>
        <trans-unit id="0c61d84ec4246f92b0c8e2c1b4302e941be636ec" translate="yes" xml:space="preserve">
          <source>Merge key in both frames</source>
          <target state="translated">두 프레임에서 키 병합</target>
        </trans-unit>
        <trans-unit id="19ef66c4dc7abc9bce739da9dbdf868bd477ae5e" translate="yes" xml:space="preserve">
          <source>Merge key only in &lt;code&gt;'left'&lt;/code&gt; frame</source>
          <target state="translated">&lt;code&gt;'left'&lt;/code&gt; 프레임 에서만 키 병합</target>
        </trans-unit>
        <trans-unit id="0f9fd2d706c7b827951193e1b79d6c4b7e5470dc" translate="yes" xml:space="preserve">
          <source>Merge key only in &lt;code&gt;'right'&lt;/code&gt; frame</source>
          <target state="translated">&lt;code&gt;'right'&lt;/code&gt; 프레임 에서만 키 병합</target>
        </trans-unit>
        <trans-unit id="3ea74de8f1e44b82c73193be8333ca4d215ceb62" translate="yes" xml:space="preserve">
          <source>Merge method</source>
          <target state="translated">병합 방법</target>
        </trans-unit>
        <trans-unit id="a367250fc16c19763cdb4fa5081413360b246894" translate="yes" xml:space="preserve">
          <source>Merge on nearest keys.</source>
          <target state="translated">가장 가까운 키를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="772035b454fddd26d804bedadadfcbd620e81285" translate="yes" xml:space="preserve">
          <source>Merge with a database-style join.</source>
          <target state="translated">데이터베이스 스타일 조인으로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="0db553897f375c607b9a9205c9cd1d0923c893ab" translate="yes" xml:space="preserve">
          <source>Merge with optional filling/interpolation.</source>
          <target state="translated">선택적인 채우기 / 보간으로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="148250eb8dc6b602778210bd80ecb7fb18c8349d" translate="yes" xml:space="preserve">
          <source>Merge, join, and concatenate</source>
          <target state="translated">병합, 가입 및 연결</target>
        </trans-unit>
        <trans-unit id="733249d7ced9c0e8f438dacb170b2af7433958b8" translate="yes" xml:space="preserve">
          <source>Merge, join, concatenate and compare</source>
          <target state="translated">병합, 결합, 연결 및 비교</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="37f47e21de4879b766fb1a3760ecaab311c3e9ae" translate="yes" xml:space="preserve">
          <source>Merging / concatenation</source>
          <target state="translated">병합 / 연결</target>
        </trans-unit>
        <trans-unit id="35577658b8f76759aac9839c682c66625d57cdb6" translate="yes" xml:space="preserve">
          <source>Merging asof</source>
          <target state="translated">asof 병합</target>
        </trans-unit>
        <trans-unit id="05ab5b5d57cfe6fdceb9623c60ffeb3cb9c53d4f" translate="yes" xml:space="preserve">
          <source>Merging on &lt;code&gt;category&lt;/code&gt; dtypes that are the same can be quite performant compared to &lt;code&gt;object&lt;/code&gt; dtype merging.</source>
          <target state="translated">동일한 &lt;code&gt;category&lt;/code&gt; dtype 에 대한 병합은 &lt;code&gt;object&lt;/code&gt; dtype 병합에 비해 상당히 성능이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="88a6fb572bb29131289afd9f312a5cdd13b79729" translate="yes" xml:space="preserve">
          <source>Merging on a combination of columns and index levels</source>
          <target state="translated">열과 인덱스 수준의 조합에서 병합</target>
        </trans-unit>
        <trans-unit id="49ae3f7e4df5822a7d886b3b59e27bf64732f73b" translate="yes" xml:space="preserve">
          <source>Merging on-disk tables with millions of rows</source>
          <target state="translated">수백만 개의 행이있는 온 디스크 테이블 병합</target>
        </trans-unit>
        <trans-unit id="4aa5ec4e75ee6ae3483641389ed3d63d1d23897b" translate="yes" xml:space="preserve">
          <source>Merging ordered data</source>
          <target state="translated">정렬 된 데이터 병합</target>
        </trans-unit>
        <trans-unit id="0e4ad2ab4f8cc99a44c6b9467a45152283c559a6" translate="yes" xml:space="preserve">
          <source>Merging together values within Series or DataFrame columns</source>
          <target state="translated">Series 또는 DataFrame 열 내의 값 병합</target>
        </trans-unit>
        <trans-unit id="36f6b9e7056dcd1dcacf8ec8181535163c630c1b" translate="yes" xml:space="preserve">
          <source>Merging will preserve &lt;code&gt;category&lt;/code&gt; dtypes of the mergands. See also the section on &lt;a href=&quot;categorical#categorical-merge&quot;&gt;categoricals&lt;/a&gt;.</source>
          <target state="translated">병합하면 병합의 &lt;code&gt;category&lt;/code&gt; dtype 이 유지됩니다 . &lt;a href=&quot;categorical#categorical-merge&quot;&gt;범주에&lt;/a&gt; 대한 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="beee22884d2dd3cdc302370458d39c1477c96571" translate="yes" xml:space="preserve">
          <source>Merging will preserve the dtype of the join keys.</source>
          <target state="translated">병합하면 결합 키의 dtype이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="f6ea3d6e8db1f1275b7c92167188d213d4354a5b" translate="yes" xml:space="preserve">
          <source>Method 1 : idxmin() to get the index of the minimums</source>
          <target state="translated">방법 1 : 최소 인덱스를 얻기위한 idxmin ()</target>
        </trans-unit>
        <trans-unit id="44b5b2cd5c0c8cb72f1b6ec2810526395e1c5ac2" translate="yes" xml:space="preserve">
          <source>Method 2 : sort then take first of each</source>
          <target state="translated">방법 2 : 정렬 한 다음 각각을 먼저 수행</target>
        </trans-unit>
        <trans-unit id="5f0337845fa160f43e4c22fbe32ed48ddb937cdf" translate="yes" xml:space="preserve">
          <source>Method Chaining</source>
          <target state="translated">메소드 체인</target>
        </trans-unit>
        <trans-unit id="fba97801dbd397534877202701358e825b978f3f" translate="yes" xml:space="preserve">
          <source>Method for down/re-sampling, default to &amp;lsquo;mean&amp;rsquo; for downsampling.</source>
          <target state="translated">다운 샘플링 / 재 샘플링 방법은 다운 샘플링의 경우 '평균'으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1389e0e832a05337d6ccb31e50ea1425ca91a8" translate="yes" xml:space="preserve">
          <source>Method name</source>
          <target state="translated">방법 이름</target>
        </trans-unit>
        <trans-unit id="11e4621f474169c7fa634b6e49b96100d293fcef" translate="yes" xml:space="preserve">
          <source>Method nunique for DataFrame.</source>
          <target state="translated">DataFrame을위한 메소드</target>
        </trans-unit>
        <trans-unit id="26acbc7971ee21cb50abad4d5e7577e54cb97878" translate="yes" xml:space="preserve">
          <source>Method nunique for Series.</source>
          <target state="translated">시리즈를위한 방법의 기발함.</target>
        </trans-unit>
        <trans-unit id="05279af96a5bf792f0aadabfaad4a2ec4ed97893" translate="yes" xml:space="preserve">
          <source>Method of correlation:</source>
          <target state="translated">상관 방법 :</target>
        </trans-unit>
        <trans-unit id="125eeb1861a9136a8df188c4ff4ea5f674017c8f" translate="yes" xml:space="preserve">
          <source>Method of employing 4-4-5 calendar.</source>
          <target state="translated">4-4-5 캘린더 사용 방법.</target>
        </trans-unit>
        <trans-unit id="add7737487792d2622995353cff35455ea4748c8" translate="yes" xml:space="preserve">
          <source>Method summary</source>
          <target state="translated">방법 요약</target>
        </trans-unit>
        <trans-unit id="29c229ad44ad49f5687badce9845f6b432d95bba" translate="yes" xml:space="preserve">
          <source>Method to handle dropping duplicates:</source>
          <target state="translated">중복 삭제를 처리하는 방법 :</target>
        </trans-unit>
        <trans-unit id="41e0004f4b224262184bb7b7e09950e7b1d0c453" translate="yes" xml:space="preserve">
          <source>Method to set one or more non-data dependent properties or each cell.</source>
          <target state="translated">하나 이상의 비 데이터 종속 속성 또는 각 셀을 설정하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5a9afda44917236543559d1dba017c099ad25057" translate="yes" xml:space="preserve">
          <source>Method to use for filling holes in reindexed DataFrame. Please note: this is only applicable to DataFrames/Series with a monotonically increasing/decreasing index.</source>
          <target state="translated">재 인덱싱 된 DataFrame에서 구멍을 채우는 데 사용하는 방법입니다. 참고 : 이것은 단조 증가 / 감소 인덱스가있는 DataFrames / Series에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="556baf5107d38549c1c7537ba871c91c3685731a" translate="yes" xml:space="preserve">
          <source>Method to use for filling holes in reindexed Series (note this does not fill NaNs that already were present):</source>
          <target state="translated">재 색인 된 시리즈의 구멍을 채우는 데 사용하는 방법 (이미 존재했던 NaN을 채우지는 않습니다) :</target>
        </trans-unit>
        <trans-unit id="8e34984e85a7b732f2df14fc2802b9ee8d02d98f" translate="yes" xml:space="preserve">
          <source>Method to use for filling holes in reindexed Series pad / ffill: propagate last valid observation forward to next valid backfill / bfill: use NEXT valid observation to fill gap</source>
          <target state="translated">재 인덱싱 된 시리즈 패드 / 충진에서 구멍을 채우는 데 사용하는 방법 : 마지막 유효 관측 값을 다음 유효 백필 / bfill으로 전달 : 다음 유효 관측 값을 사용하여 간격을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="cf985bbe10fcb13d023e88ac40adce728dd2a3c8" translate="yes" xml:space="preserve">
          <source>Method to use for filling holes in reindexed Series pad / ffill: propagate last valid observation forward to next valid backfill / bfill: use NEXT valid observation to fill gap.</source>
          <target state="translated">재 색인 된 시리즈 패드 / 채우기에 구멍을 채우는 데 사용하는 방법 : 마지막 유효한 관측치를 다음 유효한 백 필로 전달 / bfill : NEXT 유효한 관측치를 사용하여 간격을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="76d4a60899fea55499fc2efedf9f8c7c91a19e56" translate="yes" xml:space="preserve">
          <source>Method to use for filling holes in reindexed Series pad / ffill: propagate last valid observation forward to next valid backfill / bfill: use next valid observation to fill gap.</source>
          <target state="translated">재 인덱싱 된 시리즈 패드 / 충진에서 구멍을 채우는 데 사용하는 방법 : 마지막 유효 관측 값을 다음 유효 백필 / bfill으로 전달 : 다음 유효 관측 값을 사용하여 간격을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="f7573296e6afe4d877b9cf65f4a3ff35dc6b7710" translate="yes" xml:space="preserve">
          <source>Method to use for filling holes in reindexed Series:</source>
          <target state="translated">재 색인 된 시리즈에서 구멍을 채우는 데 사용하는 방법 :</target>
        </trans-unit>
        <trans-unit id="fb015a6047d4493159ce72f7831ce8eb351e51f0" translate="yes" xml:space="preserve">
          <source>Method to use for filling holes in resampled data</source>
          <target state="translated">재 샘플링 된 데이터의 구멍을 채우는 데 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="034448f41b6bbb7d4ee1b437272cb97bf234f843" translate="yes" xml:space="preserve">
          <source>Method to use when the desired quantile falls between two points.</source>
          <target state="translated">원하는 Quantile이 두 지점 사이에있을 때 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cc5e9a4ff7b6d6fe8221f27a0592c6474fe7aeab" translate="yes" xml:space="preserve">
          <source>Method used to compute correlation:</source>
          <target state="translated">상관 관계를 계산하는 데 사용되는 방법 :</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="983e0e47fb27d7278997e132d6a949bb2392fa45" translate="yes" xml:space="preserve">
          <source>Methods for working with missing data, e.g. &lt;a href=&quot;../reference/api/pandas.series.isna#pandas.Series.isna&quot;&gt;&lt;code&gt;isna()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.series.fillna#pandas.Series.fillna&quot;&gt;&lt;code&gt;fillna()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/api/pandas.series.dropna#pandas.Series.dropna&quot;&gt;&lt;code&gt;dropna()&lt;/code&gt;&lt;/a&gt;, all work normally:</source>
          <target state="translated">누락 된 데이터로 작업하는 방법, 예를 들어 &lt;a href=&quot;../reference/api/pandas.series.isna#pandas.Series.isna&quot;&gt; &lt;code&gt;isna()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.series.fillna#pandas.Series.fillna&quot;&gt; &lt;code&gt;fillna()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/api/pandas.series.dropna#pandas.Series.dropna&quot;&gt; &lt;code&gt;dropna()&lt;/code&gt; &lt;/a&gt; , 모두 정상적으로 작동합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
