<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pandas">
    <body>
      <group id="pandas">
        <trans-unit id="4898687bd28dcd5a9d7e71ae90321ee7a6f62f6e" translate="yes" xml:space="preserve">
          <source>Expanding window functions</source>
          <target state="translated">확장 창 기능</target>
        </trans-unit>
        <trans-unit id="23fe2841f3b5f3b5917d4fcbd59d3f25ae891f70" translate="yes" xml:space="preserve">
          <source>Expanding window: Accumulating window over the values.</source>
          <target state="translated">확장 창 : 값에 대한 누적 창.</target>
        </trans-unit>
        <trans-unit id="3a233e0339daf951dd297e72928414cfcc4f0f89" translate="yes" xml:space="preserve">
          <source>Expanding windows</source>
          <target state="translated">창 확장</target>
        </trans-unit>
        <trans-unit id="368af8e049410c8a7c94fbc184fbe2bfd5d462ef" translate="yes" xml:space="preserve">
          <source>Expanding.aggregate()</source>
          <target state="translated">Expanding.aggregate()</target>
        </trans-unit>
        <trans-unit id="43990b7ac8295d9269441df7b987f2d4d9b51923" translate="yes" xml:space="preserve">
          <source>Expanding.apply()</source>
          <target state="translated">Expanding.apply()</target>
        </trans-unit>
        <trans-unit id="4aee228837e363f06ecdd823126896ab0f489900" translate="yes" xml:space="preserve">
          <source>Expanding.corr()</source>
          <target state="translated">Expanding.corr()</target>
        </trans-unit>
        <trans-unit id="f4c56bd97a231d06792666c339793e451f8f9d15" translate="yes" xml:space="preserve">
          <source>Expanding.count()</source>
          <target state="translated">Expanding.count()</target>
        </trans-unit>
        <trans-unit id="f168d9ba8aeeaa26b8563691d9e9982d1b6af7ff" translate="yes" xml:space="preserve">
          <source>Expanding.cov()</source>
          <target state="translated">Expanding.cov()</target>
        </trans-unit>
        <trans-unit id="130aaa27cb652cb66c8524d57f9ee84fecafb68c" translate="yes" xml:space="preserve">
          <source>Expanding.kurt()</source>
          <target state="translated">Expanding.kurt()</target>
        </trans-unit>
        <trans-unit id="0ee90d9629a55a6beb5827afc2ce324906538c43" translate="yes" xml:space="preserve">
          <source>Expanding.max()</source>
          <target state="translated">Expanding.max()</target>
        </trans-unit>
        <trans-unit id="db4d847807cb58ffae83eb70e348775f842263cf" translate="yes" xml:space="preserve">
          <source>Expanding.mean()</source>
          <target state="translated">Expanding.mean()</target>
        </trans-unit>
        <trans-unit id="0d502b7022c87bb9a56e1b306f3ec1789b33e973" translate="yes" xml:space="preserve">
          <source>Expanding.median()</source>
          <target state="translated">Expanding.median()</target>
        </trans-unit>
        <trans-unit id="570ea5d9f73ff518eb416e752f2a25ef49a98c00" translate="yes" xml:space="preserve">
          <source>Expanding.min()</source>
          <target state="translated">Expanding.min()</target>
        </trans-unit>
        <trans-unit id="9be610746594a151709141149375a374a1bdd047" translate="yes" xml:space="preserve">
          <source>Expanding.quantile()</source>
          <target state="translated">Expanding.quantile()</target>
        </trans-unit>
        <trans-unit id="d06fc279224c4edfa5ec2ed3fcde0aeaaea22ef7" translate="yes" xml:space="preserve">
          <source>Expanding.skew()</source>
          <target state="translated">Expanding.skew()</target>
        </trans-unit>
        <trans-unit id="c9a3e12a9f97059a7b5acbf4137acb5323513c79" translate="yes" xml:space="preserve">
          <source>Expanding.std()</source>
          <target state="translated">Expanding.std()</target>
        </trans-unit>
        <trans-unit id="e45d311fff91d92a2419851792777474e5d5bfcc" translate="yes" xml:space="preserve">
          <source>Expanding.sum()</source>
          <target state="translated">Expanding.sum()</target>
        </trans-unit>
        <trans-unit id="1d63c3a9adb782b5e071a922036a6afea8e08c19" translate="yes" xml:space="preserve">
          <source>Expanding.var()</source>
          <target state="translated">Expanding.var()</target>
        </trans-unit>
        <trans-unit id="08befc3de77fdcd270394e66785aaa6922aaaffa" translate="yes" xml:space="preserve">
          <source>Expect to do some cleanup after you call this function. For example, you might need to manually assign column names if the column names are converted to NaN when you pass the</source>
          <target state="translated">이 함수를 호출 한 후 정리를 수행 할 수 있습니다. 예를 들어, 열 이름이 NaN으로 변환되면 열 이름을 수동으로 할당해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a16025b92eeda3d982387bc4b964699efd2e9dd" translate="yes" xml:space="preserve">
          <source>Expect to do some cleanup after you call this function. For example, you might need to manually assign column names if the column names are converted to NaN when you pass the &lt;code&gt;header=0&lt;/code&gt; argument. We try to assume as little as possible about the structure of the table and push the idiosyncrasies of the HTML contained in the table to the user.</source>
          <target state="translated">이 함수를 호출 한 후 정리를 수행해야합니다. 예를 들어 &lt;code&gt;header=0&lt;/code&gt; 인수 를 전달할 때 열 이름이 NaN으로 변환 된 경우 열 이름을 수동으로 할당해야 할 수 있습니다 . 우리는 테이블의 구조에 대해 가능한 한 적게 가정하고 테이블에 포함 된 HTML의 고유성을 사용자에게 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="e14fe67d8fcc086b16c1a194e2d8eed2c973cb74" translate="yes" xml:space="preserve">
          <source>Experienced users of relational databases like SQL will be familiar with the terminology used to describe join operations between two SQL-table like structures (&lt;code&gt;DataFrame&lt;/code&gt; objects). There are several cases to consider which are very important to understand:</source>
          <target state="translated">SQL과 같은 관계형 데이터베이스의 숙련 된 사용자는 두 SQL- 테이블 유사 구조 ( &lt;code&gt;DataFrame&lt;/code&gt; 개체) 간의 조인 작업을 설명하는 데 사용되는 용어에 익숙 합니다. 고려해야 할 몇 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb0d8502a8e799ad1b732bb9fd135c7742a93ee" translate="yes" xml:space="preserve">
          <source>Experimental &lt;code&gt;NA&lt;/code&gt; scalar to denote missing values</source>
          <target state="translated">결 측값을 나타내는 실험적 &lt;code&gt;NA&lt;/code&gt; 스칼라</target>
        </trans-unit>
        <trans-unit id="4db31436187ed17e7a6e7ad81a6e68b0f552e2fe" translate="yes" xml:space="preserve">
          <source>Experimental NA scalar to denote missing values</source>
          <target state="translated">결 측값을 나타내는 실험적 NA 스칼라</target>
        </trans-unit>
        <trans-unit id="c4077e07de84800317a513cbed87b752cbdfd854" translate="yes" xml:space="preserve">
          <source>Experimental: This is a new feature and still under development. We&amp;rsquo;ll be adding features and possibly making breaking changes in future releases. We&amp;rsquo;d love to hear your feedback.</source>
          <target state="translated">실험적 : 이것은 새로운 기능이며 아직 개발 중입니다. 향후 릴리스에서 기능을 추가하고 주요 변경 사항을 적용 할 예정입니다. 우리는 당신의 의견을 듣고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="f0d9f40568c451c514c72a26ddb47e482adfb349" translate="yes" xml:space="preserve">
          <source>Experimental: the behaviour of &lt;code&gt;pd.NA&lt;/code&gt; can still change without warning.</source>
          <target state="translated">실험적 : &lt;code&gt;pd.NA&lt;/code&gt; 의 동작은 경고없이 여전히 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09618f0dd260ba45b2ea50b92da3f4797b9d4245" translate="yes" xml:space="preserve">
          <source>Explain why the current behavior is wrong/not desired and what you expect instead.</source>
          <target state="translated">현재 행동이 왜 틀렸거나 바람직하지 않은지 그리고 대신에 당신이 기대하는 것을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="29c4d818b13091b12fb7e1033100f74231f127be" translate="yes" xml:space="preserve">
          <source>Explicitly pass &lt;code&gt;sort=True&lt;/code&gt; to silence the warning and sort. Explicitly pass &lt;code&gt;sort=False&lt;/code&gt; to silence the warning and not sort.</source>
          <target state="translated">명시 적으로 &lt;code&gt;sort=True&lt;/code&gt; 를 전달 하여 경고 및 정렬을 끄십시오. &lt;code&gt;sort=False&lt;/code&gt; 를 명시 적으로 전달 하여 경고를 끄고 정렬하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f31f972030da5744bb3b442a7cad4c038c1a65e4" translate="yes" xml:space="preserve">
          <source>Explode a DataFrame from list-like columns to long format.</source>
          <target state="translated">목록 같은 열에서 긴 형식으로 DataFrame을 분해하십시오.</target>
        </trans-unit>
        <trans-unit id="1765275e14cafc2a48cc2d7ab9961baefded93a0" translate="yes" xml:space="preserve">
          <source>Exploded lists to rows of the subset columns; index will be duplicated for these rows.</source>
          <target state="translated">부분 집합 열의 행으로 분해 된 목록. 이 행에 대해 인덱스가 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="e75086b1197d69eef128e13cf9b5f307968c6542" translate="yes" xml:space="preserve">
          <source>Exploded lists to rows; index will be duplicated for these rows.</source>
          <target state="translated">분해 된 목록을 행으로; 이 행에 대해 인덱스가 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae732f4e79d2c9c2427de200400664d03468f56" translate="yes" xml:space="preserve">
          <source>Exploding a list-like column</source>
          <target state="translated">목록 같은 열 분해</target>
        </trans-unit>
        <trans-unit id="acc52a56f6d6b750d6e6d6905467a920e7a18099" translate="yes" xml:space="preserve">
          <source>Exponential weighted moving average.</source>
          <target state="translated">지수 가중 이동 평균.</target>
        </trans-unit>
        <trans-unit id="1f1ad49e0789ca5aa1bab984b2f604c2a8652866" translate="yes" xml:space="preserve">
          <source>Exponential weighted moving stddev.</source>
          <target state="translated">지수 가중 이동 stddev.</target>
        </trans-unit>
        <trans-unit id="8f4df549c7e9cdae3deb2abd3e0a3e1f39e87970" translate="yes" xml:space="preserve">
          <source>Exponential weighted moving variance.</source>
          <target state="translated">지수 가중 이동 분산.</target>
        </trans-unit>
        <trans-unit id="8542de4d51bd3357b741df6010c4bb06697b5308" translate="yes" xml:space="preserve">
          <source>Exponential weighted sample correlation.</source>
          <target state="translated">지수 가중 샘플 상관.</target>
        </trans-unit>
        <trans-unit id="bb5d9178a7bfb17ed9b276801fad601764f951b4" translate="yes" xml:space="preserve">
          <source>Exponential weighted sample covariance.</source>
          <target state="translated">지수 가중 샘플 공분산.</target>
        </trans-unit>
        <trans-unit id="e98be901a19c80a080f0a080be202f92c8452e81" translate="yes" xml:space="preserve">
          <source>ExponentialMovingWindow also has an &lt;code&gt;ignore_na&lt;/code&gt; argument, which determines how intermediate null values affect the calculation of the weights. When &lt;code&gt;ignore_na=False&lt;/code&gt; (the default), weights are calculated based on absolute positions, so that intermediate null values affect the result. When &lt;code&gt;ignore_na=True&lt;/code&gt;, weights are calculated by ignoring intermediate null values. For example, assuming &lt;code&gt;adjust=True&lt;/code&gt;, if &lt;code&gt;ignore_na=False&lt;/code&gt;, the weighted average of &lt;code&gt;3, NaN, 5&lt;/code&gt; would be calculated as</source>
          <target state="translated">ExponentialMovingWindow에는 중간 null 값이 가중치 계산에 미치는 영향을 결정하는 &lt;code&gt;ignore_na&lt;/code&gt; 인수 도 있습니다 . 경우 &lt;code&gt;ignore_na=False&lt;/code&gt; (디폴트), 가중치는 중간 널 값이 결과에 영향을되도록, 절대 위치에 기초하여 계산된다. 경우 &lt;code&gt;ignore_na=True&lt;/code&gt; 가중치 중간체 널 값을 무시함으로써 계산된다. 예를 들어, 가정을 &lt;code&gt;adjust=True&lt;/code&gt; 경우 &lt;code&gt;ignore_na=False&lt;/code&gt; , 가중 평균 &lt;code&gt;3, NaN, 5&lt;/code&gt; 로 계산 될</target>
        </trans-unit>
        <trans-unit id="0b561fe12ded76528c8353cb627fc586812b6b42" translate="yes" xml:space="preserve">
          <source>Exponentially Weighted window</source>
          <target state="translated">지수 가중치 창</target>
        </trans-unit>
        <trans-unit id="ee9907d4a5c6c186e893f351ce1555049f3bfb49" translate="yes" xml:space="preserve">
          <source>Exponentially Weighted window: Accumulating and exponentially weighted window over the values.</source>
          <target state="translated">지수 가중치 창 : 값에 대한 누적 및 지수 가중치 창.</target>
        </trans-unit>
        <trans-unit id="27b61858e311802d9821df6e8f7f62278093aa08" translate="yes" xml:space="preserve">
          <source>Exponentially weighted windows</source>
          <target state="translated">지수 가중치 창</target>
        </trans-unit>
        <trans-unit id="8e4012c8848521a99f1fc5e0add133449f9151e9" translate="yes" xml:space="preserve">
          <source>Exponentially-weighted moving window functions</source>
          <target state="translated">지수 가중 이동 창 기능</target>
        </trans-unit>
        <trans-unit id="dc1b23811aee2bb6151cdb6c512450c9180a2c29" translate="yes" xml:space="preserve">
          <source>Exponentially-weighted window functions</source>
          <target state="translated">지수 가중치 창 함수</target>
        </trans-unit>
        <trans-unit id="5640f4f06484e90326af68b8842405638698556b" translate="yes" xml:space="preserve">
          <source>Export DataFrame object to Stata dta format.</source>
          <target state="translated">DataFrame 객체를 Stata dta 형식으로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a88921731e3a346e23b21872121af2be507a3bb1" translate="yes" xml:space="preserve">
          <source>Export Stata data files.</source>
          <target state="translated">Stata 데이터 파일을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="979a61066306881f467e70677394214f90a9d9d8" translate="yes" xml:space="preserve">
          <source>Export the styles to applied to the current Styler.</source>
          <target state="translated">현재 스타일러에 적용 할 스타일을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d348521d1d88385cae9661b52fbdcf517ee1784e" translate="yes" xml:space="preserve">
          <source>Export to Excel</source>
          <target state="translated">Excel로 내보내기</target>
        </trans-unit>
        <trans-unit id="b2d2d958399f4ec4fff4557fbb342285481c2f91" translate="yes" xml:space="preserve">
          <source>Exporting data</source>
          <target state="translated">데이터 내보내기</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="3644e278561f083b41bcc40d0fc7f0c847a45bae" translate="yes" xml:space="preserve">
          <source>Expression evaluation via &lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 통한 식 평가</target>
        </trans-unit>
        <trans-unit id="fb2d8930a1568c140d0b27f5310b0e87d35fb393" translate="yes" xml:space="preserve">
          <source>Expression evaluation via &lt;code&gt;eval()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; 통한 표현식 평가</target>
        </trans-unit>
        <trans-unit id="9d72e70163cadc5454c65c95a80c1d7eecfa870e" translate="yes" xml:space="preserve">
          <source>Expression evaluation via eval()</source>
          <target state="translated">eval ()을 통한 식 평가</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="590fc32280b4d9b7db21cb964a958d73ff33ae34" translate="yes" xml:space="preserve">
          <source>Expressions that would result in an object dtype or involve datetime operations (because of &lt;code&gt;NaT&lt;/code&gt;) must be evaluated in Python space. The main reason for this behavior is to maintain backwards compatibility with versions of NumPy &amp;lt; 1.7. In those versions of NumPy a call to &lt;code&gt;ndarray.astype(str)&lt;/code&gt; will truncate any strings that are more than 60 characters in length. Second, we can&amp;rsquo;t pass &lt;code&gt;object&lt;/code&gt; arrays to &lt;code&gt;numexpr&lt;/code&gt; thus string comparisons must be evaluated in Python space.</source>
          <target state="translated">객체 dtype을 생성하거나 &lt;code&gt;NaT&lt;/code&gt; 때문에 datetime 작업을 포함하는 표현식 은 Python 공간에서 평가되어야합니다. 이 동작의 주된 이유는 NumPy &amp;lt;1.7 버전과의 하위 호환성을 유지하기위한 것입니다. NumPy 버전에서 &lt;code&gt;ndarray.astype(str)&lt;/code&gt; 호출하면 길이가 60자를 초과하는 모든 문자열이 잘립니다. 둘째, &lt;code&gt;object&lt;/code&gt; 배열을 &lt;code&gt;numexpr&lt;/code&gt; 에 전달할 수 없으므로 문자열 비교는 Python 공간에서 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e5c766e77be60c2c1f06320f97b05b85f6955357" translate="yes" xml:space="preserve">
          <source>Extending Example</source>
          <target state="translated">확장 예</target>
        </trans-unit>
        <trans-unit id="13fbc5fe553d6748b16103c39324eed5e08f18cd" translate="yes" xml:space="preserve">
          <source>Extending by &lt;a href=&quot;#extending-extension-types&quot;&gt;extension type&lt;/a&gt;</source>
          <target state="translated">확장 &lt;a href=&quot;#extending-extension-types&quot;&gt;유형&lt;/a&gt; 으로 확장</target>
        </trans-unit>
        <trans-unit id="5abf03223ae7acb7397a409585484ae2a894ee66" translate="yes" xml:space="preserve">
          <source>Extending by &lt;a href=&quot;#extending-register-accessors&quot;&gt;registering an accessor&lt;/a&gt;</source>
          <target state="translated">접근자를 &lt;a href=&quot;#extending-register-accessors&quot;&gt;등록하여&lt;/a&gt; 확장</target>
        </trans-unit>
        <trans-unit id="e4f6827bfdef254bc0230c90588223fe13ce0664" translate="yes" xml:space="preserve">
          <source>Extending pandas</source>
          <target state="translated">팬더 확장</target>
        </trans-unit>
        <trans-unit id="02c94538d1874480a4371b6ab14ef1e2eea48fb4" translate="yes" xml:space="preserve">
          <source>Extensibility</source>
          <target state="translated">Extensibility</target>
        </trans-unit>
        <trans-unit id="faf5b82e5b92082a1b30c201996f42e93d447ca7" translate="yes" xml:space="preserve">
          <source>Extensible method chains with &lt;a href=&quot;../getting_started/basics#basics-pipe&quot;&gt;pipe&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../getting_started/basics#basics-pipe&quot;&gt;파이프가있는&lt;/a&gt; 확장 가능한 분석법 체인</target>
        </trans-unit>
        <trans-unit id="8a0ba92ee468b44b7531201cb796d2991f18f4c6" translate="yes" xml:space="preserve">
          <source>Extension Arrays are only allowed to be 1-dimensional.</source>
          <target state="translated">확장 배열은 1 차원 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="53bf06e6887fdc9a61f1de4a19bb985f66f3bdb4" translate="yes" xml:space="preserve">
          <source>Extension array for string data.</source>
          <target state="translated">문자열 데이터에 대한 확장 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f56814564426209446f0697e46ebe26660aafdae" translate="yes" xml:space="preserve">
          <source>Extension classes include categoricals, pandas sparse objects (i.e. classes represented within the pandas library and not ones external to it like scipy sparse matrices), and datetime-like arrays.</source>
          <target state="translated">확장 클래스에는 범주 형, pandas 스파 스 객체 (예 : scipy sparse 매트릭스와 같이 외부 라이브러리가 아닌 pandas 라이브러리 내에 표시되는 클래스) 및 날짜 / 시간 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="89fa2cacf1f0bb5ad2cb9bde4d5d26035b9ddd8e" translate="yes" xml:space="preserve">
          <source>Extension data types</source>
          <target state="translated">확장 데이터 유형</target>
        </trans-unit>
        <trans-unit id="e666a55adb34dbff222be3f41fac844588f83dc3" translate="yes" xml:space="preserve">
          <source>Extension dtype for boolean data.</source>
          <target state="translated">부울 데이터의 확장 dtype.</target>
        </trans-unit>
        <trans-unit id="8fe8beb4617a8808d366aab37d087c72ac92f692" translate="yes" xml:space="preserve">
          <source>Extension dtype for string data.</source>
          <target state="translated">문자열 데이터의 확장 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="9c68cdfbbd52323ff528c825ba660a53d3efe89d" translate="yes" xml:space="preserve">
          <source>Extension types</source>
          <target state="translated">확장 타입</target>
        </trans-unit>
        <trans-unit id="e37e0b59a280fb467047c66655b358959c8585ba" translate="yes" xml:space="preserve">
          <source>ExtensionArray</source>
          <target state="translated">ExtensionArray</target>
        </trans-unit>
        <trans-unit id="007c137be13ca0ff6ad175c21dd860477df48731" translate="yes" xml:space="preserve">
          <source>ExtensionArray or np.ndarray</source>
          <target state="translated">ExtensionArray 또는 np.ndarray</target>
        </trans-unit>
        <trans-unit id="ee4737cb3c3291e2fcd1d9780b8df729cb7e1c74" translate="yes" xml:space="preserve">
          <source>ExtensionArray wrapping a NumPy array.</source>
          <target state="translated">NumPy 배열을 래핑하는 ExtensionArray</target>
        </trans-unit>
        <trans-unit id="73c8214adc4e356ab9711a4c29c3f470912f9f21" translate="yes" xml:space="preserve">
          <source>ExtensionArray._concat_same_type()</source>
          <target state="translated">ExtensionArray._concat_same_type()</target>
        </trans-unit>
        <trans-unit id="473ce1b45b952bb789f7a3973cef895eadf57990" translate="yes" xml:space="preserve">
          <source>ExtensionArray._formatter()</source>
          <target state="translated">ExtensionArray._formatter()</target>
        </trans-unit>
        <trans-unit id="5c880706226291e77e7c787650fc188b5d056fe1" translate="yes" xml:space="preserve">
          <source>ExtensionArray._formatting_values()</source>
          <target state="translated">ExtensionArray._formatting_values()</target>
        </trans-unit>
        <trans-unit id="f34701c11d9383b35cf486bafec95b8200365c2a" translate="yes" xml:space="preserve">
          <source>ExtensionArray._from_factorized()</source>
          <target state="translated">ExtensionArray._from_factorized()</target>
        </trans-unit>
        <trans-unit id="0698561bc647fab5d16fc14efecb5bb99162a143" translate="yes" xml:space="preserve">
          <source>ExtensionArray._from_sequence()</source>
          <target state="translated">ExtensionArray._from_sequence()</target>
        </trans-unit>
        <trans-unit id="56096dc10921ff4cc13449344add418a5a1fbfed" translate="yes" xml:space="preserve">
          <source>ExtensionArray._from_sequence_of_strings()</source>
          <target state="translated">ExtensionArray._from_sequence_of_strings()</target>
        </trans-unit>
        <trans-unit id="d23fb69bd3530327383e20b69683f917c968bbad" translate="yes" xml:space="preserve">
          <source>ExtensionArray._ndarray_values</source>
          <target state="translated">ExtensionArray._ndarray_values</target>
        </trans-unit>
        <trans-unit id="3a817dfb8dd670c9d2e9dfb92263b64a182e3c2e" translate="yes" xml:space="preserve">
          <source>ExtensionArray._reduce()</source>
          <target state="translated">ExtensionArray._reduce()</target>
        </trans-unit>
        <trans-unit id="718ad56001a394d3e76459366481485b6ddcc359" translate="yes" xml:space="preserve">
          <source>ExtensionArray._values_for_argsort()</source>
          <target state="translated">ExtensionArray._values_for_argsort()</target>
        </trans-unit>
        <trans-unit id="80c8b1f79556e273dfc89ebd4de5311df34df43f" translate="yes" xml:space="preserve">
          <source>ExtensionArray._values_for_factorize()</source>
          <target state="translated">ExtensionArray._values_for_factorize()</target>
        </trans-unit>
        <trans-unit id="d69c82c1ad7d33d8c5c81be00a1f64032850d17e" translate="yes" xml:space="preserve">
          <source>ExtensionArray.argsort()</source>
          <target state="translated">ExtensionArray.argsort()</target>
        </trans-unit>
        <trans-unit id="c5d13b93d5058d6e83bba5610c03ad94271d6ef2" translate="yes" xml:space="preserve">
          <source>ExtensionArray.astype()</source>
          <target state="translated">ExtensionArray.astype()</target>
        </trans-unit>
        <trans-unit id="d881662b6e88f86f370e542e5ffce1e952677572" translate="yes" xml:space="preserve">
          <source>ExtensionArray.copy()</source>
          <target state="translated">ExtensionArray.copy()</target>
        </trans-unit>
        <trans-unit id="c25ceeaf7cd5462dd83a44781b60b18565c34647" translate="yes" xml:space="preserve">
          <source>ExtensionArray.dropna()</source>
          <target state="translated">ExtensionArray.dropna()</target>
        </trans-unit>
        <trans-unit id="8232e429a1ae7ce87db05235484a878fb30467d7" translate="yes" xml:space="preserve">
          <source>ExtensionArray.dtype</source>
          <target state="translated">ExtensionArray.dtype</target>
        </trans-unit>
        <trans-unit id="d5f30bc91af1ee0c40cd82f3faef035c88e5e068" translate="yes" xml:space="preserve">
          <source>ExtensionArray.factorize()</source>
          <target state="translated">ExtensionArray.factorize()</target>
        </trans-unit>
        <trans-unit id="f17d5971a3025877406d8a41f9758ecb18d8e1c5" translate="yes" xml:space="preserve">
          <source>ExtensionArray.fillna()</source>
          <target state="translated">ExtensionArray.fillna()</target>
        </trans-unit>
        <trans-unit id="26a2b599bfc6c588c8d980a67deaa378a9f260ce" translate="yes" xml:space="preserve">
          <source>ExtensionArray.isna()</source>
          <target state="translated">ExtensionArray.isna()</target>
        </trans-unit>
        <trans-unit id="a8da76c9d853401065d5da408acc3f5e3aa94c73" translate="yes" xml:space="preserve">
          <source>ExtensionArray.nbytes</source>
          <target state="translated">ExtensionArray.nbytes</target>
        </trans-unit>
        <trans-unit id="c6a53b584b48dc3783f7608e38a82fbfc3b5a348" translate="yes" xml:space="preserve">
          <source>ExtensionArray.ndim</source>
          <target state="translated">ExtensionArray.ndim</target>
        </trans-unit>
        <trans-unit id="2621513560825cc090806820370827ebe13a52b8" translate="yes" xml:space="preserve">
          <source>ExtensionArray.ravel()</source>
          <target state="translated">ExtensionArray.ravel()</target>
        </trans-unit>
        <trans-unit id="cae96a0505b2bb407af83e96a074c69d888fe5fd" translate="yes" xml:space="preserve">
          <source>ExtensionArray.repeat()</source>
          <target state="translated">ExtensionArray.repeat()</target>
        </trans-unit>
        <trans-unit id="22ac86c9049a13a9b5d2cc23e98eb17c70be0a47" translate="yes" xml:space="preserve">
          <source>ExtensionArray.searchsorted()</source>
          <target state="translated">ExtensionArray.searchsorted()</target>
        </trans-unit>
        <trans-unit id="5f2bfd13a20d7db36de0dc5968073faa3a933741" translate="yes" xml:space="preserve">
          <source>ExtensionArray.shape</source>
          <target state="translated">ExtensionArray.shape</target>
        </trans-unit>
        <trans-unit id="a1e61288edbfdbaebc59f8c35cae46a720981ef8" translate="yes" xml:space="preserve">
          <source>ExtensionArray.shift()</source>
          <target state="translated">ExtensionArray.shift()</target>
        </trans-unit>
        <trans-unit id="1014a18c8b990251623dc4c139cff12c770a4af5" translate="yes" xml:space="preserve">
          <source>ExtensionArray.take is called by &lt;code&gt;Series.__getitem__&lt;/code&gt;, &lt;code&gt;.loc&lt;/code&gt;, &lt;code&gt;iloc&lt;/code&gt;, when</source>
          <target state="translated">ExtensionArray.take는 &lt;code&gt;Series.__getitem__&lt;/code&gt; , &lt;code&gt;.loc&lt;/code&gt; , &lt;code&gt;iloc&lt;/code&gt; 에 의해 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="295aa54a63b343065fde06347d2d91692747b993" translate="yes" xml:space="preserve">
          <source>ExtensionArray.take is called by &lt;code&gt;Series.__getitem__&lt;/code&gt;, &lt;code&gt;.loc&lt;/code&gt;, &lt;code&gt;iloc&lt;/code&gt;, when &lt;code&gt;indices&lt;/code&gt; is a sequence of values. Additionally, it&amp;rsquo;s called by &lt;code&gt;Series.reindex()&lt;/code&gt;, or any other method that causes realignment, with a &lt;code&gt;fill_value&lt;/code&gt;.</source>
          <target state="translated">ExtensionArray.take는 &lt;code&gt;indices&lt;/code&gt; 가 일련의 값인 경우 &lt;code&gt;Series.__getitem__&lt;/code&gt; , &lt;code&gt;.loc&lt;/code&gt; , &lt;code&gt;iloc&lt;/code&gt; 에 의해 호출됩니다 . 또한 &lt;code&gt;Series.reindex()&lt;/code&gt; 또는 &lt;code&gt;fill_value&lt;/code&gt; 와 함께 재정렬을 일으키는 다른 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a878e0fac59c4a49ad22991013f4ce84a8371ef" translate="yes" xml:space="preserve">
          <source>ExtensionArray.take()</source>
          <target state="translated">ExtensionArray.take()</target>
        </trans-unit>
        <trans-unit id="fa80d49704c1f5509cc2d5797fe6e5770b1285d2" translate="yes" xml:space="preserve">
          <source>ExtensionArray.unique()</source>
          <target state="translated">ExtensionArray.unique()</target>
        </trans-unit>
        <trans-unit id="9188521c150dcccfc6df8a7a48f079f336c923d3" translate="yes" xml:space="preserve">
          <source>ExtensionArrays are limited to 1 dimension.</source>
          <target state="translated">ExtensionArray는 1 차원으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="66602c53ed25b3e51f8c59ce85a326a3a950f109" translate="yes" xml:space="preserve">
          <source>ExtensionDtype</source>
          <target state="translated">ExtensionDtype</target>
        </trans-unit>
        <trans-unit id="231ef721f0da6370f6d08f0b66f0066bef3d8314" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.construct_array_type()</source>
          <target state="translated">ExtensionDtype.construct_array_type()</target>
        </trans-unit>
        <trans-unit id="cbeefe5c4f031587c157481d8c4838412feca0dd" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.construct_from_string()</source>
          <target state="translated">ExtensionDtype.construct_from_string()</target>
        </trans-unit>
        <trans-unit id="cb70f3bcb5550094ff4d75978b1745a3c03407e4" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.is_dtype()</source>
          <target state="translated">ExtensionDtype.is_dtype()</target>
        </trans-unit>
        <trans-unit id="9a5a2475399414f3534ef36879746a2dd8b764c5" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.kind</source>
          <target state="translated">ExtensionDtype.kind</target>
        </trans-unit>
        <trans-unit id="2e14b102adfd9fb34a8c898ff1442f35e8f56571" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.na_value</source>
          <target state="translated">ExtensionDtype.na_value</target>
        </trans-unit>
        <trans-unit id="0c2710203a9f29a3f6cae2b480c90729fb15affe" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.name</source>
          <target state="translated">ExtensionDtype.name</target>
        </trans-unit>
        <trans-unit id="449a72da72656bcaa4b340d7f5acfd40870ec6fa" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.names</source>
          <target state="translated">ExtensionDtype.names</target>
        </trans-unit>
        <trans-unit id="d2feb58bbdabeae745ea82cf7d2ecadced161772" translate="yes" xml:space="preserve">
          <source>ExtensionDtype.type</source>
          <target state="translated">ExtensionDtype.type</target>
        </trans-unit>
        <trans-unit id="de91e8f5aa51702df94221f4e5a4e07caeb2d019" translate="yes" xml:space="preserve">
          <source>ExtensionDtypes are required to be hashable. The base class provides a default implementation, which relies on the &lt;code&gt;_metadata&lt;/code&gt; class attribute. &lt;code&gt;_metadata&lt;/code&gt; should be a tuple containing the strings that define your data type. For example, with &lt;code&gt;PeriodDtype&lt;/code&gt; that&amp;rsquo;s the &lt;code&gt;freq&lt;/code&gt; attribute.</source>
          <target state="translated">ExtensionDtype은 해시 가능해야합니다. 기본 클래스는 &lt;code&gt;_metadata&lt;/code&gt; 클래스 속성 에 의존하는 기본 구현을 제공 합니다. &lt;code&gt;_metadata&lt;/code&gt; 는 데이터 유형을 정의하는 문자열을 포함하는 튜플이어야합니다. 예를 들어, &lt;code&gt;PeriodDtype&lt;/code&gt; 을 사용하는 경우 &lt;code&gt;freq&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="792810ac7ae19283ec1f9b0cc73a7e92311d37d1" translate="yes" xml:space="preserve">
          <source>External compatibility</source>
          <target state="translated">외부 호환성</target>
        </trans-unit>
        <trans-unit id="a3eb6236080c1f682d8f9ea85a9f64cb61233db2" translate="yes" xml:space="preserve">
          <source>Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc., if using a URL that will be parsed by &lt;code&gt;fsspec&lt;/code&gt;, e.g., starting &amp;ldquo;s3://&amp;rdquo;, &amp;ldquo;gcs://&amp;rdquo;.</source>
          <target state="translated">추가 옵션은 특정 스토리지 연결, 예를 들어, 호스트, 포트, 사용자 이름, 암호 등을위한 메이크업의 감각에 의해 구문 분석하는 URL 사용하는 경우 있음 &lt;code&gt;fsspec&lt;/code&gt; 를 , &quot;GCS를 : //&quot;예를 들어, &quot;// S3 '시작 .</target>
        </trans-unit>
        <trans-unit id="de7d1b1192cbed51ec726c852f26aaea4219528c" translate="yes" xml:space="preserve">
          <source>Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc., if using a URL that will be parsed by &lt;code&gt;fsspec&lt;/code&gt;, e.g., starting &amp;ldquo;s3://&amp;rdquo;, &amp;ldquo;gcs://&amp;rdquo;. An error will be raised if providing this argument with a local path or a file-like buffer. See the fsspec and backend storage implementation docs for the set of allowed keys and values.</source>
          <target state="translated">추가 옵션은 특정 스토리지 연결, 예를 들어, 호스트, 포트, 사용자 이름, 암호 등을위한 메이크업의 감각에 의해 구문 분석하는 URL 사용하는 경우 있음 &lt;code&gt;fsspec&lt;/code&gt; 를 , &quot;GCS를 : //&quot;예를 들어, &quot;// S3 '시작 . 이 인수에 로컬 경로 또는 파일 류 버퍼를 제공하면 오류가 발생합니다. 허용되는 키 및 값 집합은 fsspec 및 백엔드 저장소 구현 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="55f993daa25bd5074393fc27f2361970b8452a0b" translate="yes" xml:space="preserve">
          <source>Extra options that make sense for a particular storage connection, e.g. host, port, username, password, etc., if using a URL that will be parsed by &lt;code&gt;fsspec&lt;/code&gt;, e.g., starting &amp;ldquo;s3://&amp;rdquo;, &amp;ldquo;gcs://&amp;rdquo;. An error will be raised if providing this argument with a non-fsspec URL. See the fsspec and backend storage implementation docs for the set of allowed keys and values.</source>
          <target state="translated">특정 스토리지 연결에 적합한 추가 옵션 (예 : 호스트, 포트, 사용자 이름, 비밀번호 등 ) (예 : &quot;s3 : //&quot;, &quot;gcs : //&quot;시작과 같이 &lt;code&gt;fsspec&lt;/code&gt; 에서 구문 분석 할 URL을 사용하는 경우) . 이 인수에 비 fsspec URL을 제공하면 오류가 발생합니다. 허용되는 키 및 값 집합은 fsspec 및 백엔드 저장소 구현 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="6cc234b33050b36a27577513912905a91e396e06" translate="yes" xml:space="preserve">
          <source>Extract 3 random elements from the &lt;code&gt;Series&lt;/code&gt;&lt;code&gt;df['num_legs']&lt;/code&gt;: Note that we use</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; &lt;code&gt;df['num_legs']&lt;/code&gt; 에서 무작위 요소 3 개를 추출 합니다.</target>
        </trans-unit>
        <trans-unit id="d8871d379ef5a388cc087108c344111259832f48" translate="yes" xml:space="preserve">
          <source>Extract 3 random elements from the &lt;code&gt;Series&lt;/code&gt;&lt;code&gt;df['num_legs']&lt;/code&gt;: Note that we use &lt;code&gt;random_state&lt;/code&gt; to ensure the reproducibility of the examples.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; &lt;code&gt;df['num_legs']&lt;/code&gt; 에서 3 개의 랜덤 원소를 추출합니다 : 예제의 재현성을 보장하기 위해 &lt;code&gt;random_state&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f22f50c3fcdbf02e9ea4708fc079e1901c86e42" translate="yes" xml:space="preserve">
          <source>Extract a subset of columns contained in &lt;code&gt;usecols&lt;/code&gt; from an SPSS file and avoid converting categorical columns into &lt;code&gt;pd.Categorical&lt;/code&gt;:</source>
          <target state="translated">SPSS 파일 에서 &lt;code&gt;usecols&lt;/code&gt; 에 포함 된 열의 하위 집합을 추출하고 범주 형 열을 &lt;code&gt;pd.Categorical&lt;/code&gt; 로 변환하지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="0947f692159d684c1372de24995397fc4725fd0e" translate="yes" xml:space="preserve">
          <source>Extract all matches in each subject (extractall)</source>
          <target state="translated">각 주제에서 모든 일치 항목 추출 (extractall)</target>
        </trans-unit>
        <trans-unit id="a9cc28dfa5e3a62bcfc74b1fa60c1914272eac1d" translate="yes" xml:space="preserve">
          <source>Extract capture groups in the regex</source>
          <target state="translated">정규식에서 캡처 그룹 추출</target>
        </trans-unit>
        <trans-unit id="d41f2c3a836fda251a32fc0e850e22516bd98228" translate="yes" xml:space="preserve">
          <source>Extract capture groups in the regex &lt;code&gt;pat&lt;/code&gt; as columns in a DataFrame.</source>
          <target state="translated">정규식에서 추출 캡처 그룹 &lt;code&gt;pat&lt;/code&gt; DataFrame의 열 등.</target>
        </trans-unit>
        <trans-unit id="85e566ed8d5eaa3d640370b431d27a738a5303bf" translate="yes" xml:space="preserve">
          <source>Extract duplicated index elements.</source>
          <target state="translated">중복 된 인덱스 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="0c596be4c1daf9bf935f8694deb3c54326de1710" translate="yes" xml:space="preserve">
          <source>Extract element from each component at specified position.</source>
          <target state="translated">지정된 위치에서 각 구성 요소에서 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="744b4b33fae9f9e29abd38204a65372410ed487d" translate="yes" xml:space="preserve">
          <source>Extract element from lists, tuples, or strings in each element in the Series/Index.</source>
          <target state="translated">시리즈 / 인덱스의 각 요소에있는 목록, 튜플 또는 문자열에서 요소를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c2f999c097d35cd7822024e5c0524dda06fe346b" translate="yes" xml:space="preserve">
          <source>Extract first match in each subject (extract)</source>
          <target state="translated">각 주제에서 첫 번째 일치 항목 추출 (추출)</target>
        </trans-unit>
        <trans-unit id="97fc28f4138b579eb07ab4da30c5782cefb1a15a" translate="yes" xml:space="preserve">
          <source>Extract matched groups.</source>
          <target state="translated">일치하는 그룹을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="bbfdead34054d5165239fdacbcfde126181ac28e" translate="yes" xml:space="preserve">
          <source>Extract the array stored within a Series.</source>
          <target state="translated">Series 내에 저장된 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0c27059bf19e69ea10040d870a4f2e16ee4a7d44" translate="yes" xml:space="preserve">
          <source>Extracting a regular expression with more than one group returns a DataFrame with one column per group.</source>
          <target state="translated">둘 이상의 그룹이있는 정규식을 추출하면 그룹당 하나의 열이있는 DataFrame이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="730826a3806637d35bcd4820ffd03e1132a08419" translate="yes" xml:space="preserve">
          <source>Extracting a regular expression with one group returns a &lt;code&gt;DataFrame&lt;/code&gt; with one column if &lt;code&gt;expand=True&lt;/code&gt;.</source>
          <target state="translated">하나의 그룹이있는 정규식을 추출 하면 &lt;code&gt;expand=True&lt;/code&gt; 인 경우 하나의 열이 있는 &lt;code&gt;DataFrame&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad5026b7dc3bacdd43b7f246a7f6d355abdaa47" translate="yes" xml:space="preserve">
          <source>Extracting substrings</source>
          <target state="translated">부분 문자열 추출</target>
        </trans-unit>
        <trans-unit id="fd6a5ecb0c6d5148842ac5a363fcb56a58341f32" translate="yes" xml:space="preserve">
          <source>FAIL</source>
          <target state="translated">FAIL</target>
        </trans-unit>
        <trans-unit id="79eecff6b62da41fcfcc6f0af3acd88c8b8b4c53" translate="yes" xml:space="preserve">
          <source>FRED</source>
          <target state="translated">FRED</target>
        </trans-unit>
        <trans-unit id="017ef19a9d298f725b1ec74fe5ece28ad72e6e0f" translate="yes" xml:space="preserve">
          <source>FY5253</source>
          <target state="translated">FY5253</target>
        </trans-unit>
        <trans-unit id="5c421e21100f33dcaf16b1ff70ecca0ef7659f07" translate="yes" xml:space="preserve">
          <source>FY5253.apply()</source>
          <target state="translated">FY5253.apply()</target>
        </trans-unit>
        <trans-unit id="5601fdf04bf11b9e0b92590ff68269e42840e58e" translate="yes" xml:space="preserve">
          <source>FY5253.apply_index()</source>
          <target state="translated">FY5253.apply_index()</target>
        </trans-unit>
        <trans-unit id="19bfede70046057b28680d716bbb18b980d4220d" translate="yes" xml:space="preserve">
          <source>FY5253.base</source>
          <target state="translated">FY5253.base</target>
        </trans-unit>
        <trans-unit id="8cec92b095723ba7ad895eac9b7789e3db48ba2a" translate="yes" xml:space="preserve">
          <source>FY5253.copy()</source>
          <target state="translated">FY5253.copy()</target>
        </trans-unit>
        <trans-unit id="7c187cb09c095fe96f994db6a0aebd3afc90048f" translate="yes" xml:space="preserve">
          <source>FY5253.freqstr</source>
          <target state="translated">FY5253.freqstr</target>
        </trans-unit>
        <trans-unit id="c955b39246415eca9108fe9bde93232b3ccff6db" translate="yes" xml:space="preserve">
          <source>FY5253.get_rule_code_suffix()</source>
          <target state="translated">FY5253.get_rule_code_suffix()</target>
        </trans-unit>
        <trans-unit id="5298a875486b7169ab5abdd1d7ba4d58e1c752c6" translate="yes" xml:space="preserve">
          <source>FY5253.get_year_end()</source>
          <target state="translated">FY5253.get_year_end()</target>
        </trans-unit>
        <trans-unit id="43012cb72b94b94c95e1b83d9b847e4c61a89f63" translate="yes" xml:space="preserve">
          <source>FY5253.isAnchored()</source>
          <target state="translated">FY5253.isAnchored()</target>
        </trans-unit>
        <trans-unit id="eb7a63fe669feea50eefdb7f8ae8bd5e19af6a3e" translate="yes" xml:space="preserve">
          <source>FY5253.kwds</source>
          <target state="translated">FY5253.kwds</target>
        </trans-unit>
        <trans-unit id="c1ca3e62768aad77a704433b5226bb17fc633bbd" translate="yes" xml:space="preserve">
          <source>FY5253.name</source>
          <target state="translated">FY5253.name</target>
        </trans-unit>
        <trans-unit id="b04023d1e1db1a1cd0708ec89c7776b9b0952f35" translate="yes" xml:space="preserve">
          <source>FY5253.nanos</source>
          <target state="translated">FY5253.nanos</target>
        </trans-unit>
        <trans-unit id="591dd42f1a57e74a3a2bfb62d5ecf8e4a9117c99" translate="yes" xml:space="preserve">
          <source>FY5253.normalize</source>
          <target state="translated">FY5253.normalize</target>
        </trans-unit>
        <trans-unit id="b63752f9c96232ad43a0804cc7f7094c5fcc2103" translate="yes" xml:space="preserve">
          <source>FY5253.onOffset()</source>
          <target state="translated">FY5253.onOffset()</target>
        </trans-unit>
        <trans-unit id="f422d1976fef0736bd1f85d70f5c7ac4c113494c" translate="yes" xml:space="preserve">
          <source>FY5253.rollback()</source>
          <target state="translated">FY5253.rollback()</target>
        </trans-unit>
        <trans-unit id="f814706653b1f30f15f5d614a94d92ced79db59a" translate="yes" xml:space="preserve">
          <source>FY5253.rollforward()</source>
          <target state="translated">FY5253.rollforward()</target>
        </trans-unit>
        <trans-unit id="4b3afd6bce6fff09096989fc47cc72ea709477b2" translate="yes" xml:space="preserve">
          <source>FY5253.rule_code</source>
          <target state="translated">FY5253.rule_code</target>
        </trans-unit>
        <trans-unit id="96cb254005259267e19e4bd82e0fd8fca2de6e97" translate="yes" xml:space="preserve">
          <source>FY5253Quarter</source>
          <target state="translated">FY5253Quarter</target>
        </trans-unit>
        <trans-unit id="784ec042450bf644e66f35a4a938f32413cf5031" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.apply()</source>
          <target state="translated">FY5253Quarter.apply()</target>
        </trans-unit>
        <trans-unit id="b85f1c00dbdb6f30641a8700c8a806d459815e7e" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.apply_index()</source>
          <target state="translated">FY5253Quarter.apply_index()</target>
        </trans-unit>
        <trans-unit id="2e92948513d2191885863cda33bc3fecaf39830d" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.base</source>
          <target state="translated">FY5253Quarter.base</target>
        </trans-unit>
        <trans-unit id="1d6dd6043c56a8f1f6bc64560198b8cdf6404f02" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.copy()</source>
          <target state="translated">FY5253Quarter.copy()</target>
        </trans-unit>
        <trans-unit id="627993ed976b336dd92237f82f9513a96b0b0816" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.freqstr</source>
          <target state="translated">FY5253Quarter.freqstr</target>
        </trans-unit>
        <trans-unit id="9382fceeeaefa1d3a83c1e1088daa23f089bfd28" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.get_weeks()</source>
          <target state="translated">FY5253Quarter.get_weeks()</target>
        </trans-unit>
        <trans-unit id="2bdc786f729da695a2417ae118b6f500217f6d61" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.isAnchored()</source>
          <target state="translated">FY5253Quarter.isAnchored()</target>
        </trans-unit>
        <trans-unit id="131a83b6cb7a0cae58edaed29e72ebbac580d613" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.kwds</source>
          <target state="translated">FY5253Quarter.kwds</target>
        </trans-unit>
        <trans-unit id="f92e5dbdb30c0e456c81014fb50c6ade607078d6" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.name</source>
          <target state="translated">FY5253Quarter.name</target>
        </trans-unit>
        <trans-unit id="f878fd5b00ef03a1bd8c417ac65d2bd9dbd482e8" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.nanos</source>
          <target state="translated">FY5253Quarter.nanos</target>
        </trans-unit>
        <trans-unit id="4721c95a94bd62217b65365ed8f55d5599d6550c" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.normalize</source>
          <target state="translated">FY5253Quarter.normalize</target>
        </trans-unit>
        <trans-unit id="81f1f26d0714f6f53a686dd752c282d2237d0dfb" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.onOffset()</source>
          <target state="translated">FY5253Quarter.onOffset()</target>
        </trans-unit>
        <trans-unit id="bff7ef0536dd5481b9739e743990ea675542ceda" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.rollback()</source>
          <target state="translated">FY5253Quarter.rollback()</target>
        </trans-unit>
        <trans-unit id="3ad4ca001f2ee53912ae6b9d625be4d4cdb345d8" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.rollforward()</source>
          <target state="translated">FY5253Quarter.rollforward()</target>
        </trans-unit>
        <trans-unit id="8c94940257d2280193600e2e070237d3ee04b4bd" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.rule_code</source>
          <target state="translated">FY5253Quarter.rule_code</target>
        </trans-unit>
        <trans-unit id="fbc4787a7142002a26b9732c839c55435ddf8ea8" translate="yes" xml:space="preserve">
          <source>FY5253Quarter.year_has_extra_week()</source>
          <target state="translated">FY5253Quarter.year_has_extra_week()</target>
        </trans-unit>
        <trans-unit id="2ae45aa607f992e0b433a33fac2d171af1ea28c0" translate="yes" xml:space="preserve">
          <source>Faceted</source>
          <target state="translated">Faceted</target>
        </trans-unit>
        <trans-unit id="106e4b4674a42bd42b9cedf0e327049f1e090b77" translate="yes" xml:space="preserve">
          <source>Factorizing values</source>
          <target state="translated">인수 분해 값</target>
        </trans-unit>
        <trans-unit id="d0cbaa4d652fa9b69360beb1ca8205ae3f1f269c" translate="yes" xml:space="preserve">
          <source>Factory function for creating a subclass of &lt;code&gt;Styler&lt;/code&gt; with a custom template and Jinja environment.</source>
          <target state="translated">사용자 정의 템플릿 및 Jinja 환경 으로 &lt;code&gt;Styler&lt;/code&gt; 의 서브 클래스를 작성하기위한 팩토리 기능 .</target>
        </trans-unit>
        <trans-unit id="cc1bde2b960f3e7b831f2aece43f8b4708c1aa49" translate="yes" xml:space="preserve">
          <source>Factory function for creating a subclass of &lt;code&gt;Styler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Styler&lt;/code&gt; 의 하위 클래스를 만들기위한 팩토리 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="88e656f0b4ab714a3cdccffc2dec1871c3dbee26" translate="yes" xml:space="preserve">
          <source>Fallback behavior</source>
          <target state="translated">대체 동작</target>
        </trans-unit>
        <trans-unit id="97cdbdc7feff827efb082a6b6dd2727237cd49fd" translate="yes" xml:space="preserve">
          <source>False</source>
          <target state="translated">False</target>
        </trans-unit>
        <trans-unit id="b96deb3768dcebdce69efb10e87804c88b8a34e2" translate="yes" xml:space="preserve">
          <source>False : Do not sort the result.</source>
          <target state="translated">False : 결과를 정렬하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a20a7910e54529a94e15496d9bf2c64deab106ce" translate="yes" xml:space="preserve">
          <source>False : Drop all duplicates.</source>
          <target state="translated">False : 모든 중복을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c98629c7d9f2b3ee2abb8a2b88c80ef6f13a8d9e" translate="yes" xml:space="preserve">
          <source>False : Mark all duplicates as &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">False : 모든 중복을 &lt;code&gt;True&lt;/code&gt; 로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="9e574619f5888527dd4b46c8d21efb6599967561" translate="yes" xml:space="preserve">
          <source>False : do not sort the result.</source>
          <target state="translated">False : 결과를 정렬하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ea45601f3da5945d3494412d4956fc90a505760" translate="yes" xml:space="preserve">
          <source>False : returns an ndarray of integers.</source>
          <target state="translated">False : 정수의 ndarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5509abef56b320ae40870a70b29bce3da24aff93" translate="yes" xml:space="preserve">
          <source>False for ranks by high (1) to low (N)</source>
          <target state="translated">순위가 높음 (1)에서 낮음 (N)에 대해서는 거짓</target>
        </trans-unit>
        <trans-unit id="c38d18d61f60514622129b9d816256d1798e0944" translate="yes" xml:space="preserve">
          <source>False for ranks by high (1) to low (N).</source>
          <target state="translated">높은 (1)에서 낮은 (N)의 순위에 대해서는 False입니다.</target>
        </trans-unit>
        <trans-unit id="361d4af337668b944d87cc468ab35915ea6ead05" translate="yes" xml:space="preserve">
          <source>False to sort in descending order</source>
          <target state="translated">내림차순으로 정렬하는 거짓</target>
        </trans-unit>
        <trans-unit id="33c7b9e0c6640c191e80b0f42a3e0cb5599fe90c" translate="yes" xml:space="preserve">
          <source>False to sort in descending order Can also be a list to specify a directed ordering</source>
          <target state="translated">내림차순으로 정렬하는 거짓 지시 된 순서를 지정하는 목록 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc736e0f1f9d6edd41b15cbab82015a10b79392" translate="yes" xml:space="preserve">
          <source>False to sort in descending order. Can also be a list to specify a directed ordering.</source>
          <target state="translated">내림차순으로 정렬하려면 False입니다. 지시 된 순서를 지정하는 목록 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71ab72067a97a3bff9c6ece7c76464ff712e84f" translate="yes" xml:space="preserve">
          <source>False, because &lt;code&gt;0&lt;/code&gt; is considered False.</source>
          <target state="translated">거짓이 때문에 &lt;code&gt;0&lt;/code&gt; 은 거짓으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2f7fd33420282f75aebed8e9c5a1dc0497e87330" translate="yes" xml:space="preserve">
          <source>False, write a string representation of the object to the clipboard.</source>
          <target state="translated">False, 개체의 문자열 표현을 클립 보드에 씁니다.</target>
        </trans-unit>
        <trans-unit id="beafa8310aa2a0b60e7b0a42d9d003a6d2af7e1c" translate="yes" xml:space="preserve">
          <source>False: negative values in</source>
          <target state="translated">False : 음수 값</target>
        </trans-unit>
        <trans-unit id="83bc9e31cbcb5092f1db34d73fe09930c9c1ff11" translate="yes" xml:space="preserve">
          <source>False: negative values in &lt;code&gt;indices&lt;/code&gt; indicate positional indices from the right (the default). This is similar to &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html#numpy.take&quot;&gt;&lt;code&gt;numpy.take()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">False : &lt;code&gt;indices&lt;/code&gt; 음수 값 은 오른쪽의 위치 인덱스를 나타냅니다 (기본값). 이것은 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html#numpy.take&quot;&gt; &lt;code&gt;numpy.take()&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="dc15e7c9376a780ab20e2736f813431c67f47561" translate="yes" xml:space="preserve">
          <source>False: only update values that are NA in the original DataFrame.</source>
          <target state="translated">False : 원래 DataFrame에서 NA 인 값만 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c3332e1b039f3d9c21340c1bb2685d08ae322a82" translate="yes" xml:space="preserve">
          <source>Fama/French</source>
          <target state="translated">Fama/French</target>
        </trans-unit>
        <trans-unit id="874216e990eccdf7c6c0b4c9179b7cb8a56dd84f" translate="yes" xml:space="preserve">
          <source>Fast integer location scalar accessor.</source>
          <target state="translated">빠른 정수 위치 스칼라 접근 자.</target>
        </trans-unit>
        <trans-unit id="337ea8ca14b943e61d637c82f2c613bba294e211" translate="yes" xml:space="preserve">
          <source>Fast lookup of value from 1-dimensional ndarray.</source>
          <target state="translated">1 차원 ndarray에서 빠른 가치 검색.</target>
        </trans-unit>
        <trans-unit id="a10b648a47a4d5e7cf7d74b1e50dcb4a6bd8b633" translate="yes" xml:space="preserve">
          <source>Fast lookup of value from 1-dimensional ndarray. Only use this if you know what you&amp;rsquo;re doing.</source>
          <target state="translated">1 차원 ndarray에서 빠른 가치 검색. 현재하고있는 일을 알고있는 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bd36642eb449b970a92b19f21c93bab36201657f" translate="yes" xml:space="preserve">
          <source>Fast scalar value getting and setting</source>
          <target state="translated">빠른 스칼라 값 가져 오기 및 설정</target>
        </trans-unit>
        <trans-unit id="36da1f60291065c6fc24d5741f89f6401195d25a" translate="yes" xml:space="preserve">
          <source>Fast shifting using the &lt;code&gt;shift&lt;/code&gt; method on pandas objects.</source>
          <target state="translated">pandas 개체 에서 &lt;code&gt;shift&lt;/code&gt; 방법을 사용하여 빠르게 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="4de292bd5560d050aa899dfa437d2faf6fcfb7e8" translate="yes" xml:space="preserve">
          <source>Fast writing/reading. Not-appendable, nor searchable</source>
          <target state="translated">빠른 쓰기 / 읽기. 추가 불가 및 검색 불가</target>
        </trans-unit>
        <trans-unit id="173bea418fbf0fa2f7bbd5ce089223701237b5e4" translate="yes" xml:space="preserve">
          <source>Faster than &lt;code&gt;.sort_values().head(n)&lt;/code&gt; for small</source>
          <target state="translated">보다 빠른 &lt;code&gt;.sort_values().head(n)&lt;/code&gt; 대한 소형</target>
        </trans-unit>
        <trans-unit id="99538d966c9294a32b99f0efc0badb2deba8a351" translate="yes" xml:space="preserve">
          <source>Faster than &lt;code&gt;.sort_values().head(n)&lt;/code&gt; for small &lt;code&gt;n&lt;/code&gt; relative to the size of the &lt;code&gt;Series&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 객체 의 크기에 비해 작은 &lt;code&gt;n&lt;/code&gt; 의 경우 &lt;code&gt;.sort_values().head(n)&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="afac290377288f0295ea44b55d47f15889846f80" translate="yes" xml:space="preserve">
          <source>Faster than &lt;code&gt;.sort_values(ascending=False).head(n)&lt;/code&gt; for small</source>
          <target state="translated">보다 빠른 &lt;code&gt;.sort_values(ascending=False).head(n)&lt;/code&gt; 대한 소형</target>
        </trans-unit>
        <trans-unit id="825fdb617ed6728a4a54a249658aec3f6835cd72" translate="yes" xml:space="preserve">
          <source>Faster than &lt;code&gt;.sort_values(ascending=False).head(n)&lt;/code&gt; for small &lt;code&gt;n&lt;/code&gt; relative to the size of the &lt;code&gt;Series&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 객체 의 크기에 비해 작은 &lt;code&gt;n&lt;/code&gt; 에 대해 &lt;code&gt;.sort_values(ascending=False).head(n)&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="0d9bf5551ad3e6450e13ede432ffe8987098c1fb" translate="yes" xml:space="preserve">
          <source>Feather</source>
          <target state="translated">Feather</target>
        </trans-unit>
        <trans-unit id="b0fdb754235635f8ea32eb98dd0e41c1153e1dba" translate="yes" xml:space="preserve">
          <source>Feather Format</source>
          <target state="translated">깃털 형식</target>
        </trans-unit>
        <trans-unit id="3b6756aaab93cc7e83b66ab195930a4e8dc51801" translate="yes" xml:space="preserve">
          <source>Feather is designed to faithfully serialize and de-serialize DataFrames, supporting all of the pandas dtypes, including extension dtypes such as categorical and datetime with tz.</source>
          <target state="translated">Feather는 DataFrames를 충실하게 직렬화 및 역 직렬화하도록 설계되어 범주 형 및 날짜 시간과 같은 확장형 dtype (tz 포함)을 포함하여 모든 pandas dtype을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c98089614faf4a2ece58e65c5d66c3c0d5a8cca8" translate="yes" xml:space="preserve">
          <source>Feather provides binary columnar serialization for data frames. It is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy.</source>
          <target state="translated">Feather는 데이터 프레임에 대한 이진 열 직렬화를 제공합니다. 데이터 프레임을 효율적으로 읽고 쓸 수 있도록 설계되었으며 데이터 분석 언어간에 데이터를 쉽게 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0bae807be9d78f92cf0d62e494d47b8de3238cc" translate="yes" xml:space="preserve">
          <source>Featuretools</source>
          <target state="translated">Featuretools</target>
        </trans-unit>
        <trans-unit id="1bd8f0c9372d96db7fc3b02fc7b5017c1b1fe9fc" translate="yes" xml:space="preserve">
          <source>Featuretools is a Python library for automated feature engineering built on top of pandas. It excels at transforming temporal and relational datasets into feature matrices for machine learning using reusable feature engineering &amp;ldquo;primitives&amp;rdquo;. Users can contribute their own primitives in Python and share them with the rest of the community.</source>
          <target state="translated">Featuretools는 팬더 위에 구축 된 자동화 된 기능 엔지니어링을위한 Python 라이브러리입니다. 재사용 가능한 피처 엔지니어링 &quot;프리미티브&quot;를 사용하여 기계 학습을위한 시간 및 관계형 데이터 세트를 피처 매트릭스로 변환하는 데 탁월합니다. 사용자는 Python에서 자신의 프리미티브를 제공하고 다른 커뮤니티와 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc5fc74a0c921be17dde1b381a9a43609da45dab" translate="yes" xml:space="preserve">
          <source>Fedora</source>
          <target state="translated">Fedora</target>
        </trans-unit>
        <trans-unit id="e37089c94eb8cb4b17ffb0dece5eb4de66357210" translate="yes" xml:space="preserve">
          <source>Feel free to ask questions on the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/pydata&quot;&gt;mailing list&lt;/a&gt; or on &lt;a href=&quot;https://gitter.im/pydata/pandas&quot;&gt;Gitter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/pydata&quot;&gt;메일 링리스트&lt;/a&gt; 나 &lt;a href=&quot;https://gitter.im/pydata/pandas&quot;&gt;Gitter&lt;/a&gt; 에 대해 질문하십시오 .</target>
        </trans-unit>
        <trans-unit id="a483d7df7ab24a937de2380a830b243ab62c3a2a" translate="yes" xml:space="preserve">
          <source>Feel free to skip it, unless you are familiar with the implementation of the algorithm, or you discover some counter-intuitive behavior while writing the examples for the function.</source>
          <target state="translated">알고리즘 구현에 익숙하지 않거나 함수에 대한 예제를 작성하는 동안 반 직관적 인 동작을 발견하지 않는 한 자유롭게 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="b7ea81880c7ea5074a817ce7e3f2f2fdbcfea6d9" translate="yes" xml:space="preserve">
          <source>Field delimiter.</source>
          <target state="translated">필드 구분 기호</target>
        </trans-unit>
        <trans-unit id="537a99a5583ab4fca05a8cb9d614bc5ab2272c0a" translate="yes" xml:space="preserve">
          <source>Field name to join on in left DataFrame.</source>
          <target state="translated">왼쪽 DataFrame에서 결합 할 필드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="09ce7cef8b0db07219e0a6af8f7d876b8cac156f" translate="yes" xml:space="preserve">
          <source>Field name to join on in right DataFrame.</source>
          <target state="translated">오른쪽 DataFrame에서 결합 할 필드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e2428bb9f4638e33864108df0c94759242ddf4ce" translate="yes" xml:space="preserve">
          <source>Field name to join on. Must be found in both DataFrames. The data MUST be ordered. Furthermore this must be a numeric column, such as datetimelike, integer, or float. On or left_on/right_on must be given.</source>
          <target state="translated">참여할 필드 이름입니다. 두 DataFrame 모두에 있어야합니다. 데이터는 반드시 주문해야합니다. 또한 datetimelike, integer 또는 float과 같은 숫자 열이어야합니다. On 또는 left_on / right_on이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9582e86f4774cdf2c342c747a46adc99527b29f4" translate="yes" xml:space="preserve">
          <source>Field names to join on in left DataFrame. Can be a vector or list of vectors of the length of the DataFrame to use a particular vector as the join key instead of columns</source>
          <target state="translated">왼쪽 DataFrame에서 결합 할 필드 이름입니다. 열 대신 결합 키로 특정 벡터를 사용하기 위해 DataFrame 길이의 벡터 또는 벡터 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58709c58ced1664cb805d040ee2292fcb677b9c0" translate="yes" xml:space="preserve">
          <source>Field names to join on in left DataFrame. Can be a vector or list of vectors of the length of the DataFrame to use a particular vector as the join key instead of columns.</source>
          <target state="translated">왼쪽 DataFrame에서 조인 할 필드 이름입니다. 특정 벡터를 열 대신 조인 키로 사용하기 위해 DataFrame 길이의 벡터 또는 벡터 목록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eba74cb6f01f4490a588ac70b9e868ab69dfb204" translate="yes" xml:space="preserve">
          <source>Field names to join on in right DataFrame or vector/list of vectors per left_on docs</source>
          <target state="translated">left_on 문서 당 오른쪽 DataFrame 또는 벡터 / 벡터 목록에서 결합 할 필드 이름</target>
        </trans-unit>
        <trans-unit id="350de40c47f3224884271b0f531823b5b6a271fa" translate="yes" xml:space="preserve">
          <source>Field names to join on in right DataFrame or vector/list of vectors per left_on docs.</source>
          <target state="translated">오른쪽 DataFrame 또는 left_on 문서 당 벡터 / 벡터 목록에서 조인 할 필드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0775d3111b928ff336ce0fae1112cd65453fb13f" translate="yes" xml:space="preserve">
          <source>Field names to join on. Must be found in both DataFrames.</source>
          <target state="translated">결합 할 필드 이름. 두 DataFrame 모두에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="387353364130ed6d443806b5a300456ac5e8ff91" translate="yes" xml:space="preserve">
          <source>Field names to match on in the left DataFrame.</source>
          <target state="translated">왼쪽 DataFrame에서 일치시킬 필드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7cc5b2b66482174b9fe56a7bbcc7ea8a9dc20f34" translate="yes" xml:space="preserve">
          <source>Field names to match on in the right DataFrame.</source>
          <target state="translated">오른쪽 DataFrame에서 일치시킬 필드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bdeae7c8dead1bbc7e71d424f6decb56f17dc0a5" translate="yes" xml:space="preserve">
          <source>Field of array to use as the index, alternately a specific set of input labels to use</source>
          <target state="translated">색인으로 사용할 배열 필드, 또는 사용할 특정 입력 레이블 세트</target>
        </trans-unit>
        <trans-unit id="b0fb6ba527e4e59b47a95ab446b49e9113056063" translate="yes" xml:space="preserve">
          <source>Field of array to use as the index, alternately a specific set of input labels to use.</source>
          <target state="translated">인덱스로 사용할 배열 필드, 또는 사용할 특정 입력 레이블 집합입니다.</target>
        </trans-unit>
        <trans-unit id="9f921bb637b152dee2457d31ff5ee759ea85df62" translate="yes" xml:space="preserve">
          <source>Fields to use as metadata for each record in resulting table.</source>
          <target state="translated">결과 테이블에서 각 레코드의 메타 데이터로 사용할 필드입니다.</target>
        </trans-unit>
        <trans-unit id="0c3a075dd5f38cadf6b9b7c5519436ae7fa103e1" translate="yes" xml:space="preserve">
          <source>Figure size in inches by default.</source>
          <target state="translated">기본적으로 인치 단위의 그림 크기입니다.</target>
        </trans-unit>
        <trans-unit id="2d459b24c0fff89729feac3cd99d5f9cc5bff4cb" translate="yes" xml:space="preserve">
          <source>File mode to use (write or append).</source>
          <target state="translated">사용할 파일 모드 (쓰기 또는 추가).</target>
        </trans-unit>
        <trans-unit id="ef330c6183dfa3dd3515d0720fff6b7d9dd0ef5e" translate="yes" xml:space="preserve">
          <source>File mode to use (write or append). Append does not work with fsspec URLs.</source>
          <target state="translated">사용할 파일 모드 (쓰기 또는 추가). 추가는 fsspec URL에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bf921970eeddb890ebff0d8792330c78a4638b9" translate="yes" xml:space="preserve">
          <source>File path or HDFStore object.</source>
          <target state="translated">파일 경로 또는 HDFStore 객체.</target>
        </trans-unit>
        <trans-unit id="f867daaac4e2cd95d46387c5829dc91e1389f80c" translate="yes" xml:space="preserve">
          <source>File path or Root Directory path. Will be used as Root Directory path while writing a partitioned dataset.</source>
          <target state="translated">파일 경로 또는 루트 디렉토리 경로. 파티션 된 데이터 세트를 쓰는 동안 루트 디렉토리 경로로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2d188c74673dc7f89a526316a160f1db07c29e" translate="yes" xml:space="preserve">
          <source>File path or existing ExcelWriter.</source>
          <target state="translated">파일 경로 또는 기존 ExcelWriter</target>
        </trans-unit>
        <trans-unit id="313b1148aa9528548af7998cfbba677fcabeb3b9" translate="yes" xml:space="preserve">
          <source>File path or object, if None is provided the result is returned as a string. If a file object is passed it should be opened with &lt;code&gt;newline=&amp;rsquo;&amp;lsquo;&lt;/code&gt;, disabling universal newlines.</source>
          <target state="translated">파일 경로 또는 객체 (없음이 제공되는 경우 결과는 문자열로 반환 됨) 파일 객체가 전달되면 &lt;code&gt;newline=&amp;rsquo;&amp;lsquo;&lt;/code&gt; 으로 열어서 개행 문자를 비활성화 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d67eaa07eecf81e15135eeaa544b3b8b8bffa17d" translate="yes" xml:space="preserve">
          <source>File path or object, if None is provided the result is returned as a string. If a non-binary file object is passed, it should be opened with</source>
          <target state="translated">None이 제공되면 파일 경로 또는 개체는 결과가 문자열로 반환됩니다. 바이너리가 아닌 파일 객체가 전달되면 다음으로 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="095f84ba38f5b35140a16b30636b5da81cd59592" translate="yes" xml:space="preserve">
          <source>File path or object. If not specified, the result is returned as a string.</source>
          <target state="translated">파일 경로 또는 객체. 지정하지 않으면 결과가 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="20e72ab0bf82ca97709211f07f6e7471fe8797f8" translate="yes" xml:space="preserve">
          <source>File path where the pickled object will be loaded.</source>
          <target state="translated">피클 링 된 객체가로드 될 파일 경로입니다.</target>
        </trans-unit>
        <trans-unit id="2e26c6c8f5ac7b5d57f95844c1203c4def0475be" translate="yes" xml:space="preserve">
          <source>File path where the pickled object will be stored.</source>
          <target state="translated">피클 된 객체가 저장 될 파일 경로.</target>
        </trans-unit>
        <trans-unit id="4eb88901451342cc556b63073f34bc645ba8a848" translate="yes" xml:space="preserve">
          <source>File path, URL, or buffer where the pickled object will be loaded from.</source>
          <target state="translated">피클 된 개체를로드 할 파일 경로, URL 또는 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="62fbca8d9970683097adf5d98619064d132fec07" translate="yes" xml:space="preserve">
          <source>File path.</source>
          <target state="translated">파일 경로.</target>
        </trans-unit>
        <trans-unit id="d6f7325e2e9e26c6794496761a7c8ce3147c1856" translate="yes" xml:space="preserve">
          <source>Files with a &lt;code&gt;.xls&lt;/code&gt; extension will be written using &lt;code&gt;xlwt&lt;/code&gt; and those with a &lt;code&gt;.xlsx&lt;/code&gt; extension will be written using &lt;code&gt;xlsxwriter&lt;/code&gt; (if available) or &lt;code&gt;openpyxl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.xls&lt;/code&gt; 확장자를 가진 파일은 &lt;code&gt;xlwt&lt;/code&gt; 를 사용하여 작성 되고 &lt;code&gt;.xlsx&lt;/code&gt; 확장자를 가진 파일은 &lt;code&gt;xlsxwriter&lt;/code&gt; (사용 가능한 경우) 또는 &lt;code&gt;openpyxl&lt;/code&gt; 을 사용하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3858e73b7fc30664a8ec7b0eb85a44bfea6211b9" translate="yes" xml:space="preserve">
          <source>Files with an &amp;ldquo;implicit&amp;rdquo; index column</source>
          <target state="translated">&quot;암시 적&quot;인덱스 열이있는 파일</target>
        </trans-unit>
        <trans-unit id="90f4f142c20f6d2cc2a4df24e090733d5de66367" translate="yes" xml:space="preserve">
          <source>Files with fixed width columns</source>
          <target state="translated">너비가 고정 된 열이있는 파일</target>
        </trans-unit>
        <trans-unit id="c143458416a8969726c2447a1c5e9f3bbef28e02" translate="yes" xml:space="preserve">
          <source>Fill 0&amp;rsquo;s</source>
          <target state="translated">0 채우기</target>
        </trans-unit>
        <trans-unit id="b351038351d12644063121e24b90ff37b41455d8" translate="yes" xml:space="preserve">
          <source>Fill NA values.</source>
          <target state="translated">NA 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b80990868950f517aa1173a925642b04f82ae8d3" translate="yes" xml:space="preserve">
          <source>Fill NA/NaN values using the specified method.</source>
          <target state="translated">지정된 방법을 사용하여 NA / NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="f3703dd475408f0afbbeb8a80210486a209db623" translate="yes" xml:space="preserve">
          <source>Fill NA/NaN values with the specified value</source>
          <target state="translated">NA / NaN 값을 지정된 값으로 채 웁니다</target>
        </trans-unit>
        <trans-unit id="c54389e04e9cf004d3212bd02d609d1328c2fc58" translate="yes" xml:space="preserve">
          <source>Fill NA/NaN values with the specified value.</source>
          <target state="translated">NA / NaN 값을 지정된 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="1ad281031358606ee50cddf44b1809b3875fd386" translate="yes" xml:space="preserve">
          <source>Fill NaN Values of a Series.</source>
          <target state="translated">계열의 NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="012f242cf29ad225c54b44a3d5b4edfd2db37cfa" translate="yes" xml:space="preserve">
          <source>Fill NaN values in the DataFrame using the specified method, which can be &amp;lsquo;backfill&amp;rsquo;.</source>
          <target state="translated">지정된 방법을 사용하여 DataFrame에서 NaN 값을 채우십시오 ( '백필'일 수 있음).</target>
        </trans-unit>
        <trans-unit id="620143528e7eeceab027f4c36491dbefd2ac6f7e" translate="yes" xml:space="preserve">
          <source>Fill NaN values in the DataFrame using the specified method, which can be &amp;lsquo;bfill&amp;rsquo; and &amp;lsquo;ffill&amp;rsquo;.</source>
          <target state="translated">지정된 메소드 ( 'bfill'및 'ffill')를 사용하여 DataFrame에서 NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b238ad9507ac3f809a2ab2e08a93025a62752747" translate="yes" xml:space="preserve">
          <source>Fill NaN values in the Series using the specified method, which can be &amp;lsquo;backfill&amp;rsquo;.</source>
          <target state="translated">지정된 방법을 사용하여 시리즈의 NaN 값을 채우십시오 ( '백필'일 수 있음).</target>
        </trans-unit>
        <trans-unit id="01169179363207d823dbfbfb25b9a2e49f9e7f71" translate="yes" xml:space="preserve">
          <source>Fill NaN values in the Series using the specified method, which can be &amp;lsquo;bfill&amp;rsquo; and &amp;lsquo;ffill&amp;rsquo;.</source>
          <target state="translated">지정된 방법을 사용하여 Series에서 NaN 값을 채 웁니다 ( 'bfill'및 'ffill').</target>
        </trans-unit>
        <trans-unit id="86b9680d33b50b90915060223dd79eff0fbc58de" translate="yes" xml:space="preserve">
          <source>Fill NaN values in the resampled data with nearest neighbor starting from center.</source>
          <target state="translated">리샘플링 된 데이터의 NaN 값을 중심에서 시작하여 가장 가까운 이웃으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="8a1d65b8070d271997fcc108e84c419d8da901ee" translate="yes" xml:space="preserve">
          <source>Fill NaN values of a DataFrame.</source>
          <target state="translated">DataFrame의 NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="845fb67b514306e502764974977b4e2cf3604a4c" translate="yes" xml:space="preserve">
          <source>Fill NaN values of a Series.</source>
          <target state="translated">시리즈의 NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="3bf2513d8f583f24d1cf18e4cbea6b7f8b346740" translate="yes" xml:space="preserve">
          <source>Fill NaN values using an interpolation method.</source>
          <target state="translated">보간 방법을 사용하여 NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="0d891bc00bafcca46ab866f09a35e42513e1ec32" translate="yes" xml:space="preserve">
          <source>Fill NaN values using interpolation.</source>
          <target state="translated">보간법을 사용하여 NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="5567118bdf70946310fb9b109d9c8aa5b86ffff1" translate="yes" xml:space="preserve">
          <source>Fill NaN values using the specified method, which can be &amp;lsquo;backfill&amp;rsquo;.</source>
          <target state="translated">지정된 방법을 사용하여 NaN 값을 채우십시오 ( '백필'일 수 있음).</target>
        </trans-unit>
        <trans-unit id="6476bed1e703a5e80152dbeb86e69facac82ba3f" translate="yes" xml:space="preserve">
          <source>Fill NaN values with nearest neighbor starting from center.</source>
          <target state="translated">중심에서 시작하여 가장 가까운 이웃으로 NaN 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="239b7e96bf370e9a8793ec17c8fc251ade8f48f5" translate="yes" xml:space="preserve">
          <source>Fill existing missing (NaN) values, and any new element needed for successful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing.</source>
          <target state="translated">기존의 누락 (NaN) 값과 성공적인 DataFrame 정렬에 필요한 새 요소를 계산하기 전에이 값으로 채 웁니다. 해당 DataFrame 위치의 데이터가 모두 없으면 결과가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="ff5b02c3c75844d33026b20638aeda4514267b08" translate="yes" xml:space="preserve">
          <source>Fill existing missing (NaN) values, and any new element needed for successful Series alignment, with this value before computation. If data in both corresponding Series locations is missing the result of filling (at that location) will be missing.</source>
          <target state="translated">계산 전에 기존 누락 (NaN) 값과 성공적인 계열 정렬에 필요한 새 요소를이 값으로 채 웁니다. 해당 시리즈 위치의 데이터가 누락 된 경우 해당 위치에서 채우기 결과가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="80c8a1f9c96c84f9010d65f2ca63bb4847e17255" translate="yes" xml:space="preserve">
          <source>Fill existing missing (NaN) values, and any new element needed for successful Series alignment, with this value before computation. If data in both corresponding Series locations is missing the result will be missing.</source>
          <target state="translated">기존 결 측값 (NaN) 값과 성공적인 시리즈 정렬에 필요한 새 요소를 계산하기 전에이 값으로 채 웁니다. 해당하는 두 시리즈 위치의 데이터가 없으면 결과가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="72cd3e10098966c27a2fceeb8935d7975d2c98bc" translate="yes" xml:space="preserve">
          <source>Fill forward a reversed timeseries</source>
          <target state="translated">반전 된 시계열을 앞으로 채우기</target>
        </trans-unit>
        <trans-unit id="86d9310e9c017c0a293c11fd233ec9441c4076d4" translate="yes" xml:space="preserve">
          <source>Fill from the nearest index value</source>
          <target state="translated">가장 가까운 인덱스 값에서 채우기</target>
        </trans-unit>
        <trans-unit id="8c7ce6d948d44dac6dfeaf8bf517f1c7d18be768" translate="yes" xml:space="preserve">
          <source>Fill missing values introduced by upsampling.</source>
          <target state="translated">업 샘플링으로 인해 누락 된 값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="f7d07b8d33cc2312853bed471ecde65638350c5b" translate="yes" xml:space="preserve">
          <source>Fill missing values using different methods.</source>
          <target state="translated">다른 방법으로 결 측값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="dd6b45ab7ba3a6ee1147e740d05c4d0e23098774" translate="yes" xml:space="preserve">
          <source>Fill the DataFrame forward (that is, going down) along each column using linear interpolation.</source>
          <target state="translated">선형 보간을 사용하여 각 열을 따라 DataFrame을 앞으로 (즉, 아래로) 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="af2e73645aaaa37322817e31676e49792ea4dd15" translate="yes" xml:space="preserve">
          <source>Fill value for missing values.</source>
          <target state="translated">결 측값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="0286d23f77f50d8f5b13da8c7eaa2450be65daf5" translate="yes" xml:space="preserve">
          <source>Fill value for missing values. The default depends on dtype of the array. For object-dtype, &lt;code&gt;numpy.nan&lt;/code&gt; is used. For &lt;code&gt;StringDtype&lt;/code&gt;, &lt;code&gt;pandas.NA&lt;/code&gt; is used.</source>
          <target state="translated">결 측값에 대한 값을 채 웁니다. 기본값은 배열의 dtype에 따라 다릅니다. object-dtype의 경우 &lt;code&gt;numpy.nan&lt;/code&gt; 이 사용됩니다. 들어 &lt;code&gt;StringDtype&lt;/code&gt; , &lt;code&gt;pandas.NA&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b3c8650c44d3c0d5fac3904c2f1523aed116809" translate="yes" xml:space="preserve">
          <source>Fill value to use for NA-indices when</source>
          <target state="translated">NA- 인덱스에 사용할 값을 채우십시오.</target>
        </trans-unit>
        <trans-unit id="0509ef51947892cfb19b054f43ccc493d4b39614" translate="yes" xml:space="preserve">
          <source>Fill value to use for NA-indices when &lt;code&gt;allow_fill&lt;/code&gt; is True. This may be &lt;code&gt;None&lt;/code&gt;, in which case the default NA value for the type, &lt;code&gt;self.dtype.na_value&lt;/code&gt;, is used.</source>
          <target state="translated">&lt;code&gt;allow_fill&lt;/code&gt; 이 True 인 경우 NA 표시에 사용할 채우기 값 입니다. 이것은 &lt;code&gt;None&lt;/code&gt; 일 수 있으며 ,이 경우 &lt;code&gt;self.dtype.na_value&lt;/code&gt; 유형의 기본 NA 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="54d21db00ae179eebc6fa2f0769d5a8cc8da4b3a" translate="yes" xml:space="preserve">
          <source>Fill values backward</source>
          <target state="translated">값을 뒤로 채우기</target>
        </trans-unit>
        <trans-unit id="e253680a84dd7a1be68722647a844b23bac65289" translate="yes" xml:space="preserve">
          <source>Fill values forward</source>
          <target state="translated">값을 앞으로 채우기</target>
        </trans-unit>
        <trans-unit id="acec370e9c2d1616314d788ad14ea433b2c5ee3f" translate="yes" xml:space="preserve">
          <source>Filling NAs within groups with a value derived from each group.</source>
          <target state="translated">그룹 내 NA를 각 그룹에서 파생 된 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="fae1b11e487a49cc3f500a364d8b93960e2c5f23" translate="yes" xml:space="preserve">
          <source>Filling axis, method and limit</source>
          <target state="translated">충전 축, 방법 및 한계</target>
        </trans-unit>
        <trans-unit id="2bc4fc692f3ae5787d1519710e12a362f206d7bc" translate="yes" xml:space="preserve">
          <source>Filling axis, method and limit.</source>
          <target state="translated">채우기 축, 방법 및 한계.</target>
        </trans-unit>
        <trans-unit id="2b2b64e4d6ffbf59c3c8ba2a743cda3ed72b4ec7" translate="yes" xml:space="preserve">
          <source>Filling forward / backward</source>
          <target state="translated">앞으로 / 뒤로 채우기</target>
        </trans-unit>
        <trans-unit id="720f8435075e534272838f7737e56f06a0e89d75" translate="yes" xml:space="preserve">
          <source>Filling in &lt;code&gt;NaN&lt;/code&gt; in a &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; via linear interpolation.</source>
          <target state="translated">채우기 &lt;code&gt;NaN&lt;/code&gt; 의 (A)에 &lt;a href=&quot;pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 의 선형 보간을 통해.</target>
        </trans-unit>
        <trans-unit id="364da3468aeaddc67bdf9a029fb9bfada31d4104" translate="yes" xml:space="preserve">
          <source>Filling in &lt;code&gt;NaN&lt;/code&gt; in a Series by padding, but filling at most two consecutive &lt;code&gt;NaN&lt;/code&gt; at a time.</source>
          <target state="translated">패딩으로 시리즈 에서 &lt;code&gt;NaN&lt;/code&gt; 을 채우지 만 한 번에 최대 두 개의 연속 &lt;code&gt;NaN&lt;/code&gt; 을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="36dae5bd5ff9735cf59567c6eecb5edf838f9c67" translate="yes" xml:space="preserve">
          <source>Filling in &lt;code&gt;NaN&lt;/code&gt; in a Series via polynomial interpolation or splines: Both &amp;lsquo;polynomial&amp;rsquo; and &amp;lsquo;spline&amp;rsquo; methods require that you also specify an &lt;code&gt;order&lt;/code&gt; (int).</source>
          <target state="translated">다항식 보간 또는 스플라인을 통해 시리즈 에서 &lt;code&gt;NaN&lt;/code&gt; 채우기 : '다항식'과 '스플라인'방법 모두 &lt;code&gt;order&lt;/code&gt; (int) 도 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba7ba42d91a9f6fdb44216bf2581a321997de5cd" translate="yes" xml:space="preserve">
          <source>Filling left and right side of strings in the Series/Index with an additional character.</source>
          <target state="translated">시리즈 / 인덱스에서 문자열의 왼쪽과 오른쪽을 추가 문자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="5cf0129732b2592d4bc9cbea905a0fdc8181a407" translate="yes" xml:space="preserve">
          <source>Filling left and right side of strings in the Series/Index with an additional character. Equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.center&quot;&gt;&lt;code&gt;str.center()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시리즈 / 인덱스에서 문자열의 왼쪽과 오른쪽을 추가 문자로 채 웁니다. &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.center&quot;&gt; &lt;code&gt;str.center()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="811887a667f91303bfe683ebc5d89c25b8a758b9" translate="yes" xml:space="preserve">
          <source>Filling left side of strings in the Series/Index with an additional character.</source>
          <target state="translated">시리즈 / 인덱스에서 문자열의 왼쪽을 추가 문자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="8c736ad6780ac3ac80ef59b551cb3689cad0a107" translate="yes" xml:space="preserve">
          <source>Filling left side of strings in the Series/Index with an additional character. Equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.rjust&quot;&gt;&lt;code&gt;str.rjust()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시리즈 / 인덱스에서 문자열의 왼쪽을 추가 문자로 채 웁니다. &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.rjust&quot;&gt; &lt;code&gt;str.rjust()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ad05a0f0992418b05509080d6ac6f73afcab4e55" translate="yes" xml:space="preserve">
          <source>Filling method for upsampling.</source>
          <target state="translated">업 샘플링을위한 충전 방법.</target>
        </trans-unit>
        <trans-unit id="cff5861e1c1bd4e37340b1fd2f56e5b678207829" translate="yes" xml:space="preserve">
          <source>Filling missing data.</source>
          <target state="translated">누락 된 데이터 채우기.</target>
        </trans-unit>
        <trans-unit id="a71ddf48e5fc87844cc9033e90535193556eea1a" translate="yes" xml:space="preserve">
          <source>Filling missing values: fillna</source>
          <target state="translated">결 측값 채우기 : fillna</target>
        </trans-unit>
        <trans-unit id="591c633fe1e0c4843a77818a3d273b2e5108eee5" translate="yes" xml:space="preserve">
          <source>Filling right side of strings in the Series/Index with an additional character.</source>
          <target state="translated">추가 문자로 시리즈 / 인덱스에서 문자열의 오른쪽을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="ac10402a9e5bce560522e238f305710fdc6b5048" translate="yes" xml:space="preserve">
          <source>Filling right side of strings in the Series/Index with an additional character. Equivalent to &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.ljust&quot;&gt;&lt;code&gt;str.ljust()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추가 문자로 시리즈 / 인덱스에서 문자열의 오른쪽을 채 웁니다. &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str.ljust&quot;&gt; &lt;code&gt;str.ljust()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3ee97f787d3462513e1a2aee066d2f58a29dc6b5" translate="yes" xml:space="preserve">
          <source>Filling while reindexing</source>
          <target state="translated">재 인덱싱 중 채우기</target>
        </trans-unit>
        <trans-unit id="0549c496a7ed86749b9c184bc8c5c01522d73491" translate="yes" xml:space="preserve">
          <source>Filling with a PandasObject</source>
          <target state="translated">PandasObject로 채우기</target>
        </trans-unit>
        <trans-unit id="ea1a798c1780f4c5c4d6d36025c673cb49dac498" translate="yes" xml:space="preserve">
          <source>Fills both sides of strings with an arbitrary character.</source>
          <target state="translated">문자열의 양쪽을 임의의 문자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a27c90ebe348dfe3ffc211ea99ea0a48a752f8e5" translate="yes" xml:space="preserve">
          <source>Fills both sides of strings with an arbitrary character. Equivalent to &lt;code&gt;Series.str.pad(side='both')&lt;/code&gt;.</source>
          <target state="translated">문자열의 양쪽을 임의의 문자로 채 웁니다. &lt;code&gt;Series.str.pad(side='both')&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="dc550ee2845042f5e8d1ff1a04a41f75b5f1c5bf" translate="yes" xml:space="preserve">
          <source>Fills boths sides of strings with an arbitrary character.</source>
          <target state="translated">문자열의 양쪽을 임의의 문자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a3790f1af6bf86ff119f3eca7c76b2154b52e604" translate="yes" xml:space="preserve">
          <source>Fills boths sides of strings with an arbitrary character. Equivalent to &lt;code&gt;Series.str.pad(side='both')&lt;/code&gt;.</source>
          <target state="translated">문자열의 양쪽을 임의의 문자로 채 웁니다. 상당 &lt;code&gt;Series.str.pad(side='both')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a43da16217d034e574ff066c3012d9cdf0c66f8" translate="yes" xml:space="preserve">
          <source>Fills the left side of strings with an arbitrary character.</source>
          <target state="translated">문자열의 왼쪽을 임의의 문자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="106ddad8573bd02a956a989c9742c39ceb29806f" translate="yes" xml:space="preserve">
          <source>Fills the left side of strings with an arbitrary character. Equivalent to &lt;code&gt;Series.str.pad(side='left')&lt;/code&gt;.</source>
          <target state="translated">문자열의 왼쪽을 임의의 문자로 채 웁니다. 상당 &lt;code&gt;Series.str.pad(side='left')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a9279066cf35c7e73adb2878aaafa11b9de5d8" translate="yes" xml:space="preserve">
          <source>Fills the right side of strings with an arbitrary character.</source>
          <target state="translated">문자열의 오른쪽을 임의의 문자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="05003d915ba13fb5621018480e37ff2d17c1e5a5" translate="yes" xml:space="preserve">
          <source>Fills the right side of strings with an arbitrary character. Equivalent to &lt;code&gt;Series.str.pad(side='right')&lt;/code&gt;.</source>
          <target state="translated">문자열의 오른쪽을 임의의 문자로 채 웁니다. 상당 &lt;code&gt;Series.str.pad(side='right')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e5b8b3cd17ff18d6b2b9386a1b1dbb0a2f5d05a" translate="yes" xml:space="preserve">
          <source>Fills the specified sides of strings with an arbitrary character.</source>
          <target state="translated">문자열의 지정된면을 임의의 문자로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="92bdbda9547944933870b63744d2169ce82e2877" translate="yes" xml:space="preserve">
          <source>Filter out data based on the group sum or mean.</source>
          <target state="translated">그룹 합계 또는 평균을 기준으로 데이터를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="da1af3c6a70664b7e6ab7a3eb382cfa0f8496e18" translate="yes" xml:space="preserve">
          <source>Filtering columns (&lt;code&gt;usecols&lt;/code&gt;)</source>
          <target state="translated">열 필터링 ( &lt;code&gt;usecols&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a47ab8dd25aa5491b5bbc68a53a2862ea544de05" translate="yes" xml:space="preserve">
          <source>Filtering columns (usecols)</source>
          <target state="translated">열 필터링 (usecols)</target>
        </trans-unit>
        <trans-unit id="e24c8deea492863000f12c08bc2a43031bf33c9b" translate="yes" xml:space="preserve">
          <source>Filtering in SAS is done with an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; statement, on one or more columns.</source>
          <target state="translated">SAS에서 필터링은 하나 이상의 열에서 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; 문으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ceb04aaab45b86e456bdfc93c82ee8e289159f8" translate="yes" xml:space="preserve">
          <source>Filtering in SQL is done via a WHERE clause.</source>
          <target state="translated">SQL에서 필터링은 WHERE 절을 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5eb30ddec11231f97abc85b225208163f15fac" translate="yes" xml:space="preserve">
          <source>Filtering in Stata is done with an &lt;code&gt;if&lt;/code&gt; clause on one or more columns.</source>
          <target state="translated">Stata에서의 필터링은 하나 이상의 열에서 &lt;code&gt;if&lt;/code&gt; 절을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba995512865f28b893456e50621f593eb7467d9e" translate="yes" xml:space="preserve">
          <source>Filtration</source>
          <target state="translated">Filtration</target>
        </trans-unit>
        <trans-unit id="b87bbcc9bdc114b91d0f24808ac097e2ca40421a" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; takes an argument &lt;code&gt;raw&lt;/code&gt; which is False by default, which converts each row or column into a Series before applying the function. When set to True, the passed function will instead receive an ndarray object, which has positive performance implications if you do not need the indexing functionality.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;../reference/api/pandas.dataframe.apply#pandas.DataFrame.apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; 는 기본적으로 False 인 &lt;code&gt;raw&lt;/code&gt; 인자를 취하며 , 함수를 적용하기 전에 각 행이나 열을 Series로 변환합니다. True로 설정하면 전달 된 함수는 대신 인덱싱 기능이 필요하지 않은 경우 성능에 긍정적 인 영향을주는 ndarray 객체를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="5dc208187b90ce718333f5acde9494b691e98374" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;../reference/api/pandas.series.rename#pandas.Series.rename&quot;&gt;&lt;code&gt;rename()&lt;/code&gt;&lt;/a&gt; also accepts a scalar or list-like for altering the &lt;code&gt;Series.name&lt;/code&gt; attribute.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;../reference/api/pandas.series.rename#pandas.Series.rename&quot;&gt; &lt;code&gt;rename()&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Series.name&lt;/code&gt; 속성 을 변경하기 위해 스칼라 또는 목록과 유사한 것을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="438e35bbd0819a6546277d92c231dafcfbc83738" translate="yes" xml:space="preserve">
          <source>Finally, Pandas has arrays that mostly overlap with NumPy</source>
          <target state="translated">마지막으로 Pandas에는 NumPy와 주로 겹치는 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="264e0b36e24059eef44455ffc6e4194b118e326e" translate="yes" xml:space="preserve">
          <source>Finally, arbitrary objects may be stored using the &lt;code&gt;object&lt;/code&gt; dtype, but should be avoided to the extent possible (for performance and interoperability with other libraries and methods. See &lt;a href=&quot;#basics-object-conversion&quot;&gt;object conversion&lt;/a&gt;).</source>
          <target state="translated">마지막으로, 임의의 개체는 &lt;code&gt;object&lt;/code&gt; dtype을 사용하여 저장할 수 있지만 가능한 한 피해야합니다 (성능 및 다른 라이브러리 및 메서드와의 상호 운용성을 위해. &lt;a href=&quot;#basics-object-conversion&quot;&gt;개체 변환&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e315058264895db88de5355ba1090da9b3b66ca2" translate="yes" xml:space="preserve">
          <source>Finally, as a small note on performance, because the &lt;code&gt;take&lt;/code&gt; method handles a narrower range of inputs, it can offer performance that is a good deal faster than fancy indexing.</source>
          <target state="translated">마지막으로 성능에 대한 작은 참고 사항으로 &lt;code&gt;take&lt;/code&gt; 메서드는 더 좁은 범위의 입력을 처리하므로 고급 인덱싱보다 훨씬 빠른 성능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="074f531bafa15bb6667d0794076638395257fdec" translate="yes" xml:space="preserve">
          <source>Finally, commit your changes to your local repository with an explanatory message. &lt;em&gt;Pandas&lt;/em&gt; uses a convention for commit message prefixes and layout. Here are some common prefixes along with general guidelines for when to use them:</source>
          <target state="translated">마지막으로, 설명 메시지와 함께 변경 사항을 로컬 저장소에 커미트하십시오. &lt;em&gt;Pandas&lt;/em&gt; 는 커밋 메시지 접두사 및 레이아웃에 규칙을 사용합니다. 다음은 일반적인 접두사와 함께 사용시기에 대한 일반 지침입니다.</target>
        </trans-unit>
        <trans-unit id="7a3a2030544dc52fa263a10f8f42aa1943fab2a3" translate="yes" xml:space="preserve">
          <source>Finally, make the pull request</source>
          <target state="translated">마지막으로, 풀 요청을</target>
        </trans-unit>
        <trans-unit id="c55f8ca064057cf200a19007d9d9666c9fba515b" translate="yes" xml:space="preserve">
          <source>Finally, one can also add margins or normalize this output.</source>
          <target state="translated">마지막으로 여백을 추가하거나이 출력을 정규화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ddb11fd4bf1b481b4431a731120594f2f960ed" translate="yes" xml:space="preserve">
          <source>Finally, one can also set a seed for &lt;code&gt;sample&lt;/code&gt;&amp;rsquo;s random number generator using the &lt;code&gt;random_state&lt;/code&gt; argument, which will accept either an integer (as a seed) or a NumPy RandomState object.</source>
          <target state="translated">마지막으로 &lt;code&gt;random_state&lt;/code&gt; 인수를 사용하여 &lt;code&gt;sample&lt;/code&gt; 의 난수 생성기에 대한 시드를 설정할 수도 있습니다.이 인수는 정수 (시드로) 또는 NumPy RandomState 객체를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="33c5b02a41a918e027be13f64b63bb5bbc6d912f" translate="yes" xml:space="preserve">
          <source>Finally, the</source>
          <target state="translated">마지막으로</target>
        </trans-unit>
        <trans-unit id="27fa23c49ed3ebd21d5b1052a32ea64c21623944" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;escape&lt;/code&gt; argument allows you to control whether the &amp;ldquo;&amp;lt;&amp;rdquo;, &amp;ldquo;&amp;gt;&amp;rdquo; and &amp;ldquo;&amp;amp;&amp;rdquo; characters escaped in the resulting HTML (by default it is &lt;code&gt;True&lt;/code&gt;). So to get the HTML without escaped characters pass &lt;code&gt;escape=False&lt;/code&gt;</source>
          <target state="translated">마지막으로 &lt;code&gt;escape&lt;/code&gt; 인수를 사용하면 결과 HTML에서 &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;및 &quot;&amp;amp;&quot;문자가 이스케이프되는지 여부를 제어 할 수 있습니다 (기본적으로 &lt;code&gt;True&lt;/code&gt; ). 따라서 이스케이프 문자없이 HTML을 얻으려면 &lt;code&gt;escape=False&lt;/code&gt; 를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="921496f8a7db5c07ef7a944cc63cfb57c8926a84" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;ind&lt;/code&gt; parameter determines the evaluation points for the plot of the estimated PDF:</source>
          <target state="translated">마지막으로, &lt;code&gt;ind&lt;/code&gt; 매개 변수는 예상 PDF의 플롯에 대한 평가 지점을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1e31010aba724179340c4913069038c29972241b" translate="yes" xml:space="preserve">
          <source>Finally, the combination of &lt;code&gt;TimedeltaIndex&lt;/code&gt; with &lt;code&gt;DatetimeIndex&lt;/code&gt; allow certain combination operations that are NaT preserving:</source>
          <target state="translated">마지막으로 &lt;code&gt;TimedeltaIndex&lt;/code&gt; 와 &lt;code&gt;DatetimeIndex&lt;/code&gt; 의 조합은 NaT를 유지하는 특정 조합 작업을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9128d56448c5b7e9d9b85e85dcc6a217e0b59284" translate="yes" xml:space="preserve">
          <source>Finally, the input shapes matched. &lt;code&gt;Styler.applymap&lt;/code&gt; calls the function on each scalar input, and the function returns a scalar output.</source>
          <target state="translated">마지막으로 입력 모양이 일치했습니다. &lt;code&gt;Styler.applymap&lt;/code&gt; 은 각 스칼라 입력에서 함수를 호출 하고이 함수는 스칼라 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12f54b9b3b005a26c7c2ecc0c6daee2dfcf87447" translate="yes" xml:space="preserve">
          <source>Finally, the parser allows you to specify a custom &lt;code&gt;date_parser&lt;/code&gt; function to take full advantage of the flexibility of the date parsing API:</source>
          <target state="translated">마지막으로 파서는 날짜 파싱 API의 유연성을 최대한 활용하기 위해 사용자 지정 &lt;code&gt;date_parser&lt;/code&gt; 함수 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd1aa781f50f23e164927e65d59ce22a68a3edf2" translate="yes" xml:space="preserve">
          <source>Finally, the string alias &lt;code&gt;'Sparse[dtype]'&lt;/code&gt; may be used to specify a sparse dtype in many places</source>
          <target state="translated">마지막으로 문자열 별칭 &lt;code&gt;'Sparse[dtype]'&lt;/code&gt; 사용하여 여러 위치에서 희소 dtype을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba35679e402eac43d8224a5f31102d8e499a8f05" translate="yes" xml:space="preserve">
          <source>Finally, there are several &lt;a href=&quot;#visualization-tools&quot;&gt;plotting functions&lt;/a&gt; in &lt;code&gt;pandas.plotting&lt;/code&gt; that take a &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; as an argument. These include:</source>
          <target state="translated">마지막으로, 몇 가지가 있습니다 &lt;a href=&quot;#visualization-tools&quot;&gt;플로팅 기능&lt;/a&gt; 에 &lt;code&gt;pandas.plotting&lt;/code&gt; 테이크 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 를&lt;/a&gt; 인수로가. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7a177fd3fdc0105bc609d6b76a9d9bb3bc50eb75" translate="yes" xml:space="preserve">
          <source>Finally, this strategy will work with the other &lt;code&gt;pd.read_*(...)&lt;/code&gt; functions described in the &lt;a href=&quot;io#io&quot;&gt;io docs&lt;/a&gt;.</source>
          <target state="translated">마지막으로이 전략은 &lt;a href=&quot;io#io&quot;&gt;io 문서에&lt;/a&gt; 설명 된 다른 &lt;code&gt;pd.read_*(...)&lt;/code&gt; 함수 와 함께 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5590c4de9e78bd5ff9604091f19c548b7d153de1" translate="yes" xml:space="preserve">
          <source>Finally, we expect certain styling functions to be common enough that we&amp;rsquo;ve included a few &amp;ldquo;built-in&amp;rdquo; to the &lt;code&gt;Styler&lt;/code&gt;, so you don&amp;rsquo;t have to write them yourself.</source>
          <target state="translated">마지막으로, &lt;code&gt;Styler&lt;/code&gt; 에 몇 가지 &quot;내장&quot;기능을 포함 할 수 있도록 특정 스타일링 기능이 공통적 일 것으로 예상 하므로 직접 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="461e01cebb09ff495c3966513426443f9e44b706" translate="yes" xml:space="preserve">
          <source>Financial analysis in Python, by Thomas Wiecki</source>
          <target state="translated">Thomas Wiecki의 Python의 재무 분석</target>
        </trans-unit>
        <trans-unit id="43c7f2b66340b9f72da6f9ec397c5d793b7efc1c" translate="yes" xml:space="preserve">
          <source>Find all occurrences of pattern or regular expression in the Series/Index.</source>
          <target state="translated">시리즈 / 인덱스에서 모든 패턴 또는 정규식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="18d914d41d09d92c97e462c896bc6019f8705e89" translate="yes" xml:space="preserve">
          <source>Find indices where elements should be inserted to maintain order.</source>
          <target state="translated">순서를 유지하기 위해 요소를 삽입해야하는 인덱스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="e30620e483ba6d26d7ecfd6f8ec89e0c35c0173a" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted Index</source>
          <target state="translated">정렬 된 인덱스로 인덱스 찾기</target>
        </trans-unit>
        <trans-unit id="6777ff2908c662d8b35b2bcc5a8eff61cbc5d874" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted Index &lt;code&gt;self&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;value&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;self&lt;/code&gt; would be preserved.</source>
          <target state="translated">정렬 된 인덱스 &lt;code&gt;self&lt;/code&gt; 에서 인덱스를 찾아 해당 &lt;code&gt;value&lt;/code&gt; 의 해당 요소가 인덱스 앞에 삽입 된 경우 &lt;code&gt;self&lt;/code&gt; 순서를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="d6b6454cea2b0b1249b955dfb60fef8f47683f20" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted Series</source>
          <target state="translated">정렬 된 시리즈로 인덱스 찾기</target>
        </trans-unit>
        <trans-unit id="4aa6ebd8fbaddbd5838a4bb02aa91f7c9b8903dc" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted Series &lt;code&gt;self&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;value&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;self&lt;/code&gt; would be preserved.</source>
          <target state="translated">정렬 된 시리즈 &lt;code&gt;self&lt;/code&gt; 에서 인덱스를 찾아 해당 &lt;code&gt;value&lt;/code&gt; 의 해당 요소가 인덱스 앞에 삽입 된 경우 &lt;code&gt;self&lt;/code&gt; 순서 가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="947c1baad68b85d33786979f083cccc1ae161347" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array</source>
          <target state="translated">정렬 된 배열로 인덱스 찾기</target>
        </trans-unit>
        <trans-unit id="716dfeeb0123c5721590db33ec916189d656c0ff" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array &lt;code&gt;self&lt;/code&gt; (a) such that, if the corresponding elements in &lt;code&gt;value&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;self&lt;/code&gt; would be preserved.</source>
          <target state="translated">정렬 된 배열 &lt;code&gt;self&lt;/code&gt; (a) 에서 인덱스를 찾아 해당 &lt;code&gt;value&lt;/code&gt; 의 해당 요소가 인덱스 앞에 삽입 된 경우 &lt;code&gt;self&lt;/code&gt; 의 순서 가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e7b76997622a184c319f0f4883cd439078e1c8b3" translate="yes" xml:space="preserve">
          <source>Find the locations (indices) of the labels from the index for every entry in the &lt;code&gt;where&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 인수의 모든 항목에 대한 색인에서 레이블의 위치 (표시)를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="517a7893ed2a96fe5193cf1a0eb7e6e9f21aa5c8" translate="yes" xml:space="preserve">
          <source>Find the unique value in an array.</source>
          <target state="translated">배열에서 고유 한 값을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="bb9ce9325a8828ae6caeb2fdb3fe7c3703913154" translate="yes" xml:space="preserve">
          <source>Finer Control: Display Values</source>
          <target state="translated">더 세밀한 제어 : 표시 값</target>
        </trans-unit>
        <trans-unit id="71a6e6a60e22fb8666833e481ab865cee9d2db5a" translate="yes" xml:space="preserve">
          <source>Finer control: slicing</source>
          <target state="translated">세밀한 제어 : 슬라이싱</target>
        </trans-unit>
        <trans-unit id="b74bdee9c34f37b6b9b0d20a8ca8a9bf6797f6e1" translate="yes" xml:space="preserve">
          <source>Finish</source>
          <target state="translated">Finish</target>
        </trans-unit>
        <trans-unit id="8527da08fc06bc9a94667e594a3fbac56fdfd9fb" translate="yes" xml:space="preserve">
          <source>First DataFrame to compare.</source>
          <target state="translated">비교할 첫 번째 DataFrame입니다.</target>
        </trans-unit>
        <trans-unit id="cf3c09cc589a3fe214655be233df3ffc15dc338e" translate="yes" xml:space="preserve">
          <source>First differences of the Series.</source>
          <target state="translated">시리즈의 첫 번째 차이점.</target>
        </trans-unit>
        <trans-unit id="cc8761f1ada728e18a7ee585c85d0cb9a47387bd" translate="yes" xml:space="preserve">
          <source>First discrete difference for a Series.</source>
          <target state="translated">시리즈의 첫 번째 이산 차이.</target>
        </trans-unit>
        <trans-unit id="682b4cf0861faa16a4ac787fd346894847d9b0d2" translate="yes" xml:space="preserve">
          <source>First discrete difference of element.</source>
          <target state="translated">요소의 첫 번째 이산 차이.</target>
        </trans-unit>
        <trans-unit id="457429c2078f20369b179701540ca68b6ea144e4" translate="yes" xml:space="preserve">
          <source>First discrete difference of object.</source>
          <target state="translated">물체의 첫 번째 이산 차이.</target>
        </trans-unit>
        <trans-unit id="a1105d718a6f7fb0bb3a2d17c942d8d1d3df3280" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s create a few decent-sized arrays to play with:</source>
          <target state="translated">먼저 적절한 크기의 배열을 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="df437b3e25df298d58bd8402e83550074ea9777a" translate="yes" xml:space="preserve">
          <source>First level of index to be swapped. Can pass level name as string. Type of parameters can be mixed.</source>
          <target state="translated">교환 될 인덱스의 첫 번째 레벨. 레벨 이름을 문자열로 전달할 수 있습니다. 매개 변수 유형을 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c605e6eb57ef134dfbf7f99647bb37b571e192ff" translate="yes" xml:space="preserve">
          <source>First some setup:</source>
          <target state="translated">먼저 몇 가지 설정 :</target>
        </trans-unit>
        <trans-unit id="5edd2a3124b74c24600512185419ac19a7013408" translate="yes" xml:space="preserve">
          <source>First we&amp;rsquo;re going to need to import the Cython magic function to IPython:</source>
          <target state="translated">먼저 Cython 매직 함수를 IPython으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="86829af109eeb1096386b337d9177676af1fb4a1" translate="yes" xml:space="preserve">
          <source>First we&amp;rsquo;re going to need to import the Cython magic function to ipython:</source>
          <target state="translated">먼저 Cython 매직 함수를 ipython으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="1202c2eab1bf3d61d38baddda864a5fd6c924cd8" translate="yes" xml:space="preserve">
          <source>First you will need &lt;a href=&quot;http://conda.pydata.org/docs/&quot;&gt;Conda&lt;/a&gt; to be installed and downloading and running the &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda&lt;/a&gt; will do this for you. The installer &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;can be found here&lt;/a&gt;</source>
          <target state="translated">먼저이 필요합니다 &lt;a href=&quot;http://conda.pydata.org/docs/&quot;&gt;CONDA가&lt;/a&gt; 설치 및 다운로드하고 실행하는 &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;Miniconda가&lt;/a&gt; 당신을 위해 이것을 할 것입니다. 설치 프로그램 &lt;a href=&quot;http://conda.pydata.org/miniconda.html&quot;&gt;은 여기에서 찾을 수 있습니다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e870e97435bbfd7c4b54ed2489fc4d8538372cf3" translate="yes" xml:space="preserve">
          <source>First, if</source>
          <target state="translated">먼저</target>
        </trans-unit>
        <trans-unit id="50022a74ee1f6e5c624643417ead03bbbbc7d9b0" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;to_replace&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; are both lists, they &lt;strong&gt;must&lt;/strong&gt; be the same length.</source>
          <target state="translated">경우 첫째, &lt;code&gt;to_replace&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 두 목록은, 그들이 &lt;strong&gt;있어야&lt;/strong&gt; 같은 길이.</target>
        </trans-unit>
        <trans-unit id="5bde2018e88f23e5d556a11f4266a70473c45311" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s create a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; with a slew of different dtypes:</source>
          <target state="translated">먼저 다양한 dtype을 사용하여 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 을 만들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b043a0b10b92a4156dd017939831dc8b187e8858" translate="yes" xml:space="preserve">
          <source>First, you need to have a development environment to be able to build pandas (see the docs on &lt;a href=&quot;#contributing-dev-env&quot;&gt;creating a development environment above&lt;/a&gt;).</source>
          <target state="translated">먼저 팬더를 만들 수있는 개발 환경이 있어야합니다 ( &lt;a href=&quot;#contributing-dev-env&quot;&gt;위의 개발 환경 작성에 대한&lt;/a&gt; 문서 참조 ).</target>
        </trans-unit>
        <trans-unit id="6f4b61624a356e1d2a6d854c09b3e6ab5a6038cd" translate="yes" xml:space="preserve">
          <source>Fiscal year the Period lies in according to its starting-quarter.</source>
          <target state="translated">회계 연도는 시작 분기에 따른 기간입니다.</target>
        </trans-unit>
        <trans-unit id="a921a07410d343d8af5d9edc4954e39ceb63a08f" translate="yes" xml:space="preserve">
          <source>Fixed format</source>
          <target state="translated">고정 형식</target>
        </trans-unit>
        <trans-unit id="a3a2293595d64a9075a54da78eadb9c323aa1782" translate="yes" xml:space="preserve">
          <source>Fixed format. Fast writing/reading. Not-appendable, nor searchable.</source>
          <target state="translated">고정 형식. 빠른 쓰기 / 읽기. 추가하거나 검색 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="096429582412b5dd03edcf30fb0fba792136ba19" translate="yes" xml:space="preserve">
          <source>Fixed-Width Text File</source>
          <target state="translated">고정 너비 텍스트 파일</target>
        </trans-unit>
        <trans-unit id="58a760bff0046a4aa7f02ffceb04f7cca96f1c46" translate="yes" xml:space="preserve">
          <source>Flag indicating whether converted categorical data are ordered.</source>
          <target state="translated">변환 된 범주 형 데이터의 순서를 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="9f95c149c4faaec5888d99c7f71ec74e2531b4c8" translate="yes" xml:space="preserve">
          <source>Flag indicating whether to convert missing values to their Stata representations. If False, missing values are replaced with nan. If True, columns containing missing values are returned with object data types and missing values are represented by StataMissingValue objects.</source>
          <target state="translated">결 측값을 Stata 표현으로 변환할지 여부를 나타내는 플래그입니다. False이면 결 측값이 nan으로 바뀝니다. True 인 경우 결 측값이 포함 된 열은 객체 데이터 유형과 함께 반환되며 결 측값은 StataMissingValue 객체로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="662a77030cc9860bb52adc75ba74b37ca13f8b74" translate="yes" xml:space="preserve">
          <source>Flag to ignore nan values during truth testing</source>
          <target state="translated">진도 테스트 중 nan 값을 무시하도록 플래그 지정</target>
        </trans-unit>
        <trans-unit id="c6f1432abac99bfba1ef88a26345c9f393063ebf" translate="yes" xml:space="preserve">
          <source>Flag to ignore nan values during truth testing.</source>
          <target state="translated">진실 테스트 중에 nan 값을 무시하도록 플래그를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="7a792d280d5985b9aba1e46b641e583758229d62" translate="yes" xml:space="preserve">
          <source>Flags can be added to the pattern or regular expression. For instance, to find the pattern &amp;lsquo;MONKEY&amp;rsquo; ignoring the case:</source>
          <target state="translated">패턴을 패턴이나 정규식에 추가 할 수 있습니다. 예를 들어, 대소 문자를 무시하고 패턴 'MONKEY'를 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f81ce345a6136ee346ca93fc27e28c7f4ec3dfd8" translate="yes" xml:space="preserve">
          <source>Flags can be get or set using &lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">플래그는를 사용하여 가져 오거나 설정할 수 있습니다 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32bf6637987ad863cda20b0727c09937149d4b27" translate="yes" xml:space="preserve">
          <source>Flags for the</source>
          <target state="translated">에 대한 플래그</target>
        </trans-unit>
        <trans-unit id="83c97a15e4943a077a1e1220e7137d2a81e85162" translate="yes" xml:space="preserve">
          <source>Flags for the &lt;code&gt;re&lt;/code&gt; module. For a complete list, &lt;a href=&quot;https://docs.python.org/3/howto/regex.html#compilation-flags&quot;&gt;see here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;re&lt;/code&gt; 모듈에 대한 플래그입니다 . 전체 목록 &lt;a href=&quot;https://docs.python.org/3/howto/regex.html#compilation-flags&quot;&gt;은 여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="432577bb2b22d5a9ee85382b4c6b054e1979f7e5" translate="yes" xml:space="preserve">
          <source>Flags from &lt;code&gt;re&lt;/code&gt; module, e.g.</source>
          <target state="translated">&lt;code&gt;re&lt;/code&gt; 모듈의 플래그 , 예 :</target>
        </trans-unit>
        <trans-unit id="585436554646f7f4eacd66bdc3e594d3d286d018" translate="yes" xml:space="preserve">
          <source>Flags from &lt;code&gt;re&lt;/code&gt; module, e.g. &lt;code&gt;re.IGNORECASE&lt;/code&gt; (default is 0, which means no flags).</source>
          <target state="translated">&lt;code&gt;re&lt;/code&gt; 모듈의 플래그 ( 예 : &lt;code&gt;re.IGNORECASE&lt;/code&gt; ) (기본값은 0이며 플래그가 없음을 의미)</target>
        </trans-unit>
        <trans-unit id="515107780eabce305acf354719927312071b81a1" translate="yes" xml:space="preserve">
          <source>Flags from the &lt;code&gt;re&lt;/code&gt; module, e.g. &lt;code&gt;re.IGNORECASE&lt;/code&gt;, that modify regular expression matching for things like case, spaces, etc. For more details, see &lt;a href=&quot;https://docs.python.org/3/library/re.html#module-re&quot;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;re.IGNORECASE&lt;/code&gt; 와 같은 &lt;code&gt;re&lt;/code&gt; 모듈의 플래그는 대소 문자, 공백 등의 항목에 대해 정규식 일치를 수정합니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/re.html#module-re&quot;&gt; &lt;code&gt;re&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcfae77bce37f455c591d98d47644be09b6c0eb9" translate="yes" xml:space="preserve">
          <source>Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in &lt;a href=&quot;api/pandas.dataframe.attrs#pandas.DataFrame.attrs&quot;&gt;&lt;code&gt;DataFrame.attrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플래그는 pandas 객체의 속성을 참조합니다. 데이터 세트의 속성 (예 : 기록 된 날짜, 액세스 한 URL 등)은 &lt;a href=&quot;api/pandas.dataframe.attrs#pandas.DataFrame.attrs&quot;&gt; &lt;code&gt;DataFrame.attrs&lt;/code&gt; 에&lt;/a&gt; 저장되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="45fbe0214264fb4b3fb9a64291506455d2cc6ac7" translate="yes" xml:space="preserve">
          <source>Flags refer to attributes of the pandas object. Properties of the dataset (like the date is was recorded, the URL it was accessed from, etc.) should be stored in &lt;a href=&quot;api/pandas.series.attrs#pandas.Series.attrs&quot;&gt;&lt;code&gt;Series.attrs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플래그는 pandas 객체의 속성을 참조합니다. 데이터 세트의 속성 (예 : 기록 된 날짜, 액세스 한 URL 등)은 &lt;a href=&quot;api/pandas.series.attrs#pandas.Series.attrs&quot;&gt; &lt;code&gt;Series.attrs&lt;/code&gt; 에&lt;/a&gt; 저장되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8051e3208891a231c29a0e104f1e90ec4adb9ea" translate="yes" xml:space="preserve">
          <source>Flags that apply to pandas objects.</source>
          <target state="translated">pandas 객체에 적용되는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="2d0543b37c8d9a7d6d7ae7b9c672da227d0ebd09" translate="yes" xml:space="preserve">
          <source>Flags to pass through to the re module, e.g. re.IGNORECASE.</source>
          <target state="translated">re 모듈에 전달할 플래그 (예 : re.IGNORECASE).</target>
        </trans-unit>
        <trans-unit id="50a90b005f85eea45da97271e0e67906807ec326" translate="yes" xml:space="preserve">
          <source>Flat file</source>
          <target state="translated">플랫 파일</target>
        </trans-unit>
        <trans-unit id="89921b5e6fd8ba462fb65161fd0d92b815e1763c" translate="yes" xml:space="preserve">
          <source>Flatten Hierarchical columns</source>
          <target state="translated">계층 적 열 병합</target>
        </trans-unit>
        <trans-unit id="6604e7feff8b1c565f2050463260cfbad88bc664" translate="yes" xml:space="preserve">
          <source>Flattened array.</source>
          <target state="translated">평평한 배열.</target>
        </trans-unit>
        <trans-unit id="6b8321e71ad02696b00c9740d5199653e2fe2cef" translate="yes" xml:space="preserve">
          <source>Flattened data of the Series.</source>
          <target state="translated">시리즈의 플랫 데이터.</target>
        </trans-unit>
        <trans-unit id="3ecb3394bc21b2c28a924bfb2ceb7ce3b4d4c89b" translate="yes" xml:space="preserve">
          <source>Flexible &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">유연한 &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4dced8a2e2a4243ea94ec16f6aeac7e5e147302d" translate="yes" xml:space="preserve">
          <source>Flexible &lt;strong&gt;reshaping&lt;/strong&gt; and pivoting of data sets</source>
          <target state="translated">데이터 세트의 유연한 &lt;strong&gt;재구성&lt;/strong&gt; 및 피벗</target>
        </trans-unit>
        <trans-unit id="592e2cd03ef0079de8be45e2ddd7d5de0cfd60a5" translate="yes" xml:space="preserve">
          <source>Flexible apply</source>
          <target state="translated">유연한 적용</target>
        </trans-unit>
        <trans-unit id="df5806c6267d9b68d3103f1763eb955966fe3ab4" translate="yes" xml:space="preserve">
          <source>Flexible binary operations</source>
          <target state="translated">유연한 이진 연산</target>
        </trans-unit>
        <trans-unit id="a962b0d0790e6a702e910629104b3ccecaddc371" translate="yes" xml:space="preserve">
          <source>Flexible comparisons</source>
          <target state="translated">유연한 비교</target>
        </trans-unit>
        <trans-unit id="46b6264f81b90b7bece4c321b647a9b3f7639f96" translate="yes" xml:space="preserve">
          <source>Float64Index</source>
          <target state="translated">Float64Index</target>
        </trans-unit>
        <trans-unit id="3cd6667377c655b03847b3669898276edf87d560" translate="yes" xml:space="preserve">
          <source>Float64Index[source]</source>
          <target state="translated">Float64Index[source]</target>
        </trans-unit>
        <trans-unit id="0ff90825ac199f78375793c24aad512313a0021c" translate="yes" xml:space="preserve">
          <source>Floating point output precision in terms of number of places after the decimal, for regular formatting as well as scientific notation. Similar to &lt;code&gt;precision&lt;/code&gt; in &lt;code&gt;numpy.set_printoptions()&lt;/code&gt;. [default: 6] [currently: 6]</source>
          <target state="translated">일반 형식 및 과학적 표기법에 대한 소수점 이하 자릿수 측면의 부동 소수점 출력 정밀도입니다. &lt;code&gt;numpy.set_printoptions()&lt;/code&gt; &lt;code&gt;precision&lt;/code&gt; 와 유사합니다 . [기본값 : 6] [현재 : 6]</target>
        </trans-unit>
        <trans-unit id="e2282e1bead14d64d42d3dceedcd3f4eff4f5b8b" translate="yes" xml:space="preserve">
          <source>Floating point output precision in terms of number of places after the decimal, for regular formatting as well as scientific notation. Similar to numpy&amp;rsquo;s &lt;code&gt;precision&lt;/code&gt; print option</source>
          <target state="translated">일반 형식 및 과학적 표기법에 대한 소수점 이하 자릿수 측면의 부동 소수점 출력 정밀도입니다. numpy의 &lt;code&gt;precision&lt;/code&gt; 인쇄 옵션과 유사</target>
        </trans-unit>
        <trans-unit id="6eec942e32d846e2fa7809236a660b9a8999826a" translate="yes" xml:space="preserve">
          <source>Floats: &lt;code&gt;'float16', 'float32', 'float64'&lt;/code&gt;</source>
          <target state="translated">플로트 : &lt;code&gt;'float16', 'float32', 'float64'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ebc44dc921c7e582f09164853c5caec040b7656" translate="yes" xml:space="preserve">
          <source>Floor the DatetimeIndex to the specified freq.</source>
          <target state="translated">DatetimeIndex를 지정된 주파수로 플로어링합니다.</target>
        </trans-unit>
        <trans-unit id="d0059e1678d97210e084e848c2fa9149e58d0335" translate="yes" xml:space="preserve">
          <source>Floor the datetimes to the specified freq.</source>
          <target state="translated">날짜 시간을 지정된 주파수로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b6ba0db1f814179114ec82fbf188b2eb5be2596e" translate="yes" xml:space="preserve">
          <source>Fold</source>
          <target state="translated">Fold</target>
        </trans-unit>
        <trans-unit id="8ad886bee58cb0e2df6198bed9df97c140aef480" translate="yes" xml:space="preserve">
          <source>Following table shows how &lt;code&gt;pandas&lt;/code&gt; data structures define constructor properties by default.</source>
          <target state="translated">다음 표는 &lt;code&gt;pandas&lt;/code&gt; 데이터 구조가 기본적으로 생성자 특성을 정의 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="fd5d231e67319578d1a3c4c2e247df09cf9457a6" translate="yes" xml:space="preserve">
          <source>Following this naming convention isn&amp;rsquo;t strictly necessary, but strongly suggested for compatibility with Arrow.</source>
          <target state="translated">이 명명 규칙을 따르는 것이 반드시 필요한 것은 아니지만 Arrow와의 호환성을 위해 강력히 제안됩니다.</target>
        </trans-unit>
        <trans-unit id="41148d5ccad00f168e223acb6c377f90966dbedf" translate="yes" xml:space="preserve">
          <source>Follows Python list.append semantics for negative values.</source>
          <target state="translated">음수 값에 대해서는 Python list.append 의미를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1c2807ca390019a864532a70bcdb665175f9740c" translate="yes" xml:space="preserve">
          <source>Font size for xticks and yticks.</source>
          <target state="translated">xticks 및 yticks의 글꼴 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f7880600348a091a43e2a84906d6002820643108" translate="yes" xml:space="preserve">
          <source>For</source>
          <target state="translated">For</target>
        </trans-unit>
        <trans-unit id="8b19e1de4cda57356fd0e9491c03c399045a6308" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../reference/api/pandas.multiindex#pandas.MultiIndex&quot;&gt;&lt;code&gt;MultiIndex&lt;/code&gt;&lt;/a&gt;-ed objects to be indexed and sliced effectively, they need to be sorted. As with any index, you can use &lt;a href=&quot;../reference/api/pandas.dataframe.sort_index#pandas.DataFrame.sort_index&quot;&gt;&lt;code&gt;sort_index()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">들어 &lt;a href=&quot;../reference/api/pandas.multiindex#pandas.MultiIndex&quot;&gt; &lt;code&gt;MultiIndex&lt;/code&gt; 는&lt;/a&gt; 색인을 효과적으로 분리 할 객체를 -ed, 그들은 정렬 할 필요가있다. 모든 인덱스와 마찬가지로 &lt;a href=&quot;../reference/api/pandas.dataframe.sort_index#pandas.DataFrame.sort_index&quot;&gt; &lt;code&gt;sort_index()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a2a4b82e2fed58f699c6191ef2108148460f22f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;'cython'&lt;/code&gt; engine, there are no accepted &lt;code&gt;engine_kwargs&lt;/code&gt;</source>
          <target state="translated">내용은 &lt;code&gt;'cython'&lt;/code&gt; 엔진에는 허용이없는 &lt;code&gt;engine_kwargs&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="38c7248434584d02538a075ee040ab4ddd608656" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;'numba'&lt;/code&gt; engine, the engine can accept &lt;code&gt;nopython&lt;/code&gt;, &lt;code&gt;nogil&lt;/code&gt; and &lt;code&gt;parallel&lt;/code&gt; dictionary keys. The values must either be &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. The default &lt;code&gt;engine_kwargs&lt;/code&gt; for the &lt;code&gt;'numba'&lt;/code&gt; engine is &lt;code&gt;{'nopython': True, 'nogil': False, 'parallel': False}&lt;/code&gt; and will be applied to both the &lt;code&gt;func&lt;/code&gt; and the &lt;code&gt;apply&lt;/code&gt; rolling aggregation.</source>
          <target state="translated">들어 &lt;code&gt;'numba'&lt;/code&gt; 엔진, 엔진은 받아 들일 수 &lt;code&gt;nopython&lt;/code&gt; , &lt;code&gt;nogil&lt;/code&gt; 과 &lt;code&gt;parallel&lt;/code&gt; 사전 키를. 값은 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 여야합니다 . 기본 &lt;code&gt;engine_kwargs&lt;/code&gt; 에 대한 &lt;code&gt;'numba'&lt;/code&gt; 엔진은 &lt;code&gt;{'nopython': True, 'nogil': False, 'parallel': False}&lt;/code&gt; 과 모두에 적용됩니다 &lt;code&gt;func&lt;/code&gt; 와 &lt;code&gt;apply&lt;/code&gt; 압연 집계.</target>
        </trans-unit>
        <trans-unit id="5a6e7e218bd118587d42e1c8ad4d844c1b22d85e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;'numba'&lt;/code&gt; engine, the engine can accept &lt;code&gt;nopython&lt;/code&gt;, &lt;code&gt;nogil&lt;/code&gt; and &lt;code&gt;parallel&lt;/code&gt; dictionary keys. The values must either be &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. The default &lt;code&gt;engine_kwargs&lt;/code&gt; for the &lt;code&gt;'numba'&lt;/code&gt; engine is &lt;code&gt;{'nopython': True, 'nogil': False, 'parallel': False}&lt;/code&gt; and will be applied to the function</source>
          <target state="translated">들어 &lt;code&gt;'numba'&lt;/code&gt; 엔진, 엔진은 받아 들일 수 &lt;code&gt;nopython&lt;/code&gt; , &lt;code&gt;nogil&lt;/code&gt; 과 &lt;code&gt;parallel&lt;/code&gt; 사전 키를. 값은 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 여야합니다 . 기본 &lt;code&gt;engine_kwargs&lt;/code&gt; 에 대한 &lt;code&gt;'numba'&lt;/code&gt; 엔진은 &lt;code&gt;{'nopython': True, 'nogil': False, 'parallel': False}&lt;/code&gt; 와 함수에 적용됩니다</target>
        </trans-unit>
        <trans-unit id="9ecbbe90abea3befc6b730ae5340125aa55961ad" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DataFrame&lt;/code&gt; objects which don&amp;rsquo;t have a meaningful index, you may wish to append them and ignore the fact that they may have overlapping indexes. To do this, use the &lt;code&gt;ignore_index&lt;/code&gt; argument:</source>
          <target state="translated">의미있는 인덱스가없는 &lt;code&gt;DataFrame&lt;/code&gt; 개체의 경우 추가하고 겹치는 인덱스가 있다는 사실을 무시할 수 있습니다. 이렇게하려면 &lt;code&gt;ignore_index&lt;/code&gt; 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ad0cef1babda381b5f8503fa7264f9101ca8626" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DataFrame&lt;/code&gt; objects, a string indicating a column to be used to group. Of course &lt;code&gt;df.groupby('A')&lt;/code&gt; is just syntactic sugar for &lt;code&gt;df.groupby(df['A'])&lt;/code&gt;, but it makes life simpler.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 객체의 경우 그룹화 하는 데 사용할 열을 나타내는 문자열입니다. 물론 &lt;code&gt;df.groupby('A')&lt;/code&gt; 는 &lt;code&gt;df.groupby(df['A'])&lt;/code&gt; 구문 설탕 이지만 인생을 더 단순하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7a72f46c3ee1715da977723aeb661f40da9944a1" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DataFrame&lt;/code&gt; objects, a string indicating an index level to be used to group.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 개체의 경우 그룹화 하는 데 사용할 인덱스 수준을 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="969f496bd7921cbd52b49d76ab713f39bb39022e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DataFrame&lt;/code&gt; objects, a string indicating either a column name or an index level name to be used to group.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 개체의 경우 그룹화 하는 데 사용할 열 이름 또는 인덱스 수준 이름을 나타내는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ffe73efb236ce9e3f0cfeceff72c6a2abea67a3f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DataFrames&lt;/code&gt;, likewise, &lt;code&gt;in&lt;/code&gt; applies to the column axis, testing for membership in the list of column names.</source>
          <target state="translated">들면 &lt;code&gt;DataFrames&lt;/code&gt; , 마찬가지로 &lt;code&gt;in&lt;/code&gt; 열 이름리스트에 멤버를 테스트, 열 축 적용된다.</target>
        </trans-unit>
        <trans-unit id="9984200f780463c79a64f7c0606e7db30a20a03d" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;DataFrames&lt;/code&gt;, the stringified version of the column name is used</source>
          <target state="translated">들어 &lt;code&gt;DataFrames&lt;/code&gt; , 열 이름의 캐릭터 라인 버전이 사용됩니다</target>
        </trans-unit>
        <trans-unit id="cfc57f27ea09f1423e255ab9d0bbbf0bde6bf0ec" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Index&lt;/code&gt; (not &lt;code&gt;MultiIndex&lt;/code&gt;), &lt;code&gt;index.name&lt;/code&gt; is used, with a fallback to &lt;code&gt;index&lt;/code&gt; if that is None.</source>
          <target state="translated">들어 &lt;code&gt;Index&lt;/code&gt; (하지 &lt;code&gt;MultiIndex&lt;/code&gt; ), &lt;code&gt;index.name&lt;/code&gt; 는 에 대체와 함께 사용되는 &lt;code&gt;index&lt;/code&gt; 즉 아무도없는 경우.</target>
        </trans-unit>
        <trans-unit id="70fe8260581c909fadf2b4845f8627f71b1b1198" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MultiIndex&lt;/code&gt;, &lt;code&gt;mi.names&lt;/code&gt; is used. If any level has no name, then &lt;code&gt;level_&amp;lt;i&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">들어 &lt;code&gt;MultiIndex&lt;/code&gt; , &lt;code&gt;mi.names&lt;/code&gt; 이 사용됩니다. 레벨에 이름이 없으면 &lt;code&gt;level_&amp;lt;i&amp;gt;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9acd5abc7b9bd7dd1d488b166bb1139f12f68ace" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;PeriodIndex&lt;/code&gt; only, controls whether to use the start or end of &lt;code&gt;rule&lt;/code&gt;.</source>
          <target state="translated">대한 &lt;code&gt;PeriodIndex&lt;/code&gt; 만, 시작을 사용하거나의 종료 여부를 제어 &lt;code&gt;rule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01e82820bab46ab1b92b92728e00a794620b065e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Series&lt;/code&gt; and &lt;code&gt;DataFrame&lt;/code&gt; objects, &lt;a href=&quot;../reference/api/pandas.dataframe.var#pandas.DataFrame.var&quot;&gt;&lt;code&gt;var()&lt;/code&gt;&lt;/a&gt; normalizes by &lt;code&gt;N-1&lt;/code&gt; to produce unbiased estimates of the sample variance, while NumPy&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; normalizes by N, which measures the variance of the sample. Note that &lt;a href=&quot;../reference/api/pandas.dataframe.cov#pandas.DataFrame.cov&quot;&gt;&lt;code&gt;cov()&lt;/code&gt;&lt;/a&gt; normalizes by &lt;code&gt;N-1&lt;/code&gt; in both pandas and NumPy.</source>
          <target state="translated">들면 &lt;code&gt;Series&lt;/code&gt; 와 &lt;code&gt;DataFrame&lt;/code&gt; 는 개체 &lt;a href=&quot;../reference/api/pandas.dataframe.var#pandas.DataFrame.var&quot;&gt; &lt;code&gt;var()&lt;/code&gt; &lt;/a&gt; 정규화 &lt;code&gt;N-1&lt;/code&gt; 샘플의 분산 비 편향 추정을 생성하면서 NumPy와의 &lt;code&gt;var&lt;/code&gt; 샘플의 분산을 측정 N, 정규화. 참고 &lt;a href=&quot;../reference/api/pandas.dataframe.cov#pandas.DataFrame.cov&quot;&gt; &lt;code&gt;cov()&lt;/code&gt; &lt;/a&gt; 정규화 &lt;code&gt;N-1&lt;/code&gt; 판다 NumPy와 모두를.</target>
        </trans-unit>
        <trans-unit id="c2158ff4cbb8118296adef253fb6732155c2715b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;StringDtype&lt;/code&gt;, &lt;a href=&quot;../reference/series#api-series-str&quot;&gt;string accessor methods&lt;/a&gt; that return &lt;strong&gt;numeric&lt;/strong&gt; output will always return a nullable integer dtype, rather than either int or float dtype, depending on the presence of NA values. Methods returning &lt;strong&gt;boolean&lt;/strong&gt; output will return a nullable boolean dtype.</source>
          <target state="translated">들면 &lt;code&gt;StringDtype&lt;/code&gt; , &lt;a href=&quot;../reference/series#api-series-str&quot;&gt;문자열 액세서 메소드&lt;/a&gt; 리턴 &lt;strong&gt;수치&lt;/strong&gt; 출력은 항상 NA 값의 존재 여부에 따라, 오히려 하나 또는 INT 플로트 DTYPE보다는 널 DTYPE 정수를 반환한다. &lt;strong&gt;부울&lt;/strong&gt; 출력을 반환하는 메서드 는 nullable 부울 dtype을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="59c976e6e4b25103c60d93dfbad500ca5a068cf5" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Styler.apply&lt;/code&gt; your function should take a Series or DataFrame (depending on the axis parameter), and return a Series or DataFrame with an identical shape where each value is a string with a CSS attribute-value pair.</source>
          <target state="translated">들면 &lt;code&gt;Styler.apply&lt;/code&gt; 함수는 (축 파라미터에 따라 다름) 계열 또는 DataFrame을해야하고, 각각의 값은 CSS 속성 - 값 쌍을 가진 문자열 동일한 모양으로 시리즈 또는 DataFrame를 반환한다.</target>
        </trans-unit>
        <trans-unit id="92339953f496b23ea822e700f216e9425cad8c74" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Styler.applymap&lt;/code&gt; your function should take a scalar and return a single string with the CSS attribute-value pair.</source>
          <target state="translated">들어 &lt;code&gt;Styler.applymap&lt;/code&gt; 함수는 스칼라을하고 CSS 속성 - 값 쌍을 가진 단일 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="63191dcfce3b8b6e25642ded988ccc2599ce21d9" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;complex&lt;/code&gt; inputs, &lt;code&gt;1.2 + 1j&lt;/code&gt;, the absolute value is \(\sqrt{ a^2 + b^2 }\).</source>
          <target state="translated">들면 &lt;code&gt;complex&lt;/code&gt; 입력, &lt;code&gt;1.2 + 1j&lt;/code&gt; , 절대 값 \이다 (\가 SQRT {A ^ 2 + B ^ 2} \).</target>
        </trans-unit>
        <trans-unit id="70debc113e01c43ddacf9e08578f152095caf5af" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;df2&lt;/code&gt;, the &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; with multiple dtypes, &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt;&lt;code&gt;DataFrame.to_numpy()&lt;/code&gt;&lt;/a&gt; is relatively expensive.</source>
          <target state="translated">들어 &lt;code&gt;df2&lt;/code&gt; 의 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 여러 dtypes와 함께, &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt; &lt;code&gt;DataFrame.to_numpy()&lt;/code&gt; &lt;/a&gt; 상대적으로 비싸다.</target>
        </trans-unit>
        <trans-unit id="81030d9ab1703f3cc9f7ebeecfb57dcb67354169" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;df&lt;/code&gt;, our &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; of all floating-point values, &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt;&lt;code&gt;DataFrame.to_numpy()&lt;/code&gt;&lt;/a&gt; is fast and doesn&amp;rsquo;t require copying data.</source>
          <target state="translated">들어 &lt;code&gt;df&lt;/code&gt; , 우리 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 모든 부동 소수점 값은 &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt; &lt;code&gt;DataFrame.to_numpy()&lt;/code&gt; &lt;/a&gt; 빠르고 및 복사 데이터를 필요로하지 않는다.</target>
        </trans-unit>
        <trans-unit id="7d6d186fe28880ea81f2a38d1737448118a977e8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;pytz&lt;/code&gt; time zones, it is incorrect to pass a time zone object directly into the &lt;code&gt;datetime.datetime&lt;/code&gt; constructor (e.g., &lt;code&gt;datetime.datetime(2011, 1, 1, tz=pytz.timezone('US/Eastern'))&lt;/code&gt;. Instead, the datetime needs to be localized using the &lt;code&gt;localize&lt;/code&gt; method on the &lt;code&gt;pytz&lt;/code&gt; time zone object.</source>
          <target state="translated">들어 &lt;code&gt;pytz&lt;/code&gt; 의 시간대가 직접으로 시간대 개체를 전달할 잘못된 &lt;code&gt;datetime.datetime&lt;/code&gt; 의 생성자 (예를 들어, &lt;code&gt;datetime.datetime(2011, 1, 1, tz=pytz.timezone('US/Eastern'))&lt;/code&gt; . 대신에, 날짜 시간 은 &lt;code&gt;pytz&lt;/code&gt; 시간대 객체 의 &lt;code&gt;localize&lt;/code&gt; 메소드를 사용하여 현지화 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bbc15e72871f4239431f203a522d34e3ddbd7bbf" translate="yes" xml:space="preserve">
          <source>For DataFrame objects, rank only numeric columns if set to True.</source>
          <target state="translated">DataFrame 개체의 경우 True로 설정하면 숫자 열만 순위를 매 깁니다.</target>
        </trans-unit>
        <trans-unit id="91db5d1cbbb5e4c92797d308f60ee309d08c4097" translate="yes" xml:space="preserve">
          <source>For DataFrame objects, the keyword</source>
          <target state="translated">DataFrame 개체의 경우 키워드</target>
        </trans-unit>
        <trans-unit id="9cce67030bcae3fa28751b9398f791cd48e516ab" translate="yes" xml:space="preserve">
          <source>For DataFrame objects, the keyword &lt;code&gt;on&lt;/code&gt; can be used to specify the column instead of the index for resampling.</source>
          <target state="translated">DataFrame 객체의 경우 키워드 &lt;code&gt;on&lt;/code&gt; 을 사용하여 리샘플링을위한 인덱스 대신 열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71ef4087864dce14de387ae8d781d013d56790d" translate="yes" xml:space="preserve">
          <source>For DataFrame, each expanding sum is computed column-wise.</source>
          <target state="translated">DataFrame의 경우 각 확장 합계는 열 단위로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="b01b228ea2c64bd54f0f73ce17508220bd446e6a" translate="yes" xml:space="preserve">
          <source>For DataFrame, each rolling sum is computed column-wise.</source>
          <target state="translated">DataFrame의 경우 각 롤링 합계는 열 단위로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="cd6c1a399560afc76b4e569ced42902abd8b0203" translate="yes" xml:space="preserve">
          <source>For DataFrame, each window sum is computed column-wise.</source>
          <target state="translated">DataFrame의 경우 각 창 합계는 열 단위로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a5da9be849b2608642456c85cefd01d67cada570" translate="yes" xml:space="preserve">
          <source>For DataFrame, if not</source>
          <target state="translated">DataFrame의 경우, 그렇지 않은 경우</target>
        </trans-unit>
        <trans-unit id="f21ec2bb0e16013b4766b86d5046d3b975a1bd8c" translate="yes" xml:space="preserve">
          <source>For DataFrame, if not &lt;code&gt;None&lt;/code&gt;, only use these columns to check for NaNs.</source>
          <target state="translated">DataFrame의 경우 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우이 열만 사용하여 NaN을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c075a5df8888360865d89b7245097779c7785e33" translate="yes" xml:space="preserve">
          <source>For DataFrame, it works in the same way:</source>
          <target state="translated">DataFrame의 경우 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="64b2d4340bdb65dcde6ab187fa5e1497014440bf" translate="yes" xml:space="preserve">
          <source>For DataFrames exceeding max_rows/max_cols, the repr (and HTML repr) can show a truncated table (the default from 0.13), or switch to the view from df.info() (the behaviour in earlier versions of pandas). [default: truncate] [currently: truncate]</source>
          <target state="translated">max_rows / max_cols를 초과하는 DataFrame의 경우 repr (및 HTML repr)은 잘린 테이블 (기본값 0.13)을 표시하거나 df.info ()에서보기로 전환 할 수 있습니다 (이전 버전의 pandas 동작). [기본값 : 자르기] [현재 : 자르기]</target>
        </trans-unit>
        <trans-unit id="f55404d2565903c0cb15b888692658832061cb66" translate="yes" xml:space="preserve">
          <source>For DataFrames exceeding max_rows/max_cols, the repr (and HTML repr) can show a truncated table (the default), or switch to the view from df.info() (the behaviour in earlier versions of pandas). allowable settings, [&amp;lsquo;truncate&amp;rsquo;, &amp;lsquo;info&amp;rsquo;]</source>
          <target state="translated">max_rows / max_cols를 초과하는 DataFrame의 경우 repr (및 HTML repr)은 잘린 테이블 (기본값)을 표시하거나 df.info ()에서보기로 전환 할 수 있습니다 (이전 버전의 pandas 동작). 허용 가능한 설정, [ 'truncate', 'info']</target>
        </trans-unit>
        <trans-unit id="abd0020733f34b336c7ad2f0e11739d018224f42" translate="yes" xml:space="preserve">
          <source>For DataFrames that have Series that are missing data (assuming that data is &lt;a href=&quot;https://en.wikipedia.org/wiki/Missing_data#Missing_at_random&quot;&gt;missing at random&lt;/a&gt;) the returned covariance matrix will be an unbiased estimate of the variance and covariance between the member Series.</source>
          <target state="translated">데이터가 누락 된 Series가있는 DataFrame의 경우 (데이터가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Missing_data#Missing_at_random&quot;&gt;임의로 누락 된&lt;/a&gt; 것으로 가정 ) 반환 된 공분산 행렬은 멤버 Series 간의 분산 및 공분산의 편향 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="d91c3c941e072373927ae861a8c378b45e3329fd" translate="yes" xml:space="preserve">
          <source>For DataFrames with multiple columns, filters should explicitly specify a column as the filter criterion.</source>
          <target state="translated">여러 열이있는 DataFrame의 경우 필터는 필터 기준으로 열을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9068a5515b39e3a535269ea26c862f779bd7857f" translate="yes" xml:space="preserve">
          <source>For DataFrames, the given indices should be a 1d list or ndarray that specifies row or column positions.</source>
          <target state="translated">DataFrames의 경우 지정된 인덱스는 행 또는 열 위치를 지정하는 1d 목록 또는 ndarray 여야합니다.</target>
        </trans-unit>
        <trans-unit id="414dbb0aaf8c5064971faf2dbd38ab952e07a046" translate="yes" xml:space="preserve">
          <source>For DataFrames, the join method will be applied to both the index and the columns by default:</source>
          <target state="translated">DataFrames의 경우 조인 메서드는 기본적으로 인덱스와 열 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="04863e2f92d104de2912b47a66a44d2952000792" translate="yes" xml:space="preserve">
          <source>For DatetimeArray</source>
          <target state="translated">DatetimeArray의 경우</target>
        </trans-unit>
        <trans-unit id="f9a6c0a346380d4a38720bcdb26a1b61bf486fb7" translate="yes" xml:space="preserve">
          <source>For DatetimeArray &lt;code&gt;values&lt;/code&gt; (or a Series or Index boxing one), &lt;code&gt;dtype&lt;/code&gt; and &lt;code&gt;freq&lt;/code&gt; will be extracted from &lt;code&gt;values&lt;/code&gt;, with precedence given to</source>
          <target state="translated">DatetimeArray &lt;code&gt;values&lt;/code&gt; (또는 Series 또는 Index boxing 값 )의 경우 &lt;code&gt;dtype&lt;/code&gt; 및 &lt;code&gt;freq&lt;/code&gt; 는 &lt;code&gt;values&lt;/code&gt; 에서 추출 되며 우선 순위는</target>
        </trans-unit>
        <trans-unit id="2f61866957f7d7301f34da0c17d93b8e0bc0a0e7" translate="yes" xml:space="preserve">
          <source>For Index, level should be 0, since there are no multiple levels.</source>
          <target state="translated">여러 레벨이 없으므로 인덱스의 경우 레벨은 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cd12ec2ee5dac6dcc0938558080c7de32cf80dfb" translate="yes" xml:space="preserve">
          <source>For MultiIndex, level for which the labels will be removed.</source>
          <target state="translated">MultiIndex의 경우 레이블을 제거 할 수준입니다.</target>
        </trans-unit>
        <trans-unit id="8eae3fa2918d301dfd457ba8e42908b628e9e5f7" translate="yes" xml:space="preserve">
          <source>For MultiIndex, level from which the labels will be removed.</source>
          <target state="translated">MultiIndex의 경우 레이블을 제거 할 수준입니다.</target>
        </trans-unit>
        <trans-unit id="8c859c5d65dd092b51a2eee4b3c2651e816ab15f" translate="yes" xml:space="preserve">
          <source>For NumPy compatibility. No additional arguments are used.</source>
          <target state="translated">NumPy 호환성을 위해. 추가 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e45d187e976f5b24022aff48a05ad2a87a5a95ab" translate="yes" xml:space="preserve">
          <source>For NumPy dtypes, this will be a reference to the actual data stored in this Series or Index (assuming &lt;code&gt;copy=False&lt;/code&gt;). Modifying the result in place will modify the data stored in the Series or Index (not that we recommend doing that).</source>
          <target state="translated">NumPy dtype의 경우이 시리즈 또는 인덱스에 저장된 실제 데이터에 대한 참조입니다 ( &lt;code&gt;copy=False&lt;/code&gt; 가정 ). 결과를 수정하면 시리즈 또는 인덱스에 저장된 데이터가 수정됩니다 (권장하지 않는 것이 좋습니다).</target>
        </trans-unit>
        <trans-unit id="46d8136fe73fb92abf2169a76543dd967e628589" translate="yes" xml:space="preserve">
          <source>For PeriodIndex only (see PeriodIndex.asfreq).</source>
          <target state="translated">PeriodIndex에만 해당됩니다 (PeriodIndex.asfreq 참조).</target>
        </trans-unit>
        <trans-unit id="12625a6c070a7bf7dc66c0e42a1382b32332f97f" translate="yes" xml:space="preserve">
          <source>For PeriodIndex only, see PeriodIndex.asfreq</source>
          <target state="translated">PeriodIndex 만 해당하는 경우 PeriodIndex.asfreq를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8790140b5ecf731d553340f444adbf8dc407c14" translate="yes" xml:space="preserve">
          <source>For Python 3.5 and earlier, the order of &lt;code&gt;**kwargs&lt;/code&gt; in a functions was not preserved. This means that the output column ordering would not be consistent. To ensure consistent ordering, the keys (and so output columns) will always be sorted for Python 3.5.</source>
          <target state="translated">Python 3.5 및 이전 버전에서는 함수 의 &lt;code&gt;**kwargs&lt;/code&gt; 순서가 유지되지 않았습니다. 이는 출력 열 순서가 일관되지 않음을 의미합니다. 일관된 순서를 보장하기 위해 키 (및 출력 열)는 항상 Python 3.5 용으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="560a573dd870506bf44d57c7bea8439b53270213" translate="yes" xml:space="preserve">
          <source>For Series and DataFrame, the same type is returned, containing booleans.</source>
          <target state="translated">Series 및 DataFrame의 경우 부울을 포함하는 동일한 유형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="85ece3a2eeff9dc451c862701f6bdfa92323842a" translate="yes" xml:space="preserve">
          <source>For Series input, the output is a scalar indicating whether any element is True.</source>
          <target state="translated">시리즈 입력의 경우 출력은 요소가 참인지 여부를 나타내는 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="34631f63aeff7e4329e87b95098e1c5c60a9a74e" translate="yes" xml:space="preserve">
          <source>For Series, it&amp;rsquo;s name attribute must be set.</source>
          <target state="translated">Series의 경우 이름 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="be32919c1d5262c1392779e7670a68d0e9d6a276" translate="yes" xml:space="preserve">
          <source>For Series, its name attribute must be set.</source>
          <target state="translated">시리즈의 경우 이름 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f00f5a6c531a40dbd5d2921d98dd3f4c16cd5a12" translate="yes" xml:space="preserve">
          <source>For Series, only rows can be truncated.</source>
          <target state="translated">Series의 경우 행만 잘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5551e2e93a683cfa36af817dbfb8da081f29d5c7" translate="yes" xml:space="preserve">
          <source>For Series, returns a Series with boolean values. For DatetimeIndex, returns a boolean array.</source>
          <target state="translated">Series의 경우 부울 값이있는 Series를 반환합니다. DatetimeIndex의 경우 부울 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f2b21676ad900d12ec0105fb422473304ed295a" translate="yes" xml:space="preserve">
          <source>For Series, the row labels are prefixed. For DataFrame, the column labels are prefixed.</source>
          <target state="translated">Series의 경우 행 레이블이 접두사로 사용됩니다. DataFrame의 경우 열 레이블이 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="ff9e287cffb3291ab844008474983151ffa9d6c4" translate="yes" xml:space="preserve">
          <source>For Series, the row labels are suffixed. For DataFrame, the column labels are suffixed.</source>
          <target state="translated">Series의 경우 행 레이블에 접미사가 붙습니다. DataFrame의 경우 열 레이블에 접미사가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="4c1d9ec189276d3e67196cf2df839e8b20b194c0" translate="yes" xml:space="preserve">
          <source>For Table formats, append the input data to the existing.</source>
          <target state="translated">테이블 형식의 경우 입력 데이터를 기존에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0d341912d1333fe0ddfead35b57a3b881f5ef665" translate="yes" xml:space="preserve">
          <source>For Windows developers, when using Python 3.5 and later, it is sufficient to install &lt;a href=&quot;https://visualstudio.com/&quot;&gt;Visual Studio 2017&lt;/a&gt; with the &lt;strong&gt;Python development workload&lt;/strong&gt; and the &lt;strong&gt;Python native development tools&lt;/strong&gt; option. Otherwise, the following links may be helpful.</source>
          <target state="translated">Windows 개발자의 경우 Python 3.5 이상을 사용 하는 경우 &lt;strong&gt;Python 개발 워크로드&lt;/strong&gt; 및 &lt;strong&gt;Python 기본 개발 도구&lt;/strong&gt; 옵션으로 &lt;a href=&quot;https://visualstudio.com/&quot;&gt;Visual Studio 2017&lt;/a&gt; 을 설치하면 충분합니다 . 그렇지 않으면 다음 링크가 도움이 될 수 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="384f122eac1b5e433520d4e7209e7a595a37456d" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;Series&lt;/code&gt;:</source>
          <target state="translated">A의 &lt;code&gt;Series&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="302a998d968637e1e2d466388207248153079cc3" translate="yes" xml:space="preserve">
          <source>For a DataFrame a dict can specify that different values should be replaced in different columns. For example, &lt;code&gt;{'a': 1, 'b': 'z'}&lt;/code&gt; looks for the value 1 in column &amp;lsquo;a&amp;rsquo; and the value &amp;lsquo;z&amp;rsquo; in column &amp;lsquo;b&amp;rsquo; and replaces these values with whatever is specified in</source>
          <target state="translated">DataFrame의 경우 dict는 다른 열에서 다른 값을 대체하도록 지정할 수 있습니다. 예를 들어, &lt;code&gt;{'a': 1, 'b': 'z'}&lt;/code&gt; 는 'a'열에서 값 1을 찾고 'b'열에서 'z'값을 찾아이 값을 다음에 지정된 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="90469ed06a05157905ae4315a937a34cb81acd34" translate="yes" xml:space="preserve">
          <source>For a DataFrame a dict can specify that different values should be replaced in different columns. For example, &lt;code&gt;{'a': 1, 'b': 'z'}&lt;/code&gt; looks for the value 1 in column &amp;lsquo;a&amp;rsquo; and the value &amp;lsquo;z&amp;rsquo; in column &amp;lsquo;b&amp;rsquo; and replaces these values with whatever is specified in &lt;code&gt;value&lt;/code&gt;. The &lt;code&gt;value&lt;/code&gt; parameter should not be &lt;code&gt;None&lt;/code&gt; in this case. You can treat this as a special case of passing two lists except that you are specifying the column to search in.</source>
          <target state="translated">DataFrame의 경우 dict는 다른 값을 다른 열에서 바꾸도록 지정할 수 있습니다. 예를 들어, &lt;code&gt;{'a': 1, 'b': 'z'}&lt;/code&gt; 는 'a'열에서 1 값과 'b'열에서 'z'값을 찾아 &lt;code&gt;value&lt;/code&gt; 에 지정된 값으로 바꿉니다 . 이 경우 &lt;code&gt;value&lt;/code&gt; 매개 변수는 &lt;code&gt;None&lt;/code&gt; 이 아니어야합니다 . 검색 할 열을 지정하는 것을 제외하고 두 목록을 전달하는 특별한 경우로 이것을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="975433d26077a48b481dac8c960f9027d338c06a" translate="yes" xml:space="preserve">
          <source>For a DataFrame nested dictionaries, e.g., &lt;code&gt;{'a': {'b': np.nan}}&lt;/code&gt;, are read as follows: look in column &amp;lsquo;a&amp;rsquo; for the value &amp;lsquo;b&amp;rsquo; and replace it with NaN. The</source>
          <target state="translated">DataFrame 중첩 사전 (예 &lt;code&gt;{'a': {'b': np.nan}}&lt;/code&gt; )의 경우 다음과 같이 읽습니다. 'a'열에서 'b'값을 찾아 NaN으로 바꿉니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="5971d67c38f7055e4b38754e2d37c0bdf80184f1" translate="yes" xml:space="preserve">
          <source>For a DataFrame nested dictionaries, e.g., &lt;code&gt;{'a': {'b': np.nan}}&lt;/code&gt;, are read as follows: look in column &amp;lsquo;a&amp;rsquo; for the value &amp;lsquo;b&amp;rsquo; and replace it with NaN. The &lt;code&gt;value&lt;/code&gt; parameter should be &lt;code&gt;None&lt;/code&gt; to use a nested dict in this way. You can nest regular expressions as well. Note that column names (the top-level dictionary keys in a nested dictionary) &lt;strong&gt;cannot&lt;/strong&gt; be regular expressions.</source>
          <target state="translated">DataFrame 중첩 사전 (예 &lt;code&gt;{'a': {'b': np.nan}}&lt;/code&gt; )의 경우 다음과 같이 읽습니다. 'a'열에서 'b'값을 찾아서 NaN으로 바꾸십시오. &lt;code&gt;value&lt;/code&gt; 매개 변수는 없을 것 &lt;code&gt;None&lt;/code&gt; 이 방법으로 중첩 딕셔너리를 사용합니다. 정규식도 중첩 할 수 있습니다. 열 이름 (중첩 사전의 최상위 사전 키) &lt;strong&gt;은&lt;/strong&gt; 정규식이 될 &lt;strong&gt;수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8846fb8a70acde641b5debfcd6c2ee0da0faa87b" translate="yes" xml:space="preserve">
          <source>For a DataFrame with MultiIndex, the keyword</source>
          <target state="translated">MultiIndex가있는 DataFrame의 경우 키워드</target>
        </trans-unit>
        <trans-unit id="da53ca74475e4a9020b470b13ae5f78ed4c4cf4f" translate="yes" xml:space="preserve">
          <source>For a DataFrame with MultiIndex, the keyword &lt;code&gt;level&lt;/code&gt; can be used to specify on which level the resampling needs to take place.</source>
          <target state="translated">MultiIndex가있는 DataFrame의 경우 키워드 &lt;code&gt;level&lt;/code&gt; 을 사용하여 리샘플링을 수행해야하는 수준을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d2cee46e85411966e39c0cf35bb8c9e7a30b92" translate="yes" xml:space="preserve">
          <source>For a DataFrame, a datetime-like column on which to calculate the rolling window, rather than the DataFrame&amp;rsquo;s index. Provided integer column is ignored and excluded from result since an integer index is not used to calculate the rolling window.</source>
          <target state="translated">DataFrame의 경우 DataFrame의 인덱스가 아니라 롤링 창을 계산할 날짜 / 시간 열입니다. 제공된 정수 열은 롤링 창을 계산하는 데 사용되지 않으므로 정수 열이 무시되고 결과에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="3adb768ad47bdbf21cb17ce37e84d56719b00cf6" translate="yes" xml:space="preserve">
          <source>For a DataFrame, a datetime-like column or MultiIndex level on which to calculate the rolling window, rather than the DataFrame&amp;rsquo;s index. Provided integer column is ignored and excluded from result since an integer index is not used to calculate the rolling window.</source>
          <target state="translated">DataFrame의 경우 DataFrame의 인덱스가 아닌 롤링 윈도우를 계산할 날짜 시간과 유사한 열 또는 MultiIndex 수준입니다. 롤링 윈도우를 계산하는 데 정수 인덱스가 사용되지 않으므로 제공된 정수 컬럼은 무시되고 결과에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="789e72a4455aabb90352c01f28608019b93ca564" translate="yes" xml:space="preserve">
          <source>For a DataFrame, column to use instead of index for resampling. Column must be datetime-like.</source>
          <target state="translated">DataFrame의 경우 리샘플링을 위해 인덱스 대신 사용할 열입니다. 열은 날짜 / 시간과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="8a614643ff44ad2970706f562f41b720ffc8fa39" translate="yes" xml:space="preserve">
          <source>For a DataFrame, you can specify individual values by column:</source>
          <target state="translated">DataFrame의 경우 열별로 개별 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="113e89c2fe555fe85a489f03bec86465fd3730da" translate="yes" xml:space="preserve">
          <source>For a DatetimeIndex, string values in</source>
          <target state="translated">DatetimeIndex의 경우 문자열 값</target>
        </trans-unit>
        <trans-unit id="f3b3af660f1ff68f30d407b4b7cab096b6ec3c95" translate="yes" xml:space="preserve">
          <source>For a DatetimeIndex, string values in &lt;code&gt;values&lt;/code&gt; are converted to Timestamps.</source>
          <target state="translated">DatetimeIndex 들어있는 문자열 값 &lt;code&gt;values&lt;/code&gt; 타임 스탬프로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc2552180846e39cc3bac2f745d1892121c98a2e" translate="yes" xml:space="preserve">
          <source>For a MultiIndex, level (name or number) to use for resampling.</source>
          <target state="translated">MultiIndex의 경우 리샘플링에 사용할 레벨 (이름 또는 번호)입니다.</target>
        </trans-unit>
        <trans-unit id="3d4de0881cd69400ed50e4b7d5119d06373a73ed" translate="yes" xml:space="preserve">
          <source>For a MultiIndex, level (name or number) to use for resampling. &lt;code&gt;level&lt;/code&gt; must be datetime-like.</source>
          <target state="translated">다중 인덱스의 경우 리샘플링에 사용할 수준 (이름 또는 번호)입니다. &lt;code&gt;level&lt;/code&gt; 은 날짜 / 시간과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f9ea9f3629cc2bbd62665a7f2bb6bcfc1ae7f358" translate="yes" xml:space="preserve">
          <source>For a MultiIndex, the maximum is determined lexicographically.</source>
          <target state="translated">MultiIndex의 경우 최대 값은 사전 식으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="3b362023808b7faf5e55058a842072797e09a0f0" translate="yes" xml:space="preserve">
          <source>For a MultiIndex, the minimum is determined lexicographically.</source>
          <target state="translated">다중 인덱스의 경우 최소값은 사전 식으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ffca1b2a30c570bc556bfb9c18184ceb152d94" translate="yes" xml:space="preserve">
          <source>For a Series with a MultiIndex, only remove the specified levels from the index. Removes all levels by default.</source>
          <target state="translated">다중 색인이있는 시리즈의 경우 지정된 수준 만 색인에서 제거하십시오. 기본적으로 모든 레벨을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3565de1af18de61c93f710bb157bdda48f297168" translate="yes" xml:space="preserve">
          <source>For a Series with a PeriodIndex, the keyword</source>
          <target state="translated">PeriodIndex가있는 시리즈의 경우 키워드</target>
        </trans-unit>
        <trans-unit id="e713123fa1502df74995a9180a5a8847d4a6ff81" translate="yes" xml:space="preserve">
          <source>For a Series with a PeriodIndex, the keyword &lt;code&gt;convention&lt;/code&gt; can be used to control whether to use the start or end of &lt;code&gt;rule&lt;/code&gt;.</source>
          <target state="translated">PeriodIndex가있는 Series의 경우 키워드 &lt;code&gt;convention&lt;/code&gt; 을 사용하여 &lt;code&gt;rule&lt;/code&gt; 의 시작 또는 끝을 사용할지 여부를 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4233f32e71fccd019269ae7f238dad5f61591155" translate="yes" xml:space="preserve">
          <source>For a Series, you can replace a single value or a list of values by another value:</source>
          <target state="translated">시리즈의 경우 단일 값 또는 값 목록을 다른 값으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc88e84fa639481de82c00c03d459c3cafaed4ed" translate="yes" xml:space="preserve">
          <source>For a boolean mask,</source>
          <target state="translated">부울 마스크의 경우</target>
        </trans-unit>
        <trans-unit id="cc73f9fd9d28a9a7ecb5ff5f13a97eb0bd6600bc" translate="yes" xml:space="preserve">
          <source>For a floating-point index, use &lt;code&gt;method='values'&lt;/code&gt;:</source>
          <target state="translated">부동 소수점 인덱스의 경우 &lt;code&gt;method='values'&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="edbcf39701f36432a165b73da7daf8ea06fe1727" translate="yes" xml:space="preserve">
          <source>For a grouped &lt;code&gt;DataFrame&lt;/code&gt;, you can rename in a similar manner:</source>
          <target state="translated">그룹화 된 &lt;code&gt;DataFrame&lt;/code&gt; 의 경우 비슷한 방식으로 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e71ee73fd0addbae7190921f688d9e2132e9193b" translate="yes" xml:space="preserve">
          <source>For a high level summary of the pandas fundamentals, see &lt;a href=&quot;dsintro#dsintro&quot;&gt;Intro to data structures&lt;/a&gt; and &lt;a href=&quot;basics#basics&quot;&gt;Essential basic functionality&lt;/a&gt;.</source>
          <target state="translated">Pandas 기본 사항에 대한 높은 수준의 요약은 &lt;a href=&quot;dsintro#dsintro&quot;&gt;데이터 구조 소개&lt;/a&gt; 및 &lt;a href=&quot;basics#basics&quot;&gt;필수 기본 기능 &lt;/a&gt;을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="7d95f3d7f90e52ac53c1428810b948a8db5ccb8b" translate="yes" xml:space="preserve">
          <source>For a mix of numeric and non-numeric types, the output array will have object dtype.</source>
          <target state="translated">숫자 유형과 숫자가 아닌 유형을 혼합 한 경우 출력 배열에는 객체 dtype이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62ab9cf97e6a3766f107d39032568a41c805f7e7" translate="yes" xml:space="preserve">
          <source>For a more exhaustive treatment of sophisticated label-based indexing and slicing, see the &lt;a href=&quot;indexing#indexing&quot;&gt;section on indexing&lt;/a&gt;. We will address the fundamentals of reindexing / conforming to new sets of labels in the &lt;a href=&quot;basics#basics-reindexing&quot;&gt;section on reindexing&lt;/a&gt;.</source>
          <target state="translated">정교한 레이블 기반 인덱싱 및 슬라이싱에 대한보다 철저한 처리는 인덱싱 &lt;a href=&quot;indexing#indexing&quot;&gt;섹션을&lt;/a&gt; 참조하십시오 . 재색 인화 &lt;a href=&quot;basics#basics-reindexing&quot;&gt;섹션&lt;/a&gt; 에서 새 레이블 세트를 재색 인화 / 준수하는 기본 사항을 다룰 것 입니다.</target>
        </trans-unit>
        <trans-unit id="eb3a633d57f9bef5f62cf2430f07381e7da87b13" translate="yes" xml:space="preserve">
          <source>For a non-numerical Series object, &lt;a href=&quot;../reference/api/pandas.series.describe#pandas.Series.describe&quot;&gt;&lt;code&gt;describe()&lt;/code&gt;&lt;/a&gt; will give a simple summary of the number of unique values and most frequently occurring values:</source>
          <target state="translated">숫자가 아닌 Series 객체의 경우 &lt;a href=&quot;../reference/api/pandas.series.describe#pandas.Series.describe&quot;&gt; &lt;code&gt;describe()&lt;/code&gt; &lt;/a&gt; 는 고유 값 수와 가장 자주 발생하는 값에 대한 간단한 요약을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="554dd416b4b1bc235371462326b25e8a16df1072" translate="yes" xml:space="preserve">
          <source>For a sequence</source>
          <target state="translated">시퀀스 용</target>
        </trans-unit>
        <trans-unit id="01a90ba1096d0852fabe64494dde3b5ad3fccbce" translate="yes" xml:space="preserve">
          <source>For a sequence &lt;code&gt;where&lt;/code&gt;, a Series is returned. The first value is NaN, because the first element of &lt;code&gt;where&lt;/code&gt; is before the first index value.</source>
          <target state="translated">시퀀스에 대한 일련의 반환됩니다. &lt;code&gt;where&lt;/code&gt; 의 첫 번째 요소가 첫 번째 인덱스 값 앞에 있기 때문에 첫 번째 값은 NaN 입니다. &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1565d1a0363ce87b3bfe0a8612d64cbe534ad0cc" translate="yes" xml:space="preserve">
          <source>For aggregated output, return object with group labels as the index. Only relevant for DataFrame input. as_index=False is effectively &amp;ldquo;SQL-style&amp;rdquo; grouped output.</source>
          <target state="translated">집계 된 출력의 경우 그룹 레이블이있는 개체를 인덱스로 반환하십시오. DataFrame 입력에만 해당됩니다. as_index = 거짓은 사실상&amp;ldquo;SQL 스타일&amp;rdquo;그룹화 된 출력입니다.</target>
        </trans-unit>
        <trans-unit id="4be6aca2dc976b242c9a0ae7d88b2e70ea41f704" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;orient&lt;/code&gt; values except &lt;code&gt;'table'&lt;/code&gt;, default is True.</source>
          <target state="translated">&lt;code&gt;'table'&lt;/code&gt; 을 제외한 모든 &lt;code&gt;orient&lt;/code&gt; 값의 경우 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="71486b234bf1508cdb7b1870e03b25ac7454fab9" translate="yes" xml:space="preserve">
          <source>For all other cases, NumPy&amp;rsquo;s usual inference rules will be used.</source>
          <target state="translated">다른 모든 경우에는 NumPy의 일반적인 추론 규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9803c06d2763e4a515660003892a64d59d75687d" translate="yes" xml:space="preserve">
          <source>For all other pandas objects, an Index of the appropriate type is returned.</source>
          <target state="translated">다른 모든 팬더 객체의 경우 적절한 유형의 인덱스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e42bb69048a156d3d8fde243ee894a4f13f61637" translate="yes" xml:space="preserve">
          <source>For all remaining dtypes &lt;code&gt;.array&lt;/code&gt; will be a &lt;code&gt;arrays.NumpyExtensionArray&lt;/code&gt; wrapping the actual ndarray stored within. If you absolutely need a NumPy array (possibly with copying / coercing data), then use &lt;a href=&quot;pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt;&lt;code&gt;Series.to_numpy()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">나머지 모든 dtype에 대해 &lt;code&gt;.array&lt;/code&gt; 는 arrays.NumpyExtensionArray 가 되어 실제 저장된 &lt;code&gt;arrays.NumpyExtensionArray&lt;/code&gt; 래핑합니다. NumPy 배열이 절대적으로 필요한 경우 (데이터 복사 / 강제 변환과 함께 &lt;a href=&quot;pandas.series.to_numpy#pandas.Series.to_numpy&quot;&gt; &lt;code&gt;Series.to_numpy()&lt;/code&gt; &lt;/a&gt; 대신 Series.to_numpy ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="96d6525e61f00fb8d7f030e51a96b9a38a78b86e" translate="yes" xml:space="preserve">
          <source>For all supported aggregation functions, see &lt;a href=&quot;../reference/window#api-functions-ewm&quot;&gt;Exponentially-weighted window functions&lt;/a&gt;.</source>
          <target state="translated">지원되는 모든 집계 함수는 &lt;a href=&quot;../reference/window#api-functions-ewm&quot;&gt;지수 가중치 창 함수를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="0555b08dfbf3347b8abec3821352f61907c113c8" translate="yes" xml:space="preserve">
          <source>For all supported aggregation functions, see &lt;a href=&quot;../reference/window#api-functions-expanding&quot;&gt;Expanding window functions&lt;/a&gt;.</source>
          <target state="translated">지원되는 모든 집계 함수는 &lt;a href=&quot;../reference/window#api-functions-expanding&quot;&gt;창 함수 확장을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="578eda6fe4cc004a6022b44860b6576f83d68b5c" translate="yes" xml:space="preserve">
          <source>For all supported aggregation functions, see &lt;a href=&quot;../reference/window#api-functions-rolling&quot;&gt;Rolling window functions&lt;/a&gt;.</source>
          <target state="translated">지원되는 모든 집계 함수는 &lt;a href=&quot;../reference/window#api-functions-rolling&quot;&gt;롤링 기간 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1566b7aba8446653c3586ca83d7e77ea3d405ed4" translate="yes" xml:space="preserve">
          <source>For all supported aggregation functions, see &lt;a href=&quot;../reference/window#api-functions-window&quot;&gt;Weighted window functions&lt;/a&gt;.</source>
          <target state="translated">지원되는 모든 집계 함수는 &lt;a href=&quot;../reference/window#api-functions-window&quot;&gt;가중 창 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2506af2c3f808c81da44f555370d766836015a0" translate="yes" xml:space="preserve">
          <source>For ambiguous times, pandas supports explicitly specifying the keyword-only fold argument. Due to daylight saving time, one wall clock time can occur twice when shifting from summer to winter time; fold describes whether the datetime-like corresponds to the first (0) or the second time (1) the wall clock hits the ambiguous time. Fold is supported only for constructing from naive &lt;code&gt;datetime.datetime&lt;/code&gt; (see &lt;a href=&quot;https://docs.python.org/3/library/datetime.html&quot;&gt;datetime documentation&lt;/a&gt; for details) or from &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt;&lt;code&gt;Timestamp&lt;/code&gt;&lt;/a&gt; or for constructing from components (see below). Only &lt;code&gt;dateutil&lt;/code&gt; timezones are supported (see &lt;a href=&quot;https://dateutil.readthedocs.io/en/stable/tz.html#dateutil.tz.enfold&quot;&gt;dateutil documentation&lt;/a&gt; for &lt;code&gt;dateutil&lt;/code&gt; methods that deal with ambiguous datetimes) as &lt;code&gt;pytz&lt;/code&gt; timezones do not support fold (see &lt;a href=&quot;http://pytz.sourceforge.net/index.html&quot;&gt;pytz documentation&lt;/a&gt; for details on how &lt;code&gt;pytz&lt;/code&gt; deals with ambiguous datetimes). To localize an ambiguous datetime with &lt;code&gt;pytz&lt;/code&gt;, please use &lt;a href=&quot;../reference/api/pandas.timestamp.tz_localize#pandas.Timestamp.tz_localize&quot;&gt;&lt;code&gt;Timestamp.tz_localize()&lt;/code&gt;&lt;/a&gt;. In general, we recommend to rely on &lt;a href=&quot;../reference/api/pandas.timestamp.tz_localize#pandas.Timestamp.tz_localize&quot;&gt;&lt;code&gt;Timestamp.tz_localize()&lt;/code&gt;&lt;/a&gt; when localizing ambiguous datetimes if you need direct control over how they are handled.</source>
          <target state="translated">모호한 경우 Pandas는 키워드 전용 접기 인수를 명시 적으로 지정하는 것을 지원합니다. 일광 절약 시간으로 인해 여름 시간에서 겨울 시간으로 전환 할 때 벽시계 시간이 두 번 발생할 수 있습니다. fold는 datetime-like가 벽시계가 모호한 시간에 도달하는 첫 번째 (0) 또는 두 번째 시간 (1)에 해당하는지 여부를 나타냅니다. 접기는 순진한 &lt;code&gt;datetime.datetime&lt;/code&gt; (자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html&quot;&gt;datetime 문서&lt;/a&gt; 참조) 또는 &lt;a href=&quot;../reference/api/pandas.timestamp#pandas.Timestamp&quot;&gt; &lt;code&gt;Timestamp&lt;/code&gt; &lt;/a&gt; 에서 생성하거나 구성 요소 (아래 참조)에서 생성하는 경우에만 지원됩니다 . 만 &lt;code&gt;dateutil&lt;/code&gt; 시간대가 지원됩니다 (참조 &lt;a href=&quot;https://dateutil.readthedocs.io/en/stable/tz.html#dateutil.tz.enfold&quot;&gt;dateutil 문서&lt;/a&gt; 에 대한 &lt;code&gt;dateutil&lt;/code&gt; 방법을 모호한 날짜 시간과 거래하는)와 같은 &lt;code&gt;pytz&lt;/code&gt; 시간대는 접기를 지원하지 않습니다 ( &lt;code&gt;pytz&lt;/code&gt; 가 모호한 날짜 시간을 처리 하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;http://pytz.sourceforge.net/index.html&quot;&gt;pytz 문서&lt;/a&gt; 참조 ). &lt;code&gt;pytz&lt;/code&gt; 로 모호한 날짜 시간을 지역화하려면 &lt;a href=&quot;../reference/api/pandas.timestamp.tz_localize#pandas.Timestamp.tz_localize&quot;&gt; &lt;code&gt;Timestamp.tz_localize()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . 일반적으로 처리 방법을 직접 제어해야하는 경우 모호한 날짜 시간을 지역화 할 때 &lt;a href=&quot;../reference/api/pandas.timestamp.tz_localize#pandas.Timestamp.tz_localize&quot;&gt; &lt;code&gt;Timestamp.tz_localize()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="77ea39534ac1f06e6a5a4da8436b19165b3cdf45" translate="yes" xml:space="preserve">
          <source>For an ordered or unique index, compute the slice indexer for input labels and step.</source>
          <target state="translated">순서가 있거나 고유 한 인덱스의 경우 입력 레이블 및 단계에 대한 슬라이스 인덱서를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="9d0316ddeacecfa8d43c002c574469ad7628692a" translate="yes" xml:space="preserve">
          <source>For any 3rd-party extension types, the array type will be an ExtensionArray.</source>
          <target state="translated">타사 확장 유형의 경우 배열 유형은 ExtensionArray입니다.</target>
        </trans-unit>
        <trans-unit id="3e2da3796382453766522a84a85cb19c666123e8" translate="yes" xml:space="preserve">
          <source>For applying more complex functions on a Series.</source>
          <target state="translated">Series에 더 복잡한 기능을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="cce66206c4d93fc802e5a5acc42d57f753764528" translate="yes" xml:space="preserve">
          <source>For arithmetic operations, this implementation will try to reconstruct a new &lt;code&gt;ExtensionArray&lt;/code&gt; with the result of the element-wise operation. Whether or not that succeeds depends on whether the operation returns a result that&amp;rsquo;s valid for the &lt;code&gt;ExtensionArray&lt;/code&gt;. If an &lt;code&gt;ExtensionArray&lt;/code&gt; cannot be reconstructed, an ndarray containing the scalars returned instead.</source>
          <target state="translated">산술 연산의 경우이 구현은 요소 별 연산의 결과로 새 &lt;code&gt;ExtensionArray&lt;/code&gt; 를 재구성하려고 시도 합니다. 성공 여부는 작업이 &lt;code&gt;ExtensionArray&lt;/code&gt; 에 유효한 결과를 반환하는지 여부에 따라 다릅니다 . &lt;code&gt;ExtensionArray&lt;/code&gt; 를 재구성 할 수없는 경우 스칼라를 포함하는 ndarray가 대신 리턴되었습니다.</target>
        </trans-unit>
        <trans-unit id="d48a831a802c0fa43131f28084da63dc537e014a" translate="yes" xml:space="preserve">
          <source>For array-like input, the &lt;code&gt;.dtype&lt;/code&gt; attribute will be extracted.</source>
          <target state="translated">배열과 같은 입력의 경우 &lt;code&gt;.dtype&lt;/code&gt; 속성이 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="53cc2f1833c58419b5ef08648eaf112ea8c4dc17" translate="yes" xml:space="preserve">
          <source>For axis, the convention is to use something like:</source>
          <target state="translated">축의 경우 규칙은 다음과 같은 것을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="da6740808a23207cdb9b153d35db3bfbad38923e" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, &lt;code&gt;inplace&lt;/code&gt; defaults to &lt;code&gt;True&lt;/code&gt; if not specified. This will change in a future version of pandas - if your code depends on an inplace assignment you should update to explicitly set &lt;code&gt;inplace=True&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 지정하지 않으면 &lt;code&gt;inplace&lt;/code&gt; 의 기본값은 &lt;code&gt;True&lt;/code&gt; 입니다. 이것은 판다의 다음 버전에서 변경 될 것입니다. 코드가 인플레 이스 할당에 의존하는 경우 명시 적으로 &lt;code&gt;inplace=True&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88c22dc946f6f6d62702a43123a7fbb69a6a2685" translate="yes" xml:space="preserve">
          <source>For backwards-compatibility, &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; infers these as either integer or float dtype</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 는이를 정수 또는 부동 dtype으로 추론합니다.</target>
        </trans-unit>
        <trans-unit id="2f7dde26fe01669de65775dcadba882c6971cd2a" translate="yes" xml:space="preserve">
          <source>For backwards-compatibility, &lt;code&gt;object&lt;/code&gt; dtype remains the default type we infer a list of strings to</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;object&lt;/code&gt; dtype은 문자열 목록을 추론하는 기본 유형으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="443c463e30a211dc4fb30ceb94018d434457809e" translate="yes" xml:space="preserve">
          <source>For boolean dtypes, this uses &lt;code&gt;operator.xor()&lt;/code&gt; rather than &lt;code&gt;operator.sub()&lt;/code&gt;. The result is calculated according to current dtype in Dataframe, however dtype of the result is always float64.</source>
          <target state="translated">부울 dtype의 경우 &lt;code&gt;operator.xor()&lt;/code&gt; 대신 &lt;code&gt;operator.sub()&lt;/code&gt; 합니다. 결과는 Dataframe의 현재 dtype에 따라 계산되지만 결과의 dtype은 항상 float64입니다.</target>
        </trans-unit>
        <trans-unit id="db854867e9508de92a0640906e60ab3f05fdd5c0" translate="yes" xml:space="preserve">
          <source>For boolean dtypes, this uses &lt;code&gt;operator.xor()&lt;/code&gt; rather than &lt;code&gt;operator.sub()&lt;/code&gt;. The result is calculated according to current dtype in Series, however dtype of the result is always float64.</source>
          <target state="translated">부울 dtype의 경우 &lt;code&gt;operator.xor()&lt;/code&gt; 대신 &lt;code&gt;operator.sub()&lt;/code&gt; 합니다. 결과는 Series의 현재 dtype에 따라 계산되지만 결과의 dtype은 항상 float64입니다.</target>
        </trans-unit>
        <trans-unit id="3e21f801432cdd0a74665ee64582a8a6c3c72f43" translate="yes" xml:space="preserve">
          <source>For column(s)-on-column(s) operations.</source>
          <target state="translated">열 대 열 작업의 경우.</target>
        </trans-unit>
        <trans-unit id="d641e7cc7c11bb62c80879068b370f0f815e2e7f" translate="yes" xml:space="preserve">
          <source>For column(s)-on-columns(s) operations.</source>
          <target state="translated">열-열 작업의 경우.</target>
        </trans-unit>
        <trans-unit id="ce7ac8dd0ba62a33543b8e693127c8e65d8bb70d" translate="yes" xml:space="preserve">
          <source>For columns with spaces in their name, you can use backtick quoting.</source>
          <target state="translated">이름에 공백이있는 열의 경우 역 따옴표를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd6dbeb2cda0ff9d70317a0dc2f55d6e242e112" translate="yes" xml:space="preserve">
          <source>For comparison methods,</source>
          <target state="translated">비교 방법의 경우</target>
        </trans-unit>
        <trans-unit id="cae4877c2954aa265da0deff1667bbfd19754912" translate="yes" xml:space="preserve">
          <source>For comparison, a full documentation build may take 15 minutes, but a single section may take 15 seconds. Subsequent builds, which only process portions you have changed, will be faster.</source>
          <target state="translated">전체 문서를 작성하는 데 15 분이 걸리지 만 한 섹션에 15 초가 걸릴 수 있습니다. 변경된 부분 만 처리하는 후속 빌드가 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="e2d5198da410c5c9ecfaa69de0bbd6b29efde29a" translate="yes" xml:space="preserve">
          <source>For compatibility with &lt;a href=&quot;pandas.dataframe.to_csv#pandas.DataFrame.to_csv&quot;&gt;&lt;code&gt;to_csv()&lt;/code&gt;&lt;/a&gt;, to_excel serializes lists and dicts to strings before writing.</source>
          <target state="translated">&lt;a href=&quot;pandas.dataframe.to_csv#pandas.DataFrame.to_csv&quot;&gt; &lt;code&gt;to_csv()&lt;/code&gt; &lt;/a&gt; 와의 호환성을 위해 to_excel은 쓰기 전에 목록을 직렬화하고 문자열을 지시합니다.</target>
        </trans-unit>
        <trans-unit id="71ce00c30a542899b20549373acda54c03ba40ea" translate="yes" xml:space="preserve">
          <source>For compatibility with &lt;code&gt;numpy.take()&lt;/code&gt;. Has no effect on the output.</source>
          <target state="translated">&lt;code&gt;numpy.take()&lt;/code&gt; 와 호환됩니다 . 출력에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="892f3307167bf604ac2b5846510ad71c09ca1a90" translate="yes" xml:space="preserve">
          <source>For compatibility with &lt;code&gt;to_csv()&lt;/code&gt;, to_excel serializes lists and dicts to strings before writing.</source>
          <target state="translated">&lt;code&gt;to_csv()&lt;/code&gt; 와의 호환성을 위해 to_excel은 쓰기 전에 목록을 직렬화하고 문자열을 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0c77fe1409d6ced69fda3a755edf5035461c118d" translate="yes" xml:space="preserve">
          <source>For compatibility with CSV writers, ExcelWriter serializes lists and dicts to strings before writing.</source>
          <target state="translated">CSVWriter와의 호환성을 위해 ExcelWriter는 쓰기 전에 목록을 직렬화하고 문자열로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="421d19eba00bb25c4d4a87440dccf2018ca1e028" translate="yes" xml:space="preserve">
          <source>For compatibility with DataFrame.idxmax. Redundant for application on Series.</source>
          <target state="translated">DataFrame.idxmax와의 호환성 Series에 적용하기 위해 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="7a82d9cc16bb369d7fbfc0b3e272962659859f5e" translate="yes" xml:space="preserve">
          <source>For compatibility with DataFrame.idxmin. Redundant for application on Series.</source>
          <target state="translated">DataFrame.idxmin과의 호환성 Series에 적용하기 위해 중복됩니다.</target>
        </trans-unit>
        <trans-unit id="682e58232ae1e457b9e2a1160071d2cc9dae7e41" translate="yes" xml:space="preserve">
          <source>For compatibility with NumPy. Only 0 or None are allowed.</source>
          <target state="translated">NumPy와 호환됩니다. 0 또는 없음 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd040ea8536374d7db78bffe2fa7be28b925b715" translate="yes" xml:space="preserve">
          <source>For compatibility with other expanding methods. Has no effect on the computed median.</source>
          <target state="translated">다른 확장 방법과 호환됩니다. 계산 된 중앙값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d526a6a537750ab15674ab070a52b26e13fe948" translate="yes" xml:space="preserve">
          <source>For compatibility with other expanding methods. Has no effect on the computed value.</source>
          <target state="translated">다른 확장 방법과 호환됩니다. 계산 된 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62cf001ef6e381fc194a00eece8a3d83bd70384b" translate="yes" xml:space="preserve">
          <source>For compatibility with other expanding methods. Has no effect on the result.</source>
          <target state="translated">다른 확장 방법과 호환됩니다. 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="270f4f8a2d0ddf58665aae97b508e7592b296570" translate="yes" xml:space="preserve">
          <source>For compatibility with other rolling methods. Has no effect on the computed median.</source>
          <target state="translated">다른 롤링 방법과 호환됩니다. 계산 된 중앙값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d48069a518f252645211551d5b782a4d3ae50bd" translate="yes" xml:space="preserve">
          <source>For compatibility with other rolling methods. Has no effect on the computed value.</source>
          <target state="translated">다른 롤링 방법과 호환됩니다. 계산 된 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92fa9e8d7cc3b93a3c1a5a58e5c858192ccca880" translate="yes" xml:space="preserve">
          <source>For compatibility with other rolling methods. Has no effect on the result.</source>
          <target state="translated">다른 롤링 방법과 호환됩니다. 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad87d7a33557969da44eab7eea542616525c83ca" translate="yes" xml:space="preserve">
          <source>For compatibility with other string methods. Not used.</source>
          <target state="translated">다른 문자열 메서드와 호환됩니다. 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="417878975f2d756def24125d3c196726898b78a2" translate="yes" xml:space="preserve">
          <source>For compatibility with other window methods. Has no effect on the computed value.</source>
          <target state="translated">다른 창 방법과 호환됩니다. 계산 된 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aa6b928c51d22e554165d982b411595147cd7b1" translate="yes" xml:space="preserve">
          <source>For compatibility. Has no effect on the result.</source>
          <target state="translated">호환성을 위해. 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2110c380ed7d3738432180be67c9c94da571483f" translate="yes" xml:space="preserve">
          <source>For complex types, define the subtypes. For &lt;code&gt;dict&lt;/code&gt; and &lt;code&gt;tuple&lt;/code&gt;, as more than one type is present, we use the brackets to help read the type (curly brackets for &lt;code&gt;dict&lt;/code&gt; and normal brackets for &lt;code&gt;tuple&lt;/code&gt;):</source>
          <target state="translated">복합 유형의 경우 하위 유형을 정의하십시오. 들어 &lt;code&gt;dict&lt;/code&gt; 및 &lt;code&gt;tuple&lt;/code&gt; 하나 개 이상의 유형이 존재하는 한, 우리는 도움에 브래킷 유형 (대한 중괄호 읽고 사용 &lt;code&gt;dict&lt;/code&gt; 와 정상 괄호 &lt;code&gt;tuple&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="7f61a5d4675425ab94021a5387681bff1f104b47" translate="yes" xml:space="preserve">
          <source>For concatenation with a &lt;code&gt;Series&lt;/code&gt; or &lt;code&gt;DataFrame&lt;/code&gt;, it is possible to align the indexes before concatenation by setting the &lt;code&gt;join&lt;/code&gt;-keyword.</source>
          <target state="translated">&lt;code&gt;Series&lt;/code&gt; 또는 &lt;code&gt;DataFrame&lt;/code&gt; 과의 연결의 경우 &lt;code&gt;join&lt;/code&gt; -keyword 를 설정하여 연결하기 전에 인덱스를 정렬 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaa1d48873e9f269ce084ff5f17780a27f97b08c" translate="yes" xml:space="preserve">
          <source>For consistency with pandas methods, you should raise an &lt;code&gt;AttributeError&lt;/code&gt; if the data passed to your accessor has an incorrect dtype.</source>
          <target state="translated">팬더 메소드와 일관성을 유지 하려면 접근 자에게 전달 된 데이터에 잘못된 dtype이있는 경우 &lt;code&gt;AttributeError&lt;/code&gt; 를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="e478e047f30809e5637c5cd5a7d528652f15839b" translate="yes" xml:space="preserve">
          <source>For convenience, we provide the &lt;code&gt;Styler.from_custom_template&lt;/code&gt; method that does the same as the custom subclass.</source>
          <target state="translated">편의상 사용자 정의 서브 클래스와 동일한 &lt;code&gt;Styler.from_custom_template&lt;/code&gt; 메소드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="530ca33a011c894a0aad35a33c68166224cba548" translate="yes" xml:space="preserve">
          <source>For data grouped with &lt;code&gt;by&lt;/code&gt;, return a Series of the above or a numpy array:</source>
          <target state="translated">&lt;code&gt;by&lt;/code&gt; 로 그룹화 된 데이터 의 경우 위의 Series 또는 numpy 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b75696dcc2c895e64ec96df623092d2c62062db" translate="yes" xml:space="preserve">
          <source>For datetime64[ns] types, &lt;code&gt;NaT&lt;/code&gt; represents missing values. This is a pseudo-native sentinel value that can be represented by NumPy in a singular dtype (datetime64[ns]). pandas objects provide compatibility between &lt;code&gt;NaT&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">datetime64 [ns] 유형의 경우 &lt;code&gt;NaT&lt;/code&gt; 는 누락 된 값을 나타냅니다. 이것은 단일 dtype (datetime64 [ns])에서 NumPy로 표현할 수있는 의사 네이티브 센티넬 값입니다. pandas 객체는 &lt;code&gt;NaT&lt;/code&gt; 와 &lt;code&gt;NaN&lt;/code&gt; 간의 호환성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="165c51e954c9957a1abe9c5f2f1d2a62b2f81090" translate="yes" xml:space="preserve">
          <source>For datetimes,</source>
          <target state="translated">datetimes의 경우</target>
        </trans-unit>
        <trans-unit id="712adfd871e02781142dacd9c5bf9f30bfb7ab0f" translate="yes" xml:space="preserve">
          <source>For datetimes, &lt;code&gt;NaT&lt;/code&gt; (Not a Time) is considered as an NA value.</source>
          <target state="translated">날짜 시간의 경우 &lt;code&gt;NaT&lt;/code&gt; (시간 아님)는 NA 값으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1d718e4f35381c99658c499ed426b9114cf87bab" translate="yes" xml:space="preserve">
          <source>For dict-like &lt;code&gt;new_categories&lt;/code&gt;, extra keys are ignored and categories not in the dictionary are passed through</source>
          <target state="translated">dict-like &lt;code&gt;new_categories&lt;/code&gt; 의 경우 추가 키가 무시되고 사전에없는 카테고리가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d505a50b69e450b7efa269e808b1acbe1ca46c15" translate="yes" xml:space="preserve">
          <source>For documentation on pyarrow, see &lt;a href=&quot;https://arrow.apache.org/docs/python/index.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">pyarrow에 대한 문서는 &lt;a href=&quot;https://arrow.apache.org/docs/python/index.html&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="85601a197bfcb02f2dc37ddcbfa6b49628b0f64b" translate="yes" xml:space="preserve">
          <source>For downsampling, &lt;code&gt;closed&lt;/code&gt; can be set to &amp;lsquo;left&amp;rsquo; or &amp;lsquo;right&amp;rsquo; to specify which end of the interval is closed:</source>
          <target state="translated">다운 샘플링의 경우 &lt;code&gt;closed&lt;/code&gt; 를 'left'또는 'right'로 설정하여 닫히는 간격의 끝을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04df7995647b4f7420c27617fdceafceaebe390a" translate="yes" xml:space="preserve">
          <source>For each column/row the number of non-NA/null entries. If</source>
          <target state="translated">각 열 / 행에 대해 비 NA / 널 항목 수. 만약</target>
        </trans-unit>
        <trans-unit id="0e896148fb1025cfcb3bd14a920fb320137f8a96" translate="yes" xml:space="preserve">
          <source>For each column/row the number of non-NA/null entries. If &lt;code&gt;level&lt;/code&gt; is specified returns a &lt;code&gt;DataFrame&lt;/code&gt;.</source>
          <target state="translated">각 열 / 행에 대해 비 NA / 널 항목의 수입니다. 경우 &lt;code&gt;level&lt;/code&gt; 지정된 리턴한다이다 &lt;code&gt;DataFrame&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee8537ea0c23406bcaff79eb4b083d0a0666a728" translate="yes" xml:space="preserve">
          <source>For each kind of plot (e.g. &lt;code&gt;line&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;scatter&lt;/code&gt;) any additional arguments keywords are passed along to the corresponding matplotlib function (&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot&quot;&gt;&lt;code&gt;ax.plot()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar&quot;&gt;&lt;code&gt;ax.bar()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter&quot;&gt;&lt;code&gt;ax.scatter()&lt;/code&gt;&lt;/a&gt;). These can be used to control additional styling, beyond what pandas provides.</source>
          <target state="translated">각 종류의 플롯 (예 : &lt;code&gt;line&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; , &lt;code&gt;scatter&lt;/code&gt; )에 대해 추가 인수 키워드가 해당 matplotlib 함수 ( &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.plot.html#matplotlib.axes.Axes.plot&quot;&gt; &lt;code&gt;ax.plot()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.bar.html#matplotlib.axes.Axes.bar&quot;&gt; &lt;code&gt;ax.bar()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.axes.Axes.scatter.html#matplotlib.axes.Axes.scatter&quot;&gt; &lt;code&gt;ax.scatter()&lt;/code&gt; &lt;/a&gt; )에 전달됩니다. 팬더가 제공하는 것 이상의 추가 스타일을 제어하는 ​​데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf3b6a87dfe0995e3d922eddc4fa9a03403c193e" translate="yes" xml:space="preserve">
          <source>For each row in the left DataFrame:</source>
          <target state="translated">왼쪽 DataFrame의 각 행에 대해 :</target>
        </trans-unit>
        <trans-unit id="6c8f7af9b2a4abfa72e760e544079f542f23d1d2" translate="yes" xml:space="preserve">
          <source>For each string in the Series, extract groups from all matches of regular expression and return a DataFrame with one row for each match and one column for each group.</source>
          <target state="translated">Series의 각 문자열에 대해 정규식의 모든 일치 항목에서 그룹을 추출하고 각 일치 항목에 대해 하나의 행과 각 그룹에 대해 하나의 열이있는 DataFrame을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a8013b5a5cfc1ecec1d78fd3896b2b663275d0b" translate="yes" xml:space="preserve">
          <source>For each subject string in the Series, extract groups from all matches of regular expression pat.</source>
          <target state="translated">시리즈의 각 주제 문자열에 대해 정규 표현식 pat의 모든 일치 항목에서 그룹을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="ba1438dd50f0f247483fe45f89b371bb933d5d9a" translate="yes" xml:space="preserve">
          <source>For each subject string in the Series, extract groups from all matches of regular expression pat. When each subject string in the Series has exactly one match, extractall(pat).xs(0, level=&amp;rsquo;match&amp;rsquo;) is the same as extract(pat).</source>
          <target state="translated">시리즈의 각 주제 문자열에 대해 정규 표현식 pat의 모든 일치 항목에서 그룹을 추출하십시오. Series의 각 주제 문자열이 정확히 하나의 일치를 갖는 경우 extractall (pat) .xs (0, level = 'match')는 extract (pat)와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8a667787b0b2314ce27d7dc11e4f2ed9fd830304" translate="yes" xml:space="preserve">
          <source>For each subject string in the Series, extract groups from the first match of regular expression</source>
          <target state="translated">시리즈의 각 주제 문자열에 대해 정규식의 첫 번째 일치 항목에서 그룹을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="cf885ae2709de792f6cfe528fc9715e262e95052" translate="yes" xml:space="preserve">
          <source>For each subject string in the Series, extract groups from the first match of regular expression &lt;code&gt;pat&lt;/code&gt;.</source>
          <target state="translated">시리즈의 각 주제 문자열에 대해 정규식 &lt;code&gt;pat&lt;/code&gt; 의 첫 번째 일치 항목에서 그룹을 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b263c3151928f3ce7454cfc3f55c4fb3140e1b7" translate="yes" xml:space="preserve">
          <source>For ease of implementation and consistency with operations between pandas and NumPy ndarrays, we recommend &lt;em&gt;not&lt;/em&gt; handling Series and Indexes in your binary ops. Instead, you should detect these cases and return &lt;code&gt;NotImplemented&lt;/code&gt;. When pandas encounters an operation like &lt;code&gt;op(Series, ExtensionArray)&lt;/code&gt;, pandas will</source>
          <target state="translated">팬더와 NumPy ndarray 간의 작업을 쉽게 구현하고 일관성을 유지하려면 이진 op에서 시리즈 및 인덱스를 처리 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다 . 대신, 이러한 경우를 감지하고 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환해야합니다 . 팬더가 &lt;code&gt;op(Series, ExtensionArray)&lt;/code&gt; 와 같은 연산을 만나면 팬더는</target>
        </trans-unit>
        <trans-unit id="0b428761c16dd513688f80f7e2d35def7bd81810" translate="yes" xml:space="preserve">
          <source>For element-wise operations.</source>
          <target state="translated">요소 별 작업</target>
        </trans-unit>
        <trans-unit id="9efa8ddf7a616d448dd8c77c680a4296fa2076d4" translate="yes" xml:space="preserve">
          <source>For elementwise operations.</source>
          <target state="translated">요소 별 작업용.</target>
        </trans-unit>
        <trans-unit id="37c305823aeeca0be506f34cc3e70904d41c758f" translate="yes" xml:space="preserve">
          <source>For example, (3, 5) will display the subplots using 3 columns and 5 rows, starting from the top-left.</source>
          <target state="translated">예를 들어 (3, 5)는 왼쪽 상단부터 3 개의 열과 5 개의 행을 사용하여 하위 그림을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e9b129c0fba20f5ef04003c663591ea8463c7535" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://dask.org&quot;&gt;Dask&lt;/a&gt;, a parallel computing library, has &lt;a href=&quot;https://docs.dask.org/en/latest/dataframe.html&quot;&gt;dask.dataframe&lt;/a&gt;, a pandas-like API for working with larger than memory datasets in parallel. Dask can use multiple threads or processes on a single machine, or a cluster of machines to process data in parallel.</source>
          <target state="translated">예를 들어 병렬 컴퓨팅 라이브러리 인 &lt;a href=&quot;https://dask.org&quot;&gt;Dask&lt;/a&gt; 에는 메모리보다 큰 데이터 세트를 병렬로 작업하기위한 팬더와 유사한 API 인 &lt;a href=&quot;https://docs.dask.org/en/latest/dataframe.html&quot;&gt;dask.dataframe이&lt;/a&gt; 있습니다. Dask는 단일 컴퓨터 또는 컴퓨터 클러스터에서 여러 스레드 또는 프로세스를 사용하여 데이터를 병렬로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="180f123bbf972f2172b8b06a94f7d25e2428e823" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;pd.NA&lt;/code&gt; propagates in arithmetic operations, similarly to &lt;code&gt;np.nan&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;pd.NA&lt;/code&gt; 는 유사에, 산술 연산에 전파 &lt;code&gt;np.nan&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c115a20f4c461197761f6446cee18ae7403dd35a" translate="yes" xml:space="preserve">
          <source>For example, a bar plot can be created the following way:</source>
          <target state="translated">예를 들어 다음과 같은 방법으로 막대 플롯을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74da2e0f3f8c3b1e02cb504bb3d9cefb8792c71f" translate="yes" xml:space="preserve">
          <source>For example, for the logical &amp;ldquo;or&amp;rdquo; operation (&lt;code&gt;|&lt;/code&gt;), if one of the operands is &lt;code&gt;True&lt;/code&gt;, we already know the result will be &lt;code&gt;True&lt;/code&gt;, regardless of the other value (so regardless the missing value would be &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;). In this case, &lt;code&gt;pd.NA&lt;/code&gt; does not propagate:</source>
          <target state="translated">예를 들어, 논리적 &quot;또는&quot;동작 ( &lt;code&gt;|&lt;/code&gt; ), 피연산자 중 하나가있는 경우 &lt;code&gt;True&lt;/code&gt; , 우리가 이미있을 것입니다 결과를 알고있는 &lt;code&gt;True&lt;/code&gt; 에 관계없이 다른 값을, (그래서 관계없이 누락 된 값이 될 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; ). 이 경우 &lt;code&gt;pd.NA&lt;/code&gt; 는 다음을 전파하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67e85a7f7191a1ab3472f78358b6af5d8dd96860" translate="yes" xml:space="preserve">
          <source>For example, for two dates that are in British Summer Time (and so would normally be GMT+1), both the following asserts evaluate as true:</source>
          <target state="translated">예를 들어 영국 서머 타임 (일반적으로 GMT + 1) 인 두 날짜의 경우 다음 두 주장이 모두 참으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ab93ecae85bc77f392f050f7d7da5999a2438c2f" translate="yes" xml:space="preserve">
          <source>For example, having the right endpoint open is useful in many problems that require that there is no contamination from present information back to past information. This allows the rolling window to compute statistics &amp;ldquo;up to that point in time&amp;rdquo;, but not including that point in time.</source>
          <target state="translated">예를 들어, 올바른 엔드 포인트를 개방하는 것은 현재 정보에서 과거 정보로의 오염이 없어야하는 많은 문제에서 유용합니다. 이렇게하면 롤링 윈도우가 &quot;해당 시점까지&quot;통계를 계산할 수 있지만 해당 시점은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bc0883976afb6fd2e8d1608bbacecae53f40d32" translate="yes" xml:space="preserve">
          <source>For example, if one of your columns is called &lt;code&gt;a a&lt;/code&gt; and you want to sum it with &lt;code&gt;b&lt;/code&gt;, your query should be &lt;code&gt;`a a` + b&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 열 중 하나가 &lt;code&gt;a a&lt;/code&gt; 이고 &lt;code&gt;b&lt;/code&gt; 와 합산하려는 경우 쿼리는 &lt;code&gt;`a a` + b&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8837e09177570ef2fc18f8fe482af8df2c775edb" translate="yes" xml:space="preserve">
          <source>For example, if we have the following :class:&lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음과 같은 경우 : class : &lt;code&gt;DataFrame&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6ca22605cae37c216e28e1cb77d486844be5c2b8" translate="yes" xml:space="preserve">
          <source>For example, in the following case setting the value has no effect:</source>
          <target state="translated">예를 들어 다음과 같은 경우 값을 설정해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b1b1413b8890ab066d563b1385f683dd21254b13" translate="yes" xml:space="preserve">
          <source>For example, lists are considered iterators but not strings or datetime objects.</source>
          <target state="translated">예를 들어, 목록은 반복자로 간주되지만 문자열 또는 날짜 / 시간 객체는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="279a52aeb05ecab7dc34b429cf7719ea2fbf16d7" translate="yes" xml:space="preserve">
          <source>For example, numeric containers will always use &lt;code&gt;NaN&lt;/code&gt; regardless of the missing value type chosen:</source>
          <target state="translated">예를 들어 숫자 컨테이너는 선택한 누락 값 유형에 관계없이 항상 &lt;code&gt;NaN&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="464d922a7e68fc268ab6bbb6390b2b16e301b70a" translate="yes" xml:space="preserve">
          <source>For example, pandas supports:</source>
          <target state="translated">예를 들어, 팬더는 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="055a735f82bf582d42d1192000e2da2f55f4b258" translate="yes" xml:space="preserve">
          <source>For example, suppose we wished to standardize the data within each group:</source>
          <target state="translated">예를 들어, 각 그룹 내에서 데이터를 표준화하고 싶다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="96b628fab275ecfc77c43e9e5d58c18b31cbc026" translate="yes" xml:space="preserve">
          <source>For example, the above conjunction can be written without parentheses. Alternatively, you can use the &lt;code&gt;'python'&lt;/code&gt; parser to enforce strict Python semantics.</source>
          <target state="translated">예를 들어, 위의 접속사는 괄호없이 쓸 수 있습니다. 또는 &lt;code&gt;'python'&lt;/code&gt; 파서를 사용하여 엄격한 Python 의미 체계를 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e6a6c303a99087c83038e8fde36d84f175775ba" translate="yes" xml:space="preserve">
          <source>For example, the memory usage of the &lt;code&gt;DataFrame&lt;/code&gt; below is shown when calling &lt;a href=&quot;../reference/api/pandas.dataframe.info#pandas.DataFrame.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;../reference/api/pandas.dataframe.info#pandas.DataFrame.info&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; 호출 할 때 아래 의 &lt;code&gt;DataFrame&lt;/code&gt; 메모리 사용량 이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cb80fbe94eaef5ddb083f1c3b19d25468c88f28" translate="yes" xml:space="preserve">
          <source>For example, to back-propagate the last valid value to fill the &lt;code&gt;NaN&lt;/code&gt; values, pass &lt;code&gt;bfill&lt;/code&gt; as an argument to the &lt;code&gt;method&lt;/code&gt; keyword.</source>
          <target state="translated">예를 들어, &lt;code&gt;NaN&lt;/code&gt; 값 을 채우기 위해 마지막 유효 값을 역 전파하려면 &lt;code&gt;bfill&lt;/code&gt; 을 &lt;code&gt;method&lt;/code&gt; 키워드 의 인수로 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6d5779d89e47439b1710cbcaea1bead76736b3f" translate="yes" xml:space="preserve">
          <source>For example, to localize and convert a naive stamp to time zone aware.</source>
          <target state="translated">예를 들어, 순진한 스탬프를 표준 시간대 인식으로 현지화하고 변환합니다.</target>
        </trans-unit>
        <trans-unit id="35e721fe6c3eeacb93a3450db759022142d159e0" translate="yes" xml:space="preserve">
          <source>For example, to read in a &lt;code&gt;MultiIndex&lt;/code&gt; index without names:</source>
          <target state="translated">예를 들어, 이름없이 &lt;code&gt;MultiIndex&lt;/code&gt; 인덱스 를 읽으려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2faabbb8efeb51a51e437c62ae28599c9954e434" translate="yes" xml:space="preserve">
          <source>For example, to select &lt;code&gt;bool&lt;/code&gt; columns:</source>
          <target state="translated">예를 들어 &lt;code&gt;bool&lt;/code&gt; 열 을 선택하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bc6c73acb0d1f19b5693e06a33934d86173f09a" translate="yes" xml:space="preserve">
          <source>For example, to select all numeric and boolean columns while excluding unsigned integers:</source>
          <target state="translated">예를 들어, 부호없는 정수를 제외하고 모든 숫자 및 부울 열을 선택하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f4fe295591361842d5833db2be6f9819f1f994ac" translate="yes" xml:space="preserve">
          <source>For example, we can fit a regression using statsmodels. Their API expects a formula first and a &lt;code&gt;DataFrame&lt;/code&gt; as the second argument, &lt;code&gt;data&lt;/code&gt;. We pass in the function, keyword pair &lt;code&gt;(sm.ols, 'data')&lt;/code&gt; to &lt;code&gt;pipe&lt;/code&gt;:</source>
          <target state="translated">예를 들어 통계 모델을 사용하여 회귀를 피팅 할 수 있습니다. 이들 API 먼저 화학식 및 기대 &lt;code&gt;DataFrame&lt;/code&gt; 번째 인수로서 &lt;code&gt;data&lt;/code&gt; . 함수, 키워드 쌍 &lt;code&gt;(sm.ols, 'data')&lt;/code&gt; 을 &lt;code&gt;pipe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52893b067b3f51c5e418dd1219158d210548e5cb" translate="yes" xml:space="preserve">
          <source>For example, when having missing values in a Series with the nullable integer dtype, it will use &lt;code&gt;pd.NA&lt;/code&gt;:</source>
          <target state="translated">예를 들어, nullable 정수 dtype이있는 Series에서 누락 된 값이있는 경우 &lt;code&gt;pd.NA&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="9030653cea0c8e5d577e02dac683c6b975cca384" translate="yes" xml:space="preserve">
          <source>For example, with a single value:</source>
          <target state="translated">예를 들어, 단일 값으로</target>
        </trans-unit>
        <trans-unit id="b80548da1794b78acac386b479af60bc8d680d48" translate="yes" xml:space="preserve">
          <source>For example, with tabular data (DataFrame) it is more semantically helpful to think of the &lt;strong&gt;index&lt;/strong&gt; (the rows) and the &lt;strong&gt;columns&lt;/strong&gt; rather than axis 0 and axis 1. Iterating through the columns of the DataFrame thus results in more readable code:</source>
          <target state="translated">예를 들어 테이블 형식의 데이터 (DataFrame)를 사용하면 &lt;strong&gt;인덱스&lt;/strong&gt; (행)와 &lt;strong&gt;열&lt;/strong&gt; 을 생각하는 것이 의미 적으로 도움이됩니다.&lt;strong&gt;&lt;/strong&gt; 축 0과 축 1이 아니라 . 따라서 DataFrame의 열을 반복하면 코드를보다 쉽게 ​​읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c46fc59b290c4826a3cc5386a362ae8c173d4231" translate="yes" xml:space="preserve">
          <source>For example, you might want to compare two &lt;code&gt;DataFrame&lt;/code&gt; and stack their differences side by side.</source>
          <target state="translated">예를 들어 두 &lt;code&gt;DataFrame&lt;/code&gt; 을 비교 하고 차이점을 나란히 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f42ece28b7e9e63b840a5e75141439ae2c615b2" translate="yes" xml:space="preserve">
          <source>For example.</source>
          <target state="translated">예를 들면.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4c2fcd64fb673a3f628441e0740432a8e29358c" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;fillna, ffill, bfill, shift.&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;fillna, ffill, bfill, shift.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="852c46d829944b38ac825ba6035e46611acbb92c" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;head, tail&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;head, tail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2a014e51b9811cdb8c29dcdc0fa6405e58b0d3" translate="yes" xml:space="preserve">
          <source>For example; we might have &lt;code&gt;trades&lt;/code&gt; and &lt;code&gt;quotes&lt;/code&gt; and we want to &lt;code&gt;asof&lt;/code&gt; merge them.</source>
          <target state="translated">예를 들면 다음과 같습니다. 우리는있을 수 있습니다 &lt;code&gt;trades&lt;/code&gt; 및 &lt;code&gt;quotes&lt;/code&gt; 우리가 원하는 &lt;code&gt;asof&lt;/code&gt; 병합 그들.</target>
        </trans-unit>
        <trans-unit id="91b2e9351ebfbbc5dedad682a1223e44fcc8a705" translate="yes" xml:space="preserve">
          <source>For examples that use the &lt;code&gt;StringIO&lt;/code&gt; class, make sure you import it according to your Python version, i.e. &lt;code&gt;from StringIO import StringIO&lt;/code&gt; for Python 2 and &lt;code&gt;from io import StringIO&lt;/code&gt; for Python 3.</source>
          <target state="translated">&lt;code&gt;StringIO&lt;/code&gt; 클래스 를 사용하는 예제 의 경우 Python 버전에 따라, 즉 &lt;code&gt;from StringIO import StringIO&lt;/code&gt; Python 2의 경우 및 Python 3의 경우 &lt;code&gt;from io import StringIO&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0b492ff26ca6868cc19ebcd9584bb49a83b19653" translate="yes" xml:space="preserve">
          <source>For examples that use the &lt;code&gt;StringIO&lt;/code&gt; class, make sure you import it with &lt;code&gt;from io import StringIO&lt;/code&gt; for Python 3.</source>
          <target state="translated">&lt;code&gt;StringIO&lt;/code&gt; 클래스 를 사용하는 예제의 경우 Python 3 용 &lt;code&gt;from io import StringIO&lt;/code&gt; 를 사용하여 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="9283b22c9244a562200262d59ce7ac558c716200" translate="yes" xml:space="preserve">
          <source>For explicit control over the matching and broadcasting behavior, see the section on &lt;a href=&quot;basics#basics-binop&quot;&gt;flexible binary operations&lt;/a&gt;.</source>
          <target state="translated">일치 및 브로드 캐스팅 동작에 대한 명시적인 제어는 &lt;a href=&quot;basics#basics-binop&quot;&gt;유연한 이진 연산&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="ea3aa86a7b39570367d49900d470e7176b05cd6d" translate="yes" xml:space="preserve">
          <source>For extension dtypes with arguments the following may be an adequate implementation.</source>
          <target state="translated">인수가있는 확장 dtype의 경우 다음이 적절하게 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c684be8400a56e476dac6a264012c6b6dd3de56" translate="yes" xml:space="preserve">
          <source>For extension types, &lt;code&gt;to_numpy()&lt;/code&gt;&lt;em&gt;may&lt;/em&gt; require copying data and coercing the result to a NumPy type (possibly object), which may be expensive. When you need a no-copy reference to the underlying data, &lt;a href=&quot;pandas.series.array#pandas.Series.array&quot;&gt;&lt;code&gt;Series.array&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">확장 유형의 경우 &lt;code&gt;to_numpy()&lt;/code&gt; &lt;em&gt;는&lt;/em&gt; 데이터를 복사하고 결과를 NumPy 유형 (가능한 객체)으로 강제 변환해야 할 수 있습니다. 기본 데이터에 대한 복사 금지 참조가 필요할 때 &lt;a href=&quot;pandas.series.array#pandas.Series.array&quot;&gt; &lt;code&gt;Series.array&lt;/code&gt; &lt;/a&gt; 를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="03b1f4bf9be095aecf99c6cb089e00e05b6c05b6" translate="yes" xml:space="preserve">
          <source>For extension types, like Categorical, the actual ExtensionArray is returned</source>
          <target state="translated">Categorical과 같은 확장 유형의 경우 실제 ExtensionArray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fae567579428a20098b6a5f9391d3703064bf4b8" translate="yes" xml:space="preserve">
          <source>For finer-tuned control, see hierarchical indexing documentation along with the related stack/unstack methods.</source>
          <target state="translated">미세 조정 된 제어에 대해서는 관련 스택 / 언 스택 방법과 함께 계층 적 인덱싱 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b49eeebdd1bc77e11a74ab6654b10dab27ab314" translate="yes" xml:space="preserve">
          <source>For float arg, precision rounding might happen. To prevent unexpected behavior use a fixed-width exact type.</source>
          <target state="translated">float arg의 경우 정밀 반올림이 발생할 수 있습니다. 예기치 않은 동작을 방지하려면 고정 너비 정확한 유형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2425d9f00218ce8436b5df2b98dc0bfa0e2d7bcb" translate="yes" xml:space="preserve">
          <source>For frequencies that evenly subdivide 1 day, the &amp;ldquo;origin&amp;rdquo; of the aggregated intervals. For example, for &amp;lsquo;5min&amp;rsquo; frequency, base could range from 0 through 4. Defaults to 0.</source>
          <target state="translated">1 일로 균등하게 세분화되는 빈도의 경우 집계 된 간격의 &quot;원점&quot;입니다. 예를 들어 '5 분'주파수의 경우 기본 범위는 0에서 4까지입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="902b44edc63b15cf2b27d7f9c8b037f4c244432a" translate="yes" xml:space="preserve">
          <source>For further details and examples see the &lt;code&gt;mask&lt;/code&gt; documentation in &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;indexing&lt;/a&gt;.</source>
          <target state="translated">자세한 내용과 예 는 &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;인덱싱&lt;/a&gt; 의 &lt;code&gt;mask&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2bcb4c081d2c20234d293359cc695af15e903af" translate="yes" xml:space="preserve">
          <source>For further details and examples see the &lt;code&gt;query&lt;/code&gt; documentation in &lt;a href=&quot;../../user_guide/indexing#indexing-query&quot;&gt;indexing&lt;/a&gt;.</source>
          <target state="translated">자세한 내용과 예 는 &lt;a href=&quot;../../user_guide/indexing#indexing-query&quot;&gt;인덱싱&lt;/a&gt; 의 &lt;code&gt;query&lt;/code&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f143995453a00fe6d03094e989011811f9955e" translate="yes" xml:space="preserve">
          <source>For further details and examples see the &lt;code&gt;where&lt;/code&gt; documentation in &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;indexing&lt;/a&gt;.</source>
          <target state="translated">자세한 내용과 예 는 &lt;a href=&quot;../../user_guide/indexing#indexing-where-mask&quot;&gt;색인화 &lt;/a&gt; &lt;code&gt;where&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="561b283987d4cf733b9db1d454e282ce47e5c4fb" translate="yes" xml:space="preserve">
          <source>For further details see Wikipedia&amp;rsquo;s entry for &lt;a href=&quot;https://en.wikipedia.org/wiki/Box_plot&quot;&gt;boxplot&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 Wikipedia의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Box_plot&quot;&gt;boxplot&lt;/a&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0990c38a717ea76a4fa9438979f01efd090f8b2b" translate="yes" xml:space="preserve">
          <source>For getting &lt;em&gt;multiple&lt;/em&gt; indexers, using &lt;code&gt;.get_indexer&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;여러&lt;/em&gt; 인덱서 를 가져 &lt;code&gt;.get_indexer&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bd9b0f46db1b41a174605df3b4f48986222dfc0" translate="yes" xml:space="preserve">
          <source>For getting a cross section using a label (equivalent to &lt;code&gt;df.xs('a')&lt;/code&gt;):</source>
          <target state="translated">레이블을 사용하여 횡단면을 &lt;code&gt;df.xs('a')&lt;/code&gt; 와 동일 ) :</target>
        </trans-unit>
        <trans-unit id="032dcab4ce9d2e8b77bdeca4cad14954ff5577a1" translate="yes" xml:space="preserve">
          <source>For getting a cross section using a label:</source>
          <target state="translated">레이블을 사용하여 횡단면을 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="118c5cc152fdfdcf7aa3b2bff7653d84abd6eb16" translate="yes" xml:space="preserve">
          <source>For getting a cross section using an integer position (equiv to &lt;code&gt;df.xs(1)&lt;/code&gt;):</source>
          <target state="translated">정수 위치를 사용하여 횡단면을 &lt;code&gt;df.xs(1)&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="113519e4cc9b0efdd9900ae4c24a32a3db774fe2" translate="yes" xml:space="preserve">
          <source>For getting a scalar value:</source>
          <target state="translated">스칼라 값을 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="6fac7e1124f85b3137e77848161606d5662375f8" translate="yes" xml:space="preserve">
          <source>For getting a value explicitly:</source>
          <target state="translated">명시 적으로 값을 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="2738da994f1d2422123b7b031dad5137a55cd5cb" translate="yes" xml:space="preserve">
          <source>For getting fast access to a scalar (equivalent to the prior method):</source>
          <target state="translated">스칼라에 빠르게 액세스하려면 (이전 방법과 동일) :</target>
        </trans-unit>
        <trans-unit id="e1a207a7b28894f03e7b2c69ac4c08ae25438e03" translate="yes" xml:space="preserve">
          <source>For getting values with a boolean array:</source>
          <target state="translated">부울 배열로 값을 가져 오는 경우 :</target>
        </trans-unit>
        <trans-unit id="6fedd905694f9b08a1d2eb71c34703058e37022c" translate="yes" xml:space="preserve">
          <source>For historical reasons, &lt;code&gt;df.groupby(&quot;g&quot;).boxplot()&lt;/code&gt; is not equivalent to &lt;code&gt;df.boxplot(by=&quot;g&quot;)&lt;/code&gt;. See &lt;a href=&quot;visualization#visualization-box-return&quot;&gt;here&lt;/a&gt; for an explanation.</source>
          <target state="translated">역사적인 이유로 &lt;code&gt;df.groupby(&quot;g&quot;).boxplot()&lt;/code&gt; 은 &lt;code&gt;df.boxplot(by=&quot;g&quot;)&lt;/code&gt; 와 동일하지 않습니다 . 설명 은 &lt;a href=&quot;visualization#visualization-box-return&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3225ed6fd0670309a94a939659df2b83e2c25cc5" translate="yes" xml:space="preserve">
          <source>For holidays that occur on fixed dates (e.g., US Memorial Day or July 4th) an observance rule determines when that holiday is observed if it falls on a weekend or some other non-observed day. Defined observance rules are:</source>
          <target state="translated">고정 된 날짜 (예 : 미국 현충일 또는 7 월 4 일)에 발생하는 공휴일의 경우 준수 규칙에 따라 해당 공휴일이 주말 또는 기타 비준수 일에 해당하는시기가 결정됩니다. 정의 된 준수 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edc0d28fce40bea1f1bbc84b7706e65202ac0cbe" translate="yes" xml:space="preserve">
          <source>For homogeneous data, directly modifying the values via the &lt;code&gt;values&lt;/code&gt; attribute or advanced indexing.</source>
          <target state="translated">동종 데이터의 경우 &lt;code&gt;values&lt;/code&gt; 속성 또는 고급 인덱싱을 통해 값을 직접 수정 합니다.</target>
        </trans-unit>
        <trans-unit id="6348b513eb36c3c730e52d3d6019959489fce286" translate="yes" xml:space="preserve">
          <source>For indexes, an ndarray of booleans is returned.</source>
          <target state="translated">인덱스의 경우 부울 ndarray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="428e2135af050a51cafb232e6421b79573443ff3" translate="yes" xml:space="preserve">
          <source>For information on key sorting by value, see &lt;a href=&quot;#basics-sort-value-key&quot;&gt;value sorting&lt;/a&gt;.</source>
          <target state="translated">값별 키 정렬에 대한 자세한 내용은 &lt;a href=&quot;#basics-sort-value-key&quot;&gt;값 정렬을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="2cea0e11e959437e39c83368983569ee0fc09951" translate="yes" xml:space="preserve">
          <source>For instance, a contrived way to transpose the DataFrame would be:</source>
          <target state="translated">예를 들어, DataFrame을 전치하는 인위적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7360c98165ac7cbc45eafb9abb65b0f0fd420961" translate="yes" xml:space="preserve">
          <source>For instance, here is a boxplot representing five trials of 10 observations of a uniform random variable on [0,1).</source>
          <target state="translated">예를 들어, 다음은 [0,1)에 대한 균일 랜덤 변수의 10 개의 관측치에 대한 5 번의 시행을 나타내는 상자 그림입니다.</target>
        </trans-unit>
        <trans-unit id="73914a15d78531d14b7c4a1d527d11bb2e0734dc" translate="yes" xml:space="preserve">
          <source>For instance, you can use the &lt;code&gt;converters&lt;/code&gt; argument of &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt;&lt;code&gt;read_csv()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;../reference/api/pandas.read_csv#pandas.read_csv&quot;&gt; &lt;code&gt;read_csv()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;converters&lt;/code&gt; 인수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="e4019291d8f62995f383f47da4c2a3a51becdabb" translate="yes" xml:space="preserve">
          <source>For interaction with Apache Arrow (pyarrow), a &lt;code&gt;__from_arrow__&lt;/code&gt; method can be implemented: this method receives a pyarrow Array or ChunkedArray as only argument and is expected to return the appropriate pandas ExtensionArray for this dtype and the passed values:</source>
          <target state="translated">Apache Arrow (pyarrow)와의 상호 작용을 위해 &lt;code&gt;__from_arrow__&lt;/code&gt; 메서드를 구현할 수 있습니다.이 메서드는 pyarrow Array 또는 ChunkedArray를 유일한 인수로 받고이 dtype 및 전달 된 값에 대해 적절한 pandas ExtensionArray를 반환 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="1d7adad8c65d360dc936e8663cd8abea67d035de" translate="yes" xml:space="preserve">
          <source>For internal compatibility with numpy arrays.</source>
          <target state="translated">numpy 배열과의 내부 호환성을 위해.</target>
        </trans-unit>
        <trans-unit id="3938742ad221462b3d5ac3cfbe2cc1e25f69fdff" translate="yes" xml:space="preserve">
          <source>For internal compatibility with the Index API.</source>
          <target state="translated">Index API와의 내부 호환성을 위해.</target>
        </trans-unit>
        <trans-unit id="f8def0800904e304ec124f027edd8aa6dddd1377" translate="yes" xml:space="preserve">
          <source>For internal compatibility with with the Index API.</source>
          <target state="translated">인덱스 API와의 내부 호환성</target>
        </trans-unit>
        <trans-unit id="de1cb23caf7dbeb301ffad25e4368576f7f6f007" translate="yes" xml:space="preserve">
          <source>For keyword arguments with a default value, the default will be listed after a comma at the end of the type. The exact form of the type in this case will be &amp;ldquo;int, default 0&amp;rdquo;. In some cases it may be useful to explain what the default argument means, which can be added after a comma &amp;ldquo;int, default -1, meaning all cpus&amp;rdquo;.</source>
          <target state="translated">기본값이있는 키워드 인수의 경우 기본값은 유형 끝에서 쉼표 뒤에 표시됩니다. 이 경우 형식의 정확한 형식은 &quot;int, default 0&quot;입니다. 어떤 경우에는 기본 인수가 무엇을 의미하는지 설명하는 것이 유용 할 수 있는데, &quot;int, default -1, 모든 CPU를 의미&quot;뒤에 쉼표 뒤에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0adaeb3f1106850f9ae3027ebeacc87af327953c" translate="yes" xml:space="preserve">
          <source>For labeled, non-time series data, you may wish to produce a bar plot:</source>
          <target state="translated">비 계열 계열 레이블이 지정된 데이터의 경우 막대 플롯을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6666e77264efaa6a460903552fe331ad87484b8" translate="yes" xml:space="preserve">
          <source>For lack of &lt;code&gt;NA&lt;/code&gt; (missing) support from the ground up in NumPy and Python in general, we were given the difficult choice between either:</source>
          <target state="translated">NumPy와 일반적으로 Python에서 처음부터 &lt;code&gt;NA&lt;/code&gt; (누락 된) 지원 이 없기 때문에 다음 중 하나를 선택하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="5d68fbcf912c893f2905459001aa69261085393a" translate="yes" xml:space="preserve">
          <source>For large numbers that have been written with a thousands separator, you can set the &lt;code&gt;thousands&lt;/code&gt; keyword to a string of length 1 so that integers will be parsed correctly:</source>
          <target state="translated">천 단위 구분 기호로 작성된 큰 숫자의 경우 정수가 올바르게 구문 분석되도록 &lt;code&gt;thousands&lt;/code&gt; 키워드를 길이 1의 문자열로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="580124faf04e07758951c13003fe7c5950d2a2ce" translate="yes" xml:space="preserve">
          <source>For line-delimited json files, pandas can also return an iterator which reads in &lt;code&gt;chunksize&lt;/code&gt; lines at a time. This can be useful for large files or to read from a stream.</source>
          <target state="translated">줄로 구분 된 json 파일의 경우 pandas는 한 번 에 &lt;code&gt;chunksize&lt;/code&gt; 줄로 읽는 반복자를 반환 할 수도 있습니다 . 이는 대용량 파일이나 스트림에서 읽는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1fce633382ace0f95ce1ceb3a99b3d31f075e3c" translate="yes" xml:space="preserve">
          <source>For logical operations, &lt;code&gt;pd.NA&lt;/code&gt; follows the rules of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt; (or &lt;em&gt;Kleene logic&lt;/em&gt;, similarly to R, SQL and Julia). This logic means to only propagate missing values when it is logically required.</source>
          <target state="translated">논리 연산의 경우 &lt;code&gt;pd.NA&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3 개 값 논리&lt;/a&gt; (또는 R, SQL 및 Julia와 유사한 &lt;em&gt;Kleene 논리)&lt;/em&gt; 의 규칙을 따릅니다 . 이 논리는 논리적으로 필요한 경우에만 누락 된 값을 전파하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cd17cc9d2ee4b0595b6f4d1721e19135dac396b1" translate="yes" xml:space="preserve">
          <source>For many ExtensionArrays, there will be two representations of</source>
          <target state="translated">많은 ExtensionArray의 경우 두 가지 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a2566df3f5bed78f1243c5dc7500605adea3ed" translate="yes" xml:space="preserve">
          <source>For many ExtensionArrays, there will be two representations of &lt;code&gt;fill_value&lt;/code&gt;: a user-facing &amp;ldquo;boxed&amp;rdquo; scalar, and a low-level physical NA value. &lt;code&gt;fill_value&lt;/code&gt; should be the user-facing version, and the implementation should handle translating that to the physical version for processing the take if necessary.</source>
          <target state="translated">많은 ExtensionArray에는 &lt;code&gt;fill_value&lt;/code&gt; 의 두 가지 표현, 즉 사용자가 직면 한 &quot;박스형&quot;스칼라와 낮은 수준의 물리적 NA 값이 있습니다. &lt;code&gt;fill_value&lt;/code&gt; 는 사용자를 향한 버전이어야하며 구현시 필요한 경우 테이크를 처리하기 위해 실제 버전으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="df40cca3a7fe216c28d30fc0fdab0c7fa86ea96b" translate="yes" xml:space="preserve">
          <source>For many reasons we chose the latter. After years of production use it has proven, at least in my opinion, to be the best decision given the state of affairs in NumPy and Python in general. The special value &lt;code&gt;NaN&lt;/code&gt; (Not-A-Number) is used everywhere as the &lt;code&gt;NA&lt;/code&gt; value, and there are API functions &lt;code&gt;isna&lt;/code&gt; and &lt;code&gt;notna&lt;/code&gt; which can be used across the dtypes to detect NA values.</source>
          <target state="translated">여러 가지 이유로 우리는 후자를 선택했습니다. 수년간의 프로덕션 사용 후에 적어도 내 생각에는 NumPy와 Python의 상태를 고려할 때 가장 좋은 결정이라는 것이 입증되었습니다. 특수 값 &lt;code&gt;NaN&lt;/code&gt; (Not-A-Number)은 모든 곳에서 &lt;code&gt;NA&lt;/code&gt; 값 으로 사용되며, NA 값을 감지하기 위해 dtype에서 사용할 수있는 API 함수 &lt;code&gt;isna&lt;/code&gt; 및 &lt;code&gt;notna&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5a3b988b41d8a805c3b5e20e1224d6a8d441736" translate="yes" xml:space="preserve">
          <source>For many use cases writing pandas in pure Python and NumPy is sufficient. In some computationally heavy applications however, it can be possible to achieve sizable speed-ups by offloading work to &lt;a href=&quot;http://cython.org/&quot;&gt;cython&lt;/a&gt;.</source>
          <target state="translated">많은 유스 케이스의 경우 순수 Python 및 NumPy로 팬더를 작성하면 충분합니다. 그러나 계산량이 많은 일부 응용 프로그램에서는 작업을 &lt;a href=&quot;http://cython.org/&quot;&gt;cython&lt;/a&gt; 으로 오프로드하여 상당한 속도 향상을 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd5148102e97f3a32e851da4f99458e933d3b280" translate="yes" xml:space="preserve">
          <source>For many use cases writing pandas in pure Python and NumPy is sufficient. In some computationally heavy applications however, it can be possible to achieve sizable speed-ups by offloading work to &lt;a href=&quot;https://cython.org/&quot;&gt;cython&lt;/a&gt;.</source>
          <target state="translated">많은 사용 사례에서 순수 Python 및 NumPy로 팬더를 작성하는 것으로 충분합니다. 그러나 계산량이 많은 일부 응용 프로그램에서는 작업을 &lt;a href=&quot;https://cython.org/&quot;&gt;cython&lt;/a&gt; 에 오프로드하여 상당한 속도 향상을 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b71da563397dbd40337aa5b8a20ea61b78174cf4" translate="yes" xml:space="preserve">
          <source>For memory savings, this should be the most common value in the array.</source>
          <target state="translated">메모리 절약을 위해서는 이것이 어레이에서 가장 일반적인 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e8109079167e80b0f5a798a2cb12312edf4b9b2b" translate="yes" xml:space="preserve">
          <source>For mixed data types provided via a &lt;code&gt;DataFrame&lt;/code&gt;, the default is to return only an analysis of numeric columns. If the dataframe consists only of object and categorical data without any numeric columns, the default is to return an analysis of both the object and categorical columns. If &lt;code&gt;include='all'&lt;/code&gt; is provided as an option, the result will include a union of attributes of each type.</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 을 통해 제공된 혼합 데이터 유형의 경우 기본값은 숫자 열 분석 만 리턴하는 것입니다. 데이터 프레임이 숫자 열이없는 개체 및 범주 형 데이터로만 구성된 경우 기본값은 개체와 범주 형 열의 분석을 반환하는 것입니다. 경우 &lt;code&gt;include='all'&lt;/code&gt; 옵션으로 제공되며, 결과는 각 유형의 특성의 조합을 포함 할 것이다.</target>
        </trans-unit>
        <trans-unit id="0cc4b2e84755ddb87399e5f342442911a74e62e0" translate="yes" xml:space="preserve">
          <source>For more complex examples (grouping for example), avoid using data without interpretation, like a matrix of random numbers with columns A, B, C, D&amp;hellip; And instead use a meaningful example, which makes it easier to understand the concept. Unless required by the example, use names of animals, to keep examples consistent. And numerical properties of them.</source>
          <target state="translated">보다 복잡한 예 (예를 들어 그룹화)의 경우 열 A, B, C, D가 포함 된 난수 행렬과 같이 해석없이 데이터를 사용하지 말고 의미있는 예를 사용하면 개념을보다 쉽게 ​​이해할 수 있습니다. 예제에서 요구하지 않는 한 예제의 일관성을 유지하기 위해 동물의 이름을 사용하십시오. 그리고 그것들의 수치 적 특성.</target>
        </trans-unit>
        <trans-unit id="4db1d203723f6466ff69cafd19c4560dc311a579" translate="yes" xml:space="preserve">
          <source>For more details see the API documentation for &lt;a href=&quot;pandas.eval#pandas.eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;. For detailed examples see &lt;a href=&quot;../../user_guide/enhancingperf#enhancingperf-eval&quot;&gt;enhancing performance with eval&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;pandas.eval#pandas.eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 대한 API 설명서를 참조하십시오 . 자세한 예 &lt;a href=&quot;../../user_guide/enhancingperf#enhancingperf-eval&quot;&gt;는 eval을 사용하여 성능 향상을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d3e7354134ce3638855035adb4756aa18bf7c5d" translate="yes" xml:space="preserve">
          <source>For more examples, see &lt;a href=&quot;../../user_guide/text#text-concatenate&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;../../user_guide/text#text-concatenate&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c247b7f185f53748afc3975b97cf3a23c3f6734" translate="yes" xml:space="preserve">
          <source>For more fine-grained control, use &lt;code&gt;iterator=True&lt;/code&gt; and specify &lt;code&gt;chunksize&lt;/code&gt; with each call to &lt;code&gt;read()&lt;/code&gt;.</source>
          <target state="translated">보다 세밀한 제어를 위해 &lt;code&gt;iterator=True&lt;/code&gt; 를 사용 하고 &lt;code&gt;read()&lt;/code&gt; 호출 할 때 마다 &lt;code&gt;chunksize&lt;/code&gt; 를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="75d8a30e5a3e9e26068bd5b1759c6cd940d19352" translate="yes" xml:space="preserve">
          <source>For more formatting and styling options, see &lt;a href=&quot;#visualization-formatting&quot;&gt;formatting&lt;/a&gt; below.</source>
          <target state="translated">형식 및 스타일 옵션에 대한 자세한 내용은 아래 &lt;a href=&quot;#visualization-formatting&quot;&gt;형식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d53864eed4a499b958150462adab2efa03e17401" translate="yes" xml:space="preserve">
          <source>For more information about duplicate labels, see &lt;a href=&quot;duplicates#duplicates&quot;&gt;Duplicate Labels&lt;/a&gt;.</source>
          <target state="translated">중복 레이블에 대한 자세한 내용은 &lt;a href=&quot;duplicates#duplicates&quot;&gt;중복 레이블&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f03fb9ac8d9595a76234b65ebd564c7f8bb01d3" translate="yes" xml:space="preserve">
          <source>For more information on &lt;code&gt;.at&lt;/code&gt;, &lt;code&gt;.iat&lt;/code&gt;, &lt;code&gt;.loc&lt;/code&gt;, and &lt;code&gt;.iloc&lt;/code&gt;, see the &lt;a href=&quot;../user_guide/indexing#indexing&quot;&gt;indexing documentation&lt;/a&gt;.</source>
          <target state="translated">에 대한 자세한 내용은 &lt;code&gt;.at&lt;/code&gt; , &lt;code&gt;.iat&lt;/code&gt; , &lt;code&gt;.loc&lt;/code&gt; 및 &lt;code&gt;.iloc&lt;/code&gt; 의 참조 &lt;a href=&quot;../user_guide/indexing#indexing&quot;&gt;인덱스 문서를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="694b804760792f5b924e7509fe507ab99681809a" translate="yes" xml:space="preserve">
          <source>For more information on the choices available when specifying the &lt;code&gt;format&lt;/code&gt; option, see the Python &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;datetime documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 옵션을 지정할 때 사용할 수있는 선택 사항에 대한 자세한 내용 은 Python &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;datetime 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94d6917d9571485c675da60239fd9c6c681d965d" translate="yes" xml:space="preserve">
          <source>For more information on the forms, see the &lt;a href=&quot;https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize&quot;&gt;&lt;code&gt;unicodedata.normalize()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">양식에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize&quot;&gt; &lt;code&gt;unicodedata.normalize()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29357f73f549c2753f04d0dbde59a45aa498cd61" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.query&quot;&gt;BigQuery REST API Reference&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs#configuration.query&quot;&gt;BigQuery REST API 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe06d20afcf584afd6d8be687c4bdbdf203fd1f" translate="yes" xml:space="preserve">
          <source>For more information see the &lt;a href=&quot;../../user_guide/io#io-hdf5&quot;&gt;user guide&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../../user_guide/io#io-hdf5&quot;&gt;사용 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2738385b8c69531782ecb535c9514a1d8e2dcf48" translate="yes" xml:space="preserve">
          <source>For more information see the examples the SQLAlchemy &lt;a href=&quot;https://docs.sqlalchemy.org/en/latest/core/engines.html&quot;&gt;documentation&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 SQLAlchemy &lt;a href=&quot;https://docs.sqlalchemy.org/en/latest/core/engines.html&quot;&gt;설명서&lt;/a&gt; 의 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9540bf72078abdec18fd1e6942000ba9e55ad949" translate="yes" xml:space="preserve">
          <source>For more information see: &lt;a href=&quot;http://en.wikipedia.org/wiki/4-4-5_calendar&quot;&gt;http://en.wikipedia.org/wiki/4-4-5_calendar&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 다음을 참조하십시오 : &lt;a href=&quot;http://en.wikipedia.org/wiki/4-4-5_calendar&quot;&gt;http://en.wikipedia.org/wiki/4-4-5_calendar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d8162d22a432e377c6c446ce8007c62ff5041c8" translate="yes" xml:space="preserve">
          <source>For more information see: &lt;a href=&quot;https://en.wikipedia.org/wiki/4-4-5_calendar&quot;&gt;https://en.wikipedia.org/wiki/4-4-5_calendar&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/4-4-5_calendar&quot;&gt;https://en.wikipedia.org/wiki/4-4-5_calendar를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0494704c2cb9de594939f986fa369462e9cc13d" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;http://python3statement.org/&quot;&gt;Python 3 statement&lt;/a&gt; and the &lt;a href=&quot;https://docs.python.org/3/howto/pyporting.html&quot;&gt;Porting to Python 3 guide&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://python3statement.org/&quot;&gt; Python 3 문&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/howto/pyporting.html&quot;&gt;Python 3으로 이식 안내서를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9866dac8fb4a1bccca6e4fe3e355cb710c5015a2" translate="yes" xml:space="preserve">
          <source>For more, see the &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; documentation.</source>
          <target state="translated">자세한 내용은 참조 &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest의&lt;/a&gt; 문서를.</target>
        </trans-unit>
        <trans-unit id="a373615513c61887ba3ada5e17c999e8311450d0" translate="yes" xml:space="preserve">
          <source>For most data types, pandas uses NumPy arrays as the concrete objects contained with a &lt;a href=&quot;api/pandas.index#pandas.Index&quot;&gt;&lt;code&gt;Index&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대부분의 데이터 유형에서 팬더는 NumPy 배열을 &lt;a href=&quot;api/pandas.index#pandas.Index&quot;&gt; &lt;code&gt;Index&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; 에&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bf82910e3187b0e3669f2a8c729d0ceaa8011d63" translate="yes" xml:space="preserve">
          <source>For multiple groupings, the result index will be a MultiIndex</source>
          <target state="translated">여러 그룹화의 경우 결과 색인은 다중 색인이됩니다</target>
        </trans-unit>
        <trans-unit id="fc74d8fe9ecf9df39ac50ccaee4b3bfb5cd0f210" translate="yes" xml:space="preserve">
          <source>For multiple groupings, the result index will be a MultiIndex.</source>
          <target state="translated">여러 그룹화의 경우 결과 색인은 다중 색인이됩니다.</target>
        </trans-unit>
        <trans-unit id="320f4c2eda9f19083856a63be36aefd6affa724a" translate="yes" xml:space="preserve">
          <source>For negative values of</source>
          <target state="translated">음수 값</target>
        </trans-unit>
        <trans-unit id="af4b5c80a1630537bb2f2a60ed680509fb86a2a1" translate="yes" xml:space="preserve">
          <source>For non-integer/boolean dtypes, an appropriate error is raised:</source>
          <target state="translated">정수 / 부울이 아닌 dtype의 경우 적절한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c7bdf4112ee3b72a8371413300cae34f0a234b00" translate="yes" xml:space="preserve">
          <source>For numeric data, the result&amp;rsquo;s index will include &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;std&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt; as well as lower, &lt;code&gt;50&lt;/code&gt; and upper percentiles. By default the lower percentile is &lt;code&gt;25&lt;/code&gt; and the upper percentile is &lt;code&gt;75&lt;/code&gt;. The &lt;code&gt;50&lt;/code&gt; percentile is the same as the median.</source>
          <target state="translated">숫자 데이터의 경우 결과 색인에는 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;mean&lt;/code&gt; , &lt;code&gt;std&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; 및 낮은 백분위 수 및 &lt;code&gt;50&lt;/code&gt; 백분위 수가 포함됩니다. 기본적으로 하위 백분위 수는 &lt;code&gt;25&lt;/code&gt; 이고 상위 백분위 수는 &lt;code&gt;75&lt;/code&gt; 입니다. &lt;code&gt;50&lt;/code&gt; 백분위 평균과 동일하다.</target>
        </trans-unit>
        <trans-unit id="cebdb9dc867edad981fd3ba5b173f48d66b1abd6" translate="yes" xml:space="preserve">
          <source>For object containers, pandas will use the value given:</source>
          <target state="translated">객체 컨테이너의 경우 pandas는 주어진 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="138f514bb9ae738a899ea24cc00269630443f802" translate="yes" xml:space="preserve">
          <source>For object data (e.g. strings or timestamps), the result&amp;rsquo;s index will include &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;unique&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, and &lt;code&gt;freq&lt;/code&gt;. The &lt;code&gt;top&lt;/code&gt; is the most common value. The &lt;code&gt;freq&lt;/code&gt; is the most common value&amp;rsquo;s frequency. Timestamps also include the &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; items.</source>
          <target state="translated">객체 데이터 (예 : 문자열 또는 타임 스탬프)의 경우 결과 색인에 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;unique&lt;/code&gt; , &lt;code&gt;top&lt;/code&gt; 및 &lt;code&gt;freq&lt;/code&gt; 가 포함 됩니다. &lt;code&gt;top&lt;/code&gt; 가장 일반적인 값입니다. &lt;code&gt;freq&lt;/code&gt; 가장 일반적인 값의 주파수이다. 타임 스탬프에는 &lt;code&gt;first&lt;/code&gt; 항목 과 &lt;code&gt;last&lt;/code&gt; 항목 도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="52d6d6be2da24d462edefa2d8e7d22fe348ae398" translate="yes" xml:space="preserve">
          <source>For object-dtyped columns, if &lt;code&gt;infer_objects&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, use the inference rules as during normal Series/DataFrame construction. Then, if possible, convert to &lt;code&gt;StringDtype&lt;/code&gt;, &lt;code&gt;BooleanDtype&lt;/code&gt; or an appropriate integer or floating extension type, otherwise leave as &lt;code&gt;object&lt;/code&gt;.</source>
          <target state="translated">object-dtyped 열의 경우 &lt;code&gt;infer_objects&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 이면 일반 Series / DataFrame 생성 중에 추론 규칙을 사용합니다. 그런 다음 가능하면 &lt;code&gt;StringDtype&lt;/code&gt; , &lt;code&gt;BooleanDtype&lt;/code&gt; 또는 적절한 정수 또는 부동 확장 유형으로 변환하고 그렇지 않으면 &lt;code&gt;object&lt;/code&gt; 로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="f554c9936ee765c581d5455dc5d85c303dfbd0f4" translate="yes" xml:space="preserve">
          <source>For objects to be considered file-like, they must be an iterator AND have either a</source>
          <target state="translated">객체가 파일과 유사한 것으로 간주 되려면 이터레이터 여야하고</target>
        </trans-unit>
        <trans-unit id="465bdc736a1f8e5e2efd89ddbb84b0ec01f99c18" translate="yes" xml:space="preserve">
          <source>For objects to be considered file-like, they must be an iterator AND have either a &lt;code&gt;read&lt;/code&gt; and/or &lt;code&gt;write&lt;/code&gt; method as an attribute.</source>
          <target state="translated">객체가 파일과 같은 것으로 간주 되려면 객체는 반복자이어야하며 속성으로 &lt;code&gt;read&lt;/code&gt; 및 / 또는 &lt;code&gt;write&lt;/code&gt; 방법 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d4f63fafc623ee4603fb615753f5f7f47d3e6a06" translate="yes" xml:space="preserve">
          <source>For on-the-fly compression of the output dta. If string, specifies compression mode. If dict, value at key &amp;lsquo;method&amp;rsquo; specifies compression mode. Compression mode must be one of {&amp;lsquo;infer&amp;rsquo;, &amp;lsquo;gzip&amp;rsquo;, &amp;lsquo;bz2&amp;rsquo;, &amp;lsquo;zip&amp;rsquo;, &amp;lsquo;xz&amp;rsquo;, None}. If compression mode is &amp;lsquo;infer&amp;rsquo; and</source>
          <target state="translated">출력 dta의 즉각적인 압축을 위해. 문자열 인 경우 압축 모드를 지정합니다. dict 인 경우 'method'키의 값은 압축 모드를 지정합니다. 압축 모드는 { 'infer', 'gzip', 'bz2', 'zip', 'xz', None} 중 하나 여야합니다. 압축 모드가 '추론'이고</target>
        </trans-unit>
        <trans-unit id="c0bce7f100e5b87dc20a7ff6f1130f3d1ed044c2" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo; and</source>
          <target state="translated">온 디스크 데이터의 즉각적인 압축 해제를 위해. '추론'하고</target>
        </trans-unit>
        <trans-unit id="5807479643017470f979a29619731b84195733dd" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo; and &lt;code&gt;filepath_or_buffer&lt;/code&gt; is path-like, then detect compression from the following extensions: &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;.xz&amp;rsquo; (otherwise no decompression). If using &amp;lsquo;zip&amp;rsquo;, the ZIP file must contain only one data file to be read in. Set to None for no decompression.</source>
          <target state="translated">온 디스크 데이터를 즉시 압축 해제합니다. 'infer'및 &lt;code&gt;filepath_or_buffer&lt;/code&gt; 가 경로와 같은 경우 '.gz', '.bz2', '.zip'또는 '.xz'(또는 압축 해제 없음) 확장자에서 압축을 감지하십시오. 'zip'을 사용하는 경우 ZIP 파일은 읽을 데이터 파일을 하나만 포함해야합니다. 압축 해제하지 않으려면 없음으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4b1a54b61b3512074fd4f647bc4bc9c5a146e3bc" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo;, then use gzip, bz2, xz or zip if path ends in &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.xz&amp;rsquo;, or &amp;lsquo;.zip&amp;rsquo; respectively, and no decompression otherwise. Set to None for no decompression.</source>
          <target state="translated">온 디스크 데이터를 즉시 압축 해제합니다. '추천'인 경우 경로가 각각 '.gz', '.bz2', '.xz'또는 '.zip'으로 끝나는 경우 gzip, bz2, xz 또는 zip을 사용하고 그렇지 않으면 압축 해제하지 마십시오. 감압하지 않으려면 없음으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="acdaedcb04def73a0b184a8c9893ab1d4272fe4e" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo;, then use gzip, bz2, zip or xz if path_or_buf is a string ending in &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;xz&amp;rsquo;, respectively, and no decompression otherwise. If using &amp;lsquo;zip&amp;rsquo;, the ZIP file must contain only one data file to be read in. Set to None for no decompression.</source>
          <target state="translated">온 디스크 데이터를 즉시 압축 해제합니다. '추천'인 경우 path_or_buf가 각각 '.gz', '.bz2', '.zip'또는 'xz'로 끝나는 문자열 인 경우 gzip, bz2, zip 또는 xz를 사용하고 그렇지 않으면 압축 해제하지 마십시오. 'zip'을 사용하는 경우 ZIP 파일은 읽을 데이터 파일을 하나만 포함해야합니다. 압축 해제하지 않으려면 없음으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bac284fb6d67e7e42f7691c9b8fd8d01fd2e94a4" translate="yes" xml:space="preserve">
          <source>For on-the-fly decompression of on-disk data. If &amp;lsquo;infer&amp;rsquo;, then use gzip, bz2, zip, or xz if &lt;code&gt;filepath_or_buffer&lt;/code&gt; is path-like ending in &amp;lsquo;.gz&amp;rsquo;, &amp;lsquo;.bz2&amp;rsquo;, &amp;lsquo;.zip&amp;rsquo;, or &amp;lsquo;.xz&amp;rsquo;, respectively, and no decompression otherwise. If using &amp;lsquo;zip&amp;rsquo;, the ZIP file must contain only one data file to be read in. Set to &lt;code&gt;None&lt;/code&gt; for no decompression. Can also be a dict with key &lt;code&gt;'method'&lt;/code&gt; set to one of {&lt;code&gt;'zip'&lt;/code&gt;, &lt;code&gt;'gzip'&lt;/code&gt;, &lt;code&gt;'bz2'&lt;/code&gt;} and other key-value pairs are forwarded to &lt;code&gt;zipfile.ZipFile&lt;/code&gt;, &lt;code&gt;gzip.GzipFile&lt;/code&gt;, or &lt;code&gt;bz2.BZ2File&lt;/code&gt;. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: &lt;code&gt;compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}&lt;/code&gt;.</source>
          <target state="translated">온 디스크 데이터의 즉각적인 압축 해제를 위해. 'infer'인 경우, &lt;code&gt;filepath_or_buffer&lt;/code&gt; 가 각각 '.gz', '.bz2', '.zip'또는 '.xz'로 끝나는 경로와 유사한 경우 gzip, bz2, zip 또는 xz를 사용 하고 그렇지 않으면 압축 해제하지 않습니다. . 'zip'을 사용하는 경우 ZIP 파일에는 읽을 데이터 파일이 하나만 있어야합니다. 압축을 풀지 않으 려면 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 . 키 &lt;code&gt;'method'&lt;/code&gt; 가 { &lt;code&gt;'zip'&lt;/code&gt; , &lt;code&gt;'gzip'&lt;/code&gt; , &lt;code&gt;'bz2'&lt;/code&gt; } 중 하나로 설정된 dict 일 수도 있으며 다른 키-값 쌍은 &lt;code&gt;zipfile.ZipFile&lt;/code&gt; , &lt;code&gt;gzip.GzipFile&lt;/code&gt; 또는 &lt;code&gt;bz2.BZ2File&lt;/code&gt; 로 전달됩니다 . 예를 들어 더 빠른 압축과 재현 가능한 gzip 아카이브를 만들기 위해 다음을 전달할 수 있습니다. &lt;code&gt;compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="987b76ecb692d8818b42d3971149d7bff3260d70" translate="yes" xml:space="preserve">
          <source>For periods that span over multiple days, the day at the beginning of the period is returned.</source>
          <target state="translated">여러 날에 걸쳐있는 기간의 경우 기간 시작일이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="662b7bf8341d7b362e53abb22b5202de24ac90e2" translate="yes" xml:space="preserve">
          <source>For periods with a frequency higher than days, the last day of the period is returned.</source>
          <target state="translated">빈도가 일보다 높은 기간의 경우 기간의 마지막 날이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fb50d4d508cd8c1601d128cec14cf856355ecd7e" translate="yes" xml:space="preserve">
          <source>For pie plots it&amp;rsquo;s best to use square figures, i.e. a figure aspect ratio 1. You can create the figure with equal width and height, or force the aspect ratio to be equal after plotting by calling &lt;code&gt;ax.set_aspect('equal')&lt;/code&gt; on the returned &lt;code&gt;axes&lt;/code&gt; object.</source>
          <target state="translated">파이 플롯의 경우 정사각형 그림, 즉 그림 종횡비 1을 사용하는 것이 가장 좋습니다. 너비와 높이가 동일한 그림을 만들거나 플로팅 후 &lt;code&gt;ax.set_aspect('equal')&lt;/code&gt; 을 호출하여 종횡비를 동일하게 만들 수 있습니다 . 반환 된 &lt;code&gt;axes&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="f20cb9d6aaa1f319d0fbe424ca0488540400e731" translate="yes" xml:space="preserve">
          <source>For potential users coming from &lt;a href=&quot;https://en.wikipedia.org/wiki/SAS_(software)&quot;&gt;SAS&lt;/a&gt; this page is meant to demonstrate how different SAS operations would be performed in pandas.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/SAS_(software)&quot;&gt;SAS&lt;/a&gt; 에서 오는 잠재적 인 사용자를 위해이 페이지는 팬더에서 다른 SAS 작업이 수행되는 방법을 보여주기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="91a32cce48835b020148b4ec8bdcadea3e77d396" translate="yes" xml:space="preserve">
          <source>For potential users coming from &lt;a href=&quot;https://en.wikipedia.org/wiki/Stata&quot;&gt;Stata&lt;/a&gt; this page is meant to demonstrate how different Stata operations would be performed in pandas.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Stata&quot;&gt;Stata&lt;/a&gt; 에서 온 잠재적 사용자를 위해이 페이지는 팬더에서 다양한 Stata 작업이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e1d215f8c65e8806b64b9f99bdc1753adfd8238b" translate="yes" xml:space="preserve">
          <source>For regular NumPy types like int, and float, a PandasArray is returned.</source>
          <target state="translated">int 및 float와 같은 일반 NumPy 유형의 경우 PandasArray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d42b9c8d29b7e7711acb1a5fe60fadbbcd7180b4" translate="yes" xml:space="preserve">
          <source>For row and column slicing, any valid indexer to &lt;code&gt;.loc&lt;/code&gt; will work.</source>
          <target state="translated">행 및 열 슬라이싱의 경우 &lt;code&gt;.loc&lt;/code&gt; 에 대한 유효한 인덱서 가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="377224ee8831a7f9bc64d03588b90fd9349eee4d" translate="yes" xml:space="preserve">
          <source>For scalar input, returns a scalar boolean. For array input, returns an array of boolean indicating whether each corresponding element is missing.</source>
          <target state="translated">스칼라 입력의 경우 스칼라 부울을 리턴합니다. 배열 입력의 경우, 해당하는 각 요소가 누락되었는지 여부를 나타내는 부울 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd021b2414eea09b75e93e704e6c0735c3100766" translate="yes" xml:space="preserve">
          <source>For scalar input, returns a scalar boolean. For array input, returns an array of boolean indicating whether each corresponding element is valid.</source>
          <target state="translated">스칼라 입력의 경우 스칼라 부울을 리턴합니다. 배열 입력의 경우, 해당하는 각 요소가 유효한지 여부를 나타내는 부울 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="26ef0d221aa3ee784401e395fad8b9a1fa645619" translate="yes" xml:space="preserve">
          <source>For series, the &lt;code&gt;object.name&lt;/code&gt; is used. If that&amp;rsquo;s none, then the name is &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">시리즈의 경우 &lt;code&gt;object.name&lt;/code&gt; 이 사용됩니다. 이것이 없으면 이름은 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e95a8b1c1abb37ee88f9f6b1b08c0c63f911bad4" translate="yes" xml:space="preserve">
          <source>For slicing columns explicitly:</source>
          <target state="translated">열을 명시 적으로 분할하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="55604cdd6ac5563ed96088ede0e1cfaa99d0864f" translate="yes" xml:space="preserve">
          <source>For slicing rows explicitly:</source>
          <target state="translated">행을 명시 적으로 분할하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="22ee1a4d311a6da50dd1b6cd2e58ca99cdcd9710" translate="yes" xml:space="preserve">
          <source>For slightly more complex use cases like splitting the html document name from a url, a combination of parameter settings can be used.</source>
          <target state="translated">html 문서 이름을 URL에서 분할하는 것과 같이 약간 더 복잡한 사용 사례의 경우 매개 변수 설정 조합을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1abd5590458316fea2deba3093e3133026d1e28" translate="yes" xml:space="preserve">
          <source>For some data types, pandas extends NumPy&amp;rsquo;s type system.</source>
          <target state="translated">일부 데이터 유형의 경우 팬더는 NumPy의 유형 시스템을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="43c07d95bb4022f21917c1c990ceda823946b9fb" translate="yes" xml:space="preserve">
          <source>For some data types, pandas extends NumPy&amp;rsquo;s type system. String aliases for these types can be found at &lt;a href=&quot;../user_guide/basics#basics-dtypes&quot;&gt;dtypes&lt;/a&gt;.</source>
          <target state="translated">일부 데이터 유형의 경우 pandas는 NumPy의 유형 시스템을 확장합니다. 이러한 유형의 문자열 별칭은 &lt;a href=&quot;../user_guide/basics#basics-dtypes&quot;&gt;dtypes&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fb2e58956a12e840fd770705e79600c3e0befd1" translate="yes" xml:space="preserve">
          <source>For some frequencies you can specify an anchoring suffix:</source>
          <target state="translated">일부 주파수의 경우 고정 접미사를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="913aa64e1ce56102d1c5030f84ccea1c91c13c65" translate="yes" xml:space="preserve">
          <source>For some problems knowledge of the future is available for analysis. For example, this occurs when each data point is a full time series read from an experiment, and the task is to extract underlying conditions. In these cases it can be useful to perform forward-looking rolling window computations. &lt;a href=&quot;../reference/api/pandas.api.indexers.fixedforwardwindowindexer#pandas.api.indexers.FixedForwardWindowIndexer&quot;&gt;&lt;code&gt;FixedForwardWindowIndexer&lt;/code&gt;&lt;/a&gt; class is available for this purpose. This &lt;a href=&quot;../reference/api/pandas.api.indexers.baseindexer#pandas.api.indexers.BaseIndexer&quot;&gt;&lt;code&gt;BaseIndexer&lt;/code&gt;&lt;/a&gt; subclass implements a closed fixed-width forward-looking rolling window, and we can use it as follows:</source>
          <target state="translated">일부 문제의 경우 미래에 대한 지식을 분석 할 수 있습니다. 예를 들어, 이는 각 데이터 포인트가 실험에서 읽은 전체 시계열이고 기본 조건을 추출하는 작업 일 때 발생합니다. 이러한 경우 미래 ​​예측 롤링 윈도우 계산을 수행하는 것이 유용 할 수 있습니다. &lt;a href=&quot;../reference/api/pandas.api.indexers.fixedforwardwindowindexer#pandas.api.indexers.FixedForwardWindowIndexer&quot;&gt; &lt;code&gt;FixedForwardWindowIndexer&lt;/code&gt; &lt;/a&gt; 위해 FixedForwardWindowIndexer 클래스를 사용할 수 있습니다. 이 &lt;a href=&quot;../reference/api/pandas.api.indexers.baseindexer#pandas.api.indexers.BaseIndexer&quot;&gt; &lt;code&gt;BaseIndexer&lt;/code&gt; &lt;/a&gt; 하위 클래스는 닫힌 고정 너비 전방 롤링 창을 구현하며 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0258efb49315dcf764074e050a7939adb88f9674" translate="yes" xml:space="preserve">
          <source>For the case when &lt;code&gt;n=0&lt;/code&gt;, the date is not moved if on an anchor point, otherwise it is rolled forward to the next anchor point.</source>
          <target state="translated">경우에 대해 &lt;code&gt;n=0&lt;/code&gt; , 날짜, 그렇지 않으면 다음의 앵커 포인트로 포워드하고, 기준점의 경우 이동되지 않는다.</target>
        </trans-unit>
        <trans-unit id="b5a7819e8c98c63ecde6229bddc35e97e9662c1a" translate="yes" xml:space="preserve">
          <source>For the curious here is how the above &lt;code&gt;DataFrame&lt;/code&gt; was created:</source>
          <target state="translated">궁금한 &lt;code&gt;DataFrame&lt;/code&gt; 은 위의 DataFrame 이 어떻게 생성 되었는지 입니다.</target>
        </trans-unit>
        <trans-unit id="6c3b0ae4cbaee1f14bc076c6ff074b9aaae229c7" translate="yes" xml:space="preserve">
          <source>For the first approach, you define selected operators, e.g., &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__le__&lt;/code&gt;, etc. that you want your &lt;code&gt;ExtensionArray&lt;/code&gt; subclass to support.</source>
          <target state="translated">첫 번째 접근 방식의 경우 &lt;code&gt;ExtensionArray&lt;/code&gt; 서브 클래스에서 지원 하려는 선택된 연산자 (예 : &lt;code&gt;__add__&lt;/code&gt; , &lt;code&gt;__le__&lt;/code&gt; 등)를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1c81b27627f32cfe756a965cb58b2ff932cbe811" translate="yes" xml:space="preserve">
          <source>For the meaning of</source>
          <target state="translated">의 의미</target>
        </trans-unit>
        <trans-unit id="b0b6112cc4e69119fbb1bf4e165ae88af1e5ad40" translate="yes" xml:space="preserve">
          <source>For the meaning of &lt;code&gt;closed&lt;/code&gt; and &lt;code&gt;open&lt;/code&gt; see &lt;a href=&quot;pandas.interval#pandas.Interval&quot;&gt;&lt;code&gt;Interval&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;closed&lt;/code&gt; 및 &lt;code&gt;open&lt;/code&gt; 의미는 &lt;a href=&quot;pandas.interval#pandas.Interval&quot;&gt; &lt;code&gt;Interval&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b63fcc2be8c9dddee7b5f09e6db02dc77537bab" translate="yes" xml:space="preserve">
          <source>For the most part, pandas uses NumPy arrays and dtypes for Series or individual columns of a DataFrame. NumPy provides support for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;timedelta64[ns]&lt;/code&gt; and &lt;code&gt;datetime64[ns]&lt;/code&gt; (note that NumPy does not support timezone-aware datetimes).</source>
          <target state="translated">대부분의 경우 pandas는 Series 또는 DataFrame의 개별 열에 대해 NumPy 배열 및 dtype을 사용합니다. NumPy는 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;timedelta64[ns]&lt;/code&gt; 및 &lt;code&gt;datetime64[ns]&lt;/code&gt; 지원합니다 (NumPy는 시간대 인식 날짜 시간을 지원하지 않음).</target>
        </trans-unit>
        <trans-unit id="2200afa6f056c494633f76e17ce4aeed95ab4537" translate="yes" xml:space="preserve">
          <source>For the rationale behind this behavior, see &lt;a href=&quot;advanced#advanced-endpoints-are-inclusive&quot;&gt;Endpoints are inclusive&lt;/a&gt;.</source>
          <target state="translated">이 동작의 근거 &lt;a href=&quot;advanced#advanced-endpoints-are-inclusive&quot;&gt;는 Endpoints are inclusive를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4211216a810ee93f4099dc95edf7510bbd94c0a" translate="yes" xml:space="preserve">
          <source>For this, use the &lt;a href=&quot;../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first&quot;&gt;&lt;code&gt;combine_first()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">이를 위해 &lt;a href=&quot;../reference/api/pandas.dataframe.combine_first#pandas.DataFrame.combine_first&quot;&gt; &lt;code&gt;combine_first()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a40785b10f5cf0ad2bd96ac4af735fb41551f80c" translate="yes" xml:space="preserve">
          <source>For those offsets that are anchored to the start or end of specific frequency (&lt;code&gt;MonthEnd&lt;/code&gt;, &lt;code&gt;MonthBegin&lt;/code&gt;, &lt;code&gt;WeekEnd&lt;/code&gt;, etc), the following rules apply to rolling forward and backwards.</source>
          <target state="translated">시작 또는 특정 주파수의 말 (에 고정되어 그 오프셋을 &lt;code&gt;MonthEnd&lt;/code&gt; , &lt;code&gt;MonthBegin&lt;/code&gt; , &lt;code&gt;WeekEnd&lt;/code&gt; 등), 다음과 같은 규칙이 앞뒤로 압연에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f668287786e3ee36069ddd780c615ea2fdf7b8d5" translate="yes" xml:space="preserve">
          <source>For time series data, it&amp;rsquo;s conventional to represent the time component in the index of a &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; so manipulations can be performed with respect to the time element.</source>
          <target state="translated">시계열 데이터의 경우 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 의 인덱스에서 시간 구성 요소를 나타내는 것이 일반적 이므로 시간 요소와 관련하여 조작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74ac61de50539871dfbab253279ae8765fe97c4e" translate="yes" xml:space="preserve">
          <source>For timezone-aware data, the timezones may be retained with &lt;code&gt;dtype='object'&lt;/code&gt;</source>
          <target state="translated">시간대 인식 데이터의 경우 시간대는 &lt;code&gt;dtype='object'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75be1964312826cb48015a9c43b800814759e61f" translate="yes" xml:space="preserve">
          <source>For transfer of &lt;code&gt;DataFrame&lt;/code&gt; objects from &lt;code&gt;pandas&lt;/code&gt; to R, one option is to use HDF5 files, see &lt;a href=&quot;../../user_guide/io#io-external-compatibility&quot;&gt;External compatibility&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;pandas&lt;/code&gt; 에서 R 로 &lt;code&gt;DataFrame&lt;/code&gt; 객체 를 전송하는 경우 한 가지 옵션은 HDF5 파일을 사용 하는 것입니다. 예는 &lt;a href=&quot;../../user_guide/io#io-external-compatibility&quot;&gt;외부 호환성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff03dc61e8b56825526bfc637603ddd6f373fb81" translate="yes" xml:space="preserve">
          <source>For types other than these, the &lt;code&gt;'metadata'&lt;/code&gt; key can be omitted. Implementations can assume &lt;code&gt;None&lt;/code&gt; if the key is not present.</source>
          <target state="translated">이들 이외의 유형의 경우 &lt;code&gt;'metadata'&lt;/code&gt; 키를 생략 할 수 있습니다. 키가 존재하지 않는 경우, 구현에서는 &lt;code&gt;None&lt;/code&gt; 을 가정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58dfc7ae211c2c37fc86999d80f329c7e353b158" translate="yes" xml:space="preserve">
          <source>For upsampling, you can specify a way to upsample and the &lt;code&gt;limit&lt;/code&gt; parameter to interpolate over the gaps that are created:</source>
          <target state="translated">업 샘플링의 경우 생성 된 간격을 보간 할 업 샘플링 방법과 &lt;code&gt;limit&lt;/code&gt; 매개 변수를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59129113fd44c434ea738ba42e4842a3b812fe08" translate="yes" xml:space="preserve">
          <source>Force Google BigQuery to re-authenticate the user. This is useful if multiple accounts are used.</source>
          <target state="translated">Google BigQuery가 사용자를 다시 인증하도록합니다. 여러 계정을 사용하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c4804c6e847cb63899d9044dc2761688f1c5e4bc" translate="yes" xml:space="preserve">
          <source>Force encoded string to be ASCII.</source>
          <target state="translated">인코딩 된 문자열을 ASCII로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="59597690649fd3cb38fcf1971a87905afe4dd2f4" translate="yes" xml:space="preserve">
          <source>Form of the output with new additional css classes,</source>
          <target state="translated">새로운 추가 CSS 클래스가있는 출력 형식,</target>
        </trans-unit>
        <trans-unit id="4414e35b15eeb7579a39fef63b8a78c106f2a378" translate="yes" xml:space="preserve">
          <source>Form the intersection of two Index objects.</source>
          <target state="translated">두 개의 Index 객체의 교차점을 형성하십시오.</target>
        </trans-unit>
        <trans-unit id="abe27f9f1159d82b0faf0bca0ea35285e1dc9c91" translate="yes" xml:space="preserve">
          <source>Form the union of two Index objects.</source>
          <target state="translated">두 개의 Index 객체를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="3274c425c17a043f22ff3df0df8b6b0da09b1e17" translate="yes" xml:space="preserve">
          <source>Format Timedelta as ISO 8601 Duration like &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt;, where the &lt;code&gt;[n]&lt;/code&gt; s are replaced by the values.</source>
          <target state="translated">Timedelta를 ISO 8601로 포맷 &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt; 와 같은 지속 시간 . 여기서 &lt;code&gt;[n]&lt;/code&gt; 은 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="11f20deeb76af0ec70327a877ea886ce6705aeb6" translate="yes" xml:space="preserve">
          <source>Format Timedelta as ISO 8601 Duration like &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt;, where the &lt;code&gt;[n]&lt;/code&gt; s are replaced by the values. See &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;https://en.wikipedia.org/wiki/ISO_8601#Durations&lt;/a&gt;</source>
          <target state="translated">Timedelta를 ISO 8601로 포맷 &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt; 와 같은 지속 시간 . 여기서 &lt;code&gt;[n]&lt;/code&gt; 은 값으로 대체됩니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;https://en.wikipedia.org/wiki/ISO_8601#Durations를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="fae016f2914c8675c362c226a3a6aa1ba1140233" translate="yes" xml:space="preserve">
          <source>Format Timedelta as ISO 8601 Duration like &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt;, where the &lt;code&gt;[n]&lt;/code&gt; s are replaced by the values. See &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;https://en.wikipedia.org/wiki/ISO_8601#Durations&lt;/a&gt;.</source>
          <target state="translated">Timedelta를 &lt;code&gt;P[n]Y[n]M[n]DT[n]H[n]M[n]S&lt;/code&gt; 와 같이 ISO 8601 기간으로 형식화합니다 . 여기서 &lt;code&gt;[n]&lt;/code&gt; 은 값으로 대체됩니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601#Durations&quot;&gt;https://en.wikipedia.org/wiki/ISO_8601#Durations를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="de2e34068366c3b66447d1e40d8ed3cff721d57a" translate="yes" xml:space="preserve">
          <source>Format Type</source>
          <target state="translated">체재 유형</target>
        </trans-unit>
        <trans-unit id="0f03fcd6106e5cd7bc9d8b548ad021e4187d3de4" translate="yes" xml:space="preserve">
          <source>Format specified values of</source>
          <target state="translated">지정된 값의 형식 지정</target>
        </trans-unit>
        <trans-unit id="27b42a61c9970832b8b186790fa35509873d2e8d" translate="yes" xml:space="preserve">
          <source>Format specified values of &lt;code&gt;self&lt;/code&gt; and return them.</source>
          <target state="translated">지정된 &lt;code&gt;self&lt;/code&gt; 값을 형식화 하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="6d34b872a816aa7076abe13f14e014dee1ff70d4" translate="yes" xml:space="preserve">
          <source>Format string for dates written into Excel files (e.g. &amp;lsquo;YYYY-MM-DD&amp;rsquo;)</source>
          <target state="translated">Excel 파일에 기록 된 날짜의 형식 문자열 (예 : 'YYYY-MM-DD')</target>
        </trans-unit>
        <trans-unit id="a5a8078c50729de9efd422a070a95e6d4a538396" translate="yes" xml:space="preserve">
          <source>Format string for dates written into Excel files (e.g. &amp;lsquo;YYYY-MM-DD&amp;rsquo;).</source>
          <target state="translated">Excel 파일에 기록 된 날짜의 형식 문자열 (예 : 'YYYY-MM-DD').</target>
        </trans-unit>
        <trans-unit id="b020f5c5a2e9e8e57385dd78f284cb6b4b7505c3" translate="yes" xml:space="preserve">
          <source>Format string for datetime objects written into Excel files (e.g. &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo;)</source>
          <target state="translated">Excel 파일에 기록 된 날짜 / 시간 개체의 형식 문자열 (예 : 'YYYY-MM-DD HH : MM : SS')</target>
        </trans-unit>
        <trans-unit id="16af6f4e3a2e10fdde98c31918ba5eaa1d8d582c" translate="yes" xml:space="preserve">
          <source>Format string for datetime objects written into Excel files. (e.g. &amp;lsquo;YYYY-MM-DD HH:MM:SS&amp;rsquo;).</source>
          <target state="translated">Excel 파일에 기록 된 datetime 개체의 형식 문자열입니다. (예 : 'YYYY-MM-DD HH : MM : SS').</target>
        </trans-unit>
        <trans-unit id="d1f9c220a86b204985f6534d8f24dc3625fd9b63" translate="yes" xml:space="preserve">
          <source>Format string for datetime objects.</source>
          <target state="translated">날짜 / 시간 객체의 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="61792b236b0b98b0b29b2f1c1226613a42ed772e" translate="yes" xml:space="preserve">
          <source>Format string for floating point numbers.</source>
          <target state="translated">부동 소수점 숫자의 형식 문자열</target>
        </trans-unit>
        <trans-unit id="12d5ff452c1eb10875717600710c2fc8385f11ce" translate="yes" xml:space="preserve">
          <source>Format string for floating point numbers. For example &lt;code&gt;float_format=&quot;%.2f&quot;&lt;/code&gt; will format 0.1234 to 0.12.</source>
          <target state="translated">부동 소수점 숫자의 형식 문자열 예를 들어 &lt;code&gt;float_format=&quot;%.2f&quot;&lt;/code&gt; 는 0.1234에서 0.12로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a40d6d0d1b61ff1361218c6ee4329d240e29e58d" translate="yes" xml:space="preserve">
          <source>Format string to convert Timestamp to string. See strftime documentation for more information on the format string: &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&lt;/a&gt;.</source>
          <target state="translated">타임 스탬프를 문자열로 변환 할 형식 문자열입니다. 형식 문자열에 대한 자세한 정보는 strftime 문서를 참조하십시오 : &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&quot;&gt;https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea5852d75118543757450d402f17dda1d0d4df2d" translate="yes" xml:space="preserve">
          <source>Format the text display value of cells.</source>
          <target state="translated">셀의 텍스트 표시 값을 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="2839f0ebcdc286bd3f69f57d9b80f1e60e2540ef" translate="yes" xml:space="preserve">
          <source>Format to use when storing object in HDFStore. Value can be one of:</source>
          <target state="translated">HDFStore에 개체를 저장할 때 사용할 형식입니다. 값은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5438a2d879f16b19a503d6ae97eb8801b8ce2d4b" translate="yes" xml:space="preserve">
          <source>Formatted values.</source>
          <target state="translated">형식화 된 값.</target>
        </trans-unit>
        <trans-unit id="9caf844b46e108a2e316a48cc142a86b7fedc524" translate="yes" xml:space="preserve">
          <source>Formatter for floating point numbers. For example &lt;code&gt;float_format=&quot;%%.2f&quot;&lt;/code&gt; and &lt;code&gt;float_format=&quot;{:0.2f}&quot;.format&lt;/code&gt; will both result in 0.1234 being formatted as 0.12.</source>
          <target state="translated">부동 소수점 숫자를위한 포매터. 예를 들어 &lt;code&gt;float_format=&quot;%%.2f&quot;&lt;/code&gt; 및 &lt;code&gt;float_format=&quot;{:0.2f}&quot;.format&lt;/code&gt; 은 모두 0.1234가 0.12로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="0e77f48cad9b746f1a5e6ce0b31be23cac89278f" translate="yes" xml:space="preserve">
          <source>Formatter for floating point numbers. For example &lt;code&gt;float_format=&quot;%.2f&quot;&lt;/code&gt; and &lt;code&gt;float_format=&quot;{:0.2f}&quot;.format&lt;/code&gt; will both result in 0.1234 being formatted as 0.12.</source>
          <target state="translated">부동 소수점 숫자를위한 포맷터. 예를 들어 &lt;code&gt;float_format=&quot;%.2f&quot;&lt;/code&gt; 및 &lt;code&gt;float_format=&quot;{:0.2f}&quot;.format&lt;/code&gt; 은 둘 다 0.1234가 0.12로 형식화되도록합니다.</target>
        </trans-unit>
        <trans-unit id="cf268a12d163a61d0b25d6155bb9831413a55f75" translate="yes" xml:space="preserve">
          <source>Formatter function to apply to columns&amp;rsquo; elements if they are floats, default None.</source>
          <target state="translated">열 요소가 부동 소수점 인 경우에 적용되는 포맷터 함수, 기본값 없음</target>
        </trans-unit>
        <trans-unit id="a1a3182087a75f77562965d92f3cc94f1e89d474" translate="yes" xml:space="preserve">
          <source>Formatter function to apply to columns&amp;rsquo; elements if they are floats. The result of this function must be a unicode string.</source>
          <target state="translated">부동 소수점 인 경우 열 요소에 적용 할 포맷터 함수입니다. 이 함수의 결과는 유니 코드 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e679c684982ace527105df86559a12012c2c5b7b" translate="yes" xml:space="preserve">
          <source>Formatter function to apply to columns&amp;rsquo; elements if they are floats. This function must return a unicode string and will be applied only to the non-&lt;code&gt;NaN&lt;/code&gt; elements, with &lt;code&gt;NaN&lt;/code&gt; being handled by &lt;code&gt;na_rep&lt;/code&gt;.</source>
          <target state="translated">열의 요소가 부동 인 경우 적용 할 포맷터 함수입니다. 이 기능은 유니 코드 문자열을 반환해야하고 비에만 적용될 &lt;code&gt;NaN&lt;/code&gt; 으로 요소 &lt;code&gt;NaN&lt;/code&gt; 이이 처리되는 &lt;code&gt;na_rep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="153d92209f6160e2c7bf2b09525797a6d5ee079c" translate="yes" xml:space="preserve">
          <source>Formatter functions to apply to columns&amp;rsquo; elements by position or name. The result of each function must be a unicode string. List must be of length equal to the number of columns.</source>
          <target state="translated">포맷터 기능은 위치 또는 이름별로 열 요소에 적용됩니다. 각 함수의 결과는 유니 코드 문자열이어야합니다. 목록의 길이는 열 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="72f57b74b9d88606e29be585cee16804ea237812" translate="yes" xml:space="preserve">
          <source>Formatter functions to apply to columns&amp;rsquo; elements by position or name. The result of each function must be a unicode string. List/tuple must be of length equal to the number of columns.</source>
          <target state="translated">위치 또는 이름별로 열 요소에 적용 할 포맷터 함수입니다. 각 함수의 결과는 유니 코드 문자열이어야합니다. 목록 / 튜플의 길이는 열 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="1df875b791663b3fee445ce8e30ff16d10c8bc6c" translate="yes" xml:space="preserve">
          <source>Formatting function for scalar values.</source>
          <target state="translated">스칼라 값에 대한 형식화 기능.</target>
        </trans-unit>
        <trans-unit id="fec6e6340feaf4c44dea2c9ea14eb0a4d79a89da" translate="yes" xml:space="preserve">
          <source>Formerly this could be achieved with the dedicated &lt;code&gt;DataFrame.lookup&lt;/code&gt; method which was deprecated in version 1.2.0.</source>
          <target state="translated">이전에는 버전 1.2.0에서 더 이상 사용되지 않는 전용 &lt;code&gt;DataFrame.lookup&lt;/code&gt; 메서드를 사용 하여이 작업을 수행 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="10b080ba15dc5aefcfefd804f4ca97b3cc0646e8" translate="yes" xml:space="preserve">
          <source>Fortunately, pandas offers more than one way to ensure that your column(s) contain only one &lt;code&gt;dtype&lt;/code&gt;. If you&amp;rsquo;re unfamiliar with these concepts, you can see &lt;a href=&quot;basics#basics-dtypes&quot;&gt;here&lt;/a&gt; to learn more about dtypes, and &lt;a href=&quot;basics#basics-object-conversion&quot;&gt;here&lt;/a&gt; to learn more about &lt;code&gt;object&lt;/code&gt; conversion in pandas.</source>
          <target state="translated">다행히 pandas는 열에 &lt;code&gt;dtype&lt;/code&gt; 이 하나만 포함되도록하는 여러 가지 방법을 제공합니다 . 이러한 개념에 익숙하지 않은 경우 &lt;a href=&quot;basics#basics-dtypes&quot;&gt;여기&lt;/a&gt; 에서 dtypes 에 대해 자세히 알아보고 &lt;a href=&quot;basics#basics-object-conversion&quot;&gt;여기&lt;/a&gt; 에서 pandas의 &lt;code&gt;object&lt;/code&gt; 변환에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c976e6b46c484aaf12d4a3efc98fd6cb2858df6" translate="yes" xml:space="preserve">
          <source>Forward fill &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">정방향 채우기 &lt;code&gt;NaN&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="e86dc7f86849980e77b3a231273a8c263b89cb76" translate="yes" xml:space="preserve">
          <source>Forward fill NaN values in the resampled data.</source>
          <target state="translated">리샘플링 된 데이터에서 NaN 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c053305e5069585c8d36770eff2795aee72f8356" translate="yes" xml:space="preserve">
          <source>Forward fill NaN values.</source>
          <target state="translated">정방향 채우기 NaN 값.</target>
        </trans-unit>
        <trans-unit id="fc16c19e4a628a86db057e19b2fd0c18596d082d" translate="yes" xml:space="preserve">
          <source>Forward fill the values.</source>
          <target state="translated">값을 앞으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="e3037e63bf6849b84a9a65234ff16b35b8d4cade" translate="yes" xml:space="preserve">
          <source>Fraction</source>
          <target state="translated">Fraction</target>
        </trans-unit>
        <trans-unit id="7040945e333897a50c272ad699442b72485733c4" translate="yes" xml:space="preserve">
          <source>Fraction of axis items to return. Cannot be used with</source>
          <target state="translated">반환 할 축 항목의 비율입니다. 함께 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="12bdf318c0d4581b90440467582f220b0fc4edf0" translate="yes" xml:space="preserve">
          <source>Fraction of axis items to return. Cannot be used with &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">반환 할 축 항목의 비율입니다. &lt;code&gt;n&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="28c0b0ef782cf1fb30b3632ae56388c6b39f8cd5" translate="yes" xml:space="preserve">
          <source>Fraction of items to return. Cannot be used with</source>
          <target state="translated">반품 할 품목의 비율입니다. 함께 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="40128863b5b7df9bd5589b4004c946c4e2ca5c66" translate="yes" xml:space="preserve">
          <source>Frequencies</source>
          <target state="translated">Frequencies</target>
        </trans-unit>
        <trans-unit id="980c2bada0ad87425f81d3386eba272ab186114e" translate="yes" xml:space="preserve">
          <source>Frequency DateOffset or string.</source>
          <target state="translated">빈도 DateOffset 또는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4e2052837c563f82cb90654bfccf98e57113fe07" translate="yes" xml:space="preserve">
          <source>Frequency String</source>
          <target state="translated">주파수 문자열</target>
        </trans-unit>
        <trans-unit id="eeaec262d8d1ec3e815468bf6c562b4984e6f093" translate="yes" xml:space="preserve">
          <source>Frequency alias. By default the freq is taken from</source>
          <target state="translated">주파수 별명. 기본적으로 주파수는 다음에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2aa6132ea33484a73b5908ff5440273e93a2e9be" translate="yes" xml:space="preserve">
          <source>Frequency alias. By default the freq is taken from &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; if those are Period objects. Otherwise, the default is &lt;code&gt;&quot;D&quot;&lt;/code&gt; for daily frequency.</source>
          <target state="translated">주파수 별칭. 기본적으로 freq는 Period 객체 인 경우 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 에서 가져옵니다 . 그렇지 않으면 일일 빈도 의 기본값은 &lt;code&gt;&quot;D&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48b5cc5f2864213d55478931fee6feb9bd830124" translate="yes" xml:space="preserve">
          <source>Frequency associated with the PeriodIndex.</source>
          <target state="translated">PeriodIndex와 관련된 빈도입니다.</target>
        </trans-unit>
        <trans-unit id="29501b6e79441445d620b18c8d698ebe6a42d233" translate="yes" xml:space="preserve">
          <source>Frequency conversion</source>
          <target state="translated">주파수 변환</target>
        </trans-unit>
        <trans-unit id="0704c83dcc1e70b7b2e157acfe7c07f6efc4fcd6" translate="yes" xml:space="preserve">
          <source>Frequency conversion and resampling of time series.</source>
          <target state="translated">시계열의 주파수 변환 및 리샘플링.</target>
        </trans-unit>
        <trans-unit id="fd55b561a9be69187040b96c77c0efdda5608660" translate="yes" xml:space="preserve">
          <source>Frequency conversion and resampling with PeriodIndex</source>
          <target state="translated">PeriodIndex를 사용한 주파수 변환 및 리샘플링</target>
        </trans-unit>
        <trans-unit id="29900c0796afb4b609d4bcdb79b77a38a277aeab" translate="yes" xml:space="preserve">
          <source>Frequency increment to shift by. If None, the index is shifted by its own</source>
          <target state="translated">이동할 주파수 증가입니다. None이면 인덱스가 자체적으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="23edad8221b7cc76aa71e3a857e9e58b10925dd4" translate="yes" xml:space="preserve">
          <source>Frequency increment to shift by. If None, the index is shifted by its own &lt;code&gt;freq&lt;/code&gt; attribute. Offset aliases are valid strings, e.g., &amp;lsquo;D&amp;rsquo;, &amp;lsquo;W&amp;rsquo;, &amp;lsquo;M&amp;rsquo; etc.</source>
          <target state="translated">전환 할 주파수 증분. None이면 인덱스는 고유 한 &lt;code&gt;freq&lt;/code&gt; 특성 으로 이동 합니다. 오프셋 별칭은 유효한 문자열입니다 (예 : 'D', 'W', 'M'등).</target>
        </trans-unit>
        <trans-unit id="f2eb99c55cf2b7999d81428a54976938c2e82ab4" translate="yes" xml:space="preserve">
          <source>Frequency of the PeriodIndex.</source>
          <target state="translated">PeriodIndex의 빈도입니다.</target>
        </trans-unit>
        <trans-unit id="5c23f3321bc4b11c6796901996eb842d300c1bd4" translate="yes" xml:space="preserve">
          <source>Frequency string indicating the ceiling resolution.</source>
          <target state="translated">천장 해상도를 나타내는 주파수 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="5e9a2151f10f781441f8595f589998cdfb32128d" translate="yes" xml:space="preserve">
          <source>Frequency string indicating the flooring resolution.</source>
          <target state="translated">바닥 해상도를 나타내는 주파수 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6d95ff4d3564e0f9adcc89106ee0ec52061252c0" translate="yes" xml:space="preserve">
          <source>Frequency string indicating the rounding resolution.</source>
          <target state="translated">반올림 해상도를 나타내는 주파수 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b86a03713f6c521ae7559c485ac63724fc22e5a1" translate="yes" xml:space="preserve">
          <source>Frequency string.</source>
          <target state="translated">주파수 문자열.</target>
        </trans-unit>
        <trans-unit id="38627bd3804c3d1ef864563ce2ba5cc088ff5255" translate="yes" xml:space="preserve">
          <source>Frequency strings can have multiples, e.g. &amp;lsquo;5H&amp;rsquo;</source>
          <target state="translated">주파수 스트링은 배수를 가질 수 있습니다 (예 : '5H'</target>
        </trans-unit>
        <trans-unit id="b3d68d4e36f22234f436146bef664e61b007edfd" translate="yes" xml:space="preserve">
          <source>Frequency strings can have multiples, e.g. &amp;lsquo;5H&amp;rsquo;.</source>
          <target state="translated">주파수 스트링은 '5H'와 같은 배수를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="021618b637dd7059f0d0d646eeeec2971166407a" translate="yes" xml:space="preserve">
          <source>Frequency strings can have multiples, e.g. &amp;lsquo;5H&amp;rsquo;. See &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;here&lt;/a&gt; for a list of frequency aliases.</source>
          <target state="translated">주파수 스트링은 '5H'와 같은 배수를 가질 수 있습니다. 주파수 별명 목록은 &lt;a href=&quot;../../user_guide/timeseries#timeseries-offset-aliases&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd5245b787182c5c3241886586866da3a1ca5436" translate="yes" xml:space="preserve">
          <source>Frequency table like plyr in R</source>
          <target state="translated">R의 플라이어와 같은 주파수 테이블</target>
        </trans-unit>
        <trans-unit id="ca763ad9176c91fc7794e09187da2fcb49fe3f0c" translate="yes" xml:space="preserve">
          <source>Frequency tables can also be normalized to show percentages rather than counts using the &lt;code&gt;normalize&lt;/code&gt; argument:</source>
          <target state="translated">빈도 테이블은 &lt;code&gt;normalize&lt;/code&gt; 인수를 사용하여 개수가 아닌 백분율을 표시하도록 정규화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f5fb89546fa56451bf07260d4420bcc62940bb0" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions (FAQ)</source>
          <target state="translated">자주 묻는 질문 (FAQ)</target>
        </trans-unit>
        <trans-unit id="608af1de5eb7b093505effa772485c6b312751be" translate="yes" xml:space="preserve">
          <source>Frequently Used Options</source>
          <target state="translated">자주 사용하는 옵션</target>
        </trans-unit>
        <trans-unit id="3bed39d9fcf5eca17c8bb995860a91bb768245e6" translate="yes" xml:space="preserve">
          <source>Frequently used options</source>
          <target state="translated">자주 사용하는 옵션</target>
        </trans-unit>
        <trans-unit id="560e7164ce49a408f1ebb47fcb371ee5c6e9f8c5" translate="yes" xml:space="preserve">
          <source>From a SciPy sparse matrix, use &lt;a href=&quot;../reference/api/pandas.dataframe.sparse.from_spmatrix#pandas.DataFrame.sparse.from_spmatrix&quot;&gt;&lt;code&gt;DataFrame.sparse.from_spmatrix()&lt;/code&gt;&lt;/a&gt;,</source>
          <target state="translated">SciPy 희소 행렬에서 &lt;a href=&quot;../reference/api/pandas.dataframe.sparse.from_spmatrix#pandas.DataFrame.sparse.from_spmatrix&quot;&gt; &lt;code&gt;DataFrame.sparse.from_spmatrix()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d2eac70ef0a5f5e96f1b013aeb45cdc42e5e4af" translate="yes" xml:space="preserve">
          <source>From a Series</source>
          <target state="translated">시리즈에서</target>
        </trans-unit>
        <trans-unit id="bb0c3aeefe2ffa504c77d85a6e384a77a68918a9" translate="yes" xml:space="preserve">
          <source>From a dict of tuples</source>
          <target state="translated">튜플 사전에서</target>
        </trans-unit>
        <trans-unit id="1e7bf702e797484e049ea682828b5817b2627058" translate="yes" xml:space="preserve">
          <source>From a list of dataclasses</source>
          <target state="translated">데이터 클래스 목록에서</target>
        </trans-unit>
        <trans-unit id="468bec45e11c5a66c1fb8e184be8e3d05c1baa7b" translate="yes" xml:space="preserve">
          <source>From a list of dicts</source>
          <target state="translated">사전 목록에서</target>
        </trans-unit>
        <trans-unit id="28cb354d97006dfaaec5c6fea1e49e4243d115b9" translate="yes" xml:space="preserve">
          <source>From a list of namedtuples</source>
          <target state="translated">명명 된 튜플 목록에서</target>
        </trans-unit>
        <trans-unit id="451a153d92dc2f516c333805f79c92ce119a1a2f" translate="yes" xml:space="preserve">
          <source>From an array-like, use the regular &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt;&lt;code&gt;Series&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; constructors with &lt;code&gt;SparseArray&lt;/code&gt; values.</source>
          <target state="translated">에서 배열과 같은, 일반 사용 &lt;a href=&quot;../reference/api/pandas.series#pandas.Series&quot;&gt; &lt;code&gt;Series&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 와 생성자 &lt;code&gt;SparseArray&lt;/code&gt; 의 값을.</target>
        </trans-unit>
        <trans-unit id="51dbe984842c639f798cf4c00682fec24a67ec27" translate="yes" xml:space="preserve">
          <source>From an internal implementation point of view, the relevant methods that an &lt;code&gt;Index&lt;/code&gt; must define are one or more of the following (depending on how incompatible the new object internals are with the &lt;code&gt;Index&lt;/code&gt; functions):</source>
          <target state="translated">내부 구현 관점에서 &lt;code&gt;Index&lt;/code&gt; 이 정의해야하는 관련 메소드 는 다음 중 하나 이상입니다 (새 객체 내부가 &lt;code&gt;Index&lt;/code&gt; 함수 와 호환되지 않는 방법에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="838ded2482ca315552b6120806df84702ecc48c0" translate="yes" xml:space="preserve">
          <source>From dense to sparse, use &lt;a href=&quot;../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype&quot;&gt;&lt;code&gt;DataFrame.astype()&lt;/code&gt;&lt;/a&gt; with a &lt;a href=&quot;../reference/api/pandas.sparsedtype#pandas.SparseDtype&quot;&gt;&lt;code&gt;SparseDtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">조밀 한 것에서 희소 한 것까지 &lt;a href=&quot;../reference/api/pandas.dataframe.astype#pandas.DataFrame.astype&quot;&gt; &lt;code&gt;DataFrame.astype()&lt;/code&gt; &lt;/a&gt; 과 함께 DataFrame.astype () 을 사용 &lt;a href=&quot;../reference/api/pandas.sparsedtype#pandas.SparseDtype&quot;&gt; &lt;code&gt;SparseDtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bef20bb92a4ecb1074f7231b2c6c18e79fd2c3d4" translate="yes" xml:space="preserve">
          <source>From dict of Series or dicts</source>
          <target state="translated">시리즈 또는 사전의 사전에서</target>
        </trans-unit>
        <trans-unit id="d48ed2bf3909a1c94b6ec8e4895529dcba290c73" translate="yes" xml:space="preserve">
          <source>From dict of ndarrays / lists</source>
          <target state="translated">ndarrays / 목록의 사전에서</target>
        </trans-unit>
        <trans-unit id="195142b655d4793088d75afe93e4bcce5136989a" translate="yes" xml:space="preserve">
          <source>From dicts of Series, arrays, or dicts.</source>
          <target state="translated">시리즈, 배열 또는 dict의 dict에서.</target>
        </trans-unit>
        <trans-unit id="b7196b008f44353e6c5efec802c5f896714ff2ec" translate="yes" xml:space="preserve">
          <source>From sequence of (key, value) pairs read_csv, pandas.read_table, pandas.read_clipboard.</source>
          <target state="translated">일련의 (키, 값) 쌍에서 read_csv, pandas.read_table, pandas.read_clipboard.</target>
        </trans-unit>
        <trans-unit id="15c35c73e4f646131a45ef32c98eb47188a3a6d9" translate="yes" xml:space="preserve">
          <source>From sparse to dense, use the &lt;code&gt;.sparse&lt;/code&gt; accessors</source>
          <target state="translated">희소에서 밀도까지 &lt;code&gt;.sparse&lt;/code&gt; 접근 자를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c5b34c4f8143f7f702a3c6c7ead4e324ee97fc44" translate="yes" xml:space="preserve">
          <source>From structured or record array</source>
          <target state="translated">구조화 또는 레코드 배열에서</target>
        </trans-unit>
        <trans-unit id="b176f67b52be7bbe2819d54827855344efe72ae6" translate="yes" xml:space="preserve">
          <source>From timestamps to epoch</source>
          <target state="translated">타임 스탬프에서 에포크까지</target>
        </trans-unit>
        <trans-unit id="bd42ec4c0ea951284451d92090bdf2f6f5e04270" translate="yes" xml:space="preserve">
          <source>From version 1.5 and up, matplotlib offers a range of pre-configured plotting styles. Setting the style can be used to easily give plots the general look that you want. Setting the style is as easy as calling &lt;code&gt;matplotlib.style.use(my_plot_style)&lt;/code&gt; before creating your plot. For example you could write &lt;code&gt;matplotlib.style.use('ggplot')&lt;/code&gt; for ggplot-style plots.</source>
          <target state="translated">버전 1.5 이상부터 matplotlib는 사전 구성된 다양한 플로팅 스타일을 제공합니다. 스타일을 설정하면 플롯에 원하는 일반적인 모양을 쉽게 제공 할 수 있습니다. 스타일을 설정하는 것은 플롯을 만들기 전에 &lt;code&gt;matplotlib.style.use(my_plot_style)&lt;/code&gt; 를 호출하는 것만 큼 쉽습니다 . 예를 들어 ggplot 스타일 플롯에 대해 &lt;code&gt;matplotlib.style.use('ggplot')&lt;/code&gt; 를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478363baf36bf970827067c84760027bec65c3e3" translate="yes" xml:space="preserve">
          <source>Full documentation can be found &lt;a href=&quot;https://pandas-gbq.readthedocs.io/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">전체 문서는 &lt;a href=&quot;https://pandas-gbq.readthedocs.io/&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e923820f9cb1be7bad0a168e65ed377bea0b69ef" translate="yes" xml:space="preserve">
          <source>Full numpy-like syntax:</source>
          <target state="translated">전체 numpy와 유사한 구문 :</target>
        </trans-unit>
        <trans-unit id="ee6da781dd3904b7e5324e87d8cdc1f6b64b8c1d" translate="yes" xml:space="preserve">
          <source>Full path to a group (without trailing &amp;lsquo;/&amp;rsquo;)</source>
          <target state="translated">그룹의 전체 경로 ( '/'뒤에없는)</target>
        </trans-unit>
        <trans-unit id="97a48a2d2308e44125bb4d91bbd3567af562fd7e" translate="yes" xml:space="preserve">
          <source>Full path to a group (without trailing &amp;lsquo;/&amp;rsquo;).</source>
          <target state="translated">그룹에 대한 전체 경로 (후행 '/'없음).</target>
        </trans-unit>
        <trans-unit id="11ffc7ddf9ec01349c70b6e01a334bdb40a54b4c" translate="yes" xml:space="preserve">
          <source>Full reStructuredText specification</source>
          <target state="translated">전체 reStructuredText 사양</target>
        </trans-unit>
        <trans-unit id="47f6c7a8bbc55714acb71726d9a2028cdf551f0e" translate="yes" xml:space="preserve">
          <source>Fun stuff</source>
          <target state="translated">재미있는 것들</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="e78ad1b15dcf0a18aac08b8e177988aeb54619f9" translate="yes" xml:space="preserve">
          <source>Function / dict values must be unique (1-to-1). Labels not contained in a dict / Series will be left as-is. Extra labels listed don&amp;rsquo;t throw an error.</source>
          <target state="translated">함수 / dict 값은 고유해야합니다 (1 대 1). 사전 / 시리즈에 포함되지 않은 라벨은 그대로 유지됩니다. 나열된 추가 레이블은 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edac3e16cb277f3cd2986b45d81bff72a02fa44a" translate="yes" xml:space="preserve">
          <source>Function application</source>
          <target state="translated">기능 적용</target>
        </trans-unit>
        <trans-unit id="4953fe85849a4b51652d26a6190276f3b0adedb3" translate="yes" xml:space="preserve">
          <source>Function application, GroupBy &amp;amp; window</source>
          <target state="translated">기능 적용, GroupBy 및 창</target>
        </trans-unit>
        <trans-unit id="a091b8028bdfd2490bbdbbdf923aa3850451fd0e" translate="yes" xml:space="preserve">
          <source>Function application, groupby &amp;amp; window</source>
          <target state="translated">기능 적용, 그룹 별 및 창</target>
        </trans-unit>
        <trans-unit id="a80564ae1eb2beea69c09657eb462f01bfee8a88" translate="yes" xml:space="preserve">
          <source>Function calls other than math functions.</source>
          <target state="translated">수학 함수 이외의 함수 호출</target>
        </trans-unit>
        <trans-unit id="76af48c83189116cc762e906885f196893a97afa" translate="yes" xml:space="preserve">
          <source>Function is not implemented.</source>
          <target state="translated">기능이 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b6e2f37f0394b81471cc213a2d7016e539b351b4" translate="yes" xml:space="preserve">
          <source>Function is not implemented. Use pd.to_datetime().</source>
          <target state="translated">기능이 구현되지 않았습니다. pd.to_datetime ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee853619be4d3ea5b8ad55dd4800636f60b9ee08" translate="yes" xml:space="preserve">
          <source>Function is used to convert the given Timestamp object into the ISO format.</source>
          <target state="translated">함수는 주어진 Timestamp 객체를 ISO 형식으로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1775156176b062accb65d8aaa3939cdd1c353130" translate="yes" xml:space="preserve">
          <source>Function of one argument that reduces all the values in a bin to a single number (e.g.</source>
          <target state="translated">Bin의 모든 값을 단일 숫자로 줄이는 하나의 인수 함수 (예 :</target>
        </trans-unit>
        <trans-unit id="e73952036e9be9558f2dca02b9e30a7942bfd1fe" translate="yes" xml:space="preserve">
          <source>Function of one argument that reduces all the values in a bin to a single number (e.g. &lt;code&gt;np.mean&lt;/code&gt;, &lt;code&gt;np.max&lt;/code&gt;, &lt;code&gt;np.sum&lt;/code&gt;, &lt;code&gt;np.std&lt;/code&gt;).</source>
          <target state="translated">bin의 모든 값을 단일 숫자로 줄이는 하나의 인수 기능 (예 : &lt;code&gt;np.mean&lt;/code&gt; , &lt;code&gt;np.max&lt;/code&gt; , &lt;code&gt;np.sum&lt;/code&gt; , &lt;code&gt;np.std&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ed43094428b13e552f75bb19800d19e26830b08" translate="yes" xml:space="preserve">
          <source>Function that takes two scalars as inputs and returns an element.</source>
          <target state="translated">두 스칼라를 입력으로 받아서 요소를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="142d58ab1106ca3f8240ae97dc04e4232324301a" translate="yes" xml:space="preserve">
          <source>Function that takes two series as inputs and return a Series or a scalar. Used to merge the two dataframes column by columns.</source>
          <target state="translated">두 개의 계열을 입력으로 사용하여 계열 또는 스칼라를 반환하는 함수입니다. 두 데이터 프레임을 열별로 병합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ec927c6a3a44c57ebbeeaccb4cfeca58715e990" translate="yes" xml:space="preserve">
          <source>Function to apply to each column or row.</source>
          <target state="translated">각 열 또는 행에 적용하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="704f42764f050d29a2a580580656f4dd4c090158" translate="yes" xml:space="preserve">
          <source>Function to apply to each group.</source>
          <target state="translated">각 그룹에 적용 할 수있는 기능.</target>
        </trans-unit>
        <trans-unit id="13a104de8c013e516c73b5bde235fc7ced562e5a" translate="yes" xml:space="preserve">
          <source>Function to apply to each subframe. Should return True or False.</source>
          <target state="translated">각 서브 프레임에 적용하는 기능. True 또는 False를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d49c651fa62be8c001e03b6398849e32448686d9" translate="yes" xml:space="preserve">
          <source>Function to apply to the Series/DataFrame. &lt;code&gt;args&lt;/code&gt;, and &lt;code&gt;kwargs&lt;/code&gt; are passed into &lt;code&gt;func&lt;/code&gt;. Alternatively a &lt;code&gt;(callable, data_keyword)&lt;/code&gt; tuple where &lt;code&gt;data_keyword&lt;/code&gt; is a string indicating the keyword of &lt;code&gt;callable&lt;/code&gt; that expects the Series/DataFrame.</source>
          <target state="translated">Series / DataFrame에 적용 할 기능입니다. &lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;kwargs&lt;/code&gt; 는 &lt;code&gt;func&lt;/code&gt; 로 전달됩니다 . 또는 &lt;code&gt;(callable, data_keyword)&lt;/code&gt; 튜플에서 &lt;code&gt;data_keyword&lt;/code&gt; 는 Series / DataFrame을 예상하는 &lt;code&gt;callable&lt;/code&gt; 의 키워드를 나타내는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="cc74e4c0ad913c56ace7ee8175764f419629352e" translate="yes" xml:space="preserve">
          <source>Function to apply to the Styler. Alternatively, a &lt;code&gt;(callable, keyword)&lt;/code&gt; tuple where &lt;code&gt;keyword&lt;/code&gt; is a string indicating the keyword of &lt;code&gt;callable&lt;/code&gt; that expects the Styler.</source>
          <target state="translated">스타일러에 적용하는 기능입니다. 또는 &lt;code&gt;keyword&lt;/code&gt; 가 스타일러 가 필요한 &lt;code&gt;callable&lt;/code&gt; 키워드를 나타내는 문자열 인 &lt;code&gt;(callable, keyword)&lt;/code&gt; 튜플 입니다.</target>
        </trans-unit>
        <trans-unit id="f444ad2df723abe1ed532098b3d7e45813af9b74" translate="yes" xml:space="preserve">
          <source>Function to apply to this GroupBy object or, alternatively, a</source>
          <target state="translated">이 GroupBy 개체에 적용 할 함수 또는</target>
        </trans-unit>
        <trans-unit id="23bacc378f21eac868fee1ea31be046691dd5073" translate="yes" xml:space="preserve">
          <source>Function to apply to this GroupBy object or, alternatively, a &lt;code&gt;(callable, data_keyword)&lt;/code&gt; tuple where &lt;code&gt;data_keyword&lt;/code&gt; is a string indicating the keyword of &lt;code&gt;callable&lt;/code&gt; that expects the GroupBy object.</source>
          <target state="translated">이 GroupBy 객체 또는 &lt;code&gt;(callable, data_keyword)&lt;/code&gt; 튜플에 적용하는 &lt;code&gt;data_keyword&lt;/code&gt; 입니다. 여기서 data_keyword 는 GroupBy 객체를 예상하는 &lt;code&gt;callable&lt;/code&gt; 의 키워드를 나타내는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="39ff7f66d9f4dbeddbee4990b83c25b83dc44eef" translate="yes" xml:space="preserve">
          <source>Function to apply to this Resampler object or, alternatively, a</source>
          <target state="translated">이 Resampler 개체에 적용 할 함수 또는</target>
        </trans-unit>
        <trans-unit id="9dee26726482f3a7276da8f145a7cb4652d03675" translate="yes" xml:space="preserve">
          <source>Function to apply to this Resampler object or, alternatively, a &lt;code&gt;(callable, data_keyword)&lt;/code&gt; tuple where &lt;code&gt;data_keyword&lt;/code&gt; is a string indicating the keyword of &lt;code&gt;callable&lt;/code&gt; that expects the Resampler object.</source>
          <target state="translated">이 Resampler 객체 또는 &lt;code&gt;(callable, data_keyword)&lt;/code&gt; 튜플에 적용하는 &lt;code&gt;data_keyword&lt;/code&gt; 입니다. 여기서 data_keyword 는 Resampler 객체를 예상하는 &lt;code&gt;callable&lt;/code&gt; 의 키워드를 나타내는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="f90ee47a0b391d4586e24293aff42d41b421e638" translate="yes" xml:space="preserve">
          <source>Function to create a fixed frequency IntervalIndex.</source>
          <target state="translated">고정 주파수 IntervalIndex를 생성하는 기능.</target>
        </trans-unit>
        <trans-unit id="6a6b05ecfb5d80d3726eb6df8f3e820f01fcb088" translate="yes" xml:space="preserve">
          <source>Function to use for aggregating the data. If a function, must either work when passed a DataFrame or when passed to DataFrame.apply.</source>
          <target state="translated">데이터 집계에 사용되는 기능입니다. 함수 인 경우 DataFrame을 전달하거나 DataFrame.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e33e26c4e1b172a8d6959e1cb71afa79a34061a" translate="yes" xml:space="preserve">
          <source>Function to use for aggregating the data. If a function, must either work when passed a Series or when passed to Series.apply.</source>
          <target state="translated">데이터 집계에 사용되는 기능입니다. 함수 인 경우 Series를 전달하거나 Series.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="4128f18fca69a96ee57714dbd347b51c07c908de" translate="yes" xml:space="preserve">
          <source>Function to use for aggregating the data. If a function, must either work when passed a Series/Dataframe or when passed to Series/Dataframe.apply.</source>
          <target state="translated">데이터 집계에 사용되는 기능입니다. 함수 인 경우 Series / Dataframe을 전달하거나 Series / Dataframe.apply에 전달 될 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb8a7a8f8895024a39f151773776b9187da1c05a" translate="yes" xml:space="preserve">
          <source>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses &lt;code&gt;dateutil.parser.parser&lt;/code&gt; to do the conversion. Pandas will try to call</source>
          <target state="translated">문자열 열 시퀀스를 datetime 인스턴스 배열로 변환하는 데 사용할 함수입니다. 기본값은 &lt;code&gt;dateutil.parser.parser&lt;/code&gt; 를 사용 하여 변환을 수행합니다. 팬더는 전화를 시도합니다</target>
        </trans-unit>
        <trans-unit id="262d965883765f2bd1799b280b7f33844c253c56" translate="yes" xml:space="preserve">
          <source>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses &lt;code&gt;dateutil.parser.parser&lt;/code&gt; to do the conversion. Pandas will try to call &lt;code&gt;date_parser&lt;/code&gt; in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by &lt;code&gt;parse_dates&lt;/code&gt;) as arguments; 2) concatenate (row-wise) the string values from the columns defined by &lt;code&gt;parse_dates&lt;/code&gt; into a single array and pass that; and 3) call &lt;code&gt;date_parser&lt;/code&gt; once for each row using one or more strings (corresponding to the columns defined by &lt;code&gt;parse_dates&lt;/code&gt;) as arguments.</source>
          <target state="translated">일련의 문자열 열을 날짜 / 시간 인스턴스 배열로 변환하는 데 사용되는 함수입니다. 기본값은 &lt;code&gt;dateutil.parser.parser&lt;/code&gt; 를 사용 하여 변환을 수행합니다. 팬더는 예외가 발생하면 다음과 같이 세 가지 방법으로 &lt;code&gt;date_parser&lt;/code&gt; 를 호출하려고 시도 합니다. 1) 하나 이상의 배열 ( &lt;code&gt;parse_dates&lt;/code&gt; 에 정의 된 대로 )을 인수로 전달합니다. 2) &lt;code&gt;parse_dates&lt;/code&gt; 에 의해 정의 된 열의 문자열 값을 단일 배열로 연결하고 행으로 전달합니다. 3) 하나 이상의 문자열 ( &lt;code&gt;parse_dates&lt;/code&gt; 에 의해 정의 된 열에 해당 )을 인수로 사용하여 각 행에 대해 &lt;code&gt;date_parser&lt;/code&gt; 를 한 번 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06931417a8c3c87be1386bec1e882c4da93d8560" translate="yes" xml:space="preserve">
          <source>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses &lt;code&gt;dateutil.parser.parser&lt;/code&gt; to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments.</source>
          <target state="translated">문자열 열 시퀀스를 datetime 인스턴스 배열로 변환하는 데 사용할 함수입니다. 기본값은 &lt;code&gt;dateutil.parser.parser&lt;/code&gt; 를 사용 하여 변환을 수행합니다. pandas는 다음 세 가지 방법으로 date_parser를 호출하려고 시도합니다. 예외가 발생하면 다음으로 진행합니다. 1) 하나 이상의 배열 (parse_dates에 정의 된대로)을 인수로 전달합니다. 2) parse_dates에 의해 정의 된 열의 문자열 값을 단일 배열로 연결 (행 방향)하고 전달합니다. 3) 하나 이상의 문자열 (parse_dates로 정의 된 열에 해당)을 인수로 사용하여 각 행에 대해 date_parser를 한 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b0bbc6d6ba1a4e5c4f41ee18d817a7042c102770" translate="yes" xml:space="preserve">
          <source>Function to use for transforming the data. If a function, must either work when passed a DataFrame or when passed to DataFrame.apply.</source>
          <target state="translated">데이터 변환에 사용되는 기능. 함수 인 경우 DataFrame을 전달하거나 DataFrame.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="39487fe2a1e885ac7a7ca5b5b4b174ca86c22317" translate="yes" xml:space="preserve">
          <source>Function to use for transforming the data. If a function, must either work when passed a DataFrame or when passed to DataFrame.apply. If func is both list-like and dict-like, dict-like behavior takes precedence.</source>
          <target state="translated">데이터 변환에 사용할 함수입니다. 함수 인 경우 DataFrame을 전달할 때 또는 DataFrame.apply에 전달할 때 작동해야합니다. func가 목록과 유사하고 dict와 비슷하면 dict와 유사한 동작이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3bcef89ad9a8ddd55a53f46f2c926e9dbbbeea63" translate="yes" xml:space="preserve">
          <source>Function to use for transforming the data. If a function, must either work when passed a Series or when passed to Series.apply.</source>
          <target state="translated">데이터 변환에 사용되는 기능. 함수 인 경우 Series를 전달하거나 Series.apply에 전달할 때 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa98328a1ae8d8de94d1d2dd602141e50d1b3e25" translate="yes" xml:space="preserve">
          <source>Function to use for transforming the data. If a function, must either work when passed a Series or when passed to Series.apply. If func is both list-like and dict-like, dict-like behavior takes precedence.</source>
          <target state="translated">데이터 변환에 사용할 함수입니다. 함수 인 경우 Series를 전달할 때 또는 Series.apply에 전달할 때 작동해야합니다. func가 목록과 유사하고 dict와 비슷하면 dict와 유사한 동작이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="c7b3d071160f92e9defe001e7d5385571e245c98" translate="yes" xml:space="preserve">
          <source>Function will return &lt;code&gt;NaN&lt;/code&gt; for correlations of equal valued sequences; this is the result of a 0/0 division error.</source>
          <target state="translated">함수는 값이 같은 시퀀스의 상관 관계에 대해 &lt;code&gt;NaN&lt;/code&gt; 을 반환합니다. 이것은 0/0 나누기 오류의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="8201f25c3556b63cc6851b272ff2bb738a415b90" translate="yes" xml:space="preserve">
          <source>Functionally, their behavior should be nearly identical to their dense counterparts.</source>
          <target state="translated">기능적으로 이들의 동작은 조밀 한 대응과 거의 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c42a4d0ba5cbdb5b1c7cee6a8cc11c3803206e8" translate="yes" xml:space="preserve">
          <source>Functions or dict-like are transformations to apply to the index. Scalar or hashable sequence-like will alter the &lt;code&gt;Series.name&lt;/code&gt; attribute.</source>
          <target state="translated">함수 또는 dict-like는 인덱스에 적용 할 변환입니다. 스칼라 또는 해시 가능한 시퀀스 유사는 &lt;code&gt;Series.name&lt;/code&gt; 속성 을 변경 합니다.</target>
        </trans-unit>
        <trans-unit id="0a8b514ba071637dc2eae1bbef0e3daa98c4e2db" translate="yes" xml:space="preserve">
          <source>Further information on any specific method can be obtained in the &lt;a href=&quot;../reference/index#api&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">특정 방법에 대한 추가 정보는 &lt;a href=&quot;../reference/index#api&quot;&gt;API 참조 서&lt;/a&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33960d896ae62907f19482073a4f668f78b43f62" translate="yes" xml:space="preserve">
          <source>Further, operations among the scalars yield another scalar &lt;code&gt;Timedelta&lt;/code&gt;.</source>
          <target state="translated">또한 스칼라 간의 연산은 또 다른 스칼라 &lt;code&gt;Timedelta&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="e4a6925877eb7edda6e9c45cc43cf5d72dcbb77f" translate="yes" xml:space="preserve">
          <source>Furthermore &lt;code&gt;ptrepack in.h5 out.h5&lt;/code&gt; will &lt;em&gt;repack&lt;/em&gt; the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the &lt;code&gt;copy&lt;/code&gt; method.</source>
          <target state="translated">또한 &lt;code&gt;ptrepack in.h5 out.h5&lt;/code&gt; 는 이전에 삭제 된 공간을 재사용 할 수 있도록 파일을 &lt;em&gt;다시 &lt;/em&gt;압축 합니다. 또는 단순히 파일을 제거하고 다시 쓰거나 &lt;code&gt;copy&lt;/code&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64b02f12cf377018a98a9dbbd642420a521d1c1e" translate="yes" xml:space="preserve">
          <source>Furthermore one can run</source>
          <target state="translated">또한 하나를 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9f32b632aa0c2e3a46632a14a40b988e84e0148d" translate="yes" xml:space="preserve">
          <source>Furthermore you can align a level of a MultiIndexed DataFrame with a Series.</source>
          <target state="translated">또한 MultiIndexed DataFrame의 수준을 Series와 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba09a34a282e8cfe4b72a46471ed7b56f61361d3" translate="yes" xml:space="preserve">
          <source>Furthermore you can use partial string selection and the range will be inferred:</source>
          <target state="translated">또한 부분 문자열 선택을 사용할 수 있으며 범위가 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="a551a4e49b838725aa38f2446e3d1fbba5c7851e" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;where&lt;/code&gt; aligns the input boolean condition (ndarray or DataFrame), such that partial selection with setting is possible. This is analogous to partial setting via &lt;code&gt;.loc&lt;/code&gt; (but on the contents rather than the axis labels).</source>
          <target state="translated">또한, &lt;code&gt;where&lt;/code&gt; 가지런 입력 부울 조건 (ndarray 또는 DataFrame) 설정 부분과 선택이 가능하도록. 이것은 &lt;code&gt;.loc&lt;/code&gt; 을 통한 부분 설정과 유사합니다 (그러나 축 레이블이 아닌 내용에 있음).</target>
        </trans-unit>
        <trans-unit id="26329e4c5b41c63071fb03b9901ed5ec2432a59e" translate="yes" xml:space="preserve">
          <source>Furthermore, if you have a &lt;code&gt;Series&lt;/code&gt; with datetimelike values, then you can access these properties via the &lt;code&gt;.dt&lt;/code&gt; accessor, as detailed in the section on &lt;a href=&quot;basics#basics-dt-accessors&quot;&gt;.dt accessors&lt;/a&gt;.</source>
          <target state="translated">당신이있는 경우 또한, &lt;code&gt;Series&lt;/code&gt; datetimelike 값으로, 당신은을 통해 이러한 속성에 액세스 할 수 있습니다 &lt;code&gt;.dt&lt;/code&gt; 섹션에 설명 된대로, 접근 &lt;a href=&quot;basics#basics-dt-accessors&quot;&gt;.dt 접근&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="69360bdf1bb1c815af94063683809f16ec21002a" translate="yes" xml:space="preserve">
          <source>Furthermore, if you try to index something that is not fully lexsorted, this can raise:</source>
          <target state="translated">또한 완전히 lexsort되지 않은 항목을 인덱싱하려고하면 다음이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2de15db87adefb16b25954ff170378e29734e3" translate="yes" xml:space="preserve">
          <source>Furthermore, you can &lt;em&gt;set&lt;/em&gt; the values using the following methods.</source>
          <target state="translated">또한 다음 방법을 사용하여 값을 &lt;em&gt;설정할&lt;/em&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c050741b81f244f70f2367d0cc0ec4b36cd78cad" translate="yes" xml:space="preserve">
          <source>Furthermore, you can also specify multiple aggregation functions for each column separately.</source>
          <target state="translated">또한 각 열에 대해 여러 집계 함수를 개별적으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="047ca54032a1756c098d3bc1a941a0ed8e583df8" translate="yes" xml:space="preserve">
          <source>Future</source>
          <target state="translated">Future</target>
        </trans-unit>
        <trans-unit id="e19a59f9e8e15c4d1d11e2e68babca36e9d045c0" translate="yes" xml:space="preserve">
          <source>GROUP BY</source>
          <target state="translated">GROUP BY</target>
        </trans-unit>
        <trans-unit id="798198756ff1bfa44edf9d447d8302298b55d1f2" translate="yes" xml:space="preserve">
          <source>General (Either slicing style : depends on if the slice contains labels or positions)</source>
          <target state="translated">일반 (슬라이스 스타일 : 슬라이스에 레이블 또는 위치가 있는지 여부에 따라 다름)</target>
        </trans-unit>
        <trans-unit id="4081b8f9a028626a8abc9781488d7aad98742eab" translate="yes" xml:space="preserve">
          <source>General 2D labeled, size-mutable tabular structure with potentially heterogeneously-typed column</source>
          <target state="translated">이종 형식의 컬럼이있는 일반 2D 레이블이 있고 크기를 변경할 수있는 테이블 형식 구조</target>
        </trans-unit>
        <trans-unit id="57f2ab6aaa8943784f6f0b78910f4133f0520de6" translate="yes" xml:space="preserve">
          <source>General DataFrame combine</source>
          <target state="translated">일반 DataFrame 결합</target>
        </trans-unit>
        <trans-unit id="98ef0f4152a1d979296580f796428b16d22667e1" translate="yes" xml:space="preserve">
          <source>General function to concatenate DataFrame or Series objects.</source>
          <target state="translated">DataFrame 또는 Series 객체를 연결하는 일반 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4cb5fd0bbde100c5b28a657a95eaed1a4ad8e85f" translate="yes" xml:space="preserve">
          <source>General functions</source>
          <target state="translated">일반 기능</target>
        </trans-unit>
        <trans-unit id="0b5bb29a82c981f103a5f61cabcf8bd48c43388f" translate="yes" xml:space="preserve">
          <source>General parsing configuration</source>
          <target state="translated">일반 구문 분석 구성</target>
        </trans-unit>
        <trans-unit id="f8545898f71e08221b10f2e0ab96079a755c679d" translate="yes" xml:space="preserve">
          <source>General plot style arguments</source>
          <target state="translated">일반 플롯 스타일 인수</target>
        </trans-unit>
        <trans-unit id="58cc07cd05c6958c9a8410023fc828dc507072f7" translate="yes" xml:space="preserve">
          <source>General purpose method to trim DataFrame values to given threshold(s).</source>
          <target state="translated">DataFrame 값을 지정된 임계 값으로 자르는 범용 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3eaf5b37af932297d69a43c5413cf092f404a995" translate="yes" xml:space="preserve">
          <source>General purpose method to trim Series values to given threshold(s).</source>
          <target state="translated">주어진 임계 값으로 시리즈 값을 트리밍하는 범용 방법.</target>
        </trans-unit>
        <trans-unit id="bf6bda4587aff077462187186bdf6576ccc550c7" translate="yes" xml:space="preserve">
          <source>General rules</source>
          <target state="translated">일반적인 규칙</target>
        </trans-unit>
        <trans-unit id="2f7132be444a9c9f8523f39e425eb87d35bf051d" translate="yes" xml:space="preserve">
          <source>General terminology translation</source>
          <target state="translated">일반적인 용어 번역</target>
        </trans-unit>
        <trans-unit id="e3bbd1c83b028d0c18e790d49d124c58e3c9099b" translate="yes" xml:space="preserve">
          <source>General utility functions</source>
          <target state="translated">일반적인 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="e9d9d0c2fbe32089f49833ef17574a0cc5c7ff9a" translate="yes" xml:space="preserve">
          <source>Generalization of pivot that can handle duplicate values for one index/column pair.</source>
          <target state="translated">하나의 인덱스 / 열 쌍에 대한 중복 값을 처리 할 수있는 피벗의 일반화.</target>
        </trans-unit>
        <trans-unit id="e864efc51dcbe71c3be2f995f34a6766104d509d" translate="yes" xml:space="preserve">
          <source>Generally speaking, the &lt;code&gt;.str&lt;/code&gt; accessor is intended to work only on strings. With very few exceptions, other uses are not supported, and may be disabled at a later point.</source>
          <target state="translated">일반적으로 &lt;code&gt;.str&lt;/code&gt; 접근자는 문자열에서만 작동합니다. 매우 적은 예외를 제외하고 다른 사용은 지원되지 않으며 나중에 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dc4857a5c0bd7e0b01c500f03d43c3402ae101b" translate="yes" xml:space="preserve">
          <source>Generally, we recommend using &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt;&lt;code&gt;StringDtype&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;text#text-types&quot;&gt;Text data types&lt;/a&gt; for more.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../reference/api/pandas.stringdtype#pandas.StringDtype&quot;&gt; &lt;code&gt;StringDtype&lt;/code&gt; 을&lt;/a&gt; 사용하는 것이 좋습니다 . 자세한 내용은 &lt;a href=&quot;text#text-types&quot;&gt;텍스트 데이터 유형&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9723f95b5d873d1d0432716fdc17d3ff53dac65f" translate="yes" xml:space="preserve">
          <source>Generally, you can intersect the desired labels with the current axis, and then reindex.</source>
          <target state="translated">일반적으로 원하는 레이블을 현재 축과 교차 한 다음 다시 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57c4da3dc8fcaf4636cd99e0adac82f51a674c1c" translate="yes" xml:space="preserve">
          <source>Generate Embedded plots in excel files using Pandas, Vincent and xlsxwriter</source>
          <target state="translated">Pandas, Vincent 및 xlsxwriter를 사용하여 Excel 파일에 포함 된 플롯 생성</target>
        </trans-unit>
        <trans-unit id="97aaccee0280623c7908ba738eb125f70fa8c65f" translate="yes" xml:space="preserve">
          <source>Generate Kernel Density Estimate plot using Gaussian kernels.</source>
          <target state="translated">가우스 커널을 사용하여 커널 밀도 추정 플롯을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="55bb3b6a0825402faffa6d15a4e5ec851195083a" translate="yes" xml:space="preserve">
          <source>Generate a DataFrame with default index.</source>
          <target state="translated">기본 인덱스를 사용하여 DataFrame을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="219ad59288654be2d791655c7c1cdc5738d4811d" translate="yes" xml:space="preserve">
          <source>Generate a Series with duplicated entries.</source>
          <target state="translated">항목이 중복 된 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d5ae7b7a1be28979841ab10c7f389a56db94e4bd" translate="yes" xml:space="preserve">
          <source>Generate a hexagonal binning plot of</source>
          <target state="translated">다음의 육각형 비닝 플롯 생성</target>
        </trans-unit>
        <trans-unit id="f8e2fd0b69d0700fdc99adbe82bc0b097e71b8b0" translate="yes" xml:space="preserve">
          <source>Generate a hexagonal binning plot of &lt;code&gt;x&lt;/code&gt; versus &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; (the default), this is a histogram of the number of occurrences of the observations at &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 대 &lt;code&gt;y&lt;/code&gt; 의 6 각형 비닝 플롯을 생성합니다 . 경우 &lt;code&gt;C&lt;/code&gt; 는 없다 &lt;code&gt;None&lt;/code&gt; (디폴트), 이것의 관찰 된 발생 수의 히스토그램 &lt;code&gt;(x[i], y[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c45a875a76fb480480e0754f59178b9694f259b" translate="yes" xml:space="preserve">
          <source>Generate a hexagonal binning plot.</source>
          <target state="translated">육각형 비닝 플롯을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7a09d459f15db9c183018d83be8c00048ad13270" translate="yes" xml:space="preserve">
          <source>Generate a matplotlib plot of Andrews curves, for visualising clusters of multivariate data.</source>
          <target state="translated">다변량 데이터의 군집을 시각화하기 위해 Andrews 곡선의 matplotlib 플롯을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="910f71e6e699fa038e133873ca6183eec8514f9d" translate="yes" xml:space="preserve">
          <source>Generate a new DataFrame or Series with the index reset.</source>
          <target state="translated">인덱스 재설정으로 새 DataFrame 또는 Series를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="e1b8bb8546d849110ebb781111358327c8d49294" translate="yes" xml:space="preserve">
          <source>Generate a pie plot for a Series.</source>
          <target state="translated">시리즈에 대한 원형 그림을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7f4e98c69008bba302d5b7a908b67a16908b81" translate="yes" xml:space="preserve">
          <source>Generate a pie plot.</source>
          <target state="translated">파이 플롯을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="dc7bcc3162c98da8a5d3f09b27d176f895415994" translate="yes" xml:space="preserve">
          <source>Generate a random sample from a given 1-D numpy array.</source>
          <target state="translated">주어진 1 차원 numpy 배열에서 임의의 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="de7da30319f200e71b5c69df93949125d5970388" translate="yes" xml:space="preserve">
          <source>Generate an pandas.Index with duplicate values.</source>
          <target state="translated">중복 값으로 pandas.Index를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7548e1b4ba3d5faf268b55256de1d16a5a1494d4" translate="yes" xml:space="preserve">
          <source>Generate descriptive statistics of DataFrame columns.</source>
          <target state="translated">DataFrame 열에 대한 설명 통계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7038c3cc7a3edb83499619ad3f141f927977174a" translate="yes" xml:space="preserve">
          <source>Generate descriptive statistics that summarize the central tendency, dispersion and shape of a dataset&amp;rsquo;s distribution, excluding &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 값을 제외하고 데이터 세트 분포의 중심 경향, 분산 및 형태를 요약하는 설명 통계를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2ac750a2ce196d6ef9efeab728f8835f8717da84" translate="yes" xml:space="preserve">
          <source>Generate descriptive statistics.</source>
          <target state="translated">기술 통계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1c0e87508b56b35069661b33e123d8ab3c888671" translate="yes" xml:space="preserve">
          <source>Generate random samples from a DataFrame object.</source>
          <target state="translated">DataFrame 개체에서 임의의 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="76ba3c68ce4f31e83b645e6806741f73c57161bd" translate="yes" xml:space="preserve">
          <source>Generate sequences of fixed-frequency dates and time spans</source>
          <target state="translated">고정 빈도 날짜 및 시간 범위의 시퀀스 생성</target>
        </trans-unit>
        <trans-unit id="8825d513eda107425c4db37ecc245cbce4bd8d15" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D numpy array.</source>
          <target state="translated">주어진 1 차원 numpy 배열에서 무작위 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2d741fbb2d4c4f32c32f16ca7439fde75979f3cf" translate="yes" xml:space="preserve">
          <source>Generates descriptive statistics</source>
          <target state="translated">기술 통계를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5d2c5d4f49636f8f789c8d5262a478c477a1b588" translate="yes" xml:space="preserve">
          <source>Generates random samples from each group of a DataFrame object.</source>
          <target state="translated">DataFrame 개체의 각 그룹에서 임의의 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0181548f4c6f346b95b4b58028d26bc14510fff8" translate="yes" xml:space="preserve">
          <source>Generates random samples from each group of a Series object.</source>
          <target state="translated">Series 객체의 각 그룹에서 무작위 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="afddf3622252f75e90b0a8f62cad90c906ef3a8b" translate="yes" xml:space="preserve">
          <source>Generating ranges of intervals</source>
          <target state="translated">간격 범위 생성</target>
        </trans-unit>
        <trans-unit id="f317b4727f1d2350ad327ae413e1c55cba7f1d25" translate="yes" xml:space="preserve">
          <source>Generating ranges of time deltas</source>
          <target state="translated">시간 델타 범위 생성</target>
        </trans-unit>
        <trans-unit id="5dfb9b080c4a972cdca3ac39c4646147c92b34cc" translate="yes" xml:space="preserve">
          <source>Generating ranges of timestamps</source>
          <target state="translated">타임 스탬프 범위 생성</target>
        </trans-unit>
        <trans-unit id="d0bf3a03bd47b9dd9ed6c94d4c73789b10776bf3" translate="yes" xml:space="preserve">
          <source>Generator expressions</source>
          <target state="translated">생성기 표현식</target>
        </trans-unit>
        <trans-unit id="fe74896cfd89c88da5527de0b77998e0973da7bc" translate="yes" xml:space="preserve">
          <source>Generator yielding sequence for each group.</source>
          <target state="translated">각 그룹에 대한 생성기 항복 시퀀스.</target>
        </trans-unit>
        <trans-unit id="e6ffe0b73bdf76de6a54e29b687da0fb0cc766d3" translate="yes" xml:space="preserve">
          <source>Generator yielding sequence of (name, subsetted object)</source>
          <target state="translated">(이름, 부분 집합 객체)의 생성기 생성 순서</target>
        </trans-unit>
        <trans-unit id="ee1dd78f6508aeb6480d2fa7b1c1d9c323bcdca3" translate="yes" xml:space="preserve">
          <source>Generic offset class, defaults to absolute 24 hours</source>
          <target state="translated">일반 오프셋 클래스, 기본값은 절대 24 시간입니다.</target>
        </trans-unit>
        <trans-unit id="f52f26899659fbe64ac428f6f78a58c9560bf3e1" translate="yes" xml:space="preserve">
          <source>Generic rolling windows support specifying windows as a fixed number of observations or variable number of observations based on an offset. If a time based offset is provided, the corresponding time based index must be monotonic.</source>
          <target state="translated">일반 롤링 윈도우는 고정 된 수의 관측치 또는 오프셋을 기반으로하는 가변적 인 수의 관측치로 윈도우 지정을 지원합니다. 시간 기반 오프셋이 제공되는 경우 해당 시간 기반 인덱스는 단조로운 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b01f6cccf5c430a83b24dca76d9975bcf356977c" translate="yes" xml:space="preserve">
          <source>Geopandas</source>
          <target state="translated">Geopandas</target>
        </trans-unit>
        <trans-unit id="cb776443950280f6cba9d022306b92a37aebde5d" translate="yes" xml:space="preserve">
          <source>Geopandas extends pandas data objects to include geographic information which support geometric operations. If your work entails maps and geographical coordinates, and you love pandas, you should take a close look at Geopandas.</source>
          <target state="translated">Geopandas는 팬더 데이터 오브젝트를 확장하여 기하학적 조작을 지원하는 지리 정보를 포함합니다. 작품에지도와 지리적 좌표가 필요하고 팬더를 좋아한다면 Geopandas를 자세히 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="77547c7db8cb694b00c98eb040ef04ace0d4db71" translate="yes" xml:space="preserve">
          <source>Get Addition of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 추가 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="ae2b7868a7d16c6026fb9f6641c4c055febc08c7" translate="yes" xml:space="preserve">
          <source>Get Addition of dataframe and other, element-wise (binary operator &lt;code&gt;add&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 &lt;code&gt;add&lt;/code&gt; (이진 연산자 add ) 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="dadbf9ed77fbdc257016c633c7e291e7b73e7cd7" translate="yes" xml:space="preserve">
          <source>Get Addition of dataframe and other, element-wise (binary operator &lt;code&gt;radd&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 추가 (이진 연산자 &lt;code&gt;radd&lt;/code&gt; )를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6bbedad9f3c908607b8505ae592a88a030e340ea" translate="yes" xml:space="preserve">
          <source>Get Equal to of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="6881b850c3c986532c08fb363c53b2eb0225116b" translate="yes" xml:space="preserve">
          <source>Get Equal to of dataframe and other, element-wise (binary operator &lt;code&gt;eq&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 단위 (이진 연산자 &lt;code&gt;eq&lt;/code&gt; )와 같습니다.</target>
        </trans-unit>
        <trans-unit id="c77b496dae5458decd6d61337be179d66f573e86" translate="yes" xml:space="preserve">
          <source>Get Exponential power of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="8eb4c6e43f6b5f7f1f412175306b6bb201708cee" translate="yes" xml:space="preserve">
          <source>Get Exponential power of dataframe and other, element-wise (binary operator &lt;code&gt;pow&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 지수 (이진 연산자 &lt;code&gt;pow&lt;/code&gt; )의 지수를 구합니다 .</target>
        </trans-unit>
        <trans-unit id="9e2adf723c6a76eeacda639340be16ce67a6fb1b" translate="yes" xml:space="preserve">
          <source>Get Exponential power of dataframe and other, element-wise (binary operator &lt;code&gt;rpow&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 지수 (이진 연산자 &lt;code&gt;rpow&lt;/code&gt; )의 지수를 구합니다 .</target>
        </trans-unit>
        <trans-unit id="a387d6ef2779dc8da01ee7b7b02fc33b7080eec7" translate="yes" xml:space="preserve">
          <source>Get Floating division of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자)의 부동 분할 가져 오기</target>
        </trans-unit>
        <trans-unit id="727dbad4ab0d8474a93248f1508b0cc0c9f1b307" translate="yes" xml:space="preserve">
          <source>Get Floating division of dataframe and other, element-wise (binary operator &lt;code&gt;rtruediv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 부동 나누기를 &lt;code&gt;rtruediv&lt;/code&gt; (이진 연산자 rtruediv ).</target>
        </trans-unit>
        <trans-unit id="d8378a422387e375d08740b312f9be047a2f00a1" translate="yes" xml:space="preserve">
          <source>Get Floating division of dataframe and other, element-wise (binary operator &lt;code&gt;truediv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 부동 나누기를 &lt;code&gt;truediv&lt;/code&gt; (이진 연산자 truediv ).</target>
        </trans-unit>
        <trans-unit id="adf5d0cd1d9d44e3201b0ca6ac261a1e94db8930" translate="yes" xml:space="preserve">
          <source>Get Greater than of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="44b0e6b5f85380abfebaa39e25b3823f213b24b9" translate="yes" xml:space="preserve">
          <source>Get Greater than of dataframe and other, element-wise (binary operator &lt;code&gt;gt&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;gt&lt;/code&gt; ) 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="1789716a314c6c27ab80bccf203b620388ef058c" translate="yes" xml:space="preserve">
          <source>Get Greater than or equal to of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자)보다 크거나 같음</target>
        </trans-unit>
        <trans-unit id="b92efef83c131fe503d93b81d6d7dcfaa3ebbec3" translate="yes" xml:space="preserve">
          <source>Get Greater than or equal to of dataframe and other, element-wise (binary operator &lt;code&gt;ge&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;ge&lt;/code&gt; ) 보다 크거나 같습니다 .</target>
        </trans-unit>
        <trans-unit id="121c8cbd2377b6ae3bd23d3ba83cfdc395c6345e" translate="yes" xml:space="preserve">
          <source>Get Integer division of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 정수 나누기 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="3b3323a949a6f3b8c35324c9770c44dcf422805f" translate="yes" xml:space="preserve">
          <source>Get Integer division of dataframe and other, element-wise (binary operator &lt;code&gt;floordiv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 정수 나누기를 &lt;code&gt;floordiv&lt;/code&gt; (이진 연산자 floordiv ).</target>
        </trans-unit>
        <trans-unit id="a9a9d2b9cdcb9c5d2b98c51cd705b440d80846d3" translate="yes" xml:space="preserve">
          <source>Get Integer division of dataframe and other, element-wise (binary operator &lt;code&gt;rfloordiv&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임과 기타 요소 단위의 정수 나누기를 &lt;code&gt;rfloordiv&lt;/code&gt; (이진 연산자 rfloordiv ).</target>
        </trans-unit>
        <trans-unit id="f36701518cbfa3c0b9c90b169220c9733ada32df" translate="yes" xml:space="preserve">
          <source>Get Less than of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="42cad2ed7313d6b9b23637df759f19fa00d341fc" translate="yes" xml:space="preserve">
          <source>Get Less than of dataframe and other, element-wise (binary operator &lt;code&gt;lt&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 단위보다 적습니다 (이진 연산자 &lt;code&gt;lt&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d4eebd6e54ed6804fb2c1b2cfc7b4ce880339ed" translate="yes" xml:space="preserve">
          <source>Get Less than or equal to of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자)보다 작거나 같음 가져 오기</target>
        </trans-unit>
        <trans-unit id="043ee0ad8a1d3fa93c2d6c75fa60bc7c570d85ef" translate="yes" xml:space="preserve">
          <source>Get Less than or equal to of dataframe and other, element-wise (binary operator &lt;code&gt;le&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임보다 작거나 같고 다른 요소 별 (이진 연산자 &lt;code&gt;le&lt;/code&gt; )을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="542e17e3c8bc21809597fbd75840335d0079cefb" translate="yes" xml:space="preserve">
          <source>Get Modulo of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 모듈로 가져 오기 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="ce91129ba136f0463638b325f7b4a5fc85531dd6" translate="yes" xml:space="preserve">
          <source>Get Modulo of dataframe and other, element-wise (binary operator &lt;code&gt;mod&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;mod&lt;/code&gt; )의 Modulo를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="2166c9895afda2fe3805a4ed6a37715f8be994ff" translate="yes" xml:space="preserve">
          <source>Get Modulo of dataframe and other, element-wise (binary operator &lt;code&gt;rmod&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이진 연산자 &lt;code&gt;rmod&lt;/code&gt; )의 Modulo를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0625dfbb735d0db6b4fea0300af646f46515174f" translate="yes" xml:space="preserve">
          <source>Get Multiplication of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 곱셈 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="a9db3feb3586f1258e403412cc555b754ab3c92a" translate="yes" xml:space="preserve">
          <source>Get Multiplication of dataframe and other, element-wise (binary operator &lt;code&gt;mul&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 곱셈을 가져옵니다 (이진 연산자 &lt;code&gt;mul&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1388d2cf2af80e17317c08f9770b52a49f9c2f2d" translate="yes" xml:space="preserve">
          <source>Get Multiplication of dataframe and other, element-wise (binary operator &lt;code&gt;rmul&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 곱셈 (이진 연산자 &lt;code&gt;rmul&lt;/code&gt; )을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="10032af7b310e99993d1c449de793839bac58e40" translate="yes" xml:space="preserve">
          <source>Get Not equal to of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 (이항 연산자)의 같지 않음 가져 오기</target>
        </trans-unit>
        <trans-unit id="8d2d574ef5c8590ffef550e6bdd72a846a37f4c8" translate="yes" xml:space="preserve">
          <source>Get Not equal to of dataframe and other, element-wise (binary operator &lt;code&gt;ne&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 단위 (이진 연산자 &lt;code&gt;ne&lt;/code&gt; ) 와 같지 않음</target>
        </trans-unit>
        <trans-unit id="4dd888c9ae85479d0c96d708bb637b60611e222f" translate="yes" xml:space="preserve">
          <source>Get Subtraction of dataframe and other, element-wise (binary operator</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 빼기 (이항 연산자</target>
        </trans-unit>
        <trans-unit id="5d7a3ecd88fdea915d9e5f10e4a4bf57cd19868a" translate="yes" xml:space="preserve">
          <source>Get Subtraction of dataframe and other, element-wise (binary operator &lt;code&gt;rsub&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 빼기 (이진 연산자 &lt;code&gt;rsub&lt;/code&gt; )를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3146ba91d874f9eec6369574348eb7294ec036ef" translate="yes" xml:space="preserve">
          <source>Get Subtraction of dataframe and other, element-wise (binary operator &lt;code&gt;sub&lt;/code&gt;).</source>
          <target state="translated">데이터 프레임 및 기타 요소 별 빼기 (이진 연산자 &lt;code&gt;sub&lt;/code&gt; ) 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5ffb03ddea42699557317c0964d22c0679b431fc" translate="yes" xml:space="preserve">
          <source>Get both the location for the requested label(s) and the resulting sliced index.</source>
          <target state="translated">요청 된 레이블의 위치와 결과로 생성 된 슬라이스 인덱스를 모두 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d7e7e84fb35f14833cafb97389a3676c8f6152f2" translate="yes" xml:space="preserve">
          <source>Get day of the month that a Period falls on.</source>
          <target state="translated">기간이 속하는 월의 일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f98146c87c9e6cee6313cc766cab7861c157fa71" translate="yes" xml:space="preserve">
          <source>Get index locations of values at particular time of day.</source>
          <target state="translated">특정 시간에 값의 색인 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b396c868bb66ea9686b080a7f2d8b889c0c8eed0" translate="yes" xml:space="preserve">
          <source>Get index locations of values between particular times of day.</source>
          <target state="translated">하루 중 특정 시간 사이에 값의 색인 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="23dc3a30559b7e6e6eedb5f3c3b58fd37774290b" translate="yes" xml:space="preserve">
          <source>Get integer location, slice or boolean mask for requested label.</source>
          <target state="translated">요청 된 레이블에 대한 정수 위치, 슬라이스 또는 부울 마스크를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1495512810109b6180c84bd6f543e79e38733811" translate="yes" xml:space="preserve">
          <source>Get item from object for given key (ex: DataFrame column).</source>
          <target state="translated">주어진 키에 대해 객체에서 항목을 가져옵니다 (예 : DataFrame 열).</target>
        </trans-unit>
        <trans-unit id="8b71bfe2d62d2b197499002a79677564b6bb8b4f" translate="yes" xml:space="preserve">
          <source>Get just the index locations for values at particular time of the day.</source>
          <target state="translated">하루 중 특정 시간의 값에 대한 색인 위치 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="71c260bc2dc68edd80f8a6e385cc5f4a28047b23" translate="yes" xml:space="preserve">
          <source>Get just the index locations for values between particular times of the day.</source>
          <target state="translated">하루 중 특정 시간 사이의 값에 대한 색인 위치 만 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="3f38be46e955efcd2c6dea5438f9a31d9e68e604" translate="yes" xml:space="preserve">
          <source>Get level values by supplying</source>
          <target state="translated">제공하여 레벨 값 얻기</target>
        </trans-unit>
        <trans-unit id="573ad3e027b86128c73222c5a4a405ad9e017adb" translate="yes" xml:space="preserve">
          <source>Get level values by supplying &lt;code&gt;level&lt;/code&gt; as integer:</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 을 정수 로 제공하여 레벨 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="1111149ddd1953c3acf759b763c942dd6aebdb5c" translate="yes" xml:space="preserve">
          <source>Get level values by supplying level as either integer or name:</source>
          <target state="translated">레벨을 정수 또는 이름으로 제공하여 레벨 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3f551eb06d1ffbc835cc2d27b8e279a799c9f808" translate="yes" xml:space="preserve">
          <source>Get location and sliced index for requested label(s)/level(s).</source>
          <target state="translated">요청 된 레이블 / 레벨에 대한 위치 및 슬라이스 인덱스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6a307c9491073aca10dcc83b9998b926c3f1eacf" translate="yes" xml:space="preserve">
          <source>Get location for a label or a tuple of labels as an integer, slice or boolean mask.</source>
          <target state="translated">레이블, 레이블 튜플의 위치를 ​​정수, 슬라이스 또는 부울 마스크로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="04948c999aacd8c60e4754df05b4fa1f888c796a" translate="yes" xml:space="preserve">
          <source>Get location for a label or a tuple of labels.</source>
          <target state="translated">레이블 또는 튜플 레이블 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="029e778ca715f569b320678ab17a54cf332a28ca" translate="yes" xml:space="preserve">
          <source>Get location for a label/slice/list/mask or a sequence of such.</source>
          <target state="translated">레이블 / 슬라이스 / 목록 / 마스크 또는 일련의 해당 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e701aacc9cf17a9d8fb0fe0b04c4c9a2c0791ffa" translate="yes" xml:space="preserve">
          <source>Get location for a sequence of labels.</source>
          <target state="translated">일련의 레이블에 대한 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="824b3bc5f378073942323556dbc08c4d67ff1704" translate="yes" xml:space="preserve">
          <source>Get location for a single label.</source>
          <target state="translated">단일 라벨의 위치를 ​​확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e8470b50a051d8c2a1e07f71b2068d0272a87805" translate="yes" xml:space="preserve">
          <source>Get minute of the hour component of the Period.</source>
          <target state="translated">기간의 분 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="61c884339a71957b8fa72a90bf638fe5fdb4f3e5" translate="yes" xml:space="preserve">
          <source>Get slice location given start label(s) and end label(s).</source>
          <target state="translated">시작 레이블과 끝 레이블이 주어진 슬라이스 위치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3b74328d49b5994b7d4f9426591fe89e3cfd0532" translate="yes" xml:space="preserve">
          <source>Get the</source>
          <target state="translated">얻기</target>
        </trans-unit>
        <trans-unit id="32e22c5444ec637133057a762bc46d660f56e619" translate="yes" xml:space="preserve">
          <source>Get the &amp;lsquo;info axis&amp;rsquo; (see Indexing for more)</source>
          <target state="translated">'정보 축'가져 오기 (자세한 내용은 색인 생성 참조)</target>
        </trans-unit>
        <trans-unit id="b6fc45b952a34180fe8692c511e1fbb4e6e6b7d4" translate="yes" xml:space="preserve">
          <source>Get the &amp;lsquo;info axis&amp;rsquo; (see Indexing for more).</source>
          <target state="translated">'정보 축'을 가져옵니다 (자세한 내용은 인덱싱 참조).</target>
        </trans-unit>
        <trans-unit id="e9b674ec2f37a30b7d5417d9d9378cd3eba5604d" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;n&lt;/code&gt; largest elements.</source>
          <target state="translated">가져 오기 &lt;code&gt;n&lt;/code&gt; 개의 가장 큰 요소.</target>
        </trans-unit>
        <trans-unit id="eca332631315a697ab2dadd0c683ad9188881f34" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;n&lt;/code&gt; smallest elements.</source>
          <target state="translated">가져 오기 &lt;code&gt;n&lt;/code&gt; 개의 작은 요소.</target>
        </trans-unit>
        <trans-unit id="4601ee7e2fc8bf47de5b97b0291cc9199dcbd1f0" translate="yes" xml:space="preserve">
          <source>Get the Timestamp for the start of the period.</source>
          <target state="translated">기간 시작에 대한 타임 스탬프를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="07f7d1de1063ebe9947bb90e5cdae317654a67e9" translate="yes" xml:space="preserve">
          <source>Get the actual data stored within.</source>
          <target state="translated">저장된 실제 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="99634341ab162b4a7396497551aed6dd030cfe5b" translate="yes" xml:space="preserve">
          <source>Get the day component of the Period.</source>
          <target state="translated">기간의 요일 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4a98cce76b327ba3b387b56ccf083be789e26381" translate="yes" xml:space="preserve">
          <source>Get the day of the week.</source>
          <target state="translated">요일을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="189df6716b5a6b1d989b4c51ba0f2748cb480e4d" translate="yes" xml:space="preserve">
          <source>Get the day of the year.</source>
          <target state="translated">일의 날을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="3deee4a9d34c0e6128411af19bb5850492ac27ff" translate="yes" xml:space="preserve">
          <source>Get the hour component of the Period.</source>
          <target state="translated">기간의 시간 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="62648ef6be87d89f5f8136953dd96632265809c2" translate="yes" xml:space="preserve">
          <source>Get the hour of the day component of the Period.</source>
          <target state="translated">기간의 하루 중 시간 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4f664bca93b0209423129c921a083c98b2152f5d" translate="yes" xml:space="preserve">
          <source>Get the minute component of the Period.</source>
          <target state="translated">기간의 분 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e5068a6788db19fad22f4e850406d75cc69f2210" translate="yes" xml:space="preserve">
          <source>Get the mode(s) of each element along the selected axis.</source>
          <target state="translated">선택한 축을 따라 각 요소의 모드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="69e4c4ddf76d3ec246218509166a03502fe01840" translate="yes" xml:space="preserve">
          <source>Get the properties associated with this pandas object.</source>
          <target state="translated">이 pandas 객체와 관련된 속성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="17b8d7dc3d99a3a7619e34b598ea2a54a9b136e0" translate="yes" xml:space="preserve">
          <source>Get the rows for the first 3 days:</source>
          <target state="translated">처음 3 일 동안 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6a1dd6ed89163a698fe72b6a036b624ca3dfd259" translate="yes" xml:space="preserve">
          <source>Get the rows for the last 3 days:</source>
          <target state="translated">지난 3 일 동안 행을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e8d5ed0b60b1464f225b6afd929fe0b75bc9b685" translate="yes" xml:space="preserve">
          <source>Get the second component of the Period.</source>
          <target state="translated">기간의 두 번째 구성 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a7b83fc8ba8d64c22a2ea6d6c1df748bef59fdfc" translate="yes" xml:space="preserve">
          <source>Get the total number of days in the month that this period falls on.</source>
          <target state="translated">이 기간이 속하는 달의 총 일수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8c6497692eca0d6502e69e194009ad5c889b26f0" translate="yes" xml:space="preserve">
          <source>Get the total number of days of the month that the Period falls in.</source>
          <target state="translated">기간이 속하는 월의 총 일수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ec5e090f583787b867bee0f65078446f1ea000fa" translate="yes" xml:space="preserve">
          <source>Get the week of the year on the given Period.</source>
          <target state="translated">주어진 기간에 연중 주를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2f4b514c04c85dbc73a28873d10a5448e0822974" translate="yes" xml:space="preserve">
          <source>Get value at specified row/column pair</source>
          <target state="translated">지정된 행 / 열 쌍에서 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="e9db42f4395fcd5fb0233badf519ef8ac271a5f0" translate="yes" xml:space="preserve">
          <source>Get value within a Series</source>
          <target state="translated">시리즈 내에서 가치 창출</target>
        </trans-unit>
        <trans-unit id="f196f6bda0f581e85f5082a9236f74807e223dbe" translate="yes" xml:space="preserve">
          <source>Get value within a series</source>
          <target state="translated">시리즈 내에서 가치를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="59cd54cc529534492d232423983da9f637e45a87" translate="yes" xml:space="preserve">
          <source>Get values at several indexes</source>
          <target state="translated">여러 인덱스에서 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="13203bb9c3a173284d2d8adbcf5dfbfd5b23a1ad" translate="yes" xml:space="preserve">
          <source>Get values at several indexes and levels</source>
          <target state="translated">여러 지수와 수준에서 가치를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="7737c7550574f5e4bba8b3eb93e76f282e82a8bd" translate="yes" xml:space="preserve">
          <source>Get values at specified column and axis</source>
          <target state="translated">지정된 열과 축에서 값을 얻습니다</target>
        </trans-unit>
        <trans-unit id="c3cf089d4fdd1a573c5c5d9ef92841253297d6ed" translate="yes" xml:space="preserve">
          <source>Get values at specified index</source>
          <target state="translated">지정된 인덱스에서 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="1b70443afd4b6214bb9fbf7909cd12798c9821c6" translate="yes" xml:space="preserve">
          <source>Get values at specified index and level</source>
          <target state="translated">지정된 색인 및 수준에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3eef0696906c70598950c0cf85ca15d449e50d3d" translate="yes" xml:space="preserve">
          <source>Get values for a level of a MultiIndex.</source>
          <target state="translated">MultiIndex 수준의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="907aece8915b1fd3f6cf9d65eb58f61fcf680c08" translate="yes" xml:space="preserve">
          <source>Gets the number of days in the month.</source>
          <target state="translated">해당 월의 일 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c39d2f841b730db156ae2ad4d2bc2d88e199c83f" translate="yes" xml:space="preserve">
          <source>Getting</source>
          <target state="translated">Getting</target>
        </trans-unit>
        <trans-unit id="f5e032919594a9cf02d07af96697f2910cd6272d" translate="yes" xml:space="preserve">
          <source>Getting and setting options</source>
          <target state="translated">옵션 얻기 및 설정</target>
        </trans-unit>
        <trans-unit id="608052c50c86b3eb1e82a7ca328a285e362cdc4c" translate="yes" xml:space="preserve">
          <source>Getting data in/out</source>
          <target state="translated">데이터 입 / 출력</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="dc7206940ee12f67d6eae829d10799db2074f500" translate="yes" xml:space="preserve">
          <source>Getting started with Git</source>
          <target state="translated">Git 시작하기</target>
        </trans-unit>
        <trans-unit id="141c851d4caafbc68efdb1a768132c88f34d77f5" translate="yes" xml:space="preserve">
          <source>Getting support</source>
          <target state="translated">지원 받기</target>
        </trans-unit>
        <trans-unit id="f4dd5cea628dedba773ef68e17db081dfa538eb3" translate="yes" xml:space="preserve">
          <source>Getting the &amp;ldquo;raw data&amp;rdquo; inside a &lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt;&lt;code&gt;DataFrame&lt;/code&gt;&lt;/a&gt; is possibly a bit more complex. When your &lt;code&gt;DataFrame&lt;/code&gt; only has a single data type for all the columns, &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt;&lt;code&gt;DataFrame.to_numpy()&lt;/code&gt;&lt;/a&gt; will return the underlying data:</source>
          <target state="translated">&lt;a href=&quot;../reference/api/pandas.dataframe#pandas.DataFrame&quot;&gt; &lt;code&gt;DataFrame&lt;/code&gt; &lt;/a&gt; 내에서 &quot;원시 데이터&quot;를 가져 오는 것은 아마도 조금 더 복잡 할 수 있습니다. 귀하의 경우 &lt;code&gt;DataFrame&lt;/code&gt; 은 단지 모든 컬럼에 대해 하나의 데이터 유형이, &lt;a href=&quot;../reference/api/pandas.dataframe.to_numpy#pandas.DataFrame.to_numpy&quot;&gt; &lt;code&gt;DataFrame.to_numpy()&lt;/code&gt; &lt;/a&gt; 기본 데이터를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="21f6ceca1bbf6fe07b539a2f576e14d457783d96" translate="yes" xml:space="preserve">
          <source>Getting the &lt;code&gt;Index&lt;/code&gt; values of a &lt;code&gt;DataFrame&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;DataFrame&lt;/code&gt; 의 &lt;code&gt;Index&lt;/code&gt; 값 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="6581ebf227a8e26691ae34c23b5c2a21e509085d" translate="yes" xml:space="preserve">
          <source>Getting the examples pass the doctests in the validation script can sometimes be tricky. Here are some attention points:</source>
          <target state="translated">예제가 유효성 검사 스크립트의 doctest를 통과시키는 것은 까다로울 수 있습니다. 다음은 몇 가지주의 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1be10a2c118e99a528e8d10b29eff17ab62e2d96" translate="yes" xml:space="preserve">
          <source>Getting values from an object with multi-axes selection uses the following notation (using &lt;code&gt;.loc&lt;/code&gt; as an example, but the following applies to &lt;code&gt;.iloc&lt;/code&gt; as well). Any of the axes accessors may be the null slice &lt;code&gt;:&lt;/code&gt;. Axes left out of the specification are assumed to be &lt;code&gt;:&lt;/code&gt;, e.g. &lt;code&gt;p.loc['a']&lt;/code&gt; is equivalent to &lt;code&gt;p.loc['a', :, :]&lt;/code&gt;.</source>
          <target state="translated">다중 축을 선택하여 객체에서 값을 &lt;code&gt;.loc&lt;/code&gt; &lt;code&gt;.iloc&lt;/code&gt; 다음 표기법을 사용합니다 ( 예를 들어 .loc 을 사용 하지만 .iloc 에도 적용됨 ). 축에 접근 중 어떤 널 조각 될 수있다 &lt;code&gt;:&lt;/code&gt; . 사양에서 제외 된 축은 다음과 같이 가정합니다 &lt;code&gt;:&lt;/code&gt; 예를 들어 &lt;code&gt;p.loc['a']&lt;/code&gt; 는 &lt;code&gt;p.loc['a', :, :]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd711296b40c18649d46559dd68b1ee0da737bc5" translate="yes" xml:space="preserve">
          <source>Given a 1d array, return an array of deterministic integers.</source>
          <target state="translated">1d 배열이 주어지면 결정적 정수 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="3a3796a0f5fe11d12313dd4f66af267c77c58905" translate="yes" xml:space="preserve">
          <source>Given a Series of points randomly sampled from an unknown distribution, estimate its PDF using KDE with automatic bandwidth determination and plot the results, evaluating them at 1000 equally spaced points (default):</source>
          <target state="translated">알 수없는 분포에서 무작위로 샘플링 된 일련의 점이 주어지면 자동 대역폭 결정과 함께 KDE를 사용하여 PDF를 추정하고 결과를 플로팅하여 1000 개의 동일한 간격 점으로 평가합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="3f46c4cef009aef06e3694e93a8139836dbe2191" translate="yes" xml:space="preserve">
          <source>Given a grouper, the function resamples it according to a string &amp;ldquo;string&amp;rdquo; -&amp;gt; &amp;ldquo;frequency&amp;rdquo;.</source>
          <target state="translated">그룹화가 주어지면이 함수는 문자열 &quot;string&quot;-&amp;gt; &quot;frequency&quot;에 따라 리샘플링합니다.</target>
        </trans-unit>
        <trans-unit id="a7c6bf9d23675574ea35af12d4bd450996ba46af" translate="yes" xml:space="preserve">
          <source>Given a table name and a SQLAlchemy connectable, returns a DataFrame. This function does not support DBAPI connections.</source>
          <target state="translated">테이블 이름과 SQLAlchemy 연결 가능이 주어지면 DataFrame을 리턴합니다. 이 기능은 DBAPI 연결을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b87d15eecdea8eb7653c12b4e51c23d4fea5052c" translate="yes" xml:space="preserve">
          <source>Given equal-length arrays of row and column labels, return an array of the values corresponding to each (row, col) pair.</source>
          <target state="translated">동일한 길이의 행 및 열 레이블 배열이 제공되면 각 (행, 열) 쌍에 해당하는 값의 배열을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="fabde83b0c4b2113be9e8ecc3ebf7214a0f13ac7" translate="yes" xml:space="preserve">
          <source>Given the following time series</source>
          <target state="translated">다음 시계열이 주어지면</target>
        </trans-unit>
        <trans-unit id="0a2adc4aa886557fac5ae3f54e97e92a4f7cffca" translate="yes" xml:space="preserve">
          <source>Global flags applying to this object.</source>
          <target state="translated">이 개체에 적용되는 전역 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="6fcff4bc7b39ca253eddd5973a7f9609ada81a29" translate="yes" xml:space="preserve">
          <source>Global metadata applying to this dataset.</source>
          <target state="translated">이 데이터 세트에 적용되는 글로벌 메타 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="453762880d5aba77583acd766f4497e2fda5fc63" translate="yes" xml:space="preserve">
          <source>Going forward, we are moving to a more &lt;em&gt;functional&lt;/em&gt; style using the &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; framework, which offers a richer testing framework that will facilitate testing and developing. Thus, instead of writing test classes, we will write test functions like this:</source>
          <target state="translated">앞으로 우리는 &lt;a href=&quot;http://docs.pytest.org/en/latest/&quot;&gt;pytest&lt;/a&gt; 프레임 워크를 사용하여 보다 &lt;em&gt;기능적인&lt;/em&gt; 스타일로 전환하고 있습니다. pytest 프레임 워크는 테스트 및 개발을 용이하게하는 풍부한 테스트 프레임 워크를 제공합니다. 따라서 테스트 클래스를 작성하는 대신 다음과 같은 테스트 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="44e30797d5bd57312b121d1ba2c19ea22cf9065c" translate="yes" xml:space="preserve">
          <source>Going from long back to wide just takes some creative use of</source>
          <target state="translated">긴 백에서 와이드로 이동하려면 창의적인 사용이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a5f07bcb9bd2209b6891a0a5088f4aee79499a3e" translate="yes" xml:space="preserve">
          <source>Going from long back to wide just takes some creative use of &lt;code&gt;unstack&lt;/code&gt;</source>
          <target state="translated">오래전부터 넓게 돌아 가면 &lt;code&gt;unstack&lt;/code&gt; 창의적으로 사용하기 만하면됩니다</target>
        </trans-unit>
        <trans-unit id="c0cda22631dd1ea825c1317ced801a160bf0d263" translate="yes" xml:space="preserve">
          <source>Google Big Query</source>
          <target state="translated">구글 빅 쿼리</target>
        </trans-unit>
        <trans-unit id="2aa23a69a54076f50966d834705f7f8b7c75fb86" translate="yes" xml:space="preserve">
          <source>Google Big Query access</source>
          <target state="translated">Google Big Query 액세스</target>
        </trans-unit>
        <trans-unit id="e7a072101b6dc4cffd92e0691a040783403ff051" translate="yes" xml:space="preserve">
          <source>Google BigQuery</source>
          <target state="translated">Google BigQuery</target>
        </trans-unit>
        <trans-unit id="baba5872dc3b988b52803423439f4bd3bf204801" translate="yes" xml:space="preserve">
          <source>Google BigQuery Account project ID. Optional when available from the environment.</source>
          <target state="translated">Google BigQuery 계정 프로젝트 ID 환경에서 사용 가능한 경우 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1e15a0e47310034f5db3e8c25f23a00ccb08922b" translate="yes" xml:space="preserve">
          <source>Google Cloud Storage access</source>
          <target state="translated">Google 클라우드 저장소 액세스</target>
        </trans-unit>
        <trans-unit id="d887b25f7c1a45f4ebe5a21e2237262384db2f4e" translate="yes" xml:space="preserve">
          <source>Google Finance</source>
          <target state="translated">Google 금융</target>
        </trans-unit>
        <trans-unit id="000eb225364983805facb15a740de1dfd422fd39" translate="yes" xml:space="preserve">
          <source>Gotchas</source>
          <target state="translated">Gotchas</target>
        </trans-unit>
        <trans-unit id="55e73c0f5407b8794ebbf6f430bb0b67ff6270a1" translate="yes" xml:space="preserve">
          <source>Greater than of series and other.</source>
          <target state="translated">시리즈와 다른 것보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="37b28639298b1f085109978610256242435a1984" translate="yes" xml:space="preserve">
          <source>Group By: split-apply-combine</source>
          <target state="translated">분류 기준 : split-apply-combine</target>
        </trans-unit>
        <trans-unit id="36e4d51c149b3d21c306bc1edf9124e952d77e5c" translate="yes" xml:space="preserve">
          <source>Group DataFrame columns, compute a set of metrics and return a named Series. The Series name is used as the name for the column index. This is especially useful in conjunction with reshaping operations such as stacking in which the column index name will be used as the name of the inserted column:</source>
          <target state="translated">DataFrame 열을 그룹화하고 메트릭 집합을 계산하고 명명 된 Series를 반환합니다. 시리즈 이름은 열 인덱스의 이름으로 사용됩니다. 이는 열 인덱스 이름이 삽입 된 열의 이름으로 사용되는 스택과 같은 재구성 작업과 관련하여 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ad5aa335bf8f7a15b17daec2eb082dce11e523f" translate="yes" xml:space="preserve">
          <source>Group DataFrame or Series using a mapper or by a Series of columns.</source>
          <target state="translated">매퍼를 사용하거나 일련의 열을 기준으로 DataFrame 또는 Series를 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="8291b5d6b85048869cd6ea6e9f4ffc88a7e8d37d" translate="yes" xml:space="preserve">
          <source>Group DataFrame using a mapper or by a Series of columns.</source>
          <target state="translated">매퍼 또는 일련의 열을 사용하여 DataFrame을 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="5d14eb2dd66311c2062021949c071c58f2d5ad2c" translate="yes" xml:space="preserve">
          <source>Group Series using a mapper or by a Series of columns.</source>
          <target state="translated">매퍼 또는 일련의 열을 사용하여 계열을 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="936a26a0e5b573119c16b0b168b4db2a80507b68" translate="yes" xml:space="preserve">
          <source>Group by mapping, function, label, or list of labels.</source>
          <target state="translated">매핑, 기능, 레이블 또는 레이블 목록별로 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="257f9dba89392c25e6d298b31a0db2b62384f5f0" translate="yes" xml:space="preserve">
          <source>Group by: split-apply-combine</source>
          <target state="translated">그룹화 기준 : split-apply-combine</target>
        </trans-unit>
        <trans-unit id="7296f39827af27186dc97498d3664bcda7a0278b" translate="yes" xml:space="preserve">
          <source>Group left DataFrame by group columns and merge piece by piece with right DataFrame</source>
          <target state="translated">왼쪽 열을 그룹 열별로 그룹화하고 오른쪽 DataFrame을 사용하여 조각별로 병합</target>
        </trans-unit>
        <trans-unit id="1f9820c3ad50c61829ca1a72ee875102ae297e1f" translate="yes" xml:space="preserve">
          <source>Group left DataFrame by group columns and merge piece by piece with right DataFrame.</source>
          <target state="translated">그룹 열로 왼쪽 DataFrame을 그룹화하고 오른쪽 DataFrame과 하나씩 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="52590aceb82999e5cffb23f0d3a8acd6d395ff36" translate="yes" xml:space="preserve">
          <source>Group right DataFrame by group columns and merge piece by piece with left DataFrame</source>
          <target state="translated">그룹 열별로 오른쪽 DataFrame을 그룹화하고 왼쪽 DataFrame으로 조각별로 병합</target>
        </trans-unit>
        <trans-unit id="d78b4a917ca3ef22a8eb634f30065e077612ce87" translate="yes" xml:space="preserve">
          <source>Group right DataFrame by group columns and merge piece by piece with left DataFrame.</source>
          <target state="translated">그룹 열로 오른쪽 DataFrame을 그룹화하고 왼쪽 DataFrame과 하나씩 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="5a98397137ec4e2773eeafe47898de4f7267c4f7" translate="yes" xml:space="preserve">
          <source>Group the index labels by a given array of values.</source>
          <target state="translated">주어진 값 배열로 색인 레이블을 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="ab60d1f2ebb48b9206dd44e2508b4b2d7b6004c8" translate="yes" xml:space="preserve">
          <source>Group where to start walking.</source>
          <target state="translated">걷기 시작 위치를 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="41b5a96267dccb4d82371d385b32a0d7df0a44e1" translate="yes" xml:space="preserve">
          <source>Group where to start walking. If not supplied, the root group is used.</source>
          <target state="translated">걷기 시작하는 그룹. 제공되지 않으면 루트 그룹이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="63718ab0ad2dfd113729e407e5fdf344eb231fd5" translate="yes" xml:space="preserve">
          <source>GroupBy</source>
          <target state="translated">GroupBy</target>
        </trans-unit>
        <trans-unit id="84373419f62063ca22c67894c9fcd3ced0ccab74" translate="yes" xml:space="preserve">
          <source>GroupBy dropna</source>
          <target state="translated">GroupBy 드롭 나</target>
        </trans-unit>
        <trans-unit id="3365b262c12d46ff24a3b1d2eedf97772022e503" translate="yes" xml:space="preserve">
          <source>GroupBy object attributes</source>
          <target state="translated">GroupBy 개체 속성</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
