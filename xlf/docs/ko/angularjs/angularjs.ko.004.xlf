<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angularjs">
    <body>
      <group id="angularjs">
        <trans-unit id="0fd04e9e5b96e85cca8613d8294a4a6de3b25a55" translate="yes" xml:space="preserve">
          <source>If a request expectation has no response specified, the algorithm will search your backend definitions for an appropriate response.</source>
          <target state="translated">요청 예상에 응답이 지정되지 않은 경우 알고리즘은 백엔드 정의에서 적절한 응답을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="3c34b3f9a2baeaea1921d5fa87951146f390ffe3" translate="yes" xml:space="preserve">
          <source>If a required controller cannot be found, and it is optional, the instance is &lt;code&gt;null&lt;/code&gt;, otherwise the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/service/error/%24compile/ctreq&quot;&gt;Missing Required Controller&lt;/a&gt; error is thrown.</source>
          <target state="translated">필요한 컨트롤러를 찾을 수없고 선택적인 경우 인스턴스는 &lt;code&gt;null&lt;/code&gt; 이고, 그렇지 않으면 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/service/error/%24compile/ctreq&quot;&gt;누락 된 필수 컨트롤러&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8ecc0e4af38e92205b4a945081b7e78cdb43a2c" translate="yes" xml:space="preserve">
          <source>If a required controller cannot be found, and it is optional, the instance is &lt;code&gt;null&lt;/code&gt;, otherwise the &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/api/ng/service/error/%24compile/ctreq&quot;&gt;Missing Required Controller&lt;/a&gt; error is thrown.</source>
          <target state="translated">필수 컨트롤러를 찾을 수없고 선택 사항 인 경우 인스턴스는 &lt;code&gt;null&lt;/code&gt; 이고 그렇지 않으면 &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/api/ng/service/error/%24compile/ctreq&quot;&gt;Missing Required Controller&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3062c2d3fcf43cdcf6dc09ea8da967844fcf796b" translate="yes" xml:space="preserve">
          <source>If a service is decorated by both &lt;code&gt;$provide.decorator&lt;/code&gt; and &lt;code&gt;module.decorator&lt;/code&gt;, the decorators are applied in order:</source>
          <target state="translated">서비스가 &lt;code&gt;$provide.decorator&lt;/code&gt; 및 &lt;code&gt;module.decorator&lt;/code&gt; 에 의해 장식 된 경우, 데코레이터는 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8065da6f118dbd267964e5dadd97dd3d9850fb06" translate="yes" xml:space="preserve">
          <source>If a value is specified, returns the $httpProvider for chaining. otherwise, returns the current configured value.</source>
          <target state="translated">값이 지정되면 체인에 대한 $ httpProvider를 반환합니다. 그렇지 않으면 현재 구성된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f41bc8f62e166a66fdd0b00ba6f38f10a023aad" translate="yes" xml:space="preserve">
          <source>If an action's configuration specifies that it is cancellable, you can cancel the request related to an instance or collection (as long as it is a result of a &quot;non-instance&quot; call):</source>
          <target state="translated">조치 구성이 취소 가능하도록 지정하면 &quot;인스턴스가 아닌&quot;호출의 결과 인 한 인스턴스 또는 콜렉션과 관련된 요청을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7cda513ad242dc0410921f7e4d7987e45e3c2b" translate="yes" xml:space="preserve">
          <source>If an attribute with a binding is prefixed with the &lt;code&gt;ngAttr&lt;/code&gt; prefix (denormalized as &lt;code&gt;ng-attr-&lt;/code&gt;) then during the binding it will be applied to the corresponding unprefixed attribute. This allows you to bind to attributes that would otherwise be eagerly processed by browsers (e.g. an SVG element's &lt;code&gt;circle[cx]&lt;/code&gt; attributes). When using &lt;code&gt;ngAttr&lt;/code&gt;, the &lt;code&gt;allOrNothing&lt;/code&gt; flag of &lt;a href=&quot;../api/ng/service/%24interpolate&quot;&gt;$interpolate&lt;/a&gt; is used, so if any expression in the interpolated string results in &lt;code&gt;undefined&lt;/code&gt;, the attribute is removed and not added to the element.</source>
          <target state="translated">바인딩이있는 속성 앞에 &lt;code&gt;ngAttr&lt;/code&gt; 접두사 가 붙으면 ( &lt;code&gt;ng-attr-&lt;/code&gt; 로 비정규 화됨 ) 바인딩 중에 해당 접두사가없는 속성에 적용됩니다. 이를 통해 브라우저에서 열성적으로 처리 할 수있는 속성 (예 : SVG 요소의 &lt;code&gt;circle[cx]&lt;/code&gt; 속성) 에 바인딩 할 수 있습니다 . &lt;code&gt;ngAttr&lt;/code&gt; 을 사용할 때 &lt;a href=&quot;../api/ng/service/%24interpolate&quot;&gt;$ interpolate&lt;/a&gt; 의 &lt;code&gt;allOrNothing&lt;/code&gt; 플래그 가 사용되므로 보간 된 문자열의 표현식으로 인해 &lt;code&gt;undefined&lt;/code&gt; 가 발생하면 속성이 제거되고 요소에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c897c9ef737c27fdd08857ed2716fb1b8f4d9a5" translate="yes" xml:space="preserve">
          <source>If an expectation or definition uses a &lt;strong&gt;regex&lt;/strong&gt; to match the URL, you can provide an array of &lt;strong&gt;keys&lt;/strong&gt; via a &lt;code&gt;params&lt;/code&gt; argument. The index of each &lt;strong&gt;key&lt;/strong&gt; in the array will match the index of a &lt;strong&gt;group&lt;/strong&gt; in the &lt;strong&gt;regex&lt;/strong&gt;.</source>
          <target state="translated">기대 또는 정의가 &lt;strong&gt;정규식&lt;/strong&gt; 을 사용 하여 URL과 일치하는 경우 &lt;code&gt;params&lt;/code&gt; 인수 를 통해 &lt;strong&gt;키&lt;/strong&gt; 배열을 제공 할 수 있습니다 . 각각의 인덱스 &lt;strong&gt;키&lt;/strong&gt; 배열은 인덱스 일치 &lt;strong&gt;기를&lt;/strong&gt; 에 &lt;strong&gt;정규식&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e464595e0a743e0020b60c55e500247b0faf2671" translate="yes" xml:space="preserve">
          <source>If an interceptor object was provided, the promise will instead be resolved with the value returned by the response interceptor (on success) or responceError interceptor (on failure).</source>
          <target state="translated">인터셉터 오브젝트가 제공된 경우, 대신 약속이 응답 인터셉터 (성공) 또는 responceError 인터셉터 (실패)에 의해 리턴 된 값으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="7550c3d4cbd675d41d3da8b71e0e2ec2f8a2fd48" translate="yes" xml:space="preserve">
          <source>If any expectation within an &lt;code&gt;it&lt;/code&gt; block fails, the runner marks the &lt;code&gt;it&lt;/code&gt; as &quot;failed&quot; and continues on to the next block.</source>
          <target state="translated">&lt;code&gt;it&lt;/code&gt; 블록 내 예상 이 실패하면 러너는 &lt;code&gt;it&lt;/code&gt; 를 &quot;실패&quot;로 표시 하고 다음 블록으로 계속 진행합니다.</target>
        </trans-unit>
        <trans-unit id="1352dc692bed1cbf1f5076fcaeba257174fe28f2" translate="yes" xml:space="preserve">
          <source>If automatic scrolling is disabled, one must explicitly call &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$anchorScroll()&lt;/a&gt; in order to scroll to the element related to the current hash.</source>
          <target state="translated">자동 스크롤이 비활성화 된 경우 현재 해시와 관련된 요소로 스크롤하려면 &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$ anchorScroll ()&lt;/a&gt; 을 명시 적으로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3b4e24e7eaa2ca32436552a01221de60832d916b" translate="yes" xml:space="preserve">
          <source>If boolean, sets &lt;code&gt;html5Mode.enabled&lt;/code&gt; to value. If object, sets &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;requireBase&lt;/code&gt; and &lt;code&gt;rewriteLinks&lt;/code&gt; to respective values. Supported properties:</source>
          <target state="translated">부울 인 경우 &lt;code&gt;html5Mode.enabled&lt;/code&gt; 를 value로 설정 합니다. object 인 경우 &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;requireBase&lt;/code&gt; 및 &lt;code&gt;rewriteLinks&lt;/code&gt; 를 해당 값으로 설정합니다. 지원되는 속성 :</target>
        </trans-unit>
        <trans-unit id="7148e4e9bfb3ae0f9035089b0911fcd382c40701" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;bindToController&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt; are defined and have object hashes, &lt;code&gt;bindToController&lt;/code&gt; overrides &lt;code&gt;scope&lt;/code&gt;.</source>
          <target state="translated">두 경우 &lt;code&gt;bindToController&lt;/code&gt; 및 &lt;code&gt;scope&lt;/code&gt; 정의 및 객체의 해시를 가지고 있으며, &lt;code&gt;bindToController&lt;/code&gt; 은 우선 &lt;code&gt;scope&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cabef013ace4e4c9c00e6712ac1e83f19c28fc9" translate="yes" xml:space="preserve">
          <source>If both values are objects, compare their indices instead.</source>
          <target state="translated">두 값이 모두 객체 인 경우 인덱스를 대신 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="e0f58fb3edabd2bfd4c52120891ecad3c7f08490" translate="yes" xml:space="preserve">
          <source>If both values are of type &lt;code&gt;string&lt;/code&gt;, compare them alphabetically in a case- and locale-insensitive way.</source>
          <target state="translated">두 값이 모두 &lt;code&gt;string&lt;/code&gt; 유형 인 경우 대소 문자를 구분하지 않고 대소 문자를 구분하지 않고 알파벳순으로 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="a3acd0c125665e994f5cc5d87ff32bae58ae7519" translate="yes" xml:space="preserve">
          <source>If caching is enabled, but neither the default cache nor config.cache are set to a cache object, then the default &lt;code&gt;$cacheFactory(&quot;$http&quot;)&lt;/code&gt; object is used.</source>
          <target state="translated">캐싱이 사용 가능하지만 기본 캐시 나 config.cache가 캐시 오브젝트로 설정되지 않은 경우 기본 &lt;code&gt;$cacheFactory(&quot;$http&quot;)&lt;/code&gt; 오브젝트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6be3243cff2b9606141e7d8a8288624cc35fdc41" translate="yes" xml:space="preserve">
          <source>If called with a function then it's considered to be the controller constructor function. Otherwise it's considered to be a string which is used to retrieve the controller constructor using the following steps:</source>
          <target state="translated">함수와 함께 호출되면 컨트롤러 생성자 함수로 간주됩니다. 그렇지 않으면 다음 단계를 사용하여 컨트롤러 생성자를 검색하는 데 사용되는 문자열로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="eca4a0606f2e890d1b99bf344fe5c04e4c526a90" translate="yes" xml:space="preserve">
          <source>If called with no arguments returns the parsed &lt;code&gt;search&lt;/code&gt; object. If called with one or more arguments returns &lt;code&gt;$location&lt;/code&gt; object itself.</source>
          <target state="translated">인수없이 호출하면 구문 분석 된 &lt;code&gt;search&lt;/code&gt; 객체가 반환 됩니다. 하나 이상의 인수로 호출하면 &lt;code&gt;$location&lt;/code&gt; 객체 자체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c24fb87cdf6ae1778bbb557cc0ff10b76544fa3c" translate="yes" xml:space="preserve">
          <source>If called, all changes to $location during the current &lt;code&gt;$digest&lt;/code&gt; will replace the current history record, instead of adding a new one.</source>
          <target state="translated">호출되면, 현재 &lt;code&gt;$digest&lt;/code&gt; 동안 $ location에 대한 모든 변경 사항 은 새 기록 레코드를 추가하는 대신 현재 기록 레코드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="b025c8c144cafc2941eab97705006674236a7463" translate="yes" xml:space="preserve">
          <source>If custom triggers are used, custom debouncing timeouts can be set for each event using an object in &lt;code&gt;debounce&lt;/code&gt;. This can be useful to force immediate updates on some specific circumstances (like blur events).</source>
          <target state="translated">사용자 지정 트리거가 사용되는 경우 &lt;code&gt;debounce&lt;/code&gt; 의 객체를 사용하여 각 이벤트에 대해 사용자 지정 수신 거부 시간 초과를 설정할 수 있습니다 . 이 기능은 특정 상황 (예 : 흐림 이벤트)에서 즉시 업데이트를 수행하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50eecbd017e410f336fd4a83ba00bd8c53ebc392" translate="yes" xml:space="preserve">
          <source>If for example we wanted to create animations for &lt;code&gt;leave&lt;/code&gt; and &lt;code&gt;move&lt;/code&gt; (ngRepeat triggers move) then we can do so using the same CSS naming conventions:</source>
          <target state="translated">예를 들어 &lt;code&gt;leave&lt;/code&gt; 및 &lt;code&gt;move&lt;/code&gt; (ngRepeat 트리거 이동)에 대한 애니메이션을 만들려 는 경우 동일한 CSS 명명 규칙을 사용하여 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="107509b3211b546d6aa398c5cd00116593d484cf" translate="yes" xml:space="preserve">
          <source>If it is necessary to reference the controller or any functions bound to the controller from the template, you can use the option &lt;code&gt;controllerAs&lt;/code&gt; to specify the name of the controller as an alias. The directive needs to define a scope for this configuration to be used. This is particularly useful in the case when the directive is used as a component.</source>
          <target state="translated">제어기 또는 템플리트에서 제어기에 바인드 된 기능을 참조해야하는 경우, controllerAs 옵션을 사용하여 &lt;code&gt;controllerAs&lt;/code&gt; 이름을 별명으로 지정할 수 있습니다. 지시문은이 구성이 사용될 범위를 정의해야합니다. 이것은 지시문이 구성 요소로 사용되는 경우에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9a307e66a98c3ebe2ff88b0c79288c8c10c4b570" translate="yes" xml:space="preserve">
          <source>If jQuery is available, &lt;code&gt;angular.element&lt;/code&gt; is an alias for the &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;jQuery&lt;/a&gt; function. If jQuery is not available, &lt;code&gt;angular.element&lt;/code&gt; delegates to AngularJS's built-in subset of jQuery, called &quot;jQuery lite&quot; or &lt;strong&gt;jqLite&lt;/strong&gt;.</source>
          <target state="translated">jQuery를 사용할 수있는 경우 &lt;code&gt;angular.element&lt;/code&gt; 는 &lt;a href=&quot;http://api.jquery.com/jQuery/&quot;&gt;jQuery&lt;/a&gt; 함수 의 별명입니다 . jQuery를 사용할 수없는 경우 &lt;code&gt;angular.element&lt;/code&gt; 는 &quot;jQuery lite&quot;또는 &lt;strong&gt;jqLite&lt;/strong&gt; 라는 AngularJS의 내장 jQuery 서브 세트에 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="c701fc2f8dc85147ea98151e5bf3322bcac3aaee" translate="yes" xml:space="preserve">
          <source>If multiple controllers are required, the &lt;code&gt;require&lt;/code&gt; option of the directive can take an array argument. The corresponding parameter being sent to the &lt;code&gt;link&lt;/code&gt; function will also be an array.</source>
          <target state="translated">여러 제어기가 필요한 경우 지시문 의 &lt;code&gt;require&lt;/code&gt; 옵션은 배열 인수를 사용할 수 있습니다. &lt;code&gt;link&lt;/code&gt; 함수 에 전송되는 해당 매개 변수 도 배열입니다.</target>
        </trans-unit>
        <trans-unit id="9131087c07a27ae54bb5cb150194e99e5b9ded60" translate="yes" xml:space="preserve">
          <source>If multiple identical requests are made using the same cache, which is not yet populated, one request will be made to the server and remaining requests will return the same response.</source>
          <target state="translated">아직 채워지지 않은 동일한 캐시를 사용하여 여러 개의 동일한 요청이 이루어진 경우 하나의 요청이 서버에 작성되고 나머지 요청은 동일한 응답을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5099fba28286973badadf5e09f2c704804e0e9a4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;templateNamespace&lt;/code&gt; is specified, then the namespace is considered to be &lt;code&gt;html&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;templateNamespace&lt;/code&gt; 를 지정 하지 않으면 네임 스페이스는 &lt;code&gt;html&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="565e32b222f018c04759a0915c1eafd46c68d0e3" translate="yes" xml:space="preserve">
          <source>If no delay is specified, it uses a delay such that all currently pending tasks are flushed.</source>
          <target state="translated">지연을 지정하지 않으면 현재 보류중인 모든 작업이 플러시되도록 지연을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a343b02429ad2a626c45c677fe2309fc8eb6e9af" translate="yes" xml:space="preserve">
          <source>If no destination is supplied, a copy of the object or array is created.</source>
          <target state="translated">대상이 제공되지 않으면 객체 또는 배열의 사본이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="613c17fb4d65c58a50bf306d9be2b19d42f72bd3" translate="yes" xml:space="preserve">
          <source>If no rule is defined for a category, then an empty string is displayed and a warning is generated. Note that some locales define more categories than &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;. For example, fr-fr defines &lt;code&gt;few&lt;/code&gt; and &lt;code&gt;many&lt;/code&gt;.</source>
          <target state="translated">범주에 대해 규칙이 정의되어 있지 않으면 빈 문자열이 표시되고 경고가 생성됩니다. 일부 로케일은보다 더 많은 카테고리를 정의하는 것이 주 &lt;code&gt;one&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; . 예를 들어 fr-fr은 &lt;code&gt;few&lt;/code&gt; 및 &lt;code&gt;many&lt;/code&gt; 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="68fc3fa08dbab4451ff79de79c9fc1a49cba71b3" translate="yes" xml:space="preserve">
          <source>If one of the values is undefined, consider it &quot;greater than&quot; the other.</source>
          <target state="translated">값 중 하나가 정의되지 않은 경우 다른 값보다 &quot;더 큰&quot;것으로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="be847ed107cfee41deb9115ce6a8c35e338521f0" translate="yes" xml:space="preserve">
          <source>If one wants to modify a camelcased attribute (SVG elements have valid camelcased attributes), such as &lt;code&gt;viewBox&lt;/code&gt; on the &lt;code&gt;svg&lt;/code&gt; element, one can use underscores to denote that the attribute to bind to is naturally camelcased.</source>
          <target state="translated">하나 같은 (SVG 요소가 유효 낙타 표기법 속성이)가 낙타 표기법 특성을 수정하고자하는 경우 &lt;code&gt;viewBox&lt;/code&gt; 를 ON &lt;code&gt;svg&lt;/code&gt; 요소, 하나는 바인딩의 속성이 자연스럽게 낙타 표기법되는 것을 표시하기 위해 밑줄을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa3a550f7e49feb35b5c38e18a628e43579977d7" translate="yes" xml:space="preserve">
          <source>If our animation code class-based (meaning that something like &lt;code&gt;ngClass&lt;/code&gt;, &lt;code&gt;ngHide&lt;/code&gt; and &lt;code&gt;ngShow&lt;/code&gt; triggers it) then we can still define our animations inside of the same registered animation, however, the function input arguments are a bit different:</source>
          <target state="translated">우리의 애니메이션 코드 클래스 기반 경우 (같은 뭔가 의미 &lt;code&gt;ngClass&lt;/code&gt; , &lt;code&gt;ngHide&lt;/code&gt; 및 &lt;code&gt;ngShow&lt;/code&gt; 우리는 여전히 같은 등록 애니메이션의 내부에 우리의 애니메이션을 정의 할 수 있습니다 트리거를) 그러나, 함수 입력 인수는 비트 다릅니다 :</target>
        </trans-unit>
        <trans-unit id="3929b62e0e7741d149c634de5223054eef38f614" translate="yes" xml:space="preserve">
          <source>If provided, then enables/disables SCE application-wide.</source>
          <target state="translated">제공된 경우 SCE 응용 프로그램 전체를 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="420de9532a9310bd61b98d99b3e5431883df58a7" translate="yes" xml:space="preserve">
          <source>If provided, update the internal &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; flag.</source>
          <target state="translated">제공된 경우 내부 &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; 플래그를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6c236207f5e15b8cfb41e7366e363e30acf5b95" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt; skips model dirty checking, otherwise will invoke &lt;code&gt;fn&lt;/code&gt; within the &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$apply&lt;/a&gt; block.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정하면 모델 더티 검사를 건너 뛰고, 그렇지 않으면 &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$ apply&lt;/a&gt; 블록 내에서 &lt;code&gt;fn&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="35a5cf1a0eea8e136f5c4728cf9e80e86d58aa15" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt; skips model dirty checking, otherwise will invoke &lt;code&gt;fn&lt;/code&gt; within the &lt;a href=&quot;../type/%24rootscope.scope#%24apply.html&quot;&gt;$apply&lt;/a&gt; block.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정하면 모델 더티 검사를 건너 뛰고, 그렇지 않으면 &lt;a href=&quot;../type/%24rootscope.scope#%24apply.html&quot;&gt;$ apply&lt;/a&gt; 블록 내에서 &lt;code&gt;fn&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="6d79cbe97b0cba018fd80c72312c2caecd191843" translate="yes" xml:space="preserve">
          <source>If set to false AngularJS will not automatically trim the input.</source>
          <target state="translated">false로 설정하면 AngularJS가 입력을 자동으로 자르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99f750122c635a9c79ac25ba8a258a265ea9d70d" translate="yes" xml:space="preserve">
          <source>If set to false AngularJS will not automatically trim the input. This parameter is ignored for input[type=password] controls, which will never trim the input.</source>
          <target state="translated">false로 설정하면 AngularJS가 입력을 자동으로 자르지 않습니다. 이 매개 변수는 input [type = password] 컨트롤에 대해 무시되며 입력을 자르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d365bd222f8aac61ea4ce4cf5f583497a646e6c8" translate="yes" xml:space="preserve">
          <source>If set to true then the current &lt;code&gt;priority&lt;/code&gt; will be the last set of directives which will execute (any directives at the current priority will still execute as the order of execution on same &lt;code&gt;priority&lt;/code&gt; is undefined). Note that expressions and other directives used in the directive's template will also be excluded from execution.</source>
          <target state="translated">true로 설정하면 현재 &lt;code&gt;priority&lt;/code&gt; 는 실행될 마지막 지시문 세트가됩니다 (현재 우선 순위의 모든 지시문은 동일한 &lt;code&gt;priority&lt;/code&gt; 의 실행 순서 가 정의되지 않은 상태 로 계속 실행 됨 ). 지시문 템플릿에 사용 된 표현식 및 기타 지시문도 실행에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="8198e6aef6aaac2f45ebacc8a1aa2d4b63f0fc33" translate="yes" xml:space="preserve">
          <source>If set to true, the JSON output will contain newlines and whitespace. If set to an integer, the JSON output will contain that many spaces per indentation.</source>
          <target state="translated">true로 설정하면 JSON 출력에 줄 바꿈 및 공백이 포함됩니다. 정수로 설정하면 JSON 출력에 들여 쓰기 당 많은 공간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cd63bbd500f85b0aa9f3f57a50ef372022a6763d" translate="yes" xml:space="preserve">
          <source>If set, specifies a vertical scroll-offset. This is often useful when there are fixed positioned elements at the top of the page, such as navbars, headers etc.</source>
          <target state="translated">설정된 경우 세로 스크롤 오프셋을 지정합니다. 이 기능은 페이지 상단에 네비게이션 바, 헤더 등 고정 된 위치에있는 요소가있을 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fe6333e8f42c68100e28d8d911a3367f20054d75" translate="yes" xml:space="preserve">
          <source>If specified then new module is being created. If unspecified then the module is being retrieved for further configuration.</source>
          <target state="translated">지정된 경우 새 모듈이 작성됩니다. 지정되지 않은 경우 추가 구성을 위해 모듈을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="27aeb59cad0b804c6ef2d86a1dfa615624970c38" translate="yes" xml:space="preserve">
          <source>If that is the case, the compiler adds an interpolateDirective to the node and registers &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;watches&lt;/a&gt; on the computed interpolation function, which will update the corresponding text nodes or attribute values as part of the normal &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;digest&lt;/a&gt; cycle.</source>
          <target state="translated">이 경우 컴파일러는 interpolateDirective를 노드에 추가 하고 계산 된 보간 함수에 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;시계&lt;/a&gt; 를 등록 합니다.이 함수는 해당 텍스트 노드 또는 속성 값을 일반 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;다이제스트&lt;/a&gt; 주기의 일부로 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="06ebcf108a89a946fe69e686a9111125f0f020a4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is falsy then the element is removed from the DOM tree. If it is truthy a copy of the compiled element is added to the DOM tree.</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;식&lt;/a&gt; falsy입니다 다음 요소는 DOM 트리에서 제거됩니다. 사실이라면 컴파일 된 요소의 사본이 DOM 트리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="92018ed26fa3598f627e4578ebf49a3b9ed44b1b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is truthy, then special attribute &quot;open&quot; will be set on the element</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;식&lt;/a&gt; truthy이며, 다음 특별한 속성 &quot;개방&quot;이 요소에 설정됩니다</target>
        </trans-unit>
        <trans-unit id="431632c12958fee7c8e13e21d996c9067cd8b138" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is truthy, then special attribute &quot;readonly&quot; will be set on the element</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;표현은&lt;/a&gt; 다음 특별한 속성이 &quot;읽기 전용&quot;요소에 설정됩니다 truthy입니다</target>
        </trans-unit>
        <trans-unit id="705b7850ed3cc932f2a8560a14e97c372e2c1a26" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is truthy, then special attribute &quot;selected&quot; will be set on the element</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;식&lt;/a&gt; truthy이며, 다음 특별한 속성은 &quot;선택&quot;요소에 설정됩니다</target>
        </trans-unit>
        <trans-unit id="a2e2565ac63611a2ee4218e5debd4028869e44fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is truthy, then the &lt;code&gt;checked&lt;/code&gt; attribute will be set on the element</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;식&lt;/a&gt; truthy입니다 후 &lt;code&gt;checked&lt;/code&gt; 속성은 요소에 설정됩니다</target>
        </trans-unit>
        <trans-unit id="0fa6eb7b7fd73a6c228cab8613440b5f26fe154c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is truthy, then the &lt;code&gt;disabled&lt;/code&gt; attribute will be set on the element</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;식&lt;/a&gt; truthy이며, 다음 &lt;code&gt;disabled&lt;/code&gt; 속성은 요소에 설정됩니다</target>
        </trans-unit>
        <trans-unit id="c8f2e6672bb03dd7bddaac75918cc6f50c5be88c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is truthy/falsy then the element is hidden/shown respectively.</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;표현은&lt;/a&gt; truthy / falsy 다음 요소가 숨겨져 / 각각 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1328e9d07bc981d3a2f225632334634a909a47c7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; is truthy/falsy then the element is shown/hidden respectively.</source>
          <target state="translated">는 IF &lt;a href=&quot;../../../guide/expression&quot;&gt;표현은&lt;/a&gt; truthy / falsy 다음 요소는 각각 숨김 / 표시이다.</target>
        </trans-unit>
        <trans-unit id="57f738c91082e8b25cb1fa3c8475f9812310ab4e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Content-Type&lt;/code&gt; is &lt;code&gt;application/json&lt;/code&gt; or the response looks like JSON, deserialize it using a JSON parser.</source>
          <target state="translated">는 IF &lt;code&gt;Content-Type&lt;/code&gt; 있습니다 &lt;code&gt;application/json&lt;/code&gt; 또는 JSON과 같은 응답 외모가하는 JSON 파서를 사용하여 직렬화.</target>
        </trans-unit>
        <trans-unit id="569213aa4cfaa4bcb8cb504d5cc5158f580f2ef7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;data&lt;/code&gt; property of the request configuration object contains an object, serialize it into JSON format.</source>
          <target state="translated">요청 구성 객체 의 &lt;code&gt;data&lt;/code&gt; 속성에 객체가 포함 된 경우 JSON 형식으로 직렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="a575ef21797e38c6a9636004fb3da88ae0f427fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;name&lt;/code&gt; attribute is specified, the form controller is published onto the current scope under this name.</source>
          <target state="translated">경우] &lt;code&gt;name&lt;/code&gt; 속성이 지정 폼 컨트롤러이 이름으로 현재 범위에 게시된다.</target>
        </trans-unit>
        <trans-unit id="26b0e12a78f6677dac08ad73f6c6c9206d29a49b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ngAnimate&lt;/code&gt; module is active within the application then the &lt;code&gt;ngMessages&lt;/code&gt;, &lt;code&gt;ngMessage&lt;/code&gt; and &lt;code&gt;ngMessageExp&lt;/code&gt; directives will trigger animations whenever any messages are added and removed from the DOM by the &lt;code&gt;ngMessages&lt;/code&gt; directive.</source>
          <target state="translated">경우] &lt;code&gt;ngAnimate&lt;/code&gt; 의 모듈은 상기 애플리케이션 내에서 활성화 후 &lt;code&gt;ngMessages&lt;/code&gt; 는 , &lt;code&gt;ngMessage&lt;/code&gt; 및 &lt;code&gt;ngMessageExp&lt;/code&gt; 지시자는 메시지에 추가되고하여 DOM에서 제거 될 때마다 트리거 애니메이션 &lt;code&gt;ngMessages&lt;/code&gt; 의 지시자.</target>
        </trans-unit>
        <trans-unit id="7620b6d1e4671d235ceba2b3eb50bbc8af56dbac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;require&lt;/code&gt; property is an object and &lt;code&gt;bindToController&lt;/code&gt; is truthy, then the required controllers are bound to the controller using the keys of the &lt;code&gt;require&lt;/code&gt; property. This binding occurs after all the controllers have been constructed but before &lt;code&gt;$onInit&lt;/code&gt; is called. If the name of the required controller is the same as the local name (the key), the name can be omitted. For example, &lt;code&gt;{parentDir: '^^'}&lt;/code&gt; is equivalent to &lt;code&gt;{parentDir: '^^parentDir'}&lt;/code&gt;. See the &lt;a href=&quot;../provider/%24compileprovider#component.html&quot;&gt;&lt;code&gt;$compileProvider&lt;/code&gt;&lt;/a&gt; helper for an example of how this can be used. If no such required directive(s) can be found, or if the directive does not have a controller, then an error is raised (unless no link function is specified and the required controllers are not being bound to the directive controller, in which case error checking is skipped). The name can be prefixed with:</source>
          <target state="translated">(가) 경우 &lt;code&gt;require&lt;/code&gt; 속성이 객체이며, &lt;code&gt;bindToController&lt;/code&gt; 이 truthy이며, 다음 필요한 컨트롤러는이의 키를 사용하여 컨트롤러에 바인딩 &lt;code&gt;require&lt;/code&gt; 속성을. 이 바인딩은 모든 컨트롤러가 구성된 후 &lt;code&gt;$onInit&lt;/code&gt; 가 호출 되기 전에 발생합니다 . 필요한 컨트롤러 이름이 로컬 이름 (키)과 동일하면 이름을 생략 할 수 있습니다. 예를 들어 &lt;code&gt;{parentDir: '^^'}&lt;/code&gt; 은 &lt;code&gt;{parentDir: '^^parentDir'}&lt;/code&gt; . &lt;a href=&quot;../provider/%24compileprovider#component.html&quot;&gt; &lt;code&gt;$compileProvider&lt;/code&gt; &lt;/a&gt; 참조이것이 어떻게 사용될 수 있는지의 예를위한 도우미. 이러한 필수 지시문을 찾을 수 없거나 지시문에 제어기가없는 경우 링크 기능이 지정되지 않고 필수 제어기가 지시문 제어기에 바인드되지 않는 한 오류가 발생합니다. 오류 검사를 건너 뜁니다). 이름 앞에 접두사를 붙일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e9084553ff9f6768e27df6a51cf00d07607970ba" translate="yes" xml:space="preserve">
          <source>If the argument is a hash object containing an array of values, these values will be encoded as duplicate search parameters in the URL.</source>
          <target state="translated">인수가 값 배열을 포함하는 해시 객체 인 경우이 값은 URL에서 중복 검색 매개 변수로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb61a9e955126eaa26ea942a4627e94e63e44a6" translate="yes" xml:space="preserve">
          <source>If the compared values are of different types:</source>
          <target state="translated">비교 된 값이 다른 유형 인 경우 :</target>
        </trans-unit>
        <trans-unit id="a6ebb8e7acaaad05ba88ba630bbcf4bb474a27c9" translate="yes" xml:space="preserve">
          <source>If the compiler finds that an element matches a directive, then the directive is added to the list of directives that match the DOM element. A single element may match multiple directives.</source>
          <target state="translated">컴파일러가 요소가 지시문과 일치하는 것을 발견하면 지시문이 DOM 요소와 일치하는 지시문 목록에 추가됩니다. 단일 요소는 여러 지시문과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dba304c82bd0b93a1d184175d2e32a6154fed02c" translate="yes" xml:space="preserve">
          <source>If the controller has been attached using the &lt;code&gt;controller as&lt;/code&gt; syntax then the controller instance will be assigned to a property on the scope.</source>
          <target state="translated">&lt;code&gt;controller as&lt;/code&gt; 구문 으로 사용하여 컨트롤러를 연결 한 경우 컨트롤러 인스턴스는 범위의 속성에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="6cd88d003715e1438f37dc2797bc52968605194f" translate="yes" xml:space="preserve">
          <source>If the directive is using 'element' transclusion, the compiler will actually remove the directive's entire element from the DOM and replace it with a comment node. The compiler then inserts the directive's template &quot;after&quot; this comment node, as a sibling.</source>
          <target state="translated">지시문이 'element'transclusion을 사용하는 경우 컴파일러는 실제로 지시문의 전체 요소를 DOM에서 제거하고 주석 노드로 대체합니다. 그런 다음 컴파일러는이 주석 노드 &quot;이후&quot;지시문의 템플릿을 형제로 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ccc0a0551436812b070e6ede527ae76f73bef649" translate="yes" xml:space="preserve">
          <source>If the element selector is prefixed with a &lt;code&gt;?&lt;/code&gt; then that slot is optional.</source>
          <target state="translated">요소 선택기 앞에 접두사가 &lt;code&gt;?&lt;/code&gt; 그 슬롯은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="539951d39c2b051017250ec693df08f36d0a8f58" translate="yes" xml:space="preserve">
          <source>If the element with &lt;code&gt;ngRef&lt;/code&gt; is destroyed &lt;code&gt;null&lt;/code&gt; is assigned to the property.</source>
          <target state="translated">&lt;code&gt;ngRef&lt;/code&gt; 가 있는 요소 가 삭제 되면 속성에 &lt;code&gt;null&lt;/code&gt; 이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8c51b91039912156c6ef5160d6f7caa8d6f1e32c" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a RegExp object, then this is used directly.</source>
          <target state="translated">식이 RegExp 개체로 평가되면 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb5cd62dfec3bda2d681b5166adcc87bc454767" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a string, the string should be one or more space-delimited class names.</source>
          <target state="translated">표현식이 문자열로 평가되는 경우 문자열은 하나 이상의 공백으로 구분 된 클래스 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb3c8751b0c61a411cfd191d56c199c86cb9d8a9" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a string, then it will be converted to a RegExp after wrapping it in &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; characters. For instance, &lt;code&gt;&quot;abc&quot;&lt;/code&gt; will be converted to &lt;code&gt;new RegExp('^abc$')&lt;/code&gt;.</source>
          <target state="translated">표현식이 문자열로 평가되면 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 문자로 래핑 한 후 RegExp로 변환됩니다 . 예를 들어 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 는 &lt;code&gt;new RegExp('^abc$')&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0a90d5734dbd86cb9e55270bd3a9ec2a471d3da2" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to an array, each element of the array should either be a string as in type 1 or an object as in type 2. This means that you can mix strings and objects together in an array to give you more control over what CSS classes appear. See the code below for an example of this.</source>
          <target state="translated">표현식이 배열로 평가되는 경우 배열의 각 요소는 유형 1과 같은 문자열이거나 유형 2와 같은 객체 여야합니다. 이는 문자열과 객체를 함께 배열로 혼합하여 무엇을 더 잘 제어 할 수 있음을 의미합니다. CSS 클래스가 나타납니다. 이에 대한 예제는 아래 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f28d2244e2fc42662b32132ed29fd1499d1d52b" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to an object, then for each key-value pair of the object with a truthy value the corresponding key is used as a class name.</source>
          <target state="translated">표현식이 객체로 평가되면 정확한 값을 가진 객체의 각 키-값 쌍에 대해 해당 키가 클래스 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d90a6cf7f68c8935fa77929bee3b2d26568ebc77" translate="yes" xml:space="preserve">
          <source>If the expression is truthy, then the &lt;code&gt;checked&lt;/code&gt; attribute will be set on the element. &lt;strong&gt;Note&lt;/strong&gt; : &lt;code&gt;ngChecked&lt;/code&gt; should not be used alongside &lt;code&gt;ngModel&lt;/code&gt;. Checkout &lt;a href=&quot;../directive/ngchecked&quot;&gt;ngChecked&lt;/a&gt; for usage.</source>
          <target state="translated">표현식이 진실이면 &lt;code&gt;checked&lt;/code&gt; 속성이 요소에 설정됩니다. &lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;ngChecked&lt;/code&gt; 는 &lt;code&gt;ngModel&lt;/code&gt; 과 함께 사용해서는 안됩니다 . 체크 아웃 &lt;a href=&quot;../directive/ngchecked&quot;&gt;ngChecked&lt;/a&gt; 사용을 위해.</target>
        </trans-unit>
        <trans-unit id="4f8a5c1d790a45cf8480b55c2ec6d0e8c83e21ad" translate="yes" xml:space="preserve">
          <source>If the expression will not change once set, it is a candidate for one-time binding. Here are three example cases.</source>
          <target state="translated">일단 설정된식이 변경되지 않으면 일회성 바인딩의 후보입니다. 다음은 세 가지 사례입니다.</target>
        </trans-unit>
        <trans-unit id="8a619d19d7445d7e347bec6f9960436c9602b51f" translate="yes" xml:space="preserve">
          <source>If the first argument was a string, a factory function for the filter to be registered.</source>
          <target state="translated">첫 번째 인수가 문자열 인 경우 필터를 등록 할 팩토리 함수입니다.</target>
        </trans-unit>
        <trans-unit id="361c8831315e17339674f0ae2feca36f02b8ac8a" translate="yes" xml:space="preserve">
          <source>If the function throws an error or the returned promise gets rejected, no further processing will take place and the &lt;a href=&quot;../service/%24route#%24routeChangeError.html&quot;&gt;$routeChangeError&lt;/a&gt; event will be fired.</source>
          <target state="translated">함수가 오류를 발생 시키거나 리턴 된 약속이 거부되면 추가 처리가 수행되지 않고 &lt;a href=&quot;../service/%24route#%24routeChangeError.html&quot;&gt;$ routeChangeError&lt;/a&gt; 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="801344aef470ca55925f85d5fc988659687084e2" translate="yes" xml:space="preserve">
          <source>If the horizontal distance is greater, this is a swipe and &lt;code&gt;move&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; events follow.</source>
          <target state="translated">수평 거리가 더 크면 스 와이프하고 &lt;code&gt;move&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 이벤트가 이어집니다.</target>
        </trans-unit>
        <trans-unit id="a956873d372528560c2d21f9517980780e587b81" translate="yes" xml:space="preserve">
          <source>If the input is null or undefined, it will just be returned. If the input is infinite (Infinity or -Infinity), the Infinity symbol '&amp;infin;' or '-&amp;infin;' is returned, respectively. If the input is not a number an empty string is returned.</source>
          <target state="translated">입력이 null이거나 정의되지 않은 경우 반환됩니다. 입력이 무한대 (무한대 또는-무한대)이면 무한대 기호 '&amp;infin;'또는 '-&amp;infin;'이 각각 반환됩니다. 입력이 숫자가 아닌 경우 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c59983d990ab2fd7484efe71b9e5bc2142d0391" translate="yes" xml:space="preserve">
          <source>If the interpolated value is not a &lt;code&gt;String&lt;/code&gt;, it is computed as follows:</source>
          <target state="translated">보간 된 값이 &lt;code&gt;String&lt;/code&gt; 이 아닌 경우 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5201fb064f6147470f00f21dea4bab9f47241e2f" translate="yes" xml:space="preserve">
          <source>If the map of attributes contains a value for &lt;code&gt;target&lt;/code&gt;, it overrides the value of the target parameter.</source>
          <target state="translated">속성 맵에 &lt;code&gt;target&lt;/code&gt; 값이 포함 된 경우 대상 매개 변수 값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd620b139e2c7c9068fe0980b84af6bdfabe8c0" translate="yes" xml:space="preserve">
          <source>If the ngMessages renders no inner ngMessage directive (i.e. when none of the truthy keys are matched by a defined message), then it will render a default message using the &lt;a href=&quot;ngmessages/directive/ngmessagedefault&quot;&gt;&lt;code&gt;ngMessageDefault&lt;/code&gt;&lt;/a&gt; directive. Note that matched messages will always take precedence over unmatched messages. That means the default message will not be displayed when another message is matched. This is also true for &lt;code&gt;ng-messages-multiple&lt;/code&gt;.</source>
          <target state="translated">ngMessages가 내부 ngMessage 지시문을 렌더링하지 않으면 (즉, 정의 된 메시지와 일치하는 키가없는 경우) &lt;a href=&quot;ngmessages/directive/ngmessagedefault&quot;&gt; &lt;code&gt;ngMessageDefault&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 기본 메시지를 렌더링합니다 . 일치하는 메시지는 항상 일치하지 않는 메시지보다 우선합니다. 즉, 다른 메시지가 일치하면 기본 메시지가 표시되지 않습니다. &lt;code&gt;ng-messages-multiple&lt;/code&gt; 의 경우에도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="b16925af72a4fed089f605a5771aa7712c7c7fd8" translate="yes" xml:space="preserve">
          <source>If the object has a &lt;code&gt;valueOf()&lt;/code&gt; method that returns a primitive, its return value will be used instead.</source>
          <target state="translated">객체 에 프리미티브를 리턴 하는 &lt;code&gt;valueOf()&lt;/code&gt; 메소드가있는 경우 해당 리턴 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1a13de46e7e46a68d029c7a50e792f652a12e1" translate="yes" xml:space="preserve">
          <source>If the object has a custom &lt;code&gt;toString()&lt;/code&gt; method (i.e. not the one inherited from &lt;code&gt;Object&lt;/code&gt;) that returns a primitive, its return value will be used instead.</source>
          <target state="translated">객체 에 프리미티브를 리턴 하는 사용자 정의 &lt;code&gt;toString()&lt;/code&gt; 메소드 (예 : &lt;code&gt;Object&lt;/code&gt; 에서 상속 된 메소드가 아님)가있는 경우 해당 리턴 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b4070dda3da26b7789461241d4d6a2028444a334" translate="yes" xml:space="preserve">
          <source>If the option is set to &lt;code&gt;false&lt;/code&gt; and the URL in the browser changes, but the new URL maps to the same route, then a &lt;code&gt;$routeUpdate&lt;/code&gt; event is broadcasted on the root scope (without reloading the route).</source>
          <target state="translated">옵션이 &lt;code&gt;false&lt;/code&gt; 로 설정되고 브라우저의 URL이 변경되었지만 새 URL이 동일한 경로에 매핑되면 &lt;code&gt;$routeUpdate&lt;/code&gt; 이벤트가 루트 범위에서 경로를 다시로드하지 않고 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="4f675d1330a06aa7e73c29dee26c8f270d3431c5" translate="yes" xml:space="preserve">
          <source>If the option is set to &lt;code&gt;false&lt;/code&gt; and the URL in the browser changes, then a &lt;code&gt;$routeUpdate&lt;/code&gt; event is broadcasted on the root scope (without reloading the route).</source>
          <target state="translated">옵션이로 설정된 경우 &lt;code&gt;false&lt;/code&gt; 브라우저의 URL이 변경되면 &lt;code&gt;$routeUpdate&lt;/code&gt; 이벤트가 루트 범위에서 라우트를 다시로드하지 않고 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="667711c7d75a7f70cf4b59c7711f0e8c0ddf7c8c" translate="yes" xml:space="preserve">
          <source>If the option is set to &lt;code&gt;true&lt;/code&gt;, then the particular route can be matched without being case sensitive</source>
          <target state="translated">옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정되면 대소 문자를 구분하지 않고 특정 경로를 일치시킬 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2fa05f4335e8c37af4609e2cbfa503116352d3ed" translate="yes" xml:space="preserve">
          <source>If the parameter value is prefixed with &lt;code&gt;@&lt;/code&gt;, then the value for that parameter will be extracted from the corresponding property on the &lt;code&gt;data&lt;/code&gt; object (provided when calling actions with a request body). For example, if the &lt;code&gt;defaultParam&lt;/code&gt; object is &lt;code&gt;{someParam: '@someProp'}&lt;/code&gt; then the value of &lt;code&gt;someParam&lt;/code&gt; will be &lt;code&gt;data.someProp&lt;/code&gt;. Note that the parameter will be ignored, when calling a &quot;GET&quot; action method (i.e. an action method that does not accept a request body).</source>
          <target state="translated">매개 변수 값 앞에 &lt;code&gt;@&lt;/code&gt; 가 붙으면 해당 매개 변수의 값이 &lt;code&gt;data&lt;/code&gt; 오브젝트 의 해당 특성에서 추출됩니다 (요청 본문으로 조치를 호출 할 때 제공됨). 예를 들어 &lt;code&gt;defaultParam&lt;/code&gt; 객체가 &lt;code&gt;{someParam: '@someProp'}&lt;/code&gt; 이면 &lt;code&gt;someParam&lt;/code&gt; 의 값 것이다 &lt;code&gt;data.someProp&lt;/code&gt; . &quot;GET&quot;조치 메소드 (예 : 요청 본문을 승인하지 않는 조치 메소드)를 호출 할 때 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="748507705e8b73f2f2de5777914e00ac0057102d" translate="yes" xml:space="preserve">
          <source>If the passed parameter had been returned by a prior call to &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt;, returns the value that had been passed to &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전달 된 매개 변수가 &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출에 의해 리턴 된 경우 전달 된 값을 리턴합니다.&lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34bdf8299f97f8ef59f74107df302ae6779e17bc" translate="yes" xml:space="preserve">
          <source>If the passed parameter is not a value that had been returned by &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt;, it must be returned as-is.</source>
          <target state="translated">전달 된 매개 변수가 &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; 가 리턴 한 값이 아닌 경우 그대로 리턴 해야합니다.</target>
        </trans-unit>
        <trans-unit id="eba391f315a45facb41d9100a63641fbf14c5c21" translate="yes" xml:space="preserve">
          <source>If the provider is:</source>
          <target state="translated">제공자가 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="8fb90fddde351c69618ca1d22a26145a9faddc79" translate="yes" xml:space="preserve">
          <source>If the service has been declared multiple times, a decorator will decorate the service that has been declared last:</source>
          <target state="translated">서비스가 여러 번 선언 된 경우 데코레이터는 마지막으로 선언 된 서비스를 장식합니다.</target>
        </trans-unit>
        <trans-unit id="073e1a6fd73d36907ed730dd5649eee40ed506d0" translate="yes" xml:space="preserve">
          <source>If the transcluded content is not empty (i.e. contains one or more DOM nodes, including whitespace text nodes), any existing content of this element will be removed before the transcluded content is inserted. If the transcluded content is empty (or only whitespace), the existing content is left intact. This lets you provide fallback content in the case that no transcluded content is provided.</source>
          <target state="translated">포함 된 컨텐츠가 비어 있지 않은 경우 (즉, 공백 텍스트 노드를 포함하여 하나 이상의 DOM 노드가 포함 된 경우)이 요소의 기존 컨텐츠는 포함 된 컨텐츠를 삽입하기 전에 제거됩니다. 포함 된 내용이 비어 있거나 공백 만 있으면 기존 내용이 그대로 유지됩니다. 이를 통해 변환 된 컨텐츠가 제공되지 않는 경우 대체 컨텐츠를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9ff46f623d6f00d105132061348b4f635bc911c" translate="yes" xml:space="preserve">
          <source>If the value is a RegExp literal, e.g. &lt;code&gt;ngPattern=&quot;/^\d+$/&quot;&lt;/code&gt;, it is used directly.</source>
          <target state="translated">값이 RegExp 리터럴 인 경우 (예 : &lt;code&gt;ngPattern=&quot;/^\d+$/&quot;&lt;/code&gt; ) 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="691fa80c49c3faa2138cb82838f938dea193adbf" translate="yes" xml:space="preserve">
          <source>If the value is empty, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;on&lt;/code&gt;, then child animations are allowed. If the value is &lt;code&gt;false&lt;/code&gt;, child animations are not allowed.</source>
          <target state="translated">값이 비어 있거나 &lt;code&gt;true&lt;/code&gt; 이거나 &lt;code&gt;on&lt;/code&gt; 있으면 하위 애니메이션이 허용됩니다. 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 하위 애니메이션이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34f1578079504e9d3dc1f5f790637a829842cb7f" translate="yes" xml:space="preserve">
          <source>If the vertical distance is greater, this is a scroll, and we let the browser take over. A &lt;code&gt;cancel&lt;/code&gt; event is sent.</source>
          <target state="translated">수직 거리가 더 크면 이것은 스크롤이며 브라우저가 대신합니다. A는 &lt;code&gt;cancel&lt;/code&gt; 이벤트가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2d6b619ad1758255d1b68794d39d43746c76cfac" translate="yes" xml:space="preserve">
          <source>If the viewValue of &lt;code&gt;ngModel&lt;/code&gt; does not match any of the options, then the control will automatically add an &quot;unknown&quot; option, which it then removes when the mismatch is resolved.</source>
          <target state="translated">ngModel의 &lt;code&gt;ngModel&lt;/code&gt; 가 옵션과 일치하지 않으면 컨트롤은 &quot;알 수 없음&quot;옵션을 자동으로 추가하고 불일치가 해결되면 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9a9455b461bd0ed851b0a2e20ee353139e41bf20" translate="yes" xml:space="preserve">
          <source>If there are no pending requests to flush when the method is called, an exception is thrown (as this is typically a sign of programming error).</source>
          <target state="translated">메소드가 호출 될 때 비우기 위해 보류중인 요청이 없으면 예외가 발생합니다 (일반적으로 프로그래밍 오류의 표시이므로).</target>
        </trans-unit>
        <trans-unit id="060ea5570e9b3727e1af7089f2eeb073f6d7b905" translate="yes" xml:space="preserve">
          <source>If those attributes are added to an element, they will be applied to all the child elements and controls that inherit from it unless they are overridden.</source>
          <target state="translated">이러한 특성이 요소에 추가되면 재정의되지 않는 한 해당 특성을 상속하는 모든 자식 요소 및 컨트롤에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c1cfe0ec558e25c8faaad7729d14ba017c6c40" translate="yes" xml:space="preserve">
          <source>If true, then the scope does not prototypically inherit from the parent scope. The scope is isolated, as it can not see parent scope properties. When creating widgets, it is useful for the widget to not accidentally read parent state.</source>
          <target state="translated">true이면 해당 범위는 부모 범위에서 프로토 타입으로 상속되지 않습니다. 부모 범위 속성을 볼 수 없으므로 범위가 격리됩니다. 위젯을 작성할 때 위젯이 실수로 상위 상태를 읽지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1a1eda02417fef4dacf554c54592d8c5e31f4371" translate="yes" xml:space="preserve">
          <source>If true, when requests are loaded, they will schedule a deferred &quot;apply&quot; on the next tick, giving time for subsequent requests in a roughly ~10ms window to load and share the same digest cycle.</source>
          <target state="translated">true이면 요청이로드 될 때 다음 틱에 지연된 &quot;적용&quot;을 예약하여 대략 ~ 10ms 창에서 후속 요청에 대해 동일한 다이제스트주기를로드하고 공유 할 시간을줍니다.</target>
        </trans-unit>
        <trans-unit id="6f15cbe99032410d5987084ecc33f306be94d6db" translate="yes" xml:space="preserve">
          <source>If two directives suspend a scope, then one of them resumes the scope, the scope will no longer be suspended. This could result in the other directive believing a scope to be suspended when it is not.</source>
          <target state="translated">두 지시문이 범위를 일시 중단하면 그 중 하나가 범위를 재개하면 해당 범위가 더 이상 일시 중단되지 않습니다. 이로 인해 다른 지시어는 스코프가 일시 중단 될 때 믿어지지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a2ab806aea83a4f315e6a0440d6fa1d95f6028" translate="yes" xml:space="preserve">
          <source>If we change the above to &lt;code&gt;{{ 1000 | currency:&quot;USD$&quot;}}&lt;/code&gt;, AngularJS will always show a balance of &lt;code&gt;USD$1000&lt;/code&gt; regardless of locale.</source>
          <target state="translated">위의 &lt;code&gt;{{ 1000 | currency:&quot;USD$&quot;}}&lt;/code&gt; , AngularJS는 로캘에 관계없이 항상 &lt;code&gt;USD$1000&lt;/code&gt; 의 잔액을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="8182958d3c9e9a8a4566ae6109e758f0624b87f7" translate="yes" xml:space="preserve">
          <source>If you are creating a reusable component then you should be careful when using &lt;code&gt;&quot;*&quot;: &quot;$inherit&quot;&lt;/code&gt; since you may inadvertently inherit a setting in the future that changes the behavior of your component.</source>
          <target state="translated">재사용 가능한 컴포넌트를 작성하는 경우 &lt;code&gt;&quot;*&quot;: &quot;$inherit&quot;&lt;/code&gt; 를 사용할 때 나중에 컴포넌트의 동작을 변경하는 설정을 실수로 상속 할 수 있으므로주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6824fd64e915a35e23d50509c5e4bba8e51856fc" translate="yes" xml:space="preserve">
          <source>If you are familiar with &lt;code&gt;ngInclude&lt;/code&gt;, &lt;code&gt;templateUrl&lt;/code&gt; works just like it. Here's the same example using &lt;code&gt;templateUrl&lt;/code&gt; instead:</source>
          <target state="translated">당신이 잘 알고있는 경우 &lt;code&gt;ngInclude&lt;/code&gt; , &lt;code&gt;templateUrl&lt;/code&gt; 는 그냥처럼 작동합니다. 다음은 &lt;code&gt;templateUrl&lt;/code&gt; 을 대신 사용하는 동일한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="77b4c3f9eed7868de1adc6770793e45e91738ff2" translate="yes" xml:space="preserve">
          <source>If you are generating your JavaScript from some other templating engine (not recommended, e.g. in issue &lt;a href=&quot;https://github.com/angular/angular.js/issues/4006&quot;&gt;#4006&lt;/a&gt;), remember to escape your regular expression (and be aware that you might need more than one level of escaping depending on your templating engine and the way you interpolated the value.) Do make use of your platform's escaping mechanism as it might be good enough before coding your own. E.g. Ruby has &lt;a href=&quot;http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape&quot;&gt;Regexp.escape(str)&lt;/a&gt; and Python has &lt;a href=&quot;http://docs.python.org/library/re.html#re.escape&quot;&gt;re.escape&lt;/a&gt;. Javascript lacks a similar built in function for escaping. Take a look at Google Closure library's &lt;a href=&quot;http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962&quot;&gt;goog.string.regExpEscape(s)&lt;/a&gt;.</source>
          <target state="translated">다른 템플릿 엔진에서 JavaScript를 생성하는 경우 (예 : 문제 &lt;a href=&quot;https://github.com/angular/angular.js/issues/4006&quot;&gt;# 4006&lt;/a&gt; 에서 권장되지 않음 ) 정규 표현식을 피해야합니다 (템플릿 엔진 및 방법에 따라 둘 이상의 이스케이프 처리가 필요할 수 있음을 기억하십시오) 값을 보간했습니다.) 자신의 코드를 작성하기 전에 플랫폼의 이스케이프 메커니즘을 충분히 활용하십시오. 예를 들어 Ruby에는 &lt;a href=&quot;http://www.ruby-doc.org/core-2.0.0/Regexp.html#method-c-escape&quot;&gt;Regexp.escape (str)가&lt;/a&gt; 있고 Python에는 &lt;a href=&quot;http://docs.python.org/library/re.html#re.escape&quot;&gt;re.escape가&lt;/a&gt; 있습니다. Javascript에는 이스케이프를위한 유사한 내장 기능이 없습니다. Google Closure 라이브러리의 &lt;a href=&quot;http://docs.closure-library.googlecode.com/git/closure_goog_string_string.js.source.html#line962&quot;&gt;goog.string.regExpEscape (s)를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="a29cc079c5381669c7a3a9da4c7b33b8f798e95e" translate="yes" xml:space="preserve">
          <source>If you are hitting any of these limitations, the recommended workaround is to convert your object into an array that is sorted into the order that you prefer before providing it to &lt;code&gt;ngRepeat&lt;/code&gt;. You could do this with a filter such as &lt;a href=&quot;http://ngmodules.org/modules/angular-toArrayFilter&quot;&gt;toArrayFilter&lt;/a&gt; or implement a &lt;code&gt;$watch&lt;/code&gt; on the object yourself.</source>
          <target state="translated">이러한 제한 사항 중 하나라도 해결하려는 경우 권장되는 해결 방법은 객체를 &lt;code&gt;ngRepeat&lt;/code&gt; 에 제공하기 전에 원하는 순서로 정렬 된 배열로 변환하는 것 입니다. &lt;a href=&quot;http://ngmodules.org/modules/angular-toArrayFilter&quot;&gt;toArrayFilter&lt;/a&gt; 와 같은 필터를 사용 하거나 객체에 &lt;code&gt;$watch&lt;/code&gt; 를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dd2e2dc29df4f42bc993e77fee00d09330237a" translate="yes" xml:space="preserve">
          <source>If you are just using &lt;a href=&quot;../directive/ngtransclude&quot;&gt;&lt;code&gt;ngTransclude&lt;/code&gt;&lt;/a&gt; then you don't need to worry about this function, since ngTransclude will deal with it for us.</source>
          <target state="translated">&lt;a href=&quot;../directive/ngtransclude&quot;&gt; &lt;code&gt;ngTransclude&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 ngTransclude가이를 처리하므로이 기능에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a45454eb838a97c3b99832ac7c22cb8a9f728800" translate="yes" xml:space="preserve">
          <source>If you are not asking the linking function to clone the template, create the DOM element(s) before you send them to the compiler and keep this reference around.</source>
          <target state="translated">링크 함수에 템플릿 복제를 요청하지 않는 경우 DOM 요소를 작성하여 컴파일러에 보내기 전에이 참조를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="05854a1d0c3c61abd34a6185ba88099223eaf1f6" translate="yes" xml:space="preserve">
          <source>If you are setting the option value with the option's &lt;code&gt;value&lt;/code&gt; attribute, or textContent, the value will always be a &lt;code&gt;string&lt;/code&gt; which means that the model value must also be a string. Otherwise the &lt;code&gt;select&lt;/code&gt; directive cannot match them correctly.</source>
          <target state="translated">옵션의 &lt;code&gt;value&lt;/code&gt; 속성 또는 textContent를 사용하여 옵션 값을 설정하는 경우 값은 항상 &lt;code&gt;string&lt;/code&gt; 이되므로 모델 값도 문자열이어야합니다. 그렇지 않으면 &lt;code&gt;select&lt;/code&gt; 지시문이 올바르게 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8616bb7e831e9c34f5ed1c22db4f4d693acd3c1c" translate="yes" xml:space="preserve">
          <source>If you are sure that your project only uses element and attribute directives, and you are not using any 3rd party library that uses directives inside element classes or html comments, you can disable the compilation of directives on element classes and comments for the whole application. This results in a compilation performance gain, as the compiler does not have to check comments and element classes looking for directives.</source>
          <target state="translated">프로젝트에서 요소 및 속성 지시문 만 사용하고 요소 클래스 또는 HTML 주석 내부에서 지시문을 사용하는 타사 라이브러리를 사용하지 않는 경우 전체 애플리케이션의 요소 클래스 및 주석에 대한 지시문 컴파일을 비활성화 할 수 있습니다. 컴파일러는 지시문을 찾기 위해 주석과 요소 클래스를 확인할 필요가 없으므로 컴파일 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="7f18d87980792564416a9131237779e5b2ab35b5" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;$element&lt;/code&gt; or &lt;code&gt;$attrs&lt;/code&gt; in the controller, make sure to provide them as &lt;code&gt;locals&lt;/code&gt;. The &lt;code&gt;$element&lt;/code&gt; must be a jqLite-wrapped DOM element, and &lt;code&gt;$attrs&lt;/code&gt; should be an object that has all properties / functions that you are using in the controller. If this is getting too complex, you should compile the component instead and access the component's controller via the &lt;a href=&quot;../../ng/function/angular.element#methods.html&quot;&gt;&lt;code&gt;controller&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;$element&lt;/code&gt; 또는 &lt;code&gt;$attrs&lt;/code&gt; 컨트롤러에를로를 제공 할 수 있는지 확인 &lt;code&gt;locals&lt;/code&gt; . &lt;code&gt;$element&lt;/code&gt; jqLite 감싸 DOM 요소이어야하며, &lt;code&gt;$attrs&lt;/code&gt; 당신이 컨트롤러에 사용되는 모든 속성 / 기능을 가진 개체 수 있어야합니다. 이것이 너무 복잡해지면 대신 구성 요소를 컴파일하고 &lt;a href=&quot;../../ng/function/angular.element#methods.html&quot;&gt; &lt;code&gt;controller&lt;/code&gt; &lt;/a&gt; 기능을 통해 구성 요소의 컨트롤러에 액세스해야 합니다.</target>
        </trans-unit>
        <trans-unit id="62ca6a2bc0e076ff23829bf151f3637b4d8d77f5" translate="yes" xml:space="preserve">
          <source>If you are using a url with a suffix, just add the suffix, like this: &lt;code&gt;$resource('http://example.com/resource.json')&lt;/code&gt; or &lt;code&gt;$resource('http://example.com/:id.json')&lt;/code&gt; or even &lt;code&gt;$resource('http://example.com/resource/:resource_id.:format')&lt;/code&gt; If the parameter before the suffix is empty, :resource_id in this case, then the &lt;code&gt;/.&lt;/code&gt; will be collapsed down to a single &lt;code&gt;.&lt;/code&gt;. If you need this sequence to appear and not collapse then you can escape it with &lt;code&gt;/\.&lt;/code&gt;.</source>
          <target state="translated">접미사와 함께 URL을 사용하는 경우 &lt;code&gt;$resource('http://example.com/resource.json')&lt;/code&gt; 또는 &lt;code&gt;$resource('http://example.com/:id.json')&lt;/code&gt; 와 같이 접미사를 추가하십시오 . .json ') 또는 &lt;code&gt;$resource('http://example.com/resource/:resource_id.:format')&lt;/code&gt; 접미사 앞의 매개 변수가 비어 있으면이 경우 : resource_id이고 &lt;code&gt;/.&lt;/code&gt; 단일로 축소됩니다 &lt;code&gt;.&lt;/code&gt; . 이 시퀀스가 ​​나타나고 축소되지 않도록하려면 &lt;code&gt;/\.&lt;/code&gt; 하여 이스케이프 처리 할 수 ​​있습니다 . .</target>
        </trans-unit>
        <trans-unit id="8175243d5dd6cd4ad446324c5b107b61705e0849" translate="yes" xml:space="preserve">
          <source>If you are writing your controllers as classes you have easier access to the properties and methods, which will appear on the scope, from inside the controller code.</source>
          <target state="translated">컨트롤러를 클래스로 작성하는 경우 컨트롤러 코드 내부에서 범위에 표시되는 속성 및 메서드에 더 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="579b0bfd8c97d214c17252551f1e2da79f4821e2" translate="yes" xml:space="preserve">
          <source>If you choose to use the old style directive syntax &lt;code&gt;ng:&lt;/code&gt; then include xml-namespace in &lt;code&gt;html&lt;/code&gt; when running the page in the XHTML mode. (This is here for historical reasons, and we no longer recommend use of &lt;code&gt;ng:&lt;/code&gt;.)</source>
          <target state="translated">이전 스타일 지시문 구문 &lt;code&gt;ng:&lt;/code&gt; 를 사용하도록 선택한 경우 XHTML 모드에서 페이지를 실행할 때 xml-namespace를 &lt;code&gt;html&lt;/code&gt; 에 포함 하십시오. (이것은 역사적인 이유로 여기에 있으며 더 이상 &lt;code&gt;ng:&lt;/code&gt; 사용하지 않는 것이 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="95ac9993d00393a11c4032cc3f53f03837212f99" translate="yes" xml:space="preserve">
          <source>If you do have CSS transitions / animations defined for the animation events, make sure they have a higher priority than any styles that are not related to &lt;code&gt;ngAnimate&lt;/code&gt;.</source>
          <target state="translated">애니메이션 이벤트에 대해 CSS 전환 / 애니메이션이 정의 된 경우 &lt;code&gt;ngAnimate&lt;/code&gt; 와 관련이없는 스타일보다 우선 순위가 더 높은지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e60f87bc71cf08bbc7d9b1d676646a6c5716f48c" translate="yes" xml:space="preserve">
          <source>If you do not provide &lt;code&gt;ngCsp&lt;/code&gt; then AngularJS tries to autodetect if CSP is blocking dynamic code creation from strings (e.g., &lt;code&gt;unsafe-eval&lt;/code&gt; not specified in CSP header) and automatically deactivates this feature in the &lt;a href=&quot;../service/%24parse&quot;&gt;&lt;code&gt;$parse&lt;/code&gt;&lt;/a&gt; service. This autodetection, however, triggers a CSP error to be logged in the console:</source>
          <target state="translated">&lt;code&gt;ngCsp&lt;/code&gt; 를 제공하지 않으면 AngularJS는 CSP가 문자열 (예 : CSP 헤더에 &lt;code&gt;unsafe-eval&lt;/code&gt; 을 지정하지 않음) 에서 동적 코드 생성을 차단하는지 자동 감지하려고 시도 하고 &lt;a href=&quot;../service/%24parse&quot;&gt; &lt;code&gt;$parse&lt;/code&gt; &lt;/a&gt; 서비스 에서이 기능을 자동으로 비활성화 합니다. 그러나이 자동 감지는 콘솔에 CSP 오류가 기록되도록 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="090e07725aef98ccf8c178d8354126ccc84bb075" translate="yes" xml:space="preserve">
          <source>If you do want your animations to play when the app bootstraps, you can enable animations globally in your main module's &lt;a href=&quot;../api/ng/type/angular.module#run.html&quot;&gt;run&lt;/a&gt; function:</source>
          <target state="translated">앱이 부트 스트랩 할 때 애니메이션을 재생하려면 기본 모듈의 &lt;a href=&quot;../api/ng/type/angular.module#run.html&quot;&gt;실행&lt;/a&gt; 기능 에서 애니메이션을 전체적으로 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c54acd5a1055cc95784ce1576ee1d24938a564f3" translate="yes" xml:space="preserve">
          <source>If you have an input that uses &lt;code&gt;ng-model-options&lt;/code&gt; to set up debounced updates or updates that depend on special events such as &lt;code&gt;blur&lt;/code&gt;, there can be a period when the &lt;code&gt;$viewValue&lt;/code&gt; is out of sync with the ngModel's &lt;code&gt;$modelValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ng-model-options&lt;/code&gt; 를 사용하여 &lt;code&gt;blur&lt;/code&gt; 와 같은 특수 이벤트에 의존하는 디 바운스 된 업데이트 또는 업데이트를 설정 하는 입력이있는 경우 &lt;code&gt;$viewValue&lt;/code&gt; 가 ngModel의 &lt;code&gt;$modelValue&lt;/code&gt; 와 동기화되지 않는 기간이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f76a6558a7d25629fa9ecb3f235d6240ed436b29" translate="yes" xml:space="preserve">
          <source>If you have awesome AngularJS resources that belong on that page, please tell us about them on &lt;a href=&quot;https://plus.google.com/u/0/+AngularJS&quot;&gt;Google+&lt;/a&gt; or &lt;a href=&quot;https://twitter.com/angularjs&quot;&gt;Twitter&lt;/a&gt;.</source>
          <target state="translated">해당 페이지에 속하는 멋진 AngularJS 리소스가 있다면 &lt;a href=&quot;https://plus.google.com/u/0/+AngularJS&quot;&gt;Google+&lt;/a&gt; 또는 &lt;a href=&quot;https://twitter.com/angularjs&quot;&gt;Twitter&lt;/a&gt; 에서 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="cc605f97c4d62e22545f2f1d9d3a0d4805d17f68" translate="yes" xml:space="preserve">
          <source>If you have very specific requirements about the way items are sorted, you can pass your own comparator function. For example, you might need to compare some strings in a locale-sensitive way. (When specifying a custom comparator, you also need to pass a value for the &lt;code&gt;reverse&lt;/code&gt; argument - passing &lt;code&gt;false&lt;/code&gt; retains the default sorting order, i.e. ascending.)</source>
          <target state="translated">항목을 정렬하는 방법에 대한 특정 요구 사항이있는 경우 고유 한 비교기 함수를 전달할 수 있습니다. 예를 들어, 일부 문자열을 로케일 구분 방식으로 비교해야 할 수 있습니다. (커스텀 비교기를 지정할 때 &lt;code&gt;reverse&lt;/code&gt; 인수 값도 전달해야합니다. &lt;code&gt;false&lt;/code&gt; 를 전달 하면 기본 정렬 순서가 유지됩니다 (예 : 오름차순).</target>
        </trans-unit>
        <trans-unit id="83df81bb997c0451e68609a38aa5876c44d17de2" translate="yes" xml:space="preserve">
          <source>If you however do need to write a stateful filter, you have to mark the filter as &lt;code&gt;$stateful&lt;/code&gt;, which means that it will be executed one or more times during the each &lt;code&gt;$digest&lt;/code&gt; cycle.</source>
          <target state="translated">그러나 상태 저장 필터를 작성해야하는 경우 필터를 &lt;code&gt;$stateful&lt;/code&gt; 로 표시해야합니다. 즉, 각 &lt;code&gt;$digest&lt;/code&gt; 주기 동안 필터 가 한 번 이상 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="207d49b848c74ffcb21da0b752a994a1ebcb5c10" translate="yes" xml:space="preserve">
          <source>If you intend to implement CSP with these rules then you must tell AngularJS not to use these features.</source>
          <target state="translated">이러한 규칙을 사용하여 CSP를 구현하려는 경우 AngularJS에 이러한 기능을 사용하지 않도록 지시해야합니다.</target>
        </trans-unit>
        <trans-unit id="870c0ac7d5968a770c3f532b92db58783f974638" translate="yes" xml:space="preserve">
          <source>If you need access to the bound view, there are two ways to do it:</source>
          <target state="translated">바운드보기에 액세스해야하는 경우 다음 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aa27655c9b71a602d902a015fc4942f9f7944c1" translate="yes" xml:space="preserve">
          <source>If you need to have more control over the initialization process, you can use a manual bootstrapping method instead. Examples of when you'd need to do this include using script loaders or the need to perform an operation before AngularJS compiles a page.</source>
          <target state="translated">초기화 프로세스를보다 세밀하게 제어해야하는 경우 수동 부트 스트랩 방법을 대신 사용할 수 있습니다. 스크립트 로더 사용 또는 AngularJS가 페이지를 컴파일하기 전에 작업을 수행해야하는 경우를 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbca727a7864fd896ef933ac7699c9e2ca5dac44" translate="yes" xml:space="preserve">
          <source>If you need to test a nested Controller you must create the same scope hierarchy in your test that exists in the DOM:</source>
          <target state="translated">중첩 된 컨트롤러를 테스트해야하는 경우 테스트에 DOM에 존재하는 동일한 범위 계층 구조를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9181af21716003a3c721a1845e6a9eddf078bb2" translate="yes" xml:space="preserve">
          <source>If you omit the &lt;code&gt;name&lt;/code&gt; attribute on a radio input, &lt;code&gt;ngModel&lt;/code&gt; will automatically assign it a unique name.</source>
          <target state="translated">라디오 입력 에서 &lt;code&gt;name&lt;/code&gt; 속성 을 생략하면 &lt;code&gt;ngModel&lt;/code&gt; 이 자동으로 고유 한 이름을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ecb468ce29d2f458690fba5b025b3f86a8d80c22" translate="yes" xml:space="preserve">
          <source>If you only want a promise that will be resolved after some specified delay then you can call &lt;code&gt;$timeout&lt;/code&gt; without the &lt;code&gt;fn&lt;/code&gt; function.</source>
          <target state="translated">지정된 지연 후에 해결 될 약속 만 원하는 경우 &lt;code&gt;fn&lt;/code&gt; 함수 없이 &lt;code&gt;$timeout&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5b2fc07801a43a0c7f77b3da6fcfcbca33ad603" translate="yes" xml:space="preserve">
          <source>If you use a custom comparator, it will be called with pairs of objects of the form &lt;code&gt;{value: ..., type: '...', index: ...}&lt;/code&gt; and is expected to return &lt;code&gt;0&lt;/code&gt; if the objects are equal (as far as the comparator is concerned), &lt;code&gt;-1&lt;/code&gt; if the 1st one should be ranked higher than the second, or &lt;code&gt;1&lt;/code&gt; otherwise.</source>
          <target state="translated">사용자 지정 비교기를 사용하면 &lt;code&gt;{value: ..., type: '...', index: ...}&lt;/code&gt; 형식의 개체 쌍으로 호출되며 개체가 같으면 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다. (비교 자와 관련하여), &lt;code&gt;-1&lt;/code&gt; 이 1보다 두 번째로 순위가 높아야하는 경우 -1 , 그렇지 않으면 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58f3058d3baff2b3a073006ea03f29eefad6d04e" translate="yes" xml:space="preserve">
          <source>If you want to be notified whenever &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; is called, you can register a &lt;code&gt;watchExpression&lt;/code&gt; function with no &lt;code&gt;listener&lt;/code&gt;. (Be prepared for multiple calls to your &lt;code&gt;watchExpression&lt;/code&gt; because it will execute multiple times in a single &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; cycle if a change is detected.)</source>
          <target state="translated">&lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ digest&lt;/a&gt; 가 호출 될 때마다 알림을 &lt;code&gt;watchExpression&lt;/code&gt; &lt;code&gt;listener&lt;/code&gt; 없이 watchExpression 함수를 등록 할 수 있습니다 . ( 변경이 감지되면 &lt;code&gt;watchExpression&lt;/code&gt; 이 단일 &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ 다이제스트&lt;/a&gt; 주기로 여러 번 실행되므로 watchExpression 을 여러 번 호출 할 수 있도록 준비하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6f6cc8237e6dc46dbea8035f91ef1cceb56523a5" translate="yes" xml:space="preserve">
          <source>If you want to be notified whenever &lt;code&gt;$digest()&lt;/code&gt; is called, you can register a &lt;code&gt;watchExpression&lt;/code&gt; function with &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$watch()&lt;/a&gt; with no &lt;code&gt;listener&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$digest()&lt;/code&gt; 가 호출 될 때마다 알림을 &lt;code&gt;watchExpression&lt;/code&gt; &lt;code&gt;listener&lt;/code&gt; 없이 &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$ watch ()&lt;/a&gt; 로 watchExpression 함수를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac59abc08a6313ed9820733d9cddfe40a666fa59" translate="yes" xml:space="preserve">
          <source>If you want to keep the default behavior and just add new events that may trigger the model update and validation, add &quot;default&quot; as one of the specified events.</source>
          <target state="translated">기본 동작을 유지하고 모델 업데이트 및 유효성 검사를 트리거 할 수있는 새 이벤트 만 추가하려면 지정된 이벤트 중 하나로 &quot;기본&quot;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7ffb3f226f4ffeb1e0ee64801113cc17b7d6cb85" translate="yes" xml:space="preserve">
          <source>If you want to manually control the insertion and removal of the transcluded content in your directive then you must use this transclude function. When you call a transclude function it returns a a jqLite/JQuery object that contains the compiled DOM, which is linked to the correct transclusion scope.</source>
          <target state="translated">지시문에 포함 된 컨텐츠의 삽입 및 제거를 수동으로 제어하려면이 변환 기능을 사용해야합니다. transclude 함수를 호출하면 올바른 transclusion 범위에 연결된 컴파일 된 DOM이 포함 된 jqLite / JQuery 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0ea1c4594995ec365515b0f24785bafbd02e2b9" translate="yes" xml:space="preserve">
          <source>If you want to manually control the insertion and removal of the transcluded content in your directive then you must use this transclude function. When you call a transclude function it returns a jqLite/JQuery object that contains the compiled DOM, which is linked to the correct transclusion scope.</source>
          <target state="translated">지시문에서 트랜스 클루 드 된 콘텐츠의 삽입 및 제거를 수동으로 제어하려면이 트랜스 클루 드 기능을 사용해야합니다. transclude 함수를 호출하면 올바른 transclusion 범위에 연결된 컴파일 된 DOM을 포함하는 jqLite / JQuery 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="350e89977f66c00f278ba622f5c870b1d11fc27e" translate="yes" xml:space="preserve">
          <source>If you want to pass custom options to the &lt;code&gt;$http&lt;/code&gt; service, such as setting the Accept header you can configure this via &lt;a href=&quot;../provider/%24templaterequestprovider#httpOptions.html&quot;&gt;&lt;code&gt;$templateRequestProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">수락 헤더 설정과 같은 사용자 지정 옵션을 &lt;code&gt;$http&lt;/code&gt; 서비스 에 전달 하려면 &lt;a href=&quot;../provider/%24templaterequestprovider#httpOptions.html&quot;&gt; &lt;code&gt;$templateRequestProvider&lt;/code&gt; &lt;/a&gt; 를 통해이를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55cac270f43d60bf68fc09da3ef0e7d2fc46b878" translate="yes" xml:space="preserve">
          <source>If you want to run more complex JavaScript code, you should make it a controller method and call the method from your view. If you want to &lt;code&gt;eval()&lt;/code&gt; an AngularJS expression yourself, use the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24eval.html&quot;&gt;&lt;code&gt;$eval()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">보다 복잡한 JavaScript 코드를 실행하려면 해당 코드를 컨트롤러 메소드로 만들고 뷰에서 메소드를 호출해야합니다. 당신이 원하는 경우 &lt;code&gt;eval()&lt;/code&gt; AngularJS와 표현 자신의 사용 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24eval.html&quot;&gt; &lt;code&gt;$eval()&lt;/code&gt; &lt;/a&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="94ef57a2b10b7fb543b9ad681272e7260b865493" translate="yes" xml:space="preserve">
          <source>If you wish to be able to navigate to the application via a URL such as &lt;code&gt;/base&lt;/code&gt; then you should ensure that your server is setup to redirect such requests to &lt;code&gt;/base/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/base&lt;/code&gt; 와 같은 URL을 통해 응용 프로그램을 탐색하려면 해당 요청을 &lt;code&gt;/base/&lt;/code&gt; 로 리디렉션하도록 서버를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4a461bd3d1f4cd564f100034e6f4c026c6547ba8" translate="yes" xml:space="preserve">
          <source>If you wish to debug an application with this information then you should open up a debug console in the browser then call this method directly in this console:</source>
          <target state="translated">이 정보를 사용하여 응용 프로그램을 디버깅하려면 브라우저에서 디버그 콘솔을 연 다음이 콘솔에서 직접이 메서드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="67961efc8f60d457340202b3fece6ab62a772fa8" translate="yes" xml:space="preserve">
          <source>If you wish to exclude these then you can use the native &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite&quot;&gt;`isFinite'&lt;/a&gt; method.</source>
          <target state="translated">이것들을 제외하고 싶다면 네이티브 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite&quot;&gt;`isFinite '&lt;/a&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="febd4482ea90c369092b50e44a77405198b68c7e" translate="yes" xml:space="preserve">
          <source>If you wish to override the request/response transformations only for a single request then provide &lt;code&gt;transformRequest&lt;/code&gt; and/or &lt;code&gt;transformResponse&lt;/code&gt; properties on the configuration object passed into &lt;code&gt;$http&lt;/code&gt;.</source>
          <target state="translated">단일 요청에 대해서만 요청 / 응답 변환을 대체하려면 &lt;code&gt;$http&lt;/code&gt; 전달 된 구성 오브젝트에서 &lt;code&gt;transformRequest&lt;/code&gt; 및 / 또는 &lt;code&gt;transformResponse&lt;/code&gt; 특성 을 제공 하십시오 .</target>
        </trans-unit>
        <trans-unit id="92efd56723876207dc42707b797385c44e1ed645" translate="yes" xml:space="preserve">
          <source>If you wish, you can manually delegate exceptions, e.g. &lt;code&gt;try { ... } catch(e) { $exceptionHandler(e); }&lt;/code&gt;</source>
          <target state="translated">원하는 경우 예외를 수동으로 위임 할 수 있습니다 (예 : &lt;code&gt;try { ... } catch(e) { $exceptionHandler(e); }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dede550c88c109a7aa713ce10867aee17cad1fe" translate="yes" xml:space="preserve">
          <source>If you would like to customise where and how the callbacks are stored then try overriding or decorating the &lt;a href=&quot;%24jsonpcallbacks&quot;&gt;&lt;code&gt;$jsonpCallbacks&lt;/code&gt;&lt;/a&gt; service.</source>
          <target state="translated">콜백 저장 위치와 방법을 사용자 정의하려면 &lt;a href=&quot;%24jsonpcallbacks&quot;&gt; &lt;code&gt;$jsonpCallbacks&lt;/code&gt; &lt;/a&gt; 서비스를 재정의하거나 꾸미십시오 .</target>
        </trans-unit>
        <trans-unit id="6de6f522958da34b1dcc259678edc0cbe2c6e606" translate="yes" xml:space="preserve">
          <source>If you're using manual bootstrapping, you can also use strict DI by providing &lt;code&gt;strictDi: true&lt;/code&gt; in the optional config argument:</source>
          <target state="translated">수동 부트 스트랩을 사용하는 경우 선택적 config 인수에 &lt;code&gt;strictDi: true&lt;/code&gt; 를 제공하여 엄격한 DI를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27ab337d46310ca730ffb687877a71fd87b9ffd3" translate="yes" xml:space="preserve">
          <source>If your app is currently in the &lt;code&gt;en-US&lt;/code&gt; locale, the browser will show &lt;code&gt;$1000.00&lt;/code&gt;. If someone in the Japanese locale (&lt;code&gt;ja&lt;/code&gt;) views your app, their browser will show a balance of &lt;code&gt;&amp;yen;1000.00&lt;/code&gt; instead. This is problematic because $1000 is not the same as &amp;yen;1000.</source>
          <target state="translated">앱이 현재 &lt;code&gt;en-US&lt;/code&gt; 로캘 인 경우 브라우저에 &lt;code&gt;$1000.00&lt;/code&gt; 이 표시됩니다 . 일본어 로케일 ( &lt;code&gt;ja&lt;/code&gt; ) 의 누군가가 앱을 보는 경우 브라우저에 &lt;code&gt;&amp;yen;1000.00&lt;/code&gt; 의 잔액이 대신 표시 됩니다. $ 1000이 &amp;yen; 1000과 같지 않기 때문에 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="1430bac2eebac9bf88d3059ad02454360c8556c7" translate="yes" xml:space="preserve">
          <source>If your directive uses &lt;code&gt;templateUrl&lt;/code&gt;, consider using &lt;a href=&quot;https://github.com/karma-runner/karma-ng-html2js-preprocessor&quot;&gt;karma-ng-html2js-preprocessor&lt;/a&gt; to pre-compile HTML templates and thus avoid having to load them over HTTP during test execution. Otherwise you may run into issues if the test directory hierarchy differs from the application's.</source>
          <target state="translated">지시문이 &lt;code&gt;templateUrl&lt;/code&gt; 을 사용하는 경우 &lt;a href=&quot;https://github.com/karma-runner/karma-ng-html2js-preprocessor&quot;&gt;karma-ng-html2js-preprocessor&lt;/a&gt; 를 사용하여 HTML 템플리트를 사전 컴파일하여 테스트 실행 중에 HTTP를 통해로드하지 않아도됩니다. 그렇지 않으면 테스트 디렉토리 계층이 응용 프로그램과 다를 경우 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93fe649037fb09c8d4e2db87fdce1cee0df7982c" translate="yes" xml:space="preserve">
          <source>If your expressions are constant literals, they're automatically trusted and you don't need to call &lt;code&gt;$sce.trustAs&lt;/code&gt; on them (e.g. &lt;code&gt;&amp;lt;div ng-bind-html=&quot;'&amp;lt;b&amp;gt;implicitly trusted&amp;lt;/b&amp;gt;'&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;) just works (remember to include the &lt;code&gt;ngSanitize&lt;/code&gt; module). The &lt;code&gt;$sceDelegate&lt;/code&gt; will also use the &lt;code&gt;$sanitize&lt;/code&gt; service if it is available when binding untrusted values to &lt;code&gt;$sce.HTML&lt;/code&gt; context. AngularJS provides an implementation in &lt;code&gt;angular-sanitize.js&lt;/code&gt;, and if you wish to use it, you will also need to depend on the &lt;a href=&quot;../../ngsanitize&quot;&gt;&lt;code&gt;ngSanitize&lt;/code&gt;&lt;/a&gt; module in your application.</source>
          <target state="translated">표현식이 상수 리터럴 인 경우 자동으로 신뢰 &lt;code&gt;$sce.trustAs&lt;/code&gt; 를 호출 할 필요가 없습니다 (예 : &lt;code&gt;&amp;lt;div ng-bind-html=&quot;'&amp;lt;b&amp;gt;implicitly trusted&amp;lt;/b&amp;gt;'&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; ) 작동합니다 ( &lt;code&gt;ngSanitize&lt;/code&gt; 모듈 을 포함해야 함 ). &lt;code&gt;$sceDelegate&lt;/code&gt; 또한 사용 &lt;code&gt;$sanitize&lt;/code&gt; 으로 신뢰할 수없는 값을 바인딩 할 때 사용할 수있는 경우 서비스를 &lt;code&gt;$sce.HTML&lt;/code&gt; 상황. AngularJS는 &lt;code&gt;angular-sanitize.js&lt;/code&gt; 에서 구현을 제공하며이를 사용하려면 애플리케이션 의 &lt;a href=&quot;../../ngsanitize&quot;&gt; &lt;code&gt;ngSanitize&lt;/code&gt; &lt;/a&gt; 모듈에 의존 해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab4db8d966388aab90159f0307d07fcccc35f63f" translate="yes" xml:space="preserve">
          <source>Imagine you want to have a container with tabs in which the contents of the container correspond to which tab is active.</source>
          <target state="translated">컨테이너의 내용이 활성화 된 탭에 해당하는 탭이있는 컨테이너를 원한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="6b84004070116f71855a9922d8e631eb72f699dc" translate="yes" xml:space="preserve">
          <source>Impact on loading templates</source>
          <target state="translated">템플릿 로딩에 미치는 영향</target>
        </trans-unit>
        <trans-unit id="20b1bba1cb06ab8386a24bd0d8dfecea07cd7671" translate="yes" xml:space="preserve">
          <source>Implementing custom form controls (using ngModel)</source>
          <target state="translated">사용자 지정 양식 컨트롤 구현 (ngModel 사용)</target>
        </trans-unit>
        <trans-unit id="bd06cedc31ae5b22c03264197e96ab3c19ffede6" translate="yes" xml:space="preserve">
          <source>Implicit Annotation</source>
          <target state="translated">암시 적 주석</target>
        </trans-unit>
        <trans-unit id="096ba44a184249033cb9a0bb4ffebe2657bba416" translate="yes" xml:space="preserve">
          <source>Implicit module which gets automatically added to each &lt;a href=&quot;auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;.</source>
          <target state="translated">각 &lt;a href=&quot;auto/service/%24injector&quot;&gt;$ injector에&lt;/a&gt; 자동으로 추가되는 암시 적 모듈 .</target>
        </trans-unit>
        <trans-unit id="4723ddf746f3809e3b1477e490d52c8337146616" translate="yes" xml:space="preserve">
          <source>Implicitly from the function parameter names (has caveats)</source>
          <target state="translated">함수 매개 변수 이름에서 암시 적으로 (주의 사항)</target>
        </trans-unit>
        <trans-unit id="8eecc4f94a1b1fe69acddb79e183178a9e26df1a" translate="yes" xml:space="preserve">
          <source>Important things to notice:</source>
          <target state="translated">유의해야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="3f98eeaab6110938e71c2879641215dabb0c66ef" translate="yes" xml:space="preserve">
          <source>In AngularJS applications, you move the job of filling page templates with data from the server to the client. The result is a system better structured for dynamic page updates. Below are the core features you'll use.</source>
          <target state="translated">AngularJS 애플리케이션에서 데이터로 페이지 템플리트를 채우는 작업을 서버에서 클라이언트로 이동합니다. 결과적으로 동적 페이지 업데이트를 위해보다 체계적인 시스템이 구성됩니다. 사용할 핵심 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c4f4ac01e027f6469e6478b81104e9792711986" translate="yes" xml:space="preserve">
          <source>In AngularJS forms, this is not necessary. The input's state will be updated based on the value of the underlying model data.</source>
          <target state="translated">AngularJS 양식에서는 필요하지 않습니다. 입력 상태는 기본 모델 데이터의 값에 따라 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="b597dc43f8f9e0a6d2155495f4e5474be04320ca" translate="yes" xml:space="preserve">
          <source>In AngularJS, a Component is a special kind of &lt;a href=&quot;directive&quot;&gt;directive&lt;/a&gt; that uses a simpler configuration which is suitable for a component-based application structure.</source>
          <target state="translated">AngularJS에서 구성 요소는 구성 요소 기반 응용 프로그램 구조에 적합한 간단한 구성을 사용 하는 특별한 종류의 &lt;a href=&quot;directive&quot;&gt;지시문&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbbc814b28ce35865c1e769b822e5f29dc4de827" translate="yes" xml:space="preserve">
          <source>In AngularJS, a Controller is defined by a JavaScript &lt;strong&gt;constructor function&lt;/strong&gt; that is used to augment the &lt;a href=&quot;scope&quot;&gt;AngularJS Scope&lt;/a&gt;.</source>
          <target state="translated">AngularJS에서 컨트롤러는 &lt;a href=&quot;scope&quot;&gt;AngularJS Scope&lt;/a&gt; 를 확장하는 데 사용되는 JavaScript &lt;strong&gt;생성자 함수로&lt;/strong&gt; 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a5efbd64f006dff6c25bf138c6b220b436c7355" translate="yes" xml:space="preserve">
          <source>In AngularJS, forms can be nested. This means that the outer form is valid when all of the child forms are valid as well. However, browsers do not allow nesting of &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; elements, so AngularJS provides the &lt;a href=&quot;ngform&quot;&gt;&lt;code&gt;ngForm&lt;/code&gt;&lt;/a&gt; directive, which behaves identically to &lt;code&gt;form&lt;/code&gt; but can be nested. Nested forms can be useful, for example, if the validity of a sub-group of controls needs to be determined.</source>
          <target state="translated">AngularJS에서 폼은 중첩 될 수 있습니다. 이것은 모든 하위 양식도 유효 할 때 외부 양식이 유효 함을 의미합니다. 그러나 브라우저는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소의 중첩을 허용하지 않으므로 AngularJS는 &lt;code&gt;form&lt;/code&gt; 과 동일하게 동작 하지만 중첩 될 수있는 &lt;a href=&quot;ngform&quot;&gt; &lt;code&gt;ngForm&lt;/code&gt; &lt;/a&gt; 지시문을 제공합니다 . 예를 들어 하위 그룹 제어의 유효성을 결정해야하는 경우 중첩 양식이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03844de6e8b1d50475106d63d0d10f3d8c611949" translate="yes" xml:space="preserve">
          <source>In AngularJS, templates are written with HTML that contains AngularJS-specific elements and attributes. AngularJS combines the template with information from the model and controller to render the dynamic view that a user sees in the browser.</source>
          <target state="translated">AngularJS에서 템플릿은 AngularJS 관련 요소 및 속성이 포함 된 HTML로 작성됩니다. AngularJS는 템플릿을 모델 및 컨트롤러의 정보와 결합하여 사용자가 브라우저에서 볼 수있는 동적 뷰를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="a1f619517bf2bbf5ed7ed5d2dc4a8bbb5b243e43" translate="yes" xml:space="preserve">
          <source>In HTML Template Binding</source>
          <target state="translated">HTML 템플릿 바인딩에서</target>
        </trans-unit>
        <trans-unit id="2e80ed003402377171ce0924403b8c90164f9832" translate="yes" xml:space="preserve">
          <source>In HTML5 mode, the &lt;code&gt;$location&lt;/code&gt; service getters and setters interact with the browser URL address through the HTML5 history API. This allows for use of regular URL path and search segments, instead of their hashbang equivalents. If the HTML5 History API is not supported by a browser, the &lt;code&gt;$location&lt;/code&gt; service will fall back to using the hashbang URLs automatically. This frees you from having to worry about whether the browser displaying your app supports the history API or not; the &lt;code&gt;$location&lt;/code&gt; service transparently uses the best available option.</source>
          <target state="translated">HTML5 모드에서 &lt;code&gt;$location&lt;/code&gt; 서비스 게터 및 세터는 HTML5 기록 API를 통해 브라우저 URL 주소와 상호 작용합니다. 이를 통해 hashbang에 해당하는 대신 일반 URL 경로 및 검색 세그먼트를 사용할 수 있습니다. HTML5 히스토리 API가 브라우저에서 지원되지 않으면 &lt;code&gt;$location&lt;/code&gt; 서비스는 자동으로 hashbang URL을 사용합니다. 이를 통해 앱을 표시하는 브라우저가 히스토리 API를 지원하는지 여부를 걱정할 필요가 없습니다. &lt;code&gt;$location&lt;/code&gt; 서비스를 투명하게 가장 적합한 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c291168b9231a4e5740fc0f7c7f24071d1ef1309" translate="yes" xml:space="preserve">
          <source>In Jasmine we use the &lt;code&gt;describe&lt;/code&gt; function to group our tests together:</source>
          <target state="translated">Jasmine에서는 &lt;code&gt;describe&lt;/code&gt; 함수를 사용하여 테스트를 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="a823b45ca87464c258e471b13899cdf061f7a1d1" translate="yes" xml:space="preserve">
          <source>In JavaScript</source>
          <target state="translated">자바 스크립트에서</target>
        </trans-unit>
        <trans-unit id="bbd50f6eadbfc76eda0b9ce7716de2fb5a24fcf4" translate="yes" xml:space="preserve">
          <source>In JavaScript calling &lt;code&gt;toString()&lt;/code&gt; on a function returns the function definition. The definition can then be parsed and the function arguments can be extracted. This method of discovering annotations is disallowed when the injector is in strict mode. &lt;em&gt;NOTE:&lt;/em&gt; This does not work with minification, and obfuscation tools since these tools change the argument names.</source>
          <target state="translated">JavaScript 에서 함수의 &lt;code&gt;toString()&lt;/code&gt; 호출 은 함수 정의를 리턴합니다. 그런 다음 정의를 구문 분석하고 함수 인수를 추출 할 수 있습니다. 인젝터가 엄격 모드 인 경우 주석을 발견하는이 방법이 허용되지 않습니다. &lt;em&gt;참고 :&lt;/em&gt; 이 도구는 인수 이름을 변경하므로 축소 및 난독 화 도구에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b54f06dab3f6e1ac9b946e1f4b43d7b0403e35c" translate="yes" xml:space="preserve">
          <source>In a legacy browser, the URL changes to &lt;code&gt;/index.html#!/some?foo=bar&lt;/code&gt;</source>
          <target state="translated">기존 브라우저에서 URL은 &lt;code&gt;/index.html#!/some?foo=bar&lt;/code&gt; 로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="1c5b58dd4eafa0d4a18da8ca18883a8ad953b136" translate="yes" xml:space="preserve">
          <source>In a modern browser, the URL changes to &lt;code&gt;/some?foo=bar&lt;/code&gt;</source>
          <target state="translated">최신 브라우저에서는 URL이 &lt;code&gt;/some?foo=bar&lt;/code&gt; 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="a3a7a9d6c6de28fb043fa931b25966d7356a56f7" translate="yes" xml:space="preserve">
          <source>In a more complex app, you can display multiple views within one main page using &quot;partials&quot; &amp;ndash; segments of template located in separate HTML files. You can use the &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt;ngView&lt;/a&gt; directive to load partials based on configuration passed to the &lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt;$route&lt;/a&gt; service. The &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;AngularJS tutorial&lt;/a&gt; shows this technique in steps seven and eight.</source>
          <target state="translated">보다 복잡한 앱에서는 별도의 HTML 파일에있는 템플릿 세그먼트 인 &quot;부분&quot;을 사용하여 하나의 기본 페이지 내에 여러보기를 표시 할 수 있습니다. &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt;ngView&lt;/a&gt; 지시문을 사용 하여 &lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt;$ route&lt;/a&gt; 서비스에 전달 된 구성에 따라 부분을로드 할 수 있습니다 . &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/guide/tutorial/&quot;&gt;AngularJS와는 튜토리얼&lt;/a&gt; 쇼를 단계 7-8에서이 기술을.</target>
        </trans-unit>
        <trans-unit id="9f1cddade303a6c5111dc5a24b1534a289b20314" translate="yes" xml:space="preserve">
          <source>In a more complex app, you can display multiple views within one main page using &quot;partials&quot; &amp;ndash; segments of template located in separate HTML files. You can use the &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt;ngView&lt;/a&gt; directive to load partials based on configuration passed to the &lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt;$route&lt;/a&gt; service. The &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/guide/tutorial/&quot;&gt;AngularJS tutorial&lt;/a&gt; shows this technique in steps seven and eight.</source>
          <target state="translated">더 복잡한 앱에서는 별도의 HTML 파일에있는 템플릿 세그먼트 인 &quot;부분&quot;을 사용하여 하나의 기본 페이지 내에 여러보기를 표시 할 수 있습니다. &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt;ngView&lt;/a&gt; 지시문을 사용 하여 &lt;a href=&quot;../api/ngroute/service/%24route&quot;&gt;$ route&lt;/a&gt; 서비스에 전달 된 구성을 기반으로 부분을로드 할 수 있습니다 . &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/guide/tutorial/&quot;&gt;AngularJS와는 튜토리얼&lt;/a&gt; 쇼를 단계 7-8에서이 기술을.</target>
        </trans-unit>
        <trans-unit id="0c0c40a1378e0d2f42f6d4f7be33566e03db6b53" translate="yes" xml:space="preserve">
          <source>In a simple app, the template consists of HTML, CSS, and AngularJS directives contained in just one HTML file (usually &lt;code&gt;index.html&lt;/code&gt;).</source>
          <target state="translated">간단한 앱에서 템플릿은 하나의 HTML 파일 (일반적으로 &lt;code&gt;index.html&lt;/code&gt; )에 포함 된 HTML, CSS 및 AngularJS 지시문으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e674faa938f37f1939ece405364297bb3d2958a2" translate="yes" xml:space="preserve">
          <source>In a single module the order of execution is as follows:</source>
          <target state="translated">단일 모듈에서 실행 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="749307d1cbfaf16fe4aabba520b82ae1902a1b6a" translate="yes" xml:space="preserve">
          <source>In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation with CSS styles.</source>
          <target state="translated">CSS 클래스의 추가 및 제거 외에도 ngAnimate는 CSS 스타일로 애니메이션을 더 꾸미는 데 사용할 수있는 두 가지 도우미 메서드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6321ce8bd6ac1756913a159906eecc022bf64796" translate="yes" xml:space="preserve">
          <source>In addition to all the regular &lt;code&gt;Scope&lt;/code&gt; methods, the following helper methods are available:</source>
          <target state="translated">모든 일반적인 &lt;code&gt;Scope&lt;/code&gt; 방법 외에도 다음과 같은 도우미 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b766677551b49d250621b2a334d198d39eec2e53" translate="yes" xml:space="preserve">
          <source>In addition to prioritization, ngMessages also allows for including messages from a remote or an inline template. This allows for generic collection of messages to be reused across multiple parts of an application.</source>
          <target state="translated">우선 순위 지정 외에도 ngMessages는 원격 또는 인라인 템플릿의 메시지를 포함 할 수 있습니다. 이를 통해 응용 프로그램의 여러 부분에서 일반 메시지 콜렉션을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="716143d7f33a871721bcf40bfd2db07a6cdb72d7" translate="yes" xml:space="preserve">
          <source>In addition to the above elements, tests may also contain helper functions to avoid duplicating code in the &lt;code&gt;it&lt;/code&gt; blocks.</source>
          <target state="translated">위의 요소 외에도 테스트에는 &lt;code&gt;it&lt;/code&gt; 블록에 코드가 중복되는 것을 피하기 위해 도우미 함수가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="470ea7a4e5c2fe6de7091aa6f7ec21ee51897509" translate="yes" xml:space="preserve">
          <source>In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering an event listener using the &lt;code&gt;$animate&lt;/code&gt; service. Let's say for example that an animation was triggered on our view routing controller to hook into that:</source>
          <target state="translated">애니메이션 약속 외에도 &lt;code&gt;$animate&lt;/code&gt; 서비스를 사용하여 이벤트 리스너를 등록하여 지시문 및 컨트롤러 코드 내에서 애니메이션 관련 콜백을 사용할 수 있습니다 . 예를 들어 뷰 라우팅 컨트롤러에서 애니메이션이 트리거되어 다음과 같이 연결되었다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1699cbe96c0e4716d740c691996232ad4e5fe565" translate="yes" xml:space="preserve">
          <source>In addition, the browser's &lt;a href=&quot;https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest&quot;&gt;Same Origin Policy&lt;/a&gt; and &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;Cross-Origin Resource Sharing (CORS)&lt;/a&gt; policy may further restrict whether the template is successfully loaded. For example, &lt;code&gt;ngInclude&lt;/code&gt; won't work for cross-domain requests on all browsers and for &lt;code&gt;file://&lt;/code&gt; access on some browsers.</source>
          <target state="translated">또한 브라우저의 &lt;a href=&quot;https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest&quot;&gt;동일한 원본 정책&lt;/a&gt; 및 &lt;a href=&quot;http://www.w3.org/TR/cors/&quot;&gt;CORS (Cross-Origin Resource Sharing)&lt;/a&gt; 정책은 템플릿이 성공적으로로드되는지 여부를 추가로 제한 할 수 있습니다. 예를 들어, &lt;code&gt;ngInclude&lt;/code&gt; 는 모든 브라우저의 도메인 간 요청 및 일부 브라우저의 &lt;code&gt;file://&lt;/code&gt; 액세스 에는 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a57b0290a74b9eb78ccc15559fe648219b660cfc" translate="yes" xml:space="preserve">
          <source>In addition, you can supply a &lt;code&gt;headers&lt;/code&gt; property in the config object passed when calling &lt;code&gt;$http(config)&lt;/code&gt;, which overrides the defaults without changing them globally.</source>
          <target state="translated">또한 &lt;code&gt;$http(config)&lt;/code&gt; 호출 할 때 전달 된 구성 객체에 &lt;code&gt;headers&lt;/code&gt; 속성을 제공 할 수 있습니다.이 속성 은 기본값을 전역 적으로 변경하지 않고 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="589af7f1aae2e3ad6aab5df9c86b6c8e31638595" translate="yes" xml:space="preserve">
          <source>In all of these examples we are going to assume this module definition:</source>
          <target state="translated">이 모든 예제에서이 모듈 정의를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2ba4bd29bc7d7975c3e58c60de7ab29abd9339c6" translate="yes" xml:space="preserve">
          <source>In an effort to keep synchronized with router changes in the new Angular, this implementation of the Component Router (ngComponentRouter module) has been deprecated and will not receive further updates. We are investigating backporting the Router for the new Angular to AngularJS, but alternatively, use the &lt;a href=&quot;../../ngroute&quot;&gt;&lt;code&gt;ngRoute&lt;/code&gt;&lt;/a&gt; module or community developed projects (e.g. &lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;ui-router&lt;/a&gt;).</source>
          <target state="translated">새로운 Angular에서 라우터 변경 사항과 동기화를 유지하기 위해이 구성 요소 라우터 (ngComponentRouter 모듈) 구현은 더 이상 사용되지 않으며 추가 업데이트를받지 않습니다. 새로운 Angular에서 AngularJS로 라우터를 백 포트하는 방법을 조사하고 있지만 &lt;a href=&quot;../../ngroute&quot;&gt; &lt;code&gt;ngRoute&lt;/code&gt; &lt;/a&gt; 모듈 또는 커뮤니티 개발 프로젝트 (예 : &lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;ui-router&lt;/a&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="667b1ad2855f853d06e0711549d307d56aa4fdca" translate="yes" xml:space="preserve">
          <source>In an effort to keep synchronized with router changes in the new Angular, this implementation of the Component Router (ngComponentRouter module) has been deprecated and will not receive further updates. We are investigating backporting the Router for the new Angular to AngularJS, but alternatively, use the &lt;a href=&quot;ngroute&quot;&gt;&lt;code&gt;ngRoute&lt;/code&gt;&lt;/a&gt; module or community developed projects (e.g. &lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;ui-router&lt;/a&gt;).</source>
          <target state="translated">새로운 Angular에서 라우터 변경 사항과 동기화를 유지하기 위해이 구성 요소 라우터 (ngComponentRouter 모듈) 구현은 더 이상 사용되지 않으며 추가 업데이트를받지 않습니다. 새로운 Angular에서 AngularJS로 라우터를 백 포트하는 방법을 조사하고 있지만 &lt;a href=&quot;ngroute&quot;&gt; &lt;code&gt;ngRoute&lt;/code&gt; &lt;/a&gt; 모듈 또는 커뮤니티 개발 프로젝트 (예 : &lt;a href=&quot;https://github.com/angular-ui/ui-router&quot;&gt;ui-router&lt;/a&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9386991172b647254fafb7d351016e610e121394" translate="yes" xml:space="preserve">
          <source>In any case, the value passed to the method should always reflect the current value of the control. For example, if you are calling &lt;code&gt;$setViewValue&lt;/code&gt; for an input element, you should pass the input DOM value. Otherwise, the control and the scope model become out of sync. It's also important to note that &lt;code&gt;$setViewValue&lt;/code&gt; does not call &lt;code&gt;$render&lt;/code&gt; or change the control's DOM value in any way. If we want to change the control's DOM value programmatically, we should update the &lt;code&gt;ngModel&lt;/code&gt; scope expression. Its new value will be picked up by the model controller, which will run it through the &lt;code&gt;$formatters&lt;/code&gt;, &lt;code&gt;$render&lt;/code&gt; it to update the DOM, and finally call &lt;code&gt;$validate&lt;/code&gt; on it.</source>
          <target state="translated">어쨌든, 메소드에 전달 된 값은 항상 컨트롤의 현재 값을 반영해야합니다. 예를 들어 입력 요소에 대해 &lt;code&gt;$setViewValue&lt;/code&gt; 를 호출하는 경우 입력 DOM 값을 전달해야합니다. 그렇지 않으면 컨트롤과 스코프 모델이 동기화되지 않습니다. 또한 &lt;code&gt;$setViewValue&lt;/code&gt; 는 &lt;code&gt;$render&lt;/code&gt; 호출 하거나 어떤 식 으로든 컨트롤의 DOM 값을 변경 하지 않습니다 . 프로그래밍 방식으로 컨트롤의 DOM 값을 변경하려면 &lt;code&gt;ngModel&lt;/code&gt; 범위 표현식을 업데이트해야 합니다. 새로운 값은 모델 컨트롤러에 의해 선택되어 &lt;code&gt;$formatters&lt;/code&gt; , &lt;code&gt;$render&lt;/code&gt; 를 통해 DOM을 업데이트하고 &lt;code&gt;$validate&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="68fe7d927164f0e298a884af50c62aebe47691da" translate="yes" xml:space="preserve">
          <source>In both examples, the &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; expression is applied successfully to each &lt;code&gt;item&lt;/code&gt; in the &lt;code&gt;items&lt;/code&gt; array. Because the selected option has been set programmatically in the controller, the &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; expression is also applied to the &lt;code&gt;ngModel&lt;/code&gt; value. In the first example, the &lt;code&gt;ngModel&lt;/code&gt; value is &lt;code&gt;items[0]&lt;/code&gt; and the &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; expression evaluates to &lt;code&gt;items[0].id&lt;/code&gt; with no issue. In the second example, the &lt;code&gt;ngModel&lt;/code&gt; value is &lt;code&gt;items[0].subItem&lt;/code&gt; and the &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; expression evaluates to &lt;code&gt;items[0].subItem.id&lt;/code&gt; (which is undefined). As a result, the model value is not matched against any &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; and the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; appears as having no selected value.</source>
          <target state="translated">두 예제 모두에서 &lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt; 표현식이 &lt;code&gt;items&lt;/code&gt; 배열의 각 &lt;code&gt;item&lt;/code&gt; 에 성공적으로 적용 됩니다. 선택한 옵션이 컨트롤러에서 프로그래밍 방식으로 설정되었으므로 &lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt; 표현식이 &lt;code&gt;ngModel&lt;/code&gt; 값 에도 적용됩니다 . 첫 번째 예에서 &lt;code&gt;ngModel&lt;/code&gt; 값은 &lt;code&gt;items[0]&lt;/code&gt; 이고 표현 식별 &lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt; 문제없이 &lt;code&gt;items[0].id&lt;/code&gt; 로 평가됩니다 . 두 번째 예에서, &lt;code&gt;ngModel&lt;/code&gt; 의 값은 &lt;code&gt;items[0].subItem&lt;/code&gt; 및 &lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt; 을 표현들을 평가 &lt;code&gt;items[0].subItem.id&lt;/code&gt; &lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;(정의되지 않음). 결과적으로, 모델 값이 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 과 일치하지 않으며 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 는 선택된 값이없는 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5db12307c0b10381c7de9de7d244ed95abd76ff2" translate="yes" xml:space="preserve">
          <source>In browsers that follow the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/forms.html#number-state-%28type=number%29&quot;&gt;HTML5 specification&lt;/a&gt;, &lt;code&gt;input[number]&lt;/code&gt; does not work as expected with &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions.allowInvalid&lt;/code&gt;&lt;/a&gt;. If a non-number is entered in the input, the browser will report the value as an empty string, which means the view / model values in &lt;code&gt;ngModel&lt;/code&gt; and subsequently the scope value will also be an empty string.</source>
          <target state="translated">&lt;a href=&quot;https://html.spec.whatwg.org/multipage/forms.html#number-state-%28type=number%29&quot;&gt;HTML5 사양&lt;/a&gt; 을 따르는 브라우저 에서 &lt;code&gt;input[number]&lt;/code&gt; 는 &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions.allowInvalid&lt;/code&gt; 에서&lt;/a&gt; 예상대로 작동하지 않습니다 . 입력에 숫자가 아닌 값을 입력하면 브라우저는 값을 빈 문자열로보고합니다. 즉, &lt;code&gt;ngModel&lt;/code&gt; 의보기 / 모델 값 과 이후 범위 값도 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="e3e1a3ce31bec47d5200ef4cf60ace5abb3ccfe7" translate="yes" xml:space="preserve">
          <source>In case of parameter name collision, &lt;code&gt;path&lt;/code&gt; params take precedence over &lt;code&gt;search&lt;/code&gt; params.</source>
          <target state="translated">매개 변수 이름 충돌의 경우 &lt;code&gt;path&lt;/code&gt; 매개 변수가 &lt;code&gt;search&lt;/code&gt; 매개 변수 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="c26867c8ed3c13342fd31b32bf994a5c01045f08" translate="yes" xml:space="preserve">
          <source>In case the &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;ngModelOptions&lt;/a&gt; directive is used with &lt;code&gt;updateOn&lt;/code&gt; and the &lt;code&gt;default&lt;/code&gt; trigger is not listed, all those actions will remain pending until one of the &lt;code&gt;updateOn&lt;/code&gt; events is triggered on the DOM element. All these actions will be debounced if the &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;ngModelOptions&lt;/a&gt; directive is used with a custom debounce for this particular event. Note that a &lt;code&gt;$digest&lt;/code&gt; is only triggered once the &lt;code&gt;updateOn&lt;/code&gt; events are fired, or if &lt;code&gt;debounce&lt;/code&gt; is specified, once the timer runs out.</source>
          <target state="translated">경우에 &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;ngModelOptions의&lt;/a&gt; 지시어와 함께 사용 &lt;code&gt;updateOn&lt;/code&gt; 과 &lt;code&gt;default&lt;/code&gt; 트리거가 나열되지 않은, 모든 작업은 한 때까지 보류 유지됩니다 &lt;code&gt;updateOn&lt;/code&gt; 의 이벤트가 DOM 요소에 트리거됩니다. &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;ngModelOptions&lt;/a&gt; 지시문이이 특정 이벤트에 대한 사용자 정의 디 바운스와 함께 사용 되면 이러한 모든 조치가 디 바운스됩니다 . &amp;bull; 그래도 참고 &lt;code&gt;$digest&lt;/code&gt; 단지 한 번 실행됩니다 &lt;code&gt;updateOn&lt;/code&gt; 의 이벤트는 해고, 또는 경우 &lt;code&gt;debounce&lt;/code&gt; 타이머가 다 떨어지기 일단 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="dbb2128824b196014baa5c500781714a968857a4" translate="yes" xml:space="preserve">
          <source>In cases like the following, links are not rewritten; instead, the browser will perform a full page reload to the original link.</source>
          <target state="translated">다음과 같은 경우 링크가 다시 작성되지 않습니다. 대신 브라우저는 원본 링크로 전체 페이지를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="eb1595edfe03ceecabe189afd4c1478336da4f55" translate="yes" xml:space="preserve">
          <source>In cases where both backend definitions and request expectations are specified during unit testing, the request expectations are evaluated first.</source>
          <target state="translated">단위 테스트 중에 백엔드 정의와 요청 예상이 모두 지정된 경우 요청 예상이 먼저 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="bf55b6216c29164cc9616d092551ba62d75a0676" translate="yes" xml:space="preserve">
          <source>In complex applications it's possible that dependencies between &lt;code&gt;$onChanges&lt;/code&gt; hooks and bindings will result in several iterations of calls to these hooks. However if an application needs more than the default 10 iterations to stabilize then you should investigate what is causing the model to continuously change during the &lt;code&gt;$onChanges&lt;/code&gt; hook execution.</source>
          <target state="translated">복잡한 응용 프로그램에서 &lt;code&gt;$onChanges&lt;/code&gt; 후크와 바인딩 사이의 종속성 으로 인해 이러한 후크에 대한 호출이 여러 번 반복 될 수 있습니다. 그러나 애플리케이션이 안정화하기 위해 기본 10 회 이상의 반복이 필요한 경우 &lt;code&gt;$onChanges&lt;/code&gt; 후크 실행 중에 모델이 지속적으로 변경되는 원인을 조사해야합니다 .</target>
        </trans-unit>
        <trans-unit id="572607a7218cef33ac940e82902038d02ae937e5" translate="yes" xml:space="preserve">
          <source>In complex applications it's possible that the dependencies between &lt;code&gt;$watch&lt;/code&gt;s will result in several digest iterations. However if an application needs more than the default 10 digest iterations for its model to stabilize then you should investigate what is causing the model to continuously change during the digest.</source>
          <target state="translated">복잡한 응용 프로그램에서 &lt;code&gt;$watch&lt;/code&gt; 사이의 종속성으로 인해 여러 가지 요약 반복이 발생할 수 있습니다. 그러나 애플리케이션이 모델을 안정화하기 위해 기본 10 개 이상의 다이제스트 반복을 필요로하는 경우 다이제스트 중에 모델이 지속적으로 변경되는 원인을 조사해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6327a6402c02d7879a52df32482acae297464b3" translate="yes" xml:space="preserve">
          <source>In general it's possible to apply more than one directive to one element, but there might be limitations depending on the type of scope required by the directives. The following points will help explain these limitations. For simplicity only two directives are taken into account, but it is also applicable for several directives:</source>
          <target state="translated">일반적으로 둘 이상의 지시문을 하나의 요소에 적용 할 수 있지만 지시문에 필요한 범위 유형에 따라 제한이있을 수 있습니다. 다음은 이러한 제한 사항을 설명하는 데 도움이됩니다. 단순화를 위해 두 개의 지시문 만 고려되지만 여러 지시문에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d65eb267b1b0354141999d7194c0a15d48c760f2" translate="yes" xml:space="preserve">
          <source>In general, a Controller shouldn't try to do too much. It should contain only the business logic needed for a single view.</source>
          <target state="translated">일반적으로 컨트롤러는 너무 많은 일을 시도해서는 안됩니다. 단일 뷰에 필요한 비즈니스 로직 만 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="12b68495b61d68a58ae4306b8d4fa6a9c7a5a8c9" translate="yes" xml:space="preserve">
          <source>In general, the match between the model and an option is evaluated by strictly comparing the model value against the value of the available options.</source>
          <target state="translated">일반적으로 모델과 옵션 간의 일치는 사용 가능한 옵션의 값과 모델 값을 엄격하게 비교하여 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c9ab8714b380fd88731ce6a010864a6dad2a5821" translate="yes" xml:space="preserve">
          <source>In general, this applies only to filters that take &lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/Primitive&quot;&gt;primitive values&lt;/a&gt; as inputs. Filters that receive &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Objects&quot;&gt;Objects&lt;/a&gt; as input are executed on each &lt;code&gt;$digest&lt;/code&gt;, as it would be too costly to track if the inputs have changed.</source>
          <target state="translated">일반적으로 이는 &lt;a href=&quot;https://developer.mozilla.org/docs/Glossary/Primitive&quot;&gt;기본 값&lt;/a&gt; 을 입력 으로 사용하는 필터에만 적용됩니다 . 입력으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Objects&quot;&gt;오브젝트&lt;/a&gt; 를 수신하는 필터 는 입력이 변경되었는지 추적하기에는 너무 비용이 많이 들기 때문에 각 &lt;code&gt;$digest&lt;/code&gt; 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="223c150544e590c3b09b2f83432104d5c677b5fc" translate="yes" xml:space="preserve">
          <source>In its current implementation, we'd need to create a different controller each time in order to re-use such a directive:</source>
          <target state="translated">현재 구현에서는 이러한 지시문을 재사용하기 위해 매번 다른 컨트롤러를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="aaf87ac010abced2fa8d3d211eaa4cf5c460607b" translate="yes" xml:space="preserve">
          <source>In its default setup, ngAria for &lt;code&gt;ngShow&lt;/code&gt; is actually redundant. It toggles &lt;code&gt;aria-hidden&lt;/code&gt; on the directive when it is hidden or shown. However, the default CSS of &lt;code&gt;display: none !important&lt;/code&gt;, already hides child elements from a screen reader. It becomes more useful when the default CSS is overridden with properties that don&amp;rsquo;t affect assistive technologies, such as &lt;code&gt;opacity&lt;/code&gt; or &lt;code&gt;transform&lt;/code&gt;. By toggling &lt;code&gt;aria-hidden&lt;/code&gt; dynamically with ngAria, we can ensure content visually hidden with this technique will not be read aloud in a screen reader.</source>
          <target state="translated">기본 설정에서 ngShow의 &lt;code&gt;ngShow&lt;/code&gt; 는 실제로 중복됩니다. 지시문이 숨겨 지거나 표시 될 때 지시문에서 &lt;code&gt;aria-hidden&lt;/code&gt; 을 토글 합니다. 그러나 &lt;code&gt;display: none !important&lt;/code&gt; 의 기본 CSS : none! important 는 이미 스크린 리더에서 자식 요소를 숨 깁니다. &lt;code&gt;opacity&lt;/code&gt; 또는 &lt;code&gt;transform&lt;/code&gt; 과 같은 보조 기술에 영향을 미치지 않는 속성으로 기본 CSS를 재정의하는 경우 더 유용합니다 . ngAria를 사용하여 &lt;code&gt;aria-hidden&lt;/code&gt; 을 동적으로 전환 하여이 기술로 시각적으로 숨겨진 컨텐츠를 화면 판독기에서 소리내어 읽지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac48986b940877fd638b3f87daf87350f3cd59a" translate="yes" xml:space="preserve">
          <source>In many cases, &lt;a href=&quot;ngrepeat&quot;&gt;ngRepeat&lt;/a&gt; can be used on &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements instead of &lt;code&gt;ngOptions&lt;/code&gt; to achieve a similar result. However, &lt;code&gt;ngOptions&lt;/code&gt; provides some benefits:</source>
          <target state="translated">많은 경우에, &lt;a href=&quot;ngrepeat&quot;&gt;ngRepeat을&lt;/a&gt; 사용할 수있다 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 대신 요소 &lt;code&gt;ngOptions&lt;/code&gt; 은 유사한 결과를 얻을 수있다. 그러나 &lt;code&gt;ngOptions&lt;/code&gt; 는 몇 가지 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="816f5a467069e8684ca6c8eac56b04421f4f9aac" translate="yes" xml:space="preserve">
          <source>In many cases, &lt;code&gt;ngRepeat&lt;/code&gt; can be used on &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements instead of &lt;a href=&quot;ngoptions&quot;&gt;ngOptions&lt;/a&gt; to achieve a similar result. However, &lt;code&gt;ngOptions&lt;/code&gt; provides some benefits:</source>
          <target state="translated">많은 경우에, &lt;code&gt;ngRepeat&lt;/code&gt; 을 사용할 수있다 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 대신 요소 &lt;a href=&quot;ngoptions&quot;&gt;ngOptions은&lt;/a&gt; 유사한 결과를 얻을 수있다. 그러나 &lt;code&gt;ngOptions&lt;/code&gt; 는 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a74c3d278c8929951ba5893b635995005f8e65" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt; and scopes interact but do not create new instances of scope. However, some directives, such as &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;ng-controller&lt;/a&gt; and &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ng-repeat&lt;/a&gt;, create new child scopes and attach the child scope to the corresponding DOM element.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; 과 범위는 상호 작용하지만 범위의 새 인스턴스를 만들지는 않습니다. 그러나 &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;ng-controller&lt;/a&gt; 및 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ng-repeat&lt;/a&gt; 와 같은 일부 지시문은 새 자식 범위를 만들고 자식 범위를 해당 DOM 요소에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="a6d61eeade717370e6792f08603d2f769bf7909b" translate="yes" xml:space="preserve">
          <source>In order for &lt;code&gt;yOffset&lt;/code&gt; to work properly, scrolling should take place on the document's root and not some child element.</source>
          <target state="translated">위해에 대한 &lt;code&gt;yOffset&lt;/code&gt; 는 문서의 루트에 장소가 아닌 일부 자식 요소를 취해야한다 스크롤 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="43159b000f095713d7995347d0aa0418f3baf129" translate="yes" xml:space="preserve">
          <source>In order for custom control to work with &lt;code&gt;ngModel&lt;/code&gt; and to achieve two-way data-binding it needs to:</source>
          <target state="translated">&lt;code&gt;ngModel&lt;/code&gt; 에서 사용자 정의 제어를 작동하고 양방향 데이터 바인딩을 수행하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="93e76425878be6a245b2b5122baa300334e1d96a" translate="yes" xml:space="preserve">
          <source>In order for the injector to know how to create and wire together all of these objects, it needs a registry of &quot;recipes&quot;. Each recipe has an identifier of the object and the description of how to create this object.</source>
          <target state="translated">인젝터가 이러한 모든 오브젝트를 작성하고 함께 연결하는 방법을 알기 위해서는 &quot;레시피&quot;레지스트리가 필요합니다. 각 레시피에는 객체의 식별자와이 객체를 생성하는 방법에 대한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="41ca1c0cfc3250833efe87b946e6688542d335f0" translate="yes" xml:space="preserve">
          <source>In order to answer such a question it is very important that we can isolate the unit of code under test. That is because when we are testing the sort function we don't want to be forced into creating related pieces such as the DOM elements, or making any XHR calls to fetch the data to sort.</source>
          <target state="translated">이러한 질문에 답하기 위해서는 테스트중인 코드 단위를 분리 할 수 ​​있어야합니다. 정렬 함수를 테스트 할 때 DOM 요소와 같은 관련 조각을 작성하거나 정렬 할 데이터를 페치하기 위해 XHR 호출을 수행하지 않아도되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="83939e2bc9f9e5b599175fbfb5fec4456c3a2747" translate="yes" xml:space="preserve">
          <source>In order to enable animations the &lt;code&gt;ngAnimate&lt;/code&gt; module has to be loaded.</source>
          <target state="translated">애니메이션을 활성화하려면 &lt;code&gt;ngAnimate&lt;/code&gt; 모듈을로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6563365aaa2bf57b65af1a6e2ab56f748edc001" translate="yes" xml:space="preserve">
          <source>In order to ensure that the sorting will be deterministic across platforms, if none of the specified predicates can distinguish between two items, &lt;code&gt;orderBy&lt;/code&gt; will automatically introduce a dummy predicate that returns the item's index as &lt;code&gt;value&lt;/code&gt;. (If you are using a custom comparator, make sure it can handle this predicate as well.)</source>
          <target state="translated">지정된 술어가 두 항목을 구별 할 수없는 경우, 여러 플랫폼에서 정렬이 결정적임을 보장하기 위해 &lt;code&gt;orderBy&lt;/code&gt; 는 자동으로 항목의 색인을 &lt;code&gt;value&lt;/code&gt; 로 리턴하는 더미 술어를 도입 합니다 . (사용자 정의 비교기를 사용하는 경우이 술어도 처리 할 수 ​​있는지 확인하십시오.)</target>
        </trans-unit>
        <trans-unit id="ba07d896b98bd38aa92e1a51979d43b5762c90ac" translate="yes" xml:space="preserve">
          <source>In order to make the definition easier, components enforce best practices like use of &lt;code&gt;controllerAs&lt;/code&gt;, &lt;code&gt;bindToController&lt;/code&gt;. They always have &lt;strong&gt;isolate scope&lt;/strong&gt; and are restricted to elements.</source>
          <target state="translated">정의를 쉽게하기 위해 구성 요소는 &lt;code&gt;controllerAs&lt;/code&gt; , &lt;code&gt;bindToController&lt;/code&gt; 사용과 같은 모범 사례를 시행 합니다. 이들은 항상 &lt;strong&gt;격리 범위를&lt;/strong&gt; 가지며 요소로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="92f3760b5ddb703592c1c344abf1808f65b67a46" translate="yes" xml:space="preserve">
          <source>In order to prevent collisions in environments where multiple AngularJS apps share the same domain or subdomain, we recommend that each application uses a unique cookie name.</source>
          <target state="translated">여러 AngularJS 앱이 동일한 도메인 또는 하위 도메인을 공유하는 환경에서 충돌을 방지하려면 각 애플리케이션이 고유 한 쿠키 이름을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c431fcb3d2dd29f9f6877e5863d11e1c5282ac1f" translate="yes" xml:space="preserve">
          <source>In order to react to events or execute computation in the view we must provide behavior to the scope. We add behavior to the scope by attaching methods to the &lt;code&gt;$scope&lt;/code&gt; object. These methods are then available to be called from the template/view.</source>
          <target state="translated">이벤트에 반응하거나보기에서 계산을 실행하려면 범위에 동작을 제공해야합니다. 메소드를 &lt;code&gt;$scope&lt;/code&gt; 객체 에 첨부하여 범위에 동작을 추가 합니다. 그런 다음 템플릿 / 뷰에서 이러한 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d69397877d61d2ffddceb4be6f794cc00dd86f" translate="yes" xml:space="preserve">
          <source>In order to show error messages corresponding to &lt;code&gt;myField&lt;/code&gt; we first create an element with an &lt;code&gt;ngMessages&lt;/code&gt; attribute set to the &lt;code&gt;$error&lt;/code&gt; object owned by the &lt;code&gt;myField&lt;/code&gt; input in our &lt;code&gt;myForm&lt;/code&gt; form.</source>
          <target state="translated">&lt;code&gt;myField&lt;/code&gt; 에 해당하는 오류 메시지를 표시하기 위해 먼저 &lt;code&gt;myForm&lt;/code&gt; 양식 의 &lt;code&gt;myField&lt;/code&gt; 입력이 소유 한 &lt;code&gt;$error&lt;/code&gt; 객체로 설정된 &lt;code&gt;ngMessages&lt;/code&gt; 속성을 가진 요소를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="38ca262d53b30c1c185b66f2480b52ad395cd555" translate="yes" xml:space="preserve">
          <source>In order to:</source>
          <target state="translated">하기 위해 :</target>
        </trans-unit>
        <trans-unit id="cee56acce42439af4e48556eac71fd143eec3563" translate="yes" xml:space="preserve">
          <source>In our &lt;code&gt;link&lt;/code&gt; function, we want to update the displayed time once a second, or whenever a user changes the time formatting string that our directive binds to. We will use the &lt;code&gt;$interval&lt;/code&gt; service to call a handler on a regular basis. This is easier than using &lt;code&gt;$timeout&lt;/code&gt; but also works better with end-to-end testing, where we want to ensure that all &lt;code&gt;$timeout&lt;/code&gt;s have completed before completing the test. We also want to remove the &lt;code&gt;$interval&lt;/code&gt; if the directive is deleted so we don't introduce a memory leak.</source>
          <target state="translated">우리에 &lt;code&gt;link&lt;/code&gt; 기능, 우리는 두 번째 한 번에 표시되는 시간을 업데이트 할, 또는 사용자가 문자열을 포맷 시간을 변경할 때마다 우리의 지침 귀속에 그. &lt;code&gt;$interval&lt;/code&gt; 서비스를 사용하여 정기적으로 핸들러를 호출합니다. 이것은 &lt;code&gt;$timeout&lt;/code&gt; 사용하는 것보다 쉽지만 end-to-end 테스트에서 더 효과적입니다 . 테스트를 완료하기 전에 모든 &lt;code&gt;$timeout&lt;/code&gt; 이 완료 되었는지 확인하려고합니다 . 또한 지시어가 삭제되면 &lt;code&gt;$interval&lt;/code&gt; 을 제거하여 메모리 누수가 발생하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="1b484d590e22004602005d9748c97e5a23a50efa" translate="yes" xml:space="preserve">
          <source>In plain HTML forms, the &lt;code&gt;name&lt;/code&gt; attribute is used to identify groups of radio inputs, so that the browser can manage their state (checked/unchecked) based on the state of other inputs in the same group.</source>
          <target state="translated">일반 HTML 양식에서 &lt;code&gt;name&lt;/code&gt; 속성은 라디오 입력 그룹을 식별하는 데 사용되므로 브라우저가 동일한 그룹의 다른 입력 상태를 기반으로 상태 (선택 / 선택 해제)를 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="46cfb3934a0deeee576ac8393203dd312b39eb1f" translate="yes" xml:space="preserve">
          <source>In practice</source>
          <target state="translated">실제로</target>
        </trans-unit>
        <trans-unit id="23f474e3365b6841390e2d04f8b7b183101fc5b0" translate="yes" xml:space="preserve">
          <source>In practice, flickering can appear when nesting elements with structural animations such as &lt;code&gt;ngIf&lt;/code&gt; into elements that have class-based animations such as &lt;code&gt;ngClass&lt;/code&gt;.</source>
          <target state="translated">같은 구성 요소 애니메이션 중첩 때 실제로 플리커 게재 &lt;code&gt;ngIf&lt;/code&gt; 같은 클래스 기반 애니메이션이 요소로 &lt;code&gt;ngClass&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="4b6b3f1479d15949f893579bddd17a5c4695b028" translate="yes" xml:space="preserve">
          <source>In privileged contexts, directives and code will bind to the result of &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;$sce.getTrusted(context, value)&lt;/a&gt; rather than to the value directly. Think of this function as a way to enforce the required security context in your data sink. Directives use &lt;a href=&quot;%24sce#parseAs.html&quot;&gt;$sce.parseAs&lt;/a&gt; rather than &lt;code&gt;$parse&lt;/code&gt; to watch attribute bindings, which performs the &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;$sce.getTrusted&lt;/a&gt; behind the scenes on non-constant literals. Also, when binding without directives, AngularJS will understand the context of your bindings automatically.</source>
          <target state="translated">특권 컨텍스트에서 지시문과 코드는 &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;값이&lt;/a&gt; 아닌 $ sce.getTrusted (context, value) 의 결과에 바인딩 됩니다. 이 기능을 데이터 싱크에 필요한 보안 컨텍스트를 적용하는 방법으로 생각하십시오. 지시문은 속성 바인딩을 감시하기 위해 &lt;code&gt;$parse&lt;/code&gt; 대신 &lt;a href=&quot;%24sce#parseAs.html&quot;&gt;$ sce.parseAs를&lt;/a&gt; 사용 합니다. 이는 상수가 아닌 리터럴에서 씬 뒤에서 &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;$ sce.getTrusted&lt;/a&gt; 를 수행합니다 . 또한 지시문없이 바인딩하면 AngularJS는 바인딩 컨텍스트를 자동으로 이해합니다.</target>
        </trans-unit>
        <trans-unit id="ad0a78c7ea83ece459db4a6b9e0ec41e1d081220" translate="yes" xml:space="preserve">
          <source>In some cases you can also rely upon automatic sanitization of untrusted values - see below.</source>
          <target state="translated">경우에 따라 신뢰할 수없는 값의 자동 살균에 의존 할 수도 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="ced5561a26558d4d24bd44d63f6ee1bbb96f6f9e" translate="yes" xml:space="preserve">
          <source>In templates, filters are only executed when their inputs have changed. This is more performant than executing a filter on each &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;&lt;code&gt;$digest&lt;/code&gt;&lt;/a&gt; as is the case with &lt;a href=&quot;expression&quot;&gt;expressions&lt;/a&gt;.</source>
          <target state="translated">템플릿에서 필터는 입력이 변경된 경우에만 실행됩니다. 이것은 &lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; 의 경우와 같이 각 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt; &lt;code&gt;$digest&lt;/code&gt; &lt;/a&gt; 에서 필터를 실행하는 것보다 성능이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b3df173ca7c9246d6aeebf7b82e7ed92a41a33d7" translate="yes" xml:space="preserve">
          <source>In tests you can use &lt;a href=&quot;../../ngmock/service/%24interval#flush.html&quot;&gt;&lt;code&gt;$interval.flush(millis)&lt;/code&gt;&lt;/a&gt; to move forward by &lt;code&gt;millis&lt;/code&gt; milliseconds and trigger any functions scheduled to run in that time.</source>
          <target state="translated">테스트에서 &lt;a href=&quot;../../ngmock/service/%24interval#flush.html&quot;&gt; &lt;code&gt;$interval.flush(millis)&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;millis&lt;/code&gt; 초 단위 로 앞으로 이동 하고 해당 시간에 실행되도록 예약 된 기능을 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6d6b4db41ec26c414ad5cfb1ba6c62e946416d6" translate="yes" xml:space="preserve">
          <source>In tests you can use &lt;a href=&quot;../../ngmock/service/%24timeout&quot;&gt;&lt;code&gt;$timeout.flush()&lt;/code&gt;&lt;/a&gt; to synchronously flush the queue of deferred functions.</source>
          <target state="translated">테스트에서 &lt;a href=&quot;../../ngmock/service/%24timeout&quot;&gt; &lt;code&gt;$timeout.flush()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 지연된 함수 큐를 동 기적으로 플러시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9afa5f460758c21238a4ac6be52ef14781fd6696" translate="yes" xml:space="preserve">
          <source>In that case, it is necessary to intercept the &lt;em&gt;initial&lt;/em&gt; compilation of the element:</source>
          <target state="translated">이 경우 요소 의 &lt;em&gt;초기&lt;/em&gt; 컴파일 을 가로 챌 필요가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f664cca1d4ca20781d1fa172027d128144824737" translate="yes" xml:space="preserve">
          <source>In the above example &lt;code&gt;SomeClass&lt;/code&gt; is not concerned with creating or locating the &lt;code&gt;greeter&lt;/code&gt; dependency, it is simply handed the &lt;code&gt;greeter&lt;/code&gt; when it is instantiated.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;SomeClass&lt;/code&gt; 는 &lt;code&gt;greeter&lt;/code&gt; 의존성 을 생성하거나 찾는 것과 관련이 없으며 , 인스턴스화 될 때 단순히 &lt;code&gt;greeter&lt;/code&gt; 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="d6351961d5f7c7bedc28b2fb3f9404a2fa13777f" translate="yes" xml:space="preserve">
          <source>In the above example notice that the &lt;code&gt;MyController&lt;/code&gt; assigns &lt;code&gt;World&lt;/code&gt; to the &lt;code&gt;username&lt;/code&gt; property of the scope. The scope then notifies the &lt;code&gt;input&lt;/code&gt; of the assignment, which then renders the input with username pre-filled. This demonstrates how a controller can write data into the scope.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;MyController&lt;/code&gt; 는 범위 의 &lt;code&gt;username&lt;/code&gt; 속성에 &lt;code&gt;World&lt;/code&gt; 를 할당합니다 . 그런 다음 범위 는 할당 의 &lt;code&gt;input&lt;/code&gt; 을 알리고 사용자 이름이 미리 입력 된 입력을 렌더링합니다. 이것은 컨트롤러가 스코프에 데이터를 쓰는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e594bf894541dbfbfa549d5ac280e9f9712c2570" translate="yes" xml:space="preserve">
          <source>In the case of AngularJS' SCE service, one uses &lt;a href=&quot;%24sce#trustAs.html&quot;&gt;$sce.trustAs&lt;/a&gt; (and shorthand methods such as &lt;a href=&quot;%24sce#trustAsHtml.html&quot;&gt;$sce.trustAsHtml&lt;/a&gt;, etc.) to build the trusted versions of your values.</source>
          <target state="translated">AngularJS의 SCE 서비스의 경우, &lt;a href=&quot;%24sce#trustAs.html&quot;&gt;$ sce.trustAs&lt;/a&gt; (및 &lt;a href=&quot;%24sce#trustAsHtml.html&quot;&gt;$ sce.trustAsHtml&lt;/a&gt; 등과 같은 속기 방법 )를 사용하여 신뢰할 수있는 버전의 값을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="959810922e73332af4b6023c346f0a5b1acbe45e" translate="yes" xml:space="preserve">
          <source>In the code above, we see how the &lt;code&gt;apiToken&lt;/code&gt; service is defined via the Factory recipe that depends on the &lt;code&gt;clientId&lt;/code&gt; service. The factory service then uses NSA-proof encryption to produce an authentication token.</source>
          <target state="translated">위의 코드에서 &lt;code&gt;apiToken&lt;/code&gt; 서비스가 &lt;code&gt;clientId&lt;/code&gt; 서비스 에 의존하는 팩토리 레시피를 통해 정의되는 방법을 봅니다 . 팩토리 서비스는 NSA 증명 암호화를 사용하여 인증 토큰을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="84f8e46a5ef8dfd7b5fa4f69ef21284f0f989e10" translate="yes" xml:space="preserve">
          <source>In the example HTML code above the message that is set on required will override the corresponding required message defined within the remote template. Therefore, with particular input fields (such email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied while more generic messages can be used to handle other, more general input errors.</source>
          <target state="translated">위의 HTML 코드 예제에서 required로 설정된 메시지는 원격 템플릿 내에 정의 된 해당 필수 메시지를 무시합니다. 따라서 특정 입력 필드 (예 : 전자 메일 주소, 날짜 필드, 자동 완성 입력 등)를 사용하면 특수한 오류 메시지를 적용 할 수 있고보다 일반적인 메시지를 사용하여보다 일반적인 다른 입력 오류를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="fd65d4b7c7659da1f46b3e642c3fddcc6b9572ba" translate="yes" xml:space="preserve">
          <source>In the example above we in-lined the value of the &lt;code&gt;template&lt;/code&gt; option, but this will become annoying as the size of your template grows.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;template&lt;/code&gt; 옵션 의 값을 인라인으로 표시했지만 템플릿 크기가 커짐에 따라 이는 성 가실 것입니다.</target>
        </trans-unit>
        <trans-unit id="4ea40c9ac185962c5537c5bf56297794190e4724" translate="yes" xml:space="preserve">
          <source>In the example above: The template contains the directive &lt;code&gt;ng-app=&quot;invoice2&quot;&lt;/code&gt;. This tells AngularJS to use the &lt;code&gt;invoice2&lt;/code&gt; module as the main module for the application. The code snippet &lt;code&gt;angular.module('invoice2', ['finance2'])&lt;/code&gt; specifies that the &lt;code&gt;invoice2&lt;/code&gt; module depends on the &lt;code&gt;finance2&lt;/code&gt; module. By this, AngularJS uses the &lt;code&gt;InvoiceController&lt;/code&gt; as well as the &lt;code&gt;currencyConverter&lt;/code&gt; service.</source>
          <target state="translated">위의 예에서 : 템플릿에는 지시문 &lt;code&gt;ng-app=&quot;invoice2&quot;&lt;/code&gt; 가 포함되어 있습니다 . 이것은 AngularJS가 &lt;code&gt;invoice2&lt;/code&gt; 모듈을 애플리케이션의 기본 모듈로 사용하도록 지시 합니다. 코드 스 니펫 &lt;code&gt;angular.module('invoice2', ['finance2'])&lt;/code&gt; 는 &lt;code&gt;invoice2&lt;/code&gt; 모듈 이 finance2 모듈에 종속되도록 &lt;code&gt;finance2&lt;/code&gt; 합니다. 이를 통해 AngularJS는 &lt;code&gt;InvoiceController&lt;/code&gt; 와 &lt;code&gt;currencyConverter&lt;/code&gt; 서비스를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="06c6dacfa62f890f4ce330dacbb04a271d1a5f52" translate="yes" xml:space="preserve">
          <source>In the example below if the &lt;code&gt;ngApp&lt;/code&gt; directive were not placed on the &lt;code&gt;html&lt;/code&gt; element then the document would not be compiled, the &lt;code&gt;AppController&lt;/code&gt; would not be instantiated and the &lt;code&gt;{{ a+b }}&lt;/code&gt; would not be resolved to &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">아래 예제에서 &lt;code&gt;ngApp&lt;/code&gt; 지시문이 &lt;code&gt;html&lt;/code&gt; 요소에 없으면 문서가 컴파일 되지 않고 &lt;code&gt;AppController&lt;/code&gt; 가 인스턴스화되지 않고 &lt;code&gt;{{ a+b }}&lt;/code&gt; 가 &lt;code&gt;3&lt;/code&gt; 으로 해석되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f0733690aa73762a66daf4ab130eb29e196bfdd6" translate="yes" xml:space="preserve">
          <source>In the example below we are testing a service that takes a long time to generate its answer. To avoid having all of the assertions we want to write in a single test case, &lt;a href=&quot;../api/ngmock/function/angular.mock.module.sharedinjector&quot;&gt;module.sharedInjector()&lt;/a&gt; and Jasmine's &lt;code&gt;beforeAll()&lt;/code&gt; are used to run the service only once. The test cases then all make assertions about the properties added to the service instance.</source>
          <target state="translated">아래 예에서는 응답을 생성하는 데 시간이 오래 걸리는 서비스를 테스트하고 있습니다. 단일 테스트 사례에서 작성하려는 모든 어설 션을 피하기 위해 &lt;a href=&quot;../api/ngmock/function/angular.mock.module.sharedinjector&quot;&gt;module.sharedInjector ()&lt;/a&gt; 및 Jasmine의 &lt;code&gt;beforeAll()&lt;/code&gt; 을 사용하여 서비스를 한 번만 실행합니다. 테스트 사례는 모두 서비스 인스턴스에 추가 된 속성에 대한 어설 션을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bab3c31c5347dae0fee8eb746e2e91d85348416e" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;&quot;0: Nobody is viewing.&quot;&lt;/code&gt; is an explicit number rule. If you did not specify this rule, 0 would be matched to the &quot;other&quot; category and &quot;0 people are viewing&quot; would be shown instead of &quot;Nobody is viewing&quot;. You can specify an explicit number rule for other numbers, for example 12, so that instead of showing &quot;12 people are viewing&quot;, you can show &quot;a dozen people are viewing&quot;.</source>
          <target state="translated">이 예에서는 &lt;code&gt;&quot;0: Nobody is viewing.&quot;&lt;/code&gt; 명시적인 숫자 규칙입니다. 이 규칙을 지정하지 않으면 &quot;다른 사람&quot;범주와 0이 일치하고 &quot;아무도보고 있지 않음&quot;대신 &quot;0 명이보고 있습니다&quot;가 표시됩니다. 다른 숫자 (예 : 12)에 대해 명시적인 숫자 규칙을 지정할 수 있으므로 &quot;12 명이보고 있습니다&quot;를 표시하는 대신 &quot;수십명이보고 있습니다&quot;를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9240f6b392f9f24d3f0cc0e6e9f1b6f87bdaa61f" translate="yes" xml:space="preserve">
          <source>In the example, note that:</source>
          <target state="translated">이 예에서는 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="84ff38ef3acedf57990298f438e0044989906ff2" translate="yes" xml:space="preserve">
          <source>In the following example a new block of HTML containing a &lt;code&gt;ng-controller&lt;/code&gt; directive is added to the end of the document body by JQuery. We then compile and link it into the current AngularJS scope.</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;ng-controller&lt;/code&gt; 지시문이 포함 된 새로운 HTML 블록이 JQuery에 의해 문서 본문 끝에 추가됩니다. 그런 다음 컴파일하여 현재 AngularJS 범위에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="e5310456ee5d9fc9becb78c6016bab204fd72bf8" translate="yes" xml:space="preserve">
          <source>In the following example we create two directives:</source>
          <target state="translated">다음 예제에서는 두 개의 지시문을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e5133af465b2e35bb8a87b952a090800d0de494d" translate="yes" xml:space="preserve">
          <source>In the following example we will build a form to calculate the costs of an invoice in different currencies.</source>
          <target state="translated">다음 예에서는 송장 비용을 다른 통화로 계산하는 양식을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="77918f42e8ba84df32a20e6ed8fa56c3f1646559" translate="yes" xml:space="preserve">
          <source>In the following example, the interpolation information would be ignored and the browser would simply interpret the attribute as present, meaning that the button would always be disabled.</source>
          <target state="translated">다음 예제에서 보간 정보는 무시되고 브라우저는 단순히 속성을 존재하는 것으로 해석하므로 버튼이 항상 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="efef16f2696255d51f1a599a09667ffbb53142df" translate="yes" xml:space="preserve">
          <source>In the following example, we say that the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element &lt;strong&gt;matches&lt;/strong&gt; the &lt;code&gt;ngModel&lt;/code&gt; directive</source>
          <target state="translated">다음 예제에서는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 가 &lt;code&gt;ngModel&lt;/code&gt; 지시문 &lt;strong&gt;과 일치&lt;/strong&gt; 한다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="79560f8749a4459cf00c1e8ac63200d2b09c35ab" translate="yes" xml:space="preserve">
          <source>In the link function, link the compiled element with the element's scope.</source>
          <target state="translated">링크 함수에서 컴파일 된 요소를 요소의 범위와 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="cae02af11dc52e4c34dfd155a0e09f2c35b21656" translate="yes" xml:space="preserve">
          <source>In the new JavaScript file we are also creating a &lt;a href=&quot;concepts#module.html&quot;&gt;module&lt;/a&gt; at which we register the controller. We will talk about modules in the next section.</source>
          <target state="translated">새로운 JavaScript 파일에서 우리는 컨트롤러를 등록 할 &lt;a href=&quot;concepts#module.html&quot;&gt;모듈&lt;/a&gt; 을 만들고 있습니다. 다음 섹션에서 모듈에 대해 이야기하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ddb9bac8dbb551492f9275fbd24cd7951d7d8c0c" translate="yes" xml:space="preserve">
          <source>In these examples we use &lt;code&gt;&amp;lt;base href=&quot;/base/index.html&quot; /&amp;gt;&lt;/code&gt;. The inputs represent the address bar of the browser.</source>
          <target state="translated">이 예에서는 &lt;code&gt;&amp;lt;base href=&quot;/base/index.html&quot; /&amp;gt;&lt;/code&gt; 합니다. 입력은 브라우저의 주소 표시 줄을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b67dc576ed7fd6345e84f4eb6c7018ca4bfbcc4f" translate="yes" xml:space="preserve">
          <source>In this case, you can use &lt;code&gt;$rollbackViewValue()&lt;/code&gt; to manually cancel the debounced / future update and reset the input to the last committed view value.</source>
          <target state="translated">이 경우 &lt;code&gt;$rollbackViewValue()&lt;/code&gt; 를 사용 하여 디 바운스 / 향후 업데이트를 수동으로 취소하고 입력을 마지막 커밋 된보기 값으로 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6505ab30bfaaaac0b15030b3f3986050a80340d6" translate="yes" xml:space="preserve">
          <source>In this case, you need to override the default currency symbol by providing the &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;&lt;code&gt;currency&lt;/code&gt;&lt;/a&gt; currency filter with a currency symbol as a parameter.</source>
          <target state="translated">이 경우 &lt;a href=&quot;../api/ng/filter/currency&quot;&gt; &lt;code&gt;currency&lt;/code&gt; &lt;/a&gt; 통화 필터에 통화 기호를 매개 변수로 제공하여 기본 통화 기호를 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="14e832106d47cd2398f7a2e9a5e870b31e8b80af" translate="yes" xml:space="preserve">
          <source>In this example there are two locations where a simple interpolation binding (&lt;code&gt;{{}}&lt;/code&gt;) is present, but the one wrapped in &lt;code&gt;ngNonBindable&lt;/code&gt; is left alone.</source>
          <target state="translated">이 예제에는 간단한 보간 바인딩 ( &lt;code&gt;{{}}&lt;/code&gt; )이 존재하지만 &lt;code&gt;ngNonBindable&lt;/code&gt; 로 랩핑 된 위치는 두 개만 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d3a54eba3caaff060cebf9bc0469b28b7141602" translate="yes" xml:space="preserve">
          <source>In this example we create a custom method on our resource to make a PUT request:</source>
          <target state="translated">이 예에서는 PUT 요청을 만들기 위해 리소스에 사용자 정의 메소드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6899b61e7576501948474a864710fc73cabc4d8a" translate="yes" xml:space="preserve">
          <source>In this example we will build a directive that displays the current time. Once a second, it updates the DOM to reflect the current time.</source>
          <target state="translated">이 예에서는 현재 시간을 표시하는 지시문을 작성합니다. 1 초에 한 번씩 DOM을 업데이트하여 현재 시간을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="4439980cd7f8e616e932b5cf07209756402b8a31" translate="yes" xml:space="preserve">
          <source>In this example, we've used the Value recipe to define the value to provide when &lt;code&gt;DemoController&lt;/code&gt; asks for the service with id &quot;clientId&quot;.</source>
          <target state="translated">이 예제에서는 Value 레시피를 사용하여 &lt;code&gt;DemoController&lt;/code&gt; 가 ID가 &quot;clientId&quot;인 서비스를 요청할 때 제공 할 값을 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="7a7d32308b0ce66221de3ff0ef1900cca2184aa8" translate="yes" xml:space="preserve">
          <source>In this mode, &lt;code&gt;$location&lt;/code&gt; uses Hashbang URLs in all browsers. AngularJS also does not intercept and rewrite links in this mode. I.e. links work as expected and also perform full page reloads when other parts of the url than the hash fragment was changed.</source>
          <target state="translated">이 모드에서 &lt;code&gt;$location&lt;/code&gt; 은 모든 브라우저에서 Hashbang URL을 사용합니다. AngularJS는이 모드에서 링크를 가로 채거나 다시 쓰지 않습니다. 즉, 링크가 예상대로 작동하고 해시 조각 이외의 URL의 다른 부분이 변경되면 전체 페이지 다시로드를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5becec1b89211dd88c512f01dd020136e19e6976" translate="yes" xml:space="preserve">
          <source>In this scenario the ordering of the values in the &lt;code&gt;$inject&lt;/code&gt; array must match the ordering of the parameters in &lt;code&gt;MyController&lt;/code&gt;.</source>
          <target state="translated">이 시나리오에서 &lt;code&gt;$inject&lt;/code&gt; 배열 의 값 순서는 &lt;code&gt;MyController&lt;/code&gt; 의 매개 변수 순서와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="13f2a9a690a1e6a57d2a22be202ab6f40a5e27bc" translate="yes" xml:space="preserve">
          <source>In unit tests, if &lt;code&gt;angular-mocks.js&lt;/code&gt; is loaded, this service is overridden by &lt;a href=&quot;../../ngmock/service/%24exceptionhandler&quot;&gt;mock $exceptionHandler&lt;/a&gt; which aids in testing.</source>
          <target state="translated">단위 테스트에서 &lt;code&gt;angular-mocks.js&lt;/code&gt; 가로 드되면 테스트를 지원 하는 &lt;a href=&quot;../../ngmock/service/%24exceptionhandler&quot;&gt;mock $ exceptionHandler&lt;/a&gt; 가이 서비스를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="f65268ee4fca5a690bd7ec3d41fb1bec92988ebd" translate="yes" xml:space="preserve">
          <source>In unit tests, you may need to call &lt;code&gt;$digest()&lt;/code&gt; to simulate the scope life cycle.</source>
          <target state="translated">단위 테스트에서는 &lt;code&gt;$digest()&lt;/code&gt; 를 호출 하여 범위 수명주기를 시뮬레이션 해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1175103ab9a357b144d5afd8b6a34c7357be8f89" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;angular_1_router.js&lt;/code&gt; in your HTML:</source>
          <target state="translated">HTML에 &lt;code&gt;angular_1_router.js&lt;/code&gt; 를 포함 시키십시오 :</target>
        </trans-unit>
        <trans-unit id="eee121d0108cf587e09cedc45732972ef8bcd660" translate="yes" xml:space="preserve">
          <source>Including ngAria</source>
          <target state="translated">ngAria 포함</target>
        </trans-unit>
        <trans-unit id="97ab23190c81b3035d6f0736f1e943af6dedb556" translate="yes" xml:space="preserve">
          <source>Including the &lt;code&gt;angular-mocks.js&lt;/code&gt; file automatically adds the &lt;code&gt;ngMock&lt;/code&gt; module, so your tests are ready to go!</source>
          <target state="translated">&lt;code&gt;angular-mocks.js&lt;/code&gt; 파일을 포함하면 &lt;code&gt;ngMock&lt;/code&gt; 모듈이 자동으로 추가 되므로 테스트를 시작할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="022e67bfe4c9d31f23e277e933c1ffc2d7b2553f" translate="yes" xml:space="preserve">
          <source>Incorrect scope on replaced element: &lt;a href=&quot;https://github.com/angular/angular.js/issues/9837&quot;&gt;#9837&lt;/a&gt;</source>
          <target state="translated">교체 된 요소에 잘못된 범위 : &lt;a href=&quot;https://github.com/angular/angular.js/issues/9837&quot;&gt;# 9837&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bc6cb47d35d34b7a2afa7d59d3ad1affaa2fd4d" translate="yes" xml:space="preserve">
          <source>Increasing the TTL could have performance implications, so you should not change it without proper justification.</source>
          <target state="translated">TTL을 늘리면 성능에 영향을 줄 수 있으므로 적절한 근거없이 변경하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fe65a117b989a572706242b27f193dcbfe4cccb2" translate="yes" xml:space="preserve">
          <source>Index at which to begin limitation. As a negative index, &lt;code&gt;begin&lt;/code&gt; indicates an offset from the end of &lt;code&gt;input&lt;/code&gt;. Defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">제한을 시작할 인덱스. 음의 인덱스 인 &lt;code&gt;begin&lt;/code&gt; 은 &lt;code&gt;input&lt;/code&gt; 끝에서 오프셋을 나타냅니다 . 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be561e9cda308e941f15c8f2d92167d741116500" translate="yes" xml:space="preserve">
          <source>Inference</source>
          <target state="translated">Inference</target>
        </trans-unit>
        <trans-unit id="e3429591e14050c72d5c0051bbbbd1a28af8277c" translate="yes" xml:space="preserve">
          <source>Information about the module</source>
          <target state="translated">모듈에 대한 정보</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="5dfb1d0123ddef5f4f1709bff3cd4b6a227f90d4" translate="yes" xml:space="preserve">
          <source>Inheritance works with methods in the same way as it does with properties. So in our previous examples, all of the properties could be replaced with methods that return string values.</source>
          <target state="translated">상속은 속성과 같은 방식으로 메서드와 함께 작동합니다. 이전 예제에서 모든 속성은 문자열 값을 반환하는 메서드로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0ccb7ae52acb2325f9958f72c6588fcb209c80" translate="yes" xml:space="preserve">
          <source>Inheriting Options</source>
          <target state="translated">상속 옵션</target>
        </trans-unit>
        <trans-unit id="96a10dd68557ab7a42e636872dcf0b6dfbfa7c5b" translate="yes" xml:space="preserve">
          <source>Injection Function Annotation</source>
          <target state="translated">주입 함수 주석</target>
        </trans-unit>
        <trans-unit id="a9fff665a0f0f15d16e0d15e587df45688563f62" translate="yes" xml:space="preserve">
          <source>Injection locals for Controller.</source>
          <target state="translated">컨트롤러 용 주입 로컬.</target>
        </trans-unit>
        <trans-unit id="2ca8a0d344a0e19a0d77c7ff904b9681383397eb" translate="yes" xml:space="preserve">
          <source>Injector</source>
          <target state="translated">Injector</target>
        </trans-unit>
        <trans-unit id="79f0f713c81b40636682b05fc5367727bac538b1" translate="yes" xml:space="preserve">
          <source>Injector API</source>
          <target state="translated">인젝터 API</target>
        </trans-unit>
        <trans-unit id="14473111235c870eaff95fa0c0269e33135347df" translate="yes" xml:space="preserve">
          <source>Injector object. See &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;.</source>
          <target state="translated">인젝터 객체. &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e347f4ceb23a6d8637cc8028fda9ad8c7b7c47f" translate="yes" xml:space="preserve">
          <source>Inline</source>
          <target state="translated">Inline</target>
        </trans-unit>
        <trans-unit id="925743fe777d805151236206dc7c89eab96a1877" translate="yes" xml:space="preserve">
          <source>Inline Array Annotation</source>
          <target state="translated">인라인 배열 주석</target>
        </trans-unit>
        <trans-unit id="6b04e7cb97df1376cafddfa71719f04eb50b9a6e" translate="yes" xml:space="preserve">
          <source>Input elements using ngModelController do this automatically when they are destroyed.</source>
          <target state="translated">ngModelController를 사용하는 입력 요소는 파괴 될 때이를 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="746797b58353ee493a111e047d8432803b2bf4f0" translate="yes" xml:space="preserve">
          <source>Input text.</source>
          <target state="translated">텍스트를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="5e4c6a9c5fc75d66498cf6d23beea81ac1405c3b" translate="yes" xml:space="preserve">
          <source>Input to be serialized into JSON.</source>
          <target state="translated">JSON으로 직렬화 할 입력입니다.</target>
        </trans-unit>
        <trans-unit id="36c92f17e709bebc8508b025911cc23c819f2bdc" translate="yes" xml:space="preserve">
          <source>Input to filter.</source>
          <target state="translated">필터 입력.</target>
        </trans-unit>
        <trans-unit id="b469f7b387e7ea5a8aa43ef249909abf751dad91" translate="yes" xml:space="preserve">
          <source>Input with date validation and transformation. In browsers that do not yet support the HTML5 date input, a text element will be used. In that case, text must be entered in a valid ISO-8601 date format (yyyy-MM-dd), for example: &lt;code&gt;2009-01-06&lt;/code&gt;. Since many modern browsers do not yet support this input type, it is important to provide cues to users on the expected input format via a placeholder or label.</source>
          <target state="translated">날짜 유효성 검사 및 변환으로 입력합니다. 아직 HTML5 날짜 입력을 지원하지 않는 브라우저에서는 텍스트 요소가 사용됩니다. 이 경우 텍스트는 유효한 ISO-8601 날짜 형식 (yyyy-MM-dd)으로 입력해야합니다 (예 : &lt;code&gt;2009-01-06&lt;/code&gt; ) . 많은 최신 브라우저가 아직이 입력 유형을 지원하지 않기 때문에 자리 표시 자 또는 레이블을 통해 예상되는 입력 형식에 대한 단서를 사용자에게 제공하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="368b3f90c079e89422060af3560495bdef962d93" translate="yes" xml:space="preserve">
          <source>Input with datetime validation and transformation. In browsers that do not yet support the HTML5 date input, a text element will be used. In that case, the text must be entered in a valid ISO-8601 local datetime format (yyyy-MM-ddTHH:mm:ss), for example: &lt;code&gt;2010-12-28T14:57:00&lt;/code&gt;.</source>
          <target state="translated">날짜 시간 유효성 검사 및 변환으로 입력합니다. 아직 HTML5 날짜 입력을 지원하지 않는 브라우저에서는 텍스트 요소가 사용됩니다. 이 경우 텍스트는 유효한 ISO-8601 로컬 날짜 시간 형식 (yyyy-MM-ddTHH : mm : ss)으로 입력해야합니다 (예 : &lt;code&gt;2010-12-28T14:57:00&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="f055ea0fb91bafd4e2519ef585345bddd83e494f" translate="yes" xml:space="preserve">
          <source>Input with month validation and transformation. In browsers that do not yet support the HTML5 month input, a text element will be used. In that case, the text must be entered in a valid ISO-8601 month format (yyyy-MM), for example: &lt;code&gt;2009-01&lt;/code&gt;.</source>
          <target state="translated">월 유효성 검사 및 변환으로 입력합니다. 아직 HTML5 월 입력을 지원하지 않는 브라우저에서는 텍스트 요소가 사용됩니다. 이 경우 텍스트는 유효한 ISO-8601 월 형식 (yyyy-MM)으로 입력해야합니다 (예 : &lt;code&gt;2009-01&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="2d19ccf55a4ce32c01abc960d0eb8d89049b6ff3" translate="yes" xml:space="preserve">
          <source>Input with time validation and transformation. In browsers that do not yet support the HTML5 time input, a text element will be used. In that case, the text must be entered in a valid ISO-8601 local time format (HH:mm:ss), for example: &lt;code&gt;14:57:00&lt;/code&gt;. Model must be a Date object. This binding will always output a Date object to the model of January 1, 1970, or local date &lt;code&gt;new Date(1970, 0, 1, HH, mm, ss)&lt;/code&gt;.</source>
          <target state="translated">시간 검증 및 변환을 통한 입력. HTML5 시간 입력을 아직 지원하지 않는 브라우저에서는 텍스트 요소가 사용됩니다. 이 경우 텍스트는 유효한 ISO-8601 현지 시간 형식 (HH : mm : ss)으로 입력해야합니다 (예 : &lt;code&gt;14:57:00&lt;/code&gt; ) . 모델은 날짜 개체 여야합니다. 이 바인딩은 항상 1970 년 1 월 1 일의 모델 또는 지역 날짜 &lt;code&gt;new Date(1970, 0, 1, HH, mm, ss)&lt;/code&gt; Date 객체를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="87b35cff3f70eb2b5963a0cee4a1695a8c2487fc" translate="yes" xml:space="preserve">
          <source>Input with week-of-the-year validation and transformation to Date. In browsers that do not yet support the HTML5 week input, a text element will be used. In that case, the text must be entered in a valid ISO-8601 week format (yyyy-W##), for example: &lt;code&gt;2013-W02&lt;/code&gt;.</source>
          <target state="translated">연중 주 유효성 검사 및 날짜로의 변환으로 입력합니다. 아직 HTML5 주 입력을 지원하지 않는 브라우저에서는 텍스트 요소가 사용됩니다. 이 경우 텍스트는 유효한 ISO-8601 주 형식 (yyyy-W ##)으로 입력해야합니다 (예 : &lt;code&gt;2013-W02&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="8623e06b7bf838dfcd7440cde11477a28bd943b1" translate="yes" xml:space="preserve">
          <source>Inputs should be using &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; bindings. The &lt;code&gt;&amp;lt;&lt;/code&gt; symbol denotes &lt;a href=&quot;../api/ng/service/%24compile#-scope-.html&quot;&gt;one-way bindings&lt;/a&gt; which are available since 1.5. The difference to &lt;code&gt;=&lt;/code&gt; is that the bound properties in the component scope are not watched, which means if you assign a new value to the property in the component scope, it will not update the parent scope. Note however, that both parent and component scope reference the same object, so if you are changing object properties or array elements in the component, the parent will still reflect that change. The general rule should therefore be to never change an object or array property in the component scope. &lt;code&gt;@&lt;/code&gt; bindings can be used when the input is a string, especially when the value of the binding doesn't change.</source>
          <target state="translated">입력은 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 바인딩을 사용해야합니다 . &lt;code&gt;&amp;lt;&lt;/code&gt; 기호는 의미 &lt;a href=&quot;../api/ng/service/%24compile#-scope-.html&quot;&gt;단방향 바인딩&lt;/a&gt; 1.5부터 사용할 수 있습니다. &lt;code&gt;=&lt;/code&gt; 와의 차이점 은 구성 요소 범위의 바운드 속성이 감시되지 않는다는 것입니다. 즉, 구성 요소 범위의 속성에 새 값을 할당하면 부모 범위가 업데이트되지 않습니다. 그러나 부모 및 구성 요소 범위는 모두 동일한 개체를 참조하므로 구성 요소에서 개체 속성 또는 배열 요소를 변경하는 경우에도 부모는 해당 변경 사항을 반영합니다. 따라서 일반적인 규칙은 구성 요소 범위에서 객체 또는 배열 속성을 절대 변경하지 않아야합니다. &lt;code&gt;@&lt;/code&gt; 입력이 문자열 인 경우, 특히 바인딩 값이 변경되지 않는 경우 바인딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e52682fa7935f8560c99962baa2e9b2e2f695aa" translate="yes" xml:space="preserve">
          <source>Inserts (moves) the element into its new position in the DOM either after the &lt;code&gt;after&lt;/code&gt; element (if provided) or as the first child within the &lt;code&gt;parent&lt;/code&gt; element and then triggers an animation. A promise is returned that will be resolved during the next digest once the animation has completed.</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 요소 이후 (제공된 경우) 또는 &lt;code&gt;parent&lt;/code&gt; 요소 내의 첫 번째 하위 요소로 요소를 DOM의 새 위치에 삽입 (이동) 한 다음 애니메이션을 트리거합니다. 애니메이션이 완료되면 다음 다이제스트 중에 해결 될 약속이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9d08db8a2f848ef678473f1e8f3fc6d65efc3930" translate="yes" xml:space="preserve">
          <source>Inserts a named entry into the &lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; object to be retrieved later, and incrementing the size of the cache if the key was not already present in the cache. If behaving like an LRU cache, it will also remove stale entries from the set.</source>
          <target state="translated">키를 캐시에 아직없는 경우 나중에 검색 할 이름 지정된 항목을 &lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; 객체에 삽입하고 캐시 크기를 증가시킵니다. LRU 캐시처럼 작동하면 세트에서 오래된 항목도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b56347e262d3cfcb832a5204694e59add55e7c8a" translate="yes" xml:space="preserve">
          <source>Inserts the element into the DOM either after the &lt;code&gt;after&lt;/code&gt; element (if provided) or as the first child within the &lt;code&gt;parent&lt;/code&gt; element and then triggers an animation. A promise is returned that will be resolved during the next digest once the animation has completed.</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 요소 뒤 (제공된 경우) 또는 &lt;code&gt;parent&lt;/code&gt; 요소 내의 첫 번째 자식으로 요소를 DOM에 삽입 한 다음 애니메이션을 트리거합니다. 애니메이션이 완료되면 다음 다이제스트 중에 해결 될 약속이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4a974602fd15a3bb043838c33a55716734438b42" translate="yes" xml:space="preserve">
          <source>Inside this directive's compile function, add any other directive attributes to the template.</source>
          <target state="translated">이 지시문의 컴파일 함수 내에서 다른 지시문 속성을 템플리트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="8282d74914fee52414c245630944283136d0ee0c" translate="yes" xml:space="preserve">
          <source>Instance of given controller.</source>
          <target state="translated">주어진 컨트롤러의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="062b9f18d0fd09a55820ed08041572545f617364" translate="yes" xml:space="preserve">
          <source>Instance of requested controller.</source>
          <target state="translated">요청 된 컨트롤러의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="211f21858ca1d5311a2538cd51c3ed72a3d7a141" translate="yes" xml:space="preserve">
          <source>Instantiating &lt;code&gt;$route&lt;/code&gt; early is necessary for capturing the initial &lt;a href=&quot;../../ng/service/%24location#%24locationChangeStart.html&quot;&gt;$locationChangeStart&lt;/a&gt; event and navigating to the appropriate route. Usually, &lt;code&gt;$route&lt;/code&gt; is instantiated in time by the &lt;a href=&quot;../directive/ngview&quot;&gt;ngView&lt;/a&gt; directive. Yet, in cases where &lt;code&gt;ngView&lt;/code&gt; is included in an asynchronously loaded template (e.g. in another directive's template), the directive factory might not be called soon enough for &lt;code&gt;$route&lt;/code&gt; to be instantiated &lt;em&gt;before&lt;/em&gt; the initial &lt;code&gt;$locationChangeSuccess&lt;/code&gt; event is fired. Eager instantiation ensures that &lt;code&gt;$route&lt;/code&gt; is always instantiated in time, regardless of when &lt;code&gt;ngView&lt;/code&gt; will be loaded.</source>
          <target state="translated">초기 &lt;a href=&quot;../../ng/service/%24location#%24locationChangeStart.html&quot;&gt;$ locationChangeStart&lt;/a&gt; 이벤트 를 캡처 하고 적절한 경로를 탐색하려면 &lt;code&gt;$route&lt;/code&gt; 조기에 인스턴스화 해야 합니다. 일반적으로 &lt;code&gt;$route&lt;/code&gt; 는 &lt;a href=&quot;../directive/ngview&quot;&gt;ngView&lt;/a&gt; 지시문으로 시간에 인스턴스화됩니다 . 그러나 &lt;code&gt;ngView&lt;/code&gt; 가 비동기 적으로로드 된 템플릿 (예 : 다른 지시문의 템플릿)에 포함 된 경우 초기 &lt;code&gt;$locationChangeSuccess&lt;/code&gt; 이벤트가 시작 &lt;em&gt;되기 전에 &lt;/em&gt; &lt;code&gt;$route&lt;/code&gt; 를 인스턴스화 할 수 있도록 지시문 팩토리가 곧 호출되지 않을 수 있습니다 . 빠른 인스턴스화는 &lt;code&gt;ngView&lt;/code&gt; 가 언제로드 되는지에 관계없이 &lt;code&gt;$route&lt;/code&gt; 가 항상 제 시간에 인스턴스화되도록 합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d3a7f6588b1415794dfce3d5d197e1c86baed2d" translate="yes" xml:space="preserve">
          <source>Instead of an ngController, we now have a heroList component that holds the data of different heroes, and creates a heroDetail for each of them.</source>
          <target state="translated">ngController 대신 다른 영웅의 데이터를 보유하고 각각에 대해 heroDetail을 만드는 heroList 구성 요소가 생겼습니다.</target>
        </trans-unit>
        <trans-unit id="6f3dfbdc7d4af7c104dfa249eb6020271af2c661" translate="yes" xml:space="preserve">
          <source>Instead of manipulating Input Data, the component calls the correct Output Event with the changed data. For a deletion, that means the component doesn't delete the &lt;code&gt;hero&lt;/code&gt; itself, but sends it back to the owner component via the correct event.</source>
          <target state="translated">입력 데이터를 조작하는 대신 컴포넌트는 변경된 데이터를 사용하여 올바른 출력 이벤트를 호출합니다. 삭제의 경우 구성 요소가 &lt;code&gt;hero&lt;/code&gt; 자체를 삭제하지 않고 올바른 이벤트를 통해 소유자 구성 요소로 다시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="83be5bd3ffd4491816aabd2cd39c2c3b9c8878ac" translate="yes" xml:space="preserve">
          <source>Instead the &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt; directive compiles &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; separately. The result of the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element compilation is a linking function which contains all of the directives contained in the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element, ready to be attached to a specific clone of the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">대신 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; &lt;/a&gt; 지시문은 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 를 개별적으로 컴파일합니다 . 의 결과 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소는 컴파일에 포함 된 지시자를 모두 포함하는 연결기 함수 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 준비 요소의 특정 복제에 부착 될 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="633968d37033cd055bb2eb774fd1e896dbbc403f" translate="yes" xml:space="preserve">
          <source>Instead use services like &lt;code&gt;$window&lt;/code&gt; and &lt;code&gt;$location&lt;/code&gt; in functions on controllers, which are then called from expressions. Such services provide mockable access to globals.</source>
          <target state="translated">대신 컨트롤러의 함수에서 &lt;code&gt;$window&lt;/code&gt; 및 &lt;code&gt;$location&lt;/code&gt; 과 같은 서비스를 사용하면 식에서 호출됩니다. 이러한 서비스는 전 세계에 대한 모의 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e907f4bb49fd3c2e897bc3769f08b3d04e07eddb" translate="yes" xml:space="preserve">
          <source>Integration with the browser event loop</source>
          <target state="translated">브라우저 이벤트 루프와 통합</target>
        </trans-unit>
        <trans-unit id="f9c3ced7a72c2e86229aee91105ee78487714dbb" translate="yes" xml:space="preserve">
          <source>Interceptors</source>
          <target state="translated">Interceptors</target>
        </trans-unit>
        <trans-unit id="9db23e6c66b8f703c4c5170aac080107d2e70814" translate="yes" xml:space="preserve">
          <source>Interceptors detailed info</source>
          <target state="translated">인터셉터 상세 정보</target>
        </trans-unit>
        <trans-unit id="9ce9437cbc666edc9eb9fcee34199bb7906c0c55" translate="yes" xml:space="preserve">
          <source>Intercomponent Communication</source>
          <target state="translated">컴포넌트 간 통신</target>
        </trans-unit>
        <trans-unit id="062715707c7ec1cacc1e15b12597b7e7f10f0e06" translate="yes" xml:space="preserve">
          <source>Interface for configuring AngularJS &lt;a href=&quot;../function/angular.module&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">AngularJS &lt;a href=&quot;../function/angular.module&quot;&gt;모듈&lt;/a&gt; 구성을위한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="e4d32358862ac0edaba0242863407cf48322048c" translate="yes" xml:space="preserve">
          <source>Interface for configuring AngularJS &lt;a href=&quot;function/angular.module&quot;&gt;modules&lt;/a&gt;.</source>
          <target state="translated">AngularJS &lt;a href=&quot;function/angular.module&quot;&gt;모듈&lt;/a&gt; 구성을위한 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="ecd5ccdaf3148a44137ddcbe0c56ca93bd059aa4" translate="yes" xml:space="preserve">
          <source>Internally it looks a bit like this:</source>
          <target state="translated">내부적으로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b741cdf9b58113f65f5de5d9a4967edb5170093" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;ngAnimate&lt;/code&gt; waits until all template downloads that are started right after bootstrap have finished. Then, it waits for the currently running &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; and one more after that, to finish. This ensures that the whole app has been compiled fully before animations are attempted.</source>
          <target state="translated">내부적으로 &lt;code&gt;ngAnimate&lt;/code&gt; 는 부트 스트랩이 완료된 직후 시작된 모든 템플릿 다운로드가 완료 될 때까지 기다립니다. 그런 다음 현재 실행중인 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$ digest를&lt;/a&gt; 기다렸다가 그 후에 한 번 더 기다립니다 . 이렇게하면 애니메이션을 시도하기 전에 전체 앱이 완전히 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="22c5f10ca7f996927beededd6dc71f14380c408d" translate="yes" xml:space="preserve">
          <source>Internationalization (i18n) is the process of developing products in such a way that they can be localized for languages and cultures easily. Localization (l10n), is the process of adapting applications and text to enable their usability in a particular cultural or linguistic market. For application developers, internationalizing an application means abstracting all of the strings and other locale-specific bits (such as date or currency formats) out of the application. Localizing an application means providing translations and localized formats for the abstracted bits.</source>
          <target state="translated">국제화 (i18n)는 언어 및 문화에 맞게 쉽게 현지화 할 수있는 방식으로 제품을 개발하는 프로세스입니다. 현지화 (l10n)는 특정 문화 또는 언어 시장에서 유용성을 발휘할 수 있도록 응용 프로그램 및 텍스트를 조정하는 프로세스입니다. 응용 프로그램 개발자에게 응용 프로그램을 국제화한다는 것은 응용 프로그램에서 모든 문자열 및 기타 로캘 별 비트 (예 : 날짜 또는 통화 형식)를 추상화하는 것을 의미합니다. 응용 프로그램을 지역화한다는 것은 추상화 된 비트에 대한 번역 및 지역화 된 형식을 제공하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="627598da36f0488e21c56b4623e3c3ac29134995" translate="yes" xml:space="preserve">
          <source>Internet Explorer and Edge do not support the &lt;code&gt;details&lt;/code&gt; element, it is recommended to use &lt;a href=&quot;ngshow&quot;&gt;&lt;code&gt;ngShow&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;nghide&quot;&gt;&lt;code&gt;ngHide&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Internet Explorer 및 Edge는 &lt;code&gt;details&lt;/code&gt; 요소를 지원하지 않으므로 대신 &lt;a href=&quot;ngshow&quot;&gt; &lt;code&gt;ngShow&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;nghide&quot;&gt; &lt;code&gt;ngHide&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="3da05a3ab5e77c32bfb542c759dbb3b2f9921337" translate="yes" xml:space="preserve">
          <source>Interpolation markup with embedded &lt;a href=&quot;expression&quot;&gt;expressions&lt;/a&gt; is used by AngularJS to provide data-binding to text nodes and attribute values.</source>
          <target state="translated">AngularJS는 내장 &lt;a href=&quot;expression&quot;&gt;표현식&lt;/a&gt; 이 포함 된 보간 마크 업을 사용하여 텍스트 노드 및 속성 값에 데이터 바인딩을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="464d6921114c284acd9c8fb8f85d8fdc2d3aa0a2" translate="yes" xml:space="preserve">
          <source>Introductory Material</source>
          <target state="translated">입문 자료</target>
        </trans-unit>
        <trans-unit id="6ef14993cacdc6240416f3e705cd81fa9aedff49" translate="yes" xml:space="preserve">
          <source>Invoke the method and supply the method arguments from the &lt;code&gt;$injector&lt;/code&gt;.</source>
          <target state="translated">메소드를 호출하고 &lt;code&gt;$injector&lt;/code&gt; 에서 메소드 인수를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="35b43899a3f83610ba7b4c6c1390ee4e1f1b7e31" translate="yes" xml:space="preserve">
          <source>Invokes the &lt;code&gt;iterator&lt;/code&gt; function once for each item in &lt;code&gt;obj&lt;/code&gt; collection, which can be either an object or an array. The &lt;code&gt;iterator&lt;/code&gt; function is invoked with &lt;code&gt;iterator(value, key, obj)&lt;/code&gt;, where &lt;code&gt;value&lt;/code&gt; is the value of an object property or an array element, &lt;code&gt;key&lt;/code&gt; is the object property key or array element index and obj is the &lt;code&gt;obj&lt;/code&gt; itself. Specifying a &lt;code&gt;context&lt;/code&gt; for the function is optional.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 컬렉션의 각 항목에 대해 &lt;code&gt;iterator&lt;/code&gt; 함수를 한 번 호출합니다 ( 객체 또는 배열 일 수 있음). &lt;code&gt;iterator&lt;/code&gt; 함수를 호출 &lt;code&gt;iterator(value, key, obj)&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; 객체 속성 또는 배열 요소의 값은, &lt;code&gt;key&lt;/code&gt; 객체 속성 키 또는 어레이 엘리먼트 인덱스이며 OBJ가있다 &lt;code&gt;obj&lt;/code&gt; 자체. 함수 의 &lt;code&gt;context&lt;/code&gt; 를 지정하는 것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="a5ab7787ce6bc4362a9f13777edcdaf6b98998bd" translate="yes" xml:space="preserve">
          <source>Ionic Framework</source>
          <target state="translated">이온 프레임 워크</target>
        </trans-unit>
        <trans-unit id="1a782aa74f75185993195ad4bcbc102f9f427def" translate="yes" xml:space="preserve">
          <source>Isolating the Scope of a Directive</source>
          <target state="translated">지시문의 범위 분리</target>
        </trans-unit>
        <trans-unit id="d20f2f6b4e6d817ba6e89b3f9673aecdf3113258" translate="yes" xml:space="preserve">
          <source>Issues with replace: true</source>
          <target state="translated">바꾸기 문제 : true</target>
        </trans-unit>
        <trans-unit id="553315737e3b34b8f0ca05c4145e5f178bea3093" translate="yes" xml:space="preserve">
          <source>It also watches the &lt;a href=&quot;%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; and automatically scrolls to match any anchor whenever it changes. This can be disabled by calling &lt;a href=&quot;../provider/%24anchorscrollprovider#disableAutoScrolling.html&quot;&gt;$anchorScrollProvider.disableAutoScrolling()&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;%24location#hash.html&quot;&gt;$ location.hash ()를&lt;/a&gt; 보고 변경 될 때마다 앵커와 일치하도록 자동으로 스크롤됩니다. &lt;a href=&quot;../provider/%24anchorscrollprovider#disableAutoScrolling.html&quot;&gt;$ anchorScrollProvider.disableAutoScrolling ()&lt;/a&gt; 을 호출하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c489374ee92d89df88a69e803f218fae80bb3039" translate="yes" xml:space="preserve">
          <source>It can also be used to achieve one-way binding of a given expression to an input element such as an &lt;code&gt;input[text]&lt;/code&gt; or a &lt;code&gt;textarea&lt;/code&gt;, when that element does not use ngModel.</source>
          <target state="translated">또한 해당 요소가 ngModel을 사용하지 않는 경우 주어진 표현식을 &lt;code&gt;input[text]&lt;/code&gt; 또는 &lt;code&gt;textarea&lt;/code&gt; 와 같은 입력 요소에 단방향 바인딩하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ead9df0c1b0575bc0d0a33bce64a5d7d3f5aebc" translate="yes" xml:space="preserve">
          <source>It can be used like so:</source>
          <target state="translated">다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db03d0c1d6f65c6696ad45dd10b046e86fb2b5bc" translate="yes" xml:space="preserve">
          <source>It can be used to trigger a native browser event on an element, which is useful for unit testing.</source>
          <target state="translated">요소에서 기본 브라우저 이벤트를 트리거하는 데 사용할 수 있으며 단위 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="92cd05db0fac39e05b3a78129dbc2c13bb5d210c" translate="yes" xml:space="preserve">
          <source>It does not cause a full page reload when the browser URL is changed. To reload the page after changing the URL, use the lower-level API, &lt;code&gt;$window.location.href&lt;/code&gt;.</source>
          <target state="translated">브라우저 URL이 변경 될 때 전체 페이지를 다시로드하지 않습니다. URL을 변경 한 후 페이지를 다시로드하려면 하위 레벨 &lt;code&gt;$window.location.href&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd0e3b492e0e9ddf8f072cf8217d885fc9dc93f" translate="yes" xml:space="preserve">
          <source>It impacts performance, as interpolation adds another watcher to the scope.</source>
          <target state="translated">보간이 다른 감시자를 범위에 추가하므로 성능에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4d5b67bbcac712f4a34e5aa8cfdb8f074f88c7b5" translate="yes" xml:space="preserve">
          <source>It increases the complexity of the markup</source>
          <target state="translated">마크 업의 복잡성을 증가시킵니다</target>
        </trans-unit>
        <trans-unit id="fc05bcff5f72991e69c700ce73817afcbbb8bd13" translate="yes" xml:space="preserve">
          <source>It indicates to the compiler whether or not directives on comments should be compiled. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">주석에 대한 지시문을 컴파일해야하는지 여부를 컴파일러에 표시합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="906af1e36dfdfa37c091ab433fc206589b32aa37" translate="yes" xml:space="preserve">
          <source>It indicates to the compiler whether or not directives on element classes should be compiled. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">요소 클래스의 지시문을 컴파일해야하는지 여부를 컴파일러에 표시합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a5ee5553d7a8187ba379677bf68a64abd66747eb" translate="yes" xml:space="preserve">
          <source>It is a really, &lt;em&gt;really&lt;/em&gt; good idea to regard app testing as equal in importance to app writing. Testing difficulty is dramatically affected by the way the code is structured.</source>
          <target state="translated">그것은 정말입니다 &lt;em&gt;정말&lt;/em&gt; 응용 프로그램 작성에 중요성에서 동일하게 테스트 관련 응용 프로그램에 대한 좋은 아이디어. 코드의 구조에 따라 테스트 난이도가 크게 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="8855a2587ecadec73d7a3421fc455403fbc8a53a" translate="yes" xml:space="preserve">
          <source>It is a very good idea to decouple DOM manipulation from app logic. This dramatically improves the testability of the code.</source>
          <target state="translated">DOM 조작을 앱 로직에서 분리하는 것이 좋습니다. 이것은 코드의 테스트 가능성을 크게 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="727b35094155043ed303b76b370615c80c2ab5a2" translate="yes" xml:space="preserve">
          <source>It is also possible that you run into difficulties if you try to update the ngModel's &lt;code&gt;$modelValue&lt;/code&gt; programmatically before these debounced/future events have resolved/occurred, because AngularJS's dirty checking mechanism is not able to tell whether the model has actually changed or not.</source>
          <target state="translated">AngularJS의 더티 검사 메커니즘이 모델이 실제로 변경되었는지 여부를 알 수 없기 때문에 이러한 디 바운스 / 미래 이벤트가 해결 / 발생하기 전에 프로그래밍 방식으로 ngModel의 &lt;code&gt;$modelValue&lt;/code&gt; 를 업데이트하려고하면 문제가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c4111be6bb24188a6a2bea325a2c92f6ed5f77" translate="yes" xml:space="preserve">
          <source>It is also possible to call the &lt;code&gt;orderBy&lt;/code&gt; filter manually, by injecting &lt;code&gt;orderByFilter&lt;/code&gt;, and calling it with the desired parameters. (Alternatively, you could inject the &lt;code&gt;$filter&lt;/code&gt; factory and retrieve the &lt;code&gt;orderBy&lt;/code&gt; filter with &lt;code&gt;$filter('orderBy')&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;orderByFilter&lt;/code&gt; 를 주입 하고 원하는 매개 변수 로 호출하여 &lt;code&gt;orderBy&lt;/code&gt; 필터를 수동으로 호출 할 수도 있습니다 . (또는, &lt;code&gt;$filter&lt;/code&gt; 팩토리를 주입하고 &lt;code&gt;$filter('orderBy')&lt;/code&gt; &lt;code&gt;orderBy&lt;/code&gt; 필터를 검색 할 수 있습니다. 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7a590d3c2d53e278b044a014b894acece3725f" translate="yes" xml:space="preserve">
          <source>It is also possible to set &lt;code&gt;bindToController&lt;/code&gt; to an object hash with the same format as the &lt;code&gt;scope&lt;/code&gt; property. This will set up the scope bindings to the controller directly. Note that &lt;code&gt;scope&lt;/code&gt; can still be used to define which kind of scope is created. By default, no scope is created. Use &lt;code&gt;scope: {}&lt;/code&gt; to create an isolate scope (useful for component directives).</source>
          <target state="translated">&lt;code&gt;bindToController&lt;/code&gt; 를 &lt;code&gt;scope&lt;/code&gt; 속성 과 동일한 형식의 객체 해시 로 설정할 수도 있습니다 . 이것은 컨트롤러에 대한 범위 바인딩을 직접 설정합니다. 참고 &lt;code&gt;scope&lt;/code&gt; 아직 생성 범위의 종류를 정의 할 수 있습니다. 기본적으로 범위는 만들어지지 않습니다. 사용 &lt;code&gt;scope: {}&lt;/code&gt; (구성 요소 지침에 유용)을 분리 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="25431739b654d8cc47b28b9c43eeca226e65b9a6" translate="yes" xml:space="preserve">
          <source>It is also possible to set it as the default &lt;code&gt;paramSerializer&lt;/code&gt; in the &lt;a href=&quot;../provider/%24httpprovider#defaults.html&quot;&gt;&lt;code&gt;$httpProvider&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../provider/%24httpprovider#defaults.html&quot;&gt; &lt;code&gt;$httpProvider&lt;/code&gt; &lt;/a&gt; 에서 기본 &lt;code&gt;paramSerializer&lt;/code&gt; 로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d5c13dd91385416023d0e8e5aa828224c7f5217" translate="yes" xml:space="preserve">
          <source>It is always good to make common tasks trivial and difficult tasks possible.</source>
          <target state="translated">일반적인 작업을 사소하고 어려운 작업을 수행하는 것이 항상 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b3e683fad2f9309dfaa4db918783ad8289246cf8" translate="yes" xml:space="preserve">
          <source>It is an excellent idea to decouple the client side of an app from the server side. This allows development work to progress in parallel, and allows for reuse of both sides.</source>
          <target state="translated">앱의 클라이언트 쪽을 서버 쪽에서 분리하는 것이 좋습니다. 이를 통해 개발 작업을 동시에 진행할 수 있으며 양쪽을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b0fa48b6950751b768005b01d414197a136d433" translate="yes" xml:space="preserve">
          <source>It is common to attach Controllers at different levels of the DOM hierarchy. Since the &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;ng-controller&lt;/a&gt; directive creates a new child scope, we get a hierarchy of scopes that inherit from each other. The &lt;code&gt;$scope&lt;/code&gt; that each Controller receives will have access to properties and methods defined by Controllers higher up the hierarchy. See &lt;a href=&quot;https://github.com/angular/angular.js/wiki/Understanding-Scopes&quot;&gt;Understanding Scopes&lt;/a&gt; for more information about scope inheritance.</source>
          <target state="translated">여러 레벨의 DOM 계층에서 컨트롤러를 연결하는 것이 일반적입니다. 때문에 &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;NG-컨트롤러&lt;/a&gt; 지시어는 새 자식 범위를 만들고, 우리는 서로 범위의 계층 구조가 상속을받을. &lt;code&gt;$scope&lt;/code&gt; 각 제어기는 계층까지의 상위 컨트롤러에 의해 정의 된 속성 및 메소드에 액세스 할 수신. 범위 상속에 대한 자세한 내용은 범위 &lt;a href=&quot;https://github.com/angular/angular.js/wiki/Understanding-Scopes&quot;&gt;이해를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="898e639ea78a3295cd345092429425a8851a4def" translate="yes" xml:space="preserve">
          <source>It is currently not possible for an interpolated expression to contain the interpolation end symbol. For example, &lt;code&gt;{{ '}}' }}&lt;/code&gt; will be incorrectly interpreted as &lt;code&gt;{{ ' }}&lt;/code&gt; + &lt;code&gt;' }}&lt;/code&gt;, i.e. an interpolated expression consisting of a single-quote (&lt;code&gt;'&lt;/code&gt;) and the &lt;code&gt;' }}&lt;/code&gt; string.</source>
          <target state="translated">보간 된 표현식이 보간 종료 기호를 포함 할 수 없습니다. 예를 들어, &lt;code&gt;{{ '}}' }}&lt;/code&gt; 은 &lt;code&gt;{{ ' }}&lt;/code&gt; + &lt;code&gt;' }}&lt;/code&gt; 로 잘못 해석됩니다 . 즉, 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )와 &lt;code&gt;' }}&lt;/code&gt; 문자열 로 구성된 보간 된 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="78735c155bc5c04e168b61fd0cfb26236c9dbc1c" translate="yes" xml:space="preserve">
          <source>It is documented that &lt;code&gt;animation.start()&lt;/code&gt; will return a promise object and this is true, however, there is also an additional method available on the runner called &lt;code&gt;.done(callbackFn)&lt;/code&gt;. The done method works the same as &lt;code&gt;.finally(callbackFn)&lt;/code&gt;, however, it does &lt;strong&gt;not trigger a digest to occur&lt;/strong&gt;. Therefore, for performance reasons, it's always best to use &lt;code&gt;runner.done(callback)&lt;/code&gt; instead of &lt;code&gt;runner.then()&lt;/code&gt;, &lt;code&gt;runner.catch()&lt;/code&gt; or &lt;code&gt;runner.finally()&lt;/code&gt; unless you really need a digest to kick off afterwards.</source>
          <target state="translated">이 설명되어 있습니다 &lt;code&gt;animation.start()&lt;/code&gt; 약속 개체를 반환하고이 그러나, 또한 주자라고 볼 수 있습니다 추가 방법 사실이 있습니다 &lt;code&gt;.done(callbackFn)&lt;/code&gt; . done 메소드는 &lt;code&gt;.finally(callbackFn)&lt;/code&gt; 과 동일하게 작동 하지만 &lt;strong&gt;다이제스트가 발생&lt;/strong&gt; 하지는 &lt;strong&gt;않습니다&lt;/strong&gt; . 따라서 성능상의 이유로 나중에 나중에 시작하기 위해 다이제스트가 필요하지 않으면 &lt;code&gt;runner.then()&lt;/code&gt; , &lt;code&gt;runner.catch()&lt;/code&gt; 또는 &lt;code&gt;runner.finally()&lt;/code&gt; 대신 &lt;code&gt;runner.done(callback)&lt;/code&gt; 을 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9adf8cb48d55887fa324e58aa54a93785a13c110" translate="yes" xml:space="preserve">
          <source>It is important to be aware of this when writing tests for directives that use 'element' transclusion. If you place the directive on the root element of the DOM fragment that you pass to &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;&lt;code&gt;$compile&lt;/code&gt;&lt;/a&gt;, then the DOM node returned from the linking function will be the comment node and you will lose the ability to access the template and transcluded content.</source>
          <target state="translated">'요소'전이를 사용하는 지시문에 대한 테스트를 작성할 때이를 알고 있어야합니다. &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt; &lt;code&gt;$compile&lt;/code&gt; &lt;/a&gt; 전달한 DOM 프래그먼트의 루트 요소에 지시문을 배치하면 연결 함수에서 리턴 된 DOM 노드가 주석 노드가되고 템플리트 및 변환 된 컨텐츠에 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="ade37c34e6742fe81576b7d98f9b8cab2717a032" translate="yes" xml:space="preserve">
          <source>It is important to realize that invoking a &lt;code&gt;$resource&lt;/code&gt; object method immediately returns an empty reference (object or array depending on &lt;code&gt;isArray&lt;/code&gt;). Once the data is returned from the server the existing reference is populated with the actual data. This is a useful trick since usually the resource is assigned to a model which is then rendered by the view. Having an empty object results in no rendering, once the data arrives from the server then the object is populated with the data and the view automatically re-renders itself showing the new data. This means that in most cases one never has to write a callback function for the action methods.</source>
          <target state="translated">&lt;code&gt;$resource&lt;/code&gt; 객체 메서드 를 호출 하면 빈 참조 ( &lt;code&gt;isArray&lt;/code&gt; 에 따라 객체 또는 배열)가 즉시 반환 됩니다. 서버에서 데이터가 반환되면 기존 참조는 실제 데이터로 채워집니다. 일반적으로 리소스가 모델에 할당 된 다음 뷰에 의해 렌더링되므로 유용한 트릭입니다. 비어있는 객체가 있으면 렌더링되지 않습니다. 일단 데이터가 서버에서 도착하면 객체가 데이터로 채워지고 뷰가 자동으로 다시 렌더링되어 새 데이터를 표시합니다. 이것은 대부분의 경우 액션 메소드에 대한 콜백 함수를 작성할 필요가 없다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="44e11a7a5909b52ab207ef70f4ca59576a8afb49" translate="yes" xml:space="preserve">
          <source>It is mainly used on &lt;a href=&quot;../input/input%5Bradio%5D&quot;&gt;&lt;code&gt;input[radio]&lt;/code&gt;&lt;/a&gt; and option elements, so that when the element is selected, the &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt; of that element (or its &lt;a href=&quot;select&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; parent element) is set to the bound value. It is especially useful for dynamically generated lists using &lt;a href=&quot;ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt;, as shown below.</source>
          <target state="translated">&lt;a href=&quot;../input/input%5Bradio%5D&quot;&gt; &lt;code&gt;input[radio]&lt;/code&gt; &lt;/a&gt; 및 옵션 요소 에 주로 사용 되므로 요소를 선택할 때 해당 요소 (또는 &lt;a href=&quot;select&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 상위 요소) 의 &lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 이 바운드 값으로 설정됩니다. 아래와 같이 &lt;a href=&quot;ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; 를&lt;/a&gt; 사용하여 동적으로 생성 된 목록에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="dd54d32cbd1f2ba51acb0890230e9b3c8d1d18e0" translate="yes" xml:space="preserve">
          <source>It is normal practice to attach your transcluded content (&lt;code&gt;clone&lt;/code&gt;) to the DOM inside your &lt;strong&gt;clone attach function&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;clone&lt;/code&gt; 컨텐츠 ( clone )를 &lt;strong&gt;복제 첨부 기능&lt;/strong&gt; 내 DOM 에 첨부하는 것이 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="43e9284ca16e984dd2b44c46563b6814669b9eaa" translate="yes" xml:space="preserve">
          <source>It is not possible to trust specific URLs/paths. The &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;fragment&lt;/code&gt; parts of a URL will be ignored. For example, &lt;code&gt;https://foo.com/path/bar?query=baz#fragment&lt;/code&gt; will be treated as &lt;code&gt;https://foo.com&lt;/code&gt;, meaning that &lt;strong&gt;all&lt;/strong&gt; requests to URLs starting with &lt;code&gt;https://foo.com/&lt;/code&gt; will include the XSRF token.</source>
          <target state="translated">특정 URL / 경로를 신뢰하는 것은 불가능합니다. URL 의 &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;query&lt;/code&gt; 및 &lt;code&gt;fragment&lt;/code&gt; 부분은 무시됩니다. 예를 들어, &lt;code&gt;https://foo.com/path/bar?query=baz#fragment&lt;/code&gt; 은 으로 처리됩니다 &lt;code&gt;https://foo.com&lt;/code&gt; 즉, &lt;strong&gt;모든&lt;/strong&gt; URL에 대한 요청으로 시작 &lt;code&gt;https://foo.com/&lt;/code&gt; 포함됩니다 XSRF 토큰.</target>
        </trans-unit>
        <trans-unit id="13587fb80feb5ab37440031b46d39c968c78429f" translate="yes" xml:space="preserve">
          <source>It is not possible to whitelist specific URLs/paths. The &lt;code&gt;path&lt;/code&gt;, &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;fragment&lt;/code&gt; parts of a URL will be ignored. For example, &lt;code&gt;https://foo.com/path/bar?query=baz#fragment&lt;/code&gt; will be treated as &lt;code&gt;https://foo.com&lt;/code&gt;, meaning that &lt;strong&gt;all&lt;/strong&gt; requests to URLs starting with &lt;code&gt;https://foo.com/&lt;/code&gt; will include the XSRF token.</source>
          <target state="translated">특정 URL / 경로를 허용 목록에 추가 할 수 없습니다. URL 의 &lt;code&gt;path&lt;/code&gt; , &lt;code&gt;query&lt;/code&gt; 및 &lt;code&gt;fragment&lt;/code&gt; 부분은 무시됩니다. 예를 들어, &lt;code&gt;https://foo.com/path/bar?query=baz#fragment&lt;/code&gt; 은 으로 처리됩니다 &lt;code&gt;https://foo.com&lt;/code&gt; 즉, &lt;strong&gt;모든&lt;/strong&gt; URL에 대한 요청으로 시작 &lt;code&gt;https://foo.com/&lt;/code&gt; 포함됩니다 XSRF 토큰.</target>
        </trans-unit>
        <trans-unit id="f5755149536ff4c33eaf7b094db38129ae71d347" translate="yes" xml:space="preserve">
          <source>It is often desirable to inline Injected functions and that's when setting the &lt;code&gt;$inject&lt;/code&gt; property is very inconvenient. In these situations using the array notation to specify the dependencies in a way that survives minification is a better choice:</source>
          <target state="translated">Injected 함수를 인라인하는 것이 종종 바람직하며 &lt;code&gt;$inject&lt;/code&gt; 속성을 설정하는 것이 매우 불편할 때입니다. 이러한 상황에서 배열 표기법을 사용하여 축소 후에도 종속성을 지정하는 것이 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="ea74d8637b90b9e1696533460b703c6c41293ed9" translate="yes" xml:space="preserve">
          <source>It is possible that during the &lt;code&gt;enter&lt;/code&gt; animation, the &lt;code&gt;.message&lt;/code&gt; div will be briefly visible before it starts animating. In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:</source>
          <target state="translated">&lt;code&gt;enter&lt;/code&gt; 애니메이션 중에 &lt;code&gt;.message&lt;/code&gt; div가 애니메이션을 시작하기 전에 잠깐 볼 수 있습니다. 이 경우 애니메이션을 시작하기 전에 요소를 숨기도록 CSS에 스타일을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82d2b045366df68d3ac3e59440164fdc698eb46" translate="yes" xml:space="preserve">
          <source>It is possible that during the &lt;code&gt;enter&lt;/code&gt; event, the &lt;code&gt;.message&lt;/code&gt; div will be briefly visible before it starts animating. In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:</source>
          <target state="translated">&lt;code&gt;enter&lt;/code&gt; 이벤트 중에 &lt;code&gt;.message&lt;/code&gt; div가 애니메이션을 시작하기 전에 잠깐 볼 수 있습니다. 이 경우 애니메이션을 시작하기 전에 요소를 숨기도록 CSS에 스타일을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c69afb8c7919c982dfe15812d0593df59e687ac6" translate="yes" xml:space="preserve">
          <source>It is possible to access the context object using the identifier &lt;code&gt;this&lt;/code&gt; and the locals object using the identifier &lt;code&gt;$locals&lt;/code&gt;.</source>
          <target state="translated">식별자 &lt;code&gt;this&lt;/code&gt; 를 사용하여 컨텍스트 객체에 액세스 하고 식별자 &lt;code&gt;$locals&lt;/code&gt; 사용하여 locals 객체 에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3066c08f5caeabdd7acdc8e45264d026b7139d6e" translate="yes" xml:space="preserve">
          <source>It is possible to create chains of any length and since a promise can be resolved with another promise (which will defer its resolution further), it is possible to pause/defer resolution of the promises at any point in the chain. This makes it possible to implement powerful APIs like $http's response interceptors.</source>
          <target state="translated">일정 길이의 체인을 생성 할 수 있으며 약속을 다른 약속으로 해결할 수 있으므로 (해당 해결이 더 지연 될 수 있음) 체인의 어느 시점에서나 약속의 해결을 일시 중지 / 지연 할 수 있습니다. 이를 통해 $ http의 응답 인터셉터와 같은 강력한 API를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccda427b3a1fede3c12595f91bdd135712e54499" translate="yes" xml:space="preserve">
          <source>It is possible to disable individual attributes added by ngAria with the &lt;a href=&quot;ngaria/provider/%24ariaprovider#config.html&quot;&gt;config&lt;/a&gt; method. For more details, see the &lt;a href=&quot;../guide/accessibility&quot;&gt;Developer Guide&lt;/a&gt;.</source>
          <target state="translated">ngAria가 &lt;a href=&quot;ngaria/provider/%24ariaprovider#config.html&quot;&gt;config&lt;/a&gt; 메소드로 추가 한 개별 속성을 비활성화 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../guide/accessibility&quot;&gt;개발자 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="463de9ded47806d9b1e436ee2e11963140db8b5f" translate="yes" xml:space="preserve">
          <source>It is possible to get &lt;code&gt;ngRepeat&lt;/code&gt; to iterate over the properties of an object using the following syntax:</source>
          <target state="translated">다음 구문을 사용하여 &lt;code&gt;ngRepeat&lt;/code&gt; 가 객체의 속성을 반복하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6efc27732c8ebe9e9e84ddd4403a59ab8aa7bee" translate="yes" xml:space="preserve">
          <source>It is possible to inject other providers into the provider function, but the injected provider must have been defined before the one that requires it.</source>
          <target state="translated">다른 제공자를 제공자 기능에 삽입 할 수 있지만, 주입 된 제공자가 필요한 제공자보다 먼저 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="996e7a28852c7c4983233eb69326521205c8d521" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;ngAria&lt;/code&gt; ignore a specific element, by adding the &lt;code&gt;ng-aria-disable&lt;/code&gt; attribute on it. Note that only the element itself (and not its child elements) will be ignored.</source>
          <target state="translated">할 수 &lt;code&gt;ngAria&lt;/code&gt; 가 추가하여 특정 요소를 무시 &lt;code&gt;ng-aria-disable&lt;/code&gt; 그것에 속성을. 자식 요소가 아닌 요소 자체 만 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7dcf70c9223ffd381f61a6b912e2f0febfd3f458" translate="yes" xml:space="preserve">
          <source>It is preferable to use &lt;code&gt;ngBind&lt;/code&gt; instead of &lt;code&gt;{{ expression }}&lt;/code&gt; if a template is momentarily displayed by the browser in its raw state before AngularJS compiles it. Since &lt;code&gt;ngBind&lt;/code&gt; is an element attribute, it makes the bindings invisible to the user while the page is loading.</source>
          <target state="translated">브라우저가 템플릿을 AngularJS가 컴파일하기 전에 기본적으로 원시 상태로 표시하는 경우 &lt;code&gt;{{ expression }}&lt;/code&gt; 대신 &lt;code&gt;ngBind&lt;/code&gt; 를 사용하는 것이 좋습니다 . 이후 &lt;code&gt;ngBind&lt;/code&gt; 이 요소의 속성, 그것은 페이지가 로딩되는 동안 사용자에게 바인딩이 보이지 않는 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7fa93572d942a68934418e0f950bd76f13eabf5" translate="yes" xml:space="preserve">
          <source>It is recommended that the&lt;code&gt;$animate&lt;/code&gt; service is always used when executing DOM-related procedures within directives.</source>
          <target state="translated">지시문 내에서 DOM 관련 프로 시저를 실행할 때는 항상 &lt;code&gt;$animate&lt;/code&gt; 서비스를 사용 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="20dd27ac14a6636e950bb55c4e920c64e3cfa0d1" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;a href=&quot;%24verifynopendingtasks&quot;&gt;&lt;code&gt;$verifyNoPendingTasks&lt;/code&gt;&lt;/a&gt; instead, which additionally supports verifying a specific type of tasks. For example, you can verify there are no pending timeouts with &lt;code&gt;$verifyNoPendingTasks('$timeout')&lt;/code&gt;.</source>
          <target state="translated">대신 특정 유형의 작업 확인을 지원하는 &lt;a href=&quot;%24verifynopendingtasks&quot;&gt; &lt;code&gt;$verifyNoPendingTasks&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 . 예를 들어 &lt;code&gt;$verifyNoPendingTasks('$timeout')&lt;/code&gt; 보류중인 시간 초과가 없는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f45818ee9136dc6dadbc2fa5e5ca2b49e58cb3e" translate="yes" xml:space="preserve">
          <source>It is safe to do DOM transformation in the post-linking function on elements that are not waiting for their async templates to be resolved.</source>
          <target state="translated">비동기 템플릿이 해결되기를 기다리지 않는 요소의 사후 연결 기능에서 DOM 변환을 수행하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5cd79d0b11c62c96f4bc727951641d2d5341dda9" translate="yes" xml:space="preserve">
          <source>It is strongly discouraged to write filters that are stateful, because the execution of those can't be optimized by AngularJS, which often leads to performance issues. Many stateful filters can be converted into stateless filters just by exposing the hidden state as a model and turning it into an argument for the filter.</source>
          <target state="translated">AngularJS에서는 필터 실행을 최적화 할 수 없으므로 성능 문제가 발생하기 때문에 상태 저장 필터를 작성하지 않는 것이 좋습니다. 숨겨진 상태를 모델로 노출하고 필터의 인수로 바꾸면 많은 상태 저장 필터를 상태 비 저장 필터로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c70092309a32e4d1a0bcae4da2f3f0c325e2cf9" translate="yes" xml:space="preserve">
          <source>It is very helpful indeed if the framework guides developers through the entire journey of building an app: From designing the UI, through writing the business logic, to testing.</source>
          <target state="translated">UI 디자인부터 비즈니스 로직 작성, 테스트에 이르기까지 프레임 워크가 개발자에게 앱 개발의 전체 과정을 안내하는 것이 매우 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a8e33bee9be3d901e4da72984e940ec4a7e8a400" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;.forEach&lt;/code&gt; does not iterate over inherited properties because it filters using the &lt;code&gt;hasOwnProperty&lt;/code&gt; method.</source>
          <target state="translated">그것은 있음을 주목할 필요가있다 &lt;code&gt;.forEach&lt;/code&gt; 이 는 필터 사용하기 때문에 반복 처리가 이상 속성을 상속하지 않습니다 &lt;code&gt;hasOwnProperty&lt;/code&gt; 의 방법을.</target>
        </trans-unit>
        <trans-unit id="611cdb339d280f84c55eabf4024dabc2e5e34ff2" translate="yes" xml:space="preserve">
          <source>It makes more sense to show nothing than to throw an exception if &lt;code&gt;a&lt;/code&gt; is undefined (perhaps we are waiting for the server response, and it will become defined soon). If expression evaluation wasn't forgiving we'd have to write bindings that clutter the code, for example: &lt;code&gt;{{((a||{}).b||{}).c}}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 정의되지 않은 경우 예외를 throw하는 것보다 아무것도 표시하지 않는 것이 더 합리적입니다 (아마도 서버 응답을 기다리고 있으며 곧 정의됩니다). 식 평가가 용서되지 않았다면 코드를 어지럽히는 바인딩을 작성해야합니다 &lt;code&gt;{{((a||{}).b||{}).c}}&lt;/code&gt; 예 : {{((a || {}). b || {}). c}}</target>
        </trans-unit>
        <trans-unit id="d3741e91b84dec124290a25fd27ad2bd88202ce9" translate="yes" xml:space="preserve">
          <source>It needs to be able to clone new &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; elements for every &lt;code&gt;action&lt;/code&gt; in &lt;code&gt;user.actions&lt;/code&gt;. This initially seems trivial, but it becomes more complicated when you consider that &lt;code&gt;user.actions&lt;/code&gt; might have items added to it later. This means that it needs to save a clean copy of the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element for cloning purposes.</source>
          <target state="translated">&lt;code&gt;user.actions&lt;/code&gt; 의 모든 &lt;code&gt;action&lt;/code&gt; 에 대해 새 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 를 복제 할 수 있어야합니다 . 처음에는 사소한 것처럼 보이지만, &lt;code&gt;user.actions&lt;/code&gt; 에 나중에 추가 된 항목이 있다고 생각하면 더욱 복잡해집니다 . 즉, 복제 목적으로 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 의 깨끗한 사본을 저장해야 합니다.</target>
        </trans-unit>
        <trans-unit id="044534907de0e3d02f1d6dcf3bd09783d0a7ce1a" translate="yes" xml:space="preserve">
          <source>It will not be evaluated:</source>
          <target state="translated">평가되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="51d3504ce322f478d04b175eb950e68a8c86c2ed" translate="yes" xml:space="preserve">
          <source>It will not insert undefined values into the cache.</source>
          <target state="translated">캐시에 정의되지 않은 값을 삽입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="647a38d6c647676338b60b9a322ac3dc18d5d2e4" translate="yes" xml:space="preserve">
          <source>It's also possible to add components via &lt;a href=&quot;../api/ng/provider/%24compileprovider#component.html&quot;&gt;&lt;code&gt;$compileProvider&lt;/code&gt;&lt;/a&gt; in a module's config phase.</source>
          <target state="translated">모듈의 구성 단계에서 &lt;a href=&quot;../api/ng/provider/%24compileprovider#component.html&quot;&gt; &lt;code&gt;$compileProvider&lt;/code&gt; &lt;/a&gt; 를 통해 구성 요소를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22f4771591ad7899072f54bc41e4b386849c26e5" translate="yes" xml:space="preserve">
          <source>It's important to note that AngularJS operates on DOM nodes rather than strings. Usually, you don't notice this restriction because when a page loads, the web browser parses HTML into the DOM automatically.</source>
          <target state="translated">AngularJS는 문자열이 아닌 DOM 노드에서 작동한다는 점에 유의해야합니다. 일반적으로 페이지가로드 될 때 웹 브라우저가 HTML을 DOM으로 자동 구문 분석하기 때문에이 제한 사항을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="63749726fcc574a51f6aa95ccfbd08fbb78f8122" translate="yes" xml:space="preserve">
          <source>It's important to remember that SCE only applies to interpolation expressions.</source>
          <target state="translated">SCE는 보간 표현식에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="97fe1b00d73664eb3be824469d6bc43514c62a58" translate="yes" xml:space="preserve">
          <source>It's just a simple call to &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$injector&lt;/a&gt;, but extracted into a service, so that one can override this service with &lt;a href=&quot;https://gist.github.com/1649788&quot;&gt;BC version&lt;/a&gt;.</source>
          <target state="translated">단순히 &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;$ injector&lt;/a&gt; 호출 이지만 서비스로 추출되어 &lt;a href=&quot;https://gist.github.com/1649788&quot;&gt;BC 버전&lt;/a&gt; 으로이 서비스를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e7cdaffe82fa8054dcd10304a4d6e6e817934e7" translate="yes" xml:space="preserve">
          <source>It's rare for directives to have a &lt;strong&gt;compile function&lt;/strong&gt;, since most directives are concerned with working with a specific DOM element instance rather than changing its overall structure.</source>
          <target state="translated">대부분의 지시문은 전체 구조를 변경하지 않고 특정 DOM 요소 인스턴스를 다루는 것과 관련되므로 지시문에 &lt;strong&gt;컴파일 함수&lt;/strong&gt; 가있는 경우는 드 rare니다 .</target>
        </trans-unit>
        <trans-unit id="d8f50a90fa099f10e64b9bd1dc9869f5899151a0" translate="yes" xml:space="preserve">
          <source>It's worth noting that the success callback for &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;query&lt;/code&gt; and other methods gets called with the resource instance (populated with the data that came from the server) as well as an &lt;code&gt;$http&lt;/code&gt; header getter function, the HTTP status code and the response status text. So one could rewrite the above example and get access to HTTP headers as follows:</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; , &lt;code&gt;query&lt;/code&gt; 및 기타 메소드에 대한 성공 콜백 은 &lt;code&gt;$http&lt;/code&gt; 헤더 getter 함수, HTTP 상태 코드 및 응답 상태 텍스트 뿐만 아니라 자원 인스턴스 (서버에서 가져온 데이터로 채워짐)로 호출됩니다. . 따라서 위의 예제를 다시 작성하고 다음과 같이 HTTP 헤더에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c6b93cece7b56e6dd78ac2666ff04806c02f52" translate="yes" xml:space="preserve">
          <source>Iterating over object properties</source>
          <target state="translated">객체 속성에 대한 반복</target>
        </trans-unit>
        <trans-unit id="d168d1da3e52bad6c8a376a1d89c87495a6d115b" translate="yes" xml:space="preserve">
          <source>Iterator function.</source>
          <target state="translated">반복자 기능.</target>
        </trans-unit>
        <trans-unit id="92529e5e57daf03b5c7563eb34fd6f6925c58ee2" translate="yes" xml:space="preserve">
          <source>Its name (&lt;code&gt;customerInfo&lt;/code&gt;) corresponds to the directive's &lt;strong&gt;isolate scope&lt;/strong&gt; property, &lt;code&gt;customerInfo&lt;/code&gt;.</source>
          <target state="translated">이름 ( &lt;code&gt;customerInfo&lt;/code&gt; )은 지시문의 &lt;strong&gt;분리 범위&lt;/strong&gt; 특성 &lt;code&gt;customerInfo&lt;/code&gt; 에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="e18ffa2ef59d4b87123bc4116b7fecfc6e23eb76" translate="yes" xml:space="preserve">
          <source>Its value (&lt;code&gt;=info&lt;/code&gt;) tells &lt;code&gt;$compile&lt;/code&gt; to bind to the &lt;code&gt;info&lt;/code&gt; attribute.</source>
          <target state="translated">값 ( &lt;code&gt;=info&lt;/code&gt; )은 &lt;code&gt;$compile&lt;/code&gt; 에게 &lt;code&gt;info&lt;/code&gt; 속성 에 바인딩하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="e2109f35483e028183630e81dec66527c27fcb3c" translate="yes" xml:space="preserve">
          <source>JSON Hijacking Protection</source>
          <target state="translated">JSON 하이재킹 보호</target>
        </trans-unit>
        <trans-unit id="a73f31364f316869a18b10faeec2662cc4789dca" translate="yes" xml:space="preserve">
          <source>JSON Vulnerability Protection</source>
          <target state="translated">JSON 취약점 보호</target>
        </trans-unit>
        <trans-unit id="1a3f795e84cd2bbb65926a8a582d42403b1d5c7a" translate="yes" xml:space="preserve">
          <source>JSON string to deserialize.</source>
          <target state="translated">직렬화 해제 할 JSON 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="e7310488497f531f2e417022cb940817561304d1" translate="yes" xml:space="preserve">
          <source>JSON string.</source>
          <target state="translated">JSON 문자열.</target>
        </trans-unit>
        <trans-unit id="cd109ddd9abf44c82c6e482563ac9c2d1dab6b46" translate="yes" xml:space="preserve">
          <source>JSON vulnerability</source>
          <target state="translated">JSON 취약점</target>
        </trans-unit>
        <trans-unit id="f3231f4d14fc745f083c6fc41fdecc2a60618120" translate="yes" xml:space="preserve">
          <source>JSON-ified string representing &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">나타내는 문자열을 JSON은-는 ified &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df2d62a7c9d7c1a7fdd0de39b8a9f3b75d1b3fe4" translate="yes" xml:space="preserve">
          <source>JSONP requests must specify a callback to be used in the response from the server. This callback is passed as a query parameter in the request. You must specify the name of this parameter by setting the &lt;code&gt;jsonpCallbackParam&lt;/code&gt; property on the request config object.</source>
          <target state="translated">JSONP 요청은 서버의 응답에 사용될 콜백을 지정해야합니다. 이 콜백은 요청에서 쿼리 매개 변수로 전달됩니다. 요청 구성 오브젝트 에서 &lt;code&gt;jsonpCallbackParam&lt;/code&gt; 특성을 설정하여이 매개 변수의 이름을 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3755f3f206953314cab133719791d70c7c568127" translate="yes" xml:space="preserve">
          <source>Jasmine</source>
          <target state="translated">Jasmine</target>
        </trans-unit>
        <trans-unit id="ec4307a3b7c7279b22900f7258d244467b4170ca" translate="yes" xml:space="preserve">
          <source>Jasmine comes with a number of matchers that help you make a variety of assertions. You should &lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html#section-Matchers&quot;&gt;read the Jasmine documentation&lt;/a&gt; to see what they are. To use Jasmine with Karma, we use the &lt;a href=&quot;https://github.com/karma-runner/karma-jasmine&quot;&gt;karma-jasmine&lt;/a&gt; test runner.</source>
          <target state="translated">Jasmine에는 다양한 어설 션을 만드는 데 도움이되는 여러 가지 매칭 기능이 있습니다. 당신은해야 &lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html#section-Matchers&quot;&gt;재스민 설명서를 읽어&lt;/a&gt; 그들이 무엇인지 볼 수 있습니다. Karma와 함께 Jasmine을 사용하기 위해 &lt;a href=&quot;https://github.com/karma-runner/karma-jasmine&quot;&gt;karma-jasmine&lt;/a&gt; 테스트 러너를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06353eaa73f71ca7f32f2abd2d524ecc102f0f53" translate="yes" xml:space="preserve">
          <source>Jasmine's &lt;code&gt;beforeAll()&lt;/code&gt; and mocha's &lt;code&gt;before()&lt;/code&gt; hooks are often useful for sharing test setup - either to reduce test run-time or simply to make for more focused test cases.</source>
          <target state="translated">Jasmine의 &lt;code&gt;beforeAll()&lt;/code&gt; 및 mocha의 &lt;code&gt;before()&lt;/code&gt; 후크는 종종 테스트 실행 시간을 줄이거 나보다 집중된 테스트 사례를 만들기 위해 테스트 설정을 공유하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cd26eab17c125b6d4053a3b51afa63e0255f89fb" translate="yes" xml:space="preserve">
          <source>JavaScript developers often use custom types to write object-oriented code. Let's explore how we could launch a unicorn into space via our &lt;code&gt;unicornLauncher&lt;/code&gt; service which is an instance of a custom type:</source>
          <target state="translated">JavaScript 개발자는 종종 사용자 정의 유형을 사용하여 객체 지향 코드를 작성합니다. 커스텀 타입의 인스턴스 인 &lt;code&gt;unicornLauncher&lt;/code&gt; 서비스를 통해 유니콘을 우주로 발사 할 수있는 방법을 살펴 보겠습니다 :</target>
        </trans-unit>
        <trans-unit id="ee93c12cc73a4b3357dead9e3073e9c84333533a" translate="yes" xml:space="preserve">
          <source>JavaScript does not have annotations, and annotations are needed for dependency injection. The following are all valid ways of annotating function with injection arguments and are equivalent.</source>
          <target state="translated">JavaScript에는 주석이 없으며 종속성 삽입에 주석이 필요합니다. 다음은 주입 인수로 함수에 주석을 달 수있는 올바른 방법이며 모두 같습니다.</target>
        </trans-unit>
        <trans-unit id="f87f3f5a13f550d2b612f32c40eed8fdfb04d4d7" translate="yes" xml:space="preserve">
          <source>JavaScript is a dynamically typed language which comes with great power of expression, but it also comes with almost no help from the compiler. For this reason we feel very strongly that any code written in JavaScript needs to come with a strong set of tests. We have built many features into AngularJS which make testing your AngularJS applications easy. With AngularJS, there is no excuse for not testing.</source>
          <target state="translated">JavaScript는 다이나믹 한 형식의 언어로 표현력이 뛰어나지 만 컴파일러의 도움이 거의 없습니다. 이러한 이유로 우리는 JavaScript로 작성된 모든 코드에 강력한 테스트 세트가 필요하다는 것을 매우 강하게 느낍니다. AngularJS에는 많은 기능이 내장되어 AngularJS 응용 프로그램을 쉽게 테스트 할 수 있습니다. AngularJS를 사용하면 테스트하지 않을 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fadc60e22e889ef4a5db8d9566fc1f75d1e1fc3" translate="yes" xml:space="preserve">
          <source>JavaScript-based Animations</source>
          <target state="translated">자바 스크립트 기반 애니메이션</target>
        </trans-unit>
        <trans-unit id="f0c95a02174fcae881d51cda5ca7ab7183d9d05f" translate="yes" xml:space="preserve">
          <source>Just before a scope is destroyed, a &lt;code&gt;$destroy&lt;/code&gt; event is broadcasted on this scope. Application code can register a &lt;code&gt;$destroy&lt;/code&gt; event handler that will give it a chance to perform any necessary cleanup.</source>
          <target state="translated">범위가 파괴되기 직전에 &lt;code&gt;$destroy&lt;/code&gt; 이벤트가이 범위에서 브로드 캐스트됩니다. 응용 프로그램 코드는 필요한 정리 작업을 수행 할 수있는 &lt;code&gt;$destroy&lt;/code&gt; 이벤트 핸들러를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="446df7317547fafc6781146fe724896a641a6589" translate="yes" xml:space="preserve">
          <source>Just like with the Value recipe, the Factory recipe can create a service of any type, whether it be a primitive, object literal, function, or even an instance of a custom type.</source>
          <target state="translated">값 레시피와 마찬가지로 팩토리 레시피는 기본, 객체 리터럴, 함수 또는 사용자 정의 유형의 인스턴스 등 모든 유형의 서비스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f3bad15c258125fed5359f408174ac231480f45" translate="yes" xml:space="preserve">
          <source>Just like with the array annotation, you'll need to take care to keep the &lt;code&gt;$inject&lt;/code&gt; in sync with the parameters in the function declaration.</source>
          <target state="translated">배열 주석과 마찬가지로 &lt;code&gt;$inject&lt;/code&gt; 가 함수 선언의 매개 변수와 동기화되도록 주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="83b97c0c14f5a90f7cfc308d350169d4502ed064" translate="yes" xml:space="preserve">
          <source>Just starting out with AngularJS? Try working through our step by step tutorial or try building on our seed project.</source>
          <target state="translated">AngularJS로 시작합니까? 단계별 자습서를 통해 작업하거나 시드 프로젝트를 구축해보십시오.</target>
        </trans-unit>
        <trans-unit id="835db6cf74c39f78cc6a89ccd0b07490be2e3f7d" translate="yes" xml:space="preserve">
          <source>Karma</source>
          <target state="translated">Karma</target>
        </trans-unit>
        <trans-unit id="796757c2eef12e78a1cedcfc4dd244620a421fe3" translate="yes" xml:space="preserve">
          <source>Karma is a NodeJS application, and should be installed through npm/yarn. Full installation instructions are available on &lt;a href=&quot;http://karma-runner.github.io/0.12/intro/installation.html&quot;&gt;the Karma website&lt;/a&gt;.</source>
          <target state="translated">Karma는 NodeJS 애플리케이션이며 npm / yarn을 통해 설치해야합니다. 전체 설치 지침은 &lt;a href=&quot;http://karma-runner.github.io/0.12/intro/installation.html&quot;&gt;Karma 웹 사이트&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f05628aa30b14f4028806e1eb5cdfe5f20cc24" translate="yes" xml:space="preserve">
          <source>Keep in mind that extending the built-in list of attributes may expose your app to XSS or other vulnerabilities. Be very mindful of the attributes you add.</source>
          <target state="translated">기본 제공 속성 목록을 확장하면 앱이 XSS 또는 다른 취약점에 노출 될 수 있습니다. 추가 한 속성에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="a92f7b09ee83168618ccf21bf5c35dba619424e7" translate="yes" xml:space="preserve">
          <source>Keep in mind that extending the built-in lists of elements may expose your app to XSS or other vulnerabilities. Be very mindful of the elements you add.</source>
          <target state="translated">내장 요소 목록을 확장하면 앱이 XSS 또는 다른 취약점에 노출 될 수 있습니다. 추가 한 요소에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="0b7234c93db939ba9dc42512dc4a50d3d5fc5e8d" translate="yes" xml:space="preserve">
          <source>Keep in mind that ngAnimate can detect each of these classes when added and removed.</source>
          <target state="translated">ngAnimate는 추가 및 제거시 이러한 각 클래스를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b11c7d42b4f9176649a2805e7a06ba3998ac5d" translate="yes" xml:space="preserve">
          <source>Keep in mind that, as of AngularJS version 1.3, there is no need to change the display property to block during animation states - ngAnimate will automatically handle the style toggling for you.</source>
          <target state="translated">AngularJS 버전 1.3부터는 애니메이션 상태 동안 블로킹하기 위해 디스플레이 속성을 변경할 필요가 없습니다. ngAnimate는 자동으로 스타일 전환을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8f7f42cad636bff6a772bcf1eda4ec9fe24b543e" translate="yes" xml:space="preserve">
          <source>Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss (so there is no need to call &lt;code&gt;runner.done(doneFn)&lt;/code&gt; inside of your JavaScript animation code). Check the &lt;a href=&quot;%24animatecss#usage.html&quot;&gt;animation code above&lt;/a&gt; to see how this works.</source>
          <target state="translated">ngAnimate는이 작업을보다 쉽게하기 위해 JS 애니메이션 API를 조정하여 $ animateCss에서 러너 인스턴스가 반환 될 때를 인식하도록했습니다 (따라서 JavaScript 애니메이션 코드 내에서 &lt;code&gt;runner.done(doneFn)&lt;/code&gt; 을 호출 할 필요가 없습니다 ). 이것이 작동하는 방법을 보려면 &lt;a href=&quot;%24animatecss#usage.html&quot;&gt;위&lt;/a&gt; 의 애니메이션 코드 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f6da5d91090ed7c6d5814b2991a120259c7d9e93" translate="yes" xml:space="preserve">
          <source>Keeping the state of the control (valid/invalid, dirty/pristine, touched/untouched, validation errors).</source>
          <target state="translated">컨트롤 상태 유지 (유효 / 무효, 더티 / 프리스틴, 터치 / 터치, 검증 오류)</target>
        </trans-unit>
        <trans-unit id="249603dc1891319661212764d6ba00d514a14c84" translate="yes" xml:space="preserve">
          <source>KendoUI</source>
          <target state="translated">KendoUI</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="50f8aa7cf7544eeebc75090c7d2c1e1a09370875" translate="yes" xml:space="preserve">
          <source>Large numbers and step validation</source>
          <target state="translated">많은 수 및 단계 유효성 검사</target>
        </trans-unit>
        <trans-unit id="5b0c7a2bd6ffad5686bfa5559eb7d1db15d82077" translate="yes" xml:space="preserve">
          <source>Later, if you want to remove the transcluded content from your DOM then you should also destroy the associated transclusion scope:</source>
          <target state="translated">나중에 DOM에서 변환 된 컨텐츠를 제거하려면 관련 변환 범위도 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="80de8be3b722879c53efa51624711a0b6a01add8" translate="yes" xml:space="preserve">
          <source>Lazily instantiated &amp;ndash; AngularJS only instantiates a service when an application component depends on it.</source>
          <target state="translated">지연 인스턴스화 &amp;ndash; AngularJS는 응용 프로그램 구성 요소가 종속 된 경우에만 서비스를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="b048378ee8f5a0297ca090e6904d0ccf8b77cd20" translate="yes" xml:space="preserve">
          <source>Learn</source>
          <target state="translated">Learn</target>
        </trans-unit>
        <trans-unit id="dbeb304ace39b2772a333789790e10087fec101d" translate="yes" xml:space="preserve">
          <source>Let's add some more logic to the example that allows us to enter and calculate the costs in different currencies and also pay the invoice.</source>
          <target state="translated">다른 통화로 비용을 입력하고 계산하고 송장을 지불 할 수있는 논리를 예제에 더 추가합시다.</target>
        </trans-unit>
        <trans-unit id="90ea8d67278fa3e22b77b8cc09d3a394d5450b4e" translate="yes" xml:space="preserve">
          <source>Let's change our directive to use &lt;code&gt;restrict: 'E'&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;restrict: 'E'&lt;/code&gt; 을 사용하도록 지시문을 변경해 봅시다 : 'E' :</target>
        </trans-unit>
        <trans-unit id="d91be5ddf9ad7a7db54de0a3590a672352083fa1" translate="yes" xml:space="preserve">
          <source>Let's create a directive that simply replaces its contents with a static template:</source>
          <target state="translated">내용을 정적 템플릿으로 간단히 바꾸는 지시문을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="e3b2a3b462354632d09f1e671f1d24fa08274712" translate="yes" xml:space="preserve">
          <source>Let's finish our example by fetching the exchange rates from the &lt;a href=&quot;https://exchangeratesapi.io&quot;&gt;exchangeratesapi.io&lt;/a&gt; exchange rate API. The following example shows how this is done with AngularJS:</source>
          <target state="translated">&lt;a href=&quot;https://exchangeratesapi.io&quot;&gt;exchangeratesapi.io&lt;/a&gt; 환율 API 에서 환율을 가져 와서 예제를 마무리하겠습니다 . 다음 예제는 AngularJS에서이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a2d73fe9e2675c4a6e225d3286eff53e81aab313" translate="yes" xml:space="preserve">
          <source>Let's refactor our example and move the currency conversion into a service in another file:</source>
          <target state="translated">예제를 리팩토링하고 통화 변환을 다른 파일의 서비스로 옮깁니다.</target>
        </trans-unit>
        <trans-unit id="e33ef1ad31a993b44b167589b8164ec89e801fcb" translate="yes" xml:space="preserve">
          <source>Let's say for example we have two views that are managed by &lt;code&gt;ng-view&lt;/code&gt; and we want to show that there is a relationship between two components situated in within these views. By using the &lt;code&gt;ng-animate-ref&lt;/code&gt; attribute we can identify that the two components are paired together and we can then attach an animation, which is triggered when the view changes.</source>
          <target state="translated">예를 들어 &lt;code&gt;ng-view&lt;/code&gt; 로 관리되는 두 개의 뷰가 있고이 뷰 내에 위치한 두 구성 요소 사이에 관계가 있음을 보여주고 싶습니다. 사용하여 &lt;code&gt;ng-animate-ref&lt;/code&gt; 속성을 우리는 두 가지 구성 요소가 함께 짝 것을 확인할 수 있습니다 그리고 우리는 때 뷰 변경을 트리거하는 애니메이션을 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="298a3adba79b2a136a068e0087e224c280869e40" translate="yes" xml:space="preserve">
          <source>Let's say that our &lt;code&gt;unicornLauncher&lt;/code&gt; service can stamp a unicorn with the planet name it's being launched from if this name was provided during the configuration phase. The planet name is application specific and is used also by various controllers during the runtime of the application. We can then define the planet name as a constant like this:</source>
          <target state="translated">&lt;code&gt;unicornLauncher&lt;/code&gt; 서비스는 구성 단계에서이 이름을 제공 한 경우 시작되는 행성 이름으로 유니콘에 도장을 찍을 수 있다고 가정 합니다. 행성 이름은 응용 프로그램에 따라 다르며 응용 프로그램을 실행하는 동안 다양한 컨트롤러에서도 사용됩니다. 그런 다음 행성 이름을 다음과 같이 상수로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f0321f70aa92a49f56c96150c79e4cd2b88e227" translate="yes" xml:space="preserve">
          <source>Let's say that our &lt;code&gt;unicornLauncher&lt;/code&gt; service is so awesome that many apps use it. By default the launcher shoots unicorns into space without any protective shielding. But on some planets the atmosphere is so thick that we must wrap every unicorn in tinfoil before sending it on its intergalactic trip, otherwise they would burn while passing through the atmosphere. It would then be great if we could configure the launcher to use the tinfoil shielding for each launch in apps that need it. We can make it configurable like so:</source>
          <target state="translated">우리의 &lt;code&gt;unicornLauncher&lt;/code&gt; 서비스가 너무 뛰어나서 많은 앱이 그것을 사용 한다고 가정 해 봅시다 . 기본적으로 실행기는 보호 차폐없이 유니콘을 우주로 발사합니다. 그러나 일부 행성에서는 대기가 너무 두껍기 때문에 은하계 여행을 보내기 전에 은박지로 모든 유니콘을 포장해야합니다. 그렇지 않으면 대기를 통과하면서 화상을 입을 수 있습니다. 그런 다음 앱이 필요한 앱에서 각 실행에 은박지 차폐를 사용하도록 실행기를 구성 할 수 있다면 좋을 것입니다. 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4554d27f3ea48a7db947cce4f856a4b1a611a8" translate="yes" xml:space="preserve">
          <source>Let's say that our HTML code for our messages container looks like so:</source>
          <target state="translated">메시지 컨테이너의 HTML 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f866ae3fd006fdb24ccbab98934a0c21ceee6ca1" translate="yes" xml:space="preserve">
          <source>Let's say that we want to have a very simple service called &quot;clientId&quot; that provides a string representing an authentication id used for some remote API. You would define it like this:</source>
          <target state="translated">원격 API에 사용되는 인증 ID를 나타내는 문자열을 제공하는 &quot;clientId&quot;라는 매우 간단한 서비스를 원한다고 가정 해 봅시다. 다음과 같이 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="6b8a3e62938bff7b32e460edfe415d213c9c307c" translate="yes" xml:space="preserve">
          <source>Let's say we have created an app that uses the default format for many of our &lt;code&gt;Date&lt;/code&gt; filters. Suddenly requirements have changed (that never happens) and we need all of our default dates to be &lt;code&gt;'shortDate'&lt;/code&gt; instead of &lt;code&gt;'mediumDate'&lt;/code&gt;.</source>
          <target state="translated">많은 &lt;code&gt;Date&lt;/code&gt; 필터에 기본 형식을 사용하는 앱을 만들었다 고 가정 해 보겠습니다 . 갑자기 요구 사항이 변경되어 (아무도 발생하지 않음) 모든 기본 날짜가 &lt;code&gt;'shortDate'&lt;/code&gt; 대신 &lt;code&gt;'mediumDate'&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7a869f2b1dc009607a199a9b62ccec65eadcb3a2" translate="yes" xml:space="preserve">
          <source>Let's say you are writing a banking app and you want to display an account balance of 1000 dollars. You write the following binding using the currency filter:</source>
          <target state="translated">은행 응용 프로그램을 작성 중이고 1000 달러의 계정 잔액을 표시하려고한다고 가정 해 봅시다. 통화 필터를 사용하여 다음 바인딩을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c628b1fd2c31e5e7025394209d765b5f5e59eda2" translate="yes" xml:space="preserve">
          <source>Let's say you have a chunk of your template that represents a customer's information. This template is repeated many times in your code. When you change it in one place, you have to change it in several others. This is a good opportunity to use a directive to simplify your template.</source>
          <target state="translated">고객 정보를 나타내는 템플릿 덩어리가 있다고 가정 해 봅시다. 이 템플릿은 코드에서 여러 번 반복됩니다. 한 곳에서 변경하면 다른 곳에서도 변경해야합니다. 이것은 지시문을 사용하여 템플릿을 단순화 할 수있는 좋은 기회입니다.</target>
        </trans-unit>
        <trans-unit id="c8c58cb6d56f10eb4cc5271ca81a0f4260534c05" translate="yes" xml:space="preserve">
          <source>Let's say, however, that we would also like to create a service that computes a token used for authentication against a remote API. This token will be called &lt;code&gt;apiToken&lt;/code&gt; and will be computed based on the &lt;code&gt;clientId&lt;/code&gt; value and a secret stored in the browser's local storage:</source>
          <target state="translated">그러나 원격 API에 대한 인증에 사용되는 토큰을 계산하는 서비스를 만들고 싶다고 가정 해 봅시다. 이 토큰은 &lt;code&gt;apiToken&lt;/code&gt; 이라고 하며 &lt;code&gt;clientId&lt;/code&gt; 값과 브라우저의 로컬 저장소에 저장된 비밀을 기반으로 계산 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb2113b148155b9fb3e678b86a1b6292b725041" translate="yes" xml:space="preserve">
          <source>Let's see an example of a enter/leave animation using &lt;code&gt;ngRepeat&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ngRepeat&lt;/code&gt; 을 사용한 enter / leave 애니메이션의 예를 보자 :</target>
        </trans-unit>
        <trans-unit id="dd679a2e36289a34afcd1847fbd10d9cfe7cf0a5" translate="yes" xml:space="preserve">
          <source>Let's start with an AngularJS app with no dependencies.</source>
          <target state="translated">종속성이없는 AngularJS 앱으로 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="853b64b22116270e945534edd7f9f969ae039277" translate="yes" xml:space="preserve">
          <source>Let's start with input fields for quantity and cost whose values are multiplied to produce the total of the invoice:</source>
          <target state="translated">송장 총액을 생성하기 위해 값을 곱한 수량 및 비용에 대한 입력 필드로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="3a87426a46ae3a1bd831c83a8ac22a86b6a2ddc6" translate="yes" xml:space="preserve">
          <source>Let's take a closer look at the scope option:</source>
          <target state="translated">범위 옵션을 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ad6f98d49bcc332ad093324b782e6e8ec7a31f24" translate="yes" xml:space="preserve">
          <source>Let's take a look at how we would create a very simple component via the directive api that depends on the &lt;code&gt;planetName&lt;/code&gt; constant we've just defined and displays the planet name, in our case: &quot;Planet Name: Greasy Giant&quot;.</source>
          <target state="translated">방금 정의한 &lt;code&gt;planetName&lt;/code&gt; 상수 에 의존 하고 행성 이름을 표시하는 지시문 api를 통해 매우 간단한 구성 요소를 만드는 방법을 살펴 보겠습니다.이 경우에는 &quot;Planet Name : Greasy Giant&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="02630abdf06f034279a0636877f3aa1fce289330" translate="yes" xml:space="preserve">
          <source>Let's take a look at the different scenarios for creating and using services via various recipe types. We'll start with the simplest case possible where various places in your code need a shared string and we'll accomplish this via Value recipe.</source>
          <target state="translated">다양한 레시피 유형을 통해 서비스를 생성하고 사용하기위한 다양한 시나리오를 살펴 보겠습니다. 코드의 여러 곳에 공유 문자열이 필요한 경우 가능한 가장 간단한 경우부터 시작하여 Value 레시피를 통해이 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="65084febdc505a3aedac5a7c194b2efa216e2144" translate="yes" xml:space="preserve">
          <source>Let's write some tests to show how to override configuration in tests.</source>
          <target state="translated">테스트에서 구성을 재정의하는 방법을 보여주는 몇 가지 테스트를 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7db120ff0add5b38c6339cbb76ef30243d16848f" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 3.0.</source>
          <target state="translated">Creative Commons Attribution License 3.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="e91f6ba4ec02c67a796600daa345b1a2b526d763" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 4.0.</source>
          <target state="translated">Creative Commons Attribution License 4.0에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="d3911533e30bd2745884e44a33dc2841ba42a193" translate="yes" xml:space="preserve">
          <source>Life-cycle hook examples</source>
          <target state="translated">수명주기 후크 예</target>
        </trans-unit>
        <trans-unit id="72d665ddd236e21d4dba142cf80503414b7be118" translate="yes" xml:space="preserve">
          <source>Life-cycle hooks</source>
          <target state="translated">수명주기 후크</target>
        </trans-unit>
        <trans-unit id="a28d0799ebeb3a447cb6b6539c436a3337a59d6e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;max&lt;/code&gt;, sets the &lt;code&gt;max&lt;/code&gt; validation error key if the value entered is greater than &lt;code&gt;ngMax&lt;/code&gt;, but does not trigger HTML5 native validation. Takes an expression.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 와 마찬가지로 입력 된 값이 &lt;code&gt;ngMax&lt;/code&gt; 보다 큰 경우 &lt;code&gt;max&lt;/code&gt; 유효성 검사 오류 키를 설정 하지만 HTML5 기본 유효성 검사를 트리거하지 않습니다. 표현을 취합니다.</target>
        </trans-unit>
        <trans-unit id="736200b3c3163acfc763d1dee6a087b566995823" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;min&lt;/code&gt;, sets the &lt;code&gt;min&lt;/code&gt; validation error key if the value entered is less than &lt;code&gt;ngMin&lt;/code&gt;, but does not trigger HTML5 native validation. Takes an expression.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 과 마찬가지로 입력 된 값이 &lt;code&gt;ngMin&lt;/code&gt; 미만인 경우 &lt;code&gt;min&lt;/code&gt; 유효성 검사 오류 키를 설정 하지만 HTML5 기본 유효성 검사를 트리거하지 않습니다. 표현을 취합니다.</target>
        </trans-unit>
        <trans-unit id="53200f8a62b7c0c12c64684c5c3a36ca905e973d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;step&lt;/code&gt;, sets the &lt;code&gt;step&lt;/code&gt; validation error key if the value entered does not fit the &lt;code&gt;ngStep&lt;/code&gt; constraint, but does not trigger HTML5 native validation. Takes an expression.</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 과 마찬가지로 입력 된 값이 &lt;code&gt;ngStep&lt;/code&gt; 제약 조건에 맞지 않지만 HTML5 기본 유효성 검사를 트리거하지 않는 경우 &lt;code&gt;step&lt;/code&gt; 유효성 검사 오류 키를 설정합니다 . 표현을 취합니다.</target>
        </trans-unit>
        <trans-unit id="ad7b72d8ff408e1dcf3b167cf8de1b0af89c8cd1" translate="yes" xml:space="preserve">
          <source>Like any software library, it is critical to keep AngularJS up to date. Please track the &lt;a href=&quot;https://github.com/angular/angular.js/blob/master/CHANGELOG.md&quot;&gt;CHANGELOG&lt;/a&gt; and make sure you are aware of upcoming security patches and other updates.</source>
          <target state="translated">다른 소프트웨어 라이브러리와 마찬가지로 AngularJS를 최신 상태로 유지하는 것이 중요합니다. &lt;a href=&quot;https://github.com/angular/angular.js/blob/master/CHANGELOG.md&quot;&gt;CHANGELOG를&lt;/a&gt; 추적하고 향후 보안 패치 및 기타 업데이트에 대해 알고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4aff2bb0aea69064ecfe10bde17f80bcd00b4eab" translate="yes" xml:space="preserve">
          <source>Like with &lt;code&gt;$provide.decorator&lt;/code&gt;, the &lt;code&gt;module.decorator&lt;/code&gt; function runs during the config phase of the app. That means you can define a &lt;code&gt;module.decorator&lt;/code&gt; before the decorated service is defined.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;$provide.decorator&lt;/code&gt; 의 &lt;code&gt;module.decorator&lt;/code&gt; 의 기능은 응용 프로그램의 설정 단계에서 실행됩니다. 즉 , 데코 레이팅 된 서비스가 정의되기 전에 &lt;code&gt;module.decorator&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a33352096ab23bfe64b61b04f4606de68cb10c82" translate="yes" xml:space="preserve">
          <source>Links starting with '/' that lead to a different base path</source>
          <target state="translated">다른 기본 경로로 연결되는 '/'로 시작하는 링크</target>
        </trans-unit>
        <trans-unit id="6c73374c914b151e896711eea2feec173d938d57" translate="yes" xml:space="preserve">
          <source>Links that contain &lt;code&gt;target&lt;/code&gt; element</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 요소 가 포함 된 링크</target>
        </trans-unit>
        <trans-unit id="82538d88e9ab837cce2872605a50080ea1374920" translate="yes" xml:space="preserve">
          <source>Listener directives, such as &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;ng-click&lt;/a&gt;, register a listener with the DOM. When the DOM listener fires, the directive executes the associated expression and updates the view using the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$apply()&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;ng-click&lt;/a&gt; 과 같은 리스너 지시문 은 리스너를 DOM에 등록합니다. DOM 리스너가 실행되면 지시문은 연관된 표현식을 실행하고 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$ apply ()&lt;/a&gt; 메소드를 사용하여 뷰를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="cd36de4b8e171b9332630e621a9c668d36e80403" translate="yes" xml:space="preserve">
          <source>Listens on events of a given type. See &lt;a href=&quot;%24rootscope.scope#%24emit.html&quot;&gt;$emit&lt;/a&gt; for discussion of event life cycle.</source>
          <target state="translated">주어진 유형의 이벤트를 수신합니다. 이벤트 수명주기에 대한 설명은 &lt;a href=&quot;%24rootscope.scope#%24emit.html&quot;&gt;$ emit&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5f227fbe66da636f154d7a55f6e58ac8bc7df94" translate="yes" xml:space="preserve">
          <source>Load the content of a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element into &lt;a href=&quot;../service/%24templatecache&quot;&gt;&lt;code&gt;$templateCache&lt;/code&gt;&lt;/a&gt;, so that the template can be used by &lt;a href=&quot;nginclude&quot;&gt;&lt;code&gt;ngInclude&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../ngroute/directive/ngview&quot;&gt;&lt;code&gt;ngView&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../../guide/directive&quot;&gt;directives&lt;/a&gt;. The type of the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element must be specified as &lt;code&gt;text/ng-template&lt;/code&gt;, and a cache name for the template must be assigned through the element's &lt;code&gt;id&lt;/code&gt;, which can then be used as a directive's &lt;code&gt;templateUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소 의 컨텐츠 를 &lt;a href=&quot;../service/%24templatecache&quot;&gt; &lt;code&gt;$templateCache&lt;/code&gt; &lt;/a&gt; 로 로드하여 &lt;a href=&quot;nginclude&quot;&gt; &lt;code&gt;ngInclude&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../ngroute/directive/ngview&quot;&gt; &lt;code&gt;ngView&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../guide/directive&quot;&gt;지시문&lt;/a&gt; 이 템플리트를 사용할 수 있도록하십시오 . &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소 의 유형은 &lt;code&gt;text/ng-template&lt;/code&gt; 으로 지정되어야하며 템플리트 의 캐시 이름은 요소의 &lt;code&gt;id&lt;/code&gt; 를 통해 지정되어야하며 , 지시문의 &lt;code&gt;templateUrl&lt;/code&gt; 로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2682f5818fdf3a2c34a3d670292ba36031d8c26" translate="yes" xml:space="preserve">
          <source>Load the content of a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element into &lt;a href=&quot;service/%24templatecache&quot;&gt;&lt;code&gt;$templateCache&lt;/code&gt;&lt;/a&gt;, so that the template can be used by &lt;a href=&quot;directive/nginclude&quot;&gt;&lt;code&gt;ngInclude&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../ngroute/directive/ngview&quot;&gt;&lt;code&gt;ngView&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../guide/directive&quot;&gt;directives&lt;/a&gt;. The type of the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element must be specified as &lt;code&gt;text/ng-template&lt;/code&gt;, and a cache name for the template must be assigned through the element's &lt;code&gt;id&lt;/code&gt;, which can then be used as a directive's &lt;code&gt;templateUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소 의 컨텐츠 를 &lt;a href=&quot;service/%24templatecache&quot;&gt; &lt;code&gt;$templateCache&lt;/code&gt; &lt;/a&gt; 로 로드하여 &lt;a href=&quot;directive/nginclude&quot;&gt; &lt;code&gt;ngInclude&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../ngroute/directive/ngview&quot;&gt; &lt;code&gt;ngView&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../guide/directive&quot;&gt;지시문&lt;/a&gt; 이 템플리트를 사용할 수 있도록하십시오 . &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소 의 유형은 &lt;code&gt;text/ng-template&lt;/code&gt; 으로 지정되어야하며 템플리트 의 캐시 이름은 요소의 &lt;code&gt;id&lt;/code&gt; 를 통해 지정되어야하며 , 지시문의 &lt;code&gt;templateUrl&lt;/code&gt; 로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="386bb84f82a8ccd818e6513db565d7414d459020" translate="yes" xml:space="preserve">
          <source>Loading &amp;hellip;</source>
          <target state="translated">로드 중&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="92daf596f9c7373f5742e7adea3239594ef098ac" translate="yes" xml:space="preserve">
          <source>Local Storage and session: &lt;a href=&quot;https://github.com/gsklee/ngStorage&quot;&gt;ngStorage&lt;/a&gt;</source>
          <target state="translated">로컬 스토리지 및 세션 : &lt;a href=&quot;https://github.com/gsklee/ngStorage&quot;&gt;ngStorage&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f197bc8d0c1a5832b3ddd1cbb680e16792aa794b" translate="yes" xml:space="preserve">
          <source>Local variables object, useful for overriding values in scope.</source>
          <target state="translated">로컬 변수 객체로 범위 내 값을 재정의하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9e2b5c22af01ee07caf3e1b6e0e50b119b72a276" translate="yes" xml:space="preserve">
          <source>Localizable pluralization is supported via the &lt;a href=&quot;../api/ng/directive/ngpluralize&quot;&gt;&lt;code&gt;ngPluralize&lt;/code&gt; directive&lt;/a&gt;. Additionally, you can use &lt;a href=&quot;i18n#messageformat-extensions.html&quot;&gt;MessageFormat extensions&lt;/a&gt; to &lt;code&gt;$interpolate&lt;/code&gt; for localizable pluralization and gender support in all interpolations via the &lt;code&gt;ngMessageFormat&lt;/code&gt; module.</source>
          <target state="translated">현지화 가능한 복수화는 &lt;a href=&quot;../api/ng/directive/ngpluralize&quot;&gt; &lt;code&gt;ngPluralize&lt;/code&gt; 지시문을&lt;/a&gt; 통해 지원됩니다 . 또한 &lt;a href=&quot;i18n#messageformat-extensions.html&quot;&gt;MessageFormat 확장&lt;/a&gt; 을 사용 하여 &lt;code&gt;ngMessageFormat&lt;/code&gt; 모듈을 통해 모든 보간에서 지역화 가능한 복수화 및 성별 지원을 위해 &lt;code&gt;$interpolate&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c38c9e8280edd6b4b9e66ce981d790b329a5986" translate="yes" xml:space="preserve">
          <source>Logically the rendering of &lt;code&gt;{{greeting}}&lt;/code&gt; involves:</source>
          <target state="translated">논리적으로 &lt;code&gt;{{greeting}}&lt;/code&gt; 의 렌더링 에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="88c1ecf02babeb5ad2e55e9263728fa80f7464a9" translate="yes" xml:space="preserve">
          <source>Looking at &lt;code&gt;index.html&lt;/code&gt;, the first &lt;code&gt;&amp;lt;my-customer&amp;gt;&lt;/code&gt; element binds the &lt;code&gt;info&lt;/code&gt; attribute to &lt;code&gt;naomi&lt;/code&gt;, which we have exposed on our controller's scope. The second binds &lt;code&gt;info&lt;/code&gt; to &lt;code&gt;igor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; 을 살펴보면 첫 번째 &lt;code&gt;&amp;lt;my-customer&amp;gt;&lt;/code&gt; 요소는 &lt;code&gt;info&lt;/code&gt; 속성을 &lt;code&gt;naomi&lt;/code&gt; 에 바인딩합니다.이 속성은 컨트롤러 범위에서 노출되었습니다. 두 번째는 &lt;code&gt;info&lt;/code&gt; 를 &lt;code&gt;igor&lt;/code&gt; 에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="e62713f092f6126d14c257b1a2ea3e1321cd8698" translate="yes" xml:space="preserve">
          <source>Looking back at &lt;code&gt;myPane&lt;/code&gt;'s definition, notice the last argument in its &lt;code&gt;link&lt;/code&gt; function: &lt;code&gt;tabsCtrl&lt;/code&gt;. When a directive requires a controller, it receives that controller as the fourth argument of its &lt;code&gt;link&lt;/code&gt; function. Taking advantage of this, &lt;code&gt;myPane&lt;/code&gt; can call the &lt;code&gt;addPane&lt;/code&gt; function of &lt;code&gt;myTabs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;myPane&lt;/code&gt; 의 정의를 되돌아 보면 &lt;code&gt;link&lt;/code&gt; 함수 의 마지막 인수 인 &lt;code&gt;tabsCtrl&lt;/code&gt; 에 주목하십시오 . 지시문에 컨트롤러가 필요한 경우 해당 컨트롤러를 &lt;code&gt;link&lt;/code&gt; 함수 의 네 번째 인수로받습니다 . 이을 활용, &lt;code&gt;myPane&lt;/code&gt; 가 부르는 할 수 &lt;code&gt;addPane&lt;/code&gt; 의 의 기능 &lt;code&gt;myTabs&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="84817f41d25fc5b19c9eb66508717663ce503692" translate="yes" xml:space="preserve">
          <source>MVC components in angular:</source>
          <target state="translated">각도의 MVC 구성 요소 :</target>
        </trans-unit>
        <trans-unit id="c4c061d266032ace287629ddef3b630f9da95456" translate="yes" xml:space="preserve">
          <source>Mailing List</source>
          <target state="translated">메일 링리스트</target>
        </trans-unit>
        <trans-unit id="2aed1946399b485ebf0139306da8f10efbf28a7d" translate="yes" xml:space="preserve">
          <source>Maintains synchronization between itself and the browser's URL when the user</source>
          <target state="translated">사용자가 자신과 브라우저의 URL 간 동기화 유지</target>
        </trans-unit>
        <trans-unit id="f4e937da2bde1d6d0cfc0d02a86baa0ee73041b8" translate="yes" xml:space="preserve">
          <source>Make sure to trigger the &lt;code&gt;doneFunction&lt;/code&gt; once the animation is fully complete.</source>
          <target state="translated">애니메이션이 완전히 완료되면 &lt;code&gt;doneFunction&lt;/code&gt; 을 트리거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="85f50f3c3504cad9a5153e8c3e0188d355cdd4c4" translate="yes" xml:space="preserve">
          <source>Manage the life-cycle of other components (for example, to create service instances).</source>
          <target state="translated">다른 구성 요소의 수명주기를 관리합니다 (예 : 서비스 인스턴스 생성).</target>
        </trans-unit>
        <trans-unit id="1849bd470e0a02c13c2a2ddb02f3758c9affbd6a" translate="yes" xml:space="preserve">
          <source>Manipulate DOM &amp;mdash; Controllers should contain only business logic. Putting any presentation logic into Controllers significantly affects its testability. AngularJS has &lt;a href=&quot;databinding&quot;&gt;databinding&lt;/a&gt; for most cases and &lt;a href=&quot;directive&quot;&gt;directives&lt;/a&gt; to encapsulate manual DOM manipulation.</source>
          <target state="translated">DOM 조작 &amp;mdash; 컨트롤러에는 비즈니스 로직 만 포함해야합니다. 프리젠 테이션 로직을 컨트롤러에 넣으면 테스트 가능성에 크게 영향을줍니다. AngularJS는 수동 DOM 조작을 캡슐화하기 위해 대부분의 경우에 대한 &lt;a href=&quot;databinding&quot;&gt;데이터 바인딩&lt;/a&gt; 과 &lt;a href=&quot;directive&quot;&gt;지시문&lt;/a&gt; 을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9af5b7cc102e62cfc978a4d85d9c90ff03b0df28" translate="yes" xml:space="preserve">
          <source>Manual Initialization</source>
          <target state="translated">수동 초기화</target>
        </trans-unit>
        <trans-unit id="90f5e60e65fca1294553bf2cd139697a3ef29d83" translate="yes" xml:space="preserve">
          <source>Map of service factory which need to be provided for the current scope. Defaults to &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng&quot;&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 범위에 제공해야하는 서비스 팩토리 맵. 기본값은 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng&quot;&gt; &lt;code&gt;ng&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ccbcbed9e1a75b205a840a23be21449dd188c578" translate="yes" xml:space="preserve">
          <source>Map of service factory which need to be provided for the current scope. Defaults to &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/api/ng&quot;&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 범위에 대해 제공해야하는 서비스 팩토리 맵입니다. 기본값은 &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/api/ng&quot;&gt; &lt;code&gt;ng&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5269958ad384de42d0b63bacb9f5157d606dc742" translate="yes" xml:space="preserve">
          <source>Mapping information to be assigned to &lt;code&gt;$route.current&lt;/code&gt; on route match.</source>
          <target state="translated">경로 일치시 &lt;code&gt;$route.current&lt;/code&gt; 에 할당 될 매핑 정보 .</target>
        </trans-unit>
        <trans-unit id="da3d8cef85e180466f01ff233815f53e0dd3ef41" translate="yes" xml:space="preserve">
          <source>Mapping information to be assigned to &lt;code&gt;$route.current&lt;/code&gt;. If called with a string, the value maps to &lt;code&gt;redirectTo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$route.current&lt;/code&gt; 할당 할 매핑 정보 . 문자열로 호출하면 값이 &lt;code&gt;redirectTo&lt;/code&gt; 에 매핑 됩니다 .</target>
        </trans-unit>
        <trans-unit id="44a921d79f06891bfc2ef6533b9ad081d31ae1c1" translate="yes" xml:space="preserve">
          <source>Matching Directives</source>
          <target state="translated">일치하는 지시어</target>
        </trans-unit>
        <trans-unit id="3e5d7daf956c2a40411ad8f2caaffa9353d8e9cb" translate="yes" xml:space="preserve">
          <source>Matching model and option values</source>
          <target state="translated">일치하는 모델 및 옵션 값</target>
        </trans-unit>
        <trans-unit id="ce55e08fd61078003560d3df48ca614d3ef433a6" translate="yes" xml:space="preserve">
          <source>Matching route requests</source>
          <target state="translated">일치하는 경로 요청</target>
        </trans-unit>
        <trans-unit id="a5beb361a1706e9b51cb40edde5a3ab468f07e34" translate="yes" xml:space="preserve">
          <source>Message order</source>
          <target state="translated">메시지 순서</target>
        </trans-unit>
        <trans-unit id="9344efa286fd5e9da95be089754f4d314f0c308d" translate="yes" xml:space="preserve">
          <source>MessageFormat extensions</source>
          <target state="translated">MessageFormat 확장</target>
        </trans-unit>
        <trans-unit id="f1702b4686278becffc88baabe6f4b7a8355532c" translate="yes" xml:space="preserve">
          <source>Messages</source>
          <target state="translated">Messages</target>
        </trans-unit>
        <trans-unit id="218cc71b2cafc9fcbd7fceeec963d55a35fec45c" translate="yes" xml:space="preserve">
          <source>Messages immediately follow a selection keyword and are optionally preceded by whitespace. They are written in single curly braces (&lt;code&gt;{}&lt;/code&gt;). They may contain AngularJS interpolation syntax inside them.</source>
          <target state="translated">메시지는 즉시 선택 키워드를 따르며 선택적으로 공백이 앞에옵니다. 중괄호 ( &lt;code&gt;{}&lt;/code&gt; )로 작성됩니다. 내부에 AngularJS 보간 구문이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22617e3b4156662ce4d8bd4830be681f85178aee" translate="yes" xml:space="preserve">
          <source>Messages immediately follow a selection keyword and are optionally preceded by whitespace. They are written in single curly braces (&lt;code&gt;{}&lt;/code&gt;). They may contain AngularJS interpolation syntax inside them. In addition, the &lt;code&gt;#&lt;/code&gt; symbol is a placeholder for the actual numeric value of the expression.</source>
          <target state="translated">메시지는 즉시 선택 키워드를 따르며 선택적으로 공백이 앞에옵니다. 중괄호 ( &lt;code&gt;{}&lt;/code&gt; )로 작성됩니다. 내부에 AngularJS 보간 구문이 포함될 수 있습니다. 또한 &lt;code&gt;#&lt;/code&gt; 기호는 표현식의 실제 숫자 값에 대한 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="4360339f6ba188dfc1f3a475e862ec2c0d68ad84" translate="yes" xml:space="preserve">
          <source>Method for serializing common AngularJS objects (scope, elements, etc..) into strings. It is useful for logging objects to the console when debugging.</source>
          <target state="translated">일반적인 AngularJS 객체 (범위, 요소 등)를 문자열로 직렬화하는 방법. 디버깅 할 때 콘솔에 객체를 기록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="43639e3b7d3b45a703fcba77c83b24edff6ec4cf" translate="yes" xml:space="preserve">
          <source>Method's `this`</source>
          <target state="translated">방법의`this`</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="b1d702459399a2512fba5a402d4d5f26aee34693" translate="yes" xml:space="preserve">
          <source>Mobile</source>
          <target state="translated">Mobile</target>
        </trans-unit>
        <trans-unit id="d724e7ec1e548df829cecc5ca677f6410b0ee24d" translate="yes" xml:space="preserve">
          <source>Mock implementation of &lt;a href=&quot;../../ng/service/%24exceptionhandler&quot;&gt;&lt;code&gt;$exceptionHandler&lt;/code&gt;&lt;/a&gt; that rethrows or logs errors passed to it. See &lt;a href=&quot;../provider/%24exceptionhandlerprovider&quot;&gt;$exceptionHandlerProvider&lt;/a&gt; for configuration information.</source>
          <target state="translated">전달 된 오류를 다시 발생 시키거나 기록하는 &lt;a href=&quot;../../ng/service/%24exceptionhandler&quot;&gt; &lt;code&gt;$exceptionHandler&lt;/code&gt; &lt;/a&gt; 의 모의 구현 . 구성 정보는 &lt;a href=&quot;../provider/%24exceptionhandlerprovider&quot;&gt;$ exceptionHandlerProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95690efafa1aec8a5967e5ca97f434409e9cbdee" translate="yes" xml:space="preserve">
          <source>Mock implementation of &lt;a href=&quot;../../ng/service/%24log&quot;&gt;&lt;code&gt;$log&lt;/code&gt;&lt;/a&gt; that gathers all logged messages in arrays (one array per logging level). These arrays are exposed as &lt;code&gt;logs&lt;/code&gt; property of each of the level-specific log function, e.g. for level &lt;code&gt;error&lt;/code&gt; the array is exposed as &lt;code&gt;$log.error.logs&lt;/code&gt;.</source>
          <target state="translated">로깅 된 모든 메시지를 배열 (로깅 레벨 당 하나의 배열)로 수집 하는 &lt;a href=&quot;../../ng/service/%24log&quot;&gt; &lt;code&gt;$log&lt;/code&gt; &lt;/a&gt; 의 모의 구현 . 이러한 배열은 각 수준별 로그 함수의 &lt;code&gt;logs&lt;/code&gt; 속성으로 노출됩니다 ( 예 : 레벨 &lt;code&gt;error&lt;/code&gt; 경우 배열은 &lt;code&gt;$log.error.logs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c792a9824ded906f50da531e1c45870b67a1a1f1" translate="yes" xml:space="preserve">
          <source>Mock implementation of &lt;a href=&quot;../ng/service/%24exceptionhandler&quot;&gt;&lt;code&gt;$exceptionHandler&lt;/code&gt;&lt;/a&gt; that rethrows or logs errors passed to it. See &lt;a href=&quot;provider/%24exceptionhandlerprovider&quot;&gt;$exceptionHandlerProvider&lt;/a&gt; for configuration information.</source>
          <target state="translated">전달 된 오류를 다시 발생 시키거나 기록하는 &lt;a href=&quot;../ng/service/%24exceptionhandler&quot;&gt; &lt;code&gt;$exceptionHandler&lt;/code&gt; &lt;/a&gt; 의 모의 구현 . 구성 정보는 &lt;a href=&quot;provider/%24exceptionhandlerprovider&quot;&gt;$ exceptionHandlerProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68cd4a92c7e27b6bb0d8d5d52580a952d3a23598" translate="yes" xml:space="preserve">
          <source>Mock implementation of &lt;a href=&quot;../ng/service/%24log&quot;&gt;&lt;code&gt;$log&lt;/code&gt;&lt;/a&gt; that gathers all logged messages in arrays (one array per logging level). These arrays are exposed as &lt;code&gt;logs&lt;/code&gt; property of each of the level-specific log function, e.g. for level &lt;code&gt;error&lt;/code&gt; the array is exposed as &lt;code&gt;$log.error.logs&lt;/code&gt;.</source>
          <target state="translated">로깅 된 모든 메시지를 배열 (로깅 레벨 당 하나의 배열)로 수집 하는 &lt;a href=&quot;../ng/service/%24log&quot;&gt; &lt;code&gt;$log&lt;/code&gt; &lt;/a&gt; 의 모의 구현 . 이러한 배열은 각 수준별 로그 함수의 &lt;code&gt;logs&lt;/code&gt; 속성으로 노출됩니다 ( 예 : 레벨 &lt;code&gt;error&lt;/code&gt; 경우 배열은 &lt;code&gt;$log.error.logs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="752de6efdd11fb76bababaaf2aeeed8daf63a62a" translate="yes" xml:space="preserve">
          <source>Mock implementation of &lt;a href=&quot;ng/service/%24exceptionhandler&quot;&gt;&lt;code&gt;$exceptionHandler&lt;/code&gt;&lt;/a&gt; that rethrows or logs errors passed to it. See &lt;a href=&quot;ngmock/provider/%24exceptionhandlerprovider&quot;&gt;$exceptionHandlerProvider&lt;/a&gt; for configuration information.</source>
          <target state="translated">전달 된 오류를 다시 발생 시키거나 기록하는 &lt;a href=&quot;ng/service/%24exceptionhandler&quot;&gt; &lt;code&gt;$exceptionHandler&lt;/code&gt; &lt;/a&gt; 의 모의 구현 . 구성 정보는 &lt;a href=&quot;ngmock/provider/%24exceptionhandlerprovider&quot;&gt;$ exceptionHandlerProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6663abd0c82d9922ac001aab44db50268d035bb7" translate="yes" xml:space="preserve">
          <source>Mock implementation of &lt;a href=&quot;ng/service/%24log&quot;&gt;&lt;code&gt;$log&lt;/code&gt;&lt;/a&gt; that gathers all logged messages in arrays (one array per logging level). These arrays are exposed as &lt;code&gt;logs&lt;/code&gt; property of each of the level-specific log function, e.g. for level &lt;code&gt;error&lt;/code&gt; the array is exposed as &lt;code&gt;$log.error.logs&lt;/code&gt;.</source>
          <target state="translated">로깅 된 모든 메시지를 배열 (로깅 레벨 당 하나의 배열)로 수집 하는 &lt;a href=&quot;ng/service/%24log&quot;&gt; &lt;code&gt;$log&lt;/code&gt; &lt;/a&gt; 의 모의 구현 . 이러한 배열은 각 수준별 로그 함수의 &lt;code&gt;logs&lt;/code&gt; 속성으로 노출됩니다 ( 예 : 레벨 &lt;code&gt;error&lt;/code&gt; 경우 배열은 &lt;code&gt;$log.error.logs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a4f99f800b8c2a3c8606af42b64ef2f40a52496" translate="yes" xml:space="preserve">
          <source>Mock implementation of the $interval service.</source>
          <target state="translated">$ interval 서비스의 모의 구현.</target>
        </trans-unit>
        <trans-unit id="17e556de84f8d6be56cb0a460b4ed4cfe2347048" translate="yes" xml:space="preserve">
          <source>Mock implementation of the &lt;a href=&quot;../../ng/service/%24animate&quot;&gt;&lt;code&gt;$animate&lt;/code&gt;&lt;/a&gt; service. Exposes two additional methods for testing animations.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24animate&quot;&gt; &lt;code&gt;$animate&lt;/code&gt; &lt;/a&gt; 서비스 의 모의 구현 . 애니메이션 테스트를위한 두 가지 추가 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5cb86aae12fa34c71428443e8ea53d839ee3299" translate="yes" xml:space="preserve">
          <source>Mock implementation of the &lt;a href=&quot;../ng/service/%24animate&quot;&gt;&lt;code&gt;$animate&lt;/code&gt;&lt;/a&gt; service. Exposes two additional methods for testing animations.</source>
          <target state="translated">&lt;a href=&quot;../ng/service/%24animate&quot;&gt; &lt;code&gt;$animate&lt;/code&gt; &lt;/a&gt; 서비스 의 모의 구현 . 애니메이션 테스트를위한 두 가지 추가 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="50e36573f2e41d3b17e543c2e8cd625f0cb46dd2" translate="yes" xml:space="preserve">
          <source>Mock implementation of the &lt;a href=&quot;ng/service/%24animate&quot;&gt;&lt;code&gt;$animate&lt;/code&gt;&lt;/a&gt; service. Exposes two additional methods for testing animations.</source>
          <target state="translated">&lt;a href=&quot;ng/service/%24animate&quot;&gt; &lt;code&gt;$animate&lt;/code&gt; &lt;/a&gt; 서비스 의 모의 구현 . 애니메이션 테스트를위한 두 가지 추가 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2283a4fa911cb4d414dca0de238334e1c9113cf1" translate="yes" xml:space="preserve">
          <source>Mock of the Date type which has its timezone specified via constructor arg.</source>
          <target state="translated">생성자 arg를 통해 시간대가 지정된 날짜 유형의 모형.</target>
        </trans-unit>
        <trans-unit id="2103a63a9856b3815fb037adeec81b1f3b88e8c7" translate="yes" xml:space="preserve">
          <source>Mode of operation, defaults to &lt;code&gt;rethrow&lt;/code&gt;.</source>
          <target state="translated">작동 모드, 기본값은 &lt;code&gt;rethrow&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="d10c1d6ff062accb0017a7a34ed190f79cc9dc67" translate="yes" xml:space="preserve">
          <source>Model &amp;mdash; Models are the properties of a scope; scopes are attached to the DOM where scope properties are accessed through bindings.</source>
          <target state="translated">모델 &amp;mdash; 모델은 범위의 속성입니다. 범위는 바인딩을 통해 범위 속성에 액세스하는 DOM에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a0babb0f360230e95d42d97a77bd9a2ca869ead1" translate="yes" xml:space="preserve">
          <source>Model updates and validation</source>
          <target state="translated">모델 업데이트 및 검증</target>
        </trans-unit>
        <trans-unit id="11d8a9f1a171b04d6657a278d94d71665b02f7f3" translate="yes" xml:space="preserve">
          <source>ModelOptions</source>
          <target state="translated">ModelOptions</target>
        </trans-unit>
        <trans-unit id="45054a7aa80d7c8287ad5c465dc0e7de6ba32a41" translate="yes" xml:space="preserve">
          <source>Modern browser will rewrite hashbang URLs to regular URLs.</source>
          <target state="translated">최신 브라우저는 hashbang URL을 일반 URL로 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="820d0a285c630d7723527339445562c6186a70c3" translate="yes" xml:space="preserve">
          <source>Modifies the default behavior of the html a tag so that the default action is prevented when the href attribute is empty.</source>
          <target state="translated">href 속성이 비어있을 때 기본 동작이 방지되도록 HTML의 기본 동작에 태그를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="60affe2a59dff1baf449afaa8e69c15e4a1a2bd0" translate="yes" xml:space="preserve">
          <source>Modifying built-in validators</source>
          <target state="translated">내장 유효성 검사기 수정</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="b4e47c4a8861a9aac47d0d5b25ff49b2077eaa5b" translate="yes" xml:space="preserve">
          <source>Module Components</source>
          <target state="translated">모듈 구성 요소</target>
        </trans-unit>
        <trans-unit id="d81b6c3fe7d7f3ded3174d2cd156b032d228112b" translate="yes" xml:space="preserve">
          <source>Module Loading</source>
          <target state="translated">모듈 로딩</target>
        </trans-unit>
        <trans-unit id="b3c0d8ccd032afe728bc7677d8f1b82146252c2e" translate="yes" xml:space="preserve">
          <source>Module Methods</source>
          <target state="translated">모듈 방법</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="f5676031d7eb7334f1e212a85e0629bf21c4a263" translate="yes" xml:space="preserve">
          <source>Modules are a way of managing $injector configuration, and have nothing to do with loading of scripts into a VM. There are existing projects which deal with script loading, which may be used with AngularJS. Because modules do nothing at load time they can be loaded into the VM in any order and thus script loaders can take advantage of this property and parallelize the loading process.</source>
          <target state="translated">모듈은 $ injector 구성을 관리하는 방법이며 스크립트를 VM에로드하는 것과는 아무런 관련이 없습니다. AngularJS와 함께 사용할 수있는 스크립트 로딩을 다루는 기존 프로젝트가 있습니다. 로드시 모듈은 아무 것도 수행하지 않기 때문에 어떤 순서로든 VM에로드 할 수 있으므로 스크립트 로더는이 특성을 활용하고로드 프로세스를 병렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf8a006e80c713702e5a7c272966dd2af4a2f36" translate="yes" xml:space="preserve">
          <source>Modules can list other modules as their dependencies. Depending on a module implies that the required module will be loaded before the requiring module is loaded.</source>
          <target state="translated">모듈은 다른 모듈을 해당 종속성으로 나열 할 수 있습니다. 모듈에 따라 필요한 모듈이로드되기 전에 필요한 모듈이로드됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c5c5ac536e9458ce6b1c893d8a9eed0ef866164a" translate="yes" xml:space="preserve">
          <source>Modules cannot be unloaded.</source>
          <target state="translated">모듈을 언로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3eef75b2abb3353ef96fa4c958b29a3b973ad79" translate="yes" xml:space="preserve">
          <source>More Advanced Uses</source>
          <target state="translated">더 고급 사용</target>
        </trans-unit>
        <trans-unit id="418d11009885a828d7747f211903e923c55650a8" translate="yes" xml:space="preserve">
          <source>More Topics</source>
          <target state="translated">더 많은 주제</target>
        </trans-unit>
        <trans-unit id="9e1aceda0913803b7af1cbac40b818d7b4e0a493" translate="yes" xml:space="preserve">
          <source>More about animations</source>
          <target state="translated">애니메이션에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="ff1c8d0ffd1a8365adbfecdf5260da4ce1225fe0" translate="yes" xml:space="preserve">
          <source>More information about using &lt;code&gt;ngMessage&lt;/code&gt; can be found in the &lt;a href=&quot;../../ngmessages&quot;&gt;&lt;code&gt;ngMessages&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">사용에 대한 자세한 내용 &lt;code&gt;ngMessage&lt;/code&gt; 는 에서 찾을 수 있습니다 &lt;a href=&quot;../../ngmessages&quot;&gt; &lt;code&gt;ngMessages&lt;/code&gt; 모듈 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b67e8753649b7d6d8714798e1353c9a36bc83e4" translate="yes" xml:space="preserve">
          <source>More information about using &lt;code&gt;ngMessageDefault&lt;/code&gt; can be found in the &lt;a href=&quot;../../ngmessages&quot;&gt;&lt;code&gt;ngMessages&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">사용에 대한 자세한 내용 &lt;code&gt;ngMessageDefault&lt;/code&gt; 는 에서 찾을 수 있습니다 &lt;a href=&quot;../../ngmessages&quot;&gt; &lt;code&gt;ngMessages&lt;/code&gt; 모듈 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86538f30d68e13efb3ce4ea2e7bb61bbd3bdb2ef" translate="yes" xml:space="preserve">
          <source>More specifically, it follows these steps to determine the relative order of items:</source>
          <target state="translated">보다 구체적으로, 다음 단계에 따라 항목의 상대적 순서를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7d5c68a394c71124c6fcf54230d4eeb10dd1d33a" translate="yes" xml:space="preserve">
          <source>Moreover, additional dependencies are made available to Controllers:</source>
          <target state="translated">또한 컨트롤러에 추가 종속성이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="712827c0d97b4d3b4a04a5896cfe1915383ddc14" translate="yes" xml:space="preserve">
          <source>Most applications have a main method that instantiates and wires together the different parts of the application.</source>
          <target state="translated">대부분의 응용 프로그램에는 응용 프로그램의 다른 부분을 인스턴스화하고 함께 연결하는 기본 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="51bcbe4ed0c2178dc07e3908a9fd0bee0ee90626" translate="yes" xml:space="preserve">
          <source>Most modern search engines are able to crawl AJAX applications with dynamic content, provided all included resources are available to the crawler bots.</source>
          <target state="translated">포함 된 모든 리소스를 크롤러 봇에서 사용할 수있는 경우 대부분의 최신 검색 엔진은 동적 콘텐츠로 AJAX 응용 프로그램을 크롤링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="747ba7435637638bbd15e8ae21703dcf856ff388" translate="yes" xml:space="preserve">
          <source>Most of what ngAria does is only visible &quot;under the hood&quot;. To see the module in action, once you've added it as a dependency, you can test a few things:</source>
          <target state="translated">ngAria가하는 대부분의 작업은 &quot;후드&quot;아래에서만 보입니다. 모듈이 작동하는지 확인하려면 모듈을 종속성으로 추가 한 후 몇 가지 사항을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f501e7075bf76219f10ebfc5ad08e05b72506c" translate="yes" xml:space="preserve">
          <source>Most other templating systems consume a static string template and combine it with data, resulting in a new string. The resulting text is then &lt;code&gt;innerHTML&lt;/code&gt;ed into an element.</source>
          <target state="translated">대부분의 다른 템플릿 시스템은 정적 문자열 템플릿을 사용하여 데이터와 결합하여 새 문자열을 만듭니다. 그런 다음 결과 텍스트는 &lt;code&gt;innerHTML&lt;/code&gt; 로 요소에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="086508416bb179789c4bccdcedba3ca8939c6c3f" translate="yes" xml:space="preserve">
          <source>Most templating systems bind data in only one direction: they merge template and model components together into a view. After the merge occurs, changes to the model or related sections of the view are NOT automatically reflected in the view. Worse, any changes that the user makes to the view are not reflected in the model. This means that the developer has to write code that constantly syncs the view with the model and the model with the view.</source>
          <target state="translated">대부분의 템플릿 시스템은 데이터를 한 방향으로 만 바인딩합니다. 템플릿과 모델 구성 요소를 하나의 뷰로 병합합니다. 병합이 발생한 후 뷰의 모델 또는 관련 섹션에 대한 변경 사항이 뷰에 자동으로 반영되지 않습니다. 더군다나 사용자가 뷰를 변경하면 모델에 반영되지 않습니다. 즉, 개발자는 뷰를 모델과 지속적으로 동기화하고 모델을 뷰와 동기화하는 코드를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d52bae3c10aff36233610ff3bdec1bf84f987e77" translate="yes" xml:space="preserve">
          <source>Much of ngAria's heavy lifting happens in the &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;ngModel&lt;/a&gt; directive. For elements using ngModel, special attention is paid by ngAria if that element also has a role or type of &lt;code&gt;checkbox&lt;/code&gt;, &lt;code&gt;radio&lt;/code&gt;, &lt;code&gt;range&lt;/code&gt; or &lt;code&gt;textbox&lt;/code&gt;.</source>
          <target state="translated">ngAria의 무거운의 대부분은에서 발생 &lt;a href=&quot;../api/ng/directive/ngmodel&quot;&gt;ngModel의&lt;/a&gt; 지시어. ngModel을 사용하는 요소의 경우 해당 요소에도 &lt;code&gt;checkbox&lt;/code&gt; , &lt;code&gt;radio&lt;/code&gt; , &lt;code&gt;range&lt;/code&gt; 또는 &lt;code&gt;textbox&lt;/code&gt; 의 역할 또는 유형이있는 경우 ngAria가 특별한주의를 기울입니다 .</target>
        </trans-unit>
        <trans-unit id="41d3f0ba4eb4a4f6a8f2357e3f45a9724879b4b6" translate="yes" xml:space="preserve">
          <source>Much simpler!</source>
          <target state="translated">훨씬 간단합니다!</target>
        </trans-unit>
        <trans-unit id="8c836dc52529f23f775aa7226aae8e07d35fcd7a" translate="yes" xml:space="preserve">
          <source>Multi-slot transclusion</source>
          <target state="translated">멀티 슬롯 트랜 슬 레이션</target>
        </trans-unit>
        <trans-unit id="65cb2723f95ca2511451a3da1b3266635717e52a" translate="yes" xml:space="preserve">
          <source>Multiple directives trying to manage the suspended status of a scope can confuse each other:</source>
          <target state="translated">범위의 일시 중단 상태를 관리하려는 여러 지시문이 서로 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ee7b873340c29badb35669536547e420b30242" translate="yes" xml:space="preserve">
          <source>Must be set to &lt;code&gt;'text/ng-template'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'text/ng-template'&lt;/code&gt; 으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="6482d00c26b4ecb8dd78f5db3674319bacb19283" translate="yes" xml:space="preserve">
          <source>NOTE: This method is supported only in HTML5 mode and only in browsers supporting the HTML5 History API (i.e. methods &lt;code&gt;pushState&lt;/code&gt; and &lt;code&gt;replaceState&lt;/code&gt;). If you need to support older browsers (like IE9 or Android &amp;lt; 4.0), don't use this method.</source>
          <target state="translated">참고 :이 메소드는 HTML5 모드 및 HTML5 히스토리 API를 지원하는 브라우저에서만 지원됩니다 (즉, &lt;code&gt;pushState&lt;/code&gt; 및 &lt;code&gt;replaceState&lt;/code&gt; 메소드 ). IE9 또는 Android &amp;lt;4.0과 같은 이전 브라우저를 지원해야하는 경우이 방법을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="9407fb27f323515c53fff87ba47269667f06a0ad" translate="yes" xml:space="preserve">
          <source>Name of a constructor function registered with the current &lt;a href=&quot;../provider/%24controllerprovider&quot;&gt;$controllerProvider&lt;/a&gt; or an &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; that on the current scope evaluates to a constructor function.</source>
          <target state="translated">현재 &lt;a href=&quot;../provider/%24controllerprovider&quot;&gt;$ controllerProvider에&lt;/a&gt; 등록 된 생성자 함수의 이름 또는 현재 범위에서 생성자 함수로 평가 되는 &lt;a href=&quot;../../../guide/expression&quot;&gt;표현식&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06124546cb53397fd0c1fe917a2d06c9730752d5" translate="yes" xml:space="preserve">
          <source>Name of the component in camelCase (i.e. &lt;code&gt;myComp&lt;/code&gt; which will match &lt;code&gt;&amp;lt;my-comp&amp;gt;&lt;/code&gt;), or an object map of components where the keys are the names and the values are the component definition objects.</source>
          <target state="translated">camelCase의 구성 요소 이름 (예 : &lt;code&gt;&amp;lt;my-comp&amp;gt;&lt;/code&gt; 와 일치하는 &lt;code&gt;myComp&lt;/code&gt; ) 또는 키가 이름이고 값이 구성 요소 정의 오브젝트 인 구성 요소의 오브젝트 맵.</target>
        </trans-unit>
        <trans-unit id="072d5c784d720162e01f22fc1db2129c7f844161" translate="yes" xml:space="preserve">
          <source>Name of the directive in camel-case (i.e. &lt;code&gt;ngBind&lt;/code&gt; which will match as &lt;code&gt;ng-bind&lt;/code&gt;), or an object map of directives where the keys are the names and the values are the factories.</source>
          <target state="translated">camel-case의 지시어 이름 (예 : &lt;code&gt;ng-bind&lt;/code&gt; 와 일치하는 &lt;code&gt;ngBind&lt;/code&gt; ) 또는 키가 이름이고 값이 팩토리 인 지시어의 객체 맵입니다.</target>
        </trans-unit>
        <trans-unit id="e6a914b6fb9551d259b79ae1dbd0cd9ae591131f" translate="yes" xml:space="preserve">
          <source>Name of the filter function to retrieve</source>
          <target state="translated">검색 할 필터 함수의 이름</target>
        </trans-unit>
        <trans-unit id="48fe49bedf694afeeba33df340c5f5206f900829" translate="yes" xml:space="preserve">
          <source>Name of the filter function, or an object map of filters where the keys are the filter names and the values are the filter factories.</source>
          <target state="translated">필터 함수의 이름 또는 키가 필터 이름이고 값이 필터 팩토리 인 필터의 객체 맵.</target>
        </trans-unit>
        <trans-unit id="548763f0d3866204ba6e7b35db5d3f96ad31cf16" translate="yes" xml:space="preserve">
          <source>Name of the form. If specified, the form controller will be published into related scope, under this name.</source>
          <target state="translated">양식의 이름입니다. 지정된 경우, 양식 제어기는이 이름으로 관련 범위에 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="9e53ab7e7738ab49a15d16836113abe4d510b286" translate="yes" xml:space="preserve">
          <source>Name of the form. If specified, the form controller will be published into the related scope, under this name.</source>
          <target state="translated">양식의 이름입니다. 지정하면 양식 제어기가이 이름으로 관련 범위에 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0878caaba3e3087d38d9fa863cec474456870b" translate="yes" xml:space="preserve">
          <source>Name of the module.</source>
          <target state="translated">모듈 이름.</target>
        </trans-unit>
        <trans-unit id="18fd8b70f87ab6b31b561c63ec64d92c5698eb18" translate="yes" xml:space="preserve">
          <source>Name of the service to query.</source>
          <target state="translated">조회 할 서비스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="82cb2408f4510676ea3921c7dc32b0ed22111b44" translate="yes" xml:space="preserve">
          <source>Name of the validator. The &lt;code&gt;validationErrorKey&lt;/code&gt; will be assigned to either &lt;code&gt;$error[validationErrorKey]&lt;/code&gt; or &lt;code&gt;$pending[validationErrorKey]&lt;/code&gt; (for unfulfilled &lt;code&gt;$asyncValidators&lt;/code&gt;), so that it is available for data-binding. The &lt;code&gt;validationErrorKey&lt;/code&gt; should be in camelCase and will get converted into dash-case for class name. Example: &lt;code&gt;myError&lt;/code&gt; will result in &lt;code&gt;ng-valid-my-error&lt;/code&gt; and &lt;code&gt;ng-invalid-my-error&lt;/code&gt; classes and can be bound to as &lt;code&gt;{{ someForm.$error.myError }}&lt;/code&gt;.</source>
          <target state="translated">유효성 검사기의 이름입니다. &lt;code&gt;validationErrorKey&lt;/code&gt; 는 하나에 할당 될 &lt;code&gt;$error[validationErrorKey]&lt;/code&gt; 또는 &lt;code&gt;$pending[validationErrorKey]&lt;/code&gt; (이루지위한 &lt;code&gt;$asyncValidators&lt;/code&gt; ), 그래서 데이터 바인딩에 사용할 수있다. &lt;code&gt;validationErrorKey&lt;/code&gt; 은 낙타 표기법에 있어야하고 클래스 이름 대시의 경우로 변환 얻을 것이다. 예 : &lt;code&gt;myError&lt;/code&gt; 는 &lt;code&gt;ng-valid-my-error&lt;/code&gt; 및 &lt;code&gt;ng-invalid-my-error&lt;/code&gt; 클래스가되며 &lt;code&gt;{{ someForm.$error.myError }}&lt;/code&gt; 로 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85289b1ba972a7f24ee7623acf7573ae60b50a4a" translate="yes" xml:space="preserve">
          <source>Name of the validator. The &lt;code&gt;validationErrorKey&lt;/code&gt; will be assigned to either &lt;code&gt;$error[validationErrorKey]&lt;/code&gt; or &lt;code&gt;$pending[validationErrorKey]&lt;/code&gt; (for unfulfilled &lt;code&gt;$asyncValidators&lt;/code&gt;), so that it is available for data-binding. The &lt;code&gt;validationErrorKey&lt;/code&gt; should be in camelCase and will get converted into dash-case for class name. Example: &lt;code&gt;myError&lt;/code&gt; will result in &lt;code&gt;ng-valid-my-error&lt;/code&gt; and &lt;code&gt;ng-invalid-my-error&lt;/code&gt; classes and can be bound to as &lt;code&gt;{{ someForm.someControl.$error.myError }}&lt;/code&gt;.</source>
          <target state="translated">유효성 검사기의 이름입니다. &lt;code&gt;validationErrorKey&lt;/code&gt; 는 하나에 할당 될 &lt;code&gt;$error[validationErrorKey]&lt;/code&gt; 또는 &lt;code&gt;$pending[validationErrorKey]&lt;/code&gt; (이루지위한 &lt;code&gt;$asyncValidators&lt;/code&gt; ), 그래서 데이터 바인딩에 사용할 수있다. &lt;code&gt;validationErrorKey&lt;/code&gt; 은 낙타 표기법에 있어야하고 클래스 이름 대시의 경우로 변환 얻을 것이다. 예 : &lt;code&gt;myError&lt;/code&gt; 는 &lt;code&gt;ng-valid-my-error&lt;/code&gt; 및 &lt;code&gt;ng-invalid-my-error&lt;/code&gt; 클래스가되며 &lt;code&gt;{{ someForm.someControl.$error.myError }}&lt;/code&gt; 로 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6dadcd7b87a8d68370b138a9b117a7ab56bec1f" translate="yes" xml:space="preserve">
          <source>Name or id of a cache to access.</source>
          <target state="translated">액세스 할 캐시의 이름 또는 ID입니다.</target>
        </trans-unit>
        <trans-unit id="1cc839cd419511980445e1dd8371a817f1b64734" translate="yes" xml:space="preserve">
          <source>Name or id of the newly created cache.</source>
          <target state="translated">새로 작성된 캐시의 이름 또는 ID입니다.</target>
        </trans-unit>
        <trans-unit id="0de929bec5077041e37d818b7a7097719fecd549" translate="yes" xml:space="preserve">
          <source>Name to normalize</source>
          <target state="translated">정규화 할 이름</target>
        </trans-unit>
        <trans-unit id="07487ab347f8a5946bbf4a7ce75a38afca586f21" translate="yes" xml:space="preserve">
          <source>Namespace from 'angular-mocks.js' which contains testing related code.</source>
          <target state="translated">테스트 관련 코드가 포함 된 'angular-mocks.js'의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="34956fb712b5af5e64b1d1e8c8bcaf652008c2f6" translate="yes" xml:space="preserve">
          <source>Native range input with validation and transformation.</source>
          <target state="translated">유효성 검사 및 변환을 통한 기본 범위 입력.</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="309c7dfccaca7701bd78f84e8b381d4d0275d9db" translate="yes" xml:space="preserve">
          <source>New URL</source>
          <target state="translated">새로운 URL</target>
        </trans-unit>
        <trans-unit id="a014f3cd7850f6e9c71c46467e552b11d3de79a6" translate="yes" xml:space="preserve">
          <source>New URL without base prefix (e.g. &lt;code&gt;/path?a=b#hash&lt;/code&gt;)</source>
          <target state="translated">기본 접두사가없는 새 URL (예 : &lt;code&gt;/path?a=b#hash&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6165acb81f2917de772cffb70b019703cffc138d" translate="yes" xml:space="preserve">
          <source>New hash fragment</source>
          <target state="translated">새로운 해시 조각</target>
        </trans-unit>
        <trans-unit id="5a73ca3fba6bb247c517d68e0cd4de0f73708ffb" translate="yes" xml:space="preserve">
          <source>New history state object</source>
          <target state="translated">새로운 히스토리 상태 오브젝트</target>
        </trans-unit>
        <trans-unit id="1523c8acdb2ee4d7786ae768261d0c785a7a6dd4" translate="yes" xml:space="preserve">
          <source>New path</source>
          <target state="translated">새로운 길</target>
        </trans-unit>
        <trans-unit id="8db704d10996287f306c82d9804ae000900aa1c3" translate="yes" xml:space="preserve">
          <source>New regexp to trust urls with.</source>
          <target state="translated">URL을 신뢰할 수있는 새 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="20f8323c20517bd9bedeb523464666a743f37eca" translate="yes" xml:space="preserve">
          <source>New regexp to whitelist urls with.</source>
          <target state="translated">URL을 허용하는 새로운 정규 표현식.</target>
        </trans-unit>
        <trans-unit id="dad34ec1ee8bacd2e9041cd0903b5c9069ff92f6" translate="yes" xml:space="preserve">
          <source>New search params - string or hash object.</source>
          <target state="translated">새로운 검색 매개 변수-문자열 또는 해시 객체.</target>
        </trans-unit>
        <trans-unit id="b804c31a8623f2816dbf7f69ecf28929e801a795" translate="yes" xml:space="preserve">
          <source>Newly created cache object with the following set of methods:</source>
          <target state="translated">다음과 같은 메소드 세트를 사용하여 새로 작성된 캐시 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="329a1c91ff3f72a700f6b29e306ae7d1fe09310b" translate="yes" xml:space="preserve">
          <source>Newly created scope.</source>
          <target state="translated">새로 생성 된 범위.</target>
        </trans-unit>
        <trans-unit id="61456090d5fe7bf739399fed88265d12f9613af2" translate="yes" xml:space="preserve">
          <source>Next, we want to add buttons to this dialog box, and allow someone using the directive to bind their own behavior to it.</source>
          <target state="translated">다음으로이 대화 상자에 버튼을 추가하고 지시문을 사용하는 사람이 자신의 동작을 바인딩하도록 허용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="c4d55e8a99a370ad4de49aff15c4c44511823de9" translate="yes" xml:space="preserve">
          <source>No (restricted to elements only)</source>
          <target state="translated">아니오 (요소로만 제한됨)</target>
        </trans-unit>
        <trans-unit id="109595eb5dc1869fbf21a971f7aa0f381c49f943" translate="yes" xml:space="preserve">
          <source>No (scope is always isolate)</source>
          <target state="translated">아니요 (범위는 항상 분리됨)</target>
        </trans-unit>
        <trans-unit id="2f486ce8e2e4c561b4a09d4b910696530061716a" translate="yes" xml:space="preserve">
          <source>No (use bindings instead)</source>
          <target state="translated">아니요 (바인딩 대신 사용)</target>
        </trans-unit>
        <trans-unit id="680a8d06076faf3861dc12dd6c01bc3981abc532" translate="yes" xml:space="preserve">
          <source>No Control Flow Statements</source>
          <target state="translated">제어 흐름 문 없음</target>
        </trans-unit>
        <trans-unit id="62ba91f2c31ef5c4a122749bdddf7004b57597ab" translate="yes" xml:space="preserve">
          <source>No conversion; the object itself is used.</source>
          <target state="translated">전환 없음; 객체 자체가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b477c2fb0db2220aabe25a86981bcf26c5b788ac" translate="yes" xml:space="preserve">
          <source>No declaration means that AngularJS will assume that you can do inline styles, but it will do a runtime check for unsafe-eval. E.g. &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. This is backwardly compatible with previous versions of AngularJS.</source>
          <target state="translated">선언이 없으면 AngularJS는 인라인 스타일을 수행 할 수 있다고 가정하지만 unsafe-eval에 대한 런타임 검사를 수행합니다. 예 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; . 이전 버전의 AngularJS와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="6eb8bd5e680e864c50300934b57de696d6282a04" translate="yes" xml:space="preserve">
          <source>No function declarations or RegExp creation with literal notation</source>
          <target state="translated">리터럴 표기법으로 함수 선언 또는 RegExp 작성 없음</target>
        </trans-unit>
        <trans-unit id="3ddeaa27a6c6629f743c53a762ac439d7628c772" translate="yes" xml:space="preserve">
          <source>Non-immediate (debounced) model updates</source>
          <target state="translated">즉각적이지 않은 (신고 된) 모델 업데이트</target>
        </trans-unit>
        <trans-unit id="b8c54e5e1e867a54e9d75697c450f4be835f910e" translate="yes" xml:space="preserve">
          <source>Normalization</source>
          <target state="translated">Normalization</target>
        </trans-unit>
        <trans-unit id="0538f85d0c3c3f8fa12699be15d0d496f65654b6" translate="yes" xml:space="preserve">
          <source>Normalized element attribute name of the property to modify. The name is reverse-translated using the &lt;a href=&quot;%24compile.directive.attributes#%24attr.html&quot;&gt;$attr&lt;/a&gt; property to the original name.</source>
          <target state="translated">수정할 속성의 정규화 된 요소 특성 이름입니다. 이름은 &lt;a href=&quot;%24compile.directive.attributes#%24attr.html&quot;&gt;$ attr&lt;/a&gt; 속성을 사용하여 원래 이름으로 역변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="42edd323f35213654eaf5568a5b6ad2beea08650" translate="yes" xml:space="preserve">
          <source>Normalized key. (ie ngAttribute) .</source>
          <target state="translated">정규화 된 키. (즉 ngAttribute).</target>
        </trans-unit>
        <trans-unit id="ed68fc07c0bcd36453eb89a7b1304551a073ed7f" translate="yes" xml:space="preserve">
          <source>Note also that component directives, which are created with the &lt;a href=&quot;../api/ng/type/angular.module#component.html&quot;&gt;.component()&lt;/a&gt; helper always create an isolate scope.</source>
          <target state="translated">또한 &lt;a href=&quot;../api/ng/type/angular.module#component.html&quot;&gt;.component ()&lt;/a&gt; 헬퍼 로 작성된 구성 요소 지시문은 항상 분리 범위를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="8aa993a00ba6dab2bd4ba7c5837f5d462e2f62de" translate="yes" xml:space="preserve">
          <source>Note however that the &lt;code&gt;$animate.enabled()&lt;/code&gt; state for individual elements does not overwrite disabling rules that have been set in the &lt;a href=&quot;../api/ng/provider/%24animateprovider#classNameFilter.html&quot;&gt;classNameFilter&lt;/a&gt;.</source>
          <target state="translated">그러나 개별 요소 의 &lt;code&gt;$animate.enabled()&lt;/code&gt; 상태는 &lt;a href=&quot;../api/ng/provider/%24animateprovider#classNameFilter.html&quot;&gt;classNameFilter&lt;/a&gt; 에 설정된 비활성화 규칙을 덮어 쓰지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5ee9f05a205194a145267c81de693fc4c5f07a17" translate="yes" xml:space="preserve">
          <source>Note in the example above how we can pass in &lt;code&gt;$event&lt;/code&gt; to &lt;code&gt;clickMe&lt;/code&gt;, but how it does not show up in &lt;code&gt;{{$event}}&lt;/code&gt;. This is because &lt;code&gt;$event&lt;/code&gt; is outside the scope of that binding.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;$event&lt;/code&gt; 를 &lt;code&gt;clickMe&lt;/code&gt; 에 전달할 수 있지만 &lt;code&gt;{{$event}}&lt;/code&gt; 에 표시되지 않는 방법 에 유의하십시오 . &lt;code&gt;$event&lt;/code&gt; 가 해당 바인딩의 범위를 벗어나기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="cb458ac4c395d1b568721519300e24a944cc46d1" translate="yes" xml:space="preserve">
          <source>Note that &quot;=1&quot; takes precedence over &quot;one&quot;.</source>
          <target state="translated">&quot;= 1&quot;이 &quot;one&quot;보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="434bc4aa7a04baed5fd5937b7268a8d770b70508" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;directive#normalization.html&quot;&gt;attribute name normalization&lt;/a&gt; does not apply here, so &lt;code&gt;'internalLink'&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; match &lt;code&gt;'internal-link'&lt;/code&gt;.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;directive#normalization.html&quot;&gt;속성 이름 정상화가&lt;/a&gt; 여기에 적용되지 않기 때문에 &lt;code&gt;'internalLink'&lt;/code&gt; 는 것입니다 &lt;strong&gt;하지&lt;/strong&gt; 일치 &lt;code&gt;'internal-link'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a1a58c3fbcaa18d57812a2d20a3557e11472cb2" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;nganimate/directive/nganimateswap&quot;&gt;&lt;code&gt;ngAnimateSwap&lt;/code&gt;&lt;/a&gt; is a &lt;em&gt;structural directive&lt;/em&gt;, which means it creates a new instance of the element (including any other/child directives it may have) and links it to a new scope every time &lt;em&gt;swap&lt;/em&gt; happens. In some cases this might not be desirable (e.g. for performance reasons, or when you wish to retain internal state on the original element instance).</source>
          <target state="translated">참고 &lt;a href=&quot;nganimate/directive/nganimateswap&quot;&gt; &lt;code&gt;ngAnimateSwap&lt;/code&gt; 는&lt;/a&gt; A는 &lt;em&gt;구조 지정&lt;/em&gt; 이 모든 시간 영역에 새로운 링크를 (다른 / 자식 지시가있을 수 포함) 엘리먼트의 새로운 인스턴스 생성 수단, &lt;em&gt;교환이&lt;/em&gt; 발생한다. 경우에 따라 (예 : 성능상의 이유로 또는 원래 요소 인스턴스에서 내부 상태를 유지하려는 경우) 바람직하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b460923b8c2ebd1c623d370f0b9ad6d939ad9c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; makes a stronger statement about the URL than &lt;code&gt;$sce.URL&lt;/code&gt; or &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; do and therefore contexts requiring values trusted for &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; can be used anywhere that values trusted for &lt;code&gt;$sce.URL&lt;/code&gt; or &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; are required.</source>
          <target state="translated">하는 것으로 &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; 보다 URL에 대한 강한 진술하게 &lt;code&gt;$sce.URL&lt;/code&gt; 또는 &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; 않고 값을 필요로하므로 컨텍스트에 대해 신뢰 &lt;code&gt;$sce.RESOURCE_URL&lt;/code&gt; 값을 신뢰할 것을 어디에서나 사용할 수있는 &lt;code&gt;$sce.URL&lt;/code&gt; 또는 &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc1bf3983b1102710be771517de48e27fd68d37a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$watchCollection&lt;/code&gt; does a shallow comparison of the properties of the object (or the items in the collection if the model is an array). This means that changing a property deeper than the first level inside the object/collection will not trigger a re-rendering.</source>
          <target state="translated">하는 것으로 &lt;code&gt;$watchCollection&lt;/code&gt; (모델이 배열 인 경우 또는 컬렉션의 항목) 개체의 속성의 단순 비교를 수행합니다. 즉, 객체 / 컬렉션 내부의 첫 번째 수준보다 깊은 속성을 변경해도 다시 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dee39f5a021ca087206f120df7d48fc93821a3b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;input[range]&lt;/code&gt; is not compatible with&lt;code&gt;ngMax&lt;/code&gt;, &lt;code&gt;ngMin&lt;/code&gt;, and &lt;code&gt;ngStep&lt;/code&gt;, because they do not set the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; attributes, which means that the browser won't automatically adjust the input value based on their values, and will always assume min = 0, max = 100, and step = 1.</source>
          <target state="translated">참고 &lt;code&gt;input[range]&lt;/code&gt; 와 호환되지 않습니다 &lt;code&gt;ngMax&lt;/code&gt; , &lt;code&gt;ngMin&lt;/code&gt; 및 &lt;code&gt;ngStep&lt;/code&gt; 그들이 설정되어 있지 않기 때문에, &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 속성을, 어떤 브라우저가 자동으로 값을 기준으로 입력 값을 조정하지 않으며, 항상 가정을 의미 최소 = 0, 최대 = 100, 단계 = 1.</target>
        </trans-unit>
        <trans-unit id="9d27b908b7897290c16b7b7bb8b9495950a6a26e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;novalidate&lt;/code&gt; is used to disable browser's native form validation.</source>
          <target state="translated">참고 &lt;code&gt;novalidate&lt;/code&gt; 비활성화 브라우저의 기본 양식 유효성 검사에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03cc51fc0228dd8abc334f43fcb44d8105df0c96" translate="yes" xml:space="preserve">
          <source>Note that a named property will match properties on the same level only, while the special &lt;code&gt;$&lt;/code&gt; property will match properties on the same level or deeper. E.g. an array item like &lt;code&gt;{name: {first: 'John', last: 'Doe'}}&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; be matched by &lt;code&gt;{name: 'John'}&lt;/code&gt;, but &lt;strong&gt;will&lt;/strong&gt; be matched by &lt;code&gt;{$: 'John'}&lt;/code&gt;.</source>
          <target state="translated">명명 된 속성은 같은 수준의 속성과 만 일치 하는 반면 특수 &lt;code&gt;$&lt;/code&gt; 속성은 같은 수준 이상의 속성과 일치합니다. 예와 같은 배열 항목 &lt;code&gt;{name: {first: 'John', last: 'Doe'}}&lt;/code&gt; 합니다 &lt;strong&gt;하지&lt;/strong&gt; 일치 할 &lt;code&gt;{name: 'John'}&lt;/code&gt; 하지만 &lt;strong&gt;것입니다&lt;/strong&gt; 일치 할 &lt;code&gt;{$: 'John'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa75d31f67261d997c50bc28147928d5dc77fe26" translate="yes" xml:space="preserve">
          <source>Note that an empty trusted resource URL list will block every resource URL from being loaded, and will require you to manually mark each one as trusted with &lt;code&gt;$sce.trustAsResourceUrl&lt;/code&gt;. However, templates requested by &lt;a href=&quot;../service/%24templaterequest&quot;&gt;$templateRequest&lt;/a&gt; that are present in &lt;a href=&quot;../service/%24templatecache&quot;&gt;$templateCache&lt;/a&gt; will not go through this check. If you have a mechanism to populate your templates in that cache at config time, then it is a good idea to remove 'self' from the trusted resource URL lsit. This helps to mitigate the security impact of certain types of issues, like for instance attacker-controlled &lt;code&gt;ng-includes&lt;/code&gt;.</source>
          <target state="translated">비어있는 신뢰할 수있는 리소스 URL 목록은 모든 리소스 URL &lt;code&gt;$sce.trustAsResourceUrl&lt;/code&gt; 하고 $ sce.trustAsResourceUrl을 사용 하여 각 URL을 신뢰할 수 있음으로 수동으로 표시해야합니다 . 그러나,에 의해 요청 된 템플릿 &lt;a href=&quot;../service/%24templaterequest&quot;&gt;$ templateRequest&lt;/a&gt; 에 존재 &lt;a href=&quot;../service/%24templatecache&quot;&gt;$ templateCache는&lt;/a&gt; 이 검사를 통과하지 않습니다. 구성시 해당 캐시에 템플릿을 채우는 메커니즘이있는 경우 신뢰할 수있는 리소스 URL lsit에서 'self'를 제거하는 것이 좋습니다. 이를 통해 공격자가 제어하는 &lt;code&gt;ng-includes&lt;/code&gt; 와 같은 특정 유형의 문제로 인한 보안 영향을 완화하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9ecf6346c2070b6c0ab4c14bc7c542fb88a7f2d" translate="yes" xml:space="preserve">
          <source>Note that an empty whitelist will block every resource URL from being loaded, and will require you to manually mark each one as trusted with &lt;code&gt;$sce.trustAsResourceUrl&lt;/code&gt;. However, templates requested by &lt;a href=&quot;../service/%24templaterequest&quot;&gt;$templateRequest&lt;/a&gt; that are present in &lt;a href=&quot;../service/%24templatecache&quot;&gt;$templateCache&lt;/a&gt; will not go through this check. If you have a mechanism to populate your templates in that cache at config time, then it is a good idea to remove 'self' from that whitelist. This helps to mitigate the security impact of certain types of issues, like for instance attacker-controlled &lt;code&gt;ng-includes&lt;/code&gt;.</source>
          <target state="translated">빈 화이트리스트는 모든 리소스 URL &lt;code&gt;$sce.trustAsResourceUrl&lt;/code&gt; 로 각 리소스 URL을 신뢰할 수있는 것으로 수동 표시해야합니다 . 그러나 &lt;a href=&quot;../service/%24templaterequest&quot;&gt;$ templateCache&lt;/a&gt; 에있는 $ templateRequest 가 요청한 &lt;a href=&quot;../service/%24templatecache&quot;&gt;템플릿&lt;/a&gt; 은이 검사를 거치지 않습니다. 구성시 해당 캐시에 템플리트를 채우는 메커니즘이있는 경우 해당 화이트리스트에서 '자기'를 제거하는 것이 좋습니다. 이를 통해 공격자 제어 &lt;code&gt;ng-includes&lt;/code&gt; 와 같은 특정 유형의 문제로 인한 보안 영향을 완화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7060fae7453c3d445c4f38cba4bd21dedf19b39d" translate="yes" xml:space="preserve">
          <source>Note that child elements that contain &lt;code&gt;templateUrl&lt;/code&gt; directives will not have been compiled and linked since they are waiting for their template to load asynchronously and their own compilation and linking has been suspended until that occurs.</source>
          <target state="translated">&lt;code&gt;templateUrl&lt;/code&gt; 지시문이 포함 된 자식 요소는 템플릿이 비동기 적으로로드되기를 기다리고 있으며 자체 컴파일 및 연결이 발생할 때까지 일시 중지되었으므로 컴파일 및 링크되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c99053b76829524b72c418b0f4b8f9dc7e529792" translate="yes" xml:space="preserve">
          <source>Note that different from config methods on providers, &lt;code&gt;matchLatestDefinitionEnabled()&lt;/code&gt; can be changed even when the application is already running.</source>
          <target state="translated">제공자의 구성 메소드와는 달리 , 애플리케이션이 이미 실행중인 경우에도 &lt;code&gt;matchLatestDefinitionEnabled()&lt;/code&gt; 를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4e1e4289fbf35f5faf80c5307adaaad54b9551d" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;code&gt;ngAnimateChildren&lt;/code&gt; is set, no child animations will run when the parent element is removed from the DOM (&lt;code&gt;leave&lt;/code&gt; animation).</source>
          <target state="translated">경우에도주의 &lt;code&gt;ngAnimateChildren&lt;/code&gt; 이 설정되어 부모 요소는 DOM (에서 제거 될 때, 자식 애니메이션이 실행되지 않습니다 &lt;code&gt;leave&lt;/code&gt; 애니메이션).</target>
        </trans-unit>
        <trans-unit id="c7c140cbe8e284d7d91b2523d922769f21bf4f4b" translate="yes" xml:space="preserve">
          <source>Note that if the directive did not create its own scope, then &lt;code&gt;scope&lt;/code&gt; in &lt;code&gt;scope.name = 'Jeff'&lt;/code&gt; would reference the outside scope and we would see &lt;code&gt;Jeff&lt;/code&gt; in the output.</source>
          <target state="translated">지시어가 자신의 범위, 다음 작성하지 않은 경우에하는 것으로 &lt;code&gt;scope&lt;/code&gt; 에서 &lt;code&gt;scope.name = 'Jeff'&lt;/code&gt; 외부의 범위를 참조 할 것이며, 우리는 볼 것이다 &lt;code&gt;Jeff&lt;/code&gt; 출력에.</target>
        </trans-unit>
        <trans-unit id="b69d7fb66d4f2706680e48a28fa8422bbf4e8619" translate="yes" xml:space="preserve">
          <source>Note that if the response is a redirect, XMLHttpRequest will transparently follow it, meaning that the outcome (success or error) will be determined by the final response status code.</source>
          <target state="translated">응답이 경로 재 지정 인 경우 XMLHttpRequest가이를 따라 투명하게 따르므로 결과 (성공 또는 오류)는 최종 응답 상태 코드에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="52178123f14ee320297cad57648610e144298b96" translate="yes" xml:space="preserve">
          <source>Note that if the root element is on the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element then the cloned node will be placed inside of body.</source>
          <target state="translated">루트 요소가 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 요소에 있으면 복제 된 노드가 본문 내부에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="7c6dba9ed0e82c79a5e7151ec5feb744119ce28b" translate="yes" xml:space="preserve">
          <source>Note that if you provide these properties on the config object the default transformations will be overwritten. If you wish to augment the default transformations then you must include them in your local transformation array.</source>
          <target state="translated">구성 객체에 이러한 속성을 제공하면 기본 변환을 덮어 씁니다. 기본 변환을 기능 보강하려면 로컬 변환 배열에 변환을 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="00812766716b60ebac71cd394d6a7fe6f3350e0c" translate="yes" xml:space="preserve">
          <source>Note that if you want to assign from a child into the parent scope, you must initialize the target property on the parent scope, otherwise &lt;code&gt;ngRef&lt;/code&gt; will assign on the child scope. This commonly happens when assigning elements or components wrapped in &lt;a href=&quot;ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt;. See the second example below.</source>
          <target state="translated">자식에서 부모 범위로 할당하려면 부모 범위에서 대상 속성을 초기화해야합니다. 그렇지 않으면 &lt;code&gt;ngRef&lt;/code&gt; 가 자식 범위에서 할당합니다. 이것은 일반적으로 &lt;a href=&quot;ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; 로&lt;/a&gt; 래핑 된 요소 또는 컴포넌트를 지정할 때 발생합니다 . 아래 두 번째 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0fa4368d83b81bf923d569ddb949c70bea7f44" translate="yes" xml:space="preserve">
          <source>Note that in this mode, AngularJS intercepts all links (subject to the &quot;Html link rewriting&quot; rules below) and updates the url in a way that never performs a full page reload.</source>
          <target state="translated">이 모드에서 AngularJS는 모든 링크를 가로 채고 (아래 &quot;Html 링크 다시 쓰기&quot;규칙에 따라) 전체 페이지를 다시로드하지 않는 방식으로 URL을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c08cd1bfbb11534ce5e7fae83491bc8949dbc417" translate="yes" xml:space="preserve">
          <source>Note that only browsers that support CSS transitions and/or keyframe animations are capable of rendering animations triggered via &lt;code&gt;$animateCss&lt;/code&gt; (bad news for IE9 and lower).</source>
          <target state="translated">CSS 전환 및 / 또는 키 프레임 애니메이션을 지원하는 브라우저 만 &lt;code&gt;$animateCss&lt;/code&gt; (IE9 이하의 나쁜 소식)를 통해 트리거되는 애니메이션을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e2e236826b266700273a74ec0d099fb253557f" translate="yes" xml:space="preserve">
          <source>Note that only the removed control's validation state (&lt;code&gt;$errors&lt;/code&gt;etc.) will be removed from the form. &lt;code&gt;$dirty&lt;/code&gt;, &lt;code&gt;$submitted&lt;/code&gt; states will not be changed, because the expected behavior can be different from case to case. For example, removing the only &lt;code&gt;$dirty&lt;/code&gt; control from a form may or may not mean that the form is still &lt;code&gt;$dirty&lt;/code&gt;.</source>
          <target state="translated">제거 된 컨트롤의 유효성 검사 상태 ( &lt;code&gt;$errors&lt;/code&gt; 등) 만 양식에서 제거됩니다. &lt;code&gt;$dirty&lt;/code&gt; , &lt;code&gt;$submitted&lt;/code&gt; 상태는 예상되는 동작이 대소 문자에 따라 다를 수 있으므로 변경되지 않습니다. 예를 들어, 양식에서 &lt;code&gt;$dirty&lt;/code&gt; 컨트롤 만 제거 하면 양식이 여전히 &lt;code&gt;$dirty&lt;/code&gt; 임을 의미 할 수도 있고 그렇지 않을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba3b53de509e58a62730e40c650af0e249cde701" translate="yes" xml:space="preserve">
          <source>Note that serializer will sort the request parameters alphabetically.</source>
          <target state="translated">serializer는 요청 매개 변수를 알파벳순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="361cd364814ae208a63b23f1fe54b88cb0b4da83" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;!&lt;/code&gt; prefix in the hashbang mode is not part of &lt;code&gt;$location.path()&lt;/code&gt;; it is actually &lt;code&gt;hashPrefix&lt;/code&gt;.</source>
          <target state="translated">참고이 &lt;code&gt;!&lt;/code&gt; 해시 뱅 모드의 접두사는 &lt;code&gt;$location.path()&lt;/code&gt; 일부가 아닙니다 . 실제로 &lt;code&gt;hashPrefix&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="255b65aefef25adace72fa2d5ba49a9bb01df7db" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;$routeParams&lt;/code&gt; are only updated &lt;em&gt;after&lt;/em&gt; a route change completes successfully. This means that you cannot rely on &lt;code&gt;$routeParams&lt;/code&gt; being correct in route resolve functions. Instead you can use &lt;code&gt;$route.current.params&lt;/code&gt; to access the new route's parameters.</source>
          <target state="translated">있습니다 &lt;code&gt;$routeParams&lt;/code&gt; 단지 업데이트 &lt;em&gt;후&lt;/em&gt; 경로 변경이 성공적으로 완료됩니다. 즉 , 경로 확인 기능에서 &lt;code&gt;$routeParams&lt;/code&gt; 가 올바른지 신뢰할 수 없습니다 . 대신 &lt;code&gt;$route.current.params&lt;/code&gt; 를 사용하여 새 경로의 매개 변수에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ed0048fcbcf6b9f1d9c9796273aa944cdd8c09d" translate="yes" xml:space="preserve">
          <source>Note that the callback does not trigger a scope digest. Wrap your call into a &lt;a href=&quot;../type/%24rootscope.scope#%24apply.html&quot;&gt;scope.$apply&lt;/a&gt; to propagate changes to the scope.</source>
          <target state="translated">콜백은 범위 다이제스트를 트리거하지 않습니다. 통화를 &lt;a href=&quot;../type/%24rootscope.scope#%24apply.html&quot;&gt;범위&lt;/a&gt; 로 묶습니다. $ apply 를 사용하여 변경 사항을 범위에 전파합니다.</target>
        </trans-unit>
        <trans-unit id="88e8f90425456fee890aba473cd13936b00c42f7" translate="yes" xml:space="preserve">
          <source>Note that the current state of the control will not be reflected on the new parent form. This is not an issue with normal use, as freshly compiled and linked controls are in a &lt;code&gt;$pristine&lt;/code&gt; state.</source>
          <target state="translated">컨트롤의 현재 상태는 새 부모 폼에 반영되지 않습니다. 새로 컴파일되고 연결된 컨트롤이 &lt;code&gt;$pristine&lt;/code&gt; 상태 이기 때문에 정상적인 사용에는 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bc392f2c46cf2ff9d24ffab306a297a902ca69ec" translate="yes" xml:space="preserve">
          <source>Note that the interpolateDirective has a priority of 100 and sets up the watch in the preLink function.</source>
          <target state="translated">interpolateDirective의 우선 순위는 100이며 preLink 기능에서 시계를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1e7a8adb55af74b5da7969da9a3763d122026199" translate="yes" xml:space="preserve">
          <source>Note that the required controllers will not be available during the instantiation of the controller, but they are guaranteed to be available just before the &lt;code&gt;$onInit&lt;/code&gt; method is executed!</source>
          <target state="translated">컨트롤러를 인스턴스화하는 동안 필요한 컨트롤러를 사용할 수 없지만 &lt;code&gt;$onInit&lt;/code&gt; 메서드가 실행 되기 직전에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c34ae91c81cc9b2d0be6d7e1934c17d8776d6a7" translate="yes" xml:space="preserve">
          <source>Note that the setters don't update &lt;code&gt;window.location&lt;/code&gt; immediately. Instead, the &lt;code&gt;$location&lt;/code&gt; service is aware of the &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt; life-cycle and coalesces multiple &lt;code&gt;$location&lt;/code&gt; mutations into one &quot;commit&quot; to the &lt;code&gt;window.location&lt;/code&gt; object during the scope &lt;code&gt;$digest&lt;/code&gt; phase. Since multiple changes to the $location's state will be pushed to the browser as a single change, it's enough to call the &lt;code&gt;replace()&lt;/code&gt; method just once to make the entire &quot;commit&quot; a replace operation rather than an addition to the browser history. Once the browser is updated, the $location service resets the flag set by &lt;code&gt;replace()&lt;/code&gt; method and future mutations will create new history records, unless &lt;code&gt;replace()&lt;/code&gt; is called again.</source>
          <target state="translated">setter는 &lt;code&gt;window.location&lt;/code&gt; 을 즉시 업데이트하지 않습니다 . 대신 &lt;code&gt;$location&lt;/code&gt; 서비스는 &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;범위&lt;/a&gt; 수명주기를 인식 하고 &lt;code&gt;window.location&lt;/code&gt; &lt;code&gt;$digest&lt;/code&gt; 단계 동안 여러 &lt;code&gt;$location&lt;/code&gt; 돌연변이를 window.location 객체에 대한 하나의 &quot;커밋&quot;으로 통합합니다 . $ location의 상태에 대한 여러 변경 사항이 단일 변경으로 브라우저에 푸시되므로 &lt;code&gt;replace()&lt;/code&gt; 메서드를 한 번만 호출 하면 브라우저 기록에 추가하는 대신 전체 &quot;커밋&quot;을 바꾸기 작업으로 만들 수 있습니다. 브라우저가 업데이트되면 $ location 서비스는 &lt;code&gt;replace()&lt;/code&gt; 의해 설정된 플래그를 재설정합니다 &lt;code&gt;replace()&lt;/code&gt; 를 다시 호출 하지 않으면 메소드 및 향후 돌연변이로 인해 새 히스토리 레코드가 작성 됩니다.</target>
        </trans-unit>
        <trans-unit id="23e7bfea25426540eb64b363a42574d6fb731133" translate="yes" xml:space="preserve">
          <source>Note that this directive should not be used together with &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt;, as this can lead to unexpected behavior.</source>
          <target state="translated">이 지시어는 &lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 과 함께 사용 하면 예기치 않은 동작이 발생할 수 있으므로 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="a113d4b03841c78edec91e5f83c98fd737fcdc85" translate="yes" xml:space="preserve">
          <source>Note that this feature is only active when the &lt;code&gt;ngAnimate&lt;/code&gt; module is used.</source>
          <target state="translated">이 기능은 &lt;code&gt;ngAnimate&lt;/code&gt; 모듈이 사용될 때만 활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="287fb53c098a514c8ea13e5c815f04f74ffde3ad" translate="yes" xml:space="preserve">
          <source>Note that this only patches jqLite. If you use jQuery 3.5.0 or newer, please read the &lt;a href=&quot;https://jquery.com/upgrade-guide/3.5/&quot;&gt;jQuery 3.5 upgrade guide&lt;/a&gt; for more details about the workarounds.</source>
          <target state="translated">이것은 jqLite 만 패치합니다. jQuery 3.5.0 이상을 사용하는 경우 해결 방법에 대한 자세한 내용은 &lt;a href=&quot;https://jquery.com/upgrade-guide/3.5/&quot;&gt;jQuery 3.5 업그레이드 가이드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="533bf055a177afefc469a9231695b1feea4c317e" translate="yes" xml:space="preserve">
          <source>Note that we have used non-prefixed CSS transition properties in our examples as the major browsers now support non-prefixed properties. If you intend to support older browsers or certain mobile browsers then you will need to include prefixed versions of the transition properties. Take a look at &lt;a href=&quot;http://caniuse.com/#feat=css-transitions&quot;&gt;http://caniuse.com/#feat=css-transitions&lt;/a&gt; for what browsers require prefixes, and &lt;a href=&quot;https://github.com/postcss/autoprefixer&quot;&gt;https://github.com/postcss/autoprefixer&lt;/a&gt; for a tool that can automatically generate the prefixes for you.</source>
          <target state="translated">주요 브라우저는 이제 접두사가없는 속성을 지원하므로 예제에서 접두사가없는 CSS 전환 속성을 사용했습니다. 이전 브라우저 나 특정 모바일 브라우저를 지원하려면 접두사 버전의 전환 속성을 포함해야합니다. 한 번 봐 가지고 &lt;a href=&quot;http://caniuse.com/#feat=css-transitions&quot;&gt;http://caniuse.com/#feat=css-transitions&lt;/a&gt; 브라우저 접두사를 요구하고, 무엇을위한 &lt;a href=&quot;https://github.com/postcss/autoprefixer&quot;&gt;https://github.com/postcss/autoprefixer&lt;/a&gt; 자동으로 당신을 위해 접두사를 생성 할 수있는 도구를합니다.</target>
        </trans-unit>
        <trans-unit id="9c3e1cc0ee20d7a72fe1a7d291a53df28e47882d" translate="yes" xml:space="preserve">
          <source>Note that we provided the name of our application module to be loaded into the injector as the second parameter of the &lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt; function. Notice that &lt;code&gt;angular.bootstrap&lt;/code&gt; will not create modules on the fly. You must create any custom &lt;a href=&quot;module&quot;&gt;modules&lt;/a&gt; before you pass them as a parameter.</source>
          <target state="translated">&lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt; 함수 의 두 번째 매개 변수로 인젝터에로드 할 애플리케이션 모듈의 이름을 제공했습니다 . 통지 &lt;code&gt;angular.bootstrap&lt;/code&gt; 가 즉시 모듈을 만들지 않습니다. 매개 변수로 전달하기 전에 모든 사용자 정의 &lt;a href=&quot;module&quot;&gt;모듈을&lt;/a&gt; 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ead3bf4970f104fb56e684eaff167f7cdae7eea" translate="yes" xml:space="preserve">
          <source>Note that whatever is returned by the decorator function will replace that which is being decorated. For example, a missing return statement will wipe out the entire object being decorated.</source>
          <target state="translated">데코레이터 기능에 의해 반환되는 것은 데코레이션되는 것을 대체합니다. 예를 들어, return 문이 없으면 장식중인 전체 객체가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="fa3e23fba7c51ee609d4ecc4d18b8ad2d0d55f3e" translate="yes" xml:space="preserve">
          <source>Note that when an element is removed using &lt;code&gt;ngIf&lt;/code&gt; its scope is destroyed and a new scope is created when the element is restored. The scope created within &lt;code&gt;ngIf&lt;/code&gt; inherits from its parent scope using &lt;a href=&quot;https://github.com/angular/angular.js/wiki/Understanding-Scopes#javascript-prototypal-inheritance&quot;&gt;prototypal inheritance&lt;/a&gt;. An important implication of this is if &lt;code&gt;ngModel&lt;/code&gt; is used within &lt;code&gt;ngIf&lt;/code&gt; to bind to a javascript primitive defined in the parent scope. In this case any modifications made to the variable within the child scope will override (hide) the value in the parent scope.</source>
          <target state="translated">&lt;code&gt;ngIf&lt;/code&gt; 를 사용하여 요소가 제거 된 경우 해당 범위가 소멸되고 요소가 복원 될 때 새 범위가 작성됩니다. &lt;code&gt;ngIf&lt;/code&gt; 내에서 작성된 범위 는 &lt;a href=&quot;https://github.com/angular/angular.js/wiki/Understanding-Scopes#javascript-prototypal-inheritance&quot;&gt;프로토 타입 상속을&lt;/a&gt; 사용하여 상위 범위에서 상속 됩니다. 이 경우의 중요한 의미이다 &lt;code&gt;ngModel&lt;/code&gt; 가 내에서 사용 &lt;code&gt;ngIf&lt;/code&gt; 상위 범위에 정의 된 스크립트 프리미티브에 결합한다. 이 경우 하위 범위 내에서 변수를 수정하면 상위 범위의 값이 무시됩니다 (숨기기).</target>
        </trans-unit>
        <trans-unit id="ec430e54b4e4cb65b0f886e7a9ce1cc6897310e8" translate="yes" xml:space="preserve">
          <source>Note that when you specify offsets, you must provide explicit number rules for numbers from 0 up to and including the offset. If you use an offset of 3, for example, you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for plural categories &quot;one&quot; and &quot;other&quot;.</source>
          <target state="translated">오프셋을 지정할 때 0에서 오프셋까지의 숫자에 대해 명시적인 숫자 규칙을 제공해야합니다. 예를 들어, 오프셋 3을 사용하는 경우 0, 1, 2 및 3에 대해 명시적인 숫자 규칙을 제공해야합니다. 또한 복수 범주 &quot;one&quot;및 &quot;other&quot;에 대해 복수 문자열을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bb502c46c9a90c606dcc935a89c49887979e77d" translate="yes" xml:space="preserve">
          <source>Note that when you type hashbang url into the first browser (or vice versa) it doesn't rewrite / redirect to regular / hashbang url, as this conversion happens only during parsing the initial URL = on page reload.</source>
          <target state="translated">첫 번째 브라우저에 hashbang url을 입력하면 (또는 그 반대로) 일반 / hashbang url로 다시 쓰거나 리디렉션하지 않습니다.이 변환은 페이지 재로드시 초기 URL = 구문 분석 중에 만 발생하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b178156524e6cb72a5162e49e917632f00765f48" translate="yes" xml:space="preserve">
          <source>Note that you are not registering a &lt;strong&gt;service instance&lt;/strong&gt;, but rather a &lt;strong&gt;factory function&lt;/strong&gt; that will create this instance when called.</source>
          <target state="translated">&lt;strong&gt;서비스 인스턴스를&lt;/strong&gt; 등록하지 않고 호출 될 때이 인스턴스를 작성 하는 &lt;strong&gt;팩토리 함수&lt;/strong&gt; 를 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="426af06ec89b5b89375d353f1e16d2216df4049e" translate="yes" xml:space="preserve">
          <source>Note that you can also attach controllers to the DOM by declaring it in a route definition via the &lt;a href=&quot;../../ngroute/service/%24route&quot;&gt;$route&lt;/a&gt; service. A common mistake is to declare the controller again using &lt;code&gt;ng-controller&lt;/code&gt; in the template itself. This will cause the controller to be attached and executed twice.</source>
          <target state="translated">&lt;a href=&quot;../../ngroute/service/%24route&quot;&gt;$ route&lt;/a&gt; 서비스 를 통해 경로 정의에서 컨트롤러를 선언하여 DOM에 컨트롤러를 연결할 수도 있습니다 . 일반적인 실수는 템플릿 자체에서 &lt;code&gt;ng-controller&lt;/code&gt; 를 사용하여 컨트롤러를 다시 선언하는 것입니다. 이로 인해 컨트롤러가 두 번 연결되고 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="768387cfb355f78bebd7f61156633279bb4ef574" translate="yes" xml:space="preserve">
          <source>Note that you can also require the directive's own controller - it will be made available like any other controller.</source>
          <target state="translated">지시문 자체 컨트롤러가 필요할 수도 있습니다. 다른 컨트롤러처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0856f9e27bd71605496c72bdce7db828215d5caa" translate="yes" xml:space="preserve">
          <source>Note that you can only inject &lt;a href=&quot;angular.module#provider.html&quot;&gt;&lt;code&gt;providers&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;angular.module#constant.html&quot;&gt;&lt;code&gt;constants&lt;/code&gt;&lt;/a&gt; into this function.</source>
          <target state="translated">이 함수에는 &lt;a href=&quot;angular.module#provider.html&quot;&gt; &lt;code&gt;providers&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;angular.module#constant.html&quot;&gt; &lt;code&gt;constants&lt;/code&gt; &lt;/a&gt; 만 주입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fca268533ad52bcf0c065e75a8a1bda0b9ae178" translate="yes" xml:space="preserve">
          <source>Note that, in AngularJS, there is also a &lt;code&gt;$destroy&lt;/code&gt; jQuery event, which can be used to clean up DOM bindings before an element is removed from the DOM.</source>
          <target state="translated">AngularJS에는 &lt;code&gt;$destroy&lt;/code&gt; jQuery 이벤트도 있습니다.이 이벤트는 DOM에서 요소를 제거하기 전에 DOM 바인딩을 정리하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b50a7b94348fd5ca87221af2d3704fcd38ed6945" translate="yes" xml:space="preserve">
          <source>Note that, since JSONP requests are sensitive because the response is given full access to the browser, the url must be declared, via &lt;a href=&quot;%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt; as a trusted resource URL. You can trust a URL by adding it to the trusted resource URL list via &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;&lt;code&gt;$sceDelegateProvider.trustedResourceUrlList&lt;/code&gt;&lt;/a&gt; or by explicitly trusting the URL via &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;&lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응답에 브라우저에 대한 전체 액세스 권한이 부여되므로 JSONP 요청은 민감하므로 &lt;a href=&quot;%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; 를 통해 신뢰할 수있는 리소스 URL로 URL을 선언해야합니다 . &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt; &lt;code&gt;$sceDelegateProvider.trustedResourceUrlList&lt;/code&gt; &lt;/a&gt; 를 통해 URL을 신뢰할 수있는 리소스 URL 목록에 추가 하거나 &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt; &lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt; &lt;/a&gt; 통해 URL을 명시 적으로 신뢰하여 URL을 신뢰할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28eeae6418e548c9d53253ae27de441a4197d400" translate="yes" xml:space="preserve">
          <source>Note that, since JSONP requests are sensitive because the response is given full access to the browser, the url must be declared, via &lt;a href=&quot;%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt; as a trusted resource URL. You can trust a URL by adding it to the whitelist via &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;&lt;code&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/code&gt;&lt;/a&gt; or by explicitly trusting the URL via &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;&lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">응답에 브라우저에 대한 전체 액세스 권한이 부여되므로 JSONP 요청은 민감하므로 URL은 &lt;a href=&quot;%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; 를 통해 신뢰할 수있는 자원 URL로 선언해야합니다 . &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt; &lt;code&gt;$sceDelegateProvider.resourceUrlWhitelist&lt;/code&gt; &lt;/a&gt; 를 통해 화이트리스트에 추가 하거나 &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt; &lt;code&gt;$sce.trustAsResourceUrl(url)&lt;/code&gt; &lt;/a&gt; 통해 URL을 명시 적으로 신뢰하여 URL을 신뢰할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c149229cd726688ef5b9a6babd1d42d388052bde" translate="yes" xml:space="preserve">
          <source>Note, that code executed in event-listeners (even those registered using jqLite's &lt;code&gt;on&lt;/code&gt;/&lt;code&gt;bind&lt;/code&gt; methods) does not delegate exceptions to the &lt;a href=&quot;%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; (unless executed during a digest).</source>
          <target state="translated">이벤트 리스너에서 실행 된 코드 (jqLite의 &lt;code&gt;on&lt;/code&gt; / &lt;code&gt;bind&lt;/code&gt; 메소드를 사용하여 등록 된 코드조차도 )는 예외를 &lt;a href=&quot;%24exceptionhandler&quot;&gt;$ exceptionHandler에&lt;/a&gt; 위임하지 않습니다 (다이제스트 중에 실행되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="9e38d74b6819f720cd61a7094b0d049052abbf0b" translate="yes" xml:space="preserve">
          <source>Note, this directive requires &lt;code&gt;ngModel&lt;/code&gt; to be present.</source>
          <target state="translated">이 지시문에는 &lt;code&gt;ngModel&lt;/code&gt; 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b59520eea72ca86bfd70bf545fa47501473c8a9a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;ngModel&lt;/code&gt; will try to bind to the property given by evaluating the expression on the current scope. If the property doesn't already exist on this scope, it will be created implicitly and added to the scope.</source>
          <target state="translated">참고 : &lt;code&gt;ngModel&lt;/code&gt; 은 현재 범위에서 표현식을 평가하여 지정된 속성에 바인딩하려고합니다. 이 범위에 속성이 존재하지 않으면 암시 적으로 만들어지고 범위에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c67b04ea81758d7b804ada0ab90cd4b709045975" translate="yes" xml:space="preserve">
          <source>Note: A Word on Modules</source>
          <target state="translated">참고 : 모듈에 관한 단어</target>
        </trans-unit>
        <trans-unit id="ded91630c0d7419f8e1e784dda3b45c381bb9947" translate="yes" xml:space="preserve">
          <source>Note: All services in AngularJS are singletons. That means that the injector uses each recipe at most once to create the object. The injector then caches the reference for all future needs.</source>
          <target state="translated">참고 : AngularJS의 모든 서비스는 싱글 톤입니다. 즉, 인젝터는 각 레시피를 최대 한 번 사용하여 객체를 만듭니다. 그런 다음 인젝터는 모든 향후 요구에 대한 참조를 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="9e323b77fe9b73f870ed3df7c5fd2a58db5399d7" translate="yes" xml:space="preserve">
          <source>Note: As the &lt;code&gt;blur&lt;/code&gt; event is executed synchronously also during DOM manipulations (e.g. removing a focussed input), AngularJS executes the expression using &lt;code&gt;scope.$evalAsync&lt;/code&gt; if the event is fired during an &lt;code&gt;$apply&lt;/code&gt; to ensure a consistent state.</source>
          <target state="translated">참고 : &lt;code&gt;blur&lt;/code&gt; 이벤트는 DOM 조작 중에도 동 기적으로 실행되므로 (예 : 포커스 된 입력 제거) AngularJS 는 &lt;code&gt;$apply&lt;/code&gt; 중에 이벤트가 발생 하면 일관성있는 상태를 유지하도록 &lt;code&gt;scope.$evalAsync&lt;/code&gt; 사용하여 표현식을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="c280156fbac945785329bf6b2c4598680af419de" translate="yes" xml:space="preserve">
          <source>Note: As the &lt;code&gt;focus&lt;/code&gt; event is executed synchronously when calling &lt;code&gt;input.focus()&lt;/code&gt; AngularJS executes the expression using &lt;code&gt;scope.$evalAsync&lt;/code&gt; if the event is fired during an &lt;code&gt;$apply&lt;/code&gt; to ensure a consistent state.</source>
          <target state="translated">참고 : &lt;code&gt;input.focus()&lt;/code&gt; 호출 할 때 &lt;code&gt;focus&lt;/code&gt; 이벤트가 동기식으로 실행되므로 AngularJS 는 &lt;code&gt;$apply&lt;/code&gt; 중에 이벤트가 발생 하면 일관성있는 상태를 유지하도록 &lt;code&gt;scope.$evalAsync&lt;/code&gt; 사용하여 표현식을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="389de76ccd42531e06d862c273bd31729b8ac968" translate="yes" xml:space="preserve">
          <source>Note: By default, the address that appears in your &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag will be used as the path. This is important so that cookies will be visible for all routes when html5mode is enabled.</source>
          <target state="translated">참고 : 기본적으로 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 태그에 나타나는 주소가 경로로 사용됩니다. html5mode가 활성화 된 경우 모든 경로에 쿠키가 표시되도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e31495007ee5e25b71e93337695e741041bb6b41" translate="yes" xml:space="preserve">
          <source>Note: If a &lt;code&gt;$sanitize&lt;/code&gt; service is unavailable and the bound value isn't explicitly trusted, you will have an exception (instead of an exploit.)</source>
          <target state="translated">참고 : &lt;code&gt;$sanitize&lt;/code&gt; 서비스를 사용할 수없고 바운드 값을 명시 적으로 신뢰하지 않으면 익스플로잇 대신 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="377131b4062957e0cd54324140e9b1862488c89c" translate="yes" xml:space="preserve">
          <source>Note: Not all browsers support blackboxing.</source>
          <target state="translated">참고 : 모든 브라우저가 블랙 박스를 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a089d7d30df3e20d1229e11d2f529063219abf86" translate="yes" xml:space="preserve">
          <source>Note: Path should always begin with forward slash (/), this method will add the forward slash if it is missing.</source>
          <target state="translated">참고 : 경로는 항상 슬래시 (/)로 시작해야합니다.이 방법은 슬래시가없는 경우 슬래시를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="eb8c13038a41fd0eff7f4877829e9fd98a3545b0" translate="yes" xml:space="preserve">
          <source>Note: Service recipes follow a design pattern called &lt;a href=&quot;http://www.martinfowler.com/articles/injection.html#ConstructorInjectionWithPicocontainer&quot;&gt;constructor injection&lt;/a&gt;.</source>
          <target state="translated">참고 : 서비스 레시피는 &lt;a href=&quot;http://www.martinfowler.com/articles/injection.html#ConstructorInjectionWithPicocontainer&quot;&gt;생성자 주입&lt;/a&gt; 이라는 디자인 패턴을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="475834278a9624d0a055bc9effed019c3ae7d13c" translate="yes" xml:space="preserve">
          <source>Note: compared to the non-AngularJS version &lt;code&gt;location.host&lt;/code&gt; which returns &lt;code&gt;hostname:port&lt;/code&gt;, this returns the &lt;code&gt;hostname&lt;/code&gt; portion only.</source>
          <target state="translated">참고 : &lt;code&gt;hostname:port&lt;/code&gt; 를 반환 하는 비 AJularJS 버전 &lt;code&gt;location.host&lt;/code&gt; 와 비교 하면 &lt;code&gt;hostname&lt;/code&gt; 부분 만 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="29b3409bac783620b70260279692f3e46f1b409c" translate="yes" xml:space="preserve">
          <source>Note: each module is only loaded once, even if multiple other modules require it. Note: the factory function for &quot;values&quot; and &quot;services&quot; is called lazily when the value/service is injected for the first time.</source>
          <target state="translated">참고 : 여러 개의 다른 모듈이 필요한 경우에도 각 모듈은 한 번만로드됩니다. 참고 : 값 / 서비스가 처음으로 주입 될 때 &quot;값&quot;및 &quot;서비스&quot;에 대한 팩토리 기능이 느리게 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="097deab2d3194da828c79a657f91e42bb7760b81" translate="yes" xml:space="preserve">
          <source>Note: progress/notify callbacks are not currently supported via the ES6-style interface.</source>
          <target state="translated">참고 : 진행 / 알림 콜백은 현재 ES6 스타일 인터페이스를 통해 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5db2b0e614cd03b6d341dbe39badf2f8a3c6edee" translate="yes" xml:space="preserve">
          <source>Note: unlike ES6 behavior, an exception thrown in the constructor function will NOT implicitly reject the promise.</source>
          <target state="translated">참고 : ES6 동작과 달리 생성자 함수에서 예외가 발생하면 약속을 암시 적으로 거부하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="c54075f533215ab50d0fd7cf38a3eeb8c23fc08c" translate="yes" xml:space="preserve">
          <source>Notice how by nesting the &lt;code&gt;describe&lt;/code&gt; calls and being descriptive when calling them with strings, the test is very clear. It documents exactly what it is testing, and at a glance you can quickly see what is happening. Now let's add the test for when the password is less than three characters, which should see &lt;code&gt;$scope.strength&lt;/code&gt; set to &quot;weak&quot;:</source>
          <target state="translated">&lt;code&gt;describe&lt;/code&gt; 호출 을 중첩하고 문자열로 호출 할 때 설명적인 방법으로 테스트가 매우 명확하다는 것을 알 수 있습니다. 테스트중인 내용을 정확하게 문서화하고, 한 번에 무슨 일이 일어나고 있는지 빠르게 확인할 수 있습니다. 이제 암호가 3 자 미만일 때 테스트를 추가하겠습니다. &lt;code&gt;$scope.strength&lt;/code&gt; 가 &quot;weak&quot;로 설정되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ea973d032cbe0e4a3acb5cd3fd8438e47c464d8c" translate="yes" xml:space="preserve">
          <source>Notice how we created an AngularJS module called &lt;code&gt;myApp&lt;/code&gt;, and specified that this module definition contains a &quot;recipe&quot; for constructing the &lt;code&gt;clientId&lt;/code&gt; service, which is a simple string in this case.</source>
          <target state="translated">&lt;code&gt;myApp&lt;/code&gt; 이라는 AngularJS 모듈을 어떻게 만들고이 모듈 정의에 &lt;code&gt;clientId&lt;/code&gt; 서비스 구성을위한 &quot;레시피&quot;가 포함되어 있음을 주목 하십시오 .이 경우 간단한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="6e1c89c353e0b2bfa617e6200563c1f70f6b36b2" translate="yes" xml:space="preserve">
          <source>Notice how we nested three &lt;code&gt;ng-controller&lt;/code&gt; directives in our template. This will result in four scopes being created for our view:</source>
          <target state="translated">템플릿에 세 개의 &lt;code&gt;ng-controller&lt;/code&gt; 지시문을 어떻게 중첩했는지 확인하십시오 . 이로 인해 4 개의 범위가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="866554109e207e68affe8a1878fa43779923f1b4" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;ng-bind-html&lt;/code&gt; is bound to &lt;code&gt;userHtml&lt;/code&gt; controlled by the user. With SCE disabled, this application allows the user to render arbitrary HTML into the DIV, which would be an XSS security bug. In a more realistic example, one may be rendering user comments, blog articles, etc. via bindings. (HTML is just one example of a context where rendering user controlled input creates security vulnerabilities.)</source>
          <target state="translated">것을 알 수 &lt;code&gt;ng-bind-html&lt;/code&gt; 결합되어 &lt;code&gt;userHtml&lt;/code&gt; 는 사용자가 제어. SCE를 비활성화하면이 응용 프로그램을 통해 사용자는 임의의 HTML을 DIV로 렌더링 할 수 있으며 이는 XSS 보안 버그입니다. 보다 현실적인 예에서, 바인딩을 통해 사용자 코멘트, 블로그 기사 등을 렌더링 할 수있다. HTML은 사용자 제어 입력을 렌더링하여 보안 취약점을 만드는 컨텍스트의 한 예일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="73b624fb6abc400437a5b17f43dc406ad4cba089" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;{{vojta.name}}&lt;/code&gt; and &lt;code&gt;{{vojta.address}}&lt;/code&gt; are empty, meaning they are undefined. Although we defined &lt;code&gt;vojta&lt;/code&gt; in the controller, it's not available within the directive.</source>
          <target state="translated">공지 사항이 &lt;code&gt;{{vojta.name}}&lt;/code&gt; 과 &lt;code&gt;{{vojta.address}}&lt;/code&gt; 은 그들이 정의되지 않은하는 의미 비어 있습니다. 컨트롤러에서 &lt;code&gt;vojta&lt;/code&gt; 를 정의했지만 지시문 내에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0298da2c4dfd3a77cc9d26ed5cd330121c43f588" translate="yes" xml:space="preserve">
          <source>Notice that AngularJS automatically places &lt;code&gt;ng-scope&lt;/code&gt; class on elements where scopes are attached. The &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; definition in this example highlights in red the new scope locations. The child scopes are necessary because the repeater evaluates &lt;code&gt;{{name}}&lt;/code&gt; expression, but depending on which scope the expression is evaluated it produces different result. Similarly the evaluation of &lt;code&gt;{{department}}&lt;/code&gt; prototypically inherits from root scope, as it is the only place where the &lt;code&gt;department&lt;/code&gt; property is defined.</source>
          <target state="translated">AngularJS 는 범위가 연결된 요소에 &lt;code&gt;ng-scope&lt;/code&gt; 클래스를 자동으로 배치 합니다. 이 예제 의 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 정의는 새 범위 위치를 빨간색으로 강조 표시합니다. repeater는 &lt;code&gt;{{name}}&lt;/code&gt; 표현식을 평가하므로 하위 범위가 필요 하지만, 평가되는 범위에 따라 다른 결과가 생성됩니다. 마찬가지로 &lt;code&gt;{{department}}&lt;/code&gt; 의 평가 는 &lt;code&gt;department&lt;/code&gt; 속성이 정의 된 유일한 위치이므로 루트 범위에서 프로토 타입으로 상속 됩니다.</target>
        </trans-unit>
        <trans-unit id="3839958f8944ea1c22c3c00974493cea51d7518b" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;SpicyController&lt;/code&gt; Controller now defines just one method called &lt;code&gt;spicy&lt;/code&gt;, which takes one argument called &lt;code&gt;spice&lt;/code&gt;. The template then refers to this Controller method and passes in a string constant &lt;code&gt;'chili'&lt;/code&gt; in the binding for the first button and a model property &lt;code&gt;customSpice&lt;/code&gt; (bound to an input box) in the second button.</source>
          <target state="translated">것을 알 수 &lt;code&gt;SpicyController&lt;/code&gt; 컨트롤러가 지금이라는 단 하나의 방법 정의 &lt;code&gt;spicy&lt;/code&gt; 라는 하나 개의 인수 소요 &lt;code&gt;spice&lt;/code&gt; . 그런 다음 템플릿은이 Controller 메서드를 참조 하고 첫 번째 버튼의 바인딩에서 문자열 상수 &lt;code&gt;'chili'&lt;/code&gt; 를 전달하고 두 번째 버튼의 모델 속성 &lt;code&gt;customSpice&lt;/code&gt; (입력 상자에 바인딩)를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="fcafb839ae2e19c3003dbe181ab743c7da4deb5d" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;debounce&lt;/code&gt; setting now inherits the value from the outer &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">있음을 주목 &lt;code&gt;debounce&lt;/code&gt; 설정은 이제 외부로부터 값을 상속 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="11c8b074765da89c55e8bddbf88d6d735cedb6db" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;debounce&lt;/code&gt; setting was not inherited and used the default value instead.</source>
          <target state="translated">것을 알 &lt;code&gt;debounce&lt;/code&gt; 설정이 상속 대신 기본값을 사용하지 않았다.</target>
        </trans-unit>
        <trans-unit id="84e33f4c42c94171ec70e888a6080924ce7f9f08" translate="yes" xml:space="preserve">
          <source>Notice that the unicorn provider is injected into the config function. This injection is done by a provider injector which is different from the regular instance injector, in that it instantiates and wires (injects) all provider instances only.</source>
          <target state="translated">유니콘 공급자는 구성 기능에 주입됩니다. 이 주입은 모든 인스턴스 인스턴스 만 인스턴스화하고 배선 (주입)한다는 점에서 일반 인스턴스 인젝터와 다른 제공자 인젝터에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="199e1ec52bd8dfa3947e323243561950569a2371" translate="yes" xml:space="preserve">
          <source>Notice that we are still using two plural categories(one, other), but we added three explicit number rules 0, 1 and 2. When one person, perhaps John, views the document, &quot;John is viewing&quot; will be shown. When three people view the document, no explicit number rule is found, so an offset of 2 is taken off 3, and AngularJS uses 1 to decide the plural category. In this case, plural category 'one' is matched and &quot;John, Mary and one other person are viewing&quot; is shown.</source>
          <target state="translated">우리는 여전히 두 개의 복수 범주 (하나는 다른 것)를 사용하고 있지만 세 가지 명시 적 숫자 규칙 0, 1 및 2를 추가했습니다. John과 같은 한 사람이 문서를 볼 때 &quot;John is looking&quot;가 표시됩니다. 세 사람이 문서를 볼 때 명시적인 숫자 규칙이 없으므로 오프셋 2가 3에서 제거되고 AngularJS는 1을 사용하여 복수 범주를 결정합니다. 이 경우 복수 범주 '1'이 일치하고 &quot;John, Mary 및 다른 사람이보고 있습니다&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1994c2630a8638f99ab205cb6033d30163f18599" translate="yes" xml:space="preserve">
          <source>Notice that we have bindings in this directive. After &lt;code&gt;$compile&lt;/code&gt; compiles and links &lt;code&gt;&amp;lt;div my-customer&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;, it will try to match directives on the element's children. This means you can compose directives of other directives. We'll see how to do that in &lt;a href=&quot;directive#creating-directives-that-communicate.html&quot;&gt;an example&lt;/a&gt; below.</source>
          <target state="translated">이 지시문에는 바인딩이 있습니다. &lt;code&gt;$compile&lt;/code&gt; 컴파일 및 &lt;code&gt;&amp;lt;div my-customer&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 링크 후 , 요소의 하위 요소에 대한 지시문을 일치 시키려고 시도합니다. 이는 다른 지시문의 지시문을 작성할 수 있음을 의미합니다. 아래 &lt;a href=&quot;directive#creating-directives-that-communicate.html&quot;&gt;예&lt;/a&gt; 에서이를 수행하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="81bd7a0e3da58bfc17640a279f9a5cbc48aaad4b" translate="yes" xml:space="preserve">
          <source>Notice the CSS class &lt;strong&gt;fade&lt;/strong&gt;? We can now create the CSS transition code that references this class:</source>
          <target state="translated">CSS 클래스 &lt;strong&gt;페이드를 확인하십시오&lt;/strong&gt; . 이제이 클래스를 참조하는 CSS 전환 코드를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5507629b5d2276102b44fefc2c3db40187c151" translate="yes" xml:space="preserve">
          <source>Now that AngularJS knows of all the parts of the application, it needs to create them. In the previous section we saw that controllers are created using a constructor function. For services, there are multiple ways to specify how they are created (see the &lt;a href=&quot;services&quot;&gt;service guide&lt;/a&gt;). In the example above, we are using an anonymous function as the factory function for the &lt;code&gt;currencyConverter&lt;/code&gt; service. This function should return the &lt;code&gt;currencyConverter&lt;/code&gt; service instance.</source>
          <target state="translated">AngularJS는 애플리케이션의 모든 부분을 알고 있으므로이를 생성해야합니다. 이전 섹션에서 우리는 컨트롤러가 생성자 함수를 사용하여 생성되는 것을 보았습니다. 서비스의 경우 서비스 작성 방법을 지정하는 여러 가지 방법이 있습니다 ( &lt;a href=&quot;services&quot;&gt;서비스 안내서&lt;/a&gt; 참조 ). 위의 예에서는 &lt;code&gt;currencyConverter&lt;/code&gt; 서비스 의 팩토리 함수로 익명 함수를 사용하고 있습니다. 이 함수는 &lt;code&gt;currencyConverter&lt;/code&gt; 서비스 인스턴스를 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3023743de3fc166f2614a5025a30366a01a0be40" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;on&lt;/code&gt; CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element in our HTML code then we can trigger a CSS or JS animation to happen.</source>
          <target state="translated">이제 인사말 상자 구성 요소 &lt;code&gt;on&lt;/code&gt; CSS 클래스가 추가 및 제거되었습니다. 이제 HTML 코드에서 인사 상자 요소 위에 CSS 클래스를 추가하면 CSS 또는 JS 애니메이션이 발생하도록 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a9c4611e97cb75f64fecd19f3bf1eb542109c4a" translate="yes" xml:space="preserve">
          <source>Now we can add a directive to our app.</source>
          <target state="translated">이제 앱에 지시문을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ddd006ee96483952150cc966e2ccc3310f3a60b" translate="yes" xml:space="preserve">
          <source>Now we can fill in the rest via our transition CSS code:</source>
          <target state="translated">이제 전환 CSS 코드를 통해 나머지를 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd4db9a4bc3a4df724b8949105cc438f10d21ff" translate="yes" xml:space="preserve">
          <source>Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur: an &lt;code&gt;out&lt;/code&gt; and an &lt;code&gt;in&lt;/code&gt; stage. The &lt;code&gt;out&lt;/code&gt; stage happens first and that is when the element is animated away from its origin. Once that animation is over then the &lt;code&gt;in&lt;/code&gt; stage occurs which animates the element to its destination. The reason why there are two animations is to give enough time for the enter animation on the new element to be ready.</source>
          <target state="translated">이제 앵커 애니메이션으로 돌아갈 수 있습니다. : 애니메이션이 발생하면 발생하는 두 단계가 &lt;code&gt;out&lt;/code&gt; 와 &lt;code&gt;in&lt;/code&gt; 무대. &lt;code&gt;out&lt;/code&gt; 스테이지가 먼저 발생하고, 소자의 원점으로부터 떨어진 애니메이션 때이다. 해당 애니메이션이 끝나면 요소가 대상으로 애니메이션되는 &lt;code&gt;in&lt;/code&gt; stage가 발생합니다. 두 개의 애니메이션이있는 이유는 새 요소의 enter 애니메이션이 준비 될 수 있도록 충분한 시간을 제공하기 위해서입니다.</target>
        </trans-unit>
        <trans-unit id="85942980bd72608eb2e7385f2bd59154033057d3" translate="yes" xml:space="preserve">
          <source>Now we create the &lt;strong&gt;JavaScript animation&lt;/strong&gt; that will trigger the CSS transition:</source>
          <target state="translated">이제 CSS 전환을 트리거 할 &lt;strong&gt;JavaScript 애니메이션&lt;/strong&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b6aea76798fd7c993834e12f5affe0d762a73898" translate="yes" xml:space="preserve">
          <source>Now we have two tests, but notice the duplication between the tests. Both have to create the &lt;code&gt;$scope&lt;/code&gt; variable and create the controller. As we add new tests, this duplication is only going to get worse. Thankfully, Jasmine provides &lt;code&gt;beforeEach&lt;/code&gt;, which lets us run a function before each individual test. Let's see how that would tidy up our tests:</source>
          <target state="translated">이제 두 가지 테스트가 있지만 테스트간에 중복이 있음을 알 수 있습니다. 둘 다 &lt;code&gt;$scope&lt;/code&gt; 변수를 작성하고 제어기를 작성해야합니다. 새로운 테스트를 추가함에 따라이 중복은 더욱 악화 될 것입니다. 고맙게도 Jasmine은 &lt;code&gt;beforeEach&lt;/code&gt; 를 제공 하여 각 개별 테스트 전에 기능을 실행할 수 있습니다. 그것이 우리의 테스트를 정리하는 방법을 보자.</target>
        </trans-unit>
        <trans-unit id="01bc994e095baae01166aef817062cc1507de306" translate="yes" xml:space="preserve">
          <source>Now we setup the mock backend and create the test specs:</source>
          <target state="translated">이제 모의 백엔드를 설정하고 테스트 사양을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e2b8c1c02a592bac26655509f0d4ef8342a63dc4" translate="yes" xml:space="preserve">
          <source>Now what do the contents of our &lt;code&gt;animator&lt;/code&gt; variable look like:</source>
          <target state="translated">이제 &lt;code&gt;animator&lt;/code&gt; 변수 의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c69de682241b16fef357ef55cb7730c3f9464cc0" translate="yes" xml:space="preserve">
          <source>Now, when the &lt;code&gt;ngIf&lt;/code&gt; expression changes, &lt;code&gt;ngAnimate&lt;/code&gt; will see the spinner animation and use it to animate the &lt;code&gt;enter&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; event, which doesn't work because the animation is infinite. The element will still be added / removed after a timeout, but there will be a noticeable delay.</source>
          <target state="translated">이제 &lt;code&gt;ngIf&lt;/code&gt; 표현식이 변경되면 &lt;code&gt;ngAnimate&lt;/code&gt; 에서 스피너 애니메이션을보고이를 사용하여 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 이벤트 에 애니메이션을 적용합니다 . 애니메이션은 무한하므로 작동하지 않습니다. 시간 초과 후에도 요소가 계속 추가 / 제거되지만 눈에 띄게 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="7d0d5f99a37ee70edab031267785cec623ef0119" translate="yes" xml:space="preserve">
          <source>Now, when the view changes (once the link is clicked), ngAnimate will examine the HTML contents to see if there is a match reference between any components in the view that is leaving and the view that is entering. It will scan both the view which is being removed (leave) and inserted (enter) to see if there are any paired DOM elements that contain a matching ref value.</source>
          <target state="translated">이제 뷰가 ​​변경되면 (링크를 클릭하면) ngAnimate는 HTML 내용을 검사하여 떠나는 뷰의 구성 요소와 들어가는 뷰 사이에 일치 참조가 있는지 확인합니다. 일치하는 참조 값을 포함하는 쌍을 이루는 DOM 요소가 있는지 확인하기 위해 제거 (방치) 및 삽입 (입력)중인보기를 모두 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="f95dbfde74296ed5d57d3a973b8c06886fc00be8" translate="yes" xml:space="preserve">
          <source>Nowadays most of the AngularJS projects are using only element and attribute directives, and in such projects there is no need to compile comments and classes.</source>
          <target state="translated">오늘날 대부분의 AngularJS 프로젝트는 요소 및 속성 지시문 만 사용하므로 이러한 프로젝트에서는 주석과 클래스를 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c05a46d489572fe209bbfcd6fd0cae15d381835c" translate="yes" xml:space="preserve">
          <source>Number of decimal places to round the amount to, defaults to default max fraction size for current locale</source>
          <target state="translated">양을 반올림 할 소수 자릿수, 현재 로캘의 기본 최대 분수 크기로 기본 설정</target>
        </trans-unit>
        <trans-unit id="2de873c3c8c40a30dc87a6efdf6c6b6b808f8957" translate="yes" xml:space="preserve">
          <source>Number of decimal places to round the number to. If this is not provided then the fraction size is computed from the current locale's number formatting pattern. In the case of the default locale, it will be 3.</source>
          <target state="translated">숫자를 반올림 할 소수 자릿수입니다. 이것이 제공되지 않으면 분수 크기는 현재 로케일의 숫자 서식 패턴에서 계산됩니다. 기본 로캘의 경우 3이됩니다.</target>
        </trans-unit>
        <trans-unit id="1cab7d05ea962fa769885ebf77b5f10eb16d0782" translate="yes" xml:space="preserve">
          <source>Number of milliseconds between each function call.</source>
          <target state="translated">각 함수 호출 사이의 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="7344ecd696099cafba5489c27372c57dd66d2a02" translate="yes" xml:space="preserve">
          <source>Number of pending requests to skip. For example, a value of &lt;code&gt;5&lt;/code&gt; would skip the first 5 pending requests and start flushing from the 6th onwards.</source>
          <target state="translated">건너 뛸 보류중인 요청 수입니다. 예를 들어, 값 &lt;code&gt;5&lt;/code&gt; 는 처음 5 개의 보류 요청을 건너 뛰고 6 번째부터 플러시를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="8eac9b329b2c580c8d444a64eb6fd91be474f30c" translate="yes" xml:space="preserve">
          <source>Number of responses to flush. If undefined/null, all pending requests (starting after &lt;code&gt;skip&lt;/code&gt;) will be flushed.</source>
          <target state="translated">플러시 할 응답 수입니다. undefined / null 인 경우 모든 보류중인 요청 ( &lt;code&gt;skip&lt;/code&gt; 후 시작 )이 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="f68b421f294e9b31cc2b54567e284f63c5469db0" translate="yes" xml:space="preserve">
          <source>Number of times to repeat. If not set, or 0, will repeat indefinitely.</source>
          <target state="translated">반복 횟수 설정하지 않으면 0이 무기한 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="e8550249d090d9100ad4508016e764db78774af3" translate="yes" xml:space="preserve">
          <source>Number rounded to &lt;code&gt;fractionSize&lt;/code&gt; appropriately formatted based on the current locale (e.g., in the en_US locale it will have &quot;.&quot; as the decimal separator and include &quot;,&quot; group separators after each third digit).</source>
          <target state="translated">현재 로케일을 기준으로 적절하게 형식화 된 숫자는 &lt;code&gt;fractionSize&lt;/code&gt; 로 반올림 됩니다 (예 : en_US 로케일에서는 소수점 구분 기호로 &quot;.&quot;가 있고 각 세 번째 숫자 뒤에 &quot;,&quot;그룹 구분 기호가 포함됨).</target>
        </trans-unit>
        <trans-unit id="bcd00e774ff736ecae6ca4c95d8c126b66654ba9" translate="yes" xml:space="preserve">
          <source>Number to format.</source>
          <target state="translated">서식을 지정할 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="5d0d0d8ab6d5d3a672af3a8d509722442303836e" translate="yes" xml:space="preserve">
          <source>Object components in ng</source>
          <target state="translated">ng의 객체 구성 요소</target>
        </trans-unit>
        <trans-unit id="e11c5730b47cb2ae0f3be1f4242cef69f0b5793c" translate="yes" xml:space="preserve">
          <source>Object components in ngMock</source>
          <target state="translated">ngMock의 객체 구성 요소</target>
        </trans-unit>
        <trans-unit id="0c7088859ca13e9dfdbb54c021c04f3e6cd0c7cb" translate="yes" xml:space="preserve">
          <source>Object containing default options to pass when setting cookies.</source>
          <target state="translated">쿠키를 설정할 때 전달할 기본 옵션이 포함 된 개체입니다.</target>
        </trans-unit>
        <trans-unit id="995d78c863aed54dbb876e5ea4c402cae1dd9572" translate="yes" xml:space="preserve">
          <source>Object containing default options used when creating &lt;code&gt;$resource&lt;/code&gt; instances.</source>
          <target state="translated">&lt;code&gt;$resource&lt;/code&gt; 인스턴스를 만들 때 사용되는 기본 옵션을 포함하는 개체 입니다.</target>
        </trans-unit>
        <trans-unit id="657930111284b6f69526339fc342bb6150cc6a1b" translate="yes" xml:space="preserve">
          <source>Object containing default values for all &lt;a href=&quot;../service/%24http&quot;&gt;$http&lt;/a&gt; requests.</source>
          <target state="translated">모든 &lt;a href=&quot;../service/%24http&quot;&gt;$ http&lt;/a&gt; 요청에 대한 기본값을 포함하는 개체 입니다.</target>
        </trans-unit>
        <trans-unit id="759fd0d572c4011472fed205eac43611faa1366f" translate="yes" xml:space="preserve">
          <source>Object describing the request to be made and how it should be processed. The object has following properties:</source>
          <target state="translated">요청 및 처리 방법을 설명하는 객체입니다. 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49310707de14d25a2b81072b3f31cead565e8a0a" translate="yes" xml:space="preserve">
          <source>Object or value to compare.</source>
          <target state="translated">비교할 객체 또는 값입니다.</target>
        </trans-unit>
        <trans-unit id="dd24b197b8c1db2163e1ac796ff37f51ee66294a" translate="yes" xml:space="preserve">
          <source>Object properties:</source>
          <target state="translated">객체 속성 :</target>
        </trans-unit>
        <trans-unit id="661911c1c58762c1a751a12e82b587ad0734d14f" translate="yes" xml:space="preserve">
          <source>Object to become context (&lt;code&gt;this&lt;/code&gt;) for the iterator function.</source>
          <target state="translated">반복자 함수의 컨텍스트가 될 객체 ( &lt;code&gt;this&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="28a82450c0a24a36b7195543cddb1b53d9eb4603" translate="yes" xml:space="preserve">
          <source>Object to iterate over.</source>
          <target state="translated">반복 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="fa827302c104f3c03bab5c1912db8174154c1c51" translate="yes" xml:space="preserve">
          <source>Object with all route configuration Objects as its properties.</source>
          <target state="translated">모든 경로 구성 객체를 속성으로 갖는 객체.</target>
        </trans-unit>
        <trans-unit id="19569f4887493f227cb304cc348f8b757202b03d" translate="yes" xml:space="preserve">
          <source>Observes an interpolated attribute.</source>
          <target state="translated">보간 된 속성을 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="5d89917fa7619007c94c10f147a56a81bbebfd52" translate="yes" xml:space="preserve">
          <source>Observing &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt;, such as double-curly expressions &lt;code&gt;{{expression}}&lt;/code&gt;, register listeners using the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$watch()&lt;/a&gt; method. This type of directive needs to be notified whenever the expression changes so that it can update the view.</source>
          <target state="translated">이중 곱슬 곱식 &lt;code&gt;{{expression}}&lt;/code&gt; 과 같은 &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시문을&lt;/a&gt; 관찰 하면 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$ watch ()&lt;/a&gt; 메소드를 사용하여 리스너를 등록하십시오 . 이 유형의 지시문은 뷰가 업데이트 될 수 있도록 표현식이 변경 될 때마다 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="fa8994e94ae63340255decacb1a40a4119cd94c0" translate="yes" xml:space="preserve">
          <source>Occurs</source>
          <target state="translated">Occurs</target>
        </trans-unit>
        <trans-unit id="942e0589c947be65474a002d509b097c5723a042" translate="yes" xml:space="preserve">
          <source>Official AngularJS Tutorial</source>
          <target state="translated">공식 AngularJS 튜토리얼</target>
        </trans-unit>
        <trans-unit id="5211024b2c932653139044bde2ef35e801bc766a" translate="yes" xml:space="preserve">
          <source>Official Communications</source>
          <target state="translated">공식 커뮤니케이션</target>
        </trans-unit>
        <trans-unit id="3dbb82784f4ceea929a606b795d9c5a9fff56ccd" translate="yes" xml:space="preserve">
          <source>Official announcements, news and releases are posted to our blog, G+ and Twitter:</source>
          <target state="translated">공식 공지, 뉴스 및 릴리스는 블로그, G + 및 Twitter에 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="aee2a58d9d00b28c3d6357134f216912f4105e7f" translate="yes" xml:space="preserve">
          <source>Offset of the &lt;em&gt;desired&lt;/em&gt; timezone in hours (fractions will be honored)</source>
          <target state="translated">&lt;em&gt;원하는&lt;/em&gt; 시간대 오프셋 (시간 단위) (분수가 적용됨)</target>
        </trans-unit>
        <trans-unit id="45919291790453a621a3d3ca6cb3d2791302bb6c" translate="yes" xml:space="preserve">
          <source>Offset to deduct from the total number.</source>
          <target state="translated">총수에서 공제되는 오프셋.</target>
        </trans-unit>
        <trans-unit id="3397619639d18ef70105382abc79e8b41ababef1" translate="yes" xml:space="preserve">
          <source>Often it's desirable to pass data from the isolate scope via an expression to the parent scope, this can be done by passing a map of local variable names and values into the expression wrapper function. For example, the &lt;code&gt;hideDialog&lt;/code&gt; function takes a message to display when the dialog is hidden. This is specified in the directive by calling &lt;code&gt;close({message: 'closing for now'})&lt;/code&gt;. Then the local variable &lt;code&gt;message&lt;/code&gt; will be available within the &lt;code&gt;on-close&lt;/code&gt; expression.</source>
          <target state="translated">식을 통해 격리 범위에서 부모 범위로 데이터를 전달하는 것이 바람직한 경우가 종종 있는데, 이는 로컬 변수 이름 및 값의 맵을 식 래퍼 함수로 전달하여 수행 할 수 있습니다. 예를 들어, &lt;code&gt;hideDialog&lt;/code&gt; 함수는 대화 상자가 숨겨져있을 때 메시지를 표시합니다. &lt;code&gt;close({message: 'closing for now'})&lt;/code&gt; 를 호출하여 지시문에 지정됩니다 . 그런 다음 로컬 변수 &lt;code&gt;message&lt;/code&gt; 를 &lt;code&gt;on-close&lt;/code&gt; 식 내에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc10f6b83c02595fc0e689a6e9a864045ddab25f" translate="yes" xml:space="preserve">
          <source>Often services have no configuration options and there is no need to add methods to the service provider. The provider will be no more than a constructor function with a &lt;code&gt;$get&lt;/code&gt; property. For these cases the &lt;a href=&quot;%24provide&quot;&gt;$provide&lt;/a&gt; service has additional helper methods to register services without specifying a provider.</source>
          <target state="translated">서비스에는 구성 옵션이없고 서비스 공급자에 메소드를 추가 할 필요가없는 경우가 종종 있습니다. 공급자는 &lt;code&gt;$get&lt;/code&gt; 속성을 가진 생성자 함수 일뿐입니다. 이러한 경우 &lt;a href=&quot;%24provide&quot;&gt;$ provide&lt;/a&gt; 서비스에는 공급자를 지정하지 않고 서비스를 등록하는 추가 도우미 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea29abb9e633dfb97ed5c1299fc4f4bd33508a9" translate="yes" xml:space="preserve">
          <source>Often, we would like to inject a reference once, in a &lt;code&gt;beforeEach()&lt;/code&gt; block and reuse this in multiple &lt;code&gt;it()&lt;/code&gt; clauses. To be able to do this we must assign the reference to a variable that is declared in the scope of the &lt;code&gt;describe()&lt;/code&gt; block. Since we would, most likely, want the variable to have the same name of the reference we have a problem, since the parameter to the &lt;code&gt;inject()&lt;/code&gt; function would hide the outer variable.</source>
          <target state="translated">종종 &lt;code&gt;beforeEach()&lt;/code&gt; 블록 에 한 번 참조를 삽입하고 &lt;code&gt;it()&lt;/code&gt; 여러 it () 절 에서 재사용 하려고 합니다. 이를 위해 &lt;code&gt;describe()&lt;/code&gt; 블록 의 범위에서 선언 된 변수에 참조를 할당해야합니다 . &lt;code&gt;inject()&lt;/code&gt; 함수에 대한 매개 변수가 외부 변수를 숨기 므로 문제가있는 참조와 동일한 이름을 갖는 변수를 원할 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="55cc916839b43a01a85adc73fa724a6b9294ff71" translate="yes" xml:space="preserve">
          <source>Older browsers will redirect regular URLs to hashbang URLs.</source>
          <target state="translated">오래된 브라우저는 일반 URL을 hashbang URL로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="730fe0b7474bfd48c7cbf76d43e5e9fcaa819084" translate="yes" xml:space="preserve">
          <source>Omitted or undefined options will leave the corresponding configuration values unchanged.</source>
          <target state="translated">생략되거나 정의되지 않은 옵션은 해당 구성 값을 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="3d94300e6072360828bff66e63d1c6eb5a9039e5" translate="yes" xml:space="preserve">
          <source>On failure, the promise is rejected with the &lt;a href=&quot;../../ng/service/%24http&quot;&gt;http response&lt;/a&gt; object.</source>
          <target state="translated">실패하면 약속은 &lt;a href=&quot;../../ng/service/%24http&quot;&gt;http 응답&lt;/a&gt; 오브젝트 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="3150ca64068eaff88aaa9f32a3f98bf979b1b891" translate="yes" xml:space="preserve">
          <source>On success, the promise is resolved with the same resource instance or collection object, updated with data from server. This makes it easy to use in the &lt;a href=&quot;../../ngroute/provider/%24routeprovider&quot;&gt;&lt;code&gt;resolve&lt;/code&gt; section of &lt;code&gt;$routeProvider.when()&lt;/code&gt;&lt;/a&gt; to defer view rendering until the resource(s) are loaded.</source>
          <target state="translated">성공하면 약속은 동일한 리소스 인스턴스 또는 컬렉션 개체로 해결되고 서버의 데이터로 업데이트됩니다. 따라서 &lt;a href=&quot;../../ngroute/provider/%24routeprovider&quot;&gt; &lt;code&gt;$routeProvider.when()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;resolve&lt;/code&gt; 섹션 에서 리소스를로드 할 때까지 뷰 렌더링을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e6a8fff8ee4ceb9f5d6a1cede49118cf8c5e9d" translate="yes" xml:space="preserve">
          <source>On this page, you will find a list of official AngularJS resources on various topics.</source>
          <target state="translated">이 페이지에는 다양한 주제에 대한 공식 AngularJS 리소스 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f0b69c7df5f5044072412f7dcb0c295c8f63c40" translate="yes" xml:space="preserve">
          <source>On to more complex examples!</source>
          <target state="translated">더 복잡한 예제로!</target>
        </trans-unit>
        <trans-unit id="a20c241950bf7f4ec7065c9cedf5f5b4df396af2" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;$animateCss&lt;/code&gt; is designed to be used inside of a registered JavaScript animation that is powered by ngAnimate. It is possible to use &lt;code&gt;$animateCss&lt;/code&gt; directly inside of a directive, however, any automatic control over cancelling animations and/or preventing animations from being run on child elements will not be handled by AngularJS. For this to work as expected, please use &lt;code&gt;$animate&lt;/code&gt; to trigger the animation and then setup a JavaScript animation that injects &lt;code&gt;$animateCss&lt;/code&gt; to trigger the CSS animation.</source>
          <target state="translated">다시 한번, &lt;code&gt;$animateCss&lt;/code&gt; 는 ngAnimate에 의해 구동되는 등록 된 JavaScript 애니메이션 내에서 사용되도록 설계되었습니다. 지시문 내에서 직접 &lt;code&gt;$animateCss&lt;/code&gt; 를 사용할 수 있지만 애니메이션 취소 및 / 또는 자식 요소에서 애니메이션 실행을 방지하는 자동 제어는 AngularJS에서 처리하지 않습니다. 예상대로 작동하려면 &lt;code&gt;$animate&lt;/code&gt; 를 사용 하여 애니메이션 을 트리거 한 다음 &lt;code&gt;$animateCss&lt;/code&gt; 를 삽입 하여 CSS 애니메이션을 트리거 하는 JavaScript 애니메이션을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="832079f71980ce1bf7e842ef4695d9a39eb9d0c3" translate="yes" xml:space="preserve">
          <source>Once all directives matching a DOM element have been identified, the compiler sorts the directives by their &lt;code&gt;priority&lt;/code&gt;.</source>
          <target state="translated">DOM 요소와 일치하는 모든 지시문이 식별되면 컴파일러는 지시문을 &lt;code&gt;priority&lt;/code&gt; 별로 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="a5f730f0b3ca3a229d8d79e42506be6dbbf141ef" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;$location&lt;/code&gt; service is instantiated, you can interact with it via jQuery-style getter and setter methods that allow you to get or change the current URL in the browser.</source>
          <target state="translated">한때 &lt;code&gt;$location&lt;/code&gt; 서비스의 인스턴스가, 당신은 당신이 얻을하거나 브라우저의 현재 URL을 변경할 수 jQuery를 스타일의 getter와 setter 메소드를 통해 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e75b43c6e8a6eaaaf021b30cd3620a33cd3961" translate="yes" xml:space="preserve">
          <source>Once the AngularJS &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; loop finishes, the execution leaves the AngularJS and JavaScript context. This is followed by the browser re-rendering the DOM to reflect any changes.</source>
          <target state="translated">AngularJS &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$ digest&lt;/a&gt; 루프가 완료되면 AngularJS 및 JavaScript 컨텍스트에서 실행됩니다. 그런 다음 브라우저는 DOM을 다시 렌더링하여 변경 사항을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="e021990af4a5931d2b41ef6a3af610ec4c360b79" translate="yes" xml:space="preserve">
          <source>Once the Controller has been attached to the DOM, the &lt;code&gt;double&lt;/code&gt; method can be invoked in an AngularJS expression in the template:</source>
          <target state="translated">Controller가 DOM에 연결되면 템플릿의 AngularJS 표현식에서 &lt;code&gt;double&lt;/code&gt; 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539e0ec3e60f15ed5b3ffd14cdc4bf07b3d5f281" translate="yes" xml:space="preserve">
          <source>Once the callback executes, the browser leaves the JavaScript context and re-renders the view based on DOM changes.</source>
          <target state="translated">콜백이 실행되면 브라우저는 JavaScript 컨텍스트를 떠나 DOM 변경에 따라 뷰를 다시 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="c42a629e99e7a6cb394fb6dd8cda3b8c140669fe" translate="yes" xml:space="preserve">
          <source>Once the configuration phase is over, interaction with providers is disallowed and the process of creating services starts. We call this part of the application life-cycle the run phase.</source>
          <target state="translated">구성 단계가 끝나면 공급자와의 상호 작용이 허용되지 않으며 서비스 작성 프로세스가 시작됩니다. 애플리케이션 수명주기의이 부분을 실행 단계라고합니다.</target>
        </trans-unit>
        <trans-unit id="4f503d8cfa1aefbfebbf220fc051e38e94c15149" translate="yes" xml:space="preserve">
          <source>Once this threshold is exceeded, either the horizontal or vertical delta is greater.</source>
          <target state="translated">이 임계 값을 초과하면 수평 또는 수직 델타가 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="ee5e5d4a8e33c0f18fe55ea3714b42beb7574f24" translate="yes" xml:space="preserve">
          <source>One advantage of this approach is that there's no array of names to keep in sync with the function parameters. You can also freely reorder dependencies.</source>
          <target state="translated">이 접근 방식의 한 가지 장점은 함수 매개 변수와 동기화 할 이름 배열이 없다는 것입니다. 종속성을 자유롭게 재정렬 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e81236156cec40b8f929730878ed25e4592cd246" translate="yes" xml:space="preserve">
          <source>One caveat with this combination of CSS and &lt;code&gt;aria-hidden&lt;/code&gt;: you must also remove links and other interactive child elements from the tab order using &lt;code&gt;tabIndex=&amp;ldquo;-1&amp;rdquo;&lt;/code&gt; on each control. This ensures screen reader users won't accidentally focus on &quot;mystery elements&quot;. Managing tab index on every child control can be complex and affect performance, so it&amp;rsquo;s best to just stick with the default &lt;code&gt;display: none&lt;/code&gt; CSS. See the &lt;a href=&quot;http://www.w3.org/TR/aria-in-html/#fourth-rule-of-aria-use&quot;&gt;fourth rule of ARIA use&lt;/a&gt;.</source>
          <target state="translated">이 CSS와 &lt;code&gt;aria-hidden&lt;/code&gt; 조합에 대한 하나의 경고 : 각 컨트롤에서 &lt;code&gt;tabIndex=&amp;ldquo;-1&amp;rdquo;&lt;/code&gt; 을 사용하여 탭 순서에서 링크 및 기타 대화식 하위 요소를 제거해야합니다 . 이렇게하면 화면 판독기 사용자가 실수로 &quot;미스테리 요소&quot;에 집중하지 않게됩니다. 모든 자식 컨트롤에서 탭 인덱스를 관리하는 것은 복잡하고 성능에 영향을 줄 수 있으므로 기본 &lt;code&gt;display: none&lt;/code&gt; CSS 없음을 사용하는 것이 가장 좋습니다 . &lt;a href=&quot;http://www.w3.org/TR/aria-in-html/#fourth-rule-of-aria-use&quot;&gt;ARIA 사용&lt;/a&gt; 의 네 번째 규칙을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4801ac26d4a643695f54dd7f69d290e1fed765ee" translate="yes" xml:space="preserve">
          <source>One example of such a context is rendering arbitrary content via the &lt;a href=&quot;../api/ng/directive/ngbindhtml&quot;&gt;&lt;code&gt;ngBindHtml&lt;/code&gt;&lt;/a&gt; directive. If the content is provided by a user there is a chance of Cross Site Scripting (XSS) attacks. The &lt;a href=&quot;../api/ng/directive/ngbindhtml&quot;&gt;&lt;code&gt;ngBindHtml&lt;/code&gt;&lt;/a&gt; directive will not render content that is not marked as safe by &lt;a href=&quot;../api/ng/service/%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;../api/ngsanitize&quot;&gt;&lt;code&gt;ngSanitize&lt;/code&gt;&lt;/a&gt; module can be used to clean such user provided content and mark the content as safe.</source>
          <target state="translated">이러한 컨텍스트의 한 예는 &lt;a href=&quot;../api/ng/directive/ngbindhtml&quot;&gt; &lt;code&gt;ngBindHtml&lt;/code&gt; &lt;/a&gt; 지시문을 통해 임의의 컨텐츠를 렌더링하는 것 입니다. 사용자가 컨텐츠를 제공하면 XSS (Cross Site Scripting) 공격이 발생할 가능성이 있습니다. &lt;a href=&quot;../api/ng/directive/ngbindhtml&quot;&gt; &lt;code&gt;ngBindHtml&lt;/code&gt; 의&lt;/a&gt; 지시에 의해 안전한 것으로 표시되지 않은 콘텐츠를 렌더링하지 않습니다 &lt;a href=&quot;../api/ng/service/%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../api/ngsanitize&quot;&gt; &lt;code&gt;ngSanitize&lt;/code&gt; 의&lt;/a&gt; 모듈은 깨끗 같은 사용자 제공 컨텐츠에 사용되는 안전 등의 콘텐츠를 표시 할 수있다.</target>
        </trans-unit>
        <trans-unit id="8da34b97a8ac7368cf4a952a5049271759ff499d" translate="yes" xml:space="preserve">
          <source>One issue occurs if you want to preselect an option. For example, if you set the model to an object that is equal to an object in your collection, &lt;code&gt;ngOptions&lt;/code&gt; won't be able to set the selection, because the objects are not identical. So by default, you should always reference the item in your collection for preselections, e.g.: &lt;code&gt;$scope.selected = $scope.collection[3]&lt;/code&gt;.</source>
          <target state="translated">옵션을 미리 선택하려는 경우 한 가지 문제가 발생합니다. 예를 들어 모델을 컬렉션의 객체와 동일한 객체 로 설정하면 객체가 동일하지 않기 때문에 &lt;code&gt;ngOptions&lt;/code&gt; 에서 선택 항목을 설정할 수 없습니다. 따라서 기본적으로 항상 사전 선택을 위해 컬렉션의 항목을 참조해야합니다 (예 : &lt;code&gt;$scope.selected = $scope.collection[3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03cf224c49b28630f423eb00b170a96952f63750" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;template&lt;/code&gt; or &lt;code&gt;templateUrl&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 또는 &lt;code&gt;templateUrl&lt;/code&gt; 중 하나 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1e0b15fa92a730eefc11a4f041fe211c93f8a77f" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;templateUrl&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; is required.</source>
          <target state="translated">&lt;code&gt;templateUrl&lt;/code&gt; 또는 &lt;code&gt;template&lt;/code&gt; 중 하나 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="854c677d0ec17d170fc8ceb1283231687845a9df" translate="yes" xml:space="preserve">
          <source>One of the most common use cases for directives is to create reusable components.</source>
          <target state="translated">지시문의 가장 일반적인 사용 사례 중 하나는 재사용 가능한 구성 요소를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a1e704a493b53f759675b1a40b45e4e787bc094" translate="yes" xml:space="preserve">
          <source>One-time binding</source>
          <target state="translated">일회성 바인딩</target>
        </trans-unit>
        <trans-unit id="d835907bfc4fb4d1c778ab9ea9cff8835777aba5" translate="yes" xml:space="preserve">
          <source>One-time binding expressions will retain the value of the expression at the end of the digest cycle as long as that value is not undefined. If the value of the expression is set within the digest loop and later, within the same digest loop, it is set to undefined, then the expression is not fulfilled and will remain watched.</source>
          <target state="translated">일회성 바인딩 표현식은 값이 정의되지 않은 한 다이제스트주기 종료시 표현식의 값을 유지합니다. 표현식 값이 다이제스트 루프 내에서 설정되고 나중에 동일한 다이제스트 루프 내에서 정의되지 않은 상태로 설정되면 표현식이 이행되지 않고 감시 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="96499287e9d0872201af20706453570303a19464" translate="yes" xml:space="preserve">
          <source>One-way binding is useful if you do not plan to propagate changes to your isolated scope bindings back to the parent. However, it does not make this completely impossible.</source>
          <target state="translated">단방향 바인딩은 변경 내용을 격리 된 범위 바인딩에 대한 부모로 다시 전파하지 않으려는 경우에 유용합니다. 그러나 이것이 완전히 불가능하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dccdcd12500ea529350f72fe2d3b19576485f9d7" translate="yes" xml:space="preserve">
          <source>Only GET and JSONP requests are cached.</source>
          <target state="translated">GET 및 JSONP 요청 만 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="cdbf524cafe4d97e9aa889d4e8172073d5ad8692" translate="yes" xml:space="preserve">
          <source>Only enumerable properties are taken into account. Non-enumerable properties (both on &lt;code&gt;source&lt;/code&gt; and on &lt;code&gt;destination&lt;/code&gt;) will be ignored.</source>
          <target state="translated">열거 가능한 속성 만 고려됩니다. 열거 할 수없는 속성 ( &lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;destination&lt;/code&gt; 모두 )은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="87ef77c843d94d8412ef52b8157422f49c4e5ce1" translate="yes" xml:space="preserve">
          <source>Only trusted origins that you have control over and make sure you understand the implications of doing so.</source>
          <target state="translated">제어 할 수있는 신뢰할 수있는 출처와 그렇게하는 것의 의미를 이해하도록합니다.</target>
        </trans-unit>
        <trans-unit id="fd014ff097e63e654d665440447b5e12e4b2ada5" translate="yes" xml:space="preserve">
          <source>Only whitelist origins that you have control over and make sure you understand the implications of doing so.</source>
          <target state="translated">본인이 통제 할 수있는 출처 만 허용하고 그 의미를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8bfc2e5f51edb5b85fb55866f0e43ef5e595160" translate="yes" xml:space="preserve">
          <source>Opening a regular URL in a legacy browser -&amp;gt; redirects to a hashbang URL</source>
          <target state="translated">레거시 브라우저에서 일반 URL을 열면 해시 뱅 URL로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="eac6c8960165a7f26749c618d7083ac4d241844c" translate="yes" xml:space="preserve">
          <source>Opening hashbang URL in a modern browser -&amp;gt; rewrites to a regular URL</source>
          <target state="translated">최신 브라우저에서 해시 뱅 URL을 열면 일반 URL로 다시 작성</target>
        </trans-unit>
        <trans-unit id="4cb67181c995794bf3233189f17b34d6d6217d98" translate="yes" xml:space="preserve">
          <source>Optional arguments to be prebound to the &lt;code&gt;fn&lt;/code&gt; function call.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 함수 호출에 사전 바인드되는 선택적 인수 .</target>
        </trans-unit>
        <trans-unit id="ac0d0c08de325f31e275247f3679a58b231c7aae" translate="yes" xml:space="preserve">
          <source>Optional configuration function for the module. Same as &lt;a href=&quot;../type/angular.module#config.html&quot;&gt;Module#config()&lt;/a&gt;.</source>
          <target state="translated">모듈의 선택적 구성 기능. &lt;a href=&quot;../type/angular.module#config.html&quot;&gt;Module # config ()&lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b0e8d88ea45891039fc896a3cf76fcc8a6285b7f" translate="yes" xml:space="preserve">
          <source>Optional configuration object. See &lt;a href=&quot;%24http#%24http-arguments.html&quot;&gt;&lt;code&gt;$http()&lt;/code&gt; arguments&lt;/a&gt;.</source>
          <target state="translated">선택적 구성 개체 &lt;a href=&quot;%24http#%24http-arguments.html&quot;&gt; &lt;code&gt;$http()&lt;/code&gt; 인수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef8683e6e87ff851919c02dfa80a3465f8201585" translate="yes" xml:space="preserve">
          <source>Optional event type. If none is specified, the function tries to determine the right event type for the element, e.g. &lt;code&gt;change&lt;/code&gt; for &lt;code&gt;input[text]&lt;/code&gt;.</source>
          <target state="translated">선택적 이벤트 유형. 지정하지 않은 경우, 기능 소자 시도는, 예를 들어 적합한 이벤트 유형 결정 &lt;code&gt;change&lt;/code&gt; 에 대한 &lt;code&gt;input[text]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9e2a88dac526935cb244eb3725881ffa83069f2" translate="yes" xml:space="preserve">
          <source>Optional information about the context in which the error was thrown.</source>
          <target state="translated">오류가 발생한 컨텍스트에 대한 선택적 정보입니다.</target>
        </trans-unit>
        <trans-unit id="1a8192981f2869d35df047f536371348437dfb99" translate="yes" xml:space="preserve">
          <source>Optional object. If preset then any argument names are read from this object first, before the &lt;code&gt;$injector&lt;/code&gt; is consulted.</source>
          <target state="translated">선택적 객체. 프리셋 인 경우 &lt;code&gt;$injector&lt;/code&gt; 를 참조 하기 전에 먼저이 객체에서 인수 이름을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="5308b40f28c97e7121b60297dbc6d959146a267f" translate="yes" xml:space="preserve">
          <source>Optional one or more arguments which will be passed onto the event listeners.</source>
          <target state="translated">이벤트 리스너에 전달 될 하나 이상의 인수 (선택 사항).</target>
        </trans-unit>
        <trans-unit id="ffb1a7ca3375dfcc6ea76b0ae3ce4b9bb97b4432" translate="yes" xml:space="preserve">
          <source>Optionally, a single hard-coded &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; element, with the value set to an empty string, can be nested into the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element. This element will then represent the &lt;code&gt;null&lt;/code&gt; or &quot;not selected&quot; option. See example below for demonstration.</source>
          <target state="translated">선택적으로 값이 빈 문자열로 설정된 하드 코딩 된 단일 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 요소를 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소에 중첩시킬 수 있습니다 . 그런 다음이 요소는 &lt;code&gt;null&lt;/code&gt; 또는 &quot;선택되지 않음&quot;옵션 을 나타냅니다 . 데모는 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be30a36044b515fd6383450db5f35c6cd47f0ba2" translate="yes" xml:space="preserve">
          <source>Optionally, you can also pass a &lt;code&gt;delay&lt;/code&gt; argument to only flush tasks that are scheduled to be executed within &lt;code&gt;delay&lt;/code&gt; milliseconds. Currently, &lt;code&gt;delay&lt;/code&gt; only applies to timeouts, since all other tasks have a delay of 0 (i.e. they are scheduled to be executed as soon as possible, but still asynchronously).</source>
          <target state="translated">선택적으로 &lt;code&gt;delay&lt;/code&gt; 밀리 초) 내에 실행되도록 예약 된 플러시 작업에만 &lt;code&gt;delay&lt;/code&gt; 인수를 전달할 수도 있습니다 . 현재 &lt;code&gt;delay&lt;/code&gt; 다른 모든 작업이 0의 지연이 있기 때문에 만, 시간 제한 적용 (비동기 여전히 그들은 가능한 한 빨리 실행되도록 예정되어 즉,하지만).</target>
        </trans-unit>
        <trans-unit id="4b5f9957c039daa83cf25452707710c1e43b965d" translate="yes" xml:space="preserve">
          <source>Options object that specifies the cache behavior. Properties:</source>
          <target state="translated">캐시 동작을 지정하는 옵션 개체입니다. 속성 :</target>
        </trans-unit>
        <trans-unit id="0dfe73319c3612f8a3b2d0b40ebbd05b380be0ec" translate="yes" xml:space="preserve">
          <source>Options object. See &lt;a href=&quot;../provider/%24cookiesprovider#defaults.html&quot;&gt;$cookiesProvider.defaults&lt;/a&gt;</source>
          <target state="translated">옵션 객체. &lt;a href=&quot;../provider/%24cookiesprovider#defaults.html&quot;&gt;$ cookiesProvider.defaults를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1a0580f34c8e279c5382e2d17c2d33fd81d807e" translate="yes" xml:space="preserve">
          <source>Or you can even overwrite the whole &lt;code&gt;actions&lt;/code&gt; list and specify your own:</source>
          <target state="translated">또는 전체 &lt;code&gt;actions&lt;/code&gt; 목록을 덮어 쓰고 자신의 작업 을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="53ea91d4f8d828842a74887526a654e8ed22c0de" translate="yes" xml:space="preserve">
          <source>Order of requests matters</source>
          <target state="translated">요청 순서 문제</target>
        </trans-unit>
        <trans-unit id="545aec36915e5edaf380fe6995274a74ca310fc5" translate="yes" xml:space="preserve">
          <source>Ordering a table with ngRepeat</source>
          <target state="translated">ngRepeat을 사용하여 테이블 주문</target>
        </trans-unit>
        <trans-unit id="b328f238cd54c5675a77847bfa732f0014d578b3" translate="yes" xml:space="preserve">
          <source>Ordering the specified &lt;code&gt;collection&lt;/code&gt; happens in two phases:</source>
          <target state="translated">지정된 &lt;code&gt;collection&lt;/code&gt; 주문하는 과정 은 두 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="ab286f64bf8ad2bdaf9ba29734918078d2434ff7" translate="yes" xml:space="preserve">
          <source>Ordinarily, we would expect that &lt;code&gt;{{name}}&lt;/code&gt; would be &lt;code&gt;Jeff&lt;/code&gt;. However, we see in this example that the &lt;code&gt;{{name}}&lt;/code&gt; binding is still &lt;code&gt;Tobias&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;{{name}}&lt;/code&gt; 은 &lt;code&gt;Jeff&lt;/code&gt; 일 것으로 예상 됩니다. 그러나이 예제에서 &lt;code&gt;{{name}}&lt;/code&gt; 바인딩은 여전히 &lt;code&gt;Tobias&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1167c4f1730b003f23191dfd48807c264f48a17b" translate="yes" xml:space="preserve">
          <source>Other Features</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="456d2677e518e26ef0d24a4e5e0c50a00c1e8bbd" translate="yes" xml:space="preserve">
          <source>Other Languages</source>
          <target state="translated">다른 언어</target>
        </trans-unit>
        <trans-unit id="020a1308bcbd2b8d869bb1b5c21560f23a1fa146" translate="yes" xml:space="preserve">
          <source>Other attributes may also not work as expected when they contain interpolation markup, and can be used with &lt;code&gt;ngAttr&lt;/code&gt; instead. The following is a list of known problematic attributes:</source>
          <target state="translated">보간 마크 업이 포함 된 다른 속성도 예상대로 작동하지 않을 수 있으며 대신 &lt;code&gt;ngAttr&lt;/code&gt; 과 함께 사용할 수 있습니다 . 다음은 알려진 문제 속성 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e4dd7ab1c0e39f0f88a1797f64ef4a8003416e45" translate="yes" xml:space="preserve">
          <source>Otherwise whitespace around the delimiter is ignored when splitting (although it is respected when joining the list items back together) and whitespace around each list item is stripped before it is added to the model.</source>
          <target state="translated">그렇지 않으면 분리 할 때 구분 기호 주위의 공백이 무시되고 (목록 항목을 다시 결합 할 때 존중되지만) 각 목록 항목 주위의 공백은 모델에 추가되기 전에 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a0675534b64e196386b94e2804a59bd1bc23fa8e" translate="yes" xml:space="preserve">
          <source>Otherwise, return:</source>
          <target state="translated">그렇지 않으면 다음을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="072eb9bf03eeb09cbe67d59dcba2963501dc97e5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;myCustomer&lt;/code&gt; directive above is great, but it has a fatal flaw. We can only use it once within a given scope.</source>
          <target state="translated">위 의 &lt;code&gt;myCustomer&lt;/code&gt; 지시문은 훌륭하지만 치명적인 결함이 있습니다. 주어진 범위 내에서 한 번만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558209072aafaacde0c7cdb5a66cdfe66c0d2c5d" translate="yes" xml:space="preserve">
          <source>Outputs are realized with &lt;code&gt;&amp;amp;&lt;/code&gt; bindings, which function as callbacks to component events.</source>
          <target state="translated">출력은 구성 요소 이벤트에 대한 콜백으로 기능하는 &lt;code&gt;&amp;amp;&lt;/code&gt; 바인딩 으로 실현됩니다 .</target>
        </trans-unit>
        <trans-unit id="22ba9ea1494be6e8782c0e21dbbf76a0b41e8a62" translate="yes" xml:space="preserve">
          <source>Override the current model options settings programmatically.</source>
          <target state="translated">프로그래밍 방식으로 현재 모델 옵션 설정을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="ef041aeb92c07c1a85fa7fdac09f3f7219358b54" translate="yes" xml:space="preserve">
          <source>Override the property name to use when attaching the controller to the scope.</source>
          <target state="translated">컨트롤러를 스코프에 연결할 때 사용할 속성 이름을 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="22b14e1048bf2a3d5b605204778ea44f9663ce36" translate="yes" xml:space="preserve">
          <source>Overriding .ng-hide</source>
          <target state="translated">.ng-hide 재정의</target>
        </trans-unit>
        <trans-unit id="9a7fbfe01d220ff7f0962d309017a2ffc384f7fe" translate="yes" xml:space="preserve">
          <source>Overriding immediate updates</source>
          <target state="translated">즉시 업데이트 재정의</target>
        </trans-unit>
        <trans-unit id="fa09aea495028381f0827010d76af2aac843fe48" translate="yes" xml:space="preserve">
          <source>Overriding the Default Transformations Per Request</source>
          <target state="translated">요청 당 기본 변환 재정의</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="b4524ad64470cfefa0e6ef5ccaabb2ecf125384c" translate="yes" xml:space="preserve">
          <source>Page reload navigation</source>
          <target state="translated">페이지 새로 고침 탐색</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="6cf3b6abb1b4f5ccecfcf57f0c3af07ef7fb83d1" translate="yes" xml:space="preserve">
          <source>Parse all your application element classes.</source>
          <target state="translated">모든 애플리케이션 요소 클래스를 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="8ca73572c8320134a2008b43c3b43eeb683a50e5" translate="yes" xml:space="preserve">
          <source>Parse all your application html comments.</source>
          <target state="translated">모든 응용 프로그램 HTML 주석을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="3f4af19a0d34ae188e13ee7ba944ba662612d7e9" translate="yes" xml:space="preserve">
          <source>Parsers are used to sanitize / convert the &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;$viewValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파서는 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;$viewValue&lt;/code&gt; &lt;/a&gt; 를 살균 / 변환하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7cd56f2a2a3f47830760edfb89946eb7b9e2cd1" translate="yes" xml:space="preserve">
          <source>Pass</source>
          <target state="translated">Pass</target>
        </trans-unit>
        <trans-unit id="3724e4e357a62c0e307b4b1ff0955749ca8faa98" translate="yes" xml:space="preserve">
          <source>Passing an array (&lt;code&gt;[...]&lt;/code&gt;) is equivalent to passing &lt;code&gt;{htmlElements: [...]}&lt;/code&gt;.</source>
          <target state="translated">배열 ( &lt;code&gt;[...]&lt;/code&gt; )을 전달하는 것은 &lt;code&gt;{htmlElements: [...]}&lt;/code&gt; 를 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f7ca9f03a097ecb064033e0b20fd57b688e73b06" translate="yes" xml:space="preserve">
          <source>Passing one argument retrieves an existing &lt;a href=&quot;../type/angular.module&quot;&gt;&lt;code&gt;angular.Module&lt;/code&gt;&lt;/a&gt;, whereas passing more than one argument creates a new &lt;a href=&quot;../type/angular.module&quot;&gt;&lt;code&gt;angular.Module&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">하나의 인수를 전달하면 기존의 &lt;a href=&quot;../type/angular.module&quot;&gt; &lt;code&gt;angular.Module&lt;/code&gt; 을&lt;/a&gt; 검색 하지만, 둘 이상의 인수를 전달하면 새로운 &lt;a href=&quot;../type/angular.module&quot;&gt; &lt;code&gt;angular.Module&lt;/code&gt; &lt;/a&gt; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5ee5be4397673c7b0cfcf05f36fb561ca4a2f795" translate="yes" xml:space="preserve">
          <source>Patch the $delegate</source>
          <target state="translated">$ delegate 패치</target>
        </trans-unit>
        <trans-unit id="c24b1eabafb92c695a49765eb3856c47bb2e3c5e" translate="yes" xml:space="preserve">
          <source>Pending tasks scheduled via &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$applyAsync&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$ applyAsync&lt;/a&gt; 를 통해 예약 된 보류중인 작업 입니다.</target>
        </trans-unit>
        <trans-unit id="949f1fe22a6e90a316f8a5355573c25a0073893c" translate="yes" xml:space="preserve">
          <source>Pending tasks scheduled via &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$evalAsync&lt;/a&gt;. These include tasks scheduled via &lt;code&gt;$evalAsync()&lt;/code&gt; indirectly (such as &lt;a href=&quot;../../ng/service/%24q&quot;&gt;&lt;code&gt;$q&lt;/code&gt;&lt;/a&gt; promises).</source>
          <target state="translated">&lt;a href=&quot;../../ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$ evalAsync&lt;/a&gt; 를 통해 예약 된 보류중인 작업 입니다. 여기에는 &lt;code&gt;$evalAsync()&lt;/code&gt; 를 통해 간접적으로 예약 된 작업 (예 : &lt;a href=&quot;../../ng/service/%24q&quot;&gt; &lt;code&gt;$q&lt;/code&gt; &lt;/a&gt; promises)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="37a92dc5c98d97bbf900c4f6991b8aac335f50fc" translate="yes" xml:space="preserve">
          <source>Pending timeouts (via &lt;a href=&quot;%24timeout&quot;&gt;&lt;code&gt;$timeout&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">대기 시간 초과 ( &lt;a href=&quot;%24timeout&quot;&gt; &lt;code&gt;$timeout&lt;/code&gt; &lt;/a&gt; 통해 ).</target>
        </trans-unit>
        <trans-unit id="c7c922ddec77e6492fd9602470ecd3c278ff489f" translate="yes" xml:space="preserve">
          <source>Performs an inline animation on the element which applies the provided to and from CSS styles to the element. If any detected CSS transition, keyframe or JavaScript matches the provided className value, then the animation will take on the provided styles. For example, if a transition animation is set for the given className, then the provided &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; styles will be applied alongside the given transition. If the CSS style provided in &lt;code&gt;from&lt;/code&gt; does not have a corresponding style in &lt;code&gt;to&lt;/code&gt;, the style in &lt;code&gt;from&lt;/code&gt; is applied immediately, and no animation is run. If a JavaScript animation is detected then the provided styles will be given in as function parameters into the &lt;code&gt;animate&lt;/code&gt; method (or as part of the &lt;code&gt;options&lt;/code&gt; parameter):</source>
          <target state="translated">제공된 CSS 스타일을 요소에 적용하는 요소에 대해 인라인 애니메이션을 수행합니다. 감지 된 CSS 전환, 키 프레임 또는 JavaScript가 제공된 className 값과 일치하면 애니메이션이 제공된 스타일을 취합니다. 전이 애니메이션 주어진 클래스 이름에 대해 설정된 경우, 예를 들어, 제공된 &lt;code&gt;from&lt;/code&gt; 와 &lt;code&gt;to&lt;/code&gt; 지정된 전환과 함께 적용 할 스타일. 에서 제공하는 CSS 스타일의 경우 &lt;code&gt;from&lt;/code&gt; 에 상응하는 스타일이없는 &lt;code&gt;to&lt;/code&gt; ,의 스타일 &lt;code&gt;from&lt;/code&gt; 즉시 적용되며, 어떤 애니메이션이 실행되지 않습니다. JavaScript 애니메이션이 감지되면 제공된 스타일이 &lt;code&gt;animate&lt;/code&gt; 함수 매개 변수로 제공됩니다.방법 (또는 &lt;code&gt;options&lt;/code&gt; 매개 변수의 일부 ) :</target>
        </trans-unit>
        <trans-unit id="0fe8ef331e3e18dd6d6ee2e94ecd618e64625c03" translate="yes" xml:space="preserve">
          <source>Performs both the addition and removal of a CSS classes on an element and (during the process) triggers an animation surrounding the class addition/removal. Much like &lt;code&gt;$animate.addClass&lt;/code&gt; and &lt;code&gt;$animate.removeClass&lt;/code&gt;, &lt;code&gt;setClass&lt;/code&gt; will only evaluate the classes being added/removed once a digest has passed. Note that class-based animations are treated differently compared to structural animations (like enter, move and leave) since the CSS classes may be added/removed at different points depending if CSS or JavaScript animations are used.</source>
          <target state="translated">요소에서 CSS 클래스의 추가 및 제거를 수행하고 (프로세스 중) 클래스 추가 / 제거를 둘러싼 애니메이션을 트리거합니다. 많은처럼 &lt;code&gt;$animate.addClass&lt;/code&gt; 및 &lt;code&gt;$animate.removeClass&lt;/code&gt; , &lt;code&gt;setClass&lt;/code&gt; 는 다이제스트가 통과되면 클래스가 추가 / 제거되는 만 평가합니다. CSS 또는 JavaScript 애니메이션 사용 여부에 따라 CSS 클래스가 다른 지점에서 추가 / 제거 될 수 있으므로 클래스 기반 애니메이션은 구조 애니메이션 (입력, 이동 및 휴가 등)과 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fde22c44087196711ccbb71078d1ff22cb70d919" translate="yes" xml:space="preserve">
          <source>Periodic tasks scheduled via &lt;a href=&quot;%24interval&quot;&gt;&lt;code&gt;$interval&lt;/code&gt;&lt;/a&gt; use a different queue and are not flushed by &lt;code&gt;$flushPendingTasks()&lt;/code&gt;. Use &lt;a href=&quot;%24interval#flush.html&quot;&gt;$interval.flush(millis)&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;%24interval&quot;&gt; &lt;code&gt;$interval&lt;/code&gt; &lt;/a&gt; 통해 예약 된 주기적 작업 은 다른 큐를 사용하며 &lt;code&gt;$flushPendingTasks()&lt;/code&gt; 플러시되지 않습니다 . 사용 &lt;a href=&quot;%24interval#flush.html&quot;&gt;$ interval.flush (밀리 세컨드)&lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="ccb639561dbe9976233905fa4c560e41d0cddf85" translate="yes" xml:space="preserve">
          <source>Periodic tasks scheduled via &lt;a href=&quot;%24interval&quot;&gt;&lt;code&gt;$interval&lt;/code&gt;&lt;/a&gt; use a different queue and are not taken into account by &lt;code&gt;$verifyNoPendingTasks()&lt;/code&gt;. There is currently no way to verify that there are no pending &lt;a href=&quot;%24interval&quot;&gt;&lt;code&gt;$interval&lt;/code&gt;&lt;/a&gt; tasks.</source>
          <target state="translated">&lt;a href=&quot;%24interval&quot;&gt; &lt;code&gt;$interval&lt;/code&gt; &lt;/a&gt; 통해 예약 된 주기적 작업 은 다른 대기열을 사용하며 &lt;code&gt;$verifyNoPendingTasks()&lt;/code&gt; 에서는 고려하지 않습니다 . 현재 보류중인 &lt;a href=&quot;%24interval&quot;&gt; &lt;code&gt;$interval&lt;/code&gt; &lt;/a&gt; 태스크 가 없는지 확인할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9175845018286100e8c4dd426601703543b596bf" translate="yes" xml:space="preserve">
          <source>Place &lt;code&gt;ng-app&lt;/code&gt; to the root of your application, typically on the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag if you want AngularJS to auto-bootstrap your application.</source>
          <target state="translated">장소 &lt;code&gt;ng-app&lt;/code&gt; 응용 프로그램의 루트는 일반적으로에 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 태그는 자동으로 부트 스트랩에 AngularJS와 응용 프로그램을 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="b78ac8ca34cd41564ccb9b7e0ba05721f3cb269f" translate="yes" xml:space="preserve">
          <source>Place the &lt;code&gt;script&lt;/code&gt; tag at the bottom of the page. Placing script tags at the end of the page improves app load time because the HTML loading is not blocked by loading of the &lt;code&gt;angular.js&lt;/code&gt; script. You can get the latest bits from &lt;a href=&quot;http://code.angularjs.org&quot;&gt;http://code.angularjs.org&lt;/a&gt;. Please don't link your production code to this URL, as it will expose a security hole on your site. For experimental development linking to our site is fine.</source>
          <target state="translated">장소 &lt;code&gt;script&lt;/code&gt; 페이지 하단에 태그를. 페이지 끝에 스크립트 태그를 배치하면 &lt;code&gt;angular.js&lt;/code&gt; 스크립트를 로드하여 HTML로드가 차단되지 않기 때문에 앱로드 시간이 향상 됩니다. &lt;a href=&quot;http://code.angularjs.org&quot;&gt;http://code.angularjs.org&lt;/a&gt; 에서 최신 비트를 얻을 수 있습니다 . 프로덕션 코드를이 URL에 연결하지 마십시오. 사이트에 보안 허점이 나타납니다. 실험적 개발을 위해 우리 사이트에 연결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d41f5191f36242fba26edcab7cdae2ac55f00a60" translate="yes" xml:space="preserve">
          <source>Placeholder comments for structural directives will contain information about what directive and binding caused the placeholder. E.g. &lt;code&gt;&amp;lt;!-- ngIf: shouldShow() --&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">구조적 지시문에 대한 자리 표시 자 주석에는 위치 지정자를 유발 한 지시문 및 바인딩에 대한 정보가 포함됩니다. 예를 들어 &lt;code&gt;&amp;lt;!-- ngIf: shouldShow() --&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d6d23dce11abfc04d22b576b279be0582a4674d8" translate="yes" xml:space="preserve">
          <source>Placeholder comments will contain information about what directive and binding caused the placeholder. E.g. &lt;code&gt;&amp;lt;!-- ngIf: shouldShow() --&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">자리 표시 자 주석에는 자리 표시자를 유발 한 지시문 및 바인딩에 대한 정보가 포함됩니다. 예를 들어 &lt;code&gt;&amp;lt;!-- ngIf: shouldShow() --&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ba144cb01be20139ef167effe8a39441ca2909ab" translate="yes" xml:space="preserve">
          <source>Please keep in mind the points below about AngularJS's expression language.</source>
          <target state="translated">AngularJS의 표현 언어에 대한 아래 사항을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="936d7dabb804fdafdee688afad175b795e535e73" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;as [variable name]&lt;/code&gt; is not an operator but rather a part of ngRepeat micro-syntax so it can be used only after all filters (and not as operator, inside an expression).</source>
          <target state="translated">제발 참고 &lt;code&gt;as [variable name]&lt;/code&gt; 그것이 단지 모든 필터 이후 (및 NOT 연산자로서 표현) 안에 이용 될 수 있도록 조작자 아니라 ngRepeat 마이크로 구문의 일부가 아니다.</target>
        </trans-unit>
        <trans-unit id="8fb457fc228fdb314328599f4f48cd78fc2cb244" translate="yes" xml:space="preserve">
          <source>Please note that `as [variable name] is not an operator but rather a part of ngRepeat micro-syntax so it can be used only after all filters (and not as operator, inside an expression).</source>
          <target state="translated">`[변수 이름]은 연산자가 아니라 ngRepeat 마이크로 구문의 일부이므로 모든 필터 (표현식 내에서 연산자가 아닌) 후에 만 ​​사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5864ee00ebaaffa52efb0e40ba7741e0c1980903" translate="yes" xml:space="preserve">
          <source>Please note that if $http is used then it is important that the server returns a success HTTP response code in order to fulfill the validation and a status level of &lt;code&gt;4xx&lt;/code&gt; in order to reject the validation.</source>
          <target state="translated">$ http를 사용하는 경우 유효성 검사를 수행하기 위해 서버가 성공 HTTP 응답 코드를 반환하고 유효성 검사 를 거부하려면 상태 수준 &lt;code&gt;4xx&lt;/code&gt; 를 반환 해야합니다.</target>
        </trans-unit>
        <trans-unit id="402875a9ef4cbfb33f456a217bbc17d01b959a8a" translate="yes" xml:space="preserve">
          <source>Please note that if these are intended to reach a translator and be translated, it is recommended that the messages appear as a whole and not be split up.</source>
          <target state="translated">번역가에게 전달되고 번역 될 예정이라면 메시지가 전체적으로 표시되고 분할되지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="634d576f91a735237019985afbde7d8d151fc66d" translate="yes" xml:space="preserve">
          <source>Please note that whitespace (including newline) is generally insignificant except as part of the actual message text that occurs in curly braces. Whitespace is generally used to aid readability.</source>
          <target state="translated">중괄호로 나타나는 실제 메시지 텍스트의 일부를 제외하고 공백 (줄 바꾸기 포함)은 일반적으로 중요하지 않습니다. 공백은 일반적으로 가독성을 돕기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ef8776654a5598bd9bf8265ea86a4a13f90f500" translate="yes" xml:space="preserve">
          <source>Plural</source>
          <target state="translated">Plural</target>
        </trans-unit>
        <trans-unit id="be452558ab8a9d90c33c6ce5d76a1fb64db222cf" translate="yes" xml:space="preserve">
          <source>Plural Syntax</source>
          <target state="translated">복수 구문</target>
        </trans-unit>
        <trans-unit id="677291ce1832a3291ebfefdce4206c36b5695d5c" translate="yes" xml:space="preserve">
          <source>Plural and Gender together</source>
          <target state="translated">복수와 성별</target>
        </trans-unit>
        <trans-unit id="30ea53b5f87201afcd442579a963613a5bfcf069" translate="yes" xml:space="preserve">
          <source>Plural categories and explicit number rules</source>
          <target state="translated">복수 카테고리 및 명시 적 숫자 규칙</target>
        </trans-unit>
        <trans-unit id="179566a6a07c07bfd96129c294fa82e9392f11c5" translate="yes" xml:space="preserve">
          <source>Plural category matches are single words corresponding to the &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;plural categories&lt;/a&gt; of the CLDR plural category spec. These categories vary by locale. The &quot;en&quot; (English) locale, for example, defines just &quot;one&quot; and &quot;other&quot; while the &quot;ga&quot; (Irish) locale defines &quot;one&quot;, &quot;two&quot;, &quot;few&quot;, &quot;many&quot; and &quot;other&quot;. Typically, you would just write the categories for your language. During translation, the translators will add or remove more categories depending on the target locale.</source>
          <target state="translated">복수 카테고리 일치는 CLDR 복수 카테고리 스펙 의 &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;복수 카테고리&lt;/a&gt; 에 대응하는 단일 단어 이다. 이 범주는 로케일에 따라 다릅니다. 예를 들어 &quot;en&quot;(영어) 로캘은 &quot;one&quot;과 &quot;other&quot;만 정의하고 &quot;ga&quot;(아일랜드어) 로캘은 &quot;one&quot;, &quot;two&quot;, &quot;wew&quot;, &quot;many&quot;및 &quot;other&quot;를 정의합니다. . 일반적으로 언어의 범주 만 작성하면됩니다. 번역하는 동안 번역 사는 대상 로캘에 따라 더 많은 범주를 추가하거나 제거합니다.</target>
        </trans-unit>
        <trans-unit id="cd288f230e5e528cd142ef52cbb884894ff3ac60" translate="yes" xml:space="preserve">
          <source>Plural syntax with optional offset</source>
          <target state="translated">옵셋 옵션이있는 복수 구문</target>
        </trans-unit>
        <trans-unit id="af1d180211f1fc8c7b2d6c46daa5db30af6e55bc" translate="yes" xml:space="preserve">
          <source>Post-linking function</source>
          <target state="translated">사후 연결 기능</target>
        </trans-unit>
        <trans-unit id="5c90cf7f41a8da16012e1f3fcd7e3e25047730d5" translate="yes" xml:space="preserve">
          <source>Pre-linking function</source>
          <target state="translated">사전 연결 기능</target>
        </trans-unit>
        <trans-unit id="9ec3d53b91c1e1f2ab71a67e94e59a4e5b149247" translate="yes" xml:space="preserve">
          <source>Prefix for hash part (containing path and search)</source>
          <target state="translated">해시 부분의 접두사 (경로 및 검색 포함)</target>
        </trans-unit>
        <trans-unit id="a6966604f1f1b212381bad520d36ae4193da4261" translate="yes" xml:space="preserve">
          <source>Prefix used for Hashbang URLs (used in Hashbang mode or in legacy browsers in HTML5 mode).</source>
          <target state="translated">Hashbang URL에 사용되는 접두사 (Hashbang 모드 또는 HTML5 모드의 레거시 브라우저에서 사용).</target>
        </trans-unit>
        <trans-unit id="60d63afbc58e76c10cdc1e0426f8ae18cd1a3642" translate="yes" xml:space="preserve">
          <source>Pressing an '&lt;code&gt;X&lt;/code&gt;' key causes the browser to emit a &lt;code&gt;keydown&lt;/code&gt; event on the input control.</source>
          <target state="translated">에 '누르면 &lt;code&gt;X&lt;/code&gt; '키 것은 방출 원인 브라우저 &lt;code&gt;keydown&lt;/code&gt; 입력 컨트롤 이벤트.</target>
        </trans-unit>
        <trans-unit id="af8404ddcb19d0ee7bb4e3ada0c8ab29709d3381" translate="yes" xml:space="preserve">
          <source>Preventing collisions with existing animations and third-party libraries</source>
          <target state="translated">기존 애니메이션 및 타사 라이브러리와의 충돌 방지</target>
        </trans-unit>
        <trans-unit id="db2be9312367b0f1226840803e164f31490ec678" translate="yes" xml:space="preserve">
          <source>Preventing flicker before an animation starts</source>
          <target state="translated">애니메이션이 시작되기 전에 깜박임 방지</target>
        </trans-unit>
        <trans-unit id="f11dc6c496b3bea9136c75e36fb573c80908b9bf" translate="yes" xml:space="preserve">
          <source>Previous route information, or undefined if current is first route entered.</source>
          <target state="translated">이전 경로 정보 또는 현재 경로가 처음 입력 된 경우 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c853815d467b47e8ed78315578dd45ccb8c7d2ec" translate="yes" xml:space="preserve">
          <source>Previous route information.</source>
          <target state="translated">이전 경로 정보.</target>
        </trans-unit>
        <trans-unit id="6c2d988f12e64b7e45565826d807a919907ae496" translate="yes" xml:space="preserve">
          <source>Previously compiled HTML will not be affected by newly loaded directives, filters and components.</source>
          <target state="translated">이전에 컴파일 된 HTML은 새로로드 된 지시문, 필터 및 구성 요소의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd339205264cf6840eb650823d064e5a8b67fcfd" translate="yes" xml:space="preserve">
          <source>Previously, we used the &lt;code&gt;link&lt;/code&gt; function to create a directive that manipulated its DOM elements. Building upon that example, let's make a directive that reacts to events on its elements.</source>
          <target state="translated">이전에는 &lt;code&gt;link&lt;/code&gt; 함수를 사용하여 DOM 요소를 조작하는 지시문을 작성했습니다. 이 예를 바탕으로 요소의 이벤트에 반응하는 지시문을 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="c9e51fc63f08ba85c648b29ea8ba3f3e3bb81df0" translate="yes" xml:space="preserve">
          <source>Problems arise when the application is bootstrapped on a different element, and animations are attempted on elements that are outside the application tree, e.g. when libraries append popup or modal elements to the body tag.</source>
          <target state="translated">응용 프로그램이 다른 요소에서 부트 스트랩 될 때 문제가 발생하고 라이브러리가 본문 태그에 팝업 또는 모달 요소를 추가하는 경우와 같이 응용 프로그램 트리 외부에있는 요소에서 애니메이션이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb08e5643a533ad7c05b134e9e747b584dc75f7" translate="yes" xml:space="preserve">
          <source>Process the digest loop as normal</source>
          <target state="translated">정상적으로 다이제스트 루프 처리</target>
        </trans-unit>
        <trans-unit id="3b0fe78c753fdde32ba8bad6bdf5db38803ba21b" translate="yes" xml:space="preserve">
          <source>Processes all of the &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;watchers&lt;/a&gt; of the current scope and its children. Because a &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;watcher&lt;/a&gt;'s listener can change the model, the &lt;code&gt;$digest()&lt;/code&gt; keeps calling the &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;watchers&lt;/a&gt; until no more listeners are firing. This means that it is possible to get into an infinite loop. This function will throw &lt;code&gt;'Maximum iteration limit exceeded.'&lt;/code&gt; if the number of iterations exceeds 10.</source>
          <target state="translated">현재 범위의 모든 &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;감시자&lt;/a&gt; 와 해당 자식을 처리합니다. 때문에 &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;감시자&lt;/a&gt; 의 청취자 모델을 변경할 수 있으며, &lt;code&gt;$digest()&lt;/code&gt; 호출 유지 &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;전문가를&lt;/a&gt; 더 이상 청취자가 발사되지 않을 때까지. 이것은 무한 루프에 들어갈 수 있음을 의미합니다. 이 함수는 &lt;code&gt;'Maximum iteration limit exceeded.'&lt;/code&gt; 반복 횟수가 10을 초과하는 경우</target>
        </trans-unit>
        <trans-unit id="75965b4edaaa41b0b73d45b63157b2b38036c091" translate="yes" xml:space="preserve">
          <source>Professional AngularJS</source>
          <target state="translated">전문 AngularJS</target>
        </trans-unit>
        <trans-unit id="80a2b88f2f6d0fed4bc5bba789ac7b216657a3a4" translate="yes" xml:space="preserve">
          <source>Programmatically changing options</source>
          <target state="translated">프로그래밍 방식으로 옵션 변경</target>
        </trans-unit>
        <trans-unit id="3956d65e997700fbbe6962701c6c46976d9eae6b" translate="yes" xml:space="preserve">
          <source>Promise returned by the &lt;code&gt;$timeout&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;$timeout&lt;/code&gt; 함수에 의해 반환 된 약속 .</target>
        </trans-unit>
        <trans-unit id="8a59aafa09d6e49c77e62ffcdc6d53d10993c4e6" translate="yes" xml:space="preserve">
          <source>Promise that will be resolved when the timeout is reached. The promise will be resolved with the return value of the &lt;code&gt;fn&lt;/code&gt; function.</source>
          <target state="translated">제한 시간에 도달하면 해결 될 약속입니다. 약속은 &lt;code&gt;fn&lt;/code&gt; 함수 의 반환 값으로 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="bc9c3590c4b80616037b44fc342b9db9dab484bc" translate="yes" xml:space="preserve">
          <source>Properties to add to the controller before invoking the constructor. This is used to simulate the &lt;code&gt;bindToController&lt;/code&gt; feature and simplify certain kinds of tests.</source>
          <target state="translated">생성자를 호출하기 전에 컨트롤러에 추가 할 속성입니다. &lt;code&gt;bindToController&lt;/code&gt; 기능 을 시뮬레이션하고 특정 종류의 테스트를 단순화 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8bd5483ecc0eeaa299f08dfff7f347a4fe2fec5" translate="yes" xml:space="preserve">
          <source>Properties to add to the controller instance. This is used to simulate the &lt;code&gt;bindToController&lt;/code&gt; feature and simplify certain kinds of tests.</source>
          <target state="translated">컨트롤러 인스턴스에 추가 할 속성입니다. &lt;code&gt;bindToController&lt;/code&gt; 기능 을 시뮬레이션하고 특정 종류의 테스트를 단순화 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0ec888619fe8d4c92ba83e3a1d78dab13efeb93" translate="yes" xml:space="preserve">
          <source>Property name of the form under which the control is published.</source>
          <target state="translated">컨트롤이 게시되는 폼의 속성 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1e8b2a7060963cf04221774fa7b7b5a02b0e287b" translate="yes" xml:space="preserve">
          <source>Protection from JSON Hijacking is provided if the server prefixes all JSON requests with following string &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt;. AngularJS will automatically strip the prefix before processing it as JSON. For more information please visit &lt;a href=&quot;../api/ng/service/%24http#json-vulnerability-protection.html&quot;&gt;JSON Hijacking Protection&lt;/a&gt;.</source>
          <target state="translated">서버에서 모든 JSON 요청 앞에 다음 문자열 &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt; 하면 JSON 하이재킹으로부터 보호됩니다 . AngularJS는 접두사를 JSON으로 처리하기 전에 자동으로 제거합니다. 자세한 정보는 &lt;a href=&quot;../api/ng/service/%24http#json-vulnerability-protection.html&quot;&gt;JSON 하이재킹 보호&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9390e0ef5f71d138bc596eddbe51b8e38d4521a" translate="yes" xml:space="preserve">
          <source>Protection from XSRF is provided by using the double-submit cookie defense pattern. For more information please visit &lt;a href=&quot;../api/ng/service/%24http#cross-site-request-forgery-xsrf-protection.html&quot;&gt;XSRF protection&lt;/a&gt;.</source>
          <target state="translated">이중 제출 쿠키 방어 패턴을 사용하여 XSRF로부터 보호 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../api/ng/service/%24http#cross-site-request-forgery-xsrf-protection.html&quot;&gt;XSRF 보호&lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="90f86c4a0449e7e5adb2fe6a2e9e1a00e1f16c40" translate="yes" xml:space="preserve">
          <source>Protractor does not work out-of-the-box with apps that bootstrap manually using &lt;code&gt;angular.bootstrap&lt;/code&gt;. You must use the &lt;code&gt;ng-app&lt;/code&gt; directive.</source>
          <target state="translated">각도기는 &lt;code&gt;angular.bootstrap&lt;/code&gt; 을 사용하여 수동으로 부트 스트랩하는 앱에서 기본적 으로 작동하지 않습니다 . &lt;code&gt;ng-app&lt;/code&gt; 지시문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb5d793ecb6593e91414a3b5b89cbf50a0df7252" translate="yes" xml:space="preserve">
          <source>Protractor is a &lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js&lt;/a&gt; program, and runs end-to-end tests that are also written in JavaScript and run with node. Protractor uses &lt;a href=&quot;https://code.google.com/p/selenium/wiki/GettingStarted&quot;&gt;WebDriver&lt;/a&gt; to control browsers and simulate user actions.</source>
          <target state="translated">각도기는 &lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js&lt;/a&gt; 프로그램이며 JavaScript로 작성되고 노드와 함께 실행되는 종단 간 테스트를 실행합니다. 각도기는 &lt;a href=&quot;https://code.google.com/p/selenium/wiki/GettingStarted&quot;&gt;WebDriver&lt;/a&gt; 를 사용 하여 브라우저를 제어하고 사용자 동작을 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="bb3f0ccf64c0877d614e1a06bb00e1452bd032c9" translate="yes" xml:space="preserve">
          <source>Protractor uses &lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html&quot;&gt;Jasmine&lt;/a&gt; for its test syntax. As in unit testing, a test file is comprised of one or more &lt;code&gt;it&lt;/code&gt; blocks that describe the requirements of your application. &lt;code&gt;it&lt;/code&gt; blocks are made of &lt;strong&gt;commands&lt;/strong&gt; and &lt;strong&gt;expectations&lt;/strong&gt;. Commands tell Protractor to do something with the application such as navigate to a page or click on a button. Expectations tell Protractor to assert something about the application's state, such as the value of a field or the current URL.</source>
          <target state="translated">각도기는 테스트 구문으로 &lt;a href=&quot;http://jasmine.github.io/1.3/introduction.html&quot;&gt;Jasmine&lt;/a&gt; 을 사용 합니다. 단위 테스트에서와 마찬가지로, 테스트 파일은 하나 이상의 구성되어 &lt;code&gt;it&lt;/code&gt; 응용 프로그램의 요구 사항에 대해 설명 블록. &lt;code&gt;it&lt;/code&gt; 블록은 만들어진 &lt;strong&gt;명령&lt;/strong&gt; 및 &lt;strong&gt;기대&lt;/strong&gt; . 명령은 페이지로 이동하거나 버튼을 클릭하는 것과 같이 응용 프로그램에서 무언가를 수행하도록 Protractor에 지시합니다. Protractor는 필드 값이나 현재 URL과 같이 응용 프로그램의 상태에 대해 무언가를 주장 할 것을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="7ceee3f3615a2bbe4ce0ac5a269a311e4821daf4" translate="yes" xml:space="preserve">
          <source>Provider</source>
          <target state="translated">Provider</target>
        </trans-unit>
        <trans-unit id="d1ee5ed53bb0014f222cf9a775404d40f04a276f" translate="yes" xml:space="preserve">
          <source>Provider Recipe</source>
          <target state="translated">공급자 레시피</target>
        </trans-unit>
        <trans-unit id="faeb91f343caefcfbfb0f7ef0ebef566e9f808d2" translate="yes" xml:space="preserve">
          <source>Provider components in ng</source>
          <target state="translated">ng의 공급자 구성 요소</target>
        </trans-unit>
        <trans-unit id="aac6643460d97ee9f664d62a35a270349841cf75" translate="yes" xml:space="preserve">
          <source>Provider components in ngAria</source>
          <target state="translated">ngAria의 제공자 구성 요소</target>
        </trans-unit>
        <trans-unit id="3697f23641b772bbaabfc5f9418598d9a7d11a6f" translate="yes" xml:space="preserve">
          <source>Provider components in ngCookies</source>
          <target state="translated">ngCookies의 공급자 구성 요소</target>
        </trans-unit>
        <trans-unit id="607b375320386821b2b91b0abb605d476671a991" translate="yes" xml:space="preserve">
          <source>Provider components in ngMock</source>
          <target state="translated">ngMock의 공급자 구성 요소</target>
        </trans-unit>
        <trans-unit id="27f092cf1e72b65217dc348f8fb9eef609ef0f86" translate="yes" xml:space="preserve">
          <source>Provider components in ngResource</source>
          <target state="translated">ngResource의 제공자 구성 요소</target>
        </trans-unit>
        <trans-unit id="82fa91bef1fcd6b27dcb61546d819b59f500cbf9" translate="yes" xml:space="preserve">
          <source>Provider components in ngRoute</source>
          <target state="translated">ngRoute의 공급자 구성 요소</target>
        </trans-unit>
        <trans-unit id="64e454af2188dee8d60382135ae30ceba7b9fb7b" translate="yes" xml:space="preserve">
          <source>Provider components in ngSanitize</source>
          <target state="translated">ngSanitize의 제공자 구성 요소</target>
        </trans-unit>
        <trans-unit id="0b7f95fe00b27ad60f556fe51d59a14ae33eea20" translate="yes" xml:space="preserve">
          <source>Provider for the $rootScope service.</source>
          <target state="translated">$ rootScope 서비스 제공 업체.</target>
        </trans-unit>
        <trans-unit id="53d2419e2fad27c745ab7837fb34c5b4cb3b5535" translate="yes" xml:space="preserve">
          <source>Provider is the most complex recipe type. You don't need it unless you are building a reusable piece of code that needs global configuration.</source>
          <target state="translated">공급자는 가장 복잡한 레시피 유형입니다. 전역 구성이 필요한 재사용 가능한 코드를 작성하지 않는 한 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87b7c08baed1c8e93db95b79bcdca55b631dd7bb" translate="yes" xml:space="preserve">
          <source>Providers</source>
          <target state="translated">Providers</target>
        </trans-unit>
        <trans-unit id="3c19717766308f184231292bb4ec1e53f9ff7873" translate="yes" xml:space="preserve">
          <source>Provides pre-instantiated services which should append/override services provided by &lt;code&gt;providers&lt;/code&gt;. This is handy when unit-testing and having the need to override a default service.</source>
          <target state="translated">&lt;code&gt;providers&lt;/code&gt; 제공 한 서비스를 추가 / 재정의해야하는 사전 인스턴스화 된 서비스를 제공 합니다. 이는 단위 테스트를 수행하고 기본 서비스를 대체해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8eae5c3fc815670c73fa3a65878af6b41fec633e" translate="yes" xml:space="preserve">
          <source>Provides read/write access to browser's cookies.</source>
          <target state="translated">브라우저 쿠키에 대한 읽기 / 쓰기 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a023f9aad6dc377039a1b87b20af53972b89720" translate="yes" xml:space="preserve">
          <source>Providing locale rules to AngularJS</source>
          <target state="translated">AngularJS에 로케일 규칙 제공</target>
        </trans-unit>
        <trans-unit id="ddd8ad56b330bca54c9be9804edc93d69e2dea69" translate="yes" xml:space="preserve">
          <source>Providing validation behavior (i.e. required, number, email, url).</source>
          <target state="translated">유효성 검사 동작 제공 (예 : 필수, 번호, 전자 메일, URL)</target>
        </trans-unit>
        <trans-unit id="b73be446095cb68833313fd87ebc08cef7cbc028" translate="yes" xml:space="preserve">
          <source>Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains all the important functionality needed for common async tasks.</source>
          <target state="translated">Q에는 $ q보다 많은 기능이 있지만 바이트 비용이 듭니다. $ q는 작지만 일반적인 비동기 작업에 필요한 모든 중요한 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a17b9bb70264b6c8d6ecde29f85b3a88abcad433" translate="yes" xml:space="preserve">
          <source>Query parameters</source>
          <target state="translated">쿼리 매개 변수</target>
        </trans-unit>
        <trans-unit id="6c66d1dc2e56375fe263d76a3be7b856f40b76c8" translate="yes" xml:space="preserve">
          <source>Range Input with ngMin &amp;amp; ngMax attributes</source>
          <target state="translated">ngMin 및 ngMax 속성이있는 범위 입력</target>
        </trans-unit>
        <trans-unit id="aa28402b349eaa855997074022329eee97704df9" translate="yes" xml:space="preserve">
          <source>Raw cookie value.</source>
          <target state="translated">원시 쿠키 값.</target>
        </trans-unit>
        <trans-unit id="1618100fea13078aa76080795808feb6be857d99" translate="yes" xml:space="preserve">
          <source>Raw value to be stored.</source>
          <target state="translated">저장 될 원시 값.</target>
        </trans-unit>
        <trans-unit id="2b86c80b3e4094ce9a3d04d4536abffffbad8e90" translate="yes" xml:space="preserve">
          <source>Read and write custom information about this module. For example you could put the version of the module in here.</source>
          <target state="translated">이 모듈에 대한 사용자 정의 정보를 읽고 씁니다. 예를 들어 여기에 모듈 버전을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d7732dd14cd9ae15d39f4a1ba98522f1578cf57" translate="yes" xml:space="preserve">
          <source>Read more about &lt;a href=&quot;../service/%24sce&quot;&gt;Strict Contextual Escaping (SCE)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../service/%24sce&quot;&gt;SCE (Strict Contextual Escaping)&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="51c8f5fa0bf495bbdab1fb9e3c43c6038a6fa0dc" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../../guide/accessibility&quot;&gt;ngAria Developer Guide&lt;/a&gt; for a thorough explanation of each directive.</source>
          <target state="translated">읽기 &lt;a href=&quot;../../../guide/accessibility&quot;&gt;ngAria 개발자 가이드를&lt;/a&gt; 각 지침의 철저한 설명.</target>
        </trans-unit>
        <trans-unit id="354d2d712f48b41905c006f1295a07a5166ec835" translate="yes" xml:space="preserve">
          <source>Ready to find out more about AngularJS?</source>
          <target state="translated">AngularJS에 대한 자세한 정보가 필요하십니까?</target>
        </trans-unit>
        <trans-unit id="434f7fd2e7fbbeb863bbeb23079429e58d437bae" translate="yes" xml:space="preserve">
          <source>Reasons for using one-time binding</source>
          <target state="translated">일회성 바인딩을 사용하는 이유</target>
        </trans-unit>
        <trans-unit id="c400f997011216a042b977f816c836e8b9842bfe" translate="yes" xml:space="preserve">
          <source>Recommended Setup</source>
          <target state="translated">권장 설정</target>
        </trans-unit>
        <trans-unit id="4a36b4af5afa45bcf158d1716fdc3677a5e0a895" translate="yes" xml:space="preserve">
          <source>Refer &lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;$sceDelegateProvider&lt;/a&gt; for an example.</source>
          <target state="translated">예제는 &lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;$ sceDelegateProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5b195da530d0efe734a7d53c8b68080b3cc3c7f" translate="yes" xml:space="preserve">
          <source>Refer &lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;$sceDelegateProvider&lt;/a&gt; to configure this service.</source>
          <target state="translated">이 서비스를 구성하려면 &lt;a href=&quot;../provider/%24scedelegateprovider&quot;&gt;$ sceDelegateProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b627a0fb853040d3e0434dbbefd5809d93b210f" translate="yes" xml:space="preserve">
          <source>Reference to &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">을 참조 &lt;code&gt;dst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd87679cf893a1dd2dca79c61d0e9d748b5026f" translate="yes" xml:space="preserve">
          <source>Reference to &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">을 참조 &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b671addffac0b2e853bfb7228e292c171a7d6ed5" translate="yes" xml:space="preserve">
          <source>Reference to check.</source>
          <target state="translated">확인 참조.</target>
        </trans-unit>
        <trans-unit id="3b633a4c1143db3741cc3f064fe12f9828a781e6" translate="yes" xml:space="preserve">
          <source>Reference to the current route definition. The route definition contains:</source>
          <target state="translated">현재 경로 정의에 대한 참조 경로 정의에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bb91dbe53666db180aa57161eb36d124fa150320" translate="yes" xml:space="preserve">
          <source>Reference to the parent scope.</source>
          <target state="translated">부모 범위에 대한 참조</target>
        </trans-unit>
        <trans-unit id="bed990515ae3cd84556c4d6208760d018bf3b353" translate="yes" xml:space="preserve">
          <source>Reference to the root scope.</source>
          <target state="translated">루트 범위에 대한 참조</target>
        </trans-unit>
        <trans-unit id="b8d49172c668642e2f62c37bc331faa62a3e1ab5" translate="yes" xml:space="preserve">
          <source>Regex parameter matching</source>
          <target state="translated">정규식 매개 변수 일치</target>
        </trans-unit>
        <trans-unit id="fc0504148c30c6097df7cfb4174da0f1a4cbd9e0" translate="yes" xml:space="preserve">
          <source>Register a &lt;strong&gt;component definition&lt;/strong&gt; with the compiler. This is a shorthand for registering a special type of directive, which represents a self-contained UI component in your application. Such components are always isolated (i.e. &lt;code&gt;scope: {}&lt;/code&gt;) and are always restricted to elements (i.e. &lt;code&gt;restrict: 'E'&lt;/code&gt;).</source>
          <target state="translated">컴파일러에 &lt;strong&gt;컴포넌트 정의&lt;/strong&gt; 를 등록하십시오 . 이것은 애플리케이션에서 자체 포함 된 UI 구성 요소를 나타내는 특수 유형의 지시문을 등록하기위한 약칭입니다. 이러한 컴포넌트는 항상 분리되어 있고 (예 : &lt;code&gt;scope: {}&lt;/code&gt; ) 항상 요소 (예 &lt;code&gt;restrict: 'E'&lt;/code&gt; )로 제한 됩니다.</target>
        </trans-unit>
        <trans-unit id="e65f3ece273368fd8433f2cdcda7c960e1f6572d" translate="yes" xml:space="preserve">
          <source>Register a &lt;strong&gt;constant service&lt;/strong&gt; with the &lt;a href=&quot;%24injector&quot;&gt;$injector&lt;/a&gt;, such as a string, a number, an array, an object or a function. Like the &lt;a href=&quot;%24provide#value.html&quot;&gt;value&lt;/a&gt;, it is not possible to inject other services into a constant.</source>
          <target state="translated">문자열, 숫자, 배열, 객체 또는 함수와 같은 &lt;strong&gt;상수 서비스&lt;/strong&gt; 를 &lt;a href=&quot;%24injector&quot;&gt;$ injector에&lt;/a&gt; 등록하십시오 . &lt;a href=&quot;%24provide#value.html&quot;&gt;value&lt;/a&gt; 와 마찬가지로 다른 서비스를 상수에 주입 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="45524c2eb035d8e9328d31f7bed278f90e7c83fc" translate="yes" xml:space="preserve">
          <source>Register a &lt;strong&gt;decorator function&lt;/strong&gt; with the &lt;a href=&quot;%24injector&quot;&gt;$injector&lt;/a&gt;. A decorator function intercepts the creation of a service, allowing it to override or modify the behavior of the service. The return value of the decorator function may be the original service, or a new service that replaces (or wraps and delegates to) the original service.</source>
          <target state="translated">&lt;a href=&quot;%24injector&quot;&gt;$ injector에 &lt;/a&gt;&lt;strong&gt;데코레이터 기능&lt;/strong&gt; 을 등록하십시오 . 데코레이터 기능은 서비스 생성을 가로 채서 서비스 동작을 재정의하거나 수정할 수 있습니다. 데코레이터 함수의 반환 값은 원래 서비스이거나 원래 서비스를 대체 (또는 랩핑하고 위임)하는 새로운 서비스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea020b086a634153190597650e70f48a24258953" translate="yes" xml:space="preserve">
          <source>Register a &lt;strong&gt;provider function&lt;/strong&gt; with the &lt;a href=&quot;%24injector&quot;&gt;$injector&lt;/a&gt;. Provider functions are constructor functions, whose instances are responsible for &quot;providing&quot; a factory for a service.</source>
          <target state="translated">&lt;a href=&quot;%24injector&quot;&gt;$ injector에 &lt;/a&gt;&lt;strong&gt;제공자 기능&lt;/strong&gt; 을 등록하십시오 . 프로 바이더 함수는 생성자 함수이며, 인스턴스는 서비스 팩토리를 &quot;제공&quot;하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="45783c066e03d8c03ea0efb06a359bae85613169" translate="yes" xml:space="preserve">
          <source>Register a &lt;strong&gt;service constructor&lt;/strong&gt;, which will be invoked with &lt;code&gt;new&lt;/code&gt; to create the service instance. This is short for registering a service where its provider's &lt;code&gt;$get&lt;/code&gt; property is a factory function that returns an instance instantiated by the injector from the service constructor function.</source>
          <target state="translated">&lt;strong&gt;서비스 생성자를&lt;/strong&gt; 등록하십시오. &lt;strong&gt;서비스 생성자&lt;/strong&gt; 는 &lt;code&gt;new&lt;/code&gt; 로 호출되어 서비스 인스턴스를 작성합니다. 공급자의 &lt;code&gt;$get&lt;/code&gt; 속성이 인젝터가 인스턴스화 한 인스턴스를 서비스 생성자 함수에서 반환하는 팩토리 함수 인 서비스를 등록하기에 짧습니다 .</target>
        </trans-unit>
        <trans-unit id="eed2257ce18cce4c83839c3ad49253c60a762e9c" translate="yes" xml:space="preserve">
          <source>Register a &lt;strong&gt;service factory&lt;/strong&gt;, which will be called to return the service instance. This is short for registering a service where its provider consists of only a &lt;code&gt;$get&lt;/code&gt; property, which is the given service factory function. You should use &lt;a href=&quot;%24provide#factory.html&quot;&gt;$provide.factory(getFn)&lt;/a&gt; if you do not need to configure your service in a provider.</source>
          <target state="translated">&lt;strong&gt;서비스 팩토리를&lt;/strong&gt; 등록하십시오. &lt;strong&gt;서비스 팩토리&lt;/strong&gt; 는 서비스 인스턴스를 리턴하기 위해 호출됩니다. 이것은 공급자가 &lt;code&gt;$get&lt;/code&gt; 속성 으로 만 구성된 서비스를 등록하기위한 약식이며 , 이는 지정된 서비스 팩토리 기능입니다. 당신은 사용해야 &lt;a href=&quot;%24provide#factory.html&quot;&gt;$ provide.factory (getFn을)&lt;/a&gt; 당신이 공급자의 서비스를 구성 할 필요가없는 경우.</target>
        </trans-unit>
        <trans-unit id="635024287d83106675ce8f580b6af894b0ca524f" translate="yes" xml:space="preserve">
          <source>Register a &lt;strong&gt;value service&lt;/strong&gt; with the &lt;a href=&quot;%24injector&quot;&gt;$injector&lt;/a&gt;, such as a string, a number, an array, an object or a function. This is short for registering a service where its provider's &lt;code&gt;$get&lt;/code&gt; property is a factory function that takes no arguments and returns the &lt;strong&gt;value service&lt;/strong&gt;. That also means it is not possible to inject other services into a value service.</source>
          <target state="translated">문자열, 숫자, 배열, 객체 또는 함수와 같은 &lt;strong&gt;값 서비스&lt;/strong&gt; 를 &lt;a href=&quot;%24injector&quot;&gt;$ injector에&lt;/a&gt; 등록하십시오 . 프로 바이더의 &lt;code&gt;$get&lt;/code&gt; 속성이 인수를 취하지 않고 &lt;strong&gt;service 값을&lt;/strong&gt; 반환하는 팩토리 함수 인 서비스를 등록하기에 짧습니다 . 이는 다른 서비스를 가치 서비스에 주입 할 수 없다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b87eb97a1c3c8baad3cdae5ff8ff853d06484051" translate="yes" xml:space="preserve">
          <source>Register a control with the form. Input elements using ngModelController do this automatically when they are linked.</source>
          <target state="translated">폼으로 컨트롤을 등록하십시오. ngModelController를 사용하는 입력 요소는 링크 될 때이를 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="eb48cfa4c810ae8c4bb96fcfdc6c3eb349e97e1e" translate="yes" xml:space="preserve">
          <source>Register a new directive with the compiler.</source>
          <target state="translated">컴파일러에 새 지시문을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="d51fd0243e0e86d898e850537c07b7bc17d03dc4" translate="yes" xml:space="preserve">
          <source>Registered filter instance, or if a map of filters was provided then a map of the registered filter instances.</source>
          <target state="translated">등록 된 필터 인스턴스 또는 필터 맵이 제공된 경우 등록 된 필터 인스턴스의 맵입니다.</target>
        </trans-unit>
        <trans-unit id="e34c75266465d4da9d7310c64a01438305b252b5" translate="yes" xml:space="preserve">
          <source>Registering Services</source>
          <target state="translated">서비스 등록</target>
        </trans-unit>
        <trans-unit id="d1260ea7fdb8f8f1a5f99c1e31524881fab210aa" translate="yes" xml:space="preserve">
          <source>Registering a Service with $provide</source>
          <target state="translated">$ provide로 서비스 등록</target>
        </trans-unit>
        <trans-unit id="48d1928dfaff8d1fc38b25397535b4cf15cf8700" translate="yes" xml:space="preserve">
          <source>Registering the control with its parent &lt;a href=&quot;form&quot;&gt;form&lt;/a&gt;.</source>
          <target state="translated">부모와 제어 등록 &lt;a href=&quot;form&quot;&gt;양식을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3b34d6f14031683c49fcb0996fc9a2287467ec" translate="yes" xml:space="preserve">
          <source>Registers a &lt;code&gt;listener&lt;/code&gt; callback to be executed whenever the &lt;code&gt;watchExpression&lt;/code&gt; changes.</source>
          <target state="translated">&lt;code&gt;watchExpression&lt;/code&gt; 이 변경 될 때마다 실행될 &lt;code&gt;listener&lt;/code&gt; 콜백을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="e755ff9b4f19ef2d1c7dc5cbea80131344b000f0" translate="yes" xml:space="preserve">
          <source>Registers a new injectable animation factory function. The factory function produces the animation object which contains callback functions for each event that is expected to be animated.</source>
          <target state="translated">새로운 인젝터 블 애니메이션 팩토리 기능을 등록합니다. 팩토리 함수는 애니메이션 될 것으로 예상되는 각 이벤트에 대한 콜백 함수를 포함하는 애니메이션 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="40aec920014d2862cafad66b448612b687f31308" translate="yes" xml:space="preserve">
          <source>Registration in the config block</source>
          <target state="translated">설정 블록에 등록</target>
        </trans-unit>
        <trans-unit id="98fdd77196db1b5bf3eb22caffc45a13dfad7a74" translate="yes" xml:space="preserve">
          <source>Related API</source>
          <target state="translated">관련 API</target>
        </trans-unit>
        <trans-unit id="cfbc9e10239e3aa2884b26233bd2772c8b87a636" translate="yes" xml:space="preserve">
          <source>Related Topics</source>
          <target state="translated">관련 주제</target>
        </trans-unit>
        <trans-unit id="8f7bfe2a8726123d4d57d9e3cb41a80d80eefbfc" translate="yes" xml:space="preserve">
          <source>Relative links</source>
          <target state="translated">상대 링크</target>
        </trans-unit>
        <trans-unit id="98eb2443ddb19e4af9222b182551b238c57fffed" translate="yes" xml:space="preserve">
          <source>Relative or absolute URL specifying the destination of the request</source>
          <target state="translated">요청의 목적지를 지정하는 상대 또는 절대 URL</target>
        </trans-unit>
        <trans-unit id="e6e7b36b90301e1149d1fd8dbda9f15e4b6881b3" translate="yes" xml:space="preserve">
          <source>Remove given cookie</source>
          <target state="translated">주어진 쿠키를 제거</target>
        </trans-unit>
        <trans-unit id="ee2741c4b98105f982c53a03fff032d207b158a9" translate="yes" xml:space="preserve">
          <source>Removes an entry from the &lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; 객체 에서 항목을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="8920f5ca9f0566bd4a9f1e7b0ee0099b999aa651" translate="yes" xml:space="preserve">
          <source>Removes the CSS class value specified by the classVal parameter from the element. If animations are enabled then an animation will be triggered for the class removal.</source>
          <target state="translated">요소에서 classVal 매개 변수로 지정된 CSS 클래스 값을 제거합니다. 애니메이션이 활성화되면 클래스 제거를 위해 애니메이션이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="04b5e728a8d34f70ce59d4ce19242f609cb92274" translate="yes" xml:space="preserve">
          <source>Removes the current scope (and all of its children) from the parent scope. Removal implies that calls to &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest()&lt;/a&gt; will no longer propagate to the current scope and its children. Removal also implies that the current scope is eligible for garbage collection.</source>
          <target state="translated">부모 범위에서 현재 범위 및 모든 해당 자식을 제거합니다. 제거는 &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ digest ()&lt;/a&gt; 호출 이 더 이상 현재 범위와 해당 자식으로 전파되지 않음 을 의미합니다 . 제거는 또한 현재 범위가 가비지 콜렉션에 적합하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f5cfe4b8875850cebab31b8ae5ebdb0f01a98015" translate="yes" xml:space="preserve">
          <source>Replace method</source>
          <target state="translated">방법 교체</target>
        </trans-unit>
        <trans-unit id="abed80d59c3cc2cdfd2934eac8defa722471a0e8" translate="yes" xml:space="preserve">
          <source>Replace or decorate this service to create your own custom XMLHttpRequest objects.</source>
          <target state="translated">이 서비스를 바꾸거나 장식하여 사용자 정의 XMLHttpRequest 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7fdab89988ce8fbbc75820a42b26b98ef91641e9" translate="yes" xml:space="preserve">
          <source>Replace the contents of the directive's element (default).</source>
          <target state="translated">지시문 요소의 내용을 바꾸십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="8d8db9b8f187119d598467a295084104278dca63" translate="yes" xml:space="preserve">
          <source>Replace the directive's element itself (if &lt;code&gt;replace&lt;/code&gt; is true - DEPRECATED).</source>
          <target state="translated">지시문의 요소 자체를 교체하십시오 ( &lt;code&gt;replace&lt;/code&gt; 가 true 인 경우 DEPRECATED).</target>
        </trans-unit>
        <trans-unit id="1b74ba244acc5851ea1e932d4c6f319a815eeff5" translate="yes" xml:space="preserve">
          <source>Reporting a security issue</source>
          <target state="translated">보안 문제보고</target>
        </trans-unit>
        <trans-unit id="c922eca42e3d5120a6bfc72bcad1d30519cb4e28" translate="yes" xml:space="preserve">
          <source>Represents the URL object as a set of methods (protocol, host, port, path, search, hash).</source>
          <target state="translated">URL 객체를 일련의 메소드 (프로토콜, 호스트, 포트, 경로, 검색, 해시)로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44275cc926494215c0dd8c311f508c08138ab44c" translate="yes" xml:space="preserve">
          <source>Request Expectations vs Backend Definitions</source>
          <target state="translated">요청 예상 및 백엔드 정의</target>
        </trans-unit>
        <trans-unit id="fb7dc677c72c08388ac26aa5b3b8bf37f74b4a0b" translate="yes" xml:space="preserve">
          <source>Request content</source>
          <target state="translated">콘텐츠 요청</target>
        </trans-unit>
        <trans-unit id="4e9c03db567af687cbcde897eb8e4e49684606e8" translate="yes" xml:space="preserve">
          <source>Request expectations</source>
          <target state="translated">기대 요청</target>
        </trans-unit>
        <trans-unit id="7c76d91bc3fe714b2e19d415024bc0ce817ca932" translate="yes" xml:space="preserve">
          <source>Request expectations provide a way to make assertions about requests made by the application and to define responses for those requests. The test will fail if the expected requests are not made or they are made in the wrong order.</source>
          <target state="translated">요청 기대는 응용 프로그램의 요청에 대한 어설 션을 만들고 해당 요청에 대한 응답을 정의하는 방법을 제공합니다. 예상되는 요청이 없거나 잘못된 순서로 요청되면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c3d3aaf0c7d684713b0e633e09eb2de9d118d464" translate="yes" xml:space="preserve">
          <source>Request required</source>
          <target state="translated">필요한 요청</target>
        </trans-unit>
        <trans-unit id="2ef4b562f29645c2c4f2482326315042cb223eaa" translate="yes" xml:space="preserve">
          <source>Request transformations (&lt;code&gt;$httpProvider.defaults.transformRequest&lt;/code&gt; and &lt;code&gt;$http.defaults.transformRequest&lt;/code&gt;) is an array with one function that does the following:</source>
          <target state="translated">요청 변환 ( &lt;code&gt;$httpProvider.defaults.transformRequest&lt;/code&gt; 및 &lt;code&gt;$http.defaults.transformRequest&lt;/code&gt; )은 다음을 수행하는 하나의 함수가있는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="90f650d7162ff6af24a4492b8baa19c6caca946c" translate="yes" xml:space="preserve">
          <source>Require another directive and inject its controller as the fourth argument to the linking function. The &lt;code&gt;require&lt;/code&gt; property can be a string, an array or an object:</source>
          <target state="translated">다른 지시어가 필요하고 컨트롤러를 연결 함수의 네 번째 인수로 삽입하십시오. &lt;code&gt;require&lt;/code&gt; 속성은 문자열 배열이나 객체가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e1d5e0b06dfa562e69981647c63bd3b86e664409" translate="yes" xml:space="preserve">
          <source>Requires the &lt;a href=&quot;../../ngaria&quot;&gt;&lt;code&gt;ngAria&lt;/code&gt;&lt;/a&gt; module to be installed.</source>
          <target state="translated">필요 &lt;a href=&quot;../../ngaria&quot;&gt; &lt;code&gt;ngAria&lt;/code&gt; 에&lt;/a&gt; 설치 될 모듈을.</target>
        </trans-unit>
        <trans-unit id="7ec0099c504303c4c9c48e96dc4609ad55904f4a" translate="yes" xml:space="preserve">
          <source>Requires the &lt;a href=&quot;../../ngcookies&quot;&gt;&lt;code&gt;ngCookies&lt;/code&gt;&lt;/a&gt; module to be installed.</source>
          <target state="translated">필요 &lt;a href=&quot;../../ngcookies&quot;&gt; &lt;code&gt;ngCookies&lt;/code&gt; 가&lt;/a&gt; 설치되는 모듈.</target>
        </trans-unit>
        <trans-unit id="c5862a5cb0ec6abe952c905b15a9f3429f373234" translate="yes" xml:space="preserve">
          <source>Requires the &lt;a href=&quot;../../ngresource&quot;&gt;&lt;code&gt;ngResource&lt;/code&gt;&lt;/a&gt; module to be installed.</source>
          <target state="translated">필요 &lt;a href=&quot;../../ngresource&quot;&gt; &lt;code&gt;ngResource&lt;/code&gt; 에&lt;/a&gt; 설치 될 모듈을.</target>
        </trans-unit>
        <trans-unit id="928e58682d0c86f23af73ec08890f10c14e4c472" translate="yes" xml:space="preserve">
          <source>Requires the &lt;a href=&quot;../../ngroute&quot;&gt;&lt;code&gt;ngRoute&lt;/code&gt;&lt;/a&gt; module to be installed.</source>
          <target state="translated">필요 &lt;a href=&quot;../../ngroute&quot;&gt; &lt;code&gt;ngRoute&lt;/code&gt; 에&lt;/a&gt; 설치 될 모듈을.</target>
        </trans-unit>
        <trans-unit id="537fea66db726eae9da189c87f27644f84ba9348" translate="yes" xml:space="preserve">
          <source>Requires the &lt;a href=&quot;../../ngsanitize&quot;&gt;&lt;code&gt;ngSanitize&lt;/code&gt;&lt;/a&gt; module to be installed.</source>
          <target state="translated">필요 &lt;a href=&quot;../../ngsanitize&quot;&gt; &lt;code&gt;ngSanitize&lt;/code&gt; 에&lt;/a&gt; 설치 될 모듈을.</target>
        </trans-unit>
        <trans-unit id="1a11c4501de6ba56e5400e26238d9a6bec494d4b" translate="yes" xml:space="preserve">
          <source>Requires the &lt;a href=&quot;../../ngtouch&quot;&gt;&lt;code&gt;ngTouch&lt;/code&gt;&lt;/a&gt; module to be installed.</source>
          <target state="translated">필요 &lt;a href=&quot;../../ngtouch&quot;&gt; &lt;code&gt;ngTouch&lt;/code&gt; 에&lt;/a&gt; 설치 될 모듈을.</target>
        </trans-unit>
        <trans-unit id="4dc1287fe5b5d1c6b627f7a7a956e26221d21611" translate="yes" xml:space="preserve">
          <source>Reset all of the logging arrays to empty.</source>
          <target state="translated">모든 로깅 배열을 비우십시오.</target>
        </trans-unit>
        <trans-unit id="2b0b4d40965cbdcf2bc7f1639bd05a9faab1c19d" translate="yes" xml:space="preserve">
          <source>Resets all request expectations, but preserves all backend definitions. Typically, you would call resetExpectations during a multiple-phase test when you want to reuse the same instance of $httpBackend mock.</source>
          <target state="translated">모든 요청 예상을 재설정하지만 모든 백엔드 정의는 유지합니다. 일반적으로 동일한 $ httpBackend mock 인스턴스를 재사용하려는 경우 다단계 테스트 중에 resetExpectations를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9b1627a90ba7fe159014541f613675e06126b296" translate="yes" xml:space="preserve">
          <source>Resolved promises, e.g. from explicit &lt;code&gt;$q&lt;/code&gt; deferreds and &lt;code&gt;$http&lt;/code&gt; calls, trigger &lt;code&gt;$apply()&lt;/code&gt; against the &lt;code&gt;$rootScope&lt;/code&gt; and so will still trigger a global digest even if the promise was initiated by a component that lives on a suspended scope.</source>
          <target state="translated">해결 된 약속 (예 : 명시 적 &lt;code&gt;$q&lt;/code&gt; 지연 및 &lt;code&gt;$http&lt;/code&gt; 호출 &lt;code&gt;$apply()&lt;/code&gt; 은 &lt;code&gt;$rootScope&lt;/code&gt; 에 대해 $ apply () 를 트리거하므로 일시 중단 된 범위에있는 구성 요소에 의해 약속이 시작된 경우에도 여전히 전역 요약을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="5171c896616adb2c3ae9357c2a11116e0ab2aa7b" translate="yes" xml:space="preserve">
          <source>Resolving References (Underscore Wrapping)</source>
          <target state="translated">참조 해결 (밑줄 감싸기)</target>
        </trans-unit>
        <trans-unit id="1fdbddda0698a34f465a4a76d405fca85c2bc495" translate="yes" xml:space="preserve">
          <source>Response required</source>
          <target state="translated">필요한 답변</target>
        </trans-unit>
        <trans-unit id="4279f5f3a3f43e3e9697fcb9701f9133954216d8" translate="yes" xml:space="preserve">
          <source>Response transformations (&lt;code&gt;$httpProvider.defaults.transformResponse&lt;/code&gt; and &lt;code&gt;$http.defaults.transformResponse&lt;/code&gt;) is an array with one function that does the following:</source>
          <target state="translated">응답 변환 ( &lt;code&gt;$httpProvider.defaults.transformResponse&lt;/code&gt; 및 &lt;code&gt;$http.defaults.transformResponse&lt;/code&gt; )은 다음을 수행하는 하나의 함수가있는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="34f624389800f45b8f738aae8d6df1ee633e353c" translate="yes" xml:space="preserve">
          <source>Restores the pre-1.8 behavior of jqLite that turns XHTML-like strings like &lt;code&gt;&amp;lt;div /&amp;gt;&amp;lt;span /&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;. The new behavior is a security fix. Thus, if you need to call this function, please try to adjust your code for this change and remove your use of this function as soon as possible.</source>
          <target state="translated">같은 문자열 형 XHTML 변 jqLite의 사전 1.8 거동 회복 &lt;code&gt;&amp;lt;div /&amp;gt;&amp;lt;span /&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt; 대신 &lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; . 새로운 동작은 보안 수정입니다. 따라서이 함수를 호출해야하는 경우이 변경에 맞게 코드를 조정하고 가능한 한 빨리이 함수의 사용을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="71af08d07b3e60fd452cd1d0a14b65208dec62a8" translate="yes" xml:space="preserve">
          <source>Resume watchers of this scope subtree in case it was suspended.</source>
          <target state="translated">이 범위 하위 트리의 감시자가 일시 중단 된 경우 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c3cc9b89d7252c496c37f0adc038b1ff7352e328" translate="yes" xml:space="preserve">
          <source>Retrieve information regarding a particular &lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt;.</source>
          <target state="translated">특정 &lt;a href=&quot;%24cachefactory.cache&quot;&gt;캐시&lt;/a&gt; 에 관한 정보를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="029ee2c69a33b0a01589d3072b7fe14eb14fae75" translate="yes" xml:space="preserve">
          <source>Retrieves named data stored in the &lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; 객체에 저장된 명명 된 데이터를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="8171a153e7113cb47d5271b3cbb42b84ff913e5a" translate="yes" xml:space="preserve">
          <source>Retrieves or overrides the default regular expression that is used for determining trusted safe urls during a[href] sanitization.</source>
          <target state="translated">[href] 삭제 중에 신뢰할 수있는 안전한 URL을 결정하는 데 사용되는 기본 정규식을 검색하거나 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="d82de9afda7c8c459229787af42476d98ee66468" translate="yes" xml:space="preserve">
          <source>Retrieves or overrides the default regular expression that is used for determining trusted safe urls during img[src] sanitization.</source>
          <target state="translated">img [src] 삭제 중에 신뢰할 수있는 안전한 URL을 결정하는 데 사용되는 기본 정규식을 검색하거나 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="b79d873410e3c147f2393994b51801ea7b9e7971" translate="yes" xml:space="preserve">
          <source>Retrieves or overrides the default regular expression that is used for whitelisting of safe urls during a[href] sanitization.</source>
          <target state="translated">위생 처리 중에 안전한 URL을 허용 목록에 사용하는 기본 정규식을 검색하거나 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="0f87729394a5fbe13e20ab17fd7dfea291758f33" translate="yes" xml:space="preserve">
          <source>Retrieves or overrides the default regular expression that is used for whitelisting of safe urls during img[src] sanitization.</source>
          <target state="translated">img [src] 위생 처리 중 안전한 URL을 허용 목록에 사용하는 기본 정규식을 검색하거나 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="56c2ae0bea288f2deb96af027ca9db1c1e0b88dc" translate="yes" xml:space="preserve">
          <source>Retrieves or overrides whether to generate an error when a rejected promise is not handled. This feature is enabled by default.</source>
          <target state="translated">거부 된 약속이 처리되지 않은 경우 오류를 생성할지 여부를 검색하거나 재정의합니다. 이 기능은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c185b622ce0745aa94f9eb7657d6eb237ec2b1fa" translate="yes" xml:space="preserve">
          <source>Retrieving Scopes from the DOM.</source>
          <target state="translated">DOM에서 범위 검색</target>
        </trans-unit>
        <trans-unit id="b94fccf633ef32d6a7adbbcb71ca77e3795f319f" translate="yes" xml:space="preserve">
          <source>Return URL (e.g. &lt;code&gt;/path?a=b#hash&lt;/code&gt;) when called without any parameter.</source>
          <target state="translated">매개 변수없이 호출되면 URL (예 : &lt;code&gt;/path?a=b#hash&lt;/code&gt; )을 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="140d46868b4d533c15312ce7397910001cda166b" translate="yes" xml:space="preserve">
          <source>Return an instance of the service.</source>
          <target state="translated">서비스 인스턴스를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="52c77045e19f27ad9c42170b240a88aba2880086" translate="yes" xml:space="preserve">
          <source>Return full URL representation with all segments encoded according to rules specified in &lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986에&lt;/a&gt; 지정된 규칙에 따라 인코딩 된 모든 세그먼트와 함께 전체 URL 표시를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="a84b48c4bccbb0cc57fe52888fad2de77796bd94" translate="yes" xml:space="preserve">
          <source>Return host of current URL.</source>
          <target state="translated">현재 URL의 호스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9571c514202bc742683b59fda7b96fff7838c64" translate="yes" xml:space="preserve">
          <source>Return path of current URL when called without any parameter.</source>
          <target state="translated">매개 변수없이 호출 될 때 현재 URL의 경로를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1fa7a4a66728b565c4e07673c76f2345202fcefb" translate="yes" xml:space="preserve">
          <source>Return port of current URL.</source>
          <target state="translated">현재 URL의 반환 포트.</target>
        </trans-unit>
        <trans-unit id="1d7c6f2975be06cdce751120c8ce17812edf9714" translate="yes" xml:space="preserve">
          <source>Return protocol of current URL.</source>
          <target state="translated">현재 URL의 프로토콜을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18b8fbc14549d13332fe634d60cd64acc7bbf234" translate="yes" xml:space="preserve">
          <source>Return search part (as object) of current URL when called without any parameter.</source>
          <target state="translated">매개 변수없이 호출되면 현재 URL의 검색 부분 (객체)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e2043f80bfdb23de9427764cc68baf2ef7904c2" translate="yes" xml:space="preserve">
          <source>Return the history state object when called without any parameter.</source>
          <target state="translated">매개 변수없이 호출되면 기록 상태 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="110ff013828ec54e25bfc2b37603def46e139ae4" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;undefined&lt;/code&gt; from a parser means a parse error occurred. In that case, no &lt;a href=&quot;ngmodel.ngmodelcontroller#%24validators.html&quot;&gt;&lt;code&gt;$validators&lt;/code&gt;&lt;/a&gt; will run and the &lt;code&gt;ngModel&lt;/code&gt; will be set to &lt;code&gt;undefined&lt;/code&gt; unless &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions.allowInvalid&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;true&lt;/code&gt;. The parse error is stored in &lt;code&gt;ngModel.$error.parse&lt;/code&gt;.</source>
          <target state="translated">파서에서 &lt;code&gt;undefined&lt;/code&gt; 를 반환 하면 파싱 오류가 발생했음을 의미합니다. 이 경우에는 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24validators.html&quot;&gt; &lt;code&gt;$validators&lt;/code&gt; &lt;/a&gt; 실행되지되고 &lt;code&gt;ngModel&lt;/code&gt; 이 설정됩니다 &lt;code&gt;undefined&lt;/code&gt; 않는 한 &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions.allowInvalid&lt;/code&gt; 가&lt;/a&gt; 설정되어 &lt;code&gt;true&lt;/code&gt; . 구문 분석 오류는 &lt;code&gt;ngModel.$error.parse&lt;/code&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="6322592f617b52f15e691f0664eb67413ed6b4d9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the select element currently has an empty option element, i.e. an option that signifies that the select is empty / the selection is null.</source>
          <target state="translated">select 요소에 현재 빈 옵션 요소가있는 경우 (예 : select가 비어 있음 / 선택이 null임을 나타내는 옵션) &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2be820c292c48c220766945900a106842fe92493" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the select element has an empty option and this empty option is currently selected. Returns &lt;code&gt;false&lt;/code&gt; if the select element has no empty option or it is not selected.</source>
          <target state="translated">select 요소에 빈 옵션이 있고이 빈 옵션이 현재 선택된 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . select 요소에 빈 옵션이 없거나 선택하지 않은 경우 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="84bd2e384f903fbc16707ec0fe6ebfd47faeb625" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the select element's unknown option is selected. The unknown option is added and automatically selected whenever the select model doesn't match any option.</source>
          <target state="translated">요소 선택의 알 수없는 옵션이 선택된 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 알 수없는 옵션이 추가되어 선택 모델이 옵션과 일치하지 않을 때마다 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="181f1c7690856bcb7fcf6731a0fb5201a6ccccc9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the task hasn't executed yet and was successfully canceled.</source>
          <target state="translated">작업이 아직 실행되지 않아 성공적으로 취소 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="96717e8f9258537bda3c42a8756552de8cced4c1" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the task was successfully canceled.</source>
          <target state="translated">작업이 성공적으로 취소 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="867a62db9c23f0997b39841b28f2e59ddad2bb16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the task was successfully cancelled.</source>
          <target state="translated">작업이 성공적으로 취소 된 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="15f8467fdef401d96fd8e32cecf9dae076fe71cc" translate="yes" xml:space="preserve">
          <source>Returns a boolean indicating if SCE is enabled.</source>
          <target state="translated">SCE가 사용 가능한지 여부를 나타내는 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6a4b36d75da9780449e67995a0c9d8f2357adca9" translate="yes" xml:space="preserve">
          <source>Returns a de-registration function for all listeners.</source>
          <target state="translated">모든 리스너에 대한 등록 취소 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3199c479081525ca17de9a88b742996c4d4425b" translate="yes" xml:space="preserve">
          <source>Returns a de-registration function for this listener. When the de-registration function is executed, the internal watch operation is terminated.</source>
          <target state="translated">이 청취자의 등록 해제 기능을 돌려줍니다. 등록 해제 기능이 실행되면 내부 감시 작업이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="da8b706e428495422b325816f68f7d9fb0924119" translate="yes" xml:space="preserve">
          <source>Returns a deregistration function for this listener.</source>
          <target state="translated">이 청취자의 등록 해제 기능을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="a62e22e5f831bc88dd6a0a893e8a44c0774a1e17" translate="yes" xml:space="preserve">
          <source>Returns a deregistration function for this observer.</source>
          <target state="translated">이 옵저버의 등록 해제 함수를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="70a6eca6b0045b166ed0f2aa0ff409c9e7abdd47" translate="yes" xml:space="preserve">
          <source>Returns a function which calls function &lt;code&gt;fn&lt;/code&gt; bound to &lt;code&gt;self&lt;/code&gt; (&lt;code&gt;self&lt;/code&gt; becomes the &lt;code&gt;this&lt;/code&gt; for &lt;code&gt;fn&lt;/code&gt;). You can supply optional &lt;code&gt;args&lt;/code&gt; that are prebound to the function. This feature is also known as &lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial application&lt;/a&gt;, as distinguished from &lt;a href=&quot;http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application&quot;&gt;function currying&lt;/a&gt;.</source>
          <target state="translated">반환 호출이 작동하는 기능 &lt;code&gt;fn&lt;/code&gt; 에 바인딩 &lt;code&gt;self&lt;/code&gt; ( &lt;code&gt;self&lt;/code&gt; 되고 &lt;code&gt;this&lt;/code&gt; 위해 &lt;code&gt;fn&lt;/code&gt; ). 함수에 사전 바인딩 된 선택적 &lt;code&gt;args&lt;/code&gt; 를 제공 할 수 있습니다 . 이 기능은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application&quot;&gt;함수 카레&lt;/a&gt; 와 구별되는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Partial_application&quot;&gt;부분적 응용&lt;/a&gt; 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="76eaba577560004aed48cfdfe1aa3c8424fd0aa9" translate="yes" xml:space="preserve">
          <source>Returns a key value object with all the cookies</source>
          <target state="translated">모든 쿠키가 포함 된 키 값 객체를 반환합니다</target>
        </trans-unit>
        <trans-unit id="0a52a1fd016452a1dacdc288a006e2e537121c87" translate="yes" xml:space="preserve">
          <source>Returns a new instance of deferred.</source>
          <target state="translated">지연된 새 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="136a5149676161a6fd098efcaeeef0ff90a14b7a" translate="yes" xml:space="preserve">
          <source>Returns a promise of the passed value or promise</source>
          <target state="translated">전달 된 값 또는 약속의 약속을 반환</target>
        </trans-unit>
        <trans-unit id="53f41d95873bd14bb41b9b13964b73702f270a5c" translate="yes" xml:space="preserve">
          <source>Returns a promise that resolves or rejects as soon as one of those promises resolves or rejects, with the value or reason from that promise.</source>
          <target state="translated">해당 약속의 가치 또는 이유와 함께 해당 약속 중 하나가 해결 또는 거부되는 즉시 해결 또는 거부하는 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef857672d8e5bb92df878c0cd409b4cd4a641e9f" translate="yes" xml:space="preserve">
          <source>Returns a promise that was already resolved as rejected with the &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 거부되어 이미 해결 된 약속을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0f1de3ceadfe205063fa5015ea7133427f3c14e4" translate="yes" xml:space="preserve">
          <source>Returns a single promise that will be resolved with an array/hash of values, each value corresponding to the promise at the same index/key in the &lt;code&gt;promises&lt;/code&gt; array/hash. If any of the promises is resolved with a rejection, this resulting promise will be rejected with the same rejection value.</source>
          <target state="translated">반환 된 값의 어레이 / 해시 해결 될 단일 약속은 동일한 인덱스 / 키의 약속에 대응하는 각각의 값이 &lt;code&gt;promises&lt;/code&gt; 배열 / 해시. 약속 중 하나라도 거부로 해결되면이 결과 약속은 동일한 거부 값으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="2b7aae4d3bb18f409e3f426b3c452cfcca7d02e8" translate="yes" xml:space="preserve">
          <source>Returns a trusted representation of the parameter for the specified context. This trusted object will later on be used as-is, without any security check, by bindings or directives that require this security context. For instance, marking a string as trusted for the &lt;code&gt;$sce.HTML&lt;/code&gt; context will entirely bypass the potential &lt;code&gt;$sanitize&lt;/code&gt; call in corresponding &lt;code&gt;$sce.HTML&lt;/code&gt; bindings or directives, such as &lt;code&gt;ng-bind-html&lt;/code&gt;. Note that in most cases you won't need to call this function: if you have the sanitizer loaded, passing the value itself will render all the HTML that does not pose a security risk.</source>
          <target state="translated">지정된 컨텍스트에 대한 신뢰할 수있는 매개 변수 표현을 리턴합니다. 이 트러스트 된 개체는 나중에이 보안 컨텍스트가 필요한 바인딩 또는 지시문에 의해 보안 검사없이있는 그대로 사용됩니다. 예를 들어 문자열을 &lt;code&gt;$sce.HTML&lt;/code&gt; 컨텍스트에 대해 신뢰할 수있는 것으로 표시하면 &lt;code&gt;ng-bind-html&lt;/code&gt; 과 같은 해당 &lt;code&gt;$sce.HTML&lt;/code&gt; 바인딩 또는 지시문 에서 잠재적 &lt;code&gt;$sanitize&lt;/code&gt; 호출을 완전히 무시합니다 . 대부분의 경우이 함수를 호출 할 필요는 없습니다. 살균제를로드 한 경우 값 자체를 전달하면 보안 위험이없는 모든 HTML이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="e63ee47d380d94c7114daa75d9a484cd818b0895" translate="yes" xml:space="preserve">
          <source>Returns an array containing the items from the specified &lt;code&gt;collection&lt;/code&gt;, ordered by a &lt;code&gt;comparator&lt;/code&gt; function based on the values computed using the &lt;code&gt;expression&lt;/code&gt; predicate.</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; 술어를 사용하여 계산 된 값을 기반으로 &lt;code&gt;comparator&lt;/code&gt; 함수로 정렬 된 지정된 &lt;code&gt;collection&lt;/code&gt; 의 항목을 포함하는 배열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c7812902dff27c75deda49f81fee7823d71feecf" translate="yes" xml:space="preserve">
          <source>Returns an array of service names which the function is requesting for injection. This API is used by the injector to determine which services need to be injected into the function when the function is invoked. There are three ways in which the function can be annotated with the needed dependencies.</source>
          <target state="translated">함수가 주입을 요청하는 서비스 이름의 배열을 리턴합니다. 이 API는 인젝터에서 함수를 호출 할 때 함수에 어떤 서비스를 주입해야하는지 결정하기 위해 사용됩니다. 필요한 종속성으로 함수에 주석을 달 수있는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92130a2ac23bc3fb5d32303cc360ae1afb6c8f1e" translate="yes" xml:space="preserve">
          <source>Returns an object with &lt;code&gt;respond&lt;/code&gt; and &lt;code&gt;passThrough&lt;/code&gt; methods that control how a matched request is handled. You can save this object for later use and invoke &lt;code&gt;respond&lt;/code&gt; or &lt;code&gt;passThrough&lt;/code&gt; again in order to change how a matched request is handled.</source>
          <target state="translated">와 객체를 돌려줍니다 &lt;code&gt;respond&lt;/code&gt; 및 &lt;code&gt;passThrough&lt;/code&gt; 제어 일치하는 요청을 처리하는 방법을하는 것이 방법. 일치하는 요청이 처리되는 방식을 변경하기 위해 나중에 사용하기 위해이 오브젝트를 저장하고 &lt;code&gt;respond&lt;/code&gt; 또는 &lt;code&gt;passThrough&lt;/code&gt; 를 다시 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b12454311ab476fb55e3d251419c65cd614f0f0d" translate="yes" xml:space="preserve">
          <source>Returns an object with &lt;code&gt;respond&lt;/code&gt; method that controls how a matched request is handled. You can save this object for later use and invoke &lt;code&gt;respond&lt;/code&gt; again in order to change how a matched request is handled.</source>
          <target state="translated">일치하는 요청을 처리하는 방법을 제어하는 &lt;code&gt;respond&lt;/code&gt; 메소드가 있는 오브젝트를 리턴합니다 . 일치하는 요청이 처리되는 방식을 변경하기 위해 나중에 사용하기 위해이 오브젝트를 저장하고 &lt;code&gt;respond&lt;/code&gt; 다시 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f047416d0b927febeecefb5e718bd2f9a2df1b6" translate="yes" xml:space="preserve">
          <source>Returns an object with &lt;code&gt;respond&lt;/code&gt; method that controls how a matched request is handled. You can save this object for later use and invoke &lt;code&gt;respond&lt;/code&gt; again in order to change how a matched request is handled. See #expect for more info.</source>
          <target state="translated">일치하는 요청을 처리하는 방법을 제어하는 &lt;code&gt;respond&lt;/code&gt; 메소드가 있는 오브젝트를 리턴합니다 . 일치하는 요청이 처리되는 방식을 변경하기 위해 나중에 사용하기 위해이 오브젝트를 저장하고 &lt;code&gt;respond&lt;/code&gt; 다시 호출 할 수 있습니다. 자세한 내용은 #expect를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="febb41850b2ea1bde8532f9d32840c151719f31c" translate="yes" xml:space="preserve">
          <source>Returns an object with &lt;code&gt;respond&lt;/code&gt; method that controls how a matched request is handled. You can save this object for later use and invoke &lt;code&gt;respond&lt;/code&gt; again in order to change how a matched request is handled. See &lt;a href=&quot;%24httpbackend#expect.html&quot;&gt;&lt;code&gt;expect&lt;/code&gt;&lt;/a&gt; for more info.</source>
          <target state="translated">일치하는 요청을 처리하는 방법을 제어하는 &lt;code&gt;respond&lt;/code&gt; 메소드가 있는 오브젝트를 리턴합니다 . 일치하는 요청이 처리되는 방식을 변경하기 위해 나중에 사용하기 위해이 오브젝트를 저장하고 &lt;code&gt;respond&lt;/code&gt; 다시 호출 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;%24httpbackend#expect.html&quot;&gt; &lt;code&gt;expect&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02fb6420d8c8e60003b530a7c0b9efa52506b950" translate="yes" xml:space="preserve">
          <source>Returns an object with &lt;code&gt;respond&lt;/code&gt; method that controls how a matched request is handled. You can save this object for later use and invoke &lt;code&gt;respond&lt;/code&gt; again in order to change how a matched request is handled. See &lt;a href=&quot;%24httpbackend#when.html&quot;&gt;&lt;code&gt;when&lt;/code&gt;&lt;/a&gt; for more info.</source>
          <target state="translated">일치하는 요청을 처리하는 방법을 제어하는 &lt;code&gt;respond&lt;/code&gt; 메소드가 있는 오브젝트를 리턴합니다 . 일치하는 요청이 처리되는 방식을 변경하기 위해 나중에 사용하기 위해이 오브젝트를 저장하고 &lt;code&gt;respond&lt;/code&gt; 다시 호출 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;%24httpbackend#when.html&quot;&gt; &lt;code&gt;when&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbcad89ebd6ebd347f43b569c186847060998b49" translate="yes" xml:space="preserve">
          <source>Returns self for chaining.</source>
          <target state="translated">연결을 위해 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1a2a6fe4c577bdba410ad77f0ccde833e7c1887" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;../service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; options when used as getter and self if used as setter.</source>
          <target state="translated">getter로 사용될 경우 &lt;a href=&quot;../service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 옵션을 반환하고 setter로 사용될 경우 self를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7a0b054676e6ac8ef163680f448b297979e55786" translate="yes" xml:space="preserve">
          <source>Returns the currently configured value if called without an argument or self for chaining otherwise.</source>
          <target state="translated">인수없이 호출 된 경우 현재 구성된 값을 반환하거나 그렇지 않으면 연결을 위해 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7566a0737921da5fa5699819d77a23be22ebc138" translate="yes" xml:space="preserve">
          <source>Returns the deserialized value of given cookie key</source>
          <target state="translated">주어진 쿠키 키의 역 직렬화 된 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="ac1fa2af0777e89e79281d48c66da8366cebd038" translate="yes" xml:space="preserve">
          <source>Returns the hash fragment when called without any parameters.</source>
          <target state="translated">매개 변수없이 호출되면 해시 조각을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc4c7aa6bc7052877ba14c90df407adc10fbbf79" translate="yes" xml:space="preserve">
          <source>Returns the newly created injector for this app.</source>
          <target state="translated">이 앱에 대해 새로 생성 된 인젝터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b123de86d068011c16640c3bb3f09ea32bf5b046" translate="yes" xml:space="preserve">
          <source>Returns the symbol when used as getter and self if used as setter.</source>
          <target state="translated">getter로 사용될 때는 기호를, setter로 사용할 때는 self를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c26a024ab2a1085285618d5276acb4f34dbdaba" translate="yes" xml:space="preserve">
          <source>Returns the value of given cookie key</source>
          <target state="translated">주어진 쿠키 키의 값을 반환</target>
        </trans-unit>
        <trans-unit id="4b0f507f707432410cc232ce8c8391aa310c2b61" translate="yes" xml:space="preserve">
          <source>Returns the value of the given option</source>
          <target state="translated">주어진 옵션의 값을 반환</target>
        </trans-unit>
        <trans-unit id="f2ef6265c021653aef5295a30225ad8ccd92d4d1" translate="yes" xml:space="preserve">
          <source>Reusing and Overriding Messages</source>
          <target state="translated">메시지 재사용 및 재정의</target>
        </trans-unit>
        <trans-unit id="3cf34505e224585e164828aeb4eda4ea440ca96d" translate="yes" xml:space="preserve">
          <source>Right click on the element of interest in your browser and select 'inspect element'. You should see the browser debugger with the element you clicked on highlighted.</source>
          <target state="translated">브라우저에서 관심있는 요소를 마우스 오른쪽 단추로 클릭하고 '요소 검사'를 선택하십시오. 클릭 한 요소가 강조 표시된 브라우저 디버거가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1282afa099110ef5bab27cf0d0743ad34ccd017" translate="yes" xml:space="preserve">
          <source>Right now, the &lt;code&gt;InvoiceController&lt;/code&gt; contains all logic of our example. When the application grows it is a good practice to move view-independent logic from the controller into a &lt;a href=&quot;services&quot;&gt;service&lt;/a&gt;, so it can be reused by other parts of the application as well. Later on, we could also change that service to load the exchange rates from the web, e.g. by calling the &lt;a href=&quot;https://exchangeratesapi.io&quot;&gt;exchangeratesapi.io&lt;/a&gt; exchange rate API, without changing the controller.</source>
          <target state="translated">현재 &lt;code&gt;InvoiceController&lt;/code&gt; 에는 예제의 모든 논리가 포함되어 있습니다. 응용 프로그램이 커지면 뷰 독립적 인 논리를 컨트롤러에서 &lt;a href=&quot;services&quot;&gt;서비스&lt;/a&gt; 로 이동하는 것이 좋습니다 . 따라서 응용 프로그램의 다른 부분에서도 재사용 할 수 있습니다. 나중에 컨트롤러를 변경하지 않고 &lt;a href=&quot;https://exchangeratesapi.io&quot;&gt;exchangeratesapi.io&lt;/a&gt; 환율 API 를 호출하여 웹에서 환율을로드하도록 해당 서비스를 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="388dc3a13e7c2df62a7d0113aee4bc60c22fb08f" translate="yes" xml:space="preserve">
          <source>Rollback all form controls pending updates to the &lt;code&gt;$modelValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$modelValue&lt;/code&gt; 대한 업데이트 보류중인 모든 양식 제어를 롤백하십시오 .</target>
        </trans-unit>
        <trans-unit id="5996cf7c4ec8a2ea89e5c3d6b6268347017db8ab" translate="yes" xml:space="preserve">
          <source>RootRouter</source>
          <target state="translated">RootRouter</target>
        </trans-unit>
        <trans-unit id="a8b9a80d5b6fe314ec0617a6cf219163ebb328aa" translate="yes" xml:space="preserve">
          <source>Route path (matched against &lt;code&gt;$location.path&lt;/code&gt;). If &lt;code&gt;$location.path&lt;/code&gt; contains redundant trailing slash or is missing one, the route will still match and the &lt;code&gt;$location.path&lt;/code&gt; will be updated to add or drop the trailing slash to exactly match the route definition.</source>
          <target state="translated">경로 경로 ( &lt;code&gt;$location.path&lt;/code&gt; 와 일치 ) 경우 &lt;code&gt;$location.path&lt;/code&gt; 중복 후행 슬래시를 포함하거나 하나의 누락, 경로는 여전히 일치와 &lt;code&gt;$location.path&lt;/code&gt; 추가하거나 정확하게 경로 정의와 일치하는 후행 슬래시를 드롭 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="8dcd12c669cda5e58092102e97cb8d8dd360a58b" translate="yes" xml:space="preserve">
          <source>RouteDefinition</source>
          <target state="translated">RouteDefinition</target>
        </trans-unit>
        <trans-unit id="76a5f5f22494bf6a3c36afbf4839eb11b038893c" translate="yes" xml:space="preserve">
          <source>RouteParams</source>
          <target state="translated">RouteParams</target>
        </trans-unit>
        <trans-unit id="6dcf16e1c5d3e9fd2ae4a4d54c174448fe43e1b6" translate="yes" xml:space="preserve">
          <source>Router</source>
          <target state="translated">Router</target>
        </trans-unit>
        <trans-unit id="8183a5a123ef606156a7236c70c6654dd427ccb8" translate="yes" xml:space="preserve">
          <source>Routers and &quot;Routing Component&quot; instances have a 1:1 correspondence.</source>
          <target state="translated">라우터와 &quot;Routing Component&quot;인스턴스는 1 : 1로 대응됩니다.</target>
        </trans-unit>
        <trans-unit id="83fdf92a177cbfa66587a728de0b8ede57b01242" translate="yes" xml:space="preserve">
          <source>Routes that specify &lt;code&gt;redirectTo&lt;/code&gt; will not have their controllers, template functions or resolves called, the &lt;code&gt;$location&lt;/code&gt; will be changed to the redirect url and route processing will stop. The exception to this is if the &lt;code&gt;redirectTo&lt;/code&gt; is a function that returns &lt;code&gt;undefined&lt;/code&gt;. In this case the route transition occurs as though there was no redirection.</source>
          <target state="translated">&lt;code&gt;redirectTo&lt;/code&gt; 를 지정하는 경로는 컨트롤러, 템플릿 기능 또는 확인이 호출되지 않으며 &lt;code&gt;$location&lt;/code&gt; 은 경로 재 지정 URL로 변경되고 경로 처리가 중지됩니다. &lt;code&gt;redirectTo&lt;/code&gt; 가 &lt;code&gt;undefined&lt;/code&gt; 를 반환하는 함수 인 경우는 예외 입니다. 이 경우 경로 전환이없는 것처럼 경로 전환이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e7b1153512a20069add6781cd8603848df2e4812" translate="yes" xml:space="preserve">
          <source>Run Blocks</source>
          <target state="translated">런 블록</target>
        </trans-unit>
        <trans-unit id="6722ce3ddf6850ce91e5f88f346e10e3149acc4e" translate="yes" xml:space="preserve">
          <source>Run blocks are the closest thing in AngularJS to the main method. A run block is the code which needs to run to kickstart the application. It is executed after all of the services have been configured and the injector has been created. Run blocks typically contain code which is hard to unit-test, and for this reason should be declared in isolated modules, so that they can be ignored in the unit-tests.</source>
          <target state="translated">실행 블록은 AngularJS에서 주요 방법에 가장 가까운 것입니다. 실행 블록은 응용 프로그램을 시작하기 위해 실행해야하는 코드입니다. 모든 서비스가 구성되고 인젝터가 작성된 후에 실행됩니다. 실행 블록에는 일반적으로 단위 테스트가 어려운 코드가 포함되므로 이러한 이유로 단위 테스트에서 무시할 수 있도록 분리 된 모듈에서 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c8d88336270bc857b4196cfd5d242d75f0df581" translate="yes" xml:space="preserve">
          <source>Running in Production</source>
          <target state="translated">프로덕션에서 실행</target>
        </trans-unit>
        <trans-unit id="6bf708b8b6443fe6b3516682e7295e2172a361cc" translate="yes" xml:space="preserve">
          <source>Runs each of the registered validators (first synchronous validators and then asynchronous validators). If the validity changes to invalid, the model will be set to &lt;code&gt;undefined&lt;/code&gt;, unless &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions.allowInvalid&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;. If the validity changes to valid, it will set the model to the last available valid &lt;code&gt;$modelValue&lt;/code&gt;, i.e. either the last parsed value or the last value set from the scope.</source>
          <target state="translated">등록 된 각 유효성 검사기 (먼저 동기 유효성 검사기 및 비동기 유효성 검사기)를 실행합니다. 유효성이 무효로 변경되면 &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions.allowInvalid&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;true&lt;/code&gt; 가 아닌 한 모델은 &lt;code&gt;undefined&lt;/code&gt; 로 설정됩니다 . 유효성이 valid로 변경되면 모델은 사용 가능한 마지막 유효한 &lt;code&gt;$modelValue&lt;/code&gt; (예 : 마지막 구문 분석 된 값 또는 범위에서 설정된 마지막 값)로 모델을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="51a25d271cdba006eac5b5ccdf053324c5952492" translate="yes" xml:space="preserve">
          <source>Runs interval tasks scheduled to be run in the next &lt;code&gt;millis&lt;/code&gt; milliseconds.</source>
          <target state="translated">다음 &lt;code&gt;millis&lt;/code&gt; 초 단위 로 실행되도록 예약 된 간격 작업을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="4d98cf965492ebc44005e85cab154fe7869e024c" translate="yes" xml:space="preserve">
          <source>Runs the model -&amp;gt; view pipeline on the current &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt;$modelValue&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt;$ modelValue&lt;/a&gt; 에서 모델-&amp;gt; 뷰 파이프 라인을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="2694e7251db3dfe3d11328de106646d2159d761d" translate="yes" xml:space="preserve">
          <source>Runtime equivalent of the &lt;code&gt;$httpProvider.defaults&lt;/code&gt; property. Allows configuration of default headers, withCredentials as well as request and response transformations.</source>
          <target state="translated">&lt;code&gt;$httpProvider.defaults&lt;/code&gt; 속성에 해당하는 런타임 요청 및 응답 변환뿐만 아니라 자격 증명을 사용하여 기본 헤더를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14edc209d09ed27caa061a338e4aa18cb1b36a06" translate="yes" xml:space="preserve">
          <source>Sample project</source>
          <target state="translated">샘플 프로젝트</target>
        </trans-unit>
        <trans-unit id="3344d56affca2f26f3349fbdd450598c93585333" translate="yes" xml:space="preserve">
          <source>Sandbox removal</source>
          <target state="translated">샌드 박스 제거</target>
        </trans-unit>
        <trans-unit id="0f3d939de1df71ef2e1f63f17842b0611b8ef64d" translate="yes" xml:space="preserve">
          <source>Sanitized HTML.</source>
          <target state="translated">살균 된 HTML.</target>
        </trans-unit>
        <trans-unit id="580aa4cc01f79a6c59249fb583ca11e7ec51d9fe" translate="yes" xml:space="preserve">
          <source>Sanitizes an html string by stripping all potentially dangerous tokens.</source>
          <target state="translated">잠재적으로 위험한 토큰을 모두 제거하여 HTML 문자열을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="9e175993438b3e28876508d6f59beb5b4a306211" translate="yes" xml:space="preserve">
          <source>Savvy readers may be wondering what the difference is between &lt;code&gt;link&lt;/code&gt; and &lt;code&gt;controller&lt;/code&gt;. The basic difference is that &lt;code&gt;controller&lt;/code&gt; can expose an API, and &lt;code&gt;link&lt;/code&gt; functions can interact with controllers using &lt;code&gt;require&lt;/code&gt;.</source>
          <target state="translated">잘 아는 독자들은 &lt;code&gt;link&lt;/code&gt; 와 &lt;code&gt;controller&lt;/code&gt; 의 차이점이 무엇인지 궁금 할 것 입니다. 기본적인 차이점은 &lt;code&gt;controller&lt;/code&gt; 가 API를 노출 할 수 있고 &lt;code&gt;link&lt;/code&gt; 함수가 &lt;code&gt;require&lt;/code&gt; 를 사용하여 컨트롤러와 상호 작용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0026a1fa21295bd980ca8124863ef3160c0b9ac7" translate="yes" xml:space="preserve">
          <source>Say for example we have the following template code:</source>
          <target state="translated">예를 들어 다음과 같은 템플릿 코드가 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="c722c123fc2fd2bee33be1a4dd76341ecd74052f" translate="yes" xml:space="preserve">
          <source>Schedule the invocation of $apply to occur at a later time. The actual time difference varies across browsers, but is typically around ~10 milliseconds.</source>
          <target state="translated">$ apply 호출이 나중에 발생하도록 스케줄하십시오. 실제 시간 차이는 브라우저마다 다르지만 일반적으로 약 10 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="d62f8def19ab323ad10bffef70588ee9540fc2d6" translate="yes" xml:space="preserve">
          <source>Scope $watch Depths</source>
          <target state="translated">범위 $ watch 깊이</target>
        </trans-unit>
        <trans-unit id="a0d0cff31594de76eaec1ced0bc0427022b195e7" translate="yes" xml:space="preserve">
          <source>Scope $watch Performance Considerations</source>
          <target state="translated">범위 $ watch 성능 고려 사항</target>
        </trans-unit>
        <trans-unit id="302b65ae6f117c3e38e7c18bfe45c77b70add9db" translate="yes" xml:space="preserve">
          <source>Scope Events Propagation</source>
          <target state="translated">범위 이벤트 전파</target>
        </trans-unit>
        <trans-unit id="14241b753df73c19b8820274254a2c60ac0f3554" translate="yes" xml:space="preserve">
          <source>Scope Hierarchies</source>
          <target state="translated">범위 계층</target>
        </trans-unit>
        <trans-unit id="235fb31c091c88a3fb9489274d806ccefa3ab9aa" translate="yes" xml:space="preserve">
          <source>Scope Life Cycle</source>
          <target state="translated">범위 수명주기</target>
        </trans-unit>
        <trans-unit id="d0976b956d6be8d6a8545b0183535a72f8ebf106" translate="yes" xml:space="preserve">
          <source>Scope and DOMWindow objects are being compared only by identify (&lt;code&gt;===&lt;/code&gt;).</source>
          <target state="translated">Scope 및 DOMWindow 객체는 식별 ( &lt;code&gt;===&lt;/code&gt; )에 의해서만 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="916a87217731f57973f048683cb4e97fb8e65898" translate="yes" xml:space="preserve">
          <source>Scope as Data-Model</source>
          <target state="translated">데이터 모델로서의 범위</target>
        </trans-unit>
        <trans-unit id="bc212604b2d7699ce510ae90a60dff8c0da3bd01" translate="yes" xml:space="preserve">
          <source>Scope characteristics</source>
          <target state="translated">범위 특성</target>
        </trans-unit>
        <trans-unit id="439fa51120c7e99613ab6ed03151eda647cd3102" translate="yes" xml:space="preserve">
          <source>Scope is the glue between application controller and the view. During the template &lt;a href=&quot;compiler&quot;&gt;linking&lt;/a&gt; phase the &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt; set up &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;&lt;code&gt;$watch&lt;/code&gt;&lt;/a&gt; expressions on the scope. The &lt;code&gt;$watch&lt;/code&gt; allows the directives to be notified of property changes, which allows the directive to render the updated value to the DOM.</source>
          <target state="translated">범위는 애플리케이션 컨트롤러와보기 사이의 접착제입니다. 템플릿 &lt;a href=&quot;compiler&quot;&gt;연결&lt;/a&gt; 단계 동안 &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; 은 범위에서 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt; &lt;code&gt;$watch&lt;/code&gt; &lt;/a&gt; 식을 설정합니다 . &lt;code&gt;$watch&lt;/code&gt; 지시어는 지시어는 DOM에 업데이트 된 값을 렌더링 할 수 있습니다 속성 변경, 통보받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd3e0ec8cb2c6725e8aebcf009d5a5f0c7046543" translate="yes" xml:space="preserve">
          <source>Scope's &lt;code&gt;$apply()&lt;/code&gt; method transitions through the following stages:</source>
          <target state="translated">Scope의 &lt;code&gt;$apply()&lt;/code&gt; 메소드는 다음 단계를 통해 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="c23540e5fb551edff0ac95649a1d551f9736d55e" translate="yes" xml:space="preserve">
          <source>Scopes</source>
          <target state="translated">Scopes</target>
        </trans-unit>
        <trans-unit id="e3c4eecb101b53837a98d4900e291d21207bd54b" translate="yes" xml:space="preserve">
          <source>Scopes and Directives</source>
          <target state="translated">범위와 지시문</target>
        </trans-unit>
        <trans-unit id="b0f972ffeb44595b9c559cde18f280bbcdb9f0ed" translate="yes" xml:space="preserve">
          <source>Scopes and controllers interact with each other in the following situations:</source>
          <target state="translated">스코프와 컨트롤러는 다음 상황에서 서로 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="e2e9569b987d972c9628df7d29a9a7916ae77fe8" translate="yes" xml:space="preserve">
          <source>Scopes are attached to the DOM as &lt;code&gt;$scope&lt;/code&gt; data property, and can be retrieved for debugging purposes. (It is unlikely that one would need to retrieve scopes in this way inside the application.) The location where the root scope is attached to the DOM is defined by the location of &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt;&lt;code&gt;ng-app&lt;/code&gt;&lt;/a&gt; directive. Typically &lt;code&gt;ng-app&lt;/code&gt; is placed on the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element, but it can be placed on other elements as well, if, for example, only a portion of the view needs to be controlled by AngularJS.</source>
          <target state="translated">범위는 &lt;code&gt;$scope&lt;/code&gt; data 속성 으로 DOM에 첨부되며 디버깅 목적으로 검색 할 수 있습니다. (응용 프로그램 내에서 이러한 방식으로 범위를 검색해야 할 가능성은 거의 없습니다.) 루트 범위가 DOM에 연결된 위치는 &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt; &lt;code&gt;ng-app&lt;/code&gt; &lt;/a&gt; 지시문 의 위치로 정의됩니다 . 일반적으로 &lt;code&gt;ng-app&lt;/code&gt; 은 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 요소에 배치되지만, 예를 들어 AngularJS에서 뷰의 일부만 제어해야하는 경우 다른 요소에도 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d7b2296b8556dc8d3127680a232536b62a2e88a" translate="yes" xml:space="preserve">
          <source>Scopes can be nested to limit access to the properties of application components while providing access to shared model properties. Nested scopes are either &quot;child scopes&quot; or &quot;isolate scopes&quot;. A &quot;child scope&quot; (prototypically) inherits properties from its parent scope. An &quot;isolate scope&quot; does not. See &lt;a href=&quot;directive#isolating-the-scope-of-a-directive.html&quot;&gt;isolated scopes&lt;/a&gt; for more information.</source>
          <target state="translated">공유 모델 속성에 대한 액세스를 제공하면서 응용 프로그램 구성 요소의 속성에 대한 액세스를 제한하기 위해 범위를 중첩 할 수 있습니다. 중첩 범위는 &quot;자식 범위&quot;또는 &quot;격리 범위&quot;입니다. &quot;자식 범위&quot;(시제품)는 부모 범위의 속성을 상속합니다. &quot;격리 범위&quot;는 그렇지 않습니다. 자세한 내용은 &lt;a href=&quot;directive#isolating-the-scope-of-a-directive.html&quot;&gt;격리 된 범위&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="305cd57d6f32dc5f9b280f00159d0df0f3023e4e" translate="yes" xml:space="preserve">
          <source>Scopes can propagate events in similar fashion to DOM events. The event can be &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24broadcast.html&quot;&gt;broadcasted&lt;/a&gt; to the scope children or &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24emit.html&quot;&gt;emitted&lt;/a&gt; to scope parents.</source>
          <target state="translated">범위는 DOM 이벤트와 유사한 방식으로 이벤트를 전파 할 수 있습니다. 이 행사는 할 수 있습니다 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24broadcast.html&quot;&gt;방송&lt;/a&gt; 범위 어린이 또는 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24emit.html&quot;&gt;방출&lt;/a&gt; 범위 부모.</target>
        </trans-unit>
        <trans-unit id="d1a3bd31aed7d75d260f08509418244324e8a207" translate="yes" xml:space="preserve">
          <source>Scopes provide APIs (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$apply&lt;/a&gt;) to propagate any model changes through the system into the view from outside of the &quot;AngularJS realm&quot; (controllers, services, AngularJS event handlers).</source>
          <target state="translated">범위 는 시스템을 통해 모델 변경 사항을 &quot;AngularJS 영역&quot;외부 (컨트롤러, 서비스, AngularJS 이벤트 핸들러)의보기로 전파 하기위한 API ( &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$ apply&lt;/a&gt; )를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="11ac5700c534742d0e8c9053281de57235e54557" translate="yes" xml:space="preserve">
          <source>Scopes provide APIs (&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$watch&lt;/a&gt;) to observe model mutations.</source>
          <target state="translated">범위는 모델 돌연변이를 관찰 하기 위해 API ( &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;$ watch&lt;/a&gt; )를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ce449a4334e989d4805feb6f59bfbc096fd1d3f1" translate="yes" xml:space="preserve">
          <source>Scopes provide context against which &lt;a href=&quot;expression&quot;&gt;expressions&lt;/a&gt; are evaluated. For example &lt;code&gt;{{username}}&lt;/code&gt; expression is meaningless, unless it is evaluated against a specific scope which defines the &lt;code&gt;username&lt;/code&gt; property.</source>
          <target state="translated">범위는 &lt;a href=&quot;expression&quot;&gt;식이&lt;/a&gt; 평가 되는 컨텍스트를 제공합니다 . 예를 들어 &lt;code&gt;{{username}}&lt;/code&gt; 표현식은 &lt;code&gt;username&lt;/code&gt; 특성 을 정의하는 특정 범위에 대해 평가되지 않는 한 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">보안 고려 사항</target>
        </trans-unit>
        <trans-unit id="c656e13929f42b006319c02054f25a66cda15f73" translate="yes" xml:space="preserve">
          <source>See &quot;Setting HTTP Headers&quot; and &quot;Transforming Requests and Responses&quot; sections above.</source>
          <target state="translated">위의 &quot;HTTP 헤더 설정&quot;및 &quot;요청 및 응답 변환&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce580465f075a927c26bd792f620faeb08178d8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;%24resource#using-interceptors.html&quot;&gt;below&lt;/a&gt; for an example of using interceptors in &lt;code&gt;$resource&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$resource&lt;/code&gt; 에서 인터셉터를 사용하는 예는 &lt;a href=&quot;%24resource#using-interceptors.html&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a0f7cdb05f0d1da3c48719d367b1b98eaed811b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;%24rootscope.scope#%24suspend.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt; for information about the dangers of using this approach.</source>
          <target state="translated">이 방법을 사용할 때의 위험에 대한 정보는 &lt;a href=&quot;%24rootscope.scope#%24suspend.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ab6e9c3878b3b65c683ceec3e46af03e5068396" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;%24scedelegate#getTrusted.html&quot;&gt;getTrusted&lt;/a&gt; for the function that will consume those trusted values, and &lt;a href=&quot;%24sce&quot;&gt;$sce&lt;/a&gt; for general documentation about strict contextual escaping.</source>
          <target state="translated">신뢰할 수있는 값을 소비하는 함수에 대해서는 &lt;a href=&quot;%24scedelegate#getTrusted.html&quot;&gt;getTrusted&lt;/a&gt; 를 참조 하고 엄격한 컨텍스트 이스케이프에 대한 일반 문서는 &lt;a href=&quot;%24sce&quot;&gt;$ sce&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08a2abfd00cc89b00d13557bd045d8a7fc819d20" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../auto/service/%24provide#decorator.html&quot;&gt;$provide.decorator()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../auto/service/%24provide#decorator.html&quot;&gt;$ provide.decorator ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4881e6ea68349cef48089f2f637bc14482f49cf0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../auto/service/%24provide#factory.html&quot;&gt;$provide.factory()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../auto/service/%24provide#factory.html&quot;&gt;$ provide.factory ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc816366c830b4ded4b6885c7268a758294924b3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../auto/service/%24provide#provider.html&quot;&gt;$provide.provider()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../auto/service/%24provide#provider.html&quot;&gt;$ provide.provider ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="802e7e1e8c14b1ed28b14aaa7fe5ba0c8a8729a5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../auto/service/%24provide#service.html&quot;&gt;$provide.service()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../auto/service/%24provide#service.html&quot;&gt;$ provide.service ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1492fdd835886f46960aff4b15c1ea7527996eee" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../../auto/service/%24provide#value.html&quot;&gt;$provide.value()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../auto/service/%24provide#value.html&quot;&gt;$ provide.value ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4702c3d54b709af87dc2b647ec20769598ffc5d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt;&lt;code&gt;ngModelOptions&lt;/code&gt;&lt;/a&gt; for information about what options can be specified and how model option inheritance works.</source>
          <target state="translated">지정할 수있는 옵션 및 모델 옵션 상속 작동 방식에 대한 정보는 &lt;a href=&quot;../directive/ngmodeloptions&quot;&gt; &lt;code&gt;ngModelOptions&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45e9c3ebaad21216152aaedcba8b19ad6f025f8c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../provider/%24animateprovider#register.html&quot;&gt;$animateProvider.register()&lt;/a&gt; and &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate module&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../provider/%24animateprovider#register.html&quot;&gt;$ animateProvider.register ()&lt;/a&gt; 및 &lt;a href=&quot;../../nganimate&quot;&gt;ngAnimate 모듈&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="658501b0548d68515ff6b170517e8aa37a8f25fc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../provider/%24compileprovider#component.html&quot;&gt;$compileProvider.component()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../provider/%24compileprovider#component.html&quot;&gt;$ compileProvider.component ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33da85697433ddb423abb205cb0071fc01ab0c67" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../provider/%24compileprovider#debugInfoEnabled.html&quot;&gt;&lt;code&gt;$compileProvider&lt;/code&gt;&lt;/a&gt; for more.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../provider/%24compileprovider#debugInfoEnabled.html&quot;&gt; &lt;code&gt;$compileProvider&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e7660c1158870c4e303c6c71117d715a3757a1a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;$compileProvider.directive()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../provider/%24compileprovider#directive.html&quot;&gt;$ compileProvider.directive ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3680a0f086330aee3870b424d3ec342433ba7964" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../provider/%24controllerprovider#register.html&quot;&gt;$controllerProvider.register()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../provider/%24controllerprovider#register.html&quot;&gt;$ controllerProvider.register ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="24b5bfecbf9bb5014e4c2c79d7ace634c3181572" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../provider/%24filterprovider#register.html&quot;&gt;$filterProvider.register()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../provider/%24filterprovider#register.html&quot;&gt;$ filterProvider.register ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d993d3401264eac8064f38c18942944ab3315a88" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../service/%24route#examples.html&quot;&gt;$route&lt;/a&gt; for an example of configuring and using &lt;code&gt;ngRoute&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngRoute&lt;/code&gt; 구성 및 사용의 예는 &lt;a href=&quot;../service/%24route#examples.html&quot;&gt;$ route&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="078f7235c75d6b9194ec298e0b95e74d1ffd82cc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;angular.mock.inject&quot;&gt;inject&lt;/a&gt; for usage example</source>
          <target state="translated">사용법 예는 &lt;a href=&quot;angular.mock.inject&quot;&gt;주입&lt;/a&gt; 을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="913150b7af43d4803c12014f2495d922c6f53ce1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;di#using-dependency-injection.html&quot;&gt;Using Dependency Injection&lt;/a&gt; to find out which dependencies can be injected in each method.</source>
          <target state="translated">각 방법에 주입 할 수있는 종속성을 확인하려면 &lt;a href=&quot;di#using-dependency-injection.html&quot;&gt;종속성 주입 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34a10d5c19333054e6759e18c71a55e84a1b5185" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;directive&quot;&gt;&lt;code&gt;$compileProvider.directive&lt;/code&gt;&lt;/a&gt; for more info.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;directive&quot;&gt; &lt;code&gt;$compileProvider.directive&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="788b9222c3928afb09f4b7e9ad07a03aa9ce0a97" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;form.formcontroller#%24error.html&quot;&gt;$error&lt;/a&gt; for a list of built-in validation tokens.</source>
          <target state="translated">내장 된 유효성 검사 토큰 목록은 &lt;a href=&quot;form.formcontroller#%24error.html&quot;&gt;$ error&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d368454c2e9095f2ee9538a7b3902eef5c5e921e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.google.com/a/google.com/document/d/1pbtW2yvtmFBikfRrJd8VAsabiFkKezmYZ_PbgdjQOVU/edit&quot;&gt;the design doc&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://docs.google.com/a/google.com/document/d/1pbtW2yvtmFBikfRrJd8VAsabiFkKezmYZ_PbgdjQOVU/edit&quot;&gt;은 디자인 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6c9dadfccbd374155d0b83905fbf6db42471eb01" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/angular/angular.js/issues/14018&quot;&gt;https://github.com/angular/angular.js/issues/14018&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/angular/angular.js/issues/14018&quot;&gt;https://github.com/angular/angular.js/issues/14018&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="965fb29fc499cec553ef8ae9cda41d3773f4c576" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/angular/angular.js/pull/14221&quot;&gt;https://github.com/angular/angular.js/pull/14221&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/angular/angular.js/pull/14221&quot;&gt;https://github.com/angular/angular.js/pull/14221&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="98bc08e70cdb8a19e8f8ebd22122e19a9f54a166" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/angular/angular.js/pull/14610#issuecomment-219401099&quot;&gt;https://github.com/angular/angular.js/pull/14610#issuecomment-219401099&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/angular/angular.js/pull/14610#issuecomment-219401099&quot;&gt;https://github.com/angular/angular.js/pull/14610#issuecomment-219401099&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c0e9938efdfba23465cbe6b8ab60e447cad7f63" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;module#module-loading.html&quot;&gt;Modules&lt;/a&gt; for more details about &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; blocks and &lt;a href=&quot;providers&quot;&gt;Providers&lt;/a&gt; for more information about the different provider types.</source>
          <target state="translated">참조 &lt;a href=&quot;module#module-loading.html&quot;&gt;모듈&lt;/a&gt; 에 대한 자세한 내용은 &lt;code&gt;run&lt;/code&gt; 및 &lt;code&gt;config&lt;/code&gt; 블록 및 &lt;a href=&quot;providers&quot;&gt;공급자&lt;/a&gt; 다른 공급자 유형에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bc920667f9c77737168e5d37cbdaf815ee9f2e4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;ngclick&quot;&gt;ngClick&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ngclick&quot;&gt;ngClick&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="4c8ebb4aa13aea65763e9630efc734b8dacab942" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;ngcookies/service/%24cookies&quot;&gt;&lt;code&gt;$cookies&lt;/code&gt;&lt;/a&gt; for usage.</source>
          <target state="translated">사용법 은 &lt;a href=&quot;ngcookies/service/%24cookies&quot;&gt; &lt;code&gt;$cookies&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b00bd75d710a9877128c13b28d66fe558262c35" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;ngresource/provider/%24resourceprovider&quot;&gt;&lt;code&gt;$resourceProvider&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ngresource/service/%24resource&quot;&gt;&lt;code&gt;$resource&lt;/code&gt;&lt;/a&gt; for usage.</source>
          <target state="translated">사용법 은 &lt;a href=&quot;ngresource/provider/%24resourceprovider&quot;&gt; &lt;code&gt;$resourceProvider&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ngresource/service/%24resource&quot;&gt; &lt;code&gt;$resource&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
