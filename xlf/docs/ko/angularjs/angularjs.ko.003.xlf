<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angularjs">
    <body>
      <group id="angularjs">
        <trans-unit id="7422e70c60bc15b4ce5aee88f1fa3d09ecfa4487" translate="yes" xml:space="preserve">
          <source>AngularJS simplifies application development by presenting a higher level of abstraction to the developer. Like any abstraction, it comes at a cost of flexibility. In other words, not every app is a good fit for AngularJS. AngularJS was built with the CRUD application in mind. Luckily CRUD applications represent the majority of web applications. To understand what AngularJS is good at, though, it helps to understand when an app is not a good fit for AngularJS.</source>
          <target state="translated">AngularJS는 개발자에게 더 높은 수준의 추상화를 제공하여 애플리케이션 개발을 단순화합니다. 다른 추상화와 마찬가지로 유연성이 떨어집니다. 즉, 모든 앱이 AngularJS에 적합한 것은 아닙니다. AngularJS는 CRUD 응용 프로그램을 염두에두고 작성되었습니다. 다행히 CRUD 응용 프로그램은 대부분의 웹 응용 프로그램을 나타냅니다. AngularJS의 장점을 이해하려면 앱이 AngularJS에 적합하지 않은 시점을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="fe3ac4e24f01511fd93bb16d06effbc2d6379f34" translate="yes" xml:space="preserve">
          <source>AngularJS strongly relies on contextual escaping for the security of bindings: disabling or modifying this might cause cross site scripting (XSS) vulnerabilities. For libraries owners, changes to this service will also influence users, so be extra careful and document your changes.</source>
          <target state="translated">AngularJS는 바인딩의 보안을 위해 상황에 맞는 이스케이프에 크게 의존합니다.이를 비활성화하거나 수정하면 XSS (Cross Site Scripting) 취약점이 발생할 수 있습니다. 도서관 소유자의 경우이 서비스의 변경 사항이 사용자에게도 영향을 미치므로주의해서 변경 사항을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="4431411ecab45405bde7dd419d71acb67b3391ca" translate="yes" xml:space="preserve">
          <source>AngularJS supports i18n/l10n for &lt;a href=&quot;../api/ng/filter/date&quot;&gt;date&lt;/a&gt;, &lt;a href=&quot;../api/ng/filter/number&quot;&gt;number&lt;/a&gt; and &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;currency&lt;/a&gt; filters.</source>
          <target state="translated">AngularJS는 &lt;a href=&quot;../api/ng/filter/date&quot;&gt;날짜&lt;/a&gt; , &lt;a href=&quot;../api/ng/filter/number&quot;&gt;숫자&lt;/a&gt; 및 &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;통화&lt;/a&gt; 필터에 i18n / l10n을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="3a4ebceac2caf5ebdf9c2c4c4dc59c26f35d27a5" translate="yes" xml:space="preserve">
          <source>AngularJS takes another approach. It attempts to minimize the impedance mismatch between document centric HTML and what an application needs by creating new HTML constructs. AngularJS teaches the browser new syntax through a construct we call &lt;em&gt;directives&lt;/em&gt;. Examples include:</source>
          <target state="translated">AngularJS는 다른 접근 방식을 취합니다. 새로운 HTML 구문을 만들어 문서 중심 HTML과 응용 프로그램에 필요한 것 사이의 임피던스 불일치를 최소화하려고 시도합니다. AngularJS는 &lt;em&gt;지시어&lt;/em&gt; 를 호출하는 구문을 통해 브라우저에 새로운 구문을 알려 줍니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="769e07375c5ab3bf0b0051ac78640da73f4c7868" translate="yes" xml:space="preserve">
          <source>AngularJS templates work differently. First the template (which is the uncompiled HTML along with any additional markup or directives) is compiled on the browser. The compilation step produces a live view. Any changes to the view are immediately reflected in the model, and any changes in the model are propagated to the view. The model is the single-source-of-truth for the application state, greatly simplifying the programming model for the developer. You can think of the view as simply an instant projection of your model.</source>
          <target state="translated">AngularJS 템플릿은 다르게 작동합니다. 먼저 템플릿 (추가 마크 업 또는 지시문과 함께 컴파일되지 않은 HTML)이 브라우저에서 컴파일됩니다. 컴파일 단계는 라이브 뷰를 생성합니다. 뷰에 대한 모든 변경 사항이 모델에 즉시 반영되고 모델의 모든 변경 사항이 뷰에 전파됩니다. 이 모델은 응용 프로그램 상태의 단일 소스 소스이므로 개발자의 프로그래밍 모델을 크게 단순화합니다. 뷰를 단순히 모델의 즉각적인 투영으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfc125702fe4d5d98bdb594a33013e8322f09d18" translate="yes" xml:space="preserve">
          <source>AngularJS will detect if it has been loaded into the browser more than once and only allow the first loaded script to be bootstrapped and will report a warning to the browser console for each of the subsequent scripts. This prevents strange results in applications, where otherwise multiple instances of AngularJS try to work on the DOM.</source>
          <target state="translated">AngularJS는 브라우저에 두 번 이상로드되었는지 감지하고 첫 번째로로드 된 스크립트 만 부트 스트랩 할 수 있도록 허용하고 후속 스크립트 각각에 대해 브라우저 콘솔에 경고를보고합니다. 이렇게하면 AngularJS의 여러 인스턴스가 DOM에서 작동하는 응용 프로그램에서 이상한 결과가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="015dbed2a049b3782ded1815109d25f8af8a31a3" translate="yes" xml:space="preserve">
          <source>AngularJS will strip the prefix, before processing the JSON.</source>
          <target state="translated">AngularJS는 JSON을 처리하기 전에 접두사를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3086e18c373e1b050a89b62431f812b993b265f5" translate="yes" xml:space="preserve">
          <source>AngularJS's &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;currency filter&lt;/a&gt; allows you to use the default currency symbol from the &lt;a href=&quot;../api/ng/service/%24locale&quot;&gt;locale service&lt;/a&gt;, or you can provide the filter with a custom currency symbol.</source>
          <target state="translated">AngularJS의 &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;통화 필터&lt;/a&gt; 를 사용하면 &lt;a href=&quot;../api/ng/service/%24locale&quot;&gt;로케일 서비스&lt;/a&gt; 의 기본 통화 기호를 사용 하거나 필터에 사용자 정의 통화 기호를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08db1303b33928851568ddd60cd23f21541a8af" translate="yes" xml:space="preserve">
          <source>AngularJS's &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;HTML compiler&lt;/a&gt; allows the developer to teach the browser new HTML syntax. The compiler allows you to attach behavior to any HTML element or attribute and even create new HTML elements or attributes with custom behavior. AngularJS calls these behavior extensions &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt;.</source>
          <target state="translated">AngularJS의 &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;HTML 컴파일러를&lt;/a&gt; 통해 개발자는 브라우저에 새로운 HTML 구문을 가르 칠 수 있습니다. 컴파일러를 사용하면 HTML 요소 또는 속성에 동작을 추가하고 사용자 지정 동작으로 새로운 HTML 요소 또는 속성을 만들 수도 있습니다. AngularJS는 이러한 행동 확장 &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시어를&lt;/a&gt; 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="f50b6286f749aa08025813527659c6fc74af40dd" translate="yes" xml:space="preserve">
          <source>AngularJS's jqLite</source>
          <target state="translated">AngularJS의 jqLite</target>
        </trans-unit>
        <trans-unit id="e609b570c930b204946ccb899b6f09e78d1083ec" translate="yes" xml:space="preserve">
          <source>AngularJS's sweet spot</source>
          <target state="translated">AngularJS의 스위트 스팟</target>
        </trans-unit>
        <trans-unit id="18bb073a29d517b8a3a42b434c49bfbd5a2b2a13" translate="yes" xml:space="preserve">
          <source>AngularJS's wrapper for &lt;code&gt;window.setInterval&lt;/code&gt;. The &lt;code&gt;fn&lt;/code&gt; function is executed every &lt;code&gt;delay&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;window.setInterval&lt;/code&gt; 에 대한 AngularJS의 래퍼입니다 . &lt;code&gt;fn&lt;/code&gt; 기능은 모든 실행 &lt;code&gt;delay&lt;/code&gt; 밀리 초.</target>
        </trans-unit>
        <trans-unit id="f3ddbcf960e64f545ec9cb831b76819fde7f2373" translate="yes" xml:space="preserve">
          <source>AngularJS's wrapper for &lt;code&gt;window.setTimeout&lt;/code&gt;. The &lt;code&gt;fn&lt;/code&gt; function is wrapped into a try/catch block and delegates any exceptions to &lt;a href=&quot;%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;window.setTimeout&lt;/code&gt; 의 AngularJS 래퍼입니다 . &lt;code&gt;fn&lt;/code&gt; 함수는 try / catch 블록 위임에 대한 예외에 싸여 &lt;a href=&quot;%24exceptionhandler&quot;&gt;$ exceptionHandler의&lt;/a&gt; 서비스를.</target>
        </trans-unit>
        <trans-unit id="e28ca8ee33fee303615de7b48a3ebaeeb4dda2c4" translate="yes" xml:space="preserve">
          <source>AngularJS's wrapper for &lt;code&gt;window.setTimeout&lt;/code&gt;. The &lt;code&gt;fn&lt;/code&gt; function is wrapped into a try/catch block and delegates any exceptions to &lt;a href=&quot;service/%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">&lt;code&gt;window.setTimeout&lt;/code&gt; 의 AngularJS 래퍼입니다 . &lt;code&gt;fn&lt;/code&gt; 함수는 try / catch 블록 위임에 대한 예외에 싸여 &lt;a href=&quot;service/%24exceptionhandler&quot;&gt;$ exceptionHandler의&lt;/a&gt; 서비스를.</target>
        </trans-unit>
        <trans-unit id="edf5ebe5a67b68ae5fca138a2a5dfbc8054af2c8" translate="yes" xml:space="preserve">
          <source>AngularStrap for Bootstrap 3</source>
          <target state="translated">부트 스트랩 3 용 AngularStrap</target>
        </trans-unit>
        <trans-unit id="aba9a35ec9eedc8eb79e6d0f03cd4eef93153ee8" translate="yes" xml:space="preserve">
          <source>Animating between value changes</source>
          <target state="translated">가치 변화 사이의 애니메이션</target>
        </trans-unit>
        <trans-unit id="62afd21e88769f01ba1c9330803baad57564d6e9" translate="yes" xml:space="preserve">
          <source>Animation</source>
          <target state="translated">Animation</target>
        </trans-unit>
        <trans-unit id="7f5f07bd5a091d92689e50573c0da813d4d14d72" translate="yes" xml:space="preserve">
          <source>Animation Anchoring (via ng-animate-ref)</source>
          <target state="translated">애니메이션 앵커링 (ng-animate-ref를 통해)</target>
        </trans-unit>
        <trans-unit id="c77dcdedc0f40e8dac08a08c8bef7255abb90e75" translate="yes" xml:space="preserve">
          <source>Animations</source>
          <target state="translated">Animations</target>
        </trans-unit>
        <trans-unit id="4fe25ebece61799897136d3106b7e79fe6ccfbc5" translate="yes" xml:space="preserve">
          <source>Animations are not available unless you include the &lt;a href=&quot;../api/nganimate&quot;&gt;&lt;code&gt;ngAnimate&lt;/code&gt; module&lt;/a&gt; as a dependency of your application.</source>
          <target state="translated">&lt;a href=&quot;../api/nganimate&quot;&gt; &lt;code&gt;ngAnimate&lt;/code&gt; 모듈&lt;/a&gt; 을 응용 프로그램의 종속성으로 포함하지 않으면 애니메이션을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c0594ee2973edc0be64f9dfa8e39acbf86b8a72a" translate="yes" xml:space="preserve">
          <source>Animations in &lt;code&gt;ngShow&lt;/code&gt;/&lt;code&gt;ngHide&lt;/code&gt; work with the show and hide events that are triggered when the directive expression is true and false. This system works like the animation system present with &lt;code&gt;ngClass&lt;/code&gt; except that you must also include the &lt;code&gt;!important&lt;/code&gt; flag to override the display property so that the elements are not actually hidden during the animation.</source>
          <target state="translated">&lt;code&gt;ngShow&lt;/code&gt; / &lt;code&gt;ngHide&lt;/code&gt; 의 애니메이션 은 지시문 표현식이 true 및 false 일 때 트리거되는 show 및 hide 이벤트와 함께 작동합니다. 이 시스템은 애니메이션 중에 요소가 실제로 숨겨지지 않도록 표시 속성을 재정의하기 위해 &lt;code&gt;!important&lt;/code&gt; 플래그 도 포함해야한다는 점을 제외하고 &lt;code&gt;ngClass&lt;/code&gt; 에 있는 애니메이션 시스템과 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="0b2a60876cb65fb0147911bedc0ad0bf15f7d3ff" translate="yes" xml:space="preserve">
          <source>Animations in AngularJS are completely based on CSS classes. As long as you have a CSS class attached to an HTML element within your application, you can apply animations to it. Let's say for example that we have an HTML template with a repeater like so:</source>
          <target state="translated">AngularJS의 애니메이션은 CSS 클래스를 기반으로합니다. 응용 프로그램 내 HTML 요소에 CSS 클래스가 첨부되어 있으면 애니메이션을 적용 할 수 있습니다. 예를 들어 리피터가있는 HTML 템플릿이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="fff49af586e2c4e9b3f2dd501fcc0aaac06fb0d6" translate="yes" xml:space="preserve">
          <source>Animations in ngForm are triggered when any of the associated CSS classes are added and removed. These classes are: &lt;code&gt;.ng-pristine&lt;/code&gt;, &lt;code&gt;.ng-dirty&lt;/code&gt;, &lt;code&gt;.ng-invalid&lt;/code&gt; and &lt;code&gt;.ng-valid&lt;/code&gt; as well as any other validations that are performed within the form. Animations in ngForm are similar to how they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well as JS animations.</source>
          <target state="translated">ngForm의 애니메이션은 연결된 CSS 클래스가 추가 및 제거 될 때 트리거됩니다. 이러한 클래스는 &lt;code&gt;.ng-pristine&lt;/code&gt; , &lt;code&gt;.ng-dirty&lt;/code&gt; , &lt;code&gt;.ng-invalid&lt;/code&gt; 및 &lt;code&gt;.ng-valid&lt;/code&gt; 및 양식 내에서 수행되는 다른 유효성 검사입니다. ngForm의 애니메이션은 ngClass에서 작동하는 방식과 유사하며 CSS 전환, 키 프레임 및 JS 애니메이션을 사용하여 애니메이션을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67b5c3728edc0e75f5c55a0c0056f00846acd15f" translate="yes" xml:space="preserve">
          <source>Animations on app bootstrap / page load</source>
          <target state="translated">앱 부트 스트랩 / 페이지로드의 애니메이션</target>
        </trans-unit>
        <trans-unit id="2177639f84412abd63d8ce1ffb0f9712bb859c76" translate="yes" xml:space="preserve">
          <source>Animations within custom directives can also be established by injecting &lt;code&gt;$animate&lt;/code&gt; directly into your directive and making calls to it when needed.</source>
          <target state="translated">사용자 지정 지시문 내의 애니메이션은 지시문에 &lt;code&gt;$animate&lt;/code&gt; 직접 주입 하고 필요할 때 호출하여 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29559d5d09175ad58fe92108a5edad256c28781a" translate="yes" xml:space="preserve">
          <source>Animations within models are triggered when any of the associated CSS classes are added and removed on the input element which is attached to the model. These classes include: &lt;code&gt;.ng-pristine&lt;/code&gt;, &lt;code&gt;.ng-dirty&lt;/code&gt;, &lt;code&gt;.ng-invalid&lt;/code&gt; and &lt;code&gt;.ng-valid&lt;/code&gt; as well as any other validations that are performed on the model itself. The animations that are triggered within ngModel are similar to how they work in ngClass and animations can be hooked into using CSS transitions, keyframes as well as JS animations.</source>
          <target state="translated">모델 내의 애니메이션은 연결된 CSS 클래스가 모델에 연결된 입력 요소에서 추가 및 제거 될 때 트리거됩니다. 이러한 클래스에는 &lt;code&gt;.ng-pristine&lt;/code&gt; , &lt;code&gt;.ng-dirty&lt;/code&gt; , &lt;code&gt;.ng-invalid&lt;/code&gt; 및 &lt;code&gt;.ng-valid&lt;/code&gt; 및 모델 자체에서 수행되는 다른 유효성 검사가 포함됩니다. ngModel 내에서 트리거되는 애니메이션은 ngClass에서 작동하는 방식과 유사하며 CSS 전환, 키 프레임 및 JS 애니메이션을 사용하여 애니메이션을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1859b1a59db69babc41c14f59a24c34e903944a3" translate="yes" xml:space="preserve">
          <source>Annotated constructor function.</source>
          <target state="translated">주석 생성자 함수.</target>
        </trans-unit>
        <trans-unit id="f2c8d59d42e7c3db1d26f04eb9b0478f66b9b7d5" translate="yes" xml:space="preserve">
          <source>Another scenario is adding a directive programmatically to a compiled element and then executing compile again. See the following &lt;strong&gt;faulty example&lt;/strong&gt;:</source>
          <target state="translated">또 다른 시나리오는 프로그래밍 방식으로 컴파일 된 요소에 지시문을 추가 한 다음 컴파일을 다시 실행하는 것입니다. 다음 &lt;strong&gt;잘못된 예를&lt;/strong&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="969a0ecaa65eb289d9a2e9d6090f5991d37b5286" translate="yes" xml:space="preserve">
          <source>Another solution is to use a &lt;code&gt;track by&lt;/code&gt; clause, because then &lt;code&gt;ngOptions&lt;/code&gt; will track the identity of the item not by reference, but by the result of the &lt;code&gt;track by&lt;/code&gt; expression. For example, if your collection items have an id property, you would &lt;code&gt;track by item.id&lt;/code&gt;.</source>
          <target state="translated">또 다른 해결책은 사용하는 것입니다 &lt;code&gt;track by&lt;/code&gt; 한 후하기 때문에, 절 &lt;code&gt;ngOptions&lt;/code&gt; 이 참조가 아닌 항목의 신원을 추적하지만, 결과에 의해 &lt;code&gt;track by&lt;/code&gt; 식입니다. 예를 들어 컬렉션 항목에 id 속성이 있으면 &lt;code&gt;track by item.id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35ba7d28b3ce7cc7d01f098476d04b91469e1cbe" translate="yes" xml:space="preserve">
          <source>Another use-case for &lt;code&gt;ngOn&lt;/code&gt; is listening to &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events&quot;&gt;custom events&lt;/a&gt; fired by &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements&quot;&gt;custom elements&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ngOn&lt;/code&gt; 의 또 다른 사용 사례 는 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements&quot;&gt;커스텀 요소에&lt;/a&gt; 의해 발생 된 커스텀 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Guide/Events/Creating_and_triggering_events&quot;&gt;이벤트를&lt;/a&gt; 듣는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c3bdf53bf457c9fc3e92bc2d910f483e037f083e" translate="yes" xml:space="preserve">
          <source>Any JavaScript object (including arrays and primitive types) to filter.</source>
          <target state="translated">필터링 할 모든 JavaScript 객체 (배열 및 기본 유형 포함)</target>
        </trans-unit>
        <trans-unit id="de4518bc294ed54cea1f8963368f0e3c1241d4ef" translate="yes" xml:space="preserve">
          <source>Any exception emitted from the &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;listeners&lt;/a&gt; will be passed onto the &lt;a href=&quot;../service/%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">&lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;리스너&lt;/a&gt; 에서 생성 된 예외 는 &lt;a href=&quot;../service/%24exceptionhandler&quot;&gt;$ exceptionHandler&lt;/a&gt; 서비스 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="eca8010205016887bae956d6ae88be83c9bd4978" translate="yes" xml:space="preserve">
          <source>Any exceptions from the execution of the expression are forwarded to the &lt;a href=&quot;../service/%24exceptionhandler&quot;&gt;$exceptionHandler&lt;/a&gt; service.</source>
          <target state="translated">식 실행의 모든 ​​예외는 &lt;a href=&quot;../service/%24exceptionhandler&quot;&gt;$ exceptionHandler&lt;/a&gt; 서비스 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="136f3a6017ec892c22b97b38e6ce1b5592c356e0" translate="yes" xml:space="preserve">
          <source>Any external event on a directive/component will not trigger a digest while the hosting scope is suspended - even if the event handler calls &lt;code&gt;$apply()&lt;/code&gt; or &lt;code&gt;$rootScope.$digest()&lt;/code&gt;.</source>
          <target state="translated">이벤트 핸들러가 &lt;code&gt;$apply()&lt;/code&gt; 또는 &lt;code&gt;$rootScope.$digest()&lt;/code&gt; 호출하더라도 지시문 / 구성 요소의 외부 이벤트는 호스팅 범위가 일시 중단되는 동안 다이제스트를 트리거하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e3b668fd7f49731bcb3c1e067c00ebcd8e78ada" translate="yes" xml:space="preserve">
          <source>Any other characters in the &lt;code&gt;format&lt;/code&gt; string will be output as-is.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 문자열의 다른 문자 는 그대로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="422ef3807aa704fa02f9a1d220d6afe5c46512c0" translate="yes" xml:space="preserve">
          <source>Any pending &lt;code&gt;ngModelOptions&lt;/code&gt; changes will take place immediately when an enclosing form is submitted. Note that &lt;code&gt;ngClick&lt;/code&gt; events will occur before the model is updated. Use &lt;code&gt;ngSubmit&lt;/code&gt; to have access to the updated model.</source>
          <target state="translated">보류중인 &lt;code&gt;ngModelOptions&lt;/code&gt; 변경 사항은 첨부 양식을 제출하면 즉시 이루어집니다. 참고 &lt;code&gt;ngClick&lt;/code&gt; 의 모델이 업데이트되기 전에 이벤트가 발생합니다. &lt;code&gt;ngSubmit&lt;/code&gt; 을 사용 하여 업데이트 된 모델에 액세스 하십시오 .</target>
        </trans-unit>
        <trans-unit id="185b074a10fc46555a5d70fddc56be15b7205ef5" translate="yes" xml:space="preserve">
          <source>Any pending changes will take place immediately when an enclosing form is submitted via the &lt;code&gt;submit&lt;/code&gt; event. Note that &lt;code&gt;ngClick&lt;/code&gt; events will occur before the model is updated. Use &lt;code&gt;ngSubmit&lt;/code&gt; to have access to the updated model.</source>
          <target state="translated">&lt;code&gt;submit&lt;/code&gt; 이벤트 를 통해 엔 클로징 양식을 제출하면 보류중인 변경 사항이 즉시 발생합니다 . 참고 &lt;code&gt;ngClick&lt;/code&gt; 의 모델이 업데이트되기 전에 이벤트가 발생합니다. &lt;code&gt;ngSubmit&lt;/code&gt; 을 사용 하여 업데이트 된 모델에 액세스 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f782e9cb5bbdcbf217e9814a968f5294ded104d" translate="yes" xml:space="preserve">
          <source>Any time your application needs to react to a change in the current URL or if you want to change the current URL in the browser.</source>
          <target state="translated">응용 프로그램이 현재 URL의 변경에 반응하거나 브라우저에서 현재 URL을 변경하려는 경우 언제든지.</target>
        </trans-unit>
        <trans-unit id="b848ee45c3ed822427c3aa6d8e5ae09ef5cd1527" translate="yes" xml:space="preserve">
          <source>Any uncaught exception in AngularJS expressions is delegated to this service. The default implementation simply delegates to &lt;code&gt;$log.error&lt;/code&gt; which logs it into the browser console.</source>
          <target state="translated">AngularJS 표현식에서 포착되지 않은 예외는이 서비스에 위임됩니다. 기본 구현 은 브라우저 콘솔에 로그인하는 &lt;code&gt;$log.error&lt;/code&gt; 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="4b18dc74f28f4ae563b1962fe286aa979fa3353d" translate="yes" xml:space="preserve">
          <source>Any url about to be assigned to a[href] via data-binding is first normalized and turned into an absolute url. Afterwards, the url is matched against the &lt;code&gt;aHrefSanitizationTrustedUrlList&lt;/code&gt; regular expression. If a match is found, the original url is written into the dom. Otherwise, the absolute url is prefixed with &lt;code&gt;'unsafe:'&lt;/code&gt; string and only then is it written into the DOM.</source>
          <target state="translated">데이터 바인딩을 통해 a [href]에 할당 될 URL은 먼저 정규화되고 절대 URL로 변환됩니다. 그 후 URL은 &lt;code&gt;aHrefSanitizationTrustedUrlList&lt;/code&gt; 정규식 과 일치 합니다. 일치하는 항목이 있으면 원래 URL이 dom에 기록됩니다. 그렇지 않으면 절대 URL 앞에 &lt;code&gt;'unsafe:'&lt;/code&gt; 문자열 이 붙고 그 후에 만 ​​DOM에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="66d8a5005f5b7a5ddb9208ba220fe6b30ba308b2" translate="yes" xml:space="preserve">
          <source>Any url about to be assigned to a[href] via data-binding is first normalized and turned into an absolute url. Afterwards, the url is matched against the &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; regular expression. If a match is found, the original url is written into the dom. Otherwise, the absolute url is prefixed with &lt;code&gt;'unsafe:'&lt;/code&gt; string and only then is it written into the DOM.</source>
          <target state="translated">데이터 바인딩을 통해 a [href]에 할당 될 URL은 먼저 정규화되어 절대 URL로 바뀝니다. 그 후, URL은 &lt;code&gt;aHrefSanitizationWhitelist&lt;/code&gt; 정규식 과 일치 합니다. 일치하는 것이 있으면 원래 URL이 돔에 기록됩니다. 그렇지 않으면 절대 URL 앞에 &lt;code&gt;'unsafe:'&lt;/code&gt; 문자열이 붙고 DOM에만 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="2946adf5d679433deeba77fd311b6476cc2a4b48" translate="yes" xml:space="preserve">
          <source>Any url about to be assigned to img[src] via data-binding is first normalized and turned into an absolute url. Afterwards, the url is matched against the &lt;code&gt;imgSrcSanitizationTrustedUrlList&lt;/code&gt; regular expression. If a match is found, the original url is written into the dom. Otherwise, the absolute url is prefixed with &lt;code&gt;'unsafe:'&lt;/code&gt; string and only then is it written into the DOM.</source>
          <target state="translated">데이터 바인딩을 통해 img [src]에 할당 될 URL은 먼저 정규화되고 절대 URL로 바뀝니다. 그 후 URL은 &lt;code&gt;imgSrcSanitizationTrustedUrlList&lt;/code&gt; 정규식 과 일치 합니다. 일치하는 항목이 있으면 원래 URL이 dom에 기록됩니다. 그렇지 않으면 절대 URL 앞에 &lt;code&gt;'unsafe:'&lt;/code&gt; 문자열 이 붙고 그 후에 만 ​​DOM에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d6dd2884ca2cb0baa2409af0223b0a1c7c139d" translate="yes" xml:space="preserve">
          <source>Any url about to be assigned to img[src] via data-binding is first normalized and turned into an absolute url. Afterwards, the url is matched against the &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; regular expression. If a match is found, the original url is written into the dom. Otherwise, the absolute url is prefixed with &lt;code&gt;'unsafe:'&lt;/code&gt; string and only then is it written into the DOM.</source>
          <target state="translated">데이터 바인딩을 통해 img [src]에 할당 될 URL은 먼저 정규화되어 절대 URL로 바뀝니다. 그 후, URL은 &lt;code&gt;imgSrcSanitizationWhitelist&lt;/code&gt; 정규 표현식 과 일치 합니다. 일치하는 것이 있으면 원래 URL이 돔에 기록됩니다. 그렇지 않으면 절대 URL 앞에 &lt;code&gt;'unsafe:'&lt;/code&gt; 문자열이 붙고 DOM에만 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="43f5d990f54d41e9398585a561e89b92ddaadd53" translate="yes" xml:space="preserve">
          <source>Apart from the &lt;strong&gt;Top Level Component&lt;/strong&gt; (&lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt;&lt;code&gt;$routerRootComponent&lt;/code&gt;&lt;/a&gt;) which is associated with the &lt;a href=&quot;../service/%24rootrouter&quot;&gt;&lt;code&gt;$rootRouter&lt;/code&gt;&lt;/a&gt;, every &lt;strong&gt;Routing Component&lt;/strong&gt; is associated with a &lt;code&gt;ChildRouter&lt;/code&gt;, which manages the routing for that &lt;strong&gt;Routing Component&lt;/strong&gt;.</source>
          <target state="translated">외에도에서 &lt;strong&gt;최상위 요소&lt;/strong&gt; ( &lt;a href=&quot;../service/%24routerrootcomponent&quot;&gt; &lt;code&gt;$routerRootComponent&lt;/code&gt; &lt;/a&gt; 와 관련된) &lt;a href=&quot;../service/%24rootrouter&quot;&gt; &lt;code&gt;$rootRouter&lt;/code&gt; &lt;/a&gt; , 모든 &lt;strong&gt;라우팅 구성 요소는&lt;/strong&gt; 와 관련된 &lt;code&gt;ChildRouter&lt;/code&gt; 그에 대한 라우팅 관리, &lt;strong&gt;라우팅 구성 요소를&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e402e007d5cf0eceb8bba2547d33af36db64dcdf" translate="yes" xml:space="preserve">
          <source>Apart from the ternary operator (&lt;code&gt;a ? b : c&lt;/code&gt;), you cannot write a control flow statement in an expression. The reason behind this is core to the AngularJS philosophy that application logic should be in controllers, not the views. If you need a real conditional, loop, or to throw from a view expression, delegate to a JavaScript method instead.</source>
          <target state="translated">삼항 연산자 ( &lt;code&gt;a ? b : c&lt;/code&gt; ) 외에는 식에 제어 흐름 문을 작성할 수 없습니다. 그 이유는 애플리케이션 로직이 뷰가 아닌 컨트롤러에 있어야한다는 AngularJS 철학의 핵심입니다. 실제 조건부, 루프 또는 뷰 표현식에서 던져야하는 경우 대신 JavaScript 메소드에 위임하십시오.</target>
        </trans-unit>
        <trans-unit id="d71de8152541f4a1b7fda48b87f3fe315656e14c" translate="yes" xml:space="preserve">
          <source>Application Structure</source>
          <target state="translated">응용 프로그램 구조</target>
        </trans-unit>
        <trans-unit id="7fe601ec2e88419589f9146418e8e7af8c971aaa" translate="yes" xml:space="preserve">
          <source>Application Structure &amp;amp; Style Guides</source>
          <target state="translated">응용 프로그램 구조 및 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="e47fe9ae51aadfdd2d85b572285710bb9d6644ca" translate="yes" xml:space="preserve">
          <source>Application developers are free to define their own services by registering the service's name and &lt;strong&gt;service factory function&lt;/strong&gt;, with an AngularJS module.</source>
          <target state="translated">애플리케이션 개발자는 서비스 이름 및 &lt;strong&gt;서비스 팩토리 기능을&lt;/strong&gt; AngularJS 모듈 에 등록하여 자신의 서비스를 자유롭게 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="157fcee1bf70241b8658bd19f019bbfffbd57a6b" translate="yes" xml:space="preserve">
          <source>Application developers will rarely need to call this method directly. It is used internally, by &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setValidity.html&quot;&gt;NgModelController.$setValidity()&lt;/a&gt;, to propagate a control's validity state to the parent &lt;code&gt;FormController&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 개발자는이 메서드를 직접 호출 할 필요가 거의 없습니다. 컨트롤의 유효성 상태를 부모 &lt;code&gt;FormController&lt;/code&gt; 에 전파하기 위해 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setValidity.html&quot;&gt;NgModelController. $ setValidity ()에&lt;/a&gt; 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="53162fc7151bee0f7c7ba8c31bf1c2355dfc4550" translate="yes" xml:space="preserve">
          <source>Architecture, file structure, components, one-way dataflow and best practices</source>
          <target state="translated">아키텍처, 파일 구조, 구성 요소, 단방향 데이터 흐름 및 모범 사례</target>
        </trans-unit>
        <trans-unit id="c83a0088927a1633acaed10f539ea98bb1e204c3" translate="yes" xml:space="preserve">
          <source>Argument names</source>
          <target state="translated">인수 이름</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="f2d1a651267110941a7e3eba6df9faa2ed02c04d" translate="yes" xml:space="preserve">
          <source>Array containing URLs whose origins are trusted to receive the XSRF token. See the &lt;a href=&quot;../service/%24http#security-considerations.html&quot;&gt;Security Considerations&lt;/a&gt; sections for more details on XSRF.</source>
          <target state="translated">출처가 XSRF 토큰을 수신하도록 신뢰할 수있는 URL을 포함하는 배열입니다. XSRF에 대한 자세한 내용 은 &lt;a href=&quot;../service/%24http#security-considerations.html&quot;&gt;보안 고려 사항&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32c9d1434f0741f3d270e0c58ec7b6e77a762138" translate="yes" xml:space="preserve">
          <source>Array containing service factories for all synchronous or asynchronous &lt;a href=&quot;../service/%24http&quot;&gt;$http&lt;/a&gt; pre-processing of request or postprocessing of responses.</source>
          <target state="translated">요청의 모든 동기 또는 비동기 &lt;a href=&quot;../service/%24http&quot;&gt;$ http&lt;/a&gt; 사전 처리 또는 응답 후 처리를 위한 서비스 팩토리를 포함하는 배열 .</target>
        </trans-unit>
        <trans-unit id="557b5657af00498abd22b4555192836bb6d9557e" translate="yes" xml:space="preserve">
          <source>Array of config objects for currently pending requests. This is primarily meant to be used for debugging purposes.</source>
          <target state="translated">현재 보류중인 요청에 대한 구성 객체의 배열입니다. 이것은 주로 디버깅 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dda0d43b5dd90aadcea7413aa4213f341abd201c" translate="yes" xml:space="preserve">
          <source>Array of expressions that will be individually watched using &lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$watch()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;%24rootscope.scope#%24watch.html&quot;&gt;$ watch ()를&lt;/a&gt; 사용하여 개별적으로 볼 표현식 배열</target>
        </trans-unit>
        <trans-unit id="16a28eaf7d1396d70aa69a55073aa5ed0d533006" translate="yes" xml:space="preserve">
          <source>Array of functions to execute whenever a change to &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;$viewValue&lt;/code&gt;&lt;/a&gt; has caused a change to &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt;&lt;code&gt;$modelValue&lt;/code&gt;&lt;/a&gt;. It is called with no arguments, and its return value is ignored. This can be used in place of additional $watches against the model value.</source>
          <target state="translated">&lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;$viewValue&lt;/code&gt; &lt;/a&gt; 변경으로 인해 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt; &lt;code&gt;$modelValue&lt;/code&gt; &lt;/a&gt; 변경이 발생할 때마다 실행할 함수 배열입니다 . 인수없이 호출되며 리턴 값은 무시됩니다. 모델 값에 대해 추가 $ watch 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1424ab51b27d79e61339e273ce91fa793a8714e8" translate="yes" xml:space="preserve">
          <source>Array of functions to execute, as a pipeline, whenever the bound ngModel expression changes programmatically. The &lt;code&gt;$formatters&lt;/code&gt; are not called when the value of the control is changed by user interaction.</source>
          <target state="translated">바인딩 된 ngModel 표현식이 프로그래밍 방식으로 변경 될 때마다 파이프 라인으로 실행할 함수의 배열입니다. &lt;code&gt;$formatters&lt;/code&gt; 컨트롤의 값이 사용자 상호 작용에 의해 변경 될 때 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02b2ca54d88c554ca4e1087c37aecbf0eac12226" translate="yes" xml:space="preserve">
          <source>Array of functions to execute, as a pipeline, whenever the control updates the ngModelController with a new &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt;&lt;code&gt;$viewValue&lt;/code&gt;&lt;/a&gt; from the DOM, usually via user input. See &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt;&lt;code&gt;$setViewValue()&lt;/code&gt;&lt;/a&gt; for a detailed lifecycle explanation. Note that the &lt;code&gt;$parsers&lt;/code&gt; are not called when the bound ngModel expression changes programmatically.</source>
          <target state="translated">컨트롤이 일반적으로 사용자 입력을 통해 DOM에서 새 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24viewValue.html&quot;&gt; &lt;code&gt;$viewValue&lt;/code&gt; &lt;/a&gt; ngModelController를 업데이트 할 때마다 파이프 라인으로 실행할 함수 배열입니다 . 자세한 수명주기 설명 은 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24setViewValue.html&quot;&gt; &lt;code&gt;$setViewValue()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 있습니다 &lt;code&gt;$parsers&lt;/code&gt; 결합 된 ngModel 표현 프로그래밍 변경 될 때 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8aa61e073a4c0baab4b05c142ba71754be4dbe3a" translate="yes" xml:space="preserve">
          <source>Array of keys to assign to regex matches in request url described above.</source>
          <target state="translated">위에서 설명한 요청 URL에서 정규식 일치에 할당 할 키 배열입니다.</target>
        </trans-unit>
        <trans-unit id="dce6ae97df369ff12e95dc68ff11901fddbd2a92" translate="yes" xml:space="preserve">
          <source>Array of keys to assign to regex matches in request url described on &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;$httpBackend mock&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;$ httpBackend mock&lt;/a&gt; 에 설명 된 요청 URL에서 정규식 일치에 할당 할 키 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="9c6621304506b22ca9a68ad77ea41a030e17c566" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#debug.html&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#debug.html&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="57ea05d19a68d43106644cbce6da8d34187676e8" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#error.html&quot;&gt;&lt;code&gt;error()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#error.html&quot;&gt; &lt;code&gt;error()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="8151a9ffd2283d4619d532eaaac736b5d01ab54f" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#info.html&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#info.html&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="69d8c243e53bd946f150a38a73b18a8f0819eed0" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#log.html&quot;&gt;&lt;code&gt;log()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#log.html&quot;&gt; &lt;code&gt;log()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="787bf1b8fa54bd835ba5079f6b4ece639ed7b9ed" translate="yes" xml:space="preserve">
          <source>Array of messages logged using &lt;a href=&quot;../../ng/service/%24log#warn.html&quot;&gt;&lt;code&gt;warn()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24log#warn.html&quot;&gt; &lt;code&gt;warn()&lt;/code&gt; &lt;/a&gt; 사용하여 기록 된 메시지 배열 .</target>
        </trans-unit>
        <trans-unit id="0fb4bcb40bc5316de7a202017017eaefa3df7c7b" translate="yes" xml:space="preserve">
          <source>Array/array-like, string or number to be limited.</source>
          <target state="translated">배열 / 배열과 같은 문자열 또는 숫자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="647955f61de2f76c3b41b2e5804a604deead0bcb" translate="yes" xml:space="preserve">
          <source>Articles, Videos, and Projects</source>
          <target state="translated">기사, 비디오 및 프로젝트</target>
        </trans-unit>
        <trans-unit id="7275de9628a1cc80191841f09611cfb2af505dfb" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;ngRepeat&lt;/code&gt; does its thing, each time a new item is added into the list, &lt;code&gt;ngRepeat&lt;/code&gt; will add an &lt;code&gt;ng-enter&lt;/code&gt; class to the element that is being added. When removed it will apply an &lt;code&gt;ng-leave&lt;/code&gt; class and when moved around it will apply an &lt;code&gt;ng-move&lt;/code&gt; class.</source>
          <target state="translated">으로 &lt;code&gt;ngRepeat&lt;/code&gt; 가 그 일을, 새 항목이 목록에 추가 될 때마다, &lt;code&gt;ngRepeat&lt;/code&gt; 이 추가됩니다 &lt;code&gt;ng-enter&lt;/code&gt; 추가되는 요소에 클래스를. 제거하면 &lt;code&gt;ng-leave&lt;/code&gt; 클래스가 적용되고 &lt;code&gt;ng-move&lt;/code&gt; 하면 ng-move 클래스 가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0695df435dac0ab2843253e78e2827b4f1a7f956" translate="yes" xml:space="preserve">
          <source>As a best practice, consider adding an &lt;code&gt;ng-strict-di&lt;/code&gt; directive on the same element as &lt;code&gt;ng-app&lt;/code&gt;:</source>
          <target state="translated">모범 사례 로 &lt;code&gt;ng-app&lt;/code&gt; 와 동일한 요소에 &lt;code&gt;ng-strict-di&lt;/code&gt; 지시문을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e65d701eca158f6dc26450435f4a299e994565af" translate="yes" xml:space="preserve">
          <source>As a result of &lt;code&gt;ngBind&lt;/code&gt;, &lt;code&gt;ngBindHtml&lt;/code&gt; or &lt;code&gt;{{...}}&lt;/code&gt; interpolations, binding data and CSS class &lt;code&gt;ng-binding&lt;/code&gt; are attached to the corresponding element.</source>
          <target state="translated">&lt;code&gt;ngBind&lt;/code&gt; , &lt;code&gt;ngBindHtml&lt;/code&gt; 또는 &lt;code&gt;{{...}}&lt;/code&gt; 보간 결과 바인딩 데이터 및 CSS 클래스 &lt;code&gt;ng-binding&lt;/code&gt; 이 해당 요소에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="67db5c7bc5d719b0ac857083a55a856d06e77a01" translate="yes" xml:space="preserve">
          <source>As a result of that, &lt;a href=&quot;../directive/ngview&quot;&gt;ngView&lt;/a&gt; creates new scope and reinstantiates the controller.</source>
          <target state="translated">그 결과 &lt;a href=&quot;../directive/ngview&quot;&gt;ngView는&lt;/a&gt; 새로운 범위를 생성하고 컨트롤러를 다시 인스턴스화 합니다.</target>
        </trans-unit>
        <trans-unit id="2325450d98839f1a7cf5c6905e3d4f5721cb3fd3" translate="yes" xml:space="preserve">
          <source>As already mentioned in the intro, the Provider recipe is the core recipe type and all the other recipe types are just syntactic sugar on top of it. It is the most verbose recipe with the most abilities, but for most services it's overkill.</source>
          <target state="translated">서론에서 이미 언급했듯이, 제공자 레시피는 핵심 레시피 유형이며 다른 모든 레시피 유형은 그 위에 구문 설탕입니다. 가장 많은 기능을 갖춘 가장 장황한 레시피이지만 대부분의 서비스에는 과잉입니다.</target>
        </trans-unit>
        <trans-unit id="6ef852d71fd5d9cc1d2ec23dccfd5e8aa5b6791e" translate="yes" xml:space="preserve">
          <source>As already mentioned, the component helper makes it easier to structure your application with a component-based architecture. But what makes a component beyond the options that the component helper has?</source>
          <target state="translated">이미 언급했듯이 구성 요소 도우미를 사용하면 구성 요소 기반 아키텍처로 응용 프로그램을보다 쉽게 ​​구성 할 수 있습니다. 그러나 구성 요소 도우미가 제공하는 옵션을 넘어서 구성 요소를 만드는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="66190f01e31088a12a65092a98ca24475f550877" translate="yes" xml:space="preserve">
          <source>As an array of injection names, where the last item in the array is the function to call.</source>
          <target state="translated">주입 이름의 배열로서, 배열의 마지막 항목은 호출 할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ab19f6eb4ea00d87f713b79c4d8c813abaeab501" translate="yes" xml:space="preserve">
          <source>As an example, &lt;a href=&quot;../directive/ngbindhtml&quot;&gt;ngBindHtml&lt;/a&gt; uses &lt;a href=&quot;%24sce#parseAsHtml.html&quot;&gt;$sce.parseAsHtml(binding expression)&lt;/a&gt;. Here's the actual code (slightly simplified):</source>
          <target state="translated">예를 들어 &lt;a href=&quot;../directive/ngbindhtml&quot;&gt;ngBindHtml&lt;/a&gt; 은 &lt;a href=&quot;%24sce#parseAsHtml.html&quot;&gt;$ sce.parseAsHtml (binding expression)을 사용&lt;/a&gt; 합니다. 실제 코드는 다음과 같습니다 (약간 단순화).</target>
        </trans-unit>
        <trans-unit id="07153bae5bff22d9000ae9eab846630c563316f9" translate="yes" xml:space="preserve">
          <source>As applications grow in size and complexity, it becomes unrealistic to rely on manual testing to verify the correctness of new features, catch bugs and notice regressions. Unit tests are the first line of defense for catching bugs, but sometimes issues come up with integration between components which can't be captured in a unit test. End-to-end tests are made to find these problems.</source>
          <target state="translated">응용 프로그램의 크기와 복잡성이 증가함에 따라 수동 테스트를 통해 새로운 기능의 정확성을 확인하고 버그를 포착하며 회귀를 발견하는 것은 비현실적입니다. 단위 테스트는 버그를 잡기위한 첫 번째 방어선이지만 단위 테스트에서 캡처 할 수없는 구성 요소 간의 통합으로 문제가 발생하는 경우가 있습니다. 이러한 문제를 찾기 위해 종단 간 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6d7a55120448d479c287c566c8d98fb08b5ccd50" translate="yes" xml:space="preserve">
          <source>As discussed in the &lt;a href=&quot;concepts&quot;&gt;Concepts&lt;/a&gt; section of this guide, any objects (or primitives) assigned to the scope become model properties. Any methods assigned to the scope are available in the template/view, and can be invoked via AngularJS expressions and &lt;code&gt;ng&lt;/code&gt; event handler directives (e.g. &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;ngClick&lt;/a&gt;).</source>
          <target state="translated">이 안내서 의 &lt;a href=&quot;concepts&quot;&gt;개념&lt;/a&gt; 섹션 에서 설명한대로 범위에 할당 된 모든 객체 (또는 기본 요소)는 모델 속성이됩니다. 범위에 지정된 모든 메소드는 템플리트 /보기에서 사용 가능하며 AngularJS 표현식 및 &lt;code&gt;ng&lt;/code&gt; 이벤트 핸들러 지시문 (예 : &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;ngClick&lt;/a&gt; )을 통해 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="543566b9bcbd90fce5b7b69e2eb29f4197ad9e3d" translate="yes" xml:space="preserve">
          <source>As mentioned in the syntax for plural and select, the embedded messages can contain AngularJS interpolation syntax. Since you can use MessageFormat extensions in AngularJS interpolation, this allows you to nest plural and gender expressions in any order.</source>
          <target state="translated">복수 및 선택 구문에서 언급했듯이 임베드 된 메시지에는 AngularJS 보간 구문이 포함될 수 있습니다. AngularJS 보간에서 MessageFormat 확장을 사용할 수 있으므로 여러 식과 성별 식을 임의의 순서로 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a72e1e24aff22427a315dbc60e5118663742eedc" translate="yes" xml:space="preserve">
          <source>As new &lt;code&gt;action&lt;/code&gt;s are inserted, the template &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element needs to be cloned and inserted into &lt;code&gt;ul&lt;/code&gt;. But cloning the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is not enough. It also needs to compile the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; so that its directives, like &lt;code&gt;{{action.description}}&lt;/code&gt;, evaluate against the right &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;code&gt;action&lt;/code&gt; 이 삽입되면 템플릿 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 복제하여 &lt;code&gt;ul&lt;/code&gt; 에 삽입해야합니다 . 그러나 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 복제하는 것만으로는 충분하지 않습니다. 또한 컴파일 할 필요가 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 그래서 그 지시어와 같은 &lt;code&gt;{{action.description}}&lt;/code&gt; 오른쪽에 대한 평가 &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;범위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ec13f23302b7d1dd1ac45a02e83f66da3e707c4" translate="yes" xml:space="preserve">
          <source>As of version 1.2, AngularJS ships with SCE enabled by default.</source>
          <target state="translated">버전 1.2부터 AngularJS는 기본적으로 SCE가 활성화 된 상태로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b8080a15a0ddec2d77c43863b3384640745b7f2b" translate="yes" xml:space="preserve">
          <source>As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application is being developed with the real backend api replaced with a mock, it is often desirable for certain category of requests to bypass the mock and issue a real http request (e.g. to fetch templates or static files from the webserver). To configure the backend with this behavior use the &lt;code&gt;passThrough&lt;/code&gt; request handler of &lt;code&gt;when&lt;/code&gt; instead of &lt;code&gt;respond&lt;/code&gt;.</source>
          <target state="translated">단위 테스트와는 달리 종단 간 테스트 시나리오 또는 실제 백엔드 API를 모의로 대체하여 응용 프로그램을 개발하는 시나리오에서는 특정 범주의 요청이 모의 및 문제를 우회하는 것이 바람직합니다. 실제 http 요청 (예 : 웹 서버에서 템플릿 또는 정적 파일 가져 오기) 이 동작으로 백엔드를 구성하려면 &lt;code&gt;respond&lt;/code&gt; 대신 &lt;code&gt;when&lt;/code&gt; 의 &lt;code&gt;passThrough&lt;/code&gt; 요청 핸들러를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f031cf7748d485e3e97d83ef88851314a68f2046" translate="yes" xml:space="preserve">
          <source>As the name suggests, the &lt;strong&gt;isolate scope&lt;/strong&gt; of the directive isolates everything except models that you've explicitly added to the &lt;code&gt;scope: {}&lt;/code&gt; hash object. This is helpful when building reusable components because it prevents a component from changing your model state except for the models that you explicitly pass in.</source>
          <target state="translated">이름에서 알 수 있듯이 지시문 의 &lt;strong&gt;격리 범위&lt;/strong&gt; 는 명시 적으로 &lt;code&gt;scope: {}&lt;/code&gt; 추가 한 모델을 제외한 모든 것을 격리합니다 : {} 해시 개체. 재사용 가능한 컴포넌트를 빌드 할 때 명시 적으로 전달한 모델을 제외하고 컴포넌트가 모델 상태를 변경하지 못하게하므로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1d9cf083e1eebce068119ed3315973988cd233c8" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;repeated-item&lt;/code&gt; class is present on the element that will be repeated and this class will be used as a reference within our application's CSS and/or JavaScript animation code to tell AngularJS to perform an animation.</source>
          <target state="translated">보시다시피 &lt;code&gt;repeated-item&lt;/code&gt; 클래스는 반복 될 요소에 존재 하며이 클래스는 응용 프로그램의 CSS 및 / 또는 JavaScript 애니메이션 코드 내에서 참조로 사용되어 AngularJS가 애니메이션을 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="de4fc7d19e5e0a6d0ac18488a8fccba793d3b358" translate="yes" xml:space="preserve">
          <source>Asking for dependencies solves the issue of hard coding, but it also means that the injector needs to be passed throughout the application. Passing the injector breaks the &lt;a href=&quot;http://en.wikipedia.org/wiki/Law_of_Demeter&quot;&gt;Law of Demeter&lt;/a&gt;. To remedy this, we use a declarative notation in our HTML templates, to hand the responsibility of creating components over to the injector, as in this example:</source>
          <target state="translated">종속성을 요청하면 하드 코딩 문제가 해결되지만 인젝터가 애플리케이션 전체에 전달되어야합니다. 인젝터를 통과하면 &lt;a href=&quot;http://en.wikipedia.org/wiki/Law_of_Demeter&quot;&gt;데메테르&lt;/a&gt; 의 법칙이 위반 됩니다. 이를 해결하기 위해 HTML 템플릿에 선언적 표기법을 사용하여 다음 예제와 같이 인젝터에 구성 요소를 생성하는 책임을 넘깁니다.</target>
        </trans-unit>
        <trans-unit id="602dca52ef2fb38805f8af26bdf588f7fcb1e4e4" translate="yes" xml:space="preserve">
          <source>Assert that all of the logging methods have no logged messages. If any messages are present, an exception is thrown.</source>
          <target state="translated">모든 로깅 방법에 기록 된 메시지가 없는지 확인하십시오. 메시지가 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e32c36e98ffeeb8e37e062d05cb463a7f175dbe" translate="yes" xml:space="preserve">
          <source>Assignable AngularJS expression to data-bind to.</source>
          <target state="translated">데이터 바인딩 할 수있는 AngularJS 표현식.</target>
        </trans-unit>
        <trans-unit id="fa624932ddb296ac5007e5591dd9bfb041b6cb1e" translate="yes" xml:space="preserve">
          <source>Assigning a property to &lt;code&gt;$scope&lt;/code&gt; creates or updates the model.</source>
          <target state="translated">&lt;code&gt;$scope&lt;/code&gt; 속성을 할당 하면 모델이 생성되거나 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="adc58ef773100f1ac890b76704547adbe78e189d" translate="yes" xml:space="preserve">
          <source>Associates the provided element with a host parent element to allow the element to be animated even if it exists outside of the DOM structure of the AngularJS application. By doing so, any animation triggered via &lt;code&gt;$animate&lt;/code&gt; can be issued on the element despite being outside the realm of the application or within another application. Say for example if the application was bootstrapped on an element that is somewhere inside of the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag, but we wanted to allow for an element to be situated as a direct child of &lt;code&gt;document.body&lt;/code&gt;, then this can be achieved by pinning the element via &lt;code&gt;$animate.pin(element)&lt;/code&gt;. Keep in mind that calling &lt;code&gt;$animate.pin(element, parentElement)&lt;/code&gt; will not actually insert into the DOM anywhere; it will just create the association.</source>
          <target state="translated">제공된 요소를 호스트 상위 요소와 연관시켜 요소가 AngularJS 애플리케이션의 DOM 구조 외부에있는 경우에도 애니메이션을 적용 할 수 있습니다. 이렇게하면 &lt;code&gt;$animate&lt;/code&gt; 를 통해 트리거 된 모든 애니메이션 은 응용 프로그램 영역 외부 나 다른 응용 프로그램 내에 있더라도 요소에서 실행될 수 있습니다. 예를 들어, &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 태그 안에있는 요소에서 응용 프로그램을 부트 스트랩 했지만, 요소를 &lt;code&gt;document.body&lt;/code&gt; 의 직접적인 자식으로 배치하고 싶었다면 이를 고정시킬 수 있습니다. &lt;code&gt;$animate.pin(element)&lt;/code&gt; 를 통한 요소 . &lt;code&gt;$animate.pin(element, parentElement)&lt;/code&gt; 호출실제로 어디서나 DOM에 삽입하지 않습니다. 연결을 만들뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8a319250e7a62a6449653025f2ab2f88895ac77d" translate="yes" xml:space="preserve">
          <source>Asynchronous Loading</source>
          <target state="translated">비동기식 로딩</target>
        </trans-unit>
        <trans-unit id="5bbd06015f69fbcbcdb24725f6bb1567275ce22b" translate="yes" xml:space="preserve">
          <source>At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS's &lt;strong&gt;HTML compiler&lt;/strong&gt; (&lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;&lt;code&gt;$compile&lt;/code&gt;&lt;/a&gt;) to attach a specified behavior to that DOM element (e.g. via event listeners), or even to transform the DOM element and its children.</source>
          <target state="translated">상위 수준에서 지시문은 DOM 요소 (예 : 속성, 요소 이름, 주석 또는 CSS 클래스)의 마커로 AngularJS의 &lt;strong&gt;HTML 컴파일러&lt;/strong&gt; ( &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt; &lt;code&gt;$compile&lt;/code&gt; &lt;/a&gt; )에게 지정된 동작을 해당 DOM 요소에 첨부하도록 (예 : 이벤트 리스너를 통해) 지시합니다. 또는 DOM 요소와 해당 하위 요소를 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fded031893dd4b58525b3e28e5c62e3f06e82a91" translate="yes" xml:space="preserve">
          <source>At first glance, it looks like removing the original &lt;code&gt;addMouseover&lt;/code&gt; attribute is all there is needed to make this example work. However, if the directive element or its children have other directives attached, they will be compiled and linked again, because the compiler doesn't keep track of which directives have been assigned to which elements.</source>
          <target state="translated">언뜻보기에 원래 &lt;code&gt;addMouseover&lt;/code&gt; 속성을 제거하면 이 예제를 작동시키는 데 필요한 모든 것 같습니다. 그러나 지시문 요소 나 그 자식에 다른 지시문이 첨부되어 있으면 컴파일러는 어떤 지시문이 어떤 요소에 할당되었는지 추적하지 않기 때문에 다시 컴파일되고 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="16d656728db993e2d91d65f16fd40b8735a327f3" translate="yes" xml:space="preserve">
          <source>At first it might not be obvious why this extra complexity is worth the trouble. The payoff comes in the way of guarantees that promise and deferred APIs make, see &lt;a href=&quot;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md&quot;&gt;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md&lt;/a&gt;.</source>
          <target state="translated">처음에는 왜 이러한 추가 복잡성이 문제의 가치가 있는지 분명하지 않을 수 있습니다. 그 대가는 약속 및 지연된 API가 보장하는 방식으로 이루어집니다 ( &lt;a href=&quot;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md&quot;&gt;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e100b35ab6c0fe1f3d2cdccfdad5402c15024472" translate="yes" xml:space="preserve">
          <source>At runtime the &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;&lt;code&gt;ngRepeat&lt;/code&gt;&lt;/a&gt; watches the expression and as items are added to the array it clones the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element, creates a new &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt; for the cloned &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element and calls the link function on the cloned &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">런타임시 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt; &lt;code&gt;ngRepeat&lt;/code&gt; 는&lt;/a&gt; 식 시계 및 항목이 배열에 추가되는 것이 클론 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 신규 작성 &lt;a href=&quot;../api/ng/type/%24rootscope.scope&quot;&gt;영역&lt;/a&gt; 복제에 대한 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소 및 복제에 링크 기능을 호출 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31dab9e3efd9dd8deab1758a62454f3f213bdba8" translate="yes" xml:space="preserve">
          <source>At runtime: &lt;a href=&quot;../api/ng/service/%24animate#enabled.html&quot;&gt;$animate.enabled()&lt;/a&gt;</source>
          <target state="translated">런타임시 : &lt;a href=&quot;../api/ng/service/%24animate#enabled.html&quot;&gt;$ animate.enabled ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f67e221630aa693d76075a22c1ba1f64147ff501" translate="yes" xml:space="preserve">
          <source>At the end of &lt;code&gt;$apply&lt;/code&gt;, AngularJS performs a &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; cycle on the root scope, which then propagates throughout all child scopes. During the &lt;code&gt;$digest&lt;/code&gt; cycle, all &lt;code&gt;$watch&lt;/code&gt;ed expressions or functions are checked for model mutation and if a mutation is detected, the &lt;code&gt;$watch&lt;/code&gt; listener is called.</source>
          <target state="translated">&lt;code&gt;$apply&lt;/code&gt; 의 끝 에서 AngularJS 는 루트 범위에서 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24digest.html&quot;&gt;$ 다이제스트&lt;/a&gt; 주기를 수행 한 다음 모든 하위 범위에 전파됩니다. &lt;code&gt;$digest&lt;/code&gt; 주기 동안 모든 &lt;code&gt;$watch&lt;/code&gt; watched 표현식 또는 함수는 모델 돌연변이를 검사하고 돌연변이가 감지되면 &lt;code&gt;$watch&lt;/code&gt; 리스너가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="811060f5b400ba59f43a01f37e35d2b7526adfec" translate="yes" xml:space="preserve">
          <source>At this point you may wonder why the compile process has separate compile and link phases. The short answer is that compile and link separation is needed any time a change in a model causes a change in the &lt;strong&gt;structure&lt;/strong&gt; of the DOM.</source>
          <target state="translated">이 시점에서 컴파일 프로세스에 별도의 컴파일 및 링크 단계가있는 이유가 궁금 할 수 있습니다. 짧은 대답은 모델의 변경으로 인해 DOM &lt;strong&gt;구조&lt;/strong&gt; 가 변경 될 때마다 컴파일 및 링크 분리가 필요하다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7d38f6daaef849032ab49cae508751fbd896de2c" translate="yes" xml:space="preserve">
          <source>Attaching new behavior to DOM elements, such as DOM event handling.</source>
          <target state="translated">DOM 이벤트 처리와 같은 DOM 요소에 새로운 동작 추가</target>
        </trans-unit>
        <trans-unit id="f18ef5bd3a9704f6d7f339924ddd7e7a2c353300" translate="yes" xml:space="preserve">
          <source>Attribute values are not merged</source>
          <target state="translated">속성 값이 병합되지 않습니다</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="9cf83f638488303498c3d24f3e3e27d978f4e28e" translate="yes" xml:space="preserve">
          <source>Attributes such as &lt;code&gt;disabled&lt;/code&gt; are called &lt;code&gt;boolean&lt;/code&gt; attributes, because their presence means &lt;code&gt;true&lt;/code&gt; and their absence means &lt;code&gt;false&lt;/code&gt;. We cannot use normal attribute bindings with them, because the HTML specification does not require browsers to preserve the values of boolean attributes. This means that if we put an AngularJS interpolation expression into such an attribute then the binding information would be lost, because the browser ignores the attribute value.</source>
          <target state="translated">&lt;code&gt;disabled&lt;/code&gt; 와 같은 속성은 존재 여부가 &lt;code&gt;true&lt;/code&gt; 이고 부재가 &lt;code&gt;false&lt;/code&gt; 를 의미하므로 &lt;code&gt;boolean&lt;/code&gt; 속성 이라고 합니다 . HTML 스펙에는 브라우저가 부울 속성 값을 보존 할 필요가 없으므로 일반적인 속성 바인딩을 사용할 수 없습니다. 즉, AngularJS 보간 표현식을 이러한 속성에 넣으면 브라우저가 속성 값을 무시하기 때문에 바인딩 정보가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="ec94b23d4cf5e5552507a5899b9e011b45a154d6" translate="yes" xml:space="preserve">
          <source>Augment the $delegate</source>
          <target state="translated">$ 대리인 보강</target>
        </trans-unit>
        <trans-unit id="41869ae502e1528f5e860a994dc5f7a5715f3cc3" translate="yes" xml:space="preserve">
          <source>Automatic Initialization</source>
          <target state="translated">자동 초기화</target>
        </trans-unit>
        <trans-unit id="cf01601ec7b755876c4207df91db99430e5fd491" translate="yes" xml:space="preserve">
          <source>Automatic value adjustment also means that a range input element can never have the &lt;code&gt;required&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, or &lt;code&gt;max&lt;/code&gt; errors.</source>
          <target state="translated">자동 값 조정은 또한 범위 입력 요소가 &lt;code&gt;required&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; 또는 &lt;code&gt;max&lt;/code&gt; 오류를 가질 수 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="1105b837870d87e705ed3933cf58b23765b1ac5f" translate="yes" xml:space="preserve">
          <source>Available task types:</source>
          <target state="translated">사용 가능한 작업 유형 :</target>
        </trans-unit>
        <trans-unit id="b158354eab7dcfad40f037bfff4be8583770ec91" translate="yes" xml:space="preserve">
          <source>Back to the initial question: How does the &lt;code&gt;InvoiceController&lt;/code&gt; get a reference to the &lt;code&gt;currencyConverter&lt;/code&gt; function? In AngularJS, this is done by simply defining arguments on the constructor function. With this, the injector is able to create the objects in the right order and pass the previously created objects into the factories of the objects that depend on them. In our example, the &lt;code&gt;InvoiceController&lt;/code&gt; has an argument named &lt;code&gt;currencyConverter&lt;/code&gt;. By this, AngularJS knows about the dependency between the controller and the service and calls the controller with the service instance as argument.</source>
          <target state="translated">초기 질문으로 돌아 가기 : &lt;code&gt;InvoiceController&lt;/code&gt; 는 &lt;code&gt;currencyConverter&lt;/code&gt; 함수에 대한 참조를 어떻게 얻 습니까? AngularJS에서는 생성자 함수에 인수를 정의하기 만하면됩니다. 이를 통해 인젝터는 올바른 순서로 오브젝트를 작성하고 이전에 작성된 오브젝트를 종속 오브젝트의 팩토리로 전달할 수 있습니다. 이 예에서 &lt;code&gt;InvoiceController&lt;/code&gt; 에는 &lt;code&gt;currencyConverter&lt;/code&gt; 라는 인수가 있습니다. 이를 통해 AngularJS는 컨트롤러와 서비스 간의 종속성에 대해 알고 서비스 인스턴스를 인수로 사용하여 컨트롤러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d9c883a905731bc3ab1e5b1797dcc17a576c4565" translate="yes" xml:space="preserve">
          <source>Back to top</source>
          <target state="translated">맨 위로</target>
        </trans-unit>
        <trans-unit id="667908f902838bdc241aa234ee74229ead2f1562" translate="yes" xml:space="preserve">
          <source>Backend definitions</source>
          <target state="translated">백엔드 정의</target>
        </trans-unit>
        <trans-unit id="dd04a0ffb87db83b44ae4c32b0c0f5c8813e323e" translate="yes" xml:space="preserve">
          <source>Backend definitions allow you to define a fake backend for your application which doesn't assert if a particular request was made or not, it just returns a trained response if a request is made. The test will pass whether or not the request gets made during testing.</source>
          <target state="translated">백엔드 정의를 사용하면 특정 요청이 있었는지 여부를 주장하지 않고 요청이 이루어진 경우 훈련 된 응답 만 반환하는 애플리케이션에 대한 가짜 백엔드를 정의 할 수 있습니다. 테스트는 테스트 중에 요청이 이루어 졌는지 여부를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="59f299125e1e43938ff9695b8c50f5b33268fea4" translate="yes" xml:space="preserve">
          <source>Base href constraints</source>
          <target state="translated">기본 href 제약</target>
        </trans-unit>
        <trans-unit id="f8401938c390cf3e82bf20e8f5b954ce826b2925" translate="yes" xml:space="preserve">
          <source>Based on the context, other options may exist to mark a value as trusted / configure the behavior of &lt;a href=&quot;../service/%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt;. For example, to restrict the &lt;code&gt;RESOURCE_URL&lt;/code&gt; context to specific origins, use the &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;resourceUrlWhitelist()&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;resourceUrlBlacklist()&lt;/a&gt;.</source>
          <target state="translated">컨텍스트를 기반으로 &lt;a href=&quot;../service/%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; 의 동작을 신뢰 / 구성으로 표시하는 다른 옵션이있을 수 있습니다 . 예를 들어, &lt;code&gt;RESOURCE_URL&lt;/code&gt; 컨텍스트를 특정 출처 로 제한 하려면 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;resourceUrlWhitelist ()&lt;/a&gt; 및 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;resourceUrlBlacklist ()를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="966128c4ac23ffe813426a6e232622f047cdaa69" translate="yes" xml:space="preserve">
          <source>Based on the context, other options may exist to mark a value as trusted / configure the behavior of &lt;a href=&quot;../service/%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt;. For example, to restrict the &lt;code&gt;RESOURCE_URL&lt;/code&gt; context to specific origins, use the &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;trustedResourceUrlList()&lt;/a&gt; and &lt;a href=&quot;../provider/%24scedelegateprovider#bannedResourceUrlList.html&quot;&gt;bannedResourceUrlList()&lt;/a&gt;.</source>
          <target state="translated">컨텍스트에 따라 값을 신뢰할 수 있음으로 표시하거나 &lt;a href=&quot;../service/%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; 동작을 구성하는 다른 옵션이있을 수 있습니다 . 예를 들어 &lt;code&gt;RESOURCE_URL&lt;/code&gt; 컨텍스트를 특정 출처 로 제한 하려면 &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;trustedResourceUrlList ()&lt;/a&gt; 및 &lt;a href=&quot;../provider/%24scedelegateprovider#bannedResourceUrlList.html&quot;&gt;bannedResourceUrlList ()를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2c96dacf00c451ef465f6115a45a20bccf1256" translate="yes" xml:space="preserve">
          <source>Basic</source>
          <target state="translated">Basic</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="a630ca8deb35f0b3fd6f775e263194a67f9726ee" translate="yes" xml:space="preserve">
          <source>Basic transclusion</source>
          <target state="translated">기본 번역</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="a8f4a3a1f0d4e06e71d9546076fd38b396b53d8c" translate="yes" xml:space="preserve">
          <source>Be aware that a scope may not be included in digests if it has a suspended ancestor, even if &lt;code&gt;$isSuspended()&lt;/code&gt; returns false.</source>
          <target state="translated">&lt;code&gt;$isSuspended()&lt;/code&gt; 가 false를 반환 하더라도 조상에 일시 중단 된 범위가 있으면 다이제스트에 범위가 포함되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb178cd3edcfd7946fd6725c07d458de69029a68" translate="yes" xml:space="preserve">
          <source>Be aware that the attribute values to match against cannot be expressions. They are interpreted as literal string values to match against. For example, &lt;strong&gt;&lt;code&gt;ng-switch-when=&quot;someVal&quot;&lt;/code&gt;&lt;/strong&gt; will match against the string &lt;code&gt;&quot;someVal&quot;&lt;/code&gt; not against the value of the expression &lt;code&gt;$scope.someVal&lt;/code&gt;.</source>
          <target state="translated">일치시킬 속성 값은 표현식이 될 수 없습니다. 일치하는 리터럴 문자열 값으로 해석됩니다. 예를 들어 &lt;strong&gt; &lt;code&gt;ng-switch-when=&quot;someVal&quot;&lt;/code&gt; &lt;/strong&gt; 은 표현식 &lt;code&gt;$scope.someVal&lt;/code&gt; 의 값이 아닌 &lt;code&gt;&quot;someVal&quot;&lt;/code&gt; 문자열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d57c89c178c1084f792baa907f8b2cd67bfc1260" translate="yes" xml:space="preserve">
          <source>Be aware that the controller will be instantiated and attached to the scope as specified in the component definition object. If you do not provide a &lt;code&gt;$scope&lt;/code&gt; object in the &lt;code&gt;locals&lt;/code&gt; param then the helper will create a new isolated scope as a child of &lt;code&gt;$rootScope&lt;/code&gt;.</source>
          <target state="translated">구성 요소 정의 오브젝트에 지정된대로 컨트롤러가 인스턴스화되고 범위에 연결됩니다. &lt;code&gt;locals&lt;/code&gt; 매개 변수 에 &lt;code&gt;$scope&lt;/code&gt; 객체를 제공하지 않으면 도우미는 &lt;code&gt;$rootScope&lt;/code&gt; 의 자식으로 격리 된 새 범위를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6ed3cc776f278e962e755c71673491d092cfea71" translate="yes" xml:space="preserve">
          <source>Be aware that, before AngularJS 1.7.0, &lt;code&gt;a[href]&lt;/code&gt; and &lt;code&gt;img[src]&lt;/code&gt; used to sanitize their interpolated values directly rather than rely upon &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;&lt;code&gt;$sce.getTrusted&lt;/code&gt;&lt;/a&gt;. &lt;strong&gt;As of 1.7.0, this is no longer the case.&lt;/strong&gt; Now such interpolations are marked as requiring &lt;code&gt;$sce.URL&lt;/code&gt; (for &lt;code&gt;a[href]&lt;/code&gt;) or &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; (for &lt;code&gt;img[src]&lt;/code&gt;), so that the sanitization happens (via &lt;code&gt;$sce.getTrusted...&lt;/code&gt;) when the &lt;code&gt;$interpolate&lt;/code&gt; service evaluates the expressions.</source>
          <target state="translated">AngularJS 1.7.0 이전에는 &lt;code&gt;a[href]&lt;/code&gt; 및 &lt;code&gt;img[src]&lt;/code&gt; 가 &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt; &lt;code&gt;$sce.getTrusted&lt;/code&gt; &lt;/a&gt; 의존하지 않고 보간 된 값을 직접 위생 처리하는 데 사용되었습니다 . &lt;strong&gt;1.7.0부터는 더 이상 그렇지 않습니다. &lt;/strong&gt;이제 보간이 필요한 것으로 표시되어 &lt;code&gt;$sce.URL&lt;/code&gt; (위한 &lt;code&gt;a[href]&lt;/code&gt; 또는) &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; (위한 &lt;code&gt;img[src]&lt;/code&gt; ) 때문에, 살균이 (통해 일어나는 &lt;code&gt;$sce.getTrusted...&lt;/code&gt; ) 때 &lt;code&gt;$interpolate&lt;/code&gt; 서비스는 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="2dc590986ab9f4a1c9c7cd048d14ee382cfa0665" translate="yes" xml:space="preserve">
          <source>Be careful when using &lt;code&gt;select&lt;/code&gt;&lt;strong&gt;&lt;code&gt;as&lt;/code&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;code&gt;track by&lt;/code&gt;&lt;/strong&gt; in the same expression.</source>
          <target state="translated">같은 식으로 &lt;code&gt;select&lt;/code&gt; &lt;strong&gt; &lt;code&gt;as&lt;/code&gt; &lt;/strong&gt; 및 &lt;strong&gt; &lt;code&gt;track by&lt;/code&gt; &lt;/strong&gt; 를 사용할 때주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="756d08e3929f443998e8b33d291e1c7ac910d9d7" translate="yes" xml:space="preserve">
          <source>Be ready to update rapidly when new security-centric patches are available.</source>
          <target state="translated">새로운 보안 중심 패치가 제공되면 신속하게 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="064da4156fc4de43ba0aa3698866646d47db5fcc" translate="yes" xml:space="preserve">
          <source>Be sure to check all relative links, images, scripts etc. AngularJS requires you to specify the url base in the head of your main html file (&lt;code&gt;&amp;lt;base href=&quot;/my-base/index.html&quot;&amp;gt;&lt;/code&gt;) unless &lt;code&gt;html5Mode.requireBase&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; in the html5Mode definition object passed to &lt;code&gt;$locationProvider.html5Mode()&lt;/code&gt;. With that, relative urls will always be resolved to this base url, even if the initial url of the document was different.</source>
          <target state="translated">모든 상대 링크, 이미지, 스크립트 등을 확인하십시오. AngularJS는 &lt;code&gt;html5Mode.requireBase&lt;/code&gt; 가 아닌 한 기본 HTML 파일 ( &lt;code&gt;&amp;lt;base href=&quot;/my-base/index.html&quot;&amp;gt;&lt;/code&gt; ) 의 머리글에 URL 기준을 지정해야합니다. &lt;code&gt;$locationProvider.html5Mode()&lt;/code&gt; 전달 된 html5Mode 정의 객체에서 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 . 이를 통해 문서의 초기 URL이 다르더라도 상대 URL은 항상이 기본 URL로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ccae1d4f176aa022cf0467d0a41874c687b05c" translate="yes" xml:space="preserve">
          <source>Bear in mind that calling &lt;code&gt;$http.jsonp&lt;/code&gt; gives the remote server (and, if the request is not secured, any Man-in-the-Middle attackers) instant remote code execution in your application: the result of these requests is handed off to the browser as a regular &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;$http.jsonp&lt;/code&gt; 를 호출 하면 응용 프로그램 에서 원격 서버 (및 요청이 보안되지 않은 경우 모든 Man-in-the-Middle 공격자)에게 즉시 원격 코드 실행을 제공합니다. 이러한 요청의 결과는 다음과 같습니다. 브라우저를 일반 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="913a9f820820f8fa1cd66701b894a4992b1a3a57" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$location&lt;/code&gt; uses getters/setters, you can use &lt;code&gt;ng-model-options=&quot;{ getterSetter: true }&quot;&lt;/code&gt; to bind it to &lt;code&gt;ngModel&lt;/code&gt;:</source>
          <target state="translated">때문에 &lt;code&gt;$location&lt;/code&gt; 의 getter / setter를 사용하여, 당신은 사용할 수 있습니다 &lt;code&gt;ng-model-options=&quot;{ getterSetter: true }&quot;&lt;/code&gt; 에 바인딩하는 &lt;code&gt;ngModel&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66918714be29738338a327fa4d2ac2597587dfb7" translate="yes" xml:space="preserve">
          <source>Because AngularJS separates logic from the view layer, it keeps controllers easy to test. Let's take a look at how we might test the controller below, which provides &lt;code&gt;$scope.grade&lt;/code&gt;, which sets a property on the scope based on the length of the password.</source>
          <target state="translated">AngularJS는 뷰 레이어에서 로직을 분리하기 때문에 컨트롤러를 쉽게 테스트 할 수 있습니다. 아래에서 컨트롤러를 테스트하는 방법을 살펴 보겠습니다. 아래에서 &lt;code&gt;$scope.grade&lt;/code&gt; 를 제공 하여 암호 길이에 따라 범위에 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1af7e1fd57a13d91c70dd236e289a06c3575397f" translate="yes" xml:space="preserve">
          <source>Because calling the &lt;code&gt;then&lt;/code&gt; method of a promise returns a new derived promise, it is easily possible to create a chain of promises:</source>
          <target state="translated">promise 의 &lt;code&gt;then&lt;/code&gt; 메소드를 호출하면 새로운 파생 약속이 리턴되므로 약속 체인을 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9672864e0e40f75d7a0f50f10bc9d756a2e191b3" translate="yes" xml:space="preserve">
          <source>Because controllers are not available on the global scope, we need to use &lt;a href=&quot;../api/ngmock/function/angular.mock.inject&quot;&gt;&lt;code&gt;angular.mock.inject&lt;/code&gt;&lt;/a&gt; to inject our controller first. The first step is to use the &lt;code&gt;module&lt;/code&gt; function, which is provided by angular-mocks. This loads in the module it's given, so it is available in your tests. We pass this into &lt;code&gt;beforeEach&lt;/code&gt;, which is a function Jasmine provides that lets us run code before each test. Then we can use &lt;code&gt;inject&lt;/code&gt; to access &lt;code&gt;$controller&lt;/code&gt;, the service that is responsible for instantiating controllers.</source>
          <target state="translated">컨트롤러는 전체 범위에서 사용할 수 &lt;a href=&quot;../api/ngmock/function/angular.mock.inject&quot;&gt; &lt;code&gt;angular.mock.inject&lt;/code&gt; &lt;/a&gt; 를 사용 하여 컨트롤러를 먼저 주입 해야합니다 . 첫 번째 단계는 각도 모의에 의해 제공되는 &lt;code&gt;module&lt;/code&gt; 기능 을 사용하는 것 입니다. 이것은 주어진 모듈에로드되므로 테스트에서 사용할 수 있습니다. 이를 Jasmine이 제공하는 함수 인 &lt;code&gt;beforeEach&lt;/code&gt; 로 전달하여 각 테스트 전에 코드를 실행할 수있게합니다. 그런 다음 &lt;code&gt;inject&lt;/code&gt; 를 사용 하여 &lt;code&gt;$controller&lt;/code&gt; 인스턴스화를 담당하는 서비스 인 $ controller 에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75d8d0e2449a8a637f5cd0e710800e69e1f06b91" translate="yes" xml:space="preserve">
          <source>Because ngAria hooks into the &lt;code&gt;ng-disabled&lt;/code&gt; directive, developers do not have to do anything to enable this feature. The &lt;code&gt;aria-disabled&lt;/code&gt; attribute is automatically managed simply as a silent side-effect of using &lt;code&gt;ng-disabled&lt;/code&gt; with the ngAria module.</source>
          <target state="translated">ngAria는 &lt;code&gt;ng-disabled&lt;/code&gt; 지시문에 연결되기 때문에 개발자는이 기능을 활성화하기 위해 아무것도 할 필요가 없습니다. &lt;code&gt;aria-disabled&lt;/code&gt; 속성이 자동으로 사용하는 자동 부작용 단순히 관리 &lt;code&gt;ng-disabled&lt;/code&gt; ngAria 모듈.</target>
        </trans-unit>
        <trans-unit id="e4f9e4a032b3c265ca8bc0abd382f689fad90b1d" translate="yes" xml:space="preserve">
          <source>Because of rewriting capability in HTML5 mode, your users will be able to open regular url links in legacy browsers and hashbang links in modern browser:</source>
          <target state="translated">HTML5 모드의 재 작성 기능으로 인해 사용자는 기존 브라우저에서 일반 URL 링크를 열고 최신 브라우저에서 해시 뱅 링크를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf8e5fddffa8c784285c98c1c4d48d93b7de849" translate="yes" xml:space="preserve">
          <source>Because of these caveats, we recommend avoiding this style of annotation.</source>
          <target state="translated">이러한 경고 때문에 이러한 스타일의 주석을 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f831e48daf5bfcb79f6cbc1cd4201ba14ebde551" translate="yes" xml:space="preserve">
          <source>Because template loading is asynchronous the compiler will suspend compilation of directives on that element for later when the template has been resolved. In the meantime it will continue to compile and link sibling and parent elements as though this element had not contained any directives.</source>
          <target state="translated">템플릿 로딩은 비동기식이므로 컴파일러는 템플릿이 해결 될 때 나중에 해당 요소에 대한 지시문 컴파일을 일시 중단합니다. 그 동안이 요소에 지시문이 포함되지 않은 것처럼 형제 및 상위 요소를 계속 컴파일하고 링크합니다.</target>
        </trans-unit>
        <trans-unit id="c2686aeaeb26c6b0f88a3e35dc78028d0d367579" translate="yes" xml:space="preserve">
          <source>Because the constants are fixed, they get applied before other provide methods. See &lt;a href=&quot;../../auto/service/%24provide#constant.html&quot;&gt;$provide.constant()&lt;/a&gt;.</source>
          <target state="translated">상수는 고정되어 있으므로 다른 제공 메소드보다 먼저 적용됩니다. &lt;a href=&quot;../../auto/service/%24provide#constant.html&quot;&gt;$ provide.constant ()를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe7c5eb34e275ba1c5c585a6d36df4df0abd8a0c" translate="yes" xml:space="preserve">
          <source>Because the view is just a projection of the model, the controller is completely separated from the view and unaware of it. This makes testing a snap because it is easy to test your controller in isolation without the view and the related DOM/browser dependency.</source>
          <target state="translated">뷰는 모델의 투영 일 뿐이므로 컨트롤러는 뷰와 완전히 분리되어이를 인식하지 못합니다. 뷰와 관련 DOM / 브라우저 의존성없이 컨트롤러를 독립적으로 테스트하기가 쉽기 때문에 테스트가 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d2474582b13c2c5cbe322f103e9aa433011581de" translate="yes" xml:space="preserve">
          <source>Because these messages can themselves contain AngularJS expressions, you could also write this as follows:</source>
          <target state="translated">이러한 메시지 자체에는 AngularJS 표현식이 포함될 수 있으므로 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e949293bb3141d39921183faafd54e8bcb4089c2" translate="yes" xml:space="preserve">
          <source>Becomes:</source>
          <target state="translated">Becomes:</target>
        </trans-unit>
        <trans-unit id="eac5d76c03a8af1becda5e52ec3a36ad44266321" translate="yes" xml:space="preserve">
          <source>Before animating, &lt;code&gt;ngAnimate&lt;/code&gt; checks if the animated element is inside the application DOM tree. If not, no animation is run. Usually, this is not a problem since most apps use the &lt;code&gt;html&lt;/code&gt; or &lt;code&gt;body&lt;/code&gt; elements as their root.</source>
          <target state="translated">애니메이션을 적용하기 전에 &lt;code&gt;ngAnimate&lt;/code&gt; 는 애니메이션 요소가 응용 프로그램 DOM 트리 내에 있는지 확인합니다. 그렇지 않으면 애니메이션이 실행되지 않습니다. 대부분의 앱은 &lt;code&gt;html&lt;/code&gt; 또는 &lt;code&gt;body&lt;/code&gt; 요소를 루트로 사용하기 때문에 일반적으로 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9dea2dff9695dcee2903587ddf4721df61dee63" translate="yes" xml:space="preserve">
          <source>Before compilation</source>
          <target state="translated">컴파일하기 전에</target>
        </trans-unit>
        <trans-unit id="f741ff2771fb251149a44e53c3845e34e949b99f" translate="yes" xml:space="preserve">
          <source>Before compilation:</source>
          <target state="translated">컴파일하기 전에 :</target>
        </trans-unit>
        <trans-unit id="d2ed330fba12b5acc7c29421a0cc662fa9ec96e4" translate="yes" xml:space="preserve">
          <source>Before we can write a directive, we need to know how AngularJS's &lt;a href=&quot;compiler&quot;&gt;HTML compiler&lt;/a&gt; determines when to use a given directive.</source>
          <target state="translated">지시문을 작성하기 전에 AngularJS의 &lt;a href=&quot;compiler&quot;&gt;HTML 컴파일러&lt;/a&gt; 가 주어진 지시문을 언제 사용할지 결정 하는 방법을 알아야합니다 .</target>
        </trans-unit>
        <trans-unit id="a4244aeaf237de0bd45b29f36dc3172737bcea80" translate="yes" xml:space="preserve">
          <source>Before you start creating interceptors, be sure to understand the &lt;a href=&quot;%24q&quot;&gt;$q and deferred/promise APIs&lt;/a&gt;.</source>
          <target state="translated">인터셉터 작성을 시작하기 전에 &lt;a href=&quot;%24q&quot;&gt;$ q 및 지연 / 약속 API&lt;/a&gt; 를 이해하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9130bc666cd2fae643b177fd9066f63c8444f18" translate="yes" xml:space="preserve">
          <source>Below is a more detailed breakdown of the attributes handled by ngAria:</source>
          <target state="translated">다음은 ngAria가 처리하는 속성에 대한 자세한 분석입니다.</target>
        </trans-unit>
        <trans-unit id="11bbabfeedc954ff982e0a78487164bd01cf2aef" translate="yes" xml:space="preserve">
          <source>Below is a pseudo code showing how a simplified dialog component may work.</source>
          <target state="translated">아래는 단순화 된 대화 상자 구성 요소가 어떻게 작동하는지 보여주는 의사 코드입니다.</target>
        </trans-unit>
        <trans-unit id="8780b9b9f2ecc23a18832842a6331d7e904cf4bd" translate="yes" xml:space="preserve">
          <source>Below is a quick example of animations being enabled for &lt;code&gt;ngShow&lt;/code&gt; and &lt;code&gt;ngHide&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;ngShow&lt;/code&gt; 및 &lt;code&gt;ngHide&lt;/code&gt; 에 사용되는 애니메이션의 간단한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="be1db57587b85598644961ce203ff84d2d516194" translate="yes" xml:space="preserve">
          <source>Below is the corresponding code using the &lt;code&gt;$compile&lt;/code&gt; service. This should help give you an idea of what AngularJS does internally.</source>
          <target state="translated">아래는 &lt;code&gt;$compile&lt;/code&gt; 서비스를 사용하는 해당 코드 입니다. 이것은 AngularJS가 내부적으로하는 일에 대한 아이디어를 제공하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="95b8e9add7e9e88cd1012d17110827a722b230cd" translate="yes" xml:space="preserve">
          <source>Besides making it possible to bind different data to the scope inside a directive, using an isolated scope has another effect.</source>
          <target state="translated">지시문 내의 범위에 다른 데이터를 바인딩 할 수있게하는 것 외에도 격리 된 범위를 사용하면 다른 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="93406408f653eced71823f50bb1a33f720c1359a" translate="yes" xml:space="preserve">
          <source>Besides the new file that contains the controller code, we also added an &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;&lt;code&gt;ng-controller&lt;/code&gt;&lt;/a&gt; directive to the HTML. This directive tells AngularJS that the new &lt;code&gt;InvoiceController&lt;/code&gt; is responsible for the element with the directive and all of the element's children. The syntax &lt;code&gt;InvoiceController as invoice&lt;/code&gt; tells AngularJS to instantiate the controller and save it in the variable &lt;code&gt;invoice&lt;/code&gt; in the current scope.</source>
          <target state="translated">컨트롤러 코드가 포함 된 새 파일 외에도 &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt; &lt;code&gt;ng-controller&lt;/code&gt; &lt;/a&gt; 지시문을 HTML에 추가했습니다 . 이 지시문은 AngularJS에 새 &lt;code&gt;InvoiceController&lt;/code&gt; 가 지시문이있는 요소와 모든 요소의 자식을 담당 함을 알려줍니다 . &lt;code&gt;InvoiceController as invoice&lt;/code&gt; 구문 은 AngularJS에게 컨트롤러를 인스턴스화 하고 현재 범위 의 변수 &lt;code&gt;invoice&lt;/code&gt; 에 저장하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="5dce4dc5831fd9122f1e8fb1725d04397f36283e" translate="yes" xml:space="preserve">
          <source>Besides these few cases, you should use &lt;a href=&quot;../../../guide/component&quot;&gt;Components&lt;/a&gt; or &lt;a href=&quot;../../../guide/controller&quot;&gt;Controllers&lt;/a&gt; rather than &lt;code&gt;ngInit&lt;/code&gt; to initialize values on a scope.</source>
          <target state="translated">이러한 몇 가지 경우 외에 &lt;code&gt;ngInit&lt;/code&gt; 대신 &lt;a href=&quot;../../../guide/component&quot;&gt;구성 요소&lt;/a&gt; 또는 &lt;a href=&quot;../../../guide/controller&quot;&gt;컨트롤러를&lt;/a&gt; 사용 하여 범위의 값을 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd3e4ab482cc2518af6697be2e20841e8a579b32" translate="yes" xml:space="preserve">
          <source>Beware that using &lt;code&gt;angular.module('myModule', [])&lt;/code&gt; will create the module &lt;code&gt;myModule&lt;/code&gt; and overwrite any existing module named &lt;code&gt;myModule&lt;/code&gt;. Use &lt;code&gt;angular.module('myModule')&lt;/code&gt; to retrieve an existing module.</source>
          <target state="translated">그 사용에주의 &lt;code&gt;angular.module('myModule', [])&lt;/code&gt; 모듈 만드는 것 &lt;code&gt;myModule&lt;/code&gt; 하고 기존 모듈이라는 덮어 &lt;code&gt;myModule&lt;/code&gt; . 사용 &lt;code&gt;angular.module('myModule')&lt;/code&gt; 기존의 모듈을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8807c9bb60191c14db0f1b18c1ea78b4f82dbc02" translate="yes" xml:space="preserve">
          <source>Bind to built-in DOM events</source>
          <target state="translated">내장 DOM 이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="657d28f8e1850fbaf57c9e8970ad485efff54816" translate="yes" xml:space="preserve">
          <source>Bind to custom DOM events</source>
          <target state="translated">커스텀 DOM 이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="d5b9dbf27d5fc4d4a4c313e066f87df8c57477db" translate="yes" xml:space="preserve">
          <source>Binding expressions to arbitrary properties poses a security risk, as properties like &lt;code&gt;innerHTML&lt;/code&gt; can insert potentially dangerous HTML into the application, e.g. script tags that execute malicious code. For this reason, &lt;code&gt;ngProp&lt;/code&gt; applies Strict Contextual Escaping with the &lt;a href=&quot;../service/%24sce&quot;&gt;$sce service&lt;/a&gt;. This means vulnerable properties require their content to be &quot;trusted&quot;, based on the context of the property. For example, the &lt;code&gt;innerHTML&lt;/code&gt; is in the &lt;code&gt;HTML&lt;/code&gt; context, and the &lt;code&gt;iframe.src&lt;/code&gt; property is in the &lt;code&gt;RESOURCE_URL&lt;/code&gt; context, which requires that values written to this property are trusted as a &lt;code&gt;RESOURCE_URL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;innerHTML&lt;/code&gt; 과 같은 속성은 잠재적으로 위험한 HTML (예 : 악성 코드를 실행하는 스크립트 태그)을 응용 프로그램에 삽입 할 수 있으므로 임의의 속성에 식을 바인딩하면 보안 위험이 발생 합니다. 이러한 이유로 &lt;code&gt;ngProp&lt;/code&gt; 은 &lt;a href=&quot;../service/%24sce&quot;&gt;$ sce 서비스&lt;/a&gt; 와 함께 엄격한 컨텍스트 이스케이프를 적용 합니다 . 즉, 취약한 속성은 속성에 따라 콘텐츠를 &quot;신뢰할 수 있어야&quot;합니다. 예를 들어 &lt;code&gt;innerHTML&lt;/code&gt; 은 &lt;code&gt;HTML&lt;/code&gt; 컨텍스트에 있고 &lt;code&gt;iframe.src&lt;/code&gt; 속성은 &lt;code&gt;RESOURCE_URL&lt;/code&gt; 컨텍스트 에 있으며이 속성에 기록 된 값은 &lt;code&gt;RESOURCE_URL&lt;/code&gt; 로 신뢰되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c95abad5a4fb01b2daa804b21d3bcaa9976b850" translate="yes" xml:space="preserve">
          <source>Binding select to a non-string value via ngModel parsing / formatting</source>
          <target state="translated">ngModel 구문 분석 / 형식화를 통해 선택을 문자열이 아닌 값에 바인딩</target>
        </trans-unit>
        <trans-unit id="87c4c92c7cc5c40f37665ead791df5e9d4951a3e" translate="yes" xml:space="preserve">
          <source>Binding the view into the model, which other directives such as &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt; or &lt;code&gt;select&lt;/code&gt; require.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; , &lt;code&gt;textarea&lt;/code&gt; 또는 &lt;code&gt;select&lt;/code&gt; 과 같은 다른 지시문이 필요한 뷰를 모델에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="bb8d1dbec2383b2ace68d315a5505325a07603fe" translate="yes" xml:space="preserve">
          <source>Binding to a getter/setter</source>
          <target state="translated">게터 / 세터에 바인딩</target>
        </trans-unit>
        <trans-unit id="25ace093925e2814896e0582fd4ff55182dce1a7" translate="yes" xml:space="preserve">
          <source>Binding to boolean attributes</source>
          <target state="translated">부울 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="8bce3a109839f438e000945b18acdd32b0210c8c" translate="yes" xml:space="preserve">
          <source>Binding to camelCase properties</source>
          <target state="translated">camelCase 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="99b5983ad3dd8a0fefc84a6eff022b8d33c135fe" translate="yes" xml:space="preserve">
          <source>Binding to different contexts</source>
          <target state="translated">다른 상황에 바인딩</target>
        </trans-unit>
        <trans-unit id="d0561b07cc318a1f09fc9de10ee57ff0d9c80f3a" translate="yes" xml:space="preserve">
          <source>Binding to form and control state</source>
          <target state="translated">형태 및 제어 상태에 대한 바인딩</target>
        </trans-unit>
        <trans-unit id="ebd58a4a7b83d78b2f35d5de1c469945d20cbdfa" translate="yes" xml:space="preserve">
          <source>Binding to innerHTML with ngSanitize</source>
          <target state="translated">ngSanitize를 사용하여 innerHTML에 바인딩</target>
        </trans-unit>
        <trans-unit id="b6fc4d77d0ae47604bdf44f931ee45b700a34949" translate="yes" xml:space="preserve">
          <source>Binds the given expression to the value of the element.</source>
          <target state="translated">주어진 표현식을 요소의 값에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="0b9d2b2362bc33581ba11fddcb0cf0590ebd3a7a" translate="yes" xml:space="preserve">
          <source>Blog</source>
          <target state="translated">Blog</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="89ec4ec2bf400e823f3ca49d0cb938b0fedd7bab" translate="yes" xml:space="preserve">
          <source>Bootstrap</source>
          <target state="translated">Bootstrap</target>
        </trans-unit>
        <trans-unit id="443f17a7b86f51793bfee7a9b599be7411962f49" translate="yes" xml:space="preserve">
          <source>Both approaches described above require you to prepare different &lt;code&gt;index.html&lt;/code&gt; pages or JavaScript files for each locale that your app may use. You also need to configure your server to serve the correct file that corresponds to the desired locale.</source>
          <target state="translated">위에서 설명한 두 가지 방법 모두 앱에서 사용할 수있는 각 로캘마다 다른 &lt;code&gt;index.html&lt;/code&gt; 페이지 또는 JavaScript 파일 을 준비해야합니다 . 또한 원하는 로케일에 해당하는 올바른 파일을 제공하도록 서버를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca64c991bfb8f51ff1d5093045e9b7f736452f5" translate="yes" xml:space="preserve">
          <source>Both controllers and directives have reference to the scope, but not to each other. This arrangement isolates the controller from the directive as well as from the DOM. This is an important point since it makes the controllers view agnostic, which greatly improves the testing story of the applications.</source>
          <target state="translated">컨트롤러와 지시문은 범위를 참조하지만 서로를 참조하지는 않습니다. 이 배열은 컨트롤러를 지시문 및 DOM에서 분리합니다. 컨트롤러를 무시해도되므로 응용 프로그램의 테스트 스토리가 크게 향상되므로 이는 중요한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="40dcb3b95121f56d8a5d3c7eb1620ecb8cb8dc8b" translate="yes" xml:space="preserve">
          <source>Both methods return the &lt;code&gt;requestHandler&lt;/code&gt; object for possible overrides.</source>
          <target state="translated">두 메소드 모두 가능한 대체를 위해 &lt;code&gt;requestHandler&lt;/code&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d46a182956cbe1896d122a91a94ab7a7d4100cc8" translate="yes" xml:space="preserve">
          <source>Both objects or values are of the same type and all of their properties are equal by comparing them with &lt;code&gt;angular.equals&lt;/code&gt;.</source>
          <target state="translated">객체 또는 값은 모두 동일한 유형이며 &lt;code&gt;angular.equals&lt;/code&gt; 와 비교하여 모든 속성이 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3e5005cfde41f6cbdc44666fa883267220053196" translate="yes" xml:space="preserve">
          <source>Both objects or values pass &lt;code&gt;===&lt;/code&gt; comparison.</source>
          <target state="translated">객체 또는 값 모두 &lt;code&gt;===&lt;/code&gt; 비교를 통과 합니다.</target>
        </trans-unit>
        <trans-unit id="a125206df8681fa85102404723fa7cd9d26dd16c" translate="yes" xml:space="preserve">
          <source>Both requests and responses can be transformed using transformation functions: &lt;code&gt;transformRequest&lt;/code&gt; and &lt;code&gt;transformResponse&lt;/code&gt;. These properties can be a single function that returns the transformed value (&lt;code&gt;function(data, headersGetter, status)&lt;/code&gt;) or an array of such transformation functions, which allows you to &lt;code&gt;push&lt;/code&gt; or &lt;code&gt;unshift&lt;/code&gt; a new transformation function into the transformation chain.</source>
          <target state="translated">요청과 응답 모두 &lt;code&gt;transformRequest&lt;/code&gt; 및 &lt;code&gt;transformResponse&lt;/code&gt; 변환 기능을 사용하여 변환 할 수 있습니다 . 이러한 특성은 하나의 함수가 될 수 복귀 변환 값 ( &lt;code&gt;function(data, headersGetter, status)&lt;/code&gt; 가 수 있음) 또는 변환 함수의 배열 &lt;code&gt;push&lt;/code&gt; 또는 &lt;code&gt;unshift&lt;/code&gt; 변환 체인에 새로운 변환 함수.</target>
        </trans-unit>
        <trans-unit id="75b4106a74d08ca7beaa672015bdedf0fbb0610c" translate="yes" xml:space="preserve">
          <source>Both server and the client must cooperate in order to eliminate these threats. AngularJS comes pre-configured with strategies that address these issues, but for this to work backend server cooperation is required.</source>
          <target state="translated">이러한 위협을 제거하려면 서버와 클라이언트 모두 협력해야합니다. AngularJS에는 이러한 문제를 해결하는 전략이 사전 구성되어 있지만이를 위해서는 백엔드 서버 협력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d7a06053351dcacb0958c1d7874174fafa3e176f" translate="yes" xml:space="preserve">
          <source>Both services use the array notation to declare their dependencies.</source>
          <target state="translated">두 서비스 모두 배열 표기법을 사용하여 종속성을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="453b6ec0bdcf074f42019bd759bd4f46fe479c1d" translate="yes" xml:space="preserve">
          <source>Both values are NaN. (In JavaScript, NaN == NaN =&amp;gt; false. But we consider two NaN as equal)</source>
          <target state="translated">두 값 모두 NaN입니다. (JavaScript에서는 NaN == NaN =&amp;gt; false입니다. 그러나 우리는 두 NaN을 동일한 것으로 간주합니다)</target>
        </trans-unit>
        <trans-unit id="8238aa1fee0718d12fd25bfcbae5d91e5efcde6e" translate="yes" xml:space="preserve">
          <source>Both values represent the same regular expression (In JavaScript, /abc/ == /abc/ =&amp;gt; false. But we consider two regular expressions as equal when their textual representation matches).</source>
          <target state="translated">두 값 모두 동일한 정규 표현식을 나타냅니다 (JavaScript에서는 / abc / == / abc / =&amp;gt; false. 그러나 텍스트 표현이 일치 할 경우 두 정규 표현식을 동일한 것으로 간주합니다).</target>
        </trans-unit>
        <trans-unit id="236ab44b7fba5a5f64f75f18c707a81aa8471a1c" translate="yes" xml:space="preserve">
          <source>BreezeJS</source>
          <target state="translated">BreezeJS</target>
        </trans-unit>
        <trans-unit id="a0cdfd5795b7e2c68f3f565bde94c8cda195a6da" translate="yes" xml:space="preserve">
          <source>Broadcasted after a URL was changed.</source>
          <target state="translated">URL이 변경된 후 방송됩니다.</target>
        </trans-unit>
        <trans-unit id="5717f71e7e0404413a5bac0d197a4f54f36c5557" translate="yes" xml:space="preserve">
          <source>Broadcasted after a route change has happened successfully. The &lt;code&gt;resolve&lt;/code&gt; dependencies are now available in the &lt;code&gt;current.locals&lt;/code&gt; property.</source>
          <target state="translated">경로 변경이 완료된 후 방송됩니다. &lt;code&gt;resolve&lt;/code&gt; 종속성은 이제 사용할 수 있습니다 &lt;code&gt;current.locals&lt;/code&gt; 의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="db63277f54c549ffb9ccc9b41975c00069d4fd0b" translate="yes" xml:space="preserve">
          <source>Broadcasted before a URL will change.</source>
          <target state="translated">URL이 변경되기 전에 방송됩니다.</target>
        </trans-unit>
        <trans-unit id="a528b7c196e8ddc0cb9c7f059079eae85e556a77" translate="yes" xml:space="preserve">
          <source>Broadcasted before a route change. At this point the route services starts resolving all of the dependencies needed for the route change to occur. Typically this involves fetching the view template as well as any dependencies defined in &lt;code&gt;resolve&lt;/code&gt; route property. Once all of the dependencies are resolved &lt;code&gt;$routeChangeSuccess&lt;/code&gt; is fired.</source>
          <target state="translated">경로 변경 전에 방송됩니다. 이 시점에서 경로 서비스는 경로 변경이 발생하는 데 필요한 모든 종속성을 해결하기 시작합니다. 일반적으로이 뷰 템플릿뿐만 아니라에 정의 된 모든 종속성을 가져 오는 포함 &lt;code&gt;resolve&lt;/code&gt; 경로 속성을. 모든 종속성이 해결되면 &lt;code&gt;$routeChangeSuccess&lt;/code&gt; 가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0e142877d6ef7e5d1e6c077814dcc5637d27b1f7" translate="yes" xml:space="preserve">
          <source>Broadcasted if a redirection function fails or any redirection or resolve promises are rejected.</source>
          <target state="translated">리디렉션 기능이 실패하거나 리디렉션 또는 해결 약속이 거부 된 경우 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="5cfcce92d36aeb1c520e9b5db15f22bee58c5791" translate="yes" xml:space="preserve">
          <source>Broadcasted if the same instance of a route (including template, controller instance, resolved dependencies, etc.) is being reused. This can happen if either &lt;code&gt;reloadOnSearch&lt;/code&gt; or &lt;code&gt;reloadOnUrl&lt;/code&gt; has been set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">동일한 라우트 인스턴스 (템플릿, 컨트롤러 인스턴스, 해결 된 종속성 등 포함)가 재사용되는 경우 브로드 캐스팅됩니다. &lt;code&gt;reloadOnSearch&lt;/code&gt; 또는 &lt;code&gt;reloadOnUrl&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a8322d960d47320dc5989c276e6b8166c048003" translate="yes" xml:space="preserve">
          <source>Broadcasted when a scope and its children are being destroyed.</source>
          <target state="translated">스코프와 그 자식이 파괴 될 때 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="7d70e82b9c499004d1850cf08803f0ce4e7e5cfd" translate="yes" xml:space="preserve">
          <source>Browser in HTML5 Fallback mode (Hashbang mode)</source>
          <target state="translated">HTML5 대체 모드의 브라우저 (Hashbang 모드)</target>
        </trans-unit>
        <trans-unit id="ecc6c180b9874f1a6748cfecac7f942eda9570d6" translate="yes" xml:space="preserve">
          <source>Browser in HTML5 mode</source>
          <target state="translated">HTML5 모드의 브라우저</target>
        </trans-unit>
        <trans-unit id="e37c900dcb84282abb18dc7216453ee2a12ba08a" translate="yes" xml:space="preserve">
          <source>Browsers that support range (latest Chrome, Safari, Firefox, Edge) treat &lt;code&gt;input[range]&lt;/code&gt; in a way that never allows the input to hold an invalid value. That means:</source>
          <target state="translated">범위를 지원하는 브라우저 (최신 Chrome, Safari, Firefox, Edge)는 &lt;code&gt;input[range]&lt;/code&gt; 이 잘못된 값을 유지하는 것을 허용하지 않는 방식으로 입력 [범위] 를 처리 합니다. 그것의 의미는:</target>
        </trans-unit>
        <trans-unit id="e83b0bc612367cc74978d533e0e30cf24b965e7c" translate="yes" xml:space="preserve">
          <source>Built-in validation tokens:</source>
          <target state="translated">내장 된 검증 토큰 :</target>
        </trans-unit>
        <trans-unit id="02e264495bc8c8e6e9753884128090bbb591476a" translate="yes" xml:space="preserve">
          <source>But &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt; has a dilemma.</source>
          <target state="translated">그러나 &lt;a href=&quot;../api/ng/directive/ngrepeat&quot;&gt;ngRepeat&lt;/a&gt; 에는 딜레마가 있습니다.</target>
        </trans-unit>
        <trans-unit id="59c3592d94e357cca81ab82eb84d5087a88626ed" translate="yes" xml:space="preserve">
          <source>But given that the token is just a string literal, sticking with the Value recipe is still more appropriate as it makes the code easier to follow.</source>
          <target state="translated">그러나 토큰은 문자열 리터럴이므로 코드를 더 쉽게 따라갈 수 있으므로 Value 레시피를 사용하는 것이 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="fce344d9abbbab9562c13cd7f34c0b9da8dd4d9c" translate="yes" xml:space="preserve">
          <source>But unlike &lt;a href=&quot;%24provide#value.html&quot;&gt;value&lt;/a&gt;, a constant can be injected into a module configuration function (see &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt;&lt;code&gt;angular.Module&lt;/code&gt;&lt;/a&gt;) and it cannot be overridden by an AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;decorator&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;%24provide#value.html&quot;&gt;값&lt;/a&gt; 과 달리 상수는 모듈 구성 함수 ( &lt;a href=&quot;../../ng/type/angular.module#config.html&quot;&gt; &lt;code&gt;angular.Module&lt;/code&gt; &lt;/a&gt; 참조)에 삽입 될 수 있으며 AngularJS &lt;a href=&quot;%24provide#decorator.html&quot;&gt;데코레이터&lt;/a&gt; 로 재정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="405847fd05efd79761c86b02e94559369547dbc6" translate="yes" xml:space="preserve">
          <source>By adding an &lt;code&gt;$inject&lt;/code&gt; property onto a function the injection parameters can be specified.</source>
          <target state="translated">함수에 &lt;code&gt;$inject&lt;/code&gt; 속성을 추가하면 주입 매개 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa2da9f3a76efbcb9284be63afad1a9da922618" translate="yes" xml:space="preserve">
          <source>By default $animate doesn't trigger any animations. This is because the &lt;code&gt;ngAnimate&lt;/code&gt; module isn't included and only when it is active then the animation hooks that &lt;code&gt;$animate&lt;/code&gt; triggers will be functional. Once active then all structural &lt;code&gt;ng-&lt;/code&gt; directives will trigger animations as they perform their DOM-related operations (enter, leave and move). Other directives such as &lt;code&gt;ngClass&lt;/code&gt;, &lt;code&gt;ngShow&lt;/code&gt;, &lt;code&gt;ngHide&lt;/code&gt; and &lt;code&gt;ngMessages&lt;/code&gt; also provide support for animations.</source>
          <target state="translated">기본적으로 $ animate는 애니메이션을 트리거하지 않습니다. 이는 &lt;code&gt;ngAnimate&lt;/code&gt; 모듈이 포함되어 있지 않고 활성화 된 경우에만 &lt;code&gt;$animate&lt;/code&gt; 트리거가 작동하도록 하는 애니메이션 후크입니다 . 활성화 된 모든 구조되면 &lt;code&gt;ng-&lt;/code&gt; 그들의 DOM 관련 작업 (입력, 휴가 및 이동)을 수행 할 때 지침이 애니메이션을 트리거합니다. &lt;code&gt;ngClass&lt;/code&gt; , &lt;code&gt;ngShow&lt;/code&gt; , &lt;code&gt;ngHide&lt;/code&gt; 및 &lt;code&gt;ngMessages&lt;/code&gt; 와 같은 다른 지시문 도 애니메이션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6a63f23b39aeafeeeef2f721b04b4097b6810a86" translate="yes" xml:space="preserve">
          <source>By default AngularJS attaches information about binding and scopes to DOM nodes, and adds CSS classes to data-bound elements:</source>
          <target state="translated">기본적으로 AngularJS는 바인딩 및 범위에 대한 정보를 DOM 노드에 연결하고 CSS 클래스를 데이터 바인딩 된 요소에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="370ccd1eb19dc0d611cfd9491b8afea309b7a0df" translate="yes" xml:space="preserve">
          <source>By default AngularJS compiles and executes all directives inside comments and element classes. In order to perform this task, the AngularJS compiler must look for directives by:</source>
          <target state="translated">기본적으로 AngularJS는 주석과 요소 클래스 내부의 모든 지시문을 컴파일하고 실행합니다. 이 작업을 수행하려면 AngularJS 컴파일러는 다음을 통해 지시문을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="1e2842d70be7f65d0a8c45bdabb3581c644cabee" translate="yes" xml:space="preserve">
          <source>By default you don't need to override anything in CSS and the animations will work around the display style.</source>
          <target state="translated">기본적으로 CSS에서 어떤 것도 무시할 필요가 없으며 애니메이션은 표시 스타일을 중심으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cfc9fd29727c805e8bcd27c2fd78719670ad599e" translate="yes" xml:space="preserve">
          <source>By default you don't need to override in CSS anything and the animations will work around the display style.</source>
          <target state="translated">기본적으로 CSS에서 재정의 할 필요는 없으며 애니메이션은 표시 스타일을 중심으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8e2db882ad5f7a39f81879fd1d5e758ebc4f4597" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$anchorScroll()&lt;/a&gt; will automatically detect changes to &lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$location.hash()&lt;/a&gt; and scroll to the element matching the new hash.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../service/%24anchorscroll&quot;&gt;$ anchorScroll ()&lt;/a&gt; 은 &lt;a href=&quot;../service/%24location#hash.html&quot;&gt;$ location.hash ()의&lt;/a&gt; 변경 사항을 자동으로 감지 하고 새 해시와 일치하는 요소로 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="eb7793000636bd074d047602162058c73e34ad5e" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;$sce&lt;/code&gt; will throw an error if it detects untrusted HTML content, and will not bind the content. However, if you include the &lt;a href=&quot;../../ngsanitize&quot;&gt;ngSanitize module&lt;/a&gt;, it will try to sanitize the potentially dangerous HTML, e.g. strip non-trusted tags and attributes when binding to &lt;code&gt;innerHTML&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;$sce&lt;/code&gt; 는 신뢰할 수없는 HTML 콘텐츠를 감지하면 오류를 발생시키고 콘텐츠를 바인딩하지 않습니다. 그러나 &lt;a href=&quot;../../ngsanitize&quot;&gt;ngSanitize 모듈&lt;/a&gt; 을 포함하면 잠재적으로 위험한 HTML을 삭제하려고합니다. 예를 들어 &lt;code&gt;innerHTML&lt;/code&gt; 에 바인딩 할 때 신뢰할 수없는 태그와 속성을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="c70a53728f1b21d2741de003d4f7d107644ad595" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;$sce&lt;/code&gt; will throw an error if it detects untrusted HTML content, and will not bind the content. However, if you include the &lt;a href=&quot;../../ngsanitize&quot;&gt;ngSanitize module&lt;/a&gt;, it will try to sanitize the potentially dangerous HTML, e.g. strip non-whitelisted tags and attributes when binding to &lt;code&gt;innerHTML&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;$sce&lt;/code&gt; 는 신뢰할 수없는 HTML 내용을 감지하면 내용을 바인딩하지 않으며 오류를 발생시킵니다. 그러나 &lt;a href=&quot;../../ngsanitize&quot;&gt;ngSanitize 모듈&lt;/a&gt; 을 포함하면 잠재적으로 위험한 HTML을 삭제하려고 시도합니다 (예 : &lt;code&gt;innerHTML&lt;/code&gt; 에 바인딩 할 때 화이트리스트에없는 태그 및 속성 제거) .</target>
        </trans-unit>
        <trans-unit id="79c69d18163b4e263908e7612db7c38c1f192b89" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ngMessages&lt;/code&gt; will only display one message for a particular key/value collection at any time. If more than one message (or error) key is currently true, then which message is shown is determined by the order of messages in the HTML template code (messages declared first are prioritised). This mechanism means the developer does not have to prioritize messages using custom JavaScript code.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngMessages&lt;/code&gt; 는 언제든지 특정 키 / 값 수집에 대해 하나의 메시지 만 표시합니다. 둘 이상의 메시지 (또는 오류) 키가 현재 true 인 경우 표시되는 메시지는 HTML 템플리트 코드의 메시지 순서에 따라 결정됩니다 (먼저 선언 된 메시지가 우선 순위가 지정됨). 이 메커니즘은 개발자가 사용자 정의 JavaScript 코드를 사용하여 메시지의 우선 순위를 지정할 필요가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="24c1da0bbb6770f2b962ebbc35b060bf09623b8f" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ngModel&lt;/code&gt; watches the model by reference, not value. This is important to know when binding inputs to models that are objects (e.g. &lt;code&gt;Date&lt;/code&gt;) or collections (e.g. arrays). If only properties of the object or collection change, &lt;code&gt;ngModel&lt;/code&gt; will not be notified and so the input will not be re-rendered.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngModel&lt;/code&gt; 은 값이 아닌 참조로 모델을 감시합니다. 입력을 객체 (예 : &lt;code&gt;Date&lt;/code&gt; ) 또는 컬렉션 (예 : 배열) 인 모델에 바인딩 할 때 알아야 합니다. 객체 또는 컬렉션의 속성 만 변경되면 &lt;code&gt;ngModel&lt;/code&gt; 에 알리지 않으므로 입력이 다시 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7190d37e5aa54069ede2834cb78f273c5c43c428" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ngModel&lt;/code&gt; watches the model by reference, not value. This is important to know when binding the select to a model that is an object or a collection.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngModel&lt;/code&gt; 은 값이 아닌 참조로 모델을 감시합니다. 선택을 개체 또는 컬렉션 인 모델에 바인딩 할 때 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="6903112b079eaf8ffdf3aec857a1afc48c94199d" translate="yes" xml:space="preserve">
          <source>By default, AngularJS only loads templates from the same domain and protocol as the application document. This is done by calling &lt;a href=&quot;%24sce#getTrustedResourceUrl.html&quot;&gt;$sce.getTrustedResourceUrl&lt;/a&gt; on the template URL. To load templates from other domains and/or protocols, you may either &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;whitelist them&lt;/a&gt; or &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;wrap it&lt;/a&gt; into a trusted value.</source>
          <target state="translated">기본적으로 AngularJS는 응용 프로그램 문서와 동일한 도메인 및 프로토콜의 템플릿 만로드합니다. 템플릿 URL에서 &lt;a href=&quot;%24sce#getTrustedResourceUrl.html&quot;&gt;$ sce.getTrustedResourceUrl&lt;/a&gt; 을 호출하면됩니다 . 다른 도메인 및 / 또는 프로토콜에서 템플릿을로드하려면 템플릿을 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;허용 목록에 포함 시키&lt;/a&gt; 거나 신뢰할 수있는 값으로 줄 &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;바꿈 할&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f1df63e0012ca7f538b0d74fdaec979f00c64c9" translate="yes" xml:space="preserve">
          <source>By default, AngularJS only loads templates from the same domain and protocol as the application document. This is done by calling &lt;a href=&quot;%24sce#getTrustedResourceUrl.html&quot;&gt;$sce.getTrustedResourceUrl&lt;/a&gt; on the template URL. To load templates from other domains and/or protocols, you may either add them to the &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;trustedResourceUrlList&lt;/a&gt; or &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;wrap them&lt;/a&gt; into trusted values.</source>
          <target state="translated">기본적으로 AngularJS는 애플리케이션 문서와 동일한 도메인 및 프로토콜에서만 템플릿을로드합니다. 이는 템플릿 URL에서 &lt;a href=&quot;%24sce#getTrustedResourceUrl.html&quot;&gt;$ sce.getTrustedResourceUrl&lt;/a&gt; 을 호출하여 수행됩니다 . 다른 도메인 및 / 또는 프로토콜에서 템플릿을로드하려면이를 &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;trustedResourceUrlList에&lt;/a&gt; 추가 하거나 신뢰할 수있는 값으로 &lt;a href=&quot;%24sce#trustAsResourceUrl.html&quot;&gt;래핑 할&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1966d304ab081cea6a8b5d7d37a52d0b976b638f" translate="yes" xml:space="preserve">
          <source>By default, animations are disabled when the AngularJS app &lt;a href=&quot;bootstrap&quot;&gt;bootstraps&lt;/a&gt;. If you are using the &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt;&lt;code&gt;ngApp&lt;/code&gt;&lt;/a&gt; directive, this happens in the &lt;code&gt;DOMContentLoaded&lt;/code&gt; event, so immediately after the page has been loaded. Animations are disabled, so that UI and content are instantly visible. Otherwise, with many animations on the page, the loading process may become too visually overwhelming, and the performance may suffer.</source>
          <target state="translated">AngularJS 앱이 &lt;a href=&quot;bootstrap&quot;&gt;부트 스트랩&lt;/a&gt; 될 때 애니메이션은 기본적으로 비활성화되어 있습니다 . &lt;a href=&quot;../api/ng/directive/ngapp&quot;&gt; &lt;code&gt;ngApp&lt;/code&gt; &lt;/a&gt; 지시문을 사용하는 경우 이는 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 이벤트 에서 발생 하므로 페이지가로드 된 직후에 발생합니다. 애니메이션이 비활성화되어 UI와 내용을 즉시 볼 수 있습니다. 그렇지 않으면 페이지에 많은 애니메이션이 있으면로드 프로세스가 시각적으로 너무 압도되어 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4843033cbd0e8a2de04acc71992eef26af1ccc" translate="yes" xml:space="preserve">
          <source>By default, any &lt;code&gt;ngAnimate&lt;/code&gt;-enabled directives will assume that &lt;code&gt;transition&lt;/code&gt; / &lt;code&gt;animation&lt;/code&gt; styles on the element are part of an &lt;code&gt;ngAnimate&lt;/code&gt; animation. This can lead to problems when the styles are actually for animations that are independent of &lt;code&gt;ngAnimate&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;ngAnimate&lt;/code&gt; 사용 가능 지시문은 요소의 &lt;code&gt;transition&lt;/code&gt; / &lt;code&gt;animation&lt;/code&gt; 스타일이 &lt;code&gt;ngAnimate&lt;/code&gt; 애니메이션의 일부 라고 가정합니다 . 스타일이 실제로 &lt;code&gt;ngAnimate&lt;/code&gt; 와 독립적 인 애니메이션에 대한 경우 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a89e6cd1f35ad33962ebab128b602ce984b62740" translate="yes" xml:space="preserve">
          <source>By default, any change to the content will trigger a model update and form validation. You can override this behavior using the &lt;a href=&quot;../api/ng/directive/ngmodeloptions&quot;&gt;ngModelOptions&lt;/a&gt; directive to bind only to specified list of events. I.e. &lt;code&gt;ng-model-options=&quot;{ updateOn: 'blur' }&quot;&lt;/code&gt; will update and validate only after the control loses focus. You can set several events using a space delimited list. I.e. &lt;code&gt;ng-model-options=&quot;{ updateOn: 'mousedown blur' }&quot;&lt;/code&gt;</source>
          <target state="translated">기본적으로 컨텐츠를 변경하면 모델 업데이트 및 양식 유효성 검사가 트리거됩니다. &lt;a href=&quot;../api/ng/directive/ngmodeloptions&quot;&gt;ngModelOptions&lt;/a&gt; 지시문을 사용하여이 동작을 재정 의하여 지정된 이벤트 목록에만 바인딩 할 수 있습니다. 즉 &lt;code&gt;ng-model-options=&quot;{ updateOn: 'blur' }&quot;&lt;/code&gt; 은 컨트롤이 포커스를 잃은 후에 만 ​​업데이트되고 유효성이 검사됩니다. 공백으로 구분 된 목록을 사용하여 여러 이벤트를 설정할 수 있습니다. 즉 &lt;code&gt;ng-model-options=&quot;{ updateOn: 'mousedown blur' }&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="500f830c32748a1f53ff5f9a7775baaecd3aa39e" translate="yes" xml:space="preserve">
          <source>By default, ngMock will create an injector per test case to ensure your tests do not affect each other. However, if we want to use &lt;code&gt;beforeAll()&lt;/code&gt;, ngMock will have to create the injector before any test cases are run, and share that injector through all the cases for that &lt;code&gt;describe&lt;/code&gt;. That is where &lt;a href=&quot;../api/ngmock/function/angular.mock.module.sharedinjector&quot;&gt;module.sharedInjector()&lt;/a&gt; comes in. When it's called within a &lt;code&gt;describe&lt;/code&gt; block, a single injector is shared between all hooks and test cases run in that block.</source>
          <target state="translated">기본적으로 ngMock은 테스트가 서로 영향을 미치지 않도록 테스트 사례별로 인젝터를 만듭니다. 그러나 &lt;code&gt;beforeAll()&lt;/code&gt; 을 사용하려면 ngMock 은 테스트 사례가 실행되기 전에 인젝터를 생성하고 해당 인젝터를 &lt;code&gt;describe&lt;/code&gt; 의 모든 사례를 통해 공유해야 합니다 . 곳이다 &lt;a href=&quot;../api/ngmock/function/angular.mock.module.sharedinjector&quot;&gt;module.sharedInjector ()가&lt;/a&gt; 제공됩니다. 그것이 내라고하면 &lt;code&gt;describe&lt;/code&gt; 블록을 하나의 인젝터가 그 블록에서 실행되는 모든 후크 및 테스트 케이스 사이에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="85a705fceaf0b765e21238642283db4e9a9de198" translate="yes" xml:space="preserve">
          <source>By default, query parameters on request URLs are parsed into the &lt;code&gt;params&lt;/code&gt; object. So a request URL of &lt;code&gt;/list?q=searchstr&amp;amp;orderby=-name&lt;/code&gt; would set &lt;code&gt;params&lt;/code&gt; to be &lt;code&gt;{q: 'searchstr', orderby: '-name'}&lt;/code&gt;.</source>
          <target state="translated">기본적으로 요청 URL의 쿼리 매개 변수는 &lt;code&gt;params&lt;/code&gt; 객체 로 구문 분석됩니다 . 의 요청 URL 그래서 &lt;code&gt;/list?q=searchstr&amp;amp;orderby=-name&lt;/code&gt; 설정합니다 &lt;code&gt;params&lt;/code&gt; 수 &lt;code&gt;{q: 'searchstr', orderby: '-name'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7198ac8768b77ff593616dc4b6e2aca0b18676a4" translate="yes" xml:space="preserve">
          <source>By default, the &quot;required&quot; error on the ngModelController is only set on a required select when the empty option is selected. This example adds a custom directive that also sets the error when the unknown option is selected.</source>
          <target state="translated">기본적으로 ngModelController의 &quot;필수&quot;오류는 빈 옵션이 선택된 경우 필수 선택에서만 설정됩니다. 이 예제는 알 수없는 옵션을 선택할 때 오류를 설정하는 사용자 지정 지시문을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e221e45c15e66ddc82e3f4a4feda670a95e982cd" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt;&lt;code&gt;$watch&lt;/code&gt;&lt;/a&gt; method is used for tracking changes, and the equality check is based on object identity. However, if an object literal or an array literal is passed as the binding expression, the equality check is done by value (using the &lt;a href=&quot;../function/angular.equals&quot;&gt;&lt;code&gt;angular.equals&lt;/code&gt;&lt;/a&gt; function). It's also possible to watch the evaluated value shallowly with &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt;&lt;code&gt;$watchCollection&lt;/code&gt;&lt;/a&gt;: use &lt;code&gt;=*&lt;/code&gt; or &lt;code&gt;=*attr&lt;/code&gt;</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt; &lt;code&gt;$watch&lt;/code&gt; &lt;/a&gt; 메소드는 변경 사항을 추적하는 데 사용되며 동등성 검사는 객체 ID를 기반으로합니다. 그러나 객체 리터럴 또는 배열 리터럴이 바인딩 표현식으로 전달되면 값에 의해 동등성 검사가 수행됩니다 ( &lt;a href=&quot;../function/angular.equals&quot;&gt; &lt;code&gt;angular.equals&lt;/code&gt; &lt;/a&gt; 함수 사용). &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt; &lt;code&gt;$watchCollection&lt;/code&gt; &lt;/a&gt; 사용 하여 평가 된 값을 얕게 볼 수도 있습니다 . use &lt;code&gt;=*&lt;/code&gt; 또는 &lt;code&gt;=*attr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0973385c3a816fcb28f0098577f72a074edba112" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt;&lt;code&gt;$watch&lt;/code&gt;&lt;/a&gt; method is used for tracking changes, and the equality check is based on object identity. It's also possible to watch the evaluated value shallowly with &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt;&lt;code&gt;$watchCollection&lt;/code&gt;&lt;/a&gt;: use &lt;code&gt;&amp;lt;*&lt;/code&gt; or &lt;code&gt;&amp;lt;*attr&lt;/code&gt;</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../type/%24rootscope.scope#%24watch.html&quot;&gt; &lt;code&gt;$watch&lt;/code&gt; &lt;/a&gt; 메소드는 변경 사항을 추적하는 데 사용되며 동등성 검사는 객체 ID를 기반으로합니다. &lt;a href=&quot;../type/%24rootscope.scope#%24watchCollection.html&quot;&gt; &lt;code&gt;$watchCollection&lt;/code&gt; &lt;/a&gt; 평가 된 값을 얕게 볼 수도 있습니다 : use &lt;code&gt;&amp;lt;*&lt;/code&gt; or &lt;code&gt;&amp;lt;*attr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb24723013a0e6e79cb996d2a10e6b4c5257acc0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;.ng-hide&lt;/code&gt; class will style the element with &lt;code&gt;display: none !important&lt;/code&gt;. If you wish to change the hide behavior with &lt;code&gt;ngShow&lt;/code&gt;/&lt;code&gt;ngHide&lt;/code&gt;, you can simply overwrite the styles for the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class. Note that the selector that needs to be used is actually &lt;code&gt;.ng-hide:not(.ng-hide-animate)&lt;/code&gt; to cope with extra animation classes that can be added.</source>
          <target state="translated">기본적으로 &lt;code&gt;.ng-hide&lt;/code&gt; 클래스는 요소를 &lt;code&gt;display: none !important&lt;/code&gt; 스타일로 지정합니다 . &lt;code&gt;ngShow&lt;/code&gt; / &lt;code&gt;ngHide&lt;/code&gt; 로 숨기기 동작을 변경 하려면 &lt;code&gt;.ng-hide&lt;/code&gt; CSS 클래스 의 스타일을 덮어 쓰면 됩니다. 사용해야 할 선택기는 실제로 추가 할 수있는 추가 애니메이션 클래스에 대처하기 위해 &lt;code&gt;.ng-hide:not(.ng-hide-animate)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fce47139951721d70fff4365f4ba57737c92ef63" translate="yes" xml:space="preserve">
          <source>By default, the template URL is restricted to the same domain and protocol as the application document. This is done by calling &lt;a href=&quot;../service/%24sce#getTrustedResourceUrl.html&quot;&gt;$sce.getTrustedResourceUrl&lt;/a&gt; on it. To load templates from other domains or protocols you may either &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;whitelist them&lt;/a&gt; or &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;wrap them&lt;/a&gt; as trusted values. Refer to AngularJS's &lt;a href=&quot;../service/%24sce&quot;&gt;Strict Contextual Escaping&lt;/a&gt;.</source>
          <target state="translated">기본적으로 템플릿 URL은 응용 프로그램 문서와 동일한 도메인 및 프로토콜로 제한됩니다. &lt;a href=&quot;../service/%24sce#getTrustedResourceUrl.html&quot;&gt;$ sce.getTrustedResourceUrl&lt;/a&gt; 을 호출 하면됩니다. 다른 도메인이나 프로토콜에서 템플릿을로드하려면 해당 템플릿을 &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;화이트리스트에 추가&lt;/a&gt; 하거나 신뢰할 수있는 값으로 &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;래핑 할&lt;/a&gt; 수 있습니다. AngularJS의 &lt;a href=&quot;../service/%24sce&quot;&gt;엄격한 컨텍스트 이스케이프를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e18e1c3fdfab2d20000435b337eb4b86046b1731" translate="yes" xml:space="preserve">
          <source>By default, the template URL is restricted to the same domain and protocol as the application document. This is done by calling &lt;a href=&quot;../service/%24sce#getTrustedResourceUrl.html&quot;&gt;$sce.getTrustedResourceUrl&lt;/a&gt; on it. To load templates from other domains or protocols you may either add them to your &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;trusted resource URL list&lt;/a&gt; or &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;wrap them&lt;/a&gt; as trusted values. Refer to AngularJS's &lt;a href=&quot;../service/%24sce&quot;&gt;Strict Contextual Escaping&lt;/a&gt;.</source>
          <target state="translated">기본적으로 템플릿 URL은 애플리케이션 문서와 동일한 도메인 및 프로토콜로 제한됩니다. 이는 &lt;a href=&quot;../service/%24sce#getTrustedResourceUrl.html&quot;&gt;$ sce.getTrustedResourceUrl&lt;/a&gt; 을 호출하여 수행됩니다 . 다른 도메인 또는 프로토콜에서 템플릿을로드하려면 &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;신뢰할 수있는 리소스 URL 목록에 추가&lt;/a&gt; 하거나 신뢰할 수있는 값으로 &lt;a href=&quot;../service/%24sce#trustAsResourceUrl.html&quot;&gt;래핑 할&lt;/a&gt; 수 있습니다. AngularJS의 &lt;a href=&quot;../service/%24sce&quot;&gt;Strict Contextual Escaping을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32e44cbd14ed433730fe544c3bfd62ca5f7ab6e5" translate="yes" xml:space="preserve">
          <source>By default, trailing slashes will be stripped from the calculated URLs, which can pose problems with server backends that do not expect that behavior. This can be disabled by configuring the &lt;code&gt;$resourceProvider&lt;/code&gt; like this:</source>
          <target state="translated">기본적으로 후행 슬래시는 계산 된 URL에서 제거되므로 해당 동작을 기대하지 않는 서버 백엔드에 문제가 발생할 수 있습니다. &lt;code&gt;$resourceProvider&lt;/code&gt; 과 같이 구성하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="523150288e3d3cbcdab71e7b4b769b8742b51985" translate="yes" xml:space="preserve">
          <source>By enabling this setting without taking other precautions, you might expose your application to click-hijacking attacks. In these attacks, sanitized svg elements could be positioned outside of the containing element and be rendered over other elements on the page (e.g. a login link). Such behavior can then result in phishing incidents.</source>
          <target state="translated">다른 예방 조치를 취하지 않고이 설정을 활성화하면 응용 프로그램이 클릭 하이재킹 공격에 노출 될 수 있습니다. 이러한 공격에서 위생 처리 된 svg 요소는 포함 요소 외부에 배치되어 페이지의 다른 요소 (예 : 로그인 링크) 위에 렌더링 될 수 있습니다. 그런 동작으로 피싱 사고가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa28a200094d0f8e4952a2572b5bf5b51a4cfccf" translate="yes" xml:space="preserve">
          <source>By implementing these methods, your component can hook into its lifecycle.</source>
          <target state="translated">이러한 방법을 구현하면 구성 요소를 수명주기에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29c9ccc283e35e9d7b41129880c9316c7594e9f5" translate="yes" xml:space="preserve">
          <source>By listening to this event, you can remove event listeners that might cause memory leaks. Listeners registered to scopes and elements are automatically cleaned up when they are destroyed, but if you registered a listener on a service, or registered a listener on a DOM node that isn't being deleted, you'll have to clean it up yourself or you risk introducing a memory leak.</source>
          <target state="translated">이 이벤트를 수신하면 메모리 누수를 일으킬 수있는 이벤트 리스너를 제거 할 수 있습니다. 스코프 및 요소에 등록 된 리스너는 소멸 될 때 자동으로 정리되지만 서비스에 리스너를 등록하거나 삭제되지 않은 DOM 노드에 리스너를 등록한 경우 직접 정리해야합니다. 메모리 누수가 발생할 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c171fe9b3aaa70bdfa6d6276dcd49d45e27676fa" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;transition: 0s&lt;/code&gt;, &lt;code&gt;ngAnimate&lt;/code&gt; will ignore the existing transition styles, and not try to animate them (Javascript animations will still execute, though). This can be used to prevent &lt;a href=&quot;animations#preventing-collisions-with-existing-animations-and-third-party-libraries.html&quot;&gt;issues with existing animations interfering with &lt;code&gt;ngAnimate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transition: 0s&lt;/code&gt; 를 설정 하면 &lt;code&gt;ngAnimate&lt;/code&gt; 는 기존 전환 스타일을 무시하고 애니메이션을 적용하지 않습니다 (Javascript 애니메이션은 계속 실행 됨). &lt;a href=&quot;animations#preventing-collisions-with-existing-animations-and-third-party-libraries.html&quot;&gt;기존 애니메이션이 &lt;code&gt;ngAnimate&lt;/code&gt; 를&lt;/a&gt; 방해 하는 문제 를 방지하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="763c7e134cede96adf42badc199f39b157262036" translate="yes" xml:space="preserve">
          <source>By setting the &lt;code&gt;getterSetter&lt;/code&gt; property to true you are telling ngModel that the &lt;code&gt;ngModel&lt;/code&gt; expression on the scope refers to a &quot;getter/setter&quot; function rather than the value itself.</source>
          <target state="translated">&lt;code&gt;getterSetter&lt;/code&gt; 속성을 true 로 설정하면 범위 의 &lt;code&gt;ngModel&lt;/code&gt; 표현식이 값 자체가 아닌 &quot;getter / setter&quot;함수를 참조 한다고 ngModel에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="d37d16187a12d14dca29958bee98c95dd2595b03" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;!important&lt;/code&gt;, the show and hide behavior will work as expected despite any clash between CSS selector specificity (when &lt;code&gt;!important&lt;/code&gt; isn't used with any conflicting styles). If a developer chooses to override the styling to change how to hide an element then it is just a matter of using &lt;code&gt;!important&lt;/code&gt; in their own CSS code.</source>
          <target state="translated">&lt;code&gt;!important&lt;/code&gt; 를 사용 하면 CSS 선택기의 특수성 ( &lt;code&gt;!important&lt;/code&gt; 가 충돌하는 스타일과 함께 사용되지 않는 경우)간에 충돌이 발생하더라도 show 및 hide 동작이 예상대로 작동 합니다. 개발자가 스타일을 재정 의하여 요소를 숨기는 방법을 변경하기로 결정한 경우 자체 CSS 코드에서 &lt;code&gt;!important&lt;/code&gt; 를 사용하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab7870cd0f2f0c17b236bdc86d6ea708504a5cb8" translate="yes" xml:space="preserve">
          <source>CSS + JS Animations Together</source>
          <target state="translated">CSS + JS 애니메이션</target>
        </trans-unit>
        <trans-unit id="43bd3c1e45e7e9c523e66a4eeb74db09cdd9706e" translate="yes" xml:space="preserve">
          <source>CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out what CSS classes differ between the starting element and the destination element. These different CSS classes will be added/removed on the anchor element and a transition will be applied (the transition that is provided in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since the cloned element is placed inside of root element which is likely close to the body element).</source>
          <target state="translated">CSS Anchoring은 전환과 키 프레임에 의존하며 내부 코드는 시작 요소와 대상 요소 사이의 CSS 클래스가 무엇인지 파악할 수있을 정도로 지능적입니다. 이러한 다른 CSS 클래스는 앵커 요소에서 추가 / 제거되고 전환 (앵커 클래스에서 제공되는 전환)이 적용됩니다. 간단히 말해, ngAnimate는 추가 및 제거 할 클래스를 찾아서 요소를 최대한 부드럽고 자동으로 전환합니다. 앵커 요소가 시작 요소와 동일하게 표시되도록 DOM 중첩 구조에 의존하지 않는 간단한 CSS 클래스를 사용해야합니다 (복제 요소가 본문 요소에 가까운 루트 요소 내에 배치되므로).</target>
        </trans-unit>
        <trans-unit id="0f55d5c092d0ff662c046991d7571e5ba312c6ba" translate="yes" xml:space="preserve">
          <source>CSS Class-based Animations</source>
          <target state="translated">CSS 클래스 기반 애니메이션</target>
        </trans-unit>
        <trans-unit id="bbe967875f19b43ebcf8ae9cc8592cc142b0fc64" translate="yes" xml:space="preserve">
          <source>CSS Staggering Animations</source>
          <target state="translated">CSS 스 태거 애니메이션</target>
        </trans-unit>
        <trans-unit id="21444efa9494abd66434381371c755d1d31f0244" translate="yes" xml:space="preserve">
          <source>CSS classes</source>
          <target state="translated">CSS 클래스</target>
        </trans-unit>
        <trans-unit id="4785c5decce46adb9da8916ce47b654ac25c1fa0" translate="yes" xml:space="preserve">
          <source>CSS-based Animations</source>
          <target state="translated">CSS 기반 애니메이션</target>
        </trans-unit>
        <trans-unit id="b0a851e9310143c493ee5626ebda91ac22925d52" translate="yes" xml:space="preserve">
          <source>CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML and CSS code we can create an animation that will be picked up by AngularJS when an underlying directive performs an operation.</source>
          <target state="translated">ngAnimate를 사용하는 CSS 기반 애니메이션은 JavaScript 코드가 전혀 필요하지 않으므로 고유합니다. HTML과 CSS 코드 사이에서 참조하는 CSS 클래스를 사용하여 기본 지시문이 작업을 수행 할 때 AngularJS가 선택할 애니메이션을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2cd38d164b13f9a7249cbfb4a4b5ef9fc8b5c5d" translate="yes" xml:space="preserve">
          <source>Cache name of the template.</source>
          <target state="translated">템플릿의 캐시 이름.</target>
        </trans-unit>
        <trans-unit id="4841830df2aa5c0a9fdc5cf539d835c1b65395ec" translate="yes" xml:space="preserve">
          <source>Cache object identified by the cacheId or undefined if no such cache.</source>
          <target state="translated">cacheId로 식별 된 캐시 오브젝트 또는 그러한 캐시가없는 경우 정의되지 않음.</target>
        </trans-unit>
        <trans-unit id="322c7ca089e85e4cdaa343c933e86bd05885e89f" translate="yes" xml:space="preserve">
          <source>Cached responses are returned asynchronously, in the same way as responses from the server.</source>
          <target state="translated">캐시 된 응답은 서버의 응답과 같은 방식으로 비동기식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="78d83114a9f21cb004c811c700f1ebf657586754" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;compiler&quot;&gt;compile&lt;/a&gt; the element into an executable, bi-directionally bound application.</source>
          <target state="translated">&lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt; 을 호출 하여 양방향으로 바인딩 된 실행 가능한 응용 프로그램으로 요소 를 &lt;a href=&quot;compiler&quot;&gt;컴파일&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="b162081de98877f8d47457aad07d35f7c7120470" translate="yes" xml:space="preserve">
          <source>Call this method as a setter to enable/disable eager instantiation of the &lt;a href=&quot;../service/%24route&quot;&gt;$route&lt;/a&gt; service upon application bootstrap. You can also call it as a getter (i.e. without any arguments) to get the current value of the &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; flag.</source>
          <target state="translated">응용 프로그램 부트 스트랩 에서 &lt;a href=&quot;../service/%24route&quot;&gt;$ route&lt;/a&gt; 서비스 의 빠른 인스턴스화를 활성화 / 비활성화하려면이 메소드를 setter로 호출하십시오 . 또한 &lt;code&gt;eagerInstantiationEnabled&lt;/code&gt; 플래그 의 현재 값을 얻기 위해 getter (인수없이)로 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e14131abb69b67447b042d7e96d77593367604f4" translate="yes" xml:space="preserve">
          <source>Call this method to determine if this scope has been explicitly suspended. It will not tell you whether an ancestor has been suspended. To determine if this scope will be excluded from a digest triggered at the $rootScope, for example, you must check all its ancestors:</source>
          <target state="translated">이 범위를 명시 적으로 일시 중단했는지 확인하려면이 메서드를 호출하십시오. 조상이 정지되었는지 여부는 알려주지 않습니다. 예를 들어, $ rootScope에서 트리거 된 다이제스트에서이 범위가 제외되는지 확인하려면 모든 조상을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f35d12cb9238244359750cfa0d0a76f474d059bf" translate="yes" xml:space="preserve">
          <source>Call this method to enable / disable the strict component bindings check. If enabled, the compiler will enforce that all scope / controller bindings of a &lt;a href=&quot;%24compileprovider#directive.html&quot;&gt;directive&lt;/a&gt; / &lt;a href=&quot;%24compileprovider#component.html&quot;&gt;component&lt;/a&gt; that are not set as optional with &lt;code&gt;?&lt;/code&gt;, must be provided when the directive is instantiated. If not provided, the compiler will throw the &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/provider/error/%24compile/missingattr&quot;&gt;$compile:missingattr error&lt;/a&gt;.</source>
          <target state="translated">엄격한 컴포넌트 바인딩 확인을 사용하거나 사용하지 않으려면이 메소드를 호출하십시오. 활성화 된 경우 컴파일러는 &lt;code&gt;?&lt;/code&gt; 옵션으로 설정되지 않은 &lt;a href=&quot;%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; / &lt;a href=&quot;%24compileprovider#component.html&quot;&gt;구성 요소&lt;/a&gt; 의 모든 범위 / 컨트롤러 바인딩을 강제 실행 합니까? 지시문이 인스턴스화 될 때 제공되어야합니다. 제공하지 않으면 컴파일러는 &lt;a href=&quot;https://code.angularjs.org/1.7.8/docs/api/ng/provider/error/%24compile/missingattr&quot;&gt;$ compile : missingattr error를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc607bf3e373e4f665a14de95e82b50012f066fc" translate="yes" xml:space="preserve">
          <source>Call this method to enable / disable the strict component bindings check. If enabled, the compiler will enforce that all scope / controller bindings of a &lt;a href=&quot;%24compileprovider#directive.html&quot;&gt;directive&lt;/a&gt; / &lt;a href=&quot;%24compileprovider#component.html&quot;&gt;component&lt;/a&gt; that are not set as optional with &lt;code&gt;?&lt;/code&gt;, must be provided when the directive is instantiated. If not provided, the compiler will throw the &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/api/ng/provider/error/%24compile/missingattr&quot;&gt;$compile:missingattr error&lt;/a&gt;.</source>
          <target state="translated">엄격한 구성 요소 바인딩 검사를 활성화 / 비활성화하려면이 메서드를 호출합니다. 사용 가능한 경우, 컴파일러는 강제로 적용하는 모든 범위 / 컨트롤러 바인딩 &lt;a href=&quot;%24compileprovider#directive.html&quot;&gt;지침&lt;/a&gt; / &lt;a href=&quot;%24compileprovider#component.html&quot;&gt;구성 요소&lt;/a&gt; 와 함께 옵션으로 설정되어 있지 &lt;code&gt;?&lt;/code&gt; , 지시문이 인스턴스화 될 때 제공되어야합니다. 제공되지 않으면 컴파일러는 &lt;a href=&quot;https://code.angularjs.org/1.8.2/docs/api/ng/provider/error/%24compile/missingattr&quot;&gt;$ compile : missingattr 오류를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc4eaaf9dbe4e310951ac61cd764aaa491556cb9" translate="yes" xml:space="preserve">
          <source>Call this method to enable/disable various debug runtime information in the compiler such as adding binding information and a reference to the current scope on to DOM elements. If enabled, the compiler will add the following to DOM elements that have been bound to the scope</source>
          <target state="translated">바인딩 정보 및 DOM 요소에 대한 현재 범위에 대한 참조 추가와 같은 컴파일러에서 다양한 디버그 런타임 정보를 활성화 / 비활성화하려면이 메소드를 호출하십시오. 활성화 된 경우 컴파일러는 범위에 바인딩 된 DOM 요소에 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1440403750e2ed45b458c5ac229f85fb683fa150" translate="yes" xml:space="preserve">
          <source>Callback called whenever the return value of any expression in &lt;code&gt;watchExpressions&lt;/code&gt; changes The &lt;code&gt;newValues&lt;/code&gt; array contains the current values of the &lt;code&gt;watchExpressions&lt;/code&gt;, with the indexes matching those of &lt;code&gt;watchExpression&lt;/code&gt; and the &lt;code&gt;oldValues&lt;/code&gt; array contains the previous values of the &lt;code&gt;watchExpressions&lt;/code&gt;, with the indexes matching those of &lt;code&gt;watchExpression&lt;/code&gt; The &lt;code&gt;scope&lt;/code&gt; refers to the current scope.</source>
          <target state="translated">어떤 식의 리턴 값마다 콜백 전화 &lt;code&gt;watchExpressions&lt;/code&gt; 가 변경 &lt;code&gt;newValues&lt;/code&gt; 의 배열은 현재의 값이 포함 &lt;code&gt;watchExpressions&lt;/code&gt; 을 들과 일치하는 인덱스, &lt;code&gt;watchExpression&lt;/code&gt; 을 상기 &lt;code&gt;oldValues&lt;/code&gt; 의 배열은 이전 값을 포함 &lt;code&gt;watchExpressions&lt;/code&gt; 을 들과 일치하는 인덱스, &lt;code&gt;watchExpression&lt;/code&gt; 을 &lt;code&gt;scope&lt;/code&gt; 는 현재 범위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d70eaf5bd89066c1b42f522abbd8dee8568dd708" translate="yes" xml:space="preserve">
          <source>Callback called whenever the value of &lt;code&gt;watchExpression&lt;/code&gt; changes.</source>
          <target state="translated">&lt;code&gt;watchExpression&lt;/code&gt; 값이 변경 될 때마다 콜백이 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c689cdead0e90f013714cd4077f4ea01b650f8c" translate="yes" xml:space="preserve">
          <source>Callbacks and Promises</source>
          <target state="translated">콜백 및 약속</target>
        </trans-unit>
        <trans-unit id="6f75995f3b255bdefeacf9e236456a83f540b1a9" translate="yes" xml:space="preserve">
          <source>Called when the view needs to be updated. It is expected that the user of the ng-model directive will implement this method.</source>
          <target state="translated">뷰를 업데이트해야 할 때 호출됩니다. ng-model 지시문의 사용자가이 메소드를 구현할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="63675a1d70484b5f1fc1c3405a8ded5f332fcc61" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;$digest()&lt;/code&gt; directly on a descendant of a suspended scope will still run the watchers for that scope and its descendants. When digesting we only check whether the current scope is locally suspended, rather than checking whether it has a suspended ancestor.</source>
          <target state="translated">일시 중단 된 범위의 하위 항목에서 &lt;code&gt;$digest()&lt;/code&gt; 직접 호출 하면 해당 범위 및 해당 하위 항목의 감시자가 계속 실행됩니다. 다이제스트 할 때 조상이 일시 중단되었는지 확인하는 것이 아니라 현재 범위가 로컬로 일시 중단되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="49fc3e72976c3ca65e702be767e99bb84f601ccf" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;$resume()&lt;/code&gt; on a scope that has a suspended ancestor will not cause the scope to be included in future digests until all its ancestors have been resumed.</source>
          <target state="translated">조상이 일시 중단 된 범위에서 &lt;code&gt;$resume()&lt;/code&gt; 을 호출 하면 모든 조상이 다시 시작될 때까지 이후 다이제스트에 해당 범위가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20c938d13e09b0f80b5576ad14ce6af88219cf0d" translate="yes" xml:space="preserve">
          <source>Calling the linking function returns the element of the template. It is either the original element passed in, or the clone of the element if the &lt;code&gt;cloneAttachFn&lt;/code&gt; is provided.</source>
          <target state="translated">연결 함수를 호출하면 템플릿의 요소가 반환됩니다. &lt;code&gt;cloneAttachFn&lt;/code&gt; 이 제공된 경우 전달 된 원래 요소이거나 요소의 복제본입니다 .</target>
        </trans-unit>
        <trans-unit id="e6781591ce11dba9f9d2938ebe354ec4a507a51c" translate="yes" xml:space="preserve">
          <source>Calling these methods invoke &lt;a href=&quot;../../ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; with the specified http method, destination and parameters. When the data is returned from the server then the object is an instance of the resource class. The actions &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; are available on it as methods with the &lt;code&gt;$&lt;/code&gt; prefix. This allows you to easily perform CRUD operations (create, read, update, delete) on server-side data like this:</source>
          <target state="translated">이러한 메소드를 호출 하면 지정된 http 메소드, 대상 및 매개 변수로 &lt;a href=&quot;../../ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 가 호출 됩니다. 서버에서 데이터가 리턴되면 오브젝트는 자원 클래스의 인스턴스입니다. &lt;code&gt;save&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 조치 는 &lt;code&gt;$&lt;/code&gt; 접 두부 가있는 메소드로 사용 가능 합니다. 이를 통해 다음과 같이 서버 측 데이터에서 CRUD 작업 (생성, 읽기, 업데이트, 삭제)을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31893b7919db92062b0a54add3dc3c1b08b461ce" translate="yes" xml:space="preserve">
          <source>Calling these methods invokes &lt;code&gt;$http&lt;/code&gt; on the &lt;code&gt;url&lt;/code&gt; template with the given HTTP &lt;code&gt;method&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt; and &lt;code&gt;headers&lt;/code&gt;.</source>
          <target state="translated">이러한 메소드를 호출 하면 주어진 HTTP &lt;code&gt;method&lt;/code&gt; , &lt;code&gt;params&lt;/code&gt; 및 &lt;code&gt;headers&lt;/code&gt; 를 사용하여 &lt;code&gt;url&lt;/code&gt; 템플리트 에서 &lt;code&gt;$http&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="91a3b32b3f576fa1a25afa0ab7e2394916694e74" translate="yes" xml:space="preserve">
          <source>Calling this function with false disables the compilation of directives on comments for the whole application. This results in a compilation performance gain, as the compiler doesn't have to check comments when looking for directives. This should however only be used if you are sure that no comment directives are used in the application (including any 3rd party directives).</source>
          <target state="translated">이 함수를 false로 호출하면 전체 응용 프로그램의 주석에 대한 지시문 컴파일이 비활성화됩니다. 컴파일러가 지시문을 찾을 때 주석을 확인할 필요가 없기 때문에 컴파일 성능이 향상됩니다. 그러나 응용 프로그램에 주석 지시문이 사용되지 않은 경우 (타사 지시문 포함)에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbbb4b5eaa44b0b5551e31e4b0525bc03141436e" translate="yes" xml:space="preserve">
          <source>Calling this function with false disables the compilation of directives on element classes for the whole application. This results in a compilation performance gain, as the compiler doesn't have to check element classes when looking for directives. This should however only be used if you are sure that no class directives are used in the application (including any 3rd party directives).</source>
          <target state="translated">이 함수를 false로 호출하면 전체 응용 프로그램의 요소 클래스에서 지시문 컴파일이 비활성화됩니다. 컴파일러가 지시문을 찾을 때 요소 클래스를 확인할 필요가 없기 때문에 컴파일 성능이 향상됩니다. 그러나 응용 프로그램에서 클래스 지시문이 사용되지 않는 경우 (타사 지시문 포함)에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a4aefee23fa0c2ddc499c67e421bc097332c1e9" translate="yes" xml:space="preserve">
          <source>Can I disable SCE completely?</source>
          <target state="translated">SCE를 완전히 비활성화 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="38a4b640b107f7de6465c3ff929cb568050eaed3" translate="yes" xml:space="preserve">
          <source>Can be one of:</source>
          <target state="translated">다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3816f23c92cddb7d9eb035e560daee147a023eaf" translate="yes" xml:space="preserve">
          <source>Cancel an update and reset the input element's value to prevent an update to the &lt;code&gt;$modelValue&lt;/code&gt;, which may be caused by a pending debounced event or because the input is waiting for some future event.</source>
          <target state="translated">보류중인 디 바운스 된 이벤트로 인해 또는 입력이 향후 이벤트를 기다리고 있기 때문에 &lt;code&gt;$modelValue&lt;/code&gt; 대한 업데이트를 방지하려면 업데이트를 취소하고 입력 요소의 값을 재설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="da189d192d9888fffe6e40083bb8393ace97b3e9" translate="yes" xml:space="preserve">
          <source>Cancelling requests</source>
          <target state="translated">요청 취소</target>
        </trans-unit>
        <trans-unit id="838a9d672c095a05992dfe53058bf7ccd9ff411d" translate="yes" xml:space="preserve">
          <source>Cancels a task associated with the &lt;code&gt;promise&lt;/code&gt;.</source>
          <target state="translated">관련 작업을 취소합니다 &lt;code&gt;promise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fc80b14e6aaae3cc1ada473f23aa327b69f4333" translate="yes" xml:space="preserve">
          <source>Cancels a task associated with the &lt;code&gt;promise&lt;/code&gt;. As a result of this, the promise will be resolved with a rejection.</source>
          <target state="translated">관련 작업을 취소합니다 &lt;code&gt;promise&lt;/code&gt; . 그 결과 약속은 거절로 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="edecf4dc2de919262a28ba9a2f7840added3c399" translate="yes" xml:space="preserve">
          <source>Cancels the provided animation and applies the end state of the animation. Note that this does not cancel the underlying operation, e.g. the setting of classes or adding the element to the DOM.</source>
          <target state="translated">제공된 애니메이션을 취소하고 애니메이션의 종료 상태를 적용합니다. 이로 인해 기본 설정 (예 : 클래스 설정 또는 요소를 DOM에 추가)이 취소되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="43a94b1cd16e828fd25f079b0c6f119d1c492ce3" translate="yes" xml:space="preserve">
          <source>Case Studies</source>
          <target state="translated">사례 연구</target>
        </trans-unit>
        <trans-unit id="f2e31c0705378a0ca912d442b249a5361708204c" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;$route&lt;/code&gt; service to reload the current route even if &lt;a href=&quot;../../ng/service/%24location&quot;&gt;$location&lt;/a&gt; hasn't changed.</source>
          <target state="translated">원인 &lt;code&gt;$route&lt;/code&gt; 현재 경로를 다시로드 서비스를 경우에도 &lt;a href=&quot;../../ng/service/%24location&quot;&gt;$ 위치&lt;/a&gt; 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="60afdcebb41362038962725243c0aed09552fc50" translate="yes" xml:space="preserve">
          <source>Causes &lt;code&gt;$route&lt;/code&gt; service to update the current URL, replacing current route parameters with those specified in &lt;code&gt;newParams&lt;/code&gt;. Provided property names that match the route's path segment definitions will be interpolated into the location's path, while remaining properties will be treated as query params.</source>
          <target state="translated">원인 &lt;code&gt;$route&lt;/code&gt; 에 지정된 것과 현재 경로 매개 변수를 대체 현재 URL을 업데이트하는 서비스, &lt;code&gt;newParams&lt;/code&gt; 를 . 라우트의 경로 세그먼트 정의와 일치하는 제공된 특성 이름은 위치의 경로로 보간되며 나머지 특성은 쿼리 매개 변수로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="72d71a668e56adbe90d2fa9fb6ee8972c0b66e4a" translate="yes" xml:space="preserve">
          <source>Chaining promises</source>
          <target state="translated">연쇄 약속</target>
        </trans-unit>
        <trans-unit id="58e493046d8fd6e3081b6c746a33e60405b9effa" translate="yes" xml:space="preserve">
          <source>Change path when called with parameter and return &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수와 함께 호출 될 때 경로를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca2424dc0deb99a58c19e534f338127124d9aab" translate="yes" xml:space="preserve">
          <source>Change path, search and hash, when called with parameter and return &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수로 호출 될 때 경로, 검색 및 해시를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="da91b66135a4f77c9cc08ce3eaa7130f2a6d2b72" translate="yes" xml:space="preserve">
          <source>Change search part when called with parameter and return &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수와 함께 호출 될 때 검색 파트를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="c02c34ae53310357e58911c775459e9c3de3ba96" translate="yes" xml:space="preserve">
          <source>Change the URL.</source>
          <target state="translated">URL을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="927385537fbe1015a617be665c6693f672fb3a52" translate="yes" xml:space="preserve">
          <source>Change the history state object when called with one parameter and return &lt;code&gt;$location&lt;/code&gt;. The state object is later passed to &lt;code&gt;pushState&lt;/code&gt; or &lt;code&gt;replaceState&lt;/code&gt;.</source>
          <target state="translated">하나의 매개 변수로 호출 될 때 히스토리 상태 오브젝트를 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴하십시오 . 상태 객체는 나중에 &lt;code&gt;pushState&lt;/code&gt; 또는 &lt;code&gt;replaceState&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fa9f4c8eaa824574dae37f62154980d60ca28a4" translate="yes" xml:space="preserve">
          <source>Change the validity state of the form, and notify the parent form (if any).</source>
          <target state="translated">양식의 유효성 상태를 변경하고 부모 양식 (있는 경우)에 알리십시오.</target>
        </trans-unit>
        <trans-unit id="667e7970ed20e88c4e980d20c8d0629557dd7400" translate="yes" xml:space="preserve">
          <source>Change the validity state, and notify the form.</source>
          <target state="translated">유효성 상태를 변경하고 양식에 알리십시오.</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">Changelog</target>
        </trans-unit>
        <trans-unit id="1403f945a22ede84f416992deee9c6911dc2c57f" translate="yes" xml:space="preserve">
          <source>Changes the address bar.</source>
          <target state="translated">주소 표시 줄을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="318dfbf2d67fa7b4fded5ca142121201dcf2c9ef" translate="yes" xml:space="preserve">
          <source>Changes the address in the browser's address bar.</source>
          <target state="translated">브라우저의 주소 표시 줄에서 주소를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="5b764ac2b679596bebc6492993329bbb0d3fd0d8" translate="yes" xml:space="preserve">
          <source>Changes the hash fragment when called with a parameter and returns &lt;code&gt;$location&lt;/code&gt;.</source>
          <target state="translated">매개 변수와 함께 호출 될 때 해시 조각을 변경하고 &lt;code&gt;$location&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c0bb203b42d991b17fac172d8578a01b132de763" translate="yes" xml:space="preserve">
          <source>Changes to the model inside &lt;code&gt;$doCheck&lt;/code&gt; will trigger new turns of the digest loop, which will cause the changes to be propagated throughout the application. Angular does not allow the &lt;code&gt;ngDoCheck&lt;/code&gt; hook to trigger a change outside of the component. It will either throw an error or do nothing depending upon the state of &lt;code&gt;enableProdMode()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$doCheck&lt;/code&gt; 내에서 모델을 변경 하면 다이제스트 루프의 새로운 회전이 트리거되어 변경 사항이 애플리케이션 전체에 전파됩니다. Angular는 &lt;code&gt;ngDoCheck&lt;/code&gt; 후크가 컴포넌트 외부에서 변경을 트리거 할 수 없습니다 . &lt;code&gt;enableProdMode()&lt;/code&gt; 상태에 따라 오류가 발생하거나 아무 것도 수행하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7409e3021a2ae10433e51958a73352a869dfdffa" translate="yes" xml:space="preserve">
          <source>Changing parameters dynamically</source>
          <target state="translated">동적으로 매개 변수 변경</target>
        </trans-unit>
        <trans-unit id="5e785584860674d65fa52977c48c6a2d8ab7530e" translate="yes" xml:space="preserve">
          <source>ChildRouter</source>
          <target state="translated">ChildRouter</target>
        </trans-unit>
        <trans-unit id="395f9525e05660c43c121056b86241cf54b50bdc" translate="yes" xml:space="preserve">
          <source>Choose: &lt;code&gt;angular-[version].js&lt;/code&gt; for a human-readable file, suitable for development and debugging.</source>
          <target state="translated">개발 및 디버깅에 적합한 사람이 읽을 수있는 파일의 경우 &lt;code&gt;angular-[version].js&lt;/code&gt; 를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d01471977547f403988a18fa90d7812ed92cad5" translate="yes" xml:space="preserve">
          <source>Choose: &lt;code&gt;angular-[version].min.js&lt;/code&gt; for a compressed and obfuscated file, suitable for use in production.</source>
          <target state="translated">프로덕션에 사용하기에 적합한 압축 및 난독 처리 된 파일의 경우 &lt;code&gt;angular-[version].min.js&lt;/code&gt; 를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0fa5d9e8c5bdec155184c067e6fec7c8bb15af2" translate="yes" xml:space="preserve">
          <source>Choosing between ngRepeat and ngOptions</source>
          <target state="translated">ngRepeat와 ngOptions 중에서 선택</target>
        </trans-unit>
        <trans-unit id="6f950f66f6524d1d6d701a16679a2f3ae7d90d78" translate="yes" xml:space="preserve">
          <source>Chrome Accessibility Developer Tools</source>
          <target state="translated">Chrome 접근성 개발자 도구</target>
        </trans-unit>
        <trans-unit id="71c207df916db009b3057f6560a48a47fcc25310" translate="yes" xml:space="preserve">
          <source>Class actions return an empty instance (with the additional properties listed below). Instance actions return a promise for the operation.</source>
          <target state="translated">클래스 작업은 빈 인스턴스를 반환합니다 (아래에 나열된 추가 속성 포함). 인스턴스 작업은 작업에 대한 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ec0ce07d9481bf4db4c020b148a12c1b4c3112a" translate="yes" xml:space="preserve">
          <source>Class and ngClass animation hooks</source>
          <target state="translated">클래스 및 ngClass 애니메이션 후크</target>
        </trans-unit>
        <trans-unit id="2a0863a04b4ee272c83f2a94dd23442cc0eb6c51" translate="yes" xml:space="preserve">
          <source>Class-based animations (animations that are triggered via &lt;code&gt;ngClass&lt;/code&gt;, &lt;code&gt;ngShow&lt;/code&gt;, &lt;code&gt;ngHide&lt;/code&gt; and some other directives) have a slightly different naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added and removed.</source>
          <target state="translated">클래스 기반 애니메이션 ( &lt;code&gt;ngClass&lt;/code&gt; , &lt;code&gt;ngShow&lt;/code&gt; , &lt;code&gt;ngHide&lt;/code&gt; 및 기타 지시문을 통해 트리거되는 애니메이션 )의 명명 규칙은 약간 다릅니다. 클래스 기반 애니메이션은 표준 전환 또는 키 프레임을 추가 및 제거중인 클래스에서 참조 할 수있을 정도로 기본적입니다.</target>
        </trans-unit>
        <trans-unit id="9191759140319ff20e9dd16485bf237db76b0c98" translate="yes" xml:space="preserve">
          <source>Clears the cache object of any entries.</source>
          <target state="translated">모든 항목의 캐시 개체를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="e515212a1c11de2835082ada05e6ec961879403e" translate="yes" xml:space="preserve">
          <source>Click here &lt;a href=&quot;../../ng/service/%24animate&quot;&gt;to learn more about animations with &lt;code&gt;$animate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24animate&quot;&gt; &lt;code&gt;$animate&lt;/code&gt; &lt;/a&gt; 애니메이션에 대한 자세한 내용을 보려면 여기 를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4fed55c7291e2ae4022dc03f74858153d78fbbe" translate="yes" xml:space="preserve">
          <source>Click here &lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;to read the documentation for $animateCss&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../nganimate/service/%24animatecss&quot;&gt;$ animateCss 설명서를 읽으&lt;/a&gt; 려면 여기 를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="32484b33993cf9537f02013fd9f85c2ec6cd936f" translate="yes" xml:space="preserve">
          <source>Clicking on the &quot;show&quot; button will open the dialog. The dialog will have a title, which is data bound to &lt;code&gt;username&lt;/code&gt;, and it will also have a body which we would like to transclude into the dialog.</source>
          <target state="translated">&quot;표시&quot;버튼을 클릭하면 대화 상자가 열립니다. 대화 상자는 title을 가지며,이 데이터는 &lt;code&gt;username&lt;/code&gt; 에 바인딩 되어 있으며, 대화 상자로 변환 할 본문도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c724973f7e774a94420a9f7d99e10433c417d579" translate="yes" xml:space="preserve">
          <source>Clicks on a link in the page.</source>
          <target state="translated">페이지에서 링크를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="730424b9edeae148b8ff6d50d8ca98ceee4c119c" translate="yes" xml:space="preserve">
          <source>Clicks on a link.</source>
          <target state="translated">링크를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="9ab2e40fdeb36ffa03fcf8447b001724a990908a" translate="yes" xml:space="preserve">
          <source>Clicks the back or forward button (or clicks a History link).</source>
          <target state="translated">뒤로 또는 앞으로 버튼을 클릭하거나 내역 링크를 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="74d1f7b3edab4ca6a434b8e934d29da720f08e4a" translate="yes" xml:space="preserve">
          <source>Clicks the back or forward button in the browser (or clicks a History link).</source>
          <target state="translated">브라우저에서 뒤로 또는 앞으로 단추를 클릭하거나 히스토리 링크를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="09ef3902bc825a92dc2ab7a4572699d9bb63ce7f" translate="yes" xml:space="preserve">
          <source>Code licensed under &lt;a href=&quot;https://github.com/angular/angular.js/blob/master/LICENSE&quot;&gt;The MIT License&lt;/a&gt;. Documentation licensed under &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/&quot;&gt;CC BY 3.0&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/angular/angular.js/blob/master/LICENSE&quot;&gt;MIT 라이센스에&lt;/a&gt; 따라 라이센스가 부여 된 코드 . &lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/&quot;&gt;CC BY 3.0에&lt;/a&gt; 따라 라이센스가 부여 된 문서 .</target>
        </trans-unit>
        <trans-unit id="2dfc49fb8ca872a4cafc6a47501eb288da5ef7b5" translate="yes" xml:space="preserve">
          <source>CoffeeScript Tutorial</source>
          <target state="translated">CoffeeScript 튜토리얼</target>
        </trans-unit>
        <trans-unit id="c548b316d570083f3666806fff6f562e7eab1bab" translate="yes" xml:space="preserve">
          <source>Combines multiple promises into a single promise that is resolved when all of the input promises are resolved.</source>
          <target state="translated">여러 약속을 단일 약속으로 결합하여 모든 입력 약속이 해결 될 때 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="fd5f82d40e47be64b2bc3a51357dc831a7c9ccc1" translate="yes" xml:space="preserve">
          <source>Combining directives with different scope defintions</source>
          <target state="translated">다른 범위 정의와 지시문 결합</target>
        </trans-unit>
        <trans-unit id="3030caa6c289f4c08d71dfe3a1f33564ff7465d0" translate="yes" xml:space="preserve">
          <source>Commit a pending update to the &lt;code&gt;$modelValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$modelValue&lt;/code&gt; 보류중인 업데이트를 커밋합니다 .</target>
        </trans-unit>
        <trans-unit id="a521630b4593fb9bacca2130761b0f7eae72e200" translate="yes" xml:space="preserve">
          <source>Commit all form controls pending updates to the &lt;code&gt;$modelValue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$modelValue&lt;/code&gt; 대한 업데이트 보류중인 모든 양식 제어를 확약하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dcd19b6ea69063f828f5ff860efae73d6849a4b" translate="yes" xml:space="preserve">
          <source>Common Accessibility Patterns</source>
          <target state="translated">일반적인 접근성 패턴</target>
        </trans-unit>
        <trans-unit id="dcd05a800dce1c0a95f1b07835a587a1fa065ad4" translate="yes" xml:space="preserve">
          <source>Community Resources</source>
          <target state="translated">커뮤니티 리소스</target>
        </trans-unit>
        <trans-unit id="f087c397aade898e8ebf5017a565387063b4caf7" translate="yes" xml:space="preserve">
          <source>Comparator which is used in determining if values retrieved using &lt;code&gt;expression&lt;/code&gt; (when it is not a function) should be considered a match based on the expected value (from the filter expression) and actual value (from the object in the array).</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; 사용하여 검색된 값 (함수가 아닌 경우)을 판별하는 데 사용되는 비교기 는 예상 값 (필터 표현식에서)과 실제 값 (배열의 오브젝트에서)을 기반으로 일치로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="666fd1f458daf70bc53cddeb4eeb774d87e18c31" translate="yes" xml:space="preserve">
          <source>Compare for object equality using &lt;a href=&quot;../function/angular.equals&quot;&gt;&lt;code&gt;angular.equals&lt;/code&gt;&lt;/a&gt; instead of comparing for reference equality.</source>
          <target state="translated">참조 동등성을 비교하는 대신 &lt;a href=&quot;../function/angular.equals&quot;&gt; &lt;code&gt;angular.equals&lt;/code&gt; &lt;/a&gt; 를 사용하여 오브젝트 동등성을 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="3877d9f9528e5e589937b6c5e2e2222e153bc4a4" translate="yes" xml:space="preserve">
          <source>Comparing $location to window.location</source>
          <target state="translated">$ location과 window.location 비교</target>
        </trans-unit>
        <trans-unit id="e9bfd3462dbe8e77bcf76ca7642f0a152f0c0338" translate="yes" xml:space="preserve">
          <source>Comparison between Directive definition and Component definition</source>
          <target state="translated">지시어 정의와 구성 요소 정의의 비교</target>
        </trans-unit>
        <trans-unit id="53cb52234319d0132a4da6be7bbd0b5b04aa75f1" translate="yes" xml:space="preserve">
          <source>Comparison of the two approaches</source>
          <target state="translated">두 가지 접근법의 비교</target>
        </trans-unit>
        <trans-unit id="70d88717d38b547780477523d9cbf84942fc4774" translate="yes" xml:space="preserve">
          <source>Comparison with life-cycle hooks in the new Angular</source>
          <target state="translated">새로운 Angular의 수명주기 후크와 비교</target>
        </trans-unit>
        <trans-unit id="17ab47599110d104d7ae0defacdd1ff429aa3f51" translate="yes" xml:space="preserve">
          <source>Compile the element, but restrict the maximum priority, so that any already compiled directives (including the &lt;code&gt;addOptions&lt;/code&gt; directive) are not compiled again.</source>
          <target state="translated">이미 컴파일 된 지시문 ( &lt;code&gt;addOptions&lt;/code&gt; 지시문 포함)이 다시 컴파일되지 않도록 요소를 컴파일하되 최대 우선 순위를 제한 하십시오.</target>
        </trans-unit>
        <trans-unit id="341a20e237ff5c4b89204a3d4d8c8af5f8aa63bb" translate="yes" xml:space="preserve">
          <source>Compiler</source>
          <target state="translated">Compiler</target>
        </trans-unit>
        <trans-unit id="1782e5208f00a046cef2996ed8671fed74f08a08" translate="yes" xml:space="preserve">
          <source>Compiler is an AngularJS service which traverses the DOM looking for attributes. The compilation process happens in two phases.</source>
          <target state="translated">컴파일러는 속성을 찾는 DOM을 통과하는 AngularJS 서비스입니다. 컴파일 과정은 두 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="fa46964e2997513f5edb8da69c2a884d9e0d6812" translate="yes" xml:space="preserve">
          <source>Compiles a string with markup into an interpolation function. This service is used by the HTML &lt;a href=&quot;%24compile&quot;&gt;$compile&lt;/a&gt; service for data binding. See &lt;a href=&quot;../provider/%24interpolateprovider&quot;&gt;$interpolateProvider&lt;/a&gt; for configuring the interpolation markup.</source>
          <target state="translated">마크 업이있는 문자열을 보간 함수로 컴파일합니다. 이 서비스는 데이터 바인딩을 위해 HTML &lt;a href=&quot;%24compile&quot;&gt;$ compile&lt;/a&gt; 서비스에서 사용됩니다 . 보간 마크 업 구성에 대해서는 &lt;a href=&quot;../provider/%24interpolateprovider&quot;&gt;$ interpolateProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eca1135b84c5a41b83e29f018e5f8bc1af9b4725" translate="yes" xml:space="preserve">
          <source>Compiles a string with markup into an interpolation function. This service is used by the HTML &lt;a href=&quot;service/%24compile&quot;&gt;$compile&lt;/a&gt; service for data binding. See &lt;a href=&quot;provider/%24interpolateprovider&quot;&gt;$interpolateProvider&lt;/a&gt; for configuring the interpolation markup.</source>
          <target state="translated">마크 업이있는 문자열을 보간 함수로 컴파일합니다. 이 서비스는 데이터 바인딩을 위해 HTML &lt;a href=&quot;service/%24compile&quot;&gt;$ compile&lt;/a&gt; 서비스에서 사용됩니다 . 보간 마크 업 구성에 대해서는 &lt;a href=&quot;provider/%24interpolateprovider&quot;&gt;$ interpolateProvider&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35e0dd7e6479d72ea347ebf52f30653b69adb513" translate="yes" xml:space="preserve">
          <source>Compiles an HTML string or DOM into a template and produces a template function, which can then be used to link &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; and the template together.</source>
          <target state="translated">HTML 문자열 또는 DOM을 템플릿으로 컴파일하고 템플릿 함수를 생성하여 &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 와 템플릿을 함께 연결하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="443f4ce80e9a994956ec0834e6c655a3bb098864" translate="yes" xml:space="preserve">
          <source>Compiles an HTML string or DOM into a template and produces a template function, which can then be used to link &lt;a href=&quot;type/%24rootscope.scope&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt; and the template together.</source>
          <target state="translated">HTML 문자열 또는 DOM을 템플릿으로 컴파일하고 템플릿 함수를 생성하여 &lt;a href=&quot;type/%24rootscope.scope&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 와 템플릿을 함께 연결하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="952c4e08cf22564bbdb9648e98a02a3602d26f59" translate="yes" xml:space="preserve">
          <source>Complementary Libraries</source>
          <target state="translated">보완 라이브러리</target>
        </trans-unit>
        <trans-unit id="1660cae935161f6c4359132ab0d198129c40fd5d" translate="yes" xml:space="preserve">
          <source>Complete list of shortcut methods:</source>
          <target state="translated">바로 가기 방법의 전체 목록 :</target>
        </trans-unit>
        <trans-unit id="ddddba8622d54a1019f55ac5d840e4b03ae004df" translate="yes" xml:space="preserve">
          <source>Completely Replace the $delegate</source>
          <target state="translated">$ delegate를 완전히 교체하십시오</target>
        </trans-unit>
        <trans-unit id="78347206801a061c0decedac37c91767431b4537" translate="yes" xml:space="preserve">
          <source>Complex Models (objects or collections)</source>
          <target state="translated">복잡한 모델 (객체 또는 컬렉션)</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="a85196f04b4052b5f8e757116e9ed52d626cea29" translate="yes" xml:space="preserve">
          <source>Component definition object (a simplified &lt;a href=&quot;../service/%24compile#directive-definition-object.html&quot;&gt;directive definition object&lt;/a&gt;)</source>
          <target state="translated">구성 요소 정의 오브젝트 (간이 &lt;a href=&quot;../service/%24compile#directive-definition-object.html&quot;&gt;지시문 정의 오브젝트&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="52b1bdba92bb54788ab2cdeee061c0e16d336346" translate="yes" xml:space="preserve">
          <source>Component definition object (a simplified &lt;a href=&quot;../service/%24compile#directive-definition-object.html&quot;&gt;directive definition object&lt;/a&gt;), with the following properties (all optional):</source>
          <target state="translated">다음 특성을 가진 컴포넌트 정의 오브젝트 (간이 &lt;a href=&quot;../service/%24compile#directive-definition-object.html&quot;&gt;지시문 정의 오브젝트&lt;/a&gt; ) (모두 선택 사항) :</target>
        </trans-unit>
        <trans-unit id="77dc9cfc7cb3b52a950028db1a5820bbb36a0ff5" translate="yes" xml:space="preserve">
          <source>Component definitions are very simple and do not require as much configuration as defining general directives. Component definitions usually consist only of a template and a controller backing it.</source>
          <target state="translated">구성 요소 정의는 매우 간단하며 일반 지시문을 정의하는 것만 큼 많은 구성이 필요하지 않습니다. 컴포넌트 정의는 일반적으로 템플리트와이를 지원하는 컨트롤러로만 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe71f615894962f769e3b09ee4b063dd3104c07" translate="yes" xml:space="preserve">
          <source>Component-based application architecture</source>
          <target state="translated">컴포넌트 기반 애플리케이션 아키텍처</target>
        </trans-unit>
        <trans-unit id="412108d00dc3d78512b7f514b082a1dc5a2a25c0" translate="yes" xml:space="preserve">
          <source>ComponentInstruction</source>
          <target state="translated">ComponentInstruction</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="052de9b4663f1da6b0dad6763f0e84f04970f1d5" translate="yes" xml:space="preserve">
          <source>Components are also useful as route templates (e.g. when using &lt;a href=&quot;../api/ngroute&quot;&gt;ngRoute&lt;/a&gt;). In a component-based application, every view is a component:</source>
          <target state="translated">구성 요소는 경로 템플릿으로도 유용합니다 (예 : &lt;a href=&quot;../api/ngroute&quot;&gt;ngRoute 사용시&lt;/a&gt; ). 컴포넌트 기반 애플리케이션에서 모든보기는 컴포넌트입니다.</target>
        </trans-unit>
        <trans-unit id="8baa065a5cba8d6c52c78a61ff9c9163ba5e3d7e" translate="yes" xml:space="preserve">
          <source>Components as route templates</source>
          <target state="translated">배관 템플릿으로서의 구성 요소</target>
        </trans-unit>
        <trans-unit id="bf44683e2124b402afd1667eddfc51003f631e51" translate="yes" xml:space="preserve">
          <source>Components can be registered using the &lt;a href=&quot;../api/ng/provider/%24compileprovider#component.html&quot;&gt;&lt;code&gt;.component()&lt;/code&gt;&lt;/a&gt; method of an AngularJS module (returned by &lt;a href=&quot;module&quot;&gt;&lt;code&gt;angular.module()&lt;/code&gt;&lt;/a&gt;). The method takes two arguments:</source>
          <target state="translated">AngularJS 모듈 의 &lt;a href=&quot;../api/ng/provider/%24compileprovider#component.html&quot;&gt; &lt;code&gt;.component()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 컴포넌트를 등록 할 수 있습니다 (angular.module () 로 리턴 &lt;a href=&quot;module&quot;&gt; &lt;code&gt;angular.module()&lt;/code&gt; &lt;/a&gt; ). 이 방법에는 두 가지 인수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ede4134b45566bbb53a326a5ba30ed2337d4b16" translate="yes" xml:space="preserve">
          <source>Components that have their dependencies injected allow them to be easily mocked on a test by test basis, without having to mess with any global variables that could inadvertently affect another test.</source>
          <target state="translated">종속성이 주입 된 구성 요소를 사용하면 실수로 다른 테스트에 영향을 줄 수있는 전역 변수를 망칠 필요없이 테스트 기준으로 테스트를 쉽게 조롱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2bb3f2d36cc8fea7cbf33806f6b7360ab29060" translate="yes" xml:space="preserve">
          <source>Comprehensive Directive API</source>
          <target state="translated">포괄적 인 지시문 API</target>
        </trans-unit>
        <trans-unit id="c05bafdb56031bb64da1f1d1861f60118932c605" translate="yes" xml:space="preserve">
          <source>Concept</source>
          <target state="translated">Concept</target>
        </trans-unit>
        <trans-unit id="cc8d5c03c91b4ff4e34ca056bb24f3fb67fdffdd" translate="yes" xml:space="preserve">
          <source>Conceptual Overview</source>
          <target state="translated">개념적 개요</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="71c2b150a06049925dc940ff0b7ba9b28de4537b" translate="yes" xml:space="preserve">
          <source>Configure $http service to combine processing of multiple http responses received at around the same time via &lt;a href=&quot;../type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$rootScope.$applyAsync&lt;/a&gt;. This can result in significant performance improvement for bigger applications that make many HTTP requests concurrently (common during application bootstrap).</source>
          <target state="translated">&lt;a href=&quot;../type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$ rootScope. $ applyAsync&lt;/a&gt; 를 통해 거의 동시에 수신 된 여러 http 응답 처리를 결합하도록 $ http 서비스를 구성하십시오 . 이로 인해 많은 HTTP 요청을 동시에 수행하는 (애플리케이션 부트 스트랩 동안 일반적으로) 더 큰 애플리케이션의 성능이 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7896d76d615866e43aa8573a41f4d68ecbe909a3" translate="yes" xml:space="preserve">
          <source>Configure $parse service to add literal values that will be present as literal at expressions.</source>
          <target state="translated">표현식에서 리터럴로 표시 될 리터럴 값을 추가하도록 $ parse 서비스를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="401014f049aff69ca01aa4c69560adc72e65a93d" translate="yes" xml:space="preserve">
          <source>Configure several aspects of error handling in AngularJS if used as a setter or return the current configuration if used as a getter. The following options are supported:</source>
          <target state="translated">setter로 사용되는 경우 AngularJS에서 오류 처리의 여러 측면을 구성하거나 getter로 사용되는 경우 현재 구성을 리턴하십시오. 다음과 같은 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed62ca7d00be1bd9be3f6f28effdd940c0a125d" translate="yes" xml:space="preserve">
          <source>Configures the mock implementation of &lt;a href=&quot;../../ng/service/%24exceptionhandler&quot;&gt;&lt;code&gt;$exceptionHandler&lt;/code&gt;&lt;/a&gt; to rethrow or to log errors passed to the &lt;code&gt;$exceptionHandler&lt;/code&gt;.</source>
          <target state="translated">구성합니다은의 모의 구현 &lt;a href=&quot;../../ng/service/%24exceptionhandler&quot;&gt; &lt;code&gt;$exceptionHandler&lt;/code&gt; &lt;/a&gt; 다시 발생하거나 전달 오류가 로그인 할 때 &lt;code&gt;$exceptionHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa7b44a578c9b66e6eac734e95b3a649678bb56b" translate="yes" xml:space="preserve">
          <source>Configures the mock implementation of &lt;a href=&quot;../ng/service/%24exceptionhandler&quot;&gt;&lt;code&gt;$exceptionHandler&lt;/code&gt;&lt;/a&gt; to rethrow or to log errors passed to the &lt;code&gt;$exceptionHandler&lt;/code&gt;.</source>
          <target state="translated">구성합니다은의 모의 구현 &lt;a href=&quot;../ng/service/%24exceptionhandler&quot;&gt; &lt;code&gt;$exceptionHandler&lt;/code&gt; &lt;/a&gt; 다시 발생하거나 전달 오류가 로그인 할 때 &lt;code&gt;$exceptionHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab33277d4bc70753dadfe4b4b47939a3bafacc65" translate="yes" xml:space="preserve">
          <source>Configures the mock implementation of &lt;a href=&quot;ng/service/%24exceptionhandler&quot;&gt;&lt;code&gt;$exceptionHandler&lt;/code&gt;&lt;/a&gt; to rethrow or to log errors passed to the &lt;code&gt;$exceptionHandler&lt;/code&gt;.</source>
          <target state="translated">구성합니다은의 모의 구현 &lt;a href=&quot;ng/service/%24exceptionhandler&quot;&gt; &lt;code&gt;$exceptionHandler&lt;/code&gt; &lt;/a&gt; 다시 발생하거나 전달 오류가 로그인 할 때 &lt;code&gt;$exceptionHandler&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef688c3bf06b49c7583d5229b5b135310e872abe" translate="yes" xml:space="preserve">
          <source>Configuring ngPluralize</source>
          <target state="translated">ngPluralize 구성</target>
        </trans-unit>
        <trans-unit id="25493fa5f58d0b23af0328cbcc8d72f1b7096ef8" translate="yes" xml:space="preserve">
          <source>Configuring ngPluralize with offset</source>
          <target state="translated">오프셋을 사용하여 ngPluralize 구성</target>
        </trans-unit>
        <trans-unit id="614cb97d5550e6a973dc4d4e5e71bacf0e254a0a" translate="yes" xml:space="preserve">
          <source>Connecting to the scope</source>
          <target state="translated">스코프에 연결</target>
        </trans-unit>
        <trans-unit id="bd1ca2146ad14cf9d26b89eef58c53c8846544f1" translate="yes" xml:space="preserve">
          <source>Consider a base href set as follows: &lt;code&gt;&amp;lt;base href=&quot;/base/&quot;&amp;gt;&lt;/code&gt; (i.e. the application exists in the &quot;folder&quot; called &lt;code&gt;/base&lt;/code&gt;). The URL &lt;code&gt;/base&lt;/code&gt; is actually outside the application (it refers to the &lt;code&gt;base&lt;/code&gt; file found in the root &lt;code&gt;/&lt;/code&gt; folder).</source>
          <target state="translated">&lt;code&gt;&amp;lt;base href=&quot;/base/&quot;&amp;gt;&lt;/code&gt; 와 같이 기본 href 세트를 고려하십시오 (즉, 응용 프로그램은 &lt;code&gt;/base&lt;/code&gt; 라는 &quot;폴더&quot;에 있습니다 ). URL &lt;code&gt;/base&lt;/code&gt; 는 실제로 응용 프로그램 외부에 있습니다 ( 루트 &lt;code&gt;/&lt;/code&gt; 폴더 에있는 &lt;code&gt;base&lt;/code&gt; 파일을 나타냄 ).</target>
        </trans-unit>
        <trans-unit id="b75dc57f6ba4e3ce850116dfdcb6fffec204312d" translate="yes" xml:space="preserve">
          <source>Consider a text input with an autocomplete list (for fruit), where the items are objects with a name and an id. A user enters &lt;code&gt;ap&lt;/code&gt; and then selects &lt;code&gt;Apricot&lt;/code&gt; from the list. Based on this, the autocomplete widget will call &lt;code&gt;$setViewValue({name: 'Apricot', id: 443})&lt;/code&gt;, but the rendered value will still be &lt;code&gt;ap&lt;/code&gt;. The widget can then call &lt;code&gt;ctrl.$processModelValue()&lt;/code&gt; to run the model -&amp;gt; view pipeline again, which formats the object to the string &lt;code&gt;Apricot&lt;/code&gt;, then updates the &lt;code&gt;$viewValue&lt;/code&gt;, and finally renders it in the DOM.</source>
          <target state="translated">항목이 이름과 ID를 가진 객체 인 자동 완성 목록 (과일의 경우)이있는 텍스트 입력을 고려하십시오. 사용자가 &lt;code&gt;ap&lt;/code&gt; 를 입력 한 다음 목록에서 &lt;code&gt;Apricot&lt;/code&gt; 를 선택 합니다. 이를 바탕으로 자동 완성 위젯은 &lt;code&gt;$setViewValue({name: 'Apricot', id: 443})&lt;/code&gt; 을 호출 하지만 렌더링 된 값은 여전히 &lt;code&gt;ap&lt;/code&gt; 입니다. 그런 다음 위젯은 &lt;code&gt;ctrl.$processModelValue()&lt;/code&gt; 를 호출 하여 모델-&amp;gt; 뷰 파이프 라인을 다시 실행하여 오브젝트를 &lt;code&gt;Apricot&lt;/code&gt; 문자열로 형식화 한 다음 &lt;code&gt;$viewValue&lt;/code&gt; 를 업데이트 한 후 DOM에서 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="a18df99124cdd530d7ee713a96afbde420b4e68f" translate="yes" xml:space="preserve">
          <source>Consider the following example, which illustrates a typical use case of &lt;code&gt;ngMessages&lt;/code&gt;. Within the form &lt;code&gt;myForm&lt;/code&gt; we have a text input named &lt;code&gt;myField&lt;/code&gt; which is bound to the scope variable &lt;code&gt;field&lt;/code&gt; using the &lt;a href=&quot;ng/directive/ngmodel&quot;&gt;ngModel&lt;/a&gt; directive.</source>
          <target state="translated">&lt;code&gt;ngMessages&lt;/code&gt; 의 일반적인 사용 사례를 보여주는 다음 예제를 고려하십시오 . &lt;code&gt;myForm&lt;/code&gt; 양식 에는 &lt;a href=&quot;ng/directive/ngmodel&quot;&gt;ngModel&lt;/a&gt; 지시문을 사용하여 범위 변수 &lt;code&gt;field&lt;/code&gt; 바인딩 된 &lt;code&gt;myField&lt;/code&gt; 라는 텍스트 입력 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="067758acc9cf591a779af4e3d644186dd0af02ba" translate="yes" xml:space="preserve">
          <source>Consider this module, which includes a &lt;code&gt;willBreak&lt;/code&gt; service that uses implicit DI:</source>
          <target state="translated">암시 적 DI를 사용 하는 &lt;code&gt;willBreak&lt;/code&gt; 서비스를 포함하는이 모듈을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="8067f2d7407363afa44d0fb08f79e6b26296396e" translate="yes" xml:space="preserve">
          <source>Consider using &lt;a href=&quot;../api/ng/directive/ngcsp&quot;&gt;CSP&lt;/a&gt; (but don't rely only on CSP)</source>
          <target state="translated">&lt;a href=&quot;../api/ng/directive/ngcsp&quot;&gt;CSP&lt;/a&gt; 사용을 고려하십시오 (그러나 CSP에만 의존하지는 마십시오)</target>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="d694aced80a769dd56d5ff19d56f4662c3bdd367" translate="yes" xml:space="preserve">
          <source>Constant Recipe</source>
          <target state="translated">일정한 레시피</target>
        </trans-unit>
        <trans-unit id="baf6a951c27a9234a81559df8b9c866456740fa7" translate="yes" xml:space="preserve">
          <source>Constant value.</source>
          <target state="translated">상수 값.</target>
        </trans-unit>
        <trans-unit id="b99e72117469b9970f18ba5d75fe3d0de1866186" translate="yes" xml:space="preserve">
          <source>Constant, message, exception or an object representing the rejection reason.</source>
          <target state="translated">거부 이유를 나타내는 상수, 메시지, 예외 또는 객체.</target>
        </trans-unit>
        <trans-unit id="64d5e2c2aff5afc784db4e0bcb2cdc6862d0f0f0" translate="yes" xml:space="preserve">
          <source>Construction function for creating new instance of the service.</source>
          <target state="translated">서비스의 새로운 인스턴스를 생성하기위한 구성 기능.</target>
        </trans-unit>
        <trans-unit id="e4b290eee7ee9eca877a7e01bf49e3ec181e017e" translate="yes" xml:space="preserve">
          <source>Content Security Policy</source>
          <target state="translated">콘텐츠 보안 정책</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="802338f12e55179b2d6cd860935bf05175261d07" translate="yes" xml:space="preserve">
          <source>Context which &lt;code&gt;fn&lt;/code&gt; should be evaluated in.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 을 평가해야하는 컨텍스트</target>
        </trans-unit>
        <trans-unit id="18b017e5b4b89d6ff684844a26fb098545f160cf" translate="yes" xml:space="preserve">
          <source>Contribute</source>
          <target state="translated">Contribute</target>
        </trans-unit>
        <trans-unit id="4e9871e0a8defabedbf3524a3226fa9d74385b59" translate="yes" xml:space="preserve">
          <source>Contributing to AngularJS</source>
          <target state="translated">AngularJS에 기여</target>
        </trans-unit>
        <trans-unit id="86cf9b9a051872b3598a096da04f48dd25d0af73" translate="yes" xml:space="preserve">
          <source>Control of the AngularJS templates makes applications vulnerable even if there was a completely secure sandbox:</source>
          <target state="translated">AngularJS 템플릿을 제어하면 완전히 안전한 샌드 박스가 있어도 응용 프로그램이 취약 해집니다.</target>
        </trans-unit>
        <trans-unit id="a36a5ffa6e0dcfb64fac1b2b3d6fb176de9689de" translate="yes" xml:space="preserve">
          <source>Controller</source>
          <target state="translated">Controller</target>
        </trans-unit>
        <trans-unit id="99ffd59ebbf0e37afa0e0d929b94eba513e392bc" translate="yes" xml:space="preserve">
          <source>Controller &amp;mdash; The &lt;code&gt;ngController&lt;/code&gt; directive specifies a Controller class; the class contains business logic behind the application to decorate the scope with functions and values</source>
          <target state="translated">Controller &amp;mdash; &lt;code&gt;ngController&lt;/code&gt; 지시문은 Controller 클래스를 지정합니다. 클래스는 함수와 값으로 범위를 장식하기 위해 응용 프로그램 뒤에 비즈니스 논리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ccb3847c75d985adc6744eb79ac9c9cee18abe79" translate="yes" xml:space="preserve">
          <source>Controller constructor fn (optionally decorated with DI annotations in the array notation).</source>
          <target state="translated">컨트롤러 생성자 fn (선택적으로 배열 표기법의 DI 주석으로 장식 됨).</target>
        </trans-unit>
        <trans-unit id="c27dec249f237841f7387d65d26a7c0ce88c6c18" translate="yes" xml:space="preserve">
          <source>Controller constructor function.</source>
          <target state="translated">컨트롤러 생성자 함수.</target>
        </trans-unit>
        <trans-unit id="9d19a84c7ff095475b0ae33d1170893261391e4f" translate="yes" xml:space="preserve">
          <source>Controller constructor function. The controller is instantiated before the pre-linking phase and can be accessed by other directives (see &lt;code&gt;require&lt;/code&gt; attribute). This allows the directives to communicate with each other and augment each other's behavior. The controller is injectable (and supports bracket notation) with the following locals:</source>
          <target state="translated">컨트롤러 생성자 함수. 컨트롤러는 사전 연결 단계 전에 인스턴스화되며 다른 지시문으로 액세스 할 수 있습니다 ( &lt;code&gt;require&lt;/code&gt; 특성 참조 ). 이를 통해 지시문이 서로 통신하고 서로의 행동을 향상시킬 수 있습니다. 컨트롤러는 다음 지역과 함께 주사 가능하며 브래킷 표기법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a9aaeb41d0885b4404238f900eeab9f49522f6e5" translate="yes" xml:space="preserve">
          <source>Controller methods can also take arguments, as demonstrated in the following variation of the previous example.</source>
          <target state="translated">이전 예제의 다음 변형에서 설명 된대로 컨트롤러 메소드도 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e71925aefd89c1562fed9afbd32f746da1e7c9c5" translate="yes" xml:space="preserve">
          <source>Controller methods can be created through direct assignment to scope (see the &lt;code&gt;chiliSpicy&lt;/code&gt; method)</source>
          <target state="translated">범위에 직접 할당하여 컨트롤러 방법을 생성 할 수 있습니다 ( &lt;code&gt;chiliSpicy&lt;/code&gt; 방법 참조 )</target>
        </trans-unit>
        <trans-unit id="abab164d91275a7c27f69b9901af5a808932f134" translate="yes" xml:space="preserve">
          <source>Controller name to check.</source>
          <target state="translated">확인할 컨트롤러 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d164658172a7f4d47214d163beff14e7b08173e9" translate="yes" xml:space="preserve">
          <source>Controller name, or an object map of controllers where the keys are the names and the values are the constructors.</source>
          <target state="translated">컨트롤러 이름 또는 키가 이름이고 값이 생성자 인 컨트롤러의 객체 맵.</target>
        </trans-unit>
        <trans-unit id="fd28161568c4e8e181bf8b34d2eb64190067fd07" translate="yes" xml:space="preserve">
          <source>Controllers</source>
          <target state="translated">Controllers</target>
        </trans-unit>
        <trans-unit id="fbc681066b21fc1c3641cf2f3c220b9b2bb08d7e" translate="yes" xml:space="preserve">
          <source>Controllers and Scopes</source>
          <target state="translated">컨트롤러 및 범위</target>
        </trans-unit>
        <trans-unit id="911140cd3f21770764dea61bf3752956262c1067" translate="yes" xml:space="preserve">
          <source>Controllers are &quot;classes&quot; or &quot;constructor functions&quot; that are responsible for providing the application behavior that supports the declarative markup in the template. The recommended way of declaring Controllers is using the array notation:</source>
          <target state="translated">컨트롤러는 템플릿에서 선언적 마크 업을 지원하는 응용 프로그램 동작을 제공하는 &quot;클래스&quot;또는 &quot;생성자 함수&quot;입니다. 컨트롤러를 선언하는 권장 방법은 배열 표기법을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b5d98f528a42620b2cc0825785014474de8791d" translate="yes" xml:space="preserve">
          <source>Controllers can be attached to the DOM in different ways. For each of them, AngularJS will instantiate a new Controller object, using the specified Controller's &lt;strong&gt;constructor function&lt;/strong&gt;:</source>
          <target state="translated">컨트롤러는 다른 방식으로 DOM에 연결될 수 있습니다. 각각에 대해 AngularJS는 지정된 Controller의 &lt;strong&gt;생성자 함수를&lt;/strong&gt; 사용하여 새 Controller 객체를 인스턴스화 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1c6d830a012a42e0e3e98e8d7391642d69b5f9c0" translate="yes" xml:space="preserve">
          <source>Controllers define methods (behavior) that can mutate the model (properties on the scope).</source>
          <target state="translated">컨트롤러는 모델 (범위의 속성)을 변경할 수있는 메서드 (동작)를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="70c782bc574579d2517b6cec8967686212a0d454" translate="yes" xml:space="preserve">
          <source>Controllers may register &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;watches&lt;/a&gt; on the model. These watches execute immediately after the controller behavior executes.</source>
          <target state="translated">컨트롤러는 모델에 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;시계&lt;/a&gt; 를 등록 할 수 있습니다 . 이 시계는 컨트롤러 동작이 실행 된 직후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="058997bd1ff2c8ff837142c06062cc669ac555e1" translate="yes" xml:space="preserve">
          <source>Controllers use scopes to expose controller methods to templates (see &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;ng-controller&lt;/a&gt;).</source>
          <target state="translated">컨트롤러는 범위를 사용하여 컨트롤러 방법을 템플릿에 노출합니다 ( &lt;a href=&quot;../api/ng/directive/ngcontroller&quot;&gt;ng-controller&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7dd94c9d2ce116f0c4c53ed1b007067b7b712d4c" translate="yes" xml:space="preserve">
          <source>Controls (&lt;code&gt;input&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;textarea&lt;/code&gt;) are ways for a user to enter data. A Form is a collection of controls for the purpose of grouping related controls together.</source>
          <target state="translated">컨트롤 ( &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;textarea&lt;/code&gt; )은 사용자가 데이터를 입력하는 방법입니다. 양식은 관련 컨트롤을 그룹화하기위한 컨트롤 모음입니다.</target>
        </trans-unit>
        <trans-unit id="e170fcf2efd35c14b97e47909e1264edfdda6632" translate="yes" xml:space="preserve">
          <source>Convert the &lt;code&gt;:&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, or &lt;code&gt;_&lt;/code&gt;-delimited name to &lt;code&gt;camelCase&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;_&lt;/code&gt; 로 구분 된 이름을 &lt;code&gt;camelCase&lt;/code&gt; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="933184608bdac4f3c6c004f83098137beaa3d86f" translate="yes" xml:space="preserve">
          <source>Converts AngularJS &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; into a function.</source>
          <target state="translated">AngularJS &lt;a href=&quot;../../../guide/expression&quot;&gt;표현식&lt;/a&gt; 을 함수로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2eea8ad796d2916c4ebaeca90af5bde7b4d8a77a" translate="yes" xml:space="preserve">
          <source>Converts AngularJS &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt; into a function. This is like &lt;a href=&quot;%24parse&quot;&gt;$parse&lt;/a&gt; and is identical when the expression is a literal constant. Otherwise, it wraps the expression in a call to &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;$sce.getTrusted(&lt;em&gt;type&lt;/em&gt;, &lt;em&gt;result&lt;/em&gt;)&lt;/a&gt;</source>
          <target state="translated">AngularJS &lt;a href=&quot;../../../guide/expression&quot;&gt;표현식&lt;/a&gt; 을 함수로 변환 합니다. 이것은 &lt;a href=&quot;%24parse&quot;&gt;$ parse&lt;/a&gt; 와 유사하며 표현식이 리터럴 상수 일 때 동일합니다. 그렇지 않으면 &lt;a href=&quot;%24sce#getTrusted.html&quot;&gt;$ sce.getTrusted ( &lt;/a&gt;&lt;em&gt;type&lt;/em&gt; , &lt;em&gt;result&lt;/em&gt; )를 호출하여 표현식을 래핑합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f52436d3294322d69775a94b63db34d958c64e34" translate="yes" xml:space="preserve">
          <source>Converts AngularJS &lt;a href=&quot;../../guide/expression&quot;&gt;expression&lt;/a&gt; into a function.</source>
          <target state="translated">AngularJS &lt;a href=&quot;../../guide/expression&quot;&gt;표현식&lt;/a&gt; 을 함수로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="241b70e1e8de1ff6cda970c4d284ff5a349664ae" translate="yes" xml:space="preserve">
          <source>Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with &lt;code&gt;x-&lt;/code&gt; or &lt;code&gt;data-&lt;/code&gt;) to its normalized, camelCase form.</source>
          <target state="translated">속성 이름 (예 : 대시 / 콜론 / 밑줄로 구분 된 문자열, 선택적으로 &lt;code&gt;x-&lt;/code&gt; 또는 &lt;code&gt;data-&lt;/code&gt; 접두사가 붙은 문자열 )을 정규화 된 camelCase 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0849392d519f4aa3fac0a65873ae6d050016e1fe" translate="yes" xml:space="preserve">
          <source>Converts string to lowercase.</source>
          <target state="translated">문자열을 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b79ed60a960e0da09dfacee4601fd97afa217eb9" translate="yes" xml:space="preserve">
          <source>Converts string to uppercase.</source>
          <target state="translated">문자열을 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c872753511d558c4ce512746cf585786dd025a3c" translate="yes" xml:space="preserve">
          <source>Core Concepts</source>
          <target state="translated">핵심 개념</target>
        </trans-unit>
        <trans-unit id="2e84aab6976a7309d079e90c2b70df72a431d11c" translate="yes" xml:space="preserve">
          <source>Counts all the direct and indirect child scopes of the current scope.</source>
          <target state="translated">현재 범위의 모든 직접 및 간접 자식 범위를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="443961121af9afe27d68ec052ba843a27eaf31a0" translate="yes" xml:space="preserve">
          <source>Counts all the watchers of direct and indirect child scopes of the current scope.</source>
          <target state="translated">현재 범위의 직접 및 간접 자식 범위의 모든 감시자를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a16536d78dc34897436003938234d72482a1d526" translate="yes" xml:space="preserve">
          <source>Courses</source>
          <target state="translated">Courses</target>
        </trans-unit>
        <trans-unit id="389e36945902ac4da978f24ea80f3d5bbd64c891" translate="yes" xml:space="preserve">
          <source>Crawling your app</source>
          <target state="translated">앱 크롤링</target>
        </trans-unit>
        <trans-unit id="45608ebdcb44d27d42f32d60acd39e85de71b39c" translate="yes" xml:space="preserve">
          <source>Create a new injector that can provide components defined in our &lt;code&gt;myModule&lt;/code&gt; module and request our &lt;code&gt;greeter&lt;/code&gt; service from the injector. (This is usually done automatically by AngularJS bootstrap).</source>
          <target state="translated">우리에 정의 된 구성 요소를 제공 할 수있는 새로운 인젝터 만들기 &lt;code&gt;myModule&lt;/code&gt; 모듈을 우리의 요청 &lt;code&gt;greeter&lt;/code&gt; 인젝터에서 서비스를. (이는 일반적으로 AngularJS 부트 스트랩에 의해 자동으로 수행됩니다).</target>
        </trans-unit>
        <trans-unit id="971013bc0a9711b010a8dd9b707cb3697b7f4d5f" translate="yes" xml:space="preserve">
          <source>Create a new instance of JS type. The method takes a constructor function, invokes the new operator, and supplies all of the arguments to the constructor function as specified by the constructor annotation.</source>
          <target state="translated">JS 유형의 새 인스턴스를 작성하십시오. 이 메소드는 생성자 함수를 가져 와서 새 연산자를 호출하고 생성자 주석에 지정된대로 모든 인수를 생성자 함수에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9cc6657b1652167630bc2a55c743f36c28dcc171" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;Deferred&lt;/code&gt; object which represents a task which will finish in the future.</source>
          <target state="translated">나중에 완료 될 작업을 나타내는 &lt;code&gt;Deferred&lt;/code&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d11bba0687af96cbd2d8bb53eeba0343f2e22377" translate="yes" xml:space="preserve">
          <source>Creates a deep copy of &lt;code&gt;source&lt;/code&gt;, which should be an object or an array. This functions is used internally, mostly in the change-detection code. It is not intended as an all-purpose copy function, and has several limitations (see below).</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 또는 오브젝트 의 깊은 사본을 작성 합니다 . 이 기능은 주로 변경 감지 코드에서 내부적으로 사용됩니다. 이 기능은 범용 복사 기능을위한 것이 아니며 몇 가지 제한 사항이 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="afa1484b840a9ffabd1ceb69c929659784229740" translate="yes" xml:space="preserve">
          <source>Creates a new array or string containing only a specified number of elements. The elements are taken from either the beginning or the end of the source array, string or number, as specified by the value and sign (positive or negative) of &lt;code&gt;limit&lt;/code&gt;. Other array-like objects are also supported (e.g. array subclasses, NodeLists, jqLite/jQuery collections etc). If a number is used as input, it is converted to a string.</source>
          <target state="translated">지정된 수의 요소 만 포함하는 새 배열 또는 문자열을 만듭니다. &lt;code&gt;limit&lt;/code&gt; 의 값 및 부호 (양수 또는 음수)로 지정된대로 소스 배열, 문자열 또는 숫자의 시작 또는 끝에서 요소를 가져옵니다 . 다른 배열과 유사한 객체 (예 : 배열 서브 클래스, NodeList, jqLite / jQuery 컬렉션 등)도 지원됩니다. 숫자가 입력으로 사용되면 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="be3c2e6c2da6bbf270113921436fdebc0aadccf9" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition for DELETE requests. For more info see &lt;code&gt;when()&lt;/code&gt;.</source>
          <target state="translated">DELETE 요청에 대한 새 백엔드 정의를 작성합니다. 자세한 내용은 &lt;code&gt;when()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e535501af031225c35fb51be3e57cd8b30dbbd81" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition for GET requests. For more info see &lt;code&gt;when()&lt;/code&gt;.</source>
          <target state="translated">GET 요청에 대한 새 백엔드 정의를 작성합니다. 자세한 내용은 &lt;code&gt;when()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="356cc2f1fc79ace6115ff3114750774f5192302f" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition for HEAD requests. For more info see &lt;code&gt;when()&lt;/code&gt;.</source>
          <target state="translated">HEAD 요청에 대한 새 백엔드 정의를 작성합니다. 자세한 내용은 &lt;code&gt;when()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="049cbbc849e59668c71cc30e7a114207708c87cf" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition for JSONP requests. For more info see &lt;code&gt;when()&lt;/code&gt;.</source>
          <target state="translated">JSONP 요청에 대한 새 백엔드 정의를 작성합니다. 자세한 내용은 &lt;code&gt;when()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a1e3e71e874615b87146e6893453eeadfaf6659" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition for PATCH requests. For more info see &lt;code&gt;when()&lt;/code&gt;.</source>
          <target state="translated">PATCH 요청에 대한 새 백엔드 정의를 작성합니다. 자세한 내용은 &lt;code&gt;when()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eda4d8b9cd6e902637dd9ad1e48fec7c8bb7cd5c" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition for POST requests. For more info see &lt;code&gt;when()&lt;/code&gt;.</source>
          <target state="translated">POST 요청에 대한 새 백엔드 정의를 작성합니다. 자세한 내용은 &lt;code&gt;when()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25a82e38306940d53cc0431c2027b19ad9784508" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition for PUT requests. For more info see &lt;code&gt;when()&lt;/code&gt;.</source>
          <target state="translated">PUT 요청에 대한 새 백엔드 정의를 작성합니다. 자세한 내용은 &lt;code&gt;when()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15f03f22d3c9680dc729ef2ccf8e1606ba4e48fa" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition that compares only with the requested route.</source>
          <target state="translated">요청 된 경로와 만 비교하는 새로운 백엔드 정의를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f48cdf8dae7db1d48c0c6ef4dea9caf8360e67d3" translate="yes" xml:space="preserve">
          <source>Creates a new backend definition.</source>
          <target state="translated">새로운 백엔드 정의를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e4122c824ad9684d95a45783de97719b5e6982d9" translate="yes" xml:space="preserve">
          <source>Creates a new child &lt;a href=&quot;%24rootscope.scope&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">새로운 자식 &lt;a href=&quot;%24rootscope.scope&quot;&gt;범위를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="de053e738e592f1089fb9a006cc3b78b9a9bb916" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation for DELETE requests. For more info see &lt;code&gt;expect()&lt;/code&gt;.</source>
          <target state="translated">DELETE 요청에 대한 새 요청 예상을 작성합니다. 자세한 내용은 &lt;code&gt;expect()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e36dcfb22e2a05490dc118fb61c929695cfc0cd2" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation for GET requests. For more info see &lt;code&gt;expect()&lt;/code&gt;.</source>
          <target state="translated">GET 요청에 대한 새 요청 예상을 작성합니다. 자세한 내용은 &lt;code&gt;expect()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="caa7758c7686ac3d104ccfccb9c7de838c640b7d" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation for HEAD requests. For more info see &lt;code&gt;expect()&lt;/code&gt;.</source>
          <target state="translated">HEAD 요청에 대한 새 요청 예상을 작성합니다. 자세한 내용은 &lt;code&gt;expect()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbdab2ed8f022128732b490b699f2be275275bdd" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation for JSONP requests. For more info see &lt;code&gt;expect()&lt;/code&gt;.</source>
          <target state="translated">JSONP 요청에 대한 새 요청 예상을 작성합니다. 자세한 내용은 &lt;code&gt;expect()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a3d06136b6563a9d9eca8d2c71cc5612b1d724c" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation for PATCH requests. For more info see &lt;code&gt;expect()&lt;/code&gt;.</source>
          <target state="translated">PATCH 요청에 대한 새 요청 예상을 작성합니다. 자세한 내용은 &lt;code&gt;expect()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee017574d4a1cc6b2b83a364ba45ecf9253c34cd" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation for POST requests. For more info see &lt;code&gt;expect()&lt;/code&gt;.</source>
          <target state="translated">POST 요청에 대한 새 요청 예상을 작성합니다. 자세한 내용은 &lt;code&gt;expect()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5406609dce34fb161e5e19a023b5cd524a033c97" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation for PUT requests. For more info see &lt;code&gt;expect()&lt;/code&gt;.</source>
          <target state="translated">PUT 요청에 대한 새 요청 예상을 작성합니다. 자세한 내용은 &lt;code&gt;expect()&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0be9180abbbad424813f1fc95de7b10c2c836e34" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation that compares only with the requested route.</source>
          <target state="translated">요청 된 경로와 만 비교되는 새로운 요청 예상을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a30b5b3ceb57067554cf2b1480796fa683e821bd" translate="yes" xml:space="preserve">
          <source>Creates a new request expectation.</source>
          <target state="translated">새로운 요청 기대를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b87ac50e12a922afd057ef55f3f8b4babfd88906" translate="yes" xml:space="preserve">
          <source>Creates a promise that is resolved as rejected with the specified &lt;code&gt;reason&lt;/code&gt;. This api should be used to forward rejection in a chain of promises. If you are dealing with the last promise in a promise chain, you don't need to worry about it.</source>
          <target state="translated">지정된 &lt;code&gt;reason&lt;/code&gt; 거부 된 것으로 확인 된 약속을 만듭니다 . 이 API는 일련의 약속에서 거부를 전달하는 데 사용해야합니다. 약속 체인의 마지막 약속을 다루는 경우 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d3b67b5019f3d6a71328d9460125c9c206f73df" translate="yes" xml:space="preserve">
          <source>Creates an injector object that can be used for retrieving services as well as for dependency injection (see &lt;a href=&quot;../../../guide/di&quot;&gt;dependency injection&lt;/a&gt;).</source>
          <target state="translated">의존성 주입뿐만 아니라 서비스 검색에도 사용할 수있는 인젝터 오브젝트를 작성합니다 ( &lt;a href=&quot;../../../guide/di&quot;&gt;종속성 주입&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7356a349c1f5567bb5bd540f22f1fb39ae0a858c" translate="yes" xml:space="preserve">
          <source>Creates an injector object that can be used for retrieving services as well as for dependency injection (see &lt;a href=&quot;../../guide/di&quot;&gt;dependency injection&lt;/a&gt;).</source>
          <target state="translated">의존성 주입뿐만 아니라 서비스 검색에도 사용할 수있는 인젝터 오브젝트를 작성합니다 ( &lt;a href=&quot;../../guide/di&quot;&gt;종속성 주입&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8695fdeaecdde9d69786b268e43f9db9c6275ac8" translate="yes" xml:space="preserve">
          <source>Creates and configures &lt;a href=&quot;../service/%24sanitize&quot;&gt;&lt;code&gt;$sanitize&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../service/%24sanitize&quot;&gt; &lt;code&gt;$sanitize&lt;/code&gt; &lt;/a&gt; 인스턴스를 만들고 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="02881b14df84f6433db6e90021eea6be086eb518" translate="yes" xml:space="preserve">
          <source>Creates and configures &lt;a href=&quot;ngsanitize/service/%24sanitize&quot;&gt;&lt;code&gt;$sanitize&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;ngsanitize/service/%24sanitize&quot;&gt; &lt;code&gt;$sanitize&lt;/code&gt; &lt;/a&gt; 인스턴스를 만들고 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="7b5cfadde58f93508e998389a777198ca3f108c0" translate="yes" xml:space="preserve">
          <source>Creates and configures &lt;a href=&quot;service/%24sanitize&quot;&gt;&lt;code&gt;$sanitize&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;service/%24sanitize&quot;&gt; &lt;code&gt;$sanitize&lt;/code&gt; &lt;/a&gt; 인스턴스를 만들고 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="edbda21e00ea49fe435ceaf70927ac4e177701c4" translate="yes" xml:space="preserve">
          <source>Creates and wires objects and functions</source>
          <target state="translated">객체와 함수를 생성하고 연결합니다</target>
        </trans-unit>
        <trans-unit id="ffcaf8830fe68d1b1f68ba57b8709c9d5b6199de" translate="yes" xml:space="preserve">
          <source>Creating Directives</source>
          <target state="translated">지시문 작성</target>
        </trans-unit>
        <trans-unit id="a700dae1bd51c2c95667196a1753a5f50b43b0b7" translate="yes" xml:space="preserve">
          <source>Creating Directives that Communicate</source>
          <target state="translated">의사 소통하는 지시문 작성</target>
        </trans-unit>
        <trans-unit id="8fbe66dd12a5b3a3552d7672f77f9a38a3123301" translate="yes" xml:space="preserve">
          <source>Creating Services</source>
          <target state="translated">서비스 만들기</target>
        </trans-unit>
        <trans-unit id="c10c8a9d5669bca0e2013728d5dfd0cb881a0713" translate="yes" xml:space="preserve">
          <source>Creating a Directive that Adds Event Listeners</source>
          <target state="translated">이벤트 리스너를 추가하는 지시문 작성</target>
        </trans-unit>
        <trans-unit id="f13dcfd72af44ef370551b4c95c6f4d5f8e82c46" translate="yes" xml:space="preserve">
          <source>Creating a Directive that Manipulates the DOM</source>
          <target state="translated">DOM을 조작하는 지시문 작성</target>
        </trans-unit>
        <trans-unit id="4908e625ec5c3fbe3253cd44e110565c0a03e356" translate="yes" xml:space="preserve">
          <source>Creating a Directive that Wraps Other Elements</source>
          <target state="translated">다른 요소를 감싸는 지시문 만들기</target>
        </trans-unit>
        <trans-unit id="00480fa3f76205fbcff45fe1d9ab6fe1895c433a" translate="yes" xml:space="preserve">
          <source>Creating aliases for these properties is possible with &lt;a href=&quot;nginit&quot;&gt;&lt;code&gt;ngInit&lt;/code&gt;&lt;/a&gt;. This may be useful when, for instance, nesting ngRepeats.</source>
          <target state="translated">&lt;a href=&quot;nginit&quot;&gt; &lt;code&gt;ngInit&lt;/code&gt; &lt;/a&gt; 로 이러한 속성에 대한 별칭을 만들 수 있습니다. 예를 들어 ngRepeats를 중첩 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4273e44c3ccf98604f4bbe4a2ea0575d5e6e7b94" translate="yes" xml:space="preserve">
          <source>Creating and configuring a Component</source>
          <target state="translated">구성 요소 작성 및 구성</target>
        </trans-unit>
        <trans-unit id="d2c811c7456325eb8da1fc874215e55532d587bd" translate="yes" xml:space="preserve">
          <source>Creating custom actions</source>
          <target state="translated">맞춤 액션 만들기</target>
        </trans-unit>
        <trans-unit id="b9844587b0d135a1f842558883719b722f871819" translate="yes" xml:space="preserve">
          <source>Creating custom filters</source>
          <target state="translated">맞춤 필터 만들기</target>
        </trans-unit>
        <trans-unit id="b5746d62259c2e464d484d43c4e1554d32d064d9" translate="yes" xml:space="preserve">
          <source>Creating local properties on widget scope creates two problems:</source>
          <target state="translated">위젯 범위에서 로컬 특성을 작성하면 두 가지 문제점이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2a4b56bb483692f538a3505e58481eb966e8ce9" translate="yes" xml:space="preserve">
          <source>Creation versus Retrieval</source>
          <target state="translated">창조 대 검색</target>
        </trans-unit>
        <trans-unit id="5af074006d430540128f3bf6a44cb8c6f303320b" translate="yes" xml:space="preserve">
          <source>Cross Site Request Forgery (XSRF) Protection</source>
          <target state="translated">XSRF (Cross Site Request Forgery) 보호</target>
        </trans-unit>
        <trans-unit id="c8673739ea7c8a0f8b25ce9b61f288f6a98b1451" translate="yes" xml:space="preserve">
          <source>Cross Site Request Forgery (XSRF/CSRF)</source>
          <target state="translated">사이트 간 요청 위조 (XSRF / CSRF)</target>
        </trans-unit>
        <trans-unit id="7fef8120d67245c18d2d3c23d1ec55c168fe972d" translate="yes" xml:space="preserve">
          <source>Currency symbol</source>
          <target state="translated">통화 기호</target>
        </trans-unit>
        <trans-unit id="3dd4bbd8be3d3584f64ec9d144ad17acc82acc08" translate="yes" xml:space="preserve">
          <source>Currency symbol or identifier to be displayed.</source>
          <target state="translated">표시 할 통화 기호 또는 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="8fc66fe26d9d8793cd1000496300cf9f2f548b32" translate="yes" xml:space="preserve">
          <source>Current RegExp if called without value or self for chaining otherwise.</source>
          <target state="translated">값을 지정하지 않고 호출하거나 그렇지 않으면 연결을 위해 자체 RegExp를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f226ae8b1558106c8adc6746637c3dbe2b31d834" translate="yes" xml:space="preserve">
          <source>Current route information.</source>
          <target state="translated">현재 경로 정보.</target>
        </trans-unit>
        <trans-unit id="1c94bf3985b8bccc15be49b6d0743db478a47075" translate="yes" xml:space="preserve">
          <source>Current value when called without a new value or self for chaining otherwise.</source>
          <target state="translated">새 값없이 호출 될 때의 현재 값 또는 다른 방식으로 연결하기 위해 자체 값</target>
        </trans-unit>
        <trans-unit id="6334d13a652b9fde3f48f69b6ce9c655418ee599" translate="yes" xml:space="preserve">
          <source>Current/previous route information.</source>
          <target state="translated">현재 / 이전 경로 정보.</target>
        </trans-unit>
        <trans-unit id="0c6c0c1904e8345998b07d175a1de44245761ead" translate="yes" xml:space="preserve">
          <source>Currently, ngAria interfaces with the following directives:</source>
          <target state="translated">현재 ngAria는 다음 지시문과 인터페이스합니다.</target>
        </trans-unit>
        <trans-unit id="4edef8165e277d94077897e6b7f0af7494905313" translate="yes" xml:space="preserve">
          <source>Currently, the &lt;strong&gt;Component Router&lt;/strong&gt; module must be installed via &lt;code&gt;npm&lt;/code&gt;/&lt;code&gt;yarn&lt;/code&gt;, it is not available on Bower or the Google CDN.</source>
          <target state="translated">현재 &lt;strong&gt;구성 요소 라우터&lt;/strong&gt; 모듈은 &lt;code&gt;npm&lt;/code&gt; / &lt;code&gt;yarn&lt;/code&gt; 을 통해 설치해야하며 Bower 또는 Google CDN에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="11e09346e5e227c0f25baf70a4c23438004527d4" translate="yes" xml:space="preserve">
          <source>Currently, the ngMessages module only contains the code for the &lt;code&gt;ngMessages&lt;/code&gt;, &lt;code&gt;ngMessagesInclude&lt;/code&gt;&lt;code&gt;ngMessage&lt;/code&gt;, &lt;code&gt;ngMessageExp&lt;/code&gt; and &lt;code&gt;ngMessageDefault&lt;/code&gt; directives.</source>
          <target state="translated">현재 ngMessages 모듈에는 &lt;code&gt;ngMessages&lt;/code&gt; , &lt;code&gt;ngMessagesInclude&lt;/code&gt; &lt;code&gt;ngMessage&lt;/code&gt; , &lt;code&gt;ngMessageExp&lt;/code&gt; 및 &lt;code&gt;ngMessageDefault&lt;/code&gt; 지시문에 대한 코드 만 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74d5d1b5bbf2644cec8eb6da6dea035b822c7813" translate="yes" xml:space="preserve">
          <source>Custom Validation</source>
          <target state="translated">맞춤 검증</target>
        </trans-unit>
        <trans-unit id="9b15bde65e9d230027d2d89ae778a8a3108d5df6" translate="yes" xml:space="preserve">
          <source>Custom error message displayed after the user interacted with a control (i.e. when &lt;code&gt;$touched&lt;/code&gt; is set)</source>
          <target state="translated">사용자가 컨트롤과 상호 작용 한 후 (예 : &lt;code&gt;$touched&lt;/code&gt; 가 설정된 경우) 표시되는 사용자 지정 오류 메시지</target>
        </trans-unit>
        <trans-unit id="b78660829b757d40d1cf02c5a67f5153479dc66e" translate="yes" xml:space="preserve">
          <source>Custom error message displayed upon submitting the form (&lt;code&gt;$submitted&lt;/code&gt; is set), even if the user didn't interact with a control</source>
          <target state="translated">사용자가 컨트롤과 상호 작용하지 않더라도 양식을 제출할 때 표시되는 사용자 지정 오류 메시지 ( &lt;code&gt;$submitted&lt;/code&gt; 가 설정 됨)</target>
        </trans-unit>
        <trans-unit id="d33be98b55db6c87b9f4e29aaa56cfc52eb74725" translate="yes" xml:space="preserve">
          <source>Custom model update triggers</source>
          <target state="translated">맞춤형 모델 업데이트 트리거</target>
        </trans-unit>
        <trans-unit id="7a16736ffe7d57250d06a87b758621a6d4a77ba3" translate="yes" xml:space="preserve">
          <source>DOM control structures for repeating, showing and hiding DOM fragments.</source>
          <target state="translated">DOM 조각 반복, 표시 및 숨기기를위한 DOM 제어 구조.</target>
        </trans-unit>
        <trans-unit id="9a03bb780a978fe1bf04b76b90365ca5e1cd807d" translate="yes" xml:space="preserve">
          <source>DOM element which is the root of AngularJS application.</source>
          <target state="translated">AngularJS 애플리케이션의 루트 인 DOM 요소</target>
        </trans-unit>
        <trans-unit id="854d235e232e068ef083bf90af82bc89c9fe562d" translate="yes" xml:space="preserve">
          <source>Dart</source>
          <target state="translated">Dart</target>
        </trans-unit>
        <trans-unit id="f20dcbd9b08fb9703f8879bef939587ab26fc293" translate="yes" xml:space="preserve">
          <source>Data Binding</source>
          <target state="translated">데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="7865e224a6bf57800137c76704b7833654f7c47d" translate="yes" xml:space="preserve">
          <source>Data Binding in AngularJS Templates</source>
          <target state="translated">AngularJS 템플릿의 데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="1ab20277bfa22894e79f0856de3b27a40d577c50" translate="yes" xml:space="preserve">
          <source>Data Binding in Classical Template Systems</source>
          <target state="translated">클래식 템플릿 시스템의 데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="ac99f5c112abda52d4e6d7eedc74c9f89d12480b" translate="yes" xml:space="preserve">
          <source>Data Modeling &lt;a href=&quot;https://github.com/js-data/js-data-angular&quot;&gt;JS-Data-Angular&lt;/a&gt;</source>
          <target state="translated">데이터 모델링 &lt;a href=&quot;https://github.com/js-data/js-data-angular&quot;&gt;JS- 데이터-앵귤러&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d38cca5da9c7df446a12182ab09218cd420e4017" translate="yes" xml:space="preserve">
          <source>Data binding</source>
          <target state="translated">데이터 바인딩</target>
        </trans-unit>
        <trans-unit id="156ab9c87cd161d279876149b77acd0b58d8fe2b" translate="yes" xml:space="preserve">
          <source>Data binding, as in &lt;code&gt;{{}}&lt;/code&gt;.</source>
          <target state="translated">데이터로 바인딩 &lt;code&gt;{{}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ebec9e3c5afe4e96b7b5d0a2b400ca889458eb" translate="yes" xml:space="preserve">
          <source>Data properties used by the &lt;a href=&quot;../function/angular.element#methods.html&quot;&gt;&lt;code&gt;scope()&lt;/code&gt;/&lt;code&gt;isolateScope()&lt;/code&gt; methods&lt;/a&gt; to return the element's scope.</source>
          <target state="translated">&lt;a href=&quot;../function/angular.element#methods.html&quot;&gt; &lt;code&gt;scope()&lt;/code&gt; / &lt;code&gt;isolateScope()&lt;/code&gt; 메서드&lt;/a&gt; 가 요소의 범위를 반환하는 데 사용하는 데이터 속성 .</target>
        </trans-unit>
        <trans-unit id="f722ccac00c1317dd3e7eb7f3ac23bac8fb4eb14" translate="yes" xml:space="preserve">
          <source>Data-binding in AngularJS apps is the automatic synchronization of data between the model and view components. The way that AngularJS implements data-binding lets you treat the model as the single-source-of-truth in your application. The view is a projection of the model at all times. When the model changes, the view reflects the change, and vice versa.</source>
          <target state="translated">AngularJS 앱의 데이터 바인딩은 모델과 뷰 구성 요소 간의 데이터 자동 동기화입니다. AngularJS가 데이터 바인딩을 구현하는 방식으로 모델을 애플리케이션의 단일 소스로 취급 할 수 있습니다. 뷰는 항상 모델의 투영입니다. 모델이 변경되면 뷰에 변경 사항이 반영되고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="77a57d575cbd23f1439b67b6fdff07165e77bcc2" translate="yes" xml:space="preserve">
          <source>Date to format either as Date object, milliseconds (string or number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.sssZ and its shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is specified in the string input, the time is considered to be in the local timezone.</source>
          <target state="translated">Date 객체, 밀리 초 (문자열 또는 숫자) 또는 다양한 ISO 8601 날짜 / 시간 문자열 형식 (예 : yyyy-MM-ddTHH : mm : ss.sssZ) 및 yyyy-MM-ddTHH : mmZ, yyyy-MM과 같은 짧은 버전으로 형식화 할 날짜 -dd 또는 yyyyMMddTHHmmssZ). 문자열 입력에 시간대를 지정하지 않으면 시간이 현지 시간대로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1ebe58a75d08e8dfda58bd2413fc709aa1379c08" translate="yes" xml:space="preserve">
          <source>Debouncing updates</source>
          <target state="translated">업데이트 취소</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="5e42ebfd421aa36ad532cb84814016fb095d849b" translate="yes" xml:space="preserve">
          <source>Decorators are a design pattern that is used to separate modification or &lt;em&gt;decoration&lt;/em&gt; of a class without modifying the original source code. In AngularJS, decorators are functions that allow a service, directive or filter to be modified prior to its usage.</source>
          <target state="translated">데코레이터는 원본 소스 코드를 수정하지 않고 클래스의 수정 또는 &lt;em&gt;장식&lt;/em&gt; 을 분리하는 데 사용되는 디자인 패턴입니다 . AngularJS에서 데코레이터는 서비스, 지시문 또는 필터를 사용하기 전에 수정할 수있는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a7868dadf07f1c7850edc7089cb77140b698014a" translate="yes" xml:space="preserve">
          <source>Decorators have different rules for different services. This is because services are registered in different ways. Services are selected by name, however filters and directives are selected by appending &lt;code&gt;&quot;Filter&quot;&lt;/code&gt; or &lt;code&gt;&quot;Directive&quot;&lt;/code&gt; to the end of the name. The &lt;code&gt;$delegate&lt;/code&gt; provided is dictated by the type of service.</source>
          <target state="translated">데코레이터마다 서비스마다 다른 규칙이 있습니다. 서비스가 다른 방식으로 등록 되었기 때문입니다. 서비스는 이름으로 선택되지만 필터 및 지시문은 이름 끝에 &lt;code&gt;&quot;Filter&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;Directive&quot;&lt;/code&gt; 를 추가하여 선택됩니다 . &lt;code&gt;$delegate&lt;/code&gt; 제공은 서비스의 종류에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="09211fe2da464fdb5a53e646de8838c5aaa9ef4f" translate="yes" xml:space="preserve">
          <source>Deeply extends the destination object &lt;code&gt;dst&lt;/code&gt; by copying own enumerable properties from the &lt;code&gt;src&lt;/code&gt; object(s) to &lt;code&gt;dst&lt;/code&gt;. You can specify multiple &lt;code&gt;src&lt;/code&gt; objects. If you want to preserve original objects, you can do so by passing an empty object as the target: &lt;code&gt;var object = angular.merge({}, object1, object2)&lt;/code&gt;.</source>
          <target state="translated">깊이 대상 객체의 확장 &lt;code&gt;dst&lt;/code&gt; 로부터 자신의 열거 속성을 복사하여 &lt;code&gt;src&lt;/code&gt; 에 객체 (들) &lt;code&gt;dst&lt;/code&gt; . 여러 &lt;code&gt;src&lt;/code&gt; 객체를 지정할 수 있습니다 . 원본 객체를 유지하려면 빈 객체를 대상으로 전달하면됩니다. &lt;code&gt;var object = angular.merge({}, object1, object2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48d349eb48cca72baf0fba3472796293caf10dff" translate="yes" xml:space="preserve">
          <source>Default &lt;a href=&quot;%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; params serializer that converts objects to strings according to the following rules:</source>
          <target state="translated">다음 규칙에 따라 객체를 문자열로 변환하는 기본 &lt;a href=&quot;%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; params serializer</target>
        </trans-unit>
        <trans-unit id="e18582a087571d146a0e46c24129165fcade2bbe" translate="yes" xml:space="preserve">
          <source>Default &lt;a href=&quot;service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; params serializer that converts objects to strings according to the following rules:</source>
          <target state="translated">다음 규칙에 따라 객체를 문자열로 변환하는 기본 &lt;a href=&quot;service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; params serializer</target>
        </trans-unit>
        <trans-unit id="272d05ca374dc5c4d632482aeb433788c4ec30ec" translate="yes" xml:space="preserve">
          <source>Default Transformations</source>
          <target state="translated">기본 변환</target>
        </trans-unit>
        <trans-unit id="e5f063eb61d4592c613ead4c13dd985673caf4ef" translate="yes" xml:space="preserve">
          <source>Default events, extra triggers, and catch-all debounce values</source>
          <target state="translated">기본 이벤트, 추가 트리거 및 포괄 모든 디 바운스 값</target>
        </trans-unit>
        <trans-unit id="31d4d566cb937a1de4b2420380b5397c1828e7ea" translate="yes" xml:space="preserve">
          <source>Default implementation of $animate that doesn't perform any animations, instead just synchronously performs DOM updates and resolves the returned runner promise.</source>
          <target state="translated">애니메이션을 수행하지 않는 $ animate의 기본 구현은 DOM 업데이트를 동기식으로 수행하고 반환 된 러너 약속을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="2c5bb4ffb680656f0530a451ee96703523ca759b" translate="yes" xml:space="preserve">
          <source>Default values for &lt;code&gt;url&lt;/code&gt; parameters. These can be overridden in &lt;code&gt;actions&lt;/code&gt; methods. If a parameter value is a function, it will be called every time a param value needs to be obtained for a request (unless the param was overridden). The function will be passed the current data value as an argument.</source>
          <target state="translated">&lt;code&gt;url&lt;/code&gt; 매개 변수의 기본값 입니다. 이것들은 &lt;code&gt;actions&lt;/code&gt; 메소드 에서 재정의 될 수 있습니다 . 매개 변수 값이 함수 인 경우 요청에 대해 매개 변수 값을 확보해야 할 때마다 (매개 변수가 대체되지 않는 한) 호출됩니다. 함수는 현재 데이터 값을 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="317bbd656753a9dd8ea52dce97e89a2822b25653" translate="yes" xml:space="preserve">
          <source>Default:</source>
          <target state="translated">Default:</target>
        </trans-unit>
        <trans-unit id="1edc1c012a2ea4113df21912c28c7ea3c9ec3a61" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'!'&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;'!'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f38409cbc5f1ef34d4d1682cfb27697f30ae623" translate="yes" xml:space="preserve">
          <source>Default: true. When used without argument, it returns the current value.</source>
          <target state="translated">기본값 : true 인수없이 사용하면 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8652ebd1a1875dc842cac2cb6d36ca46a049174" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="797eed95d0237127f8eda8c263a529ceb7fafcb9" translate="yes" xml:space="preserve">
          <source>Defaults to false. If no value is specified, returns the current configured value.</source>
          <target state="translated">기본값은 false입니다. 값을 지정하지 않으면 현재 구성된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcabacc99098c666fe2451c159c66618bff14d10" translate="yes" xml:space="preserve">
          <source>Deferred Bootstrap</source>
          <target state="translated">지연된 부트 스트랩</target>
        </trans-unit>
        <trans-unit id="74c52f18a0d6437fe8a1f390cd629d4d1f6fb607" translate="yes" xml:space="preserve">
          <source>Define an animation on the affected elements.</source>
          <target state="translated">영향을받는 요소에 애니메이션을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="0d1872060c4b7a4227a5bb96f09173f2a080f3cf" translate="yes" xml:space="preserve">
          <source>Defines an animation hook that can be later used with &lt;a href=&quot;../service/%24animate&quot;&gt;$animate&lt;/a&gt; service and directives that use this service.</source>
          <target state="translated">나중에 &lt;a href=&quot;../service/%24animate&quot;&gt;$ animate&lt;/a&gt; 서비스 및이 서비스를 사용하는 지시문과 함께 사용할 수있는 애니메이션 후크를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6cbc7c52232bf21d30296e7e147625b5fda618ff" translate="yes" xml:space="preserve">
          <source>Defines the security context for DOM properties bound by ng-prop-*.</source>
          <target state="translated">ng-prop- *에 의해 바인딩 된 DOM 속성에 대한 보안 컨텍스트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="32989cdf0067cee754e3070b85d64e05afb480b3" translate="yes" xml:space="preserve">
          <source>Delay in milliseconds.</source>
          <target state="translated">밀리 초 단위로 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="3302581e2ec4f0f6eeb35f27969f476b33fc5b38" translate="yes" xml:space="preserve">
          <source>Delegates to &lt;a href=&quot;%24scedelegate#getTrusted.html&quot;&gt;&lt;code&gt;$sceDelegate.getTrusted&lt;/code&gt;&lt;/a&gt;. As such, takes any input, and either returns a value that's safe to use in the specified context, or throws an exception. This function is aware of trusted values created by the &lt;code&gt;trustAs&lt;/code&gt; function and its shorthands, and when contexts are appropriate, returns the unwrapped value as-is. Finally, this function can also throw when there is no way to turn &lt;code&gt;maybeTrusted&lt;/code&gt; in a safe value (e.g., no sanitization is available or possible.)</source>
          <target state="translated">&lt;a href=&quot;%24scedelegate#getTrusted.html&quot;&gt; &lt;code&gt;$sceDelegate.getTrusted&lt;/code&gt; &lt;/a&gt; 위임합니다 . 따라서 입력을 받고 지정된 컨텍스트에서 사용하기에 안전한 값을 반환하거나 예외를 발생시킵니다. 이 함수는 &lt;code&gt;trustAs&lt;/code&gt; 함수에 의해 생성 된 신뢰할 수있는 값 과 그 속기를 알고 있으며 컨텍스트가 적절하면 래핑되지 않은 값을 그대로 반환합니다. 마지막으로,이 기능은 안전한 값으로 (예를 들어, 살균을 사용할 수 없거나 가능하지 않은) &lt;code&gt;maybeTrusted&lt;/code&gt; 돌릴 방법이 없을 때 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f25baa776bc468f235f2d35f9972a7ad7ed42aa2" translate="yes" xml:space="preserve">
          <source>Delegates to &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt;. As such, returns a wrapped object that represents your value, and the trust you have in its safety for the given context. AngularJS can then use that value as-is in bindings of the specified secure context. This is used in bindings for &lt;code&gt;ng-bind-html&lt;/code&gt;, &lt;code&gt;ng-include&lt;/code&gt;, and most &lt;code&gt;src&lt;/code&gt; attribute interpolations. See &lt;a href=&quot;%24sce&quot;&gt;$sce&lt;/a&gt; for strict contextual escaping.</source>
          <target state="translated">&lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; 위임합니다 . 따라서 값과 주어진 컨텍스트에 대한 안전성에 대한 신뢰를 나타내는 랩핑 된 오브젝트를 리턴합니다. 그러면 AngularJS는 지정된 보안 컨텍스트의 바인딩에있는 그대로 해당 값을 사용할 수 있습니다. 이것은 &lt;code&gt;ng-bind-html&lt;/code&gt; , &lt;code&gt;ng-include&lt;/code&gt; 및 대부분의 &lt;code&gt;src&lt;/code&gt; 속성 보간에 대한 바인딩에 사용됩니다 . 엄격한 문맥 이탈에 대해서는 &lt;a href=&quot;%24sce&quot;&gt;$ sce&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37499fbdb55b6f4f8b4ca5691cd7ea820e28edff" translate="yes" xml:space="preserve">
          <source>Demonstration of nesting</source>
          <target state="translated">중첩 시연</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="6e0ef472d186db187fa4eb4f242e7f5f04004e20" translate="yes" xml:space="preserve">
          <source>Dependencies and Order of execution</source>
          <target state="translated">의존성과 실행 순서</target>
        </trans-unit>
        <trans-unit id="83a3432efddfe802976a8d09a38d176492fb9172" translate="yes" xml:space="preserve">
          <source>Dependency Annotation</source>
          <target state="translated">의존성 주석</target>
        </trans-unit>
        <trans-unit id="3aefbe2f210572802298b2ad0347dc9e423d2690" translate="yes" xml:space="preserve">
          <source>Dependency Injection</source>
          <target state="translated">의존성 주입</target>
        </trans-unit>
        <trans-unit id="bac2d51482e3737a082e50bda9cc403b422810db" translate="yes" xml:space="preserve">
          <source>Dependency Injection (DI) is a software design pattern that deals with how components get hold of their dependencies.</source>
          <target state="translated">종속성 주입 (DI)은 구성 요소가 종속성을 유지하는 방법을 처리하는 소프트웨어 디자인 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="6a2482ebf1a4a0d728e1de1670f37f634d9570f4" translate="yes" xml:space="preserve">
          <source>Dependency Injection in AngularJS</source>
          <target state="translated">AngularJS의 의존성 주입</target>
        </trans-unit>
        <trans-unit id="4047c105d9cf170d730f33a2033d59df30b22746" translate="yes" xml:space="preserve">
          <source>Dependency Injection is pervasive throughout AngularJS. You can use it when defining components or when providing &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; blocks for a module.</source>
          <target state="translated">의존성 주입은 AngularJS 전체에 널리 퍼져 있습니다. 구성 요소를 정의 할 때 또는 모듈에 &lt;code&gt;run&lt;/code&gt; 및 &lt;code&gt;config&lt;/code&gt; 블록을 제공 할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="327a55f82dc6818877a68e37b722bb7f2360b633" translate="yes" xml:space="preserve">
          <source>Deployment</source>
          <target state="translated">Deployment</target>
        </trans-unit>
        <trans-unit id="8201f6ff0e5004a4bfccdbd8144af27f2013f8eb" translate="yes" xml:space="preserve">
          <source>Deregister a control from the form.</source>
          <target state="translated">폼에서 컨트롤을 등록 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="2af89a89cef15b822c0d0acc729909c302781d81" translate="yes" xml:space="preserve">
          <source>Deregisters an event listener based on the event which has been associated with the provided element. This method can be used in three different ways depending on the arguments:</source>
          <target state="translated">제공된 요소와 연관된 이벤트를 기반으로 이벤트 리스너를 등록 취소합니다. 이 방법은 인수에 따라 세 가지 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e3f132e020453df1a9acbebf0586c70543cd8c33" translate="yes" xml:space="preserve">
          <source>Deserialized JSON string.</source>
          <target state="translated">역 직렬화 된 JSON 문자열</target>
        </trans-unit>
        <trans-unit id="4cd052d554151d1dc02fd9731f9a485e9108a179" translate="yes" xml:space="preserve">
          <source>Deserialized cookie value.</source>
          <target state="translated">역 직렬화 된 쿠키 값.</target>
        </trans-unit>
        <trans-unit id="1a80bbcd8ea1a814fe2e5d77c9178e1038921990" translate="yes" xml:space="preserve">
          <source>Deserializes a JSON string.</source>
          <target state="translated">JSON 문자열을 deserialize합니다.</target>
        </trans-unit>
        <trans-unit id="c27667616e652be84cc2c1b6b99515c219d63d79" translate="yes" xml:space="preserve">
          <source>Design Principles of AngularJS (video)</source>
          <target state="translated">AngularJS의 설계 원리 (비디오)</target>
        </trans-unit>
        <trans-unit id="dfc06cd40e8bbe5fdfe5911a99ffee939388a01e" translate="yes" xml:space="preserve">
          <source>Destination into which the source is copied. If provided, must be of the same type as &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">소스가 복사되는 대상 제공되는 경우 &lt;code&gt;source&lt;/code&gt; 와 동일한 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="888c51c1c5c27c5b36b8738901ae380a900d1853" translate="yes" xml:space="preserve">
          <source>Destination object.</source>
          <target state="translated">대상 객체.</target>
        </trans-unit>
        <trans-unit id="a1e2c0b92bdd88f0fcb0c37a3c357ef7f0dfaccb" translate="yes" xml:space="preserve">
          <source>Destroys the &lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; object entirely, removing it from the &lt;a href=&quot;../service/%24cachefactory&quot;&gt;$cacheFactory&lt;/a&gt; set.</source>
          <target state="translated">&lt;a href=&quot;../service/%24cachefactory&quot;&gt;$ cacheFactory&lt;/a&gt; 세트 에서 제거 하여 &lt;a href=&quot;%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; 객체를 완전히 파기합니다 .</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="3d2a0d7f87ba443d5d9d80e16047385ccffb8fd6" translate="yes" xml:space="preserve">
          <source>Determines if a reference is a &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">참조가 &lt;code&gt;Function&lt;/code&gt; 인지 판별합니다 .</target>
        </trans-unit>
        <trans-unit id="4113c903a447369d1069839fa1070f046a4c3170" translate="yes" xml:space="preserve">
          <source>Determines if a reference is a &lt;code&gt;Number&lt;/code&gt;.</source>
          <target state="translated">참조가 &lt;code&gt;Number&lt;/code&gt; 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="e163b7686cbd75d6ac0afa43f59a2a1afdecef9a" translate="yes" xml:space="preserve">
          <source>Determines if a reference is a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">참조가 &lt;code&gt;String&lt;/code&gt; 인지를 판정합니다 .</target>
        </trans-unit>
        <trans-unit id="1cf350f5a8069497935175567e278f51b713aa42" translate="yes" xml:space="preserve">
          <source>Determines if a reference is a DOM element (or wrapped jQuery element).</source>
          <target state="translated">참조가 DOM 요소 (또는 랩핑 된 jQuery 요소)인지 판별합니다.</target>
        </trans-unit>
        <trans-unit id="d525fdf8b5a9d0d2c0f715b9068dd493ccd6f25b" translate="yes" xml:space="preserve">
          <source>Determines if a reference is an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">참조가 &lt;code&gt;Array&lt;/code&gt; 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b2be2458af6292b2bcac1469ec435b958dd083b5" translate="yes" xml:space="preserve">
          <source>Determines if a reference is an &lt;code&gt;Object&lt;/code&gt;. Unlike &lt;code&gt;typeof&lt;/code&gt; in JavaScript, &lt;code&gt;null&lt;/code&gt;s are not considered to be objects. Note that JavaScript arrays are objects.</source>
          <target state="translated">참조가 &lt;code&gt;Object&lt;/code&gt; 인지 확인합니다 . JavaScript의 &lt;code&gt;typeof&lt;/code&gt; 와 달리 &lt;code&gt;null&lt;/code&gt; 은 객체로 간주되지 않습니다. JavaScript 배열은 객체입니다.</target>
        </trans-unit>
        <trans-unit id="f1973ee38e2820392df6987b25ac623a3df111fa" translate="yes" xml:space="preserve">
          <source>Determines if a reference is defined.</source>
          <target state="translated">참조가 정의되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5acbddde98e2e5498cdcbbd393b69655ebfab3fd" translate="yes" xml:space="preserve">
          <source>Determines if a reference is undefined.</source>
          <target state="translated">참조가 정의되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f3d374285cfc5534564499c4ffd11134b73c0553" translate="yes" xml:space="preserve">
          <source>Determines if a value is a date.</source>
          <target state="translated">값이 날짜인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="03fe2f186b89e2d26eec4a0369aec723c0e6b2e2" translate="yes" xml:space="preserve">
          <source>Determines if two objects or two values are equivalent. Supports value types, regular expressions, arrays and objects.</source>
          <target state="translated">두 개체 또는 두 값이 같은지 확인합니다. 값 유형, 정규식, 배열 및 객체를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9e4bd027f55486bc01eb5c3e7f889479826c89f5" translate="yes" xml:space="preserve">
          <source>Develop</source>
          <target state="translated">Develop</target>
        </trans-unit>
        <trans-unit id="45e199c34f2e47d26bd6cf3b0bc418229f9353d7" translate="yes" xml:space="preserve">
          <source>Developer Guide</source>
          <target state="translated">개발자 안내서</target>
        </trans-unit>
        <trans-unit id="8b51dbd8f299bc7c073294b641b3f766d5ad2466" translate="yes" xml:space="preserve">
          <source>Didn't find what you're looking for here? Check out the &lt;a href=&quot;guide/external-resources&quot;&gt;External AngularJS resources guide&lt;/a&gt;.</source>
          <target state="translated">찾고있는 것을 찾지 못했습니까? &lt;a href=&quot;guide/external-resources&quot;&gt;External AngularJS 자원 안내서를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2886baaf05b749277028afeb9b687e96ffae3fa3" translate="yes" xml:space="preserve">
          <source>Differences between Kris Kowal's Q and $q</source>
          <target state="translated">Kris Kowal의 Q와 $ q의 차이점</target>
        </trans-unit>
        <trans-unit id="0a4e32e999a601265a21ab8df0f84e0f0c01e628" translate="yes" xml:space="preserve">
          <source>Differences from the ICU MessageFormat syntax</source>
          <target state="translated">ICU MessageFormat 구문과의 차이점</target>
        </trans-unit>
        <trans-unit id="82ee6eee6c53c6516212864425aaba8fdf0037c2" translate="yes" xml:space="preserve">
          <source>Different DOM between &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;templateUrl&lt;/code&gt;: &lt;a href=&quot;https://github.com/angular/angular.js/issues/14326&quot;&gt;#10612&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 와 &lt;code&gt;templateUrl&lt;/code&gt; 사이의 다른 DOM : &lt;a href=&quot;https://github.com/angular/angular.js/issues/14326&quot;&gt;# 10612&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="164e0b79063f11a2936cf830fb48b8c7054cc118" translate="yes" xml:space="preserve">
          <source>Directive</source>
          <target state="translated">Directive</target>
        </trans-unit>
        <trans-unit id="fda754562558210f994489b54b2697a96dc73fa2" translate="yes" xml:space="preserve">
          <source>Directive Definition Object</source>
          <target state="translated">지시어 정의 객체</target>
        </trans-unit>
        <trans-unit id="e9cd5ca17a7c95f80bd097f0322c1ccdcc4c3d5b" translate="yes" xml:space="preserve">
          <source>Directive Info</source>
          <target state="translated">지시 정보</target>
        </trans-unit>
        <trans-unit id="67e1beffb6df3ce747606244ee286332d2ea20a6" translate="yes" xml:space="preserve">
          <source>Directive Support</source>
          <target state="translated">지시 지원</target>
        </trans-unit>
        <trans-unit id="1f833a7af0a6aaa31ef34696128cfbeafe3eed41" translate="yes" xml:space="preserve">
          <source>Directive components in ng</source>
          <target state="translated">ng의 지시문 구성 요소</target>
        </trans-unit>
        <trans-unit id="4cc0bdd0eee78ccef5ca412ee771d3f81c05f4a4" translate="yes" xml:space="preserve">
          <source>Directive components in ngAnimate</source>
          <target state="translated">ngAnimate의 지시문 구성 요소</target>
        </trans-unit>
        <trans-unit id="844df4f4bdaa7d4d1ccd12b056cbe1adfcc021cb" translate="yes" xml:space="preserve">
          <source>Directive components in ngComponentRouter</source>
          <target state="translated">ngComponentRouter의 지시문 구성 요소</target>
        </trans-unit>
        <trans-unit id="de98d7620ad6306ead111be196ed86e3671c7290" translate="yes" xml:space="preserve">
          <source>Directive components in ngMessages</source>
          <target state="translated">ngMessages의 지시문 구성 요소</target>
        </trans-unit>
        <trans-unit id="3e59659ae9dccbcaae81c53c6bc245083968f924" translate="yes" xml:space="preserve">
          <source>Directive components in ngRoute</source>
          <target state="translated">ngRoute의 지시문 구성 요소</target>
        </trans-unit>
        <trans-unit id="91447be933b3e2599ebeeeffc119c8212eeed0af" translate="yes" xml:space="preserve">
          <source>Directive components in ngTouch</source>
          <target state="translated">ngTouch의 지시문 구성 요소</target>
        </trans-unit>
        <trans-unit id="d6115f4adc06b0e052bc4ff5724424c7b78aeddd" translate="yes" xml:space="preserve">
          <source>Directive controllers can provide the following methods that are called by AngularJS at points in the life-cycle of the directive:</source>
          <target state="translated">지시문 제어기는 지시문의 수명주기 지점에서 AngularJS가 호출하는 다음 메소드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="302daa750770cb865e5e869c5d3fb8ea941e26e5" translate="yes" xml:space="preserve">
          <source>Directive name, or an object map of directives where the keys are the names and the values are the factories.</source>
          <target state="translated">지시문 이름 또는 키가 이름이고 값이 팩토리 인 지시문의 오브젝트 맵.</target>
        </trans-unit>
        <trans-unit id="7490be6dee2947f333e03a7200032b150a8f8592" translate="yes" xml:space="preserve">
          <source>Directive that instantiates &lt;a href=&quot;../type/form.formcontroller&quot;&gt;FormController&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../type/form.formcontroller&quot;&gt;FormController&lt;/a&gt; 를 인스턴스화하는 지시어 .</target>
        </trans-unit>
        <trans-unit id="d24b0ceb64605261d7559cd1d1e867e4d882600f" translate="yes" xml:space="preserve">
          <source>Directive that instantiates &lt;a href=&quot;type/form.formcontroller&quot;&gt;FormController&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;type/form.formcontroller&quot;&gt;FormController&lt;/a&gt; 를 인스턴스화하는 지시어 .</target>
        </trans-unit>
        <trans-unit id="8735ba9d320dcda668a0816d217511ecea07ecf0" translate="yes" xml:space="preserve">
          <source>Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.</source>
          <target state="translated">transclusion을 사용하는 가장 가까운 상위 지시문의 삽입 된 DOM에 대한 삽입 점을 표시하는 지시문입니다.</target>
        </trans-unit>
        <trans-unit id="746cc62cda06834c2b42e5ffe56a1badbb306cd7" translate="yes" xml:space="preserve">
          <source>Directive types</source>
          <target state="translated">지시어 타입</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="336c7042caff79e8e52e079db85c30958078de48" translate="yes" xml:space="preserve">
          <source>Directives are not deduplicated before compilation</source>
          <target state="translated">컴파일 전에 지시문은 중복 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0050d5ca31968a90a87b0b2b5fe12a4a6f033632" translate="yes" xml:space="preserve">
          <source>Directives are not re-compiled</source>
          <target state="translated">지시문은 다시 컴파일되지 않습니다</target>
        </trans-unit>
        <trans-unit id="8d67d16379fb0c5fb472d4b6392bed6f0a88bbfa" translate="yes" xml:space="preserve">
          <source>Directives can require the controllers of other directives to enable communication between each other. This can be achieved in a component by providing an object mapping for the &lt;code&gt;require&lt;/code&gt; property. The object keys specify the property names under which the required controllers (object values) will be bound to the requiring component's controller.</source>
          <target state="translated">지시문은 다른 지시문의 컨트롤러가 서로 통신 할 수 있도록 요구할 수 있습니다. 이는 &lt;code&gt;require&lt;/code&gt; 속성에 대한 객체 매핑을 제공하여 구성 요소에서 달성 할 수 있습니다 . 객체 키는 필요한 컨트롤러 (객체 값)가 필요한 구성 요소의 컨트롤러에 바인딩 될 속성 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b5ec19ceda57dbf701f9e59456ca25e9c7b1a674" translate="yes" xml:space="preserve">
          <source>Directives in AngularJS are responsible for encapsulating complex functionality within custom HTML tags, attributes, classes or comments. Unit tests are very important for directives because the components you create with directives may be used throughout your application and in many different contexts.</source>
          <target state="translated">AngularJS의 지시문은 사용자 정의 HTML 태그, 속성, 클래스 또는 주석 내에 복잡한 기능을 캡슐화합니다. 지시문을 사용하여 만드는 구성 요소는 응용 프로그램 전체와 다양한 상황에서 사용될 수 있으므로 지시문에는 단위 테스트가 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="bdc211594d3e011463f460b1b6ff16a3553721bd" translate="yes" xml:space="preserve">
          <source>Directives like &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt;&lt;code&gt;ngClick&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/ng/directive/ngfocus&quot;&gt;&lt;code&gt;ngFocus&lt;/code&gt;&lt;/a&gt; expose a &lt;code&gt;$event&lt;/code&gt; object within the scope of that expression. The object is an instance of a &lt;a href=&quot;http://api.jquery.com/category/events/event-object/&quot;&gt;jQuery Event Object&lt;/a&gt; when jQuery is present or a similar jqLite object.</source>
          <target state="translated">같은 지침 &lt;a href=&quot;../api/ng/directive/ngclick&quot;&gt; &lt;code&gt;ngClick&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/ng/directive/ngfocus&quot;&gt; &lt;code&gt;ngFocus&lt;/code&gt; 는&lt;/a&gt; 노출 &lt;code&gt;$event&lt;/code&gt; 그 표현의 범위 내에서 개체를. 객체는 jQuery가 있거나 jqLite 객체와 유사한 &lt;a href=&quot;http://api.jquery.com/category/events/event-object/&quot;&gt;jQuery 이벤트 객체&lt;/a&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="6434913d2a02f2df51c8dfef0163eab8e24c7df1" translate="yes" xml:space="preserve">
          <source>Directives often have a &lt;strong&gt;link function&lt;/strong&gt;. A link function allows the directive to register listeners to the specific cloned DOM element instance as well as to copy content into the DOM from the scope.</source>
          <target state="translated">지시문에는 종종 &lt;strong&gt;링크 기능이&lt;/strong&gt; 있습니다. 링크 함수를 사용하면 지시문이 리스너를 특정 복제 된 DOM 요소 인스턴스에 등록하고 컨텐츠를 범위에서 DOM으로 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="033d63aa44ddfb57d03dea3272e0203cf62b3238" translate="yes" xml:space="preserve">
          <source>Directives that Create Scopes</source>
          <target state="translated">범위를 생성하는 지시문</target>
        </trans-unit>
        <trans-unit id="a74321a33161090e50af4b36d898258f47549ad8" translate="yes" xml:space="preserve">
          <source>Directives that use transclusion are treated specially by the compiler. Before their compile function is called, the contents of the directive's element are removed from the element and provided via a transclusion function. The directive's template is then appended to the directive's element, to which it can then insert the transcluded content into its template.</source>
          <target state="translated">변환을 사용하는 지시문은 컴파일러에서 특별히 처리합니다. 컴파일 함수가 호출되기 전에 지시문 요소의 내용이 요소에서 제거되고 변환 함수를 통해 제공됩니다. 지시문의 템플릿은 지시문의 요소에 추가되며, 변환 된 내용을 템플릿에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bdab4ccc71e22e8ec90abeea9ccfd1df46ff179" translate="yes" xml:space="preserve">
          <source>Directives that want to modify the DOM typically use the &lt;code&gt;link&lt;/code&gt; option to register DOM listeners as well as update the DOM. It is executed after the template has been cloned and is where directive logic will be put.</source>
          <target state="translated">DOM을 수정하려는 지시문은 일반적으로 &lt;code&gt;link&lt;/code&gt; 옵션을 사용하여 DOM 리스너를 등록하고 DOM을 업데이트합니다. 템플릿이 복제 된 후 실행되며 지시문 로직이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="e5140a8ef3a9bc2683f73052c7fd79865733a8ce" translate="yes" xml:space="preserve">
          <source>Dirty checking can be done with three strategies: By reference, by collection contents, and by value. The strategies differ in the kinds of changes they detect, and in their performance characteristics.</source>
          <target state="translated">더티 검사는 세 가지 전략으로 수행 할 수 있습니다 : 참조, 수집 내용 및 가치. 전략은 감지하는 변경의 종류와 성능 특성이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f7eed9ee6c74c9630f8e771d832431d6115feaf3" translate="yes" xml:space="preserve">
          <source>Dirty checking the scope for property changes is a common operation in AngularJS and for this reason the dirty checking function must be efficient. Care should be taken that the dirty checking function does not do any DOM access, as DOM access is orders of magnitude slower than property access on JavaScript object.</source>
          <target state="translated">속성 변경 범위의 더티 검사는 AngularJS에서 일반적인 작업이므로 더티 검사 기능이 효율적이어야합니다. DOM 액세스는 JavaScript 객체의 속성 액세스보다 훨씬 느리므로 더티 검사 기능은 DOM 액세스를 수행하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="14f2ccf9e7d630a13a9a51eb1a154be01aba9e61" translate="yes" xml:space="preserve">
          <source>Disable comment and css class directives</source>
          <target state="translated">주석 및 CSS 클래스 지시문 비활성화</target>
        </trans-unit>
        <trans-unit id="17f67c438b25665408ced77a0f973ff152910ec2" translate="yes" xml:space="preserve">
          <source>Disabling Debug Data</source>
          <target state="translated">디버그 데이터 비활성화</target>
        </trans-unit>
        <trans-unit id="4c52842f01d8ff2a00e9728305157459d5a938ec" translate="yes" xml:space="preserve">
          <source>Disabling Specific Attributes</source>
          <target state="translated">특정 속성 비활성화</target>
        </trans-unit>
        <trans-unit id="de84716cee60c5cb4c6d2f6f25d3ac55ddcd7e00" translate="yes" xml:space="preserve">
          <source>Disabling attributes</source>
          <target state="translated">속성 비활성화</target>
        </trans-unit>
        <trans-unit id="20ef6ef888eb023c4461090d2f38a7acea56c9fa" translate="yes" xml:space="preserve">
          <source>Disabling auto-escaping is extremely dangerous, it usually creates a Cross Site Scripting (XSS) vulnerability in your application.</source>
          <target state="translated">자동 이스케이프를 비활성화하면 매우 위험하므로 일반적으로 응용 프로그램에 XSS (Cross Site Scripting) 취약점이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f51a2a3fb5aa9f0b2bf05d11e6cc36721611e66" translate="yes" xml:space="preserve">
          <source>Disabling ngAria on Specific Elements</source>
          <target state="translated">특정 요소에서 ngAria 비활성화</target>
        </trans-unit>
        <trans-unit id="e408de586a7e2622fd333d5e79f8788540adc05a" translate="yes" xml:space="preserve">
          <source>Disallow argument name annotation inference.</source>
          <target state="translated">인수 이름 주석 유추를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85016ac7fabd0f269f3323d663fd847b3d8b64a4" translate="yes" xml:space="preserve">
          <source>Discuss</source>
          <target state="translated">Discuss</target>
        </trans-unit>
        <trans-unit id="22d9c848e577ae1fec59456eee03bc9ea644ba34" translate="yes" xml:space="preserve">
          <source>Dispatches an event &lt;code&gt;name&lt;/code&gt; downwards to all child scopes (and their children) notifying the registered &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt; listeners.</source>
          <target state="translated">등록 된 &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt; 리스너 에게 알리는 모든 하위 범위 (및 해당 하위)에 이벤트 &lt;code&gt;name&lt;/code&gt; 아래쪽으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="522ab92da5006452539dc8ace74860c58110db39" translate="yes" xml:space="preserve">
          <source>Dispatches an event &lt;code&gt;name&lt;/code&gt; upwards through the scope hierarchy notifying the registered &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt; listeners.</source>
          <target state="translated">등록 된 &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt; 리스너 에게 알리는 범위 계층 구조를 통해 위쪽으로 이벤트 &lt;code&gt;name&lt;/code&gt; 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d77fffba57484870bc54fe43094d3c654c48c5c8" translate="yes" xml:space="preserve">
          <source>Displaying a default message</source>
          <target state="translated">기본 메시지 표시</target>
        </trans-unit>
        <trans-unit id="6a1d6df1044462482aefb148d802e6a902833016" translate="yes" xml:space="preserve">
          <source>Displaying multiple messages at the same time</source>
          <target state="translated">여러 메시지를 동시에 표시</target>
        </trans-unit>
        <trans-unit id="8fcd11662cedbe647c35df6e222817acbf87bac8" translate="yes" xml:space="preserve">
          <source>Do not bootstrap your app on an element with a directive that uses &lt;a href=&quot;../api/ng/service/%24compile#transclusion.html&quot;&gt;transclusion&lt;/a&gt;, such as &lt;a href=&quot;../api/ng/directive/ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/nginclude&quot;&gt;&lt;code&gt;ngInclude&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt;&lt;code&gt;ngView&lt;/code&gt;&lt;/a&gt;. Doing this misplaces the app &lt;a href=&quot;../api/ng/service/%24rootelement&quot;&gt;&lt;code&gt;$rootElement&lt;/code&gt;&lt;/a&gt; and the app's &lt;a href=&quot;../api/auto/service/%24injector&quot;&gt;injector&lt;/a&gt;, causing animations to stop working and making the injector inaccessible from outside the app.</source>
          <target state="translated">사용하는 지시문 요소에서 응용 프로그램을 부트 스트랩하지 마십시오 &lt;a href=&quot;../api/ng/service/%24compile#transclusion.html&quot;&gt;트랜스 클루 전을&lt;/a&gt; 같은, &lt;a href=&quot;../api/ng/directive/ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/nginclude&quot;&gt; &lt;code&gt;ngInclude&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/ngroute/directive/ngview&quot;&gt; &lt;code&gt;ngView&lt;/code&gt; &lt;/a&gt; . 이렇게하면 앱 &lt;a href=&quot;../api/ng/service/%24rootelement&quot;&gt; &lt;code&gt;$rootElement&lt;/code&gt; &lt;/a&gt; 와 앱의 &lt;a href=&quot;../api/auto/service/%24injector&quot;&gt;인젝터가&lt;/a&gt; 잘못 배치되어 애니메이션이 작동을 멈추고 인젝터가 앱 외부에서 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="734e169c6f35eeaf3a86656e7f1c0d72ba2de6cc" translate="yes" xml:space="preserve">
          <source>Do not mix client and server templates</source>
          <target state="translated">클라이언트 및 서버 템플릿을 혼합하지 마십시오</target>
        </trans-unit>
        <trans-unit id="19e892e136c9dc029952e0d0040cde8bbcc0893d" translate="yes" xml:space="preserve">
          <source>Do not run user input through &lt;code&gt;$scope.$eval&lt;/code&gt; (or any of the other expression parsing functions listed above)</source>
          <target state="translated">&lt;code&gt;$scope.$eval&lt;/code&gt; (또는 위에 나열된 다른 표현식 구문 분석 함수)을 통해 사용자 입력을 실행하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="a1222a753c501c7c58fabe9476767ef0ea0a4fda" translate="yes" xml:space="preserve">
          <source>Do not use a directive that uses &lt;a href=&quot;../service/%24compile#transclusion.html&quot;&gt;transclusion&lt;/a&gt; on the same element as &lt;code&gt;ngApp&lt;/code&gt;. This includes directives such as &lt;a href=&quot;ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;nginclude&quot;&gt;&lt;code&gt;ngInclude&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../ngroute/directive/ngview&quot;&gt;&lt;code&gt;ngView&lt;/code&gt;&lt;/a&gt;. Doing this misplaces the app &lt;a href=&quot;../service/%24rootelement&quot;&gt;&lt;code&gt;$rootElement&lt;/code&gt;&lt;/a&gt; and the app's &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;injector&lt;/a&gt;, causing animations to stop working and making the injector inaccessible from outside the app.</source>
          <target state="translated">&lt;code&gt;ngApp&lt;/code&gt; 와 동일한 요소에서 &lt;a href=&quot;../service/%24compile#transclusion.html&quot;&gt;변환&lt;/a&gt; 을 사용하는 지시문을 사용하지 마십시오 . 여기에는 &lt;a href=&quot;ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;nginclude&quot;&gt; &lt;code&gt;ngInclude&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../ngroute/directive/ngview&quot;&gt; &lt;code&gt;ngView&lt;/code&gt; &lt;/a&gt; 와 같은 지시문이 포함됩니다 . 이렇게하면 앱 &lt;a href=&quot;../service/%24rootelement&quot;&gt; &lt;code&gt;$rootElement&lt;/code&gt; &lt;/a&gt; 와 앱의 &lt;a href=&quot;../../auto/service/%24injector&quot;&gt;인젝터가&lt;/a&gt; 잘못 배치되어 애니메이션이 작동을 멈추고 인젝터가 앱 외부에서 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="a6b92442e50d6cf9ef2638015c4dcbb08c6765ea" translate="yes" xml:space="preserve">
          <source>Do not use controllers to:</source>
          <target state="translated">컨트롤러를 사용하여 다음을 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c4e0abe2eab7806b524f5f539063aa767372787f" translate="yes" xml:space="preserve">
          <source>Do not use user input to generate templates dynamically</source>
          <target state="translated">사용자 입력을 사용하여 템플릿을 동적으로 생성하지 마십시오</target>
        </trans-unit>
        <trans-unit id="cd9568f76d3ffc3f4943b3b399abc721db51ae70" translate="yes" xml:space="preserve">
          <source>Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the lack of CSS animations by using the &lt;code&gt;$animateCss&lt;/code&gt; service to trigger our own tweaked-out, CSS-based animations directly from our own JS-based animation code:</source>
          <target state="translated">이것은 CSS와 JS 애니메이션을 함께 사용할 수 없다는 것을 의미합니까? JS 기반 애니메이션의 우선 순위가 항상 높은가요? &lt;code&gt;$animateCss&lt;/code&gt; 서비스를 사용하여 CSS 기반 애니메이션 코드에서 직접 조정 된 CSS 기반 애니메이션을 트리거 하여 CSS 애니메이션 부족을 보완 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13dee9f67e174a94349cf987cddd8a72fc3af4b8" translate="yes" xml:space="preserve">
          <source>Double Compilation</source>
          <target state="translated">이중 컴파일</target>
        </trans-unit>
        <trans-unit id="46cf9c3355e52010c4d12ff1852420f2537d0b53" translate="yes" xml:space="preserve">
          <source>Double Compilation, and how to avoid it</source>
          <target state="translated">이중 컴파일 및이를 피하는 방법</target>
        </trans-unit>
        <trans-unit id="c28ddab1c668724f14783f5d982dad57dfddbb6f" translate="yes" xml:space="preserve">
          <source>Double compilation occurs when an already compiled part of the DOM gets compiled again. This is an undesired effect and can lead to misbehaving directives, performance issues, and memory leaks. A common scenario where this happens is a directive that calls &lt;code&gt;$compile&lt;/code&gt; in a directive link function on the directive element. In the following &lt;strong&gt;faulty example&lt;/strong&gt;, a directive adds a mouseover behavior to a button with &lt;code&gt;ngClick&lt;/code&gt; on it:</source>
          <target state="translated">DOM의 이미 컴파일 된 부분이 다시 컴파일 될 때 이중 컴파일이 발생합니다. 이것은 바람직하지 않은 효과이며 지시문, 성능 문제 및 메모리 누수의 오작동을 유발할 수 있습니다. 이러한 상황이 발생하는 일반적인 시나리오 는 지시문 요소의 지시문 링크 함수에서 &lt;code&gt;$compile&lt;/code&gt; 을 호출하는 지시문입니다 . 다음 &lt;strong&gt;잘못된 예제&lt;/strong&gt; 에서 지시문은 &lt;code&gt;ngClick&lt;/code&gt; 이있는 버튼에 마우스 오버 동작을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="2fe3ba6f7aec148d2830c036bfffa7e3396f913f" translate="yes" xml:space="preserve">
          <source>Double compilation occurs when an already compiled part of the DOM gets compiled again. This is an undesired effect and can lead to misbehaving directives, performance issues, and memory leaks. Refer to the Compiler Guide &lt;a href=&quot;../../../guide/compiler#double-compilation-and-how-to-avoid-it.html&quot;&gt;section on double compilation&lt;/a&gt; for an in-depth explanation and ways to avoid it.</source>
          <target state="translated">DOM의 이미 컴파일 된 부분이 다시 컴파일 될 때 이중 컴파일이 발생합니다. 이것은 바람직하지 않은 효과이며 지시문, 성능 문제 및 메모리 누수의 오작동을 유발할 수 있습니다. 자세한 설명과이를 피하는 방법 &lt;a href=&quot;../../../guide/compiler#double-compilation-and-how-to-avoid-it.html&quot;&gt;은 이중 컴파일에&lt;/a&gt; 대한 컴파일러 안내서 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b56ef3a0351d8185f34ae1615da191674f9fba40" translate="yes" xml:space="preserve">
          <source>Double compilation should therefore be avoided. In the above example, only the new element should be compiled:</source>
          <target state="translated">따라서 이중 컴파일은 피해야합니다. 위의 예에서는 새 요소 만 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="6591272ff03229f7f47a34cd608993dac9711a87" translate="yes" xml:space="preserve">
          <source>Due to the differences in change-detection, you may get many more calls to &lt;code&gt;$doCheck&lt;/code&gt; in AngularJS than you would to &lt;code&gt;ngDoCheck&lt;/code&gt; in Angular.</source>
          <target state="translated">변경 감지의 차이로 인해 Angular 에서 &lt;code&gt;ngDoCheck&lt;/code&gt; 하는 것보다 AngularJS에서 &lt;code&gt;$doCheck&lt;/code&gt; 에 대한 더 많은 호출을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="690ee2fd00601f8dae9435fe866cd934f63d5b6f" translate="yes" xml:space="preserve">
          <source>During a property comparison, properties of &lt;code&gt;function&lt;/code&gt; type and properties with names that begin with &lt;code&gt;$&lt;/code&gt; are ignored.</source>
          <target state="translated">속성 비교 중에 &lt;code&gt;function&lt;/code&gt; 유형의 속성과 이름이 &lt;code&gt;$&lt;/code&gt; 로 시작하는 속성 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d17774f2703ffb3b3466892ed055619a54364b52" translate="yes" xml:space="preserve">
          <source>During application bootstrap, before AngularJS goes off creating all services, it configures and instantiates all providers. We call this the configuration phase of the application life-cycle. During this phase, services aren't accessible because they haven't been created yet.</source>
          <target state="translated">응용 프로그램 부트 스트랩 동안 AngularJS가 모든 서비스를 만들기 전에 모든 공급자를 구성하고 인스턴스화합니다. 이것을 응용 프로그램 수명주기의 구성 단계라고합니다. 이 단계에서는 아직 생성되지 않았기 때문에 서비스에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="291ab189948f99ffa87d61aff0be223080b9841a" translate="yes" xml:space="preserve">
          <source>During template linking, directives register &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;watches&lt;/a&gt; on the scope. These watches will be used to propagate model values to the DOM.</source>
          <target state="translated">템플릿 연결 중에 지시어 는 범위에 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24watch.html&quot;&gt;시계&lt;/a&gt; 를 등록 합니다. 이 시계는 모델 값을 DOM에 전파하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45531da9cbed4e6e4ee65fe4cf35c23297ce9dea" translate="yes" xml:space="preserve">
          <source>During testing this implementation is swapped with &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;mock $httpBackend&lt;/a&gt; which can be trained with responses.</source>
          <target state="translated">테스트하는 동안이 구현은 응답으로 훈련 될 수있는 &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;모의 $ httpBackend로&lt;/a&gt; 교체됩니다 .</target>
        </trans-unit>
        <trans-unit id="84cba5a8d27805fd2532e7744606781e2d24ef87" translate="yes" xml:space="preserve">
          <source>During the compilation phase, the &lt;a href=&quot;compiler&quot;&gt;compiler&lt;/a&gt; matches &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;directives&lt;/a&gt; against the DOM template. The directives usually fall into one of two categories:</source>
          <target state="translated">컴파일 단계에서 &lt;a href=&quot;compiler&quot;&gt;컴파일러&lt;/a&gt; 는 &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시문&lt;/a&gt; 을 DOM 템플리트 와 일치 시킵니다. 지시문은 일반적으로 두 가지 범주 중 하나에 속합니다.</target>
        </trans-unit>
        <trans-unit id="552c6c3ebea05d341417ee364fae8ea2af019067" translate="yes" xml:space="preserve">
          <source>During the compilation phase:</source>
          <target state="translated">컴파일 단계에서 :</target>
        </trans-unit>
        <trans-unit id="a493125bd9c880c4ca97eb29a7017d3a9e3e64ce" translate="yes" xml:space="preserve">
          <source>During the compilation process the &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;compiler&lt;/a&gt; uses the &lt;a href=&quot;../api/ng/service/%24interpolate&quot;&gt;$interpolate&lt;/a&gt; service to see if text nodes and element attributes contain interpolation markup with embedded expressions.</source>
          <target state="translated">컴파일 과정에서 &lt;a href=&quot;../api/ng/service/%24compile&quot;&gt;컴파일러&lt;/a&gt; 는 &lt;a href=&quot;../api/ng/service/%24interpolate&quot;&gt;$ interpolate&lt;/a&gt; 서비스를 사용하여 텍스트 노드 및 요소 속성에 포함 된 표현식이 포함 된 보간 마크 업이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6439c34c3206ba861da0f9bf5fc84e0b928b58c7" translate="yes" xml:space="preserve">
          <source>During the config: &lt;a href=&quot;../api/ng/provider/%24animateprovider#classNameFilter.html&quot;&gt;$animateProvider.classNameFilter()&lt;/a&gt;</source>
          <target state="translated">구성하는 동안 : &lt;a href=&quot;../api/ng/provider/%24animateprovider#classNameFilter.html&quot;&gt;$ animateProvider.classNameFilter ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60166faf8b960cb144a5a5dfe16f5efce800297f" translate="yes" xml:space="preserve">
          <source>During the config: &lt;a href=&quot;../api/ng/provider/%24animateprovider#customFilter.html&quot;&gt;$animateProvider.customFilter()&lt;/a&gt;</source>
          <target state="translated">구성하는 동안 : &lt;a href=&quot;../api/ng/provider/%24animateprovider#customFilter.html&quot;&gt;$ animateProvider.customFilter ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88d16957e61a3abc0b2789679717c815f5765897" translate="yes" xml:space="preserve">
          <source>During the runtime phase:</source>
          <target state="translated">런타임 단계에서 :</target>
        </trans-unit>
        <trans-unit id="ac637ea8f1b2151f1dfdc40a4954ea8a48a7d7d3" translate="yes" xml:space="preserve">
          <source>During unit testing, we want our unit tests to run quickly and have no external dependencies so we don&amp;rsquo;t want to send &lt;a href=&quot;https://developer.mozilla.org/en/xmlhttprequest&quot;&gt;XHR&lt;/a&gt; or &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; requests to a real server. All we really need is to verify whether a certain request has been sent or not, or alternatively just let the application make requests, respond with pre-trained responses and assert that the end result is what we expect it to be.</source>
          <target state="translated">단위 테스트 중에는 단위 테스트가 빠르게 실행되고 외부 종속성이 없으므로 &lt;a href=&quot;https://developer.mozilla.org/en/xmlhttprequest&quot;&gt;XHR&lt;/a&gt; 또는 &lt;a href=&quot;http://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; 요청을 실제 서버 로 보내지 않습니다 . 실제로 필요한 것은 특정 요청이 전송되었는지 여부를 확인하거나 응용 프로그램이 요청을하고 미리 훈련 된 응답으로 응답하고 최종 결과가 예상 한 것이라고 주장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="871ea4da49e00d79d13d56d3eec2853372598b41" translate="yes" xml:space="preserve">
          <source>Dynamic Messaging</source>
          <target state="translated">동적 메시징</target>
        </trans-unit>
        <trans-unit id="bac036281464cca8457fab7f160594b9b956bffb" translate="yes" xml:space="preserve">
          <source>Dynamic responses</source>
          <target state="translated">동적 반응</target>
        </trans-unit>
        <trans-unit id="ddfdb597e007e1dc4eda14345e693ee956382336" translate="yes" xml:space="preserve">
          <source>Dynamically changing an interpolated value</source>
          <target state="translated">보간 된 값을 동적으로 변경</target>
        </trans-unit>
        <trans-unit id="7ffa068184121937557c12ca97fdaa8b198c8c8e" translate="yes" xml:space="preserve">
          <source>E.g. the markup &lt;code&gt;{{ 12 | currency }}&lt;/code&gt; formats the number 12 as a currency using the &lt;a href=&quot;../api/ng/filter/currency&quot;&gt;&lt;code&gt;currency&lt;/code&gt;&lt;/a&gt; filter. The resulting value is &lt;code&gt;$12.00&lt;/code&gt;.</source>
          <target state="translated">예 : 마크 업 &lt;code&gt;{{ 12 | currency }}&lt;/code&gt; 는 &lt;a href=&quot;../api/ng/filter/currency&quot;&gt; &lt;code&gt;currency&lt;/code&gt; &lt;/a&gt; 필터를 사용하여 숫자 12를 통화 형식으로 지정합니다 . 결과 값은 &lt;code&gt;$12.00&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="706f3f2c466550baf6f8cff74045985c0b276d2f" translate="yes" xml:space="preserve">
          <source>E.g. the markup &lt;code&gt;{{ 1234 | number:2 }}&lt;/code&gt; formats the number 1234 with 2 decimal points using the &lt;a href=&quot;../api/ng/filter/number&quot;&gt;&lt;code&gt;number&lt;/code&gt;&lt;/a&gt; filter. The resulting value is &lt;code&gt;1,234.00&lt;/code&gt;.</source>
          <target state="translated">예 : 마크 업 &lt;code&gt;{{ 1234 | number:2 }}&lt;/code&gt; 는 &lt;a href=&quot;../api/ng/filter/number&quot;&gt; &lt;code&gt;number&lt;/code&gt; &lt;/a&gt; 필터를 사용하여 숫자 1234를 소수점 2 개로 형식화합니다 . 결과 값은 &lt;code&gt;1,234.00&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a2a94632ee79f879ff70c670fc140a79667aac46" translate="yes" xml:space="preserve">
          <source>E2E Testing</source>
          <target state="translated">E2E 테스트</target>
        </trans-unit>
        <trans-unit id="46cb077541331f9a16fef73d47f33279ef781780" translate="yes" xml:space="preserve">
          <source>ES6, Webpack, and JSPM Starter Project</source>
          <target state="translated">ES6, 웹팩 및 JSPM 스타터 프로젝트</target>
        </trans-unit>
        <trans-unit id="ba63fe9fd9974e102c02ef7d910d4b8dddc1fa17" translate="yes" xml:space="preserve">
          <source>ES6/Typescript Best Practices</source>
          <target state="translated">ES6 / Typescript 모범 사례</target>
        </trans-unit>
        <trans-unit id="648a21d0cd9f5c2567ffd87e39c8a17cf279fb77" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../directive/form&quot;&gt;form&lt;/a&gt; directive creates an instance of &lt;code&gt;FormController&lt;/code&gt;.</source>
          <target state="translated">각 &lt;a href=&quot;../directive/form&quot;&gt;양식&lt;/a&gt; 지시문은 &lt;code&gt;FormController&lt;/code&gt; 의 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d1c0d67675138588c0dc00ee3cda517b7f653e50" translate="yes" xml:space="preserve">
          <source>Each AngularJS application has exactly one &lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;root scope&lt;/a&gt;, but may have any number of child scopes.</source>
          <target state="translated">각 AngularJS 애플리케이션에는 정확히 하나의 &lt;a href=&quot;../api/ng/service/%24rootscope&quot;&gt;루트 범위&lt;/a&gt; 가 있지만 여러 하위 범위가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829715aa8f2829bcf5c7f7ab2b1d5e696bd672e1" translate="yes" xml:space="preserve">
          <source>Each directive's &lt;code&gt;compile&lt;/code&gt; functions are executed. Each &lt;code&gt;compile&lt;/code&gt; function has a chance to modify the DOM. Each &lt;code&gt;compile&lt;/code&gt; function returns a &lt;code&gt;link&lt;/code&gt; function. These functions are composed into a &quot;combined&quot; link function, which invokes each directive's returned &lt;code&gt;link&lt;/code&gt; function.</source>
          <target state="translated">각 지시문의 &lt;code&gt;compile&lt;/code&gt; 기능이 실행됩니다. 각 &lt;code&gt;compile&lt;/code&gt; 함수는 DOM을 수정할 수있는 기회가 있습니다. 각 &lt;code&gt;compile&lt;/code&gt; 함수는 &lt;code&gt;link&lt;/code&gt; 함수를 반환 합니다. 이러한 함수는 &quot;결합 된&quot;링크 함수로 구성되어 각 지시문의 반환 된 &lt;code&gt;link&lt;/code&gt; 함수 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="03ce87fe012858dd28022ce0344110a91c5c56e7" translate="yes" xml:space="preserve">
          <source>Each element in these arrays must be one of the following:</source>
          <target state="translated">이 배열의 각 요소는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0788a57602c88bc63b92f1ea44577c3c1372677f" translate="yes" xml:space="preserve">
          <source>Each function in the &lt;code&gt;$validators&lt;/code&gt; object receives the &lt;code&gt;modelValue&lt;/code&gt; and the &lt;code&gt;viewValue&lt;/code&gt; as parameters. AngularJS will then call &lt;code&gt;$setValidity&lt;/code&gt; internally with the function's return value (&lt;code&gt;true&lt;/code&gt;: valid, &lt;code&gt;false&lt;/code&gt;: invalid). The validation functions are executed every time an input is changed (&lt;code&gt;$setViewValue&lt;/code&gt; is called) or whenever the bound &lt;code&gt;model&lt;/code&gt; changes. Validation happens after successfully running &lt;code&gt;$parsers&lt;/code&gt; and &lt;code&gt;$formatters&lt;/code&gt;, respectively. Failed validators are stored by key in &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller#%24error&quot;&gt;&lt;code&gt;ngModelController.$error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$validators&lt;/code&gt; 객체 의 각 함수 는 &lt;code&gt;modelValue&lt;/code&gt; 및 &lt;code&gt;viewValue&lt;/code&gt; 를 매개 변수로받습니다. 그런 다음 AngularJS는 함수의 반환 값으로 내부적으로 &lt;code&gt;$setValidity&lt;/code&gt; 를 호출 합니다 ( &lt;code&gt;true&lt;/code&gt; : valid, &lt;code&gt;false&lt;/code&gt; : invalid). 유효성 검사 함수는 입력이 변경 될 때마다 ( &lt;code&gt;$setViewValue&lt;/code&gt; 가 호출 될 때마다) 또는 바인딩 된 &lt;code&gt;model&lt;/code&gt; 변경 될 때마다 실행 됩니다. 유효성 검사 는 각각 &lt;code&gt;$parsers&lt;/code&gt; 및 &lt;code&gt;$formatters&lt;/code&gt; 성공적으로 실행 한 후에 발생합니다 . 실패한 유효성 검사기는 &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller#%24error&quot;&gt; &lt;code&gt;ngModelController.$error&lt;/code&gt; &lt;/a&gt; 키로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="12306c46ee9f9ac44368ea23daa3a0afc971061b" translate="yes" xml:space="preserve">
          <source>Each function in the &lt;code&gt;$validators&lt;/code&gt; object receives the &lt;code&gt;modelValue&lt;/code&gt; and the &lt;code&gt;viewValue&lt;/code&gt; as parameters. AngularJS will then call &lt;code&gt;$setValidity&lt;/code&gt; internally with the function's return value (&lt;code&gt;true&lt;/code&gt;: valid, &lt;code&gt;false&lt;/code&gt;: invalid). The validation functions are executed every time an input is changed (&lt;code&gt;$setViewValue&lt;/code&gt; is called) or whenever the bound &lt;code&gt;model&lt;/code&gt; changes. Validation happens after successfully running &lt;code&gt;$parsers&lt;/code&gt; and &lt;code&gt;$formatters&lt;/code&gt;, respectively. Failed validators are stored by key in &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller#%24error.html&quot;&gt;&lt;code&gt;ngModelController.$error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$validators&lt;/code&gt; 개체 의 각 함수 는 &lt;code&gt;modelValue&lt;/code&gt; 및 &lt;code&gt;viewValue&lt;/code&gt; 를 매개 변수로받습니다. 그런 다음 AngularJS는 함수의 반환 값 ( &lt;code&gt;true&lt;/code&gt; : valid, &lt;code&gt;false&lt;/code&gt; : invalid)을 사용하여 내부적으로 &lt;code&gt;$setValidity&lt;/code&gt; 를 호출 합니다 . 유효성 검사 함수는 입력이 변경 될 때마다 ( &lt;code&gt;$setViewValue&lt;/code&gt; 호출 됨) 또는 바인딩 된 &lt;code&gt;model&lt;/code&gt; 변경 될 때마다 실행 됩니다. 유효성 검사 는 각각 &lt;code&gt;$parsers&lt;/code&gt; 및 &lt;code&gt;$formatters&lt;/code&gt; 성공적으로 실행 한 후에 발생합니다 . 실패한 유효성 검사기는 &lt;a href=&quot;../api/ng/type/ngmodel.ngmodelcontroller#%24error.html&quot;&gt; &lt;code&gt;ngModelController.$error&lt;/code&gt; &lt;/a&gt; 에 키로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a059e84dcbee7d4310b371af5bf3f354749be0d" translate="yes" xml:space="preserve">
          <source>Each item in the &lt;strong&gt;RouteConfig&lt;/strong&gt; for a &lt;strong&gt;Routing Component&lt;/strong&gt; is an instance of this type. It can have the following properties:</source>
          <target state="translated">의 각 항목 &lt;strong&gt;RouteConfig&lt;/strong&gt; A의 &lt;strong&gt;라우팅 구성 요소는&lt;/strong&gt; 이러한 유형의 인스턴스입니다. 다음과 같은 속성을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b188f1d17688bd4f986f5bc1d938df3660b4a5" translate="yes" xml:space="preserve">
          <source>Each key value in the parameter object is first bound to url template if present and then any excess keys are appended to the url search query after the &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">매개 변수 객체의 각 키 값은 존재하는 경우 먼저 URL 템플릿에 바인딩 된 다음 &lt;code&gt;?&lt;/code&gt; 키 다음에 초과 키가 URL 검색 쿼리에 추가됩니다 . .</target>
        </trans-unit>
        <trans-unit id="c4db4dc45436f4f1a0c0c82c0e2621975a9bac1c" translate="yes" xml:space="preserve">
          <source>Each module can only be loaded once per injector. Usually an AngularJS app has only one injector and modules are only loaded once. Each test has its own injector and modules are loaded multiple times.</source>
          <target state="translated">각 모듈은 인젝터 당 한 번만로드 할 수 있습니다. 일반적으로 AngularJS 앱에는 인젝터가 하나만 있으며 모듈은 한 번만로드됩니다. 각 테스트에는 자체 인젝터가 있으며 모듈은 여러 번로드됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c6e4ddcbc08750f981caaf013164d265bbf24d" translate="yes" xml:space="preserve">
          <source>Each provide access to a &lt;code&gt;$delegate&lt;/code&gt;, which is the instantiated service/directive/filter, prior to being passed to the service that required it.</source>
          <target state="translated">각각은 필요한 서비스로 전달되기 전에 인스턴스화 된 서비스 / 지시 / 필터 인 &lt;code&gt;$delegate&lt;/code&gt; 대한 액세스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="dda93b9c00ecb491f2d026174b8fa5dbb60e68ea" translate="yes" xml:space="preserve">
          <source>Each recipe belongs to an &lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;AngularJS module&lt;/a&gt;. An AngularJS module is a bag that holds one or more recipes. And since manually keeping track of module dependencies is no fun, a module can contain information about dependencies on other modules as well.</source>
          <target state="translated">각 레시피는 &lt;a href=&quot;../api/ng/type/angular.module&quot;&gt;AngularJS 모듈에&lt;/a&gt; 속합니다 . AngularJS 모듈은 하나 이상의 레시피를 보유하는 백입니다. 또한 모듈 종속성을 수동으로 추적하는 것은 재미 있지 않으므로 모듈에는 다른 모듈에 대한 종속성에 대한 정보도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3ae98a5b0c131a547a93b487b4c98012168788" translate="yes" xml:space="preserve">
          <source>Each version of AngularJS 1 up to, but not including 1.6, contained an expression sandbox, which reduced the surface area of the vulnerability but never removed it. &lt;strong&gt;In AngularJS 1.6 we removed this sandbox as developers kept relying upon it as a security feature even though it was always possible to access arbitrary JavaScript code if one could control the AngularJS templates or expressions of applications.&lt;/strong&gt;</source>
          <target state="translated">1.6 이하의 AngularJS 1의 각 버전에는 표현 샌드 박스가 포함되어 취약점의 표면적을 줄 였지만 결코 제거하지는 않았습니다. &lt;strong&gt;AngularJS 1.6에서는 개발자가 AngularJS 템플릿 또는 응용 프로그램의 표현을 제어 할 수있는 경우 임의의 JavaScript 코드에 항상 액세스 할 수 있었음에도 불구하고 개발자가 보안 기능으로 계속 의존하면서이 샌드 박스를 제거했습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b51b7017f03b60f98505f01afc9017f64fb597b6" translate="yes" xml:space="preserve">
          <source>Each web application you build is composed of objects that collaborate to get stuff done. These objects need to be instantiated and wired together for the app to work. In AngularJS apps most of these objects are instantiated and wired together automatically by the &lt;a href=&quot;../api/auto/service/%24injector&quot;&gt;injector service&lt;/a&gt;.</source>
          <target state="translated">빌드하는 각 웹 응용 프로그램은 작업을 수행하기 위해 공동 작업하는 객체로 구성됩니다. 앱이 작동하려면 이러한 객체를 인스턴스화하고 연결해야합니다. AngularJS 앱에서 이러한 객체의 대부분은 &lt;a href=&quot;../api/auto/service/%24injector&quot;&gt;인젝터 서비스에&lt;/a&gt; 의해 자동으로 인스턴스화되고 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="e08245380fe45ed1dc1a39461e8430df197a0e09" translate="yes" xml:space="preserve">
          <source>Earlier we mentioned that we also have special purpose objects that are different from services. These objects extend the framework as plugins and therefore must implement interfaces specified by AngularJS. These interfaces are Controller, Directive, Filter and Animation.</source>
          <target state="translated">앞에서 우리는 서비스와 다른 특별한 목적의 객체도 가지고 있다고 언급했습니다. 이러한 객체는 프레임 워크를 플러그인으로 확장하므로 AngularJS에서 지정한 인터페이스를 구현해야합니다. 이러한 인터페이스는 컨트롤러, 지시문, 필터 및 애니메이션입니다.</target>
        </trans-unit>
        <trans-unit id="dca48544769c52bf3b58c672f5cd3b5c747bc2f2" translate="yes" xml:space="preserve">
          <source>Effects of DOM Element re-use</source>
          <target state="translated">DOM 요소 재사용의 효과</target>
        </trans-unit>
        <trans-unit id="c199d835c658f8ab6c23a79e307ea446a630dc73" translate="yes" xml:space="preserve">
          <source>Either a wrapped jQuery/jqLite node or a DOMElement</source>
          <target state="translated">랩핑 된 jQuery / jqLite 노드 또는 DOMElement</target>
        </trans-unit>
        <trans-unit id="c5dbec72523ae614966440682a91c6aefb466e1e" translate="yes" xml:space="preserve">
          <source>Element or HTML string to compile into a template function.</source>
          <target state="translated">템플릿 함수로 컴파일 할 요소 또는 HTML 문자열</target>
        </trans-unit>
        <trans-unit id="9cbfd00aa5e38787a6022e42110687cd2450a209" translate="yes" xml:space="preserve">
          <source>Else compare the types themselves alphabetically.</source>
          <target state="translated">그렇지 않으면 유형 자체를 알파벳순으로 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="92f004dc1ae3f95af43091d25f176aad7eb1a397" translate="yes" xml:space="preserve">
          <source>Else if one of the values is null, consider it &quot;greater than&quot; the other.</source>
          <target state="translated">그렇지 않으면 값 중 하나가 널인 경우 다른 값보다 &quot;큰&quot;것으로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="55716b221770b19d94c322e504ec2f031d1a376c" translate="yes" xml:space="preserve">
          <source>Email us at &lt;a href=&quot;mailto:security@angularjs.org&quot;&gt;security@angularjs.org&lt;/a&gt; to report any potential security issues in AngularJS.</source>
          <target state="translated">AngularJS의 잠재적 인 보안 문제를보고하려면 &lt;a href=&quot;mailto:security@angularjs.org&quot;&gt;security@angularjs.org&lt;/a&gt; 로 이메일을 보내주십시오 .</target>
        </trans-unit>
        <trans-unit id="099bc2374fc25e458767acd089b2e0b4bbe06521" translate="yes" xml:space="preserve">
          <source>Embedding interpolation markup inside expressions</source>
          <target state="translated">표현식 내에 보간 마크 업 삽입</target>
        </trans-unit>
        <trans-unit id="b2d9626fab94fe46dbc23e11d5145543e8c891df" translate="yes" xml:space="preserve">
          <source>Emitted every time the ngInclude content is reloaded.</source>
          <target state="translated">ngInclude 컨텐츠를 다시로드 할 때마다 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d69747c18e6a7823e2827479f46edbc548e716c8" translate="yes" xml:space="preserve">
          <source>Emitted every time the ngInclude content is requested.</source>
          <target state="translated">ngInclude 컨텐츠가 요청 될 때마다 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ccb5524240b958659fec098886cb27f13b421044" translate="yes" xml:space="preserve">
          <source>Emitted every time the ngView content is reloaded.</source>
          <target state="translated">ngView 컨텐츠를 다시로드 할 때마다 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5352199744d0f4dd2b1904c169630303a8240bd4" translate="yes" xml:space="preserve">
          <source>Emitted when a template HTTP request yields an erroneous response (status &amp;lt; 200 || status &amp;gt; 299)</source>
          <target state="translated">템플리트 HTTP 요청이 잘못된 응답을 생성 할 때 발생합니다 (상태 &amp;lt;200 || status&amp;gt; 299).</target>
        </trans-unit>
        <trans-unit id="faf2ad99147d30fa634f5fda5836e1dedfa19477" translate="yes" xml:space="preserve">
          <source>Enable animations outside of the application DOM tree: &lt;a href=&quot;../api/ng/service/%24animate#pin.html&quot;&gt;$animate.pin()&lt;/a&gt;</source>
          <target state="translated">응용 프로그램 DOM 트리 외부에서 애니메이션을 활성화합니다 : &lt;a href=&quot;../api/ng/service/%24animate#pin.html&quot;&gt;$ animate.pin ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a2ab88d7ccb6db7d12a00ccd002d5025b4173f0a" translate="yes" xml:space="preserve">
          <source>Enable or disable SVG support in the sanitizer.</source>
          <target state="translated">살균기에서 SVG 지원을 활성화 또는 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f1d9379845b51d7e57e166ae34919d84964f1127" translate="yes" xml:space="preserve">
          <source>Enables a subset of svg to be supported by the sanitizer.</source>
          <target state="translated">소독제에서 svg의 하위 집합을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="143c725b84ea6f36aaaba38361a8a7f2268adbf9" translate="yes" xml:space="preserve">
          <source>Enables binding AngularJS expressions to onsubmit events.</source>
          <target state="translated">이벤트를 제출할 때 AngularJS 표현식을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c80853334b84e1e011526ce6f6d2efcbb632d3b2" translate="yes" xml:space="preserve">
          <source>Enables/disables SCE and returns the current value.</source>
          <target state="translated">SCE를 활성화 / 비활성화하고 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1bfefb111e5dac345b0aa3b3c4a4f406e1870b9d" translate="yes" xml:space="preserve">
          <source>Enables/disables various ARIA attributes</source>
          <target state="translated">다양한 ARIA 속성을 활성화 / 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="7abd6ccf643ae77e58fc651912d7d14afe3ed6be" translate="yes" xml:space="preserve">
          <source>End-to-end tests can use modules to override configuration.</source>
          <target state="translated">엔드 투 엔드 테스트는 모듈을 사용하여 구성을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe10676ae39073acdfb80a439f4190fce12dba21" translate="yes" xml:space="preserve">
          <source>Enter a name in the Live Preview text box; the greeting below the text box changes instantly.</source>
          <target state="translated">라이브 미리보기 텍스트 상자에 이름을 입력하십시오. 텍스트 상자 아래의 인사말이 즉시 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="205fcd69afe3a8ebda34fa883e6cd9e9b086948b" translate="yes" xml:space="preserve">
          <source>Enter the AngularJS execution context by calling &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;&lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$apply&lt;/a&gt;&lt;code&gt;(stimulusFn)&lt;/code&gt;, where &lt;code&gt;stimulusFn&lt;/code&gt; is the work you wish to do in the AngularJS execution context.</source>
          <target state="translated">&lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; 를 호출하여 AngularJS 실행 컨텍스트를 입력하십시오 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;$ apply &lt;/a&gt; &lt;code&gt;(stimulusFn)&lt;/code&gt; , 여기서 &lt;code&gt;stimulusFn&lt;/code&gt; 은 AngularJS 실행 컨텍스트에서 수행하려는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a5a37a82bd01c55087378b21c459ede66319d8f7" translate="yes" xml:space="preserve">
          <source>Error Reference</source>
          <target state="translated">오류 참조</target>
        </trans-unit>
        <trans-unit id="a25c35bd8f4f9cad8579a43221ea776b2a563e82" translate="yes" xml:space="preserve">
          <source>Escaped Interpolation</source>
          <target state="translated">탈출 보간</target>
        </trans-unit>
        <trans-unit id="218d2e528de2ed5dec55ef5059999f6d6c7e1a86" translate="yes" xml:space="preserve">
          <source>Escaped interpolation markers are only replaced with the actual interpolation markers in rendered output when the $interpolate service processes the text. So, for HTML elements interpolated by &lt;a href=&quot;%24compile&quot;&gt;$compile&lt;/a&gt;, or otherwise interpolated with the &lt;code&gt;mustHaveExpression&lt;/code&gt; parameter set to &lt;code&gt;true&lt;/code&gt;, the interpolated text must contain an unescaped interpolation expression. As such, this is typically useful only when user-data is used in rendering a template from the server, or when otherwise untrusted data is used by a directive.</source>
          <target state="translated">이스케이프 된 보간 마커는 $ interpolate 서비스가 텍스트를 처리 할 때 렌더링 된 출력에서 ​​실제 보간 마커로만 대체됩니다. 따라서 &lt;a href=&quot;%24compile&quot;&gt;$ compile로&lt;/a&gt; 보간되거나 &lt;code&gt;mustHaveExpression&lt;/code&gt; 매개 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 보간 된 HTML 요소의 경우 보간 된 텍스트에는 이스케이프되지 않은 보간 표현식이 포함되어야합니다. 따라서 이는 일반적으로 서버에서 템플릿을 렌더링 할 때 사용자 데이터를 사용하거나 지시문에서 신뢰할 수없는 데이터를 사용하는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4d57d4ba2f3a7f358a90f37c48fff5bd229f3431" translate="yes" xml:space="preserve">
          <source>Escaping / Quoting</source>
          <target state="translated">탈출 / 인용</target>
        </trans-unit>
        <trans-unit id="fea6dd1103565fa6cc8bae9d51b299f77b6e645c" translate="yes" xml:space="preserve">
          <source>Evaluate the &lt;code&gt;greeting&lt;/code&gt;&lt;a href=&quot;expression&quot;&gt;expression&lt;/a&gt; against the scope retrieved above, and assign the result to the text of the enclosing DOM element.</source>
          <target state="translated">위에서 검색된 범위에 대해 &lt;code&gt;greeting&lt;/code&gt; &lt;a href=&quot;expression&quot;&gt;표현식&lt;/a&gt; 을 평가하고 결과를 둘러싸는 DOM 요소의 텍스트에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="cda22f8a7b7689be1d88d76ef009399f12f6bf88" translate="yes" xml:space="preserve">
          <source>Evaluate the given expression when the user changes the input. The expression is evaluated immediately, unlike the JavaScript onchange event which only triggers at the end of a change (usually, when the user leaves the form element or presses the return key).</source>
          <target state="translated">사용자가 입력을 변경할 때 주어진 표현식을 평가하십시오. 변경이 끝날 때만 트리거되는 JavaScript onchange 이벤트와 달리 표현식은 즉시 평가됩니다 (일반적으로 사용자가 양식 요소를 떠나거나 리턴 키를 누를 때).</target>
        </trans-unit>
        <trans-unit id="f056dd1c6d8bd104d6ba75bafcd760d12a08ca72" translate="yes" xml:space="preserve">
          <source>Evaluated as &lt;a href=&quot;../../../guide/expression&quot;&gt;expression&lt;/a&gt;. The expression value should evaluate to an object or an array which is observed on each &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; cycle. Any shallow change within the collection will trigger a call to the &lt;code&gt;listener&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../guide/expression&quot;&gt;expression으로&lt;/a&gt; 평가되었습니다 . 표현식 값은 각 &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ 다이제스트&lt;/a&gt; 주기 에서 관찰되는 객체 또는 배열로 평가되어야 합니다. 컬렉션 내의 얕은 변경은 &lt;code&gt;listener&lt;/code&gt; 대한 호출을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="a86c33fdabaa7b7c9f6110edee9f0ffd2acc28e1" translate="yes" xml:space="preserve">
          <source>Evaluates the expression and inserts the resulting HTML into the element in a secure way. By default, the resulting HTML content will be sanitized using the &lt;a href=&quot;../../ngsanitize/service/%24sanitize&quot;&gt;$sanitize&lt;/a&gt; service. To utilize this functionality, ensure that &lt;code&gt;$sanitize&lt;/code&gt; is available, for example, by including &lt;a href=&quot;../../ngsanitize&quot;&gt;&lt;code&gt;ngSanitize&lt;/code&gt;&lt;/a&gt; in your module's dependencies (not in core AngularJS). In order to use &lt;a href=&quot;../../ngsanitize&quot;&gt;&lt;code&gt;ngSanitize&lt;/code&gt;&lt;/a&gt; in your module's dependencies, you need to include &quot;angular-sanitize.js&quot; in your application.</source>
          <target state="translated">표현식을 평가하고 결과 HTML을 요소에 안전하게 삽입합니다. 기본적으로 결과 HTML 콘텐츠는 &lt;a href=&quot;../../ngsanitize/service/%24sanitize&quot;&gt;$ sanitize&lt;/a&gt; 서비스를 사용하여 삭제 됩니다. 이 기능을 활용하려면 예를 들어 모듈의 종속성 (핵심 AngularJS가 아님)에 &lt;a href=&quot;../../ngsanitize&quot;&gt; &lt;code&gt;ngSanitize&lt;/code&gt; &lt;/a&gt; 를 포함 시켜 &lt;code&gt;$sanitize&lt;/code&gt; 를 사용할 수 있는지 확인 하십시오. 모듈의 종속성에서 &lt;a href=&quot;../../ngsanitize&quot;&gt; &lt;code&gt;ngSanitize&lt;/code&gt; &lt;/a&gt; 를 사용하려면 응용 프로그램에 &quot;angular-sanitize.js&quot;를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="9076a3c6b5f726943b0322ab3cf79864f11e9902" translate="yes" xml:space="preserve">
          <source>Evaluates the expression and inserts the resulting HTML into the element in a secure way. By default, the resulting HTML content will be sanitized using the &lt;a href=&quot;../ngsanitize/service/%24sanitize&quot;&gt;$sanitize&lt;/a&gt; service. To utilize this functionality, ensure that &lt;code&gt;$sanitize&lt;/code&gt; is available, for example, by including &lt;a href=&quot;../ngsanitize&quot;&gt;&lt;code&gt;ngSanitize&lt;/code&gt;&lt;/a&gt; in your module's dependencies (not in core AngularJS). In order to use &lt;a href=&quot;../ngsanitize&quot;&gt;&lt;code&gt;ngSanitize&lt;/code&gt;&lt;/a&gt; in your module's dependencies, you need to include &quot;angular-sanitize.js&quot; in your application.</source>
          <target state="translated">표현식을 평가하고 결과 HTML을 요소에 안전하게 삽입합니다. 기본적으로 결과 HTML 콘텐츠는 &lt;a href=&quot;../ngsanitize/service/%24sanitize&quot;&gt;$ sanitize&lt;/a&gt; 서비스를 사용하여 삭제 됩니다. 이 기능을 활용하려면 예를 들어 모듈의 종속성 (핵심 AngularJS가 아님)에 &lt;a href=&quot;../ngsanitize&quot;&gt; &lt;code&gt;ngSanitize&lt;/code&gt; &lt;/a&gt; 를 포함 시켜 &lt;code&gt;$sanitize&lt;/code&gt; 를 사용할 수 있는지 확인 하십시오. 모듈의 종속성에서 &lt;a href=&quot;../ngsanitize&quot;&gt; &lt;code&gt;ngSanitize&lt;/code&gt; &lt;/a&gt; 를 사용하려면 응용 프로그램에 &quot;angular-sanitize.js&quot;를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="4fae0324b81717cfd0179935deb08738f4958c28" translate="yes" xml:space="preserve">
          <source>Event name to broadcast.</source>
          <target state="translated">브로드 캐스트 할 이벤트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9ae944309054d536d760fa0eef00f071c6363b43" translate="yes" xml:space="preserve">
          <source>Event name to emit.</source>
          <target state="translated">내보낼 이벤트 이름.</target>
        </trans-unit>
        <trans-unit id="9a3b19e98675ab2f955bd6ef73c0dffd2dc79c70" translate="yes" xml:space="preserve">
          <source>Event name to listen on.</source>
          <target state="translated">청취 할 이벤트 이름.</target>
        </trans-unit>
        <trans-unit id="efd8912106134f28159a082b13ebc510cdb36ce0" translate="yes" xml:space="preserve">
          <source>Event object (see &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이벤트 객체 ( &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="5256cf2d05f2a2afff96813dfafbe9056fe17f54" translate="yes" xml:space="preserve">
          <source>Event object, see &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt;&lt;code&gt;$rootScope.Scope&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이벤트 객체, &lt;a href=&quot;%24rootscope.scope#%24on.html&quot;&gt; &lt;code&gt;$rootScope.Scope&lt;/code&gt; &lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="89991e609ea2e58df8701321c81f1c2b67ca16f0" translate="yes" xml:space="preserve">
          <source>Event that triggered the update.</source>
          <target state="translated">업데이트를 트리거 한 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="dc6ee5b710b84a06b1994d13c09750db60be49d9" translate="yes" xml:space="preserve">
          <source>Every application has a single root &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt;. All other scopes are descendant scopes of the root scope. Scopes provide separation between the model and the view, via a mechanism for watching the model for changes. They also provide event emission/broadcast and subscription facility. See the &lt;a href=&quot;../../../guide/scope&quot;&gt;developer guide on scopes&lt;/a&gt;.</source>
          <target state="translated">모든 응용 프로그램에는 단일 루트 &lt;a href=&quot;../type/%24rootscope.scope&quot;&gt;범위가&lt;/a&gt; 있습니다. 다른 모든 범위는 루트 범위의 하위 범위입니다. 범위는 모델의 변경 사항을 관찰하는 메커니즘을 통해 모델과 뷰를 분리합니다. 또한 이벤트 배출 / 방송 및 가입 시설을 제공합니다. &lt;a href=&quot;../../../guide/scope&quot;&gt;범위에&lt;/a&gt; 대한 개발자 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6fed10186b9a7e4a176e17c80c83b6d2a93e97a" translate="yes" xml:space="preserve">
          <source>Every application has a single root &lt;a href=&quot;type/%24rootscope.scope&quot;&gt;scope&lt;/a&gt;. All other scopes are descendant scopes of the root scope. Scopes provide separation between the model and the view, via a mechanism for watching the model for changes. They also provide event emission/broadcast and subscription facility. See the &lt;a href=&quot;../../guide/scope&quot;&gt;developer guide on scopes&lt;/a&gt;.</source>
          <target state="translated">모든 응용 프로그램에는 단일 루트 &lt;a href=&quot;type/%24rootscope.scope&quot;&gt;범위가&lt;/a&gt; 있습니다. 다른 모든 범위는 루트 범위의 하위 범위입니다. 범위는 모델의 변경 사항을 관찰하는 메커니즘을 통해 모델과 뷰를 분리합니다. 또한 이벤트 배출 / 방송 및 가입 시설을 제공합니다. &lt;a href=&quot;../../guide/scope&quot;&gt;범위에&lt;/a&gt; 대한 개발자 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8932161648474502d4579225b7a5010ba4feeb3a" translate="yes" xml:space="preserve">
          <source>Everything you need to build a CRUD app in a cohesive set: Data-binding, basic templating directives, form validation, routing, deep-linking, reusable components and dependency injection.</source>
          <target state="translated">데이터 바인딩, 기본 템플릿 지시문, 양식 유효성 검사, 라우팅, 딥 링크, 재사용 가능한 구성 요소 및 종속성 주입과 같은 응집력있는 세트로 CRUD 앱을 빌드하는 데 필요한 모든 것.</target>
        </trans-unit>
        <trans-unit id="9eed938865a4ca53d208e8ce6cf848543e153677" translate="yes" xml:space="preserve">
          <source>Exact matches always win over keyword matches. Therefore, if you define both &lt;code&gt;=0&lt;/code&gt; and &lt;code&gt;zero&lt;/code&gt;, when the value of the expression is zero, the &lt;code&gt;=0&lt;/code&gt; message is the one that will be selected. (The duplicate keyword categories are helpful when used with the optional &lt;code&gt;offset&lt;/code&gt; syntax described later.)</source>
          <target state="translated">완전 검색은 항상 키워드 검색보다 우선합니다. 따라서 &lt;code&gt;=0&lt;/code&gt; 과 &lt;code&gt;zero&lt;/code&gt; 모두 정의 하면 표현식 값이 0 일 때 &lt;code&gt;=0&lt;/code&gt; 메시지가 선택됩니다. 중복 키워드 카테고리는 나중에 설명 할 선택적 &lt;code&gt;offset&lt;/code&gt; 구문 과 함께 사용할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="1b2e441413acb202181b009a7cb2e30e8082e0bf" translate="yes" xml:space="preserve">
          <source>Exact matches are written as the equal sign followed by the exact value. &lt;code&gt;=0&lt;/code&gt;, &lt;code&gt;=1&lt;/code&gt;, &lt;code&gt;=2&lt;/code&gt; and &lt;code&gt;=123&lt;/code&gt; are all examples of exact matches. Note that there should be no space between the equal sign and the numeric value.</source>
          <target state="translated">정확한 일치는 등호로 표시되고 정확한 값이 뒤에옵니다. &lt;code&gt;=0&lt;/code&gt; , &lt;code&gt;=1&lt;/code&gt; , &lt;code&gt;=2&lt;/code&gt; 및 &lt;code&gt;=123&lt;/code&gt; 은 모두 정확히 일치하는 예입니다. 등호와 숫자 값 사이에는 공백이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="17aeb04f751fae1ae3f4ad0b2a7c8e59cbb96c5e" translate="yes" xml:space="preserve">
          <source>Example Applications</source>
          <target state="translated">응용 프로그램 예</target>
        </trans-unit>
        <trans-unit id="7c784376e50e16848980dbe227261dcf8fd3cd3c" translate="yes" xml:space="preserve">
          <source>Example configuration</source>
          <target state="translated">구성 예</target>
        </trans-unit>
        <trans-unit id="916ba94adedad329829de9e3198135460b08ea09" translate="yes" xml:space="preserve">
          <source>Example of a component tree</source>
          <target state="translated">컴포넌트 트리의 예</target>
        </trans-unit>
        <trans-unit id="1ee0a88badf0098cd9392d2a3a772e37baa2fda5" translate="yes" xml:space="preserve">
          <source>Example of what a typical jasmine tests looks like with the inject method.</source>
          <target state="translated">일반적인 재스민 테스트의 예는 주입 방법입니다.</target>
        </trans-unit>
        <trans-unit id="07f064f0c6b85d5dffb3101177b89f9992c1c9c7" translate="yes" xml:space="preserve">
          <source>Example test:</source>
          <target state="translated">테스트 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="62dfa7f10882e77a87092f507d379f2402d87987" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;&amp;lt;a href=&quot;/ext/link?a=b&quot; target=&quot;_self&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;&amp;lt;a href=&quot;/ext/link?a=b&quot; target=&quot;_self&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c32374b44f69dd61e35af260b06e3345095cb0e9" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;&amp;lt;a href=&quot;/not-my-base/link&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;&amp;lt;a href=&quot;/not-my-base/link&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5706b247d2f0a121689f2b656388525706d03e11" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;&amp;lt;a href=&quot;http://angularjs.org/&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;&amp;lt;a href=&quot;http://angularjs.org/&quot;&amp;gt;link&amp;lt;/a&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="7bb6af775c57b33034454a0b76f9d211912e7f56" translate="yes" xml:space="preserve">
          <source>Exception associated with the error.</source>
          <target state="translated">오류와 관련된 예외입니다.</target>
        </trans-unit>
        <trans-unit id="3c931b480d9d9bfc8842e1d02f1f24126be988bc" translate="yes" xml:space="preserve">
          <source>Execute this function after injector creation. Useful for application initialization.</source>
          <target state="translated">인젝터 생성 후이 기능을 실행하십시오. 응용 프로그램 초기화에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="086045d75cb70d0de25ecacb2e252ee609998080" translate="yes" xml:space="preserve">
          <source>Execute this function on module load. Useful for service configuration.</source>
          <target state="translated">모듈로드시이 기능을 실행하십시오. 서비스 구성에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="60db8af3d71e63425912639e5639bd857a345c69" translate="yes" xml:space="preserve">
          <source>Executed after the child elements are linked.</source>
          <target state="translated">자식 요소가 연결된 후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8e9afcb55d879e3172b4ff3edb0f541f0a203d" translate="yes" xml:space="preserve">
          <source>Executed before the child elements are linked. Not safe to do DOM transformation since the compiler linking function will fail to locate the correct elements for linking.</source>
          <target state="translated">자식 요소가 연결되기 전에 실행됩니다. 컴파일러 링크 함수가 링크를위한 올바른 요소를 찾지 못하므로 DOM 변환을 수행하는 것이 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a474756a35892f6f1337f53303e90f0d73ff2f19" translate="yes" xml:space="preserve">
          <source>Executes the &lt;code&gt;expression&lt;/code&gt; on the current scope and returns the result. Any exceptions in the expression are propagated (uncaught). This is useful when evaluating AngularJS expressions.</source>
          <target state="translated">현재 범위 에서 &lt;code&gt;expression&lt;/code&gt; 을 실행하고 결과를 반환합니다. 식의 모든 예외가 전파됩니다 (포착되지 않음). AngularJS 표현식을 평가할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4d7dabbbb9314a685e95e955e06bc8dd0125cef5" translate="yes" xml:space="preserve">
          <source>Executes the expression on the current scope at a later point in time.</source>
          <target state="translated">나중에 현재 범위에서 식을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9df4399b6f3ff9926ed5500724ef427c968e367d" translate="yes" xml:space="preserve">
          <source>Exposes the current URL in the browser address bar, so you can</source>
          <target state="translated">브라우저 주소 표시 줄에 현재 URL을 노출하므로</target>
        </trans-unit>
        <trans-unit id="628cde53fd14624d568dab4d3637fdef86c20b64" translate="yes" xml:space="preserve">
          <source>Expression evaluation is forgiving to undefined and null. In JavaScript, evaluating &lt;code&gt;a.b.c&lt;/code&gt; throws an exception if &lt;code&gt;a&lt;/code&gt; is not an object. While this makes sense for a general purpose language, the expression evaluations are primarily used for data binding, which often look like this:</source>
          <target state="translated">식 평가는 정의되지 않은 null을 허용합니다. JavaScript에서 &lt;code&gt;a&lt;/code&gt; 가 객체가 아닌 경우 &lt;code&gt;a.b.c&lt;/code&gt; 평가 하면 예외가 발생 합니다. 이는 범용 언어에 적합하지만 식 평가는 주로 다음과 같은 데이터 바인딩에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0accf77dcec253c18fdfdc78fc6ec09ea004edfb" translate="yes" xml:space="preserve">
          <source>Expression that is evaluated on each &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$digest&lt;/a&gt; cycle. A change in the return value triggers a call to the &lt;code&gt;listener&lt;/code&gt;.</source>
          <target state="translated">각 &lt;a href=&quot;%24rootscope.scope#%24digest.html&quot;&gt;$ 다이제스트&lt;/a&gt; 주기 에서 평가되는 식입니다 . 반환 값이 변경되면 &lt;code&gt;listener&lt;/code&gt; 대한 호출이 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="85ae6863e6e6040f384b4b6dc569f9eb4a64e58c" translate="yes" xml:space="preserve">
          <source>Expression to evaluate when a new partial is loaded.</source>
          <target state="translated">새 부분이로드 될 때 평가할 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="77456688d291ad4f5b4e8d91f041eeb7a5e2de52" translate="yes" xml:space="preserve">
          <source>Expression to evaluate whenever the view updates.</source>
          <target state="translated">뷰가 업데이트 될 때마다 평가할 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="cf78f62fb7990fb89d458935ffb1846f90b586a1" translate="yes" xml:space="preserve">
          <source>Expressions, like the one defined for the &lt;code&gt;ngClick&lt;/code&gt; directive in the example below, are evaluated with respect to the current scope. Therefore, there is no risk of inadvertently coding in a dependency on a global value in such an expression.</source>
          <target state="translated">아래 예에서 &lt;code&gt;ngClick&lt;/code&gt; 지시문에 대해 정의 된 것과 같은 표현식 은 현재 범위와 관련하여 평가됩니다. 따라서 이러한 식에서 전역 값에 대한 종속성으로 실수로 코딩 할 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7baf9e4023c205c51428907b8b5f7094a18f4b9f" translate="yes" xml:space="preserve">
          <source>Extends the built-in list of valid attributes, i.e. attributes that are considered safe and are not stripped off during sanitization.</source>
          <target state="translated">내장 된 유효한 속성 목록, 즉 안전하다고 간주되고 위생 처리 중에 제거되지 않은 속성을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="c966928e5c88a4a9f1ab15febec0c95a059f8e2a" translate="yes" xml:space="preserve">
          <source>Extends the built-in lists of valid HTML/SVG elements, i.e. elements that are considered safe and are not stripped off during sanitization. You can extend the following lists of elements:</source>
          <target state="translated">유효한 HTML / SVG 요소 (예 : 안전하다고 간주되고 위생 처리 중에 제거되지 않은 요소)의 기본 제공 목록을 확장합니다. 다음과 같은 요소 목록을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b14b339ebedbd999c77e9b9f5c7d22127b40d2f" translate="yes" xml:space="preserve">
          <source>Extends the destination object &lt;code&gt;dst&lt;/code&gt; by copying own enumerable properties from the &lt;code&gt;src&lt;/code&gt; object(s) to &lt;code&gt;dst&lt;/code&gt;. You can specify multiple &lt;code&gt;src&lt;/code&gt; objects. If you want to preserve original objects, you can do so by passing an empty object as the target: &lt;code&gt;var object = angular.extend({}, object1, object2)&lt;/code&gt;.</source>
          <target state="translated">대상 객체의 확장 &lt;code&gt;dst&lt;/code&gt; 로부터 자신의 열거 속성을 복사하여 &lt;code&gt;src&lt;/code&gt; 에 객체 (들) &lt;code&gt;dst&lt;/code&gt; . 여러 &lt;code&gt;src&lt;/code&gt; 객체를 지정할 수 있습니다 . 원본 객체를 유지하려면 빈 객체를 대상으로 전달하면됩니다. &lt;code&gt;var object = angular.extend({}, object1, object2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed06ca00010de70fa6e3ffdb999c3f9e5c99bcb6" translate="yes" xml:space="preserve">
          <source>External AngularJS resources</source>
          <target state="translated">외부 AngularJS 리소스</target>
        </trans-unit>
        <trans-unit id="be313f8149a2d30f8327ee70864cf3d4946285a6" translate="yes" xml:space="preserve">
          <source>External Resources</source>
          <target state="translated">외부 자료</target>
        </trans-unit>
        <trans-unit id="39ad1c4756a089e469b5ec792fe50629bec8336f" translate="yes" xml:space="preserve">
          <source>Extract the contents of the element where the directive appears and make it available to the directive. The contents are compiled and provided to the directive as a &lt;strong&gt;transclusion function&lt;/strong&gt;. See the &lt;a href=&quot;%24compile#transclusion.html&quot;&gt;Transclusion&lt;/a&gt; section below.</source>
          <target state="translated">지시문이 나타나는 요소의 내용을 추출하여 지시문에 사용할 수있게하십시오. 내용은 컴파일하고 지시문에 &lt;strong&gt;transclusion 함수&lt;/strong&gt; 로 제공됩니다 . 아래의 &lt;a href=&quot;%24compile#transclusion.html&quot;&gt;Transclusion&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="3156b346a064c1db3b4dfdc8e539af534a00f477" translate="yes" xml:space="preserve">
          <source>Factory Methods</source>
          <target state="translated">공장 방법</target>
        </trans-unit>
        <trans-unit id="ef4319d2d02cf8972a8e4e597c5b497d7352cc3d" translate="yes" xml:space="preserve">
          <source>Factory Recipe</source>
          <target state="translated">공장 레시피</target>
        </trans-unit>
        <trans-unit id="c8e6696140d2e75575a027e3db926b81e7fa86b8" translate="yes" xml:space="preserve">
          <source>Factory and Service are the most commonly used recipes. The only difference between them is that the Service recipe works better for objects of a custom type, while the Factory can produce JavaScript primitives and functions.</source>
          <target state="translated">공장과 서비스는 가장 일반적으로 사용되는 레시피입니다. 이들 간의 유일한 차이점은 서비스 레시피가 사용자 정의 유형의 객체에 더 효과적이며 팩토리는 JavaScript 기본 요소 및 함수를 생성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="028dd1450ba58561838de3f298fd05498d14e273" translate="yes" xml:space="preserve">
          <source>Factory function for creating new instance of an animation.</source>
          <target state="translated">애니메이션의 새 인스턴스를 만들기위한 팩토리 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3ee6fd00a202d032c40a78907b76870f53db49dc" translate="yes" xml:space="preserve">
          <source>Factory function for creating new instance of directives.</source>
          <target state="translated">지시문의 새 인스턴스를 작성하기위한 팩토리 기능.</target>
        </trans-unit>
        <trans-unit id="00b5e72ae89de1590849f21e6c25c0567db4d3f8" translate="yes" xml:space="preserve">
          <source>Factory function for creating new instance of filter.</source>
          <target state="translated">필터의 새 인스턴스를 작성하기위한 팩토리 기능.</target>
        </trans-unit>
        <trans-unit id="cc3812a493330e545d9923589baae8e606e23d7f" translate="yes" xml:space="preserve">
          <source>Factory function used to create XMLHttpRequest objects.</source>
          <target state="translated">XMLHttpRequest 객체를 만드는 데 사용되는 팩토리 함수입니다.</target>
        </trans-unit>
        <trans-unit id="66507c8df90678391bccbb22d7912a1e54a7b768" translate="yes" xml:space="preserve">
          <source>Factory that constructs &lt;a href=&quot;../type/%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; objects and gives access to them.</source>
          <target state="translated">&lt;a href=&quot;../type/%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; 객체 를 생성 하고 액세스 할 수있는 팩토리 .</target>
        </trans-unit>
        <trans-unit id="6a2e0291c6da34749a8ac6df7b544977c583fc48" translate="yes" xml:space="preserve">
          <source>Factory that constructs &lt;a href=&quot;type/%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; objects and gives access to them.</source>
          <target state="translated">&lt;a href=&quot;type/%24cachefactory.cache&quot;&gt;Cache&lt;/a&gt; 객체 를 생성 하고 액세스 할 수있는 팩토리 .</target>
        </trans-unit>
        <trans-unit id="33ad5a927dac4ab275ae4ea2e1b605163a18a5a6" translate="yes" xml:space="preserve">
          <source>Failed interpolated expressions in &lt;code&gt;ng-href&lt;/code&gt; attributes can easily go unnoticed. We can decorate &lt;code&gt;ngHref&lt;/code&gt; to warn us of those conditions.</source>
          <target state="translated">&lt;code&gt;ng-href&lt;/code&gt; 속성 에서 실패한 보간 된 표현식 은 쉽게 눈에 띄지 않을 수 있습니다. 우리는 이러한 조건을 경고하기 위해 &lt;code&gt;ngHref&lt;/code&gt; 를 꾸밀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="022a478813680131790030507e1c1390d5280b3b" translate="yes" xml:space="preserve">
          <source>Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of applications that use the &lt;a href=&quot;../../ng/service/%24http&quot;&gt;$http service&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24http&quot;&gt;$ http 서비스&lt;/a&gt; 를 사용하는 애플리케이션의 엔드 투 엔드 테스트 또는 백엔드리스 개발에 적합한 가짜 HTTP 백엔드 구현 .</target>
        </trans-unit>
        <trans-unit id="576115681ace0f2ae10133aafeaa28843f3bceae" translate="yes" xml:space="preserve">
          <source>Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of applications that use the &lt;a href=&quot;../ng/service/%24http&quot;&gt;$http service&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../ng/service/%24http&quot;&gt;$ http 서비스&lt;/a&gt; 를 사용하는 애플리케이션의 엔드 투 엔드 테스트 또는 백엔드리스 개발에 적합한 가짜 HTTP 백엔드 구현 .</target>
        </trans-unit>
        <trans-unit id="b961aa07954a84612068135eb6d91115ca7b9b12" translate="yes" xml:space="preserve">
          <source>Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of applications that use the &lt;a href=&quot;ng/service/%24http&quot;&gt;$http service&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ng/service/%24http&quot;&gt;$ http 서비스&lt;/a&gt; 를 사용하는 애플리케이션의 엔드 투 엔드 테스트 또는 백엔드리스 개발에 적합한 가짜 HTTP 백엔드 구현 .</target>
        </trans-unit>
        <trans-unit id="2bea11d5d7c3b57fb31b4af107d8e23ff5f192ac" translate="yes" xml:space="preserve">
          <source>Fake HTTP backend implementation suitable for unit testing applications that use the &lt;a href=&quot;../../ng/service/%24http&quot;&gt;$http service&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../ng/service/%24http&quot;&gt;$ http 서비스&lt;/a&gt; 를 사용하는 단위 테스트 애플리케이션에 적합한 가짜 HTTP 백엔드 구현 .</target>
        </trans-unit>
        <trans-unit id="dc58c413dd761b834fc17ee464cbf2c2b1de608e" translate="yes" xml:space="preserve">
          <source>Fake HTTP backend implementation suitable for unit testing applications that use the &lt;a href=&quot;../ng/service/%24http&quot;&gt;$http service&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../ng/service/%24http&quot;&gt;$ http 서비스&lt;/a&gt; 를 사용하는 단위 테스트 애플리케이션에 적합한 가짜 HTTP 백엔드 구현 .</target>
        </trans-unit>
        <trans-unit id="0f28b305a959cfe601c149a9dfacea0ea1a23943" translate="yes" xml:space="preserve">
          <source>Fake HTTP backend implementation suitable for unit testing applications that use the &lt;a href=&quot;ng/service/%24http&quot;&gt;$http service&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ng/service/%24http&quot;&gt;$ http 서비스&lt;/a&gt; 를 사용하는 단위 테스트 애플리케이션에 적합한 가짜 HTTP 백엔드 구현 .</target>
        </trans-unit>
        <trans-unit id="2b6546af28f173c1cc2dec94a741c3e78cbdbce9" translate="yes" xml:space="preserve">
          <source>Fallback for legacy browsers</source>
          <target state="translated">레거시 브라우저의 대체</target>
        </trans-unit>
        <trans-unit id="28db5b5a50621fb409af99bca4f8b752427e4a5c" translate="yes" xml:space="preserve">
          <source>Feature &amp;amp; Bug Tracker</source>
          <target state="translated">기능 및 버그 추적기</target>
        </trans-unit>
        <trans-unit id="37565aacce4ed29b047384a80a69fe751d32457a" translate="yes" xml:space="preserve">
          <source>Features / Recipe type</source>
          <target state="translated">특징 / 레시피 유형</target>
        </trans-unit>
        <trans-unit id="04e7c6a718bae0ab2d3f26efc985083798ff0736" translate="yes" xml:space="preserve">
          <source>Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.</source>
          <target state="translated">동일한 요소에 다른 CSS 클래스뿐만 아니라 전환과 키 프레임을 함께 혼합해도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5c17b605508aeec026cd4b0eba633087d6e85345" translate="yes" xml:space="preserve">
          <source>Feel free to use other structural directives such as ng-if and ng-switch to further control what messages are active and when. Be careful, if you place ng-message on the same element as these structural directives, AngularJS may not be able to determine if a message is active or not. Therefore it is best to place the ng-message on a child element of the structural directive.</source>
          <target state="translated">ng-if 및 ng-switch와 같은 다른 구조적 지시문을 사용하여 활성 메시지와시기를 추가로 제어하십시오. ng-message를 이러한 구조적 지시문과 동일한 요소에 배치하면 AngularJS가 메시지의 활성 여부를 판별하지 못할 수 있습니다. 따라서 구조 지시문의 하위 요소에 ng-message를 배치하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b5c660cb22aa8077dd6a3d7e39e98d1eba6cd24e" translate="yes" xml:space="preserve">
          <source>Fetches, compiles and includes an external HTML fragment.</source>
          <target state="translated">외부 HTML 조각을 가져오고 컴파일하며 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d7decf1aa22b02ae8abf9a96849ee423eee838e4" translate="yes" xml:space="preserve">
          <source>Filter</source>
          <target state="translated">Filter</target>
        </trans-unit>
        <trans-unit id="958cb2148933330b690b4c6657039b40197736c4" translate="yes" xml:space="preserve">
          <source>Filter components in ng</source>
          <target state="translated">ng의 필터 구성 요소</target>
        </trans-unit>
        <trans-unit id="313a96c8d6aa3fcf071911deb5c09c4a10f87451" translate="yes" xml:space="preserve">
          <source>Filter components in ngSanitize</source>
          <target state="translated">ngSanitize에서 필터 구성 요소</target>
        </trans-unit>
        <trans-unit id="0fa8c3951ddd4bf377d1a463b75966dd0eab1fcd" translate="yes" xml:space="preserve">
          <source>Filter name - this must be a valid AngularJS expression identifier</source>
          <target state="translated">필터 이름-유효한 AngularJS 표현식 식별자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="590dca26d3697ff206c7510b4a1ea098ac9d1127" translate="yes" xml:space="preserve">
          <source>Filter output &amp;mdash; Use &lt;a href=&quot;filter&quot;&gt;AngularJS filters&lt;/a&gt; instead.</source>
          <target state="translated">필터 출력 &amp;mdash; 대신 &lt;a href=&quot;filter&quot;&gt;AngularJS 필터&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="699dd39da1d524706c0ac40e80676a65a7ee3d75" translate="yes" xml:space="preserve">
          <source>Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To achieve this a filter definition consists of a factory function which is annotated with dependencies and is responsible for creating a filter function.</source>
          <target state="translated">필터는 입력을 출력으로 변환하는 기능 일뿐입니다. 그러나 필터는 종속성 주입이어야합니다. 이를 위해 필터 정의는 종속성으로 주석이 달린 필터 기능을 생성하는 팩토리 기능으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4f123f5fc885990f073d8e875ec587859f544592" translate="yes" xml:space="preserve">
          <source>Filters are used for formatting data displayed to the user.</source>
          <target state="translated">필터는 사용자에게 표시되는 데이터를 형식화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="529dad0d0ff38bfbf459af3aac0d7bf3af26d043" translate="yes" xml:space="preserve">
          <source>Filters can be applied to expressions in view templates using the following syntax:</source>
          <target state="translated">다음 구문을 사용하여 뷰 템플릿의 표현식에 필터를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c6a437ea6f5579b59312d1da2316b3e28c48c6" translate="yes" xml:space="preserve">
          <source>Filters can be applied to the result of another filter. This is called &quot;chaining&quot; and uses the following syntax:</source>
          <target state="translated">다른 필터의 결과에 필터를 적용 할 수 있습니다. 이것을 &quot;체인&quot;이라고하며 다음 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55335aa85bcb3866e73d19fd2d724a8e66a43b7f" translate="yes" xml:space="preserve">
          <source>Filters format the value of an expression for display to the user. They can be used in view templates, controllers or services. AngularJS comes with a collection of &lt;a href=&quot;../api/ng/filter&quot;&gt;built-in filters&lt;/a&gt;, but it is easy to define your own as well.</source>
          <target state="translated">필터는 사용자에게 표시 할 표현식 값의 형식을 지정합니다. 뷰 템플릿, 컨트롤러 또는 서비스에서 사용할 수 있습니다. AngularJS에는 &lt;a href=&quot;../api/ng/filter&quot;&gt;내장 필터&lt;/a&gt; 모음이 포함되어 있지만 자신 만의 필터를 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="682562f1b49ae6b0a648c1ac925de5d406869964" translate="yes" xml:space="preserve">
          <source>Filters may have arguments. The syntax for this is</source>
          <target state="translated">필터에는 인수가있을 수 있습니다. 이것에 대한 문법은</target>
        </trans-unit>
        <trans-unit id="30c736d62b49c588e1fe0f61717e96ddba143772" translate="yes" xml:space="preserve">
          <source>Filters that are marked as &lt;code&gt;$stateful&lt;/code&gt; are also executed on each $digest. See &lt;a href=&quot;filter#stateful-filters.html&quot;&gt;Stateful filters&lt;/a&gt; for more information. Note that no AngularJS core filters are $stateful.</source>
          <target state="translated">&lt;code&gt;$stateful&lt;/code&gt; 로 표시된 필터 도 각 $ digest에서 실행됩니다. 자세한 내용은 &lt;a href=&quot;filter#stateful-filters.html&quot;&gt;상태 저장 필터&lt;/a&gt; 를 참조하십시오. AngularJS 코어 필터는 $ stateful이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="20d457ead64e7d7328649c07d1839f14e1100651" translate="yes" xml:space="preserve">
          <source>Finally, &lt;strong&gt;the banned resource URL list overrides the trusted resource URL list&lt;/strong&gt; and has the final say.</source>
          <target state="translated">마지막으로, &lt;strong&gt;금지 된 리소스 URL 목록은 신뢰할 수있는 리소스 URL 목록을 무시&lt;/strong&gt; 하고 최종 결정을 내립니다.</target>
        </trans-unit>
        <trans-unit id="66c30abd8d699d84caba4d7a205c80691b2213c7" translate="yes" xml:space="preserve">
          <source>Finally, &lt;strong&gt;the blacklist overrides the whitelist&lt;/strong&gt; and has the final say.</source>
          <target state="translated">마지막으로, &lt;strong&gt;블랙리스트는 화이트리스트를 무시&lt;/strong&gt; 하고 마지막으로 말합니다.</target>
        </trans-unit>
        <trans-unit id="3b6d818fbadda9b37e12f8c2201c1880d5bffeaf" translate="yes" xml:space="preserve">
          <source>Finally, Jasmine provides matchers which let you make assertions:</source>
          <target state="translated">마지막으로 Jasmine은 어설 션을 만들 수있는 매처를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b20b914a19775c7d6d718aa11a19eb2c2aea25c1" translate="yes" xml:space="preserve">
          <source>Finally, in an attempt to simplify things, if a predicate returns an object as the extracted value for an item, &lt;code&gt;orderBy&lt;/code&gt; will try to convert that object to a primitive value, before passing it to the comparator. The following rules govern the conversion:</source>
          <target state="translated">마지막으로, 단순화하기 위해 술어가 항목의 추출 된 값으로 오브젝트를 리턴하면 &lt;code&gt;orderBy&lt;/code&gt; 는 해당 오브젝트를 비교기에 전달하기 전에 해당 오브젝트를 기본 값으로 변환하려고 시도합니다. 다음 규칙이 변환에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="07f4fb01f5ca9fb0f54a74c5ff4ac147e27960d5" translate="yes" xml:space="preserve">
          <source>Finally, load the module in your application by adding it as a dependent module:</source>
          <target state="translated">마지막으로, 모듈을 종속 모듈로 추가하여 애플리케이션에 모듈을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="fdccbab2920c960c12560765b2c4dd6408e9e441" translate="yes" xml:space="preserve">
          <source>Find out more information about each directive by reading the &lt;a href=&quot;../guide/accessibility&quot;&gt;ngAria Developer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../guide/accessibility&quot;&gt;ngAria 개발자 안내서를&lt;/a&gt; 읽고 각 지시문에 대한 자세한 정보를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="ffa9aa79cbd2923d9b3db7b608c702e52b23423e" translate="yes" xml:space="preserve">
          <source>Finds links in text input and turns them into html links. Supports &lt;code&gt;http/https/ftp/sftp/mailto&lt;/code&gt; and plain email address links.</source>
          <target state="translated">텍스트 입력에서 링크를 찾아 HTML 링크로 바꿉니다. 지원 &lt;code&gt;http/https/ftp/sftp/mailto&lt;/code&gt; 및 일반 전자 메일 주소 링크.</target>
        </trans-unit>
        <trans-unit id="b477acda5b9a9fa11e6ec90588718df5fca3ceb9" translate="yes" xml:space="preserve">
          <source>Fire up a screen reader such as VoiceOver or NVDA to check for ARIA support. &lt;a href=&quot;http://webaim.org/articles/screenreader_testing/&quot;&gt;Helpful screen reader tips.&lt;/a&gt;</source>
          <target state="translated">ARIA 지원을 확인하려면 VoiceOver 또는 NVDA와 같은 스크린 리더를 실행하십시오. &lt;a href=&quot;http://webaim.org/articles/screenreader_testing/&quot;&gt;유용한 스크린 리더 팁.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="255e96fff7006defdcfa0768091004d2cadf02d1" translate="yes" xml:space="preserve">
          <source>First create an AngularJS module that will hold the service definition. (The empty array passed as the second parameter means that this module does not depend on any other modules.)</source>
          <target state="translated">먼저 서비스 정의를 보유 할 AngularJS 모듈을 작성하십시오. (두 번째 매개 변수로 전달 된 빈 배열은이 모듈이 다른 모듈에 의존하지 않음을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="d323989dc2db49f0060887626146a6c49dae68b2" translate="yes" xml:space="preserve">
          <source>First let's talk about the &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;API for registering directives&lt;/a&gt;. Much like controllers, directives are registered on modules. To register a directive, you use the &lt;code&gt;module.directive&lt;/code&gt; API. &lt;code&gt;module.directive&lt;/code&gt; takes the &lt;a href=&quot;directive#matching-directives.html&quot;&gt;normalized&lt;/a&gt; directive name followed by a &lt;strong&gt;factory function.&lt;/strong&gt; This factory function should return an object with the different options to tell &lt;code&gt;$compile&lt;/code&gt; how the directive should behave when matched.</source>
          <target state="translated">먼저 &lt;a href=&quot;../api/ng/provider/%24compileprovider#directive.html&quot;&gt;지시문을 등록하기위한 API에&lt;/a&gt; 대해 이야기 해 보자 . 컨트롤러와 마찬가지로 지시문은 모듈에 등록됩니다. 지시문을 등록하려면 &lt;code&gt;module.directive&lt;/code&gt; API 를 사용하십시오 . &lt;code&gt;module.directive&lt;/code&gt; 는 &lt;a href=&quot;directive#matching-directives.html&quot;&gt;표준화 된&lt;/a&gt; 지시문 이름과 &lt;strong&gt;팩토리 함수를 사용합니다. &lt;/strong&gt;이 팩토리 함수는 다른 옵션을 가진 객체를 반환하여 &lt;code&gt;$compile&lt;/code&gt; 에게 지시어가 일치하는 방식 을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="ae0317278d634cdf9897fb0dfd8c37d7e85a15db" translate="yes" xml:space="preserve">
          <source>First, download the file:</source>
          <target state="translated">먼저 파일을 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="4eed0a516dc6dad6334d232395f61bdc71c7a4f5" translate="yes" xml:space="preserve">
          <source>First, get the file:</source>
          <target state="translated">먼저 파일을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="9c40c3b47461dae52bbb2ce1715c3e7c4122872e" translate="yes" xml:space="preserve">
          <source>First, there is a new JavaScript file that contains a &lt;a href=&quot;controller&quot;&gt;controller&lt;/a&gt;. More accurately, the file specifies a constructor function that will be used to create the actual controller instance. The purpose of controllers is to expose variables and functionality to expressions and directives.</source>
          <target state="translated">먼저, &lt;a href=&quot;controller&quot;&gt;controller&lt;/a&gt; 를 포함하는 새로운 JavaScript 파일이 있습니다 . 보다 정확하게는 파일이 실제 컨트롤러 인스턴스를 생성하는 데 사용될 생성자 함수를 지정합니다. 컨트롤러의 목적은 변수와 기능을 표현식과 지시문에 노출시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="77d9204eade0f099f5e0ab2bbd55d4646d3a83bf" translate="yes" xml:space="preserve">
          <source>Flickering when using ngHide to toggle between elements</source>
          <target state="translated">ngHide를 사용하여 요소 간 전환시 깜박임</target>
        </trans-unit>
        <trans-unit id="b5ab32c1bf51cc481c9ab3c08fe93a1b77113b2e" translate="yes" xml:space="preserve">
          <source>Flickering when using ngShow to toggle between elements</source>
          <target state="translated">ngShow를 사용하여 요소 간 전환시 깜박임</target>
        </trans-unit>
        <trans-unit id="dd43887b63ddf9f9facc6f00c39c0b0cb59061d5" translate="yes" xml:space="preserve">
          <source>Flushes all currently pending tasks and executes the corresponding callbacks.</source>
          <target state="translated">현재 보류중인 모든 작업을 플러시하고 해당 콜백을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a90504300f4ff98f08eb7ca5fb07f8b7ddb64a04" translate="yes" xml:space="preserve">
          <source>Flushes pending requests using the trained responses. Requests are flushed in the order they were made, but it is also possible to skip one or more requests (for example to have them flushed later). This is useful for simulating scenarios where responses arrive from the server in any order.</source>
          <target state="translated">훈련 된 응답을 사용하여 보류중인 요청을 플러시합니다. 요청은 작성된 순서대로 플러시되지만 하나 이상의 요청을 건너 뛸 수도 있습니다 (예 : 나중에 플러시하도록). 응답이 서버에서 임의 순서로 도착하는 시나리오를 시뮬레이션하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="638b971934a555c5935d2b23812b0728737ef511" translate="yes" xml:space="preserve">
          <source>Flushes the queue of pending tasks.</source>
          <target state="translated">보류중인 작업 대기열을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="8fccbd9b557140b0032b7f8e325d55f44d855fc4" translate="yes" xml:space="preserve">
          <source>Flushing HTTP requests</source>
          <target state="translated">플러시 HTTP 요청</target>
        </trans-unit>
        <trans-unit id="a9fc15bcc3e40c2b04001a849fdf3aa1b08d270c" translate="yes" xml:space="preserve">
          <source>Follow &lt;a href=&quot;../service/%24sce#resourceUrlPatternItem.html&quot;&gt;this link&lt;/a&gt; for a description of the items allowed in this array.</source>
          <target state="translated">이 배열에서 허용되는 항목에 대한 설명을 보려면 &lt;a href=&quot;../service/%24sce#resourceUrlPatternItem.html&quot;&gt;이 링크&lt;/a&gt; 를 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="094d6476ce6c9b2413458a029d80353731b269a4" translate="yes" xml:space="preserve">
          <source>Following the AngularJS expression, you would denote the plural extension syntax by the &lt;code&gt;, plural,&lt;/code&gt; syntax element. The spaces there are optional.</source>
          <target state="translated">AngularJS 표현식 다음에 &lt;code&gt;, plural,&lt;/code&gt; 구문 요소로 복수 확장 구문을 표시합니다 . 공백은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="77b5d91136a3bc63a58e377a55c5cfbbe4b179c4" translate="yes" xml:space="preserve">
          <source>For CSS that's safe to source into the application. Currently unused. Feel free to use it in your own directives.</source>
          <target state="translated">응용 프로그램으로 안전하게 소스 할 수있는 CSS의 경우 현재 미사용. 자신의 지시에 자유롭게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93453f79c27232e1015010a01e85d73371266175" translate="yes" xml:space="preserve">
          <source>For HTML that's safe to source into the application. The &lt;a href=&quot;../directive/ngbindhtml&quot;&gt;ngBindHtml&lt;/a&gt; directive uses this context for bindings. If an unsafe value is encountered and the &lt;a href=&quot;../../ngsanitize&quot;&gt;$sanitize&lt;/a&gt; module is present this will sanitize the value instead of throwing an error.</source>
          <target state="translated">응용 프로그램으로 안전하게 소스 할 수있는 HTML의 경우. &lt;a href=&quot;../directive/ngbindhtml&quot;&gt;ngBindHtml의&lt;/a&gt; 지시어는 바인딩이 컨텍스트를 사용합니다. 안전하지 않은 값이 발생하고 &lt;a href=&quot;../../ngsanitize&quot;&gt;$ sanitize&lt;/a&gt; 모듈이 있으면 오류를 발생시키는 대신 값을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="26c9ca3b2c358ad13d5820190c1ba8d9939ab41e" translate="yes" xml:space="preserve">
          <source>For JavaScript that is safe to execute in your application's context. Currently unused. Feel free to use it in your own directives.</source>
          <target state="translated">응용 프로그램 컨텍스트에서 실행하기에 안전한 JavaScript 현재 미사용. 자신의 지시에 자유롭게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c53dc4f36928109e16191d24a777b2f91435bd6c" translate="yes" xml:space="preserve">
          <source>For URLs that are not only safe to follow as links, but whose contents are also safe to include in your application. Examples include &lt;code&gt;ng-include&lt;/code&gt;, &lt;code&gt;src&lt;/code&gt; / &lt;code&gt;ngSrc&lt;/code&gt; bindings for tags other than &lt;code&gt;IMG&lt;/code&gt; (e.g. &lt;code&gt;IFRAME&lt;/code&gt;, &lt;code&gt;OBJECT&lt;/code&gt;, etc.)</source>
          <target state="translated">링크로 따라 가기에 안전하지만 응용 프로그램에 포함하기에 안전한 URL의 경우. 예를 들어 &lt;code&gt;IMG&lt;/code&gt; 이외의 태그에 대한 &lt;code&gt;ng-include&lt;/code&gt; , &lt;code&gt;src&lt;/code&gt; / &lt;code&gt;ngSrc&lt;/code&gt; 바인딩 (예 : &lt;code&gt;IFRAME&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="679d8901367dd69ff1b551c6d19359134975c76f" translate="yes" xml:space="preserve">
          <source>For URLs that are safe to follow as links. Is automatically converted from string by sanitizing when needed. Note that &lt;code&gt;$sce.URL&lt;/code&gt; makes a stronger statement about the URL than &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; does and therefore contexts requiring values trusted for &lt;code&gt;$sce.URL&lt;/code&gt; can be used anywhere that values trusted for &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; are required.</source>
          <target state="translated">링크로 따라 가기 쉬운 URL의 경우. 필요할 때 살균하여 문자열에서 자동으로 변환됩니다. 하는 것으로 &lt;code&gt;$sce.URL&lt;/code&gt; 보다 URL에 대한 강한 진술하게 &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; 값을 필요로하므로 컨텍스트가 신뢰할 수행하고 &lt;code&gt;$sce.URL&lt;/code&gt; 값을 신뢰할 것을 어디에서나 사용할 수있는 &lt;code&gt;$sce.MEDIA_URL&lt;/code&gt; 요구된다.</target>
        </trans-unit>
        <trans-unit id="460be5bd6859be623406a9b95efc4d427c933c3d" translate="yes" xml:space="preserve">
          <source>For URLs that are safe to render as media. Is automatically converted from string by sanitizing when needed.</source>
          <target state="translated">미디어로 렌더링하기에 안전한 URL의 경우. 필요할 때 살균하여 문자열에서 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="56a3631774eba60c1d32538706994f443230d184" translate="yes" xml:space="preserve">
          <source>For a full breakdown of each method available on &lt;code&gt;$animate&lt;/code&gt;, see the &lt;a href=&quot;../api/ng/service/%24animate&quot;&gt;API documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$animate&lt;/code&gt; 에서 사용할 수있는 각 방법에 대한 자세한 내용은 &lt;a href=&quot;../api/ng/service/%24animate&quot;&gt;API 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee537291a987f36791c6713c21d3132becf867bb" translate="yes" xml:space="preserve">
          <source>For a full breakdown of the steps involved during each animation event, refer to the &lt;a href=&quot;../api/ng/service/%24animate&quot;&gt;&lt;code&gt;$animate&lt;/code&gt; API docs&lt;/a&gt;.</source>
          <target state="translated">각 애니메이션 이벤트 중에 포함 된 단계에 대한 자세한 내용은 &lt;a href=&quot;../api/ng/service/%24animate&quot;&gt; &lt;code&gt;$animate&lt;/code&gt; API docs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c2ee5a6e688447faa7359cb736c719caeff0771" translate="yes" xml:space="preserve">
          <source>For a full breakdown of the steps involved during each animation event, refer to the &lt;a href=&quot;ng/service/%24animate&quot;&gt;&lt;code&gt;$animate&lt;/code&gt; API docs&lt;/a&gt;.</source>
          <target state="translated">각 애니메이션 이벤트 중에 포함 된 단계에 대한 자세한 내용은 &lt;a href=&quot;ng/service/%24animate&quot;&gt; &lt;code&gt;$animate&lt;/code&gt; API docs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9eb4e7bb485c4f2c498bc194e7c524491dc3a750" translate="yes" xml:space="preserve">
          <source>For a higher level of abstraction, please check out the &lt;a href=&quot;../../ngresource/service/%24resource&quot;&gt;$resource&lt;/a&gt; service.</source>
          <target state="translated">더 높은 수준의 추상화는 &lt;a href=&quot;../../ngresource/service/%24resource&quot;&gt;$ resource&lt;/a&gt; 서비스 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d076559b1af0412b2156be6fe715805d27e234d9" translate="yes" xml:space="preserve">
          <source>For an overview of this service and the functionnality it provides in AngularJS, see the main page for &lt;a href=&quot;%24sce&quot;&gt;SCE&lt;/a&gt;. The current page is targeted for developers who need to alter how SCE works in their application, which shouldn't be needed in most cases.</source>
          <target state="translated">이 서비스 및 AngularJS에서 제공하는 기능에 대한 개요는 &lt;a href=&quot;%24sce&quot;&gt;SCE&lt;/a&gt; 기본 페이지를 참조하십시오 . 현재 페이지는 대부분의 경우 필요하지 않은 응용 프로그램에서 SCE의 작동 방식을 변경해야하는 개발자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="b35f9509f0816b491b39c105cf33a4c232d76568" translate="yes" xml:space="preserve">
          <source>For basic examples, how to use &lt;code&gt;ngModel&lt;/code&gt;, see:</source>
          <target state="translated">&lt;code&gt;ngModel&lt;/code&gt; 사용 방법에 대한 기본 예제는 다음 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="18cb02d5b2d6faa6bcd2abc7c6cf94b02170c3a3" translate="yes" xml:space="preserve">
          <source>For best practices on using &lt;code&gt;ngModel&lt;/code&gt;, see:</source>
          <target state="translated">&lt;code&gt;ngModel&lt;/code&gt; 사용에 대한 모범 사례는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="77d34f60b8e72f532f193ec3320fc033253270d4" translate="yes" xml:space="preserve">
          <source>For browsers that support the HTML5 history API, &lt;code&gt;$location&lt;/code&gt; uses the HTML5 history API to write path and search. If the history API is not supported by a browser, &lt;code&gt;$location&lt;/code&gt; supplies a Hashbang URL. This frees you from having to worry about whether the browser viewing your app supports the history API or not; the &lt;code&gt;$location&lt;/code&gt; service makes this transparent to you.</source>
          <target state="translated">HTML5 히스토리 API를 지원하는 브라우저의 경우 &lt;code&gt;$location&lt;/code&gt; 은 HTML5 히스토리 API를 사용하여 경로 및 검색을 작성합니다. 히스토리 API가 브라우저에서 지원되지 않는 경우 &lt;code&gt;$location&lt;/code&gt; 은 Hashbang URL을 제공합니다. 따라서 앱을 보는 브라우저가 히스토리 API를 지원하는지 여부를 걱정할 필요가 없습니다. &lt;code&gt;$location&lt;/code&gt; 서비스를 사용하면이 투명하게.</target>
        </trans-unit>
        <trans-unit id="667b86f65118c83e9387d50ae6fab23e51925cb5" translate="yes" xml:space="preserve">
          <source>For cases where the attribute name is the same as the value you want to bind to inside the directive's scope, you can use this shorthand syntax:</source>
          <target state="translated">속성 이름이 지시문 범위 내에서 바인딩하려는 값과 동일한 경우이 속기 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="214f9ccc5f52486bf94285f84eb26c0f1f87ae2a" translate="yes" xml:space="preserve">
          <source>For dynamically creating &lt;code&gt;href&lt;/code&gt; attributes for a tags, see the &lt;a href=&quot;nghref&quot;&gt;&lt;code&gt;ngHref&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">태그에 대한 &lt;code&gt;href&lt;/code&gt; 속성을 동적으로 생성 하려면 &lt;a href=&quot;nghref&quot;&gt; &lt;code&gt;ngHref&lt;/code&gt; &lt;/a&gt; 지시문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2cb21c62c7124bee8beb4118b76b5e301e11b61" translate="yes" xml:space="preserve">
          <source>For example consider a directive that uses transclusion and isolated scope. The DOM hierarchy might look like this:</source>
          <target state="translated">예를 들어, 변환 및 격리 범위를 사용하는 지시문을 고려하십시오. DOM 계층은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37c999fd77efd0888b9cb38aaca6a3de81ed8a47" translate="yes" xml:space="preserve">
          <source>For example given the following fragment of HTML</source>
          <target state="translated">예를 들어 다음과 같은 HTML 조각이 주어진 경우</target>
        </trans-unit>
        <trans-unit id="7928c96ad76339cd8a1a495f2757512494975f25" translate="yes" xml:space="preserve">
          <source>For example if we wanted to do a CSS animation for &lt;code&gt;ngHide&lt;/code&gt; then we place an animation on the &lt;code&gt;.ng-hide&lt;/code&gt; CSS class:</source>
          <target state="translated">예를 들어 &lt;code&gt;ngHide&lt;/code&gt; 에 대한 CSS 애니메이션을 수행 하려면 &lt;code&gt;.ng-hide&lt;/code&gt; CSS 클래스 에 애니메이션을 배치합니다 .</target>
        </trans-unit>
        <trans-unit id="68db25a901df945b32772fe453b1fa47d47a8252" translate="yes" xml:space="preserve">
          <source>For example if your server needs to return:</source>
          <target state="translated">예를 들어 서버를 반환해야하는 경우 :</target>
        </trans-unit>
        <trans-unit id="da9cd80863fc9d60fc99be6bca25f3975ab8cf3f" translate="yes" xml:space="preserve">
          <source>For example on *nix, to create an angular.js file that contains localization rules for german locale, you can do the following:</source>
          <target state="translated">예를 들어 * nix에서 독일어 로캘에 대한 현지화 규칙이 포함 된 angular.js 파일을 만들려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e64d608c66f058026befe85feab000c0e8eb56f7" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;[{id: 'foo'}, {id: 'bar'}] | orderBy:'id'&lt;/code&gt; would result in &lt;code&gt;[{id: 'bar'}, {id: 'foo'}]&lt;/code&gt;.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;[{id: 'foo'}, {id: 'bar'}] | orderBy:'id'&lt;/code&gt; 는 &lt;code&gt;[{id: 'bar'}, {id: 'foo'}]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8dd342ed97c8f1fdb9f8a8fbf2799eee0ccdcc8c" translate="yes" xml:space="preserve">
          <source>For example, an element acts as a loading spinner. It has an infinite css animation on it, and also an &lt;a href=&quot;../api/ng/directive/ngif&quot;&gt;&lt;code&gt;ngIf&lt;/code&gt;&lt;/a&gt; directive, for which no animations are defined:</source>
          <target state="translated">예를 들어, 요소는 로딩 스피너 역할을합니다. 여기에는 무한 CSS 애니메이션과 애니메이션이 정의되지 않은 &lt;a href=&quot;../api/ng/directive/ngif&quot;&gt; &lt;code&gt;ngIf&lt;/code&gt; &lt;/a&gt; 지시문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cf18d17856b16f1490eddc7ee8f166885da6706" translate="yes" xml:space="preserve">
          <source>For example, considering this template:</source>
          <target state="translated">예를 들어이 템플릿을 고려하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c917b642410469c8ea7e90f8a294d625b0e2286" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;&amp;lt;my-component my-attr=&quot;parentModel&quot;&amp;gt;&lt;/code&gt; and directive definition of &lt;code&gt;scope: { localModel:'&amp;lt;myAttr' }&lt;/code&gt;, then the isolated scope property &lt;code&gt;localModel&lt;/code&gt; will reflect the value of &lt;code&gt;parentModel&lt;/code&gt; on the parent scope. Any changes to &lt;code&gt;parentModel&lt;/code&gt; will be reflected in &lt;code&gt;localModel&lt;/code&gt;, but changes in &lt;code&gt;localModel&lt;/code&gt; will not reflect in &lt;code&gt;parentModel&lt;/code&gt;. There are however two caveats:</source>
          <target state="translated">예를 들어, &lt;code&gt;&amp;lt;my-component my-attr=&quot;parentModel&quot;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;scope: { localModel:'&amp;lt;myAttr' }&lt;/code&gt; 지시자 정의 : {localModel : '&amp;lt;myAttr'} 이면 격리 된 범위 특성 &lt;code&gt;localModel&lt;/code&gt; 은 상위 범위 의 &lt;code&gt;parentModel&lt;/code&gt; 값을 반영합니다 . 모든 변경 &lt;code&gt;parentModel&lt;/code&gt; 가 반영됩니다 &lt;code&gt;localModel&lt;/code&gt; 하지만, 변화 &lt;code&gt;localModel&lt;/code&gt; 은 반영되지 않습니다 &lt;code&gt;parentModel&lt;/code&gt; . 그러나 두 가지 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f49496495571ad1faf93be95dab230558d27e175" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;mode.rewriteLinks&lt;/code&gt; is set to &lt;code&gt;'internal-link'&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;mode.rewriteLinks&lt;/code&gt; 가 &lt;code&gt;'internal-link'&lt;/code&gt; 로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="c8160364ec09deefcb004bae9314f54d4f6ba323" translate="yes" xml:space="preserve">
          <source>For example, if an input control is added that is already &lt;code&gt;$dirty&lt;/code&gt; and has &lt;code&gt;$error&lt;/code&gt; properties, calling &lt;code&gt;$setDirty()&lt;/code&gt; and &lt;code&gt;$validate()&lt;/code&gt; afterwards will propagate the state to the parent form.</source>
          <target state="translated">예를 들어, 이미 &lt;code&gt;$dirty&lt;/code&gt; 이고 &lt;code&gt;$error&lt;/code&gt; 속성 이있는 입력 컨트롤이 추가 된 경우 &lt;code&gt;$setDirty()&lt;/code&gt; 및 &lt;code&gt;$validate()&lt;/code&gt; 호출 하면 상태가 부모 폼으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="4100a3af8d122712b1181599580e9e97e167970c" translate="yes" xml:space="preserve">
          <source>For example, it can be used for specifying the &quot;Accept&quot; header that is sent to the server, when requesting a template.</source>
          <target state="translated">예를 들어, 템플릿을 요청할 때 서버로 전송되는 &quot;Accept&quot;헤더를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c81880bfa28e2a7d53ec485327343074412001" translate="yes" xml:space="preserve">
          <source>For example, routes like &lt;code&gt;/color/:color/largecode/:largecode*\/edit&lt;/code&gt; will match &lt;code&gt;/color/brown/largecode/code/with/slashes/edit&lt;/code&gt; and extract:</source>
          <target state="translated">예를 들어 &lt;code&gt;/color/:color/largecode/:largecode*\/edit&lt;/code&gt; 와 같은 경로 는 &lt;code&gt;/color/brown/largecode/code/with/slashes/edit&lt;/code&gt; 와 일치 하고 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1b54425e1ee99911055acc84ab0ce4f407e3493d" translate="yes" xml:space="preserve">
          <source>For example, the following forms are all equivalent and match the &lt;a href=&quot;../api/ng/directive/ngbind&quot;&gt;&lt;code&gt;ngBind&lt;/code&gt;&lt;/a&gt; directive:</source>
          <target state="translated">예를 들어, 다음 형식은 모두 동일하며 &lt;a href=&quot;../api/ng/directive/ngbind&quot;&gt; &lt;code&gt;ngBind&lt;/code&gt; &lt;/a&gt; 지시문 과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="8a1d556c82b4cdccf6ac8ff718e0e8e16f73d570" translate="yes" xml:space="preserve">
          <source>For example, the parameter &lt;code&gt;_myService_&lt;/code&gt; would be resolved as the reference &lt;code&gt;myService&lt;/code&gt;. Since it is available in the function body as &lt;code&gt;_myService_&lt;/code&gt;, we can then assign it to a variable defined in an outer scope.</source>
          <target state="translated">예를 들어, 매개 변수 &lt;code&gt;_myService_&lt;/code&gt; 는 참조 &lt;code&gt;myService&lt;/code&gt; 로 해석됩니다 . 함수 본문에서 &lt;code&gt;_myService_&lt;/code&gt; 로 사용할 수 있으므로 외부 범위에 정의 된 변수에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9ab0c654c0f4dd1405a9253a4855d8cd4a37ec" translate="yes" xml:space="preserve">
          <source>For example, the transclude object &lt;code&gt;{ slotA: '?myCustomElement' }&lt;/code&gt; maps &lt;code&gt;&amp;lt;my-custom-element&amp;gt;&lt;/code&gt; elements to the &lt;code&gt;slotA&lt;/code&gt; slot, which can be accessed via the &lt;code&gt;$transclude&lt;/code&gt; function or via the &lt;a href=&quot;../directive/ngtransclude&quot;&gt;&lt;code&gt;ngTransclude&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">예를 들어, transclude 객체 &lt;code&gt;{ slotA: '?myCustomElement' }&lt;/code&gt; 는 &lt;code&gt;&amp;lt;my-custom-element&amp;gt;&lt;/code&gt; 요소를 &lt;code&gt;slotA&lt;/code&gt; 슬롯에 매핑 하며 &lt;code&gt;$transclude&lt;/code&gt; &lt;a href=&quot;../directive/ngtransclude&quot;&gt; &lt;code&gt;ngTransclude&lt;/code&gt; &lt;/a&gt; 함수 또는 ngTransclude 지시문을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63e8ba7e3633e731a37f59a5f71a0246863d5260" translate="yes" xml:space="preserve">
          <source>For example, these are valid expressions in AngularJS:</source>
          <target state="translated">예를 들어, AngularJS에서 유효한 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="96705da955a8375dd1945d20693b46a51ee66c61" translate="yes" xml:space="preserve">
          <source>For example, to bind to &lt;code&gt;viewBox&lt;/code&gt;, we can write:</source>
          <target state="translated">예를 들어 &lt;code&gt;viewBox&lt;/code&gt; 에 바인딩하려면 다음 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ccfc76b489a9482967cab3c080c55bf14ba5ead" translate="yes" xml:space="preserve">
          <source>For example, we could fix the example above by instead writing:</source>
          <target state="translated">예를 들어, 대신 다음과 같이 작성하여 위 예제를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7d01ec6314e26035b376c51a5d51073e752c597" translate="yes" xml:space="preserve">
          <source>For example, you can specify a new &lt;code&gt;update&lt;/code&gt; action that uses the &lt;code&gt;PUT&lt;/code&gt; HTTP verb:</source>
          <target state="translated">예를 들어 &lt;code&gt;PUT&lt;/code&gt; HTTP 동사 를 사용 하는 새 &lt;code&gt;update&lt;/code&gt; 작업을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24b9b4933809e915effa8985612fb6a246c52bde" translate="yes" xml:space="preserve">
          <source>For example, you should not use interpolation in the value of the &lt;code&gt;style&lt;/code&gt; attribute (e.g. &lt;code&gt;style=&quot;color: {{ 'orange' }}; font-weight: {{ 'bold' }};&quot;&lt;/code&gt;) &lt;strong&gt;and&lt;/strong&gt; at the same time use a directive that changes the content of that attribute, such as &lt;code&gt;ngStyle&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 값에 보간을 사용해서는 안 &lt;code&gt;style&lt;/code&gt; (예를 들어, 속성 &lt;code&gt;style=&quot;color: {{ 'orange' }}; font-weight: {{ 'bold' }};&quot;&lt;/code&gt; ) &lt;strong&gt;과&lt;/strong&gt; 에서 동시에 사용 같은 그 속성의 내용을 변경하는 지침 &lt;code&gt;ngStyle&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d34c040e0936e358901f3aa689af5cf27ff974b" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;(name, age) in {'adam':10, 'amalie':12}&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;(name, age) in {'adam':10, 'amalie':12}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed802f940e232dd5f65c3ca8779aee1a29358982" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;album in artist.albums&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;album in artist.albums&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="681d399129810dbe00c67bb783ff5c6fc3cb9abd" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;item in items | filter : x | orderBy : order | limitTo : limit as results track by item.id&lt;/code&gt; .</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;item in items | filter : x | orderBy : order | limitTo : limit as results track by item.id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3361e3ce4a7b68bb7099adb908017c58b77d7659" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;item in items | filter:x as results&lt;/code&gt; will store the fragment of the repeated items as &lt;code&gt;results&lt;/code&gt;, but only after the items have been processed through the filter.</source>
          <target state="translated">예를 들면 다음과 같습니다. &lt;code&gt;item in items | filter:x as results&lt;/code&gt; 로 반복되는 항목의 단편 저장할 &lt;code&gt;results&lt;/code&gt; 하지만 항목은 필터를 통해 처리 된 후에 만.</target>
        </trans-unit>
        <trans-unit id="94485d1a8b6086205e13bc75af843d115c8cdeb9" translate="yes" xml:space="preserve">
          <source>For extra convenience, &lt;code&gt;whenRoute&lt;/code&gt; and &lt;code&gt;expectRoute&lt;/code&gt; shortcuts are available. These methods offer colon delimited matching of the url path, ignoring the query string and trailing slashes. This allows declarations similar to how application routes are configured with &lt;code&gt;$routeProvider&lt;/code&gt;. Because these methods convert the definition url to regex, declaration order is important. Combined with query parameter parsing, the following is possible:</source>
          <target state="translated">편의성을 &lt;code&gt;whenRoute&lt;/code&gt; 위해 whenRoute 및 &lt;code&gt;expectRoute&lt;/code&gt; 바로 가기를 사용할 수 있습니다. 이러한 메소드는 URL 경로의 콜론으로 구분 된 일치를 제공하여 쿼리 문자열과 후행 슬래시를 무시합니다. 이를 통해 &lt;code&gt;$routeProvider&lt;/code&gt; 응용 프로그램 경로를 구성하는 방법과 유사한 선언이 가능 합니다. 이러한 메소드는 정의 URL을 정규식으로 변환하기 때문에 선언 순서가 중요합니다. 쿼리 매개 변수 구문 분석과 함께 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="072be915c36eea0008ba664485e0bec787e012a1" translate="yes" xml:space="preserve">
          <source>For folks with a jQuery background</source>
          <target state="translated">jQuery 배경을 가진 사람들을 위해</target>
        </trans-unit>
        <trans-unit id="d4be5a755dc40ef55c3ed316c05fba77165d707c" translate="yes" xml:space="preserve">
          <source>For further information check out the guide on &lt;a href=&quot;../../../guide/directive#matching-directives.html&quot;&gt;Matching Directives&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../../../guide/directive#matching-directives.html&quot;&gt;일치하는 지침&lt;/a&gt; 에 대한 안내서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4ec6b925164277672546a7d8d723f7a6f4124b26" translate="yes" xml:space="preserve">
          <source>For further information check out the guide on &lt;a href=&quot;../../../guide/directive#matching-directives.html&quot;&gt;Matching Directives&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../../../guide/directive#matching-directives.html&quot;&gt;Matching Directives&lt;/a&gt; 가이드를 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="4b43ddc504c929290eacba4d8a365ed1210996ec" translate="yes" xml:space="preserve">
          <source>For historical reasons, this method will also flush non-&lt;code&gt;$timeout&lt;/code&gt; pending tasks, such as &lt;a href=&quot;../../ng/service/%24q&quot;&gt;&lt;code&gt;$q&lt;/code&gt;&lt;/a&gt; promises and tasks scheduled via &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$applyAsync&lt;/a&gt; and &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$evalAsync&lt;/a&gt;.</source>
          <target state="translated">역사적 이유로이 방법은 &lt;a href=&quot;../../ng/service/%24q&quot;&gt; &lt;code&gt;$q&lt;/code&gt; &lt;/a&gt; 약속 및 &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$ applyAsync&lt;/a&gt; 및 &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$ evalAsync&lt;/a&gt; 를 통해 예약 된 작업 과 같이 $ &lt;code&gt;$timeout&lt;/code&gt; 아닌 보류중인 작업 도 삭제 합니다 .</target>
        </trans-unit>
        <trans-unit id="96d5709584b09a9673009d4b874368aa832eb8de" translate="yes" xml:space="preserve">
          <source>For historical reasons, this method will also verify non-&lt;code&gt;$timeout&lt;/code&gt; pending tasks, such as pending &lt;a href=&quot;../../ng/service/%24http&quot;&gt;&lt;code&gt;$http&lt;/code&gt;&lt;/a&gt; requests, in-progress &lt;a href=&quot;../../ngroute/service/%24route&quot;&gt;&lt;code&gt;$route&lt;/code&gt;&lt;/a&gt; transitions, unresolved &lt;a href=&quot;../../ng/service/%24q&quot;&gt;&lt;code&gt;$q&lt;/code&gt;&lt;/a&gt; promises and tasks scheduled via &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$applyAsync&lt;/a&gt; and &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$evalAsync&lt;/a&gt;.</source>
          <target state="translated">역사적인 이유로,이 방법은 비 확인합니다 &lt;code&gt;$timeout&lt;/code&gt; 민사와 같은 대기중인 작업, &lt;a href=&quot;../../ng/service/%24http&quot;&gt; &lt;code&gt;$http&lt;/code&gt; &lt;/a&gt; 요청 진행 &lt;a href=&quot;../../ngroute/service/%24route&quot;&gt; &lt;code&gt;$route&lt;/code&gt; &lt;/a&gt; 전환, 해결되지 않은 &lt;a href=&quot;../../ng/service/%24q&quot;&gt; &lt;code&gt;$q&lt;/code&gt; &lt;/a&gt; 통해 일정 약속과 작업 &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24applyAsync.html&quot;&gt;$ applyAsync&lt;/a&gt; 및 &lt;a href=&quot;../../ng/type/%24rootscope.scope#%24evalAsync.html&quot;&gt;$ evalAsync을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e79547ae737496ef4b830c418e98203529ffd5b3" translate="yes" xml:space="preserve">
          <source>For in-depth discussion about DI, see &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency Injection&lt;/a&gt; at Wikipedia, &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;Inversion of Control&lt;/a&gt; by Martin Fowler, or read about DI in your favorite software design pattern book.</source>
          <target state="translated">DI에 대한 자세한 내용 은 Wikipedia의 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_injection&quot;&gt;Dependency Injection&lt;/a&gt; , Martin Fowler의 &lt;a href=&quot;http://martinfowler.com/articles/injection.html&quot;&gt;Inversion of Control&lt;/a&gt; 을 참조하거나 자주 사용하는 소프트웨어 디자인 패턴 북에서 DI에 대해 읽어보십시오.</target>
        </trans-unit>
        <trans-unit id="4c4430f0a9c683776764888172731ad0be5f3a21" translate="yes" xml:space="preserve">
          <source>For information on how the compiler works, see the &lt;a href=&quot;../../../guide/compiler&quot;&gt;AngularJS HTML Compiler&lt;/a&gt; section of the Developer Guide.</source>
          <target state="translated">컴파일러의 작동 방식에 대한 정보 는 개발자 안내서 의 &lt;a href=&quot;../../../guide/compiler&quot;&gt;AngularJS HTML 컴파일러&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fcbd9cf327acae20f4980fb68635ba5be10e8a9e" translate="yes" xml:space="preserve">
          <source>For instance in a long running Single Page Application (SPA), one user may &quot;log out&quot;, but then another user may access the application without refreshing, in which case all the cached data is still available.</source>
          <target state="translated">예를 들어 장시간 실행되는 단일 페이지 응용 프로그램 (SPA)에서는 한 사용자가 &quot;로그 아웃&quot;할 수 있지만 다른 사용자는 새로 고치지 않고 응용 프로그램에 액세스 할 수 있습니다.이 경우 모든 캐시 된 데이터를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5ae6d931fb112afe199ee277a04174d9d1b69e" translate="yes" xml:space="preserve">
          <source>For instance, the required directive does this to work out if the input has data or not.</source>
          <target state="translated">예를 들어, 필수 지시문은 입력에 데이터가 있는지 여부를 확인하기 위해이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1ed68e337042bafa1e8676ab786bd6c545ca56f2" translate="yes" xml:space="preserve">
          <source>For instance, what if we wanted to create a directive that lets a user drag an element?</source>
          <target state="translated">예를 들어, 사용자가 요소를 끌 수있는 지시문을 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="83e081f1429ea35f9cc98daf2caa2c7900084512" translate="yes" xml:space="preserve">
          <source>For more about how to configure services, see &lt;a href=&quot;../../../guide/providers#provider-recipe.html&quot;&gt;Provider Recipe&lt;/a&gt;.</source>
          <target state="translated">서비스 구성 방법에 대한 자세한 정보는 &lt;a href=&quot;../../../guide/providers#provider-recipe.html&quot;&gt;제공자 레시피를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c9f8258461de9d031c72dc478ab759f9f3d6a71" translate="yes" xml:space="preserve">
          <source>For more details on the &lt;code&gt;link&lt;/code&gt; option refer to the &lt;a href=&quot;../api/ng/service/%24compile#-link-.html&quot;&gt;&lt;code&gt;$compile&lt;/code&gt; API&lt;/a&gt; page.</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 옵션 에 대한 자세한 내용 은 &lt;a href=&quot;../api/ng/service/%24compile#-link-.html&quot;&gt; &lt;code&gt;$compile&lt;/code&gt; API&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03fb612774d8f4c26b5bffdddde2f8da0d09c268" translate="yes" xml:space="preserve">
          <source>For more details, please refer to our &lt;a href=&quot;https://docs.google.com/a/google.com/document/d/1pbtW2yvtmFBikfRrJd8VAsabiFkKezmYZ_PbgdjQOVU/edit&quot;&gt;design doc&lt;/a&gt;. You can read more about the ICU MessageFormat syntax at &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages#TOC-MessageFormat&quot;&gt;Formatting Messages | ICU User Guide&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.google.com/a/google.com/document/d/1pbtW2yvtmFBikfRrJd8VAsabiFkKezmYZ_PbgdjQOVU/edit&quot;&gt;디자인 문서&lt;/a&gt; 를 참조하십시오 . ICU MessageFormat 구문에 대한 자세한 내용은 &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages#TOC-MessageFormat&quot;&gt;메시지 포맷 | ICU 사용자 안내서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6b5d56555aab13e3ab69162ff339401d9009f51" translate="yes" xml:space="preserve">
          <source>For more examples, and an in-depth guide, see the &lt;a href=&quot;../../../guide/component&quot;&gt;component guide&lt;/a&gt;.</source>
          <target state="translated">자세한 예와 자세한 안내서는 &lt;a href=&quot;../../../guide/component&quot;&gt;구성 요소 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e45ef233283f4eb561fb40a1c85a858803109abf" translate="yes" xml:space="preserve">
          <source>For more information about how AngularJS filters work, and how to create your own filters, see &lt;a href=&quot;../../../guide/filter&quot;&gt;Filters&lt;/a&gt; in the AngularJS Developer Guide.</source>
          <target state="translated">AngularJS와 작업을 필터링하고, 자신 만의 필터를 생성하는 방법에 대한 자세한 내용은 &lt;a href=&quot;../../../guide/filter&quot;&gt;필터&lt;/a&gt; AngularJS와 개발자 가이드를.</target>
        </trans-unit>
        <trans-unit id="b5c7cb088f3bf1b4252226980a33761384c56cfe" translate="yes" xml:space="preserve">
          <source>For more information on Protractor, view &lt;a href=&quot;http://angular.github.io/protractor/#/getting-started&quot;&gt;getting started&lt;/a&gt; or the &lt;a href=&quot;http://angular.github.io/protractor/#/api&quot;&gt;api docs&lt;/a&gt;.</source>
          <target state="translated">각도기에 대한 자세한 내용은 &lt;a href=&quot;http://angular.github.io/protractor/#/getting-started&quot;&gt;시작하기&lt;/a&gt; 또는 &lt;a href=&quot;http://angular.github.io/protractor/#/api&quot;&gt;api docs를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d9777dd9e23921be5e65fe03cbf4547e45948c" translate="yes" xml:space="preserve">
          <source>For more information please visit &lt;a href=&quot;../api/ng/service/%24sce&quot;&gt;&lt;code&gt;$sce&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/ngsanitize/service/%24sanitize&quot;&gt;&lt;code&gt;$sanitize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../api/ng/service/%24sce&quot;&gt; &lt;code&gt;$sce&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/ngsanitize/service/%24sanitize&quot;&gt; &lt;code&gt;$sanitize&lt;/code&gt; &lt;/a&gt; 를 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="5007e5f43b46ae511f7cfe86c43883e38fb85306" translate="yes" xml:space="preserve">
          <source>For more information please visit &lt;a href=&quot;https://www.whitehatsec.com/blog/web-storage-security/&quot;&gt;Web Storage Security&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.whitehatsec.com/blog/web-storage-security/&quot;&gt;웹 스토리지 보안을&lt;/a&gt; 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="17050d011e437da353406dbb3de303d540a80ce8" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;../../../guide/%24location&quot;&gt;Developer Guide: Using $location&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../../../guide/%24location&quot;&gt;개발자 안내서 : $ location 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d42a33c1c8d9f173d6a9033c03f236de6cab9c91" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../../../guide/bootstrap&quot;&gt;Bootstrap guide&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../../../guide/bootstrap&quot;&gt;Bootstrap 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84f28113af9b7c7d485ded6f76a10650aebf1bfa" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;di#using-strict-dependency-injection.html&quot;&gt;DI Guide&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;di#using-strict-dependency-injection.html&quot;&gt;DI 가이드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ec0f18a27efe3a5bbaaa7c9a76fdead7442a493" translate="yes" xml:space="preserve">
          <source>For more on dependencies, see the &lt;a href=&quot;di&quot;&gt;dependency injection&lt;/a&gt; docs.</source>
          <target state="translated">종속성에 대한 자세한 내용은 &lt;a href=&quot;di&quot;&gt;종속성 주입&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae1dd7c814f6a02ea749e951d697e01de287e16d" translate="yes" xml:space="preserve">
          <source>For more on the &lt;code&gt;restrict&lt;/code&gt; property, see the &lt;a href=&quot;../api/ng/service/%24compile#directive-definition-object.html&quot;&gt;API docs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;restrict&lt;/code&gt; 속성 에 대한 자세한 내용은 &lt;a href=&quot;../api/ng/service/%24compile#directive-definition-object.html&quot;&gt;API docs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08deef231a5f13117b873e36e123085e74358098" translate="yes" xml:space="preserve">
          <source>For more see the docs pages on &lt;a href=&quot;../api/ng/provider/%24compileprovider#commentDirectivesEnabled.html&quot;&gt;&lt;code&gt;$compileProvider.commentDirectivesEnabled&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/ng/provider/%24compileprovider#cssClassDirectivesEnabled.html&quot;&gt;&lt;code&gt;$compileProvider.cssClassDirectivesEnabled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../api/ng/provider/%24compileprovider#commentDirectivesEnabled.html&quot;&gt; &lt;code&gt;$compileProvider.commentDirectivesEnabled&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/ng/provider/%24compileprovider#cssClassDirectivesEnabled.html&quot;&gt; &lt;code&gt;$compileProvider.cssClassDirectivesEnabled&lt;/code&gt; &lt;/a&gt; 의 문서 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b9e3aa3cc39fa5b8b3356d069b3b85b223b9d68" translate="yes" xml:space="preserve">
          <source>For more see the docs pages on &lt;a href=&quot;../api/ng/provider/%24compileprovider#debugInfoEnabled.html&quot;&gt;&lt;code&gt;$compileProvider&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/ng/function/angular.reloadwithdebuginfo&quot;&gt;&lt;code&gt;angular.reloadWithDebugInfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../api/ng/provider/%24compileprovider#debugInfoEnabled.html&quot;&gt; &lt;code&gt;$compileProvider&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/ng/function/angular.reloadwithdebuginfo&quot;&gt; &lt;code&gt;angular.reloadWithDebugInfo&lt;/code&gt; &lt;/a&gt; 의 문서 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb0970fb80040dd5e4119122a4b3d870ad0ab13b" translate="yes" xml:space="preserve">
          <source>For mutations to be properly observed, you should make them only within the &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;scope.$apply()&lt;/a&gt;. AngularJS APIs do this implicitly, so no extra &lt;code&gt;$apply&lt;/code&gt; call is needed when doing synchronous work in controllers, or asynchronous work with &lt;a href=&quot;../api/ng/service/%24http&quot;&gt;$http&lt;/a&gt;, &lt;a href=&quot;../api/ng/service/%24timeout&quot;&gt;$timeout&lt;/a&gt; or &lt;a href=&quot;../api/ng/service/%24interval&quot;&gt;$interval&lt;/a&gt; services.</source>
          <target state="translated">돌연변이가 제대로 관찰 되려면 &lt;a href=&quot;../api/ng/type/%24rootscope.scope#%24apply.html&quot;&gt;scope. $ apply ()&lt;/a&gt; 내에서만 돌연변이를 만들어야합니다 . AngularJS API는이를 암시 적으로 수행하므로 컨트롤러에서 동기 작업을 수행하거나 &lt;a href=&quot;../api/ng/service/%24http&quot;&gt;$ http&lt;/a&gt; , &lt;a href=&quot;../api/ng/service/%24timeout&quot;&gt;$ timeout&lt;/a&gt; 또는 &lt;a href=&quot;../api/ng/service/%24interval&quot;&gt;$ interval&lt;/a&gt; 서비스를 사용한 비동기 작업을 수행 할 때 추가 &lt;code&gt;$apply&lt;/code&gt; 호출이 필요 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="70cabd8c2e94395b437f880992a54a0646b1ec62" translate="yes" xml:space="preserve">
          <source>For ngAria to do its magic, simply include the module &lt;code&gt;ngAria&lt;/code&gt; as a dependency. The following directives are supported: &lt;code&gt;ngModel&lt;/code&gt;, &lt;code&gt;ngChecked&lt;/code&gt;, &lt;code&gt;ngReadonly&lt;/code&gt;, &lt;code&gt;ngRequired&lt;/code&gt;, &lt;code&gt;ngValue&lt;/code&gt;, &lt;code&gt;ngDisabled&lt;/code&gt;, &lt;code&gt;ngShow&lt;/code&gt;, &lt;code&gt;ngHide&lt;/code&gt;, &lt;code&gt;ngClick&lt;/code&gt;, &lt;code&gt;ngDblClick&lt;/code&gt;, and &lt;code&gt;ngMessages&lt;/code&gt;.</source>
          <target state="translated">ngAria가 마법을 수행하려면 모듈 &lt;code&gt;ngAria&lt;/code&gt; 를 종속성으로 포함하기 만하면됩니다 . &lt;code&gt;ngModel&lt;/code&gt; , &lt;code&gt;ngChecked&lt;/code&gt; , &lt;code&gt;ngReadonly&lt;/code&gt; , &lt;code&gt;ngRequired&lt;/code&gt; , &lt;code&gt;ngValue&lt;/code&gt; , &lt;code&gt;ngDisabled&lt;/code&gt; , &lt;code&gt;ngShow&lt;/code&gt; , &lt;code&gt;ngHide&lt;/code&gt; , &lt;code&gt;ngClick&lt;/code&gt; , &lt;code&gt;ngDblClick&lt;/code&gt; 및 &lt;code&gt;ngMessages&lt;/code&gt; 지시문이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="7935b6948cbce976a835b91d5bd505582812c0c4" translate="yes" xml:space="preserve">
          <source>For purposes of global error handling, authentication, or any kind of synchronous or asynchronous pre-processing of request or postprocessing of responses, it is desirable to be able to intercept requests before they are handed to the server and responses before they are handed over to the application code that initiated these requests. The interceptors leverage the &lt;a href=&quot;%24q&quot;&gt;promise APIs&lt;/a&gt; to fulfill this need for both synchronous and asynchronous pre-processing.</source>
          <target state="translated">전역 오류 처리, 인증 또는 요청에 대한 모든 종류의 동기식 또는 비동기식 전처리 또는 응답 후 처리를 위해 요청이 서버로 전달되기 전에 인터셉트하고 전달하기 전에 응답을 인터셉트하는 것이 바람직합니다. 이러한 요청을 시작한 응용 프로그램 코드 인터셉터는 &lt;a href=&quot;%24q&quot;&gt;약속 API&lt;/a&gt; 를 활용하여 동기식 및 비동기식 전처리에 대한 이러한 요구를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="b64ebc99af83053596191ba8428a4a73a05f9e05" translate="yes" xml:space="preserve">
          <source>For testing AngularJS applications there are certain tools that you should use that will make testing much easier to set up and run.</source>
          <target state="translated">AngularJS 애플리케이션을 테스트하기 위해 테스트 및 설정을 훨씬 쉽게하는 특정 도구를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0981365eff2fc36be0abaf1d7aab40944bee960" translate="yes" xml:space="preserve">
          <source>For the best result, the &lt;code&gt;angular.js&lt;/code&gt; script must be loaded in the head section of the html document; alternatively, the css rule above must be included in the external stylesheet of the application.</source>
          <target state="translated">최상의 결과를 &lt;code&gt;angular.js&lt;/code&gt; 려면 angular.js 스크립트를 html 문서의 헤드 섹션에로드해야합니다. 또는 위의 CSS 규칙을 응용 프로그램의 외부 스타일 시트에 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="1cbfa677b41097f6715ec9bae88d486586566c4e" translate="yes" xml:space="preserve">
          <source>For the case of HTML, you might use a library, either on the client side, or on the server side, to sanitize unsafe HTML before binding to the value and rendering it in the document.</source>
          <target state="translated">HTML의 경우, 클라이언트 측 또는 서버 측에서 라이브러리를 사용하여 값에 바인딩하여 문서에서 렌더링하기 전에 안전하지 않은 HTML을 위생 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="807df2e76c7472af78eccb593edb0cfe6ff5aaf1" translate="yes" xml:space="preserve">
          <source>For the following examples, we'll use the prefix &lt;code&gt;my&lt;/code&gt; (e.g. &lt;code&gt;myCustomer&lt;/code&gt;).</source>
          <target state="translated">다음 예에서는 접두사 &lt;code&gt;my&lt;/code&gt; (예 : &lt;code&gt;myCustomer&lt;/code&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="960d746344ec6d94fdf45b4493cec7cf2ec6fcad" translate="yes" xml:space="preserve">
          <source>For the general details about this service in AngularJS, read the main page for &lt;a href=&quot;../service/%24sce&quot;&gt;Strict Contextual Escaping (SCE)&lt;/a&gt;.</source>
          <target state="translated">AngularJS에서이 서비스에 대한 일반적인 세부 사항은 &lt;a href=&quot;../service/%24sce&quot;&gt;SCE (Strict Contextual Escaping)&lt;/a&gt; 의 기본 페이지를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="18276b32129c935a3f68b3699c65cc3ed663b628" translate="yes" xml:space="preserve">
          <source>For this reason, AngularJS prevents the default action (form submission to the server) unless the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; element has an &lt;code&gt;action&lt;/code&gt; attribute specified.</source>
          <target state="translated">이러한 이유로 AngularJS는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소에 &lt;code&gt;action&lt;/code&gt; 속성이 지정 되어 있지 않으면 기본 조치 (서버에 양식 제출)를 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="59a0dc0f6babb8c929909c5324c52ffba8f70e1b" translate="yes" xml:space="preserve">
          <source>For this reason, AngularJS provides special &lt;code&gt;ng&lt;/code&gt;-prefixed directives for the following boolean attributes: &lt;a href=&quot;../api/ng/directive/ngdisabled&quot;&gt;&lt;code&gt;disabled&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/ngrequired&quot;&gt;&lt;code&gt;required&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/ngselected&quot;&gt;&lt;code&gt;selected&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/ngchecked&quot;&gt;&lt;code&gt;checked&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/ng/directive/ngreadonly&quot;&gt;&lt;code&gt;readOnly&lt;/code&gt;&lt;/a&gt; , and &lt;a href=&quot;../api/ng/directive/ngopen&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 이유로 AngularJS는 다음 부울 속성에 대해 특수한 &lt;code&gt;ng&lt;/code&gt; - prefixed 지시문을 제공 합니다 : &lt;a href=&quot;../api/ng/directive/ngdisabled&quot;&gt; &lt;code&gt;disabled&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/ngrequired&quot;&gt; &lt;code&gt;required&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/ngselected&quot;&gt; &lt;code&gt;selected&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/ngchecked&quot;&gt; &lt;code&gt;checked&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/ng/directive/ngreadonly&quot;&gt; &lt;code&gt;readOnly&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/ng/directive/ngopen&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3230a2f947a8018219006b3929f539fd927003d2" translate="yes" xml:space="preserve">
          <source>For this, inject a dependency with the name &lt;code&gt;&amp;lt;filterName&amp;gt;Filter&lt;/code&gt; into your controller/service/directive. E.g. a filter called &lt;code&gt;number&lt;/code&gt; is injected by using the dependency &lt;code&gt;numberFilter&lt;/code&gt;. The injected argument is a function that takes the value to format as first argument, and filter parameters starting with the second argument.</source>
          <target state="translated">이를 위해 이름이 &lt;code&gt;&amp;lt;filterName&amp;gt;Filter&lt;/code&gt; 인 종속성을 컨트롤러 / 서비스 / 지시문에 삽입하십시오. 예를 들어, &lt;code&gt;number&lt;/code&gt; 라는 필터 는 의존성 &lt;code&gt;numberFilter&lt;/code&gt; 를 사용하여 주입됩니다 . 주입 된 인수는 값을 첫 번째 인수로 형식화하고 두 번째 인수로 시작하는 매개 변수를 필터링하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="79c0422145c2571f4818e372784001318ee45548" translate="yes" xml:space="preserve">
          <source>For those elements using ngModel, ngAria will dynamically bind and update the following ARIA attributes (if they have not been explicitly specified by the developer):</source>
          <target state="translated">ngModel을 사용하는 요소의 경우 ngAria는 다음 ARIA 속성을 동적으로 바인딩하고 업데이트합니다 (개발자가 명시 적으로 지정하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="5364d19c24f92cd90b7c73685bff662a0a4cfa1a" translate="yes" xml:space="preserve">
          <source>For unit testing applications that use &lt;code&gt;$http&lt;/code&gt; service, see &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;$httpBackend mock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$http&lt;/code&gt; 서비스 를 사용하는 단위 테스트 애플리케이션 은 &lt;a href=&quot;../../ngmock/service/%24httpbackend&quot;&gt;$ httpBackend mock을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="052fb3b37ae2bbf010c88dd3bc6c08df91652edd" translate="yes" xml:space="preserve">
          <source>Forgiving</source>
          <target state="translated">Forgiving</target>
        </trans-unit>
        <trans-unit id="abc67155e14921e60c9bacfaf13e79f8e7ecfc81" translate="yes" xml:space="preserve">
          <source>Form and controls provide validation services, so that the user can be notified of invalid input before submitting a form. This provides a better user experience than server-side validation alone because the user gets instant feedback on how to correct the error. Keep in mind that while client-side validation plays an important role in providing good user experience, it can easily be circumvented and thus can not be trusted. Server-side validation is still necessary for a secure application.</source>
          <target state="translated">양식 및 컨트롤은 유효성 검사 서비스를 제공하므로 양식을 제출하기 전에 사용자에게 잘못된 입력을 알릴 수 있습니다. 이는 사용자가 오류를 수정하는 방법에 대한 즉각적인 피드백을 받기 때문에 서버 측 유효성 검사보다 나은 사용자 환경을 제공합니다. 클라이언트 측 유효성 검사는 우수한 사용자 환경을 제공하는 데 중요한 역할을하지만 쉽게 우회 할 수 있으므로 신뢰할 수 없습니다. 안전한 응용 프로그램을 위해서는 서버 측 유효성 검사가 여전히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1eedca47903886a532d39ee2257b013bc5c557cd" translate="yes" xml:space="preserve">
          <source>Format input &amp;mdash; Use &lt;a href=&quot;forms&quot;&gt;AngularJS form controls&lt;/a&gt; instead.</source>
          <target state="translated">형식 입력 &amp;mdash; 대신 &lt;a href=&quot;forms&quot;&gt;AngularJS 양식 컨트롤을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9fd294ed8b67f7239254353f7b9ddfee62002f1" translate="yes" xml:space="preserve">
          <source>Format of items in &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;resourceUrlWhitelist&lt;/a&gt;/&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;Blacklist&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlWhitelist.html&quot;&gt;resourceUrlWhitelist&lt;/a&gt; / &lt;a href=&quot;../provider/%24scedelegateprovider#resourceUrlBlacklist.html&quot;&gt;Blacklist&lt;/a&gt; 의 항목 형식</target>
        </trans-unit>
        <trans-unit id="d29adb3f4ca339ebdff8dbe1aaae081f33e02725" translate="yes" xml:space="preserve">
          <source>Format of items in &lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;trustedResourceUrlList&lt;/a&gt;/&lt;a href=&quot;../provider/%24scedelegateprovider#bannedResourceUrlList.html&quot;&gt;bannedResourceUrlList&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../provider/%24scedelegateprovider#trustedResourceUrlList.html&quot;&gt;trustedResourceUrlList&lt;/a&gt; / &lt;a href=&quot;../provider/%24scedelegateprovider#bannedResourceUrlList.html&quot;&gt;bannedResourceUrlList&lt;/a&gt; 의 항목 형식</target>
        </trans-unit>
        <trans-unit id="8e17b9df66528716e814be197136b7a326516c1c" translate="yes" xml:space="preserve">
          <source>Formats &lt;code&gt;date&lt;/code&gt; to a string based on the requested &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">형식은 &lt;code&gt;date&lt;/code&gt; 요청에 따라 문자열로 &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb856525f448d550db676ecb20ddcdce2f9183a5" translate="yes" xml:space="preserve">
          <source>Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default symbol for current locale is used.</source>
          <target state="translated">숫자를 통화로 형식화합니다 (예 : $ 1,234.56). 통화 기호가 제공되지 않으면 현재 로캘의 기본 기호가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69675ca3093ae5e95c7f23454bbb0ec2a3e3a132" translate="yes" xml:space="preserve">
          <source>Formats a number as text.</source>
          <target state="translated">숫자를 텍스트로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="43567c9dea743d47cb7123053dbe369243a548e8" translate="yes" xml:space="preserve">
          <source>Formatted number.</source>
          <target state="translated">서식이 지정된 숫자.</target>
        </trans-unit>
        <trans-unit id="a511d54043ebc3e9c36c28add78796a0f3f9f424" translate="yes" xml:space="preserve">
          <source>Formatted string or the input if input is not recognized as date/millis.</source>
          <target state="translated">입력이 날짜 / 밀리로 인식되지 않으면 형식화 된 문자열 또는 입력입니다.</target>
        </trans-unit>
        <trans-unit id="feaca5c695540ca4a17380a6775827911844a0ef" translate="yes" xml:space="preserve">
          <source>Formatters are used to format / convert the &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt;&lt;code&gt;$modelValue&lt;/code&gt;&lt;/a&gt; for display in the control.</source>
          <target state="translated">포맷터는 컨트롤에 표시 할 &lt;a href=&quot;ngmodel.ngmodelcontroller#%24modelValue.html&quot;&gt; &lt;code&gt;$modelValue&lt;/code&gt; &lt;/a&gt; 를 포맷 / 변환하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6e18ee88ca6b32cea05d0e3080d8f655d9521b6" translate="yes" xml:space="preserve">
          <source>Formatting rules (see Description). If not specified, &lt;code&gt;mediumDate&lt;/code&gt; is used.</source>
          <target state="translated">서식 규칙 (설명 참조). 지정하지 않으면 &lt;code&gt;mediumDate&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f0b06a027f8381260596b559c5a0e8d57007109" translate="yes" xml:space="preserve">
          <source>Formatting the value of time and datetime-local</source>
          <target state="translated">시간 및 날짜 / 시간의 값 형식</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="34e426cd3274227d580489998337e732030d7d3c" translate="yes" xml:space="preserve">
          <source>Free Course</source>
          <target state="translated">무료 코스</target>
        </trans-unit>
        <trans-unit id="b1cc7a14b45bb59084312de228fdaae722b439c3" translate="yes" xml:space="preserve">
          <source>From a testability point of view, the separation of the controller and the view is desirable, because it allows us to test the behavior without being distracted by the rendering details.</source>
          <target state="translated">테스트 가능성 관점에서 볼 때 컨트롤러와 뷰를 분리하는 것이 바람직합니다. 렌더링 세부 사항에 방해받지 않고 동작을 테스트 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ff161838502e7c8b317b65fb969c906dab1f4586" translate="yes" xml:space="preserve">
          <source>From the perspective of dealing with error handling, deferred and promise APIs are to asynchronous programming what &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; keywords are to synchronous programming.</source>
          <target state="translated">오류 처리를 다루는 관점에서 지연 및 약속 API는 동기 프로그래밍에 키워드를 &lt;code&gt;try&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; 및 &lt;code&gt;throw&lt;/code&gt; 것을 비동기식 프로그래밍하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d73e691376909588e8dda5cc25ad70145db6e2ea" translate="yes" xml:space="preserve">
          <source>Fulfills multiple requests</source>
          <target state="translated">여러 요청 이행</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="7e9e8ac7651cc9a1d61043f76ffdf8a16490138a" translate="yes" xml:space="preserve">
          <source>Function components in ng</source>
          <target state="translated">ng의 기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="299be8740244752c39ca3ccf8a970cee133c25c2" translate="yes" xml:space="preserve">
          <source>Function components in ngMock</source>
          <target state="translated">ngMock의 기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="c76a84b175d34bf214149af2c9e8f9e13e2e4fcc" translate="yes" xml:space="preserve">
          <source>Function for creating new instance of the service.</source>
          <target state="translated">서비스의 새로운 인스턴스를 생성하는 기능.</target>
        </trans-unit>
        <trans-unit id="7090d50b6c70bb19d3d516b59283dff809cdae61" translate="yes" xml:space="preserve">
          <source>Function for which dependent service names need to be retrieved as described above.</source>
          <target state="translated">위에서 설명한대로 종속 서비스 이름을 검색해야하는 기능.</target>
        </trans-unit>
        <trans-unit id="c4ac49e1d1511eed6fbb89bab7baa0e4b33a477d" translate="yes" xml:space="preserve">
          <source>Function that will be called whenever the interpolated value of the attribute changes. See the &lt;a href=&quot;../../../guide/interpolation#how-text-and-attribute-bindings-work.html&quot;&gt;Interpolation guide&lt;/a&gt; for more info.</source>
          <target state="translated">보간 된 속성 값이 변경 될 때마다 호출되는 함수입니다. 자세한 내용은 &lt;a href=&quot;../../../guide/interpolation#how-text-and-attribute-bindings-work.html&quot;&gt;보간 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b463c12a5f308c5c4aafc3e574eff48f177aef97" translate="yes" xml:space="preserve">
          <source>Function that wraps the &lt;code&gt;fn&lt;/code&gt; with all the specified bindings.</source>
          <target state="translated">지정된 모든 바인딩으로 &lt;code&gt;fn&lt;/code&gt; 을 래핑하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="fca9f3655fbd49d7d73e9fc899dae1611e2d1e66" translate="yes" xml:space="preserve">
          <source>Function to be bound.</source>
          <target state="translated">바인딩 할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="719583f650cbb51ca93d209fd7733efacca091e6" translate="yes" xml:space="preserve">
          <source>Function to call when the event is emitted.</source>
          <target state="translated">이벤트가 발생할 때 호출하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="195099197fbc90af0bf8f3534cf2c2ffbe52076f" translate="yes" xml:space="preserve">
          <source>Function which is responsible for resolving or rejecting the newly created promise. The first parameter is a function which resolves the promise, the second parameter is a function which rejects the promise.</source>
          <target state="translated">새로 작성된 약속을 해결하거나 거부하는 기능. 첫 번째 매개 변수는 약속을 해결하는 함수이고 두 번째 매개 변수는 약속을 거부하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="dbcc17581b648df6a6e5ecca84fd052cd7f998ad" translate="yes" xml:space="preserve">
          <source>Fundamentals in 60 Minutes (video)</source>
          <target state="translated">60 분 후 기본 사항 (비디오)</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="03be4828bd04065e742a929df12bd3febf535195" translate="yes" xml:space="preserve">
          <source>Future route information.</source>
          <target state="translated">향후 노선 정보.</target>
        </trans-unit>
        <trans-unit id="4f00f495f1b31beea48aec4250e15a8cb8f378e0" translate="yes" xml:space="preserve">
          <source>Games and GUI editors are examples of applications with intensive and tricky DOM manipulation. These kinds of apps are different from CRUD apps, and as a result are probably not a good fit for AngularJS. In these cases it may be better to use a library with a lower level of abstraction, such as &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="translated">게임 및 GUI 편집기는 집중적이고 까다로운 DOM 조작이있는 응용 프로그램의 예입니다. 이러한 종류의 앱은 CRUD 앱과 다르므로 AngularJS에는 적합하지 않을 수 있습니다. 이 경우 &lt;code&gt;jQuery&lt;/code&gt; 와 같이 추상화 수준이 낮은 라이브러리를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8a754c61c2ced0c5ff79a1827e02c9d643d6d926" translate="yes" xml:space="preserve">
          <source>Gender</source>
          <target state="translated">Gender</target>
        </trans-unit>
        <trans-unit id="022ad2aec8e03d3aeffcc6353469c736894859fc" translate="yes" xml:space="preserve">
          <source>Gender (aka select) Syntax</source>
          <target state="translated">성별 (일명 선택) 구문</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="37a13a917db9fd6aaad1b1420d262dd85b0845b4" translate="yes" xml:space="preserve">
          <source>General Learning Resources</source>
          <target state="translated">일반 학습 자료</target>
        </trans-unit>
        <trans-unit id="fbfff011ffdaef489b35073be8fbf243896fd8d0" translate="yes" xml:space="preserve">
          <source>General Use</source>
          <target state="translated">일반적인 사용</target>
        </trans-unit>
        <trans-unit id="ed7feb5b4fe5b0b70af5a852a8c4193e523ae7ea" translate="yes" xml:space="preserve">
          <source>General overview of the API</source>
          <target state="translated">API의 일반 개요</target>
        </trans-unit>
        <trans-unit id="098a776c18aed363a9dd217893658630e8cd72e8" translate="yes" xml:space="preserve">
          <source>General usage</source>
          <target state="translated">일반적인 사용법</target>
        </trans-unit>
        <trans-unit id="8245f1469399dc21184c708cfafeb02fe22720e6" translate="yes" xml:space="preserve">
          <source>Get access to a cache object by the &lt;code&gt;cacheId&lt;/code&gt; used when it was created.</source>
          <target state="translated">캐시 오브젝트 가 작성 될 때 사용 된 캐시 &lt;code&gt;cacheId&lt;/code&gt; 로 캐시 오브젝트에 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2634d2ab675dfb52782612c8c407712d90ab4ae" translate="yes" xml:space="preserve">
          <source>Get information about all the caches that have been created</source>
          <target state="translated">생성 된 모든 캐시에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b7660cf3196f07e0a3ec7d200a945203c052a995" translate="yes" xml:space="preserve">
          <source>Getter and setter methods</source>
          <target state="translated">게터와 세터 메소드</target>
        </trans-unit>
        <trans-unit id="9633645141a566c014c4723a2e74a10b5b9548d9" translate="yes" xml:space="preserve">
          <source>Getters (calls to methods without parameters) return decoded values for the following methods &lt;code&gt;path()&lt;/code&gt;, &lt;code&gt;search()&lt;/code&gt;, &lt;code&gt;hash()&lt;/code&gt;.</source>
          <target state="translated">Getter (매개 변수가없는 메서드를 호출)는 다음 메서드 &lt;code&gt;path()&lt;/code&gt; , &lt;code&gt;search()&lt;/code&gt; , &lt;code&gt;hash()&lt;/code&gt; 대한 디코딩 된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9a0f73ca6aa746ede1e77153dd3bf5bb16e841ab" translate="yes" xml:space="preserve">
          <source>Getting Help</source>
          <target state="translated">도움을 받다</target>
        </trans-unit>
        <trans-unit id="5442e2b64fa09764b9f593867e59a97292c84059" translate="yes" xml:space="preserve">
          <source>GitHub</source>
          <target state="translated">GitHub</target>
        </trans-unit>
        <trans-unit id="125fce7f6e4e46718b4324a9e531f51dac5b5239" translate="yes" xml:space="preserve">
          <source>Gitter</source>
          <target state="translated">Gitter</target>
        </trans-unit>
        <trans-unit id="8f89c3a7b049617c085d0669638c1304642c269d" translate="yes" xml:space="preserve">
          <source>Give your directive the &lt;code&gt;terminal&lt;/code&gt; property and a higher priority than directives that should not be compiled twice. In the example, the compiler will only compile directives which have a priority of 100 or higher.</source>
          <target state="translated">지시문에 &lt;code&gt;terminal&lt;/code&gt; 속성을 지정하고 두 번 컴파일해서는 안되는 지시문보다 우선 순위가 높습니다. 이 예제에서 컴파일러는 우선 순위가 100 이상인 지시문 만 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="a4944830e9ab64a911c6a61e799488b1d408b662" translate="yes" xml:space="preserve">
          <source>Given a function, the injector can infer the names of the services to inject by examining the function declaration and extracting the parameter names. In the above example, &lt;code&gt;$scope&lt;/code&gt; and &lt;code&gt;greeter&lt;/code&gt; are two services which need to be injected into the function.</source>
          <target state="translated">함수가 주어지면 인젝터는 함수 선언을 검사하고 매개 변수 이름을 추출하여 주입 할 서비스 이름을 유추 할 수 있습니다. 위의 예에서 &lt;code&gt;$scope&lt;/code&gt; 와 &lt;code&gt;greeter&lt;/code&gt; 는 함수에 주입해야하는 두 가지 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="8e22639ca85295c0d8a371689da6f4b5266c177d" translate="yes" xml:space="preserve">
          <source>Given a template &lt;code&gt;/path/:verb&lt;/code&gt; and parameter &lt;code&gt;{verb: 'greet', salutation: 'Hello'}&lt;/code&gt; results in URL &lt;code&gt;/path/greet?salutation=Hello&lt;/code&gt;.</source>
          <target state="translated">템플릿 &lt;code&gt;/path/:verb&lt;/code&gt; 및 매개 변수 &lt;code&gt;{verb: 'greet', salutation: 'Hello'}&lt;/code&gt; 가 URL &lt;code&gt;/path/greet?salutation=Hello&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="da53969ab67a277a2236b7677eabc9291e416b28" translate="yes" xml:space="preserve">
          <source>Given an expression that starts with &lt;code&gt;::&lt;/code&gt;, when a digest loop is entered and expression is dirty-checked, store the value as V</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 로 시작하는 표현식이 있으면 다이제스트 루프를 입력하고 표현식을 더티 검사 할 때 값을 V로 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="fd29881d160148e4919339fe869d1ba4998c6ef7" translate="yes" xml:space="preserve">
          <source>Given an object and a security context in which to assign it, returns a value that's safe to use in this context, which was represented by the parameter. To do so, this function either unwraps the safe type it has been given (for instance, a &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt;&lt;code&gt;$sceDelegate.trustAs&lt;/code&gt;&lt;/a&gt; result), or it might try to sanitize the value given, depending on the context and sanitizer availablility.</source>
          <target state="translated">오브젝트와 오브젝트를 지정할 보안 컨텍스트가 제공되면이 컨텍스트에서 사용하기에 안전한 값을 리턴합니다.이 값은 매개 변수로 표시됩니다. 이를 위해이 함수는 주어진 안전 유형 (예 : &lt;a href=&quot;%24scedelegate#trustAs.html&quot;&gt; &lt;code&gt;$sceDelegate.trustAs&lt;/code&gt; &lt;/a&gt; 결과)을 풀 거나 컨텍스트 및 소독제 가용성에 따라 주어진 값을 소독하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a257da8c321c097fe8fe5cc955c19057fa2bffc" translate="yes" xml:space="preserve">
          <source>Given the following error object for our example (which informs us that the field &lt;code&gt;myField&lt;/code&gt; currently has both the &lt;code&gt;required&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; errors):</source>
          <target state="translated">예제에 다음과 같은 오류 객체가 있습니다 ( &lt;code&gt;myField&lt;/code&gt; 필드에 현재 &lt;code&gt;required&lt;/code&gt; 및 &lt;code&gt;email&lt;/code&gt; 오류 가 있음을 알려줍니다 ).</target>
        </trans-unit>
        <trans-unit id="f9f18e9100167b3cbe391107f9b9896237d584ce" translate="yes" xml:space="preserve">
          <source>Given the nature of &lt;code&gt;ngModelOptions&lt;/code&gt;, the value displayed inside input fields in the view might be different from the value in the actual model. This means that if you update the model you should also invoke &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24rollbackViewValue.html&quot;&gt;&lt;code&gt;ngModel.NgModelController&lt;/code&gt;&lt;/a&gt; on the relevant input field in order to make sure it is synchronized with the model and that any debounced action is canceled.</source>
          <target state="translated">&lt;code&gt;ngModelOptions&lt;/code&gt; 의 특성상 보기의 입력 필드에 표시되는 값은 실제 모델의 값과 다를 수 있습니다. 즉, 모델을 업데이트하면 관련 입력 필드에서 &lt;a href=&quot;../type/ngmodel.ngmodelcontroller#%24rollbackViewValue.html&quot;&gt; &lt;code&gt;ngModel.NgModelController&lt;/code&gt; &lt;/a&gt; 를 호출 하여 모델과 동기화되고 디 바운스 된 작업이 취소되었는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="120a32f853f560c1d2bd012c26941580cd618e1e" translate="yes" xml:space="preserve">
          <source>Given this array of items on the $scope:</source>
          <target state="translated">$ scope에 다음과 같은 항목 배열이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="660a89b0fbdf53826bcc57234ddbd04675201f3d" translate="yes" xml:space="preserve">
          <source>Given this complex combination of CSS classes, styles and options, &lt;code&gt;$animateCss&lt;/code&gt; will figure everything out and make the animation happen.</source>
          <target state="translated">CSS 클래스, 스타일 및 옵션의 복잡한 조합을 고려할 때 &lt;code&gt;$animateCss&lt;/code&gt; 는 모든 것을 파악하고 애니메이션을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f77562ae0f3df5f61f357418891b85a82b5f1b10" translate="yes" xml:space="preserve">
          <source>Google+</source>
          <target state="translated">Google+</target>
        </trans-unit>
        <trans-unit id="99e8c59f379e7741fc044ae1510082583a27eb98" translate="yes" xml:space="preserve">
          <source>Grouping of HTML into reusable components.</source>
          <target state="translated">재사용 가능한 구성 요소로 HTML 그룹화.</target>
        </trans-unit>
        <trans-unit id="3ba448f1c251a3f30a4894252c910f2f06e1790f" translate="yes" xml:space="preserve">
          <source>Grouping related tests within &lt;code&gt;describe&lt;/code&gt; blocks and describing each individual test within an &lt;code&gt;it&lt;/code&gt; call keeps your tests self documenting.</source>
          <target state="translated">&lt;code&gt;describe&lt;/code&gt; 블록 내에서 관련 테스트를 그룹화 &lt;code&gt;it&lt;/code&gt; 호출 내에서 각 개별 테스트를 설명하면 테스트 자체 문서화가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="4857fab7166afc1434fd0e5b087340d9d836a21f" translate="yes" xml:space="preserve">
          <source>Guide: Forms</source>
          <target state="translated">안내서 : 양식</target>
        </trans-unit>
        <trans-unit id="082638bfa9b018580d30a942ed8e17ec72bfee8f" translate="yes" xml:space="preserve">
          <source>HTML &lt;code&gt;select&lt;/code&gt; element with AngularJS data-binding.</source>
          <target state="translated">AngularJS 데이터 바인딩이있는 HTML &lt;code&gt;select&lt;/code&gt; 요소</target>
        </trans-unit>
        <trans-unit id="1ed7cdfdbf49bfaa13fce98fe7cec3a1c300e160" translate="yes" xml:space="preserve">
          <source>HTML Compiler</source>
          <target state="translated">HTML 컴파일러</target>
        </trans-unit>
        <trans-unit id="8103e94886ef5d4fe535735e02a17a98d0a0dda5" translate="yes" xml:space="preserve">
          <source>HTML Sanitization</source>
          <target state="translated">HTML 위생</target>
        </trans-unit>
        <trans-unit id="dcfc59be6d6b598114227a2015e59e2456f6c3a9" translate="yes" xml:space="preserve">
          <source>HTML checkbox.</source>
          <target state="translated">HTML 확인란.</target>
        </trans-unit>
        <trans-unit id="956dfc4aa08de7e5a58a5878e750adab8be1a7a5" translate="yes" xml:space="preserve">
          <source>HTML compilation happens in three phases:</source>
          <target state="translated">HTML 컴파일은 세 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="365711f3aa530a2399266a71af0d94bbd34fb790" translate="yes" xml:space="preserve">
          <source>HTML compiler</source>
          <target state="translated">HTML 컴파일러</target>
        </trans-unit>
        <trans-unit id="9eb40b7d07d13c87ed32d2291d04e9ac3fc3ab1c" translate="yes" xml:space="preserve">
          <source>HTML has a lot of constructs for formatting the HTML for static documents in a declarative fashion. For example if something needs to be centered, there is no need to provide instructions to the browser how the window size needs to be divided in half so that the center is found, and that this center needs to be aligned with the text's center. Simply add an &lt;code&gt;align=&quot;center&quot;&lt;/code&gt; attribute to any element to achieve the desired behavior. Such is the power of declarative language.</source>
          <target state="translated">HTML에는 정적 문서의 HTML을 선언적인 형식으로 형식화하기위한 많은 구성이 있습니다. 예를 들어, 무언가를 중심에 배치해야하는 경우, 중심을 찾을 수 있도록이 창 크기를 절반으로 나누고이 중심을 텍스트 중심에 정렬해야하는 방법을 브라우저에 지시 할 필요가 없습니다. 원하는 동작을 달성하려면 요소에 &lt;code&gt;align=&quot;center&quot;&lt;/code&gt; 속성을 추가하기 만하면 됩니다. 이것이 선언적 언어의 힘입니다.</target>
        </trans-unit>
        <trans-unit id="bd11a5d2ff3115a84c7177fab98a96885225b6f0" translate="yes" xml:space="preserve">
          <source>HTML input element control. When used together with &lt;a href=&quot;directive/ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt;, it provides data-binding, input state control, and validation. Input control follows HTML5 input types and polyfills the HTML5 validation behavior for older browsers.</source>
          <target state="translated">HTML 입력 요소 컨트롤. &lt;a href=&quot;directive/ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 과 함께 사용하면 데이터 바인딩, 입력 상태 제어 및 유효성 검사를 제공합니다. 입력 제어는 HTML5 입력 유형을 따르며 이전 브라우저의 HTML5 유효성 검사 동작을 폴리 필합니다.</target>
        </trans-unit>
        <trans-unit id="75cd325edf2be9c413b3f9e3b95e9fce9dfbe8ca" translate="yes" xml:space="preserve">
          <source>HTML input element control. When used together with &lt;a href=&quot;ngmodel&quot;&gt;&lt;code&gt;ngModel&lt;/code&gt;&lt;/a&gt;, it provides data-binding, input state control, and validation. Input control follows HTML5 input types and polyfills the HTML5 validation behavior for older browsers.</source>
          <target state="translated">HTML 입력 요소 컨트롤. &lt;a href=&quot;ngmodel&quot;&gt; &lt;code&gt;ngModel&lt;/code&gt; &lt;/a&gt; 과 함께 사용하면 데이터 바인딩, 입력 상태 제어 및 유효성 검사를 제공합니다. 입력 제어는 HTML5 입력 유형을 따르며 이전 브라우저의 HTML5 유효성 검사 동작을 폴리 필합니다.</target>
        </trans-unit>
        <trans-unit id="b52ce58ede873fa3ffe8c4f4b95938da98b79e53" translate="yes" xml:space="preserve">
          <source>HTML input.</source>
          <target state="translated">HTML 입력.</target>
        </trans-unit>
        <trans-unit id="3002c557c6e602f4fc52a7ef3b7fe2ffd052cecd" translate="yes" xml:space="preserve">
          <source>HTML link rewriting</source>
          <target state="translated">HTML 링크 재 작성</target>
        </trans-unit>
        <trans-unit id="0e0f1476dcc9c91e2471380aac237c3c16762a4f" translate="yes" xml:space="preserve">
          <source>HTML markup that may:</source>
          <target state="translated">다음과 같은 HTML 마크 업 :</target>
        </trans-unit>
        <trans-unit id="f58f18b2a197f082495e5aabb52b36faf0d3e7ac" translate="yes" xml:space="preserve">
          <source>HTML radio button.</source>
          <target state="translated">HTML 라디오 버튼.</target>
        </trans-unit>
        <trans-unit id="673e4be38003649fd68400ae693d19b8570e48ea" translate="yes" xml:space="preserve">
          <source>HTML string or DOMElement to be wrapped into jQuery.</source>
          <target state="translated">jQuery에 래핑 할 HTML 문자열 또는 DOMElement</target>
        </trans-unit>
        <trans-unit id="28dfba92f8df7dc9094d96723e46d403afe9cf5f" translate="yes" xml:space="preserve">
          <source>HTML textarea element control with AngularJS data-binding. The data-binding and validation properties of this element are exactly the same as those of the &lt;a href=&quot;directive/input&quot;&gt;input element&lt;/a&gt;.</source>
          <target state="translated">AngularJS 데이터 바인딩을 사용한 HTML 텍스트 영역 요소 컨트롤. 이 요소의 데이터 바인딩 및 유효성 검사 속성은 &lt;a href=&quot;directive/input&quot;&gt;입력 요소&lt;/a&gt; 의 속성과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="90fae27fbf7cecfb835c5ded77341c01b96b78d4" translate="yes" xml:space="preserve">
          <source>HTML textarea element control with AngularJS data-binding. The data-binding and validation properties of this element are exactly the same as those of the &lt;a href=&quot;input&quot;&gt;input element&lt;/a&gt;.</source>
          <target state="translated">AngularJS 데이터 바인딩을 사용한 HTML 텍스트 영역 요소 컨트롤. 이 요소의 데이터 바인딩 및 유효성 검사 속성은 &lt;a href=&quot;input&quot;&gt;입력 요소&lt;/a&gt; 의 속성과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="380dca5d29ff8bcbe21b89ea209d96e274ac2a42" translate="yes" xml:space="preserve">
          <source>HTML with additional markup</source>
          <target state="translated">추가 마크 업이있는 HTML</target>
        </trans-unit>
        <trans-unit id="23e0aec9dcd186ca573c4b402ff2facf4bbfa786" translate="yes" xml:space="preserve">
          <source>HTML5 constraint validation and allowInvalid</source>
          <target state="translated">HTML5 제약 조건 유효성 검사 및 allowInvalid</target>
        </trans-unit>
        <trans-unit id="919928d7bcf7b5802913b51423e1f3fc331681f0" translate="yes" xml:space="preserve">
          <source>HTML5 mode</source>
          <target state="translated">HTML5 모드</target>
        </trans-unit>
        <trans-unit id="147cce8975179e5500fc1bb079891e026beac7f0" translate="yes" xml:space="preserve">
          <source>HTTP Requests</source>
          <target state="translated">HTTP 요청</target>
        </trans-unit>
        <trans-unit id="6e5a031619e754e2aaded2be7edff5361ccb3202" translate="yes" xml:space="preserve">
          <source>HTTP backend used by the &lt;a href=&quot;%24http&quot;&gt;service&lt;/a&gt; that delegates to XMLHttpRequest object or JSONP and deals with browser incompatibilities.</source>
          <target state="translated">XMLHttpRequest 객체 또는 JSONP에 위임하고 브라우저 비 호환성을 처리 하는 &lt;a href=&quot;%24http&quot;&gt;서비스에서&lt;/a&gt; 사용하는 HTTP 백엔드 .</target>
        </trans-unit>
        <trans-unit id="0843ce217fdeb5d4a43dd425f0f9a5e92422e97d" translate="yes" xml:space="preserve">
          <source>HTTP backend used by the &lt;a href=&quot;service/%24http&quot;&gt;service&lt;/a&gt; that delegates to XMLHttpRequest object or JSONP and deals with browser incompatibilities.</source>
          <target state="translated">XMLHttpRequest 객체 또는 JSONP에 위임하고 브라우저 비 호환성을 처리 하는 &lt;a href=&quot;service/%24http&quot;&gt;서비스에서&lt;/a&gt; 사용하는 HTTP 백엔드 .</target>
        </trans-unit>
        <trans-unit id="11ed26cd0ecb017842889c5368f7817eb65b4c04" translate="yes" xml:space="preserve">
          <source>HTTP headers or function that receives http header object and returns true if the headers match the current definition.</source>
          <target state="translated">HTTP 헤더 오브젝트를 수신하고 헤더가 현재 정의와 일치하면 true를 리턴하는 HTTP 헤더 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e9f0ada937e7482930d25244a71bfc57dc18e31b" translate="yes" xml:space="preserve">
          <source>HTTP headers or function that receives http header object and returns true if the headers match the current expectation.</source>
          <target state="translated">HTTP 헤더 오브젝트를 수신하고 헤더가 현재 예상과 일치하면 true를 리턴하는 HTTP 헤더 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="4da8efbb95087f4efaddd53fa5a5d02998d8073e" translate="yes" xml:space="preserve">
          <source>HTTP headers.</source>
          <target state="translated">HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="69dcbdcaea66e534100430f491b74862af6545a6" translate="yes" xml:space="preserve">
          <source>HTTP method of the request (GET, POST, PUT, ..)</source>
          <target state="translated">요청의 HTTP 메소드 (GET, POST, PUT, ..)</target>
        </trans-unit>
        <trans-unit id="e7f701abbb4892632f63163af61f703f4d792e54" translate="yes" xml:space="preserve">
          <source>HTTP method.</source>
          <target state="translated">HTTP 메소드.</target>
        </trans-unit>
        <trans-unit id="739b34082ae180864afd2da55be339a290e09a21" translate="yes" xml:space="preserve">
          <source>HTTP request body or function that receives data string and returns true if the data is as expected, or Object if request body is in JSON format.</source>
          <target state="translated">데이터 문자열을 수신하고 데이터가 예상 한 경우 true를 리턴하는 HTTP 요청 본문 또는 함수, 요청 본문이 JSON 형식 인 경우 Object를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d86c6c3cef60e8657176cf9663c203f4df35ae7e" translate="yes" xml:space="preserve">
          <source>HTTP request body or function that receives data string and returns true if the data is as expected.</source>
          <target state="translated">데이터 문자열을 수신하고 데이터가 예상 한 경우 true를 리턴하는 HTTP 요청 본문 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b3becea06d0acfa7255eb772d6dcbbb225cf0343" translate="yes" xml:space="preserve">
          <source>HTTP url or function that receives a url and returns true if the url matches the current definition.</source>
          <target state="translated">URL을 수신하고 URL이 현재 정의와 일치하면 true를 리턴하는 HTTP URL 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f52106e31df4471f850e4bc7609166aea45564e9" translate="yes" xml:space="preserve">
          <source>HTTP url or function that receives a url and returns true if the url matches the current expectation.</source>
          <target state="translated">URL을 수신하고 URL이 현재 예상과 일치하면 true를 반환하는 HTTP URL 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="99507adf96330288819643c1bf1b9641131bf84a" translate="yes" xml:space="preserve">
          <source>HTTP url or function that receives an url and returns true if the url matches the current expectation.</source>
          <target state="translated">URL을 수신하고 URL이 현재 예상과 일치하면 true를 반환하는 HTTP URL 또는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ce3a987c846205d185fc2edc4fe91e7d5c5a336c" translate="yes" xml:space="preserve">
          <source>HTTP url string that supports colon param matching.</source>
          <target state="translated">콜론 매개 변수 일치를 지원하는 HTTP URL 문자열.</target>
        </trans-unit>
        <trans-unit id="f9d5d6116a9799462a571a9c71dd9f844beb5ac1" translate="yes" xml:space="preserve">
          <source>Hash with custom settings that should extend the default &lt;code&gt;$resourceProvider&lt;/code&gt; behavior. The supported options are:</source>
          <target state="translated">기본 &lt;code&gt;$resourceProvider&lt;/code&gt; 동작을 확장해야하는 사용자 지정 설정으로 해시합니다 . 지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23feba264c938cd5a816b433a94ce03d183ea1f6" translate="yes" xml:space="preserve">
          <source>Hash with declaration of custom actions that will be available in addition to the default set of resource actions (see below). If a custom action has the same key as a default action (e.g. &lt;code&gt;save&lt;/code&gt;), then the default action will be &lt;em&gt;overwritten&lt;/em&gt;, and not extended.</source>
          <target state="translated">기본 자원 조치 세트 (아래 참조) 외에 사용 가능한 사용자 정의 조치 선언이있는 해시. 사용자 정의 조치가 기본 조치와 동일한 키 (예 : &lt;code&gt;save&lt;/code&gt; )를 갖는 경우 기본 조치는 &lt;em&gt;겹쳐 쓰여지고&lt;/em&gt; 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfaff8179045261bcc9e2cdcac0ab24460c6b352" translate="yes" xml:space="preserve">
          <source>Hashbang and HTML5 Modes</source>
          <target state="translated">해시 방 및 HTML5 모드</target>
        </trans-unit>
        <trans-unit id="1b0dd8a962c1421c7d52d29272d65b7f22a06a41" translate="yes" xml:space="preserve">
          <source>Hashbang mode</source>
          <target state="translated">해시 방 모드</target>
        </trans-unit>
        <trans-unit id="152790ca6a4f5a814b879804ca53c1db52354436" translate="yes" xml:space="preserve">
          <source>Hashbang mode (default mode)</source>
          <target state="translated">해시 방 모드 (기본 모드)</target>
        </trans-unit>
        <trans-unit id="dc65de69cf1204a0d8f6a65f23b5cbdc59c7f6f2" translate="yes" xml:space="preserve">
          <source>Helper directive that makes it possible to create control groups inside a &lt;a href=&quot;directive/form&quot;&gt;&lt;code&gt;form&lt;/code&gt;&lt;/a&gt; directive. These &quot;child forms&quot; can be used, for example, to determine the validity of a sub-group of controls.</source>
          <target state="translated">&lt;a href=&quot;directive/form&quot;&gt; &lt;code&gt;form&lt;/code&gt; &lt;/a&gt; 지시문 내에 제어 그룹을 작성할 수있게하는 헬퍼 지시문 . 이러한 &quot;자식&quot;은 예를 들어 하위 그룹의 컨트롤의 유효성을 결정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d728397a26dc6b863f20082f5868fb493c86c9" translate="yes" xml:space="preserve">
          <source>Helper directive that makes it possible to create control groups inside a &lt;a href=&quot;form&quot;&gt;&lt;code&gt;form&lt;/code&gt;&lt;/a&gt; directive. These &quot;child forms&quot; can be used, for example, to determine the validity of a sub-group of controls.</source>
          <target state="translated">&lt;a href=&quot;form&quot;&gt; &lt;code&gt;form&lt;/code&gt; &lt;/a&gt; 지시문 내에 제어 그룹을 작성할 수있게하는 헬퍼 지시문 . 이러한 &quot;자식&quot;은 예를 들어 하위 그룹의 컨트롤의 유효성을 결정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eace3f9f2323bbf0fc546742d11cd0621ca25ee4" translate="yes" xml:space="preserve">
          <source>Here a some examples of creating constants:</source>
          <target state="translated">다음은 상수를 만드는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="5e4c893051b4707f0e5b1249e7e81bc432fd4fb1" translate="yes" xml:space="preserve">
          <source>Here are a few examples of how you would usually define components:</source>
          <target state="translated">다음은 일반적으로 컴포넌트를 정의하는 방법에 대한 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="22cfeeec8cbcab5dc8c92c408c3caa8cfedfcb3d" translate="yes" xml:space="preserve">
          <source>Here are some examples of creating value services.</source>
          <target state="translated">다음은 가치 서비스를 만드는 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="2572f0dbd83dbe653e314f42e4e17d11e1e31488" translate="yes" xml:space="preserve">
          <source>Here is a directive which makes any element draggable. Notice the &lt;code&gt;draggable&lt;/code&gt; attribute on the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">다음은 요소를 드래그 할 수있게하는 지시문입니다. &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 요소 에서 &lt;code&gt;draggable&lt;/code&gt; 속성을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="62a4417e4f911e91ec77edfd2357c79ffed4f432" translate="yes" xml:space="preserve">
          <source>Here is a simple form for editing user contact information. Adding, removing, clearing, and greeting are methods declared on the controller (see source tab). These methods can easily be called from the AngularJS markup. Any changes to the data are automatically reflected in the View without the need for a manual update.</source>
          <target state="translated">다음은 사용자 연락처 정보를 편집하기위한 간단한 양식입니다. 추가, 제거, 지우기 및 인사말은 컨트롤러에서 선언 된 방법입니다 (소스 탭 참조). 이러한 메소드는 AngularJS 마크 업에서 쉽게 호출 할 수 있습니다. 데이터를 변경하면 수동 업데이트없이 View에 자동으로 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="34352a17a8a9151e3590aa194b3aa02094f7b560" translate="yes" xml:space="preserve">
          <source>Here is a tab pane example built from components:</source>
          <target state="translated">다음은 컴포넌트로 작성된 탭 분할 창 예제입니다.</target>
        </trans-unit>
        <trans-unit id="1d069503fae353633f357af5e3a2b89070c3ed31" translate="yes" xml:space="preserve">
          <source>Here is an example of a simple test:</source>
          <target state="translated">다음은 간단한 테스트의 예입니다.</target>
        </trans-unit>
        <trans-unit id="50474d9c5b7e0f79dfee63bb5d1c04123879a0cc" translate="yes" xml:space="preserve">
          <source>Here is an example of loading a bundle of modules, with a utility method called &lt;code&gt;getScript&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;getScript&lt;/code&gt; 라는 유틸리티 메소드를 사용하여 모듈 번들을로드하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="5880ff63c8f632463ae878d297d5b56bfbfbdc24" translate="yes" xml:space="preserve">
          <source>Here is an example of manually initializing AngularJS:</source>
          <target state="translated">다음은 AngularJS를 수동으로 초기화하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="8c04abad1ef15232b7d33e41e2d2c33485dde663" translate="yes" xml:space="preserve">
          <source>Here is an example of registering a service</source>
          <target state="translated">다음은 서비스 등록 예입니다</target>
        </trans-unit>
        <trans-unit id="5e759d842c3481da215b710834ed2ca1a95f87df" translate="yes" xml:space="preserve">
          <source>Here is an example of registering a service using &lt;a href=&quot;%24provide#service.html&quot;&gt;$provide.service(class)&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;%24provide#service.html&quot;&gt;$ provide.service (class)를&lt;/a&gt; 사용하여 서비스를 등록하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1a29f24b6a2342f727b445e40478dc68dee15260" translate="yes" xml:space="preserve">
          <source>Here is an example of using the injector service:</source>
          <target state="translated">인젝터 서비스를 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6658c30a573eda1a06af398c5b3162bb3669f48" translate="yes" xml:space="preserve">
          <source>Here is an example of what the template definition for the &lt;code&gt;dialog&lt;/code&gt; widget may look like.</source>
          <target state="translated">다음은 &lt;code&gt;dialog&lt;/code&gt; 위젯에 대한 템플리트 정의의 모양 예입니다.</target>
        </trans-unit>
        <trans-unit id="efb89522d8e99553f459d6f83b6cca9501f43b08" translate="yes" xml:space="preserve">
          <source>Here is the explanation of how the &lt;code&gt;Hello world&lt;/code&gt; example achieves the data-binding effect when the user enters text into the text field.</source>
          <target state="translated">다음은 사용자가 텍스트 필드에 텍스트를 입력 할 때 &lt;code&gt;Hello world&lt;/code&gt; 예제가 데이터 바인딩 효과를 얻는 방법에 대한 설명입니다 .</target>
        </trans-unit>
        <trans-unit id="dddbe54fb40a9da471f8ece2fdb9b87dab4acbf1" translate="yes" xml:space="preserve">
          <source>Here is what a secure configuration for this scenario might look like:</source>
          <target state="translated">이 시나리오의 보안 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3c1dfdb750e0373bfa4303b6efe8294d9bfd88d" translate="yes" xml:space="preserve">
          <source>Here we decorate the &lt;a href=&quot;../../ng/service/%24log&quot;&gt;$log&lt;/a&gt; service to convert warnings to errors by intercepting calls to &lt;a href=&quot;../../ng/service/%24log#error.html&quot;&gt;$log.warn()&lt;/a&gt;.</source>
          <target state="translated">여기서는 &lt;a href=&quot;../../ng/service/%24log&quot;&gt;$ log&lt;/a&gt; 서비스를 장식하여 &lt;a href=&quot;../../ng/service/%24log#error.html&quot;&gt;$ log.warn ()을&lt;/a&gt; 호출하여 경고를 오류로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="e815a124520499322845f10059e60c7b540cfceb" translate="yes" xml:space="preserve">
          <source>Here we pass an array whose elements consist of a list of strings (the names of the dependencies) followed by the function itself.</source>
          <target state="translated">여기서 우리는 요소 자체가 문자열 목록 (종속성 이름)과 그 자체로 구성된 배열을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="68c7479252208403902f6aa1ed6ea1da9bebafb9" translate="yes" xml:space="preserve">
          <source>Here we've seen the main use cases for directives. Each of these samples acts as a good starting point for creating your own directives.</source>
          <target state="translated">다음은 지시문의 주요 사용 사례를 보았습니다. 이러한 각 샘플은 고유 한 지시문을 작성하기위한 좋은 출발점 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="60e05935ab8bb78195f78bcb2800807eccda1fc0" translate="yes" xml:space="preserve">
          <source>Here you can see two &lt;code&gt;$location&lt;/code&gt; instances that show the difference between &lt;strong&gt;Html5 mode&lt;/strong&gt; and &lt;strong&gt;Html5 Fallback mode&lt;/strong&gt;. Note that to simulate different levels of browser support, the &lt;code&gt;$location&lt;/code&gt; instances are connected to a fakeBrowser service, which you don't have to set up in actual projects.</source>
          <target state="translated">여기 에서 &lt;strong&gt;Html5 모드&lt;/strong&gt; 와 &lt;strong&gt;Html5 폴백 모드&lt;/strong&gt; 의 차이점을 보여주는 두 개의 &lt;code&gt;$location&lt;/code&gt; 인스턴스를 볼 수 있습니다 . 서로 다른 수준의 브라우저 지원을 시뮬레이션하기 위해 &lt;code&gt;$location&lt;/code&gt; 인스턴스는 실제 프로젝트에서 설정할 필요가없는 fakeBrowser 서비스에 연결되어 있습니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="85689592e66dcddab07a025f0a7c7fa876676daf" translate="yes" xml:space="preserve">
          <source>Here's an example directive declared with a Directive Definition Object:</source>
          <target state="translated">Directive Definition Object로 선언 된 예제 지시문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98ab52376054b0ae6a09ea8fc36acb184a3cb5d2" translate="yes" xml:space="preserve">
          <source>Here's an example of a binding in a privileged context:</source>
          <target state="translated">권한있는 컨텍스트에서의 바인딩 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc027285afdb7e2491e24d412648e4821006ff8a" translate="yes" xml:space="preserve">
          <source>Here's an example where you might see flickering:</source>
          <target state="translated">깜박임이 나타날 수있는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c311fcba1d54c9fe55032b814cda6cb881db5cd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;EXPRESSION&lt;/code&gt; is an AngularJS expression that evaluates to the gender of the person that is used to select the message that should be displayed.</source>
          <target state="translated">여기에서 &lt;code&gt;EXPRESSION&lt;/code&gt; 은 표시 할 메시지를 선택하는 데 사용되는 사람의 성별을 평가하는 AngularJS 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="e23108d1c2e1059fd8d1e90bb0a080a1d96f5b9d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;NUMERIC_EXPRESSION&lt;/code&gt; is an expression that evaluates to a numeric value based on which the displayed message should change based on pluralization rules.</source>
          <target state="translated">여기서 &lt;code&gt;NUMERIC_EXPRESSION&lt;/code&gt; 은 표시된 메시지가 복수 규칙에 따라 변경되어야하는 기준으로 숫자 값으로 평가되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="73eb7dfae55511c85ac87046d8ad655d3b07d514" translate="yes" xml:space="preserve">
          <source>History state object that was before it was changed.</source>
          <target state="translated">변경되기 이전의 히스토리 상태 오브젝트.</target>
        </trans-unit>
        <trans-unit id="b5c1c159a3e483ad357e69c27c87a0816f3f5eba" translate="yes" xml:space="preserve">
          <source>Holds the list of modules which the injector will load before the current module is loaded.</source>
          <target state="translated">현재 모듈이로드되기 전에 인젝터가로드 할 모듈 목록을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="c20a5f818418ae5d1d96d68d2a880b61a688edbd" translate="yes" xml:space="preserve">
          <source>How directives are compiled</source>
          <target state="translated">지시어 컴파일 방법</target>
        </trans-unit>
        <trans-unit id="b4be41c74e5a460177988dde73728bedd08a211a" translate="yes" xml:space="preserve">
          <source>How do I use animations in my own directives?</source>
          <target state="translated">내 지시문에서 애니메이션을 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="683b2a3eb2b6d989ff0fc60d2e062d97e39208a2" translate="yes" xml:space="preserve">
          <source>How does AngularJS support i18n/l10n?</source>
          <target state="translated">AngularJS는 i18n / l10n을 어떻게 지원합니까?</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="88ed97b08c81463ee06f53f3b6c1779c600aa1c6" translate="yes" xml:space="preserve">
          <source>How is the element transported?</source>
          <target state="translated">요소는 어떻게 운송됩니까?</target>
        </trans-unit>
        <trans-unit id="8faafbf047891a8907eb94c858a2397c59b48b6b" translate="yes" xml:space="preserve">
          <source>How is the morphing handled?</source>
          <target state="translated">모핑은 어떻게 처리됩니까?</target>
        </trans-unit>
        <trans-unit id="f0b1fc1ac088c2160c01191d7d56a0bae6f8e3aa" translate="yes" xml:space="preserve">
          <source>How text and attribute bindings work</source>
          <target state="translated">텍스트 및 속성 바인딩 작동 방식</target>
        </trans-unit>
        <trans-unit id="6348c07b83ad0bb6dae1ec6cd1b77c21662b9a62" translate="yes" xml:space="preserve">
          <source>How the Options are handled</source>
          <target state="translated">옵션 처리 방법</target>
        </trans-unit>
        <trans-unit id="2a6cb3a378b1a04b05ce40f114a5850c30af8933" translate="yes" xml:space="preserve">
          <source>How the string representation is computed</source>
          <target state="translated">문자열 표현이 계산되는 방법</target>
        </trans-unit>
        <trans-unit id="4aa425ac030122afe10e7f53638d920844d71819" translate="yes" xml:space="preserve">
          <source>How they work</source>
          <target state="translated">작동 방식</target>
        </trans-unit>
        <trans-unit id="6e13b2dba241833a9f148d24533b2b4f0e74bb53" translate="yes" xml:space="preserve">
          <source>How to (selectively) enable, disable and skip animations</source>
          <target state="translated">애니메이션을 (선택적으로) 활성화, 비활성화 및 건너 뛰는 방법</target>
        </trans-unit>
        <trans-unit id="a25fb8be7987e971198c72036edd9325e925e49a" translate="yes" xml:space="preserve">
          <source>How to benefit from one-time binding</source>
          <target state="translated">일회성 바인딩의 이점</target>
        </trans-unit>
        <trans-unit id="cd8d1af145e22f4071b3803ea34db2257342448d" translate="yes" xml:space="preserve">
          <source>How to use decorators</source>
          <target state="translated">데코레이터 사용법</target>
        </trans-unit>
        <trans-unit id="c2a2f74412612724a85fc7c3904fcb3d54c23855" translate="yes" xml:space="preserve">
          <source>How would you ensure that every place that used these types of bindings was bound to a value that was sanitized by your library (or returned as safe for rendering by your server?) How can you ensure that you didn't accidentally delete the line that sanitized the value, or renamed some properties/fields and forgot to update the binding to the sanitized value?</source>
          <target state="translated">이러한 유형의 바인딩을 사용하는 모든 장소가 라이브러리에 의해 위생 처리 된 값 (또는 서버에서 렌더링하기에 안전한 것으로 리턴 된 값)에 바인드되도록하려면 어떻게해야합니까? 값을 삭제했거나 일부 속성 / 필드의 이름을 바꾸고 삭제 된 값으로 바인딩을 업데이트하는 것을 잊었습니까?</target>
        </trans-unit>
        <trans-unit id="69e8e5e39cfe987166eee61d96837365193ccc8b" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;isolated&lt;/code&gt; scope creates a new problem: if a transcluded DOM is a child of the widget isolated scope then it will not be able to bind to anything. For this reason the transcluded scope is a child of the original scope, before the widget created an isolated scope for its local variables. This makes the transcluded and widget isolated scope siblings.</source>
          <target state="translated">그러나 &lt;code&gt;isolated&lt;/code&gt; 범위는 새로운 문제를 만듭니다. 만약 포함 된 DOM이 위젯 격리 된 범위의 자식이라면 어떤 것도 바인딩 할 수 없습니다. 이러한 이유로 위젯이 로컬 변수에 대해 분리 된 범위를 작성하기 전에 변환 된 범위는 원래 범위의 하위입니다. 이것은 transcluded 및 widget isolated scope 형제를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="60975c6582a2823450029e613dcd8a25e14ebad5" translate="yes" xml:space="preserve">
          <source>However it's more likely that you'll just use &lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp&lt;/a&gt; or &lt;a href=&quot;angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt; to simplify this process for you.</source>
          <target state="translated">그러나 &lt;a href=&quot;../directive/ngapp&quot;&gt;ngApp&lt;/a&gt; 또는 &lt;a href=&quot;angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; &lt;/a&gt; 을 사용하여이 프로세스를 단순화 할 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="999f598a92635af8c6759e6c95a25535ddb1aa15" translate="yes" xml:space="preserve">
          <source>However this method will not work with JavaScript minifiers/obfuscators because of how they rename parameters.</source>
          <target state="translated">그러나이 방법은 매개 변수의 이름을 바꾸는 방식 때문에 JavaScript 축소 기 / 난독 처리기와 함께 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74b78a2717429ba3b6055f58ec7371c056ceb4fc" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements&quot;&gt;custom elements&lt;/a&gt; often use custom properties to hold data, and &lt;code&gt;ngProp&lt;/code&gt; can be used to provide input to these custom elements.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/Web_Components/Using_custom_elements&quot;&gt;사용자 정의 요소는&lt;/a&gt; 종종 사용자 정의 특성을 사용하여 데이터를 보유하며 &lt;code&gt;ngProp&lt;/code&gt; 을 사용하여 이러한 사용자 정의 요소에 입력을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c6bf585a28c6122be3e1b01347c02c5c70bc897" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;step&lt;/code&gt; is currently only fully implemented by Firefox. Other browsers have problems when the step value changes dynamically - they do not adjust the element value correctly, but instead may set the &lt;code&gt;stepMismatch&lt;/code&gt; error. If that's the case, the AngularJS will set the &lt;code&gt;step&lt;/code&gt; error on the input, and set the model to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;step&lt;/code&gt; 는 현재 Firefox에서만 완전히 구현됩니다. 다른 브라우저는 단계 값이 동적으로 변경 될 때 문제가 있습니다. 요소 값을 올바르게 조정하지 않고 대신 &lt;code&gt;stepMismatch&lt;/code&gt; 오류를 설정할 수 있습니다 . 이 경우 AngularJS는 입력에 &lt;code&gt;step&lt;/code&gt; 오류를 설정하고 모델을 &lt;code&gt;undefined&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="9ef1218d8c362088f0bcdd7920f20b4f50be4419" translate="yes" xml:space="preserve">
          <source>However, if the method is used programmatically, for example by adding dynamically created controls, or controls that have been previously removed without destroying their corresponding DOM element, it's the developers responsibility to make sure the current state propagates to the parent form.</source>
          <target state="translated">그러나 동적으로 생성 된 컨트롤 또는 해당 DOM 요소를 손상시키지 않고 이전에 제거 된 컨트롤을 추가하는 등의 방법으로 프로그래밍 방식으로 사용되는 경우 현재 상태가 부모 폼으로 전파되도록하는 것은 개발자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="7833f0d3d950db315e3b6d2099d681792715c7c0" translate="yes" xml:space="preserve">
          <source>However, including generic messages may not be useful enough to match all input fields, therefore, &lt;code&gt;ngMessages&lt;/code&gt; provides the ability to override messages defined in the remote template by redefining them within the directive container.</source>
          <target state="translated">그러나 일반 메시지를 포함하면 모든 입력 필드를 일치시키기에 충분히 유용하지 않을 수 있으므로 &lt;code&gt;ngMessages&lt;/code&gt; 는 지시문 컨테이너 내에서 메시지를 재정 의하여 원격 템플릿에 정의 된 메시지를 재정의하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="877ce4a445ea5e831a4f4c27b0f0efa155233b3c" translate="yes" xml:space="preserve">
          <source>However, the declarative language is also limited, as it does not allow you to teach the browser new syntax. For example, there is no easy way to get the browser to align the text at 1/3 the position instead of 1/2. What is needed is a way to teach the browser new HTML syntax.</source>
          <target state="translated">그러나, 선언 언어는 브라우저에 새로운 구문을 가르 칠 수 없기 때문에 제한적입니다. 예를 들어, 브라우저가 텍스트를 1/2 대신 1/3 위치에 맞추도록하는 쉬운 방법은 없습니다. 브라우저에 새로운 HTML 구문을 가르치는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3c9c0adee926699e18a27b00b88771ce6b3e9fc7" translate="yes" xml:space="preserve">
          <source>However, the more traditional CommonJS-style usage is still available, and documented below.</source>
          <target state="translated">그러나보다 일반적인 CommonJS 스타일 사용법은 여전히 ​​사용 가능하며 아래에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="00996f9232afaff711c6ebfe08928b5cfb6f6845" translate="yes" xml:space="preserve">
          <source>However, there are a few limitations compared to array iteration:</source>
          <target state="translated">그러나 배열 반복과 비교하여 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9641eba78bfe582ed3a2749197725f94c33dd851" translate="yes" xml:space="preserve">
          <source>Html-linkified and &lt;a href=&quot;../service/%24sanitize&quot;&gt;sanitized&lt;/a&gt; text.</source>
          <target state="translated">HTML 연결 및 &lt;a href=&quot;../service/%24sanitize&quot;&gt;위생 처리 된&lt;/a&gt; 텍스트</target>
        </trans-unit>
        <trans-unit id="c65236654eb6a81fbfab2170b0857f54bfc87642" translate="yes" xml:space="preserve">
          <source>I'm in a hurry. How do I get a Hello World module working?</source>
          <target state="translated">나는 서둘러 해요. Hello World 모듈을 작동 시키려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="28163d85350de7d518abda78cb07443850692d4d" translate="yes" xml:space="preserve">
          <source>I.e. &lt;code&gt;ng-model-options=&quot;{ debounce: 500 }&quot;&lt;/code&gt; will wait for half a second since the last content change before triggering the model update and form validation.</source>
          <target state="translated">즉, &lt;code&gt;ng-model-options=&quot;{ debounce: 500 }&quot;&lt;/code&gt; 은 마지막 업데이트 이후 0.5 초 동안 기다렸다가 모델 업데이트 및 양식 유효성 검사를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9ede6c3f478034a42df63b47c4dc0ad321990f8a" translate="yes" xml:space="preserve">
          <source>I.e. &lt;code&gt;ng-model-options=&quot;{ updateOn: 'default blur' }&quot;&lt;/code&gt;</source>
          <target state="translated">즉 &lt;code&gt;ng-model-options=&quot;{ updateOn: 'default blur' }&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4129e8cbc1ebb2a2fb072b2b3daaef96575a5cc8" translate="yes" xml:space="preserve">
          <source>I.e. &lt;code&gt;ng-model-options=&quot;{ updateOn: 'default blur', debounce: { default: 500, blur: 0 } }&quot;&lt;/code&gt;</source>
          <target state="translated">즉 &lt;code&gt;ng-model-options=&quot;{ updateOn: 'default blur', debounce: { default: 500, blur: 0 } }&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9072e6f660aab84e10c71086d8bd8d9d0e39518a" translate="yes" xml:space="preserve">
          <source>IE9 and other browsers that do not support the &lt;code&gt;range&lt;/code&gt; type fall back to a text input without any default values for &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;step&lt;/code&gt;. Model binding, validation and number parsing are nevertheless supported.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 유형을 지원하지 않는 IE9 및 기타 브라우저는 &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; 및 &lt;code&gt;step&lt;/code&gt; 에 대한 기본값없이 텍스트 입력으로 돌아갑니다 . 그럼에도 불구하고 모델 바인딩, 유효성 검사 및 번호 구문 분석이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a68fa8efe4a09d8c0c63ae60426d9366434bccb2" translate="yes" xml:space="preserve">
          <source>IRC</source>
          <target state="translated">IRC</target>
        </trans-unit>
        <trans-unit id="d7b1a1f2be81b4fe52f63eaaeeb40a859c845e0f" translate="yes" xml:space="preserve">
          <source>Id for the &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; ID입니다 .</target>
        </trans-unit>
        <trans-unit id="ec130e4d2cb91fe9bf063ea20a216bdcc71a84d6" translate="yes" xml:space="preserve">
          <source>Id of the key-value pair to delete.</source>
          <target state="translated">삭제할 키-값 쌍의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="7db857bacad045bd1f61b8fda21770e9d10e3b24" translate="yes" xml:space="preserve">
          <source>Id to use for lookup.</source>
          <target state="translated">조회에 사용할 ID입니다.</target>
        </trans-unit>
        <trans-unit id="4f2fb5d7f9da16cbc1d14fa704825b095fc9c79b" translate="yes" xml:space="preserve">
          <source>Identifier name for a reference to the controller in the directive's scope. This allows the controller to be referenced from the directive template. This is especially useful when a directive is used as component, i.e. with an &lt;code&gt;isolate&lt;/code&gt; scope. It's also possible to use it in a directive without an &lt;code&gt;isolate&lt;/code&gt; / &lt;code&gt;new&lt;/code&gt; scope, but you need to be aware that the &lt;code&gt;controllerAs&lt;/code&gt; reference might overwrite a property that already exists on the parent scope.</source>
          <target state="translated">지시문 범위에서 컨트롤러에 대한 참조의 식별자 이름입니다. 이를 통해 지시문 템플릿에서 컨트롤러를 참조 할 수 있습니다. 이것은 지시어가 구성 요소로 사용될 때, 즉 &lt;code&gt;isolate&lt;/code&gt; 범위 와 함께 특히 유용합니다 . &lt;code&gt;isolate&lt;/code&gt; / &lt;code&gt;new&lt;/code&gt; 범위 없이 지시문에서 사용할 수도 있지만 &lt;code&gt;controllerAs&lt;/code&gt; 참조가 부모 범위에 이미 존재하는 속성을 덮어 쓸 수 있다는 점에 유의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="79983926c885cfae871f9f76c7c14c825447c715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode.rewriteLinks&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; in the &lt;code&gt;mode&lt;/code&gt; configuration object passed to &lt;code&gt;$locationProvider.html5Mode()&lt;/code&gt;, the browser will perform a full page reload for every link. &lt;code&gt;mode.rewriteLinks&lt;/code&gt; can also be set to a string, which will enable link rewriting only on anchor elements that have the given attribute.</source>
          <target state="translated">경우 &lt;code&gt;mode.rewriteLinks&lt;/code&gt; 가 설정되어 &lt;code&gt;false&lt;/code&gt; 의 &lt;code&gt;mode&lt;/code&gt; 에 전달 구성 개체 &lt;code&gt;$locationProvider.html5Mode()&lt;/code&gt; , 브라우저는 모든 링크에 대한 전체 페이지를 다시로드를 수행합니다. &lt;code&gt;mode.rewriteLinks&lt;/code&gt; 는 문자열로 설정 될 수 있으며, 주어진 속성을 가진 앵커 요소에서만 링크 재 작성이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="613bfcabdb198dcf4290d1a13f26a43dcfef57c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ng-click&lt;/code&gt; or &lt;code&gt;ng-dblclick&lt;/code&gt; is encountered, ngAria will add &lt;code&gt;tabindex=&quot;0&quot;&lt;/code&gt; to any element not in a node blacklist: &lt;em&gt; Button &lt;/em&gt; Anchor &lt;em&gt; Input &lt;/em&gt; Textarea &lt;em&gt; Select &lt;/em&gt; Details/Summary To fix widespread accessibility problems with &lt;code&gt;ng-click&lt;/code&gt; on &lt;code&gt;div&lt;/code&gt; elements, ngAria will dynamically bind a keypress event by default as long as the element isn't in the node blacklist. You can turn this functionality on or off with the &lt;code&gt;bindKeypress&lt;/code&gt; configuration option. ngAria will also add the &lt;code&gt;button&lt;/code&gt; role to communicate to users of assistive technologies. This can be disabled with the &lt;code&gt;bindRoleForClick&lt;/code&gt; configuration option. For &lt;code&gt;ng-dblclick&lt;/code&gt;, you must still manually add &lt;code&gt;ng-keypress&lt;/code&gt; and a role to non-interactive elements such as &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;taco-button&lt;/code&gt; to enable keyboard access.</source>
          <target state="translated">경우 &lt;code&gt;ng-click&lt;/code&gt; 또는 &lt;code&gt;ng-dblclick&lt;/code&gt; 발생, ngAria 추가됩니다 &lt;code&gt;tabindex=&quot;0&quot;&lt;/code&gt; 이 아닌 노드 블랙리스트의 모든 요소 : &lt;em&gt;버튼&lt;/em&gt; 앵커 &lt;em&gt;입력&lt;/em&gt; 텍스트 영역 &lt;em&gt;을 선택&lt;/em&gt; 세부 사항 / 요약과 광범위한 접근성 문제를 해결하려면 &lt;code&gt;ng-click&lt;/code&gt; 에 &lt;code&gt;div&lt;/code&gt; 요소 ngAria을 요소가 노드 블랙리스트에없는 한 기본적으로 키 누르기 이벤트를 동적으로 바인딩합니다. &lt;code&gt;bindKeypress&lt;/code&gt; 구성 옵션을 사용하여이 기능을 켜거나 끌 수 있습니다 . 또한 ngAria는 보조 기술 사용자에게 알리기 위해 &lt;code&gt;button&lt;/code&gt; 역할을 추가 할 것 입니다. &lt;code&gt;bindRoleForClick&lt;/code&gt; 으로 비활성화 할 수 있습니다.구성 옵션. 들어 &lt;code&gt;ng-dblclick&lt;/code&gt; , 당신은 수동으로 추가해야합니다 &lt;code&gt;ng-keypress&lt;/code&gt; 와 같은 비 대화 형 요소에 역할 &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;taco-button&lt;/code&gt; 키보드 액세스를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="60f9ef56696025d8f02f54a53f118da87247ee51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ng-click&lt;/code&gt; or &lt;code&gt;ng-dblclick&lt;/code&gt; is encountered, ngAria will add &lt;code&gt;tabindex=&quot;0&quot;&lt;/code&gt; to any element not in the list of built in aria nodes: &lt;em&gt; Button &lt;/em&gt; Anchor &lt;em&gt; Input &lt;/em&gt; Textarea &lt;em&gt; Select &lt;/em&gt; Details/Summary To fix widespread accessibility problems with &lt;code&gt;ng-click&lt;/code&gt; on &lt;code&gt;div&lt;/code&gt; elements, ngAria will dynamically bind a keypress event by default as long as the element isn't in a node from the list of built in aria nodes. You can turn this functionality on or off with the &lt;code&gt;bindKeypress&lt;/code&gt; configuration option. ngAria will also add the &lt;code&gt;button&lt;/code&gt; role to communicate to users of assistive technologies. This can be disabled with the &lt;code&gt;bindRoleForClick&lt;/code&gt; configuration option. For &lt;code&gt;ng-dblclick&lt;/code&gt;, you must still manually add &lt;code&gt;ng-keypress&lt;/code&gt; and a role to non-interactive elements such as &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;taco-button&lt;/code&gt; to enable keyboard access.</source>
          <target state="translated">경우 &lt;code&gt;ng-click&lt;/code&gt; 또는 &lt;code&gt;ng-dblclick&lt;/code&gt; 발생, ngAria이 추가됩니다 &lt;code&gt;tabindex=&quot;0&quot;&lt;/code&gt; 하지 아리아 노드 내장의 목록에있는 모든 요소 : &lt;em&gt;버튼&lt;/em&gt; 앵커 &lt;em&gt;입력&lt;/em&gt; 텍스트 영역 &lt;em&gt;을 선택&lt;/em&gt; 세부 사항 / 요약과 광범위한 접근성 문제를 해결하려면 &lt;code&gt;ng-click&lt;/code&gt; 에 &lt;code&gt;div&lt;/code&gt; 요소, ngAria는 요소가 내장 된 aria 노드 목록의 노드에없는 한 기본적으로 키 누르기 이벤트를 동적으로 바인딩합니다. &lt;code&gt;bindKeypress&lt;/code&gt; 구성 옵션을 사용하여이 기능을 켜거나 끌 수 있습니다 . ngAria는 또한 &lt;code&gt;button&lt;/code&gt; 추가 합니다보조 기술 사용자와 소통하는 역할. &lt;code&gt;bindRoleForClick&lt;/code&gt; 구성 옵션 으로 비활성화 할 수 있습니다 . 들어 &lt;code&gt;ng-dblclick&lt;/code&gt; , 당신은 수동으로 추가해야합니다 &lt;code&gt;ng-keypress&lt;/code&gt; 와 같은 비 대화 형 요소에 역할 &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;taco-button&lt;/code&gt; 키보드 액세스를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="c95cf37a17f0d52871a2a1d59d4540b01148df2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ngTrim&lt;/code&gt; is set to &lt;code&gt;&quot;false&quot;&lt;/code&gt; then whitespace around both the separator and each list item is respected. This implies that the user of the directive is responsible for dealing with whitespace but also allows you to use whitespace as a delimiter, such as a tab or newline character.</source>
          <target state="translated">경우 &lt;code&gt;ngTrim&lt;/code&gt; 가 설정되는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 후 세퍼레이터와 각 목록 항목 존중 모두 주위의 공백. 이는 지시문의 사용자가 공백을 처리 할 책임이 있지만 탭이나 줄 바꿈 문자와 같은 구분 기호로 공백을 사용할 수도 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0829e8f931b8f25cd2b158be8e0b6def23ee7c6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;paramValue&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the property specified via the first argument will be deleted.</source>
          <target state="translated">&lt;code&gt;paramValue&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 첫 번째 인수를 통해 지정된 속성이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5b3c116b7e282c2308f6ef1608442867791f58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;paramValue&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the property specified via the first argument will be added with no value nor trailing equal sign.</source>
          <target state="translated">&lt;code&gt;paramValue&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우 첫 번째 인수를 통해 지정된 속성은 값이나 후행 등호없이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5f8a14370aff7380ce331b7293fef1918515ff58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;paramValue&lt;/code&gt; is an array, it will override the property of the &lt;code&gt;search&lt;/code&gt; component of &lt;code&gt;$location&lt;/code&gt; specified via the first argument.</source>
          <target state="translated">경우 &lt;code&gt;paramValue&lt;/code&gt; 이 배열은, 그것의 재산보다 우선합니다 &lt;code&gt;search&lt;/code&gt; 의 구성 요소 &lt;code&gt;$location&lt;/code&gt; 첫 번째 인수를 통해 지정합니다.</target>
        </trans-unit>
        <trans-unit id="743650dbdbf5002c9eecb5f7379f1f0d2090bf89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;redirectTo&lt;/code&gt; is a function, it will be called with the following parameters:</source>
          <target state="translated">경우 &lt;code&gt;redirectTo&lt;/code&gt; 이 기능은, 그것은 다음과 같은 매개 변수로 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="777d9335c56dfe211081978a0fbb3906b4202502" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;search&lt;/code&gt; is a string or number, then &lt;code&gt;paramValue&lt;/code&gt; will override only a single search property.</source>
          <target state="translated">경우 &lt;code&gt;search&lt;/code&gt; 문자열이나 숫자가, 다음 &lt;code&gt;paramValue&lt;/code&gt; 는 단 하나의 검색 속성을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="8201c46ffa0db4f644f5e56359950eb7fb2a8045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is identical to &lt;code&gt;destination&lt;/code&gt; an exception will be thrown.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 가 &lt;code&gt;destination&lt;/code&gt; 과 동일한 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ed2725402e420ab1c414cd2715251710a33f8e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; is not an object or array (inc. &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;), &lt;code&gt;source&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 가 객체 또는 배열이 아닌 경우 ( &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 포함 ) &lt;code&gt;source&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a624c93008a0a64091b974be67c1370e20df5fd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;template&lt;/code&gt; is a function, it will be called with the following parameters:</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 경우 기능은, 그것은 다음과 같은 매개 변수로 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="9f1b3360d3b66afd04318f5feac73437fb4929da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;template&lt;/code&gt; is a function, then it is &lt;a href=&quot;../../auto/service/%24injector#invoke.html&quot;&gt;injected&lt;/a&gt; with the following locals:</source>
          <target state="translated">경우 &lt;code&gt;template&lt;/code&gt; 함수이고, 그것은된다 &lt;a href=&quot;../../auto/service/%24injector#invoke.html&quot;&gt;주입&lt;/a&gt; 다음의 주민들과 :</target>
        </trans-unit>
        <trans-unit id="b743c62930c10b8e90047d6d33a622a656d9a6ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;templateUrl&lt;/code&gt; is a function, it will be called with the following parameters:</source>
          <target state="translated">&lt;code&gt;templateUrl&lt;/code&gt; 인 경우 기능은, 그것은 다음과 같은 매개 변수로 호출됩니다 :</target>
        </trans-unit>
        <trans-unit id="33c8b5674d0af42566982cc240093a252e34747e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;templateUrl&lt;/code&gt; is a function, then it is &lt;a href=&quot;../../auto/service/%24injector#invoke.html&quot;&gt;injected&lt;/a&gt; with the following locals:</source>
          <target state="translated">경우 &lt;code&gt;templateUrl&lt;/code&gt; 는 함수이고, 그것은된다 &lt;a href=&quot;../../auto/service/%24injector#invoke.html&quot;&gt;주입&lt;/a&gt; 다음의 주민들과 :</target>
        </trans-unit>
        <trans-unit id="72f42dc0c99690482b2dac1ed67fcce01c622d32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, reverse the sorting order.</source>
          <target state="translated">만약 &lt;code&gt;true&lt;/code&gt; 인 정렬 순서를 반대로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="e5e1755ef85cb15eebe562cc36b63807bafca0ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;window.name&lt;/code&gt; contains prefix &lt;code&gt;NG_DEFER_BOOTSTRAP!&lt;/code&gt; when &lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt;&lt;code&gt;angular.bootstrap&lt;/code&gt;&lt;/a&gt; is called, the bootstrap process will be paused until &lt;code&gt;angular.resumeBootstrap()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;window.name&lt;/code&gt; 에 접두사 &lt;code&gt;NG_DEFER_BOOTSTRAP!&lt;/code&gt; 가 포함 된 경우 ! 때 &lt;a href=&quot;../api/ng/function/angular.bootstrap&quot;&gt; &lt;code&gt;angular.bootstrap&lt;/code&gt; 이&lt;/a&gt; 라고하며, 부트 스트랩 과정이 될 때까지 일시 중지됩니다 &lt;code&gt;angular.resumeBootstrap()&lt;/code&gt; 불린다.</target>
        </trans-unit>
        <trans-unit id="a7fff279b5c9622029c122de3c8da07fa6ebeda1" translate="yes" xml:space="preserve">
          <source>If V is not undefined, mark the result of the expression as stable and schedule a task to deregister the watch for this expression when we exit the digest loop</source>
          <target state="translated">V가 정의되지 않은 경우 표현식 결과를 안정적으로 표시하고 다이제스트 루프를 종료 할 때이 표현식에 대한 시계의 등록을 취소하는 작업을 예약하십시오.</target>
        </trans-unit>
        <trans-unit id="345464413875ecc47aaed72ea3eeb05292b2706f" translate="yes" xml:space="preserve">
          <source>If XSRF prefix is detected, strip it (see &lt;a href=&quot;../service/%24http#security-considerations.html&quot;&gt;Security Considerations in the $http docs&lt;/a&gt;).</source>
          <target state="translated">XSRF 접두사가 감지되면 제거하십시오 ( &lt;a href=&quot;../service/%24http#security-considerations.html&quot;&gt;$ http 문서의 보안 고려 사항&lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="99e0d1f20619d41f43e4adbe88a0fc055defdf60" translate="yes" xml:space="preserve">
          <source>If XSRF prefix is detected, strip it (see Security Considerations section below).</source>
          <target state="translated">XSRF 접두사가 감지되면 제거하십시오 (아래 보안 고려 사항 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="52b7eeb7ca086390168cbaa4c3ea07248c32233b" translate="yes" xml:space="preserve">
          <source>If a custom comparator still can't distinguish between two items, then they will be sorted based on their index using the built-in comparator.</source>
          <target state="translated">사용자 지정 비교기가 여전히 두 항목을 구별 할 수없는 경우 내장 비교기를 사용하여 색인을 기준으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="022ac35ee6ebafd19f7c4c717fbf1ccf2712e7bc" translate="yes" xml:space="preserve">
          <source>If a destination is provided, all of its elements (for arrays) or properties (for objects) are deleted and then all elements/properties from the source are copied to it.</source>
          <target state="translated">대상이 제공되면 모든 해당 요소 (배열 용) 또는 속성 (객체 용)이 삭제되고 소스의 모든 요소 / 속성이 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="502bbbf8d84c6abdf7c8fd468936fe84d3df6d5a" translate="yes" xml:space="preserve">
          <source>If a form has only one input field then hitting enter in this field triggers form submit (&lt;code&gt;ngSubmit&lt;/code&gt;)</source>
          <target state="translated">양식에 입력 필드가 하나만 있으면이 필드에서 Enter 키를 누르면 양식 제출 ( &lt;code&gt;ngSubmit&lt;/code&gt; )을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="adb660bb29eb456fd541995beb9da63bcee77be2" translate="yes" xml:space="preserve">
          <source>If a function has an &lt;code&gt;$inject&lt;/code&gt; property and its value is an array of strings, then the strings represent names of services to be injected into the function.</source>
          <target state="translated">함수에 &lt;code&gt;$inject&lt;/code&gt; 속성이 있고 해당 값이 문자열 배열 인 경우 문자열은 함수에 주입 할 서비스 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd412985992305562d7e70ff27e4c810956645c3" translate="yes" xml:space="preserve">
          <source>If a module has already been loaded into the injector then it will not be loaded again.</source>
          <target state="translated">모듈이 인젝터에 이미로드 된 경우 다시로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26dc0654df6e7e0d396bfd5ad28c4b667f98d931" translate="yes" xml:space="preserve">
          <source>If a parent scope is suspended then all its descendants will be also excluded from future digests whether or not they have been suspended themselves. Note that this also applies to isolate child scopes.</source>
          <target state="translated">부모 범위가 일시 중단되면 모든 하위 항목도 자체 일시 중단 여부에 관계없이 향후 다이제스트에서 제외됩니다. 이는 하위 범위를 분리하는데도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f325902be8527e0c6ea4b6c889b0905040354cc2" translate="yes" xml:space="preserve">
          <source>If a request didn't match any expectation or if the expectation doesn't have the response defined, the backend definitions are evaluated in sequential order to see if any of them match the request. The response from the first matched definition is returned.</source>
          <target state="translated">요청이 예상과 일치하지 않거나 기대에 응답이 정의되어 있지 않으면 백엔드 정의가 순차적으로 평가되어 요청과 일치하는지 확인합니다. 일치하는 첫 번째 정의의 응답이 리턴됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
