<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="0ff7dd14bddbf16872e847e94eba176ae439d7f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt; and &lt;code&gt;!is&lt;/code&gt; Operators</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 와 &lt;code&gt;!is&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="d8c935a2340adaa853030be371e651ee624f1fbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isDaemon&lt;/code&gt; - if &lt;code&gt;true&lt;/code&gt;, the thread is created as a daemon thread. The Java Virtual Machine exits when the only threads running are all daemon threads.</source>
          <target state="translated">&lt;code&gt;isDaemon&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 의 경우, thread는 데몬 스레드로서 작성됩니다 실행중인 스레드가 모두 디먼 스레드 인 경우 Java 가상 머신이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="681c744b4f800b84baa915faeffc9ff5bd83c80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isNullOrEmpty&lt;/code&gt; and &lt;code&gt;orEmpty&lt;/code&gt; extensions for some types are already present in stdlib . The first one returns &lt;code&gt;true&lt;/code&gt; if the receiver is &lt;code&gt;null&lt;/code&gt; or empty, and the second one falls back to an empty instance if the receiver is &lt;code&gt;null&lt;/code&gt;. Kotlin 1.3 provides similar extensions on collections, maps, and arrays of objects.</source>
          <target state="translated">&lt;code&gt;isNullOrEmpty&lt;/code&gt; 일부 유형의 isNullOrEmpty 및 &lt;code&gt;orEmpty&lt;/code&gt; 확장자는 이미 stdlib에 있습니다. 첫 번째 반환 &lt;code&gt;true&lt;/code&gt; 수신기가있는 경우 &lt;code&gt;null&lt;/code&gt; 또는 빈은, 수신기 인 경우 두 번째는 빈 인스턴스에 다시 떨어질 &lt;code&gt;null&lt;/code&gt; . Kotlin 1.3은 컬렉션, 맵 및 객체 배열에서 비슷한 확장을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="de90a696bcf57b1bcc31ff52baec77b7d9b7ca59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;it&lt;/code&gt; is used inside a lambda to &lt;a href=&quot;lambdas#it-implicit-name-of-a-single-parameter&quot;&gt;refer to its parameter implicitly&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;it&lt;/code&gt; 람다 내부에 사용되는 &lt;a href=&quot;lambdas#it-implicit-name-of-a-single-parameter&quot;&gt;내재적 파라미터 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4aa50b82a0b8e0f99fc4186e17e98ebb7ffcf4b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;it&lt;/code&gt;: implicit name of a single parameter</source>
          <target state="translated">&lt;code&gt;it&lt;/code&gt; : 단일 매개 변수의 암시 적 이름</target>
        </trans-unit>
        <trans-unit id="ea358e1a14d266c00c6f85e11265be634997f6a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jar&lt;/code&gt; is disabled in favor of the target's JAR task (e.g. &lt;code&gt;jvmJar&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;jar&lt;/code&gt; 대상의 JAR 태스크 (예 : &lt;code&gt;jvmJar&lt;/code&gt; ) 를 위해 jar 을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8bd780c3978b00b5702c58c38c5608cf9ed18504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;javacArguments&lt;/code&gt;: A base64-encoded list of the options passed to javac. See &lt;a href=&quot;#apjavac-options-encoding&quot;&gt;AP/javac options encoding&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;javacArguments&lt;/code&gt; : javac에 전달 된 옵션의 base64 인코딩 목록. 자세한 정보는 &lt;a href=&quot;#apjavac-options-encoding&quot;&gt;AP / javac 옵션 인코딩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5bd2a62a78ed2b4ffde2081b0ff49dda401f06dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joinToString()&lt;/code&gt; builds a single &lt;code&gt;String&lt;/code&gt; from the collection elements based on the provided arguments. &lt;code&gt;joinTo()&lt;/code&gt; does the same but appends the result to the given &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/-appendable/index&quot;&gt;&lt;code&gt;Appendable&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;joinToString()&lt;/code&gt; 은 제공된 인수를 기반으로 컬렉션 요소에서 단일 &lt;code&gt;String&lt;/code&gt; 을 작성합니다 . &lt;code&gt;joinTo()&lt;/code&gt; 는 동일하지만 결과를 지정된 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/-appendable/index&quot;&gt; &lt;code&gt;Appendable&lt;/code&gt; &lt;/a&gt; 객체에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="5e909b15f139ff5459b0205107b17607f4dd7103" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;js&lt;/code&gt; for Kotlin/JS;</source>
          <target state="translated">&lt;code&gt;js&lt;/code&gt; Kotlin / JS의 경우 js ;</target>
        </trans-unit>
        <trans-unit id="a707686185435c5406cec7e4c975d9359b0bb8e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jvm&lt;/code&gt; for Kotlin/JVM;</source>
          <target state="translated">&lt;code&gt;jvm&lt;/code&gt; Kotlin / JVM의 경우 jvm ;</target>
        </trans-unit>
        <trans-unit id="f697848dc8081d2a2c7a75b05f373534bb55ea65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;k&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; can be called anything.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 는 무엇이든 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff8a7e682a2b1f9a53924e27c15255db032aee0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: the key of the group this element belongs to;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; :이 요소가 속한 그룹의 키;</target>
        </trans-unit>
        <trans-unit id="ab4e881f29e68e9958b0eb0f70abc3ff801b7cdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: the key of the group;</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; : 그룹의 키;</target>
        </trans-unit>
        <trans-unit id="de5c81d32b0741611c5078f9b42f2916b5a9c709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin-jslib&lt;/code&gt; in the compiler distribution: use &lt;code&gt;kotlin-stdlib-js&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;kotlin-jslib&lt;/code&gt; 컴파일러 배포판의 kotlin-jslib : 대신 &lt;code&gt;kotlin-stdlib-js&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d70bd93f4539e5ca0184e65414eafc07ece123a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin-platform-native&lt;/code&gt; reference</source>
          <target state="translated">&lt;code&gt;kotlin-platform-native&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="9edb4c87cf51275dfefa597af9b0ec6766a6898e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin-runtime&lt;/code&gt;: use &lt;code&gt;kotlin-stdlib&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;kotlin-runtime&lt;/code&gt; : 대신 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d6c09d23fd2e37aeadc2e4b51c6221e0848f2d22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin-stdlib-jre7/8&lt;/code&gt;: use &lt;code&gt;kotlin-stdlib-jdk7/8&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;kotlin-stdlib-jre7/8&lt;/code&gt; : 대신 &lt;code&gt;kotlin-stdlib-jdk7/8&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="c6d44a61ea419b1e0b9d2afc609d339b1b0b5e0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.Any&lt;/code&gt; is mapped to JavaScript Object (i.e. &lt;code&gt;new Object()&lt;/code&gt;, &lt;code&gt;{}&lt;/code&gt;, etc).</source>
          <target state="translated">&lt;code&gt;kotlin.Any&lt;/code&gt; 는 JavaScript 객체 (예 : &lt;code&gt;new Object()&lt;/code&gt; , &lt;code&gt;{}&lt;/code&gt; 등)에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ddfcf2a8a79ecd8653558e192f93462d3c18e00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.Array&lt;/code&gt; is mapped to JavaScript Array.</source>
          <target state="translated">&lt;code&gt;kotlin.Array&lt;/code&gt; 는 JavaScript Array에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="3f215bcad68b1060d49b48962f3879d3bb0e4f94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.BooleanArray&lt;/code&gt; is mapped to JavaScript Int8Array with a property &lt;code&gt;$type$ == &quot;BooleanArray&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kotlin.BooleanArray&lt;/code&gt; 는 &lt;code&gt;$type$ == &quot;BooleanArray&quot;&lt;/code&gt; 속성을 사용하여 JavaScript Int8Array에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="9a86c5dacfd9c6120320455c871be52e80b58d7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.ByteArray&lt;/code&gt;, &lt;code&gt;-.ShortArray&lt;/code&gt;, &lt;code&gt;-.IntArray&lt;/code&gt;, &lt;code&gt;-.FloatArray&lt;/code&gt;, and &lt;code&gt;-.DoubleArray&lt;/code&gt; are mapped to JavaScript Int8Array, Int16Array, Int32Array, Float32Array, and Float64Array correspondingly.</source>
          <target state="translated">&lt;code&gt;kotlin.ByteArray&lt;/code&gt; , &lt;code&gt;-.ShortArray&lt;/code&gt; , &lt;code&gt;-.IntArray&lt;/code&gt; , &lt;code&gt;-.FloatArray&lt;/code&gt; 및 &lt;code&gt;-.DoubleArray&lt;/code&gt; 는 각각 JavaScript Int8Array, Int16Array, Int32Array, Float32Array 및 Float64Array 에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd0be38735d6b975409c2f81bca2f630826f4b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.Char&lt;/code&gt; is mapped to JavaScript Number representing character code.</source>
          <target state="translated">&lt;code&gt;kotlin.Char&lt;/code&gt; 는 문자 코드를 나타내는 JavaScript 번호에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="cdcf3c9ad1d43abe08401cc671a2e77504e8aa9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.CharArray&lt;/code&gt; is mapped to JavaScript UInt16Array with a property &lt;code&gt;$type$ == &quot;CharArray&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kotlin.CharArray&lt;/code&gt; 는 &lt;code&gt;$type$ == &quot;CharArray&quot;&lt;/code&gt; 속성을 사용하여 JavaScript UInt16Array에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="51964479d0cc04679f9e087cb5cb10bd7104f508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.LongArray&lt;/code&gt; is mapped to JavaScript Array of &lt;code&gt;kotlin.Long&lt;/code&gt; with a property &lt;code&gt;$type$ == &quot;LongArray&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kotlin.LongArray&lt;/code&gt; 는 &lt;code&gt;$type$ == &quot;LongArray&quot;&lt;/code&gt; 속성을 가진 &lt;code&gt;kotlin.Long&lt;/code&gt; 의 JavaScript 배열에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="40b593eac371c795dff3c154373e95d3cdc2318b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.String&lt;/code&gt; is mapped to JavaScript String.</source>
          <target state="translated">&lt;code&gt;kotlin.String&lt;/code&gt; 은 JavaScript 문자열에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="659d48c3d2e9aebbcbdd04f2fd4373b7d80c0fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.Throwable&lt;/code&gt; is mapped to JavaScript Error.</source>
          <target state="translated">&lt;code&gt;kotlin.Throwable&lt;/code&gt; 은 JavaScript 오류에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="9fa8a2460cee8d76cd0b1e9ead686e66398c35dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.UByte&lt;/code&gt;: an unsigned 8-bit integer, ranges from 0 to 255</source>
          <target state="translated">&lt;code&gt;kotlin.UByte&lt;/code&gt; : 부호없는 8 비트 정수, 범위는 0 ~ 255입니다</target>
        </trans-unit>
        <trans-unit id="55ecdeee8026ceb1527dc5228dd9ee0242b1164d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.UByteArray&lt;/code&gt;: an array of unsigned bytes</source>
          <target state="translated">&lt;code&gt;kotlin.UByteArray&lt;/code&gt; : 부호없는 바이트의 배열</target>
        </trans-unit>
        <trans-unit id="fe542874cceb8c831a2c348b62fc8e197df5b4de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.UInt&lt;/code&gt;: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1</source>
          <target state="translated">&lt;code&gt;kotlin.UInt&lt;/code&gt; : 부호없는 32 비트 정수, 범위는 0에서 2 ^ 32-1입니다 .</target>
        </trans-unit>
        <trans-unit id="53b868f94ce2ff2483b575ec530e7d864c04a613" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.UIntArray&lt;/code&gt;: an array of unsigned ints</source>
          <target state="translated">&lt;code&gt;kotlin.UIntArray&lt;/code&gt; : 부호없는 정수의 배열</target>
        </trans-unit>
        <trans-unit id="b5300ade05ab7504b50adc690d42f105e4ee68ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.ULong&lt;/code&gt;: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1</source>
          <target state="translated">&lt;code&gt;kotlin.ULong&lt;/code&gt; : 부호없는 64 비트 정수, 범위는 0 ~ 2 ^ 64-1입니다 .</target>
        </trans-unit>
        <trans-unit id="c91f3dac68dab1ad0547ccd10cb5bb4bc9498943" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.ULongArray&lt;/code&gt;: an array of unsigned longs</source>
          <target state="translated">&lt;code&gt;kotlin.ULongArray&lt;/code&gt; : 부호없는 long 배열</target>
        </trans-unit>
        <trans-unit id="db5ab1fc15c468d60456a286e46502fad9c4578b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.UShort&lt;/code&gt;: an unsigned 16-bit integer, ranges from 0 to 65535</source>
          <target state="translated">&lt;code&gt;kotlin.UShort&lt;/code&gt; : 부호없는 16 비트 정수, 범위는 0 ~ 65535</target>
        </trans-unit>
        <trans-unit id="c762c7d7fdd2dfaf391c2acbcd2b5ab6356ab61c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.UShortArray&lt;/code&gt;: an array of unsigned shorts</source>
          <target state="translated">&lt;code&gt;kotlin.UShortArray&lt;/code&gt; : 부호없는 반바지 배열</target>
        </trans-unit>
        <trans-unit id="88d3da956578fff7d75545b50c7da3120d547a4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlin.js&lt;/code&gt;. The runtime and standard library. This doesn't change between applications. It's tied to the version of Kotlin being used.</source>
          <target state="translated">&lt;code&gt;kotlin.js&lt;/code&gt; . 런타임 및 표준 라이브러리. 응용 프로그램 간에는 변경되지 않습니다. 사용중인 Kotlin 버전과 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ea000a8effe62ea2560052e3aff3ee5917f015" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kotlinx.coroutines&lt;/code&gt; is a rich library for coroutines developed by JetBrains. It contains a number of high-level coroutine-enabled primitives that this guide covers, including &lt;code&gt;launch&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt; and others.</source>
          <target state="translated">&lt;code&gt;kotlinx.coroutines&lt;/code&gt; 는 JetBrains가 개발 한 코 루틴을위한 풍부한 라이브러리입니다. 여기에는 &lt;code&gt;launch&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; 등을 포함하여이 가이드에서 다루는 여러 가지 고급 코 루틴 지원 프리미티브가 포함 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f82fba44c63724ec2e93709793338db3d8e569f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lateinit&lt;/code&gt; allows initializing a &lt;a href=&quot;properties#late-initialized-properties-and-variables&quot;&gt;non-null property outside of a constructor&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;lateinit&lt;/code&gt; 를 사용 &lt;a href=&quot;properties#late-initialized-properties-and-variables&quot;&gt;하면 생성자 외부에서 null&lt;/a&gt; 이 아닌 속성을 초기화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5a0b3563766c38058ea4c77ba9ae974f57d2ee49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lateinit&lt;/code&gt; can only be used with &lt;code&gt;var&lt;/code&gt;, not with &lt;code&gt;val&lt;/code&gt;, and the type must be non-primitive and non-nullable.</source>
          <target state="translated">&lt;code&gt;lateinit&lt;/code&gt; 는 &lt;code&gt;val&lt;/code&gt; 이 아닌 &lt;code&gt;var&lt;/code&gt; 에만 사용할 수 있으며 유형은 기본이 아니며 널 입력 가능하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="47053d7865cd4d1362dd0fed3a07553e4bcf4bf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lateinit&lt;/code&gt; modifier;</source>
          <target state="translated">&lt;code&gt;lateinit&lt;/code&gt; 수정 자;</target>
        </trans-unit>
        <trans-unit id="59a5af96d0a80bd7bccbbc50ab23c1f600da2e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length&lt;/code&gt; - the desired string length.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; - 원하는 문자열 길이</target>
        </trans-unit>
        <trans-unit id="c5f67685e8fb85c57bbdc9d9d7db128bf5c55c6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length&lt;/code&gt; - the length of the portion of the array to read.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; - 읽을 배열 부분의 길이</target>
        </trans-unit>
        <trans-unit id="a123d5c22ab2a54bb2467057b241dc254d99292a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length&lt;/code&gt; - the length of the substring to compare.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; - 비교하는 문자열의 길이.</target>
        </trans-unit>
        <trans-unit id="d9cc168ae9309d396e193854fa2e497d466b8aa1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;length&lt;/code&gt; - the number of bytes to be converted.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; - 변환되는 바이트 수</target>
        </trans-unit>
        <trans-unit id="e551de8b7f6a686a65bd70d06d97e7a7c117cbbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; can be used to invoke one or more functions on results of call chains. For example, the following code prints the results of two operations on a collection:</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 호출 체인의 결과에 하나 개 이상의 함수를 호출하는 데 사용할 수 있습니다. 예를 들어 다음 코드는 컬렉션에 대한 두 작업의 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="fe705198c64b22461a258c472dd254519e542ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is often used for executing a code block only with non-null values. To perform actions on a non-null object, use the safe call operator &lt;code&gt;?.&lt;/code&gt; on it and call &lt;code&gt;let&lt;/code&gt; with the actions in its lambda.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 은 종종 null이 아닌 값으로 만 코드 블록을 실행하는 데 사용됩니다. 널이 아닌 오브젝트에서 조치를 수행하려면 세이프 콜 연산자 &lt;code&gt;?.&lt;/code&gt; 사용하십시오 . 그것에 람다의 행동으로 &lt;code&gt;let&lt;/code&gt; 을 불러라 .</target>
        </trans-unit>
        <trans-unit id="f39dab5586b77abb09839bb50cf60ada67479e37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, and &lt;code&gt;with&lt;/code&gt; return the lambda result.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , 및 &lt;code&gt;with&lt;/code&gt; 람다 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc178cbf3d417c488cd76dd0ba0df9c30201e6a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, and &lt;code&gt;with&lt;/code&gt; return the lambda result. So, you can use them when assigning the result to a variable, chaining operations on the result, and so on.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , 및 &lt;code&gt;with&lt;/code&gt; 람다 결과를 반환합니다. 따라서 결과를 변수에 할당하거나 결과에 대한 체인 작업 등을 수행 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6540140321404c7beb48cb8d41c1d076d0ad9902" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; - Specifies how the deprecated element usages are reported in code. See the &lt;a href=&quot;../-deprecation-level/index#kotlin.DeprecationLevel&quot;&gt;DeprecationLevel&lt;/a&gt; enum for the possible values.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; - 비추천 요소 용도가 코드에보고하는 방법을 지정합니다. 가능한 값 은 &lt;a href=&quot;../-deprecation-level/index#kotlin.DeprecationLevel&quot;&gt;DeprecationLevel&lt;/a&gt; 열거를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f52f5c62d7318037ef9d40f8fdaba593bc1b0344" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="208df0bf5d40aa3cae90380f2554f8371ca7e880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; - Non-negative value specifying the maximum number of substrings the string can be split to. Zero by default means no limit is set.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; - 문자열로 분할 될 수있는 문자열의 최대 개수를 지정하는 비 - 음의 값. 기본적으로 0은 제한이 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d06bb1e204b58f4ad96b54b0bcd05a20c0a7ddae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; - Non-negative value specifying the maximum number of substrings to return. Zero by default means no limit is set.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; - 반환 할 문자열의 최대 수를 지정하는 음수가 아닌 값입니다. 기본적으로 0은 제한이 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="185232970a0ccd48f8d36fc01a8b97c7d74a583f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; - The maximum number of substrings to return.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; - 반환 할 문자열의 최대 수입니다.</target>
        </trans-unit>
        <trans-unit id="996cb31faa7091a408533c92f1605440669d6c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linuxArm32Hfp&lt;/code&gt;, &lt;code&gt;linuxMips32&lt;/code&gt;, &lt;code&gt;linuxMipsel32&lt;/code&gt;, &lt;code&gt;linuxX64&lt;/code&gt; for Linux;</source>
          <target state="translated">&lt;code&gt;linuxArm32Hfp&lt;/code&gt; , &lt;code&gt;linuxMips32&lt;/code&gt; , &lt;code&gt;linuxMipsel32&lt;/code&gt; , Linux 용 &lt;code&gt;linuxX64&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="7eaf9b61690a4c5efc748e6664d0249c907fc836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln(+Inf)&lt;/code&gt; is &lt;code&gt;+Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln(+Inf)&lt;/code&gt; 는 &lt;code&gt;+Inf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="252e73347a18f8bb8350262b3bd9c8566aec27e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln(0.0)&lt;/code&gt; is &lt;code&gt;-Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln(0.0)&lt;/code&gt; 은 &lt;code&gt;-Inf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2593060e4a854271ebc6ff65b6483ed85aca28ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln(NaN)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln(NaN)&lt;/code&gt; 은 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="b8895ee0a78645b4b9c622865b5b229403169b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; when &lt;code&gt;x &amp;lt; 0.0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln(x)&lt;/code&gt; &lt;code&gt;x &amp;lt; 0.0&lt;/code&gt; 때 ln (x) 는 &lt;code&gt;NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d32e977cf0dd497316b051e4c5a4d1b8c1668dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln1p(+Inf)&lt;/code&gt; is &lt;code&gt;+Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln1p(+Inf)&lt;/code&gt; 는 &lt;code&gt;+Inf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="453056e570960655e4d47d15bb3b675fe54808db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln1p(-1.0)&lt;/code&gt; is &lt;code&gt;-Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln1p(-1.0)&lt;/code&gt; 은 &lt;code&gt;-Inf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b4702bf0ad629b7d81ff384b1a72af88f6eb0a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln1p(NaN)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln1p(NaN)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="3cc8921af2631a539159df90811cad409ebb4c73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ln1p(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; where &lt;code&gt;x &amp;lt; -1.0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ln1p(x)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 이며 여기서 &lt;code&gt;x &amp;lt; -1.0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f18babb62aef788b1e852582f82afe6752be400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadFactor&lt;/code&gt; - the load factor (ignored)</source>
          <target state="translated">&lt;code&gt;loadFactor&lt;/code&gt; - 로드 팩터 (무시)</target>
        </trans-unit>
        <trans-unit id="f0659f8f29af75053650a20bee7d9878080e5c9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log(+Inf, +Inf)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log(+Inf, +Inf)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="5f9fcf4db999d97d7d238b1872e876501b301349" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log(+Inf, b)&lt;/code&gt; is &lt;code&gt;+Inf&lt;/code&gt; for &lt;code&gt;b &amp;gt; 1&lt;/code&gt; and &lt;code&gt;-Inf&lt;/code&gt; for &lt;code&gt;b &amp;lt; 1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log(+Inf, b)&lt;/code&gt; 인 &lt;code&gt;+Inf&lt;/code&gt; 를 위한 &lt;code&gt;b &amp;gt; 1&lt;/code&gt; 및 &lt;code&gt;-Inf&lt;/code&gt; 대 &lt;code&gt;b &amp;lt; 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4d7205bbda0cca1f7fe9d0e18f4c91575924" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log(0.0, b)&lt;/code&gt; is &lt;code&gt;-Inf&lt;/code&gt; for &lt;code&gt;b &amp;gt; 1&lt;/code&gt; and &lt;code&gt;+Inf&lt;/code&gt; for &lt;code&gt;b &amp;gt; 1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log(0.0, b)&lt;/code&gt; 있다 &lt;code&gt;-Inf&lt;/code&gt; 대 &lt;code&gt;b &amp;gt; 1&lt;/code&gt; 과 &lt;code&gt;+Inf&lt;/code&gt; 를 위한 &lt;code&gt;b &amp;gt; 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9bf6a10920924469889cc579295db4bd6dabf9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log(x, b)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; if either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log(x, b)&lt;/code&gt; 있다 &lt;code&gt;NaN&lt;/code&gt; 이 어느 경우 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 있다 &lt;code&gt;NaN&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="48b7bfd0270001a14346785eb0b107e7ec23af52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log(x, b)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; when &lt;code&gt;x &amp;lt; 0&lt;/code&gt; or &lt;code&gt;b &amp;lt;= 0&lt;/code&gt; or &lt;code&gt;b == 1.0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log(x, b)&lt;/code&gt; &lt;code&gt;x &amp;lt; 0&lt;/code&gt; 또는 &lt;code&gt;b &amp;lt;= 0&lt;/code&gt; 또는 &lt;code&gt;b == 1.0&lt;/code&gt; 때 log (x, b) 는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e3a17174ddefa3c240ec9b5428c4a695f7b64287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macosX64&lt;/code&gt; for MacOS;</source>
          <target state="translated">&lt;code&gt;macosX64&lt;/code&gt; MacOS 용 macosX64 ;</target>
        </trans-unit>
        <trans-unit id="dbeb272e7f89ac7dac73c641f4be4499d4cd2be6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main([]);&lt;/code&gt;: a call of the &lt;code&gt;main&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;main([]);&lt;/code&gt; : &lt;code&gt;main&lt;/code&gt; 기능 의 호출 .</target>
        </trans-unit>
        <trans-unit id="e69612f279814b811d3fc6078abd9151f622c2b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;main&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; compilations for JVM, JS, and Native targets;</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; JVM, JS 및 기본 대상에 대한 기본 및 &lt;code&gt;test&lt;/code&gt; 컴파일;</target>
        </trans-unit>
        <trans-unit id="26bac2457d8e6e02f39f9164fa073d3d3cf2ae86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;marginPrefix&lt;/code&gt; - non-blank string, which is used as a margin delimiter. Default is &lt;code&gt;|&lt;/code&gt; (pipe character).</source>
          <target state="translated">&lt;code&gt;marginPrefix&lt;/code&gt; - 공백이 아닌 문자열로 여백 구분 기호로 사용됩니다. 기본값은 &lt;code&gt;|&lt;/code&gt; (파이프 캐릭터).</target>
        </trans-unit>
        <trans-unit id="a5727d9111c741b27f9daa6a06d7e82e1c4fd1e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mathContext&lt;/code&gt; - specifies the precision and the rounding mode.</source>
          <target state="translated">&lt;code&gt;mathContext&lt;/code&gt; - 정밀도와 반올림 모드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fd13b61c3a876d813b06d8d27211349f43668229" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; of two values;</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 두 값의 최대 및 &lt;code&gt;min&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="f38e78071ae592eb02eb59a9dd54350331d7e3b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxSpeed&lt;/code&gt; and &lt;code&gt;horsepowers&lt;/code&gt;, which are inherited from &lt;code&gt;MotorVehicle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;maxSpeed&lt;/code&gt; 및 &lt;code&gt;horsepowers&lt;/code&gt; 에서 상속, &lt;code&gt;MotorVehicle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0178aa57547ec9fda6f96912d87656568ceb8a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - The message explaining the deprecation and recommending an alternative API to use.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; - 메시지 사용 중단을 설명하고 사용할 대체 API를 추천.</target>
        </trans-unit>
        <trans-unit id="69954a17845ed686114d3646757964c5ce2b5f6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - the detail message string.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; - 상세 메세지 캐릭터 라인</target>
        </trans-unit>
        <trans-unit id="7aa3f56c6672dbd3162619f55c00a0fa601f3c1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mingwX64&lt;/code&gt; and &lt;code&gt;mingwX86&lt;/code&gt; for Windows;</source>
          <target state="translated">&lt;code&gt;mingwX64&lt;/code&gt; Windows 용 mingwX64 및 &lt;code&gt;mingwX86&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="267160ff261db7f19167c9dd54fea15141f714be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minus&lt;/code&gt; creates a &lt;code&gt;Map&lt;/code&gt; from entries of a &lt;code&gt;Map&lt;/code&gt; on the left except those with keys from the right-hand side operand. So, the right-hand side operand can be either a single key or a collection of keys: list, set, and so on.</source>
          <target state="translated">&lt;code&gt;minus&lt;/code&gt; 에서는 오른쪽 피연산자의 키가있는 항목을 제외하고 왼쪽 의 &lt;code&gt;Map&lt;/code&gt; 항목 에서 &lt;code&gt;Map&lt;/code&gt; 을 만듭니다 . 따라서 오른쪽 피연산자는 단일 키 또는 키 모음 (목록, 설정 등) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="988b67650cf5accf92fe098a86492ee65cfddc43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mod&lt;/code&gt; operator convention</source>
          <target state="translated">&lt;code&gt;mod&lt;/code&gt; 연산자 규칙</target>
        </trans-unit>
        <trans-unit id="4e5b5e36367f2b5720885e31db4553ac0624e9fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; - the name of the element.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; - 요소의 이름</target>
        </trans-unit>
        <trans-unit id="6235ae131413288e1ad1541828056ee77ac6f50c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; - the name of the thread.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; - 스레드의 이름을.</target>
        </trans-unit>
        <trans-unit id="56831cce1ac10281427a82b03d4a290f0b3e2091" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; - the name to use for the thread which is running the timer.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; - 이름이 타이머를 실행하는 스레드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7fefd14206e17fee67936f93d8bb7b6202585842" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; - the name which compiler uses both for declaration itself and for all references to the declaration. It's required to denote a valid JavaScript identifier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; - 컴파일러가 선언 자체 및 선언에 대한 모든 참조를 모두 사용하는 이름입니다. 유효한 JavaScript 식별자를 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc326db8cb5ff54bd2faea12c15dbece4695569" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;names&lt;/code&gt; - names of the compiler diagnostics to suppress.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; - 억제 할 컴파일러 진단의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ae0634b94bbd8a34abb02bec7888d9a010a2b264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new value&lt;/code&gt; &amp;mdash; must be of the same type as the property or its subtype.</source>
          <target state="translated">&lt;code&gt;new value&lt;/code&gt; -속성 또는 하위 유형과 유형이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="ace8d18319ba4a90a94060c1b1c435fd947d410b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; - the new value</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; - 새로운 가치</target>
        </trans-unit>
        <trans-unit id="3bcca1c2c4cfe6988423b94bdd43815e502e35b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nextUp&lt;/code&gt;, &lt;code&gt;nextDown&lt;/code&gt;, &lt;code&gt;nextTowards&lt;/code&gt; extension functions;</source>
          <target state="translated">&lt;code&gt;nextUp&lt;/code&gt; , &lt;code&gt;nextDown&lt;/code&gt; , &lt;code&gt;nextTowards&lt;/code&gt; 확장 기능;</target>
        </trans-unit>
        <trans-unit id="ed51d6e0299c2fb8e3d3bc33bcd5b22ef4fb4be1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noStringConversion&lt;/code&gt; property value is space-separated lists of the functions whose &lt;code&gt;const char*&lt;/code&gt; parameters shall not be autoconverted as Kotlin string</source>
          <target state="translated">&lt;code&gt;noStringConversion&lt;/code&gt; 속성 값은 &lt;code&gt;const char*&lt;/code&gt; 매개 변수를 Kotlin 문자열로 자동 변환하지 않는 함수로 공백으로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="05a0c8ff6a3c213a67a9ee469db4827fa63ce669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noinline&lt;/code&gt; turns off &lt;a href=&quot;inline-functions#noinline&quot;&gt;inlining of a lambda passed to an inline function&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;noinline&lt;/code&gt; 은 &lt;a href=&quot;inline-functions#noinline&quot;&gt;인라인 함수에 전달 된 람다의 인라인을&lt;/a&gt; 끕니다.</target>
        </trans-unit>
        <trans-unit id="36297d07fe34068128422f55af6a43def97f5318" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; is a constant representing an object reference that doesn't point to any object</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 은 객체를 가리 키지 않는 객체 참조를 나타내는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="1068fc03044320a95496c7fdf93f1a4da1b38f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt; value is considered to be less than any non-null value.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 은 널 이 아닌 값보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="334180cb811d90900ac4efec28ceda74c1452e33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;null&lt;/code&gt;-checks are disabled for such values.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 이러한 값에 대해서는 null -checks가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="15ba108e8fde1f1b4730082255c210938d1874dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; declares &lt;a href=&quot;object-declarations&quot;&gt;a class and its instance at the same time&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 는 &lt;a href=&quot;object-declarations&quot;&gt;클래스와 그 인스턴스를 동시에&lt;/a&gt; 선언 합니다</target>
        </trans-unit>
        <trans-unit id="f3a944d208de06158465d383160a1c8a51d2fecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; - the offset in the array of the data to be converted.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; - 변환 할 데이터 배열의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="8120bdf65433d32e076766e7ab1b7c3d1d03b966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; - the start offset of the portion of the array to read.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; - 읽을 배열 부분의 시작 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="fcbd11d6992f04df0a96f8e3d24ee5a62de8bece" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onChange&lt;/code&gt; - the callback which is called after the change of the property is made. The value of the property has already been changed when this callback is invoked.</source>
          <target state="translated">&lt;code&gt;onChange&lt;/code&gt; - 속성 변경 후 호출되는 콜백 이 콜백이 호출 될 때 속성 값이 이미 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="5bd8e7fd457a57ac8471e4aacebd37f1f3bba183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onChange&lt;/code&gt; - the callback which is called before a change to the property value is attempted. The value of the property hasn't been changed yet, when this callback is invoked. If the callback returns &lt;code&gt;true&lt;/code&gt; the value of the property is being set to the new value, and if the callback returns &lt;code&gt;false&lt;/code&gt; the new value is discarded and the property remains its old value.</source>
          <target state="translated">&lt;code&gt;onChange&lt;/code&gt; - 속성 값 변경을 시도하기 전에 호출되는 콜백. 이 콜백이 호출 될 때 속성 값이 아직 변경되지 않았습니다. 콜백이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 속성 값이 새 값으로 설정되고 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 새 값이 삭제되고 속성은 이전 값으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bd0af8f0f4441f0dd5c8e3ec2ac8ee31da629ce2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onEach&lt;/code&gt; is a small, but useful extension function for collections and sequences, which allows to perform some action, possibly with side-effects, on each element of the collection/sequence in a chain of operations. On iterables it behaves like &lt;code&gt;forEach&lt;/code&gt; but also returns the iterable instance further. And on sequences it returns a wrapping sequence, which applies the given action lazily as the elements are being iterated.</source>
          <target state="translated">&lt;code&gt;onEach&lt;/code&gt; 는 컬렉션 및 시퀀스를위한 작지만 유용한 확장 기능으로, 일련의 작업에서 컬렉션 / 시퀀스의 각 요소에 대해 부작용을 가지고 일부 작업을 수행 할 수 있습니다. iterables에서 &lt;code&gt;forEach&lt;/code&gt; 처럼 동작 하지만 iterable 인스턴스를 더 반환합니다. 그리고 시퀀스에서 요소가 반복 될 때 주어진 동작을 느리게 적용하는 래핑 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e904ec087d6b0daa0ca01993e45c332a47f884f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt; allows &lt;a href=&quot;classes#inheritance&quot;&gt;subclassing a class or overriding a member&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; &lt;a href=&quot;classes#inheritance&quot;&gt;클래스를 서브 클래 싱하거나 멤버를 재정의&lt;/a&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff40089b7efd684f476ea88fc60502882cb7ea01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="07b99c04ea1829b2394f976c655390997c8969b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - a function that is invoked on each element with the following parameters:</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 다음 매개 변수를 사용하여 각 요소에서 호출되는 함수 :</target>
        </trans-unit>
        <trans-unit id="248b36e5b9cea14adb1d1632ffd922f8a21f7211" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - a function that is invoked on each subsequent element of the group with the following parameters:</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 다음 매개 변수를 사용하여 그룹의 각 후속 요소에서 호출되는 함수 :</target>
        </trans-unit>
        <trans-unit id="e2ee0282f792518493f58e943267d8efcc3288db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - function is invoked on each element with the following parameters:</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 함수는 다음 매개 변수를 사용하여 각 요소에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5cc1b221c737a0161b2a21c10d217e38462c4ade" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - function that takes the index of a character, current accumulator value and the character itself and calculates the next accumulator value.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 문자, 현재 누산기 값 및 문자 자체의 인덱스를 가져와 다음 누산기 값을 계산하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ba9c3bd14120f260b4f8e64489c22c68aa16564b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - function that takes the index of a character, current accumulator value and the character itself, and calculates the next accumulator value.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 문자, 현재 누산기 값 및 문자 자체의 인덱스를 가져와 다음 누산기 값을 계산하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f3dfc746053a52619623276197f45f33b5ecb26d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - function that takes the index of a character, the character itself and current accumulator value, and calculates the next accumulator value.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 문자의 색인, 문자 자체 및 현재 누산기 값을 가져오고 다음 누산기 값을 계산하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a2f5a2634dcfd83cfd21d6a9d72e6de1b8cdcc04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - function that takes the index of an element, current accumulator value and the element itself and calculates the next accumulator value.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 요소, 현재 누산기 값 및 요소 자체의 인덱스를 가져와 다음 누산기 값을 계산하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="02e8057805378f6f4959a5114b1e0c8c72e8a698" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - function that takes the index of an element, current accumulator value and the element itself, and calculates the next accumulator value.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 요소, 현재 누산기 값 및 요소 자체의 인덱스를 가져와 다음 누산기 값을 계산하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="040dd6574f8413112a5e75a2983637acf71a1379" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operation&lt;/code&gt; - function that takes the index of an element, the element itself and current accumulator value, and calculates the next accumulator value.</source>
          <target state="translated">&lt;code&gt;operation&lt;/code&gt; - 요소의 인덱스, 요소 자체 및 현재 누산기 값을 가져오고 다음 누산기 값을 계산하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5b067faadea8fe2e509cda471afed4b9a218621e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt; can also be used for certain other predefined functions in order to create fancy effects, such as &lt;a href=&quot;inheritance#delegated-properties&quot;&gt;delegated properties&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 또한 &lt;a href=&quot;inheritance#delegated-properties&quot;&gt;대리 속성&lt;/a&gt; 과 같은 멋진 효과를 만들기 위해 다른 사전 정의 된 함수에 연산자를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95654b15a18c309b6235b5117183f93417c5d312" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt; marks a function as &lt;a href=&quot;operator-overloading&quot;&gt;overloading an operator or implementing a convention&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 는 함수 &lt;a href=&quot;operator-overloading&quot;&gt;에 연산자&lt;/a&gt; 를 오버로드하거나 규칙을 구현하는 것으로 표시</target>
        </trans-unit>
        <trans-unit id="3cd45210ebe76bf8c9d596dbc0bd1c602c3e9156" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or(bits)&lt;/code&gt; &amp;ndash; bitwise or</source>
          <target state="translated">&lt;code&gt;or(bits)&lt;/code&gt; &amp;ndash; 비트 단위 또는</target>
        </trans-unit>
        <trans-unit id="0417518c8faa0d30af999be7aa738560e49d1684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;other&lt;/code&gt; - the second file involved in the operation, if any (for example, the target of a copy or move)</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; - 동작에 관련된 제 파일있는 경우 (예를 들어, 복사 또는 이동의 대상)</target>
        </trans-unit>
        <trans-unit id="bb20a2a448ff12b6516746fa32432684ec92ed0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;other&lt;/code&gt; - the string against a substring of which the comparison is performed.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; - 비교가 수행되는의 문자열에 대한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fd1894c3bcae99eca6d992390ddbf52aaa027cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;otherOffset&lt;/code&gt; - the start offset in the other char sequence of the substring to compare.</source>
          <target state="translated">&lt;code&gt;otherOffset&lt;/code&gt; - 비교할 부분 문자열의 다른 문자 시퀀스에서 시작 오프셋</target>
        </trans-unit>
        <trans-unit id="2c87226a909e3b81c0afe8efaffdd2d21cb277a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;otherOffset&lt;/code&gt; - the start offset in the other string of the substring to compare.</source>
          <target state="translated">&lt;code&gt;otherOffset&lt;/code&gt; - 비교할 부분 문자열의 다른 문자열에서 시작 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="278f0f16ac78072a8cba927937acd7f2f05a2391" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt; - writer to write to.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; - 쓰기에 라이터.</target>
        </trans-unit>
        <trans-unit id="16c0fd496d4fff9161f7d9ca668c90772211d02f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt; marks a type parameter as &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;covariant&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 은 유형 변수를 &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;공변량&lt;/a&gt; 으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fde49d9720c995254e8b80d376d43b1b6ce6a80b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;override&lt;/code&gt; marks a member as an &lt;a href=&quot;classes#overriding-methods&quot;&gt;override of a superclass member&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; 는 멤버를 &lt;a href=&quot;classes#overriding-methods&quot;&gt;슈퍼 클래스 멤버&lt;/a&gt; 의 오버라이드 로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="26962046c0df7da84035dbd93e8153ed382e3f4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overwrite&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; if destination overwrite is allowed.</source>
          <target state="translated">&lt;code&gt;overwrite&lt;/code&gt; - 대상 덮어 쓰기가 허용되면 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e9b081e48d7cab3fbcabb38cde0858f4dd92ef7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overwrite&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; if it is allowed to overwrite existing destination files and directories.</source>
          <target state="translated">&lt;code&gt;overwrite&lt;/code&gt; - 기존 대상 파일 및 디렉토리를 덮어 쓸 수있는 경우 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c14ba6252e54c8220dc6cf80d69d0274bff1b72e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package&lt;/code&gt; specifies the &lt;a href=&quot;packages&quot;&gt;package for the current file&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; &lt;a href=&quot;packages&quot;&gt;는 현재 파일&lt;/a&gt; 의 패키지를 지정 합니다</target>
        </trans-unit>
        <trans-unit id="a233b575d588b308b8f3f49a9a0e445768b13910" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;padChar&lt;/code&gt; - the character to pad string with, if it has length less than the &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; specified. Space is used by default.</source>
          <target state="translated">&lt;code&gt;padChar&lt;/code&gt; -&lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이가&lt;/a&gt; 지정된 길이보다 작은 경우 문자열을 채울 문자 입니다. 공간이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd5f42bf06fd521604498e289daa482258243b4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;padChar&lt;/code&gt; - the character to pad string with, if it has length less than the &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; specified. Space is used by default.</source>
          <target state="translated">&lt;code&gt;padChar&lt;/code&gt; -&lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이가&lt;/a&gt; 지정된 길이보다 작은 경우 문자열을 채울 문자 입니다. 공간이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="378933c6c2d1f9e9920876580e36b05e9b8d8efd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;padChar&lt;/code&gt; - the character to pad string with, if it has length less than the &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; specified. Space is used by default.</source>
          <target state="translated">&lt;code&gt;padChar&lt;/code&gt; -&lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이가&lt;/a&gt; 지정된 길이보다 작은 경우 문자열을 채울 문자 입니다. 공간이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87eeb6c9880e5e71d0479ba97d1c1e287e21e51b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;padChar&lt;/code&gt; - the character to pad string with, if it has length less than the &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; specified. Space is used by default.</source>
          <target state="translated">&lt;code&gt;padChar&lt;/code&gt; -&lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이가&lt;/a&gt; 지정된 길이보다 작은 경우 문자열을 채울 문자 입니다. 공간이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f627d3fa9e23e2203a00e2793f1fff7a22aa25a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;param&lt;/code&gt; (constructor parameter);</source>
          <target state="translated">&lt;code&gt;param&lt;/code&gt; (생성자 매개 변수);</target>
        </trans-unit>
        <trans-unit id="876f5a1dc4c597977d50707f9b50fb0abc3ad55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;param&lt;/code&gt; is used as an &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;annotation use-site target&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;param&lt;/code&gt; 은 &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;주석 사용 사이트 대상&lt;/a&gt; 으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="901b369de442aad5ab3ae75e055c03e25e33f53f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;param&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;param&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="e276fe6573ffb36e406150493494379285bc9c8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partialWindows&lt;/code&gt; - controls whether or not to keep partial windows in the end if any, by default &lt;code&gt;false&lt;/code&gt; which means partial windows won't be preserved</source>
          <target state="translated">&lt;code&gt;partialWindows&lt;/code&gt; - 부분 윈도우가있는 경우 끝 부분을 유지할지 여부를 제어합니다. 기본적으로 &lt;code&gt;false&lt;/code&gt; 는 부분 윈도우가 보존되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="03307a7e15abd3869cc4eb9931070c2c66b67566" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partialWindows&lt;/code&gt; includes windows of smaller sizes that start from the elements at the end of the collection. For example, if you request windows of three elements, you can't build them for the last two elements. Enabling &lt;code&gt;partialWindows&lt;/code&gt; in this case includes two more lists of sizes 2 and 1.</source>
          <target state="translated">&lt;code&gt;partialWindows&lt;/code&gt; 에는 컬렉션 끝에있는 요소에서 시작하는 작은 크기의 창이 포함됩니다. 예를 들어, 세 가지 요소의 창을 요청하면 마지막 두 요소에 대해 창을 만들 수 없습니다. 이 경우 &lt;code&gt;partialWindows&lt;/code&gt; 를 사용 하면 크기 2와 1의 두 가지 목록이 더 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d394959b391b289e117e32c942748943fc04a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plus&lt;/code&gt; and &lt;code&gt;minus&lt;/code&gt; Operators</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; 및 &lt;code&gt;minus&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="494290e91b6acda25f5d2f8130edbbea915551b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plus&lt;/code&gt; and &lt;code&gt;minus&lt;/code&gt; operators</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; 및 &lt;code&gt;minus&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="b49b180353e64fc6e5d9f7cdff02fc5294156b0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; - value returned earlier by &lt;a href=&quot;as-c-pointer&quot;&gt;Worker.asCPointer&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; - &lt;a href=&quot;as-c-pointer&quot;&gt;Worker.asCPointer에&lt;/a&gt; 의해 일찍 반환 된 값</target>
        </trans-unit>
        <trans-unit id="83c8f8709e3b990c9d3a5aec7ee5a2b395d10020" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;predicate&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="60de56b1c096594153c02aa153a88c551524ad51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;predicate&lt;/code&gt; - function that takes the index of a character and the character itself and returns the result of predicate evaluation on the character.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; -문자 및 문자 자체의 색인을 가져 와서 문자에 대한 술어 평가 결과를 리턴하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="4bbf5867532295d9c456bd64904fdfdeb406eaf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;predicate&lt;/code&gt; - function that takes the index of an element and the element itself and returns the result of predicate evaluation on the element.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; -요소 및 요소 자체의 색인을 가져 와서 요소에 대한 술어 평가 결과를 리턴하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="c442ed0ab5aa9e966a98b7f03fa078374249462d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preserve-class-initialization&lt;/code&gt; &amp;ndash; generate Java-like bytecode for constructor calls, ensuring that the class initialization order is preserved. This can affect overall performance of your application; use it only if you have some complex state shared between multiple classes and updated on class initialization.</source>
          <target state="translated">&lt;code&gt;preserve-class-initialization&lt;/code&gt; &amp;ndash; 생성자 호출을 위해 Java와 유사한 바이트 코드를 생성하여 클래스 초기화 순서가 유지되도록합니다. 응용 프로그램의 전반적인 성능에 영향을 줄 수 있습니다. 여러 클래스간에 복잡한 상태가 공유되고 클래스 초기화시 업데이트 된 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57ba3b863cc8c4290462a7e4c0c2afda26c98701" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;priority&lt;/code&gt; - the priority of the thread.</source>
          <target state="translated">&lt;code&gt;priority&lt;/code&gt; - 스레드의 우선 순위.</target>
        </trans-unit>
        <trans-unit id="c5796ca90f05f8844ac1a5114df5b97bb2be4cb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; marks a declaration as &lt;a href=&quot;visibility-modifiers&quot;&gt;visible in the current class or file&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;visibility-modifiers&quot;&gt;은 현재 클래스 나 파일에&lt;/a&gt; 선언을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3cd1ab3237e659782b1a445b6691cc604fc818d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; means visible inside this class only (including all its members);</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 은이 클래스 안에서만 볼 수 있음을 의미합니다 (모든 멤버 포함).</target>
        </trans-unit>
        <trans-unit id="b4ca3ddcd68dce9aded9ed2f0c210450bb7e6949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; members (and &lt;code&gt;internal&lt;/code&gt; members from superclasses in other modules) are also inherited, but are not directly accessible: if the superclass contains a private property &lt;code&gt;foo&lt;/code&gt; that is referenced by a public function &lt;code&gt;bar()&lt;/code&gt;, instances of the subclass will contain a &lt;code&gt;foo&lt;/code&gt;; they can't use it directly, but they are allowed to call &lt;code&gt;bar()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 멤버 (및 다른 모듈에있는 수퍼 클래스의 &lt;code&gt;internal&lt;/code&gt; 멤버)도 상속되지만 직접 액세스 할 수는 없습니다. 수퍼 클래스 에 공용 함수 &lt;code&gt;bar()&lt;/code&gt; 에서 참조 하는 전용 속성 &lt;code&gt;foo&lt;/code&gt; 가 포함 된 경우 서브 클래스의 인스턴스에는 &lt;code&gt;foo&lt;/code&gt; ; 직접 사용할 수는 없지만 &lt;code&gt;bar()&lt;/code&gt; 를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a7ab2daf9b3462587f6e2840cea60565269c93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; members are compiled to &lt;code&gt;private&lt;/code&gt; members;</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 회원은 컴파일되어 &lt;code&gt;private&lt;/code&gt; 회원;</target>
        </trans-unit>
        <trans-unit id="281c4e0c9036d6e2b18b7425ed99f8f3ded9c97b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; top-level declarations are compiled to package-local declarations;</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 최상위 선언은 패키지 로컬 선언으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="1772eb6a89fcd1a653ae37a0e00a70be31b2a71c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: this symbol is only visible inside the containing class</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; :이 심볼은 포함하는 클래스 안에서만 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7b1a8411fd48b2c8ac75533016bccfea94c57ce8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;: this symbol is only visible inside the file where this symbol is declared</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; :이 심볼은이 심볼이 선언 된 파일 내에서만 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ebbbdb3c17c62ac194fe9be714fd124da12ea708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;processScheduledJobs&lt;/code&gt; - controls is we shall wait until all scheduled jobs processed, or terminate immediately.</source>
          <target state="translated">&lt;code&gt;processScheduledJobs&lt;/code&gt; - 제어는 예정된 모든 작업이 처리 될 때까지 기다리거나 즉시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="12ee3153ed5cd6c3d8cdbd82eda4a7e94d655cec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;processors&lt;/code&gt;: A comma-specified list of annotation processor qualified class names. If specified, kapt does not try to find annotation processors in &lt;code&gt;apclasspath&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;processors&lt;/code&gt; : 주석 프로세서로 한정된 클래스 이름의 쉼표로 지정된 목록입니다. 지정된 경우 kapt는 &lt;code&gt;apclasspath&lt;/code&gt; 에서 주석 프로세서를 찾으려고 시도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bc42dd4e73430a357a459c52466884fb13a6edd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt; &amp;mdash; must be of type &lt;code&gt;KProperty&amp;lt;*&amp;gt;&lt;/code&gt; or its supertype.</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; &amp;mdash; &lt;code&gt;KProperty&amp;lt;*&amp;gt;&lt;/code&gt; 또는 그 슈퍼 타입이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8492efa53994f5517732a61648debeb707627261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt; &amp;mdash; same as for &lt;code&gt;getValue()&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; &amp;mdash; &lt;code&gt;getValue()&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="39c75279096bb1069711ff5a3beb0e36af65557c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt; (annotations with this target are not visible to Java);</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; (이 대상의 주석은 Java에 표시되지 않음);</target>
        </trans-unit>
        <trans-unit id="7d79907823fd25c6a00e88d1beabb5caf46c411f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt; - the metadata for the property, used to get the name of property and lookup the value corresponding to this name in the map.</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; -특성 의 메타 데이터로, 특성 이름을 가져오고 맵에서이 이름에 해당하는 값을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb0a7c5aaedbf85636c8349c449b9017584b130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt; - the metadata for the property, used to get the name of property and store the value associated with that name in the map.</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; -특성 의 메타 데이터로, 특성 이름을 가져오고 해당 이름과 연관된 값을 맵에 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a84e91f7b88fb5b447ff2adc00ec643fcd89527e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt; - the metadata for the property.</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; -프로퍼티 의 메타 데이타</target>
        </trans-unit>
        <trans-unit id="6c88d0209b5cf686364eee61e0aa5b18521f117e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt; is used as an &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;annotation use-site target&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt; 은 &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;주석 사용 사이트 대상&lt;/a&gt; 으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="26979e5a5a77a7c1d8d4cd90472ae70bee609c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;property&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;property&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="ef850a5ede12132543032152b498af154c1e665f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; &amp;mdash; same as &lt;code&gt;private&lt;/code&gt; + visible in subclasses too;</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; &amp;mdash; 서브 클래스에서도 &lt;code&gt;private&lt;/code&gt; + visible 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d5172ab175bda21bb87b88dda90ee95aced1b408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; is not available for top-level declarations.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 최상위 레벨 선언에는 protected 를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb63247e4c1c5e0eab7c42818f592f975a1fad75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; marks a declaration as &lt;a href=&quot;visibility-modifiers&quot;&gt;visible in the current class and its subclasses&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; &lt;a href=&quot;visibility-modifiers&quot;&gt;는 현재 클래스와 해당 서브 클래스에&lt;/a&gt; 표시되는 선언을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="88734a0fe76710da1df7b4bdadba18b2d8d5c719" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; remains &lt;code&gt;protected&lt;/code&gt; (note that Java allows accessing protected members from other classes in the same package and Kotlin doesn't, so Java classes will have broader access to the code);</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 는 &lt;code&gt;protected&lt;/code&gt; 된 상태로 유지 됩니다 (Java는 동일한 패키지의 다른 클래스에서 보호 된 멤버에 액세스하는 것을 허용하고 Kotlin은 그렇지 않으므로 Java 클래스는 코드에 더 광범위하게 액세스 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="e68dde344fe415e84c6a9816a94c8b12d5689a2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;: this symbol is only visible inside the containing class and all of its subclasses, no matter where they are declared (so if your class is public and &lt;a href=&quot;inheritance#subclassing&quot;&gt;open&lt;/a&gt;, anyone can subclass it and thus get to see and use the protected members). If you have used Java: this does &lt;em&gt;not&lt;/em&gt; also grant access from the rest of the package.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; :이 심볼은 선언 된 위치에 관계없이 포함 클래스와 모든 하위 클래스 내에서만 볼 수 있습니다 (따라서 클래스가 공개 및 &lt;a href=&quot;inheritance#subclassing&quot;&gt;공개&lt;/a&gt; 이면 누구나 하위 클래스를 만들 수 있으므로 보호 된 멤버를보고 사용할 수 있습니다). Java를 사용한 경우 : 나머지 패키지에서도 액세스 권한이 부여 되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bfec9cea237b4503e6387514e81a2644bba7606a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;provideDelegate&lt;/code&gt;, &lt;code&gt;getValue&lt;/code&gt; and &lt;code&gt;setValue&lt;/code&gt; operator functions are described in &lt;a href=&quot;delegated-properties&quot;&gt;Delegated properties&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; , &lt;code&gt;getValue&lt;/code&gt; 및 &lt;code&gt;setValue&lt;/code&gt; 연산자 함수는 &lt;a href=&quot;delegated-properties&quot;&gt;위임 된 특성에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c1c6059a88a6253ff33bb98675ffdbdfc713e49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; &amp;mdash; any client who sees the declaring class sees its &lt;code&gt;public&lt;/code&gt; members.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; &amp;mdash; 선언 클래스를 보는 모든 클라이언트는 &lt;code&gt;public&lt;/code&gt; 멤버를 보게 됩니다.</target>
        </trans-unit>
        <trans-unit id="eab1bb865b6abaa17bf70e9f55b348d2a075d6f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; (or omitted): this symbol is visible throughout the entire codebase</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; (또는 생략) :이 기호는 전체 코드베이스에서 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e349eb6b48871de21c2fc41920223e4c77f26a7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; (or omitted): this symbol is visible to any code that can see the containing class</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; (또는 생략) :이 기호는 포함 클래스를 볼 수있는 모든 코드에 표시됩니다</target>
        </trans-unit>
        <trans-unit id="766337e6074e7cbfa5ffd93c46a523fcdd45f121" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; marks a declaration as &lt;a href=&quot;visibility-modifiers&quot;&gt;visible anywhere&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 은 &lt;a href=&quot;visibility-modifiers&quot;&gt;어디에서나&lt;/a&gt; 선언을 선언</target>
        </trans-unit>
        <trans-unit id="f52a00d65f5a1828adf3ed2971a1f773399099be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; remains &lt;code&gt;public&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 여전히 &lt;code&gt;public&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba7bd6b8dedfc63ca246864f34e877c81a48abe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="4c1136a4c963471f1976afcff5e1a1af934e7e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; - a string explaining why the implementation is missing.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; - 구현이 누락 된 이유를 설명하는 문자열</target>
        </trans-unit>
        <trans-unit id="a97ab72a73b1326a99a3abc12c26aa0ff03c9064" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; - the description of the error</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; - 오류에 대한 설명</target>
        </trans-unit>
        <trans-unit id="2ce0cb646c34f13816ccce7b03f884fd00d7d2be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver1&lt;/code&gt; - the instance of the first receiver.</source>
          <target state="translated">&lt;code&gt;receiver1&lt;/code&gt; - 첫 번째 수신자의 인스턴스</target>
        </trans-unit>
        <trans-unit id="158844371f061c3de78c6f60c8d8fdebcee509e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver2&lt;/code&gt; - the instance of the second receiver.</source>
          <target state="translated">&lt;code&gt;receiver2&lt;/code&gt; - 두 번째 수신자의 인스턴스</target>
        </trans-unit>
        <trans-unit id="d05c93992a87e7b93bfa0b53aaf9442f53c0fc40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver&lt;/code&gt; (receiver parameter of an extension function or property);</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; (확장 기능 또는 특성의 리시버 매개 변수);</target>
        </trans-unit>
        <trans-unit id="a98aea6224cfc44cd0422b175f55cd717c483718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver&lt;/code&gt; - the instance of the class used to retrieve the value of the property delegate.</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; - 속성 대리자의 값을 검색하는 데 사용되는 클래스의 인스턴스</target>
        </trans-unit>
        <trans-unit id="c3da121f86146196f53573fe143d1c4f02c04011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver&lt;/code&gt; - the receiver which is used to modify the value of the property. For example, it should be a class instance if this is a member property of that class, or an extension receiver if this is a top level extension property.</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; - 속성 값을 수정하는 데 사용되는 수신자. 예를 들어, 해당 클래스의 멤버 속성 인 경우 클래스 인스턴스이거나 최상위 확장 속성 인 경우 확장 수신기입니다.</target>
        </trans-unit>
        <trans-unit id="6a781ede8edeceb338ed66f80a72f5f115f56011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver&lt;/code&gt; - the receiver which is used to obtain the value of the property delegate. For example, it should be a class instance if this is a member property of that class, or an extension receiver if this is a top level extension property.</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; - 속성 대리자의 값을 얻는 데 사용되는 수신자. 예를 들어, 해당 클래스의 멤버 속성 인 경우 클래스 인스턴스이거나 최상위 확장 속성 인 경우 확장 수신기입니다.</target>
        </trans-unit>
        <trans-unit id="78b24734911f563b9a77668c2f9e12d696554423" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver&lt;/code&gt; - the receiver which is used to obtain the value of the property. For example, it should be a class instance if this is a member property of that class, or an extension receiver if this is a top level extension property.</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; -속성 값을 얻는 데 사용되는 수신자. 예를 들어, 해당 클래스의 멤버 속성 인 경우 클래스 인스턴스이거나 최상위 확장 속성 인 경우 확장 수신기입니다.</target>
        </trans-unit>
        <trans-unit id="002bc8ba7fef19afe5c32f3a4329b439b851c81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receiver&lt;/code&gt;is used as an &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;annotation use-site target&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;receiver&lt;/code&gt; 는 &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;주석 사용 사이트 대상&lt;/a&gt; 으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3cd01de440d83b1fb95ce4ab9c8465f2d6dd4245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reified&lt;/code&gt; marks a type parameter of an inline function as &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;accessible at runtime&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;reified&lt;/code&gt; &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;는 런타임에 액세스 가능한&lt;/a&gt; 것으로 인라인 함수의 유형 매개 변수를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="3a647b84307c2a1dabf7b72996b50831df922f5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rem&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;rem&lt;/code&gt; 운영자</target>
        </trans-unit>
        <trans-unit id="d74594c3c4e34a53b2bdf0e70926edc117855eb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replaceWith&lt;/code&gt; - If present, specifies a code fragment which should be used as a replacement for the deprecated API usage.</source>
          <target state="translated">&lt;code&gt;replaceWith&lt;/code&gt; -있는 경우, 더 이상 사용되지 않는 API 사용의 대체로 사용해야하는 코드 조각을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9731b874ffaf46a10ba130d059f97ed608f406c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replacement&lt;/code&gt; - A replacement expression that can include substitutions.</source>
          <target state="translated">&lt;code&gt;replacement&lt;/code&gt; -대체 를 포함 할 수있는 대체 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="6787f23fad529d927833cc839ccfacf1d47d1c5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replacement&lt;/code&gt; - A replacement expression that can include substitutions. See &lt;a href=&quot;-regex/replace-first#kotlin.text.Regex%24replaceFirst%28kotlin.CharSequence%2C+kotlin.String%29&quot;&gt;Regex.replaceFirst&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;replacement&lt;/code&gt; -대체 를 포함 할 수있는 대체 표현식입니다. 자세한 내용은 &lt;a href=&quot;-regex/replace-first#kotlin.text.Regex%24replaceFirst%28kotlin.CharSequence%2C+kotlin.String%29&quot;&gt;Regex.replaceFirst&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c036a71ebab5e11a408004b8de144be4c01b78e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replacement&lt;/code&gt; - A replacement expression that can include substitutions. See &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)&quot;&gt;Matcher.appendReplacement&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;replacement&lt;/code&gt; -대체 를 포함 할 수있는 대체 표현식입니다. 자세한 내용은 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)&quot;&gt;Matcher.appendReplacement&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="757f261748dcbf83ee41e61ec7397a56574c415d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replacement&lt;/code&gt; - A replacement expression that can include substitutions. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;String.prototype.replace&lt;/a&gt; function docs for details.</source>
          <target state="translated">&lt;code&gt;replacement&lt;/code&gt; -대체 를 포함 할 수있는 대체 표현식입니다. 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;String.prototype.replace&lt;/a&gt; 함수 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="731ebf1eb0b6ebc6fb79eeaefce5f6364cf410c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;&lt;a href=&quot;returns&quot;&gt;returns from the nearest enclosing function or anonymous function&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; &lt;a href=&quot;returns&quot;&gt;가장 가까운 바깥 쪽 함수 또는 익명 함수에서 반환&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ccc2d3f36614592ea4f6050d3d2c24e80066d487" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reversed()&lt;/code&gt; returns a new collection with the copies of the elements. So, if you change the original collection later, this won't affect the previously obtained results of &lt;code&gt;reversed()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;reversed()&lt;/code&gt; 는 요소의 복사본이있는 새 컬렉션을 반환합니다. 따라서 나중에 원본 컬렉션을 변경해도 이전에 얻은 &lt;code&gt;reversed()&lt;/code&gt; 결과에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="11e8f77497a243623a39f155fcc2b2e549c562a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;round(x)&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;+Inf&lt;/code&gt; or &lt;code&gt;-Inf&lt;/code&gt; or already a mathematical integer.</source>
          <target state="translated">&lt;code&gt;round(x)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 입니다. 여기서 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;+Inf&lt;/code&gt; 또는 &lt;code&gt;-Inf&lt;/code&gt; 이거나 이미 수학 정수입니다.</target>
        </trans-unit>
        <trans-unit id="021a1d5581cc1e055ff999d6e5c3167953323279" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;roundToInt&lt;/code&gt;, &lt;code&gt;roundToLong&lt;/code&gt; (half to integer) extension functions;</source>
          <target state="translated">&lt;code&gt;roundToInt&lt;/code&gt; , &lt;code&gt;roundToLong&lt;/code&gt; (반에서 정수로) 확장 함수;</target>
        </trans-unit>
        <trans-unit id="a7a48636595a73c48fb5fff1a432d18d2229d423" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run()&lt;/code&gt;, &lt;code&gt;let()&lt;/code&gt;, and &lt;code&gt;with()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;run()&lt;/code&gt; , &lt;code&gt;let()&lt;/code&gt; 및 &lt;code&gt;with()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53ad25e025c60c66a44e7a1cb485a6d06906b245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; does the same as &lt;code&gt;with&lt;/code&gt; but invokes as &lt;code&gt;let&lt;/code&gt; - as an extension function of the context object.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 은 &lt;code&gt;with&lt;/code&gt; 와 동일 하지만 컨텍스트 개체의 확장 함수 로서 &lt;code&gt;let&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="bf8d9d17d64ff82469dbf5ae3e8a7363e3bf8950" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; is useful when your lambda contains both the object initialization and the computation of the return value.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 당신의 람다 객체 초기화 및 반환 값의 계산을 모두 포함 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="02cd92347a4fd8b87df788ac3d5cb5598e8e2a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; refer to the context object as a lambda receiver - by keyword &lt;code&gt;this&lt;/code&gt;. Hence, in their lambdas, the object is available as it would be in ordinary class functions. In most cases, you can omit &lt;code&gt;this&lt;/code&gt; when accessing the members of the receiver object, making the code shorter. On the other hand, if &lt;code&gt;this&lt;/code&gt; is omitted, it can be hard to distinguish between the receiver members and external objects or functions. So, having the context object as a receiver (&lt;code&gt;this&lt;/code&gt;) is recommended for lambdas that mainly operate on the object members: call its functions or assign properties.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 는 컨텍스트 객체를 람다 수신자로 키워드로 참조 &lt;code&gt;this&lt;/code&gt; . 따라서 람다에서 객체는 일반 클래스 함수에서와 같이 사용할 수 있습니다. 대부분의 경우 수신자 오브젝트의 멤버에 액세스 할 때 &lt;code&gt;this&lt;/code&gt; 생략 하여 코드를 더 짧게 만들 수 있습니다. 한편, &lt;code&gt;this&lt;/code&gt; 생략되면, 수신기 부재와 외부 물체 또는 기능을 구별하기가 어려울 수있다. 따라서 컨텍스트 객체를 수신자 ( &lt;code&gt;this&lt;/code&gt; ) 로 갖는 것은 객체 객체에서 주로 작동하는 람다에 권장됩니다. 함수를 호출하거나 속성을 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="e79e7d974f97240f7bc523276b3d8e231c76c029" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;runtimeOnly&lt;/code&gt; dependencies are available at runtime but are not visible during compilation of any module.</source>
          <target state="translated">&lt;code&gt;runtimeOnly&lt;/code&gt; 종속성은 런타임에 사용할 수 있지만 모듈 컴파일 중에는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58a6240469f8a6ee6ff33c0e5cb5c16ca2afcb94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scale&lt;/code&gt; - the scale of the resulting &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;, i.e. number of decimal places of the fractional part. By default 0.</source>
          <target state="translated">&lt;code&gt;scale&lt;/code&gt; - 결과의 규모 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;의 BigDecimal&lt;/a&gt; , 소수 부분의 소수점의 예 수. 기본적으로 0.</target>
        </trans-unit>
        <trans-unit id="ea3d126205772519dab1ad0222b7a38681bf26e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sealed&lt;/code&gt; declares a &lt;a href=&quot;sealed-classes&quot;&gt;sealed class&lt;/a&gt; (a class with restricted subclassing)</source>
          <target state="translated">&lt;code&gt;sealed&lt;/code&gt; 은 &lt;a href=&quot;sealed-classes&quot;&gt;봉인 된 클래스&lt;/a&gt; (제한된 서브 클래스가있는 클래스)를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="20556a735d9463307d50afc8593af51bcb40d9d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seatCount&lt;/code&gt;, which is &lt;code&gt;Car&lt;/code&gt;'s own property</source>
          <target state="translated">&lt;code&gt;seatCount&lt;/code&gt; 이며, &lt;code&gt;Car&lt;/code&gt; 의 자체 특성</target>
        </trans-unit>
        <trans-unit id="d8fc07290c6f54ea4f72ca5abb9bad494c417569" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second&lt;/code&gt; - Second value.</source>
          <target state="translated">&lt;code&gt;second&lt;/code&gt; -초 값.</target>
        </trans-unit>
        <trans-unit id="2285f25f1a0e8cc8b7f48cc6a7802b16c54b2f7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; (property setter);</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; (속성 세터);</target>
        </trans-unit>
        <trans-unit id="0ee8ffdd88f78d8d595444de307c476608800ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setparam&lt;/code&gt; (property setter parameter);</source>
          <target state="translated">&lt;code&gt;setparam&lt;/code&gt; (속성 세터 매개 변수);</target>
        </trans-unit>
        <trans-unit id="098cc6c6492640dbb39b4e235003b429bc9ef092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setparam&lt;/code&gt; is used as an &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;annotation use-site target&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;setparam&lt;/code&gt; 은 &lt;a href=&quot;annotations#annotation-use-site-targets&quot;&gt;주석 사용 사이트 대상&lt;/a&gt; 으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="00470515b77bec859fa0fd291b1d7e77ca03663e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seze&lt;/code&gt; - the size of one element in the array used to store bits.</source>
          <target state="translated">&lt;code&gt;seze&lt;/code&gt; - 비트를 저장하는 데 사용되는 배열의 한 요소 크기입니다.</target>
        </trans-unit>
        <trans-unit id="96c489e6b5441f3f27632e207bd8669e506ee77b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shl(bits)&lt;/code&gt; &amp;ndash; signed shift left (Java's &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;shl(bits)&lt;/code&gt; &amp;ndash; 부호있는 shift left (Java의 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4b70d011bff39eddcbc338c1187efb5ec89d1a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shr(bits)&lt;/code&gt; &amp;ndash; signed shift right (Java's &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;shr(bits)&lt;/code&gt; &amp;ndash; 오른쪽으로 서명 된 시프트 (자바 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e3f9cf744bac34c42acc68c934a8943b08244608" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sign(NaN)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sign(NaN)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="a9b8d8b2d35af1ec3f393781437b403ef99b39b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sin(NaN|+Inf|-Inf)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sin(NaN|+Inf|-Inf)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="4c1eb584a9072c71fcaa6417c2a09246c0138d53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sinh(+Inf)&lt;/code&gt; is &lt;code&gt;+Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sinh(+Inf)&lt;/code&gt; 는 &lt;code&gt;+Inf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b135da3058c9500d66aafb6a128281dbd15ca97b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sinh(-Inf)&lt;/code&gt; is &lt;code&gt;-Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sinh(-Inf)&lt;/code&gt; 는 &lt;code&gt;-Inf&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="85c95c02a351d629823df5a68e49b9f10c9f4edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sinh(NaN)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sinh(NaN)&lt;/code&gt; 은 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="ebcd1833910fca27cdcbcdc254b29db060b5e998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="3cc3c43f4b02f8b21b31f647f391bfa5e465269e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; - 소자의 수는 양수 여야 각 문자 시퀀스에 걸릴 이러한 문자 시퀀스의 요소의 수보다 클 수있다.</target>
        </trans-unit>
        <trans-unit id="6ae2c5bcf4763c4f28a64b683a56e64ac50f0f01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; - 각 목록에서 취할 요소 수는 양수 여야하며이 컬렉션의 요소 수보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0eabc070e472f9aea5636eafa863a9302747954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; - 각 문자열에 사용할 요소 수는 양수 여야하며이 문자 시퀀스의 요소 수보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7f1044f1e44064883deade54887c5142dae0bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - the number of elements to take in each window</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; - 각 창에서 취할 요소 수</target>
        </trans-unit>
        <trans-unit id="41c63f30c69855986f80c66fba60df25156094b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - the size in bytes of data of this type</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; - 이 유형의 데이터 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="5b691a866956ce689f6b294e5168479679728613" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size_t&lt;/code&gt; and &lt;code&gt;ptrdiff_t&lt;/code&gt; (also &lt;code&gt;ssize_t&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;size_t&lt;/code&gt; 및 &lt;code&gt;ptrdiff_t&lt;/code&gt; ( &lt;code&gt;ssize_t&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="87cdc6f5c81965c63759c8bc93b97beee6c125e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sort*&lt;/code&gt; instead of &lt;code&gt;sorted*&lt;/code&gt; in the names of all sorting functions: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sort&quot;&gt;&lt;code&gt;sort()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sort-descending&quot;&gt;&lt;code&gt;sortDescending()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sort-by&quot;&gt;&lt;code&gt;sortBy()&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">&lt;code&gt;sort*&lt;/code&gt; 대신 &lt;code&gt;sorted*&lt;/code&gt; 모든 정렬 함수의 이름에서 : &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sort&quot;&gt; &lt;code&gt;sort()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sort-descending&quot;&gt; &lt;code&gt;sortDescending()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sort-by&quot;&gt; &lt;code&gt;sortBy()&lt;/code&gt; &lt;/a&gt; , 등등.</target>
        </trans-unit>
        <trans-unit id="20605ae3cabe36bbd227ce9c86b87f19406bd512" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sources&lt;/code&gt; (&lt;em&gt;required&lt;/em&gt;): An output path for the generated files.</source>
          <target state="translated">&lt;code&gt;sources&lt;/code&gt; ( &lt;em&gt;필수&lt;/em&gt; ) : 생성 된 파일의 출력 경로입니다.</target>
        </trans-unit>
        <trans-unit id="58fedc20a964ac6d3e409f1eb6f5b974b7d02b00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sqrt(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; when &lt;code&gt;x &amp;lt; 0&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sqrt(x)&lt;/code&gt; 인 &lt;code&gt;NaN&lt;/code&gt; 이 때 &lt;code&gt;x &amp;lt; 0&lt;/code&gt; 또는 &lt;code&gt;x&lt;/code&gt; 이다 &lt;code&gt;NaN&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="a8068f2545dd80f59f49a0506837766685a6522f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; - if &lt;code&gt;true&lt;/code&gt;, the thread is immediately started.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 인 경우 스레드가 즉시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ff9aa0cd8a242744f68fb657ded03dd2b2d6f5b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - An index to start search with, by default 0. Must be not less than zero and not greater than &lt;code&gt;input.length()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 기본적으로 0으로 검색을 시작하는 색인. 0보다 작 &lt;code&gt;input.length()&lt;/code&gt; 보다 크지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="acdb8a0620e4c7b5130f3f413b7f675514ad6cea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - The index of character to start searching at. The search proceeds backward toward the beginning of the string.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 검색을 시작할 문자의 색인입니다. 검색은 문자열의 시작 부분으로 뒤로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="124ba5ac28f4badbe35200ad470134f178f03ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the beginning (inclusive) of the subrange of characters, 0 by default.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 문자 하위 범위의 시작 (포함)이며 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="9a1eefd9393380e662552de130993045e8c45f90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the beginning (inclusive) of the subrange to copy, 0 by default.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 복사 할 하위 범위의 시작 (포함)이며 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="6d7ba75f0fac0567e24fa448288b299f775f0dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the beginning (inclusive) of the subrange to decode, 0 by default.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 디코딩 할 하위 범위의 시작 (포함)이며 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="ee8df34a76b9d52df945d0dc5ba3c9ffb5bdc4e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the beginning (inclusive) of the substring to encode, 0 by default.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 인코딩 할 부분 문자열의 시작 (포함)이며 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="32bc7b0935a3307d89f32516078796087b21372a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the beginning (inclusive) of the substring, 0 by default.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 부분 문자열의 시작 (포함)이며 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="835e8083c9240cc60a14ec539b52df0df483620f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the index of the first character to be removed.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 제거 할 첫 번째 문자의 색인</target>
        </trans-unit>
        <trans-unit id="c012a03f38ecc253b52f1afffbc631db96db9a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the index of the first character to be replaced.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 교체 할 첫 번째 문자의 색인</target>
        </trans-unit>
        <trans-unit id="b6a5e9aac01d2306cb7c6b7a7ea596a30e7639ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the start index (inclusive).</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 시작 색인 (포함)</target>
        </trans-unit>
        <trans-unit id="aad719fc94e4921fd31594c6d16dcb0ddb52cf98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startIndex&lt;/code&gt; - the start offset (inclusive) of the substring to copy.</source>
          <target state="translated">&lt;code&gt;startIndex&lt;/code&gt; - 복사 할 부분 문자열의 시작 오프셋 (포함)입니다.</target>
        </trans-unit>
        <trans-unit id="b72ad0e532783f6ba234cbbdc102b23306ca16e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; - serves as a status code; by convention, a nonzero status code indicates abnormal termination.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; - 상태 코드 역할을합니다. 일반적으로 0이 아닌 상태 코드는 비정상 종료를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="76e05e699805ca165800cfaf4cdbd31609cb5ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdlib&lt;/code&gt; already makes use of contracts, which leads to improvements in the analyses described above. This part of contracts is &lt;strong&gt;stable&lt;/strong&gt;, meaning that you can benefit from the improved analysis right now without any additional opt-ins:</source>
          <target state="translated">&lt;code&gt;stdlib&lt;/code&gt; 는 이미 계약을 사용하므로 위에서 설명한 분석이 향상됩니다. 이 계약 부분은 &lt;strong&gt;안정적&lt;/strong&gt; 이므로 추가 옵트 인 없이도 향상된 분석의 이점을 누릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="727fd974271fc9099443f42a3b2ceeb5e2610178" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt; - the number of elements to move the window forward by on an each step, by default 1</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; - 각 단계에서 창을 앞으로 이동시키는 요소 수, 기본적으로 1</target>
        </trans-unit>
        <trans-unit id="dcd999b6301542cebc2fb677d779bd98681aaf0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt; defines a distance between first elements of two adjacent windows. By default the value is 1, so the result contains windows starting from all elements. If you increase the step to 2, you will receive only windows starting from odd elements: first, third, an so on.</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 는 두 개의 인접한 창의 첫 번째 요소 사이의 거리를 정의합니다. 기본적으로 값은 1이므로 모든 요소에서 시작하는 창이 포함됩니다. 단계를 2로 늘리면 홀수 요소 (첫 번째, 세 번째 등)부터 시작하는 창만 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="3d0d0c2c99afb5f31cdfb8aa7358f3f9d2409787" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictEnums&lt;/code&gt; and &lt;code&gt;nonStrictEnums&lt;/code&gt; properties values are space-separated lists of the enums that should be generated as a Kotlin enum or as integral values correspondingly. If the enum is not included into any of these lists, then it is generated according to the heuristics.</source>
          <target state="translated">&lt;code&gt;strictEnums&lt;/code&gt; 및 &lt;code&gt;nonStrictEnums&lt;/code&gt; 속성 값은 Kotlin 열거 형 또는 해당 정수 값으로 생성되어야하는 공백으로 구분 된 열거 형 목록입니다. 열거 형이 이러한 목록에 포함되지 않으면 추론에 따라 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fd1037cd9a47ac6bb5aed0cc042843d12462adcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stubs&lt;/code&gt; &amp;ndash; only generate stubs needed for annotation processing;</source>
          <target state="translated">&lt;code&gt;stubs&lt;/code&gt; &amp;ndash; 주석 처리에 필요한 스텁 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="88061555c9c98e794fcbabeb6346959556967b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stubs&lt;/code&gt; (&lt;em&gt;required&lt;/em&gt;): An output path for the stub files. In other words, some temporary directory.</source>
          <target state="translated">&lt;code&gt;stubs&lt;/code&gt; ( &lt;em&gt;필수&lt;/em&gt; ) : 스텁 파일의 출력 경로입니다. 다시 말해 일부 임시 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="5237e34d8ca0b0aa26e70c25ae06d3415d09f9d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stubsAndApt&lt;/code&gt; &amp;ndash; generate stubs and run annotation processing.</source>
          <target state="translated">&lt;code&gt;stubsAndApt&lt;/code&gt; &amp;ndash; 스텁을 생성하고 주석 처리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2bdb177a1a5e9df43693e64cf09b5a941dfeef82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suspend&lt;/code&gt; marks a function or lambda as suspending (usable as a &lt;a href=&quot;coroutines-overview&quot;&gt;coroutine&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;suspend&lt;/code&gt; 는 함수 또는 람다를 일시 중단으로 표시합니다 ( &lt;a href=&quot;coroutines-overview&quot;&gt;코 루틴으로&lt;/a&gt; 사용 가능 )</target>
        </trans-unit>
        <trans-unit id="d88adc9894a2f1336ad6b9c663914539e72791a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tailrec&lt;/code&gt; marks a function as &lt;a href=&quot;functions#tail-recursive-functions&quot;&gt;tail-recursive&lt;/a&gt; (allowing the compiler to replace recursion with iteration)</source>
          <target state="translated">&lt;code&gt;tailrec&lt;/code&gt; 는 함수를 &lt;a href=&quot;functions#tail-recursive-functions&quot;&gt;tail-recursive&lt;/a&gt; 로 표시합니다 (컴파일러가 재귀를 반복으로 대체하도록 허용)</target>
        </trans-unit>
        <trans-unit id="8d3d2939196993f9bab19d448225194c8a28b278" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeIf()&lt;/code&gt; and &lt;code&gt;takeUnless()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;takeIf()&lt;/code&gt; 및 &lt;code&gt;takeUnless()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c06bcfa7789a0124c5ed588357e1ea0f3463b180" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;takeIf&lt;/code&gt; 와 &lt;code&gt;takeUnless&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f6b8bc7140372eea96f7957c76b434bd69770a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt; are especially useful together with scope functions. A good case is chaining them with &lt;code&gt;let&lt;/code&gt; for running a code block on objects that match the given predicate. To do this, call &lt;code&gt;takeIf&lt;/code&gt; on the object and then call &lt;code&gt;let&lt;/code&gt; with a safe call (&lt;code&gt;?&lt;/code&gt;). For objects that don't match the predicate, &lt;code&gt;takeIf&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; isn't invoked.</source>
          <target state="translated">&lt;code&gt;takeIf&lt;/code&gt; 및 &lt;code&gt;takeUnless&lt;/code&gt; 는 범위 기능과 함께 특히 유용합니다. 좋은 조건은 주어진 술어와 일치하는 객체에서 코드 블록을 실행할 &lt;code&gt;let&lt;/code&gt; 연결하는 것입니다 . 이렇게하려면 객체에서 &lt;code&gt;takeIf&lt;/code&gt; 를 호출 한 다음 안전한 호출 ( &lt;code&gt;?&lt;/code&gt; )로 &lt;code&gt;let&lt;/code&gt; 을 호출 하십시오 . 술어와 일치하지 않는 오브젝트의 경우, &lt;code&gt;takeIf&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 하고 &lt;code&gt;let&lt;/code&gt; 이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaac4c748ff74aef66b4d4bf6a589fa48436bfe5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeIf&lt;/code&gt; is like &lt;code&gt;filter&lt;/code&gt; for a single value. It checks whether the receiver meets the predicate, and returns the receiver, if it does or &lt;code&gt;null&lt;/code&gt; if it doesn't. Combined with an elvis-operator and early returns it allows to write constructs like:</source>
          <target state="translated">&lt;code&gt;takeIf&lt;/code&gt; 는 단일 값에 대한 &lt;code&gt;filter&lt;/code&gt; 와 같습니다 . 수신자가 술어를 만족하는지 여부를 점검하고 수신자가있는 경우 리턴하거나 그렇지 않은 경우 &lt;code&gt;null&lt;/code&gt; 합니다. elvis-operator 및 초기 리턴과 결합하여 다음과 같은 구문을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c33be6cb907b12adc9119250bf308c128256a36d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUnless&lt;/code&gt; is the same as &lt;code&gt;takeIf&lt;/code&gt;, but it takes the inverted predicate. It returns the receiver when it &lt;em&gt;doesn't&lt;/em&gt; meet the predicate and &lt;code&gt;null&lt;/code&gt; otherwise. So one of the examples above could be rewritten with &lt;code&gt;takeUnless&lt;/code&gt; as following:</source>
          <target state="translated">&lt;code&gt;takeUnless&lt;/code&gt; 은 동일하다 &lt;code&gt;takeIf&lt;/code&gt; 하지만 반전 술어를합니다. 술어를 만족 &lt;em&gt;하지 않으면&lt;/em&gt; 수신자를 리턴하고 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 합니다. 따라서 위의 예제 중 하나 를 다음과 같이 &lt;code&gt;takeUnless&lt;/code&gt; 로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bb8daa78c89754426c090574adc1aff035196e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tan(NaN|+Inf|-Inf)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tan(NaN|+Inf|-Inf)&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="e2fbad78534aa0baffd2f5827a30977a3fd22e65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tanh(+Inf)&lt;/code&gt; is &lt;code&gt;1.0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tanh(+Inf)&lt;/code&gt; 는 &lt;code&gt;1.0&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="9d8705b536f611c5ef6af349994c52792dcf54e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tanh(-1.0)&lt;/code&gt; is &lt;code&gt;-Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tanh(-1.0)&lt;/code&gt; 은 &lt;code&gt;-Inf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9ef017c48a59b4351fe87c214b953f31afbc8515" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tanh(-Inf)&lt;/code&gt; is &lt;code&gt;-1.0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tanh(-Inf)&lt;/code&gt; 는 &lt;code&gt;-1.0&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="9fb9734bbf8358d4f3a29ac0b6771bd430e1a78d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tanh(1.0)&lt;/code&gt; is &lt;code&gt;+Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tanh(1.0)&lt;/code&gt; 은 &lt;code&gt;+Inf&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66d2f8e0730eaad57483b20b82eba676e897c62f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tanh(NaN)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tanh(NaN)&lt;/code&gt; 은 &lt;code&gt;NaN&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="962278e1ea50881e55b704575c8fdf7a4b75fc53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tanh(x)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; when &lt;code&gt;x &amp;gt; 1&lt;/code&gt; or &lt;code&gt;x &amp;lt; -1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tanh(x)&lt;/code&gt; &lt;code&gt;x &amp;gt; 1&lt;/code&gt; 또는 &lt;code&gt;x &amp;lt; -1&lt;/code&gt; 일 때 tanh (x) 는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b56280d6d0412a62dfb9d389803f8aac0959dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; is disabled, and the target's test task is used (e.g. &lt;code&gt;jvmTest&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 가 비활성화되고 대상의 테스트 작업이 사용됩니다 (예 : &lt;code&gt;jvmTest&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b19f69b3755690b021fdcb189a2d765113e01501" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text&lt;/code&gt; - text to append to file.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; - 파일에 추가 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="584921280571d8eda0a4ddcb9fc92763ef7d199d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text&lt;/code&gt; - text to write into file.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; - 파일에 쓸 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="c94e2aaa2c54025cd0dd82fd1be34fc781dd96f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;textView&lt;/code&gt; is an extension property for &lt;code&gt;Activity&lt;/code&gt;, and it has the same type as declared in &lt;code&gt;activity_main.xml&lt;/code&gt; (so it is a &lt;code&gt;TextView&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;textView&lt;/code&gt; 위한 확장 속성 인 &lt;code&gt;Activity&lt;/code&gt; , 그리고 선언 동일한 유형 갖는다 &lt;code&gt;activity_main.xml&lt;/code&gt; (그것이 정도로 &lt;code&gt;TextView&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6ca138f79a2155ce9eb77ce0d3226c80dba4dd46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;third&lt;/code&gt; - Third value.</source>
          <target state="translated">&lt;code&gt;third&lt;/code&gt; -셋째 값.</target>
        </trans-unit>
        <trans-unit id="59fb4725b2a41ff996479dec4539f3be6e290369" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thisOffset&lt;/code&gt; - the start offset in this char sequence of the substring to compare.</source>
          <target state="translated">&lt;code&gt;thisOffset&lt;/code&gt; - 비교할 부분 문자열의이 문자 시퀀스에서 시작 오프셋.</target>
        </trans-unit>
        <trans-unit id="7651cc401a2cecd3313fc38f62a13aa291e1292c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thisOffset&lt;/code&gt; - the start offset in this string of the substring to compare.</source>
          <target state="translated">&lt;code&gt;thisOffset&lt;/code&gt; - 비교할 부분 문자열의이 문자열에서 시작 오프셋.</target>
        </trans-unit>
        <trans-unit id="8681dc6c5b580e3d7caea60a99dbef13f55f9b2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thisRef&lt;/code&gt; &amp;mdash; must be the same or a supertype of the &lt;em&gt;property owner&lt;/em&gt; (for extension properties &amp;mdash; the type being extended);</source>
          <target state="translated">&lt;code&gt;thisRef&lt;/code&gt; &amp;mdash; &lt;em&gt;속성 소유자&lt;/em&gt; 와 동일하거나 상위 유형이어야합니다 (확장 속성의 경우-확장중인 유형).</target>
        </trans-unit>
        <trans-unit id="399a3d1a1e924f800c27694c35284415a0d323aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thisRef&lt;/code&gt; &amp;mdash; same as for &lt;code&gt;getValue()&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;thisRef&lt;/code&gt; &amp;mdash; &lt;code&gt;getValue()&lt;/code&gt; 와 동일 ;</target>
        </trans-unit>
        <trans-unit id="aa686d9597c69ad884e20b4066f00def78629496" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thisRef&lt;/code&gt; - the object for which the value is requested (not used).</source>
          <target state="translated">&lt;code&gt;thisRef&lt;/code&gt; - 값이 요청 된 객체 (사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="bb9497e6795b35429a4bd512b9801a1bd9351fcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thisRef&lt;/code&gt; - the object for which the value is requested.</source>
          <target state="translated">&lt;code&gt;thisRef&lt;/code&gt; - 값이 요청 된 객체</target>
        </trans-unit>
        <trans-unit id="abcb6cbc8d903620a1636bf866465fbc73df05c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throw&lt;/code&gt; is also an expression, and its return type is the special class &lt;code&gt;Nothing&lt;/code&gt;, which does not have any instances. The compiler knows that an expression whose type is &lt;code&gt;Nothing&lt;/code&gt; will never return normally, and will therefore generally accept its use even where a different type would normally be required, such as after the &lt;a href=&quot;null-safety#elvis-operator&quot;&gt;Elvis operator&lt;/a&gt;. If you make a function that always throws, or that starts an infinite loop, you could declare its return type to be &lt;code&gt;Nothing&lt;/code&gt; in order to make the compiler aware of this. One fun example of this is the built-in function &lt;code&gt;TODO&lt;/code&gt;, which you can call in any expression (possibly supplying a string argument), and it raises a &lt;code&gt;NotImplementedError&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 도 표현식이며 반환 유형은 인스턴스가없는 특수 클래스 &lt;code&gt;Nothing&lt;/code&gt; 입니다. 컴파일러는 유형이 &lt;code&gt;Nothing&lt;/code&gt; 인 표현식은 정상적으로 리턴되지 않으므로 &lt;a href=&quot;null-safety#elvis-operator&quot;&gt;Elvis 연산자&lt;/a&gt; 와 같이 다른 유형이 일반적으로 필요한 경우에도 일반적으로 사용을 승인합니다 . 항상 던지거나 무한 루프를 시작하는 함수 를 만드는 경우 컴파일러가이를 인식하도록 반환 유형을 &lt;code&gt;Nothing&lt;/code&gt; 으로 선언 할 수 있습니다 . 이에 대한 한 가지 재미있는 예는 내장 함수 &lt;code&gt;TODO&lt;/code&gt; 로 , 어떤 식 으로든 (문자열 인수 제공) 호출 할 수 있으며 &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="746512bbbc5796ff33613f9c8ba4763c8e2df1ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throw&lt;/code&gt; is an expression in Kotlin, so you can use it, for example, as part of an Elvis expression:</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 는 Kotlin의 표현식이므로 예를 들어 Elvis 표현식의 일부로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82f0b362b52d255e00890f34eb5b6c90731fe6ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throw&lt;/code&gt;&lt;a href=&quot;exceptions&quot;&gt;throws an exception&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; &lt;a href=&quot;exceptions&quot;&gt;예외를 &lt;/a&gt;던 졌습니다</target>
        </trans-unit>
        <trans-unit id="522b75ea192fc01f31126dceb76e4403d6efed86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throwOnInvalidSequence&lt;/code&gt; - specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;throwOnInvalidSequence&lt;/code&gt; - 잘못된 바이트 시퀀스에서 예외를 던지거나 대체 char &lt;code&gt;\uFFFD&lt;/code&gt; 대체할지 여부를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0786bbec1c422619dd28386c34573a869b9d8118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throwOnInvalidSequence&lt;/code&gt; - specifies whether to throw an exception on malformed char sequence or replace.</source>
          <target state="translated">&lt;code&gt;throwOnInvalidSequence&lt;/code&gt; - 잘못된 문자 시퀀스에서 예외를 던지거나 바꿀지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1792b36896bac4d766607f8e3bc1828ec037cfd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBigDecimal&lt;/code&gt; for &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Long&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, and &lt;code&gt;BigInteger&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;toBigDecimal&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; , &lt;code&gt;Long&lt;/code&gt; , &lt;code&gt;Float&lt;/code&gt; , &lt;code&gt;Double&lt;/code&gt; 및 &lt;code&gt;BigInteger&lt;/code&gt; 에 대한 toBigDecimal ;</target>
        </trans-unit>
        <trans-unit id="fe5553087ec0f88c70336b42de18b8470324718a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBigInteger&lt;/code&gt; for &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Long&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;toBigInteger&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; 및 &lt;code&gt;Long&lt;/code&gt; 에 대한 toBigInteger ;</target>
        </trans-unit>
        <trans-unit id="4f7e08f507e6c7df158092b47787a4feb113953d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBits&lt;/code&gt; and &lt;code&gt;toRawBits&lt;/code&gt; returning &lt;code&gt;Long&lt;/code&gt; for &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; for &lt;code&gt;Float&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;toBits&lt;/code&gt; 및 &lt;code&gt;toRawBits&lt;/code&gt; 돌아 &lt;code&gt;Long&lt;/code&gt; 위한 &lt;code&gt;Double&lt;/code&gt; 및 &lt;code&gt;Int&lt;/code&gt; 에 대한 &lt;code&gt;Float&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="8cc386b6e87bc3448b7797f22b1c5c03d88f6f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toBits&lt;/code&gt;, &lt;code&gt;toRawBits&lt;/code&gt;, &lt;code&gt;Double.fromBits&lt;/code&gt; (these are in the &lt;code&gt;kotlin&lt;/code&gt; package).</source>
          <target state="translated">&lt;code&gt;toBits&lt;/code&gt; , &lt;code&gt;toRawBits&lt;/code&gt; , &lt;code&gt;Double.fromBits&lt;/code&gt; ( &lt;code&gt;kotlin&lt;/code&gt; 패키지에 있습니다).</target>
        </trans-unit>
        <trans-unit id="545b09bd6d4acfec1c751aec080997d656fe9ab9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toFreeze&lt;/code&gt; - an object intended to be frozen.</source>
          <target state="translated">&lt;code&gt;toFreeze&lt;/code&gt; - 얼어 붙을 대상.</target>
        </trans-unit>
        <trans-unit id="e4c0c56284f7d7d6ee2371715a2c8a8210aa4182" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toIndex&lt;/code&gt; - the end of the range (exclusive), must be in &lt;code&gt;fromIndex..array.size&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toIndex&lt;/code&gt; - 범위 끝 (제외)은 &lt;code&gt;fromIndex..array.size&lt;/code&gt; 에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3589ae8a084d12124e3bc10fc6b2b2d3a3971bce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString()&lt;/code&gt; of the form &lt;code&gt;&quot;User(name=John, age=42)&quot;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;toString()&lt;/code&gt; &lt;code&gt;&quot;User(name=John, age=42)&quot;&lt;/code&gt; 형식의 toString () ;</target>
        </trans-unit>
        <trans-unit id="51154d9a1d6a4913e008e93d78cebb80aa948662" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString()&lt;/code&gt; returns a string representation of the object, similar to &lt;code&gt;__str__()&lt;/code&gt; in Python (the default implementation is rather uninteresting, as it only returns the class name and something akin to the object's id)</source>
          <target state="translated">&lt;code&gt;toString()&lt;/code&gt; 은 파이썬에서 &lt;code&gt;__str__()&lt;/code&gt; 과 비슷한 객체의 문자열 표현을 반환합니다 (기본 구현은 클래스 이름과 객체의 ID와 비슷한 것을 반환하기 때문에 다소 흥미롭지 않습니다)</target>
        </trans-unit>
        <trans-unit id="e8d872f4216b831cc8bc4d7f49dea5204e0416fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toString()&lt;/code&gt;, &lt;code&gt;equals()&lt;/code&gt;, and &lt;code&gt;hashCode()&lt;/code&gt;, which are inherited from &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;toString()&lt;/code&gt; , &lt;code&gt;equals()&lt;/code&gt; 및 &lt;code&gt;hashCode()&lt;/code&gt; 는 &lt;code&gt;Any&lt;/code&gt; 에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="638c9d74080f74c67b71667a2c185ea21e972ba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transform&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="15c4b04e951d17c1a2e477f031d2bcf27cf9bdba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transform&lt;/code&gt; - function that takes the index of a character and the character itself and returns the result of the transform applied to the character.</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; - 문자와 문자 자체의 색인을 가져와 문자에 적용된 변환 결과를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="039aa43b89df1fd9e312edea27e7540bd36beb5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transform&lt;/code&gt; - function that takes the index of an element and the element itself and returns the result of the transform applied to the element.</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; - 요소와 요소 자체의 인덱스를 가져 와서 요소에 적용된 변환 결과를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="104dcd522cc3ee9799b1640335aabcab9d66b3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this callable is &lt;code&gt;abstract&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 호출 인 경우 &lt;code&gt;abstract&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bef381db8bd06ce91772cba2de44905179068baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this callable is &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 호출 인 경우 &lt;code&gt;final&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48e9436811c46e7ef269874f8b8c972bf249af4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this callable is &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 호출 할 경우 &lt;code&gt;open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e7040532b788db7e1881a404c2f6f57d9ec2ec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is &lt;code&gt;abstract&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스 인 경우 &lt;code&gt;abstract&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29cbfd008c683c372ccea25514e60950995208ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스 인 경우 &lt;code&gt;final&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0682ac2ca7d06f0fcf26167395972d601e74dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스 인 경우 &lt;code&gt;open&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56d6f885f8db1cf343eb33f83893311ce3af6a58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is &lt;code&gt;sealed&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/sealed-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스가 &lt;code&gt;sealed&lt;/code&gt; 있으면 true 입니다. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/sealed-classes&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b071fdced7370b9c523bba505946c8904ca5851" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is a companion object. See the &lt;a href=&quot;../../../../../../docs/reference/object-declarations#companion-objects&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스가 컴패니언 객체 이면 true 입니다. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/object-declarations#companion-objects&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="845c0cfe5e08f8ccdc3394fd10bcfbfd84a7e50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is a data class. See the &lt;a href=&quot;../../../../../../docs/reference/data-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스가 데이터 클래스 인 경우는 true 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/data-classes&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6173885a56cf421523749e79e1c37be3556ce069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this class is an inner class. See the &lt;a href=&quot;../../../../../../docs/reference/nested-classes#inner-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 클래스가 내부 클래스 인 경우는 true 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/nested-classes#inner-classes&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3da89216220cb9b19287d95d61d7699c69944807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this function is &lt;code&gt;external&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/java-interop#using-jni-with-kotlin&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 함수가 &lt;code&gt;external&lt;/code&gt; 인 경우 true 입니다. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/java-interop#using-jni-with-kotlin&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="92086a8ecd17c2c4c8bffc5df741e48dda9e5af9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this function is &lt;code&gt;infix&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/functions#infix-notation&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 기능이있는 경우 &lt;code&gt;infix&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/functions#infix-notation&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="107d2be5f1d44fd574f06da199faec12b7a849ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this function is &lt;code&gt;inline&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/inline-functions&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 함수가 &lt;code&gt;inline&lt;/code&gt; 이면 true 입니다. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/inline-functions&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dffdc0c4a5c1dd507af4c9d86696578b69989817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this function is &lt;code&gt;operator&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/operator-overloading&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 함수가 &lt;code&gt;operator&lt;/code&gt; 이면 true 입니다. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/operator-overloading&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d7d894c3aad9ff0f0e72c2696fe7bfe07f5aef3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this is a suspending function.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이것이 현수 함수 인 경우는 true</target>
        </trans-unit>
        <trans-unit id="ef20cb76da715ecda07257a877b8973bf96552f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this parameter is &lt;code&gt;vararg&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/functions#variable-number-of-arguments-varargs&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 매개 변수 인 경우 &lt;code&gt;vararg&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/functions#variable-number-of-arguments-varargs&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b86debaee171b6be12d0c5af394bcd5ef11cf486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this parameter is optional and can be omitted when making a call via &lt;a href=&quot;../-k-callable/call-by#kotlin.reflect.KCallable%24callBy%28kotlin.collections.Map%28%28kotlin.reflect.KParameter%2C+kotlin.Any%29%29%29&quot;&gt;KCallable.callBy&lt;/a&gt;, or &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 매개 변수가 선택적이고 &lt;a href=&quot;../-k-callable/call-by#kotlin.reflect.KCallable%24callBy%28kotlin.collections.Map%28%28kotlin.reflect.KParameter%2C+kotlin.Any%29%29%29&quot;&gt;KCallable.callBy&lt;/a&gt; 를 통해 호출 할 때 생략 할 수 있으면 true 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="baf7d9d384a67ac6e59b989ce1119cdbbec9d4af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this property is &lt;code&gt;const&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/properties#compile-time-constants&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 속성이있는 경우 &lt;code&gt;const&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/properties#compile-time-constants&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f86909c75ad3bc1f327b31e716a0fc67647217c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this property is &lt;code&gt;lateinit&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/properties#late-initialized-properties&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 속성은 경우 &lt;code&gt;lateinit&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/properties#late-initialized-properties&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a2f2c3c702782f18fca73e673181765083a26fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this type parameter is &lt;code&gt;reified&lt;/code&gt;. See the &lt;a href=&quot;../../../../../../docs/reference/inline-functions#reified-type-parameters&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이러한 유형의 매개 변수는 경우 &lt;code&gt;reified&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/inline-functions#reified-type-parameters&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="43312f027e03b0d0813f6bd37363cc691544b17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if this type was marked nullable in the source code.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 이 유형이 소스 코드에서 널 입력 가능으로 표시되면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="37f317994df4c5094e8b2eff3348d68fdc66f93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d588010212f4bda854e420b0e2fe0c3bfcf2c29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; specifies the 'true' value of the &lt;a href=&quot;basic-types#booleans&quot;&gt;Boolean type&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 는 &lt;a href=&quot;basic-types#booleans&quot;&gt;부울 유형&lt;/a&gt; 의 'true'값을 지정합니다</target>
        </trans-unit>
        <trans-unit id="def3b82ed42051cd1d682dd5d63d63bd8b451966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; to ignore character case when comparing characters. By default &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 문자를 비교할 때 대소 문자를 무시하려면 true 입니다. 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c263006ed892c84d96985df25d92c169c705aa72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;truncate(x)&lt;/code&gt; is &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;+Inf&lt;/code&gt; or &lt;code&gt;-Inf&lt;/code&gt; or already a mathematical integer.</source>
          <target state="translated">&lt;code&gt;truncate(x)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 입니다. 여기서 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;+Inf&lt;/code&gt; 또는 &lt;code&gt;-Inf&lt;/code&gt; 이거나 이미 수학 정수입니다.</target>
        </trans-unit>
        <trans-unit id="b005f49eb850051951850520142309885972d4b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt;&lt;a href=&quot;exceptions&quot;&gt;begins an exception handling block&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; &lt;a href=&quot;exceptions&quot;&gt;예외 처리 블록을 시작한다&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc524b0c1455c19d99ad2f0f73cdfe3b44523b81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typealias&lt;/code&gt; declares a &lt;a href=&quot;type-aliases&quot;&gt;type alias&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;typealias&lt;/code&gt; 는 &lt;a href=&quot;type-aliases&quot;&gt;타입 별칭을&lt;/a&gt; 선언합니다</target>
        </trans-unit>
        <trans-unit id="a9f304545f689ccc427483b7e430c59224af092b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typedef&lt;/code&gt; are represented as &lt;code&gt;typealias&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typedef&lt;/code&gt; 는 &lt;code&gt;typealias&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="82a10ed8d79d6bb179c17c581bca9efe81e14350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ulp&lt;/code&gt; extension property;</source>
          <target state="translated">&lt;code&gt;ulp&lt;/code&gt; 연장 특성;</target>
        </trans-unit>
        <trans-unit id="88894535390d48153d0df5237c35c261b817eee9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;until&lt;/code&gt; - must be positive.</source>
          <target state="translated">&lt;code&gt;until&lt;/code&gt; -긍정적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="70bdbcf3b6f6b264e85bd3eda2c1b89301be47b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use&lt;/code&gt; can be invoked on anything that implements the &lt;code&gt;Closeable&lt;/code&gt; interface, and when the &lt;code&gt;use&lt;/code&gt; block ends (whether normally or due to an exception), &lt;code&gt;close()&lt;/code&gt; will be called on the object upon which you invoked &lt;code&gt;use&lt;/code&gt;. If an exception is raised within the block or by &lt;code&gt;close()&lt;/code&gt;, it will bubble out of &lt;code&gt;use&lt;/code&gt;. If both the block and &lt;code&gt;close()&lt;/code&gt; raise, it's the exception from the block that will bubble out.</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; &lt;code&gt;Closeable&lt;/code&gt; 인터페이스 를 구현하는 모든 항목에서 use 를 호출 할 수 있으며 &lt;code&gt;use&lt;/code&gt; 블록이 종료 되면 (일반적으로 또는 예외로 인해 &lt;code&gt;close()&lt;/code&gt; &lt;code&gt;use&lt;/code&gt; 를 호출 한 객체 에서 close () 가 호출 됩니다 . 블록 내에서 또는 &lt;code&gt;close()&lt;/code&gt; 의해 예외가 발생하면 &lt;code&gt;use&lt;/code&gt; 중단 됩니다 . 블록과 &lt;code&gt;close()&lt;/code&gt; 모두 발생하면 블록 에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a7d080477ee6fa0bcb122170eea31fcee38caa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ushr(bits)&lt;/code&gt; &amp;ndash; unsigned shift right (Java's &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ushr(bits)&lt;/code&gt; &amp;ndash; 부호없는 시프트 오른쪽 (자바 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1f2767a8e31b1f6772a122aac9c837c1e6c8702d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val String.cstr: CValuesRef&amp;lt;ByteVar&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val String.cstr: CValuesRef&amp;lt;ByteVar&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4087cad031bb61396a802e4efc05908ac3b667f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; backing field reassignment in getter</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 게터의 val 백업 필드 재 할당</target>
        </trans-unit>
        <trans-unit id="3c47a16d0f9ef80aac46c5f31c7b824ae04dd75f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;val&lt;/code&gt; declares a read-only &lt;a href=&quot;properties&quot;&gt;property&lt;/a&gt; or &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;local variable&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 은 읽기 전용 &lt;a href=&quot;properties&quot;&gt;속성&lt;/a&gt; 또는 &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;로컬 변수를&lt;/a&gt; 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="02ec4497c1d4592ea4212ad5162dc01d2e4f19cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; - The value of captured group.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; - 캡처 그룹의 값입니다.</target>
        </trans-unit>
        <trans-unit id="23d64a7f06434d7ad3888dfa5b59c1bd1b67af84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; - must be a &lt;a href=&quot;from-value#kotlinx.cinterop.StableRef.Companion%24fromValue%28kotlinx.cinterop.CPointer%28%28kotlinx.cinterop.CPointed%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; of some &lt;a href=&quot;index&quot;&gt;StableRef&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; -해야합니다 &lt;a href=&quot;from-value#kotlinx.cinterop.StableRef.Companion%24fromValue%28kotlinx.cinterop.CPointer%28%28kotlinx.cinterop.CPointed%29%29%29%2Fvalue&quot;&gt;값&lt;/a&gt; 일부 &lt;a href=&quot;index&quot;&gt;StableRef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d9770089e6b57a87a0f774b23d5a9ee78923e8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; - necessary annotation retention (RUNTIME, BINARY or SOURCE)</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; -필요한 주석 보유 (RUNTIME, BINARY 또는 SOURCE)</target>
        </trans-unit>
        <trans-unit id="4e21c9b75cca874038882f9fe38fd5b9854e4620" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; - the new value to be assigned to this property.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; - 이 프로퍼티에 할당되는 새로운 값</target>
        </trans-unit>
        <trans-unit id="48bfefd5893711d24831fcb82c147c77d10a70a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; - the qualifier to add to the declarations in the generated code. It must be a sequence of valid JavaScript identifiers separated by the &lt;code&gt;.&lt;/code&gt; character. Examples of valid qualifiers are: &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar.Baz&lt;/code&gt;, &lt;code&gt;_.$0.f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; - 한정자는 생성 된 코드에서 선언에 추가 할 수 있습니다. 로 구분 된 유효한 JavaScript 식별자 시퀀스 여야합니다 &lt;code&gt;.&lt;/code&gt; 캐릭터. 유효한 한정자의 예는 &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar.Baz&lt;/code&gt; , &lt;code&gt;_.$0.f&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ab46dca581ecbc08183d3f197bf6ab155c81e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; - the underlying value.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; - 기본 값.</target>
        </trans-unit>
        <trans-unit id="c735a93eb7b23f076be050f35df61961783a2985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; - the value to set.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; - 설정하는 값</target>
        </trans-unit>
        <trans-unit id="e03c7180b6c060e655d4e614262a11a520f50e0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var ConsoleOutput = function (_, Kotlin) { ... }&lt;/code&gt;: this is the variable named after your Kotlin module. Its value is the result of an anonymous function call. The rest of the code is the function body.</source>
          <target state="translated">&lt;code&gt;var ConsoleOutput = function (_, Kotlin) { ... }&lt;/code&gt; : Kotlin 모듈의 이름을 딴 변수입니다. 그 값은 익명 함수 호출의 결과입니다. 나머지 코드는 함수 본문입니다.</target>
        </trans-unit>
        <trans-unit id="b9592e0a8ea83521987a70d32de67303547746c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var println = Kotlin.kotlin.io.println_s8jyv4$;&lt;/code&gt;: a variable that refers to the &lt;code&gt;kotlin.io.println&lt;/code&gt; function from the passed in parameter &lt;code&gt;Kotlin&lt;/code&gt;. This is a way to import the standard &lt;code&gt;println&lt;/code&gt; function defined in &lt;code&gt;kotlin.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var println = Kotlin.kotlin.io.println_s8jyv4$;&lt;/code&gt; : 전달 된 매개 변수 &lt;code&gt;Kotlin&lt;/code&gt; 에서 &lt;code&gt;kotlin.io.println&lt;/code&gt; 함수 를 참조하는 변수입니다 . 이것은 &lt;code&gt;kotlin.js&lt;/code&gt; 에 정의 된 표준 &lt;code&gt;println&lt;/code&gt; 함수 를 가져 오는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="1bf2c9d03fd4b30bf37e4d093f10b03acda902f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declares a mutable &lt;a href=&quot;properties&quot;&gt;property&lt;/a&gt; or &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;local variable&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 는 가변 &lt;a href=&quot;properties&quot;&gt;속성&lt;/a&gt; 또는 &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;로컬 변수를&lt;/a&gt; 선언 합니다</target>
        </trans-unit>
        <trans-unit id="5957c65f7fc9d13bc008ba085ac98603b4b442ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vararg&lt;/code&gt; allows &lt;a href=&quot;functions#variable-number-of-arguments-varargs&quot;&gt;passing a variable number of arguments for a parameter&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;vararg&lt;/code&gt; 를 사용 &lt;a href=&quot;functions#variable-number-of-arguments-varargs&quot;&gt;하면 매개 변수에 가변 개수의 인수를 전달할&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec11f8c999f8da0fd10813eac21c62770702b3c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verbose&lt;/code&gt;: Enable verbose output.</source>
          <target state="translated">&lt;code&gt;verbose&lt;/code&gt; : 상세 출력을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="92c8a0d131c26de196669d8b5862b5f1f94f1c4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt; - the version in the following formats: &lt;code&gt;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;.&amp;lt;patch&amp;gt;&lt;/code&gt;, where major, minor and patch are non-negative integer numbers without leading zeros.</source>
          <target state="translated">&lt;code&gt;version&lt;/code&gt; - &lt;code&gt;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;.&amp;lt;patch&amp;gt;&lt;/code&gt; 형식의 버전 . 여기서 major, minor 및 patch는 앞에 0이없는 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="3fb87c17236c5dc7ef81b226bbf098fd0f7c1763" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void*&lt;/code&gt; is mapped to &lt;code&gt;COpaquePointer&lt;/code&gt; &amp;ndash; the special pointer type which is the supertype for any other pointer type. So if the C function takes &lt;code&gt;void*&lt;/code&gt;, then the Kotlin binding accepts any &lt;code&gt;CPointer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void*&lt;/code&gt; 는 다른 포인터 유형의 수퍼 타입 ​​인 특수 포인터 유형 인 &lt;code&gt;COpaquePointer&lt;/code&gt; 에 맵핑됩니다 . 따라서 C 함수가 &lt;code&gt;void*&lt;/code&gt; 를 사용하면 Kotlin 바인딩은 모든 &lt;code&gt;CPointer&lt;/code&gt; 를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="9d41555163d1ffa6cdb38c81185097c14023973e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wasm32&lt;/code&gt; for WebAssembly.</source>
          <target state="translated">&lt;code&gt;wasm32&lt;/code&gt; 경우 wasm32.</target>
        </trans-unit>
        <trans-unit id="5500d7301e4bdb0a81de7eceee2cbdb55f314bf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt; begins a &lt;a href=&quot;control-flow#when-expression&quot;&gt;when expression&lt;/a&gt; (executes one of the given branches)</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; 언제&lt;a href=&quot;control-flow#when-expression&quot;&gt;when 표현을&lt;/a&gt; 시작 함 (지정된 지점 중 하나를 실행 함)</target>
        </trans-unit>
        <trans-unit id="24a7208dcca095d25e928eb5f0443e189a009f61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; - a frozen object that was attempted to mutate</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; - 돌연변이 시도 된 냉동 객체</target>
        </trans-unit>
        <trans-unit id="cae7dd02ba7a7653467a24b815acb806ba2d1eba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;where&lt;/code&gt; specifies &lt;a href=&quot;generics#upper-bounds&quot;&gt;constraints for a generic type parameter&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; &lt;a href=&quot;generics#upper-bounds&quot;&gt;제네릭 형식 매개 변수에 대한 제약 조건을&lt;/a&gt; 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e968b996ca3fbf3427be432a96c253fea7a1f13e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; begins a &lt;a href=&quot;control-flow#while-loops&quot;&gt;while loop&lt;/a&gt; (loop with precondition)</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 은 &lt;a href=&quot;control-flow#while-loops&quot;&gt;while 루프 &lt;/a&gt;를 시작합니다 (전제 조건 이 있는 루프 )</target>
        </trans-unit>
        <trans-unit id="daff7d694f02b978f83b66b6dcc3d7f9927bd522" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;windowed()&lt;/code&gt; provides more flexibility with optional parameters:</source>
          <target state="translated">&lt;code&gt;windowed()&lt;/code&gt; 는 선택적 매개 변수로 더 많은 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="efc76a751bae9b1ccb9cc3574d3350ef9f6c1bef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;withSign&lt;/code&gt; extension function;</source>
          <target state="translated">&lt;code&gt;withSign&lt;/code&gt; 확장 기능;</target>
        </trans-unit>
        <trans-unit id="c7c34b39d0ccfed20a3765c04059a5d01125f3b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x ?: y&lt;/code&gt; evaluates &lt;code&gt;x&lt;/code&gt;, which becomes the result of the expression unless it's null, in which case you'll get &lt;code&gt;y&lt;/code&gt; instead (which ought to be of a non-nullable type). This is also known as the &quot;Elvis operator&quot;. You can even use it to perform an early return in case of null:</source>
          <target state="translated">&lt;code&gt;x ?: y&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 평가합니다 . 이는 null이 아닌 한 표현식의 결과가됩니다.이 경우 &lt;code&gt;y&lt;/code&gt; 대신 null을 허용하지 않는 유형이어야합니다. 이것을 &quot;엘비스 연산자&quot;라고도합니다. null 인 경우 조기 반환을 수행하기 위해 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3374ff1d1757994cb4187ba4a59ab8ec4e5c4cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.nextTowards(y)&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt; if either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x.nextTowards(y)&lt;/code&gt; 인 &lt;code&gt;NaN&lt;/code&gt; 이 어느 경우 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 있다 &lt;code&gt;NaN&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="c214be437756d38ba63986462c6054d0ad4cccf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.roundToInt() == Int.MAX_VALUE&lt;/code&gt; when &lt;code&gt;x &amp;gt; Int.MAX_VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x.roundToInt() == Int.MAX_VALUE&lt;/code&gt; &lt;code&gt;x &amp;gt; Int.MAX_VALUE&lt;/code&gt; 경우 x.roundToInt () == Int.MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="d26413dcf8a274e128e35bc2646602784d83da34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.roundToInt() == Int.MIN_VALUE&lt;/code&gt; when &lt;code&gt;x &amp;lt; Int.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x.roundToInt() == Int.MIN_VALUE&lt;/code&gt; &lt;code&gt;x &amp;lt; Int.MIN_VALUE&lt;/code&gt; 경우 x.roundToInt () == Int.MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="d0c9eff6b586527c272cc1c787d42c0901156e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.roundToLong() == Long.MAX_VALUE&lt;/code&gt; when &lt;code&gt;x &amp;gt; Long.MAX_VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x.roundToLong() == Long.MAX_VALUE&lt;/code&gt; 경우 &lt;code&gt;x &amp;gt; Long.MAX_VALUE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612d7a72ebefaecf14c31091c444a2ebf1856013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.roundToLong() == Long.MIN_VALUE&lt;/code&gt; when &lt;code&gt;x &amp;lt; Long.MIN_VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x.roundToLong() == Long.MIN_VALUE&lt;/code&gt; &lt;code&gt;x &amp;lt; Long.MIN_VALUE&lt;/code&gt; 경우 x.roundToLong () == Long.MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="45980bc8190af90667d2abf96d483fbddc7515a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.ulp&lt;/code&gt; is &lt;code&gt;+Inf&lt;/code&gt; when &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+Inf&lt;/code&gt; or &lt;code&gt;-Inf&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x.ulp&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;+Inf&lt;/code&gt; 또는 &lt;code&gt;-Inf&lt;/code&gt; 일 때 x.ulp 는 &lt;code&gt;+Inf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f2d29bf16c333939cb9d3d3120668f3f53a8e7da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x?.y&lt;/code&gt; evaluates &lt;code&gt;x&lt;/code&gt;, and if it is not null, it evaluates &lt;code&gt;x.y&lt;/code&gt; (without reevaluating &lt;code&gt;x&lt;/code&gt;), whose result becomes the result of the expression - otherwise, you get null. This also works for functions, and it can be chained - for example, &lt;code&gt;x?.y()?.z?.w()&lt;/code&gt; will return null if any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y()&lt;/code&gt;, or &lt;code&gt;x.y().z&lt;/code&gt; produce null; otherwise, it will return the result of &lt;code&gt;x.y().z.w()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x?.y&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 를 평가 하고, null이 아닌 경우 &lt;code&gt;x&lt;/code&gt; 를 재평가하지 않고 &lt;code&gt;x.y&lt;/code&gt; 평가 하여 결과가 표현식의 결과가됩니다. 그렇지 않으면 null이됩니다. 이것은 또한 함수에서도 작동하며 연결될 수 있습니다. 예를 들어 &lt;code&gt;x?.y()?.z?.w()&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x.y()&lt;/code&gt; 또는 &lt;code&gt;x.y().z&lt;/code&gt; 가 null을 생성 하면 null을 반환합니다 . 그렇지 않으면 &lt;code&gt;x.y().z.w()&lt;/code&gt; 의 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e69551c5c0c395c32af26818569bd49f6e7cd46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xor(bits)&lt;/code&gt; &amp;ndash; bitwise xor</source>
          <target state="translated">&lt;code&gt;xor(bits)&lt;/code&gt; &amp;ndash; 비트 xor</target>
        </trans-unit>
        <trans-unit id="20792616e164307f0f6f1aaa93499e52a3e00558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xs union ys as Set&amp;lt;*&amp;gt;&lt;/code&gt; and &lt;code&gt;xs union (ys as Set&amp;lt;*&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;xs union ys as Set&amp;lt;*&amp;gt;&lt;/code&gt; 및 &lt;code&gt;xs union (ys as Set&amp;lt;*&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09ebaf312aaa17dea995318ed31531f08cae6984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{ definedExternally }&lt;/code&gt; (for functions and property getters/setters).</source>
          <target state="translated">&lt;code&gt;{ definedExternally }&lt;/code&gt; (함수 및 속성 getter / setter).</target>
        </trans-unit>
        <trans-unit id="1d141b7e10f3472c35c93ba55debb58d409df47f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{module}.js&lt;/code&gt;. The actual code from the application. All files are compiled into a single JavaScript file which has the same name as the module.</source>
          <target state="translated">&lt;code&gt;{module}.js&lt;/code&gt; . 응용 프로그램의 실제 코드 모든 파일은 모듈과 동일한 이름을 가진 단일 JavaScript 파일로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="15d6193c8855ed9061fa77c50c2fd518055b41cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt; &amp;ndash; lazy disjunction</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; &amp;ndash; 게으른 분리</target>
        </trans-unit>
        <trans-unit id="b7ffdc158a19f2718388e88f46a88dc27dc2f6d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(optionally)&lt;/em&gt; the function &lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Flambda&quot;&gt;lambda&lt;/a&gt; is invoked the amount of times specified by the &lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Fkind&quot;&gt;kind&lt;/a&gt; parameter, see the &lt;a href=&quot;../-invocation-kind/index&quot;&gt;InvocationKind&lt;/a&gt; enum for possible values.</source>
          <target state="translated">&lt;em&gt;(선택적) &lt;/em&gt;&lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Flambda&quot;&gt;람다&lt;/a&gt; 함수 가 &lt;a href=&quot;calls-in-place#kotlin.contracts.ContractBuilder%24callsInPlace%28kotlin.Function%28%28kotlin.contracts.ContractBuilder.callsInPlace.R%29%29%2C+kotlin.contracts.InvocationKind%29%2Fkind&quot;&gt;kind&lt;/a&gt; 매개 변수로 지정된 횟수만큼 &lt;a href=&quot;../-invocation-kind/index&quot;&gt;호출&lt;/a&gt; 됩니다. 가능한 값 은 InvocationKind 열거를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a41f3eb2dcb4f57ce41fe5fc3912a6b553f952d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;-n&lt;/code&gt; is optional, this flag is applied by default&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;-n&lt;/code&gt; 은 선택 사항 이며이 플래그는 기본적으로 적용됩니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="45fabde5a853ee0c0f6ca31ceb7a1d324af44bec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Association&lt;/em&gt; transformations allow building maps from the collection elements and certain values associated with them. In different association types, the elements can be either keys or values in the association map.</source>
          <target state="translated">&lt;em&gt;연관&lt;/em&gt; 변환을 통해 콜렉션 요소 및 이와 연관된 특정 값에서 맵을 작성할 수 있습니다. 다른 연관 유형에서 요소는 연관 맵의 키 또는 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d220051876daa0991641918f62919bf172ade4cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Below, we use OV for &quot;Older Version&quot;, and NV for &quot;Newer Version&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;아래에서는 &quot;이전 버전&quot;에 OV를 사용하고 &quot;최신 버전&quot;에 NV를 사용합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7a04ea9849d8f6a36fd6cd2292526633888c4ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Component functions&lt;/em&gt; generated for data classes enable their use in &lt;a href=&quot;multi-declarations&quot;&gt;destructuring declarations&lt;/a&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;데이터 클래스를 위해 생성 된 &lt;em&gt;컴포넌트 함수&lt;/em&gt; 는 &lt;a href=&quot;multi-declarations&quot;&gt;선언&lt;/a&gt; 을 파괴 할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c418bb5666878bb14d6e3e8fe48a36ecd607961" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Contracts&lt;/em&gt; allow a function to explicitly describe its behavior in a way which is understood by the compiler. Currently, two wide classes of cases are supported:</source>
          <target state="translated">&lt;em&gt;계약&lt;/em&gt; 은 함수가 컴파일러가 이해하는 방식으로 동작을 명시 적으로 설명 할 수 있도록합니다. 현재 두 가지 종류의 사례가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a7bd76c53b54562067dbff0de767e7afb868c604" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Custom&lt;/em&gt; orders let you sort instances of any type in a way you like. Particularly, you can define an order for non-comparable objects or define an order other than natural for a comparable type. To define a custom order for a type, create a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; for it. &lt;code&gt;Comparator&lt;/code&gt; contains the &lt;code&gt;compare()&lt;/code&gt; function: it takes two instances of a class and returns the integer result of the comparison between them. The result is interpreted in the same way as the result of a &lt;code&gt;compareTo()&lt;/code&gt; as is described above.</source>
          <target state="translated">&lt;em&gt;맞춤&lt;/em&gt; 주문을 통해 원하는 방식으로 모든 유형의 인스턴스를 정렬 할 수 있습니다. 특히 비교할 수없는 객체의 순서를 정의하거나 비교 가능한 유형의 자연 이외의 순서를 정의 할 수 있습니다. 유형에 대한 사용자 정의 순서를 정의하려면 해당 유형에 대한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 를 작성 하십시오. &lt;code&gt;Comparator&lt;/code&gt; 에는 &lt;code&gt;compare()&lt;/code&gt; 함수 가 포함되어 있습니다. 클래스의 두 인스턴스를 가져 와서 비교 결과의 정수 결과를 반환합니다. 결과는 위에서 설명한 것처럼 &lt;code&gt;compareTo()&lt;/code&gt; 의 결과와 동일한 방식으로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="b13944a5a494260519e59ca05924a52b544b7ab7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EduTools supports HTML and Markdown, so you can start editing with your preferred format, or even a combination of both.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;EduTools는 HTML 및 Markdown을 지원하므로 원하는 형식으로 또는 두 가지를 조합하여 편집을 시작할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="659a4e8346b2622d43a76804d7f1bd757f51adca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Example:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9423d073f2288278e51d4da68026e17ed0f5c6b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Exercise: try removing the &lt;code&gt;sleep()&lt;/code&gt; from the program above and see the result.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;연습 : 위 프로그램에서 &lt;code&gt;sleep()&lt;/code&gt; 을 제거 하고 결과를보십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="19c51704cec4376067c7ccceefc40db5f7d4eee7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you have a course archive shared with you by your teacher or co-worker, use the &lt;strong&gt;Import Course&lt;/strong&gt; icon to open it. You can also log in to &lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik&lt;/a&gt; with the corresponding link to see all the courses available to you on this MOOC platform.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;선생님이나 동료가 코스 아카이브를 공유 한 경우 &lt;strong&gt;코스 가져 오기&lt;/strong&gt; 아이콘을 사용하여 엽니 다. 해당 링크를 사용하여 &lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik에&lt;/a&gt; 로그인 하여이 MOOC 플랫폼에서 사용 가능한 모든 코스를 볼 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87b22b5d907267adae749869319e55244abf713c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you need additional files for the task, just add them and decide whether you want to make them visible to learners or not with the &lt;strong&gt;Course Creator -&amp;gt; Make Visible to / Hide from Student&lt;/strong&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;과제를 위해 추가 파일이 필요한 경우 해당 파일을 추가하고 &lt;strong&gt;Course Creator-&amp;gt; 학생에게 표시 / 숨기기&lt;/strong&gt; 로 학습자에게 표시할지 여부를 결정하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fa9e7b7c13f20dc7dbb1017d8ccafb64b41c1d6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you need to enable the course creation functionality later, you can go to &lt;strong&gt;Help Menu -&amp;gt; Enable Course Creator Features&lt;/strong&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;나중에 코스 생성 기능을 활성화해야하는 경우 &lt;strong&gt;도움말 메뉴-&amp;gt; 코스 생성기 기능 활성화&lt;/strong&gt; 로 이동할 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="049b29b7fec5dec2dc83b37d60094f5eb72988a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Keeping the Language Modern&lt;/em&gt; and &lt;em&gt;Comfortable Updates&lt;/em&gt; are among the fundamental principles in Kotlin Language Design. The former says that constructions which obstruct language evolution should be removed, and the latter says that this removal should be well-communicated beforehand to make code migration as smooth as possible.</source>
          <target state="translated">&lt;em&gt;언어를 현대&lt;/em&gt; 적이고 &lt;em&gt;편안한 업데이트&lt;/em&gt; 로 &lt;em&gt;유지하는 것은&lt;/em&gt; Kotlin 언어 디자인의 기본 원칙 중 하나입니다. 전자는 언어 진화를 방해하는 구성은 제거되어야한다고 말하고 후자는 코드 제거를 가능한 한 원활하게하기 위해이 제거를 미리 통신해야한다고 말한다.</target>
        </trans-unit>
        <trans-unit id="3576603244e907bdb431e808aa4334f0dfd3ee22" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Kotlin/Native&lt;/em&gt; follows the general tradition of Kotlin to provide excellent existing platform software interoperability. In the case of a native platform, the most important interoperability target is a C library. So &lt;em&gt;Kotlin/Native&lt;/em&gt; comes with a &lt;code&gt;cinterop&lt;/code&gt; tool, which can be used to quickly generate everything needed to interact with an external library.</source>
          <target state="translated">&lt;em&gt;Kotlin / Native&lt;/em&gt; 는 Kotlin의 일반적인 전통에 따라 기존 플랫폼 소프트웨어의 우수한 상호 운용성을 제공합니다. 기본 플랫폼의 경우 가장 중요한 상호 운용성 대상은 C 라이브러리입니다. 그래서 &lt;em&gt;코 틀린 / 네이티브&lt;/em&gt; 함께 제공 &lt;code&gt;cinterop&lt;/code&gt; 에 신속하게 외부 라이브러리와 상호 작용하는 데 필요한 모든 것을 생성하는 데 사용할 수있는 도구.</target>
        </trans-unit>
        <trans-unit id="4502b76c7c436bd8529b424c4bd0b5753f045a0c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Kotlin/Native&lt;/em&gt; interoperability</source>
          <target state="translated">&lt;em&gt;코 틀린 / 네이티브&lt;/em&gt; 상호 운용성</target>
        </trans-unit>
        <trans-unit id="4d5513502d6b608466dc3045dca786c40d13ab4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Kotlin/Native&lt;/em&gt; interoperability with Swift/Objective-C</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Swift / Objective-C와의 &lt;em&gt;Kotlin / Native&lt;/em&gt; 상호 운용성</target>
        </trans-unit>
        <trans-unit id="8f286d2c8f8e5b2a27bf2e5655ff3b65179fca09" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;List&lt;/em&gt; is an ordered collection with access to elements by indices &amp;ndash; integer numbers that reflect their position. Elements can occur more than once in a list. An example of a list is a sentence: it's a group of words, their order is important, and they can repeat.</source>
          <target state="translated">&lt;em&gt;목록&lt;/em&gt; 은 색인으로 요소에 액세스 할 수있는 순서가 지정된 모음입니다. 즉, 해당 위치를 나타내는 정수입니다. 요소는 목록에서 두 번 이상 나타날 수 있습니다. 목록의 예는 문장입니다. 단어 그룹이며 순서가 중요하며 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1186b4dcc3eb6eaf3c22facbf09f539aca82e85" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Local reference&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;지역 참조&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="874fe0819e90b83c5e086ae59719653a39342041" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Map&lt;/em&gt; (or &lt;em&gt;dictionary&lt;/em&gt;) is a set of key-value pairs. Keys are unique, and each of them maps to exactly one value. The values can be duplicates. Maps are useful for storing logical connections between objects, for example, an employee's ID and their position.</source>
          <target state="translated">&lt;em&gt;맵&lt;/em&gt; (또는 &lt;em&gt;dictionary&lt;/em&gt; )은 키-값 쌍의 세트입니다. 키는 고유하며 각 키는 정확히 하나의 값으로 매핑됩니다. 값은 중복 될 수 있습니다. 맵은 직원 ID 및 위치와 같은 객체 간의 논리적 연결을 저장하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="45c72534c997c0e4796b53d7f6858daa15ffa794" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt; for Java users: outer class does not see private members of its inner classes in Kotlin.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Java 사용자를위한 &lt;em&gt;참고&lt;/em&gt; 사항 : 외부 클래스는 Kotlin에서 내부 클래스의 개인 멤버를 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="63bb8ca23f3d7b64da126b72ed5f379b0c6c243d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: if you use a producer-object, say, &lt;code&gt;List&amp;lt;? extends Foo&amp;gt;&lt;/code&gt;, you are not allowed to call &lt;code&gt;add()&lt;/code&gt; or &lt;code&gt;set()&lt;/code&gt; on this object, but this does not mean that this object is &lt;strong&gt;immutable&lt;/strong&gt;: for example, nothing prevents you from calling &lt;code&gt;clear()&lt;/code&gt; to remove all items from the list, since &lt;code&gt;clear()&lt;/code&gt; does not take any parameters at all. The only thing guaranteed by wildcards (or other types of variance) is &lt;strong&gt;type safety&lt;/strong&gt;. Immutability is a completely different story.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 생산자 개체를 사용하는 경우 &lt;code&gt;List&amp;lt;? extends Foo&amp;gt;&lt;/code&gt; 하면 이 객체에서 &lt;code&gt;add()&lt;/code&gt; 또는 &lt;code&gt;set()&lt;/code&gt; 을 호출 할 수는 없지만 이 객체가 &lt;strong&gt;변경 불가능&lt;/strong&gt; 하다는 것을 의미하지는 않습니다 . 예를 들어 &lt;code&gt;clear()&lt;/code&gt; 를 호출 하여 목록에서 모든 항목을 제거 할 수있는 것은 없습니다 이후 &lt;code&gt;clear()&lt;/code&gt; 모두에서 매개 변수를 고려하지 않습니다. 와일드 카드 (또는 다른 유형의 분산)가 보장하는 유일한 것은 &lt;strong&gt;유형 안전성&lt;/strong&gt; 입니다. 불변성은 완전히 다른 이야기입니다.</target>
        </trans-unit>
        <trans-unit id="29c7a958d54264468bbbd1a360c401d54f68c450" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NPM Directory&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;NPM 디렉토리&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04e35c0933eb4c2013ee62c6eb2bdb148591cf07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Non-literal&lt;/em&gt; values of function types with and without receiver are interchangeable, so that the receiver can stand in for the first parameter, and vice versa. For instance, a value of type &lt;code&gt;(A, B) -&amp;gt; C&lt;/code&gt; can be passed or assigned where a &lt;code&gt;A.(B) -&amp;gt; C&lt;/code&gt; is expected and the other way around:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;수신자가 있거나없는 함수 유형의 &lt;em&gt;리터럴이 아닌&lt;/em&gt; 값은 상호 교환 가능하므로 수신자가 첫 번째 매개 변수를 사용할 수 있으며 그 반대도 가능합니다. 예를 들어, 유형 &lt;code&gt;(A, B) -&amp;gt; C&lt;/code&gt; 의 값은 &lt;code&gt;A.(B) -&amp;gt; C&lt;/code&gt; 가 예상되는 곳과 다른 방법으로 전달되거나 할당 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1856aab5e71190a041ae8f7628b67cb8336e5f54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: We'll be using IntelliJ IDEA 2018.3 EAP, Android Studio 3.2, Kotlin 1.3.21, Xcode 10.0, macOS 10.14, Gradle 4.7&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : IntelliJ IDEA 2018.3 EAP, Android Studio 3.2, Kotlin 1.3.21, Xcode 10.0, macOS 10.14, Gradle 4.7을 사용합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="59d2eea60da2292d1627875bc0a780b2c702f0f8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return a sequence of values different from the current one for a given seed.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 이후 버전의 Kotlin은이 시드 번호 생성기의 알고리즘을 변경하여 지정된 시드에 대한 현재 값과 다른 값 시퀀스를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a2e8cc61c35f195f06ee34ae26d3c7b12520e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Supporting the DWARF 2 specification means that the debugger tool recognizes Kotlin as C89, because before the DWARF 5 specification, there is no identifier for the Kotlin language type in specification.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; DWARF 2 사양을 지원한다는 것은 디버거 도구가 Kotlin을 C89로 인식한다는 것을 의미합니다. DWARF 5 사양 이전에는 사양에 Kotlin 언어 유형에 대한 식별자가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="040794cbb429ac9d018163b6bf3519024398ddfe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; that these operations, as well as all the others, are optimized for &lt;a href=&quot;basic-types&quot;&gt;Basic types&lt;/a&gt; and do not introduce overhead of function calls for them.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; 이러한 작업뿐만 아니라 모든과 다른 사람에 최적화되어 &lt;a href=&quot;basic-types&quot;&gt;기본 유형&lt;/a&gt; 과 그들을 위해 함수 호출의 오버 헤드를 도입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcf5f234032d0969342f82f537e56b60b5323593" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: &lt;code&gt;===&lt;/code&gt; and &lt;code&gt;!==&lt;/code&gt; (identity checks) are not overloadable, so no conventions exist for them.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;===&lt;/code&gt; 및 &lt;code&gt;!==&lt;/code&gt; (ID 확인)은 오버로드 할 수 없으므로 규칙이 없습니다.</target>
        </trans-unit>
        <trans-unit id="23bf6dc433043ea6e907335ee19d579468813fdb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: It is the caller's responsibility to close this reader.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; :이 리더를 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="f7d0bfa2f21f7b6c88b288ddeadf76e1308af71d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: assignments are &lt;em&gt;NOT&lt;/em&gt; expressions in Kotlin.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 과제는 Kotlin의 표현식 이 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0b2fe6bb5cbc7bd540eb87f54d19fe6afc7ecaa7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: star-projections are very much like Java's raw types, but safe.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 별 투영법은 Java의 원시 유형과 매우 유사하지만 안전합니다.</target>
        </trans-unit>
        <trans-unit id="188f0e99ec34e6faf653bbe372fe89e0b1df1e99" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: the caller must close the underlying &lt;code&gt;BufferedReader&lt;/code&gt; when the iteration is finished; as the user may not complete the iteration loop (e.g. using a method like find() or any() on the iterator may terminate the iteration early.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 반복이 완료되면 호출자는 기본 &lt;code&gt;BufferedReader&lt;/code&gt; 를 닫아야합니다 . 사용자가 반복 루프를 완료 할 수 없기 때문에 (예 : 반복자에서 find () 또는 any ()와 같은 메소드를 사용하면 반복을 조기에 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6077463a7821fabdfcddc51e1d079b428ff632c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PECS stands for Producer-Extends, Consumer-Super.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PECS는 Producer-Extends, Consumer-Super의 약자입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d5f69854615ad613761dad73544b24609c7393e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;REPL&lt;/em&gt; (&lt;em&gt;Read-Eval-Print-Loop&lt;/em&gt;) is a tool for running Kotlin code interactively. REPL lets you evaluate expressions and code chunks without creating projects or even functions if you don't need them.</source>
          <target state="translated">&lt;em&gt;REPL&lt;/em&gt; ( &lt;em&gt;Read-Eval-Print-Loop&lt;/em&gt; )은 Kotlin 코드를 대화식으로 실행하기위한 도구입니다. REPL을 사용하면 필요하지 않은 프로젝트 나 함수를 만들지 않고도 식과 코드 청크를 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59a2e517268ae0cd8fd535db48b8568de9aff4ed" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set&lt;/em&gt; is a collection of unique elements. It reflects the mathematical abstraction of set: a group of objects without repetitions. Generally, the order of set elements has no significance. For example, an alphabet is a set of letters.</source>
          <target state="translated">&lt;em&gt;세트&lt;/em&gt; 는 고유 한 요소의 모음입니다. 그것은 집합의 수학적 추상화를 반영합니다 : 반복이없는 객체 그룹. 일반적으로 세트 요소의 순서는 중요하지 않습니다. 예를 들어 알파벳은 문자 집합입니다.</target>
        </trans-unit>
        <trans-unit id="631c0992c7446670a06fcd8ad234a30589710f5d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Stateful&lt;/em&gt; operations require a significant amount of state, usually proportional to the number of elements in a sequence.</source>
          <target state="translated">&lt;em&gt;상태 저장&lt;/em&gt; 작업에는 일반적으로 시퀀스의 요소 수에 비례하여 상당한 양의 상태가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5f6efe07b5f8e4e3dbf8a7561b88e3c9f1e4b50f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Stateless&lt;/em&gt; operations require no state and process each element independently, for example, &lt;a href=&quot;collection-transformations#mapping&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;collection-filtering&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;. Stateless operations can also require a small constant amount of state to process an element, for example, &lt;a href=&quot;collection-parts&quot;&gt;&lt;code&gt;take()&lt;/code&gt; or &lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;상태 비 저장&lt;/em&gt; 작업에는 상태가 필요하지 않으며 각 요소를 독립적으로 처리합니다 &lt;a href=&quot;collection-transformations#mapping&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 예 : map () 또는 &lt;a href=&quot;collection-filtering&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; . 상태 비 저장 연산은 요소를 처리하기 위해 적은 양의 상태 &lt;a href=&quot;collection-parts&quot;&gt; &lt;code&gt;take()&lt;/code&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt; 예 : take () 또는 drop () )가 필요할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50e5e63d3f187bbf7ba89581b75756435db1b274" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This material was written by &lt;a href=&quot;https://eldhuset.net/&quot;&gt;Aasmund Eldhuset&lt;/a&gt;; it is owned by &lt;a href=&quot;https://www.khanacademy.org/&quot;&gt;Khan Academy&lt;/a&gt; and is licensed for use under &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/3.0/us/&quot;&gt;CC BY-NC-SA 3.0 US&lt;/a&gt;. Please note that this is not a part of Khan Academy's official product offering.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 자료는 &lt;a href=&quot;https://eldhuset.net/&quot;&gt;Aasmund Eldhuset에&lt;/a&gt; 의해 작성되었습니다 . &lt;a href=&quot;https://www.khanacademy.org/&quot;&gt;Khan Academy의&lt;/a&gt; 소유이며 &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/3.0/us/&quot;&gt;CC BY-NC-SA 3.0 US에&lt;/a&gt; 따라 사용이 허가되었습니다 . 이것은 Khan Academy의 공식 제품 오퍼링의 일부가 아닙니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="910f279e582ad2e5260799349d5443d8807a642f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Thread confinement&lt;/em&gt; is an approach to the problem of shared mutable state where all access to the particular shared state is confined to a single thread. It is typically used in UI applications, where all UI state is confined to the single event-dispatch/application thread. It is easy to apply with coroutines by using a</source>
          <target state="translated">&lt;em&gt;스레드 제한&lt;/em&gt; 은 특정 공유 상태에 대한 모든 액세스가 단일 스레드로 제한되는 공유 변경 가능 상태 문제에 대한 접근 방식입니다. 일반적으로 모든 UI 상태가 단일 이벤트 디스패치 / 응용 프로그램 스레드로 제한되는 UI 응용 프로그램에서 사용됩니다. 코 루틴을 사용하면 쉽게 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="706b737eee14b7f5a8c622b04efa8e01738bc90d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning:&lt;/em&gt; having the &lt;strong&gt;kotlin.code.style&lt;/strong&gt; option set may modify the code style scheme during a project import and may change the code style settings.</source>
          <target state="translated">&lt;em&gt;경고 :&lt;/em&gt; 가진 &lt;strong&gt;kotlin.code.style&lt;/strong&gt; 옵션을 설정하면 프로젝트 가져 오는 동안 코드 스타일 방식을 수정할 수 있으며, 코드 스타일 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a093b969f7d46881837e46d103727f5ff74971ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Zipping&lt;/em&gt; transformation is building pairs from elements with the same positions in both collections. In the Kotlin standard library, this is done by the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip&quot;&gt;&lt;code&gt;zip()&lt;/code&gt;&lt;/a&gt; extension function. When called on a collection or an array with another collection (array) as an argument, &lt;code&gt;zip()&lt;/code&gt; returns the &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Pair&lt;/code&gt; objects. The elements of the receiver collection are the first elements in these pairs. If the collections have different sizes, the result of the &lt;code&gt;zip()&lt;/code&gt; is the smaller size; the last elements of the larger collection are not included in the result. &lt;code&gt;zip()&lt;/code&gt; can also be called in the infix form &lt;code&gt;a zip b&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;압축&lt;/em&gt; 변환은 두 컬렉션에서 동일한 위치를 가진 요소로 쌍을 작성합니다. Kotlin 표준 라이브러리에서 이것은 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip&quot;&gt; &lt;code&gt;zip()&lt;/code&gt; &lt;/a&gt; 확장 함수에 의해 수행됩니다 . 컬렉션 또는 다른 컬렉션 (배열)을 인수로 가진 배열에서 컬렉션을 호출하면 &lt;code&gt;zip()&lt;/code&gt; 은 &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Pair&lt;/code&gt; 객체를 반환 합니다. 수신자 콜렉션의 요소는이 쌍의 첫 번째 요소입니다. 컬렉션의 크기가 다른 경우 &lt;code&gt;zip()&lt;/code&gt; 의 결과 는 더 작은 크기입니다. 더 큰 컬렉션의 마지막 요소는 결과에 포함되지 않습니다. &lt;code&gt;zip()&lt;/code&gt; 은 &lt;code&gt;a zip b&lt;/code&gt; 형식으로 호출 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a0ae4f8623f1204b137519166f3471d061141c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;break&lt;/em&gt;. Terminates the nearest enclosing loop.</source>
          <target state="translated">&lt;em&gt;휴식&lt;/em&gt; . 가장 가까운 엔 클로징 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="1fc9ae085051cd3bde519375f6ccb827b0ffca8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;continue&lt;/em&gt;. Proceeds to the next step of the nearest enclosing loop.</source>
          <target state="translated">&lt;em&gt;계속하십시오&lt;/em&gt; . 가장 가까운 엔 클로징 루프의 다음 단계로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="2fae5fac1bba1876e2e3e8934d6a21a13581fb96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;for&lt;/em&gt; loop iterates through anything that provides an iterator. This is equivalent to the &lt;code&gt;foreach&lt;/code&gt; loop in languages like C#. The syntax is as follows:</source>
          <target state="translated">&lt;em&gt;for&lt;/em&gt; 루프는 반복자를 제공하는 모든 것을 반복합니다. 이것은 C #과 같은 언어 의 &lt;code&gt;foreach&lt;/code&gt; 루프와 같습니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="024028479e6e97eb843fc2a724c8de4a52bce8fe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;if&lt;/em&gt; branches can be blocks, and the last expression is the value of a block:</source>
          <target state="translated">&lt;em&gt;만약&lt;/em&gt; 분기 차단 될 수 있으며, 마지막 식은 블록의 값이다 :</target>
        </trans-unit>
        <trans-unit id="dea9927b516af2bd807f59e8615ba5e0b60ac8c6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;return&lt;/em&gt;. By default returns from the nearest enclosing function or &lt;a href=&quot;lambdas#anonymous-functions&quot;&gt;anonymous function&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;return&lt;/em&gt; . 기본적으로 가장 가까운 엔 클로징 함수 또는 &lt;a href=&quot;lambdas#anonymous-functions&quot;&gt;익명 함수&lt;/a&gt; 에서 돌아옵니다 .</target>
        </trans-unit>
        <trans-unit id="6818df73127c5514eddaf002c7f2a1095842a492" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateful&lt;/em&gt; &amp;ndash; operations which require a significant amount of state, usually proportional to the number of elements in a sequence.</source>
          <target state="translated">&lt;em&gt;상태 저장&lt;/em&gt; &amp;ndash; 일반적으로 시퀀스의 요소 수에 비례하여 상당한 양의 상태가 필요한 작업입니다.</target>
        </trans-unit>
        <trans-unit id="9a383ab6a7ce61301658faa8f457297f7587f38f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless&lt;/em&gt; &amp;ndash; operations which require no state and process each element independently like &lt;a href=&quot;map&quot;&gt;kotlin.sequences.Sequence.map&lt;/a&gt;, &lt;a href=&quot;filter&quot;&gt;kotlin.sequences.Sequence.filter&lt;/a&gt;, or require a small constant amount of state to process an element, for example &lt;a href=&quot;take&quot;&gt;kotlin.sequences.Sequence.take&lt;/a&gt; or &lt;a href=&quot;drop&quot;&gt;kotlin.sequences.Sequence.drop&lt;/a&gt;;</source>
          <target state="translated">&lt;em&gt;stateless&lt;/em&gt; &amp;ndash; 상태가 필요하지 않고 &lt;a href=&quot;map&quot;&gt;kotlin.sequences.Sequence.map&lt;/a&gt; , &lt;a href=&quot;filter&quot;&gt;kotlin.sequences.Sequence.filter&lt;/a&gt; 와 같이 각 요소를 독립적 으로 처리하는 작업 또는 요소를 처리하기 위해 적은 양의 상태 (예 : &lt;a href=&quot;take&quot;&gt;kotlin.sequences.Sequence)가 필요한 작업 take&lt;/a&gt; 또는 &lt;a href=&quot;drop&quot;&gt;kotlin.sequences.Sequence.drop&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="f8f3cb42bf6ed30e905b895543705f8c4b226960" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;try&lt;/em&gt; is an expression, i.e. it may have a return value:</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; 는 표현식입니다. 즉, 반환 값이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee13dff39772084153285c9ab7db6f40f001178c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;val&lt;/em&gt; local variables - always except for &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;local delegated properties&lt;/a&gt;;</source>
          <target state="translated">&lt;em&gt;val&lt;/em&gt; 로컬 변수-항상 &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;로컬 위임 속성을&lt;/a&gt; 제외하고 ;</target>
        </trans-unit>
        <trans-unit id="dbbca77ad89d50bc4392cdeb284bc14af782494b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;val&lt;/em&gt; properties - if the property is private or internal or the check is performed in the same &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;module&lt;/a&gt; where the property is declared. Smart casts aren't applicable to open properties or properties that have custom getters;</source>
          <target state="translated">&lt;em&gt;val&lt;/em&gt; properties-프로퍼티가 private 또는 internal이거나 체크가 프로퍼티가 선언 된 동일한 &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;모듈&lt;/a&gt; 에서 수행되는 경우 . 스마트 캐스트는 개방형 속성 또는 사용자 지정 게터가있는 속성에는 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfba4354a071acc509eef85bb2cde7f8f572beb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;var&lt;/em&gt; local variables - if the variable is not modified between the check and the usage, is not captured in a lambda that modifies it, and is not a local delegated property;</source>
          <target state="translated">&lt;em&gt;var&lt;/em&gt; local variables-확인과 사용법 사이에 변수가 수정되지 않은 경우 변수를 수정하는 람다에서 캡처되지 않으며 로컬 위임 속성이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ebb85acb44a1d6bdf51052766b0c4f41e4e6c8e8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;var&lt;/em&gt; properties - never (because the variable can be modified at any time by other code).</source>
          <target state="translated">&lt;em&gt;var&lt;/em&gt; properties-never (다른 코드로 변수를 언제든지 수정할 수 있기 때문에).</target>
        </trans-unit>
        <trans-unit id="6a9ab26e9c7534ce384d0294db420889f6805e8f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;when&lt;/em&gt; can also be used as a replacement for an &lt;em&gt;if&lt;/em&gt;-&lt;em&gt;else&lt;/em&gt;&lt;em&gt;if&lt;/em&gt; chain. If no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true:</source>
          <target state="translated">&lt;em&gt;when&lt;/em&gt; 은 &lt;em&gt;if&lt;/em&gt; - &lt;em&gt;else &lt;/em&gt;&lt;em&gt;if&lt;/em&gt; 체인을 대신 할 때도 사용할 수 있습니다 . 인수가 제공되지 않으면 분기 조건은 단순히 부울 표현식이며 해당 조건이 참이면 분기가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7152778e403c1ac4ea488ef3a7338a2fed9e905b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;when&lt;/em&gt; matches its argument against all branches sequentially until some branch condition is satisfied. &lt;em&gt;when&lt;/em&gt; can be used either as an expression or as a statement. If it is used as an expression, the value of the satisfied branch becomes the value of the overall expression. If it is used as a statement, the values of individual branches are ignored. (Just like with &lt;em&gt;if&lt;/em&gt;, each branch can be a block, and its value is the value of the last expression in the block.)</source>
          <target state="translated">&lt;em&gt;when&lt;/em&gt; 는 일부 분기 조건이 충족 될 때까지 모든 분기에 대한 인수를 순차적으로 일치시킵니다. &lt;em&gt;언제&lt;/em&gt; 표현식이나 명령문으로 사용할 수 있습니다. 표현식으로 사용되는 경우 만족 분기의 값이 전체 표현식의 값이됩니다. 명령문으로 사용되면 개별 분기의 값이 무시됩니다. ( &lt;em&gt;if&lt;/em&gt; 와 마찬가지로 각 분기는 블록이 될 수 있으며 해당 값은 블록의 마지막 표현식 값입니다.)</target>
        </trans-unit>
        <trans-unit id="c8e5919fb828e6c0e57dc91bc792845c60fbc090" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;when&lt;/em&gt; replaces the switch operator of C-like languages. In the simplest form it looks like this</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;C와 같은 언어의 스위치 연산자를 대체 &lt;em&gt;할 때 &lt;/em&gt;가장 간단한 형태는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="cadb0d35f3f46fa49ecd548b003d7faa1bbbf6f0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;while&lt;/em&gt; and &lt;em&gt;do&lt;/em&gt;..&lt;em&gt;while&lt;/em&gt; work as usual</source>
          <target state="translated">&lt;em&gt;잠시&lt;/em&gt; 및 &lt;em&gt;할&lt;/em&gt; ... &lt;em&gt;동안&lt;/em&gt; 평소와 같이 작업</target>
        </trans-unit>
        <trans-unit id="e28d6974a292f791dfa9570cc846dfbebb1996ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Existentialism&quot;&gt;The Existential&lt;/a&gt; Transformation: Consumer in, Producer out!&lt;/strong&gt; :-)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Existentialism&quot;&gt;기존의&lt;/a&gt; 변혁 : 소비자, 생산자 아웃! &lt;/strong&gt;:-)</target>
        </trans-unit>
        <trans-unit id="13cd3975ed9d952faf27bb193361480231851f32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;AMD&lt;/strong&gt; is usually used on the client-side in the browser. The idea behind AMD is to load modules asynchronously, thus improving usability and performance.</source>
          <target state="translated">&lt;strong&gt;AMD&lt;/strong&gt; 는 일반적으로 브라우저의 클라이언트 쪽에서 사용됩니다. AMD의 기본 개념은 모듈을 비동기식으로로드하여 사용 성과 성능을 향상시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2eee24e834eab0cf33cffaf4ba989326f94f7f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Access to a link task.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;링크 작업에 액세스합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f78c8faa5b7756989f20d6c8d362cd17ed051ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Access to a run task&lt;/strong&gt; (for executable binaries only). The &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin creates run tasks for all executable binaries of host platforms (Windows, Linux and macOS). Names of such tasks are based on binary names, e.g. &lt;code&gt;runReleaseExecutable&amp;lt;target-name&amp;gt;&lt;/code&gt; or &lt;code&gt;runFooDebugExecutable&amp;lt;target-name&amp;gt;&lt;/code&gt;. A run task can be accessed using the &lt;code&gt;runTask&lt;/code&gt; property of an executable binary.</source>
          <target state="translated">&lt;strong&gt;실행 작업에 액세스합니다&lt;/strong&gt; (실행 파일 바이너리에만 해당). &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인은 호스트 플랫폼 (윈도우, 리눅스 및 맥 OS)의 모든 실행 바이너리에 대한 작업을 실행 만듭니다. 이러한 작업의 이름은 이진 이름을 기반으로합니다 (예 : &lt;code&gt;runReleaseExecutable&amp;lt;target-name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;runFooDebugExecutable&amp;lt;target-name&amp;gt;&lt;/code&gt; . 실행 작업은 실행 가능한 바이너리 의 &lt;code&gt;runTask&lt;/code&gt; 속성을 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffb694371c68f79144ae5e974cc0bac3a52aefda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Access to the output file.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;출력 파일에 액세스합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cbc4c63ce2666097dc25aafd5454709270d0d5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Additions in Incremental Releases (AIR)&lt;/strong&gt;: things can be added in an incremental release, removals and changes of behavior should be avoided and announced in a previous incremental release if necessary.</source>
          <target state="translated">&lt;strong&gt;AIR (증분 릴리스)에&lt;/strong&gt; 추가 : 증분 릴리스에 항목을 추가 할 수 있으며, 필요한 경우 이전 증분 릴리스에서 동작의 제거 및 변경을 피하고 발표해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3a06f48618a6881b4838d68e7146e16182e8956" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All other experimental features, by default&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본적으로 다른 모든 실험 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d73b60aede97b7d47d99bc8d4268962a141a28ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Author&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Author&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a884c1a4a2719a1b309626fcd958b7136a0ace1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available for&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;사용 가능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="385f83ef45a08a7675930a15034fe1f85ec3a398" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Binary kind&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이진 종류&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a60efc1de782ecd0c495005460eb05ffd095f88a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comfortable Updates&lt;/strong&gt;. Incompatible changes, such as removing things from a language, may lead to painful migration from one version to the next if carried out without proper care. We will always announce such changes well in advance, mark things as deprecated and provide automated migration tools &lt;em&gt;before the change happens&lt;/em&gt;. By the time the language is changed we want most of the code in the world to be already updated and thus have no issues migrating to the new version.</source>
          <target state="translated">&lt;strong&gt;편안한 업데이트&lt;/strong&gt; . 언어에서 사물을 제거하는 등 호환되지 않는 변경은 적절한 관리없이 수행 할 경우 한 버전에서 다음 버전으로 고통스럽게 마이그레이션 할 수 있습니다. 우리는 항상 그러한 변경 사항을 미리 발표하고 더 이상 사용되지 않는 것으로 표시 &lt;em&gt;하고 변경이 발생하기 전에&lt;/em&gt; 자동 마이그레이션 도구 &lt;em&gt;를&lt;/em&gt; 제공 &lt;em&gt;합니다&lt;/em&gt; . 언어가 변경 될 때 전 세계 대부분의 코드가 이미 업데이트되기를 원하므로 새 버전으로 마이그레이션하는 데 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a90f28a34743ebe55cbb12c9c066936868abe54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CommonJS&lt;/strong&gt; is the module system used on the server-side, and in particular with node.js. Node modules all abide by this definition. CommonJS modules can also be used in the browser via &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;CommonJS&lt;/strong&gt; 는 서버 측, 특히 node.js에서 사용되는 모듈 시스템입니다. 노드 모듈은 모두이 정의를 준수합니다. &lt;a href=&quot;http://browserify.org/&quot;&gt;BrowserJise&lt;/a&gt; 를 통해 브라우저에서 CommonJS 모듈을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1195ec2bac12543bdb05c5a7c57c172f7bb32f0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compatibility&lt;/strong&gt;: Kotlin is fully compatible with JDK 6, ensuring that Kotlin applications can run on older Android devices with no issues. The Kotlin tooling is fully supported in Android Studio and compatible with the Android build system.</source>
          <target state="translated">&lt;strong&gt;호환성&lt;/strong&gt; : Kotlin은 JDK 6과 완벽하게 호환되므로 Kotlin 응용 프로그램을 문제없이 구형 Android 장치에서 실행할 수 있습니다. Kotlin 툴링은 Android Studio에서 완벽하게 지원되며 Android 빌드 시스템과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="c2ae471fc641370e12b5409285bdaee90823a077" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compilation Time&lt;/strong&gt;: Kotlin supports efficient incremental compilation, so while there's some additional overhead for clean builds, &lt;a href=&quot;https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d&quot;&gt;incremental builds are usually as fast or faster than with Java&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;컴파일 시간&lt;/strong&gt; : Kotlin은 효율적인 증분 컴파일을 지원하므로 클린 빌드에는 추가 오버 헤드가 있지만 &lt;a href=&quot;https://medium.com/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d&quot;&gt;증분 빌드는 일반적으로 Java보다 빠르거나 빠릅니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f38fcdc20544f4bd9f6e680c2daf1906f6c4fd80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compilation.&lt;/strong&gt; Each binary is built on basis of some compilation available in the same target. The default value of this parameter depends on the binary type: &lt;code&gt;Test&lt;/code&gt; binaries are based on the &lt;code&gt;test&lt;/code&gt; compilation while other binaries - on the &lt;code&gt;main&lt;/code&gt; compilation.</source>
          <target state="translated">&lt;strong&gt;편집. &lt;/strong&gt;각 바이너리는 동일한 대상에서 사용 가능한 일부 컴파일을 기반으로 빌드됩니다. 이 매개 변수의 기본값은 이진 유형에 따라 다릅니다. &lt;code&gt;Test&lt;/code&gt; 이진은 &lt;code&gt;test&lt;/code&gt; 컴파일을 기반으로하는 반면 다른 이진은 &lt;code&gt;main&lt;/code&gt; 컴파일을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="12d7a969ac1d8b31d7d77682b70cb08343ef279a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Component&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Component&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6ac230639a723040fdf0abd0778656ec5abd84a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Component&lt;/strong&gt;: Core language</source>
          <target state="translated">&lt;strong&gt;구성 요소&lt;/strong&gt; : 핵심 언어</target>
        </trans-unit>
        <trans-unit id="227fc1c09b15a2df831a0a95dbc64fd964bede49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Component&lt;/strong&gt;: Kotlin/JVM</source>
          <target state="translated">&lt;strong&gt;구성 요소&lt;/strong&gt; : Kotlin / JVM</target>
        </trans-unit>
        <trans-unit id="7570c0f126329c1405dbe8897b36472d6d303239" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Component&lt;/strong&gt;: kotlin-stdlib (JVM)</source>
          <target state="translated">&lt;strong&gt;구성 요소&lt;/strong&gt; : kotlin-stdlib (JVM)</target>
        </trans-unit>
        <trans-unit id="4000e9f93b9f3c271b29de49b2a9e0b10cab6782" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Component&lt;/strong&gt;: other</source>
          <target state="translated">&lt;strong&gt;구성 요소&lt;/strong&gt; : 기타</target>
        </trans-unit>
        <trans-unit id="08d0f1462630b68dd58d9cdbdd352aa89e99d312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components&lt;/strong&gt;: Core language</source>
          <target state="translated">&lt;strong&gt;구성 요소&lt;/strong&gt; : 핵심 언어</target>
        </trans-unit>
        <trans-unit id="9db8723ef2c0043bd70e12ab4791d09224937133" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.BooleanArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소가 &lt;code&gt;false&lt;/code&gt; 로 초기화 된 상태 에서 지정된 &lt;a href=&quot;size#kotlin.BooleanArray%24size&quot;&gt;크기&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2fa5199c1b27f8f9a99026303ae0a4378faad501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.ByteArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to zero.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소를 ​​0으로 초기화 하여 지정된 &lt;a href=&quot;size#kotlin.ByteArray%24size&quot;&gt;크기&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="bd6cf7b5ab4b4150353ed0a9e4a7cb00caff108d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.CharArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to null char (`\u0000').</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소가 null 문자 (`\ u0000 ')로 초기화되어 지정된 &lt;a href=&quot;size#kotlin.CharArray%24size&quot;&gt;size&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c4a7d8f52ac7620beff100e289d8b02da39d85b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.DoubleArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to zero.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소를 ​​0으로 초기화 하여 지정된 &lt;a href=&quot;size#kotlin.DoubleArray%24size&quot;&gt;크기&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="272ce437857108ed3f51611ec719d9d62bce42e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.FloatArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to zero.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소를 ​​0으로 초기화 하여 지정된 &lt;a href=&quot;size#kotlin.FloatArray%24size&quot;&gt;크기&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="39b826b50a38a1d30be53e1f28766e61502287c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.IntArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to zero.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소를 ​​0으로 초기화 하여 지정된 &lt;a href=&quot;size#kotlin.IntArray%24size&quot;&gt;크기&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6d03fb49a23f0ce8c38e59382849faa4a71f484c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.LongArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to zero.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소를 ​​0으로 초기화 하여 지정된 &lt;a href=&quot;size#kotlin.LongArray%24size&quot;&gt;크기&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="813f2bea41ba6fef32ee0e8bc42727148fe8fccc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new array of the specified &lt;a href=&quot;size#kotlin.ShortArray%24size&quot;&gt;size&lt;/a&gt;, with all elements initialized to zero.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 모든 요소를 ​​0으로 초기화 하여 지정된 &lt;a href=&quot;size#kotlin.ShortArray%24size&quot;&gt;크기&lt;/a&gt; 의 새 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="335d26c199adf06488a8913460409837d4075696" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a new instance of Pair.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; Pair의 새 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="773b394be7f65a95c85016d615a1c621ce6c3bc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a regular expression from the specified &lt;a href=&quot;pattern#kotlin.text.Regex%24pattern&quot;&gt;pattern&lt;/a&gt; string and the specified set of &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;options&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 지정된 &lt;a href=&quot;pattern#kotlin.text.Regex%24pattern&quot;&gt;패턴&lt;/a&gt; 문자열과 지정된 &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;옵션&lt;/a&gt; 세트 에서 정규식을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2d15192253b231c1119607339e0a2590a4bb77e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; Creates a version from all three components.</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 세 가지 구성 요소 모두에서 버전을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9569df5f31e8b5de73e6d92b548ff29f2d98a7b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor&lt;/strong&gt; creates an empty bit set with the specified &lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;생성자&lt;/strong&gt; 는 지정된 &lt;a href=&quot;size&quot;&gt;크기&lt;/a&gt; 로 빈 비트 세트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e0096f245c9fae0805031521bff1005fcb0b2f31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Copy runtime library files&lt;/strong&gt;. Indicates in what subfolder we want the &lt;code&gt;kotlin.js&lt;/code&gt; library to be output to. By default it is &lt;code&gt;lib&lt;/code&gt; which is why in the HTML we are referencing this path.</source>
          <target state="translated">&lt;strong&gt;런타임 라이브러리 파일을 복사하십시오&lt;/strong&gt; . &lt;code&gt;kotlin.js&lt;/code&gt; 라이브러리를 출력 할 하위 폴더를 나타냅니다 . 기본적으로 &lt;code&gt;lib&lt;/code&gt; 이므로 HTML에서이 경로를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="413b10e9ad8da201e3bf3c2f9c2446ab5e5202bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Add @OverrideInit to constructor to make it override Objective-C initializer</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; Objective-C 초기화 프로그램을 재정의하도록 생성자에 @OverrideInit 추가</target>
        </trans-unit>
        <trans-unit id="adf56d13cf05b3f392462e1af11305676e27e873" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Do not use Synchronized annotation in pure Kotlin/JS code</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 순수한 Kotlin / JS 코드에서 동기화 된 주석을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="452fddb0e520391a9f67bc97f96be7bea4bd264d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Do not use Synchronized annotation in pure Kotlin/Native code</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 순수한 Kotlin / 네이티브 코드에서 동기화 된 주석을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="dfab3c6713337be01b7128770be5faa0fa8ff4f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Do not use Volatile annotation in pure Kotlin/JS code</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 순수한 Kotlin / JS 코드에서 휘발성 주석을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="48cec979b523be2447f63e1e317c3d78c8ec346b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Do not use Volatile annotation in pure Kotlin/Native code</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 순수한 Kotlin / 네이티브 코드에서 휘발성 주석을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="abe0bb35ec6506cafc1fd50dc083e5353ead7ec6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Provided for binary compatibility</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 이진 호환성 제공</target>
        </trans-unit>
        <trans-unit id="1231e7a7a6d5a83c2cd105b0352613d2c669daac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Synchronization on any object is not supported on every platform and will be removed from the common standard library soon.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 모든 플랫폼에서 객체에 대한 동기화가 지원되는 것은 아니며 곧 공통 표준 라이브러리에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f426529b7537c1615991e33fc1bd17f18c166bbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 정수와 부동 소수점 인수를 혼합하는이 '포함'연산에는 의미가 모호하므로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="752efaab5e33671c902096353a2f29f2232a126d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; This exception type is not supposed to be thrown or caught in common code and will be removed from kotlin-stdlib-common soon.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 이 예외 유형은 공통 코드에서 발생하거나 포착되지 않아야하며 kotlin-stdlib-common에서 곧 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c8a88fa21880c017378826441e400ceb55798c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; This function creates a type which rarely makes sense for generic classes. For example, such type can only be used in signatures of members of that class. Use starProjectedType or createType() for clearer semantics.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 이 함수는 일반 클래스에는 거의 적합하지 않은 유형을 만듭니다. 예를 들어, 이러한 유형은 해당 클래스 구성원의 서명에만 사용할 수 있습니다. 보다 명확한 의미를 위해서는 starProjectedType 또는 createType ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f6bbf8f9eac350e7835725133adee88cb6daeb2a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use 'iterator { }' function instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 'iterator {}'함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="447e915d652609535feb5b69ab9a433b444d89d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use 'java' property to get Java class corresponding to this Kotlin class or cast this instance to Any if you really want to get the runtime Java class of this implementation of KClass.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 이 Ktlin 클래스에 해당하는 Java 클래스를 가져 오거나이 KClass 구현의 런타임 Java 클래스를 실제로 얻으려면이 인스턴스를 Any로 캐스트하려면 'java'속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8bc948514b2df4ec7b49af73847c66c422a6ed1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use 'sequence { }' function instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 'sequence {}'함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="124528a176dd411bf469d0f779b788eae05e15e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use 'waitForMultipleFutures' top-level function instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 'waitForMultipleFutures'최상위 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2a85d8342cdd2702e8a490e130e9e49ba012a310" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use .asCPointer() instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 .asCPointer () 사용</target>
        </trans-unit>
        <trans-unit id="3c1b654b2f837e72b5dbf3da907e460ec7e7cbf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use CPointer&amp;lt;*&amp;gt;.asStableRef&amp;lt;T&amp;gt;() instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 CPointer &amp;lt;*&amp;gt;. asStableRef &amp;lt;T&amp;gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9c3a310a1e69ca97ad036df74b2c5f423341adda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use Default companion object instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 기본 도우미 개체를 사용하십시오 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d774f0846c9725096d6868d8250a661e8c97f71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use Random.nextDouble instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 Random.nextDouble을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cca46c363e63f0970ef54a11a4bf2ba63e633ff7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use SequenceScope class instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; SequenceScope 클래스를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17d5f606b3230bf8deaf75eb0b98aaaae44c6e23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use StableRef&amp;lt;T&amp;gt; instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 StableRef &amp;lt;T&amp;gt;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fdbc2696154545aa9ace3d52789ca4ac09a165c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use `definedExternally` instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신`definedExternally`를 사용하십시오 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba5914429156c8fc516a3f59beaf39b64a5e9cf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use `external` modifier instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신`external` 수정자를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="58d5cf286d92237119359612e84665c034969d7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use class literal and extension property `js` instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 클래스 리터럴 및 확장 속성 'js'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6de5f60695de863a66440239847cc9793b2b34e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use encodeToByteArray instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 encodeToByteArray를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc9ed721d2dc4d3944528cb9641d6cef4c21af83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use inline extension function with body using dynamic</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 동적을 사용하여 본문에 인라인 확장 기능 사용</target>
        </trans-unit>
        <trans-unit id="12c35b94f395f24afe7b8a4a286110b23a581b2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.PI instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.PI를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33efd05b987cdb7650f554bb37295f9999c0a2cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.abs instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.abs를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f1cb5563ed7231c2dab46e4f16297df892fb2e3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.acos instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.acos를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="996e58906ac50a84be19234bc9cde02bf073f083" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.asin instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.asin을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66a5d5ed239001acbd826d1714135e01284998ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.atan instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.atan을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa95d4bb6ea3af355c890298bd2a4a41700b68b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.atan2 instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.atan2를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="60143061b29098b9cb54a512540ac43d6f76ed28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.ceil instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.ceil을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c3f82eb454195f9e9e74a70809de173e944ec2a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.cos instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.cos를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bdcd7c3509a842b932a3f5944db27c5018dc94b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.exp instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.exp를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8000773b5e7d1f1f4a888e5b5b80592a088ff6c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.floor instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.floor를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="332d44171961144416b8a0033b7de5cccca96db0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.ln instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.ln을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2debbe1367cb0ab7c89bd4b93284a48bcd20a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.pow instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.pow를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdfcdc89fe10b37e662854d2fc47c6d1e309ead4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.round instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.round를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e419fa79027d809dbd2513aa857fe253bc15eaaf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.sin instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.sin을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7b26bc4743b50acba4d04d18114fa6c724fbf393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.sqrt instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.sqrt를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73d824d8a988bfdb22175bdfe46aa11970bc50ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use kotlin.math.tan instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math.tan을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e1a0fcaa718d82676c10da684495162f92d28ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use maxOf or kotlin.math.max instead</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;더 이상 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 maxOf 또는 kotlin.math.max를 사용하십시오 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43c145ae9a2a47596ce6ea35f59e6c3bd752792b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use minOf or kotlin.math.min instead</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;더 이상 사용 &lt;strong&gt;되지 않음 :&lt;/strong&gt; 대신 minOf 또는 kotlin.math.min을 사용하십시오 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d5036d3460e6073e9a138258075298f58729d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use parameters named startIndex and endIndex.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; startIndex 및 endIndex라는 매개 변수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b5ee97845fb9246123c98710d4231785a233821e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use plain Kotlin cast</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 일반 Kotlin 캐스트 사용</target>
        </trans-unit>
        <trans-unit id="1324034f6ba898980547749a66a22ed7890795cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use plain Kotlin cast of NSString to String</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; NSString의 일반 Kotlin 캐스트를 문자열로 사용</target>
        </trans-unit>
        <trans-unit id="f708de9bf5260b05b994eae510ba0be9bfd046e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use plain Kotlin cast of String to NSString</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; NSString에 String의 일반 Kotlin 캐스트 사용</target>
        </trans-unit>
        <trans-unit id="05de66863fa6c31537422d7c01f621dc7d7967c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use readBytes() overload without estimatedSize parameter</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 추정 된 크기 매개 변수없이 readBytes () 오버로드 사용</target>
        </trans-unit>
        <trans-unit id="76f6f68dc5115acc51fbd095f0f8455c672005b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use rem(other) instead</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 rem (other)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e53fcbffd3b20605c758a965a8df3af90dae79d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use removeAt(index) instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 removeAt (index)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b7829b593479752cbfa034815c42df9f02b2f7d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use sortWith(Comparator(comparison)) instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 sortWith (Comparator (comparison))를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="24aed9d46b571a7cc738f91897e763352bd3582e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use sortWith(comparator) instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 sortWith (comparator)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a816493e0174c04dc5c78864f25874e05a19183" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use toDouble() instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 toDouble ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b5615a77c7b7d1acb10a2e712e5261dc01e50710" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use toInt() instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 toInt ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ba0440eaf794b635c91c1633c00222cd8ba2f2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use toInt(radix) instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 toInt (radix)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="972da3dde07ec4f64208ca86fd24c347853620f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecated:&lt;/strong&gt; Use top-level functions from kotlin.math package instead.</source>
          <target state="translated">&lt;strong&gt;더 이상 사용되지 않음 :&lt;/strong&gt; 대신 kotlin.math 패키지의 최상위 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bdd361edba9dde53887c45e30a98ecc6839d5370" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Deprecation cycle&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;지원 중단주기&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="92262314d78850fea262f10d209039e6c457c391" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Entry point&lt;/strong&gt; (for executable binaries only). By default the entry point for Kotlin/Native programs is a &lt;code&gt;main&lt;/code&gt; function located in the root package. This setting allows one to change this default and use a custom function as an entry point. For example it can be used to move the &lt;code&gt;main&lt;/code&gt; function from the root package.</source>
          <target state="translated">&lt;strong&gt;진입 점&lt;/strong&gt; (실행 가능한 바이너리에만 해당) 기본적으로 Kotlin / Native 프로그램의 진입 점 은 루트 패키지에 있는 &lt;code&gt;main&lt;/code&gt; 기능입니다. 이 설정을 통해이 기본값을 변경하고 사용자 지정 기능을 진입 점으로 사용할 수 있습니다. 예를 들어 루트 패키지에서 &lt;code&gt;main&lt;/code&gt; 기능 을 이동하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68b0edbe9afeaffdc2715a7389f848e4f07af145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Expressiveness&lt;/strong&gt;: Kotlin's innovative language features, such as its support for &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt; and &lt;a href=&quot;delegated-properties&quot;&gt;delegated properties&lt;/a&gt;, help build powerful and easy-to-use abstractions.</source>
          <target state="translated">&lt;strong&gt;표현력&lt;/strong&gt; : &lt;a href=&quot;type-safe-builders&quot;&gt;타입 안전 빌더&lt;/a&gt; 및 &lt;a href=&quot;delegated-properties&quot;&gt;위임 속성에&lt;/a&gt; 대한 지원과 같은 Kotlin의 혁신적인 언어 기능 은 강력하고 사용하기 쉬운 추상화를 작성하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dd290df5d8dd8a41cfaa050e0a1c2c4990ee7f7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Factory method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;공장 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="01da2bfca3b0c6cd5afd856a346c9af2ed22f57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Feedback Loop&lt;/strong&gt;. Going through deprecation cycles requires significant effort, so we want to minimize the number of incompatible changes we'll be making in the future. Apart from using our best judgement, we believe that trying things out in real life is the best way to validate a design. Before casting things in stone we want them battle-tested. This is why we use every opportunity to make early versions of our designs available in production versions of the language, but with &lt;em&gt;experimental&lt;/em&gt; status. Experimental features are not stable, they can be changed at any time, and the users that opt into using them do so explicitly to indicate that they are ready to deal with the future migration issues. These users provide invaluable feedback that we gather to iterate on the design and make it rock-solid.</source>
          <target state="translated">&lt;strong&gt;피드백 루프&lt;/strong&gt; . 지원 중단주기를 거치려면 상당한 노력이 필요하므로 향후 변경 될 수있는 변경 사항을 최소화하고자합니다. 최선의 판단을 사용하는 것 외에도 실제 상황에서 시험해 보는 것이 디자인을 검증하는 가장 좋은 방법이라고 생각합니다. 돌로 물건을 주조하기 전에 우리는 그것들이 전투 테스트를 받기를 원합니다. 그렇기 때문에 초기 버전의 디자인을 프로덕션 버전의 언어로 사용할 수 있지만 &lt;em&gt;실험적인&lt;/em&gt; 상태 로 만들 수있는 모든 기회를 사용해야 합니다. 실험 기능은 안정적이지 않으며 언제든지 변경할 수 있으며,이를 사용하도록 선택한 사용자는 향후 마이그레이션 문제를 처리 할 준비가되었음을 명시 적으로 나타냅니다. 이러한 사용자는 디자인을 반복하고 견고하게 만들기 위해 수집하는 귀중한 피드백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="84e6e1d5c7013f461d0f8180960aec592e5418ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Footprint&lt;/strong&gt;: Kotlin has a very compact runtime library, which can be further reduced through the use of ProGuard. In a &lt;a href=&quot;https://blog.gouline.net/kotlin-production-tales-62b56057dc8a&quot;&gt;real application&lt;/a&gt;, the Kotlin runtime adds only a few hundred methods and less than 100K to the size of the .apk file.</source>
          <target state="translated">&lt;strong&gt;발자국&lt;/strong&gt; : Kotlin은 매우 컴팩트 한 런타임 라이브러리를 가지고 있으며 ProGuard를 사용하여 더 줄일 수 있습니다. A의 &lt;a href=&quot;https://blog.gouline.net/kotlin-production-tales-62b56057dc8a&quot;&gt;실제 응용 프로그램&lt;/a&gt; 의 코 틀린 런타임은 단지 몇 백 방법과의 .apk 파일의 크기 미만 100K를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ab66fec3d20ab10d72344a8b47e8045de00b0458" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Framework type&lt;/strong&gt; (only for Objective-C frameworks). By default a framework built by Kotlin/Native contains a dynamic library. But it's possible to replace it with a static library.</source>
          <target state="translated">&lt;strong&gt;프레임 워크 유형&lt;/strong&gt; (Objective-C 프레임 워크에만 해당). 기본적으로 Kotlin / Native에서 빌드 한 프레임 워크에는 동적 라이브러리가 포함됩니다. 그러나 정적 라이브러리로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57126d52087eba472a07f6b0dc82b2c9b74ad896" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fully Stable (FS)&lt;/strong&gt;: incremental releases are fully compatible, only optimizations and bug fixes happen. Feature releases are backwards compatible.</source>
          <target state="translated">&lt;strong&gt;FS (Fully Stable)&lt;/strong&gt; : 증분 릴리스는 완전히 호환되며 최적화 및 버그 수정 만 발생합니다. 기능 릴리스는 이전 버전과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="5d722e5425cf5468a3cc51807165b09b74178e30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getter&lt;/strong&gt; returns &lt;code&gt;true&lt;/code&gt; if JVM access checks are suppressed for this callable object. For a property, that means that all its accessors (getter, and setter for &lt;code&gt;var&lt;/code&gt; properties) are accessible.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 호출 가능 객체에 대한 JVM 액세스 확인이 억제되면 &lt;strong&gt;Getter&lt;/strong&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다. 속성의 경우 모든 접근 자 ( &lt;code&gt;var&lt;/code&gt; 속성의 getter 및 setter )에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="893f88e4922c51e506a298efd0e349332ccff29b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; To correctly import the dependencies into the Kotlin/Native module, the Podfile must contain either &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_modular_headers_bang&quot;&gt;&lt;code&gt;use_modular_headers!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_frameworks_bang&quot;&gt;&lt;code&gt;use_frameworks!&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">&lt;strong&gt;중요 사항 :&lt;/strong&gt; 종속성을 Kotlin / Native 모듈로 올바르게 가져 오려면 Podfile에 use_modular_headers가 포함되어야합니다 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_modular_headers_bang&quot;&gt; &lt;code&gt;use_modular_headers!&lt;/code&gt; &lt;/a&gt;또는 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_frameworks_bang&quot;&gt; &lt;code&gt;use_frameworks!&lt;/code&gt; &lt;/a&gt;지령.</target>
        </trans-unit>
        <trans-unit id="fa5e5749e3c4a470f72fca590f3925968869b43c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incompatible change type&lt;/strong&gt;: Behavioral</source>
          <target state="translated">&lt;strong&gt;호환되지 않는 변경 유형&lt;/strong&gt; : 행동</target>
        </trans-unit>
        <trans-unit id="e9774a516db3294cc27043b7f776059e8e8e9244" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incompatible change type&lt;/strong&gt;: Binary</source>
          <target state="translated">&lt;strong&gt;호환되지 않는 변경 유형&lt;/strong&gt; : 이진</target>
        </trans-unit>
        <trans-unit id="5f85eefcdfc6bf3de72be4d2ef5c7ab0771b8d4b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incompatible change type&lt;/strong&gt;: Source</source>
          <target state="translated">&lt;strong&gt;호환되지 않는 변경 유형&lt;/strong&gt; : 소스</target>
        </trans-unit>
        <trans-unit id="08a3c86adb9c5648bfd57ffdaf07e8089b74133c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Incompatible change type&lt;/strong&gt;: behavioral</source>
          <target state="translated">&lt;strong&gt;호환되지 않는 변경 유형&lt;/strong&gt; : 행동</target>
        </trans-unit>
        <trans-unit id="b44d63d70cba3bead47196e58ec9474c6ee1043e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interacting with DOM elements&lt;/strong&gt;. Kotlin provides a series of statically typed interfaces to interact with the Document Object Model, allowing creation and update of DOM elements.</source>
          <target state="translated">&lt;strong&gt;DOM 요소와 상호 작용&lt;/strong&gt; . Kotlin은 Document Object Model과 상호 작용할 수있는 정적 유형의 인터페이스를 제공하여 DOM 요소를 생성 및 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cc584a094e9383c6d524ed74cdac053c8d02dbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interacting with graphics such as WebGL&lt;/strong&gt;. You can use Kotlin to create graphical elements on a web page using WebGL.</source>
          <target state="translated">&lt;strong&gt;같은 WebGL에 같은 그래픽과 상호 작용&lt;/strong&gt; . Kotlin을 사용하여 WebGL을 사용하여 웹 페이지에 그래픽 요소를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc74b175415bdb2c6872627140daf87039a72fd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interoperability&lt;/strong&gt;: Kotlin is 100% interoperable with Java, allowing to use all existing Android libraries in a Kotlin application. This includes annotation processing, so databinding and Dagger work too.</source>
          <target state="translated">&lt;strong&gt;상호 운용성&lt;/strong&gt; : Kotlin은 Java와 100 % 상호 운용 가능하므로 Kotlin 응용 프로그램에서 기존의 모든 Android 라이브러리를 사용할 수 있습니다. 여기에는 주석 처리가 포함되므로 데이터 바인딩 및 단검도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2598c2f91d35e4a4317dc1430080d368da441adb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interoperability&lt;/strong&gt;: Kotlin is fully compatible with all Java-based frameworks, which lets you stay on your familiar technology stack while reaping the benefits of a more modern language.</source>
          <target state="translated">&lt;strong&gt;상호 운용성&lt;/strong&gt; : Kotlin은 모든 Java 기반 프레임 워크와 완벽하게 호환되므로보다 현대적인 언어의 이점을 누리면서 친숙한 기술 스택을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="624797bf44bc3c55aa073bdf9a58f067cbae884b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-13762&quot;&gt;KT-13762&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-13762&quot;&gt;KT-13762&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b67b5fcbcd7791fc278190ddce0be5d15901482" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-16097&quot;&gt;KT-16097&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-16097&quot;&gt;KT-16097&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="620a0df1083fbc6bc1ebf1e8bd34ea2a88bec618" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-16310&quot;&gt;KT-16310&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-16310&quot;&gt;KT-16310&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42fbe3fe5033ce1298274704ce101b12010456ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-16681&quot;&gt;KT-16681&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-16681&quot;&gt;KT-16681&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="467037173e1ff7906572f023ecff56fc35ecbc52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-17176&quot;&gt;KT-17176&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-17176&quot;&gt;KT-17176&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="178dd1bf94f5ea52efcdeccc09a4fe9599b66fab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-17981&quot;&gt;KT-17981&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-17981&quot;&gt;KT-17981&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5901c1a8cf2a133579a52a6cc3fe44c795fb6ade" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19489&quot;&gt;KT-19489&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;문제점&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19489&quot;&gt;KT-19489&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61163eeade8a3c9c1e72e49f2a38b76ee8101c44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19532&quot;&gt;KT-19532&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19532&quot;&gt;KT-19532&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c51480006ff5ed4b72b0cbda590360487f25ef30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19618&quot;&gt;KT-19618&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;문제&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19618&quot;&gt;KT-19618&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4269bf35364cf5eef0c2aee3ffa7af7126c67b1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19628&quot;&gt;KT-19628&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;문제&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-19628&quot;&gt;KT-19628&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="18e239b48fa6b77dfc46b4f8d7346e7a9ea8aab7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20772&quot;&gt;KT-20772&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20772&quot;&gt;KT-20772&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d2ec61a056ac534581d3f9ac63d2ad9837e704fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20830&quot;&gt;KT-20830&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20830&quot;&gt;KT-20830&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7ccb04df2d64748e20e2134c65deed513ffc4ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21049&quot;&gt;KT-21049&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21049&quot;&gt;KT-21049&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="362d124cfb6e8092d3b6b64a3c1c97c18411d09d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21354&quot;&gt;KT-21354&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21354&quot;&gt;KT-21354&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c673a61bc8615e171b8adccc1ad84ac8e85d342" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21784&quot;&gt;KT-21784&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21784&quot;&gt;KT-21784&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5dfd5f1e36a2cdae750b38fa1f32ae31d60afb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-22517&quot;&gt;KT-22517&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-22517&quot;&gt;KT-22517&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="789d4c884fa9a1b852dba0d6d48be30382573fe2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-23153&quot;&gt;KT-23153&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-23153&quot;&gt;KT-23153&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="beb1d34baf6f5e60bbf2274bd851226a0335294c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-23277&quot;&gt;KT-23277&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-23277&quot;&gt;KT-23277&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ec687965b8bca3f04918c9027652dbc70762b91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-23799&quot;&gt;KT-23799&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-23799&quot;&gt;KT-23799&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a9b8117837a2658cae47906517066f191302558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-25287&quot;&gt;KT-25287&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-25287&quot;&gt;KT-25287&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="842780bcd8ff9dbe2039445f6a9599270dc126ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issue&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-9580&quot;&gt;KT-9580&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-9580&quot;&gt;KT-9580&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ffb22359482e55dfa802f06510821ee20651eb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20588&quot;&gt;KT-20588&lt;/a&gt;, &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20589&quot;&gt;KT-20589&lt;/a&gt;. See also &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20171&quot;&gt;KT-20171&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;문제&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20588&quot;&gt;KT-20588&lt;/a&gt; , &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20589&quot;&gt;KT-20589&lt;/a&gt; . &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-20171&quot;&gt;KT-20171&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="73aba56311cb1950911e3d599f9eed16865c221a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21515&quot;&gt;KT-21515&lt;/a&gt;, &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-25333&quot;&gt;KT-25333&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-21515&quot;&gt;KT-21515&lt;/a&gt; , &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-25333&quot;&gt;KT-25333&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="095db5bc99e8bc13e223afcb027bc0980992279c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Issues&lt;/strong&gt;: &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-24197&quot;&gt;KT-24197&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;이슈&lt;/strong&gt; : &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-24197&quot;&gt;KT-24197&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39e05aa1278ad7a2503bcfb3c1f1bfaa71410afd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자바 타입&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15b37f51b2dba58ccf1543c881e55363f163dbf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keeping the Language Modern&lt;/strong&gt;. We acknowledge that systems accumulate legacy over time. What had once been cutting-edge technology can be hopelessly outdated today. We have to evolve the language to keep it relevant to the needs of the users and up-to-date with their expectations. This includes not only adding new features, but also phasing out old ones that are no longer recommended for production use and have altogether become legacy.</source>
          <target state="translated">&lt;strong&gt;언어를 현대적으로 유지&lt;/strong&gt; . 우리는 시스템이 시간이 지남에 따라 유산을 축적한다는 것을 인정합니다. 한때 최첨단 기술이었던 것은 오늘날 절망적으로 구식이 될 수 있습니다. 우리는 언어를 사용자의 요구와 관련성이 있고 기대와 최신 상태로 유지하기 위해 언어를 발전시켜야합니다. 여기에는 새로운 기능 추가뿐만 아니라 더 이상 프로덕션 용도로 권장되지 않고 레거시가 된 오래된 기능을 제거하는 것도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="af07559b3d456b10e95e78f5cef72b66be05dda7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Kotlin mutable type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코 틀린 가변형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3795dcd10c1477ffbfd7ccdf4a52e9df4e62ac5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Kotlin read-only type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코 틀린 읽기 전용 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bff39871f21339ee6d16c8c134fd8d15942da64b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Kotlin type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코 틀린 타입&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0a44911f381012dae69c91143484dfd2338561a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Kotlin/Native for Native&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코 틀린 / 네이티브 네이티브&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4833f8621787b679730e7858ff9e5385cd3e49e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Last Updated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;마지막 업데이트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="def8d56e2c6c1c07fdbf780235a0372f93a0e796" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Learn Kotlin&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코 틀린 배우기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44475f8a3f8a76a68fb693cb59a54ffa320ddf7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Learning Curve&lt;/strong&gt;: For a Java developer, getting started with Kotlin is very easy. The automated Java to Kotlin converter included in the Kotlin plugin helps with the first steps. &lt;a href=&quot;../tutorials/koans&quot;&gt;Kotlin Koans&lt;/a&gt; offer a guide through the key features of the language with a series of interactive exercises.</source>
          <target state="translated">&lt;strong&gt;학습 곡선&lt;/strong&gt; : Java 개발자에게는 Kotlin을 시작하는 것이 매우 쉽습니다. Kotlin 플러그인에 포함 된 자동 Java 대 Kotlin 변환기는 첫 번째 단계에 도움이됩니다. &lt;a href=&quot;../tutorials/koans&quot;&gt;Kotlin Koans&lt;/a&gt; 는 일련의 대화식 연습과 함께 언어의 주요 기능을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="0064e6430cb7af56de1b8fa85d7c711bb821be42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Linker options.&lt;/strong&gt; Options passed to a system linker during binary building. One can use this setting to link against some native library.</source>
          <target state="translated">&lt;strong&gt;링커 옵션. &lt;/strong&gt;바이너리 빌드 중에 시스템 링커에 옵션이 전달되었습니다. 이 설정을 사용하여 일부 기본 라이브러리에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ef1270cc6a5b78912b6586714ad317f0657ed1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Loaded platform type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;로드 된 플랫폼 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c229afb06419ddd0f84981c54ddfb0d1f7ca503" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MF&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MF&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1633839bc9516bea2b216e788aac2b4d911688fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Migration&lt;/strong&gt;: Kotlin supports gradual, step by step migration of large codebases from Java to Kotlin. You can start writing new code in Kotlin while keeping older parts of your system in Java.</source>
          <target state="translated">&lt;strong&gt;마이그레이션&lt;/strong&gt; : Kotlin은 대규모 코드베이스를 Java에서 Kotlin으로 점진적으로 &lt;strong&gt;마이그레이션 할 수&lt;/strong&gt; 있도록 지원합니다. 시스템의 오래된 부분을 Java로 유지하면서 Kotlin에서 새 코드 작성을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5013d8104b487fadfcb9f6ec26b4d07e76e10250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mode for Binaries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이진 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a9e330b1c51ab2059298c572893a2b28833c886" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mode for Sources&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;소스 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b4818f9c5362c6e3c936951253cb1f7e858e0104" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Module Kind&lt;/strong&gt;. Indicates what module standard to follow. This is covered in the &lt;a href=&quot;../working-with-modules/working-with-modules&quot;&gt;Working with Modules&lt;/a&gt; tutorial in more depth.</source>
          <target state="translated">&lt;strong&gt;모듈 종류&lt;/strong&gt; . 따라야 할 모듈 표준을 나타냅니다. 이에 대한 자세한 내용 &lt;a href=&quot;../working-with-modules/working-with-modules&quot;&gt;은 모듈 작업&lt;/a&gt; 자습서에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="1291d291c889d952f962f19be664239e51749e53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Moving fast (MF)&lt;/strong&gt;: no compatibility should be expected between even &lt;a href=&quot;kotlin-evolution#feature-releases-and-incremental-releases&quot;&gt;incremental releases&lt;/a&gt;, any functionality can be added, removed or changed without warning.</source>
          <target state="translated">&lt;strong&gt;빠른 이동 (MF)&lt;/strong&gt; : &lt;a href=&quot;kotlin-evolution#feature-releases-and-incremental-releases&quot;&gt;증분 릴리스&lt;/a&gt; 간에도 호환성을 기대할 수 없으며 모든 기능을 경고없이 추가, 제거 또는 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f8cd126dd8825e89ed3aa4dbc97f569647c6c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: On the JVM, if all of the parameters of the primary constructor have default values, the compiler will generate an additional parameterless constructor which will use the default values. This makes it easier to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : JVM에서 기본 생성자의 모든 매개 변수에 기본값이있는 경우 컴파일러는 기본값을 사용하는 추가 매개 변수없는 생성자를 생성합니다. 이를 통해 매개 변수없는 생성자를 통해 클래스 인스턴스를 작성하는 Jackson 또는 JPA와 같은 라이브러리에서 Kotlin을 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89aa2209faf2c7b962a9fbb7cb927f54ba8d68e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: object declarations can't be local (i.e. be nested directly inside a function), but they can be nested into other object declarations or non-inner classes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 객체 선언은 로컬 (즉, 함수 내에 직접 중첩) 될 수 없지만 다른 객체 선언이나 비 내부 클래스에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a7391836e79098f507df30b500cfdf387dae5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: we could also use the standard class &lt;code&gt;Pair&lt;/code&gt; and have &lt;code&gt;function()&lt;/code&gt; return &lt;code&gt;Pair&amp;lt;Int, Status&amp;gt;&lt;/code&gt;, but it's often better to have your data named properly.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 표준 클래스 &lt;code&gt;Pair&lt;/code&gt; 를 사용할 수도 있고 &lt;code&gt;function()&lt;/code&gt; &lt;code&gt;Pair&amp;lt;Int, Status&amp;gt;&lt;/code&gt; 반환 하도록 할 수도 있지만 데이터의 이름을 올바르게 지정하는 것이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="920b4d9f7a2e2f012d737b1adc92132d3b2794a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: this value should not be used in general code.&lt;/strong&gt; Using it outside of the context of &lt;code&gt;suspendCoroutineUninterceptedOrReturn&lt;/code&gt; function return value (including, but not limited to, storing this value in other properties, returning it from other functions, etc) can lead to unspecified behavior of the code.</source>
          <target state="translated">&lt;strong&gt;참고 :이 값은 일반 코드에서 사용해서는 안됩니다. &lt;/strong&gt; &lt;code&gt;suspendCoroutineUninterceptedOrReturn&lt;/code&gt; 컨텍스트 외부 에서이 값을 사용하면 (이 값을 다른 특성에 저장하거나 다른 함수에서 리턴하는 등을 포함하지만 이에 국한되지 않음) 코드의 지정되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b1d1a1c1c67cb1e20686c6012118dbab4d7ed0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The plugin is based on the multiplatform project model and requires applying the &lt;code&gt;org.jetbrains.kotlin.multiplatform&lt;/code&gt; plugin. See details about the multiplatform plugin at the &lt;a href=&quot;../building-mpp-with-gradle&quot;&gt;corresponding page&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 플러그인은 멀티 플랫폼 프로젝트 모델을 기반으로하며 &lt;code&gt;org.jetbrains.kotlin.multiplatform&lt;/code&gt; 플러그인을 적용해야합니다 . &lt;a href=&quot;../building-mpp-with-gradle&quot;&gt;해당 페이지&lt;/a&gt; 에서 멀티 플랫폼 플러그인에 대한 세부 사항을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c6216b6d115320c9b1ecc7efbf4142d2f0463f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; If using pre-release or EAP versions of the Kotlin plugin, the IDE may fail to open the generated project, giving a Gradle import &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-18835#focus=streamItem-27-2718879-0-0&quot;&gt;error&lt;/a&gt;. This is because the right Maven repository isn't referenced in the &lt;code&gt;build.gradle&lt;/code&gt; file, it can be resolved by adding the following entry &lt;em&gt;twice&lt;/em&gt;, into each of the &lt;code&gt;repositories { .. }&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 시험판 또는 EAP 버전의 Kotlin 플러그인을 사용하는 경우 IDE에서 생성 된 프로젝트를 열지 못해 Gradle 가져 오기 &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-18835#focus=streamItem-27-2718879-0-0&quot;&gt;오류가 발생할 수&lt;/a&gt; 있습니다. 올바른 Maven 저장소가 &lt;code&gt;build.gradle&lt;/code&gt; 파일 에서 참조되지 않기 때문에 다음 &lt;code&gt;repositories { .. }&lt;/code&gt; 를 각 저장소 {..} 블록에 &lt;em&gt;두 번&lt;/em&gt; 추가하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f048dac293163b7f3a7598b49f61de73ac3ba9de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; It is the caller's responsibility to close both of these resources.</source>
          <target state="translated">&lt;strong&gt;참고이&lt;/strong&gt; 두 리소스를 모두 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="124d849e65ffd789b274bb9691889ca354bfd7d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; it is the caller's responsibility to close both of these resources.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 는 이러한 자원을 모두 닫습니다 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3e391a1d8a33528b8b5fbf5f4c42696126e3570c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: It is the caller's responsibility to close this stream.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 스트림을 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="a41fbf1843bb637e2270153523b6af23d3f7972b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output file name.&lt;/strong&gt; By default the output file name is based on binary name prefix or, if the name prefix isn't specified, on a project name. But it's possible to configure the output file name independently using the &lt;code&gt;baseName&lt;/code&gt; property. Note that final file name will be formed by adding system-dependent prefix and postfix to this base name. E.g. a &lt;code&gt;libfoo.so&lt;/code&gt; is produced for a Linux shared library with the base name &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;출력 파일 이름 &lt;/strong&gt;기본적으로 출력 파일 이름은 이진 이름 접두사 또는 이름 접두사가 지정되지 않은 경우 프로젝트 이름을 기반으로합니다. 그러나 &lt;code&gt;baseName&lt;/code&gt; 속성을 사용하여 출력 파일 이름을 독립적으로 구성 할 수 있습니다 . 이 기본 이름에 시스템 종속 접두사와 접미사를 추가하여 최종 파일 이름이 생성됩니다. 예를 들어 &lt;code&gt;libfoo.so&lt;/code&gt; 는 기본 이름이 &lt;code&gt;foo&lt;/code&gt; 인 Linux 공유 라이브러리 용으로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="50ced6f5b30171a4a93c828cff28c5aae9265871" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output file postfix&lt;/strong&gt;. Same as above, but in this case the compiler will append the contents of the selected file to the output.</source>
          <target state="translated">&lt;strong&gt;출력 파일 postfix&lt;/strong&gt; . 위와 동일하지만이 경우 컴파일러는 선택한 파일의 내용을 출력에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b7acbb24727c5dd951bd8fe4bdbacc1b0e5f3690" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output file prefix&lt;/strong&gt;. We can prefix the output the compiler generates with additional JavaScript. In order to do so, we indicate the name of the file that contains the JavaScript we want in this box.</source>
          <target state="translated">&lt;strong&gt;출력 파일 접두사&lt;/strong&gt; . 컴파일러가 생성하는 출력에 추가 JavaScript를 접두어로 붙일 수 있습니다. 이를 위해이 상자에 원하는 JavaScript가 포함 된 파일 이름을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1f567fbc6441cccc58a14b74cbee1b61024c0b30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;: A Kotlin application runs as fast as an equivalent Java one, thanks to very similar bytecode structure. With Kotlin's support for inline functions, code using lambdas often runs even faster than the same code written in Java.</source>
          <target state="translated">&lt;strong&gt;성능&lt;/strong&gt; : Kotlin 응용 프로그램은 매우 유사한 바이트 코드 구조 덕분에 동등한 Java 응용 프로그램만큼 빠르게 실행됩니다. Kotlin의 인라인 함수 지원으로 람다를 사용하는 코드는 종종 Java로 작성된 동일한 코드보다 훨씬 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8ff78e240531b65a1f2b3131a6ed9457cb776408" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Return&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="757d607f672c7334dae6f2d15467388440a9d89f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An index of the first occurrence of &lt;a href=&quot;index-of#kotlin.text%24indexOf%28kotlin.CharSequence%2C+kotlin.Char%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchar&quot;&gt;char&lt;/a&gt; or -1 if none is found.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt;&lt;a href=&quot;index-of#kotlin.text%24indexOf%28kotlin.CharSequence%2C+kotlin.Char%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchar&quot;&gt;char&lt;/a&gt; 의 첫 번째 색인 또는 발견되지 않은 경우 -1.</target>
        </trans-unit>
        <trans-unit id="7af850e676eb1f6ad07e246ecbc7648054a8e8f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An index of the first occurrence of &lt;a href=&quot;index-of#kotlin.text%24indexOf%28kotlin.CharSequence%2C+kotlin.String%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstring&quot;&gt;string&lt;/a&gt; or &lt;code&gt;-1&lt;/code&gt; if none is found.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt;&lt;a href=&quot;index-of#kotlin.text%24indexOf%28kotlin.CharSequence%2C+kotlin.String%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstring&quot;&gt;문자열&lt;/a&gt; 의 첫 항목 색인 또는 발견되지 않은 경우 &lt;code&gt;-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cd1a92de7d335131ff93dd7748a1b3c35c63499" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An index of the first occurrence of &lt;a href=&quot;last-index-of#kotlin.text%24lastIndexOf%28kotlin.CharSequence%2C+kotlin.Char%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchar&quot;&gt;char&lt;/a&gt; or -1 if none is found.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt;&lt;a href=&quot;last-index-of#kotlin.text%24lastIndexOf%28kotlin.CharSequence%2C+kotlin.Char%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchar&quot;&gt;char&lt;/a&gt; 의 첫 번째 색인 또는 발견되지 않은 경우 -1.</target>
        </trans-unit>
        <trans-unit id="4004685c44664daadd174c6a7248b58ad09d8306" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An index of the first occurrence of &lt;a href=&quot;last-index-of#kotlin.text%24lastIndexOf%28kotlin.CharSequence%2C+kotlin.String%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstring&quot;&gt;string&lt;/a&gt; or -1 if none is found.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt;&lt;a href=&quot;last-index-of#kotlin.text%24lastIndexOf%28kotlin.CharSequence%2C+kotlin.String%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstring&quot;&gt;문자열&lt;/a&gt; 의 첫 항목 색인 또는 발견되지 않은 경우 -1.</target>
        </trans-unit>
        <trans-unit id="7c2c91f69c38f6b0e99eb7c7f21b31b8ff2800c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An index of the first occurrence of matched character from &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;chars&lt;/a&gt; or -1 if none of &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;chars&lt;/a&gt; are found.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 에서 유사한 문자의 처음 발생의 인덱스 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;문자는&lt;/a&gt; -1 하나도 경우 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;문자가&lt;/a&gt; 발견되지 않는다.</target>
        </trans-unit>
        <trans-unit id="ed38c40ddbaf9c9e8959cc88c45220bb74df65fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An index of the last occurrence of matched character from &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;chars&lt;/a&gt; or -1 if none of &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;chars&lt;/a&gt; are found.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 에서 일치하는 문자의 마지막 항목의 지수 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;문자는&lt;/a&gt; -1의 어느 경우 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.CharArray%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fchars&quot;&gt;문자가&lt;/a&gt; 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="476664da54ca5e12b023a38b5c0c9a78a17fb037" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An instance of &lt;a href=&quot;../-match-group/index#kotlin.text.MatchGroup&quot;&gt;MatchGroup&lt;/a&gt; if the group with the specified &lt;a href=&quot;get#kotlin.text.MatchNamedGroupCollection%24get%28kotlin.String%29%2Fname&quot;&gt;name&lt;/a&gt; was matched or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 의 인스턴스 &lt;a href=&quot;../-match-group/index#kotlin.text.MatchGroup&quot;&gt;MatchGroup&lt;/a&gt; 지정과 그룹 경우 &lt;a href=&quot;get#kotlin.text.MatchNamedGroupCollection%24get%28kotlin.String%29%2Fname&quot;&gt;이름이&lt;/a&gt; 일치 또는 한 &lt;code&gt;null&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3bef3966f2f05a88d0735518e95ca5d2dce9b767" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An instance of &lt;a href=&quot;../-match-result/index&quot;&gt;MatchResult&lt;/a&gt; if match was found or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 의 인스턴스 &lt;a href=&quot;../-match-result/index&quot;&gt;MatchResult&lt;/a&gt; 일치하는 항목이 또는 경우 &lt;code&gt;null&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="e4d8f232464ef8dac9081a9a982d93b31bf500a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An instance of MatchGroup if the group with the specified &lt;a href=&quot;get#kotlin.text%24get%28kotlin.text.MatchGroupCollection%2C+kotlin.String%29%2Fname&quot;&gt;name&lt;/a&gt; was matched or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; MatchGroup의 인스턴스 지정과 그룹 경우 &lt;a href=&quot;get#kotlin.text%24get%28kotlin.text.MatchGroupCollection%2C+kotlin.String%29%2Fname&quot;&gt;이름이&lt;/a&gt; 일치 또는 한 &lt;code&gt;null&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="935d5a6f8dc59afb1cfba02a19debb5e5421db4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An instance of MatchResult if match was found or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; MatchResult의 인스턴스 일치하는 항목이 또는 경우 &lt;code&gt;null&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="bca80f4e95cb0ed398996067163cca3543f5227e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; An instance of MatchResult if the entire input matches or &lt;code&gt;null&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; MatchResult의 인스턴스의 경우 전체 입력 일치 또는 &lt;code&gt;null&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="2378752e83bb2a757af3b5523444ded4dd6b04ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; File with relative path from &lt;a href=&quot;relative-to#kotlin.io%24relativeTo%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;base&lt;/a&gt; to this.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;relative-to#kotlin.io%24relativeTo%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;기준&lt;/a&gt; 에서 이것 까지의 상대 경로가있는 파일을 &lt;strong&gt;반환&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="05784c6721c79f3dbd32bc694f8a644402e66119" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; File with relative path from &lt;a href=&quot;relative-to-or-null#kotlin.io%24relativeToOrNull%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;base&lt;/a&gt; to this, or &lt;code&gt;null&lt;/code&gt; if this and base paths have different roots.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;relative-to-or-null#kotlin.io%24relativeToOrNull%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;기준&lt;/a&gt; 에서 이것 까지의 상대 경로를 가진 파일을 &lt;strong&gt;반환&lt;/strong&gt; 하거나 , 이것과 기본 경로가 다른 루트를 갖는 경우 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="175b53596a618414d8f28838230010cdd2c26dc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; File with relative path from &lt;a href=&quot;relative-to-or-self#kotlin.io%24relativeToOrSelf%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;base&lt;/a&gt; to this, or &lt;code&gt;this&lt;/code&gt; if this and base paths have different roots.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 에서 상대 경로로 파일 &lt;a href=&quot;relative-to-or-self#kotlin.io%24relativeToOrSelf%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;기본&lt;/a&gt; 이, 또는 &lt;code&gt;this&lt;/code&gt; 이것과 기본 경로가있는 경우 서로 다른 뿌리.</target>
        </trans-unit>
        <trans-unit id="21be04e13d02602636a5a7fb84162e15455167dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; Returns a char sequence of length at least &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; consisting of &lt;code&gt;this&lt;/code&gt; char sequence appended with &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar&lt;/a&gt; as many times as are necessary to reach that length.</source>
          <target state="translated">&lt;strong&gt;Return &lt;/strong&gt;&lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar가&lt;/a&gt; 추가 된 &lt;code&gt;this&lt;/code&gt; 문자 시퀀스 로 구성되는 &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 이상의 문자 시퀀스 를 해당 길이에 도달하는 데 필요한 횟수만큼 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e256ebaed480a7f0368eda36fd51bad6e41516d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; Returns a char sequence of length at least &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; consisting of &lt;code&gt;this&lt;/code&gt; char sequence prepended with &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar&lt;/a&gt; as many times as are necessary to reach that length.</source>
          <target state="translated">&lt;strong&gt;Return &lt;/strong&gt;&lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar가&lt;/a&gt; 앞에 추가 된 &lt;code&gt;this&lt;/code&gt; 문자 순서 로 구성되는 &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 이상의 문자 순서 를 해당 길이에 도달하는 데 필요한 횟수만큼 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f60d641eaede731f221b7060f1f3e9e4d481bc2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; Returns a string of length at least &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; consisting of &lt;code&gt;this&lt;/code&gt; string appended with &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar&lt;/a&gt; as many times as are necessary to reach that length.</source>
          <target state="translated">&lt;strong&gt;돌아&lt;/strong&gt; 적어도 길이의 문자열을 반환 &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 로 구성된 &lt;code&gt;this&lt;/code&gt; 가 추가 된 문자열 &lt;a href=&quot;pad-end#kotlin.text%24padEnd%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar&lt;/a&gt; 횟수만큼 그 길이에 도달하기 위해 필요로합니다.</target>
        </trans-unit>
        <trans-unit id="3f0e97a5d1532dd289cbd00cb8febad2ebc006ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; Returns a string of length at least &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;length&lt;/a&gt; consisting of &lt;code&gt;this&lt;/code&gt; string prepended with &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar&lt;/a&gt; as many times as are necessary to reach that length.</source>
          <target state="translated">&lt;strong&gt;Return &lt;/strong&gt;&lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2FpadChar&quot;&gt;padChar가&lt;/a&gt; 앞에 추가 된 &lt;code&gt;this&lt;/code&gt; 문자열 로 구성되는 &lt;a href=&quot;pad-start#kotlin.text%24padStart%28kotlin.String%2C+kotlin.Int%2C+kotlin.Char%29%2Flength&quot;&gt;길이&lt;/a&gt; 이상의 문자열 을 해당 길이에 도달하는 데 필요한 횟수만큼 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="05d2bfaf1aa7e0d001ef17a623b8853662f84965" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; The &lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.Array%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt;&lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.Array%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="778fbef5dee9882db535983ba2b4d6a30194cda7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; The &lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.Array%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt;&lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.Array%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="bbacdc249ef59b7019772a93fea3a391cc671301" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; The &lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.collections.Iterable%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt;&lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.collections.Iterable%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="971b1a111fa49abbc52dc55c9059a6defa065fb3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; The &lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.collections.Iterable%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt;&lt;a href=&quot;group-by-to#kotlin.collections%24groupByTo%28kotlin.collections.Iterable%28%28kotlin.collections.groupByTo.T%29%29%2C+kotlin.collections.groupByTo.M%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.groupByTo.T%2C+kotlin.collections.groupByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="0b8ef7cc2d4624d80dc45bba07cbc871b1c65fd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; The &lt;a href=&quot;group-by-to#kotlin.text%24groupByTo%28kotlin.CharSequence%2C+kotlin.text.groupByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.groupByTo.K%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt;&lt;a href=&quot;group-by-to#kotlin.text%24groupByTo%28kotlin.CharSequence%2C+kotlin.text.groupByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.groupByTo.K%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="7a13a91417e9f4cda94ea862a2c14b5d12b50ec7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; The &lt;a href=&quot;group-by-to#kotlin.text%24groupByTo%28kotlin.CharSequence%2C+kotlin.text.groupByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.groupByTo.V%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt;&lt;a href=&quot;group-by-to#kotlin.text%24groupByTo%28kotlin.CharSequence%2C+kotlin.text.groupByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.groupByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.groupByTo.V%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도.</target>
        </trans-unit>
        <trans-unit id="7bd830ad513290b53fb7d18b6c571053d207675d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; This method never returns normally.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 이 메서드는 정상적으로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f79b336185113f28a5e8c19738212cf11e2ce174" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; associating the key of each group with the count of element in the group.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹의 요소 수와 연관 시키는 &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;맵을 &lt;/a&gt;&lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b2bcc4c304883498cd841b079d1ea9f4ad7ec6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; associating the key of each group with the count of elements in the group.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키와 그룹의 요소 수를 연결 하는 &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;맵을 &lt;/a&gt;&lt;strong&gt;반환&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="92e4c78b65c9a633d5b3fde208c21636da22c900" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; associating the key of each group with the result of accumulating the group elements.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹 요소의 누적 결과와 연관 시키는 &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;맵을 &lt;/a&gt;&lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="36136cc4d5676787a1a14efcd50d7d8b70d826c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; associating the key of each group with the result of aggregation of the group elements.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹 요소의 집계 결과와 연관 시키는 &lt;a href=&quot;-map/index#kotlin.collections.Map&quot;&gt;맵을 &lt;/a&gt;&lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="294ff37c2322a4c56ecea7db52c0d54cd2b4f79b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a byte array with this URL entire content.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 URL 전체 내용을 가지는 바이트 배열을 &lt;strong&gt;돌려&lt;/strong&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="3cbc799d7826647bc9a71e6d72a766656ce46405" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a file object corresponding to a newly-created directory.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;새로 작성된 디렉토리에 해당하는 파일 오브젝트를 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="b965b504748aed686b87a58974f88b91857caabc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a file object corresponding to a newly-created file.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;새로 만든 파일에 해당하는 파일 객체를 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="02bcdfc6e31df51b1d65fca5b0cb566548dd0e8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a sequence of corresponding file lines. The sequence returned can be iterated only once.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;해당 파일 줄의 순서를 &lt;strong&gt;반환&lt;/strong&gt; 합니다. 반환 된 시퀀스는 한 번만 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2160e32351bd00d00c4490b91708257b5bca54ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; a string with this URL entire content.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 URL 전체 내용이 포함 된 문자열을 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9ecc7ab2d534b07ebe5f3acac091a7bc6d580dbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; concatenated this and &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;relative&lt;/a&gt; paths, or just &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;relative&lt;/a&gt; if it's absolute.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 이와 연결된 &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;상대&lt;/a&gt; 경로를, 아니면 그냥 &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;상대&lt;/a&gt; 가 절대 있다면.</target>
        </trans-unit>
        <trans-unit id="31371dbb418b67ca7aa434b39b320ed1b192c649" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; concatenated this and &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;relative&lt;/a&gt; paths, or just &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;relative&lt;/a&gt; if it's absolute.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 이와 연결된 &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;상대&lt;/a&gt; 경로를, 아니면 그냥 &lt;a href=&quot;resolve#kotlin.io%24resolve%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;상대&lt;/a&gt; 가 절대 있다면.</target>
        </trans-unit>
        <trans-unit id="0e3b041dfb6a04ced4ee7e624743c6da9c4f43f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; concatenated this.parent and &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;relative&lt;/a&gt; paths, or just &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;relative&lt;/a&gt; if it's absolute or this has no parent.</source>
          <target state="translated">&lt;strong&gt;돌아&lt;/strong&gt; this.parent와 연결된 &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;상대&lt;/a&gt; 경로, 아니면 그냥 &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+java.io.File%29%2Frelative&quot;&gt;상대&lt;/a&gt; 가 절대 나이 부모가없는 경우.</target>
        </trans-unit>
        <trans-unit id="43a48306ba4c43d0088fb67cb705b208bcc9386a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; concatenated this.parent and &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;relative&lt;/a&gt; paths, or just &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;relative&lt;/a&gt; if it's absolute or this has no parent.</source>
          <target state="translated">&lt;strong&gt;돌아&lt;/strong&gt; this.parent와 연결된 &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;상대&lt;/a&gt; 경로, 아니면 그냥 &lt;a href=&quot;resolve-sibling#kotlin.io%24resolveSibling%28java.io.File%2C+kotlin.String%29%2Frelative&quot;&gt;상대&lt;/a&gt; 가 절대 나이 부모가없는 경우.</target>
        </trans-unit>
        <trans-unit id="7b42f6092865f9dfce116ae493656407a723eb0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; list of file lines.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;파일 줄의 목록을 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="256270599d2a21266de9d3ca44caf6ec9a0edd62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; normalized pathname with . and possibly .. removed.</source>
          <target state="translated">&lt;strong&gt;로&lt;/strong&gt; 정규화 된 경로 이름을 &lt;strong&gt;반환합니다&lt;/strong&gt; . 그리고 아마도 .. 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ce77fb5c185e1e599932236eccf578ac0149806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; number of characters copied.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;복사 한 문자 수를 &lt;strong&gt;반환합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a1ecafc512de705dfc66f3c708cb522d48dec844" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; relative path from &lt;a href=&quot;to-relative-string#kotlin.io%24toRelativeString%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;base&lt;/a&gt; to this.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;to-relative-string#kotlin.io%24toRelativeString%28java.io.File%2C+java.io.File%29%2Fbase&quot;&gt;베이스&lt;/a&gt; 에서 이것 으로 상대 경로를 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6ce25bd9a12866f3c99d0b4009527916b203f6dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; string representation of this object</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 객체의 캐릭터 라인 표현을 &lt;strong&gt;돌려줍니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="973b5f4d8230019a26ae4a00e23bd3985b1352da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map associating the key of each group with the result of aggregation of the group elements.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹 요소의 집계 결과와 연관 시키는 &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 맵을 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="31f805614a95b3a152a4e8e3503fc9c1fa30a424" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; array.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 배열을 &lt;strong&gt;반환&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="087c6dc8143f829497cf0861e5fbfaeadd61d939" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; array.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 배열을 &lt;strong&gt;반환&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="2fa8216fba791e145052d8ac7b1b86596eaaf2af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; file.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt;&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;대상&lt;/a&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="27acc9ba82f869dfcfb4143708f8793837edb3f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map associating the key of each group with the count of elements in the group.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹의 요소 수와 연관 시키는 &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 맵을 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb5af6d228a8fe297ad2c9af4dd93e2e1552665f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map associating the key of each group with the result of accumulating the group elements.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹 요소 누적 결과와 연관 시키는 &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 맵을 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2749e310c879a209eb22a1cb5a1bbb756f468c5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map associating the key of each group with the result of accumulating the group elements.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹 요소 누적 결과와 연관 시키는 &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 맵을 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6deb61e01cb64a5e31cdccfc2d658785b1ea8c2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map associating the key of each group with the result of accumulating the group elements.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;각 그룹의 키를 그룹 요소 누적 결과와 연관 시키는 &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 맵을 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4a378a10b965ebe2f261cbc1dd494566ffb215" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the destination map.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;목적지 맵을 &lt;strong&gt;반환&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="3ffdb26837bd49ca6323472de0c0724c658f82b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the element from the set equal to element, or &lt;code&gt;null&lt;/code&gt; if no such element found.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 요소 또는 동일한 세트의 요소 &lt;code&gt;null&lt;/code&gt; 이러한 요소가 발견하는 경우.</target>
        </trans-unit>
        <trans-unit id="6300c053d377865c4d06fbe7cdc2058630e2ced5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the element previously at the specified position.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;지정된 위치에서 이전에 요소를 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4b6efc09075ed5094d13d36ec3f3ad9b32b91055" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the element that has been removed.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt;제거 된 요소를 하십시오.</target>
        </trans-unit>
        <trans-unit id="382bba963167e06f2f03ca507ecf8dcb8a28e37c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the entire content of this file as a String.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 파일의 전체 내용을 String로 &lt;strong&gt;돌려&lt;/strong&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="758a96abb0c21b8ac3df91694c8e0d2aa00171a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the entire content of this file as a byte array.</source>
          <target state="translated">&lt;strong&gt;돌아&lt;/strong&gt; 바이트 배열이 파일의 전체 내용을.</target>
        </trans-unit>
        <trans-unit id="09490c594c8cba913ada9f3b5e30e509ed11661a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the execution result of &lt;a href=&quot;consume#kotlin.native.concurrent.Future%24consume%28kotlin.Function1%28%28kotlin.native.concurrent.Future.T%2C+kotlin.native.concurrent.Future.consume.R%29%29%29%2Fcode&quot;&gt;code&lt;/a&gt; consumed future's computaiton</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;미래의 컴퓨터 소비 &lt;a href=&quot;consume#kotlin.native.concurrent.Future%24consume%28kotlin.Function1%28%28kotlin.native.concurrent.Future.T%2C+kotlin.native.concurrent.Future.consume.R%29%29%29%2Fcode&quot;&gt;코드&lt;/a&gt; 의 실행 결과를 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cbf69a9f8d5e44e4110ffc060bd8888111cfb959" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the future with the computation result of &lt;a href=&quot;execute#kotlin.native.concurrent.Worker%24execute%28kotlin.native.concurrent.TransferMode%2C+kotlin.Function0%28%28kotlin.native.concurrent.Worker.execute.T1%29%29%2C+kotlin.Function1%28%28kotlin.native.concurrent.Worker.execute.T1%2C+kotlin.native.concurrent.Worker.execute.T2%29%29%29%2Fjob&quot;&gt;job&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;execute#kotlin.native.concurrent.Worker%24execute%28kotlin.native.concurrent.TransferMode%2C+kotlin.Function0%28%28kotlin.native.concurrent.Worker.execute.T1%29%29%2C+kotlin.Function1%28%28kotlin.native.concurrent.Worker.execute.T1%2C+kotlin.native.concurrent.Worker.execute.T2%29%29%29%2Fjob&quot;&gt;직업&lt;/a&gt; 의 계산 결과와 함께 미래를 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf37076c8aa3610a021ccc6077cc4a6b7e081332" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the index of the element with the specified &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;key&lt;/a&gt;, if it is contained in the list within the specified range; otherwise, the inverted insertion point &lt;code&gt;(-insertion point - 1)&lt;/code&gt;. The insertion point is defined as the index at which the element should be inserted, so that the list (or the specified subrange of list) still remains sorted.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;지정된 범위 내의리스트에 요소 가 포함되어있는 경우 , 지정된 &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;키&lt;/a&gt; 를 가지는 요소의 인덱스를 &lt;strong&gt;돌려&lt;/strong&gt; 줍니다 . 그렇지 않으면 반전 된 삽입 점 &lt;code&gt;(-insertion point - 1)&lt;/code&gt; . 삽입 점은 요소를 삽입해야하는 색인으로 정의되므로 목록 (또는 지정된 목록의 하위 범위)이 여전히 정렬되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a9e803d777b9557c6245e5dedc04acbbb5d503c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the index of the element, if it is contained in the array within the specified range; otherwise, the inverted insertion point &lt;code&gt;(-insertion point - 1)&lt;/code&gt;. The insertion point is defined as the index at which the element should be inserted, so that the array (or the specified subrange of array) still remains sorted according to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;지정된 범위 내의 배열에 포함 된 요소의 색인을 &lt;strong&gt;리턴&lt;/strong&gt; 합니다. 그렇지 않으면 반전 된 삽입 점 &lt;code&gt;(-insertion point - 1)&lt;/code&gt; . 삽입 점은 요소를 삽입해야하는 인덱스로 정의되므로 배열 (또는 지정된 배열의 하위 범위)이 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;비교기&lt;/a&gt; 에 따라 정렬 된 상태를 유지합니다. .</target>
        </trans-unit>
        <trans-unit id="775f5fbcf66d03b13237514b6f1147dc2657d711" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the index of the element, if it is contained in the array within the specified range; otherwise, the inverted insertion point &lt;code&gt;(-insertion point - 1)&lt;/code&gt;. The insertion point is defined as the index at which the element should be inserted, so that the array (or the specified subrange of array) still remains sorted.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;지정된 범위 내의 배열에 포함 된 요소의 색인을 &lt;strong&gt;리턴&lt;/strong&gt; 합니다. 그렇지 않으면 반전 된 삽입 점 &lt;code&gt;(-insertion point - 1)&lt;/code&gt; . 삽입 점은 요소를 삽입해야하는 인덱스로 정의되므로 배열 (또는 지정된 배열의 하위 범위)이 여전히 정렬되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4012a5fc0b31f5f794d06557456223ca53026758" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the index of the element, if it is contained in the list within the specified range; otherwise, the inverted insertion point &lt;code&gt;(-insertion point - 1)&lt;/code&gt;. The insertion point is defined as the index at which the element should be inserted, so that the list (or the specified subrange of list) still remains sorted according to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;지정된 범위 내의 목록에 포함 된 요소의 색인을 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오. 그렇지 않으면 반전 된 삽입 점 &lt;code&gt;(-insertion point - 1)&lt;/code&gt; . 삽입 점은 요소를 삽입해야하는 색인으로 정의되므로 목록 (또는 지정된 목록의 하위 범위)이 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Fcomparator&quot;&gt;비교기&lt;/a&gt; 에 따라 정렬 된 상태를 유지합니다. .</target>
        </trans-unit>
        <trans-unit id="abae2c4f17052a4b6d596da5189044e957f8c2d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the index of the element, if it is contained in the list within the specified range; otherwise, the inverted insertion point &lt;code&gt;(-insertion point - 1)&lt;/code&gt;. The insertion point is defined as the index at which the element should be inserted, so that the list (or the specified subrange of list) still remains sorted.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;지정된 범위 내의 목록에 포함 된 요소의 색인을 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오. 그렇지 않으면 반전 된 삽입 점 &lt;code&gt;(-insertion point - 1)&lt;/code&gt; . 삽입 점은 요소를 삽입해야하는 색인으로 정의되므로 목록 (또는 지정된 목록의 하위 범위)이 여전히 정렬되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fe5f925a5408c0d4452496efd7d3368efdf5a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the index of the found element, if it is contained in the list within the specified range; otherwise, the inverted insertion point &lt;code&gt;(-insertion point - 1)&lt;/code&gt;. The insertion point is defined as the index at which the element should be inserted, so that the list (or the specified subrange of list) still remains sorted.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;발견 된 요소가 지정된 범위 내의 목록에 포함 된 경우 색인을 &lt;strong&gt;리턴&lt;/strong&gt; 합니다. 그렇지 않으면 반전 된 삽입 지점 &lt;code&gt;(-insertion point - 1)&lt;/code&gt; . 삽입 점은 요소를 삽입해야하는 색인으로 정의되므로 목록 (또는 지정된 목록의 하위 범위)이 여전히 정렬되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="41464353a5432abc68472aa43a87fd4510b66d44" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the line read or &lt;code&gt;null&lt;/code&gt; if the input stream is redirected to a file and the end of file has been reached.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;입력 스트림이 파일로 경로 재 지정되고 파일 끝에 도달 하면 행 읽기 또는 &lt;code&gt;null&lt;/code&gt; &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="00abd1476dcc6800f13251d34e163fce122295c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the new value</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;새로운 값을 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a73dc1ce77b3bdfeac35c82c9879a06dd45e6a03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the object itself</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;객체 자체를 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db93ac379ad2f180bcdfb49bb7c431587be8eb18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the old value</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이전 값을 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="821843a1f954a65c716e7255aeb29be633cee248" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the previous value associated with the key, or &lt;code&gt;null&lt;/code&gt; if the key was not present in the map.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;키와 연관된 이전 값을 &lt;strong&gt;리턴&lt;/strong&gt; 하거나 키가 맵에없는 경우 &lt;code&gt;null&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="adc207d839de621d9c31c133016cf8005e9b9252" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the previous value corresponding to the key.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;키에 해당하는 이전 값을 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="77648af26f413a409abe1497f04a2604b578679d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the property value.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;속성 값을 &lt;strong&gt;돌려&lt;/strong&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="b34b5d7fb86e6028af57a8267e0f39b46a7b3497" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the result of &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; function invoked on this resource.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 자원에 대해 호출 된 &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;블록&lt;/a&gt; 함수 의 결과를 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bca380295624f3c8e722370e31c8fa7de0db445a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the result of &lt;a href=&quot;use#kotlin.io%24use%28kotlin.io.use.T%2C+kotlin.Function1%28%28kotlin.io.use.T%2C+kotlin.io.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; function invoked on this resource.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 자원에 대해 호출 된 &lt;a href=&quot;use#kotlin.io%24use%28kotlin.io.use.T%2C+kotlin.Function1%28%28kotlin.io.use.T%2C+kotlin.io.use.R%29%29%29%2Fblock&quot;&gt;블록&lt;/a&gt; 함수 의 결과를 &lt;strong&gt;리턴&lt;/strong&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee7c24babc900efa5939c997b50c0afd279e1935" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the return value of the action.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 작업의 반환 값을.</target>
        </trans-unit>
        <trans-unit id="9acb31899c688723a198db0fea2351bf1f0c8851" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the string representation</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;문자열 표현을 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f1084fcaa9cd90ed762eab06c702383411ffc60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the string representation of this object</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 객체의 캐릭터 라인 표현을 &lt;strong&gt;돌려&lt;/strong&gt; 줍니다</target>
        </trans-unit>
        <trans-unit id="f76c792698e8a436238db69e950de4a32eeed2ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the string with corresponding file content.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;해당 파일 내용이 포함 된 문자열을 &lt;strong&gt;반환&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="d71dec34f7b948fa103ad12f043f524e474772ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the value returned by &lt;a href=&quot;use-lines#kotlin.io%24useLines%28java.io.File%2C+java.nio.charset.Charset%2C+kotlin.Function1%28%28kotlin.sequences.Sequence%28%28kotlin.String%29%29%2C+kotlin.io.useLines.T%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;돌아&lt;/strong&gt; 에 의해 반환 된 값 &lt;a href=&quot;use-lines#kotlin.io%24useLines%28java.io.File%2C+java.nio.charset.Charset%2C+kotlin.Function1%28%28kotlin.sequences.Sequence%28%28kotlin.String%29%29%2C+kotlin.io.useLines.T%29%29%29%2Fblock&quot;&gt;블록을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2880c5e8f0aa4a6d8cef3a6f0ea6a2ff942c56c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; the value returned by &lt;a href=&quot;use-lines#kotlin.io%24useLines%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.sequences.Sequence%28%28kotlin.String%29%29%2C+kotlin.io.useLines.T%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;돌아&lt;/strong&gt; 에 의해 반환 된 값 &lt;a href=&quot;use-lines#kotlin.io%24useLines%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.sequences.Sequence%28%28kotlin.String%29%29%2C+kotlin.io.useLines.T%29%29%29%2Fblock&quot;&gt;블록을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="877b5cecaa2b252b9ab89b3416e672326a38f4a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this element</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 요소를 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34c508021b5caa10d465c47f4cb1ab0f113c6cf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's greater than or equal to the &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; or the &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 는 또는이 이상인 기기의 경우이 값을 &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 또는 &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="61f5cd39885c1dc01b3d067d16a029be90fbaafa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's greater than or equal to the &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; or the &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 는 또는이 이상인 기기의 경우이 값을 &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 또는 &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="eebc7780d22e4143183c2a2547d4154da295f048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's greater than or equal to the &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.ranges.coerceAtLeast.T%2C+kotlin.ranges.coerceAtLeast.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; or the &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.ranges.coerceAtLeast.T%2C+kotlin.ranges.coerceAtLeast.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 는 또는이 이상인 기기의 경우이 값을 &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.ranges.coerceAtLeast.T%2C+kotlin.ranges.coerceAtLeast.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 또는 &lt;a href=&quot;coerce-at-least#kotlin.ranges%24coerceAtLeast%28kotlin.ranges.coerceAtLeast.T%2C+kotlin.ranges.coerceAtLeast.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="ef4840ed80dd804ff3a5986cc974374069431a7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's in the &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Int%2C+kotlin.ranges.ClosedRange%28%28kotlin.Int%29%29%29%2Frange&quot;&gt;range&lt;/a&gt;, or &lt;code&gt;range.start&lt;/code&gt; if this value is less than &lt;code&gt;range.start&lt;/code&gt;, or &lt;code&gt;range.endInclusive&lt;/code&gt; if this value is greater than &lt;code&gt;range.endInclusive&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 가에 있다면이 값을 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Int%2C+kotlin.ranges.ClosedRange%28%28kotlin.Int%29%29%29%2Frange&quot;&gt;범위&lt;/a&gt; , 또는 &lt;code&gt;range.start&lt;/code&gt; 이 값보다 작은 경우 &lt;code&gt;range.start&lt;/code&gt; , 또는 &lt;code&gt;range.endInclusive&lt;/code&gt; 이 값보다 큰 경우 &lt;code&gt;range.endInclusive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d381ed6089bee31cf9657f7884d7cd800b684ae8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's in the &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.ranges.ClosedRange%28%28kotlin.UInt%29%29%29%2Frange&quot;&gt;range&lt;/a&gt;, or &lt;code&gt;range.start&lt;/code&gt; if this value is less than &lt;code&gt;range.start&lt;/code&gt;, or &lt;code&gt;range.endInclusive&lt;/code&gt; if this value is greater than &lt;code&gt;range.endInclusive&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 가에 있다면이 값을 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.ranges.ClosedRange%28%28kotlin.UInt%29%29%29%2Frange&quot;&gt;범위&lt;/a&gt; , 또는 &lt;code&gt;range.start&lt;/code&gt; 이 값보다 작은 경우 &lt;code&gt;range.start&lt;/code&gt; , 또는 &lt;code&gt;range.endInclusive&lt;/code&gt; 이 값보다 큰 경우 &lt;code&gt;range.endInclusive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b9c6f76a81b7e32cbeffeef005b9ae1f6e6dd9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's in the &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.ClosedFloatingPointRange%28%28kotlin.ranges.coerceIn.T%29%29%29%2Frange&quot;&gt;range&lt;/a&gt;, or &lt;code&gt;range.start&lt;/code&gt; if this value is less than &lt;code&gt;range.start&lt;/code&gt;, or &lt;code&gt;range.endInclusive&lt;/code&gt; if this value is greater than &lt;code&gt;range.endInclusive&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 가에 있다면이 값을 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.ClosedFloatingPointRange%28%28kotlin.ranges.coerceIn.T%29%29%29%2Frange&quot;&gt;범위&lt;/a&gt; , 또는 &lt;code&gt;range.start&lt;/code&gt; 이 값보다 작은 경우 &lt;code&gt;range.start&lt;/code&gt; , 또는 &lt;code&gt;range.endInclusive&lt;/code&gt; 이 값보다 큰 경우 &lt;code&gt;range.endInclusive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fde12900ed9a027692d5c5cf119165bf6b3ecab3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's in the &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.ClosedRange%28%28kotlin.ranges.coerceIn.T%29%29%29%2Frange&quot;&gt;range&lt;/a&gt;, or &lt;code&gt;range.start&lt;/code&gt; if this value is less than &lt;code&gt;range.start&lt;/code&gt;, or &lt;code&gt;range.endInclusive&lt;/code&gt; if this value is greater than &lt;code&gt;range.endInclusive&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 가에 있다면이 값을 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.ClosedRange%28%28kotlin.ranges.coerceIn.T%29%29%29%2Frange&quot;&gt;범위&lt;/a&gt; , 또는 &lt;code&gt;range.start&lt;/code&gt; 이 값보다 작은 경우 &lt;code&gt;range.start&lt;/code&gt; , 또는 &lt;code&gt;range.endInclusive&lt;/code&gt; 이 값보다 큰 경우 &lt;code&gt;range.endInclusive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9021d0804acac0d3fc3135ad5a9f3e1ffebbb5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's in the range, or &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; if this value is less than &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt;, or &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; if this value is greater than &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 이 범위 내에서, 또는이 값을 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 이 값보다 작은 경우 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; , 또는 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 이 값보다 큰 경우 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.Byte%2C+kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ddf39adfe81fd55eda220beedb1ee0d92394473" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's in the range, or &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; if this value is less than &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt;, or &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; if this value is greater than &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 이 범위 내에서, 또는이 값을 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 이 값보다 작은 경우 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; , 또는 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 이 값보다 큰 경우 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da8513adee04030a29903e7fe3e8de8a045fa249" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's in the range, or &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; if this value is less than &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt;, or &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; if this value is greater than &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;반환&lt;/strong&gt; 이 범위 내에서, 또는이 값을 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; 이 값보다 작은 경우 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FminimumValue&quot;&gt;minimumValue&lt;/a&gt; , 또는 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 이 값보다 큰 경우 &lt;a href=&quot;coerce-in#kotlin.ranges%24coerceIn%28kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%2C+kotlin.ranges.coerceIn.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a83b42e6b05aeb66ee3667c04847973894c21f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's less than or equal to the &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; or the &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 는 같음보다 작거나 만약이 값을 &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 또는 &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.Byte%2C+kotlin.Byte%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="415d71faaefdfb66496a4853672627b7685ce559" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's less than or equal to the &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; or the &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 는 같음보다 작거나 만약이 값을 &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 또는 &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.UInt%2C+kotlin.UInt%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="69d49b427f4b8356fa72b73c611ce111cfb6a3cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; this value if it's less than or equal to the &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.ranges.coerceAtMost.T%2C+kotlin.ranges.coerceAtMost.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; or the &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.ranges.coerceAtMost.T%2C+kotlin.ranges.coerceAtMost.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;돌아 가기&lt;/strong&gt; 는 같음보다 작거나 만약이 값을 &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.ranges.coerceAtMost.T%2C+kotlin.ranges.coerceAtMost.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 또는 &lt;a href=&quot;coerce-at-most#kotlin.ranges%24coerceAtMost%28kotlin.ranges.coerceAtMost.T%2C+kotlin.ranges.coerceAtMost.T%29%2FmaximumValue&quot;&gt;maximumValue&lt;/a&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="5c8431565522e77a3743ab915e75ae2d663f2102" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true if at least one class has been added</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;하나 이상의 클래스가 추가 된 경우 true를 &lt;strong&gt;리턴&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ba374a632414a5a25926a487aeef7318cc5fb558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true if at least one class has been removed</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;하나 이상의 클래스가 제거 된 경우 true를 &lt;strong&gt;리턴&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="30e4762dc58a5633f80c7697f27bcefe43ab3e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true if entry was removed</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;항목이 제거되면 true를 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e6a957e507bed24c04bb61e27887d53c7358b5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true if given object is null or frozen or permanent</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;주어진 객체가 null이거나 고정되었거나 영구적 인 경우 true를 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b696d4da0033f420d47d1bbedf50dfb69ddf49f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true if successful</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;성공하면 true를 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8ed7c973c8bac9c74625fcc690e56d86eafdab1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true if successful, false if state is unchanged</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;성공하면 true를 반환하고 상태가 변경되지 않으면 false를 &lt;strong&gt;반환&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e5ff674d3474482f3927b47d78b290b63a5dbc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true, if &lt;a href=&quot;equals#kotlin.collections.AbstractList%24equals%28kotlin.Any%29%2Fother&quot;&gt;other&lt;/a&gt; instance is a &lt;a href=&quot;../-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; of the same size, which contains the same elements in the same order.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;equals#kotlin.collections.AbstractList%24equals%28kotlin.Any%29%2Fother&quot;&gt;다른&lt;/a&gt; 인스턴스가 동일한 크기 의 &lt;a href=&quot;../-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 이고 동일한 순서로 동일한 요소를 포함하는 경우 true를 &lt;strong&gt;리턴&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="f2be18c39993e6037706a6b885d4b7f44d25972d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true, if &lt;a href=&quot;equals#kotlin.collections.AbstractMap%24equals%28kotlin.Any%29%2Fother&quot;&gt;other&lt;/a&gt; instance is a &lt;a href=&quot;../-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; of the same size, all entries of which are contained in the &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set of this map.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;equals#kotlin.collections.AbstractMap%24equals%28kotlin.Any%29%2Fother&quot;&gt;다른&lt;/a&gt; 인스턴스가 동일한 크기 의 &lt;a href=&quot;../-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; 인 경우 모든 항목 이이 맵 의 &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 세트에 포함되어 있으면 true를 &lt;strong&gt;리턴하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="450a7bd83d6731d062006a06f22ecda84bb1eee0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true, if &lt;a href=&quot;equals#kotlin.collections.AbstractMutableList%24equals%28kotlin.Any%29%2Fother&quot;&gt;other&lt;/a&gt; instance is a &lt;a href=&quot;../-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; of the same size, which contains the same elements in the same order.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;equals#kotlin.collections.AbstractMutableList%24equals%28kotlin.Any%29%2Fother&quot;&gt;다른&lt;/a&gt; 인스턴스가 동일한 크기 의 &lt;a href=&quot;../-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 이고 동일한 순서로 동일한 요소를 포함하는 경우 true를 &lt;strong&gt;리턴&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="1abd8ec71f7e048bc1e62d45b940a3252b3d95c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt; true, if &lt;a href=&quot;equals#kotlin.collections.AbstractSet%24equals%28kotlin.Any%29%2Fother&quot;&gt;other&lt;/a&gt; instance is a &lt;a href=&quot;../-set/index#kotlin.collections.Set&quot;&gt;Set&lt;/a&gt; of the same size, all elements of which are contained in this set.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;equals#kotlin.collections.AbstractSet%24equals%28kotlin.Any%29%2Fother&quot;&gt;다른&lt;/a&gt; 인스턴스가 같은 크기 의 &lt;a href=&quot;../-set/index#kotlin.collections.Set&quot;&gt;Set&lt;/a&gt; 이면 모든 요소가이 Set에 포함되어 있으면 true를 &lt;strong&gt;반환&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="2f66e4f342e15e2c15a2c5623cf2e4761faf96ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;a href=&quot;../next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%29%2Farray&quot;&gt;array&lt;/a&gt; filled with random bytes.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;임의의 바이트로 채워진 &lt;a href=&quot;../next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%29%2Farray&quot;&gt;배열을 &lt;/a&gt;&lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b294601359b4f3d4c119ed3e5632a8f9d0da298e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;a href=&quot;../next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Farray&quot;&gt;array&lt;/a&gt; with the subrange filled with random bytes.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;하위 바이트가 임의 바이트로 채워진 &lt;a href=&quot;../next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Farray&quot;&gt;배열&lt;/a&gt; 을 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b508d54df04997a543b4f5556270eb1d055da965" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;a href=&quot;next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%29%2Farray&quot;&gt;array&lt;/a&gt; filled with random bytes.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;임의의 바이트로 채워진 &lt;a href=&quot;next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%29%2Farray&quot;&gt;배열을 &lt;/a&gt;&lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d033dd5199671de0a3537e5f40b076e61d09144c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;a href=&quot;next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Farray&quot;&gt;array&lt;/a&gt; with the subrange filled with random bytes.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;하위 바이트가 임의 바이트로 채워진 &lt;a href=&quot;next-bytes#kotlin.random.Random%24nextBytes%28kotlin.ByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Farray&quot;&gt;배열&lt;/a&gt; 을 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bab424612c2630fa157f921952352b21b3e669be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;a href=&quot;next-u-bytes#kotlin.random%24nextUBytes%28kotlin.random.Random%2C+kotlin.UByteArray%29%2Farray&quot;&gt;array&lt;/a&gt; filled with random bytes.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;임의의 바이트로 채워진 &lt;a href=&quot;next-u-bytes#kotlin.random%24nextUBytes%28kotlin.random.Random%2C+kotlin.UByteArray%29%2Farray&quot;&gt;배열을 &lt;/a&gt;&lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a906e2a8cc578bed0acb2898690e9a676315ea74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;a href=&quot;next-u-bytes#kotlin.random%24nextUBytes%28kotlin.random.Random%2C+kotlin.UByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Farray&quot;&gt;array&lt;/a&gt; with the subrange filled with random bytes.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;하위 바이트가 임의 바이트로 채워진 &lt;a href=&quot;next-u-bytes#kotlin.random%24nextUBytes%28kotlin.random.Random%2C+kotlin.UByteArray%2C+kotlin.Int%2C+kotlin.Int%29%2Farray&quot;&gt;배열&lt;/a&gt; 을 &lt;strong&gt;반환&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9b06b8e30941a46203783fa2263dcc56803e210d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;false&lt;/code&gt; if the copying was terminated, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;돌아 &lt;/strong&gt; &lt;code&gt;false&lt;/code&gt; 복사가 종결 된 경우 &lt;code&gt;true&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="d85c6a1f6c8ee5b0b19cbadfd01fe4cef34ffe32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; because the list is always modified as the result of this operation.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 작업의 결과로 목록이 항상 수정되므로 &lt;code&gt;true&lt;/code&gt; 를&lt;strong&gt;반환 &lt;/strong&gt;합니다 .</target>
        </trans-unit>
        <trans-unit id="e99d6b7092ed9791a108813e7dd62b6bfd4c4564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if any element was removed from the collection, &lt;code&gt;false&lt;/code&gt; if the collection was not modified.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 요소가 컬렉션에서 제거 된 경우 &lt;code&gt;false&lt;/code&gt; 컬렉션이 수정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="eda7d2731274f6578b2d790d945d3f173dc467a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if any of the specified elements was added to the collection, &lt;code&gt;false&lt;/code&gt; if the collection was not modified.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 지정된 요소의 컬렉션에 추가 된 경우 &lt;code&gt;false&lt;/code&gt; 컬렉션이 수정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="c0914dec855b485e9447591d8b1d2ea762e7b625" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if any of the specified elements was removed from the collection, &lt;code&gt;false&lt;/code&gt; if the collection was not modified.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 지정된 요소의 컬렉션에서 제거 된 경우 &lt;code&gt;false&lt;/code&gt; 컬렉션이 수정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="4085e70ac8e0a282f24db18b8e39ab9afbcd3c90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if the element has been added, &lt;code&gt;false&lt;/code&gt; if the collection does not support duplicates and the element is already contained in the collection.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 요소가 추가 된 경우 &lt;code&gt;false&lt;/code&gt; 컬렉션이 중복을 지원하지 않는 경우 및 요소가 이미 컬렉션에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c693fb6263911181b9191c3e80cefdba651bbc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if the element has been added, &lt;code&gt;false&lt;/code&gt; if the element is already contained in the set.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;요소가 추가 된 경우 &lt;code&gt;false&lt;/code&gt; 를, 요소가 이미 세트에 포함되어 있으면 false를 &lt;strong&gt;리턴 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be16cec8a6f631c29ffef54f22443552439f434d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if the element has been successfully removed; &lt;code&gt;false&lt;/code&gt; if it was not present in the collection.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;요소가 성공적으로 제거되면 &lt;code&gt;true&lt;/code&gt; 를&lt;strong&gt;리턴 &lt;/strong&gt;합니다 . 컬렉션에없는 경우는 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="521a23e654976973f6c980fa65c69b6e1aba2f07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if the file or directory is successfully deleted, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 파일 또는 디렉토리가 성공적으로 삭제되는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="941a19bf827b2a2218dcdc25ef7e7c2983c7316b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if the list was changed as the result of the operation.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;조작의 결과로서리스트가 변경된 경우에 &lt;code&gt;true&lt;/code&gt; 를&lt;strong&gt;돌려&lt;/strong&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="6dbadcd982d0682b5671bd12c74a9d49f1990220" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if this path ends with &lt;a href=&quot;ends-with#kotlin.io%24endsWith%28java.io.File%2C+java.io.File%29%2Fother&quot;&gt;other&lt;/a&gt; path, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 경우이 경로 끝 &lt;a href=&quot;ends-with#kotlin.io%24endsWith%28java.io.File%2C+java.io.File%29%2Fother&quot;&gt;다른&lt;/a&gt; 경로, &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="eceac9e8b9c56bf2844532ab7d9c753f88314b2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if this path ends with &lt;a href=&quot;ends-with#kotlin.io%24endsWith%28java.io.File%2C+kotlin.String%29%2Fother&quot;&gt;other&lt;/a&gt; path, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 경우이 경로 끝 &lt;a href=&quot;ends-with#kotlin.io%24endsWith%28java.io.File%2C+kotlin.String%29%2Fother&quot;&gt;다른&lt;/a&gt; 경로, &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="ee6bf65ee9c660d8514a3a0e20e62b59d46c4af1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt; if this path starts with &lt;a href=&quot;starts-with#kotlin.io%24startsWith%28java.io.File%2C+java.io.File%29%2Fother&quot;&gt;other&lt;/a&gt; path, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;strong&gt;반환 &lt;/strong&gt; &lt;code&gt;true&lt;/code&gt; 이 경로로 시작하면 &lt;a href=&quot;starts-with#kotlin.io%24startsWith%28java.io.File%2C+java.io.File%29%2Fother&quot;&gt;다른&lt;/a&gt; 경로, &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="1e53e313286086d837575656b1cdb53b2d001f2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt;, if &lt;a href=&quot;equals#kotlin.collections.AbstractMutableSet%24equals%28kotlin.Any%29%2Fother&quot;&gt;other&lt;/a&gt; instance is a &lt;a href=&quot;../-set/index#kotlin.collections.Set&quot;&gt;Set&lt;/a&gt; of the same size, all elements of which are contained in this set.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;equals#kotlin.collections.AbstractMutableSet%24equals%28kotlin.Any%29%2Fother&quot;&gt;다른&lt;/a&gt; 인스턴스가 같은 크기 의 &lt;a href=&quot;../-set/index#kotlin.collections.Set&quot;&gt;Set&lt;/a&gt; 이면 모든 요소가이 세트에 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를&lt;strong&gt;리턴 &lt;/strong&gt;하십시오 .</target>
        </trans-unit>
        <trans-unit id="368c7c8580df5fcb5fb1ce96a7ec159ad5e111f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scalability&lt;/strong&gt;: Kotlin's support for &lt;a href=&quot;coroutines-overview&quot;&gt;coroutines&lt;/a&gt; helps build server-side applications that scale to massive numbers of clients with modest hardware requirements.</source>
          <target state="translated">&lt;strong&gt;확장 성&lt;/strong&gt; : Kotlin의 코 &lt;a href=&quot;coroutines-overview&quot;&gt;루틴&lt;/a&gt; 지원은 적당한 하드웨어 요구 사항으로 수많은 클라이언트로 확장 할 수있는 서버 측 응용 프로그램을 구축하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="aba4f52264f8c7fb90641546ceab5aa6ef0435aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;See Also&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또한보십시오&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5da23d00148c01b92b2648ebc9d47a24327f6f9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setter&lt;/strong&gt; if set to &lt;code&gt;true&lt;/code&gt;, suppresses JVM access checks for this callable object. For a property, both accessors are made accessible.</source>
          <target state="translated">&lt;strong&gt;Setter&lt;/strong&gt; 가 &lt;code&gt;true&lt;/code&gt; 로&lt;strong&gt;설정&lt;/strong&gt; 되면 이 호출 가능 오브젝트에 대한 JVM 액세스 검사를 억제합니다. 속성의 경우 두 접근자가 모두 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b3df1e654a6e942881d7f23a5dd9163acdc64a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: Kotlin 1.3 discontinues the following deprecated binary artifacts:</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3은 다음과 같은 더 이상 사용되지 않는 이진 아티팩트를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="0ee7a8bec6eac07ada028775fbc0f024763bf715" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: Kotlin 1.3 removes annotations from the package &lt;code&gt;org.jetbrains.annotations&lt;/code&gt; from stdlib and moves them to the separate artifacts shipped with the compiler: &lt;code&gt;annotations-13.0.jar&lt;/code&gt; and &lt;code&gt;mutability-annotations-compat.jar&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3은 stdlib 의 패키지 &lt;code&gt;org.jetbrains.annotations&lt;/code&gt; 에서 주석을 제거하고 주석을 컴파일러와 함께 제공된 별도의 아티팩트로 이동합니다 : &lt;code&gt;annotations-13.0.jar&lt;/code&gt; 및 &lt;code&gt;mutability-annotations-compat.jar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="659a889770132f3b0feeaebd5b13b9345beab732" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: a smartcast on a member of one enum entry will be correctly applied to only this enum entry</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : 하나의 열거 형 항목 멤버의 스마트 캐스트가이 열거 형 항목에만 올바르게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ed1ce28abf7c2908a12450ad4a20d59301ac2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: errors in getter-target annotations will be reported properly in 1.3</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : getter-target 주석의 오류는 1.3에서 올바르게보고됩니다</target>
        </trans-unit>
        <trans-unit id="30f95d257cce069a40e0b758b5bce0880b543c01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: evaluation order with respect to class initialization is changed in 1.3</source>
          <target state="translated">&lt;strong&gt;짧은 요약&lt;/strong&gt; : 클래스 초기화에 대한 평가 순서는 1.3에서 변경됩니다</target>
        </trans-unit>
        <trans-unit id="cb5039733125761c8239ceec59a4f67ec35c203e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: getter-target annotations on annotations constructor parameters will be properly written to classfiles in 1.3</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : 주석 생성자 매개 변수에 대한 getter-target 주석이 1.3의 클래스 파일에 올바르게 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9a298a201b00abaeb62424fe5b38ab40d7cdf657" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: if an expression in for-loop range is a local variable updated in a loop body, this change affects loop execution. This is inconsistent with iterating over other containers, such as ranges, character sequences, and collections.</source>
          <target state="translated">&lt;strong&gt;짧은 요약&lt;/strong&gt; : for-loop 범위의 표현식이 루프 본문에서 업데이트 된 로컬 변수 인 경우이 변경은 루프 실행에 영향을줍니다. 이것은 범위, 문자 시퀀스 및 컬렉션과 같은 다른 컨테이너를 반복하는 것과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a94db9866ff1d98a5e2105675817dabc0de5b17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: in Kotlin 1.3, assigning single element to vararg is deprecated and should be replaced with consecutive spread and array construction.</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3에서는 단일 요소를 vararg에 할당하는 것이 더 이상 사용되지 않으며 연속적인 스프레드 및 배열 구성으로 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="f789fff8850846faf65297cd9d5db55b6e891536" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: nullability assertions for Java-types annotated with not-null annotations will be generated more aggressively, causing code which passes &lt;code&gt;null&lt;/code&gt; here to fail faster.</source>
          <target state="translated">&lt;strong&gt;요약&lt;/strong&gt; : null이 아닌 주석으로 주석이 달린 Java 유형에 대한 nullability 어설 션이 더 적극적으로 생성되어 여기서 &lt;code&gt;null&lt;/code&gt; 을 전달하는 코드가 더 빨리 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0790dd4b65c702a13059dd52c6010990cf99139f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: reassignment of the backing field of &lt;code&gt;val&lt;/code&gt;-property in its getter is now prohibited</source>
          <target state="translated">&lt;strong&gt;짧은 요약&lt;/strong&gt; : 게터에서 &lt;code&gt;val&lt;/code&gt; - property 의 지원 필드를 재 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ea0777c773b37a77ac450057f510d49b9f1cb32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3 declaration of &lt;code&gt;mod&lt;/code&gt; operator is prohibited, as well as calls which resolve to such declarations</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : &lt;code&gt;mod&lt;/code&gt; 연산자 의 Kotlin 1.3 선언 은 금지되어 있으며 이러한 선언으로 해석되는 호출</target>
        </trans-unit>
        <trans-unit id="45036e88dcdf5c6c484175995dc3c64aa4c1a8aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3 local annotation classes are not supported</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3 로컬 주석 클래스는 지원되지 않기 때문에</target>
        </trans-unit>
        <trans-unit id="c4b03bea8c917ba8281ac12cba32cd7a5af14ba0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3 smartcasts on local delegated properties are not allowed</source>
          <target state="translated">&lt;strong&gt;짧은 요약&lt;/strong&gt; : 로컬 위임 속성에 대한 Kotlin 1.3 스마트 캐스트 이후로는 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="d47f9e57b901e028b4815e78b12d5f6d1a456eb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, data classes are prohibited to override &lt;code&gt;copy()&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3부터 ​​데이터 클래스는 &lt;code&gt;copy()&lt;/code&gt; 를 무시할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="9875f45a55dbc71204e25a03adacf85e874bd3d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, ensure that the &lt;code&gt;toIndex&lt;/code&gt; argument of &lt;code&gt;Array.copyOfRange&lt;/code&gt;, which represents the exclusive end of the range being copied, is not greater than the array size and throw &lt;code&gt;IllegalArgumentException&lt;/code&gt; if it is.</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3 이후로, 복사되는 범위의 배타적 끝을 나타내는 &lt;code&gt;Array.copyOfRange&lt;/code&gt; 의 &lt;code&gt;toIndex&lt;/code&gt; 인수가 배열 크기보다 크지 않도록하고 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c85212b875bd3c20f73f2ebcc84885e20fcf7f17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, error about wrong annotation target will be properly reported when annotation with target &lt;code&gt;PARAMETER&lt;/code&gt; is applied to parameter's type</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3부터 ​​대상 &lt;code&gt;PARAMETER&lt;/code&gt; 가있는 주석이 매개 변수 유형에 적용될 때 잘못된 주석 대상에 대한 오류가 올바르게보고됩니다.</target>
        </trans-unit>
        <trans-unit id="bf69aecb16d88c150cceda726ac8fdd9b8a437a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, inner classes are not allowed to inherit &lt;code&gt;Throwable&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;짧은 요약&lt;/strong&gt; : Kotlin 1.3부터 ​​내부 클래스는 &lt;code&gt;Throwable&lt;/code&gt; 을 상속받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="408307590ffce3274f1ed85ddb1ed0ca1ea12b03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, make sure &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; and similar methods do not overflow for long sequences. See the Issue for the full list of affected methods.</source>
          <target state="translated">&lt;strong&gt;짧은 요약&lt;/strong&gt; : Kotlin 1.3부터는 &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; 및 유사한 메소드가 긴 시퀀스에서 오버플로되지 않도록하십시오. 영향을받는 방법의 전체 목록은 문제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7a0bd4ed579ebbb6934da310497aa38764dc3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, nested classifiers (classes, object, interfaces, annotation classes, enum classes) in enum entries are prohibited</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3부터 ​​열거 형 항목의 중첩 분류 자 ​​(클래스, 객체, 인터페이스, 주석 클래스, 열거 형 클래스)는 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="f2f7b257e074a8a8fd3e28c4f3f9246cd86541d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, only &lt;code&gt;SOURCE&lt;/code&gt; retention is allowed for annotations with target &lt;code&gt;EXPRESSION&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3부터 대상 &lt;code&gt;EXPRESSION&lt;/code&gt; 이있는 주석에는 &lt;code&gt;SOURCE&lt;/code&gt; 보존 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="81f515e78c6041ef53594b1a17dd05e48bede5ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, prohibit step value for integer progressions being the minimum negative value of its integer type (&lt;code&gt;Long&lt;/code&gt; or &lt;code&gt;Int&lt;/code&gt;), so that calling &lt;code&gt;IntProgression.fromClosedRange(0, 1, step = Int.MIN_VALUE)&lt;/code&gt; will throw &lt;code&gt;IllegalArgumentException&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3부터 ​​정수 진행의 단계 값이 정수 유형의 최소 음수 값 ( &lt;code&gt;Long&lt;/code&gt; 또는 &lt;code&gt;Int&lt;/code&gt; )이되지 않도록 &lt;code&gt;IntProgression.fromClosedRange(0, 1, step = Int.MIN_VALUE)&lt;/code&gt; 를 호출 하면 &lt;code&gt;IllegalArgumentException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="63da536ad803e75f1e57970ba0d317e351a3f5bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, rules of visibility by short names are stricter for complex class hierarchies involving companion objects and nested classifiers.</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3 이후로 짧은 이름의 가시성 규칙은 컴패니언 객체 및 중첩 된 분류자가 포함 된 복잡한 클래스 계층 구조에 대해 더 엄격합니다.</target>
        </trans-unit>
        <trans-unit id="6cc8e0cd30c4e9a6b4d5761550cefe94ffda129a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, setting non-constant values as vararg annotation parameters is prohibited</source>
          <target state="translated">&lt;strong&gt;간단한 요약&lt;/strong&gt; : Kotlin 1.3부터는 상수가 아닌 값을 vararg 주석 매개 변수로 설정하는 것이 금지됩니다</target>
        </trans-unit>
        <trans-unit id="ddaa338ce4bcf1b6176f1ca2bdbaf24a2d43fb82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Short summary&lt;/strong&gt;: since Kotlin 1.3, unify behavior of &lt;code&gt;split&lt;/code&gt; method by empty match regex across all platforms</source>
          <target state="translated">&lt;strong&gt;짧은 요약&lt;/strong&gt; : Kotlin 1.3 이후 모든 플랫폼에서 빈 일치 정규식 으로 &lt;code&gt;split&lt;/code&gt; 방법의 동작을 통합</target>
        </trans-unit>
        <trans-unit id="b3d48e0508d5a3312f1e060e051f6acb179d93d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Since&lt;/strong&gt; JDK 1.8</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;JDK 1.8 &lt;strong&gt;부터&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5b1cb482aa105b0904961b456ea52c857a321c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Source&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Source&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8146f1ee5c295c4989c6751eed8a133b33324203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stable Incremental Releases (SIR)&lt;/strong&gt;: incremental releases are fully compatible, only optimizations and bug fixes happen. Any changes can be made in a &lt;a href=&quot;kotlin-evolution#feature-releases-and-incremental-releases&quot;&gt;feature release&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;SIR (Stable Incremental Release)&lt;/strong&gt; : 증분 릴리스는 완전히 호환되며 최적화 및 버그 수정 만 발생합니다. &lt;a href=&quot;kotlin-evolution#feature-releases-and-incremental-releases&quot;&gt;기능 릴리스&lt;/a&gt; 에서는 모든 변경이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="fafc0b1a9daa3668df46e9f30358b04853e27ffe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Status Entered at version&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;버전에 입력 된 상태&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37761219bd6b77fdffd94b251cc357d512620f32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Table of contents&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;목차&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c4a46ba94390494470065adf7e6b2f83d2ff2b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The context object&lt;/strong&gt; is available as a receiver (&lt;code&gt;this&lt;/code&gt;). &lt;strong&gt;The return value&lt;/strong&gt; is the lambda result.</source>
          <target state="translated">&lt;strong&gt;컨텍스트 오브젝트&lt;/strong&gt; 는 수신자 ( &lt;code&gt;this&lt;/code&gt; )로 사용 가능합니다. &lt;strong&gt;반환 값&lt;/strong&gt; 은 람다 결과입니다.</target>
        </trans-unit>
        <trans-unit id="88215a82c793e942d2af897c557ba7684fa2ef06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The context object&lt;/strong&gt; is available as a receiver (&lt;code&gt;this&lt;/code&gt;). &lt;strong&gt;The return value&lt;/strong&gt; is the object itself.</source>
          <target state="translated">&lt;strong&gt;컨텍스트 오브젝트&lt;/strong&gt; 는 수신자 ( &lt;code&gt;this&lt;/code&gt; )로 사용 가능합니다. &lt;strong&gt;반환 값&lt;/strong&gt; 은 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="54de5f5c6c58d16df4367451081909208a5bcc0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The context object&lt;/strong&gt; is available as an argument (&lt;code&gt;it&lt;/code&gt;). &lt;strong&gt;The return value&lt;/strong&gt; is the lambda result.</source>
          <target state="translated">&lt;strong&gt;컨텍스트 오브젝트&lt;/strong&gt; 는 인수 ( &lt;code&gt;it&lt;/code&gt; )로 사용 가능합니다. &lt;strong&gt;반환 값&lt;/strong&gt; 은 람다 결과입니다.</target>
        </trans-unit>
        <trans-unit id="953fcac7a2079b358a15b4680c6c75014d93ef81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The context object&lt;/strong&gt; is available as an argument (&lt;code&gt;it&lt;/code&gt;). &lt;strong&gt;The return value&lt;/strong&gt; is the object itself.</source>
          <target state="translated">&lt;strong&gt;컨텍스트 오브젝트&lt;/strong&gt; 는 인수 ( &lt;code&gt;it&lt;/code&gt; )로 사용 가능합니다. &lt;strong&gt;반환 값&lt;/strong&gt; 은 객체 자체입니다.</target>
        </trans-unit>
        <trans-unit id="5871a70d1e542e89b7ab8b15ac3cc3874a37b906" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tooling&lt;/strong&gt;: In addition to great IDE support in general, Kotlin offers framework-specific tooling (for example, for Spring) in the plugin for IntelliJ IDEA Ultimate.</source>
          <target state="translated">&lt;strong&gt;툴링&lt;/strong&gt; : Kotlin은 일반적으로 뛰어난 IDE 지원 외에도 IntelliJ IDEA Ultimate 플러그인에서 프레임 워크 별 툴링 (예 : Spring)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="71c5bff736c57fab5798aafd2d132e3b32e00919" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UMD&lt;/strong&gt; tries to unify both models allowing these to be used either on the client or server.</source>
          <target state="translated">&lt;strong&gt;UMD&lt;/strong&gt; 는 두 모델을 통합하여 클라이언트 또는 서버에서 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c728986c73dfcd4771f2e125c05c49b6de5d4c6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Working with server-side technology&lt;/strong&gt;. You can use Kotlin to interact with server-side JavaScript such as Node.js</source>
          <target state="translated">&lt;strong&gt;서버 측 기술로 작업&lt;/strong&gt; . Kotlin을 사용하여 Node.js와 같은 서버 측 JavaScript와 상호 작용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1573775a40b4413b43276a7869672eadf61c04d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;foo.klib&lt;/strong&gt; when unpacked as &lt;strong&gt;foo/&lt;/strong&gt; gives us:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;foo /&lt;/strong&gt; 로 압축을 풀 때 &lt;strong&gt;foo.klib&lt;/strong&gt; 는 다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf94185ef76323dec09fef0cbf20c3d5c523700f" translate="yes" xml:space="preserve">
          <source>@&lt;a href=&quot;index&quot;&gt;JvmDefault&lt;/a&gt; methods are excluded from interface delegation.</source>
          <target state="translated">@ &lt;a href=&quot;index&quot;&gt;JvmDefault&lt;/a&gt; 메소드는 인터페이스 위임에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="a85269ecc4d736bf7f756267a46b4cd70390de5b" translate="yes" xml:space="preserve">
          <source>@JvmDefault</source>
          <target state="translated">@JvmDefault</target>
        </trans-unit>
        <trans-unit id="38367cdaa4e817128dc323103f0d5c6a9b4d10f0" translate="yes" xml:space="preserve">
          <source>@JvmStatic and @JvmField in companion of interfaces</source>
          <target state="translated">인터페이스와 함께 사용되는 @JvmStatic 및 @JvmField</target>
        </trans-unit>
        <trans-unit id="93e9ecea8983e2a8a6ac905cc55324675716b123" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#setting-up-targets&quot;&gt;target&lt;/a&gt; is a part of the build that is responsible for building, testing, and packaging a complete piece of software for one of the platforms. Therefore, a multiplatform project usually contains multiple targets.</source>
          <target state="translated">&lt;a href=&quot;#setting-up-targets&quot;&gt;대상&lt;/a&gt; , 구축 테스트 및 플랫폼 중 하나에 대한 소프트웨어의 전체 조각을 포장 할 책임이 빌드의 일부입니다. 따라서 다중 플랫폼 프로젝트에는 일반적으로 여러 대상이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8b697eb28e0477b9900378779138d85233522e5d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../-future-state/index&quot;&gt;FutureState&lt;/a&gt; of this future</source>
          <target state="translated">&lt;a href=&quot;../-future-state/index&quot;&gt;FutureState&lt;/a&gt; 이 미래의</target>
        </trans-unit>
        <trans-unit id="25026241e77cf4069930d2a81998f1ff17f630fd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html&quot;&gt;Channel&lt;/a&gt; is conceptually very similar to &lt;code&gt;BlockingQueue&lt;/code&gt;. One key difference is that instead of a blocking &lt;code&gt;put&lt;/code&gt; operation it has a suspending &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html&quot;&gt;send&lt;/a&gt;, and instead of a blocking &lt;code&gt;take&lt;/code&gt; operation it has a suspending &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;receive&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html&quot;&gt;채널은&lt;/a&gt; 개념적으로 매우 유사하다 &lt;code&gt;BlockingQueue&lt;/code&gt; 의 . 한 가지 중요한 차이점은 블로킹 &lt;code&gt;put&lt;/code&gt; 작업 대신에 일시 중단 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html&quot;&gt;송신&lt;/a&gt; 이 있고 블로킹 &lt;code&gt;take&lt;/code&gt; 작업 대신에 일시 중단 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;수신이 있다는 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b58e2f469b88e2806e3ea71b6dc650ab9d539789" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; structure serves as an intermediate step in group-and-fold operations: they group elements by their keys and then fold each group with some aggregating operation.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;그룹화&lt;/a&gt; 열쇠에 의해 그들이 족 원소하고 일부 응집 조작으로 각 그룹을 겹 : 구조 그룹과 배 작업의 중간 단계로서 기능한다.</target>
        </trans-unit>
        <trans-unit id="335776bae2e0bd7845875238ad8bcbd05a6733c6" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;properties#late-initialized-properties-and-variables&quot;&gt;late-initialized&lt;/a&gt; property in an object or a companion object has a static backing field with the same visibility as the property setter.</source>
          <target state="translated">&lt;a href=&quot;properties#late-initialized-properties-and-variables&quot;&gt;늦은 초기화&lt;/a&gt; 객체 또는 컴패니언 객체 속성은 속성 설정 부와 같은 시인성 정적 배면 필드를 갖는다.</target>
        </trans-unit>
        <trans-unit id="8a131d6c33e43901a9e73e6d096d64a24f2b4bf6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop over a range or an array is compiled to an index-based loop that does not create an iterator object.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 범위 또는 배열 위에 루프 반복자 객체를 생성하지 않는 인덱스 기반 루프로 컴파일된다.</target>
        </trans-unit>
        <trans-unit id="5eba7bd06ba05689a35417f4a2d10cd2c5491c37" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;break&lt;/em&gt; qualified with a label jumps to the execution point right after the loop marked with that label. A &lt;em&gt;continue&lt;/em&gt; proceeds to the next iteration of that loop.</source>
          <target state="translated">레이블이 있는 &lt;em&gt;구분&lt;/em&gt; 은 해당 레이블이 표시된 루프 바로 다음에 실행 지점으로 이동합니다. A는 &lt;em&gt;계속&lt;/em&gt; 그 루프의 다음 반복으로 진행합니다.</target>
        </trans-unit>
        <trans-unit id="810ff113834a8301e08e007d7f4d97785fa7d41b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;common&lt;/em&gt; module contains code that is not specific to any platform, as well as declarations without implementation of platform-dependent APIs.</source>
          <target state="translated">&lt;em&gt;공통&lt;/em&gt; 모듈은 플랫폼에 따라 API를 구현하지 않고 모든 플랫폼 특정하지 않습니다 코드뿐만 아니라 선언이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f2cbebae11ba3ce0b4a055abc4e44e360c81202" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;mutable&lt;/em&gt; interface that extends the corresponding read-only interface with write operations: adding, removing, and updating its elements.</source>
          <target state="translated">쓰기 조작으로 해당 읽기 전용 인터페이스를 확장 하는 &lt;em&gt;변경 가능한&lt;/em&gt; 인터페이스 : 요소 추가, 제거 및 업데이트</target>
        </trans-unit>
        <trans-unit id="33e051bd23939b7cc0237b3b6664b35b7845b6d9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;platform&lt;/em&gt; module contains implementations of platform-dependent declarations in the common module for a specific platform, as well as other platform-dependent code.</source>
          <target state="translated">&lt;em&gt;플랫폼&lt;/em&gt; 모듈은 특정 플랫폼에 대한 공통 모듈 플랫폼 의존의 선언뿐만 아니라 다른 플랫폼에 의존적 인 코드의 구현을 포함하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="95129f3c56e36bede13a9f1dc15ab985f6e80cf9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;read-only&lt;/em&gt; interface that provides operations for accessing collection elements.</source>
          <target state="translated">컬렉션 요소에 액세스하기위한 작업을 제공 하는 &lt;em&gt;읽기 전용&lt;/em&gt; 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="da52eb5eec241d05137b0082a603533ac5d1c95c" translate="yes" xml:space="preserve">
          <source>A Basic Kotlin/Native Application</source>
          <target state="translated">기본 Kotlin / 기본 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="45fdff9421f438f4d7095c3e89f7e8657a2e2d21" translate="yes" xml:space="preserve">
          <source>A Comparator that orders strings ignoring character case.</source>
          <target state="translated">대소 문자를 무시하고 문자열을 주문하는 비교기.</target>
        </trans-unit>
        <trans-unit id="b8368fc3f88edc8b7307923a1672190efe58c88b" translate="yes" xml:space="preserve">
          <source>A Kotlin property is compiled to the following Java elements:</source>
          <target state="translated">Kotlin 특성은 다음 Java 요소로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="52912edb0637c5b19a657c18414f717688261523" translate="yes" xml:space="preserve">
          <source>A Kotlin source set is a collection of Kotlin sources, along with their resources, dependencies, and language settings, which may take part in Kotlin compilations of one or more &lt;a href=&quot;#setting-up-targets&quot;&gt;targets&lt;/a&gt;.</source>
          <target state="translated">Kotlin 소스 세트는 자원, 종속성 및 언어 설정과 함께 Kotlin 소스 모음으로, 하나 이상의 &lt;a href=&quot;#setting-up-targets&quot;&gt;대상&lt;/a&gt; 에 대한 Kotlin 컴파일에 참여할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9d72197be74b6ce3e9d239f43e83398938bba30" translate="yes" xml:space="preserve">
          <source>A UTF-16 &lt;em&gt;code unit&lt;/em&gt; is a 16-bit unsigned integral value that represents either one Unicode &lt;em&gt;code point&lt;/em&gt; (character code) or must be combined with another code unit to form a code unit. If this makes no sense, I strongly recommend &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;Joel Spolsky's excellent essay on Unicode and its encodings&lt;/a&gt;. For most Western scripts, including English, all code points fit inside one code unit, so it's tempting to think of a code unit as a character - but that will lead astray once your code encounters non-Western scripts. A single UTF-16 code unit can be represented with single quotes, and has the type &lt;code&gt;Char&lt;/code&gt;:</source>
          <target state="translated">UTF-16 &lt;em&gt;코드 단위&lt;/em&gt; 는 하나의 유니 &lt;em&gt;코드 코드 포인트&lt;/em&gt; (문자 코드) 를 나타내는 16 비트 부호없는 정수 값 이거나 다른 코드 단위와 결합하여 코드 단위를 형성해야합니다. 이것이 의미가 없다면, &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;유니 코드와 인코딩에 관한 Joel Spolsky의 훌륭한 에세이를&lt;/a&gt; 강력히 추천 합니다. 영어를 포함한 대부분의 서구 스크립트의 경우 모든 코드 포인트가 하나의 코드 단위 안에 들어 맞기 때문에 코드 단위를 문자로 생각하고 싶은 유혹이 있습니다. 단일 UTF-16 코드 단위는 작은 따옴표로 표시 할 수 있으며 &lt;code&gt;Char&lt;/code&gt; 유형을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="96c66067cd323127bbca005bcf884da823834a7c" translate="yes" xml:space="preserve">
          <source>A backing field will be generated for a property if it uses the default implementation of at least one of the accessors, or if a custom accessor references it through the &lt;code&gt;field&lt;/code&gt; identifier.</source>
          <target state="translated">접근자가 하나 이상의 접근 자의 기본 구현을 사용하거나 사용자 지정 접근자가 &lt;code&gt;field&lt;/code&gt; 식별자를 통해이를 참조하는 경우 속성에 대한 백업 필드가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ee4431e92fae7f00d11a4c7bbc04a214dd9d66e" translate="yes" xml:space="preserve">
          <source>A base class to simplify implementing iterators so that implementations only have to implement &lt;a href=&quot;-abstract-iterator/compute-next&quot;&gt;computeNext&lt;/a&gt; to implement the iterator, calling &lt;a href=&quot;-abstract-iterator/done&quot;&gt;done&lt;/a&gt; when the iteration is complete.</source>
          <target state="translated">그 구현은 구현해야하므로 기본 클래스는 반복자를 구현 단순화 &lt;a href=&quot;-abstract-iterator/compute-next&quot;&gt;computeNext을&lt;/a&gt; 반복자를 구현하기 위해 호출 &lt;a href=&quot;-abstract-iterator/done&quot;&gt;할&lt;/a&gt; 반복이 완료되면.</target>
        </trans-unit>
        <trans-unit id="3cea63124cc4132c0ed5c37a6d8367f6e00ac701" translate="yes" xml:space="preserve">
          <source>A base class to simplify implementing iterators so that implementations only have to implement &lt;a href=&quot;../-abstract-iterator/compute-next&quot;&gt;computeNext&lt;/a&gt; to implement the iterator, calling &lt;a href=&quot;../-abstract-iterator/done&quot;&gt;done&lt;/a&gt; when the iteration is complete.</source>
          <target state="translated">그 구현은 구현해야하므로 기본 클래스는 반복자를 구현 단순화 &lt;a href=&quot;../-abstract-iterator/compute-next&quot;&gt;computeNext을&lt;/a&gt; 반복자를 구현하기 위해 호출 &lt;a href=&quot;../-abstract-iterator/done&quot;&gt;할&lt;/a&gt; 반복이 완료되면.</target>
        </trans-unit>
        <trans-unit id="f2d9320495e89647cf476a32dde9596e3a857b4e" translate="yes" xml:space="preserve">
          <source>A base class to simplify implementing iterators so that implementations only have to implement &lt;a href=&quot;../../kotlin.collections/-abstract-iterator/compute-next&quot;&gt;computeNext&lt;/a&gt; to implement the iterator, calling &lt;a href=&quot;../../kotlin.collections/-abstract-iterator/done&quot;&gt;done&lt;/a&gt; when the iteration is complete.</source>
          <target state="translated">그 구현은 구현해야하므로 기본 클래스는 반복자를 구현 단순화 &lt;a href=&quot;../../kotlin.collections/-abstract-iterator/compute-next&quot;&gt;computeNext을&lt;/a&gt; 반복자를 구현하기 위해 호출 &lt;a href=&quot;../../kotlin.collections/-abstract-iterator/done&quot;&gt;할&lt;/a&gt; 반복이 완료되면.</target>
        </trans-unit>
        <trans-unit id="6c00a104f4d876da7e0de80875ea0fca9e6228b1" translate="yes" xml:space="preserve">
          <source>A base class to simplify implementing iterators so that implementations only have to implement &lt;a href=&quot;compute-next&quot;&gt;computeNext&lt;/a&gt; to implement the iterator, calling &lt;a href=&quot;done&quot;&gt;done&lt;/a&gt; when the iteration is complete.</source>
          <target state="translated">그 구현은 구현해야하므로 기본 클래스는 반복자를 구현 단순화 &lt;a href=&quot;compute-next&quot;&gt;computeNext을&lt;/a&gt; 반복자를 구현하기 위해 호출 &lt;a href=&quot;done&quot;&gt;할&lt;/a&gt; 반복이 완료되면.</target>
        </trans-unit>
        <trans-unit id="19e053ed1d26677db3c1fac7c3736abed6ea9733" translate="yes" xml:space="preserve">
          <source>A base exception class for file system exceptions.</source>
          <target state="translated">파일 시스템 예외에 대한 기본 예외 클래스.</target>
        </trans-unit>
        <trans-unit id="17d2682da31f89530133e0830b02d6e277febabd" translate="yes" xml:space="preserve">
          <source>A basic Kotlin/Native application</source>
          <target state="translated">기본 Kotlin / 네이티브 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="d974a0fa34d0efebf1481353e01453259f737f6f" translate="yes" xml:space="preserve">
          <source>A bound callable reference to a constructor of an &lt;a href=&quot;nested-classes#inner-classes&quot;&gt;&lt;em&gt;inner&lt;/em&gt; class&lt;/a&gt; can be obtained by providing an instance of the outer class:</source>
          <target state="translated">외부 클래스의 인스턴스를 제공하면 &lt;a href=&quot;nested-classes#inner-classes&quot;&gt;&lt;em&gt;내부&lt;/em&gt; 클래스&lt;/a&gt; 의 생성자에 대한 바운드 호출 가능 참조를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7d449e106c2dd01f7bad1cb9f1a3185c3df00be" translate="yes" xml:space="preserve">
          <source>A bound callable reference to a member of &lt;code&gt;this&lt;/code&gt; can now be written without explicit receiver, &lt;code&gt;::foo&lt;/code&gt; instead of &lt;code&gt;this::foo&lt;/code&gt;. This also makes callable references more convenient to use in lambdas where you refer to a member of the outer receiver.</source>
          <target state="translated">회원에 대한 바인딩 호출 기준 &lt;code&gt;this&lt;/code&gt; 지금은 명시 적 수신기없이 쓸 수있다 &lt;code&gt;::foo&lt;/code&gt; 대신 &lt;code&gt;this::foo&lt;/code&gt; . 또한 외부 수신기의 멤버를 참조하는 람다에서 호출 가능 참조를보다 편리하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af54ed951dc6c0df7451d7934b4ee5900cc312ff" translate="yes" xml:space="preserve">
          <source>A class and some of its members may be declared &lt;em&gt;abstract&lt;/em&gt;. An abstract member does not have an implementation in its class. Note that we do not need to annotate an abstract class or function with open &amp;ndash; it goes without saying.</source>
          <target state="translated">클래스와 그 멤버 중 일부는 &lt;em&gt;abstract&lt;/em&gt; 로 선언 될 수 있습니다 . 추상 멤버는 해당 클래스에 구현이 없습니다. 우리는 추상 클래스 나 함수를 open으로 주석을 달 필요가 없습니다. 그것은 말할 것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d916b17d56fbffcf5346b00e40154040ae10b2d" translate="yes" xml:space="preserve">
          <source>A class in Kotlin can have a &lt;strong&gt;primary constructor&lt;/strong&gt; and one or more &lt;strong&gt;secondary constructors&lt;/strong&gt;. The primary constructor is part of the class header: it goes after the class name (and optional type parameters).</source>
          <target state="translated">Kotlin의 클래스에는 &lt;strong&gt;기본 생성자&lt;/strong&gt; 와 하나 이상의 &lt;strong&gt;보조 생성자가있을 수&lt;/strong&gt; 있습니다. 기본 생성자는 클래스 헤더의 일부입니다. 클래스 이름 (및 선택적 유형 매개 변수) 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="2581bdce7795bc5c7972f832dbccf073db572d51" translate="yes" xml:space="preserve">
          <source>A class may be marked as &lt;em&gt;inner&lt;/em&gt; to be able to access members of outer class. Inner classes carry a reference to an object of an outer class:</source>
          <target state="translated">클래스는 외부 클래스의 멤버에 액세스 할 수 있도록 &lt;em&gt;내부&lt;/em&gt; 로 표시 될 수 있습니다 . 내부 클래스에는 외부 클래스의 객체에 대한 참조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d226d1baad9cba3a94880cd52b6b81a790b2eb" translate="yes" xml:space="preserve">
          <source>A class or object can implement one or more interfaces</source>
          <target state="translated">클래스 또는 객체는 하나 이상의 인터페이스를 구현할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6255cfd7b0db95e252bcab8e422391b787945fb5" translate="yes" xml:space="preserve">
          <source>A classifier is either a class or a type parameter.</source>
          <target state="translated">분류기는 클래스 또는 유형 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="143cccd856d38d332ea2321a224af138247f001f" translate="yes" xml:space="preserve">
          <source>A collection of groups matched by the regular expression.</source>
          <target state="translated">정규식과 일치하는 그룹 모음입니다.</target>
        </trans-unit>
        <trans-unit id="eee2f18e3c71ecff01d92bb485de071476c1514d" translate="yes" xml:space="preserve">
          <source>A collection of random and frequently used idioms in Kotlin. If you have a favorite idiom, contribute it by sending a pull request.</source>
          <target state="translated">코 틀린에서 자주 사용되는 임의의 관용구 모음. 당신이 좋아하는 관용구가있는 경우, 풀 요청을 보내 그것을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="511cb0e51ab5e85b5eb1e5d405f7b137a592f5ca" translate="yes" xml:space="preserve">
          <source>A collection that holds pairs of objects (keys and values) and supports efficiently retrieving the value corresponding to each key. Map keys are unique; the map holds only one value for each key. Methods in this interface support only read-only access to the map; read-write access is supported through the &lt;a href=&quot;-mutable-map/index#kotlin.collections.MutableMap&quot;&gt;MutableMap&lt;/a&gt; interface.</source>
          <target state="translated">객체 쌍 (키 및 값)을 보유하고 각 키에 해당하는 값을 효율적으로 검색하도록 지원하는 컬렉션입니다. 맵 키는 고유합니다. 지도는 각 키에 대해 하나의 값만 보유합니다. 이 인터페이스의 메소드는 맵에 대한 읽기 전용 액세스 만 지원합니다. 읽기 / 쓰기 액세스는 &lt;a href=&quot;-mutable-map/index#kotlin.collections.MutableMap&quot;&gt;MutableMap&lt;/a&gt; 인터페이스를 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="01996685e742dc461c512df4e58874c924c73fb3" translate="yes" xml:space="preserve">
          <source>A collection that holds pairs of objects (keys and values) and supports efficiently retrieving the value corresponding to each key. Map keys are unique; the map holds only one value for each key. Methods in this interface support only read-only access to the map; read-write access is supported through the &lt;a href=&quot;../-mutable-map/index#kotlin.collections.MutableMap&quot;&gt;MutableMap&lt;/a&gt; interface.</source>
          <target state="translated">객체 쌍 (키 및 값)을 보유하고 각 키에 해당하는 값을 효율적으로 검색하도록 지원하는 컬렉션입니다. 맵 키는 고유합니다. 지도는 각 키에 대해 하나의 값만 보유합니다. 이 인터페이스의 메소드는 맵에 대한 읽기 전용 액세스 만 지원합니다. 읽기 / 쓰기 액세스는 &lt;a href=&quot;../-mutable-map/index#kotlin.collections.MutableMap&quot;&gt;MutableMap&lt;/a&gt; 인터페이스를 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="f85d7c05c3d6347785429ac7de5ac5f08bf6df2c" translate="yes" xml:space="preserve">
          <source>A collection that holds pairs of objects (keys and values) and supports efficiently retrieving the value corresponding to each key. Map keys are unique; the map holds only one value for each key. Methods in this interface support only read-only access to the map; read-write access is supported through the &lt;a href=&quot;../../kotlin.collections/-mutable-map/index#kotlin.collections.MutableMap&quot;&gt;MutableMap&lt;/a&gt; interface.</source>
          <target state="translated">객체 쌍 (키 및 값)을 보유하고 각 키에 해당하는 값을 효율적으로 검색하도록 지원하는 컬렉션입니다. 맵 키는 고유합니다. 지도는 각 키에 대해 하나의 값만 보유합니다. 이 인터페이스의 메소드는 맵에 대한 읽기 전용 액세스 만 지원합니다. 읽기 / 쓰기 액세스는 &lt;a href=&quot;../../kotlin.collections/-mutable-map/index#kotlin.collections.MutableMap&quot;&gt;MutableMap&lt;/a&gt; 인터페이스를 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c69b205e4aa0cebe9a9490cfb22f55fa6f540821" translate="yes" xml:space="preserve">
          <source>A collection usually contains a number of objects (this number may also be zero) of the same type. Objects in a collection are called &lt;em&gt;elements&lt;/em&gt; or &lt;em&gt;items&lt;/em&gt;. For example, all the students in a department form a collection that can be used to calculate their average age. The following collection types are relevant for Kotlin:</source>
          <target state="translated">컬렉션에는 일반적으로 같은 유형의 여러 개체 (이 숫자는 0 일 수도 있음)가 포함됩니다. 컬렉션의 개체를 &lt;em&gt;요소&lt;/em&gt; 또는 &lt;em&gt;항목&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 예를 들어, 부서의 모든 학생들은 평균 연령을 계산하는 데 사용할 수있는 모음을 구성합니다. Kotlin과 관련된 컬렉션 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="175c59b19f03ab5d1567024326bde1676fafedb1" translate="yes" xml:space="preserve">
          <source>A companion object is initialized when the class is loaded (typically the first time it's referenced by other code that is being executed), in a thread-safe manner. You can omit the name, in which case the name defaults to &lt;code&gt;Companion&lt;/code&gt;. A class can only have one companion object, and companion objects can not be nested.</source>
          <target state="translated">컴패니언 객체는 클래스가로드 될 때 (일반적으로 실행중인 다른 코드에서 처음 참조 할 때) 스레드로부터 안전한 방식으로 초기화됩니다. 이름을 생략 할 수 있으며이 경우 이름의 기본값은 &lt;code&gt;Companion&lt;/code&gt; 입니다. 클래스는 하나의 컴패니언 객체 만 가질 수 있으며 컴패니언 객체는 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43e56b8e00aa559396d1d511bf9a35cc2360f667" translate="yes" xml:space="preserve">
          <source>A compilation can interact with several native libraries. Interoperability with each of them can be configured in the &lt;code&gt;cinterops&lt;/code&gt; block of the compilation:</source>
          <target state="translated">컴파일은 여러 기본 라이브러리와 상호 작용할 수 있습니다. 각각의 상호 운용성 은 컴파일 의 &lt;code&gt;cinterops&lt;/code&gt; 블록 에서 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6495f45d3fda071f57e947dd220c2660ee90f5d" translate="yes" xml:space="preserve">
          <source>A constant holding the &quot;not a number&quot; value of Double.</source>
          <target state="translated">&quot;숫자가 아님&quot;값을 Double로 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="30692a914f3e7f3ae14fe112947452531613b0bd" translate="yes" xml:space="preserve">
          <source>A constant holding the &quot;not a number&quot; value of Float.</source>
          <target state="translated">Float의 &quot;숫자가 아님&quot;값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="eb6d02a80c28dde3d1c7927befecdfe1f558438e" translate="yes" xml:space="preserve">
          <source>A constant holding the largest positive finite value of Double.</source>
          <target state="translated">최대 양의 유한 유한 값 Double을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="2989475e6cbce89ab970feadcd9e679867516672" translate="yes" xml:space="preserve">
          <source>A constant holding the largest positive finite value of Float.</source>
          <target state="translated">Float의 양수 유한 최대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="9deb57dbacb37ea84980557ec3676888a4dd8cd7" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of Byte can have.</source>
          <target state="translated">Byte 인스턴스가 가질 수있는 최대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="e9237724f82c02a362d8804f1d73d8111b1e5de4" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of Int can have.</source>
          <target state="translated">Int 인스턴스가 가질 수있는 최대 값을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="880d96fa44a753baecc4838563508808066ea7c7" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of Long can have.</source>
          <target state="translated">Long 인스턴스가 가질 수있는 최대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="6a5ae584582a42ae1892a5735c2c49965bffbc8c" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of Short can have.</source>
          <target state="translated">Short 인스턴스가 가질 수있는 최대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="89c142885f7633d7c3f1e70f3b5624b1ce064ec8" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of UByte can have.</source>
          <target state="translated">UByte 인스턴스가 가질 수있는 최대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="eaa523f900a184b2b64e09c8a0475f7fa4930003" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of UInt can have.</source>
          <target state="translated">UInt 인스턴스가 가질 수있는 최대 값을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="9692fe911e65777a2c7cfd9a9e8400f4bc8ea057" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of ULong can have.</source>
          <target state="translated">ULong 인스턴스가 가질 수있는 최대 값을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="9bebce3b30412feff7d8abce8c3364be5cc0cdbb" translate="yes" xml:space="preserve">
          <source>A constant holding the maximum value an instance of UShort can have.</source>
          <target state="translated">UShort 인스턴스가 가질 수있는 최대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="bee42d0098fafd184e2e83397f1d2a513cb2d77e" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of Byte can have.</source>
          <target state="translated">Byte 인스턴스가 가질 수있는 최소값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="d58d9f259e307998f48730c6b7fbe854067f6bfd" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of Int can have.</source>
          <target state="translated">Int 인스턴스가 가질 수있는 최소값을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="c6e578e54d55eab5518b163f87c31c1201e72d84" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of Long can have.</source>
          <target state="translated">Long 인스턴스가 가질 수있는 최소값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="868ab3bc40bc62a822c10b5833cc89e85a51628a" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of Short can have.</source>
          <target state="translated">Short 인스턴스가 가질 수있는 최소값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="ccf44b38400048d909e04005a6fd563ac0bb50fd" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of UByte can have.</source>
          <target state="translated">UByte 인스턴스가 가질 수있는 최소값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="4a3b6e9f1701d7413715273c33ae58e20aab5bf6" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of UInt can have.</source>
          <target state="translated">UInt 인스턴스가 가질 수있는 최소값을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="3d6d20e63abee79a15d65601c3502054a1bbe849" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of ULong can have.</source>
          <target state="translated">ULong 인스턴스가 가질 수있는 최소값을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="c1175037c9a4f35c03e808e0f86cd92e217f15b6" translate="yes" xml:space="preserve">
          <source>A constant holding the minimum value an instance of UShort can have.</source>
          <target state="translated">UShort 인스턴스가 가질 수있는 최소값을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="8544ed9c53cc314b5929a7e498f12172f1de72c6" translate="yes" xml:space="preserve">
          <source>A constant holding the negative infinity value of Double.</source>
          <target state="translated">음의 무한대 값 Double을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="b5a021a6628a66324280168a3ef6aeab4793ae7a" translate="yes" xml:space="preserve">
          <source>A constant holding the negative infinity value of Float.</source>
          <target state="translated">Float의 음의 무한대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="dc990a7b75c1fc62fc79ffba1be1662475beb71c" translate="yes" xml:space="preserve">
          <source>A constant holding the positive infinity value of Double.</source>
          <target state="translated">양의 무한대 값 Double을 유지하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="5a802ddd44d12a1f97ea67dc5856ed6b496d2f0c" translate="yes" xml:space="preserve">
          <source>A constant holding the positive infinity value of Float.</source>
          <target state="translated">Float의 양의 무한대 값을 보유하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="fa8e069cbd16134923ae756d8c767a97045aa38a" translate="yes" xml:space="preserve">
          <source>A constant holding the smallest &lt;em&gt;positive&lt;/em&gt; nonzero value of Double.</source>
          <target state="translated">0이 아닌 작은 &lt;em&gt;양&lt;/em&gt; 의 Double 값을 유지하는 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="4b47db568bf42f4dfe288f9b3dc0feeaa0783de2" translate="yes" xml:space="preserve">
          <source>A constant holding the smallest &lt;em&gt;positive&lt;/em&gt; nonzero value of Float.</source>
          <target state="translated">0 보다 작은 &lt;em&gt;양&lt;/em&gt; 의 Float 값을 유지하는 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="926498e55ee5fc08eae4bd245e2c4e41ede1cc0d" translate="yes" xml:space="preserve">
          <source>A constructor can also have a visibility modifier. If you want to place one on the primary constructor (which you might want to do if you have a number of secondary constructors which all invoke a complicated primary constructor that you don't want to expose), you need to include the &lt;code&gt;constructor&lt;/code&gt; keyword: &lt;code&gt;class Person private constructor(val name: String)&lt;/code&gt;.</source>
          <target state="translated">생성자는 또한 가시성 수정자를 가질 수 있습니다. 기본 생성자에 배치하려는 경우 (복수하지 않으려는 복잡한 기본 생성자를 모두 호출하는 여러 개의 보조 생성자가있는 경우 수행하려는 경우) &lt;code&gt;constructor&lt;/code&gt; 키워드 를 포함해야 합니다. &lt;code&gt;class Person private constructor(val name: String)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d9df8683540fa7fd7e8194d96b7bd3db3b911b3" translate="yes" xml:space="preserve">
          <source>A contravariant type parameter may be used in the converse situations. It is left as an exercise to the reader to figure out the justifications for why these member signatures are legal:</source>
          <target state="translated">컨버스 변형 타입 파라미터는 컨버스 상황에서 사용될 수있다. 이러한 회원 서명이 합법적 인 이유에 대한 정당성을 파악하는 것은 독자의 연습으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="5670eaf9dbc46e20b3dd5b3918e420cebd73b580" translate="yes" xml:space="preserve">
          <source>A coroutine is effectively a light-weight thread that can be suspended and resumed later. Coroutines are supported through &lt;a href=&quot;coroutines-overview#suspending-functions&quot;&gt;&lt;em&gt;suspending functions&lt;/em&gt;&lt;/a&gt;: a call to such a function can potentially suspend a coroutine, and to start a new coroutine we usually use an anonymous suspending functions (i.e. suspending lambdas).</source>
          <target state="translated">코 루틴은 사실상 가벼운 나사산으로 나중에 중단하고 재개 할 수 있습니다. 코 루틴은 &lt;a href=&quot;coroutines-overview#suspending-functions&quot;&gt;&lt;em&gt;일시 중단 함수를&lt;/em&gt;&lt;/a&gt; 통해 지원됩니다 . 이러한 &lt;em&gt;함수에&lt;/em&gt; 대한 호출은 잠재적으로 코 루틴을 일시 중단 할 수 있으며 새 코 루틴을 시작하기 위해 일반적으로 익명 일시 중단 기능 (즉, 람다 일시 중단)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d4d17e0e3b6993ba4a64e4ec4230c5601c955d22" translate="yes" xml:space="preserve">
          <source>A couple of important points:</source>
          <target state="translated">중요한 몇 가지 사항 :</target>
        </trans-unit>
        <trans-unit id="45f64193144cbc554e0a38cc5c4c77bcd8e4a9af" translate="yes" xml:space="preserve">
          <source>A dependency on a Kotlin module like &lt;code&gt;kotlin-stdlib&lt;/code&gt; or &lt;code&gt;kotlin-reflect&lt;/code&gt; may be added with the notation &lt;code&gt;kotlin(&quot;stdlib&quot;)&lt;/code&gt;, which is a shorthand for &lt;code&gt;&quot;org.jetbrains.kotlin:kotlin-stdlib&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kotlin-stdlib&lt;/code&gt; 또는 &lt;code&gt;kotlin-reflect&lt;/code&gt; 와 같은 Kotlin 모듈에 대한 종속성 은 &lt;code&gt;&quot;org.jetbrains.kotlin:kotlin-stdlib&quot;&lt;/code&gt; 의 약어 인 &lt;code&gt;kotlin(&quot;stdlib&quot;)&lt;/code&gt; 표기법으로 추가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91b101275ae9e945ac8ffc8ad58a3c8e8fca496a" translate="yes" xml:space="preserve">
          <source>A deprecated API element is not recommended to use, typically because it's being phased out or a better alternative exists.</source>
          <target state="translated">더 이상 사용되지 않는 API 요소는 사용하지 않는 것이 좋습니다. 일반적으로 단계적으로 중단되었거나 더 나은 대안이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2e3e3a4dd2b277b86435f56d946bc991f64c9d8c" translate="yes" xml:space="preserve">
          <source>A destructuring declaration is compiled down to the following code:</source>
          <target state="translated">파괴 선언은 다음 코드로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ea0dc6a70400cbd441b35a9a471ecf74e22467" translate="yes" xml:space="preserve">
          <source>A discriminated union that encapsulates successful outcome with a value of type &lt;a href=&quot;-result/index#T&quot;&gt;T&lt;/a&gt; or a failure with an arbitrary &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception.</source>
          <target state="translated">&lt;a href=&quot;-result/index#T&quot;&gt;T&lt;/a&gt; 유형의 값으로 성공적인 결과를 캡슐화 하거나 임의의 &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외로 실패를 식별하는 구별 된 공용체 .</target>
        </trans-unit>
        <trans-unit id="8b7b95d370a1a806d2326971406b36261b873df9" translate="yes" xml:space="preserve">
          <source>A discriminated union that encapsulates successful outcome with a value of type &lt;a href=&quot;../-result/index#T&quot;&gt;T&lt;/a&gt; or a failure with an arbitrary &lt;a href=&quot;../-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception.</source>
          <target state="translated">&lt;a href=&quot;../-result/index#T&quot;&gt;T&lt;/a&gt; 유형의 값으로 성공적인 결과를 캡슐화 하거나 임의의 &lt;a href=&quot;../-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외로 실패를 식별하는 구별 된 공용체 .</target>
        </trans-unit>
        <trans-unit id="b814b7664581cb8b41c4524734427f1204119e25" translate="yes" xml:space="preserve">
          <source>A discriminated union that encapsulates successful outcome with a value of type &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt; or a failure with an arbitrary &lt;a href=&quot;../-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception.</source>
          <target state="translated">&lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt; 유형의 값으로 성공적인 결과를 캡슐화 하거나 임의의 &lt;a href=&quot;../-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외로 실패를 식별하는 구별 된 공용체 .</target>
        </trans-unit>
        <trans-unit id="885ace999309d3ae610756b592848e6502039c1c" translate="yes" xml:space="preserve">
          <source>A dynamic call always returns &lt;code&gt;dynamic&lt;/code&gt; as a result, so we can chain such calls freely:</source>
          <target state="translated">동적 호출은 항상 &lt;code&gt;dynamic&lt;/code&gt; 으로 결과를 반환 하므로 이러한 호출을 자유롭게 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="151037307ae97fa4bf6e5eff252ac79d71442a79" translate="yes" xml:space="preserve">
          <source>A familiar error pops up:</source>
          <target state="translated">익숙한 오류가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="70a9d9b5433551b91cd818143cf29e9791b6c4f1" translate="yes" xml:space="preserve">
          <source>A few things are going on in this file, let's go through them one by one. The first entry is &lt;code&gt;headers&lt;/code&gt; which is the list of header files that we want to generate Kotlin stubs for. We can add multiple files to this entry, separating each one with a &lt;code&gt;\&lt;/code&gt; on a new line. In our case we only want &lt;code&gt;curl.h&lt;/code&gt;. The files we are referencing need to be relative to the folder where the definition file is, or be available on the system path (in our case it would be &lt;code&gt;/usr/include/curl&lt;/code&gt;).</source>
          <target state="translated">이 파일에서 몇 가지 일이 진행되고 있습니다. 하나씩 살펴 보겠습니다. 첫 번째 항목은 Kotlin 스텁을 생성하려는 헤더 파일 목록 인 &lt;code&gt;headers&lt;/code&gt; 입니다. 이 항목에 여러 파일을 추가하여 각 파일을 새 줄에 &lt;code&gt;\&lt;/code&gt; 로 구분할 수 있습니다 . 우리의 경우 &lt;code&gt;curl.h&lt;/code&gt; 만 원합니다 . 우리가 참조하는 파일은 정의 파일이있는 폴더에 상대적이거나 시스템 경로에서 사용 가능해야합니다 (이 경우 &lt;code&gt;/usr/include/curl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="510af740ade381ab5a1d2be5727f07ffe4d836f3" translate="yes" xml:space="preserve">
          <source>A full example that shows how to integrate Kotlin with DCE and webpack to get a small bundle, can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/js-dce&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Kotlin을 DCE 및 웹팩과 통합하여 작은 번들을 얻는 방법을 보여주는 전체 예제는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/js-dce&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29b239dcdbc1ff83c7abe8c86bbc963f9e130fe3" translate="yes" xml:space="preserve">
          <source>A function can take an arbitrary number of arguments, similarly to &lt;code&gt;*args&lt;/code&gt; in Python, but they must all be of the same type. Unlike Python, you may declare other positional parameters after the variadic one, but there can be at most one variadic parameter. If its type is &lt;code&gt;X&lt;/code&gt;, the type of the argument will be &lt;code&gt;XArray&lt;/code&gt; if &lt;code&gt;X&lt;/code&gt; is a primitive type and &lt;code&gt;Array&amp;lt;X&amp;gt;&lt;/code&gt; if not.</source>
          <target state="translated">함수는 파이썬의 &lt;code&gt;*args&lt;/code&gt; 와 마찬가지로 임의의 수의 인수를 취할 수 있지만 모두 같은 유형이어야합니다. 파이썬과는 달리, 가변성 변수 뒤에 다른 위치 매개 변수를 선언 할 수 있지만 가변성 변수는 최대 하나만있을 수 있습니다. 유형이 &lt;code&gt;X&lt;/code&gt; 인 경우 인수 유형은 &lt;code&gt;X&lt;/code&gt; 가 기본 유형 인 경우 &lt;code&gt;XArray&lt;/code&gt; 이고 그렇지 않은 경우 &lt;code&gt;Array&amp;lt;X&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b72bc5ee521f65f909bfc29c7a45a7202b738a5" translate="yes" xml:space="preserve">
          <source>A function declared inside a class is called a &lt;em&gt;member function&lt;/em&gt; of that class. Like in Python, every invocation of a member function must be performed on an instance of the class, and the instance will be available during the execution of the function - but unlike Python, the function signature doesn't declare that: there is no explicit &lt;code&gt;self&lt;/code&gt; parameter. Instead, every member function can use the keyword &lt;code&gt;this&lt;/code&gt; to reference the current instance, without declaring it. Unlike Python, as long as there is no name conflict with an identically-named parameter or local variable, &lt;code&gt;this&lt;/code&gt; can be omitted. If we do this inside a &lt;code&gt;Person&lt;/code&gt; class with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">클래스 안에서 선언 된 &lt;em&gt;함수&lt;/em&gt; 를 해당 클래스 의 &lt;em&gt;멤버 함수&lt;/em&gt; 라고합니다 . 파이썬과 마찬가지로 멤버 함수의 모든 호출은 클래스의 인스턴스에서 수행되어야하며 함수 실행 중에 인스턴스를 사용할 수 있습니다. 그러나 파이썬과 달리 함수 서명은 다음을 선언하지 않습니다. &lt;code&gt;self&lt;/code&gt; 매개 변수. 대신 모든 멤버 함수는 &lt;code&gt;this&lt;/code&gt; 키워드를 사용하여 선언하지 않고 현재 인스턴스를 참조 할 수 있습니다 . Python과 달리 이름이 동일한 매개 변수 또는 로컬 변수와 이름이 충돌하지 않는 &lt;code&gt;this&lt;/code&gt; 를 생략 할 수 있습니다. &lt;code&gt;name&lt;/code&gt; 속성 이있는 &lt;code&gt;Person&lt;/code&gt; 클래스 내에서이 작업을 수행하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1f3fb42e5f8df4a5f2decbeb129c38ad34d7032e" translate="yes" xml:space="preserve">
          <source>A function declaring the &lt;code&gt;callsInPlace&lt;/code&gt; effect must be &lt;em&gt;inline&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;callsInPlace&lt;/code&gt; 효과를 선언하는 함수 는 &lt;em&gt;인라인&lt;/em&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e4ec01c31a9366c1d3314f2cb2ad451913ce370" translate="yes" xml:space="preserve">
          <source>A function is said to call its functional parameter in place, if the functional parameter is only invoked while the execution has not been returned from the function, and the functional parameter cannot be invoked after the function is completed.</source>
          <target state="translated">함수에서 실행이 리턴되지 않은 동안 함수 매개 변수 만 호출되고 함수가 완료된 후에 함수 매개 변수를 호출 할 수없는 경우 함수는 해당 함수 매개 변수를 제 위치에서 호출한다고합니다.</target>
        </trans-unit>
        <trans-unit id="04a060e0c95f4ebd4ecee46f2d26f3e43540876c" translate="yes" xml:space="preserve">
          <source>A function literal with receiver is perhaps easiest to think of as an extension function in the form of a lambda expression. The declaration looks like an ordinary lambda expression; what makes it take a receiver is the context - it must be passed to a function that takes a function with receiver as a parameter, or assigned to a variable/property whose type is a function type with receiver. The only way to use a function with receiver is to invoke it on an instance of the receiver class, as if it were a member function or extension function. For example:</source>
          <target state="translated">수신자가 포함 된 함수 리터럴은 람다 식 형태의 확장 함수로 생각하기가 가장 쉽습니다. 선언은 일반적인 람다 식처럼 보입니다. 리시버를받는 것은 컨텍스트입니다. 리시버를 매개 변수로 사용하여 함수를받는 함수에 전달되거나 유형이 리시버가있는 함수 유형 인 변수 / 프로퍼티에 지정되어야합니다. 수신자와 함께 함수를 사용하는 유일한 방법은 마치 멤버 함수 또는 확장 함수 인 것처럼 수신자 클래스의 인스턴스에서 함수를 호출하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe8fc5bd10645d91436f9c70cc1976194bd5f890" translate="yes" xml:space="preserve">
          <source>A function parameter is called in place, but it's unknown how many times it can be called.</source>
          <target state="translated">함수 매개 변수가 호출되었지만 호출 할 수있는 횟수는 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0883615027d70df853616a3da883adc37485075c" translate="yes" xml:space="preserve">
          <source>A function parameter will be invoked exactly one time.</source>
          <target state="translated">함수 매개 변수는 정확히 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d39d6c5be7243d66cadcac831bd6f10f533753" translate="yes" xml:space="preserve">
          <source>A function parameter will be invoked one or more times.</source>
          <target state="translated">함수 매개 변수가 한 번 이상 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="237b19a01d8b8d078f93e56a90a19c09f844bdf8" translate="yes" xml:space="preserve">
          <source>A function parameter will be invoked one time or not invoked at all.</source>
          <target state="translated">함수 매개 변수는 한 번만 호출되거나 전혀 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f00b34f2663621671200463d2cac2aa55d7e97c" translate="yes" xml:space="preserve">
          <source>A generic collection of elements that supports adding and removing elements.</source>
          <target state="translated">요소 추가 및 제거를 지원하는 일반적인 요소 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="bbff83bb702ed0f6941e7ca039bc7bd867359b5a" translate="yes" xml:space="preserve">
          <source>A generic collection of elements. Methods in this interface support only read-only access to the collection; read/write access is supported through the &lt;a href=&quot;-mutable-collection/index#kotlin.collections.MutableCollection&quot;&gt;MutableCollection&lt;/a&gt; interface.</source>
          <target state="translated">일반적인 요소 모음. 이 인터페이스의 메소드는 콜렉션에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;-mutable-collection/index#kotlin.collections.MutableCollection&quot;&gt;MutableCollection&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="abea4bf71869abd4b455f4e16c8397c530a81f82" translate="yes" xml:space="preserve">
          <source>A generic collection of elements. Methods in this interface support only read-only access to the collection; read/write access is supported through the &lt;a href=&quot;../-mutable-collection/index#kotlin.collections.MutableCollection&quot;&gt;MutableCollection&lt;/a&gt; interface.</source>
          <target state="translated">일반적인 요소 모음. 이 인터페이스의 메소드는 콜렉션에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;../-mutable-collection/index#kotlin.collections.MutableCollection&quot;&gt;MutableCollection&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="b98a2fbb590152dca20ad79daa75978b2eac2dda" translate="yes" xml:space="preserve">
          <source>A generic collection of elements. Methods in this interface support only read-only access to the collection; read/write access is supported through the &lt;a href=&quot;../../kotlin.collections/-mutable-collection/index#kotlin.collections.MutableCollection&quot;&gt;MutableCollection&lt;/a&gt; interface.</source>
          <target state="translated">일반적인 요소 모음. 이 인터페이스의 메소드는 콜렉션에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;../../kotlin.collections/-mutable-collection/index#kotlin.collections.MutableCollection&quot;&gt;MutableCollection&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c38f7e29efee3c4f7385c8652c0172ab8569bbc" translate="yes" xml:space="preserve">
          <source>A generic ordered collection of elements that supports adding and removing elements.</source>
          <target state="translated">요소 추가 및 제거를 지원하는 일반적인 순서의 요소 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="1f1affddde96d31df4551f7de92ce93f45561b90" translate="yes" xml:space="preserve">
          <source>A generic ordered collection of elements. Methods in this interface support only read-only access to the list; read/write access is supported through the &lt;a href=&quot;-mutable-list/index#kotlin.collections.MutableList&quot;&gt;MutableList&lt;/a&gt; interface.</source>
          <target state="translated">일반적인 순서로 정렬 된 요소 모음. 이 인터페이스의 메소드는 목록에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;-mutable-list/index#kotlin.collections.MutableList&quot;&gt;MutableList&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="dea2909eb1d1d0572168e9616d0bc2df8d12c27b" translate="yes" xml:space="preserve">
          <source>A generic ordered collection of elements. Methods in this interface support only read-only access to the list; read/write access is supported through the &lt;a href=&quot;../-mutable-list/index#kotlin.collections.MutableList&quot;&gt;MutableList&lt;/a&gt; interface.</source>
          <target state="translated">일반적인 순서로 정렬 된 요소 모음. 이 인터페이스의 메소드는 목록에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;../-mutable-list/index#kotlin.collections.MutableList&quot;&gt;MutableList&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="69b1b083bbdcd6a394a2a7149f189640c381fc48" translate="yes" xml:space="preserve">
          <source>A generic ordered collection of elements. Methods in this interface support only read-only access to the list; read/write access is supported through the &lt;a href=&quot;../../kotlin.collections/-mutable-list/index#kotlin.collections.MutableList&quot;&gt;MutableList&lt;/a&gt; interface.</source>
          <target state="translated">일반적인 순서로 정렬 된 요소 모음. 이 인터페이스의 메소드는 목록에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;../../kotlin.collections/-mutable-list/index#kotlin.collections.MutableList&quot;&gt;MutableList&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd7063c4dd2c9689622f1ed7af757167d730223a" translate="yes" xml:space="preserve">
          <source>A generic unordered collection of elements that does not support duplicate elements, and supports adding and removing elements.</source>
          <target state="translated">중복 요소를 지원하지 않으며 요소 추가 및 제거를 지원하는 순서가없는 일반적인 요소 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="9c0cd9b3c1101fe42ec4c546da093b3561f35c0a" translate="yes" xml:space="preserve">
          <source>A generic unordered collection of elements that does not support duplicate elements. Methods in this interface support only read-only access to the set; read/write access is supported through the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface.</source>
          <target state="translated">중복 요소를 지원하지 않는 일반적인 순서가없는 요소 컬렉션입니다. 이 인터페이스의 메소드는 세트에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="402b36a678feb8f00e85eafd3effc930783d66d2" translate="yes" xml:space="preserve">
          <source>A generic unordered collection of elements that does not support duplicate elements. Methods in this interface support only read-only access to the set; read/write access is supported through the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface.</source>
          <target state="translated">중복 요소를 지원하지 않는 일반적인 순서가없는 요소 컬렉션입니다. 이 인터페이스의 메소드는 세트에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddbe26555159afcb7715383695a1b59ee8ccd31a" translate="yes" xml:space="preserve">
          <source>A generic unordered collection of elements that does not support duplicate elements. Methods in this interface support only read-only access to the set; read/write access is supported through the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface.</source>
          <target state="translated">중복 요소를 지원하지 않는 일반적인 순서가없는 요소 컬렉션입니다. 이 인터페이스의 메소드는 세트에 대한 읽기 전용 액세스 만 지원합니다. &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스를 통해 읽기 / 쓰기 액세스가 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce031fbd15cb09965c1695fb87cf32609c4660bd" translate="yes" xml:space="preserve">
          <source>A getter method, with the name calculated by prepending the &lt;code&gt;get&lt;/code&gt; prefix;</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 접두사 를 앞에 추가하여 이름을 계산 한 getter 메소드 .</target>
        </trans-unit>
        <trans-unit id="845d21e4688c200dd8d79ba0f6fcce97e344c534" translate="yes" xml:space="preserve">
          <source>A good example is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;functional programming idiom &lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; for collections, which takes an initial accumulator value and a combining function and builds its return value by consecutively combining current accumulator value with each collection element, replacing the accumulator:</source>
          <target state="translated">좋은 예는이다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fold_(higher-order_function)&quot;&gt;관용구 함수형 프로그래밍 &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 초기 누산기 값과 함께 기능을 취하여 연속 어큐뮬레이터 교체 각 컬렉션 원소 전류 누산기 값을 조합하여 리턴 값을 기반으로 수집 들어 :</target>
        </trans-unit>
        <trans-unit id="6ff9f7dc904e80d0113b7f5b369e86536cb5fc57" translate="yes" xml:space="preserve">
          <source>A good example of such a requirement is a UI component with the job defined in its scope. If any of the UI's child tasks have failed, it is not always necessary to cancel (effectively kill) the whole UI component, but if UI component is destroyed (and its job is cancelled), then it is necessary to fail all child jobs as their results are no longer required.</source>
          <target state="translated">이러한 요구 사항의 좋은 예는 해당 범위에 작업이 정의 된 UI 구성 요소입니다. UI의 하위 작업 중 하나라도 실패한 경우 항상 전체 UI 구성 요소를 취소 (효과적으로 종료) 할 필요는 없지만 UI 구성 요소가 손상되고 작업이 취소 된 경우 모든 하위 작업을 다음과 같이 실패해야합니다. 그들의 결과는 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b906d5c24dc71d701d1a88f5123b99a35b02e657" translate="yes" xml:space="preserve">
          <source>A great resource to study Kotlin syntax and API of the Kotlin standard library are &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">Kotlin 표준 라이브러리의 Kotlin 구문 및 API를 연구 할 수있는 훌륭한 자료는 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ebfffbfa83d34f87c675110d91e368618c92b537" translate="yes" xml:space="preserve">
          <source>A higher-order function is a function that takes functions as parameters, or returns a function.</source>
          <target state="translated">고차 함수는 함수를 매개 변수로 사용하거나 함수를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="9658b2ff766fe30712bdf6b1320de81dcddb8dd6" translate="yes" xml:space="preserve">
          <source>A key feature of the multiplatform project support is the possibility to express dependencies of common code on platform-specific parts through &lt;strong&gt;expected and actual declarations&lt;/strong&gt;. An expected declaration specifies an API (class, interface, annotation, top-level declaration etc.). An actual declaration is either a platform-dependent implementation of the API or a typealias referring to an existing implementation of the API in an external library. Here's an example:</source>
          <target state="translated">멀티 플랫폼 프로젝트 지원의 주요 특징은 &lt;strong&gt;예상 및 실제 선언을&lt;/strong&gt; 통해 플랫폼 별 부품에 공통 코드의 종속성을 표현할 수 있다는 것 입니다. 예상 선언은 API (클래스, 인터페이스, 주석, 최상위 선언 등)를 지정합니다. 실제 선언은 API의 플랫폼 종속적 구현이거나 외부 라이브러리에서 기존 API 구현을 참조하는 유형입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4f9bcf6317a3efbfc27ffa627ae2315de75f99c" translate="yes" xml:space="preserve">
          <source>A key of this coroutine context element.</source>
          <target state="translated">이 코 루틴 컨텍스트 요소의 키입니다.</target>
        </trans-unit>
        <trans-unit id="a529167efcc4bc503564dbabfc673ed3f8365dca" translate="yes" xml:space="preserve">
          <source>A kind of the metadata this annotation encodes. Kotlin compiler recognizes the following kinds (see KotlinClassHeader.Kind):</source>
          <target state="translated">이 주석이 인코딩하는 메타 데이터의 종류입니다. Kotlin 컴파일러는 다음과 같은 종류를 인식합니다 (KotlinClassHeader.Kind 참조).</target>
        </trans-unit>
        <trans-unit id="af75e92b60e6e9dc75638e6104df4d818cedc25f" translate="yes" xml:space="preserve">
          <source>A lambda expression accepted by the &lt;code&gt;executable&lt;/code&gt; method in the example above is applied to each binary created and allows one to configure the binary (see the &lt;a href=&quot;#configuring-binaries&quot;&gt;corresponding section&lt;/a&gt;). Note that this lambda can be dropped if there is no need for additional configuration:</source>
          <target state="translated">위 예제에서 &lt;code&gt;executable&lt;/code&gt; 메소드가 승인 한 람다 표현식 은 작성된 각 바이너리에 적용되며 바이너리를 구성 할 수 있습니다 ( &lt;a href=&quot;#configuring-binaries&quot;&gt;해당 섹션 참조&lt;/a&gt; ). 추가 구성이 필요없는 경우이 람다를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e8c41c77e473f5d78a3b8f292109d63deab3c1" translate="yes" xml:space="preserve">
          <source>A lambda expression is always surrounded by curly braces, parameter declarations in the full syntactic form go inside curly braces and have optional type annotations, the body goes after an &lt;code&gt;-&amp;gt;&lt;/code&gt; sign. If the inferred return type of the lambda is not &lt;code&gt;Unit&lt;/code&gt;, the last (or possibly single) expression inside the lambda body is treated as the return value.</source>
          <target state="translated">람다 식은 항상 중괄호로 묶고 전체 구문 형식의 매개 변수 선언은 중괄호 안에 들어가고 선택적 형식 주석이 있으며 본문은 &lt;code&gt;-&amp;gt;&lt;/code&gt; 기호 뒤에옵니다 . 람다의 유추 된 리턴 유형이 &lt;code&gt;Unit&lt;/code&gt; 이 아닌 경우 람다 본문 내부의 마지막 (또는 단일) 표현식이 리턴 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0c65c1cb9c5a403c061be48bf269fbc9618b3e04" translate="yes" xml:space="preserve">
          <source>A lambda expression or anonymous function (as well as a &lt;a href=&quot;functions#local-functions&quot;&gt;local function&lt;/a&gt; and an &lt;a href=&quot;object-declarations#object-expressions&quot;&gt;object expression&lt;/a&gt;) can access its &lt;em&gt;closure&lt;/em&gt;, i.e. the variables declared in the outer scope. Unlike Java, the variables captured in the closure can be modified:</source>
          <target state="translated">람다 식 또는 익명 함수 ( &lt;a href=&quot;functions#local-functions&quot;&gt;로컬 함수&lt;/a&gt; 및 &lt;a href=&quot;object-declarations#object-expressions&quot;&gt;객체 식&lt;/a&gt; )는 해당 &lt;em&gt;클로저&lt;/em&gt; (즉, 외부 범위에 선언 된 변수 )에 액세스 할 수 있습니다 . Java와 달리 클로저에서 캡처 된 변수는 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdff8d608ead4752a4b46042e230ea48bde67d92" translate="yes" xml:space="preserve">
          <source>A language is nothing without its ecosystem, so we pay extra attention to enabling smooth library evolution.</source>
          <target state="translated">생태계가없는 언어는 아무것도 아니므로 매끄러운 라이브러리 진화를 가능하게하는 데 특별한주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="cd15bacdd1c63ecfc6424c14d67180313bd1ad34" translate="yes" xml:space="preserve">
          <source>A library also needs &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt; to be set in the project:</source>
          <target state="translated">라이브러리는 프로젝트에서 &lt;code&gt;group&lt;/code&gt; 및 &lt;code&gt;version&lt;/code&gt; 을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a266d621f1143136ef1332f1d4e8fbf1937bb7bb" translate="yes" xml:space="preserve">
          <source>A library built from a multiplatform project may be published to a Maven repository with the &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;&lt;code&gt;maven-publish&lt;/code&gt; Gradle plugin&lt;/a&gt;, which can be applied as follows:</source>
          <target state="translated">멀티 플랫폼 프로젝트로 빌드 한 라이브러리는 &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt; &lt;code&gt;maven-publish&lt;/code&gt; Gradle 플러그인&lt;/a&gt; 을 사용하여 Maven 저장소에 게시 할 수 있으며 다음과 같이 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b4ed373cde6e9e1fa91e4fbb56a9c7598a75a2e" translate="yes" xml:space="preserve">
          <source>A library can be compiled against the JSR-305 annotations, but there's no need to make the annotations artifact (e.g. &lt;code&gt;jsr305.jar&lt;/code&gt;) a compile dependency for the library consumers. The Kotlin compiler can read the JSR-305 annotations from a library without the annotations present on the classpath.</source>
          <target state="translated">라이브러리는 JSR-305 어노테이션에 대해 컴파일 될 수 있지만 어노테이션 아티팩트 (예 : &lt;code&gt;jsr305.jar&lt;/code&gt; )를 라이브러리 소비자에 대한 컴파일 종속성 으로 만들 필요는 없습니다 . Kotlin 컴파일러는 클래스 경로에 주석이없는 라이브러리에서 JSR-305 주석을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d047b9b14ef599793bf3ec4c60c343db64e1e53d" translate="yes" xml:space="preserve">
          <source>A library maintainer can add &lt;code&gt;@UnderMigration&lt;/code&gt; status to both type qualifier nicknames and type qualifier defaults:</source>
          <target state="translated">라이브러리 관리자는 &lt;code&gt;@UnderMigration&lt;/code&gt; 상태를 유형 한정자 닉네임과 유형 한정자 기본값 모두에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4d698e33a9549340a4259e6c4d88d876edb0aa5" translate="yes" xml:space="preserve">
          <source>A list of additional compiler arguments</source>
          <target state="translated">추가 컴파일러 인수 목록</target>
        </trans-unit>
        <trans-unit id="c050876c45d3b9009b108f91b92dee2ba3ce4a68" translate="yes" xml:space="preserve">
          <source>A list of matched indexed group values.</source>
          <target state="translated">일치하는 인덱싱 된 그룹 값 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0490e17c090278dca9d9c3e9c1918bb3f95d57dc" translate="yes" xml:space="preserve">
          <source>A local value initialised with an expression of a platform type may or may not have a type declaration:</source>
          <target state="translated">플랫폼 유형의 표현식으로 초기화 된 로컬 값은 유형 선언이 있거나 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6082935bdff5b04031f6645a591c4c448c1b83ae" translate="yes" xml:space="preserve">
          <source>A look at how Kotlin compiles to JavaScript and the use cases for that.</source>
          <target state="translated">Kotlin이 JavaScript로 컴파일하는 방법과 그 사용 사례를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="c8130c12d930d04cefb1ed7e38d06b29b5e7dd90" translate="yes" xml:space="preserve">
          <source>A look at how to compile our first Kotlin/Native application and open it in an IDE</source>
          <target state="translated">첫 번째 Kotlin / Native 애플리케이션을 컴파일하고 IDE에서 여는 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="385e8e945a580076e3df659a821033522dacc1b9" translate="yes" xml:space="preserve">
          <source>A look at how to use Gradle to target JavaScript.</source>
          <target state="translated">Gradle을 사용하여 JavaScript를 대상으로하는 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="b89b4fa9c39dacaeb933d4650ccdc12e158979dd" translate="yes" xml:space="preserve">
          <source>A look at how to use IntelliJ IDEA to target JavaScript.</source>
          <target state="translated">IntelliJ IDEA를 사용하여 JavaScript를 대상으로하는 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="71d661a8898d659e1e97814edf5572b07d03e2a4" translate="yes" xml:space="preserve">
          <source>A look at how to use Kotlin to interact with JavaScript modules.</source>
          <target state="translated">Kotlin을 사용하여 JavaScript 모듈과 상호 작용하는 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="8b133e53c4710f53a8e5d137344f6ea855746c46" translate="yes" xml:space="preserve">
          <source>A look at how to use Maven to target JavaScript.</source>
          <target state="translated">Maven을 사용하여 JavaScript를 대상으로하는 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="5fcf68c5e070712c02ef2161e606659b7cf8046b" translate="yes" xml:space="preserve">
          <source>A look at how we can interact with the DOM as well as using JavaScript libraries</source>
          <target state="translated">JavaScript 라이브러리를 사용하고 DOM과 상호 작용할 수있는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="c0d24229bab2798843cb2291cd6e6945e16df6ed" translate="yes" xml:space="preserve">
          <source>A marker annotation can have one of two severity &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/-level/index&quot;&gt;levels&lt;/a&gt; of informing about experimental API usage:</source>
          <target state="translated">마커 주석은 실험적 API 사용에 대한 두 가지 심각도 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/-level/index&quot;&gt;수준&lt;/a&gt; 중 하나 를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b054a659f1507dbdbd8b7a70edae51e942b5d321" translate="yes" xml:space="preserve">
          <source>A member function is a function that is defined inside a class or object:</source>
          <target state="translated">멤버 함수는 클래스 또는 객체 내에 정의 된 함수입니다.</target>
        </trans-unit>
        <trans-unit id="4396cd5eb274f200a93bd95b26249891db5d5bc2" translate="yes" xml:space="preserve">
          <source>A member marked &lt;em&gt;override&lt;/em&gt; is itself open, i.e. it may be overridden in subclasses. If you want to prohibit re-overriding, use &lt;em&gt;final&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;override&lt;/em&gt; 로 표시된 멤버 는 자체적으로 열려 있습니다. 즉, 서브 클래스에서 재정의 될 수 있습니다. 다시 재정의를 금지하려면 &lt;em&gt;final을&lt;/em&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="33c9548e1a279573b42ec97cd1476aab155cc3b4" translate="yes" xml:space="preserve">
          <source>A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving the value corresponding to each key. Map keys are unique; the map holds only one value for each key.</source>
          <target state="translated">객체 쌍 (키 및 값)을 보유하고 각 키에 해당하는 값을 효율적으로 검색하도록 지원하는 수정 가능한 컬렉션입니다. 맵 키는 고유합니다. 지도는 각 키에 대해 하나의 값만 보유합니다.</target>
        </trans-unit>
        <trans-unit id="68902b1d8fd08c328f63d3b0ce175fa7604003a9" translate="yes" xml:space="preserve">
          <source>A more old-fashioned way is using an &lt;em&gt;update site&lt;/em&gt; directly:</source>
          <target state="translated">보다 구식 방법은 &lt;em&gt;업데이트 사이트를&lt;/em&gt; 직접 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="bf066db04d9910e9f11c2b8beb3034ec52a9044a" translate="yes" xml:space="preserve">
          <source>A much larger part of the Kotlin standard library can now be used from code compiled to JavaScript. In particular, key classes such as collections (&lt;code&gt;ArrayList&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt; etc.), exceptions (&lt;code&gt;IllegalArgumentException&lt;/code&gt; etc.) and a few others (&lt;code&gt;StringBuilder&lt;/code&gt;, &lt;code&gt;Comparator&lt;/code&gt;) are now defined under the &lt;code&gt;kotlin&lt;/code&gt; package. On the JVM, the names are type aliases for the corresponding JDK classes, and on the JS, the classes are implemented in the Kotlin standard library.</source>
          <target state="translated">Kotlin 표준 라이브러리의 훨씬 더 큰 부분을 이제 코드를 컴파일하여 JavaScript로 사용할 수 있습니다. 특히 컬렉션 ( &lt;code&gt;ArrayList&lt;/code&gt; , &lt;code&gt;HashMap&lt;/code&gt; 등), 예외 ( &lt;code&gt;IllegalArgumentException&lt;/code&gt; 등) 및 기타 몇 가지 ( &lt;code&gt;StringBuilder&lt;/code&gt; , &lt;code&gt;Comparator&lt;/code&gt; ) 와 같은 주요 클래스 가 &lt;code&gt;kotlin&lt;/code&gt; 패키지에 정의되었습니다 . JVM에서 이름은 해당 JDK 클래스의 유형 별명이며 JS에서는 클래스가 Kotlin 표준 라이브러리에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ee493f380acc0a42b5e890932900078480680011" translate="yes" xml:space="preserve">
          <source>A multiplatform sample library is now created and imported into IntelliJ IDEA. Let's go to any &lt;code&gt;.kt&lt;/code&gt; file and rename the package with the IntelliJ IDEA action &lt;em&gt;Refactor | Rename&lt;/em&gt; action to &lt;code&gt;org.jetbrains.base64&lt;/code&gt; Let's just check everything is right with the project so far, the project structure should be:</source>
          <target state="translated">멀티 플랫폼 샘플 라이브러리가 생성되어 IntelliJ IDEA로 가져옵니다. &lt;code&gt;.kt&lt;/code&gt; 파일 로 이동 하여 IntelliJ IDEA 작업 &lt;em&gt;Refactor | &lt;/em&gt;작업 &lt;em&gt;이름&lt;/em&gt; 을 &lt;code&gt;org.jetbrains.base64&lt;/code&gt; 로&lt;em&gt;바꿉니다.&lt;/em&gt; 지금까지 프로젝트에서 모든 것이 올바른지 확인하자. 프로젝트 구조는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f4b890960e943c6a1f6370a833c10f3876378c32" translate="yes" xml:space="preserve">
          <source>A naive way of translating these functions into Java would be this:</source>
          <target state="translated">이러한 함수를 Java로 변환하는 순진한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a39eaba88421ecc659e557c1c5917daff148999d" translate="yes" xml:space="preserve">
          <source>A new code style adoption might be a very natural process if it starts with a new project, when there's no code formatted in the old way. That is why starting from version 1.3, the Kotlin IntelliJ Plugin creates new projects with formatting from the Code Conventions document which is enabled by default.</source>
          <target state="translated">이전 코드 형식이없는 새 프로젝트로 시작하면 새로운 코드 스타일을 채택하는 것이 매우 자연스러운 과정 일 수 있습니다. 이것이 1.3 버전부터 Kotlin IntelliJ 플러그인이 기본적으로 활성화되어있는 Code Conventions 문서의 형식으로 새 프로젝트를 생성하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="2ed3400a891a08f6fa6f1243321491e235535de8" translate="yes" xml:space="preserve">
          <source>A nice built-in delegated property is &lt;code&gt;lazy&lt;/code&gt;, which is a properly threadsafe implementation of the lazy loading pattern. The supplied lambda expression will only be evaluated once, the first time the property is accessed.</source>
          <target state="translated">내장 된 훌륭한 위임 속성은 &lt;code&gt;lazy&lt;/code&gt; 입니다 . 이것은 게으른 로딩 패턴의 스레드 안전 구현입니다. 제공된 람다 식은 속성에 처음 액세스 할 때 한 번만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="05f9decb296cb438904b90a9f0f8cd0768c68ffb" translate="yes" xml:space="preserve">
          <source>A non-extension function: &lt;strong&gt;the context object&lt;/strong&gt; is passed as an argument, but inside the lambda, it's available as a receiver (&lt;code&gt;this&lt;/code&gt;). &lt;strong&gt;The return value&lt;/strong&gt; is the lambda result.</source>
          <target state="translated">비 확장 함수 : &lt;strong&gt;컨텍스트 객체&lt;/strong&gt; 는 인수로 전달되지만 람다 내부에서는 수신자 ( &lt;code&gt;this&lt;/code&gt; ) 로 사용할 수 있습니다 . &lt;strong&gt;반환 값&lt;/strong&gt; 은 람다 결과입니다.</target>
        </trans-unit>
        <trans-unit id="e9556a99638ca78eba482514fb0afe050f158662" translate="yes" xml:space="preserve">
          <source>A number of packages are imported into every Kotlin file by default:</source>
          <target state="translated">기본적으로 모든 Kotlin 파일로 여러 패키지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0690a89d31ce4555354ff36a78a338d800d8a6a1" translate="yes" xml:space="preserve">
          <source>A pair of an index of the first occurrence of matched string from &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; and the string matched or &lt;code&gt;null&lt;/code&gt; if none of &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; are found.</source>
          <target state="translated">일치하는 문자열에서 처음 나타나는 인덱스 쌍의 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 과 일치하는 문자열 또는 &lt;code&gt;null&lt;/code&gt; 것도 만약 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 발견되지 않는다.</target>
        </trans-unit>
        <trans-unit id="6180f75d77d89f493537446a08bcc4c4a8c04dbd" translate="yes" xml:space="preserve">
          <source>A pair of an index of the last occurrence of matched string from &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; and the string matched or &lt;code&gt;null&lt;/code&gt; if none of &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; are found.</source>
          <target state="translated">유사한 문자열에서 마지막 항목 인덱스 쌍의 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 과 일치하는 문자열 또는 &lt;code&gt;null&lt;/code&gt; 것도 만약 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 발견되지 않는다.</target>
        </trans-unit>
        <trans-unit id="a8c369ae3a10f910466f80e9aeb4feac05933ded" translate="yes" xml:space="preserve">
          <source>A parameter is optional in any of the two cases:</source>
          <target state="translated">두 경우 중 하나에서 매개 변수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d8e54db4b729c3b476717fda903eeba2bbf919bb" translate="yes" xml:space="preserve">
          <source>A parameter of a function (normally the last one) may be marked with &lt;code&gt;vararg&lt;/code&gt; modifier:</source>
          <target state="translated">함수의 매개 변수 (일반적으로 마지막 매개 변수)는 &lt;code&gt;vararg&lt;/code&gt; 수정 자로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b5a662aaf33cd978719d71631ebb23d192f917f" translate="yes" xml:space="preserve">
          <source>A parameterless lambda does not need the arrow. A one-parameter lambda can choose to omit the parameter name and the arrow, in which case the parameter will be called &lt;code&gt;it&lt;/code&gt;:</source>
          <target state="translated">매개 변수가없는 람다는 화살표가 필요하지 않습니다. 하나의 매개 변수 람다는 매개 변수 이름과 화살표를 생략하도록 선택할 수 있습니다.이 경우 매개 변수가 호출 &lt;code&gt;it&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="974e5c50f4b27f1754c46fb5809df40f0b98cd08" translate="yes" xml:space="preserve">
          <source>A parent coroutine always waits for completion of all its children. Parent does not have to explicitly track all the children it launches and it does not have to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;Job.join&lt;/a&gt; to wait for them at the end:</source>
          <target state="translated">부모 코 루틴은 항상 모든 자식의 완성을 기다립니다. 부모는 자신이 시작한 모든 자식을 명시 적으로 추적 할 필요가 없으며 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;Job.join&lt;/a&gt; 을 사용 하여 끝에서 기다릴 필요 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8274e7e6404a74bf26de46501fa024c47c94d1b6" translate="yes" xml:space="preserve">
          <source>A particularly interesting operator is the function-call parenthesis pair, whose function name is &lt;code&gt;invoke&lt;/code&gt; - if you implement this, you'll be able to call instances of your class as if they were functions. You can even overload it in order to provide different function signatures.</source>
          <target state="translated">특히 흥미로운 연산자는 함수 이름이 &lt;code&gt;invoke&lt;/code&gt; 되는 함수 호출 괄호 쌍입니다. 이를 구현하면 클래스의 인스턴스를 함수 인 것처럼 호출 할 수 있습니다. 다른 기능 서명을 제공하기 위해 오버로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4af47ae608a7ac564d11609101a4fb4cd519dbf" translate="yes" xml:space="preserve">
          <source>A pipeline is a pattern where one coroutine is producing, possibly infinite, stream of values:</source>
          <target state="translated">파이프 라인은 하나의 코 루틴이 무한한 값의 흐름을 생성하는 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="9cde5f90c09a2d34b46b31e70319e1f078c94d7c" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;continue&lt;/code&gt; or &lt;code&gt;break&lt;/code&gt; works the same way as in Python: &lt;code&gt;continue&lt;/code&gt; skips to the next iteration of the innermost containing loop, and &lt;code&gt;break&lt;/code&gt; stops the loop. However, you can also &lt;em&gt;label&lt;/em&gt; your loops and reference the label in the &lt;code&gt;continue&lt;/code&gt; or &lt;code&gt;break&lt;/code&gt; statement in order to indicate which loop you want to affect. A label is an identifier followed by &lt;code&gt;@,&lt;/code&gt; e.g. &lt;code&gt;outer@&lt;/code&gt; (possibly followed by a space). For example, to generate primes:</source>
          <target state="translated">일반 &lt;code&gt;continue&lt;/code&gt; 또는 &lt;code&gt;break&lt;/code&gt; 는 Python과 같은 방식으로 작동합니다. &lt;code&gt;continue&lt;/code&gt; 는 가장 안쪽에있는 루프의 다음 반복으로 건너 뛰고 &lt;code&gt;break&lt;/code&gt; 는 루프를 중지합니다. 그러나, 당신은 또한 수 있습니다 &lt;em&gt;레이블&lt;/em&gt; 당신의 루프를하고이에 라벨을 참조 &lt;code&gt;continue&lt;/code&gt; 또는 &lt;code&gt;break&lt;/code&gt; 이 영향을하고자하는 루프를 표시하기 위해 문을. 레이블은 식별자 뒤에 &lt;code&gt;@,&lt;/code&gt; 옵니다 ( 예 : &lt;code&gt;outer@&lt;/code&gt; (공백이 올 수 있음)). 예를 들어, 소수를 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6b2a30e494b907d8d4a62480d42d797547658d1c" translate="yes" xml:space="preserve">
          <source>A private field, with the same name as the property name (only for properties with backing fields).</source>
          <target state="translated">속성 이름과 이름이 같은 개인 필드 (백업 필드가있는 속성에만 해당)</target>
        </trans-unit>
        <trans-unit id="cf177bbbdaba44b6a20302adc2f02cfa544d58d1" translate="yes" xml:space="preserve">
          <source>A progression of values of type &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">유형의 값의 진행 &lt;code&gt;Char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8000107831bfdde0265eaeae084010957d7238c6" translate="yes" xml:space="preserve">
          <source>A progression of values of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">유형의 값의 진행 &lt;code&gt;Int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39af8d75cced3cff348b69e44d892f081a434b7d" translate="yes" xml:space="preserve">
          <source>A progression of values of type &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">유형의 값의 진행 &lt;code&gt;Long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9935e82fa581f03cd1527a988db2f66b9b8656e3" translate="yes" xml:space="preserve">
          <source>A progression of values of type &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UInt&lt;/code&gt; 형의 값의 진척 .</target>
        </trans-unit>
        <trans-unit id="83c8ff0fdfef1cd606459dfe6f47432c30195b62" translate="yes" xml:space="preserve">
          <source>A progression of values of type &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">유형의 값의 진행 &lt;code&gt;ULong&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9afb968e6952d4b115b95334d2ddb1edc4507185" translate="yes" xml:space="preserve">
          <source>A property is really a &lt;em&gt;backing field&lt;/em&gt; (kind of a hidden variable inside the object) and two accessor functions: one that gets the value of the variable and one that sets the value. You can override one or both of the accessors (an accessor that is not overridden automatically gets the default behavior of just returning or setting the backing field directly). Inside an accessor, you can reference the backing field with &lt;code&gt;field&lt;/code&gt;. The setter accessor must take a parameter &lt;code&gt;value&lt;/code&gt;, which is the value that is being assigned to the property. A getter body could either be a one-line expression preceded by &lt;code&gt;=&lt;/code&gt; or a more complex body enclosed in curly braces, while a setter body typically includes an assignment and must therefore be enclosed in curly braces. If you want to validate that the age is nonnegative:</source>
          <target state="translated">속성은 실제로 &lt;em&gt;백킹 필드&lt;/em&gt; (객체 내부에 숨겨진 변수의 종류)와 두 가지 접근 자 함수입니다. 하나는 변수 값을 가져오고 다른 하나는 값을 설정합니다. 접근 자 중 하나 또는 둘 다를 재정의 할 수 있습니다 (재정의되지 않은 접근자는 자동으로 백업 필드를 직접 반환하거나 설정하는 기본 동작을 갖습니다). 접근 자 내에서 backing 필드를 &lt;code&gt;field&lt;/code&gt; 로 참조 할 수 있습니다 . 세터 접근자는 매개 변수 &lt;code&gt;value&lt;/code&gt; 가져와야합니다.이 값 은 특성에 지정되는 값입니다. 게터 본문은 앞에 한 줄짜리식이 될 수 있습니다 &lt;code&gt;=&lt;/code&gt; 또는 중괄호로 묶인 더 복잡한 본문 인 반면, 세터 본문은 일반적으로 할당을 포함하므로 중괄호로 묶어야합니다. 연령이 음수가 아닌지 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a19ce70086035d292f555ddf789a2fb77aacd274" translate="yes" xml:space="preserve">
          <source>A property reference can be used where a function with one parameter is expected:</source>
          <target state="translated">하나의 매개 변수가있는 함수가 필요한 경우 특성 참조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b2d5794a9f9f912eb15fc71ef317fc16b05c80" translate="yes" xml:space="preserve">
          <source>A public function/method returning an expression of a platform type must declare its Kotlin type explicitly:</source>
          <target state="translated">플랫폼 유형의 표현식을 리턴하는 공용 함수 / 방법은 Kotlin 유형을 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4a1aec6d30adc10a1404a818c58d50f87fa6758" translate="yes" xml:space="preserve">
          <source>A range defines a closed interval in the mathematical sense: it is defined by its two endpoint values which are both included in the range. Ranges are defined for comparable types: having an order, you can define whether an arbitrary instance is in the range between two given instances. The main operation on ranges is &lt;code&gt;contains&lt;/code&gt;, which is usually used in the form of &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;!in&lt;/code&gt; operators.</source>
          <target state="translated">범위는 수학적 의미에서 닫힌 간격을 정의합니다. 범위에 포함 된 두 개의 종점 값으로 정의됩니다. 범위는 비교 가능한 유형에 대해 정의됩니다. 순서가 있으면 임의의 인스턴스가 두 개의 지정된 인스턴스 사이의 범위에 있는지 여부를 정의 할 수 있습니다. 범위의 주요 작업은 &lt;code&gt;contains&lt;/code&gt; 하며, 이는 보통 &lt;code&gt;in&lt;/code&gt; 및 &lt;code&gt;!in&lt;/code&gt; 연산자 의 형태로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="221580726f1b79e1f121d9c5b8df4ee251854dbc" translate="yes" xml:space="preserve">
          <source>A range of values of type &lt;code&gt;Char&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Char&lt;/code&gt; 유형의 값 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="88a09d3e9acac0664732cf11d2c6dc04f33f89d1" translate="yes" xml:space="preserve">
          <source>A range of values of type &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Int&lt;/code&gt; 유형의 값 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="afabce3354f73cf6ff3d9c16c2e2674280dd51c5" translate="yes" xml:space="preserve">
          <source>A range of values of type &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Long&lt;/code&gt; 유형의 값 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="3705abd4a846fe054235e2a95a61a48c4eca8a1a" translate="yes" xml:space="preserve">
          <source>A range of values of type &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UInt&lt;/code&gt; 유형의 값 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="1fbd8e752a1a0bcc370402ee311644d3a214dac3" translate="yes" xml:space="preserve">
          <source>A range of values of type &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ULong&lt;/code&gt; 유형의 값 범위 .</target>
        </trans-unit>
        <trans-unit id="3d7de3a9c56c0accab12ad13f686dcc554485ec9" translate="yes" xml:space="preserve">
          <source>A raw string is delimited by a triple quote (&lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;), contains no escaping and can contain newlines and any other characters:</source>
          <target state="translated">원시 문자열은 삼중 따옴표 ( &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; ) 로 구분되며 이스케이프가없고 개행 및 기타 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a5516e9551d2bad807411e2391edbe31ebe1675" translate="yes" xml:space="preserve">
          <source>A read-only property type (the user is expecting a &lt;code&gt;Fruit&lt;/code&gt;, and gets an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">읽기 전용 속성 유형 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 을 기대하고 &lt;code&gt;Apple&lt;/code&gt; 을 얻습니다 )</target>
        </trans-unit>
        <trans-unit id="f241038ca168a321172b12bd8867b3601fe6885b" translate="yes" xml:space="preserve">
          <source>A reference must be explicitly marked as nullable when &lt;em&gt;null&lt;/em&gt; value is possible.</source>
          <target state="translated">&lt;em&gt;null&lt;/em&gt; 값이 가능한 경우 참조는 명시 적으로 nullable로 표시되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="41955f6fcbb06b4c30b37a0afd31c657401c1d19" translate="yes" xml:space="preserve">
          <source>A regular module targets a specific platform and can either be a dependency of platform modules or depend on platform modules.</source>
          <target state="translated">일반 모듈은 특정 플랫폼을 대상으로하며 플랫폼 모듈의 종속성이거나 플랫폼 모듈에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34160be81c96c4d2ed1676174bf3ae4b23c8900e" translate="yes" xml:space="preserve">
          <source>A return type (as we've already seen)</source>
          <target state="translated">반품 유형 (이미 살펴본 바와 같이)</target>
        </trans-unit>
        <trans-unit id="83704591cb76256bc3b326e54a087a96c9a87430" translate="yes" xml:space="preserve">
          <source>A safe call can also be placed on the left side of an assignment. Then, if one of the receivers in the safe calls chain is null, the assignment is skipped, and the expression on the right is not evaluated at all:</source>
          <target state="translated">과제의 왼쪽에 안전한 전화를 걸 수도 있습니다. 그런 다음, 안전한 통화 체인의 수신자 중 하나가 null이면 할당을 건너 뛰고 오른쪽의 표현식은 전혀 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26cb3840d4fca55e7e55b38fb5d4f493cd9e25ff" translate="yes" xml:space="preserve">
          <source>A sealed class is &lt;a href=&quot;classes#abstract-classes&quot;&gt;abstract&lt;/a&gt; by itself, it cannot be instantiated directly and can have &lt;em&gt;abstract&lt;/em&gt; members.</source>
          <target state="translated">봉인 된 클래스는 자체적 으로 &lt;a href=&quot;classes#abstract-classes&quot;&gt;추상&lt;/a&gt; 이며 직접 인스턴스화 할 수 없으며 &lt;em&gt;추상&lt;/em&gt; 멤버를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8457cb4b6b370531b78c522f162b937449277750" translate="yes" xml:space="preserve">
          <source>A sequence that returns values through its iterator. The values are evaluated lazily, and the sequence is potentially infinite.</source>
          <target state="translated">반복자를 통해 값을 반환하는 시퀀스입니다. 값은 느리게 평가되며 시퀀스는 잠재적으로 무한합니다.</target>
        </trans-unit>
        <trans-unit id="7265e100a83e4681e997a3291f0bd196c84d5b43" translate="yes" xml:space="preserve">
          <source>A series of complete step-by-step tutorials to walk you through how to accomplish different tasks in Kotlin, from Getting Started to writing Android applications and more. If you have a tutorial you'd like featured here, please let us know. We'll be happy to host it and give credit!</source>
          <target state="translated">Kotlin에서 시작하기부터 Android 애플리케이션 작성에 이르기까지 다양한 작업을 수행하는 방법을 안내하는 일련의 완전한 단계별 자습서입니다. 여기에 추천하고 싶은 튜토리얼이 있으면 알려주십시오. 우리는 그것을 호스팅하고 신용을 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="4488cb2716f1ba3dca6886de2da7a5d7ed90ffb5" translate="yes" xml:space="preserve">
          <source>A set of extension functions was added for manipulating lists: &lt;code&gt;fill&lt;/code&gt;, &lt;code&gt;replaceAll&lt;/code&gt; and &lt;code&gt;shuffle&lt;/code&gt; for &lt;code&gt;MutableList&lt;/code&gt;, and &lt;code&gt;shuffled&lt;/code&gt; for read-only &lt;code&gt;List&lt;/code&gt;:</source>
          <target state="translated">확장 기능의 세트리스트 조작하기위한 추가되었습니다 &lt;code&gt;fill&lt;/code&gt; , &lt;code&gt;replaceAll&lt;/code&gt; 및 &lt;code&gt;shuffle&lt;/code&gt; 에 대한 &lt;code&gt;MutableList&lt;/code&gt; 을 하고 &lt;code&gt;shuffled&lt;/code&gt; 읽기 전용에 대한 &lt;code&gt;List&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62b64f509cf25a0a71280021d8d233038539b6d7" translate="yes" xml:space="preserve">
          <source>A set of factory methods is used for declaring elements of the &lt;code&gt;binaries&lt;/code&gt; collection. These methods allow one to specify what kinds of binaries are to be created and configure them. The following binary kinds are supported (note that not all the kinds are available for all native platforms):</source>
          <target state="translated">&lt;code&gt;binaries&lt;/code&gt; 컬렉션의 요소를 선언하기 위해 팩토리 메소드 세트가 사용됩니다 . 이러한 방법을 통해 어떤 종류의 바이너리를 생성하고 구성 할 수 있습니다. 다음 이진 종류가 지원됩니다 (모든 종류가 모든 기본 플랫폼에서 사용 가능한 것은 아님).</target>
        </trans-unit>
        <trans-unit id="55d25bafc109a837fa16e50504d1fe3a3785094d" translate="yes" xml:space="preserve">
          <source>A setter method, with the name calculated by prepending the &lt;code&gt;set&lt;/code&gt; prefix (only for &lt;code&gt;var&lt;/code&gt; properties);</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 접두사 를 앞에 붙여 이름을 계산하는 setter 메소드 ( &lt;code&gt;var&lt;/code&gt; 속성 에만 해당 );</target>
        </trans-unit>
        <trans-unit id="a79440aad6b71d56ce4283f0e84514842d6f1254" translate="yes" xml:space="preserve">
          <source>A shorter way to define a &lt;code&gt;Comparator&lt;/code&gt; is the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.comparisons/compare-by&quot;&gt;&lt;code&gt;compareBy()&lt;/code&gt;&lt;/a&gt; function from the standard library. &lt;code&gt;compareBy()&lt;/code&gt; takes a lambda function that produces a &lt;code&gt;Comparable&lt;/code&gt; value from an instance and defines the custom order as the natural order of the produced values. With &lt;code&gt;compareBy()&lt;/code&gt;, the length comparator from the example above looks like this:</source>
          <target state="translated">&lt;code&gt;Comparator&lt;/code&gt; 를 정의하는 더 짧은 방법 은 표준 라이브러리 의 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.comparisons/compare-by&quot;&gt; &lt;code&gt;compareBy()&lt;/code&gt; &lt;/a&gt; 함수입니다. &lt;code&gt;compareBy()&lt;/code&gt; 는 인스턴스에서 &lt;code&gt;Comparable&lt;/code&gt; 값 을 생성하는 람다 함수를 사용 하여 사용자 지정 순서를 생성 된 값의 자연 순서로 정의합니다. &lt;code&gt;compareBy()&lt;/code&gt; 사용하면 위 예제의 길이 비교기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8d41cb6d401bf4d42a494408558f6a917e8029e" translate="yes" xml:space="preserve">
          <source>A significant part of the definitions goes in the &lt;code&gt;libnative_api.h&lt;/code&gt; file. It includes the definition of our Kotlin/Native library world:</source>
          <target state="translated">정의의 중요한 부분은 &lt;code&gt;libnative_api.h&lt;/code&gt; 파일에 있습니다. 여기에는 Kotlin / Native 도서관 세계의 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8c62e96107720a9bca1a776893d559e996f2f875" translate="yes" xml:space="preserve">
          <source>A single annotation without arguments may be placed on the same line as the corresponding declaration:</source>
          <target state="translated">인수가없는 단일 주석은 해당 선언과 같은 줄에 배치 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b436cfd5069ee133fe3275c0591a75add8ffd26" translate="yes" xml:space="preserve">
          <source>A source file may start with a package declaration:</source>
          <target state="translated">소스 파일은 패키지 선언으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="021186335ce0a94c240ef97ae9b17e18e4801b7f" translate="yes" xml:space="preserve">
          <source>A source set by itself is platform-agnostic, but it can be considered platform-specific if it is only compiled for a single platform. A source set can, therefore, contain either common code shared between the platforms or platform-specific code.</source>
          <target state="translated">소스 세트 자체는 플랫폼에 구애받지 않지만 단일 플랫폼 용으로 만 컴파일 된 경우 플랫폼별로 고려할 수 있습니다. 따라서 소스 세트에는 플랫폼간에 공유되는 공통 코드 또는 플랫폼 별 코드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c4b0ff108f076b7bc92f46447b67f1f632fcfb" translate="yes" xml:space="preserve">
          <source>A source set is not bound to be platform-specific or &quot;shared&quot;; what it's allowed to contain depends on its usage: a source set added to multiple compilations is limited to the common language features and dependencies, while a source set that is only used by a single target can have platform-specific dependencies, and its code may use language features specific to that target's platform.</source>
          <target state="translated">소스 세트는 플랫폼 별 또는 &quot;공유&quot;로 바인딩되지 않습니다. 포함 할 수있는 것은 사용법에 따라 다릅니다. 여러 컴파일에 추가 된 소스 세트는 공통 언어 기능 및 종속성으로 제한되는 반면 단일 대상에서만 사용되는 소스 세트에는 플랫폼 별 종속성이있을 수 있으며 코드는 해당 대상 플랫폼에 특정한 언어 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc425ab30bdba05aac08e3df265edc9f79e66b7c" translate="yes" xml:space="preserve">
          <source>A symbol that is declared inside an interface normally should be public. The only other legal visibility modifier is &lt;code&gt;private&lt;/code&gt;, which can only be used if the function body is supplied - that function may then be called by each class that implements the interface, but not by anyone else.</source>
          <target state="translated">인터페이스 내부에 선언 된 심볼은 일반적으로 공개되어야합니다. 다른 유효한 가시성 수정자는 &lt;code&gt;private&lt;/code&gt; 이며, 함수 본문이 제공되는 경우에만 사용할 수 있습니다.이 함수는 인터페이스를 구현하는 각 클래스에서 호출 할 수 있지만 다른 사람은 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="32d61e578eecdd26bc4fc5d5cfb020754a651496" translate="yes" xml:space="preserve">
          <source>A syntactic variation of &lt;code&gt;run()&lt;/code&gt; is &lt;code&gt;let()&lt;/code&gt;, which takes an ordinary function type instead of a function type with receiver, so the expression that might be null will be referred to as &lt;code&gt;it&lt;/code&gt; instead of &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">의 구문 변화 &lt;code&gt;run()&lt;/code&gt; 이다 &lt;code&gt;let()&lt;/code&gt; , null이 될 수있는식이라고한다, 그래서 보통의 함수 타입 대신 수신기 기능 유형을 걸립니다 &lt;code&gt;it&lt;/code&gt; 대신에 &lt;code&gt;this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5545fc39ffaf26de75f2d70b8d37780f23c4704" translate="yes" xml:space="preserve">
          <source>A target is a part of the build responsible for compiling, testing, and packaging a piece of software aimed for one of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">대상은 &lt;a href=&quot;#supported-platforms&quot;&gt;지원되는 플랫폼&lt;/a&gt; 중 하나를 대상으로하는 소프트웨어를 컴파일, 테스트 및 패키징하는 빌드의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="999c54676b7660630ed4d00049d50a094fccdfab" translate="yes" xml:space="preserve">
          <source>A target that is not supported by the current host is ignored during build and therefore not published. A library author may want to set up builds and publishing from different hosts as required by the library target platforms.</source>
          <target state="translated">현재 호스트가 지원하지 않는 대상은 빌드 중에 무시되므로 게시되지 않습니다. 라이브러리 작성자는 라이브러리 대상 플랫폼에 필요한대로 다른 호스트에서 빌드 및 게시를 설정하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96fcc60b3ab303801bc0dc081c98259cae3bf787" translate="yes" xml:space="preserve">
          <source>A test task is created under the name &lt;code&gt;&amp;lt;targetName&amp;gt;Test&lt;/code&gt; for each target that is suitable for testing. Run the &lt;code&gt;check&lt;/code&gt; task to run the tests for all targets.</source>
          <target state="translated">테스트 작업은 &lt;code&gt;&amp;lt;targetName&amp;gt;Test&lt;/code&gt; 에 적합한 각 대상에 대해 &amp;lt;targetName&amp;gt; Test 라는 이름으로 작성됩니다 . 실행 &lt;code&gt;check&lt;/code&gt; 모든 대상에 대한 테스트를 실행하는 작업을.</target>
        </trans-unit>
        <trans-unit id="c9a04a4de5ccd8f9acab09df372876b6003bb150" translate="yes" xml:space="preserve">
          <source>A type alias allows you to define an alternative name for an existing type. This is most useful for generic types such as collections, as well as for function types. Here is an example:</source>
          <target state="translated">유형 별명을 사용하면 기존 유형의 대체 이름을 정의 할 수 있습니다. 이는 함수 유형뿐만 아니라 컬렉션과 같은 일반 유형에 가장 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9a02cc3c9a98a1f2eefa73c09ae2ace003cceec" translate="yes" xml:space="preserve">
          <source>A type-safe builder example</source>
          <target state="translated">타입 안전 빌더 예제</target>
        </trans-unit>
        <trans-unit id="6c942af40c87105ce9bd9accffec18f0f29c5897" translate="yes" xml:space="preserve">
          <source>A value of a function type can be invoked by using its &lt;a href=&quot;operator-overloading#invoke&quot;&gt;&lt;code&gt;invoke(...)&lt;/code&gt; operator&lt;/a&gt;: &lt;code&gt;f.invoke(x)&lt;/code&gt; or just &lt;code&gt;f(x)&lt;/code&gt;.</source>
          <target state="translated">함수 유형의 값은 &lt;a href=&quot;operator-overloading#invoke&quot;&gt; &lt;code&gt;invoke(...)&lt;/code&gt; 연산자&lt;/a&gt; 를 사용하여 호출 할 수 있습니다 : &lt;code&gt;f.invoke(x)&lt;/code&gt; 또는 &lt;code&gt;f(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3803ccd0cee93213eb0c6456398b134b14b2e36e" translate="yes" xml:space="preserve">
          <source>A variable only exists inside the &lt;em&gt;scope&lt;/em&gt; (curly-brace-enclosed block of code; more on that later) in which it has been declared - so a variable that's declared inside a loop only exists in that loop; you can't check its final value after the loop. Variables can be redeclared inside nested scopes - so if there's a parameter &lt;code&gt;x&lt;/code&gt; to a function and you create a loop and declare an &lt;code&gt;x&lt;/code&gt; inside that loop, the &lt;code&gt;x&lt;/code&gt; inside the loop is a different variable than the parameter &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">변수 는 선언 된 &lt;em&gt;스코프&lt;/em&gt; (중괄호로 묶은 코드 블록 에만 해당되며 나중에 자세히 설명)에만 존재합니다. 따라서 루프 내부에 선언 된 변수는 해당 루프에만 존재합니다. 루프 후 최종 값을 확인할 수 없습니다. 변수가 중첩 된 범위 내에서 다시 선언 할 수있다 - 매개 변수 거기에 만약 그렇다면 &lt;code&gt;x&lt;/code&gt; 함수에가 당신이 루프를 만들고 선언 &lt;code&gt;x&lt;/code&gt; 그 루프 내부의 &lt;code&gt;x&lt;/code&gt; 루프 내부 매개 변수와 다른 변수 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ee49960f9187f3de855aad0164b2243999549a6" translate="yes" xml:space="preserve">
          <source>A variable that doesn't refer to anything refers to &lt;code&gt;null&lt;/code&gt; (or you can say that the variable &quot;is null&quot;). As opposed to &lt;code&gt;None&lt;/code&gt; in Python, &lt;code&gt;null&lt;/code&gt; is not an object - it's just a keyword that is used to make a variable refer to nothing or to check if it does (that check must be performed with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;). Because nulls are a frequent source of programming errors, Kotlin encourages avoiding them as much as possible - a variable cannot actually be null unless it's been declared to allow for null, which you do by suffixing the type name with &lt;code&gt;?&lt;/code&gt;. For example:</source>
          <target state="translated">아무것도 참조하지 않는 변수는 &lt;code&gt;null&lt;/code&gt; 을 나타냅니다 (또는 변수가 &quot;null&quot;이라고 말할 수 있음). Python의 &lt;code&gt;None&lt;/code&gt; 과 는 달리 &lt;code&gt;null&lt;/code&gt; 은 객체가 아닙니다. 변수는 아무것도 참조하지 않거나 확인하는 데 사용되는 키워드 일뿐입니다 (확인은 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 로 수행해야 함 ). null은 프로그래밍 오류의 빈번한 원인이기 때문에 Kotlin은 가능한 한 많은 오류를 피하도록 권장합니다. 변수는 null을 허용하도록 선언되지 않은 한 실제로 null이 될 수 없습니다 &lt;code&gt;?&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c75a304d0b9d2b04fc8b2ae831b34ab2f8b99cb" translate="yes" xml:space="preserve">
          <source>A vector of bits growing if necessary and allowing one to set/clear/read bits from it by a bit index.</source>
          <target state="translated">필요한 경우 성장하는 비트 벡터로 비트 인덱스에 의해 비트를 설정 / 삭제 / 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f447137bd99bb0df9c8a7342bebccf5cbfda3a7" translate="yes" xml:space="preserve">
          <source>A version of the Gradle project is used as a value for the &lt;code&gt;version&lt;/code&gt; field. Fields&lt;code&gt;summary&lt;/code&gt; and &lt;code&gt;homepage&lt;/code&gt; can be configured using the &lt;code&gt;cocoapods&lt;/code&gt; code block.</source>
          <target state="translated">Gradle 프로젝트의 &lt;code&gt;version&lt;/code&gt; 은 버전 필드 의 값으로 사용됩니다 . &lt;code&gt;cocoapods&lt;/code&gt; 코드 블록을 사용하여 필드 &lt;code&gt;summary&lt;/code&gt; 및 &lt;code&gt;homepage&lt;/code&gt; 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b7d487bfac9fc377272b7fe65ffeb000fb2421c" translate="yes" xml:space="preserve">
          <source>A zero-based index of current iteration is passed as a parameter to &lt;a href=&quot;repeat#kotlin%24repeat%28kotlin.Int%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt;.</source>
          <target state="translated">현재 반복의 0부터 시작하는 인덱스는 &lt;a href=&quot;repeat#kotlin%24repeat%28kotlin.Int%2C+kotlin.Function1%28%28kotlin.Int%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action에&lt;/a&gt; 매개 변수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="83a7a5b782649abaa2ee5c51a6e8c21d46906a36" translate="yes" xml:space="preserve">
          <source>A: As Kotlin/Native needs to download a platform specific toolchain, you need to specify &lt;code&gt;-Dhttp.proxyHost=xxx -Dhttp.proxyPort=xxx&lt;/code&gt; as the compiler's or &lt;code&gt;gradlew&lt;/code&gt; arguments, or set it via the &lt;code&gt;JAVA_OPTS&lt;/code&gt; environment variable.</source>
          <target state="translated">A : Kotlin / Native는 플랫폼 별 툴체인을 다운로드해야 하므로 컴파일러 또는 &lt;code&gt;gradlew&lt;/code&gt; 인수 로 &lt;code&gt;-Dhttp.proxyHost=xxx -Dhttp.proxyPort=xxx&lt;/code&gt; 를 지정 하거나 &lt;code&gt;JAVA_OPTS&lt;/code&gt; 환경 변수 를 통해 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f48fa5d2280b5e4c31db2f6ac951ea7fe7772538" translate="yes" xml:space="preserve">
          <source>A: By default gradle plugin adds it on iOS target.</source>
          <target state="translated">A : 기본적으로 gradle 플러그인은 iOS 대상에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="54f627a5de981e9923ac5206ecaba6b5056c6d69" translate="yes" xml:space="preserve">
          <source>A: Currently, singleton objects are immutable (i.e. frozen after creation), and it's generally considered good practise to have the global state immutable. If for some reason you need a mutable state inside such an object, use the &lt;code&gt;@konan.ThreadLocal&lt;/code&gt; annotation on the object. Also the &lt;code&gt;kotlin.native.concurrent.AtomicReference&lt;/code&gt; class could be used to store different pointers to frozen objects in a frozen object and automatically update them.</source>
          <target state="translated">A : 현재 싱글 톤 객체는 변경할 수 없으며 (즉, 생성 후 고정됨) 일반적으로 전역 상태를 변경할 수없는 것이 좋습니다. 어떤 이유로 그러한 객체 내부에서 변경 가능한 상태가 필요한 경우 객체에서 &lt;code&gt;@konan.ThreadLocal&lt;/code&gt; 주석을 사용하십시오 . 또한 &lt;code&gt;kotlin.native.concurrent.AtomicReference&lt;/code&gt; 클래스를 사용하여 고정 된 객체에 고정 된 객체에 대한 다른 포인터를 저장하고 자동으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="469aef55abc3b452c640ed57fd2b4a77ac9d9c2a" translate="yes" xml:space="preserve">
          <source>A: Define a top level function &lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;)&lt;/code&gt; or just &lt;code&gt;fun main()&lt;/code&gt; if you are not interested in passed arguments, please ensure it's not in a package. Also compiler switch &lt;code&gt;-entry&lt;/code&gt; could be used to make any function taking &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; or no arguments and return &lt;code&gt;Unit&lt;/code&gt; as an entry point.</source>
          <target state="translated">A : 전달 된 인수에 관심이없는 경우 최상위 함수 &lt;code&gt;fun main(args: Array&amp;lt;String&amp;gt;)&lt;/code&gt; 하거나 &lt;code&gt;fun main()&lt;/code&gt; 하십시오. 패키지에 없는지 확인하십시오. 또한 컴파일러 switch &lt;code&gt;-entry&lt;/code&gt; 를 사용하여 &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; 하거나 인수를 사용하지 않고 &lt;code&gt;Unit&lt;/code&gt; 을 시작점으로 반환 하는 함수를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23a7f68b33d01081eaa44341c44994d7c2b4bc72" translate="yes" xml:space="preserve">
          <source>A: It likely happens, because you are trying to mutate a frozen object. An object can transfer to the frozen state either explicitly, as objects reachable from objects on which the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; is called, or implicitly (i.e. reachable from &lt;code&gt;enum&lt;/code&gt; or global singleton object - see the next question).</source>
          <target state="translated">A : 고정 된 개체를 변경하려고했기 때문에 발생했을 수 있습니다. &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; 가 호출 되는 객체에서 도달 할 수있는 객체 또는 암시 적으로 (즉, &lt;code&gt;enum&lt;/code&gt; 또는 전역 단일 객체 에서 도달 할 수있는 -다음 질문 참조) 객체 는 명시 적으로 고정 상태로 전환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0e72bdf6f524c2737d88889afe4af011df20fb" translate="yes" xml:space="preserve">
          <source>A: Kotlin/Native provides an automated memory management scheme, similar to what Java or Swift provides. The current implementation includes an automated reference counter with a cycle collector to collect cyclical garbage.</source>
          <target state="translated">A : Kotlin / Native는 Java 또는 Swift가 제공하는 것과 유사한 자동 메모리 관리 체계를 제공합니다. 현재 구현에는 순환 가비지를 수집하기위한 사이클 수집기가있는 자동 참조 카운터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6430ac738ad0305a45bbf44b4a1ea65027089a78" translate="yes" xml:space="preserve">
          <source>A: One of the following should be done:</source>
          <target state="translated">A : 다음 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe5cae9a95608abbf572b32e151c3389de9906d9" translate="yes" xml:space="preserve">
          <source>A: Use the &lt;code&gt;-module-name&lt;/code&gt; compiler option or matching Gradle DSL statement, i.e.</source>
          <target state="translated">A : &lt;code&gt;-module-name&lt;/code&gt; 컴파일러 옵션 또는 일치하는 Gradle DSL 문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d178f6b7d7ab96c56c796a94a8ffd31fd8247adc" translate="yes" xml:space="preserve">
          <source>A: Use the &lt;code&gt;-produce dynamic&lt;/code&gt; compiler switch, or &lt;code&gt;binaries.sharedLib()&lt;/code&gt; in Gradle, i.e.</source>
          <target state="translated">A : Gradle에서 &lt;code&gt;-produce dynamic&lt;/code&gt; 컴파일러 스위치 또는 &lt;code&gt;binaries.sharedLib()&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="583522dc14200ed2d6737834038b23fd2169fb2d" translate="yes" xml:space="preserve">
          <source>A: Use the &lt;code&gt;-produce static&lt;/code&gt; compiler switch, or &lt;code&gt;binaries.staticLib()&lt;/code&gt; in Gradle, i.e.</source>
          <target state="translated">A : Gradle에서 &lt;code&gt;-produce static&lt;/code&gt; 컴파일러 스위치 또는 &lt;code&gt;binaries.staticLib()&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55ad722eb4893f232638d8208f5ef26172c240a1" translate="yes" xml:space="preserve">
          <source>A: Use the &lt;code&gt;baseName&lt;/code&gt; option. This will also set the module name.</source>
          <target state="translated">A : &lt;code&gt;baseName&lt;/code&gt; 옵션을 사용하십시오 . 모듈 이름도 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8bdc6249aa90c585c50dc149a1ac486df2283f04" translate="yes" xml:space="preserve">
          <source>AIR</source>
          <target state="translated">AIR</target>
        </trans-unit>
        <trans-unit id="81297a2ee021a840a160551409407615f0d05b15" translate="yes" xml:space="preserve">
          <source>ANDROID</source>
          <target state="translated">ANDROID</target>
        </trans-unit>
        <trans-unit id="c7b386585a8cd45bbd249d61f6484c48e856d346" translate="yes" xml:space="preserve">
          <source>ANNOTATION_CLASS</source>
          <target state="translated">ANNOTATION_CLASS</target>
        </trans-unit>
        <trans-unit id="4a3a08afddace26444e6c02edee535eca390133a" translate="yes" xml:space="preserve">
          <source>AP/Javac options encoding</source>
          <target state="translated">AP / Javac 옵션 인코딩</target>
        </trans-unit>
        <trans-unit id="a4c5aa30008f131f9b717d9610a66f2353fd31d2" translate="yes" xml:space="preserve">
          <source>ARABIC_NUMBER</source>
          <target state="translated">ARABIC_NUMBER</target>
        </trans-unit>
        <trans-unit id="2b3110c25b23e7d1307e6fca7f13cd56712696aa" translate="yes" xml:space="preserve">
          <source>ARM32</source>
          <target state="translated">ARM32</target>
        </trans-unit>
        <trans-unit id="bb16ce026bf1a07a5455f7b9ddaf3fa1e5dc5686" translate="yes" xml:space="preserve">
          <source>ARM64</source>
          <target state="translated">ARM64</target>
        </trans-unit>
        <trans-unit id="22389c32b9d7ab2b2fdb4e3d99b9053c4e8d3d88" translate="yes" xml:space="preserve">
          <source>AT_LEAST_ONCE</source>
          <target state="translated">AT_LEAST_ONCE</target>
        </trans-unit>
        <trans-unit id="dcc1fcaf1557c4d05679436118b3946273a18903" translate="yes" xml:space="preserve">
          <source>AT_MOST_ONCE</source>
          <target state="translated">AT_MOST_ONCE</target>
        </trans-unit>
        <trans-unit id="49ade02a332b7c166aa17f14fd846c7d9e1bd27d" translate="yes" xml:space="preserve">
          <source>AWS Labs provides a &lt;a href=&quot;https://github.com/awslabs/serverless-photo-recognition&quot;&gt;sample project&lt;/a&gt; showing the use of Kotlin for writing &lt;a href=&quot;https://aws.amazon.com/lambda/&quot;&gt;AWS Lambda&lt;/a&gt; functions.</source>
          <target state="translated">AWS Labs는 &lt;a href=&quot;https://aws.amazon.com/lambda/&quot;&gt;AWS Lambda&lt;/a&gt; 함수 작성에 Kotlin을 사용하는 것을 보여주는 &lt;a href=&quot;https://github.com/awslabs/serverless-photo-recognition&quot;&gt;샘플 프로젝트&lt;/a&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="119f87452b9c604da175968848ba17b7bfa8e536" translate="yes" xml:space="preserve">
          <source>Absence of implicit conversions is rarely noticeable because the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example</source>
          <target state="translated">암시 적 변환의 부재는 컨텍스트에서 유형이 유추되고 예를 들어 적절한 변환을 위해 산술 연산이 오버로드되기 때문에 거의 눈에 띄지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes" xml:space="preserve">
          <source>Abstract Classes</source>
          <target state="translated">추상 클래스</target>
        </trans-unit>
        <trans-unit id="32f08ac28cfa041c2b36410b7bb09baeffc3885e" translate="yes" xml:space="preserve">
          <source>Abstract classes</source>
          <target state="translated">추상 수업</target>
        </trans-unit>
        <trans-unit id="8cac6657db372ec98eec0f1c267bc27922cdbf4d" translate="yes" xml:space="preserve">
          <source>Abstract classes are implicitly open, since they are useless if they don't have any concrete subclasses.</source>
          <target state="translated">추상 클래스는 구체적인 하위 클래스가 없으면 쓸모가 없으므로 암시 적으로 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="372af3b44fec0ec5a2dae9015dd5aa97b0e6f7cc" translate="yes" xml:space="preserve">
          <source>Abstract collections</source>
          <target state="translated">추상 컬렉션</target>
        </trans-unit>
        <trans-unit id="62deadea5aa50c02c734a956de1e99c71e45bf05" translate="yes" xml:space="preserve">
          <source>AbstractCollection</source>
          <target state="translated">AbstractCollection</target>
        </trans-unit>
        <trans-unit id="ecc696822df6b79b8a28e672bebead3cbea32633" translate="yes" xml:space="preserve">
          <source>AbstractCoroutineContextElement</source>
          <target state="translated">AbstractCoroutineContextElement</target>
        </trans-unit>
        <trans-unit id="3fcebf45d4e6c238fc15c900d4cdbbe3983ba070" translate="yes" xml:space="preserve">
          <source>AbstractIterator</source>
          <target state="translated">AbstractIterator</target>
        </trans-unit>
        <trans-unit id="80b25eb6b4fc66c38a02c0db0db4701efc036bfe" translate="yes" xml:space="preserve">
          <source>AbstractList</source>
          <target state="translated">AbstractList</target>
        </trans-unit>
        <trans-unit id="e5b1267bb3362c3d2609d08b1cc8a480c087ece8" translate="yes" xml:space="preserve">
          <source>AbstractMap</source>
          <target state="translated">AbstractMap</target>
        </trans-unit>
        <trans-unit id="d196bcf450087d1563b9908b7c60861d7a7b03d3" translate="yes" xml:space="preserve">
          <source>AbstractMutableCollection</source>
          <target state="translated">AbstractMutableCollection</target>
        </trans-unit>
        <trans-unit id="cdab0b7c59398ffe8f8c4e2414f6fb32c45154f4" translate="yes" xml:space="preserve">
          <source>AbstractMutableList</source>
          <target state="translated">AbstractMutableList</target>
        </trans-unit>
        <trans-unit id="1dbbde4c21f402ba61eaeabc7559d1d8b069c230" translate="yes" xml:space="preserve">
          <source>AbstractMutableMap</source>
          <target state="translated">AbstractMutableMap</target>
        </trans-unit>
        <trans-unit id="29ae24d786bef4da7e776d19818073cb89a6fefb" translate="yes" xml:space="preserve">
          <source>AbstractMutableSet</source>
          <target state="translated">AbstractMutableSet</target>
        </trans-unit>
        <trans-unit id="ce89d8527dc144fe8623087bd9235422a835ad7f" translate="yes" xml:space="preserve">
          <source>AbstractSet</source>
          <target state="translated">AbstractSet</target>
        </trans-unit>
        <trans-unit id="78edc1854054dd0a65df4bf632ca35ca20d99437" translate="yes" xml:space="preserve">
          <source>AbstractWorker</source>
          <target state="translated">AbstractWorker</target>
        </trans-unit>
        <trans-unit id="54c67fd3d098f3a0f1411f92bb9d4b4763843d8c" translate="yes" xml:space="preserve">
          <source>Access to top-level properties (&lt;code&gt;document&lt;/code&gt;, &lt;code&gt;window&lt;/code&gt; etc.) in the browser environment.</source>
          <target state="translated">브라우저 환경에서 최상위 속성 ( &lt;code&gt;document&lt;/code&gt; , &lt;code&gt;window&lt;/code&gt; 등)에 액세스 합니다.</target>
        </trans-unit>
        <trans-unit id="062b46dbf1f59a76df58f1a799356641383d7198" translate="yes" xml:space="preserve">
          <source>AccessDeniedException</source>
          <target state="translated">AccessDeniedException</target>
        </trans-unit>
        <trans-unit id="8a353ce773c51b184dc9ab781e4fce8619d42835" translate="yes" xml:space="preserve">
          <source>Accessing a &lt;code&gt;lateinit&lt;/code&gt; property before it has been initialized throws a special exception that clearly identifies the property being accessed and the fact that it hasn't been initialized.</source>
          <target state="translated">초기화되기 전에 &lt;code&gt;lateinit&lt;/code&gt; 속성에 액세스하면 액세스 중인 속성과 해당 속성이 초기화되지 않았다는 사실을 명확하게 식별하는 특별한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6f5a767ddc1bd76dea008380c3691401bac40d76" translate="yes" xml:space="preserve">
          <source>Accessing a map</source>
          <target state="translated">지도에 액세스</target>
        </trans-unit>
        <trans-unit id="ded4c19079868702de4a0401515f9859ce6d0d41" translate="yes" xml:space="preserve">
          <source>Accessing binaries</source>
          <target state="translated">바이너리에 액세스</target>
        </trans-unit>
        <trans-unit id="dc33d6b550c28222c845e121b06fbd0aed19e534" translate="yes" xml:space="preserve">
          <source>Accessing properties of an annotation instance</source>
          <target state="translated">주석 인스턴스의 속성에 액세스</target>
        </trans-unit>
        <trans-unit id="2593716ac51411fe9db10d5eff2682c068580793" translate="yes" xml:space="preserve">
          <source>Accessing static members</source>
          <target state="translated">정적 멤버에 액세스</target>
        </trans-unit>
        <trans-unit id="cf842181d642477f23f2c69b279d1bfb3dc226bf" translate="yes" xml:space="preserve">
          <source>Accessing this property first time creates a keys view from &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt;. All subsequent accesses just return the created instance.</source>
          <target state="translated">이 속성에 처음 액세스하면 &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 에서 키보기가 작성 됩니다. 모든 후속 액세스는 작성된 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="deda93269f212a2a0f24d9b71bae5f2f0178db44" translate="yes" xml:space="preserve">
          <source>Accessing this property first time creates a values view from &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt;. All subsequent accesses just return the created instance.</source>
          <target state="translated">이 속성에 처음 액세스하면 &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 에서 값보기가 작성 됩니다. 모든 후속 액세스는 작성된 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="547cfc7558e9e8755a8cea3edea36cf00e80e196" translate="yes" xml:space="preserve">
          <source>Accessor</source>
          <target state="translated">Accessor</target>
        </trans-unit>
        <trans-unit id="2d8b9d11aed9ad552693fdb8b7b4209cbca66a6c" translate="yes" xml:space="preserve">
          <source>According to Java's rules, &lt;code&gt;finalize()&lt;/code&gt; must not be &lt;em&gt;private&lt;/em&gt;.</source>
          <target state="translated">Java 규칙에 따르면 &lt;code&gt;finalize()&lt;/code&gt; 는 &lt;em&gt;private이&lt;/em&gt; 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a6cd67dc89d8085d643ec218854da3053ee3016a" translate="yes" xml:space="preserve">
          <source>According to the Feedback Loop principle described above, we iterate on our designs in the open and release versions of the language where some features have the &lt;em&gt;experimental&lt;/em&gt; status and &lt;em&gt;are supposed to change&lt;/em&gt;. Experimental features can be added, changed or removed at any point and without warning. We make sure that experimental features can't be used accidentally by an unsuspecting user. Such features usually require some sort of an explicit opt-in either in the code or in the project configuration.</source>
          <target state="translated">위에서 설명한 Feedback Loop 원칙에 따라 일부 기능이 &lt;em&gt;실험적인&lt;/em&gt; 상태 &lt;em&gt;를 갖고 변경 될&lt;/em&gt; 예정인 언어의 개방형 및 릴리스 버전에서 설계를 반복합니다 . 실험 기능은 언제든지 경고없이 추가, 변경 또는 제거 할 수 있습니다. 의심없는 사용자가 실험 기능을 실수로 사용할 수 없도록합니다. 이러한 기능은 일반적으로 코드 또는 프로젝트 구성에서 명시 적 옵트 인을 필요로합니다.</target>
        </trans-unit>
        <trans-unit id="3607a01777a8d5a65ab1d061a49e095a4fcb830f" translate="yes" xml:space="preserve">
          <source>Accumulates entries of this context starting with &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element of this context.</source>
          <target state="translated">이 컨텍스트 엔트리에서 시작 적산 &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값 및인가 &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;동작을&lt;/a&gt; 전류 누산기 값에 바로이 상황의 각 요소를 왼쪽에서.</target>
        </trans-unit>
        <trans-unit id="71476199892facc6d22265c0f1d161804d8adacd" translate="yes" xml:space="preserve">
          <source>Accumulates entries of this context starting with &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element of this context.</source>
          <target state="translated">이 컨텍스트 엔트리에서 시작 적산 &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값 및인가 &lt;a href=&quot;../-coroutine-context/fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;동작을&lt;/a&gt; 전류 누산기 값에 바로이 상황의 각 요소를 왼쪽에서.</target>
        </trans-unit>
        <trans-unit id="1c9c7f55c8a3f1326f6ed22f8562419c67d22168" translate="yes" xml:space="preserve">
          <source>Accumulates entries of this context starting with &lt;a href=&quot;../fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element of this context.</source>
          <target state="translated">이 컨텍스트 엔트리에서 시작 적산 &lt;a href=&quot;../fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값 및인가 &lt;a href=&quot;../fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;동작을&lt;/a&gt; 전류 누산기 값에 바로이 상황의 각 요소를 왼쪽에서.</target>
        </trans-unit>
        <trans-unit id="3de8543e178b7990cb6f2a115af66f701d127724" translate="yes" xml:space="preserve">
          <source>Accumulates entries of this context starting with &lt;a href=&quot;../fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element of this context.</source>
          <target state="translated">이 컨텍스트 엔트리에서 시작 적산 &lt;a href=&quot;../fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값 및인가 &lt;a href=&quot;../fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;동작을&lt;/a&gt; 전류 누산기 값에 바로이 상황의 각 요소를 왼쪽에서.</target>
        </trans-unit>
        <trans-unit id="1adebe0a3bc77b985c9e47524bc68db2419fad8a" translate="yes" xml:space="preserve">
          <source>Accumulates entries of this context starting with &lt;a href=&quot;fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element of this context.</source>
          <target state="translated">이 컨텍스트 엔트리에서 시작 적산 &lt;a href=&quot;fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값 및인가 &lt;a href=&quot;fold#kotlin.coroutines.CoroutineContext%24fold%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.CoroutineContext.fold.R%2C+kotlin.coroutines.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;동작을&lt;/a&gt; 전류 누산기 값에 바로이 상황의 각 요소를 왼쪽에서.</target>
        </trans-unit>
        <trans-unit id="c92f86d300219c2b7ac9a5e2a77e5d21940fe204" translate="yes" xml:space="preserve">
          <source>Accumulates entries of this context starting with &lt;a href=&quot;fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element of this context.</source>
          <target state="translated">이 컨텍스트 엔트리에서 시작 적산 &lt;a href=&quot;fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값 및인가 &lt;a href=&quot;fold#kotlin.coroutines.experimental.CoroutineContext%24fold%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.Function2%28%28kotlin.coroutines.experimental.CoroutineContext.fold.R%2C+kotlin.coroutines.experimental.CoroutineContext.Element%2C+%29%29%29%2Foperation&quot;&gt;동작을&lt;/a&gt; 전류 누산기 값에 바로이 상황의 각 요소를 왼쪽에서.</target>
        </trans-unit>
        <trans-unit id="ca613627da9a2347675d12e71dfe561b2ca3d08c" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.Array%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.Array%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.Array%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.Array%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a033a45ed69305a90908491839025cd1330b8b80" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.BooleanArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Boolean%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.BooleanArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Boolean%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.BooleanArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Boolean%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.BooleanArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Boolean%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="eedbdd10c9e0460e29309d06089006e375ac1524" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Byte%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Byte%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Byte%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Byte%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="d04ad6c29405e360d504c0484cb821e4b7cdba40" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.CharArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Char%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.CharArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Char%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.CharArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Char%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.CharArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Char%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="9300614531c5faad8417c38c3807a8958fcca8d3" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.DoubleArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Double%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.DoubleArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Double%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.DoubleArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Double%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.DoubleArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Double%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="bbfb3cfb0bb6b45869d1c0d2e8b792cc6c6e1d0e" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.FloatArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Float%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.FloatArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Float%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.FloatArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Float%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.FloatArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Float%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="de2163ecfe98e1dab5b357df8463499f8441fa90" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.IntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Int%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.IntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Int%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.IntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Int%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.IntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Int%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e6a2a3ce71cbd27c3bc7f7bd74565a550623525" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.LongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Long%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.LongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Long%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.LongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Long%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.LongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Long%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="7ee6675801a2685a51bef36ec4fae47a8f24dc5b" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Short%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Short%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Short%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.Short%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="82ecab0e80917b6717ae82989f4221409eb9b3a1" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UByte%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UByte%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UByte%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UByteArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UByte%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="886f394ca69291a9fbedb65748a0bef3abd60318" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UIntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UInt%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UIntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UInt%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UIntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UInt%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UIntArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UInt%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="793bb61c1b9580eb3f2b9fdc6e44752975fb3df5" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ULongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.ULong%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ULongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.ULong%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ULongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.ULong%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.ULongArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.ULong%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="810b5671858987b8e81ba9d528fb2e7adaa56b6b" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UShort%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UShort%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UShort%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.UShortArray%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.UShort%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="46b147ecd01a7992c75b767dbdf9a536e5f9ec8d" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.collections.Iterable%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.collections.Iterable%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.collections.Iterable%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold#kotlin.collections%24fold%28kotlin.collections.Iterable%28%28kotlin.collections.fold.T%29%29%2C+kotlin.collections.fold.R%2C+kotlin.Function2%28%28kotlin.collections.fold.R%2C+kotlin.collections.fold.T%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="91889b35d06dfea59afaa75a6ca8578533d73df4" translate="yes" xml:space="preserve">
          <source>Accumulates value starting with &lt;a href=&quot;../../kotlin.collections/fold-indexed#kotlin.collections%24foldIndexed%28kotlin.Array%28%28kotlin.collections.foldIndexed.T%29%29%2C+kotlin.collections.foldIndexed.R%2C+kotlin.Function3%28%28kotlin.Int%2C+kotlin.collections.foldIndexed.R%2C+kotlin.collections.foldIndexed.T%2C+%29%29%29%2Finitial&quot;&gt;initial&lt;/a&gt; value and applying &lt;a href=&quot;../../kotlin.collections/fold-indexed#kotlin.collections%24foldIndexed%28kotlin.Array%28%28kotlin.collections.foldIndexed.T%29%29%2C+kotlin.collections.foldIndexed.R%2C+kotlin.Function3%28%28kotlin.Int%2C+kotlin.collections.foldIndexed.R%2C+kotlin.collections.foldIndexed.T%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt; from left to right to current accumulator value and each element with its index in the original array.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/fold-indexed#kotlin.collections%24foldIndexed%28kotlin.Array%28%28kotlin.collections.foldIndexed.T%29%29%2C+kotlin.collections.foldIndexed.R%2C+kotlin.Function3%28%28kotlin.Int%2C+kotlin.collections.foldIndexed.R%2C+kotlin.collections.foldIndexed.T%2C+%29%29%29%2Finitial&quot;&gt;초기&lt;/a&gt; 값부터 시작하여 왼쪽에서 오른쪽으로 현재 누산기 값과 원래 배열의 인덱스가있는 각 요소에 &lt;a href=&quot;../../kotlin.collections/fold-indexed#kotlin.collections%24foldIndexed%28kotlin.Array%28%28kotlin.collections.foldIndexed.T%29%29%2C+kotlin.collections.foldIndexed.R%2C+kotlin.Function3%28%28kotlin.Int%2C+kotlin.collections.foldIndexed.R%2C+kotlin.collections.foldIndexed.T%2C+%29%29%29%2Foperation&quot;&gt;연산&lt;/a&gt; 을 적용 합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
