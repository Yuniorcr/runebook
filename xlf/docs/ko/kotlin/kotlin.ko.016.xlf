<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="bc555107bc3ab29b699e3ac57e1fb75bce2155ce" translate="yes" xml:space="preserve">
          <source>Kotlin/JS is also compatible with the most common module systems: UMD, CommonJS, and AMD. Being able to &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;produce and consume modules&lt;/a&gt; means that you can interact with the JavaScript ecosystem in a structured manner.</source>
          <target state="translated">Kotlin / JS는 가장 일반적인 모듈 시스템 인 UMD, CommonJS 및 AMD 와도 호환됩니다. &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;모듈&lt;/a&gt; 을 생성하고 사용할 수 있다는 것은 구조화 된 방식으로 JavaScript 생태계와 상호 작용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="73e221948b2977f48bf5440d552a61a97802b3f2" translate="yes" xml:space="preserve">
          <source>Kotlin/JS provides the ability to transpile your Kotlin code, the Kotlin standard library, and any compatible dependencies to JavaScript. The current implementation of Kotlin/JS targets &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5&lt;/a&gt;.</source>
          <target state="translated">Kotlin / JS는 Kotlin 코드, Kotlin 표준 라이브러리, 호환되는 모든 종속성을 자바 스크립트로 트랜스 파일하는 기능을 제공합니다. Kotlin / JS의 현재 구현은 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5를&lt;/a&gt; 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="e161bf22c4b5c5951be23fef6f0ff257426ebe17" translate="yes" xml:space="preserve">
          <source>Kotlin/JS, Today and Tomorrow</source>
          <target state="translated">Kotlin / JS, 오늘과 내일</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="629649c3a6fde50e4105c70afe705d63afa55224" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM (IR-based)</source>
          <target state="translated">Kotlin / JVM (IR 기반)</target>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin / 네이티브 &lt;a href=&quot;native/platform_libs&quot;&gt;라이브러리&lt;/a&gt; 는 프로젝트간에 Kotlin 코드를 공유하는 데 도움이됩니다. POSIX, gzip, OpenGL, Metal, Foundation 및 기타 많은 인기있는 라이브러리 및 Apple 프레임 워크가 사전 가져 오기되어 Kotlin / Native 라이브러리로 컴파일러 패키지에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin / Native Gradle 플러그인</target>
        </trans-unit>
        <trans-unit id="c83dbff85c7c1cfb09790c18b941a770c8cb6d04" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime</source>
          <target state="translated">Kotlin / 네이티브 런타임</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">코 틀린 / 네이티브 런타임 선언</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / Native는 Apple 기술과 긴밀하게 통합되어 있습니다. &lt;a href=&quot;apple-framework&quot;&gt;애플 프레임 워크로 코 틀린 / 기본&lt;/a&gt; 튜토리얼은 스위프트와 목표 - C를위한 프레임 워크로 코 틀린 코드를 컴파일하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 Objective-C 및 Swift와 긴밀하게 통합되어 있습니다. &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native에서 Apple Framework&lt;/a&gt; 튜토리얼 로 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">다이나믹 라이브러리로서의 Kotlin / Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">애플 프레임 워크로서 Kotlin / Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native는 macOS, Windows, Linux 및 &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS를&lt;/a&gt; 포함하되 이에 국한되지 않는 많은 &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;대상&lt;/a&gt; 및 응용 프로그램에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공 되며이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공됩니다 . 이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 이에 대한 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공됩니다 . 이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 이에 대한 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에 있습니다. C의 API 매핑을 시도하는 가장 빠른 방법은 모든 C 선언하는 것입니다 &lt;code&gt;interop.def&lt;/code&gt; 의 어떤 생성하지 않고, 파일을 &lt;code&gt;.h&lt;/code&gt; 의 &lt;code&gt;.c&lt;/code&gt; 인 모든에서 파일을. 그런 다음 특수 &lt;code&gt;---&lt;/code&gt; 구분 기호 행 다음에 &lt;code&gt;interop.def&lt;/code&gt; 파일 에 C 선언을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin / Native 컴파일러는 우리가 보유한 Kotlin 코드에서 동적 라이브러리를 생성 할 수 있습니다. 동적 라이브러리는 헤더 파일 인 &lt;code&gt;.h&lt;/code&gt; 파일 과 함께 제공 되며 C에서 컴파일 된 코드를 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin / Native 컴파일러는 Kotlin 코드에서 macOS 및 iOS 용 프레임 워크를 생성 할 수 있습니다. 작성된 프레임 워크에는 Objective-C 및 Swift와 함께 사용하는 데 필요한 모든 선언 및 이진이 포함되어 있습니다. 기술을 이해하는 가장 좋은 방법은 직접 시도해 보는 것입니다. 작은 Kotlin 라이브러리를 먼저 만들어 Objective-C 프로그램에서 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">코 틀린 / 네이티브 네이티브</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Native는 Objective-C 및 Swift 언어와 양방향 상호 운용성이 있습니다. Kotlin 객체는 Objective-C / Swift 참조 카운팅과 통합됩니다. 사용하지 않은 Kotlin 개체는 자동으로 제거됩니다. &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;목표 - C 상호 운용성의&lt;/a&gt; 기사는 상호 운용성 구현 세부 사항에 대한 자세한 정보가 포함되어 있습니다. 물론 기존 프레임 워크를 가져와 Kotlin에서 사용할 수 있습니다. Kotlin / Native는 사전에 가져온 시스템 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native에는 가비지 콜렉션이 있지만 C 언어의 Kotlin 오브젝트를 처리하는 데 도움이되지 않습니다. Kotlin / Native는 Objective-C 및 Swift와 상호 운용되며 참조 카운터와 통합됩니다. &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;목표 - C 상호 운용성의&lt;/a&gt; 문서 문서에서는에 대한 자세한 내용이 포함되어 있습니다. 또한 &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native&lt;/a&gt; 튜토리얼 이 Apple Framework로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Native는 엄격한 변경 가능성 검사를 구현하여 해당 시점에서 단일 스레드에서 객체를 변경할 수 없거나 액세스 할 수 있다는 중요한 불변성을 보장합니다 ( &lt;code&gt;mutable XOR global&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Swift 및 Objective-C와의 Kotlin / Native interop은 &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;문서&lt;/a&gt; 기사 에서 다룹니다 . 또한 &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native에서 Apple Framework&lt;/a&gt; 튜토리얼 과 동일한 주제를 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">코 틀린 / 네이티브 상호 운용성</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Swift / Objective-C와의 Kotlin / Native 상호 운용성</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Native는 Kotlin 코드를 가상 머신없이 실행할 수있는 원시 바이너리로 컴파일하는 기술입니다. 그것은이다 &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; 코 틀린 컴파일러와 코 틀린 표준 라이브러리의 기본 구현을위한 백엔드를 기반으로.</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native는 현재 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;작업 중&lt;/a&gt; 입니다. Kotlin을 VM없이 실행할 수있는 기본 코드로 컴파일합니다. Technology Preview가 릴리스되었지만 아직 프로덕션 준비가되지 않았으며 1.0을 지원할 모든 플랫폼을 아직 대상으로하지 않습니다. 자세한 내용은 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;Kotlin / Native를 알리는 블로그 게시물을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Native는 주로 임베디드 장치 또는 iOS와 같이 &lt;em&gt;가상 머신&lt;/em&gt; 이 바람직하지 않거나 불가능한 플랫폼에 대한 컴파일을 허용하도록 설계되었습니다 . 개발자가 추가 런타임 또는 가상 머신을 요구하지 않는 자체 포함 된 프로그램을 생성해야하는 상황을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">코 틀린 / 네이티브 도서관</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin / Native 라이브러리는 사전 정의 된 디렉토리 구조를 포함하는 zip 파일이며 다음과 같은 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Kotlin / Native 플러그인에는 최신 버전의 Gradle이 필요합니다. &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; 를 패치 하고 다음 &lt;code&gt;distrubutionUrl&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Native는 Objective-C / Swift와 양방향 상호 운용성을 제공합니다. Kotlin 코드에서 Objective-C 프레임 워크 및 라이브러리를 사용할 수 있습니다. Kotlin 모듈은 Swift / Objective-C 코드에서도 사용할 수 있습니다. 그 외에도 Kotlin / Native에는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop이&lt;/a&gt; 있습니다. 자세한 내용 은 &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native as a Dynamic Library&lt;/a&gt; 자습서도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Native는 Objective-C와 양방향 상호 운용성을 제공합니다. 빌드로 올바르게 가져온 경우 Objective-C 프레임 워크 및 라이브러리를 Kotlin 코드에서 사용할 수 있습니다 (기본적으로 시스템 프레임 워크를 가져옵니다). &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle 플러그인 문서의&lt;/a&gt; &quot;cinterop 사용&quot;을 참조하십시오 . API가 &lt;code&gt;@objc&lt;/code&gt; 를 사용 하여 Objective-C로 내보내지면 Kotlin 코드에서 Swift 라이브러리를 사용할 수 있습니다 . Pure Swift 모듈은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70a326aefb047308c0a09cf46a7be9e9cca8e58e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides integration with the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;. You can add dependencies on Pod libraries stored in the CocoaPods repository or locally as well as use a multiplatform project with native targets as a CocoaPods dependency (Kotlin Pod).</source>
          <target state="translated">Kotlin / Native는 &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods 종속성 관리자&lt;/a&gt; 와의 통합을 제공합니다 . CocoaPods 저장소 또는 로컬에 저장된 Pod 라이브러리에 대한 종속성을 추가 할 수있을뿐만 아니라 CocoaPods 종속성 (Kotlin Pod)으로 네이티브 대상이있는 다중 플랫폼 프로젝트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Native는 표준 C 라이브러리를 사용할 수있는 기능을 제공하여 필요한 거의 모든 기능이 포함 된 전체 기능 에코 시스템을 개방합니다. 실제로 Kotlin / Native는 이미 표준 라이브러리와 공통된 기능을 추가로 제공하는 사전 빌드 된 &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;플랫폼 라이브러리&lt;/a&gt; 세트 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin / Native 런타임은 상호 배타적 인 코드 블록과 조건 변수를 가진 고전적인 스레드 지향 동시성 모델을 권장하지 않습니다.이 모델은 오류가 발생하기 쉽고 신뢰할 수 없습니다. 대신, 하드웨어 동시성을 사용하고 블로킹 IO를 구현할 수있는 대체 접근 방식 모음을 제안합니다. 이러한 접근 방식은 다음과 같으며 추가 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">코 틀린 / 네이티브 소스 및 예제</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin / 기본 소스 및 예 (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin / 기본 소스 및 예 (.zip)</target>
        </trans-unit>
        <trans-unit id="5729c05577d9982b3fa36c76507104ea69c51357" translate="yes" xml:space="preserve">
          <source>Kotlin/Native standard library provides primitives for safe working with concurrently mutable data, namely &lt;code&gt;AtomicInt&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt;, &lt;code&gt;AtomicNativePtr&lt;/code&gt;, &lt;code&gt;AtomicReference&lt;/code&gt; and &lt;code&gt;FreezableAtomicReference&lt;/code&gt; in the package &lt;code&gt;kotlin.native.concurrent&lt;/code&gt;. Atomic primitives allows concurrency-safe update operations, such as increment, decrement and compare-and-swap, along with value setters and getters. Atomic primitives are considered always frozen by the runtime, and while their fields can be updated with the regular &lt;code&gt;field.value += 1&lt;/code&gt;, it is not concurrency safe. Value must be be changed using dedicated operations, so it is possible to perform concurrent-safe global counters and similar data structures.</source>
          <target state="translated">코 틀린 / 기본 표준 라이브러리는 동시에 가변 데이터, 즉와 안전한 작업을위한 기본 요소 제공 &lt;code&gt;AtomicInt&lt;/code&gt; , &lt;code&gt;AtomicLong&lt;/code&gt; , &lt;code&gt;AtomicNativePtr&lt;/code&gt; , &lt;code&gt;AtomicReference&lt;/code&gt; 및 &lt;code&gt;FreezableAtomicReference&lt;/code&gt; 패키지에 &lt;code&gt;kotlin.native.concurrent&lt;/code&gt; 을 . 원자 적 프리미티브는 값 설정자 및 게터와 함께 증가, 감소 및 비교 및 ​​교환과 같은 동시성 안전한 업데이트 작업을 허용합니다. 원자 적 기본 요소는 런타임에 의해 항상 고정 된 것으로 간주되며 해당 필드는 일반 필드로 업데이트 될 수 있습니다. &lt;code&gt;field.value += 1&lt;/code&gt; , 동시성이 안전하지 않습니다. 전용 연산을 사용하여 값을 변경해야하므로 동시 안전 글로벌 카운터 및 유사한 데이터 구조를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / Native는 C interop도 지원합니다. 이를위한 &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native를 동적 라이브러리&lt;/a&gt; 학습서로 확인하거나 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; 문서 기사를보십시오.</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin / Native는 다음 플랫폼을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin / Native는 기본 세계와 양방향 상호 운용성을 지원합니다. 한편으로 컴파일러는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">코 틀린 / 네이티브 대상 사전 설정 ( 아래 &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;참고&lt;/a&gt; 참조) :</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin / Native 대상에는 추가 테스트 종속성이 필요하지 않으며 &lt;code&gt;kotlin.test&lt;/code&gt; API 구현이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Native는 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 통해 &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; 빌드 시스템을 사용합니다 . 아래에서 Gradle 빌드를 구성하는 방법을 살펴 보겠습니다. 일부 경우에는 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHub&lt;/a&gt; 의 Kotlin 릴리스 페이지에서 Kotlin / Native 컴파일러를 수동으로 얻을 수 있습니다 (권장되지 않음) . 튜토리얼에서는 Gradle 빌드 사용에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConf Spinner 앱</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf 앱</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">람다 식 및 익명 함수</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">람다 식 구문</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">Lambda 표현식과 익명 함수는 '함수 리터럴'입니다. 즉 선언되지 않았지만 즉시 표현식으로 전달되는 함수입니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">Lambda 표현식과 익명 함수를 통칭하여 &lt;em&gt;함수 리터럴&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">수신자 유형이 컨텍스트에서 유추 될 수있는 경우 수신자가있는 함수 리터럴로 Lambda 표현식을 사용할 수 있습니다. 사용법의 가장 중요한 예 중 하나는 &lt;a href=&quot;type-safe-builders&quot;&gt;유형 안전 빌더입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">람다 형식</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">람다 매개 변수</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">람다 결과</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">언어 설정</target>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">소스 세트의 언어 설정은 IDE에서 소스를 분석하는 방법에 영향을줍니다. 현재 제한 사항으로 인해 Gradle 빌드에서는 컴파일 기본 소스 세트의 언어 설정 만 사용되며 컴파일에 참여하는 모든 소스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">늦은 초기 속성 및 변수</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit 최상위 특성 및 로컬 변수</target>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">게으른 비동기 시작</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">게으른 속성</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">코 틀린 배우기</target>
        </trans-unit>
        <trans-unit id="802c13534d20e4859719f8999764811676dc2ecd" translate="yes" xml:space="preserve">
          <source>Learn more about coroutines debugging in the &lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;튜토리얼&lt;/a&gt; 에서 코 루틴 디버깅에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">코 틀린 학습</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">EduTools 플러그인으로 Kotlin 학습</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">다른 옵션은 기본값으로두고 &lt;strong&gt;Finish를&lt;/strong&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">&lt;code&gt;fizz&lt;/code&gt; 와 &lt;code&gt;buzz&lt;/code&gt; 의 두 문자열 제작자를 보자 . 이 &lt;code&gt;fizz&lt;/code&gt; 는 300 ms마다 &quot;Fizz&quot;문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d5d7818bcabda3185325fd62a8d08d65a192e5b3" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">100 개의 코 루틴이 모두 동일한 작업을 천 번 수행하도록합시다. 추가 비교를 위해 완료 시간도 측정합니다.</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">모두 같은 행동을 천 번 수행하는 백 코 루틴을 시작합시다. 또한 추가 비교를 위해 완료 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">상황, 아동 및 직업에 대한 지식을 함께합시다. 애플리케이션에 수명주기가있는 객체가 있지만 해당 객체가 코 루틴이 아니라고 가정합니다. 예를 들어, Android 애플리케이션을 작성하고 Android 활동의 컨텍스트에서 다양한 코 루틴을 시작하여 데이터를 가져오고 업데이트하기 위해 비동기 작업을 수행하고 애니메이션을 수행하는 등의 작업을 수행해야합니다. 메모리 누수를 방지하기 위해 이러한 코 루틴을 모두 제거해야 활동이 중단됩니다 . 물론 활동과 코 루틴 라이프 사이클을 연결하기 위해 컨텍스트와 작업을 수동으로 조작 할 수 있지만 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 는 다음을 캡슐화하는 추상화를 제공합니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . 모든 코 루틴 빌더는 확장으로 선언되므로 코 루틴 범위에 대해 이미 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f1725d0b230accb8eeb7b1ecce985617d4f3a5c" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction encapsulating that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">상황, 아동 및 직업에 대한 지식을 함께 모 읍시다. 애플리케이션에 수명주기가있는 객체가 있지만 해당 객체가 코 루틴이 아니라고 가정합니다. 예를 들어, Android 애플리케이션을 작성하고 Android 활동 컨텍스트에서 다양한 코 루틴을 실행하여 데이터를 가져오고 업데이트하고 애니메이션을 수행하는 등의 비동기 작업을 수행합니다. 이러한 모든 코 루틴은 메모리를 피하기 위해 활동이 파괴 될 때 취소되어야합니다. 누출. 물론 우리는 컨텍스트와 작업을 수동으로 조작하여 액티비티와 코 루틴의 라이프 사이클을 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 수 있지만 kotlinx.coroutines 는이를 캡슐화하는 추상화를 제공합니다 : &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . 모든 코 루틴 빌더는 확장으로 선언되어 있으므로 코 루틴 범위에 이미 익숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">우리가 그것을 일곱 번 모두 실행합시다 :</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">무작위 지연으로 12 가지를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;비동기&lt;/a&gt; 예제를 사용하여 Concurrent를 가져 와서 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 과 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를 동시에 수행 하고 결과의 합계를 반환 하는 함수를 추출 합시다 . 때문에 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 에 대한 확장으로 정의 빌더 코 루틴 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; 우리는 범위에 있고 그 무엇을 필요 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope의&lt;/a&gt; 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="bcdef397c512533845238594a2c065ab9f9b9332" translate="yes" xml:space="preserve">
          <source>Let us take the &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder is defined as an extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;, we need to have it in the scope and that is what the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; 예제를 사용하여 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 및 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를 동시에 수행 하고 결과의 합계를 반환 하는 함수를 추출해 보겠습니다 . &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 코 루틴 빌더는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; 의 확장으로 정의 되기 때문에 범위에 있어야하며 이것이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 함수가 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">지연된 문자열 값의 채널을 소비하고 수신 된 각 지연된 값을 대기하지만 다음 지연된 값이 도달하거나 채널이 닫힐 때까지만 채널 생성기 함수를 작성해 봅시다. 이 예제는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; 절을 동일한 &lt;code&gt;select&lt;/code&gt; 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">기본 채널의 소비자가 따라갈 수없는 경우 값을 &lt;code&gt;side&lt;/code&gt; 채널 로 보내는 정수 생산자의 예를 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">코 루틴이 실제로 병렬로 실행되는지 확인합시다. 각 &lt;code&gt;async&lt;/code&gt; 1 초 &lt;code&gt;delay()&lt;/code&gt; 을 추가 하면 결과 프로그램은 1,000,000 초 (11,5 일 이상) 동안 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">위의 코드에서 &lt;code&gt;preparePost&lt;/code&gt; 는 오래 실행되는 프로세스이며 결과적으로 사용자 인터페이스를 차단 한다고 가정합니다 . 우리가 할 수있는 일은 별도의 스레드에서 시작하는 것입니다. 그러면 UI가 차단되는 것을 피할 수 있습니다. 이것은 매우 일반적인 기술이지만 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Objective-C에서 프레임 워크를 호출 해 봅시다. 이를 위해 다음 내용으로 &lt;code&gt;main.m&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Kotlin 라이브러리의 C API를 확인하십시오 .`</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 실행 구성을 클릭하여 프로젝트가 실제 Android 장치 또는 에뮬레이터에서 실행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Xcode 에서 &lt;em&gt;Run&lt;/em&gt; 버튼을 클릭하면 응용 프로그램이 실행되는 것을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">하자가 생성 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; C 원시 형 선언은 코 틀린에서 볼 수 있습니다 방법을 보려면 다음과 같은 내용으로 스텁 파일 :</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">Kotlin에서 C 선언이 어떻게 보이는지 확인하기 위해 다음 내용으로 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 스텁 파일을 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; 객체를 유지하면서 백만 개의 코 루틴을 다시 만들어 봅시다 . 이제 우리는 코 루틴에서 추가 할 숫자를 반환 할 수 있으므로 원자 카운터에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">하자는 클래스 생성 &lt;code&gt;Base64Test&lt;/code&gt; 에 &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; 폴더를 Base64로에 대한 기본 테스트를 작성.</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">이런 식으로 함수 f (x)를 표시해 봅시다. x에 1을 더한 다음 결과 숫자에 적어도 하나의 후행 0이있는 동안 해당 0을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">그것이 무엇을 의미하는지 조금 파헤쳐 봅시다. 코 루틴의 가장 큰 장점은 실을 막지 않고 &lt;em&gt;중단&lt;/em&gt; 할 수 있다는 것 입니다. 컴파일러는이를 가능하게하기 위해 특수 코드를 생성해야하므로 코드에서 명시 적으로 &lt;em&gt;일시 중단 될 수있는&lt;/em&gt; 함수를 표시 해야합니다. 우리는 사용 &lt;code&gt;suspend&lt;/code&gt; 그것에 대한 수정 :</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 안의 코드 블록을 별도의 함수로 추출해 봅시다 . 이 코드에서 &quot;추출 기능&quot;리팩토링을 수행하면 &lt;code&gt;suspend&lt;/code&gt; 수정자를 사용 하여 새로운 기능을 얻게 됩니다. 이것이 첫 번째 &lt;em&gt;일시 중단 기능&lt;/em&gt; 입니다. 서 스펜 딩 함수는 일반 함수처럼 코 루틴 내에서 사용할 수 있지만 추가 기능은 이 예제의 &lt;code&gt;delay&lt;/code&gt; 과 같은 다른 서 스펜 딩 함수를 사용 하여 코 루틴 실행 을 &lt;em&gt;일시 중단&lt;/em&gt; 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61bad05f01a2e90a1664c7ea21ea22130405aa4e" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code, you get a new function with the &lt;code&gt;suspend&lt;/code&gt; modifier. This is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions (like &lt;code&gt;delay&lt;/code&gt; in this example) to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 내부의 코드 블록을 별도의 함수로 추출해 보겠습니다 . 이 코드에서 &quot;Extract function&quot;리팩토링을 수행하면 &lt;code&gt;suspend&lt;/code&gt; modifier 가있는 새 함수가 생성 됩니다. 이것은 첫 번째 &lt;em&gt;일시 중단 기능&lt;/em&gt; 입니다. 일시 중단 함수는 일반 함수와 마찬가지로 코 루틴 내부에서 사용할 수 있지만 추가 기능은 다른 일시 중단 함수 ( 이 예에서 &lt;code&gt;delay&lt;/code&gt; 과 같은 )를 사용 하여 코 루틴의 실행 을 &lt;em&gt;일시 중단&lt;/em&gt; 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">먼저 프로젝트 폴더를 만들어 봅시다. 이 자습서의 모든 경로는이 폴더를 기준으로합니다. 때때로 새 파일을 추가하기 전에 누락 된 디렉토리를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">이것을 &lt;code&gt;.kt&lt;/code&gt; 확장자를 가진 파일로 바로 입력 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; 프로젝트에서 Android 프로젝트 로의 종속성을 포함시킵니다 . &lt;code&gt;app/build.gradle&lt;/code&gt; 파일 을 패치하고 다음 행을 &lt;code&gt;dependencies { .. }&lt;/code&gt; 블록에 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">외부 라이브러리 인 &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt; 에서 구현 된 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 를 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;launch&lt;/code&gt; 를 사용하는 전체 프로그램을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">무엇이 바뀌 었는지 찾아 보도록하겠습니다. Java에서는 필드에 주석을 달고 해당 뷰와 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">iPhone 에뮬레이터 또는 장치에서 응용 프로그램을 실행할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더로 옮깁니다 . 이것이 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인이 사용될 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트가 동적 또는 공유 라이브러리를 생성하도록 구성합니다.</target>
        </trans-unit>
        <trans-unit id="254d91019bfe0a24fa67828566bb23aeecf078e8" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더 로 이동하겠습니다 . &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 사용할 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트를 구성하여 동적 또는 공유 라이브러리를 생성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더로 옮깁니다 . &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 사용할 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트가 동적 또는 공유 라이브러리를 생성하도록 지시하고 구성합니다.</target>
        </trans-unit>
        <trans-unit id="034d9c3c346b06a98e0db9b883376985d9d3fdc3" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더 로 이동하겠습니다 . &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 사용할 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 동적 또는 공유 라이브러리를 생성하도록 프로젝트를 지시하고 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">의 교체하자 &lt;code&gt;testSolution()&lt;/code&gt; 는 다음과 기능의 콘텐츠를 :</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">그들을 많이 봅시다</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradle 태스크를 실행하여 &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE&lt;/a&gt; 에서 라이브러리를 빌드 하거나 다음 콘솔 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="106249141867c6b57bd6484ccdc821cb560f7f5d" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradle 작업을 실행하여 &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt; 에서 라이브러리를 빌드 하거나 다음 콘솔 명령을 호출 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="0027507ed05fb5770a6709f41c759d4f8b675c55" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library in the IDE or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradle 작업을 실행하여 IDE에서 라이브러리를 빌드하거나 다음 콘솔 명령을 호출 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">간단한 ORM을 작성한다고 가정 해 봅시다. 데이터베이스 라이브러리는 주어진 열에서 유형이 지정된 값을 가져 오기위한 &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; 및 &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; 과 같은 함수를 사용하여 &lt;code&gt;Entity&lt;/code&gt; 클래스의 인스턴스로 행을 나타냅니다 . 다음과 같이 유형이 지정된 래퍼 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">함수에서 두 가지를 반환해야한다고 가정 해 봅시다. 예를 들어 결과 개체와 일종의 상태가 있습니다. Kotlin에서이를 수행하는 간단한 방법은 &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;데이터 클래스&lt;/em&gt;&lt;/a&gt; 를 선언하고 해당 인스턴스를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;object&lt;/code&gt; 가 Objective-C와 Swift에 어떻게 매핑 되는지 봅시다 . 생성 된 &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 파일에는 &lt;code&gt;Class&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt; 에 대한 정확한 정의가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">이제 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 가 먼저 포인터로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">표에있는 내용을 요약 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Android Studio로 다시 전환 하고 &lt;em&gt;Gradle&lt;/em&gt; 도구 창 에서 &lt;code&gt;SharedCode&lt;/code&gt; 프로젝트 의 &lt;code&gt;build&lt;/code&gt; 대상을 실행하겠습니다 . 이 작업은 Xcode 빌드에서 설정 한 환경 변수를 찾고 올바른 프레임 워크 변형을 &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; 폴더에 복사합니다. 그런 다음 해당 폴더의 프레임 워크를 빌드에 포함시킵니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">Kotlin 런타임 선언을 먼저 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">구체적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;kotlin.root.example&lt;/code&gt; 필드를 살펴보면 Kotlin 코드의 패키지 구조와 &lt;code&gt;kotlin.root.&lt;/code&gt; 모방합니다 . 접두사.</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; 과 &lt;code&gt;Sequence&lt;/code&gt; 의 차이점을 예제로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; 와 &lt;code&gt;MyUnion&lt;/code&gt; 을 매개 변수 로 사용하는 생성 된 함수를 살펴 보겠습니다 . &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; 매개 변수는 kotlinx.cinterop.CValue &amp;lt;T&amp;gt; 로 표시됩니다 . 그리고 입력 된 포인터 매개 변수의 경우 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 됩니다. Kotlin은 두 유형을 쉽게 처리 할 수있는 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">코 루틴 파이프 라인을 사용하여 소수를 생성하는 예제를 통해 파이프 라인을 최대한 활용 해 봅시다. 우리는 무한한 숫자 시퀀스로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">코 루틴으로 동일하게 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">Kotlin의 API를 사용해 봅시다. 먼저 &lt;code&gt;pass_string&lt;/code&gt; 을 호출 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">이를 구현하고 IDE를 구성하기 위해 Gradle 스크립트를 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">의 채널을 함께 사용하자 에 &quot;Hello&quot;문자열을 네 번 채널 생성 &lt;code&gt;b&lt;/code&gt; 네 번 &quot;세계&quot;를 생성합니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">인터페이스와 해당 구현을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Kotlin에서 형식 안전 빌더를 구현하는 메커니즘을 살펴 보겠습니다. 우선, 빌드하려는 모델을 정의해야합니다.이 경우 HTML 태그를 모델링해야합니다. 많은 클래스로 쉽게 수행됩니다. 예를 들어 &lt;code&gt;HTML&lt;/code&gt; 은 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 태그 를 설명하는 클래스입니다 . 즉 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 와 같은 자식을 정의합니다 . ( &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;아래&lt;/a&gt; 선언 참조 )</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="00f72e56b5ae78fda32dcd4978d25a113af870e2" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">라이브러리 작성자는 @Deprecated 및 &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; 주석을 사용하여 API 표면의 진화를 제어 할 수 있습니다 . @Deprecated (level = HIDDEN)는 API에서 제거 된 선언의 경우에도 바이너리 호환성을 유지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">라이브러리 작성자는 @Deprecated 및 @Experimental 주석을 사용하여 API 표면의 진화를 제어 할 수 있습니다. @Deprecated (level = HIDDEN)를 사용하여 API에서 제거 된 선언의 경우에도 이진 호환성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">라이브러리 코드는 항상 반환 유형의 퍼블릭 / 보호 함수 및 속성을 명시 적으로 지정해야하므로 퍼블릭 API의 타입 유추에 의존하지 않습니다. 형식 유추의 미묘한 변경으로 인해 반환 형식이 실수로 변경되어 이진 호환성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">도서관 검색 순서</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Kotlin 주석 기능에 대한 라이브러리 지원</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Java와 마찬가지로 Kotlin의 제네릭은 런타임에 유지되지 않습니다. 즉 객체는 생성자에 전달 된 실제 유형 인수에 대한 정보를 전달하지 않습니다. 즉 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; 는 &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; 구별 할 수 없습니다 . 이것은 불가능 수행하기가 만드는 &lt;em&gt;것입니다&lt;/em&gt; 계정으로 제네릭을 -checks. 단지 수 있습니다 코 틀린은 &lt;em&gt;이다&lt;/em&gt; 스타 투영 일반적인 유형의 -checks :</target>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Python과 마찬가지로 Kotlin의 함수는 일류 값입니다. 변수에 할당하고 매개 변수로 전달할 수 있습니다. &lt;em&gt;함수 유형&lt;/em&gt; 은 &lt;em&gt;함수 유형&lt;/em&gt; 이며 괄호로 묶은 매개 변수 유형 목록과 리턴 유형에 대한 화살표로 표시됩니다. 이 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">파이썬에서와 같이 문장은 세미콜론으로 끝날 수 있지만 권장하지 않습니다. 줄 연속 문자가 없습니다. 대신 코드가 올바르게 구문 분석 할 수있는 유일한 방법 인 경우 하나 이상의 후속 행과 함께 행이 자동으로 결합됩니다. 실제로 이것은 파이썬에서와 같이 열린 괄호 안에 있거나 줄이 &quot;댕글 링 연산자&quot;(파이썬에서와 달리)로 끝나거나 다음 줄이 그렇지 않으면 다음 줄에서 계속됩니다. 이전과 결합되지 않은 경우 구문 분석하십시오 (Python과 달리). 이것은 &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;JavaScript&lt;/a&gt; 와 거의 반대입니다 . 결과 코드가 여전히 구문 분석되는 한 일반적으로 줄을 계속 연결합니다. 따라서 다음은 Kotlin과 Python에서 두 가지 표현입니다 ( &lt;code&gt;+&lt;/code&gt; 단항 일 수 있으므로 두 번째 줄은 자체적으로 구문 분석되지만 JavaScript에서는 하나입니다.</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">파이썬에서와 같이 &lt;em&gt;람다 식을&lt;/em&gt; 작성할 수 있습니다 . 호출 가능한 함수 객체로 평가되는 매우 간단한 구문으로 명명되지 않은 함수 선언입니다. Kotlin에서 람다는 여러 명령문을 포함 할 수 있으므로 단일 표현식 람다보다 &lt;a href=&quot;functional-programming#receivers&quot;&gt;복잡한 작업에&lt;/a&gt; 유용합니다 . 마지막 명령문은 표현식이어야하며 결과는 람다의 리턴 값이됩니다 ( &lt;code&gt;Unit&lt;/code&gt; 가 람다 표현식이 지정된 변수 / 매개 변수의 리턴 유형이 아닌 경우 람다는 리턴 값이 없음). 람다 식은 중괄호로 묶고 매개 변수 이름과 가능한 형식을 나열하여 시작합니다 (형식이 컨텍스트에서 유추되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">숫자와 마찬가지로 널 입력 가능 참조가 필요할 때 문자가 상자로 표시됩니다. 복싱 작업으로 ID가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">마찬가지로 멀티 플랫폼 라이브러리가 실험적인 &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle 메타 데이터 게시 모드로 게시&lt;/a&gt; 되고 프로젝트가 메타 데이터도 사용하도록 설정된 경우 공통 소스 세트에 대해 종속성을 한 번만 지정하면 충분합니다. 그렇지 않은 경우, 각 플랫폼 별 소스 세트에는 위에 표시된대로 공통 모듈 외에 라이브러리의 해당 플랫폼 모듈이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">선형 검색</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">라이브러리를 응용 프로그램에 연결</target>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">요소에 연결</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64, arm32, MIPS, MIPS 리틀 엔디안, 라즈베리 파이)</target>
        </trans-unit>
        <trans-unit id="c8306ed1ec95ef01523eab6c3a95dbeb9f6511fb" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</source>
          <target state="translated">Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</target>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPS 대상 ( &lt;code&gt;linuxMips32&lt;/code&gt; 및 &lt;code&gt;linuxMipsel32&lt;/code&gt; )에는 Linux 호스트가 필요합니다. 지원되는 모든 호스트에 다른 Linux 대상을 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux : &lt;code&gt;libnative_api.h&lt;/code&gt; 및 &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">특정 작업 목록</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">목록 요소 (널 포함)는 복제 할 수 있습니다. 목록은 동일한 수의 동일한 객체 또는 단일 객체의 발생을 포함 할 수 있습니다. 동일한 위치에 동일한 크기와 &lt;a href=&quot;equality#structural-equality&quot;&gt;구조적으로 동일한&lt;/a&gt; 요소 가있는 경우 두 목록은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">반복자 목록</target>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">쓰기 작업 목록</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">리스트는 또한 주어진 위치에서 요소를 대체하는 함수를 제공합니다. &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 과 연산자 형태 &lt;code&gt;[]&lt;/code&gt; . &lt;code&gt;set()&lt;/code&gt; 은 다른 요소의 인덱스를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5a0dae9f70ca77cfff82765784d806c80043676" translate="yes" xml:space="preserve">
          <source>Lists and maps also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">목록과 맵은 요소 업데이트 작업도 제공합니다. &lt;a href=&quot;list-operations&quot;&gt;특정 작업 나열&lt;/a&gt; 및 &lt;a href=&quot;map-operations&quot;&gt;특정 작업 매핑&lt;/a&gt; 에서 설명 합니다. 세트의 경우 실제로 요소를 제거하고 다른 요소를 추가하기 때문에 업데이트가 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">목록과 집합은 또한 요소 업데이트를위한 작업을 제공합니다. 이에 대해서는 &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; 및 &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations에&lt;/a&gt; 설명되어 있습니다. 세트의 경우 업데이트는 실제로 요소를 제거하고 다른 요소를 추가하기 때문에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">리스트는 &lt;code&gt;elementAt()&lt;/code&gt; , &lt;code&gt;first()&lt;/code&gt; , &lt;code&gt;last()&lt;/code&gt; 및 &lt;a href=&quot;collection-elements&quot;&gt;단일 요소 검색에&lt;/a&gt; 나열된 기타 요소 검색에 대한 모든 공통 조작을 지원합니다 . 목록에 특정한 것은 요소에 대한 인덱스 액세스이므로 요소를 읽는 가장 간단한 방법은 인덱스로 요소를 검색하는 것입니다. 인수 또는 속기 &lt;code&gt;[index]&lt;/code&gt; 구문으로 전달 된 색인으로 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">리터럴 상수</target>
        </trans-unit>
        <trans-unit id="4da0019bff16f0b757af8c7d691632f05ab7ce73" translate="yes" xml:space="preserve">
          <source>Literal constants</source>
          <target state="translated">리터럴 상수</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">로컬 위임 속성 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">지역 기능</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">지역 주석 클래스</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">지역 선언</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">로컬 위임 속성</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">로컬 함수는 외부 함수의 로컬 변수 (예 : 클로저)에 액세스 할 수 있으므로 위의 경우 &lt;em&gt;방문한&lt;/em&gt; 로컬 변수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81d1a5213298e456992ce397aa51ab435e7f9b2" translate="yes" xml:space="preserve">
          <source>Local functions</source>
          <target state="translated">지역 기능</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">지역 변수</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">지역 변수는 일반적으로 선언하고 변수의 타입이되는 경우에 같은 시간에 초기화 &lt;em&gt;유추&lt;/em&gt; 당신이 초기화 식의 유형으로 :</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">지역 변수, 함수 및 클래스는 가시성 수정자를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">잠금은 단일 스레드 만 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 초기화 할 수 있도록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">로그 : &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;log2&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;ln&lt;/code&gt; , &lt;code&gt;ln1p&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">로고는 &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;여기에서&lt;/a&gt; 다운로드 할 수 있습니다 . 로고를 사용하는 경우 아카이브 및 &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin 브랜드 사용 가이드 &lt;/a&gt; &lt;code&gt;guidelines.pdf&lt;/code&gt; 안에있는 Guidelines.pdf의 간단한 규칙을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">롬복 ( &lt;code&gt;lombok.NonNull&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">Long은 대문자 &lt;code&gt;L&lt;/code&gt; : &lt;code&gt;123L&lt;/code&gt; 로 태그됩니다</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">더 많은 API를 찾고 계십니까? &lt;a href=&quot;../multiplatform-library&quot;&gt;멀티 플랫폼 라이브러리&lt;/a&gt; 를 작성 하고 공유 하기가 쉽습니다 !</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 수신자에게 적용 가능한 매개 변수없이 &lt;code&gt;operator&lt;/code&gt; 수정자를 사용하여 &lt;code&gt;inc()&lt;/code&gt; 함수를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">함수 보인다 &lt;code&gt;unaryPlus()&lt;/code&gt; 와 &lt;code&gt;operator&lt;/code&gt; 개질제 및 수신기에 대한 매개 변수 &lt;code&gt;T&lt;/code&gt; , 즉 멤버 함수 또는 신장 기능;</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">범위의 루프</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">코 루틴 기반 API를 제공하는 라이브러리의 저수준 빌딩 블록.</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">운 좋게도 Kotlin은 &lt;em&gt;유형 매개 변수를 수정&lt;/em&gt; 하여 이러한 문제 중 일부를 완화했습니다. 제네릭 형식 매개 변수 앞에 &lt;code&gt;reified&lt;/code&gt; 를 작성 하면 런타임에 사용할 수 있게되고 &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;클래스 메타 데이터&lt;/a&gt; 를 가져 오기 위해 &lt;code&gt;T::class&lt;/code&gt; 를 작성하게 됩니다. 인라인 함수에서만이 작업을 수행 할 수 있습니다 (인라인 함수는 런타임에 유형 정보 &lt;em&gt;를&lt;/em&gt; 사용할 수 있는 콜 사이트로 컴파일되기 때문에 ). 예를 들어 덜 우아한 서명을 가진 큰 함수에 대해 인라인 랩퍼 함수를 ​​작성할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">맥 OS (x86_64)</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">반환 유형이 &lt;code&gt;Unit&lt;/code&gt; 인지 확인하고 그렇지 않으면 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">CocoaPods가 &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;설치되어&lt;/a&gt; 있는지 확인하십시오 . CocoaPods 1.6.1 이상을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">먼저 &lt;code&gt;kotlin.js&lt;/code&gt; 런타임 을로드 한 다음 애플리케이션 을로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">사용자에게 편안한 새 버전으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Objective-C 디스패치를 ​​통해 Objective-C 클래스의 Kotlin 메소드에 액세스하여 UIKit 또는 AppKit의 제어에 의해 전송 된 조치로 사용되도록합니다.</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Objective-C 디스패치를 ​​통해 Objective-C 클래스의 Kotlin 속성을 IB 콘센트로 사용할 수 있도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Kotlin &lt;code&gt;main&lt;/code&gt; 함수가 호출 된 후 런타임 조회에 Objective-C 클래스의 Kotlin 서브 클래스를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="34b5071a9847a34a44b37d8ab94597a0b604b867" translate="yes" xml:space="preserve">
          <source>Makes the annotated annotation class an associated object key.</source>
          <target state="translated">주석이 달린 주석 클래스를 연관된 객체 키로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">주어진 이름으로 C / C ++ 코드에서 최상위 레벨 기능을 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">계산 코드를 취소 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">빈번한 null 검사는 성가신 일이므로 null 가능성을 허용 해야하는 경우 Kotlin에는 아래에 설명 된 것처럼 null 일 수있는 값을 쉽게 사용할 수있는 몇 가지 매우 유용한 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">잘못된 바이트 시퀀스는 교체 char &lt;code&gt;\uFFFD&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">의존성 관리</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">소스 관리</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">대상 관리</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">수동 구성</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">수동 설치</target>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">많은 최신 IDE가 Kotlin을 지원하고 관용적 인 Kotlin 코드 작성을 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">속성을 통해 많은 옵션을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe81b734a40201fad1b163bd75e5e8866ba447fc" translate="yes" xml:space="preserve">
          <source>Many startups and Fortune 500 companies have already developed Android applications using Kotlin &amp;ndash; see the list at &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;the Google website for Kotlin developers&lt;/a&gt;.</source>
          <target state="translated">많은 신생 기업과 Fortune 500 대 기업이 이미 Kotlin을 사용하여 Android 애플리케이션을 &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;개발했습니다&lt;/a&gt; . Kotlin 개발자 용 Google 웹 사이트 의 목록을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">특정 작업지도</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">널이 아닌 경우 널 입력 가능 값 맵핑</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">지도 쓰기 작업</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap () 및 Map.toMutableMap ()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">C에서 함수 포인터 유형 매핑</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">C에서 함수 포인터 매핑</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">C에서 기본 데이터 유형 매핑</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">C에서 문자열 매핑</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">구조 및 유니온 C 유형 매핑</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">C에서 구조 및 결합 유형 매핑</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 구현이 빠른 인덱스 액세스를 지원함을 나타내는 마커 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 구현이 빠른 인덱스 액세스를 지원함을 나타내는 마커 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">마킹 API 요소</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">실험용 API 마킹</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">표시 규칙 : 암시 적 수신자는 @Ann으로 표시된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d4db1b9cfb765a0420560d33f4c49a590513a4d0" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field as immutable. It is possible to share the value of such property between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">지원 필드가있는 최상위 속성을 변경 불가능으로 표시합니다. 이러한 속성의 값을 여러 스레드간에 공유 할 수는 있지만 깊이 고정되어 해당 상태 또는 참조하는 개체의 상태를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a224cc22214be0edab83e29fa79b9dd2dd10f50f" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">지원 필드 또는 개체가있는 최상위 속성을 스레드 로컬로 표시합니다. 객체는 변경 가능한 상태로 유지되고 상태를 변경할 수 있지만 모든 스레드는이 객체의 고유 한 복사본을 가지므로 한 스레드의 변경 사항이 다른 스레드에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">백킹 필드 또는 객체가있는 최상위 변수를 변경할 수없는 것으로 표시합니다. 이러한 스레드를 여러 스레드간에 공유 할 수는 있지만 완전히 고정되므로 상태 또는 참조하는 개체의 상태를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">백킹 필드 또는 객체를 스레드 로컬로 사용하여 최상위 변수를 표시합니다. 객체는 변경 가능 상태를 유지하고 상태를 변경할 수 있지만 모든 스레드에는이 객체의 고유 한 사본이 있으므로 한 스레드의 변경 사항은 다른 스레드에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">예상되는 주석 클래스를 표시하여 모든 플랫폼에 실제 대응 클래스가 필요하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="e74d580f7febe5c2f5fce47ebee5f4b2a5e537e3" translate="yes" xml:space="preserve">
          <source>Marks experimental JS export annotations.</source>
          <target state="translated">실험적인 JS 내보내기 주석을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">실험 자체의 서명되지 않은 유형 (종종 자체 포함)에 종속 된 API를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">어노테이션이있는 특성의 JVM 백업 필드를 &lt;code&gt;transient&lt;/code&gt; 로 표시 합니다. 이는 오브젝트의 기본 직렬화 된 양식의 일부가 아님을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">어노테이션이있는 특성의 JVM 백업 필드를 &lt;code&gt;volatile&lt;/code&gt; 로 표시합니다. 이는이 필드에 대한 쓰기가 다른 스레드에 즉시 표시됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">어노테이션이있는 함수에서 생성 된 JVM 메소드를 &lt;code&gt;strictfp&lt;/code&gt; 로 표시합니다. 즉, 더 나은 이식성을 달성하려면 메소드 내에서 수행되는 부동 소수점 연산의 정밀도를 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">어노테이션이있는 함수에서 생성 된 JVM 메소드를 &lt;code&gt;synchronized&lt;/code&gt; 된 것으로 표시합니다. 즉, 메소드가 정의 된 인스턴스 (또는 정적 메소드의 경우)의 모니터에 의해 메소드가 여러 스레드에 의해 동시 실행되지 않도록 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">주석이 달린 선언을 더 이상 사용되지 않는 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7d98c397e94ce7053df95bf37d1da503360432a5" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">주석이 달린 선언을 더 이상 사용되지 않음으로 표시합니다. &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt; 와 달리 보고 된 진단의 심각도는 상수 값이 아니지만 사용의 API 버전에 따라 다릅니다 ( 사용이있는 모듈을 컴파일 할 때 &lt;code&gt;-api-version&lt;/code&gt; 인수 의 값 ). API 버전이 &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt; 보다 크거나 같으면 코드에서 선언에 액세스 할 수 없습니다 ( &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt; 수준에서 더 이상 사용되지 않는 것처럼), 그렇지 않으면 API 버전이 &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt; 보다 크거나 같으면 사용법이 표시됩니다. 오류로 ( &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; 와 같이 ), 그렇지 않으면 API 버전이 &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt; 보다 크거나 같은 경우, 사용은 경고로 표시됩니다 ( &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt; 과 같이 ). 그렇지 않으면 주석이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="80f9c066c4fb389bf5a2648a88b9da8d8a5af0b6" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">주석이 달린 선언을 더 이상 사용되지 않음으로 표시합니다. &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt; 와 달리 보고 된 진단의 심각도는 상수 값이 아니지만 사용의 API 버전에 따라 다릅니다 ( 사용이있는 모듈을 컴파일 할 때 &lt;code&gt;-api-version&lt;/code&gt; 인수 의 값 ). API 버전이 &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt; 보다 크거나 같으면 코드에서 선언에 액세스 할 수 없습니다 ( &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt; 수준에서 더 이상 사용되지 않는 것처럼), 그렇지 않으면 API 버전이 &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt; 보다 크거나 같으면 사용법이 표시됩니다. 오류로 ( &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; 와 같이 ), 그렇지 않으면 API 버전이 &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt; 보다 크거나 같은 경우, 사용은 경고로 표시됩니다 ( &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt; 과 같이 ). 그렇지 않으면 주석이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">kotlin-stdlib의 수학 연산</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">수학 함수와 상수.</target>
        </trans-unit>
        <trans-unit id="6af37177e65c1a71744a7cb984d51ba2f07f5140" translate="yes" xml:space="preserve">
          <source>Maven</source>
          <target state="translated">Maven</target>
        </trans-unit>
        <trans-unit id="b522db69b358e8fce0593518fbe3b0d7db36d2d4" translate="yes" xml:space="preserve">
          <source>Maven configuration</source>
          <target state="translated">메이븐 구성</target>
        </trans-unit>
        <trans-unit id="71edee9db1ff5b8ff75c1bfdc3477115c9cadb2f" translate="yes" xml:space="preserve">
          <source>Max value</source>
          <target state="translated">최대 값</target>
        </trans-unit>
        <trans-unit id="6f26174801b4fb329b7b4754a956851117212509" translate="yes" xml:space="preserve">
          <source>Maximum value a version component can have, a constant value 255.</source>
          <target state="translated">버전 구성 요소가 가질 수있는 최대 값, 상수 값 255</target>
        </trans-unit>
        <trans-unit id="258389887a049fd789e8d5c0611eb448fb932cc4" translate="yes" xml:space="preserve">
          <source>MediaDeviceInfo</source>
          <target state="translated">MediaDeviceInfo</target>
        </trans-unit>
        <trans-unit id="6134c6977e97c143c3e4282792a6fe2d4e4a8d3d" translate="yes" xml:space="preserve">
          <source>MediaDeviceKind</source>
          <target state="translated">MediaDeviceKind</target>
        </trans-unit>
        <trans-unit id="42773779c7725a712497e1de443b3526292ee7c5" translate="yes" xml:space="preserve">
          <source>MediaEncryptedEventInit</source>
          <target state="translated">MediaEncryptedEventInit</target>
        </trans-unit>
        <trans-unit id="5e9d9c4423f0ac299fce82e9517c3425a061ddb4" translate="yes" xml:space="preserve">
          <source>MediaError</source>
          <target state="translated">MediaError</target>
        </trans-unit>
        <trans-unit id="edc3252539f2977307059639af16d93b62f83e89" translate="yes" xml:space="preserve">
          <source>MediaKeyMessageEventInit</source>
          <target state="translated">MediaKeyMessageEventInit</target>
        </trans-unit>
        <trans-unit id="0f9940df0a60e74d9f81259c874d8fc5cf90b250" translate="yes" xml:space="preserve">
          <source>MediaKeyMessageType</source>
          <target state="translated">MediaKeyMessageType</target>
        </trans-unit>
        <trans-unit id="f6d29b82c487515b0ed4941f8440be7338b9cdd9" translate="yes" xml:space="preserve">
          <source>MediaKeySessionType</source>
          <target state="translated">MediaKeySessionType</target>
        </trans-unit>
        <trans-unit id="6a72b850014dcb01724de3815824e738f2a289e8" translate="yes" xml:space="preserve">
          <source>MediaKeyStatus</source>
          <target state="translated">MediaKeyStatus</target>
        </trans-unit>
        <trans-unit id="06b28afbee38c4e57833221839b448745bf0272f" translate="yes" xml:space="preserve">
          <source>MediaKeyStatusMap</source>
          <target state="translated">MediaKeyStatusMap</target>
        </trans-unit>
        <trans-unit id="334845d31e06fd797025ffec6b0e947ced1eee27" translate="yes" xml:space="preserve">
          <source>MediaKeySystemAccess</source>
          <target state="translated">MediaKeySystemAccess</target>
        </trans-unit>
        <trans-unit id="13b324678ad4a42d1cf13183ec5703ba89067f0a" translate="yes" xml:space="preserve">
          <source>MediaKeySystemConfiguration</source>
          <target state="translated">MediaKeySystemConfiguration</target>
        </trans-unit>
        <trans-unit id="261d7bee8c2a3f2851483973000c454b56a6d2f7" translate="yes" xml:space="preserve">
          <source>MediaKeySystemMediaCapability</source>
          <target state="translated">MediaKeySystemMediaCapability</target>
        </trans-unit>
        <trans-unit id="04bf6109f69f0241e714dae0a1bff955d8bb5503" translate="yes" xml:space="preserve">
          <source>MediaKeys</source>
          <target state="translated">MediaKeys</target>
        </trans-unit>
        <trans-unit id="0204337f58a70624acab6d8767bba63e305a6319" translate="yes" xml:space="preserve">
          <source>MediaKeysRequirement</source>
          <target state="translated">MediaKeysRequirement</target>
        </trans-unit>
        <trans-unit id="f30d349fe509ab2452d9ff5db776c749eb21115d" translate="yes" xml:space="preserve">
          <source>MediaList</source>
          <target state="translated">MediaList</target>
        </trans-unit>
        <trans-unit id="fb2396dadb0919fa005cf6b516e3b748e938e528" translate="yes" xml:space="preserve">
          <source>MediaProvider</source>
          <target state="translated">MediaProvider</target>
        </trans-unit>
        <trans-unit id="5264b922a464ea5a9f88144f8b72f9626c1db269" translate="yes" xml:space="preserve">
          <source>MediaQueryListEventInit</source>
          <target state="translated">MediaQueryListEventInit</target>
        </trans-unit>
        <trans-unit id="70dcd56d399d2e12aa2533dd163497d5ff6362fd" translate="yes" xml:space="preserve">
          <source>MediaStreamConstraints</source>
          <target state="translated">MediaStreamConstraints</target>
        </trans-unit>
        <trans-unit id="c74168a0d6b99bbcdaff6005366c94dc042ddd9e" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackEventInit</source>
          <target state="translated">MediaStreamTrackEventInit</target>
        </trans-unit>
        <trans-unit id="f6268479064052c02a6fe8b1b48bf8011df3d770" translate="yes" xml:space="preserve">
          <source>MediaStreamTrackState</source>
          <target state="translated">MediaStreamTrackState</target>
        </trans-unit>
        <trans-unit id="10f95ad72ba533133d954c473a07f3f67fdac829" translate="yes" xml:space="preserve">
          <source>MediaTrackCapabilities</source>
          <target state="translated">MediaTrackCapabilities</target>
        </trans-unit>
        <trans-unit id="bb47b7b2d8ef429be15b6e0dad452a4f8b48f974" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraintSet</source>
          <target state="translated">MediaTrackConstraintSet</target>
        </trans-unit>
        <trans-unit id="8054e6c6485f93790f303ed390e1cba5c2743911" translate="yes" xml:space="preserve">
          <source>MediaTrackConstraints</source>
          <target state="translated">MediaTrackConstraints</target>
        </trans-unit>
        <trans-unit id="43ae2bb87ab91212c29f9b3badd22fa54472dcc6" translate="yes" xml:space="preserve">
          <source>MediaTrackSettings</source>
          <target state="translated">MediaTrackSettings</target>
        </trans-unit>
        <trans-unit id="7e941f3e34c1287f6e0e3fa6973fe4daf92e6bf1" translate="yes" xml:space="preserve">
          <source>MediaTrackSupportedConstraints</source>
          <target state="translated">MediaTrackSupportedConstraints</target>
        </trans-unit>
        <trans-unit id="0821090b6a2b08e3c2088bad74f0cd7597a2e61c" translate="yes" xml:space="preserve">
          <source>MemScope</source>
          <target state="translated">MemScope</target>
        </trans-unit>
        <trans-unit id="13754495aca84346deb594b0d23bc4d086989ee4" translate="yes" xml:space="preserve">
          <source>Member Functions</source>
          <target state="translated">멤버 함수</target>
        </trans-unit>
        <trans-unit id="2675e87b859fb2d5772f0ea8bf6c203afefdde62" translate="yes" xml:space="preserve">
          <source>Member function names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">멤버 함수 이름은 &lt;code&gt;snake_case&lt;/code&gt; 대신 &lt;code&gt;lowerCamelCase&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b217f7514e4e69fd38aa7c54a821e91e41f619c3" translate="yes" xml:space="preserve">
          <source>Member functions</source>
          <target state="translated">회원 기능</target>
        </trans-unit>
        <trans-unit id="d58072c4501a38b0ae1c8099bd6324750503224c" translate="yes" xml:space="preserve">
          <source>Member functions are called with dot notation:</source>
          <target state="translated">멤버 함수는 점 표기법으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="90302bd1ef8edadba09a04d671c6ada71d5d8a46" translate="yes" xml:space="preserve">
          <source>Member functions define operations that are essential for a collection type. For example, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt;&lt;code&gt;Collection&lt;/code&gt;&lt;/a&gt; contains the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt;&lt;code&gt;isEmpty()&lt;/code&gt;&lt;/a&gt; for checking its emptiness; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; contains &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; for index access to elements, and so on.</source>
          <target state="translated">멤버 함수는 컬렉션 유형에 필수적인 작업을 정의합니다. 예를 들어 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/index&quot;&gt; &lt;code&gt;Collection&lt;/code&gt; &lt;/a&gt; 에는 공허 성을 확인하기위한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-collection/is-empty&quot;&gt; &lt;code&gt;isEmpty()&lt;/code&gt; &lt;/a&gt; 함수가 포함되어 있습니다 . &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/index&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 에는 요소에 대한 인덱스 액세스 등을위한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="a569ddca50a19b2205ceb3e1f59db2a7ba968aef" translate="yes" xml:space="preserve">
          <source>Member properties and member functions inside a generic class may for the most part use the class' generic type parameters as if they were ordinary types, without having to redeclare them. It is also possible to make functions that take more generic parameters than the class does, and to make generic functions inside nongeneric classes, and to make generic top-level functions (which is what we'll do in the next example). Note the different placement of the generic type parameter in generic function declarations:</source>
          <target state="translated">제네릭 클래스 내부의 멤버 속성과 멤버 함수는 대부분 클래스의 제네릭 형식 매개 변수를 마치 다시 선언하지 않고도 일반 형식 인 것처럼 사용할 수 있습니다. 클래스보다 더 일반적인 매개 변수를 사용하는 함수를 만들고 제네릭이 아닌 클래스 내에서 제네릭 함수를 만들고 제네릭 최상위 함수를 만들 수도 있습니다 (다음 예에서 수행 할 작업). 제네릭 함수 선언에서 제네릭 형식 매개 변수의 다른 배치에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="74971806b05c2768bdffa67bcc7b89b958d7edea" translate="yes" xml:space="preserve">
          <source>Member references and reflection</source>
          <target state="translated">회원 참조 및 반영</target>
        </trans-unit>
        <trans-unit id="10aac04b8647c134bc4873cf9a0d33a0bd4048e1" translate="yes" xml:space="preserve">
          <source>MemberAt</source>
          <target state="translated">MemberAt</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="2fd5b3fb4a679664c9a47a448257d9fa802a22f3" translate="yes" xml:space="preserve">
          <source>Members of Objective-C categories and Swift extensions are imported to Kotlin as extensions. That's why these declarations can't be overridden in Kotlin. And the extension initializers aren't available as Kotlin constructors.</source>
          <target state="translated">Objective-C 카테고리의 멤버 및 Swift 확장은 Kotlin에 확장으로 가져옵니다. 그렇기 때문에 Kotlin에서는 이러한 선언을 무시할 수 없습니다. 그리고 확장 초기화는 Kotlin 생성자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c590aa47cb148126a7aed2e0252e6e56de2e1fb5" translate="yes" xml:space="preserve">
          <source>Members of the companion object can be called by using simply the class name as the qualifier:</source>
          <target state="translated">클래스 이름을 한정자로 간단히 사용하여 컴패니언 객체의 멤버를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">메모리 할당</target>
        </trans-unit>
        <trans-unit id="0c2ee25c3007f8df17e0050402341b2f4ae697bc" translate="yes" xml:space="preserve">
          <source>Memory model binary was compiled with.</source>
          <target state="translated">메모리 모델 바이너리로 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="e73a4635af37ee3ef43681ca08ff16f60452ecfe" translate="yes" xml:space="preserve">
          <source>Memory model.</source>
          <target state="translated">메모리 모델.</target>
        </trans-unit>
        <trans-unit id="69164a09919e64cc770d2e92a315c7be5fe9ce87" translate="yes" xml:space="preserve">
          <source>MemoryModel</source>
          <target state="translated">MemoryModel</target>
        </trans-unit>
        <trans-unit id="2a2bb3d6a7f5790d759cba72823f3811d734fe09" translate="yes" xml:space="preserve">
          <source>MessageChannel</source>
          <target state="translated">MessageChannel</target>
        </trans-unit>
        <trans-unit id="ccca7aad0aa3bbb87c9ea30bfca4cd685ee282a6" translate="yes" xml:space="preserve">
          <source>MessageEventInit</source>
          <target state="translated">MessageEventInit</target>
        </trans-unit>
        <trans-unit id="da50feb28afa8ee6b84decde6712247ff2db1356" translate="yes" xml:space="preserve">
          <source>Metacharacters or escape sequences in the input sequence will be given no special meaning.</source>
          <target state="translated">입력 시퀀스의 메타 문자 또는 이스케이프 시퀀스에는 특별한 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="00c97618202a4d85cdcf254062dd76c688bb9937" translate="yes" xml:space="preserve">
          <source>Metadata in a custom format. The format may be different (or even absent) for different kinds.</source>
          <target state="translated">사용자 정의 형식의 메타 데이터. 형식은 종류에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="6ef376dbda2a9dfd9fe8fb9172d6ea36380a325e" translate="yes" xml:space="preserve">
          <source>Method call formatting</source>
          <target state="translated">메소드 호출 형식</target>
        </trans-unit>
        <trans-unit id="3643c572e5a5065b656aa6b5fce445bafca060de" translate="yes" xml:space="preserve">
          <source>Method declarations</source>
          <target state="translated">메소드 선언</target>
        </trans-unit>
        <trans-unit id="6c23f25a80838dd8e19f20f6fec8854933be69db" translate="yes" xml:space="preserve">
          <source>Method names translation</source>
          <target state="translated">분석법 이름 번역</target>
        </trans-unit>
        <trans-unit id="88533fb91c329fcc07daac7abd293e3d2ef386bf" translate="yes" xml:space="preserve">
          <source>Methods &lt;code&gt;wait()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; are not available on references of type &lt;code&gt;Any&lt;/code&gt;. Their usage is generally discouraged in favor of &lt;code&gt;java.util.concurrent&lt;/code&gt;. If you really need to call these methods, you can cast to &lt;code&gt;java.lang.Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 유형의 참조에는 &lt;code&gt;wait()&lt;/code&gt; 및 &lt;code&gt;notify()&lt;/code&gt; 메소드를 사용할 수 없습니다 . 일반적으로 &lt;code&gt;java.util.concurrent&lt;/code&gt; 사용을 권장하지 않습니다 . 이러한 메소드를 호출해야하는 경우 &lt;code&gt;java.lang.Object&lt;/code&gt; 로 캐스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04764bae2f3b42e32503d658246fd786e62d1716" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as platform, i.e. it's possible to perform unsafe operation in Kotlin:</source>
          <target state="translated">&lt;code&gt;MyList&amp;lt;T&amp;gt;&lt;/code&gt; 정의 된 메소드 는 &lt;code&gt;T&lt;/code&gt; 를 플랫폼으로 사용 합니다. 즉 Kotlin에서 안전하지 않은 조작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2362d4b5d61680189ee786359c95c772832ea599" translate="yes" xml:space="preserve">
          <source>Methods defined in &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; overriding methods in &lt;code&gt;MutableList&lt;/code&gt; use &lt;code&gt;T&lt;/code&gt; as non-platform types:</source>
          <target state="translated">정의 방법 &lt;code&gt;MyPureList&amp;lt;T&amp;gt;&lt;/code&gt; 에서 재정의 방법 &lt;code&gt;MutableList&lt;/code&gt; 의 사용 &lt;code&gt;T&lt;/code&gt; 비 플랫폼 유형으로서 :</target>
        </trans-unit>
        <trans-unit id="1643049f5673b4e1c5eb74d112c9611cf055d3c5" translate="yes" xml:space="preserve">
          <source>Methods returning void</source>
          <target state="translated">void를 돌려주는 메소드</target>
        </trans-unit>
        <trans-unit id="a8027f1188b3014c0f8995cd7120023b72397d3d" translate="yes" xml:space="preserve">
          <source>Methods that follow the Java conventions for getters and setters (no-argument methods with names starting with &lt;code&gt;get&lt;/code&gt; and single-argument methods with names starting with &lt;code&gt;set&lt;/code&gt;) are represented as properties in Kotlin. &lt;code&gt;Boolean&lt;/code&gt; accessor methods (where the name of the getter starts with &lt;code&gt;is&lt;/code&gt; and the name of the setter starts with &lt;code&gt;set&lt;/code&gt;) are represented as properties which have the same name as the getter method.</source>
          <target state="translated">getter 및 setter에 대한 Java 규칙을 따르는 메소드 ( &lt;code&gt;get&lt;/code&gt; 로 시작하는 이름을 가진 인수가없는 메소드 및 &lt;code&gt;set&lt;/code&gt; 로 시작하는 이름을 가진 단일 인수 메소드 )는 Kotlin의 특성으로 표시됩니다. &lt;code&gt;Boolean&lt;/code&gt; 액세서 메소드 (게터의 이름으로 시작 &lt;code&gt;is&lt;/code&gt; 과 함께 시작 세터의 이름 &lt;code&gt;set&lt;/code&gt; ) 게터 방법과 동일한 이름을 속성으로서 표현된다.</target>
        </trans-unit>
        <trans-unit id="a23dee2288fafb96e4e3f4b56c185b2062a8905b" translate="yes" xml:space="preserve">
          <source>Micronaut also has a lot of well-detailed &lt;a href=&quot;https://guides.micronaut.io/tags/kotlin.html&quot;&gt;guides&lt;/a&gt;, showing how you can build microservices in Kotlin.</source>
          <target state="translated">또한 Micronaut에는 Kotlin에서 마이크로 서비스를 빌드하는 방법을 보여주는 자세한 &lt;a href=&quot;https://guides.micronaut.io/tags/kotlin.html&quot;&gt;가이드&lt;/a&gt; 가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2474109210e0ea672543f6c977728ae54b8f124d" translate="yes" xml:space="preserve">
          <source>Migrate the code with the help of the tooling</source>
          <target state="translated">툴링을 사용하여 코드를 마이그레이션하십시오.</target>
        </trans-unit>
        <trans-unit id="708b9cf32b4bb9e8e85c01bf95c0ef78c92becb6" translate="yes" xml:space="preserve">
          <source>Migrating from Java</source>
          <target state="translated">Java에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="b9d3a9e9670f7240a77d83260fefdcb2501bc774" translate="yes" xml:space="preserve">
          <source>Migrating to Kotlin</source>
          <target state="translated">Kotlin으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="f44d82dafb548c8ad9d6490ef0e69cd3d1ba217d" translate="yes" xml:space="preserve">
          <source>Migration to a new code style</source>
          <target state="translated">새로운 코드 스타일로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="d0a1c8e409ae53cb281e66770ad717b9178d43ce" translate="yes" xml:space="preserve">
          <source>Migration to a new code style discussion</source>
          <target state="translated">새로운 코드 스타일 토론으로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="1bd7ccbde8d3077fec1f549017e747393223a900" translate="yes" xml:space="preserve">
          <source>MimeType</source>
          <target state="translated">MimeType</target>
        </trans-unit>
        <trans-unit id="ed52d3a5f9993b67e83d292332a8f9a1d86ebf44" translate="yes" xml:space="preserve">
          <source>MimeTypeArray</source>
          <target state="translated">MimeTypeArray</target>
        </trans-unit>
        <trans-unit id="98f205e04abca4bbe7595051d07e6eb3a4abe953" translate="yes" xml:space="preserve">
          <source>Min value</source>
          <target state="translated">최소값</target>
        </trans-unit>
        <trans-unit id="222d1f694d764125a7a7a5786d11a04234b0be8d" translate="yes" xml:space="preserve">
          <source>Missing errors in class constructor&amp;rsquo;s &lt;code&gt;@get:&lt;/code&gt; annotations</source>
          <target state="translated">클래스 생성자의 &lt;code&gt;@get:&lt;/code&gt; 에서 누락 된 오류 : 주석</target>
        </trans-unit>
        <trans-unit id="47e4750870ece5e5c348eda89bdc8e3fbb4c6cff" translate="yes" xml:space="preserve">
          <source>Missing getter-targeted annotations on annotation constructor parameters</source>
          <target state="translated">주석 생성자 매개 변수에 게터 대상 주석이 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="52b91c038ffc21a08d48959a44ba1c6fddb114f2" translate="yes" xml:space="preserve">
          <source>Mixed Java and Kotlin</source>
          <target state="translated">자바와 코 틀린 혼합</target>
        </trans-unit>
        <trans-unit id="86c40367cc1e1c53a8c10c73ada1f29fd66c1405" translate="yes" xml:space="preserve">
          <source>Mixing Java and Kotlin in one project</source>
          <target state="translated">하나의 프로젝트에서 Java와 Kotlin 혼합</target>
        </trans-unit>
        <trans-unit id="404ab93e44ed76b5232ab6931dd26299f542e43d" translate="yes" xml:space="preserve">
          <source>Modern debuggers provide several ways to set a breakpoint, see below for a tool-by-tool breakdown:</source>
          <target state="translated">최신 디버거는 중단 점을 설정하는 여러 가지 방법을 제공합니다. 도구 별 분석은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ba6ee64964304bc6c3c5424baba2b34cd73ea5d" translate="yes" xml:space="preserve">
          <source>Modifier Keywords</source>
          <target state="translated">수정 자 키워드</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="42cd86d0e702bd27bcb835a0b162fb95197132a2" translate="yes" xml:space="preserve">
          <source>Modifies the value of the property.</source>
          <target state="translated">속성 값을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="723a9a05eb17a0ec38db3b56d4b0ea18be0358a6" translate="yes" xml:space="preserve">
          <source>Module and Package Documentation</source>
          <target state="translated">모듈 및 패키지 설명서</target>
        </trans-unit>
        <trans-unit id="ed8def074470e81fe96b7cdd8aac08ec3fff3bc6" translate="yes" xml:space="preserve">
          <source>Module system used by the Kotlin Standard Library</source>
          <target state="translated">Kotlin 표준 라이브러리에서 사용하는 모듈 시스템</target>
        </trans-unit>
        <trans-unit id="ec446b6ebb15f053c4868dce62c242283cf04673" translate="yes" xml:space="preserve">
          <source>Module-wide markers</source>
          <target state="translated">모듈 전체 마커</target>
        </trans-unit>
        <trans-unit id="738fa33a16ad3f30c737fafc42459e4a03f30470" translate="yes" xml:space="preserve">
          <source>Module-wide use</source>
          <target state="translated">모듈 전체 사용</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d62ac0bf808c354dcb97b6778e8aaae4635a7c9f" translate="yes" xml:space="preserve">
          <source>More details and advanced use-cases are presented in the</source>
          <target state="translated">자세한 내용과 고급 사용 사례는</target>
        </trans-unit>
        <trans-unit id="91aa2ec21d9f2bac781876761e04b45d52ef74fe" translate="yes" xml:space="preserve">
          <source>More documentation on the types mapping can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; article.</source>
          <target state="translated">유형 맵핑에 대한 자세한 문서는 &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; 기사 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5c09addc98121bf0f9aad66c228b38f1430aecf" translate="yes" xml:space="preserve">
          <source>More information about all other types mapping details can be found in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">다른 모든 유형 맵핑 세부 사항에 대한 자세한 정보는 &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; 문서 기사 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b061f32f9ec8d43b64e344ed5485c4d9f7caf378" translate="yes" xml:space="preserve">
          <source>More tips and tricks</source>
          <target state="translated">더 많은 팁과 요령</target>
        </trans-unit>
        <trans-unit id="e9792383929cbb7b1909aa88012c0f218c0c51f8" translate="yes" xml:space="preserve">
          <source>Most built-in types are comparable:</source>
          <target state="translated">대부분의 내장 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9f0f6eb5ddb49db8f8ae5d8eb9cab0176d9ace5" translate="yes" xml:space="preserve">
          <source>Most of the functionality of signed types are supported for unsigned counterparts too:</source>
          <target state="translated">서명 된 유형의 기능은 대부분 서명되지 않은 상대방에 대해서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cb91c080f7b68ae6a8bbb2b702b1059a13b12c96" translate="yes" xml:space="preserve">
          <source>Most of the operators that are recognized by Kotlin's syntax have predefined textual names and are available for implementation in your classes, just like you can do with Python's double-underscore operator names. For example, the binary &lt;code&gt;+&lt;/code&gt; operator is called &lt;code&gt;plus&lt;/code&gt;. Similarly to the infix example, if you do this inside a &lt;code&gt;Person&lt;/code&gt; class that has got a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">Kotlin의 구문으로 인식되는 대부분의 연산자는 사전 정의 된 텍스트 이름을 가지며 파이썬의 이중 밑줄 연산자 이름과 마찬가지로 클래스에서 구현할 수 있습니다. 예를 들어 이진 &lt;code&gt;+&lt;/code&gt; 연산자는 &lt;code&gt;plus&lt;/code&gt; 라고 합니다. 마찬가지로 중위 예, 당신은 내부에서이 작업을 수행 할 경우 &lt;code&gt;Person&lt;/code&gt; 가지고 클래스 &lt;code&gt;name&lt;/code&gt; 속성을 :</target>
        </trans-unit>
        <trans-unit id="ef0792097f4b2ac5841fae23eda77fe48d6f36a5" translate="yes" xml:space="preserve">
          <source>Most of the time we define extensions on the top level - directly under packages:</source>
          <target state="translated">대부분의 경우 우리는 패키지 바로 아래에 최상위 수준에서 확장을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3edbae2a158aaf025c7463b2890fdba1f30e0552" translate="yes" xml:space="preserve">
          <source>Most of the time we define extensions on the top level, i.e. directly under packages:</source>
          <target state="translated">대부분의 경우 확장을 최상위 레벨에서 정의합니다 (예 : 패키지 바로 아래).</target>
        </trans-unit>
        <trans-unit id="d6a06199cc127e571d3588aef63c79108675eabc" translate="yes" xml:space="preserve">
          <source>Motivation</source>
          <target state="translated">Motivation</target>
        </trans-unit>
        <trans-unit id="e5f579f208747beb161cf00d47a3a0c086f81dbe" translate="yes" xml:space="preserve">
          <source>MouseEventInit</source>
          <target state="translated">MouseEventInit</target>
        </trans-unit>
        <trans-unit id="19754c53e87ae21affdf187e21540a29ec7c1fa2" translate="yes" xml:space="preserve">
          <source>Much like we reference an input element, we can access other elements on the page, casting them to the appropriate types.</source>
          <target state="translated">입력 요소를 참조하는 것처럼 페이지의 다른 요소에 액세스하여 적절한 유형으로 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85e61eaa48d6be8dae51bf80212b85c25bd2b301" translate="yes" xml:space="preserve">
          <source>Much the same way as regular properties, the properties declared in the primary constructor can be mutable (&lt;em&gt;var&lt;/em&gt;) or read-only (&lt;em&gt;val&lt;/em&gt;).</source>
          <target state="translated">일반 속성과 같은 방식으로 기본 생성자에 선언 된 속성은 변경 가능 ( &lt;em&gt;var&lt;/em&gt; ) 또는 읽기 전용 ( &lt;em&gt;val&lt;/em&gt; ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf10a69dc3111e2f0b70a7a3b5fcde0eb5de58f0" translate="yes" xml:space="preserve">
          <source>Multiplatform &lt;code&gt;Random&lt;/code&gt;</source>
          <target state="translated">멀티 플랫폼 &lt;code&gt;Random&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d27d69385dad1ecc38485d70b593ff3be6501e1" translate="yes" xml:space="preserve">
          <source>Multiplatform Gradle Project</source>
          <target state="translated">멀티 플랫폼 Gradle 프로젝트</target>
        </trans-unit>
        <trans-unit id="b476304566bdb2c8284f4c5fabc7060e30563d1f" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin Library</source>
          <target state="translated">멀티 플랫폼 코 틀린 라이브러리</target>
        </trans-unit>
        <trans-unit id="594342484b7fa8723561cd74a56adf5ed5eecd56" translate="yes" xml:space="preserve">
          <source>Multiplatform Kotlin library</source>
          <target state="translated">멀티 플랫폼 코 틀린 라이브러리</target>
        </trans-unit>
        <trans-unit id="abdd2b4ca66085ea36500996c307f3c54d5bee0a" translate="yes" xml:space="preserve">
          <source>Multiplatform Libraries</source>
          <target state="translated">멀티 플랫폼 라이브러리</target>
        </trans-unit>
        <trans-unit id="49bdb75dde412727c37ad9cfdc25f84b9800e1ee" translate="yes" xml:space="preserve">
          <source>Multiplatform Programming</source>
          <target state="translated">멀티 플랫폼 프로그래밍</target>
        </trans-unit>
        <trans-unit id="8831ff8afbd886576a6d26e7a38c2a2945370e5f" translate="yes" xml:space="preserve">
          <source>Multiplatform Project: iOS and Android</source>
          <target state="translated">멀티 플랫폼 프로젝트 : iOS 및 Android</target>
        </trans-unit>
        <trans-unit id="5cff52171a748c24fbdfa2675a9193d1e17c8b90" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects</source>
          <target state="translated">멀티 플랫폼 프로젝트</target>
        </trans-unit>
        <trans-unit id="30ece0cd52430a4d7a64233600e1721dbcbbe2bf" translate="yes" xml:space="preserve">
          <source>Multiplatform Projects (experimental)</source>
          <target state="translated">멀티 플랫폼 프로젝트 (실험)</target>
        </trans-unit>
        <trans-unit id="0198731e127deda4e2a86e65a7c2c819b3c35ae8" translate="yes" xml:space="preserve">
          <source>Multiplatform documentation</source>
          <target state="translated">멀티 플랫폼 문서</target>
        </trans-unit>
        <trans-unit id="8f424e82581dd0443f6b1cfe8761404b9445347c" translate="yes" xml:space="preserve">
          <source>Multiplatform programming</source>
          <target state="translated">다중 플랫폼 프로그래밍</target>
        </trans-unit>
        <trans-unit id="dce33eff96bb2026a847a2a553a328f131ebdfe5" translate="yes" xml:space="preserve">
          <source>Multiplatform projects</source>
          <target state="translated">멀티 플랫폼 프로젝트</target>
        </trans-unit>
        <trans-unit id="48104e942ea0eb10a48e224f17bd6af63a0f01ad" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are a new &lt;strong&gt;experimental&lt;/strong&gt; feature in Kotlin 1.2, allowing you to reuse code between target platforms supported by Kotlin &amp;ndash; JVM, JavaScript and (in the future) Native. In a multiplatform project, you have three kinds of modules:</source>
          <target state="translated">멀티 플랫폼 프로젝트는 Kotlin 1.2 의 새로운 &lt;strong&gt;실험&lt;/strong&gt; 기능으로, Kotlin이 지원하는 대상 플랫폼 (JVM, JavaScript 및 기본)간에 코드를 재사용 할 수 있습니다. 멀티 플랫폼 프로젝트에는 세 가지 종류의 모듈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="56c55ee3ca3b8c8dc0a5fe577d6b3cbe7b6bf668" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are an experimental feature in Kotlin 1.2 and 1.3. All of the language and tooling features described in this document are subject to change in future Kotlin versions.</source>
          <target state="translated">멀티 플랫폼 프로젝트는 Kotlin 1.2 및 1.3의 실험 기능입니다. 이 문서에 설명 된 모든 언어 및 툴링 기능은 향후 Kotlin 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1b4e8641ccf9f8084108431aa99a93d1fa43a8" translate="yes" xml:space="preserve">
          <source>Multiplatform projects are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. Language features and tooling may change in future Kotlin versions.</source>
          <target state="translated">멀티 플랫폼 프로젝트는 &lt;a href=&quot;evolution/components-stability&quot;&gt;알파 버전&lt;/a&gt; 입니다. 언어 기능 및 도구는 향후 Kotlin 버전에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47f8ee1f56229364d475a5b4995314b84d9fc4e" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may receive from the same channel, distributing work between themselves. Let us start with a producer coroutine that is periodically producing integers (ten numbers per second):</source>
          <target state="translated">여러 코 루틴이 동일한 채널에서 수신되어 서로간에 작업을 분산시킬 수 있습니다. 주기적으로 정수 (초당 10 개의 숫자)를 생성하는 생산자 코 루틴으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="264744e655406950142eec2a53dc539eed8a5fd7" translate="yes" xml:space="preserve">
          <source>Multiple coroutines may send to the same channel. For example, let us have a channel of strings, and a suspending function that repeatedly sends a specified string to this channel with a specified delay:</source>
          <target state="translated">여러 코 루틴이 동일한 채널로 보낼 수 있습니다. 예를 들어, 문자열 채널과 지정된 지연 시간을두고 지정된 문자열을이 채널에 반복적으로 전송하는 서 스펜 딩 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d79d3118202ae1d668fb56014f9cb20b36159e5" translate="yes" xml:space="preserve">
          <source>Multiplies this value by the other value.</source>
          <target state="translated">이 값에 다른 값을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="f342e79f479c63b3a6f1a4035901daea4fbf30b9" translate="yes" xml:space="preserve">
          <source>MustBeDocumented</source>
          <target state="translated">MustBeDocumented</target>
        </trans-unit>
        <trans-unit id="07b00606431523d4ebea7077981984b607d973e8" translate="yes" xml:space="preserve">
          <source>Mutable closure variables</source>
          <target state="translated">가변 폐쇄 변수</target>
        </trans-unit>
        <trans-unit id="e427611262df2a9a50ee135e0fceaecfa0c80c7f" translate="yes" xml:space="preserve">
          <source>Mutable concurrently accessible data buffer. Could be accessed from several workers simulteniously.</source>
          <target state="translated">동시에 액세스 가능한 가변 데이터 버퍼 여러 근로자가 동시에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46fb0a3dd2497d28351f3b643be68bf38c4dcf04" translate="yes" xml:space="preserve">
          <source>Mutable iterators</source>
          <target state="translated">가변 이터레이터</target>
        </trans-unit>
        <trans-unit id="9b7b2307fe92cd7c012fa39281f7b175b249dd6e" translate="yes" xml:space="preserve">
          <source>MutableCollection</source>
          <target state="translated">MutableCollection</target>
        </trans-unit>
        <trans-unit id="42724994b4f6f408170a142d4bb3a6bfa7198849" translate="yes" xml:space="preserve">
          <source>MutableCollection.iterator</source>
          <target state="translated">MutableCollection.iterator</target>
        </trans-unit>
        <trans-unit id="1a5033d42eefb58adbea823fa5255b0aed1d662e" translate="yes" xml:space="preserve">
          <source>MutableData</source>
          <target state="translated">MutableData</target>
        </trans-unit>
        <trans-unit id="5e9e097c14385f745d368faabbd3854a67b05b46" translate="yes" xml:space="preserve">
          <source>MutableEntry</source>
          <target state="translated">MutableEntry</target>
        </trans-unit>
        <trans-unit id="8a4f4102af09300cf876f9a6460618caaa96575a" translate="yes" xml:space="preserve">
          <source>MutableIterable</source>
          <target state="translated">MutableIterable</target>
        </trans-unit>
        <trans-unit id="a652e5941b9ff793ccc9e659b88bf1a8f5227c3a" translate="yes" xml:space="preserve">
          <source>MutableIterator</source>
          <target state="translated">MutableIterator</target>
        </trans-unit>
        <trans-unit id="49e02d16b11d601b6e4902190c5bca350a9202fc" translate="yes" xml:space="preserve">
          <source>MutableList</source>
          <target state="translated">MutableList</target>
        </trans-unit>
        <trans-unit id="4c650d57f6075cf5940d694638ac9e4ec8e77bc6" translate="yes" xml:space="preserve">
          <source>MutableListIterator</source>
          <target state="translated">MutableListIterator</target>
        </trans-unit>
        <trans-unit id="f20ff48f1ceb7119a78b4b13a251cf2c7628b7ac" translate="yes" xml:space="preserve">
          <source>MutableMap</source>
          <target state="translated">MutableMap</target>
        </trans-unit>
        <trans-unit id="c0a289c1f11c0248072d86bca1271c7246850c9c" translate="yes" xml:space="preserve">
          <source>MutableSet</source>
          <target state="translated">MutableSet</target>
        </trans-unit>
        <trans-unit id="0b5d551add97f7ca81d05d95c5a9f114421d02ad" translate="yes" xml:space="preserve">
          <source>Mutating the backing field of a read-only property by assigning &lt;code&gt;field = ...&lt;/code&gt; in the custom getter has been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">Kotlin 1.2의 경고와 Kotlin 1.3의 오류와 함께 사용자 정의 getter에서 &lt;code&gt;field = ...&lt;/code&gt; 를 지정하여 읽기 전용 속성의 지원 필드를 제거하는 것은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9e09542ba7562ba06b3618d585343bb16717cc0" translate="yes" xml:space="preserve">
          <source>MutationObserver</source>
          <target state="translated">MutationObserver</target>
        </trans-unit>
        <trans-unit id="bf760ce86085d0556b58a1fb2886ad6300cf25c9" translate="yes" xml:space="preserve">
          <source>MutationObserverInit</source>
          <target state="translated">MutationObserverInit</target>
        </trans-unit>
        <trans-unit id="902e161ec72b34937173fb6ae6f1167c6c4b933a" translate="yes" xml:space="preserve">
          <source>MutationRecord</source>
          <target state="translated">MutationRecord</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">상호 배제</target>
        </trans-unit>
        <trans-unit id="f2a0cc7430b6ab201c123d93595f5409656e44aa" translate="yes" xml:space="preserve">
          <source>Mutual exclusion solution to the problem is to protect all modifications of the shared state with a &lt;em&gt;critical section&lt;/em&gt; that is never executed concurrently. In a blocking world you'd typically use &lt;code&gt;synchronized&lt;/code&gt; or &lt;code&gt;ReentrantLock&lt;/code&gt; for that. Coroutine's alternative is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;Mutex&lt;/a&gt;. It has &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;lock&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;unlock&lt;/a&gt; functions to delimit a critical section. The key difference is that &lt;code&gt;Mutex.lock()&lt;/code&gt; is a suspending function. It does not block a thread.</source>
          <target state="translated">문제에 대한 상호 배제 솔루션 은 동시에 실행되지 않는 &lt;em&gt;중요한 섹션으로&lt;/em&gt; 공유 상태의 모든 수정을 보호하는 것입니다 . 블로킹 세계에서는 일반적으로 &lt;code&gt;synchronized&lt;/code&gt; 또는 &lt;code&gt;ReentrantLock&lt;/code&gt; 을 사용합니다. 코 루틴의 대안은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/index.html&quot;&gt;Mutex&lt;/a&gt; 라고 합니다. 그것은이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/lock.html&quot;&gt;잠금&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/unlock.html&quot;&gt;잠금 해제&lt;/a&gt; 중요한 부분을 구분하는 기능을. 주요 차이점은 &lt;code&gt;Mutex.lock()&lt;/code&gt; 이 일시 중단 함수라는 것입니다. 스레드를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6a87480ef216b736cda78776d20937ae965a5a1" translate="yes" xml:space="preserve">
          <source>My first coroutine</source>
          <target state="translated">내 첫 코 루틴</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="ac5af3d78fb9a248a0c8878049fa45cb722c5609" translate="yes" xml:space="preserve">
          <source>NEGATIVE_INFINITY</source>
          <target state="translated">NEGATIVE_INFINITY</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="19b5db1284eda5fe55423cf6ff666bbd91d48790" translate="yes" xml:space="preserve">
          <source>NONSPACING_MARK</source>
          <target state="translated">NONSPACING_MARK</target>
        </trans-unit>
        <trans-unit id="a711913b07f219db3720165b1cc42ba33ab84d07" translate="yes" xml:space="preserve">
          <source>NON_SPACING_MARK</source>
          <target state="translated">NON_SPACING_MARK</target>
        </trans-unit>
        <trans-unit id="b12d9f3adce16f3c42e185c9323b0f2c05d0d02a" translate="yes" xml:space="preserve">
          <source>NOTE: Octal literals are not supported.</source>
          <target state="translated">참고 : 8 진 리터럴은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c820cc676951d2a6935d55d3c748ef2d4229e0ef" translate="yes" xml:space="preserve">
          <source>NSArray</source>
          <target state="translated">NSArray</target>
        </trans-unit>
        <trans-unit id="850a25e67ede967c8226916d9435ee3fa9fe30c0" translate="yes" xml:space="preserve">
          <source>NSDictionary</source>
          <target state="translated">NSDictionary</target>
        </trans-unit>
        <trans-unit id="88142d93bc155af7430eda23b521adf5177befb3" translate="yes" xml:space="preserve">
          <source>NSMutableArray</source>
          <target state="translated">NSMutableArray</target>
        </trans-unit>
        <trans-unit id="093cc39541f1d88e9c8d7815809e04abdc468222" translate="yes" xml:space="preserve">
          <source>NSMutableDictionary</source>
          <target state="translated">NSMutableDictionary</target>
        </trans-unit>
        <trans-unit id="6f353d0803276b29f669e8e00d5912e0735d118f" translate="yes" xml:space="preserve">
          <source>NSMutableString</source>
          <target state="translated">NSMutableString</target>
        </trans-unit>
        <trans-unit id="21b6f3d1ecc982003af64b405b1aec1eeffcbd63" translate="yes" xml:space="preserve">
          <source>NSNumber</source>
          <target state="translated">NSNumber</target>
        </trans-unit>
        <trans-unit id="6049050154f9c68876906ec983b62a8beb7bfd87" translate="yes" xml:space="preserve">
          <source>NSSet</source>
          <target state="translated">NSSet</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed2a70884b6ea61a0ea998c7fe86ebc6c43c39e1" translate="yes" xml:space="preserve">
          <source>Name of the module being compiled</source>
          <target state="translated">컴파일중인 모듈의 이름</target>
        </trans-unit>
        <trans-unit id="bd9b36517a10ed825bfe97b96fd841ffbfd62dda" translate="yes" xml:space="preserve">
          <source>Name of the worker, as specified in &lt;a href=&quot;start&quot;&gt;Worker.start&lt;/a&gt; or &quot;worker $id&quot; by default,</source>
          <target state="translated">&lt;a href=&quot;start&quot;&gt;Worker.start&lt;/a&gt; 또는 기본적으로 &quot;worker $ id&quot;에 지정된 작업자 이름 ,</target>
        </trans-unit>
        <trans-unit id="4efab9c724a7839dff5f1e0118b1a9b242fe8997" translate="yes" xml:space="preserve">
          <source>Name of this parameter as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the parameter has no name or its name is not available at runtime. Examples of nameless parameters include &lt;code&gt;this&lt;/code&gt; instance for member functions, extension receiver for extension functions or properties, parameters of Java methods compiled without the debug information, and others.</source>
          <target state="translated">소스 코드에서 선언 된이 매개 변수의 이름이거나, 매개 변수에 이름이 없거나 런타임에 해당 이름을 사용할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다. 이름없는 매개 변수의 예로는 멤버 함수에 대한 &lt;code&gt;this&lt;/code&gt; 인스턴스, 확장 함수 또는 특성에 대한 확장 수신자, 디버그 정보없이 컴파일 된 Java 메소드의 매개 변수 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0268761f1a46defda13527e24a738481491b83" translate="yes" xml:space="preserve">
          <source>Name translation</source>
          <target state="translated">이름 번역</target>
        </trans-unit>
        <trans-unit id="80a1546459fb296b75e903b673f8cc0ad0b7638a" translate="yes" xml:space="preserve">
          <source>Named Arguments</source>
          <target state="translated">명명 된 인수</target>
        </trans-unit>
        <trans-unit id="f2ab34573e168918bf72dc73ec10c4b5b1ba3f14" translate="yes" xml:space="preserve">
          <source>Named arguments</source>
          <target state="translated">명명 된 인수</target>
        </trans-unit>
        <trans-unit id="7eee412e511b81f184e8fdcdd0d16df4490ee091" translate="yes" xml:space="preserve">
          <source>NamedNodeMap</source>
          <target state="translated">NamedNodeMap</target>
        </trans-unit>
        <trans-unit id="89ed0927522265d199caf008b2d935b4dc13e4ec" translate="yes" xml:space="preserve">
          <source>Namely, &lt;code&gt;Grouping&lt;/code&gt; supports the following operations:</source>
          <target state="translated">즉, &lt;code&gt;Grouping&lt;/code&gt; 는 다음 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ce7873d11ca1350ea35c4e7edcc86d0f3faedfbb" translate="yes" xml:space="preserve">
          <source>Names for backing properties</source>
          <target state="translated">지지 속성의 이름</target>
        </trans-unit>
        <trans-unit id="d5e90b6eaa5ac7d68bfe0de19720901740a9662f" translate="yes" xml:space="preserve">
          <source>Names for test methods</source>
          <target state="translated">테스트 방법의 이름</target>
        </trans-unit>
        <trans-unit id="1bbe1b5bbc9b48ae056a0ba828b7773769b4e6a7" translate="yes" xml:space="preserve">
          <source>Names in links are resolved using the same rules as if the name was used inside the element being documented. In particular, this means that if you have imported a name into the current file, you don't need to fully qualify it when you use it in a KDoc comment.</source>
          <target state="translated">링크의 이름은 이름이 문서화되는 요소 내부에서 사용 된 것과 동일한 규칙을 사용하여 해결됩니다. 즉, 현재 파일로 이름을 가져온 경우 KDoc 주석에서 이름을 사용할 때 이름을 완전히 규정 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5380f68245bbc672ad92afb09b8fb6715ad3ca6" translate="yes" xml:space="preserve">
          <source>Names of classes and objects start with an upper case letter and use camel humps:</source>
          <target state="translated">클래스와 객체의 이름은 대문자로 시작하고 낙타 혹을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3b4a6dab1202620b73c1005110fe77d753a54e9f" translate="yes" xml:space="preserve">
          <source>Names of classes and objects start with an upper case letter and use the camel case:</source>
          <target state="translated">클래스와 객체의 이름은 대문자로 시작하고 카멜 케이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc15464a07c43531a73eacebb7c301c643be9755" translate="yes" xml:space="preserve">
          <source>Names of constants (properties marked with &lt;code&gt;const&lt;/code&gt;, or top-level or object &lt;code&gt;val&lt;/code&gt; properties with no custom &lt;code&gt;get&lt;/code&gt; function that hold deeply immutable data) should use uppercase underscore-separated names:</source>
          <target state="translated">상수의 이름 ( &lt;code&gt;const&lt;/code&gt; 로 표시되는 속성 또는 변경이 불가능한 데이터를 보유하는 사용자 지정 &lt;code&gt;get&lt;/code&gt; 함수가 없는 최상위 또는 객체 &lt;code&gt;val&lt;/code&gt; 속성 )은 밑줄로 구분 된 대문자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed152e23d368497078b7ae5dc12a67a09aef9537" translate="yes" xml:space="preserve">
          <source>Names of functions, properties and local variables start with a lower case letter and use camel humps and no underscores:</source>
          <target state="translated">함수, 속성 및 지역 변수의 이름은 소문자로 시작하고 낙타 혹을 사용하고 밑줄을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e715a573269457e03280d22e2a0d8e880e4fdae" translate="yes" xml:space="preserve">
          <source>Names of functions, properties and local variables start with a lower case letter and use the camel case and no underscores:</source>
          <target state="translated">함수, 속성 및 지역 변수의 이름은 소문자로 시작하고 카멜 케이스를 사용하고 밑줄은 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fe2ff19a7f565c3d30edceae570abf2351b799b" translate="yes" xml:space="preserve">
          <source>Names of packages are always lower case and do not use underscores (&lt;code&gt;org.example.myproject&lt;/code&gt;). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together or use camel humps (&lt;code&gt;org.example.myProject&lt;/code&gt;).</source>
          <target state="translated">패키지 이름은 항상 소문자이며 밑줄 ( &lt;code&gt;org.example.myproject&lt;/code&gt; )을 사용하지 마십시오 . 여러 단어로 된 이름을 사용하는 것은 일반적으로 권장되지 않지만 여러 단어를 사용해야하는 경우 간단히 단어를 연결하거나 낙타 혹 ( &lt;code&gt;org.example.myProject&lt;/code&gt; )을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d506a4b97208834d8b60a4f447f3486fac1cf5be" translate="yes" xml:space="preserve">
          <source>Names of packages are always lower case and do not use underscores (&lt;code&gt;org.example.project&lt;/code&gt;). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either simply concatenate them together or use the camel case (&lt;code&gt;org.example.myProject&lt;/code&gt;).</source>
          <target state="translated">패키지 이름은 항상 소문자이며 밑줄 ( &lt;code&gt;org.example.project&lt;/code&gt; )을 사용하지 않습니다 . 여러 단어로 된 이름을 사용하는 것은 일반적으로 권장되지 않지만 여러 단어를 사용해야하는 경우 간단히 함께 연결하거나 카멜 케이스 ( &lt;code&gt;org.example.myProject&lt;/code&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f7adf5dd484e8eda6819e4b4ab1a277a17337ee" translate="yes" xml:space="preserve">
          <source>Names of properties holding references to singleton objects can use the same naming style as &lt;code&gt;object&lt;/code&gt; declarations:</source>
          <target state="translated">싱글 톤 객체에 대한 참조를 보유한 속성의 이름은 &lt;code&gt;object&lt;/code&gt; 선언 과 동일한 이름 지정 스타일을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae79cc54e87e697302be7b45dcff0dc1ad4a5a71" translate="yes" xml:space="preserve">
          <source>Names of top-level or object properties which hold objects with behavior or mutable data should use camel-case names:</source>
          <target state="translated">동작 또는 변경 가능한 데이터가있는 객체를 보유하는 최상위 또는 객체 속성의 이름은 카멜 케이스 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2dd1c430f56a1096d7535c6bff1f0b002bb217ee" translate="yes" xml:space="preserve">
          <source>Names of top-level or object properties which hold objects with behavior or mutable data should use regular camel-hump names:</source>
          <target state="translated">동작 또는 변경 가능한 데이터가있는 객체를 보유하는 최상위 또는 객체 속성의 이름은 일반적인 낙타 혹 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a821637ed465037f50fb45146c7157533ce303ab" translate="yes" xml:space="preserve">
          <source>Naming coroutines for debugging</source>
          <target state="translated">디버깅을위한 명명 코 루틴</target>
        </trans-unit>
        <trans-unit id="b8f89bc873847bc6acb441471008e2ef77f271a2" translate="yes" xml:space="preserve">
          <source>Naming rules</source>
          <target state="translated">명명 규칙</target>
        </trans-unit>
        <trans-unit id="4fc6e7f740abb8af896ebedebf941a3f8d7076b5" translate="yes" xml:space="preserve">
          <source>Native</source>
          <target state="translated">Native</target>
        </trans-unit>
        <trans-unit id="712b0ca62af66efef9be01024a01163935118cd1" translate="yes" xml:space="preserve">
          <source>NativeFreeablePlacement</source>
          <target state="translated">NativeFreeablePlacement</target>
        </trans-unit>
        <trans-unit id="8c2ed68939229f0bed6cd8b6f2cb9306658a5c17" translate="yes" xml:space="preserve">
          <source>NativePlacement</source>
          <target state="translated">NativePlacement</target>
        </trans-unit>
        <trans-unit id="f6500269f9c3fb94b4438bc913d694314febde22" translate="yes" xml:space="preserve">
          <source>NativePointed</source>
          <target state="translated">NativePointed</target>
        </trans-unit>
        <trans-unit id="82e059ceb59aa7b7713c457045493d8d28dcc3f4" translate="yes" xml:space="preserve">
          <source>NativePtr</source>
          <target state="translated">NativePtr</target>
        </trans-unit>
        <trans-unit id="f504a9f397b7b30ca39f0ef1407b932940292f78" translate="yes" xml:space="preserve">
          <source>Natural order</source>
          <target state="translated">자연 질서</target>
        </trans-unit>
        <trans-unit id="c8e6f949b8ada118fdafbdc6ee8783d697f007cb" translate="yes" xml:space="preserve">
          <source>Navigator</source>
          <target state="translated">Navigator</target>
        </trans-unit>
        <trans-unit id="e7b5edc7e8cb311a0b039335c594c9a957eb3175" translate="yes" xml:space="preserve">
          <source>NavigatorConcurrentHardware</source>
          <target state="translated">NavigatorConcurrentHardware</target>
        </trans-unit>
        <trans-unit id="c539be135337dd03c6301959fad0ce1bee475889" translate="yes" xml:space="preserve">
          <source>NavigatorContentUtils</source>
          <target state="translated">NavigatorContentUtils</target>
        </trans-unit>
        <trans-unit id="00b43738cf147df0c752dcea119b953d47ded336" translate="yes" xml:space="preserve">
          <source>NavigatorCookies</source>
          <target state="translated">NavigatorCookies</target>
        </trans-unit>
        <trans-unit id="ca09397d83fa076ca8fa71c95007223165d66fb5" translate="yes" xml:space="preserve">
          <source>NavigatorID</source>
          <target state="translated">NavigatorID</target>
        </trans-unit>
        <trans-unit id="1c556456dba6623478e38282faadace5b5f02feb" translate="yes" xml:space="preserve">
          <source>NavigatorLanguage</source>
          <target state="translated">NavigatorLanguage</target>
        </trans-unit>
        <trans-unit id="b3ab2a10f83370ceafad9f996d8048d28d1a1363" translate="yes" xml:space="preserve">
          <source>NavigatorOnLine</source>
          <target state="translated">NavigatorOnLine</target>
        </trans-unit>
        <trans-unit id="e94d6507f620430ae9754053564c70782f33c7c9" translate="yes" xml:space="preserve">
          <source>NavigatorPlugins</source>
          <target state="translated">NavigatorPlugins</target>
        </trans-unit>
        <trans-unit id="e7f4b2c609e0e06e378710e78e2e3f9dbec6df11" translate="yes" xml:space="preserve">
          <source>Negative values show that it's less than the argument.</source>
          <target state="translated">음수 값은 인수보다 작음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="789280e01339d5a915f0345cf138b9b4fb941c8e" translate="yes" xml:space="preserve">
          <source>Nested and Inner Classes</source>
          <target state="translated">중첩 및 내부 클래스</target>
        </trans-unit>
        <trans-unit id="ee69ace2d0864bd815e214e20536f1f61364fc0f" translate="yes" xml:space="preserve">
          <source>Nested classifiers in enum entries</source>
          <target state="translated">열거 형 항목의 중첩 분류 자</target>
        </trans-unit>
        <trans-unit id="40c58381d790a3e7eec655ca2a16667d8a074dd3" translate="yes" xml:space="preserve">
          <source>Nested declarations in annotation classes</source>
          <target state="translated">주석 클래스의 중첩 선언</target>
        </trans-unit>
        <trans-unit id="d053911ed6d5cc20ee675fd6a4520e78c20b1efb" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;B&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 &quot;B&quot;</target>
        </trans-unit>
        <trans-unit id="8fd58ea9d9361ae87799e3e0adb497216a8850cd" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;ON&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 「ON」</target>
        </trans-unit>
        <trans-unit id="cc8492cfce3dced2f8758c8c41b89e84144de788" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;S&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 &quot;S&quot;</target>
        </trans-unit>
        <trans-unit id="61ee633fcd6ff884b460c34fd4f698e42b8d1f57" translate="yes" xml:space="preserve">
          <source>Neutral bidirectional character type &quot;WS&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 중립 쌍방향 문자 타입 「WS」</target>
        </trans-unit>
        <trans-unit id="9ac5f98640f23386ec33233fa4af214ae29bb68c" translate="yes" xml:space="preserve">
          <source>Never equal to null: for any non-null value &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.equals(null)&lt;/code&gt; should return false.</source>
          <target state="translated">null 이외의 값 : null 이외의 값 &lt;code&gt;x&lt;/code&gt; 의 경우 , &lt;code&gt;x.equals(null)&lt;/code&gt; 는 false를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="c8ca579cfa2a0bc063bd07e3a4d9c7f65e8e3087" translate="yes" xml:space="preserve">
          <source>Never put a space after &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, or before &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; 또는 앞 &lt;code&gt;]&lt;/code&gt; , &lt;code&gt;)&lt;/code&gt; 뒤에 공백을 두지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="9294e60ab9df0dbecb3a72a47335eee294748f65" translate="yes" xml:space="preserve">
          <source>Never put a space around &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;?.&lt;/code&gt;: &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt;, &lt;code&gt;foo?.bar()&lt;/code&gt;</source>
          <target state="translated">주위에 공간을 두지 마십시오 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;?.&lt;/code&gt; : &lt;code&gt;foo.bar().filter { it &amp;gt; 2 }.joinToString()&lt;/code&gt; , &lt;code&gt;foo?.bar()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="989c5da0440d6ef3c75ca61d82d832246ce632de" translate="yes" xml:space="preserve">
          <source>New Kotlin/JS IR compiler</source>
          <target state="translated">새로운 Kotlin / JS IR 컴파일러</target>
        </trans-unit>
        <trans-unit id="845d99d67846936e2a2ecffc0c1f73a93b077848" translate="yes" xml:space="preserve">
          <source>New extensions for &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, and &lt;code&gt;CharSequence&lt;/code&gt; cover such use cases as buffering or batch processing (&lt;code&gt;chunked&lt;/code&gt;), sliding window and computing sliding average (&lt;code&gt;windowed&lt;/code&gt;) , and processing pairs of subsequent items (&lt;code&gt;zipWithNext&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;CharSequence&lt;/code&gt; 의 새로운 확장 기능은 버퍼링 또는 일괄 처리 ( &lt;code&gt;chunked&lt;/code&gt; 처리 ), 슬라이딩 창 및 슬라이딩 평균 계산 ( &lt;code&gt;windowed&lt;/code&gt; ) 및 후속 항목 쌍 처리 ( &lt;code&gt;zipWithNext&lt;/code&gt; ) 와 같은 사용 사례를 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="e22e233ab95d5952f18b874d9870e1b80280d15d" translate="yes" xml:space="preserve">
          <source>New functions were added for converting &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; to and from their bit representations:</source>
          <target state="translated">&lt;code&gt;Double&lt;/code&gt; 과 &lt;code&gt;Float&lt;/code&gt; 를 비트 표현으로 또는 비트 표현으로 변환하기위한 새로운 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1c41e8d2c414e76e3966946fcc4d1e55e43e96ed" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Take a look at the &lt;a href=&quot;../tutorials/getting-started&quot;&gt;Getting Started&lt;/a&gt; page.</source>
          <target state="translated">Kotlin을 처음 사용하십니까? &lt;a href=&quot;../tutorials/getting-started&quot;&gt;시작하기&lt;/a&gt; 페이지를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="28dcc6d65c266a50c3f667c9e5ea8aa135aa58a6" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Take a look at the &lt;a href=&quot;basic-syntax&quot;&gt;Getting Started&lt;/a&gt; page.</source>
          <target state="translated">코 틀린을 처음 사용하십니까? &lt;a href=&quot;basic-syntax&quot;&gt;시작하기&lt;/a&gt; 페이지를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="e9559254cbe41a97686cb7a5c40de455ecdf8ee6" translate="yes" xml:space="preserve">
          <source>New to Kotlin? Visit &lt;a href=&quot;../tutorials/getting-started&quot;&gt;Getting started with Kotlin&lt;/a&gt;.</source>
          <target state="translated">Kotlin을 처음 사용하십니까? &lt;a href=&quot;../tutorials/getting-started&quot;&gt;Kotlin 시작하기를&lt;/a&gt; 방문하세요 .</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="5079a9846101e11db84a1abb592a9473e268055f" translate="yes" xml:space="preserve">
          <source>Next open a new terminal and install Kotlin with:</source>
          <target state="translated">다음으로 새 터미널을 열고 다음과 같이 Kotlin을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="2f460c75911314c0c9543c3367959a31445cb463" translate="yes" xml:space="preserve">
          <source>Next, let's include the following line of code into the &lt;code&gt;MainActivity&lt;/code&gt; class from the &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; file, to the end of the &lt;code&gt;onCreate&lt;/code&gt; method:</source>
          <target state="translated">다음으로 &lt;code&gt;/app/src/main/java/&amp;lt;package&amp;gt;/MainActivity.kt&lt;/code&gt; 파일에서 &lt;code&gt;onCreate&lt;/code&gt; 메소드 의 끝까지 &lt;code&gt;MainActivity&lt;/code&gt; 클래스에 다음 코드 행을 포함시킵니다 .</target>
        </trans-unit>
        <trans-unit id="61e1f7fc790c5246a6e519f4f67f422c4a517358" translate="yes" xml:space="preserve">
          <source>Next, we need to create the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; file with the following content:</source>
          <target state="translated">다음 내용으로 &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; 파일 을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fba44f74cfbe24d927a6f2e32c74f105a6d9ca00" translate="yes" xml:space="preserve">
          <source>Next: Annotations &amp;rarr;</source>
          <target state="translated">다음 : 주석 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="00ef744e43f0f9ea134186c2ef008876b94cfb5d" translate="yes" xml:space="preserve">
          <source>Next: Classes &amp;rarr;</source>
          <target state="translated">다음 : 수업 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="c8735b85302131b9db681cecd1fb40aa277a0558" translate="yes" xml:space="preserve">
          <source>Next: Collections &amp;rarr;</source>
          <target state="translated">다음 : 모음 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="07999039cc4614cf9d9c83d8a64e7926f8829364" translate="yes" xml:space="preserve">
          <source>Next: Compiling and running &amp;rarr;</source>
          <target state="translated">다음 : 컴파일 및 실행 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="f20d28acc929c74946791930cf9c56d2978b64a8" translate="yes" xml:space="preserve">
          <source>Next: Conditionals &amp;rarr;</source>
          <target state="translated">다음 : 조건부 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="840074b0ba8fd90b4e90aa33d45718551b373169" translate="yes" xml:space="preserve">
          <source>Next: Declaring variables &amp;rarr;</source>
          <target state="translated">다음 : 변수 선언 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="cce5126b0175141ca7a8267a7936ebe65fe68d5f" translate="yes" xml:space="preserve">
          <source>Next: Documentation &amp;rarr;</source>
          <target state="translated">다음 : 설명서 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="fa55701df6604b3cecc0d604af09a04554d557b6" translate="yes" xml:space="preserve">
          <source>Next: Exceptions &amp;rarr;</source>
          <target state="translated">다음 : 예외 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6b6aa34eef4e603a14fc427c78ce11728dd25836" translate="yes" xml:space="preserve">
          <source>Next: Extension functions/properties &amp;rarr;</source>
          <target state="translated">다음 : 확장 기능 / 속성 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="085547cea36d9036af28992fd35c78130fafdd20" translate="yes" xml:space="preserve">
          <source>Next: File I/O &amp;rarr;</source>
          <target state="translated">다음 : 파일 I / O &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1ad7d1fc04a3f8f5bb3171b2738d368b2e7962ea" translate="yes" xml:space="preserve">
          <source>Next: Functional programming &amp;rarr;</source>
          <target state="translated">다음 : 기능 프로그래밍 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="4ca230bdec76005c5c8ecf036e517045996d632a" translate="yes" xml:space="preserve">
          <source>Next: Functions &amp;rarr;</source>
          <target state="translated">다음 : 기능 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="ee174e846c5088dfbb38266ba627304b28a4e778" translate="yes" xml:space="preserve">
          <source>Next: Generics &amp;rarr;</source>
          <target state="translated">다음 : 제네릭 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="1fc3a42a52feb37755a354083cafdc34a3336119" translate="yes" xml:space="preserve">
          <source>Next: Hello World &amp;rarr;</source>
          <target state="translated">다음 : Hello World &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="3e18f658842ac7800584f5830d0086c6615ba81e" translate="yes" xml:space="preserve">
          <source>Next: Inheritance &amp;rarr;</source>
          <target state="translated">다음 : 상속 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="e300f7cf6a03c09bab1b47c326855a60fe6e07fb" translate="yes" xml:space="preserve">
          <source>Next: Loops &amp;rarr;</source>
          <target state="translated">다음 : 루프 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="42aae1e29d68a1d88913d08cee33e89180a579d7" translate="yes" xml:space="preserve">
          <source>Next: Member references and reflection &amp;rarr;</source>
          <target state="translated">다음 : 회원 참조 및 반영 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="47130dd2717d7971c3c94623669be8f3f6e6f3ff" translate="yes" xml:space="preserve">
          <source>Next: Null safety &amp;rarr;</source>
          <target state="translated">다음 : Null 안전 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="86e91a1d2169b2b6d5f0e4158807082816cf024d" translate="yes" xml:space="preserve">
          <source>Next: Objects and companion objects &amp;rarr;</source>
          <target state="translated">다음 : 객체 및 컴패니언 객체 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="6bfa5e253a9933523c52548db5718fffcec08ff4" translate="yes" xml:space="preserve">
          <source>Next: Packages and imports &amp;rarr;</source>
          <target state="translated">다음 : 패키지 및 수입품 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="61b315e1a975491d53d3e93505ae2e73a35eccf9" translate="yes" xml:space="preserve">
          <source>Next: Primitive data types and their limitations &amp;rarr;</source>
          <target state="translated">다음 : 기본 데이터 유형 및 제한 사항 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="a8e3f58e4df0923f458764df8d805bc1daaebc52" translate="yes" xml:space="preserve">
          <source>Next: Scoped resource usage &amp;rarr;</source>
          <target state="translated">다음 : 범위 지정된 자원 사용 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="d22ef24051b74c0f8f3a98dbd34b162df22e8d8a" translate="yes" xml:space="preserve">
          <source>Next: Strings &amp;rarr;</source>
          <target state="translated">다음 : 문자열 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="df94caa7ffe6e8dba6f94ac077da12da6df4dd88" translate="yes" xml:space="preserve">
          <source>Next: Visibility modifiers &amp;rarr;</source>
          <target state="translated">다음 : 가시성 수정 자 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="dd6dd817ee9557c6ebd9ce223abe7e65e35724c3" translate="yes" xml:space="preserve">
          <source>Nice utility functions</source>
          <target state="translated">좋은 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="fc6d6d07a9da4b1cf8d3f863c9932b05d0b9d378" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;EXPRESSION&lt;/code&gt; and &lt;code&gt;FILE&lt;/code&gt; among &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;targets&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/index&quot;&gt;대상&lt;/a&gt; 간에 &lt;code&gt;EXPRESSION&lt;/code&gt; 및 &lt;code&gt;FILE&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d50a5c00dba30dbb17216b740546f411fd49910a" translate="yes" xml:space="preserve">
          <source>No custom getter</source>
          <target state="translated">맞춤 게터 없음</target>
        </trans-unit>
        <trans-unit id="c2792086f80dff691fc70c60e9944bd70ee578bb" translate="yes" xml:space="preserve">
          <source>No locks are used to synchronize an access to the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value; if the instance is accessed from multiple threads, its behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 값에 대한 액세스를 동기화하는 데 잠금이 사용되지 않습니다 . 여러 스레드에서 인스턴스에 액세스하면 해당 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1576fb8454236b0d4fa99182ffbcc64b6805f9d7" translate="yes" xml:space="preserve">
          <source>No need to mark the Application class as &lt;em&gt;open&lt;/em&gt; since we are using the &lt;em&gt;kotlin-spring&lt;/em&gt; Gradle plugin which does that automatically.</source>
          <target state="translated">우리가 자동으로 하는 &lt;em&gt;kotlin-spring&lt;/em&gt; Gradle 플러그인을 사용하기 때문에 Application 클래스를 &lt;em&gt;열린&lt;/em&gt; 것으로 표시 할 필요가 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ea178000db803133ca4ed5bf0f26cf40a2ac141" translate="yes" xml:space="preserve">
          <source>No parameters.</source>
          <target state="translated">매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a39dbb3db1c73d98fb6e9bf0a6cc7fe2780640aa" translate="yes" xml:space="preserve">
          <source>No raw types</source>
          <target state="translated">원시 유형 없음</target>
        </trans-unit>
        <trans-unit id="4512f94421443be3bb6fe68bb037823683ccfd0a" translate="yes" xml:space="preserve">
          <source>No-arg compiler plugin</source>
          <target state="translated">인수없는 컴파일러 플러그인</target>
        </trans-unit>
        <trans-unit id="ec11a5bdeaa38cafa1809cd0b1418fa7f8f3cfef" translate="yes" xml:space="preserve">
          <source>No. Kotlin lets you choose between generating Java 6 and Java 8 compatible bytecode. More optimal byte code may be generated for higher versions of the platform.</source>
          <target state="translated">Kotlin을 사용하면 Java 6 및 Java 8 호환 바이트 코드 생성 중에서 선택할 수 있습니다. 더 높은 버전의 플랫폼에 대해 더 최적의 바이트 코드가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3234172e6888dbe6cf68e5d69aca93bdbdb6aa" translate="yes" xml:space="preserve">
          <source>No: called without the context object</source>
          <target state="translated">아니오 : 컨텍스트 객체없이 호출</target>
        </trans-unit>
        <trans-unit id="44924246111ca028f4b377861fa8b1a56b2f8f3f" translate="yes" xml:space="preserve">
          <source>No: takes the context object as an argument.</source>
          <target state="translated">아니오 : 컨텍스트 오브젝트를 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23a71e363ee25bc12526201fd5e1559555edeab5" translate="yes" xml:space="preserve">
          <source>NoSuchElementException</source>
          <target state="translated">NoSuchElementException</target>
        </trans-unit>
        <trans-unit id="9a296716d89fec45e837ec162f0a3cdfae0666f6" translate="yes" xml:space="preserve">
          <source>NoSuchFileException</source>
          <target state="translated">NoSuchFileException</target>
        </trans-unit>
        <trans-unit id="8e965431f22047ddfc939473709e81428fafe4f0" translate="yes" xml:space="preserve">
          <source>NoSuchPropertyException</source>
          <target state="translated">NoSuchPropertyException</target>
        </trans-unit>
        <trans-unit id="dd82911bf9c2f7cf6fe3c3a3a0486e6fd4980949" translate="yes" xml:space="preserve">
          <source>NoWhenBranchMatchedException</source>
          <target state="translated">NoWhenBranchMatchedException</target>
        </trans-unit>
        <trans-unit id="6d1452836a5e358d27de613d82985d8f206e4345" translate="yes" xml:space="preserve">
          <source>NodeFilter</source>
          <target state="translated">NodeFilter</target>
        </trans-unit>
        <trans-unit id="749f705e68c34826a7cc3dffa5cbbe3e73f820de" translate="yes" xml:space="preserve">
          <source>NodeIterator</source>
          <target state="translated">NodeIterator</target>
        </trans-unit>
        <trans-unit id="05a2a8746fe10231011b4d6850be527a41c1c732" translate="yes" xml:space="preserve">
          <source>NodeList</source>
          <target state="translated">NodeList</target>
        </trans-unit>
        <trans-unit id="683af661ab161f85e9822c648db026a9cf30dda6" translate="yes" xml:space="preserve">
          <source>Non-constant vararg annotation parameters</source>
          <target state="translated">불변의 vararg 주석 매개 변수</target>
        </trans-unit>
        <trans-unit id="dc9767217a1c7b0bf421fbdc439c549407505217" translate="yes" xml:space="preserve">
          <source>Non-existent type correction</source>
          <target state="translated">존재하지 않는 유형 수정</target>
        </trans-unit>
        <trans-unit id="fe155a80a88ca53a5855fdd7ccb55154dece22f7" translate="yes" xml:space="preserve">
          <source>Non-external classes can't be extended by external classes.</source>
          <target state="translated">비 외부 클래스는 외부 클래스에 의해 확장 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4faaccd91d30b37f731dad2f02cd8a91e9099b87" translate="yes" xml:space="preserve">
          <source>Non-local returns</source>
          <target state="translated">로컬이 아닌 반품</target>
        </trans-unit>
        <trans-unit id="92dc2c3bbe1e4d97caf60f89e03fd837acb72669" translate="yes" xml:space="preserve">
          <source>Non-private fields</source>
          <target state="translated">비공개 필드</target>
        </trans-unit>
        <trans-unit id="f8f526d37ae54edc0292fa3b9fb52e0ef28cf4f3" translate="yes" xml:space="preserve">
          <source>Non-propagating use</source>
          <target state="translated">전파하지 않는 사용</target>
        </trans-unit>
        <trans-unit id="806c74a6dd444e7b581fe8d0651c3b583f7e4a35" translate="yes" xml:space="preserve">
          <source>NonDocumentTypeChildNode</source>
          <target state="translated">NonDocumentTypeChildNode</target>
        </trans-unit>
        <trans-unit id="928c9a9956e3637b60b5e9617db297b95e7290fd" translate="yes" xml:space="preserve">
          <source>NonElementParentNode</source>
          <target state="translated">NonElementParentNode</target>
        </trans-unit>
        <trans-unit id="d75dfc52cb45227dc75a26a76fe24ef6aeb82f70" translate="yes" xml:space="preserve">
          <source>Normal functions (not marked as inline) cannot have reified parameters. A type that does not have a run-time representation (e.g. a non-reified type parameter or a fictitious type like &lt;code&gt;Nothing&lt;/code&gt;) cannot be used as an argument for a reified type parameter.</source>
          <target state="translated">일반 기능 (인라인으로 표시되지 않음)에는 매개 변수를 수정할 수 없습니다. 런타임 표현이없는 유형 (예 : 비 유형 유형 매개 변수 또는 &lt;code&gt;Nothing&lt;/code&gt; 과 같은 가상 유형 )은 통합 유형 매개 변수의 인수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="49a45a50e6244c47619f28727155a0cbe41bd131" translate="yes" xml:space="preserve">
          <source>Normal methods can be overridden using the &lt;code&gt;override&lt;/code&gt; Kotlin keyword. In this case the overriding method must have the same parameter names as the overridden one.</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; Kotlin 키워드를 사용하여 일반적인 방법을 재정의 할 수 있습니다 . 이 경우 대체 메소드는 대체 메소드와 동일한 매개 변수 이름을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="a916e7bdcd294dc74af71b748cdce7d82df98e31" translate="yes" xml:space="preserve">
          <source>Normally, if you write a Kotlin function with default parameter values, it will be visible in Java only as a full signature, with all parameters present. If you wish to expose multiple overloads to Java callers, you can use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt;&lt;code&gt;@JvmOverloads&lt;/code&gt;&lt;/a&gt; annotation.</source>
          <target state="translated">일반적으로 기본 매개 변수 값으로 Kotlin 함수를 작성하면 모든 매개 변수가있는 Java에서만 전체 서명으로 표시됩니다. 여러 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/index&quot;&gt; &lt;code&gt;@JvmOverloads&lt;/code&gt; &lt;/a&gt; 을 Java 호출자에게 노출하려면 @JvmOverloads 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a89db40e0b8cfbd047b44012190c470a3ee8af7" translate="yes" xml:space="preserve">
          <source>Normally, properties declared as having a non-null type must be initialized in the constructor. However, fairly often this is not convenient. For example, properties can be initialized through dependency injection, or in the setup method of a unit test. In this case, you cannot supply a non-null initializer in the constructor, but you still want to avoid null checks when referencing the property inside the body of a class.</source>
          <target state="translated">일반적으로 null이 아닌 유형으로 선언 된 속성은 생성자에서 초기화해야합니다. 그러나 이것은 종종 편리하지 않습니다. 예를 들어, 속성은 의존성 주입을 통해 또는 단위 테스트의 설정 방법으로 초기화 될 수 있습니다. 이 경우 생성자에서 null이 아닌 이니셜 라이저를 제공 할 수 없지만 클래스 본문 내에서 속성을 참조 할 때 null 검사를 피하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a967d31a488ea79d5210d74fd176b0b854f6d231" translate="yes" xml:space="preserve">
          <source>Not only classes can have type parameters. Functions can, too. Type parameters are placed &lt;strong&gt;before&lt;/strong&gt; the name of the function:</source>
          <target state="translated">클래스 만이 타입 파라미터를 가질 수있는 것은 아닙니다. 기능도 가능합니다. 유형 매개 변수는 함수 이름 &lt;strong&gt;앞에&lt;/strong&gt; 배치 됩니다.</target>
        </trans-unit>
        <trans-unit id="2efce3f5aa2c271d194d1082031602e01c017249" translate="yes" xml:space="preserve">
          <source>Not use any members that take a star-projected type as a parameter</source>
          <target state="translated">별 투영 된 유형을 매개 변수로 사용하는 멤버를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="68b62df2b207d9543eb97cef507795cf7a5eb731" translate="yes" xml:space="preserve">
          <source>Not-null assertion operator</source>
          <target state="translated">널이 아닌 어설 션 연산자</target>
        </trans-unit>
        <trans-unit id="8850b3bd61499741c05bd500ea7929ed489941ca" translate="yes" xml:space="preserve">
          <source>NotImplementedError</source>
          <target state="translated">NotImplementedError</target>
        </trans-unit>
        <trans-unit id="0525b1fa9e28d14aa40cc8644228138fdab333ad" translate="yes" xml:space="preserve">
          <source>Notation for Platform Types</source>
          <target state="translated">플랫폼 유형에 대한 표기법</target>
        </trans-unit>
        <trans-unit id="346c210a245c6f4ac5e207e281e87f32eaf27522" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;the lateinit modifier&lt;/a&gt; allows to declare a non-null type initialized after the object is created (after the constructor call). Without &lt;code&gt;lateinit&lt;/code&gt; you'd have to declare a &lt;a href=&quot;../reference/null-safety&quot;&gt;nullable type&lt;/a&gt; and add additional nullability checks.</source>
          <target state="translated">&lt;a href=&quot;../reference/properties#late-initialized-properties-and-variables&quot;&gt;lateinit 수정자가&lt;/a&gt; 오브젝트를 작성한 후 (생성자 호출 후) 초기화 된 널이 아닌 유형을 선언하는 방법 에 유의하십시오 . &lt;code&gt;lateinit&lt;/code&gt; 가 없으면 &lt;a href=&quot;../reference/null-safety&quot;&gt;널 입력 가능 유형&lt;/a&gt; 을 선언 하고 추가 널 입력 가능 점검을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d92da0b04ba642342db49ac8931c42f19e47f68" translate="yes" xml:space="preserve">
          <source>Note how both the first &lt;code&gt;async&lt;/code&gt; and the awaiting parent are cancelled on failure of one of the children (namely, &lt;code&gt;two&lt;/code&gt;):</source>
          <target state="translated">첫 번째 &lt;code&gt;async&lt;/code&gt; 및 대기중인 부모 모두 자식 중 하나 (즉, &lt;code&gt;two&lt;/code&gt; )가 실패하면 취소되는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ece9aff9cfec4f422a4dd193e67bb220717aeb47" translate="yes" xml:space="preserve">
          <source>Note how easily one may forget the corresponding context element and then still safely access thread local. To avoid such situations, it is recommended to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">해당 컨텍스트 요소를 잊어 버린 다음 여전히 안전하게 로컬 스레드에 액세스 할 수 있습니다. 이러한 상황을 피하려면, 부적절한 사용시 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;verifyPresent&lt;/a&gt; 방법 을 사용 하고 페일-패스트 (fast-fast)하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="27e144234fbe29431367eab42a112f44ba9e6e90" translate="yes" xml:space="preserve">
          <source>Note on visibility</source>
          <target state="translated">가시성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f7e11b4556b13f0f82fdc5bafcd108c64e182fe4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin (automatically bundled into the Kotlin plugin in Android Studio) solves the same issue: replacing &lt;code&gt;findViewById&lt;/code&gt; with a concise and straightforward code. Consider using it unless you're already using ButterKnife and don't want to migrate.</source>
          <target state="translated">하는 것으로 &lt;a href=&quot;android-plugin&quot;&gt;코 틀린 안드로이드 확장&lt;/a&gt; (자동 안드로이드 스튜디오에서 코 틀린 플러그인에 번들) 플러그인이 같은 문제를 해결 : 교체 &lt;code&gt;findViewById&lt;/code&gt; 를을 간결하고 간단한 코드. ButterKnife를 이미 사용 중이 지 않고 마이그레이션하지 않으려면 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b10bef8aca468769cab7ca0f31c1ca35bfeef062" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; is an extension function defined only for channels with non-nullable elements so that there is no accidental confusion between a closed channel and a null value.</source>
          <target state="translated">참고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull는&lt;/a&gt; 폐쇄 채널 및 널 (null) 값 사이의 우발적 인 혼란이 없도록 단지 비 - 널 요소 채널에 대해 정의 된 확장 기능이다.</target>
        </trans-unit>
        <trans-unit id="23cd4a64981ce83f9769929d7af16453dd2385a0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt; is aware of possible consumer pauses and, by default, adjusts next produced element delay if a pause occurs, trying to maintain a fixed rate of produced elements.</source>
          <target state="translated">그 주 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;시세는&lt;/a&gt; 생산 요소의 고정 금리를 유지하기 위해 노력하고, 기본, 일시 정지가 발생하면 다음 요소 지연을 생산가 조정하여 가능한 소비자 일시 정지를 인식하고.</target>
        </trans-unit>
        <trans-unit id="e4f574aa6b81a2a53d14300616da27a08406bc5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;isActive&lt;/a&gt; in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is just a convenient shortcut for &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html&quot;&gt;이 isActive&lt;/a&gt; 에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope는&lt;/a&gt; 단지 편리한 단축키이다 &lt;code&gt;coroutineContext[Job]?.isActive == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="643f0957c5be70b41f4b5877b3662ee68c79f859" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-&lt;/code&gt; is an &lt;em&gt;invalid&lt;/em&gt; symbol in Java, meaning that it's impossible to call functions which accept inline classes from Java.</source>
          <target state="translated">참고 그 &lt;code&gt;-&lt;/code&gt; 입니다 &lt;em&gt;무효&lt;/em&gt; 가 자바에서 인라인 클래스를 받아 함수를 호출하는 것은 불가능하다는 의미에서 자바의 상징.</target>
        </trans-unit>
        <trans-unit id="326418c4e5742c7d5633cf6eb21a36a9bd5007fa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;associate()&lt;/code&gt; produces short-living &lt;code&gt;Pair&lt;/code&gt; objects which may affect the performance. Thus, &lt;code&gt;associate()&lt;/code&gt; should be used when the performance isn't critical or it's more preferable than other options.</source>
          <target state="translated">connect &lt;code&gt;associate()&lt;/code&gt; 는 성능에 영향을 줄 수 있는 수명이 짧은 &lt;code&gt;Pair&lt;/code&gt; 객체를 생성 합니다. 따라서 성능이 중요하지 않거나 다른 옵션보다 선호되는 경우 &lt;code&gt;associate()&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4712744d1c59fe11b666d701399f2acdde076310" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;external&lt;/code&gt; modifier is inherited by nested declarations, i.e. in &lt;code&gt;Node&lt;/code&gt; class we do not put &lt;code&gt;external&lt;/code&gt; before member functions and properties.</source>
          <target state="translated">참고 &lt;code&gt;external&lt;/code&gt; 수정이 중첩 된 선언, 즉 상속 &lt;code&gt;Node&lt;/code&gt; 클래스는 우리는 넣지 마십시오 &lt;code&gt;external&lt;/code&gt; 멤버 함수와 속성 전에.</target>
        </trans-unit>
        <trans-unit id="7c2abf53e89201db42a6d7da34bd24e5d79ffb90" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;jQuery&lt;/code&gt; needs to be included in the corresponding HTML:</source>
          <target state="translated">하는 것으로 &lt;code&gt;jQuery&lt;/code&gt; 를가 해당 HTML에 포함되어야합니다 :</target>
        </trans-unit>
        <trans-unit id="a130b307700ca7edccdf73fda8c49be967259f51" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;null&lt;/em&gt; cannot be cast to &lt;code&gt;String&lt;/code&gt; as this type is not &lt;a href=&quot;null-safety&quot;&gt;nullable&lt;/a&gt;, i.e. if &lt;code&gt;y&lt;/code&gt; is null, the code above throws an exception. In order to match Java cast semantics we have to have nullable type at cast right hand side, like:</source>
          <target state="translated">참고 &lt;em&gt;널 (null)이&lt;/em&gt; 캐스트 할 수없는 &lt;code&gt;String&lt;/code&gt; 이 유형으로는하지 &lt;a href=&quot;null-safety&quot;&gt;Null을 허용&lt;/a&gt; 하는 경우 즉, &lt;code&gt;y&lt;/code&gt; 는 null의 경우, 위의 코드에서 예외가 발생합니다. Java 캐스트 시맨틱을 일치 시키려면 다음과 같이 캐스트 오른쪽에 널 입력 가능 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="50af001ffdcccd71b90632cabd329ef39ee390e5" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;null&lt;/em&gt; cannot be cast to &lt;code&gt;String&lt;/code&gt; as this type is not &lt;a href=&quot;null-safety&quot;&gt;nullable&lt;/a&gt;, i.e. if &lt;code&gt;y&lt;/code&gt; is null, the code above throws an exception. To make such code correct for null values, use the nullable type on the right hand side of the cast:</source>
          <target state="translated">참고 &lt;em&gt;널 (null)이&lt;/em&gt; 캐스트 할 수없는 &lt;code&gt;String&lt;/code&gt; 이 유형으로는하지 &lt;a href=&quot;null-safety&quot;&gt;Null을 허용&lt;/a&gt; 하는 경우 즉, &lt;code&gt;y&lt;/code&gt; 는 null의 경우, 위의 코드에서 예외가 발생합니다. 이러한 코드를 null 값에 맞게 수정하려면 캐스트의 오른쪽에 nullable 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3b25bca041a3db971a025c2e5df5df075febfd74" translate="yes" xml:space="preserve">
          <source>Note that KDoc does not have any syntax for resolving overloaded members in links. Since the Kotlin documentation generation tool puts the documentation for all overloads of a function on the same page, identifying a specific overloaded function is not required for the link to work.</source>
          <target state="translated">KDoc에는 링크에서 오버로드 된 멤버를 해결하기위한 구문이 없습니다. Kotlin 문서 생성 도구는 기능의 모든 과부하에 대한 문서를 동일한 페이지에 배치하므로 링크가 작동하기 위해 특정 오버로드 된 기능을 식별 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="378fb47127c89ebfae61cf028d6a1d9ec0aaa851" translate="yes" xml:space="preserve">
          <source>Note that Kapt does not support multiple rounds for the generated Kotlin files.</source>
          <target state="translated">Kapt는 생성 된 Kotlin 파일에 대해 여러 라운드를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3383898decca7a9f7b6deb5d495a2e5e68df372" translate="yes" xml:space="preserve">
          <source>Note that Kotlin compiler does not apply such mangling to &lt;code&gt;external&lt;/code&gt; declarations, so you don't have to use &lt;code&gt;@JsName&lt;/code&gt; on them. Another case worth noticing is inheriting non-external classes from external classes. In this case any overridden functions won't be mangled as well.</source>
          <target state="translated">Kotlin 컴파일러는 이러한 선언 을 &lt;code&gt;external&lt;/code&gt; 선언에 적용 하지 않으므로 &lt;code&gt;@JsName&lt;/code&gt; 을 사용할 필요가 없습니다 . 주목할만한 또 다른 경우는 외부 클래스에서 비 외부 클래스를 상속하는 것입니다. 이 경우 재정의 된 함수는 엉망이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="123a11d8fa5ed53f8ac07b91892dff993cf556e9" translate="yes" xml:space="preserve">
          <source>Note that Kotlin does not have a &lt;em&gt;new&lt;/em&gt; keyword.</source>
          <target state="translated">Kotlin에는 &lt;em&gt;새로운&lt;/em&gt; 키워드 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="24cefba751ca3442834b1d28297766c4dedb14f5" translate="yes" xml:space="preserve">
          <source>Note that SAM conversions only work for interfaces, not for abstract classes, even if those also have just a single abstract method.</source>
          <target state="translated">SAM 변환은 추상 클래스가 아닌 추상 클래스가 아닌 인터페이스에 대해서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="50497e29cee31d617bb240dff5362b9731a558da" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;for&lt;/code&gt; loop always implicitly declares a new read-only variable (in this example, &lt;code&gt;name&lt;/code&gt;) - if the outer scope already contains a variable with the same name, it will be shadowed by the unrelated loop variable. For the same reason, the final value of the loop variable is not accessible after the loop.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;code&gt;for&lt;/code&gt; 루프가 항상 암시 적으로 (이 예에서는, 새로운 읽기 전용 변수 선언 &lt;code&gt;name&lt;/code&gt; ) - 외부 범위가 이미 같은 이름의 변수를 포함하는 경우, 그것은 관련없는 루프 변수에 의해 그림자가 될 것입니다. 같은 이유로 루프 후 루프 변수의 최종 값에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f345c0305c039a5c5d92b2679df3ab69307a3616" translate="yes" xml:space="preserve">
          <source>Note that a Kotlin class reference is not the same as a Java class reference. To obtain a Java class reference, use the &lt;code&gt;.java&lt;/code&gt; property on a &lt;code&gt;KClass&lt;/code&gt; instance.</source>
          <target state="translated">Kotlin 클래스 참조는 Java 클래스 참조와 동일하지 않습니다. Java 클래스 참조를 얻으려면 &lt;code&gt;KClass&lt;/code&gt; 인스턴스 에서 &lt;code&gt;.java&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0206a8d998dc749c92f53c56e6d927b2e3bb8c96" translate="yes" xml:space="preserve">
          <source>Note that a boxed primitive type used as a type parameter is mapped to a platform type: for example, &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; becomes a &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; in Kotlin.</source>
          <target state="translated">형식 매개 변수로 사용되는 박스형 기본 형식은 플랫폼 형식에 매핑됩니다. 예를 들어 &lt;code&gt;List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; 는 Kotlin에서 &lt;code&gt;List&amp;lt;Int!&amp;gt;&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="cda0f8a2d7cf131c070c968ead3e02616cc75710" translate="yes" xml:space="preserve">
          <source>Note that a file marked with the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation can't contain non-&lt;code&gt;external&lt;/code&gt; declarations.</source>
          <target state="translated">&lt;code&gt;@JsQualifier(...)&lt;/code&gt; 주석으로 표시된 파일 은 비 &lt;code&gt;external&lt;/code&gt; 선언을 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="406525d21e4a3c81c722c7741ff866f95a0130cf" translate="yes" xml:space="preserve">
          <source>Note that a function type with no receiver is inferred by default, even if a variable is initialized with a reference to an extension function. To alter that, specify the variable type explicitly.</source>
          <target state="translated">확장 함수를 참조하여 변수를 초기화하더라도 수신기가없는 함수 유형이 기본적으로 유추됩니다. 이를 변경하려면 변수 유형을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b53df8b9afb9e806e949a0d6af036fa85a8a9db9" translate="yes" xml:space="preserve">
          <source>Note that a module referenced by a dependency declared for &lt;code&gt;commonMain&lt;/code&gt; or &lt;code&gt;commonTest&lt;/code&gt; source set must be published using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin. If you want to use libraries published by the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin, you need to declare a separate source set for common native sources.</source>
          <target state="translated">&lt;code&gt;commonMain&lt;/code&gt; 또는 &lt;code&gt;commonTest&lt;/code&gt; 소스 세트에 선언 된 종속성이 참조하는 모듈 은 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인을 사용하여 공개해야합니다 . &lt;code&gt;kotlin-platform-native&lt;/code&gt; 플러그인에서 게시 한 라이브러리를 사용하려면 공통 기본 소스에 대해 별도의 소스 세트를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="07dbd163eca990505b14bc6390f514e8f9d894c6" translate="yes" xml:space="preserve">
          <source>Note that a read-only variable is not a constant per se: it can be initialized with the value of a variable (so its value doesn't need to be known at compile-time), and if it is declared inside a construct that is repeatedly invoked (such as a function or a loop), it can take on a different value on each invocation. Also, while the read-only variable may not be reassigned while it is in scope, it can still refer to an object which is in itself mutable (such as a list).</source>
          <target state="translated">읽기 전용 변수는 그 자체가 상수가 아닙니다. 변수의 값으로 초기화 할 수 있으므로 (컴파일 타임에 값을 알 필요가 없습니다.) 함수 또는 루프와 같이 반복적으로 호출되면 각 호출마다 다른 값을 취할 수 있습니다. 또한 읽기 전용 변수는 범위 내에있는 동안 재 할당되지 않을 수 있지만 여전히 변경 가능한 객체 (예 : 목록)를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89edad7d707ce970adc3246bd03659328accf5e4" translate="yes" xml:space="preserve">
          <source>Note that all classes in this tutorial are in the &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; package.</source>
          <target state="translated">이 학습서의 모든 클래스는 &lt;code&gt;org.jetbrains.kotlin.demo&lt;/code&gt; 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e339722ad427ded0a06508490a0f24fc47b54f2b" translate="yes" xml:space="preserve">
          <source>Note that altering a mutable collection doesn't require it to be a &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;: write operations modify the same mutable collection object, so the reference doesn't change. Although, if you try to reassign a &lt;code&gt;val&lt;/code&gt; collection, you'll get a compilation error.</source>
          <target state="translated">변경 가능한 컬렉션을 변경한다고해서 &lt;a href=&quot;basic-syntax#defining-variables&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; 가 될 필요는 없습니다 . 쓰기 작업은 동일한 변경 가능한 컬렉션 개체를 수정하므로 참조는 변경되지 않습니다. &lt;code&gt;val&lt;/code&gt; 컬렉션 을 다시 할당하려고 하면 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="402c9cc77c78831d6ef7a6f5b12edeefd76b9797" translate="yes" xml:space="preserve">
          <source>Note that an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder is a dual of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; coroutine builder. An actor is associated with the channel that it receives messages from, while a producer is associated with the channel that it sends elements to.</source>
          <target state="translated">있습니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;배우&lt;/a&gt; 코 루틴 빌더의 듀얼입니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;생산&lt;/a&gt; 코 루틴 빌더. 액터는 메시지를받는 채널과 관련이 있고 프로듀서는 요소를 보내는 채널과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3f7eda5be515629fb292c86295db20e329d1452f" translate="yes" xml:space="preserve">
          <source>Note that an order of &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;comparator&lt;/a&gt; is reversed by this wrapper.</source>
          <target state="translated">이 랩퍼는 &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending%28kotlin.Comparator%28%28kotlin.comparisons.compareByDescending.K%29%29%2C+kotlin.Function1%28%28kotlin.comparisons.compareByDescending.T%2C+kotlin.comparisons.compareByDescending.K%29%29%29%2Fcomparator&quot;&gt;비교기&lt;/a&gt; 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="5d17efed58ea9f37046b141c69cdea45b1227096" translate="yes" xml:space="preserve">
          <source>Note that an order of &lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending(kotlin.Comparator((kotlin.comparisons.compareByDescending.K)),%20kotlin.Function1((kotlin.comparisons.compareByDescending.T,%20kotlin.comparisons.compareByDescending.K)))/comparator&quot;&gt;comparator&lt;/a&gt; is reversed by this wrapper.</source>
          <target state="translated">&lt;a href=&quot;compare-by-descending#kotlin.comparisons%24compareByDescending(kotlin.Comparator((kotlin.comparisons.compareByDescending.K)),%20kotlin.Function1((kotlin.comparisons.compareByDescending.T,%20kotlin.comparisons.compareByDescending.K)))/comparator&quot;&gt;비교기&lt;/a&gt; 의 순서는 이 래퍼에 의해 반전됩니다.</target>
        </trans-unit>
        <trans-unit id="e5cfcc2bcacb2464eb49e0f0ddd2d5c9c0f5de73" translate="yes" xml:space="preserve">
          <source>Note that anonymous function parameters are always passed inside the parentheses. The shorthand syntax allowing to leave the function outside the parentheses works only for lambda expressions.</source>
          <target state="translated">익명 함수 매개 변수는 항상 괄호 안에 전달됩니다. 함수를 괄호 밖에 둘 수있는 속기 구문은 람다 식에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9217d029286f8cd07e91756805e90b92b90c8d04" translate="yes" xml:space="preserve">
          <source>Note that anonymous objects can be used as types only in local and private declarations. If you use an anonymous object as a return type of a public function or the type of a public property, the actual type of that function or property will be the declared supertype of the anonymous object, or &lt;code&gt;Any&lt;/code&gt; if you didn't declare any supertype. Members added in the anonymous object will not be accessible.</source>
          <target state="translated">익명 객체는 로컬 및 개인 선언에서만 유형으로 사용할 수 있습니다. 익명 객체를 공용 함수의 반환 유형 또는 공용 속성의 유형으로 사용하는 경우 해당 함수 또는 속성의 실제 유형은 익명 객체의 선언 된 수퍼 타입이거나, 수퍼 타입을 선언하지 않은 경우 &lt;code&gt;Any&lt;/code&gt; 입니다. . 익명 개체에 추가 된 멤버는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="58e17f85bfcb71bf347b7f266c8bad279b3e8c99" translate="yes" xml:space="preserve">
          <source>Note that another regular expression constructed from the same pattern string may have different &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;options&lt;/a&gt; and may match strings differently.</source>
          <target state="translated">동일한 패턴 문자열로 구성된 다른 정규식은 다른 &lt;a href=&quot;options#kotlin.text.Regex%24options&quot;&gt;옵션을&lt;/a&gt; 가질 수 있으며 문자열을 다르게 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e1195c36b54acff13f3bf0d0c44bfdb9ba62965" translate="yes" xml:space="preserve">
          <source>Note that blank lines do not affect the detected indent level.</source>
          <target state="translated">빈 줄은 감지 된 들여 쓰기 수준에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="901eb90b706fa87b74726ae4ca585fc8ee1df3bd" translate="yes" xml:space="preserve">
          <source>Note that both the target platform and the name matter: if a target was created as &lt;code&gt;jvm('jvm6')&lt;/code&gt;, using &lt;code&gt;jvm()&lt;/code&gt; will create a separate target (with the default name &lt;code&gt;jvm&lt;/code&gt;). If the preset function used to create the target under that name was different, an error is reported.</source>
          <target state="translated">목표는 다음과 같이 생성 된 경우 : 대상 플랫폼과 이름없이 모두 유의 &lt;code&gt;jvm('jvm6')&lt;/code&gt; 사용하여 &lt;code&gt;jvm()&lt;/code&gt; (기본 이름을 가진 별도의 목표 만듭니다 &lt;code&gt;jvm&lt;/code&gt; ). 해당 이름으로 대상을 작성하는 데 사용 된 사전 설정 기능이 다른 경우 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="20a8a158a1c056ad5cea3eaeda038189df025fb8" translate="yes" xml:space="preserve">
          <source>Note that boxing of numbers does not necessarily preserve identity:</source>
          <target state="translated">숫자를 복싱한다고해서 반드시 정체성이 보존되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="18f0c3bd108e4fca3d9b4ad0c92853cb37af67e8" translate="yes" xml:space="preserve">
          <source>Note that cancelling a producer coroutine closes its channel, thus eventually terminating iteration over the channel that processor coroutines are doing.</source>
          <target state="translated">생산자 코 루틴을 취소하면 채널이 닫히고 결국 프로세서 코 루틴이 수행중인 채널에 대한 반복이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a4257481b27fd911ec2dc62a1694406a02635294" translate="yes" xml:space="preserve">
          <source>Note that changing type from unsigned type to signed counterpart (and vice versa) is a &lt;em&gt;binary incompatible&lt;/em&gt; change</source>
          <target state="translated">서명되지 않은 유형에서 서명 된 상대방으로 유형을 변경 하면 그와도 &lt;em&gt;호환되지 않습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb531691886575d5d0b4f4f27624c19223bae127" translate="yes" xml:space="preserve">
          <source>Note that characters are not numbers in Kotlin.</source>
          <target state="translated">Kotlin에서 문자는 숫자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="224781b538ad44d496b4eb9848adbb611bc7607f" translate="yes" xml:space="preserve">
          <source>Note that classes which extend subclasses of a sealed class (indirect inheritors) can be placed anywhere, not necessarily in the same file.</source>
          <target state="translated">봉인 클래스 (간접 상속자)의 서브 클래스를 확장하는 클래스는 반드시 동일한 파일에있을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b347074d3d760a0df60b87ff4401c3b2a375933" translate="yes" xml:space="preserve">
          <source>Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks and property initializers is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</source>
          <target state="translated">이니셜 라이저 블록의 코드는 효과적으로 기본 생성자의 일부가됩니다. 기본 생성자에 대한 위임은 보조 생성자의 첫 번째 문으로 발생하므로 모든 이니셜 라이저 블록 및 속성 이니셜 라이저의 코드는 보조 생성자 본문보다 먼저 실행됩니다. 클래스에 기본 생성자가 없더라도 위임은 여전히 ​​암시 적으로 발생하며 이니셜 라이저 블록은 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b01c476864e020a6b3bdf6a577c404757a04f763" translate="yes" xml:space="preserve">
          <source>Note that code in initializer blocks effectively becomes part of the primary constructor. Delegation to the primary constructor happens as the first statement of a secondary constructor, so the code in all initializer blocks is executed before the secondary constructor body. Even if the class has no primary constructor, the delegation still happens implicitly, and the initializer blocks are still executed:</source>
          <target state="translated">이니셜 라이저 블록의 코드는 효과적으로 기본 생성자의 일부가됩니다. 기본 생성자에 대한 위임은 보조 생성자의 첫 번째 문으로 발생하므로 모든 초기화 블록의 코드는 보조 생성자 본문보다 먼저 실행됩니다. 클래스에 기본 생성자가없는 경우에도 위임은 여전히 ​​암시 적으로 발생하며 초기화 블록은 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="40662d03b687698fb7e2efe397dfb49179bd8a28" translate="yes" xml:space="preserve">
          <source>Note that coroutines are currently considered an &lt;strong&gt;experimental feature&lt;/strong&gt;, meaning that the Kotlin team is not committing to supporting the backwards compatibility of this feature after the final 1.1 release.</source>
          <target state="translated">코 루틴은 현재 &lt;strong&gt;실험적인 기능으로&lt;/strong&gt; 간주됩니다. 즉, Kotlin 팀은 최종 1.1 릴리스 이후이 기능의 이전 버전과의 호환성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abdd0e9fc4f6072582fff7f11143b17405eee64f" translate="yes" xml:space="preserve">
          <source>Note that despite the fact that the right-hand side of &lt;em&gt;as?&lt;/em&gt; is a non-null type &lt;code&gt;String&lt;/code&gt; the result of the cast is nullable.</source>
          <target state="translated">오른쪽의 오른쪽에도 불구하고 &lt;em&gt;? &lt;/em&gt;널이 아닌 유형의 &lt;code&gt;String&lt;/code&gt; 이며 캐스트 결과는 널 입력 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d2338fe045f1f2d5efa433b2cf56bf15940234fd" translate="yes" xml:space="preserve">
          <source>Note that division between integers always returns an integer. Any fractional part is discarded. For example:</source>
          <target state="translated">정수 간 나누기는 항상 정수를 반환합니다. 분수 부분은 모두 버립니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="984acf59abb99e6edf5501246d83e1bc7951b21e" translate="yes" xml:space="preserve">
          <source>Note that even if &lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt; is false, values of the type can still be &lt;code&gt;null&lt;/code&gt;. This may happen if it is a type of the type parameter with a nullable upper bound:</source>
          <target state="translated">&lt;a href=&quot;is-marked-nullable#kotlin.reflect.KType%24isMarkedNullable&quot;&gt;isMarkedNullable&lt;/a&gt; 이 false 인 경우에도 유형 값은 여전히 &lt;code&gt;null&lt;/code&gt; 일 수 있습니다 . 널 입력 가능한 상한이있는 유형 매개 변수의 유형 인 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9717ca7605239239d9b446b8d8baf568533a62a" translate="yes" xml:space="preserve">
          <source>Note that even if you initialize a variable with a reference to an extension function, the inferred function type will have no receiver (it will have an additional parameter accepting a receiver object). To have a function type with receiver instead, specify the type explicitly:</source>
          <target state="translated">확장 함수를 참조하여 변수를 초기화하더라도 유추 함수 유형에는 수신자가 없습니다 (수신자 객체를 허용하는 추가 매개 변수가 있음). 수신자 대신 함수 유형을 가지려면 유형을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e1859932d9a0b691a9fc9411f62e5506be7f8a66" translate="yes" xml:space="preserve">
          <source>Note that even though this is a read-only property due to declaring it with &lt;code&gt;val&lt;/code&gt; (in which case you may not provide a setter), its value can still change since it reads from a mutable property - you just can't assign to the property. Also, note that the property type is inferred from the return value of the getter.</source>
          <target state="translated">이 속성이 &lt;code&gt;val&lt;/code&gt; 로 선언되어 읽기 전용 속성이지만 (이 경우 setter를 제공하지 않을 수 있음) 변경 가능한 속성에서 읽으므로 값이 계속 변경 될 수 있습니다. 특성. 또한 속성 유형은 getter의 반환 값에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="fd6bde9af50a41c1d5f97ea7b48311cc0527806c" translate="yes" xml:space="preserve">
          <source>Note that exceptions are somewhat discouraged in Kotlin except when interacting with Java code. Instead of throwing exceptions in your own code, consider using special return types like &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt; or &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either&lt;/a&gt; from the &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;Arrow library&lt;/a&gt;.</source>
          <target state="translated">Java 코드와 상호 작용할 때를 제외하고 Kotlin에서는 예외가 다소 권장되지 않습니다. 자신의 코드에서 예외를 throw하는 대신 &lt;a href=&quot;https://arrow-kt.io/&quot;&gt;Arrow 라이브러리&lt;/a&gt; 에서 &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/option/&quot;&gt;Option&lt;/a&gt; 또는 &lt;a href=&quot;https://arrow-kt.io/docs/datatypes/either/&quot;&gt;Either&lt;/a&gt; 와 같은 특수 반환 유형을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="33e073ab069310793fb905b91ca3476dc4caf23c" translate="yes" xml:space="preserve">
          <source>Note that expected declarations are not restricted to interfaces and interface members. In this example, the expected class has a constructor and can be created directly from common code. You can apply the &lt;code&gt;expect&lt;/code&gt; modifier to other declarations as well, including top-level declarations and annotations:</source>
          <target state="translated">예상되는 선언은 인터페이스 및 인터페이스 멤버로 제한되지 않습니다. 이 예제에서 예상되는 클래스에는 생성자가 있으며 공통 코드에서 직접 작성할 수 있습니다. 최상위 레벨 선언 및 주석을 포함 하여 &lt;code&gt;expect&lt;/code&gt; 수정자를 다른 선언 에도 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45215a2c612cfc18ca0212e4816f62d8f14fe5b3" translate="yes" xml:space="preserve">
          <source>Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable even if its value is null, and can check for &lt;code&gt;this == null&lt;/code&gt; inside the body. This is what allows you to call toString() in Kotlin without checking for null: the check happens inside the extension function.</source>
          <target state="translated">확장은 널 입력 가능 리시버 유형으로 정의 될 수 있습니다. 이러한 확장은 값이 null 인 경우에도 객체 변수에서 호출 될 수 있으며 본문 내 &lt;code&gt;this == null&lt;/code&gt; 확인할 수 있습니다 . 이것은 null을 확인하지 않고 Kotlin에서 toString ()을 호출 할 수있게하는 것입니다. 확인은 확장 함수 내에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="519b88833afa591c638bec3f6bbeb8adf1aa4ab7" translate="yes" xml:space="preserve">
          <source>Note that for a top level &lt;strong&gt;extension&lt;/strong&gt; property, the delegate is the same for all extension receivers, so the actual &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;receiver&lt;/a&gt; instance passed in is not going to make any difference, it must only be a value of &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;.</source>
          <target state="translated">최상위 &lt;strong&gt;확장&lt;/strong&gt; 속성의 경우 델리게이트는 모든 확장 수신기에 대해 동일하므로 전달 된 실제 &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate%28kotlin.reflect.KProperty1.T%29%2Freceiver&quot;&gt;수신기&lt;/a&gt; 인스턴스는 아무런 차이가 없으며 &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt; 값만 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d2defd349af6dc7f8207169257d4b38f3d3fe54d" translate="yes" xml:space="preserve">
          <source>Note that for a top level &lt;strong&gt;extension&lt;/strong&gt; property, the delegate is the same for all extension receivers, so the actual &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate(kotlin.reflect.KProperty1.T)/receiver&quot;&gt;receiver&lt;/a&gt; instance passed in is not going to make any difference, it must only be a value of &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt;.</source>
          <target state="translated">최상위 &lt;strong&gt;확장&lt;/strong&gt; 속성의 경우 대리자는 모든 확장 수신기에 대해 동일하므로 전달 된 실제 &lt;a href=&quot;get-delegate#kotlin.reflect.KProperty1%24getDelegate(kotlin.reflect.KProperty1.T)/receiver&quot;&gt;수신기&lt;/a&gt; 인스턴스는 차이를 만들지 않으며 &lt;a href=&quot;index#T&quot;&gt;T&lt;/a&gt; 값이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0ed19157d69e7092350d01754dff2c913099ef4" translate="yes" xml:space="preserve">
          <source>Note that for the IDE to correctly analyze the dependencies of the common sources, the common source sets need to have corresponding dependencies on the Kotlin metadata packages in addition to the platform-specific artifact dependencies of the platform-specific source sets. Usually, an artifact with a suffix &lt;code&gt;-common&lt;/code&gt; (as in &lt;code&gt;kotlin-stdlib-common&lt;/code&gt;) or &lt;code&gt;-metadata&lt;/code&gt; is required when using a published library (unless it is published with Gradle metadata, as described below).</source>
          <target state="translated">IDE가 공통 소스의 종속성을 올바르게 분석하려면 공통 소스 세트에는 플랫폼 별 소스 세트의 플랫폼 별 아티팩트 종속성 외에도 Kotlin 메타 데이터 패키지에 대한 해당 종속성이 있어야합니다. 일반적으로 아티팩트 접미사 &lt;code&gt;-common&lt;/code&gt; (같이 &lt;code&gt;kotlin-stdlib-common&lt;/code&gt; ) 또는 &lt;code&gt;-metadata&lt;/code&gt; 가 게시 된 라이브러리를 사용하는 경우 (이 메타 데이터로 Gradle을 발행하지 않는 한 후술하는 바와 같이) 필요하다.</target>
        </trans-unit>
        <trans-unit id="ef903749bbe41c983b27f632974567077577929e" translate="yes" xml:space="preserve">
          <source>Note that for the purpose of this tutorial, we've done a line by line literal translation. Obviously we could write this in a more Kotlin idiomatic way.</source>
          <target state="translated">이 튜토리얼의 목적 상, 라인 단위 리터럴 변환을 수행했습니다. 분명히 우리는 이것을 더 Kotlin 관용적 방식으로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2712e3816fc9fe0e5aede4e3fca67cc623f69a68" translate="yes" xml:space="preserve">
          <source>Note that if a class has got a primary constructor, it is no longer possible to create an instance of it without supplying any parameters (unless one of the secondary constructors is parameterless).</source>
          <target state="translated">클래스에 기본 생성자가 있으면 보조 생성자 중 하나가 매개 변수가없는 한 매개 변수를 제공하지 않고 더 이상 해당 인스턴스를 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b1296c9d04a31b1fde17dffa086ef1b8acdb6c3" translate="yes" xml:space="preserve">
          <source>Note that if a library consumer defines variants that are missing in the library, they need to provide &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;matching fallbacks&lt;/a&gt;. For example, if a library does not have or does not publish a &lt;code&gt;staging&lt;/code&gt; build type, it will be necessary to provide a fallback for the consumers who have such a build type, specifying at least one of the build types that the library publishes:</source>
          <target state="translated">라이브러리 소비자가 라이브러리에서 누락 된 변형을 정의하는 경우 &lt;a href=&quot;https://developer.android.com/studio/build/dependencies#resolve_matching_errors&quot;&gt;일치하는 대체&lt;/a&gt; 를 제공해야 합니다 . 예를 들어, 라이브러리에 &lt;code&gt;staging&lt;/code&gt; 빌드 유형 이 없거나 공개하지 않은 경우 라이브러리가 공개하는 빌드 유형 중 하나 이상을 지정하여 해당 빌드 유형을 가진 소비자에게 대체를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c82c92fd55806c5e9d8d4f7e9db855fd43d5a7a" translate="yes" xml:space="preserve">
          <source>Note that if an inline function has no inlinable function parameters and no &lt;a href=&quot;#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt;, the compiler will issue a warning, since inlining such functions is very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed using the annotation &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt;).</source>
          <target state="translated">인라인 함수에 inlinable 함수 매개 변수가없고 &lt;a href=&quot;#reified-type-parameters&quot;&gt;reified type 매개&lt;/a&gt; 변수가없는 경우 해당 함수를 인라인하는 것이 도움이되지 않기 때문에 컴파일러에서 경고를 발행합니다. 주석 &lt;code&gt;@Suppress(&quot;NOTHING_TO_INLINE&quot;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac1401dfe931b50e5500ce4b2ebac5d2aaf6e00c" translate="yes" xml:space="preserve">
          <source>Note that if an interface with &lt;code&gt;@JvmDefault&lt;/code&gt; methods is used as a &lt;a href=&quot;delegation&quot;&gt;delegate&lt;/a&gt;, the default method implementations are called even if the actual delegate type provides its own implementations.</source>
          <target state="translated">와 인터페이스하는 경우주의 &lt;code&gt;@JvmDefault&lt;/code&gt; 의 방법이 사용된다 &lt;a href=&quot;delegation&quot;&gt;위임&lt;/a&gt; , 기본 메소드 구현은 실제 대리자 형식은 자신의 구현을 제공하는 경우에도이라고합니다.</target>
        </trans-unit>
        <trans-unit id="5c363669dd6ed31274f54972ddb75e1fa04284aa" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;comparator&lt;/code&gt; considers any two keys of this map equal, only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">경우 생성하는 것으로 &lt;code&gt;comparator&lt;/code&gt; 동일한이지도의 두 개의 키를 고려, 이들의 마지막과 관련된 값만 결과지도로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="169507f367051a5b585a09223134ff4c0faab6be" translate="yes" xml:space="preserve">
          <source>Note that if the natural sorting order of keys considers any two keys of this map equal (this could happen if the equality of keys according to &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt; is inconsistent with the equality according to &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt;), only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">키의 자연 정렬 순서가이 맵의 두 키를 동일하게 간주하는 경우 ( &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo%28kotlin.Comparable.T%29&quot;&gt;Comparable.compareTo&lt;/a&gt; 에 따른 키 의 동등성이 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;Any.equals&lt;/a&gt; 에 따른 동등성과 일치하지 않는 경우 발생할 수 있음 ) 마지막 값과 연관된 값만 그들 중 하나는 결과지도에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="e0314127afde0714d8e6361a9b85bacb2fcd7ce9" translate="yes" xml:space="preserve">
          <source>Note that if the natural sorting order of keys considers any two keys of this map equal (this could happen if the equality of keys according to &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo(kotlin.Comparable.T)&quot;&gt;Comparable.compareTo&lt;/a&gt; is inconsistent with the equality according to &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;Any.equals&lt;/a&gt;), only the value associated with the last of them gets into the resulting map.</source>
          <target state="translated">키의 자연스러운 정렬 순서가이 맵의 두 키를 동일하게 간주하는 경우 ( &lt;a href=&quot;../kotlin/-comparable/compare-to#kotlin.Comparable%24compareTo(kotlin.Comparable.T)&quot;&gt;Comparable.compareTo&lt;/a&gt; 에 따른 키 의 동일성이 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;Any.equals&lt;/a&gt; 에 따른 동일성과 일치하지 않는 경우 발생할 수 있음 ) 마지막과 관련된 값만 결과 맵에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fdeead972a4f0dc85a954b4ef35d091c4109a874" translate="yes" xml:space="preserve">
          <source>Note that if the type of the result is known from the context, the type argument can be omitted as usual due to the type inference.</source>
          <target state="translated">결과의 유형이 컨텍스트에서 알려진 경우 유형 유추로 인해 평소처럼 유형 인수를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3df7a58b11ae9c7f677f019b7e29ec36da986c3e" translate="yes" xml:space="preserve">
          <source>Note that if this function fails, then partial copying may have taken place.</source>
          <target state="translated">이 기능이 실패하면 부분 복사가 수행되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e537ff121d99004384d6b13ae0784e74c296eabf" translate="yes" xml:space="preserve">
          <source>Note that if we have called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; in &lt;code&gt;println&lt;/code&gt; and omitted &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; on individual coroutines, then we would have got the sequential behaviour as &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; starts the coroutine execution and waits for the execution to finish, which is not the intended use-case for laziness. The use-case for &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; is a replacement for the standard &lt;code&gt;lazy&lt;/code&gt; function in cases when computation of the value involves suspending functions.</source>
          <target state="translated">&lt;code&gt;println&lt;/code&gt; 에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; 를 호출 하고 개별 코 루틴에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; 를 생략 하면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; 가 코 루틴 실행을 시작하고 실행이 완료 될 때까지 기다리는 것처럼 순차적 인 동작을하게 됩니다. 게으름에 대한 의도 된 사용 사례는 아닙니다. &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; 의 사용 사례는 값 계산에 함수 중단이 포함되는 경우 표준 &lt;code&gt;lazy&lt;/code&gt; 함수를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="ca8da6b3b0810e7069d1865b81c075dccb66b2c6" translate="yes" xml:space="preserve">
          <source>Note that if we just call &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; in &lt;code&gt;println&lt;/code&gt; without first calling &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; on individual coroutines, this will lead to sequential behavior, since &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; starts the coroutine execution and waits for its finish, which is not the intended use-case for laziness. The use-case for &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; is a replacement for the standard &lt;code&gt;lazy&lt;/code&gt; function in cases when computation of the value involves suspending functions.</source>
          <target state="translated">우리가 호출하는 경우 참고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await를&lt;/a&gt; 의 &lt;code&gt;println&lt;/code&gt; 처음 호출하지 않고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;시작&lt;/a&gt; 개별 코 루틴에 있기 때문에,이, 순차적 인 행동으로 이어질 것입니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await를이&lt;/a&gt; 게으름에 대한 사용 목적의 경우하지의 마무리에 대한 코 루틴 실행 및 대기 시작합니다. &lt;code&gt;async(start = CoroutineStart.LAZY)&lt;/code&gt; 의 사용 사례는 값 계산에 함수 일시 중단이 포함되는 경우 표준 &lt;code&gt;lazy&lt;/code&gt; 함수를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="1e82a73f61c52b17d7e3c65e8e99e11241b677f8" translate="yes" xml:space="preserve">
          <source>Note that if you are using multi-project build, you should apply plugin to the main project that is an entry point to your application.</source>
          <target state="translated">다중 프로젝트 빌드를 사용하는 경우 애플리케이션의 진입 점 인 기본 프로젝트에 플러그인을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e39d91f028c6c4bc3b768c071107ff617a7a7685" translate="yes" xml:space="preserve">
          <source>Note that if you use the project template generated by the &lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; service, the &lt;code&gt;kotlin-spring&lt;/code&gt; plugin will be enabled by default.</source>
          <target state="translated">&lt;a href=&quot;http://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; 서비스에서 생성 한 프로젝트 템플릿을 사용하면 &lt;code&gt;kotlin-spring&lt;/code&gt; 플러그인이 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="261071b80b92f5599125de0c5212f010938aeec4" translate="yes" xml:space="preserve">
          <source>Note that if your function has parameters, its name will be mangled, so the mangled name should be used in the keep directive.</source>
          <target state="translated">함수에 매개 변수가 있으면 해당 이름이 맹 글링되므로 맹 글링 된 이름을 keep 지시문에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6917f47d5bafd263295f3acf8a1ef7ab9d827116" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin, outer class does not see private members of its inner classes.</source>
          <target state="translated">Kotlin에서 외부 클래스는 내부 클래스의 비공개 멤버를 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="659e4fb54490f44ab2332ce79f12e2c6749032d5" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin/JS &lt;a href=&quot;../set#kotlin.text%24set(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.Char)&quot;&gt;set&lt;/a&gt; operator function has non-constant execution time complexity. Therefore, increasing length of this string builder and then updating each character by index may slow down your program.</source>
          <target state="translated">Kotlin / JS &lt;a href=&quot;../set#kotlin.text%24set(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.Char)&quot;&gt;집합&lt;/a&gt; 연산자 함수는 실행 시간이 일정하지 않습니다. 따라서이 문자열 작성기의 길이를 늘린 다음 색인별로 각 문자를 업데이트하면 프로그램 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c99e0a3c39d8997895800da0e15222c8aa2ad3b" translate="yes" xml:space="preserve">
          <source>Note that in Kotlin/JS Float range is wider than &quot;single format&quot; bit layout can represent, so some Float values may overflow, underflow or loose their accuracy after conversion to bits and back.</source>
          <target state="translated">Kotlin / JS Float 범위는 &quot;단일 형식&quot;비트 레이아웃이 표현할 수있는 것보다 넓으므로 일부 Float 값은 비트로 또는 그 반대로 변환 한 후 오버플로, 언더 플로 또는 정확도가 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d47ad6334c013775aba391a38df6074a6dc3f4" translate="yes" xml:space="preserve">
          <source>Note that in competitive programming it is customary to give variables shorter names than it is typical in industrial programming practice, since the code is to be written just once and not supported thereafter. However, these names are usually still mnemonic &amp;mdash; &lt;code&gt;a&lt;/code&gt; for arrays, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, etc for indices, &lt;code&gt;r&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; for row and column numbers in tables, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for coordinates, etc. It is easier to keep the same names for input data as it is given in the problem statement. However, more complex problems require more code which leads to using longer self-explanatory variable and function names.</source>
          <target state="translated">경쟁 프로그래밍에서는 코드가 한 번만 작성되고 이후에는 지원되지 않기 때문에 산업 프로그래밍 실습에서 일반적인 것보다 짧은 이름을 변수에 제공하는 것이 일반적입니다. 그러나, 이러한 이름은 여전히 보통 니모닉이다 - 어레이가 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 는 등이 지표에 대한 &lt;code&gt;r&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 테이블의 행 및 열 번호에 대한 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 등의 좌표계, 동일한 이름을 유지하기 쉽다 문제점 설명에 제공된대로 입력 데이터. 그러나 더 복잡한 문제는 더 많은 코드가 필요하므로 더 긴 설명이 필요없는 변수 및 함수 이름을 사용합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24fc67264648157b787a9e1d8a1aee247379a870" translate="yes" xml:space="preserve">
          <source>Note that in many cases there's no need to use custom interoperability library creation mechanisms described below, as for APIs available on the platform standardized bindings called &lt;a href=&quot;platform_libs&quot;&gt;platform libraries&lt;/a&gt; could be used. For example, POSIX on Linux/macOS platforms, Win32 on Windows platform, or Apple frameworks on macOS/iOS are available this way.</source>
          <target state="translated">많은 경우 &lt;a href=&quot;platform_libs&quot;&gt;플랫폼 라이브러리&lt;/a&gt; 라는 플랫폼 표준화 된 바인딩에서 사용 가능한 API를 사용할 수 있으므로 아래에 설명 된 사용자 지정 상호 운용성 라이브러리 생성 메커니즘을 사용할 필요가 없습니다 . 예를 들어 Linux / macOS 플랫폼의 POSIX, Windows 플랫폼의 Win32 또는 macOS / iOS의 Apple 프레임 워크를이 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c3031faf8b33ed043c9d69fe73ae60488938a50" translate="yes" xml:space="preserve">
          <source>Note that in most cases using &lt;a href=&quot;#string-templates&quot;&gt;string templates&lt;/a&gt; or raw strings is preferable to string concatenation.</source>
          <target state="translated">대부분의 경우 문자열 연결보다 &lt;a href=&quot;#string-templates&quot;&gt;문자열 템플릿&lt;/a&gt; 또는 원시 문자열을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8d1e2fa9797125ae266c1521c6c52af5e4d67c8b" translate="yes" xml:space="preserve">
          <source>Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">이 경우 매개 변수를 각 후속 빌드에 추가해야하며 증분 컴파일이 비활성화 된 모든 빌드는 증분 캐시를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="6addd273834de7f83ab126536995cca9dd6643b2" translate="yes" xml:space="preserve">
          <source>Note that incremental annotation processing requires &lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;incremental compilation&lt;/a&gt; to be enabled as well.</source>
          <target state="translated">증분 주석 처리에는 &lt;a href=&quot;using-gradle#incremental-compilation&quot;&gt;증분 컴파일&lt;/a&gt; 도 활성화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b7588c134bcd5e8f4a5da82d120b4047c151b76" translate="yes" xml:space="preserve">
          <source>Note that infix functions always require both the receiver and the parameter to be specified. When you're calling a method on the current receiver using the infix notation, you need to use &lt;code&gt;this&lt;/code&gt; explicitly; unlike regular method calls, it cannot be omitted. This is required to ensure unambiguous parsing.</source>
          <target state="translated">삽입 기능을 사용하려면 항상 수신자와 매개 변수를 모두 지정해야합니다. 접두사 표기법을 사용하여 현재 수신자에서 메소드를 호출 할 때 &lt;code&gt;this&lt;/code&gt; 명시 적으로 사용해야 합니다 . 일반 메소드 호출과 달리 생략 할 수 없습니다. 모호하지 않은 구문 분석을 보장하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ad1d05af6c1aa655f7d3f68b893652c8d8011b1f" translate="yes" xml:space="preserve">
          <source>Note that instead of declaring lambdas in xml like in the following example, you can can bind actions directly in the code:</source>
          <target state="translated">다음 예제와 같이 xml에서 람다를 선언하는 대신 코드에서 직접 액션을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d76391f0c3ceb2cfa6bd1897bb1920148848dd2" translate="yes" xml:space="preserve">
          <source>Note that invoking &lt;code&gt;js()&lt;/code&gt; returns a result of type &lt;a href=&quot;dynamic-type&quot;&gt;&lt;code&gt;dynamic&lt;/code&gt;&lt;/a&gt;, which provides no type safety at compile time.</source>
          <target state="translated">&lt;code&gt;js()&lt;/code&gt; 를 호출 하면 &lt;a href=&quot;dynamic-type&quot;&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;/a&gt; 형식의 결과가 반환 되므로 컴파일 타임에 형식 안전성이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2de64757cb014df0ce60c045d22eb608329bdbb9" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">서스펜션 함수가 실행되는 동일한 스택 프레임에서 &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 함수를 동 기적 으로 호출하지 않는 것이 좋습니다 . 현재 연속 인스턴스를 얻는보다 안전한 방법으로 &lt;a href=&quot;../kotlin.coroutines.experimental/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d6ffb0207257e6147b3a7dc3f05f4b2eb90ba26" translate="yes" xml:space="preserve">
          <source>Note that it is not recommended to call either &lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;Continuation.resume&lt;/a&gt; nor &lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; functions synchronously in the same stackframe where suspension function is run. Use &lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; as a safer way to obtain current continuation instance.</source>
          <target state="translated">서스펜션 함수가 실행되는 동일한 스택 프레임에서 &lt;a href=&quot;../kotlin.coroutines/resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;../kotlin.coroutines/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 함수를 동 기적 으로 호출하지 않는 것이 좋습니다 . 현재 연속 인스턴스를 얻는보다 안전한 방법으로 &lt;a href=&quot;../kotlin.coroutines/suspend-coroutine&quot;&gt;suspendCoroutine&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef6ff08c8afdc4c88bfce216a4201b44bef8d337" translate="yes" xml:space="preserve">
          <source>Note that it's still possible to call the members of the outer receiver, but to do that you have to specify this receiver explicitly:</source>
          <target state="translated">외부 수신자의 멤버를 호출 할 수는 있지만이 수신자를 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a8a5665bc44d5cdbf2531c3d2423dcbe7d87681" translate="yes" xml:space="preserve">
          <source>Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in property initializers declared in the class body:</source>
          <target state="translated">기본 생성자의 매개 변수는 이니셜 라이저 블록에서 사용할 수 있습니다. 클래스 본문에 선언 된 속성 이니셜 라이저에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88ac6b28b3a3b8435f7eba9f01321df2f731f34d" translate="yes" xml:space="preserve">
          <source>Note that right after the &quot;Task from coroutine scope&quot; message (while waiting for nested launch) &quot;Task from runBlocking&quot; is executed and printed &amp;mdash; even though the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is not completed yet.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 가 아직 완료되지 않은 경우에도 &quot;Task from coroutine scope&quot;메시지 (중첩 된 시작을 기다리는 동안) 바로 뒤에 &quot;Task from runBlocking&quot;이 실행되고 인쇄 됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c4053dbcf27c46808a2ab0e8b3303b9f7cbf9a" translate="yes" xml:space="preserve">
          <source>Note that set operations are supported by &lt;code&gt;List&lt;/code&gt; as well. However, the result of set operations on lists is still a &lt;code&gt;Set&lt;/code&gt;, so all the duplicate elements are removed.</source>
          <target state="translated">Set 작업은 &lt;code&gt;List&lt;/code&gt; 에서도 지원됩니다 . 그러나 목록에 대한 set 작업의 결과는 여전히 &lt;code&gt;Set&lt;/code&gt; 이므로 모든 중복 요소가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="205ca8f88f3bcbd4d7774a26be00ee48e66a2ebf" translate="yes" xml:space="preserve">
          <source>Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find &lt;a href=&quot;delegated-properties#local-delegated-properties&quot;&gt;an example&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.1부터는 함수 또는 코드 블록 내에서 위임 된 속성을 선언 할 수 있으므로 반드시 클래스의 구성원 일 필요는 없습니다. 아래 &lt;a href=&quot;delegated-properties#local-delegated-properties&quot;&gt;에서 예를&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecba1bd96686456eab8e7e25340f9f56c1cd293b" translate="yes" xml:space="preserve">
          <source>Note that since Kotlin 1.1 you can declare a delegated property inside a function or code block, it shouldn't necessarily be a member of a class. Below you can find &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;the example&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.1 이후로 함수 또는 코드 블록 내에 위임 속성을 선언 할 수 있으므로 반드시 클래스의 멤버 일 필요는 없습니다. 아래 &lt;a href=&quot;delegated-properties#local-delegated-properties-since-11&quot;&gt;에서 예제를&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f27fe847dccbaf44c3e83c0485bdf6be308f0d6" translate="yes" xml:space="preserve">
          <source>Note that smart casts do not work when the compiler cannot guarantee that the variable cannot change between the check and the usage. More specifically, smart casts are applicable according to the following rules:</source>
          <target state="translated">컴파일러가 변수가 확인과 사용간에 변경 될 수 있음을 보장 할 수없는 경우 스마트 캐스트가 작동하지 않습니다. 보다 구체적으로, 스마트 캐스트는 다음 규칙에 따라 적용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8d16f91fe350efdfdab6da644c90340156b7ba22" translate="yes" xml:space="preserve">
          <source>Note that some Java visibilities such as package-private and protected (which also gives access to items from the same package) cannot be represented in Kotlin, so there's no &lt;a href=&quot;index&quot;&gt;KVisibility&lt;/a&gt; value corresponding to them.</source>
          <target state="translated">package-private 및 protected (동일한 패키지의 항목에 대한 액세스도 제공)와 같은 일부 Java 가시성은 Kotlin에서 표시 할 수 없으므로 이에 해당하는 &lt;a href=&quot;index&quot;&gt;KVisibility&lt;/a&gt; 값 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1c295c01c9e6a32796148120ae2cf2ae77c47235" translate="yes" xml:space="preserve">
          <source>Note that some Java visibilities such as package-private and protected (which also gives access to items from the same package) cannot be represented in Kotlin, so there's no &lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;KVisibility&lt;/a&gt; value corresponding to them.</source>
          <target state="translated">Kotlin에서는 package-private 및 protected (같은 패키지의 항목에 대한 액세스도 제공)와 같은 일부 Java 가시성을 Kotlin에 표시 할 수 없으므로 이에 대응하는 &lt;a href=&quot;index#kotlin.reflect.KVisibility&quot;&gt;KVisibility&lt;/a&gt; 값 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a13526efa441f113eff7267561f09b5212747a9d" translate="yes" xml:space="preserve">
          <source>Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body, but from another execution context, such as a local object or a nested function. In such cases, non-local control flow is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be marked with the &lt;code&gt;crossinline&lt;/code&gt; modifier:</source>
          <target state="translated">일부 인라인 함수는 함수 본문에서 직접가 아니라 로컬 객체 또는 중첩 함수와 같은 다른 실행 컨텍스트에서 매개 변수로 전달 된 람다를 호출 할 수 있습니다. 이러한 경우 람다에서는 로컬이 아닌 제어 흐름도 허용되지 않습니다. 람다 매개 변수는 &lt;code&gt;crossinline&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7e376b19704536e280b87471b9d2f1935ff22e7" translate="yes" xml:space="preserve">
          <source>Note that some of the Kotlin/Native targets require an &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;appropriate host machine&lt;/a&gt; to build on.</source>
          <target state="translated">일부 Kotlin / Native 대상에는 빌드 할 &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;적절한 호스트 시스템&lt;/a&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="36013172d7bed76a773c2a3e7f523422dd3a224f" translate="yes" xml:space="preserve">
          <source>Note that sometimes channels may produce executions that look unfair due to the nature of the executor that is being used. See &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">때때로 사용중인 실행 프로그램의 특성으로 인해 채널에서 실행이 불공정 해 보일 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/issues/111&quot;&gt;이 문제&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c3b5c2f9f97ede3b692c00928df156ad477b585" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JS에서이 인터페이스 의 &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;문자열&lt;/a&gt; 구현은 &lt;a href=&quot;get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 범위를 벗어난 경우 지정되지 않은 동작을 합니다.</target>
        </trans-unit>
        <trans-unit id="459ff0aa9d321691761e4a91e298d7fd73dfd1d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JS에서이 인터페이스 의 &lt;a href=&quot;../-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; 구현은 &lt;a href=&quot;get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 경계를 벗어난 경우 지정되지 않은 동작을가 집니다.</target>
        </trans-unit>
        <trans-unit id="656f0ee95d7b273c3b267aed0322b60e181f19cb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;String&lt;/a&gt; implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JS에서이 인터페이스 의 &lt;a href=&quot;../../kotlin/-string/index#kotlin.String&quot;&gt;문자열&lt;/a&gt; 구현은 &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get%28kotlin.Int%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 범위를 벗어난 경우 지정되지 않은 동작을 합니다.</target>
        </trans-unit>
        <trans-unit id="86d97d17b217564ee55541f4e63de5ad16ee2c54" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;@DslMarker&lt;/code&gt; annotation is available only since Kotlin 1.1.</source>
          <target state="translated">있습니다 &lt;code&gt;@DslMarker&lt;/code&gt; 의 주석 만 코 틀린 1.1부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b3f809dbbb0b87e0e79d9712336f436e1ff493" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;componentN()&lt;/code&gt; functions need to be marked with the &lt;code&gt;operator&lt;/code&gt; keyword to allow using them in a destructuring declaration.</source>
          <target state="translated">&lt;code&gt;componentN()&lt;/code&gt; 선언 (destructuring declaration)에서 사용 하려면 componentN () 함수에 &lt;code&gt;operator&lt;/code&gt; 키워드를 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4929a13b1b30f84a327018335edc5ac7a8c0ec7a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;external&lt;/code&gt; modifier is inherited by nested declarations. This is why in the example &lt;code&gt;Node&lt;/code&gt; class, we do not need to add the &lt;code&gt;external&lt;/code&gt; modifier before member functions and properties.</source>
          <target state="translated">있습니다 &lt;code&gt;external&lt;/code&gt; 수정이 중첩 선언에 의해 상속됩니다. 이것이 &lt;code&gt;Node&lt;/code&gt; 클래스 예제에서 멤버 함수와 속성 앞에 &lt;code&gt;external&lt;/code&gt; 수정자를 추가 할 필요가없는 이유입니다 .</target>
        </trans-unit>
        <trans-unit id="d942ddfab9f982a7bff6988ad53e1b8f734657f3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;kotlin-multiplaform&lt;/code&gt; plugin doesn't create any production binaries by default. The only binary available by default is a debug executable allowing one to run tests from the &lt;code&gt;test&lt;/code&gt; compilation.</source>
          <target state="translated">있습니다 &lt;code&gt;kotlin-multiplaform&lt;/code&gt; 플러그인은 기본적으로 모든 생산 바이너리를 만들지 않습니다. 기본적으로 사용 가능한 바이너리는 &lt;code&gt;test&lt;/code&gt; 컴파일 에서 테스트를 실행할 수있는 디버그 실행 파일 입니다.</target>
        </trans-unit>
        <trans-unit id="c656240136213ce9805ea2877dde6b34a8442c1b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;provideDelegate&lt;/code&gt; method affects only the creation of the auxiliary property and doesn't affect the code generated for getter or setter.</source>
          <target state="translated">있습니다 &lt;code&gt;provideDelegate&lt;/code&gt; 의 방법은 보조 건물의 생성에 영향을 미치고 게터 또는 세터에 대해 생성 된 코드에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaabc3c1b973d9e58d5da5690136b6ca64e5f983" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;rem&lt;/code&gt; operator is supported since Kotlin 1.1. Kotlin 1.0 uses the &lt;code&gt;mod&lt;/code&gt; operator, which is deprecated in Kotlin 1.1.</source>
          <target state="translated">있습니다 &lt;code&gt;rem&lt;/code&gt; 운영자가 코 틀린 1.1부터 지원됩니다. Kotlin 1.0은 &lt;code&gt;mod&lt;/code&gt; 연산자를 사용하며 Kotlin 1.1에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72e01dcbd71cc06e15070eae50092b4b7e9eed02" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;to&lt;/code&gt; notation creates a short-living &lt;code&gt;Pair&lt;/code&gt; object, so it's recommended that you use it only if performance isn't critical. To avoid excessive memory usage, use alternative ways. For example, you can create a mutable map and populate it using the write operations. The &lt;a href=&quot;scope-functions#apply&quot;&gt;&lt;code&gt;apply()&lt;/code&gt;&lt;/a&gt; function can help to keep the initialization fluent here.</source>
          <target state="translated">참고는 것을 &lt;code&gt;to&lt;/code&gt; 표기 짧은 - 생활 생성 &lt;code&gt;Pair&lt;/code&gt; 가 성능이 중요하지 않은 경우에만 사용하는 것이 좋습니다 그래서 개체를. 과도한 메모리 사용을 피하려면 다른 방법을 사용하십시오. 예를 들어, 변경 가능한 맵을 작성하고 쓰기 조작을 사용하여 채울 수 있습니다. &lt;a href=&quot;scope-functions#apply&quot;&gt; &lt;code&gt;apply()&lt;/code&gt; &lt;/a&gt; 함수는 여기에 초기화 유창하게 유지하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14f09727b2d752324269a0d82ae94535e1c1e4e5" translate="yes" xml:space="preserve">
          <source>Note that the String implementation of this interface in Kotlin/JS has unspecified behavior if the &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of its bounds.</source>
          <target state="translated">Kotlin / JS에서이 인터페이스의 String 구현은 &lt;a href=&quot;../../kotlin/-char-sequence/get#kotlin.CharSequence%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 경계를 벗어난 경우 지정되지 않은 동작을가 집니다.</target>
        </trans-unit>
        <trans-unit id="ae0cdfd1c642695da1e12ec7f632f89942b6add0" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 문자 순서는 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunked.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd01abddf25872ce916797664b86dae36d2cc1ac" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunked.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="691b0c57806763a4b2bdecce9c41e605803c5ebe" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 문자 순서는 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.chunkedSequence.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66c2ad296d8e177430bc0fa68ba7b9eb97117778" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last char sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.chunkedSequence.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1754418c79853b8c6ec574fcc023dbf40a7d737e" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 몇몇 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;windowed#kotlin.text%24windowed%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowed.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a3008d758022d0b209de4899387968b8ac78ed4" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 여러 개의 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;windowed#kotlin.text%24windowed(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowed.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="266d21f640d721c4dd41a4ded8abb4f2b56ec11c" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 임시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 몇몇 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence%28kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.CharSequence%2C+kotlin.text.windowedSequence.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e51326b0cfaf636fb6a7d19970d3f5dc2bf4c4ac" translate="yes" xml:space="preserve">
          <source>Note that the char sequence passed to the &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last char sequences may have less characters than the given &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 문자 시퀀스 는 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 여러 개의 마지막 문자 시퀀스는 주어진 &lt;a href=&quot;windowed-sequence#kotlin.text%24windowedSequence(kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.CharSequence,%20kotlin.text.windowedSequence.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eeca19ffbd81bf7218d5ce25611e87d001f58db2" translate="yes" xml:space="preserve">
          <source>Note that the compiler only uses the properties defined inside the primary constructor for the automatically generated functions. To exclude a property from the generated implementations, declare it inside the class body:</source>
          <target state="translated">컴파일러는 자동 생성 된 함수에 기본 생성자 내에 정의 된 속성 만 사용합니다. 생성 된 구현에서 특성을 제외하려면 클래스 본문 내에 특성을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="29a5989520a2bf8fd601f2d782fa7b5f4d18221d" translate="yes" xml:space="preserve">
          <source>Note that the content of &lt;code&gt;platform.posix&lt;/code&gt; is NOT identical on different platforms, in the same way as different &lt;code&gt;POSIX&lt;/code&gt; implementations are a little different.</source>
          <target state="translated">다른 &lt;code&gt;POSIX&lt;/code&gt; 구현이 약간 다른 것과 마찬가지로 &lt;code&gt;platform.posix&lt;/code&gt; 의 내용은 다른 플랫폼에서 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0ba2d2cb4d8f4a9dbc1b85a017969941095acd" translate="yes" xml:space="preserve">
          <source>Note that the databinding expression language uses the same syntax for referring to properties as Kotlin: &lt;code&gt;data.imageUrl&lt;/code&gt;. In Kotlin you can write &lt;code&gt;v.prop&lt;/code&gt; instead of &lt;code&gt;v.getProp()&lt;/code&gt; even if &lt;code&gt;getProp()&lt;/code&gt; is a Java method. Similarly, instead of calling a setter directly, you may use an assignment:</source>
          <target state="translated">참고 데이터 바인딩 표현 언어는 코 틀린와 같은 속성을 참조 동일한 구문을 사용 : &lt;code&gt;data.imageUrl&lt;/code&gt; . Kotlin에서는 &lt;code&gt;getProp()&lt;/code&gt; 가 Java 메소드 인 경우에도 &lt;code&gt;v.getProp()&lt;/code&gt; 대신 &lt;code&gt;v.prop&lt;/code&gt; 를 작성할 수 있습니다 . 마찬가지로 setter를 직접 호출하는 대신 할당을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e38cb3723f44256fc4af27d394f0da73badd7310" translate="yes" xml:space="preserve">
          <source>Note that the first build isn't incremental in any case.</source>
          <target state="translated">첫 번째 빌드는 어떤 경우에도 증분되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3539b1a59eaf5408904eb51b677999543b8a5f8e" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.collections.chunked.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36bd5508df864c7458e1fccd9c81158cc477d507" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.chunked.T)),%20kotlin.collections.chunked.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d6ec3f60ea3d3f0e1450f4fd127d92b3dabc464" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.sequences.chunked.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4dd0c4a7944c546ed18e9237812f399b9a75bb2" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. The last list may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.chunked.T)),%20kotlin.sequences.chunked.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0c9e1743347f1aa8d11316573c39fab1f4d2b86" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 몇 개의 마지막 목록은 주어진 &lt;a href=&quot;windowed#kotlin.collections%24windowed%28kotlin.collections.Iterable%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.collections.windowed.T%29%29%2C+kotlin.collections.windowed.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fccc14666a62fb388999ea11066179edff1c4d5e" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 마지막 목록에는 주어진 &lt;a href=&quot;windowed#kotlin.collections%24windowed(kotlin.collections.Iterable((kotlin.collections.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.collections.windowed.T)),%20kotlin.collections.windowed.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 요소가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a01e230c14a996ac73932af98798f763d520bb" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 보관하거나 어떤 식 으로든 탈출해서는 안됩니다. 몇 개의 마지막 목록은 주어진 &lt;a href=&quot;windowed#kotlin.sequences%24windowed%28kotlin.sequences.Sequence%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Boolean%2C+kotlin.Function1%28%28kotlin.collections.List%28%28kotlin.sequences.windowed.T%29%29%2C+kotlin.sequences.windowed.R%29%29%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01be197fd2cc3bdf986de65122c65771b937478d" translate="yes" xml:space="preserve">
          <source>Note that the list passed to the &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/transform&quot;&gt;transform&lt;/a&gt; function is ephemeral and is valid only inside that function. You should not store it or allow it to escape in some way, unless you made a snapshot of it. Several last lists may have less elements than the given &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 전달 된 목록 은 일시적이며 해당 함수 내에서만 유효합니다. 스냅 샷을 만들지 않는 한 저장하거나 어떤 식 으로든 탈출하도록 허용해서는 안됩니다. 마지막 목록에는 주어진 &lt;a href=&quot;windowed#kotlin.sequences%24windowed(kotlin.sequences.Sequence((kotlin.sequences.windowed.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Boolean,%20kotlin.Function1((kotlin.collections.List((kotlin.sequences.windowed.T)),%20kotlin.sequences.windowed.R)))/size&quot;&gt;크기&lt;/a&gt; 보다 적은 요소가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6259e89a9a4c0b547dbd66ff1bea24b671ef991" translate="yes" xml:space="preserve">
          <source>Note that the module metadata published by Gradle 5.3 and above cannot be read by Gradle versions older than 5.3.</source>
          <target state="translated">Gradle 5.3 이상에서 게시 한 모듈 메타 데이터는 5.3 이전의 Gradle 버전에서는 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="289248f23bcb06f8e447242c0fc575e0c1a20430" translate="yes" xml:space="preserve">
          <source>Note that the named argument syntax cannot be used when calling Java functions, because Java bytecode does not always preserve names of function parameters.</source>
          <target state="translated">Java 바이트 코드가 함수 매개 변수의 이름을 항상 보존하지는 않으므로 Java 함수를 호출 할 때 이름 지정된 인수 구문을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b39b5b0c66187e76139e4031731bcf6a323f589" translate="yes" xml:space="preserve">
          <source>Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.</source>
          <target state="translated">맵이 동시에 수정되는 경우 조작이 원 자성으로 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1adf6c7e534562475c3f5e5643436265ce9a453" translate="yes" xml:space="preserve">
          <source>Note that the opposite reversed translation is not implemented yet: Swift/Objective-C error-throwing methods aren't imported to Kotlin as exception-throwing.</source>
          <target state="translated">반대의 역변환은 아직 구현되지 않았습니다. Swift / Objective-C 오류 발생 메소드는 예외 발생으로 Kotlin에 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13e4f5805154eec53798d94ef883500f35ad56a4" translate="yes" xml:space="preserve">
          <source>Note that the other uses of curly braces in Kotlin, such as in function and class definitions and after &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; statements, are not lambda expressions (so it is &lt;em&gt;not&lt;/em&gt; the case that &lt;code&gt;if&lt;/code&gt; is a function that conditionally executes a lambda function).</source>
          <target state="translated">참고로 이러한 기능 클래스 정의에서와 같이 이후 코 틀린에 중괄호의 다른 용도 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 그것이 있도록 문 (람다 표현하지 &lt;em&gt;아니&lt;/em&gt; 하는 경우, &lt;code&gt;if&lt;/code&gt; 함수 조건부 람다 실행 그 함수).</target>
        </trans-unit>
        <trans-unit id="29cdb0fff079bd2313b913b84a243b2ced642967" translate="yes" xml:space="preserve">
          <source>Note that the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">반환 된 인스턴스는 자체를 사용하여 동기화합니다. 반환 된 인스턴스의 외부 코드와 동기화하지 마십시오. 실수로 교착 상태가 발생할 수 있습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab68d93b5c9158ca99b7d3217cfebeb0bc1dbe0f" translate="yes" xml:space="preserve">
          <source>Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation. For example, reversing &lt;code&gt;&quot;\uDC00\uD800&quot;&lt;/code&gt; produces &lt;code&gt;&quot;\uD800\uDC00&quot;&lt;/code&gt; which is a valid surrogate pair.</source>
          <target state="translated">역방향 작업은 작업 전에 페어링되지 않은 낮은 대리 및 높은 대리 쌍이었던 새 대리 쌍을 생성 할 수 있습니다. 예를 들어, 역전 &lt;code&gt;&quot;\uDC00\uD800&quot;&lt;/code&gt; 생산 &lt;code&gt;&quot;\uD800\uDC00&quot;&lt;/code&gt; 유효한 대리 쌍이다.</target>
        </trans-unit>
        <trans-unit id="99bb4d1e09ed7e1f3f7c48bd69bd7281f7032077" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 추가되는 배열 은 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bc2850950af5238d132e57cd0616b073acff952" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the array being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 빼는 배열 은 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cd8b63a074395eb7bac096117fd2d1a65ca128f" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 추가되는 컬렉션은 &lt;code&gt;iterator&lt;/code&gt; 가 결과 시퀀스에서 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230e838a21a0d86d33ae636264aea12d232d60bc" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the collection being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 빼는 콜렉션 은 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d7a2c8875e7a4328f4bc1cb1a337451636c5765" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being added are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 추가되는 시퀀스는 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6c8e7b439f69f32239265aaaa738e3fcea0362" translate="yes" xml:space="preserve">
          <source>Note that the source sequence and the sequence being subtracted are iterated only when an &lt;code&gt;iterator&lt;/code&gt; is requested from the resulting sequence. Changing any of them between successive calls to &lt;code&gt;iterator&lt;/code&gt; may affect the result.</source>
          <target state="translated">소스 시퀀스와 빼는 시퀀스는 결과 시퀀스에서 &lt;code&gt;iterator&lt;/code&gt; 가 요청 된 경우에만 반복됩니다 . &lt;code&gt;iterator&lt;/code&gt; 연속 호출 사이에서 변경 하면 결과에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f3815a86501d3751673db13b1bc40b17a55063d" translate="yes" xml:space="preserve">
          <source>Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly has only been available since Kotlin 1.1.</source>
          <target state="translated">코드에서 &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;바인딩 된 호출 가능 참조&lt;/a&gt; 를 직접 참조하는 &lt;code&gt;this::prop&lt;/code&gt; 구문 은 Kotlin 1.1 이후에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be4783ce40fed5c138c67544445542f050cb0f80" translate="yes" xml:space="preserve">
          <source>Note that the syntax &lt;code&gt;this::prop&lt;/code&gt; to refer a &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable reference&lt;/a&gt; in the code directly is available only since Kotlin 1.1.</source>
          <target state="translated">코드에서 &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;바인딩 된 호출 가능 참조&lt;/a&gt; 를 직접 참조하기위한 &lt;code&gt;this::prop&lt;/code&gt; 구문 은 Kotlin 1.1 이후에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2949a431bbdf8be1e322b0911e16815ddc68d4b3" translate="yes" xml:space="preserve">
          <source>Note that the terms &quot;subclass&quot; and &quot;superclass&quot; can span multiple levels of inheritance - &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;Any&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt; is the superclass of everything. If we want to restrict ourselves to one level of inheritance, we will say &quot;direct subclass&quot; or &quot;direct superclass&quot;.</source>
          <target state="translated">&quot;서브 클래스&quot;및 &quot;슈퍼 클래스&quot;라는 용어는 여러 수준의 상속을 포함 할 수 있습니다. &lt;code&gt;Car&lt;/code&gt; 는 &lt;code&gt;Any&lt;/code&gt; 의 서브 클래스 이고 &lt;code&gt;Any&lt;/code&gt; 는 모든 것의 슈퍼 클래스입니다. 우리가 하나의 상속 레벨로 제한하고 싶다면 &quot;직접 서브 클래스&quot;또는 &quot;직접 슈퍼 클래스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="6f04df739b130f057070e51840257477306e9abb" translate="yes" xml:space="preserve">
          <source>Note that the trailing newline of each line is stripped. You can also call &lt;code&gt;readLines()&lt;/code&gt; on a file object to get a list of all the lines, or &lt;code&gt;useLines()&lt;/code&gt; to supply a function that will be called on every line. If you simply want the entire file contents as one string or byte array, call &lt;code&gt;readText()&lt;/code&gt; or &lt;code&gt;readBytes()&lt;/code&gt;, respectively.</source>
          <target state="translated">각 줄의 마지막 줄 바꿈이 제거됩니다. 파일 객체에서 &lt;code&gt;readLines()&lt;/code&gt; 를 호출 하여 모든 줄의 목록을 얻거나 &lt;code&gt;useLines()&lt;/code&gt; 를 사용하여 모든 줄에서 호출 할 함수를 제공 할 수도 있습니다. 전체 파일 내용을 하나의 문자열 또는 바이트 배열로 사용 &lt;code&gt;readText()&lt;/code&gt; 또는 &lt;code&gt;readBytes()&lt;/code&gt; 를 각각 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3233b123410bb0637d15ef36074b9c50ad6be8ca" translate="yes" xml:space="preserve">
          <source>Note that the type of a property must be explicitly specified. As opposed to Python, declaring a property directly inside the class does not create a class-level property, but an instance-level one: every instance of &lt;code&gt;Person&lt;/code&gt; will have &lt;em&gt;its own&lt;/em&gt;&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;. Their values will start out in every instance as &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; and &lt;code&gt;32&lt;/code&gt;, respectively, but the value in each instance can be modified independently of the others:</source>
          <target state="translated">속성 유형을 명시 적으로 지정해야합니다. 클래스 수준의 속성을 생성하지 않는 클래스 내부에 직접 속성을 선언, 파이썬에 반대하지만, 인스턴스 레벨의 하나로서 :의 모든 인스턴스 &lt;code&gt;Person&lt;/code&gt; 이됩니다 &lt;em&gt;자신의 &lt;/em&gt; &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; . 해당 값은 모든 인스턴스 에서 각각 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; 및 &lt;code&gt;32&lt;/code&gt; 로 시작 하지만 각 인스턴스의 값은 다른 인스턴스와 독립적으로 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f16b8fd146ff06d4c86373cb61d32bd374065c" translate="yes" xml:space="preserve">
          <source>Note that the type systems of TypeScript and Kotlin do not match exactly, so you may need to edit the generated headers in case you encounter difficulties with using the APIs from Kotlin.</source>
          <target state="translated">TypeScript와 Kotlin의 유형 시스템이 정확히 일치하지 않으므로 Kotlin의 API를 사용하는 데 어려움이있는 경우 생성 된 헤더를 편집해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f31d7eb5e41ba2d64378a5f837d7e8fe985ed7" translate="yes" xml:space="preserve">
          <source>Note that the use of local returns in previous three examples is similar to the use of &lt;em&gt;continue&lt;/em&gt; in regular loops. There is no direct equivalent for &lt;em&gt;break&lt;/em&gt;, but it can be simulated by adding another nesting lambda and non-locally returning from it:</source>
          <target state="translated">이전 세 예제에서 로컬 리턴을 사용하는 것은 일반 루프에서 &lt;em&gt;continue&lt;/em&gt; 를 사용하는 것과 유사합니다 . &lt;em&gt;break&lt;/em&gt; 와 직접적으로 동등한 것은 없지만 다른 중첩 람다를 추가하고 로컬에서 로컬로 반환하여 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8c27f5e2c38c0c780333a188295d27c17547ca" translate="yes" xml:space="preserve">
          <source>Note that there are some cases in which the Kotlin compiler does not apply mangling:</source>
          <target state="translated">Kotlin 컴파일러가 맹 글링을 적용하지 않는 몇 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4baab91a6183da58c03d16fdff1a5962cf6d45a" translate="yes" xml:space="preserve">
          <source>Note that there must be no space between &lt;code&gt;continue&lt;/code&gt;/&lt;code&gt;break&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; / &lt;code&gt;break&lt;/code&gt; 와 &lt;code&gt;@&lt;/code&gt; 사이에는 공백이 없어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9d4ed672615deb4b3ea8e8cf90856dae61208644" translate="yes" xml:space="preserve">
          <source>Note that there's no point in optimizing your code when comparing to &lt;code&gt;null&lt;/code&gt; explicitly: &lt;code&gt;a == null&lt;/code&gt; will be automatically translated to &lt;code&gt;a === null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 과 명시 적으로 비교할 때 코드를 최적화 할 필요는 없습니다 . &lt;code&gt;a == null&lt;/code&gt; 은 자동으로 &lt;code&gt;a === null&lt;/code&gt; 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="29bbb70efdb2913fbd8c12ace3a60040ce02ee39" translate="yes" xml:space="preserve">
          <source>Note that these &lt;code&gt;xxxAsync&lt;/code&gt; functions are &lt;strong&gt;not&lt;/strong&gt;&lt;em&gt;suspending&lt;/em&gt; functions. They can be used from anywhere. However, their use always implies asynchronous (here meaning &lt;em&gt;concurrent&lt;/em&gt;) execution of their action with the invoking code.</source>
          <target state="translated">이 &lt;code&gt;xxxAsync&lt;/code&gt; 함수는 함수를 &lt;em&gt;일시 중단 &lt;/em&gt;&lt;strong&gt;하지 않습니다&lt;/strong&gt; . 어디에서나 사용할 수 있습니다. 그러나 그것들의 사용은 항상 호출 코드로 그들의 액션의 비동기 (여기서는 &lt;em&gt;동시를&lt;/em&gt; 의미 함 ) 실행을 의미 &lt;em&gt;합니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d091dbc112d0275a030bcbf9509f2a82ef36aedb" translate="yes" xml:space="preserve">
          <source>Note that this Comparator does not take locale into account, and will result in an unsatisfactory ordering for certain locales.</source>
          <target state="translated">이 비교기는 로케일을 고려하지 않으므로 특정 로케일에 대한 순서가 만족스럽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf9957e9675cc2706846aa1653497d6600b98d94" translate="yes" xml:space="preserve">
          <source>Note that this example also uses &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads that are created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</source>
          <target state="translated">이 예제는 Kotlin 표준 라이브러리의 &lt;code&gt;use&lt;/code&gt; 함수를 사용 하여 더 이상 필요하지 않은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; 로 작성된 스레드를 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="75aded832e4b3dd5a16b56a1e23cf328870005d2" translate="yes" xml:space="preserve">
          <source>Note that this example also uses the &lt;code&gt;use&lt;/code&gt; function from the Kotlin standard library to release threads created with &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext&lt;/a&gt; when they are no longer needed.</source>
          <target state="translated">이 예제는 Kotlin 표준 라이브러리 의 &lt;code&gt;use&lt;/code&gt; 함수를 사용하여 더 이상 필요하지 않을 때 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/new-single-thread-context.html&quot;&gt;newSingleThreadContext로&lt;/a&gt; 생성 된 스레드를 릴리스 합니다.</target>
        </trans-unit>
        <trans-unit id="ec685b693941d4e96b2af1eef69e4363925a8b20" translate="yes" xml:space="preserve">
          <source>Note that this mechanism currently only works on Java version 1.7+. The JS and Native restrictions are temporary and will be lifted in the future.</source>
          <target state="translated">이 메커니즘은 현재 Java 버전 1.7 이상에서만 작동합니다. JS 및 Native 제한은 일시적이며 향후 해제 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="f0cc5e3b07875e2d5bb6712ec59bb2224c29a52e" translate="yes" xml:space="preserve">
          <source>Note that this only works where &lt;code&gt;b&lt;/code&gt; is immutable (i.e. a local variable which is not modified between the check and the usage or a member &lt;em&gt;val&lt;/em&gt; which has a backing field and is not overridable), because otherwise it might happen that &lt;code&gt;b&lt;/code&gt; changes to &lt;em&gt;null&lt;/em&gt; after the check.</source>
          <target state="translated">여기서 참고이 경우에만 작동 &lt;code&gt;b&lt;/code&gt; 는 불변이다 (즉, 검사 및 사용 또는 구성원 사이에 수정되지 않은 지역 변수 &lt;em&gt;val에&lt;/em&gt; 역행 필드가하고 재정의되지 않습니다) 그렇지 않으면이 일어날 수 있기 때문에, &lt;code&gt;b&lt;/code&gt; 변경 &lt;em&gt;널 (null)을&lt;/em&gt; 한 후 수표.</target>
        </trans-unit>
        <trans-unit id="02cb3aecbee6ce81505199ced32233815d499b61" translate="yes" xml:space="preserve">
          <source>Note that this part of the &lt;code&gt;.def&lt;/code&gt; file is treated as part of the header file, so functions with the body should be declared as &lt;code&gt;static&lt;/code&gt;. The declarations are parsed after including the files from the &lt;code&gt;headers&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;.def&lt;/code&gt; 파일 의이 부분은 헤더 파일의 일부로 취급되므로 본문이있는 함수는 &lt;code&gt;static&lt;/code&gt; 으로 선언해야합니다 . &lt;code&gt;headers&lt;/code&gt; 목록 의 파일을 포함시킨 후 선언이 구문 분석 됩니다.</target>
        </trans-unit>
        <trans-unit id="632fe2c8e3130a19688049106ee9e7cf2e3fa004" translate="yes" xml:space="preserve">
          <source>Note that this way of applying the Kotlin/JS plugin requires adding the following code to Gradle settings file (&lt;code&gt;settings.gradle&lt;/code&gt;):</source>
          <target state="translated">Kotlin / JS 플러그인을 적용하려면 Gradle 설정 파일 ( &lt;code&gt;settings.gradle&lt;/code&gt; )에 다음 코드를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e08e867fd041797206da0cee5969714ae5576c9" translate="yes" xml:space="preserve">
          <source>Note that unlike some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a &lt;code&gt;Double&lt;/code&gt; parameter can be called only on &lt;code&gt;Double&lt;/code&gt; values, but not &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, or other numeric values.</source>
          <target state="translated">다른 언어와 달리 Kotlin에서는 숫자에 대한 암시 적 확장 변환이 없습니다. 예를 들어 &lt;code&gt;Double&lt;/code&gt; 매개 변수가 있는 함수는 &lt;code&gt;Double&lt;/code&gt; 값 에서만 호출 할 수 있지만 &lt;code&gt;Float&lt;/code&gt; , &lt;code&gt;Int&lt;/code&gt; 또는 기타 숫자 값에서는 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5d89b0ac97e4e72ec3a56a39219f1c2ad6cf8c5b" translate="yes" xml:space="preserve">
          <source>Note that we do not use &lt;code&gt;val&lt;/code&gt; in front of &lt;code&gt;maxSpeed&lt;/code&gt; in &lt;code&gt;Car&lt;/code&gt; - doing so would have introduced a distinct property in &lt;code&gt;Car&lt;/code&gt; that would have &lt;em&gt;shadowed&lt;/em&gt; the one inherited from &lt;code&gt;MotorVehicle&lt;/code&gt;. As written, it's just a constructor parameter that we pass on to the superconstructor.</source>
          <target state="translated">우리는 &lt;code&gt;Car&lt;/code&gt; 에서 &lt;code&gt;maxSpeed&lt;/code&gt; 앞에 &lt;code&gt;val&lt;/code&gt; 을 사용하지 않습니다. 그렇게하면 &lt;code&gt;MotorVehicle&lt;/code&gt; 에서 상속 된 것을 &lt;em&gt;섀도 잉&lt;/em&gt; 할 독특한 속성이 &lt;code&gt;Car&lt;/code&gt; 에 도입 되었을 것 입니다. 작성된 바와 같이, 그것은 우리가 슈퍼 컨스트럭터에 전달하는 생성자 매개 변수 일뿐입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32efdf9e14f64cdc5ac4ce116b4cf7f1f66b160c" translate="yes" xml:space="preserve">
          <source>Note that when the LazyThreadSafetyMode.SYNCHRONIZED mode is specified the returned instance uses itself to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">LazyThreadSafetyMode.SYNCHRONIZED 모드가 지정되면 반환 된 인스턴스 자체가 동기화를 위해 사용됩니다. 반환 된 인스턴스의 외부 코드와 동기화하지 마십시오. 실수로 교착 상태가 발생할 수 있습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89d8b71e027e7e428c09aada677d55add6a81f5" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;File()&lt;/code&gt; does create a &quot;file object&quot;, it doesn't actually open the file - the file object is just a reference to the file path; opening the file is a separate action. The preceding functions open and close the file automatically, whereas other functions separately open and close the file. For example, if you're parsing binary data and you don't want to read the entire file at once, you must create an &lt;em&gt;input stream&lt;/em&gt; (for binary data) or an &lt;em&gt;input stream reader&lt;/em&gt; (for strings) - the example below will read 16 bytes:</source>
          <target state="translated">반면 있습니다 &lt;code&gt;File()&lt;/code&gt; 에 &quot;파일 객체&quot;를 만들 않으며, 실제로 파일을 열지 않습니다 - 파일 객체가 파일 경로 단지 참조입니다; 파일을 여는 것은 별도의 작업입니다. 앞의 기능은 파일을 자동으로 열고 닫는 반면 다른 기능은 파일을 개별적으로 열고 닫습니다. 예를 들어, 이진 데이터를 구문 분석하고 전체 파일을 한 번에 읽지 않으려면 &lt;em&gt;입력 스트림&lt;/em&gt; (이진 데이터) 또는 &lt;em&gt;입력 스트림 판독기&lt;/em&gt; (문자열)를 만들어야합니다. 아래 예는 16 바이트 :</target>
        </trans-unit>
        <trans-unit id="14f5320c56ff81654d679ede920646b9dc75066a" translate="yes" xml:space="preserve">
          <source>Note that with Gradle Kotlin DSL, you should get the task from the project's &lt;code&gt;tasks&lt;/code&gt; first.</source>
          <target state="translated">Gradle Kotlin DSL을 사용하면 먼저 프로젝트 작업에서 작업을 가져와야 &lt;code&gt;tasks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c40d9fcf3b6b2afa85b538678b5ccf141165484f" translate="yes" xml:space="preserve">
          <source>Note that you can build the same pipeline using &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/a&gt; coroutine builder from the standard library. Replace &lt;code&gt;produce&lt;/code&gt; with &lt;code&gt;iterator&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; with &lt;code&gt;yield&lt;/code&gt;, &lt;code&gt;receive&lt;/code&gt; with &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;ReceiveChannel&lt;/code&gt; with &lt;code&gt;Iterator&lt;/code&gt;, and get rid of the coroutine scope. You will not need &lt;code&gt;runBlocking&lt;/code&gt; either. However, the benefit of a pipeline that uses channels as shown above is that it can actually use multiple CPU cores if you run it in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context.</source>
          <target state="translated">표준 라이브러리에서 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/iterator&quot;&gt; &lt;code&gt;iterator&lt;/code&gt; &lt;/a&gt; 코 루틴 빌더를 사용하여 동일한 파이프 라인을 빌드 할 수 있습니다 . 교체 &lt;code&gt;produce&lt;/code&gt; 함께 &lt;code&gt;iterator&lt;/code&gt; , &lt;code&gt;send&lt;/code&gt; 와 &lt;code&gt;yield&lt;/code&gt; , &lt;code&gt;receive&lt;/code&gt; 와 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;ReceiveChannel&lt;/code&gt; 와 &lt;code&gt;Iterator&lt;/code&gt; 와 코 루틴 범위 제거하기. &lt;code&gt;runBlocking&lt;/code&gt; 도 필요하지 않습니다 . 그러나 위에 표시된대로 채널을 사용하는 파이프 라인의 이점은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; 컨텍스트 에서 실행하면 실제로 여러 개의 CPU 코어를 사용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="fb9e894663a37dff3bfdff25d326ba2089261968" translate="yes" xml:space="preserve">
          <source>Note that you can open folders in the Source tab and see sources of libraries you are using in your project, including Kotlin standard library (&lt;code&gt;kotlin.js&lt;/code&gt;). This, however, requires that libraries are compiled with source maps enabled, as well as sources embedded into source maps. So the good practice is: if you share a library for Kotlin/JS, please, include source map into distribution.</source>
          <target state="translated">소스 탭에서 폴더를 열고 Kotlin 표준 라이브러리 ( &lt;code&gt;kotlin.js&lt;/code&gt; )를 포함하여 프로젝트에서 사용중인 라이브러리의 소스를 볼 수 있습니다 . 그러나이를 위해서는 소스 맵에 포함 된 소스뿐만 아니라 소스 맵을 사용하여 라이브러리를 컴파일해야합니다. Kotlin / JS 용 라이브러리를 공유하는 경우 소스 맵을 배포에 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="f3d310ef82c3c4cf7ec6ba7c31c24dfd55f8f136" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;em&gt;override&lt;/em&gt; keyword as part of the property declaration in a primary constructor.</source>
          <target state="translated">기본 생성자에서 속성 선언의 일부로 &lt;em&gt;override&lt;/em&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49136291f4ccdd63f93ac650ad3552f2ac330a1e" translate="yes" xml:space="preserve">
          <source>Note that you can't extend a non-external class by external classes.</source>
          <target state="translated">외부 클래스가 아닌 외부 클래스를 확장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e28231afdd7ac958845e417ade6744d2f5c90c1" translate="yes" xml:space="preserve">
          <source>Note that you need to turn on the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental flag&lt;/a&gt; to use &lt;code&gt;LayoutContainer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LayoutContainer&lt;/code&gt; 를 사용 하려면 &lt;a href=&quot;#enabling-experimental-features&quot;&gt;실험 플래그&lt;/a&gt; 를 켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="7606870a12c3125873b69f0dbf82ae21f8b6f6b5" translate="yes" xml:space="preserve">
          <source>Note that, as described in &lt;a href=&quot;classes#secondary-constructors&quot;&gt;Secondary Constructors&lt;/a&gt;, if a class has default values for all constructor parameters, a public no-argument constructor will be generated for it. This works even if the &lt;code&gt;@JvmOverloads&lt;/code&gt; annotation is not specified.</source>
          <target state="translated">&lt;a href=&quot;classes#secondary-constructors&quot;&gt;보조 생성자에&lt;/a&gt; 설명 된대로 클래스에 모든 생성자 매개 변수에 대한 기본값이 있으면 인수가없는 공용 생성자가 생성됩니다. &lt;code&gt;@JvmOverloads&lt;/code&gt; 주석이 지정되지 않은 경우에도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="bcfd3d4bc13c4d196d89ced424f8f78ed6df819a" translate="yes" xml:space="preserve">
          <source>Note that, even though the members of companion objects look like static members in other languages, at runtime those are still instance members of real objects, and can, for example, implement interfaces:</source>
          <target state="translated">컴패니언 객체의 멤버는 다른 언어에서는 정적 멤버처럼 보이지만 런타임에 여전히 실제 객체의 인스턴스 멤버이며 예를 들어 인터페이스를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63673aeff981591d75550c2f1b2c84d22a058b57" translate="yes" xml:space="preserve">
          <source>Note that, if the Java class only has a setter, it will not be visible as a property in Kotlin, because Kotlin does not support set-only properties at this time.</source>
          <target state="translated">Java 클래스에 세터 만있는 경우 Kotlin은 현재 설정 전용 특성을 지원하지 않으므로 Kotlin에서 특성으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ff451e50da6bbf10519c4f38e0ec36c818d0c89" translate="yes" xml:space="preserve">
          <source>Note that, since &lt;em&gt;throw&lt;/em&gt; and &lt;em&gt;return&lt;/em&gt; are expressions in Kotlin, they can also be used on the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:</source>
          <target state="translated">이후, 그 참고 &lt;em&gt;던져&lt;/em&gt; 및 &lt;em&gt;반환&lt;/em&gt; 코 틀린의 표현을, 그들은 또한 엘비스 연산자의 오른쪽에 사용할 수 있습니다. 예를 들어 함수 인수를 확인하는 데 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff2652dcfc51e4dc3d549eb0a81df9a68d2667cc" translate="yes" xml:space="preserve">
          <source>Note that, since extensions do not actually insert members into classes, there's no efficient way for an extension property to have a &lt;a href=&quot;properties#backing-fields&quot;&gt;backing field&lt;/a&gt;. This is why &lt;strong&gt;initializers are not allowed for extension properties&lt;/strong&gt;. Their behavior can only be defined by explicitly providing getters/setters.</source>
          <target state="translated">확장은 실제로 멤버를 클래스에 삽입하지 않으므로 확장 속성에 &lt;a href=&quot;properties#backing-fields&quot;&gt;보조 필드&lt;/a&gt; 가있는 효율적인 방법은 없습니다 . 이 때문에 &lt;strong&gt;초기화 프로그램은 확장 속성을 사용할 수 없습니다&lt;/strong&gt; . 그들의 행동은 getter / setter를 명시 적으로 제공해야만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410e3cbb9102efe17f7c84d061da15f92debf764" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;@NotNull&lt;/code&gt; annotations on &lt;code&gt;String&lt;/code&gt; type arguments. Without them, we get platform types in the type arguments:</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 유형 인수 에 &lt;code&gt;@NotNull&lt;/code&gt; 주석을 적어 둡니다 . 그것들이 없으면, 우리는 타입 인자에서 플랫폼 타입을 얻는다 :</target>
        </trans-unit>
        <trans-unit id="c5849a883ad401340758801d94c3c8fe5489e593" translate="yes" xml:space="preserve">
          <source>Note the difference between declaring two parameters and declaring a destructuring pair instead of a parameter:</source>
          <target state="translated">두 개의 매개 변수 선언과 매개 변수 대신 파괴 쌍 선언의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="fe84360ef08152f70a600e469dd1daf46f251b07" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;visibility modifier&lt;/a&gt; here. While the concept of visibility modifier is not relevant for competitive programming at all, it allows you to place multiple solution files based on the same template without getting an error for conflicting public declarations in the same package.</source>
          <target state="translated">여기 에서 &lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;../reference/visibility-modifiers&quot;&gt;가시성 수정자를 사용&lt;/a&gt; 하십시오. 가시성 수정 자의 개념은 경쟁 프로그래밍과 전혀 관련이 없지만 동일한 패키지에서 공개 선언 충돌에 대한 오류없이 동일한 템플릿을 기반으로 여러 솔루션 파일을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32363778a2d483af8b5e294fa0d257703c3636de" translate="yes" xml:space="preserve">
          <source>Note the use of Kotlin's &lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;null-assertion operator&lt;/a&gt;&lt;code&gt;!!&lt;/code&gt; after the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;readLine()&lt;/a&gt; function call. Kotlin's &lt;code&gt;readLine()&lt;/code&gt; function is defined to return a &lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;nullable type&lt;/a&gt;&lt;code&gt;String?&lt;/code&gt; and returns &lt;code&gt;null&lt;/code&gt; on the end of the input, which explicitly forces the developer to handle the case of missing input.</source>
          <target state="translated">Kotlin의 &lt;a href=&quot;../reference/null-safety#the--operator&quot;&gt;널 어설 션 연산자를 사용하십시오 &lt;/a&gt; &lt;code&gt;!!&lt;/code&gt; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/read-line&quot;&gt;readLine ()&lt;/a&gt; 함수 호출 후 Kotlin의 &lt;code&gt;readLine()&lt;/code&gt; 함수는 &lt;a href=&quot;../reference/null-safety#nullable-types-and-non-null-types&quot;&gt;nullable 유형 &lt;/a&gt; &lt;code&gt;String?&lt;/code&gt; 을 반환하도록 정의되어 있습니까? 입력의 끝에서 &lt;code&gt;null&lt;/code&gt; 을 반환 하여 개발자가 입력이 누락 된 경우를 명시 적으로 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ac2f2aad869d626d4d52fe790ab55573fcf5e8e3" translate="yes" xml:space="preserve">
          <source>Note, Kotlin/Native object references do not support multi-threaded access. Hosting the returned &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; pointer per thread might be necessary.</source>
          <target state="translated">Kotlin / 네이티브 객체 참조는 다중 스레드 액세스를 지원하지 않습니다. 스레드 당 리턴 된 &lt;code&gt;libnative_ExportedSymbols*&lt;/code&gt; 포인터를 호스팅해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b78a1550dcdacf66568124ca1b7e49361c24581" translate="yes" xml:space="preserve">
          <source>Note, here we use the &lt;code&gt;$SRCROOT/../..&lt;/code&gt; as the path to the root of our Gradle project. It can depend on the way the Xcode project was created. Also, we use the generated &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; script, the &lt;code&gt;packForXCode&lt;/code&gt; task generates it. We assumed that the Gradle build is executed at least once, before opening the Xcode project on a fresh machine</source>
          <target state="translated">여기서는 &lt;code&gt;$SRCROOT/../..&lt;/code&gt; 를 Gradle 프로젝트의 루트 경로로 사용합니다. Xcode 프로젝트가 생성 된 방식에 따라 달라질 수 있습니다. 또한 생성 된 &lt;code&gt;SharedCode/build/xcode-frameworks/gradlew&lt;/code&gt; 스크립트를 사용하며 &lt;code&gt;packForXCode&lt;/code&gt; 태스크가이를 생성합니다. 새로운 머신에서 Xcode 프로젝트를 열기 전에 Gradle 빌드가 적어도 한 번 실행되는 것으로 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="e681d434ce2d0ba5fe65e1c3eb9e64a72c2114ad" translate="yes" xml:space="preserve">
          <source>Note, how both first &lt;code&gt;async&lt;/code&gt; and awaiting parent are cancelled on the one child failure:</source>
          <target state="translated">하나의 자식 실패에서 첫 번째 &lt;code&gt;async&lt;/code&gt; 및 대기중인 부모가 모두 취소되는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa14e718dbed55afbde738f5e7d1fbd2fe0275f6" translate="yes" xml:space="preserve">
          <source>Note, however, that members overridden in this way do not get called from the members of the delegate object, which can only access its own implementations of the interface members:</source>
          <target state="translated">그러나 이런 식으로 재정의 된 멤버는 대리자 개체의 멤버에서 호출되지 않으며, 인터페이스 멤버의 자체 구현에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c0fd4e85cb25d5c9ec03f575f81a0e9dd952a9" translate="yes" xml:space="preserve">
          <source>Note, that Android has first-party support for coroutine scope in all entities with the lifecycle. See &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope&quot;&gt;the corresponding documentation&lt;/a&gt;.</source>
          <target state="translated">Android는 수명주기가있는 모든 항목의 코 루틴 범위에 대한 자사 지원을 제공합니다. &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope&quot;&gt;해당 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9016aa7ea4f2b1fc5592a3d2b46f69f0ff3c825e" translate="yes" xml:space="preserve">
          <source>Note, that an exception thrown by &lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;transform&lt;/a&gt; function is rethrown by this function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</source>
          <target state="translated">&lt;a href=&quot;recover#kotlin%24recover%28kotlin.Result%28%28kotlin.recover.T%29%29%2C+kotlin.Function1%28%28kotlin.Throwable%2C+kotlin.recover.R%29%29%29%2Ftransform&quot;&gt;변환&lt;/a&gt; 함수에 의해 발생 된 예외 는이 함수에 의해 다시 발생 합니다. 예외를 캡슐화하는 대안 은 &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab4261a565eea01ddcb4378ad59c0c58898851cf" translate="yes" xml:space="preserve">
          <source>Note, that for some cases cycle collection need to be done to ensure that dead cycles do not affect reachability of passed object graph.</source>
          <target state="translated">경우에 따라 사용 불능주기가 전달 된 객체 그래프의 도달 가능성에 영향을 미치지 않도록주기 수집을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb746582c1d18af800034f12e0c2fb36cf93a443" translate="yes" xml:space="preserve">
          <source>Note, that incrementing and decrementing &lt;code&gt;acquired&lt;/code&gt; counter here from 100K coroutines is completely safe, since it always happens from the same main thread. More on that will be explained in the next chapter on coroutine context.</source>
          <target state="translated">여기에서 100K 코 루틴에서 &lt;code&gt;acquired&lt;/code&gt; 카운터 를 증가 및 감소시키는 것은 항상 동일한 메인 스레드에서 발생하기 때문에 완전히 안전합니다. 이에 대한 자세한 내용은 코 루틴 컨텍스트에 대한 다음 장에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b6259b2eebc86f15dafec32912cdde080c4e1580" translate="yes" xml:space="preserve">
          <source>Note, that the generated bindings are generally platform-specific, so if you are developing for multiple targets, the bindings need to be regenerated.</source>
          <target state="translated">생성 된 바인딩은 일반적으로 플랫폼별로 다르므로 여러 대상을 개발하는 경우 바인딩을 재생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b7682c3f874c25b43973c6dea774be8a4df50c1" translate="yes" xml:space="preserve">
          <source>Note, that this function rethrows any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;recover#kotlin%24recover(kotlin.Result((kotlin.recover.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recover.R)))/transform&quot;&gt;transform&lt;/a&gt; function. See &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; for an alternative that encapsulates exceptions.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;recover#kotlin%24recover(kotlin.Result((kotlin.recover.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recover.R)))/transform&quot;&gt;변환&lt;/a&gt; 함수에 의해 throw 된 모든 &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외를 다시 발생 시킵니다. 예외를 캡슐화하는 대안 은 &lt;a href=&quot;recover-catching&quot;&gt;recoverCatching&lt;/a&gt; 을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="fe80340489c5eb8bbb1e5235c463cea51b0d96bc" translate="yes" xml:space="preserve">
          <source>Note, the task may not work &lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;correctly&lt;/a&gt; if you use Gradle older than 4.10. In this tutorial we have already &lt;a href=&quot;#gradle-upgrade&quot;&gt;upgraded it to 4.7&lt;/a&gt;.</source>
          <target state="translated">4.10보다 오래된 Gradle을 사용하면 작업이 &lt;a href=&quot;https://github.com/gradle/gradle/issues/6330&quot;&gt;올바르게&lt;/a&gt; 작동하지 않을 수 있습니다. 이 학습서에서는 이미 &lt;a href=&quot;#gradle-upgrade&quot;&gt;4.7로 업그레이드했습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cdfb7f6c960fbbb54ec2a22474d762eebb5eb578" translate="yes" xml:space="preserve">
          <source>Note, the way Kotlin/Native exports symbols is subject to change without notice.</source>
          <target state="translated">Kotlin / Native 내보내기 기호는 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a421385920384e5f4a176ab3c70967301467e475" translate="yes" xml:space="preserve">
          <source>Note, this mechanism currently works only on Java version 1.7+. Limitation on JS and Native is temporary and will be fixed in the future.</source>
          <target state="translated">이 메커니즘은 현재 Java 버전 1.7 이상에서만 작동합니다. JS 및 Native에 대한 제한은 일시적이며 향후 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="12618a61ea26af57372d00837c08269ccff8b13d" translate="yes" xml:space="preserve">
          <source>Note, we use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from a &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type, to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers.</source>
          <target state="translated">&lt;code&gt;memScoped&lt;/code&gt; 람다 리시버 유형 에서 제공되는 확장 특성 &lt;code&gt;ptr&lt;/code&gt; 을 사용하여 &lt;code&gt;MyStruct&lt;/code&gt; 및 &lt;code&gt;MyUnion&lt;/code&gt; 인스턴스를 기본 포인터로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="928235a3ea58117b013d6814e6ae398b8d106eb5" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver (&lt;code&gt;this&lt;/code&gt;) undergoes</source>
          <target state="translated">참고 : &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies%28kotlin.Boolean%29%2FbooleanExpression&quot;&gt;booleanExpression&lt;/a&gt; 은 함수 매개 변수 또는 수신자 ( &lt;code&gt;this&lt;/code&gt; )가 발생하는 부울 표현식의 서브 세트 만 승인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="154a86bc22d004fb84d8a8a0b6c888692235178f" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies(kotlin.Boolean)/booleanExpression&quot;&gt;booleanExpression&lt;/a&gt; can accept only a subset of boolean expressions, where a function parameter or receiver (&lt;code&gt;this&lt;/code&gt;) undergoes</source>
          <target state="translated">참고 : &lt;a href=&quot;implies#kotlin.contracts.SimpleEffect%24implies(kotlin.Boolean)/booleanExpression&quot;&gt;booleanExpression&lt;/a&gt; 은 함수 매개 변수 또는 수신자 ( &lt;code&gt;this&lt;/code&gt; )가 겪는 부울 표현식의 하위 집합 만 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6981f24296bbc00cf0e0f8db9ec6624b3daecbcc" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Any&lt;/code&gt; is not &lt;code&gt;java.lang.Object&lt;/code&gt;; in particular, it does not have any members other than &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;toString()&lt;/code&gt;. Please consult the &lt;a href=&quot;java-interop#object-methods&quot;&gt;Java interoperability&lt;/a&gt; section for more details.</source>
          <target state="translated">주 : &lt;code&gt;Any&lt;/code&gt; 는 &lt;code&gt;java.lang.Object&lt;/code&gt; 가 아닙니다 . 특히 &lt;code&gt;equals()&lt;/code&gt; , &lt;code&gt;hashCode()&lt;/code&gt; 및 &lt;code&gt;toString()&lt;/code&gt; 이외의 멤버는 없습니다 . 자세한 내용 은 &lt;a href=&quot;java-interop#object-methods&quot;&gt;Java 상호 운용성&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7cea38b31131e5f3bc473b1806a7dadc1df3f76c" translate="yes" xml:space="preserve">
          <source>Note: Before 1.3.40, both test and product executables were represented by the same binary type. Thus to access the default test binary created by the plugin, the following line was used:</source>
          <target state="translated">참고 : 1.3.40 이전에는 테스트 및 제품 실행 파일이 모두 동일한 이진 유형으로 표시되었습니다. 따라서 플러그인으로 작성된 기본 테스트 바이너리에 액세스하기 위해 다음 행이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb3a30630df8eec859177fc75c5dd700ee60baec" translate="yes" xml:space="preserve">
          <source>Note: For Spring you can use the &lt;code&gt;kotlin-spring&lt;/code&gt; compiler plugin (&lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;see below&lt;/a&gt;).</source>
          <target state="translated">참고 : Spring의 경우 &lt;code&gt;kotlin-spring&lt;/code&gt; 컴파일러 플러그인을 사용할 수 있습니다 ( &lt;a href=&quot;compiler-plugins#spring-support&quot;&gt;아래 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d6a0dc39a4a138257b96c621b751cc052081b76a" translate="yes" xml:space="preserve">
          <source>Note: This above code will work properly only on JDK7+ that supports &lt;code&gt;suppressed&lt;/code&gt; exceptions</source>
          <target state="translated">참고 :이 위의 코드는 &lt;code&gt;suppressed&lt;/code&gt; 예외 를 지원 하는 JDK7 +에서만 올바르게 작동합니다</target>
        </trans-unit>
        <trans-unit id="484cdded81040d7cac731a5df3e0b2162661d2db" translate="yes" xml:space="preserve">
          <source>Note: creating a source set does not link it to any target. Some source sets are &lt;a href=&quot;#default-project-layout&quot;&gt;predefined&lt;/a&gt; and thus compiled by default. However, custom source sets always need to be explicitly directed to the compilations. See: &lt;a href=&quot;#connecting-source-sets&quot;&gt;Connecting source sets&lt;/a&gt;.</source>
          <target state="translated">참고 : 소스 세트를 작성해도 해당 소스 세트가 링크되지 않습니다. 일부 소스 세트는 &lt;a href=&quot;#default-project-layout&quot;&gt;사전 정의&lt;/a&gt; 되어 기본적으로 컴파일됩니다. 그러나 사용자 정의 소스 세트는 항상 컴파일에 명시 적으로 지시되어야합니다. &lt;a href=&quot;#connecting-source-sets&quot;&gt;소스 세트 연결을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d3cb30c99fb08c5217d1cecd77b25e0a37cf168" translate="yes" xml:space="preserve">
          <source>Note: due to the current technical limitations, the IDE does not correctly recognize these annotations on type arguments in compiled Java libraries that are used as dependencies.</source>
          <target state="translated">참고 : 현재 기술적 인 한계로 인해 IDE는 종속성으로 사용되는 컴파일 된 Java 라이브러리의 유형 인수에 대한 이러한 주석을 올바르게 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="43526e690a06b94dffa5d82ef9ea46b38220defe" translate="yes" xml:space="preserve">
          <source>Note: runtime lookup can be forced even when the class is referenced statically from Objective-C source code by adding &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; to its &lt;code&gt;@interface&lt;/code&gt;.</source>
          <target state="translated">참고 : 클래스가 &lt;code&gt;@interface&lt;/code&gt; 에 &lt;code&gt;__attribute__((objc_runtime_visible))&lt;/code&gt; 을 추가하여 클래스가 Objective-C 소스 코드에서 정적으로 참조되는 경우에도 런타임 조회를 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="961c619d9fb3964975b4b9e69245c681552524a7" translate="yes" xml:space="preserve">
          <source>Note: static and shared libraries has suffixes &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;shared&lt;/code&gt; respectively, e.g. &lt;code&gt;fooDebugStatic&lt;/code&gt; or &lt;code&gt;barReleaseShared&lt;/code&gt;</source>
          <target state="translated">참고 : 정적 라이브러리와 공유 라이브러리에는 각각 &lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;shared&lt;/code&gt; 접미어가 있습니다 (예 : &lt;code&gt;fooDebugStatic&lt;/code&gt; 또는 &lt;code&gt;barReleaseShared&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0ba0ca9c0ff727e2f159f9a318e2b4838c970baa" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;lib&lt;/code&gt; directory which contains &lt;code&gt;kotlin.js&lt;/code&gt; and other library files is only created in IntelliJ IDEA-based projects and is controlled by the &lt;em&gt;Copy library runtime files&lt;/em&gt; flag in the Kotlin &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;facet settings&lt;/a&gt;. In a Maven or Gradle build (including multiplatform projects), no library files are copied by default to the compilation output directory. See the corresponding tutorials for the instructions on how to achieve the same with those build systems.</source>
          <target state="translated">참고 : &lt;code&gt;kotlin.js&lt;/code&gt; 및 기타 라이브러리 파일이 포함 된 &lt;code&gt;lib&lt;/code&gt; 디렉토리 는 IntelliJ IDEA 기반 프로젝트에서만 작성되며 Kotlin &lt;a href=&quot;https://www.jetbrains.com/help/idea/facets.html&quot;&gt;패싯 설정&lt;/a&gt; 의 &lt;em&gt;라이브러리 런타임 파일 복사&lt;/em&gt; 플래그에 의해 제어됩니다 . Maven 또는 Gradle 빌드 (멀티 플랫폼 프로젝트 포함)에서 라이브러리 파일은 기본적으로 컴파일 출력 디렉토리에 복사되지 않습니다. 해당 빌드 시스템으로이를 달성하는 방법에 대한 지시 사항은 해당 학습서를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a0e64e270b153ff90968e1ff6456ea22567f491" translate="yes" xml:space="preserve">
          <source>Note: the built-in JSR-305 annotations &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt;&lt;code&gt;@Nonnull&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt;&lt;code&gt;@Nullable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt;&lt;code&gt;@CheckForNull&lt;/code&gt;&lt;/a&gt; are always enabled and affect the types of the annotated declarations in Kotlin, regardless of compiler configuration with the &lt;code&gt;-Xjsr305&lt;/code&gt; flag.</source>
          <target state="translated">참고 : 내장 JSR-305 어노테이션 &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nonnull.html&quot;&gt; &lt;code&gt;@Nonnull&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/Nullable.html&quot;&gt; &lt;code&gt;@Nullable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/CheckForNull.html&quot;&gt; &lt;code&gt;@CheckForNull&lt;/code&gt; &lt;/a&gt; 은 항상 사용 가능하며 &lt;code&gt;-Xjsr305&lt;/code&gt; 플래그를 사용한 컴파일러 구성에 관계없이 Kotlin의 어노테이션이있는 선언 유형에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="70ea34d1da722222e140a53cf5465f6882b21617" translate="yes" xml:space="preserve">
          <source>Note: the migration status of a nullability annotation is not inherited by its type qualifier nicknames but is applied to its usages in default type qualifiers.</source>
          <target state="translated">참고 : Null 허용 주석의 마이그레이션 상태는 형식 한정자 닉네임으로 상속되지 않지만 기본 형식 한정자의 사용법에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0edc7da32b33f24605529da7af1e0f20a415a52" translate="yes" xml:space="preserve">
          <source>Note: the static members of these Java types are not directly accessible on the &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;companion objects&lt;/a&gt; of the Kotlin types. To call them, use the full qualified names of the Java types, e.g. &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt;.</source>
          <target state="translated">참고 : 이러한 Java 유형의 정적 멤버 는 Kotlin 유형 의 &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;컴패니언 오브젝트&lt;/a&gt; 에서 직접 액세스 할 수 없습니다 . 이를 호출하려면 Java 유형의 완전한 이름 &lt;code&gt;java.lang.Integer.toHexString(foo)&lt;/code&gt; 예 : java.lang.Integer.toHexString (foo))을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="58d630dc0f3f2c164372b5befca4a458dbf430dc" translate="yes" xml:space="preserve">
          <source>Note: the types in this example only take place with the strict mode enabled, otherwise, the platform types remain. See the &lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt;&lt;code&gt;@UnderMigration&lt;/code&gt; annotation&lt;/a&gt; and &lt;a href=&quot;#compiler-configuration&quot;&gt;Compiler configuration&lt;/a&gt; sections.</source>
          <target state="translated">참고 :이 예제의 유형은 엄격 모드가 활성화 된 경우에만 발생하며, 그렇지 않으면 플랫폼 유형이 유지됩니다. &lt;a href=&quot;#undermigration-annotation-since-1160&quot;&gt; &lt;code&gt;@UnderMigration&lt;/code&gt; 주석&lt;/a&gt; 및 &lt;a href=&quot;#compiler-configuration&quot;&gt;컴파일러 구성&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1897db2fc3536b91b9cf29ef737cb27b1a12735f" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">참고 :이 주석은 실험용 입니다. 옵트 인 방법에 대해서는 &lt;a href=&quot;../-experimental-multiplatform/index&quot;&gt;ExperimentalMultiplatform&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b4255d1b07a5ecec5778c495ae7e465e074b5b4" translate="yes" xml:space="preserve">
          <source>Note: this annotation is experimental, see &lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt; on how to opt-in for it.</source>
          <target state="translated">참고 :이 주석은 실험용 입니다. 옵트 인 방법에 대해서는 &lt;a href=&quot;../../kotlin.experimental/-experimental-type-inference/index&quot;&gt;ExperimentalTypeInference&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="357bf8828e4f466867f5aa8f9b5bb6f1a07b487b" translate="yes" xml:space="preserve">
          <source>Note: to use a visible top-level declaration from another package, you should still &lt;a href=&quot;packages#imports&quot;&gt;import&lt;/a&gt; it.</source>
          <target state="translated">참고 : 다른 패키지에서 보이는 최상위 선언을 사용하려면 여전히 &lt;a href=&quot;packages#imports&quot;&gt;가져와야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4f0d56c46129caef4c0e06f3c8334481a847bd34" translate="yes" xml:space="preserve">
          <source>Note: unlike Java, arrays in Kotlin are invariant. This means that Kotlin does not let us assign an &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; to an &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt;, which prevents a possible runtime failure (but you can use &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt;, see &lt;a href=&quot;generics#type-projections&quot;&gt;Type Projections&lt;/a&gt;).</source>
          <target state="translated">참고 : Java와 달리 Kotlin의 배열은 변하지 않습니다. 이것은 Kotlin이 &lt;code&gt;Array&amp;lt;String&amp;gt;&lt;/code&gt; 을 &lt;code&gt;Array&amp;lt;Any&amp;gt;&lt;/code&gt; 할당 하지 못하게하여 런타임 실패를 방지합니다 (그러나 &lt;code&gt;Array&amp;lt;out Any&amp;gt;&lt;/code&gt; 사용할 수 있습니다 ( &lt;a href=&quot;generics#type-projections&quot;&gt;Type Projections&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="4481948392a8846400c954e77f58d76cdaa73963" translate="yes" xml:space="preserve">
          <source>Nothing</source>
          <target state="translated">Nothing</target>
        </trans-unit>
        <trans-unit id="79090fccdb94d09e1c560c62dc8ff6d888bc7489" translate="yes" xml:space="preserve">
          <source>Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example, if a function has the return type of Nothing, it means that it never returns (always throws an exception).</source>
          <target state="translated">인스턴스가 없습니다. Nothing을 사용하여 &quot;존재하지 않는 값&quot;을 나타낼 수 있습니다. 예를 들어 함수에 반환 유형이 Nothing 인 경우 반환되지 않는 것을 의미합니다 (항상 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="a531e5857d96a6fe172e33a54636fa2c5e7837a4" translate="yes" xml:space="preserve">
          <source>Notice that the implementation on &lt;em&gt;every&lt;/em&gt; platform can encode byte arrays to a string. If we want we can provide a more efficient implementation for this method, for example, let's specialize it on the JVM:</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 플랫폼 에서 구현하면 바이트 배열을 문자열로 인코딩 할 수 있습니다. 예를 들어,이 메소드에 대해보다 효율적인 구현을 제공 할 수 있도록하려면 JVM에서 특수화하십시오.</target>
        </trans-unit>
        <trans-unit id="ac46cd6bf2ec7e9d90f5e3709af6c843ffd8a6af" translate="yes" xml:space="preserve">
          <source>NotificationAction</source>
          <target state="translated">NotificationAction</target>
        </trans-unit>
        <trans-unit id="f541255e0e0d091ef01be7d639674756d30f41bc" translate="yes" xml:space="preserve">
          <source>NotificationDirection</source>
          <target state="translated">NotificationDirection</target>
        </trans-unit>
        <trans-unit id="596349e0f504aa4e6ec1f31115a62914042449e8" translate="yes" xml:space="preserve">
          <source>NotificationEventInit</source>
          <target state="translated">NotificationEventInit</target>
        </trans-unit>
        <trans-unit id="2a1a4c24d8e083b47b4ff678b4cd0997219c060e" translate="yes" xml:space="preserve">
          <source>NotificationOptions</source>
          <target state="translated">NotificationOptions</target>
        </trans-unit>
        <trans-unit id="93c639dc73db96edc66ede2299276f652971fac6" translate="yes" xml:space="preserve">
          <source>NotificationPermission</source>
          <target state="translated">NotificationPermission</target>
        </trans-unit>
        <trans-unit id="94e838061a82a5ce0b113db3557cf9f9730866ea" translate="yes" xml:space="preserve">
          <source>Now check it with the command &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; and you should see a successful build. That's it, our library is now successfully published and any Kotlin project can depend on it, whether it is another common library, JVM, JS, or Native application.</source>
          <target state="translated">이제 &lt;code&gt;./gradlew publishToMavenLocal&lt;/code&gt; 명령 으로 확인하면 성공적인 빌드가 표시됩니다. 이제 라이브러리가 성공적으로 게시되었으며 다른 일반적인 라이브러리, JVM, JS 또는 기본 응용 프로그램인지 여부에 관계없이 모든 Kotlin 프로젝트에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6fdd021c50c395969a31c37923d25d734b30ed" translate="yes" xml:space="preserve">
          <source>Now compile the program linking with the library we have just created:</source>
          <target state="translated">이제 방금 만든 라이브러리와 연결하는 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="7fd938355a267ec17f411c8d98d04708e4180da6" translate="yes" xml:space="preserve">
          <source>Now it is time to provide an &lt;code&gt;actual&lt;/code&gt; implementation of &lt;code&gt;Base64Factory&lt;/code&gt; for every platform.</source>
          <target state="translated">이제 모든 플랫폼에 대해 &lt;code&gt;Base64Factory&lt;/code&gt; 의 &lt;code&gt;actual&lt;/code&gt; 구현 을 제공 할 차례 입니다.</target>
        </trans-unit>
        <trans-unit id="ef159996af2b9215562c38a942c2f8905195f55d" translate="yes" xml:space="preserve">
          <source>Now it is time to refresh the Gradle project again in Android Studio. Click &lt;em&gt;Sync Now&lt;/em&gt; on the yellow stripe or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the &lt;code&gt;Refresh&lt;/code&gt; action in the context menu on the root Gradle project. The &lt;code&gt;:SharedCode&lt;/code&gt; project should be recognized by the IDE now.</source>
          <target state="translated">이제 Android Studio에서 Gradle 프로젝트를 다시 새로 고칠 차례입니다. 노란색 줄무늬에서 &lt;em&gt;지금 동기화를&lt;/em&gt; 클릭 하거나 &lt;em&gt;Gradle&lt;/em&gt; 도구 창을 사용 하고 루트 Gradle 프로젝트의 상황에 맞는 메뉴에서 &lt;code&gt;Refresh&lt;/code&gt; 작업을 클릭하십시오 . &lt;code&gt;:SharedCode&lt;/code&gt; 의 프로젝트는 이제 IDE에 의해 인식되어야한다.</target>
        </trans-unit>
        <trans-unit id="9eb8c10ce256de217fd7408c5d0fa2be1c81f16b" translate="yes" xml:space="preserve">
          <source>Now it is time to see how to use &lt;code&gt;cValue&lt;/code&gt; and pass by-value parameters:</source>
          <target state="translated">이제 &lt;code&gt;cValue&lt;/code&gt; 를 사용 하고 값을 기준으로 매개 변수를 전달 하는 방법을 살펴볼 차례입니다 .</target>
        </trans-unit>
        <trans-unit id="f62049422e34abdef8fb40e736ddaa894413b1d4" translate="yes" xml:space="preserve">
          <source>Now it prints something sensible: &lt;code&gt;1784293664&lt;/code&gt;, because all coroutines complete.</source>
          <target state="translated">이제 모든 코 루틴이 완료 &lt;code&gt;1784293664&lt;/code&gt; 합리적인 것을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="144f2d2ebae18220179fd1c455d34a68896fdfc7" translate="yes" xml:space="preserve">
          <source>Now it prints something sensible: &lt;code&gt;500000500000&lt;/code&gt;, because all coroutines complete.</source>
          <target state="translated">이제 모든 코 루틴이 완료 되었기 때문에 &lt;code&gt;500000500000&lt;/code&gt; 이라는 합리적인 것을 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="9c3c5f110103dcae6c7a1c5048ae4801a489102c" translate="yes" xml:space="preserve">
          <source>Now it's time to add the task description. Click the &lt;strong&gt;Edit&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel to switch to the editing mode:</source>
          <target state="translated">이제 작업 설명을 추가 할 차례입니다. &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 상단의 &lt;strong&gt;편집&lt;/strong&gt; 아이콘을 클릭하여 편집 모드로 전환하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f21a6f3ded0ce3ad0d37be7f610a6bcde3237278" translate="yes" xml:space="preserve">
          <source>Now let us launch five processors and let them work for almost a second. See what happens:</source>
          <target state="translated">이제 5 개의 프로세서를 시작하고 거의 1 초 동안 작동하도록하겠습니다. 어떻게되는지보십시오 :</target>
        </trans-unit>
        <trans-unit id="3a85707fc6ed973d97aee272da025f72a2062245" translate="yes" xml:space="preserve">
          <source>Now let's check out the contents of the library:</source>
          <target state="translated">이제 라이브러리의 내용을 확인하십시오 :</target>
        </trans-unit>
        <trans-unit id="06f1756ff063bdd720deb57bebdc098cbb1f3682" translate="yes" xml:space="preserve">
          <source>Now let's open the project in IntelliJ IDEA. For that we click on the File | Open&amp;hellip; and select our &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; project file.</source>
          <target state="translated">이제 IntelliJ IDEA에서 프로젝트를 엽니 다. 이를 위해 File | &amp;hellip;를 열고 &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; 프로젝트 파일을 선택 하십시오.</target>
        </trans-unit>
        <trans-unit id="62863dbb3bcee301c0e208573e6e92993330cf1e" translate="yes" xml:space="preserve">
          <source>Now let's see how it works in practice:</source>
          <target state="translated">이제 실제로 어떻게 작동하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="316006c9bf1b6b4efc24b9287e973de18a0cd5b2" translate="yes" xml:space="preserve">
          <source>Now let's write the same with sequences:</source>
          <target state="translated">이제 시퀀스로 동일하게 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a94f1a0ca142aa8eb48c8af48afa3350f83b1400" translate="yes" xml:space="preserve">
          <source>Now need to create an empty &lt;code&gt;settings.gradle.kts&lt;/code&gt;&lt;code&gt;settings.gradle&lt;/code&gt; file in the project root directory.</source>
          <target state="translated">이제 프로젝트 루트 디렉토리에 빈 &lt;code&gt;settings.gradle.kts&lt;/code&gt; &lt;code&gt;settings.gradle&lt;/code&gt; 파일 을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c9080cd76ec0143ae2c7fdafc332586543b3c8a" translate="yes" xml:space="preserve">
          <source>Now the application is ready to run. The easiest way is to click the green &lt;strong&gt;Run&lt;/strong&gt; icon in the gutter and select &lt;strong&gt;Run 'AppKt'&lt;/strong&gt;.</source>
          <target state="translated">이제 응용 프로그램을 실행할 준비가되었습니다. 가장 쉬운 방법은 거터에서 녹색 &lt;strong&gt;실행&lt;/strong&gt; 아이콘 을 클릭하고 &lt;strong&gt;'AppKt'실행을&lt;/strong&gt; 선택하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a4dea9f6780cb4b1fb116abe461c884b2fc3e6f5" translate="yes" xml:space="preserve">
          <source>Now the classic &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt; can be used. Don't forget to specify the group and version of your library along with the plugin in &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">이제 고전적인 &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;플러그인을&lt;/a&gt; 사용할 수 있습니다. &lt;code&gt;build.gradle&lt;/code&gt; 의 플러그인과 함께 라이브러리의 그룹과 버전을 지정하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c36da2f63965003675ecd4f90e9e76c88deea8db" translate="yes" xml:space="preserve">
          <source>Now the main function awaits for the first of them to complete and counts the number of deferred values that are still active. Note that we've used here the fact that &lt;code&gt;select&lt;/code&gt; expression is a Kotlin DSL, so we can provide clauses for it using an arbitrary code. In this case we iterate over a list of deferred values to provide &lt;code&gt;onAwait&lt;/code&gt; clause for each deferred value.</source>
          <target state="translated">이제 주 함수는 첫 번째 함수가 완료되기를 기다리고 여전히 활성화 된 지연된 값의 수를 계산합니다. 여기서는 &lt;code&gt;select&lt;/code&gt; 표현식이 Kotlin DSL 이라는 사실을 사용 했으므로 임의 코드를 사용하여 절을 제공 할 수 있습니다. 이 경우 지연된 값 목록을 반복 하여 각 지연된 값에 대해 &lt;code&gt;onAwait&lt;/code&gt; 절 을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="fafa6b7e1e97bd8d0310f07c3ffc916e9bc52c4e" translate="yes" xml:space="preserve">
          <source>Now the result is still the same, but the code of the main coroutine is not tied to the duration of the background job in any way. Much better.</source>
          <target state="translated">이제 결과는 여전히 동일하지만 메인 코 루틴 코드는 백그라운드 작업의 지속 시간과 관련이 없습니다. 훨씬 낫다.</target>
        </trans-unit>
        <trans-unit id="68e76914b57b2c484d2fcdeac9dacb63ea15843e" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">이제 &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 그렇게하는 동안 C 함수가 Kotlin / Native 선언에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0cc37329b152a7d48d832f02d3782a3273c9a922" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</source>
          <target state="translated">이제 &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 그렇게하는 동안 C 프리미티브 유형이 Kotlin / Native에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="280651c06a20fde5cc37b475316ca2430a0a1d40" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">이제 &lt;a href=&quot;basic-kotlin-native-app#open-in-ide&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 이를 수행하는 동안 C 함수가 Kotlin / 네이티브 선언에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="323fc12d5da11d2d2fc025d2cb42257bb510df5c" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">이제 &lt;a href=&quot;using-intellij-idea&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 이 과정에서 C 함수가 Kotlin / Native 선언에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b20c24d185e4d030be0d0a6f1a94b265b8692d27" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing that, we'll examine how C primitive types are mapped into Kotlin/Native.</source>
          <target state="translated">이제 &lt;a href=&quot;using-intellij-idea&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 이를 수행하는 동안 C 기본 유형이 Kotlin / Native에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3c161d0d7217a9d942a7808aa2fde773f92818a9" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;using-intellij-idea&quot;&gt;open the project in IntelliJ IDEA&lt;/a&gt; and to see how to fix the example project. While doing this, we'll examine how C functions are mapped into Kotlin/Native declarations.</source>
          <target state="translated">이제 &lt;a href=&quot;using-intellij-idea&quot;&gt;IntelliJ IDEA에서 프로젝트&lt;/a&gt; 를 열고 예제 프로젝트를 수정하는 방법을 볼 준비가되었습니다 . 이 과정에서 C 함수가 Kotlin / Native 선언에 어떻게 매핑되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8514872c5f66d71d839c86ef7b8ede3a7f8b037f" translate="yes" xml:space="preserve">
          <source>Now we are ready to compile our &lt;code&gt;main.c&lt;/code&gt; into an executable. We include the generated &lt;code&gt;libnative.lib&lt;/code&gt; into the build command and start:</source>
          <target state="translated">이제 &lt;code&gt;main.c&lt;/code&gt; 를 실행 파일로 컴파일 할 준비가되었습니다 . 생성 된 &lt;code&gt;libnative.lib&lt;/code&gt; 를 빌드 명령에 포함시키고 시작합니다 :</target>
        </trans-unit>
        <trans-unit id="bd615a740472938a27e61f3e5ad1d8c088398a62" translate="yes" xml:space="preserve">
          <source>Now we build our pipeline by starting a stream of numbers from 2, taking a prime number from the current channel, and launching new pipeline stage for each prime number found:</source>
          <target state="translated">이제 2에서 숫자 스트림을 시작하고 현재 채널에서 소수를 취하고 발견 된 각 소수에 대해 새로운 파이프 라인 단계를 시작하여 파이프 라인을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="b09d5a8ac24e62ac515e5408d015b6449705f5ff" translate="yes" xml:space="preserve">
          <source>Now we have implementations on all the platforms and it is time to move to testing of our library.</source>
          <target state="translated">이제 모든 플랫폼에서 구현되었으며 라이브러리 테스트로 넘어갈 차례입니다.</target>
        </trans-unit>
        <trans-unit id="6fc43d604b99f2dfefc014ae5ff71405690d454a" translate="yes" xml:space="preserve">
          <source>Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</source>
          <target state="translated">이제 코드에서 C 선언을 사용하는 방법을 배웠으며 실제 예제에서이를 사용할 준비가되었습니다. &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE에서 &lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle 태스크 를 호출 하거나 다음 콘솔 명령을 사용하여 코드를 수정하고 실행 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="50d459965bcc6d81fd4d90553a544db8ca2bdb40" translate="yes" xml:space="preserve">
          <source>Now we have learned how to use C declarations in our code, we are ready to try it out on a real example. Let's fix our code and see how it runs by calling the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by using the following console command:</source>
          <target state="translated">이제 코드에서 C 선언을 사용하는 방법을 배웠으므로 실제 예제에서 사용해 볼 준비가되었습니다. 코드를 수정하고 &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE에서 &lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle 작업 을 호출 하거나 다음 콘솔 명령을 사용하여 코드가 어떻게 실행되는지 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="dcdaca8bf7117a3b069ebd97d9d500bbee893084" translate="yes" xml:space="preserve">
          <source>Now we have our library and Kotlin stubs, we can consume them from our application. To keep things simple, in this tutorial we're going to convert one of the simplest &lt;code&gt;libcurl&lt;/code&gt; examples over to Kotlin.</source>
          <target state="translated">이제 라이브러리와 Kotlin 스텁이 있으며 응용 프로그램에서 사용할 수 있습니다. 일을 단순하게 유지하기 위해이 튜토리얼에서는 가장 간단한 &lt;code&gt;libcurl&lt;/code&gt; 예제 중 하나 를 Kotlin 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="56a410308bdaa182b925a6dff7fc3ba66711f037" translate="yes" xml:space="preserve">
          <source>Now we have the &lt;code&gt;TextView&lt;/code&gt; that will show us the text created by the shared code function &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt;. It shows &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt;. Let's see how it works.</source>
          <target state="translated">이제 공유 코드 함수 &lt;code&gt;createApplicationScreenMessage()&lt;/code&gt; 작성된 텍스트를 표시 하는 &lt;code&gt;TextView&lt;/code&gt; 가 있습니다 . &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 보여줍니다 . 그것이 어떻게 작동하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="ff70a609caee6a29932d7e21240cf4b92c28370c" translate="yes" xml:space="preserve">
          <source>Now we need to define the classes and interfaces we want to implement. Create the file &lt;code&gt;Base64.kt&lt;/code&gt; in the &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; folder. Core primitive will be the &lt;code&gt;Base64Encoder&lt;/code&gt; interface which knows how to convert bytes to bytes in &lt;code&gt;Base64&lt;/code&gt; format:</source>
          <target state="translated">이제 구현하려는 클래스와 인터페이스를 정의해야합니다. 파일 만들기 &lt;code&gt;Base64.kt&lt;/code&gt; 에서 &lt;code&gt;commonMain/kotlin/jetbrains/base64&lt;/code&gt; 폴더를. 핵심 프리미티브는 &lt;code&gt;Base64&lt;/code&gt; 형식의 바이트를 바이트로 변환하는 방법을 알고 있는 &lt;code&gt;Base64Encoder&lt;/code&gt; 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="6ca6511b451c4bb08b2161576b6d00b309bd636f" translate="yes" xml:space="preserve">
          <source>Now we need to explain to Xcode, where to look for frameworks. We need to add the &lt;em&gt;relative&lt;/em&gt; path &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; into the &lt;em&gt;Search Paths | Framework Search Paths&lt;/em&gt; section. Open the &lt;em&gt;Build Settings&lt;/em&gt; tab again, pick the &lt;em&gt;All&lt;/em&gt; sub-tab below, and type the &lt;em&gt;Framework Search Paths&lt;/em&gt; into the search field to easily find the option. Xcode will then show the substituted path in the UI for it.</source>
          <target state="translated">이제 Xcode에 프레임 워크를 찾을 위치를 설명해야합니다. 우리는 추가 할 필요가 &lt;em&gt;상대&lt;/em&gt; 경로 &lt;code&gt;$(SRCROOT)/../../SharedCode/build/xcode-frameworks&lt;/code&gt; 에 &lt;em&gt;검색 경로 | 프레임 워크 검색 경로&lt;/em&gt; 섹션. &lt;em&gt;빌드 설정&lt;/em&gt; 탭을 다시 열고 아래 의 &lt;em&gt;모든&lt;/em&gt; 하위 탭 을 선택한 다음 검색 필드에 &lt;em&gt;프레임 워크 검색 경로&lt;/em&gt; 를 입력 하여 옵션을 쉽게 찾으십시오. 그러면 Xcode는 UI에 대체 경로를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bbdba5d4735168e3785e68f7843040b781bf6309" translate="yes" xml:space="preserve">
          <source>Now when we call &lt;code&gt;workload()&lt;/code&gt; from a coroutine, the compiler knows that it may suspend and will prepare accordingly:</source>
          <target state="translated">이제 코 루틴에서 &lt;code&gt;workload()&lt;/code&gt; 를 호출 하면 컴파일러는 일시 중단 될 수 있음을 알고 그에 따라 준비합니다.</target>
        </trans-unit>
        <trans-unit id="1d24cd9e38cbefb079dd50a49d7d7f03311c7bf3" translate="yes" xml:space="preserve">
          <source>Now you are ready to create a new Kotlin project.</source>
          <target state="translated">이제 새로운 Kotlin 프로젝트를 만들 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="290dbe288d985515eeabffa880759f9b6702dbd0" translate="yes" xml:space="preserve">
          <source>Now you can declare a dependency on a Kotlin/Native library in the traditional &lt;code&gt;group:artifact:version&lt;/code&gt; notation:</source>
          <target state="translated">이제 전통적인 &lt;code&gt;group:artifact:version&lt;/code&gt; 표기법 으로 Kotlin / Native 라이브러리에 대한 종속성을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21f7ffde9424834101062b3a3b4388e5becd0386" translate="yes" xml:space="preserve">
          <source>Now you can publish the artifacts with the standard Gradle &lt;code&gt;publish&lt;/code&gt; task:</source>
          <target state="translated">이제 표준 Gradle &lt;code&gt;publish&lt;/code&gt; 작업으로 이슈를 게시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f0e0a97af9c78bc7052cbc7558b0c5721564a3e" translate="yes" xml:space="preserve">
          <source>Now you can use this class from JavaScript in the following way:</source>
          <target state="translated">이제 JavaScript에서이 클래스를 다음과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5043215278e17616ae1356fe9712ab2361ec4d2" translate="yes" xml:space="preserve">
          <source>Now you have the new project created with the following folder structure:</source>
          <target state="translated">이제 다음 폴더 구조로 새 프로젝트를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="3e24bac49840414b90995c5cbd33ee7b86539a1d" translate="yes" xml:space="preserve">
          <source>Now you're ready to start learning. Read the first task description and the exercise code. You will find a placeholder in the exercise code which you need to complete to solve the task:</source>
          <target state="translated">이제 학습을 시작할 준비가되었습니다. 첫 번째 작업 설명과 운동 코드를 읽으십시오. 작업 코드에서 작업을 수행하기 위해 완료해야하는 자리 표시자를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cb44051b734fae4af55ffe5224978dec7c87251" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;callStatic()&lt;/code&gt; is static in Java, while &lt;code&gt;callNonStatic()&lt;/code&gt; is not:</source>
          <target state="translated">이제 &lt;code&gt;callStatic()&lt;/code&gt; 은 Java에서 정적이지만 &lt;code&gt;callNonStatic()&lt;/code&gt; 은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a13d0fb128d24db7d3bb5f2f36926ba1c128f4f2" translate="yes" xml:space="preserve">
          <source>Now, &lt;em&gt;this&lt;/em&gt; can be omitted, as usual, and we get something that looks very much like a builder already:</source>
          <target state="translated">이제 &lt;em&gt;이는&lt;/em&gt; 평소와 같이, 생략, 우리는 뭔가를 얻을 수 매우 이미 빌더과 같다 :</target>
        </trans-unit>
        <trans-unit id="f0a82c0a40d22072db820930c190224b73ea978f" translate="yes" xml:space="preserve">
          <source>Now, all is left is to write the main function that reads the input and implements the rest of the algorithm that the problem statement asks for &amp;mdash; to compute the number of different integers that are produced while repeatedly applying function &lt;code&gt;f&lt;/code&gt; to the initial number &lt;code&gt;n&lt;/code&gt; that is given in the standard input.</source>
          <target state="translated">반복 함수 적용하는 동안 생성되는 다른 정수 숫자 계산하기 - 이제 남은 모든 입력 및 구현을 문제 문을 요청하는 알고리즘의 나머지 판독 메인 함수 작성한다 &lt;code&gt;f&lt;/code&gt; 초기 개수 &lt;code&gt;n&lt;/code&gt; 그 표준 입력으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6047e18f4bc8d11bc30e4fd65fb8d503da1662" translate="yes" xml:space="preserve">
          <source>Now, if you call a method or access a property on &lt;code&gt;a&lt;/code&gt;, it's guaranteed not to cause an NPE, so you can safely say:</source>
          <target state="translated">당신이 방법 또는 액세스에게의 속성 호출하는 경우 이제 &lt;code&gt;a&lt;/code&gt; 안전하게 말할 수 있도록, NPE의 원인이 될 수 보장된다 :</target>
        </trans-unit>
        <trans-unit id="20f3d5cd33eec60a8a8002b141a9b28a6b9b7682" translate="yes" xml:space="preserve">
          <source>Now, if you do:</source>
          <target state="translated">지금, 당신이 할 경우 :</target>
        </trans-unit>
        <trans-unit id="f71ccd18f05da02b03c8a2c32b3e5cdf31e2366b" translate="yes" xml:space="preserve">
          <source>Now, if you open DevTools, you should see both JavaScript and Kotlin files in Sources tab, as shown in the picture below.</source>
          <target state="translated">이제 DevTools를 열면 아래 그림과 같이 소스 탭에 JavaScript 및 Kotlin 파일이 모두 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a83d9e77f9456d18d8a05fd327f1e236de7060bd" translate="yes" xml:space="preserve">
          <source>Now, if you rebuild the project, you should see both &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.js.map&lt;/code&gt; files generated.</source>
          <target state="translated">이제 프로젝트를 다시 빌드하면 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.js.map&lt;/code&gt; 파일이 모두 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="76f6cc5aafdabd68e55d4250b74b32cd977c308a" translate="yes" xml:space="preserve">
          <source>Now, it returns only from the lambda expression. Oftentimes it is more convenient to use implicit labels: such a label has the same name as the function to which the lambda is passed.</source>
          <target state="translated">이제 람다 식에서 만 반환됩니다. 암시 적 레이블을 사용하는 것이 더 편리한 경우가 종종 있습니다. 이러한 레이블의 이름은 람다가 전달되는 함수와 이름이 같습니다.</target>
        </trans-unit>
        <trans-unit id="94f815aeffcc5ac17241b513b6e20a9f1cdaea31" translate="yes" xml:space="preserve">
          <source>Now, let us see what happens if we launch a couple of coroutines sending strings (in this example we launch them in the context of the main thread as main coroutine's children):</source>
          <target state="translated">이제 문자열을 보내는 두 개의 코 루틴을 시작하면 어떻게되는지 살펴 보자 (이 예에서는 메인 스레드의 컨텍스트에서 메인 코 루틴의 자식으로 시작 함).</target>
        </trans-unit>
        <trans-unit id="71d025254fd20926043d356611276f9c88403338" translate="yes" xml:space="preserve">
          <source>Now, let's make sure that coroutines are really cheaper than threads. How about starting a million of them? Let's try starting a million threads first:</source>
          <target state="translated">이제 코 루틴이 스레드보다 실제로 저렴하다는 것을 확인하십시오. 백만 개를 시작하는 것은 어떻습니까? 먼저 백만 개의 스레드를 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="16dd7a2ec4c182b0f69f31fe9543eb28189fc230" translate="yes" xml:space="preserve">
          <source>Now, let's recall why we can say something like this in the code:</source>
          <target state="translated">이제 코드에서 이와 같이 말할 수있는 이유를 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="544d487017d11ee4001cb80b112987fd1c122959" translate="yes" xml:space="preserve">
          <source>Now, let's say we want to extract our &lt;em&gt;workload&lt;/em&gt; (which is &quot;wait 1 second and return a number&quot;) into a separate function:</source>
          <target state="translated">이제 &lt;em&gt;워크로드&lt;/em&gt; ( &quot;1 초 기다렸다가 숫자 반환&quot;)를 별도의 함수 로 추출한다고 가정 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c750281f584acadba2af58cffcc8c1305b106c0d" translate="yes" xml:space="preserve">
          <source>Now, the type parameter of &lt;code&gt;to&lt;/code&gt; must be a supertype of that of &lt;code&gt;from&lt;/code&gt;. This time, we're losing the ability to call &lt;code&gt;get()&lt;/code&gt; on &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;to&lt;/code&gt; 의 유형 매개 변수 는 &lt;code&gt;from&lt;/code&gt; 의 유형 매개 변수 여야합니다 . 이 시간, 우리는 호출 할 수있는 기능 잃고 &lt;code&gt;get()&lt;/code&gt; 에 &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66aa36fc01590becc140967b82e52fb54836cefb" translate="yes" xml:space="preserve">
          <source>Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">이제 스레드로 시도하십시오. 무슨 일이 일어날 지? (대부분의 코드에서 일종의 메모리 부족 오류가 발생할 가능성이 높습니다)</target>
        </trans-unit>
        <trans-unit id="43de32521253364ea5d09558750dd9502168f58f" translate="yes" xml:space="preserve">
          <source>Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; using the defined &lt;code&gt;scope&lt;/code&gt;. For the demo, we launch ten coroutines that delay for a different time:</source>
          <target state="translated">이제 정의 된 &lt;code&gt;scope&lt;/code&gt; 사용 하여이 &lt;code&gt;Activity&lt;/code&gt; 의 범위에서 코 루틴을 시작할 수 있습니다 . 데모를 위해 다른 시간 동안 지연되는 10 개의 코 루틴을 출시합니다.</target>
        </trans-unit>
        <trans-unit id="841ea7e84248eb13447bb49e5c5c6dbc24123f33" translate="yes" xml:space="preserve">
          <source>Now, we can launch coroutines in the scope of this &lt;code&gt;Activity&lt;/code&gt; without having to explicitly specify their context. For the demo, we launch ten coroutines that delay for a different time:</source>
          <target state="translated">이제 컨텍스트를 명시 적으로 지정하지 않고도이 &lt;code&gt;Activity&lt;/code&gt; 범위에서 코 루틴을 시작할 수 있습니다 . 데모를 위해 다른 시간 동안 지연되는 10 개의 코 루틴을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b7b794f9844126d9635b31ec7a7259faff61ea34" translate="yes" xml:space="preserve">
          <source>Now, we can qualify a &lt;em&gt;break&lt;/em&gt; or a &lt;em&gt;continue&lt;/em&gt; with a label:</source>
          <target state="translated">이제 레이블을 사용하여 &lt;em&gt;휴식을 취&lt;/em&gt; 하거나 &lt;em&gt;계속할&lt;/em&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4009ace22d0b31f5461708301ff321a7b41e34f1" translate="yes" xml:space="preserve">
          <source>Now, we need to create the implementation file (and missing directories) for Android in the &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;SharedCode/src/androidMain/kotlin/actual.kt&lt;/code&gt; 에서 Android 용 구현 파일 (및 누락 된 디렉토리)을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc32792e1ffb6994d09d3ccc5850fcde297ab5b1" translate="yes" xml:space="preserve">
          <source>Now, whenever anyone reads &lt;code&gt;p.name&lt;/code&gt;, &lt;code&gt;getValue()&lt;/code&gt; will be invoked with &lt;code&gt;p&lt;/code&gt; as &lt;code&gt;thisRef&lt;/code&gt; and metadata about the &lt;code&gt;name&lt;/code&gt; property as &lt;code&gt;property&lt;/code&gt;. Since &lt;code&gt;thisRef&lt;/code&gt; is a &lt;code&gt;DbModel&lt;/code&gt;, this delegated property can only be used inside &lt;code&gt;DbModel&lt;/code&gt; and its subclasses.</source>
          <target state="translated">사람이 읽을 때마다 지금 &lt;code&gt;p.name&lt;/code&gt; , &lt;code&gt;getValue()&lt;/code&gt; 호출한다 &lt;code&gt;p&lt;/code&gt; 로 &lt;code&gt;thisRef&lt;/code&gt; [정보와 메타 데이터 &lt;code&gt;name&lt;/code&gt; 과 재산 &lt;code&gt;property&lt;/code&gt; . 이후 &lt;code&gt;thisRef&lt;/code&gt; 는 A는 &lt;code&gt;DbModel&lt;/code&gt; 이 위임 속성은 내부에 사용될 수있다 &lt;code&gt;DbModel&lt;/code&gt; 와 그 서브.</target>
        </trans-unit>
        <trans-unit id="1ddfae4b18596b2854071f83733087767ffb2d01" translate="yes" xml:space="preserve">
          <source>Now, you can do:</source>
          <target state="translated">이제 할 수있는 일 :</target>
        </trans-unit>
        <trans-unit id="c62d757ce7f75d3f121e4c4fec1867b7958bd009" translate="yes" xml:space="preserve">
          <source>Now, you can no longer say &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt;.</source>
          <target state="translated">이제 더 이상 &lt;code&gt;val mv = MotorVehicle(100, 4)&lt;/code&gt; 라고 말할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6c97d282b328adc12f3e5a556471451c0554c8b2" translate="yes" xml:space="preserve">
          <source>Now, you can say &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; to load an object from the &lt;code&gt;Exercise&lt;/code&gt; database table.</source>
          <target state="translated">이제 &lt;code&gt;loadFromDb&amp;lt;Exercise&amp;gt;(&quot;x01234567&quot;)&lt;/code&gt; &lt;code&gt;Exercise&lt;/code&gt; 데이터베이스 테이블 에서 객체를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93baa80c955acf188a4912f62d9bfabe1e89cde4" translate="yes" xml:space="preserve">
          <source>Now, you can treat a bowl of &lt;code&gt;T&lt;/code&gt; as a producer of any superclass of &lt;code&gt;T&lt;/code&gt;, and as a consumer of any subclass of &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">지금, 당신은 한 그릇에 처리 할 수 &lt;code&gt;T&lt;/code&gt; 을 의 슈퍼 클래스의 프로듀서로 &lt;code&gt;T&lt;/code&gt; , 그리고 하위 클래스의 소비자로 &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb06774e37de315de0f5603f0b4fd0176b0b42a0" translate="yes" xml:space="preserve">
          <source>Now, you may not create a &lt;code&gt;TreeNode&lt;/code&gt; of a type that is not a subclass/implementor of &lt;code&gt;Vehicle&lt;/code&gt;. Inside the class, whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;, you may access all the public members of &lt;code&gt;Vehicle&lt;/code&gt; on it.</source>
          <target state="translated">이제 &lt;code&gt;Vehicle&lt;/code&gt; 의 서브 클래스 / 구현자가 아닌 유형 의 &lt;code&gt;TreeNode&lt;/code&gt; 를 만들 수 없습니다 . 수업 내에서 &lt;code&gt;T&lt;/code&gt; 유형의 값을 얻을 때마다 &lt;code&gt;Vehicle&lt;/code&gt; 의 모든 공개 멤버에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e66b62de2c45ca7a1dafaa470efed27db40c8abf" translate="yes" xml:space="preserve">
          <source>Null Safety</source>
          <target state="translated">널 안전</target>
        </trans-unit>
        <trans-unit id="961437d22902a2f7dfd53365cc313f4a8b919ec9" translate="yes" xml:space="preserve">
          <source>Null references are &lt;a href=&quot;null-safety&quot;&gt;controlled by the type system&lt;/a&gt;.</source>
          <target state="translated">널 참조는 &lt;a href=&quot;null-safety&quot;&gt;유형 시스템에 의해 제어됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2b2542f64eaa222fbfda6a1a4f6d0850cf59a88" translate="yes" xml:space="preserve">
          <source>Null safety</source>
          <target state="translated">널 안전</target>
        </trans-unit>
        <trans-unit id="39f94d225bc04bec959b32c61b7c0b099f1b3de4" translate="yes" xml:space="preserve">
          <source>Null safety is enforced as usual, so a variable of type &lt;code&gt;ContentKind&lt;/code&gt; can not be null, unlike in Java.</source>
          <target state="translated">Null 안전은 평소처럼 적용되므로 Java와 달리 &lt;code&gt;ContentKind&lt;/code&gt; 유형의 변수는 null 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c768f27b8cd368aac53b3bf7b3466119f4aeaaad" translate="yes" xml:space="preserve">
          <source>Null-Safety and Platform Types</source>
          <target state="translated">널 안전 및 플랫폼 유형</target>
        </trans-unit>
        <trans-unit id="7b2e605360643dd896eff359d1535b4e4db34c3d" translate="yes" xml:space="preserve">
          <source>Null-safety</source>
          <target state="translated">Null-safety</target>
        </trans-unit>
        <trans-unit id="e96a81e5fc6aa1615fc78a379fdad68b748bc26c" translate="yes" xml:space="preserve">
          <source>NullPointerException</source>
          <target state="translated">NullPointerException</target>
        </trans-unit>
        <trans-unit id="7cfd44db910fd8b20253bc74265b31aeaf45384c" translate="yes" xml:space="preserve">
          <source>Nullability</source>
          <target state="translated">Nullability</target>
        </trans-unit>
        <trans-unit id="13c99d5e49300b52aefe21f12764921df1d1f93f" translate="yes" xml:space="preserve">
          <source>Nullability annotations</source>
          <target state="translated">무효 성 주석</target>
        </trans-unit>
        <trans-unit id="e5e6784edcd14305d294e06ecb03d642a0a57873" translate="yes" xml:space="preserve">
          <source>Nullability assertions on access to Java types annotated with &lt;code&gt;@NotNull&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@NotNull&lt;/code&gt; 로 주석이 달린 Java 유형에 액세스 할 때 Nullability 어설 션</target>
        </trans-unit>
        <trans-unit id="1e5389deab4b42bc503c62cbba549bbb26b00be1" translate="yes" xml:space="preserve">
          <source>Nullable Receiver</source>
          <target state="translated">널 입력 가능 수신기</target>
        </trans-unit>
        <trans-unit id="29ff5a1131fe0933e804809fec54eb9e91bf1512" translate="yes" xml:space="preserve">
          <source>Nullable receiver</source>
          <target state="translated">Nullable 수신기</target>
        </trans-unit>
        <trans-unit id="ea692fde5fad8fec43d27ab3923928d9c3e4f762" translate="yes" xml:space="preserve">
          <source>Nullable types and Non-Null Types</source>
          <target state="translated">널 입력 가능 유형 및 널이 아닌 유형</target>
        </trans-unit>
        <trans-unit id="eda4c49c3f8e3f49857bedaeb7bb3c5e705b11d9" translate="yes" xml:space="preserve">
          <source>Nullable values and &lt;em&gt;null&lt;/em&gt; checks</source>
          <target state="translated">Nullable 값 및 &lt;em&gt;Null&lt;/em&gt; 검사</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="2e1ee95668fd5f69d1925d4acd4d52b859469b82" translate="yes" xml:space="preserve">
          <source>NumberFormatException</source>
          <target state="translated">NumberFormatException</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="b7b3deb2440db7b27508e61ad6b6526ba91d78a1" translate="yes" xml:space="preserve">
          <source>Numbers are compared with the ends of this range according to IEEE-754.</source>
          <target state="translated">IEEE-754에 따라이 범위의 끝과 숫자를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="b1c2afbaeee52797fa3a437d9c480e4a05cf0193" translate="yes" xml:space="preserve">
          <source>Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt;, an so on.</source>
          <target state="translated">숫자 유형은 전통적인 숫자 순서를 사용합니다. &lt;code&gt;1&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 보다 큽니다 . &lt;code&gt;-3.4f&lt;/code&gt; 는 -5f 보다 &lt;code&gt;-5f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aadf9b6283ac66e1e51fce7a8cfe42781b4ea431" translate="yes" xml:space="preserve">
          <source>Numeric types use the traditional numerical order: &lt;code&gt;1&lt;/code&gt; is greater than &lt;code&gt;0&lt;/code&gt;; &lt;code&gt;-3.4f&lt;/code&gt; is greater than &lt;code&gt;-5f&lt;/code&gt;, and so on.</source>
          <target state="translated">숫자 유형은 일반적인 숫자 순서를 사용합니다. &lt;code&gt;1&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 보다 큽니다 . &lt;code&gt;-3.4f&lt;/code&gt; 는 -5f 보다 &lt;code&gt;-5f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="132a0e722f57154d901e124e4cb8e8bc570f7174" translate="yes" xml:space="preserve">
          <source>Numerous use cases are covered by just the default source sets and don't require custom source sets.</source>
          <target state="translated">수많은 유스 케이스는 기본 소스 세트 만 다루며 사용자 정의 소스 세트가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5bd86a2929ff840c45d76159d984c1239906a9d" translate="yes" xml:space="preserve">
          <source>OSGi</source>
          <target state="translated">OSGi</target>
        </trans-unit>
        <trans-unit id="802bfbdcec1e0873ee0e4b3f43f68d3022244543" translate="yes" xml:space="preserve">
          <source>OTHER_LETTER</source>
          <target state="translated">OTHER_LETTER</target>
        </trans-unit>
        <trans-unit id="c526c1a55d3a7d1197fc54064f8aa775a085df54" translate="yes" xml:space="preserve">
          <source>OTHER_NEUTRALS</source>
          <target state="translated">OTHER_NEUTRALS</target>
        </trans-unit>
        <trans-unit id="0528be3a553ee55304545e3df532c16619f9a75f" translate="yes" xml:space="preserve">
          <source>OTHER_NUMBER</source>
          <target state="translated">OTHER_NUMBER</target>
        </trans-unit>
        <trans-unit id="a79f18b5ad7c3bc6ad0e1685c0b9f1d91e9ea75c" translate="yes" xml:space="preserve">
          <source>OTHER_PUNCTUATION</source>
          <target state="translated">OTHER_PUNCTUATION</target>
        </trans-unit>
        <trans-unit id="5dcd7535199ae15a813d866ef04e762cfaa07f6c" translate="yes" xml:space="preserve">
          <source>OTHER_SYMBOL</source>
          <target state="translated">OTHER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="5d84eb9e92dc661a577d3adfba33f1d74c56b13f" translate="yes" xml:space="preserve">
          <source>OUT</source>
          <target state="translated">OUT</target>
        </trans-unit>
        <trans-unit id="91920f1b8433472c27ea07aeaf636cc60ba181dc" translate="yes" xml:space="preserve">
          <source>ObjCAction</source>
          <target state="translated">ObjCAction</target>
        </trans-unit>
        <trans-unit id="e75d1b861d64404390b1044e805e449a8200ca83" translate="yes" xml:space="preserve">
          <source>ObjCBlockVar</source>
          <target state="translated">ObjCBlockVar</target>
        </trans-unit>
        <trans-unit id="e9af1c5fc6d5face32a12e24e19f7721bddde5b0" translate="yes" xml:space="preserve">
          <source>ObjCClass</source>
          <target state="translated">ObjCClass</target>
        </trans-unit>
        <trans-unit id="f25e8c7f51c9fbd76d5d3f0065c1777ea9957679" translate="yes" xml:space="preserve">
          <source>ObjCClassOf</source>
          <target state="translated">ObjCClassOf</target>
        </trans-unit>
        <trans-unit id="f6a51cb987439b8eee022689cce7766c56796d55" translate="yes" xml:space="preserve">
          <source>ObjCConstructor</source>
          <target state="translated">ObjCConstructor</target>
        </trans-unit>
        <trans-unit id="174b16a8130fefe11ed27381abeeb2de5f620114" translate="yes" xml:space="preserve">
          <source>ObjCFactory</source>
          <target state="translated">ObjCFactory</target>
        </trans-unit>
        <trans-unit id="b26295bcadcc4d23542076fe5cb26969093b0b48" translate="yes" xml:space="preserve">
          <source>ObjCMethod</source>
          <target state="translated">ObjCMethod</target>
        </trans-unit>
        <trans-unit id="07d9267ddaf9a5ade080cb2ba3e61a2c1db5834c" translate="yes" xml:space="preserve">
          <source>ObjCNotImplementedVar</source>
          <target state="translated">ObjCNotImplementedVar</target>
        </trans-unit>
        <trans-unit id="88fce822e198e83b3ad7f5c732a4ec9995f176b3" translate="yes" xml:space="preserve">
          <source>ObjCObject</source>
          <target state="translated">ObjCObject</target>
        </trans-unit>
        <trans-unit id="c3946e9e7a5b7a873393f4068d626ccc17017e1d" translate="yes" xml:space="preserve">
          <source>ObjCObjectBase</source>
          <target state="translated">ObjCObjectBase</target>
        </trans-unit>
        <trans-unit id="f2b935ffe4e074cda5d9854c568bff792bd27525" translate="yes" xml:space="preserve">
          <source>ObjCObjectBaseMeta</source>
          <target state="translated">ObjCObjectBaseMeta</target>
        </trans-unit>
        <trans-unit id="968b48c24c631a6e3656fa344166e2e696dac30a" translate="yes" xml:space="preserve">
          <source>ObjCObjectMeta</source>
          <target state="translated">ObjCObjectMeta</target>
        </trans-unit>
        <trans-unit id="877c2fba97f85ebcbe0815d3dd7f9aa9abf27eb2" translate="yes" xml:space="preserve">
          <source>ObjCObjectVar</source>
          <target state="translated">ObjCObjectVar</target>
        </trans-unit>
        <trans-unit id="380d9e7d32a5ea9a8f4a45d77367a2bd6224641f" translate="yes" xml:space="preserve">
          <source>ObjCOutlet</source>
          <target state="translated">ObjCOutlet</target>
        </trans-unit>
        <trans-unit id="6ad1a2f860c17b61aedf856b4ee3682acdaa8417" translate="yes" xml:space="preserve">
          <source>ObjCProtocol</source>
          <target state="translated">ObjCProtocol</target>
        </trans-unit>
        <trans-unit id="7ddeec08c37b0e1684597f07f64a856e9d5996d5" translate="yes" xml:space="preserve">
          <source>ObjCStringVarOf</source>
          <target state="translated">ObjCStringVarOf</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="9cf5c3411eb513b108884e51c19ba17172ea9665" translate="yes" xml:space="preserve">
          <source>Object Declarations</source>
          <target state="translated">객체 선언</target>
        </trans-unit>
        <trans-unit id="7c97f9bd791112ffa2e31c34e5efe261bd493bd5" translate="yes" xml:space="preserve">
          <source>Object Expressions and Declarations</source>
          <target state="translated">객체 표현과 선언</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">객체 방법</target>
        </trans-unit>
        <trans-unit id="da5029a017fab6364fe3776821fcb6e385dc5dee" translate="yes" xml:space="preserve">
          <source>Object Transfer Basics.</source>
          <target state="translated">객체 전송 기본.</target>
        </trans-unit>
        <trans-unit id="720b937cd9168a2afdad295cde0f6e29e57ba3f8" translate="yes" xml:space="preserve">
          <source>Object configuration and computing the result: &lt;code&gt;run&lt;/code&gt;</source>
          <target state="translated">객체 구성 및 결과 계산 : &lt;code&gt;run&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1602dbe04f927f110613a2ff025fac15d0ab85e1" translate="yes" xml:space="preserve">
          <source>Object configuration: &lt;code&gt;apply&lt;/code&gt;</source>
          <target state="translated">객체 구성 : &lt;code&gt;apply&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3d1d8d22ba8224cd8039f6fb03638fcc7cc89d7" translate="yes" xml:space="preserve">
          <source>Object declaration's initialization is thread-safe and done at first access.</source>
          <target state="translated">객체 선언의 초기화는 스레드로부터 안전하며 처음 액세스 할 때 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a447624065dc9ff0a50d2837d5bc597740342d7d" translate="yes" xml:space="preserve">
          <source>Object declaration's initialization is thread-safe.</source>
          <target state="translated">객체 선언의 초기화는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="628c7c8804cdd6233ca4db93a682c55cf0920e38" translate="yes" xml:space="preserve">
          <source>Object declarations</source>
          <target state="translated">객체 선언</target>
        </trans-unit>
        <trans-unit id="cae8f3bd29605b55880171db0511493e6eb7c132" translate="yes" xml:space="preserve">
          <source>Object describing the current platform program executes upon.</source>
          <target state="translated">현재 플랫폼 프로그램을 설명하는 객체가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="652916453e90e519555e6ab21189e4862e16ddc5" translate="yes" xml:space="preserve">
          <source>Object expressions</source>
          <target state="translated">객체 표현</target>
        </trans-unit>
        <trans-unit id="a5005a7247de5e6b7399fc2c0fe58f85332088cd" translate="yes" xml:space="preserve">
          <source>Object pinning</source>
          <target state="translated">객체 고정</target>
        </trans-unit>
        <trans-unit id="bd34180a1517f8541977dbe1575129ec09ee4ed0" translate="yes" xml:space="preserve">
          <source>Object reference</source>
          <target state="translated">객체 참조</target>
        </trans-unit>
        <trans-unit id="c74457d6502afea678cde0191acb0c28174b3019" translate="yes" xml:space="preserve">
          <source>Object subgraph detachment</source>
          <target state="translated">객체 서브 그래프 분리</target>
        </trans-unit>
        <trans-unit id="9e612181ece96085e9c01a6c4c75420948e3db15" translate="yes" xml:space="preserve">
          <source>Object subgraph freezing</source>
          <target state="translated">객체 서브 그래프 동결</target>
        </trans-unit>
        <trans-unit id="f714255fe9b4b0abd289766d10b307beefd8bdca" translate="yes" xml:space="preserve">
          <source>Object subgraph ownership transfer</source>
          <target state="translated">오브젝트 서브 그래프 소유권 이전</target>
        </trans-unit>
        <trans-unit id="f7e1ff28ab70fc23071798b8c0343f8a27fa8277" translate="yes" xml:space="preserve">
          <source>Object transfer and freezing</source>
          <target state="translated">물체 이동 및 동결</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="f624b8a4ac060c545ced78fe5b569d299005d811" translate="yes" xml:space="preserve">
          <source>Objective-C allows generics to be declared covariant or contravariant. Swift has no support for variance. Generic classes coming from Objective-C can be force-cast as needed.</source>
          <target state="translated">Objective-C를 사용하면 제네릭을 공변량 또는 공변량으로 선언 할 수 있습니다. 스위프트는 분산을 지원하지 않습니다. Objective-C에서 제공되는 일반 클래스는 필요에 따라 강제 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c34ace6f5a2b6e2147c689be6867500eabe88ca9" translate="yes" xml:space="preserve">
          <source>Objective-C and Swift use reference counting. Kotlin/Native has its own garbage collection too. Kotlin/Native garbage collection is integrated with Objective-C/Swift reference counting. We do not need to use anything special to control the lifetime of Kotlin/Native instances from Swift or Objective-C.</source>
          <target state="translated">Objective-C 및 Swift는 참조 계산을 사용합니다. Kotlin / Native에는 자체 가비지 콜렉션도 있습니다. Kotlin / Native 가비지 콜렉션은 Objective-C / Swift 참조 계산과 통합됩니다. Swift 또는 Objective-C에서 Kotlin / Native 인스턴스의 수명을 제어하기 위해 특별한 것을 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="81b529433016c0d2c2b79263ff487c0612e2136f" translate="yes" xml:space="preserve">
          <source>Objective-C classes and protocols</source>
          <target state="translated">Objective-C 클래스 및 프로토콜</target>
        </trans-unit>
        <trans-unit id="42d9bdb0193a26ed15d57450ee6f73bec2393ce7" translate="yes" xml:space="preserve">
          <source>Objective-C classes are imported into Kotlin with their original names. Protocols are imported as interfaces with &lt;code&gt;Protocol&lt;/code&gt; name suffix, i.e. &lt;code&gt;@protocol Foo&lt;/code&gt; -&amp;gt; &lt;code&gt;interface FooProtocol&lt;/code&gt;. These classes and interfaces are placed into a package &lt;a href=&quot;#usage&quot;&gt;specified in build configuration&lt;/a&gt; (&lt;code&gt;platform.*&lt;/code&gt; packages for preconfigured system frameworks).</source>
          <target state="translated">Objective-C 클래스는 원래 이름으로 Kotlin으로 가져옵니다. 프로토콜은 &lt;code&gt;Protocol&lt;/code&gt; 이름 접미사 (예 : &lt;code&gt;@protocol Foo&lt;/code&gt; &lt;code&gt;interface FooProtocol&lt;/code&gt; &amp;gt; interface FooProtocol)가있는 인터페이스로 가져옵니다 . 이러한 클래스와 인터페이스는 &lt;a href=&quot;#usage&quot;&gt;빌드 구성에 지정된&lt;/a&gt; 패키지 ( 사전 구성된 시스템 프레임 워크를위한 &lt;code&gt;platform.*&lt;/code&gt; 패키지)에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="e28ecca8c4c63098937f693b564f06106597a69f" translate="yes" xml:space="preserve">
          <source>Objective-C generics do not support all features of either Kotlin or Swift, so there will be some information lost in the translation.</source>
          <target state="translated">Objective-C 제네릭은 Kotlin 또는 Swift의 모든 기능을 지원하지 않으므로 번역에서 일부 정보가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc50c4e6d2116d2eefbad12ba8e08e873a18c54" translate="yes" xml:space="preserve">
          <source>Objective-C supports &quot;lightweight generics&quot; defined on classes, with a relatively limited feature set. Swift can import generics defined on classes to help provide additional type information to the compiler.</source>
          <target state="translated">Objective-C는 클래스에 정의 된 &quot;가벼운 제네릭&quot;을 지원하며 기능이 상대적으로 제한되어 있습니다. Swift는 클래스에 정의 된 제네릭을 가져와 컴파일러에 추가 유형 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="872324a80a8df1d396c94677f04ea994d1ae3329" translate="yes" xml:space="preserve">
          <source>Objects and companion objects</source>
          <target state="translated">객체 및 컴패니언 객체</target>
        </trans-unit>
        <trans-unit id="baa64e9ea92fa8d9f0990d9b1a5bc22ee025b445" translate="yes" xml:space="preserve">
          <source>Objects can be passed between threads in one of two possible modes.</source>
          <target state="translated">두 가지 가능한 모드 중 하나로 스레드간에 객체를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="53d6bf00994a7a961b92ecd0048f0ecd77a13ddf" translate="yes" xml:space="preserve">
          <source>ObservableProperty</source>
          <target state="translated">ObservableProperty</target>
        </trans-unit>
        <trans-unit id="1145800f1de30eba6d1df3a4fd2cc70c1f07f939" translate="yes" xml:space="preserve">
          <source>Obtain the Kotlin/Native compiler</source>
          <target state="translated">코 틀린 / 네이티브 컴파일러 얻기</target>
        </trans-unit>
        <trans-unit id="cdf71ecbbe212f441c04603a28909072a535e232" translate="yes" xml:space="preserve">
          <source>Obtaining member references from a class reference</source>
          <target state="translated">클래스 레퍼런스에서 멤버 레퍼런스 얻기</target>
        </trans-unit>
        <trans-unit id="df8298dcee7334200280003820f9875dbf3c187b" translate="yes" xml:space="preserve">
          <source>Obtaining the Compiler</source>
          <target state="translated">컴파일러 구하기</target>
        </trans-unit>
        <trans-unit id="b10db2a36e46741d4da85b74ece4b6f72fb9bfd8" translate="yes" xml:space="preserve">
          <source>Obtains a &lt;code&gt;KClass&lt;/code&gt; instance for the given constructor reference.</source>
          <target state="translated">지정된 생성자 참조 의 &lt;code&gt;KClass&lt;/code&gt; 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9910159f8fee624aa4548124f031d4745a86c889" translate="yes" xml:space="preserve">
          <source>Obtains a constructor reference for the given &lt;code&gt;KClass&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;KClass&lt;/code&gt; 의 생성자 참조를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="0219b4a8ea1da937bc70be9c1ab95184f21fc8c4" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and either suspends currently running coroutine or returns result immediately without suspension.</source>
          <target state="translated">일시 중단 함수 내에서 현재 연속 인스턴스를 가져오고 현재 실행중인 코 루틴을 일시 중단하거나 일시 중단없이 즉시 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="646fc575bcb6c35847d73d3b2dd2cc5db56f01df" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends currently running coroutine.</source>
          <target state="translated">일시 중단 함수 내에서 현재 연속 인스턴스를 가져오고 현재 실행중인 코 루틴을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="dedd1425a40b177d169a6eb17080f5f8210d2fe7" translate="yes" xml:space="preserve">
          <source>Obtains the current continuation instance inside suspend functions and suspends the currently running coroutine.</source>
          <target state="translated">일시 중단 함수 내에서 현재 연속 인스턴스를 가져오고 현재 실행중인 코 루틴을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="0e481b647fccdeaa073311d1f3e53a76a5713079" translate="yes" xml:space="preserve">
          <source>Of course, there are use cases, where we need to pass a struct as a value to one call, and then, to pass the same struct as a reference to another call. This is possible in Kotlin/Native too. A &lt;code&gt;NativePlacement&lt;/code&gt; will be needed here.</source>
          <target state="translated">물론, 한 호출에 값으로 구조체를 전달한 다음 다른 호출에 대한 참조와 동일한 구조체를 전달해야하는 사용 사례가 있습니다. 이것은 Kotlin / Native에서도 가능합니다. &lt;code&gt;NativePlacement&lt;/code&gt; 는 여기에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="31883564163ba418ee2d22f8e75f951da14db61c" translate="yes" xml:space="preserve">
          <source>Of course, this function makes sense for any &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt;, and we can make it generic:</source>
          <target state="translated">물론이 함수는 모든 &lt;code&gt;MutableList&amp;lt;T&amp;gt;&lt;/code&gt; 대해 의미 가 있으며 일반적인 것으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8b4afe53634485a00aaaa6addcb6e74df14c763" translate="yes" xml:space="preserve">
          <source>Of course, this is not a complete list of how you can use Kotlin/JS to your advantage, but merely a selection of cherry-picked cases. We invite you to experiment with combinations of these use cases, and find out what works best for your project.</source>
          <target state="translated">물론 이것은 Kotlin / JS를 어떻게 활용할 수 있는지에 대한 완전한 목록이 아니라 단순히 선별 된 사례의 일부일뿐입니다. 이러한 사용 사례를 조합하여 실험하고 프로젝트에 가장 적합한 것이 무엇인지 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="01fad7001a3bd3884c94e7702bc3df04daa71091" translate="yes" xml:space="preserve">
          <source>Of course, you can use both &lt;code&gt;kotlin-allopen&lt;/code&gt; and &lt;code&gt;kotlin-spring&lt;/code&gt; in the same project.</source>
          <target state="translated">물론 동일한 프로젝트에서 &lt;code&gt;kotlin-allopen&lt;/code&gt; 과 &lt;code&gt;kotlin-spring&lt;/code&gt; 을 모두 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42c11258f0fc4616029dfe363fc90cedc10dac00" translate="yes" xml:space="preserve">
          <source>Often C APIs allow passing some user data to callbacks. Such data is usually provided by the user when configuring the callback. It is passed to some C function (or written to the struct) as e.g. &lt;code&gt;void*&lt;/code&gt;. However, references to Kotlin objects can't be directly passed to C. So they require wrapping before configuring the callback and then unwrapping in the callback itself, to safely swim from Kotlin to Kotlin through the C world. Such wrapping is possible with &lt;code&gt;StableRef&lt;/code&gt; class.</source>
          <target state="translated">C API를 사용하면 일부 사용자 데이터를 콜백에 전달할 수 있습니다. 이러한 데이터는 일반적으로 사용자가 콜백을 구성 할 때 제공합니다. 예를 들어 &lt;code&gt;void*&lt;/code&gt; 와 같이 일부 C 함수에 전달되거나 구조체에 기록됩니다 . 그러나 Kotlin 객체에 대한 참조는 C로 직접 전달 될 수 없습니다. 따라서 콜백을 구성하기 전에 랩핑 한 다음 콜백 자체에서 언 랩핑하여 C 월드를 통해 Kotlin에서 Kotlin으로 안전하게 수영해야합니다. 이러한 랩핑은 &lt;code&gt;StableRef&lt;/code&gt; 클래스 로 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="242f4c07d8050ddde5e50538c080e4ec4486413c" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a Kotlin/Native binary using an interop. It can be done using the &lt;code&gt;target&lt;/code&gt; script block:</source>
          <target state="translated">interop을 사용하여 Kotlin / Native 바이너리에 대한 대상별 링커 옵션을 지정해야하는 경우가 종종 있습니다. &lt;code&gt;target&lt;/code&gt; 스크립트 블록을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="954df0a6263002ad270cb3cbc1c777c4a6fac8a1" translate="yes" xml:space="preserve">
          <source>Often it's necessary to specify target-specific linker options for a binary which uses a native library. It can by done using the &lt;code&gt;linkerOpts&lt;/code&gt; property of the binary. See the &lt;a href=&quot;#configuring-binaries&quot;&gt;Configuring binaries&lt;/a&gt; section for details.</source>
          <target state="translated">기본 라이브러리를 사용하는 바이너리에 대상별 링커 옵션을 지정해야하는 경우가 종종 있습니다. 바이너리 의 &lt;code&gt;linkerOpts&lt;/code&gt; 속성을 사용하여 수행 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#configuring-binaries&quot;&gt;바이너리 구성&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="17450dcb9110eb38f3fe2d512c09098b5921aef0" translate="yes" xml:space="preserve">
          <source>Older compilers reject binaries that rely on new features (e.g. a 1.0 compiler rejects binaries that use coroutines).</source>
          <target state="translated">이전 컴파일러는 새로운 기능에 의존하는 바이너리를 거부합니다 (예 : 1.0 컴파일러는 코 루틴을 사용하는 바이너리를 거부합니다).</target>
        </trans-unit>
        <trans-unit id="622d524446394c09abc4f2559c91821dbd352982" translate="yes" xml:space="preserve">
          <source>Omit semicolons whenever possible.</source>
          <target state="translated">가능할 때마다 세미콜론을 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="902eb259efe55ed5caa3e21ba3397c994cd51091" translate="yes" xml:space="preserve">
          <source>On Apple platforms &lt;code&gt;objc&lt;/code&gt; library is provided for interoperability with &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt;.</source>
          <target state="translated">Apple 플랫폼에서 &lt;code&gt;objc&lt;/code&gt; 라이브러리는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Objective-C&quot;&gt;Objective-C&lt;/a&gt; 와의 상호 운용성을 위해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a12a3cf1289b0209f29a4a3a5bf9dabfcdb8788" translate="yes" xml:space="preserve">
          <source>On GitHub</source>
          <target state="translated">GitHub에서</target>
        </trans-unit>
        <trans-unit id="c0ab16d7d10cfcca8fa016bc8b366c04e76c5016" translate="yes" xml:space="preserve">
          <source>On JVM it is possible to redefine global exception handler for all coroutines by registering &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; via &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;&lt;code&gt;ServiceLoader&lt;/code&gt;&lt;/a&gt;. Global exception handler is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt; which is used when no more specific handlers are registered. On Android, &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; is installed as a global coroutine exception handler.</source>
          <target state="translated">JVM에서는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt; &lt;code&gt;ServiceLoader&lt;/code&gt; &lt;/a&gt; 를 통해 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; 를 등록하여 모든 코 루틴에 대한 전역 예외 핸들러를 재정의 할 수 있습니다 . 전역 예외 처리기는 더 이상 특정 처리기가 등록되지 않은 경우 사용되는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.defaultUncaughtExceptionHandler&lt;/code&gt; &lt;/a&gt; 와 유사합니다 . Android에서 &lt;code&gt;uncaughtExceptionPreHandler&lt;/code&gt; 는 글로벌 코 루틴 예외 핸들러로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="52a2cc9b4e5cfa91fe617932ce29f7d004cf9460" translate="yes" xml:space="preserve">
          <source>On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.</source>
          <target state="translated">JVM에서 반환 된 생성기는 스레드로부터 안전하지 않습니다. 적절한 동기화없이 여러 스레드에서 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d634a94c081c286c31c7efa035cd25a12a05ea49" translate="yes" xml:space="preserve">
          <source>On JVM this generator is thread-safe, its methods can be invoked from multiple threads.</source>
          <target state="translated">JVM에서이 생성기는 스레드로부터 안전하며 여러 스레드에서 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82b7124cbe78a1bd0ee0229af53226a5b9d9303c" translate="yes" xml:space="preserve">
          <source>On Linux we call a similar command:</source>
          <target state="translated">Linux에서는 비슷한 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="debaeb12f7add41593464f7eef76b63e195de057" translate="yes" xml:space="preserve">
          <source>On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</source>
          <target state="translated">Windows에서 동적 라이브러리는 생성 된 정적 라이브러리 래퍼를 통해 또는 &lt;a href=&quot;https://docs.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya&quot;&gt;LoadLibrary&lt;/a&gt; 또는 유사한 Win32API 함수 를 처리하는 수동 코드를 통해 포함됩니다 . 첫 번째 옵션에 따라 &lt;code&gt;libnative.dll&lt;/code&gt; 에 대한 정적 래퍼 라이브러리를 직접 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="f32995a2978fac4fc27ca1ef6f69f7fd0261ff6b" translate="yes" xml:space="preserve">
          <source>On Windows, Dynamic libraries are included either via a generated static library wrapper or with manual code, which deals with the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt; or similar Win32API functions. We will follow the first option and generate the static wrapper library for the &lt;code&gt;libnative.dll&lt;/code&gt; on our own.</source>
          <target state="translated">Windows에서 동적 라이브러리는 생성 된 정적 라이브러리 랩퍼 또는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms684175.aspx&quot;&gt;LoadLibrary&lt;/a&gt; 또는 유사한 Win32API 함수 를 처리하는 수동 코드와 함께 포함 됩니다. 첫 번째 옵션을 따르고 &lt;code&gt;libnative.dll&lt;/code&gt; 에 대한 정적 래퍼 라이브러리를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="215b62ee2a4bb5fa218d3c640f454cdd3fd9a459" translate="yes" xml:space="preserve">
          <source>On a &lt;code&gt;dynamic&lt;/code&gt; variable, you can call &lt;strong&gt;any&lt;/strong&gt; property or function, with any parameters:</source>
          <target state="translated">A의 &lt;code&gt;dynamic&lt;/code&gt; 변수는 호출 할 수 &lt;strong&gt;있는&lt;/strong&gt; 매개 변수와 속성이나 기능을 :</target>
        </trans-unit>
        <trans-unit id="d7653dc191105be976f3e4142a119bd4841c071b" translate="yes" xml:space="preserve">
          <source>On compiling, Gradle will produce the output of our application, which is by default placed under the &lt;code&gt;build/classes/main&lt;/code&gt; directory. This can be overridden using &lt;a href=&quot;#configuring-compiler-options&quot;&gt;the compiler options&lt;/a&gt;.</source>
          <target state="translated">컴파일시 Gradle은 기본적으로 &lt;code&gt;build/classes/main&lt;/code&gt; 디렉토리 아래에있는 애플리케이션의 출력을 생성합니다 . 이것은 &lt;a href=&quot;#configuring-compiler-options&quot;&gt;컴파일러 옵션을&lt;/a&gt; 사용 하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c14acaa8726202e56fd6764b8d4c4f4bf976a344" translate="yes" xml:space="preserve">
          <source>On compiling, Maven will produce the following output</source>
          <target state="translated">컴파일시 Maven은 다음과 같은 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="605e2cebf9185d39a487f4db48ecd6fb230665c8" translate="yes" xml:space="preserve">
          <source>On empty collections, &lt;code&gt;random()&lt;/code&gt; throws an exception. To receive &lt;code&gt;null&lt;/code&gt; instead, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random-or-null&quot;&gt;&lt;code&gt;randomOrNull()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">빈 컬렉션에서 &lt;code&gt;random()&lt;/code&gt; 은 예외를 발생시킵니다. 대신 &lt;code&gt;null&lt;/code&gt; 을 받으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random-or-null&quot;&gt; &lt;code&gt;randomOrNull()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2882a4f2583407f0619da2020ec98bec3d44466d" translate="yes" xml:space="preserve">
          <source>On macOS 10.13 with Xcode, we compile the C code and link it with the dynamic library with the following command:</source>
          <target state="translated">Xcode가 포함 된 macOS 10.13에서는 C 코드를 컴파일하고 다음 명령을 사용하여 동적 라이브러리와 연결합니다.</target>
        </trans-unit>
        <trans-unit id="29573262d66dff209bb25d8ca0d7651c0e4d12be" translate="yes" xml:space="preserve">
          <source>On the JVM platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt;). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</source>
          <target state="translated">JVM 플랫폼에서 표준 라이브러리에는 Java 리플렉션 개체와의 매핑을 제공하는 리플렉션 클래스에 대한 확장이 포함되어 있습니다 ( &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt; 패키지 참조 ). 예를 들어 Kotlin 속성에 대한 getter 역할을하는 지원 필드 또는 Java 메서드를 찾으려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b99e2927eb300e8d0d8fcf2adae0bb05f7e1dd48" translate="yes" xml:space="preserve">
          <source>On the JVM platform, the runtime component required for using the reflection features is distributed as a separate artifact &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; in the Kotlin compiler distribution. This is done to reduce the required size of the runtime library for applications that do not use reflection features.</source>
          <target state="translated">JVM 플랫폼에서 리플렉션 기능을 사용하는 데 필요한 런타임 구성 요소 는 Kotlin 컴파일러 배포에서 별도의 아티팩트 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 로 배포됩니다. 이는 리플렉션 기능을 사용하지 않는 응용 프로그램에 필요한 런타임 라이브러리 크기를 줄이기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4ddd201d36fd87940a13588d6e11985482252b" translate="yes" xml:space="preserve">
          <source>On the JVM side, the main build tools include &lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt;, &lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt;, &lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt;, and &lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobalt&lt;/a&gt;. There are also some build tools available that target client-side JavaScript.</source>
          <target state="translated">JVM 측면에서 기본 빌드 도구에는 &lt;a href=&quot;using-gradle&quot;&gt;Gradle&lt;/a&gt; , &lt;a href=&quot;using-maven&quot;&gt;Maven&lt;/a&gt; , &lt;a href=&quot;using-ant&quot;&gt;Ant&lt;/a&gt; 및 &lt;a href=&quot;http://beust.com/kobalt/home/index.html&quot;&gt;Kobalt가&lt;/a&gt; 있습니다. 클라이언트 측 JavaScript를 대상으로하는 빌드 도구도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a846654c5fb7b58771a6c8aa68e2bb8f0431b17" translate="yes" xml:space="preserve">
          <source>On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified (see &lt;a href=&quot;classes#constructors&quot;&gt;Constructors&lt;/a&gt;).</source>
          <target state="translated">JVM에서 생성 된 클래스에 매개 변수가없는 생성자가 필요한 경우 모든 특성의 기본값을 지정해야합니다 ( &lt;a href=&quot;classes#constructors&quot;&gt;생성자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="22f3441381be355a57b0344800020b03a2e7fba9" translate="yes" xml:space="preserve">
          <source>On the JVM, non-nullable values of this type are represented as values of the primitive type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">JVM에서이 유형의 널 입력 불가능 값은 기본 유형 &lt;code&gt;char&lt;/code&gt; 값으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c36ad8bfe3e9b420b17609f7d80f8fe5d46e556b" translate="yes" xml:space="preserve">
          <source>On the JVM, one could provide an implementation that writes the log to the standard output:</source>
          <target state="translated">JVM에서 표준 출력에 로그를 작성하는 구현을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c721a8e1ab899d231ec42baf253266e008d200" translate="yes" xml:space="preserve">
          <source>On the JVM, the &lt;a href=&quot;basic-types#arrays&quot;&gt;array types&lt;/a&gt; (&lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt;) retain the information about the erased type of their elements, and the type casts to an array type are partially checked: the nullability and actual type arguments of the elements type are still erased. For example, the cast &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; will succeed if &lt;code&gt;foo&lt;/code&gt; is an array holding any &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;, nullable or not.</source>
          <target state="translated">JVM에서 &lt;a href=&quot;basic-types#arrays&quot;&gt;배열 유형&lt;/a&gt; ( &lt;code&gt;Array&amp;lt;Foo&amp;gt;&lt;/code&gt; )은 요소의 지워진 유형에 대한 정보를 보유하고 배열 유형에 대한 유형 캐스트는 부분적으로 점검됩니다. 요소 유형의 널 입력 가능 여부 및 실제 유형 인수는 여전히 지워집니다. 예를 들어, &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 보유한 배열 ( 널 입력 가능 여부) 인 경우 캐스트 &lt;code&gt;foo as Array&amp;lt;List&amp;lt;String&amp;gt;?&amp;gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="5506431e2bb120557c874e7652f1a65950568290" translate="yes" xml:space="preserve">
          <source>On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. &lt;code&gt;Int?&lt;/code&gt;) or generics are involved. In the latter cases numbers are boxed.</source>
          <target state="translated">Java 플랫폼에서는 널 입력 가능 숫자 참조 (예 : &lt;code&gt;Int?&lt;/code&gt; )가 필요하거나 제네릭이 포함 되지 않는 한 숫자는 실제로 JVM 기본 유형으로 저장됩니다 . 후자의 경우 숫자가 박스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fc1cc156e617b185ed0f40e773e41bff1f85a104" translate="yes" xml:space="preserve">
          <source>On the Java platform, standard library contains extensions for reflection classes that provide a mapping to and from Java reflection objects (see package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt;). For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</source>
          <target state="translated">Java 플랫폼에서 표준 라이브러리에는 Java 리플렉션 객체와의 매핑을 제공하는 리플렉션 클래스에 대한 확장이 포함되어 있습니다 (package &lt;code&gt;kotlin.reflect.jvm&lt;/code&gt; 참조 ). 예를 들어 Kotlin 속성의 getter 역할을하는 지원 필드 나 Java 메서드를 찾으려면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a19f51c47052a4b52d4d3a45688012ff83885d4" translate="yes" xml:space="preserve">
          <source>On the Java platform, the runtime component required for using the reflection features is distributed as a separate JAR file (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt;). This is done to reduce the required size of the runtime library for applications that do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the classpath of your project.</source>
          <target state="translated">Java 플랫폼에서 리플렉션 기능을 사용하는 데 필요한 런타임 구성 요소는 별도의 JAR 파일 ( &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; ) 로 분배 됩니다. 리플렉션 기능을 사용하지 않는 응용 프로그램에 필요한 런타임 라이브러리 크기를 줄이기 위해 수행됩니다. 리플렉션을 사용하는 경우 .jar 파일이 프로젝트의 클래스 경로에 추가되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5d535cc279349339edec2b28152e5485a7cce0a0" translate="yes" xml:space="preserve">
          <source>On the JavaScript platform this code will be compiled &quot;as is&quot;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in Kotlin becomes &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in the generated JavaScript code.</source>
          <target state="translated">&quot;있는 그대로&quot;이 코드는 컴파일 될 자바 스크립트 플랫폼 : &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 코 틀린에이된다 &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 생성 된 자바 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5b66a81be58a9639896f5746359a7ffeeb1b2933" translate="yes" xml:space="preserve">
          <source>On the JavaScript platform, only class references are currently supported. &lt;a href=&quot;js-reflection&quot;&gt;Learn more about reflection in Kotlin/JS&lt;/a&gt;.</source>
          <target state="translated">JavaScript 플랫폼에서는 현재 클래스 참조 만 지원됩니다. &lt;a href=&quot;js-reflection&quot;&gt;Kotlin / JS의 리플렉션에 대해 자세히 알아보세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7710454ff099464789e309cce04c505a88cd2a29" translate="yes" xml:space="preserve">
          <source>On the generic Native platform we don't have the luxury to use someone else's implementation, so we will have to write one ourselves. I won't explain the implementation details here, but it's pretty straightforward and follows Base64 format description without any optimizations:</source>
          <target state="translated">일반 네이티브 플랫폼에서는 다른 사람의 구현을 사용할 수있는 사치가 없으므로 직접 작성해야합니다. 여기에 구현 세부 사항을 설명하지는 않지만 매우 간단하며 최적화없이 Base64 형식 설명을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="dc341284a94c1ff306b2072d23ec90c8ced7deca" translate="yes" xml:space="preserve">
          <source>On the one hand, to achieve this, the compiler has to provide certain ABI stability guarantees under the constraints of separate compilation. This is why every change in the language is examined from the point of view of binary compatibility.</source>
          <target state="translated">한편으로,이를 달성하기 위해 컴파일러는 별도의 컴파일 제약 조건 하에서 특정 ABI 안정성 보장을 제공해야합니다. 이진 호환성의 관점에서 언어의 모든 변경 사항을 검사하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="000c75f582537e6c16176741f98b45d2d110bbb3" translate="yes" xml:space="preserve">
          <source>On the other hand, Kotlin/Native supports interoperability to use existing libraries directly from Kotlin/Native:</source>
          <target state="translated">반면 Kotlin / Native는 Kotlin / Native에서 직접 기존 라이브러리를 사용할 수있는 상호 운용성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="60f0f1b25c5dff1f04424f892492e20e71e1b66d" translate="yes" xml:space="preserve">
          <source>On the other hand, a lot depends on the library authors being careful about which changes are safe to make. Thus it's very important that library authors understand how source changes affect compatibility and follow certain best practices to keep both APIs and ABIs of their libraries stable. Here are some assumptions that we make when considering language changes from the library evolution standpoint:</source>
          <target state="translated">다른 한편으로, 많은 변경 사항이 안전한지 라이브러리 라이브러리 작성자가주의를 기울여야합니다. 따라서 라이브러리 작성자는 소스 변경이 호환성에 미치는 영향을 이해하고 라이브러리의 API 및 ABI를 모두 안정적으로 유지하기 위해 특정 모범 사례를 따르는 것이 중요합니다. 다음은 라이브러리 진화 관점에서 언어 변경을 고려할 때 가정 한 내용입니다.</target>
        </trans-unit>
        <trans-unit id="24a6b58cfe3e05a456f0e657a9154e03adab1e36" translate="yes" xml:space="preserve">
          <source>On the other hand, if we don't need wildcards where they are generated, we can use &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt;:</source>
          <target state="translated">반면에 생성 된 와일드 카드가 필요없는 경우 &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fe83b5bff0a5d4a34dc3a1fd60b88652cfd8998" translate="yes" xml:space="preserve">
          <source>On the other hand, infix function call's precedence is higher than that of the boolean operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;- and &lt;code&gt;in&lt;/code&gt;-checks, and some other operators. These expressions are equivalent as well:</source>
          <target state="translated">반면에, infix 함수 호출의 우선 순위는 부울 연산자 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 의 우선 순위보다 높습니다. , &lt;code&gt;is&lt;/code&gt; - &lt;code&gt;in&lt;/code&gt; - in- checks 및 일부 다른 연산자입니다. 이 표현들도 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="4b4a432df45f297429fbc3cee76b5f8d7f65a8e2" translate="yes" xml:space="preserve">
          <source>On the other hand, it preserves equality:</source>
          <target state="translated">반면에 평등을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7e3c3918cd7bead7b21ab07c18b704638f85c9a4" translate="yes" xml:space="preserve">
          <source>On the other hand, the platform libs in the distribution are merely just wrappers and bindings to the native libraries. That means the native libraries themselves (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.a&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt; etc) should be installed on the machine.</source>
          <target state="translated">다른 한편으로, 배포판의 플랫폼 라이브러리는 단지 래퍼 일 뿐이며 네이티브 라이브러리에 대한 바인딩 일뿐입니다. 즉, 기본 라이브러리 자체 ( &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.a&lt;/code&gt; , &lt;code&gt;.dylib&lt;/code&gt; , &lt;code&gt;.dll&lt;/code&gt; 등)가 시스템에 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a4bdeb370dbf1cefb8a423a42914a31fcb4ec6d9" translate="yes" xml:space="preserve">
          <source>On the other side, by default, a dispatcher for the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; is inherited. The default dispatcher for &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with a predictable FIFO scheduling.</source>
          <target state="translated">한편, 기본적으로 외부 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope에&lt;/a&gt; 대한 디스패처 가 상속됩니다. 특히 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 의 기본 디스패처 는 호출자 스레드로 제한되므로이를 상속하면 예측 가능한 FIFO 스케줄링으로이 스레드에 대한 실행을 제한하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="425d42a58936f61d420710d94f729d1304fe83b3" translate="yes" xml:space="preserve">
          <source>On the other side, the dispatcher is inherited from the outer &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; by default. The default dispatcher for the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine, in particular, is confined to the invoker thread, so inheriting it has the effect of confining execution to this thread with predictable FIFO scheduling.</source>
          <target state="translated">다른 쪽에서 디스패처는 기본적으로 외부 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; 에서 상속됩니다 . 특히 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 의 기본 디스패처 는 호출자 스레드로 제한되어 있으므로이를 상속하면 예측 가능한 FIFO 스케줄링을 사용하여 실행을이 스레드로 제한하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="40268462bf212f39b8385da7e84960f17dde7ce2" translate="yes" xml:space="preserve">
          <source>On this page, you'll learn how the modifiers apply to different types of declaring scopes.</source>
          <target state="translated">이 페이지에서는 수정자가 다양한 유형의 선언 범위에 적용되는 방법을 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="0097b825a22364e0ed5d52b543c2c2d7417ac42f" translate="yes" xml:space="preserve">
          <source>OnErrorAction</source>
          <target state="translated">OnErrorAction</target>
        </trans-unit>
        <trans-unit id="af3390fd9bdb1b1f1af829e06104c3364aeb4907" translate="yes" xml:space="preserve">
          <source>Once a worker is started with the &lt;code&gt;Worker.start&lt;/code&gt; function call, it can be addressed with its own unique integer worker id. Other workers, or non-worker concurrency primitives, such as OS threads, can send a message to the worker with the &lt;code&gt;execute&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;Worker.start&lt;/code&gt; 함수 호출 로 워커를 시작하면 고유 한 정수 워커 ID로 주소를 지정할 수 있습니다. 다른 작업자 또는 OS 스레드와 같은 비 작업 동시성 프리미티브는 &lt;code&gt;execute&lt;/code&gt; 호출 을 통해 작업자에게 메시지를 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df99b41ffc8e8869530eb6fc788d462a8f350ad0" translate="yes" xml:space="preserve">
          <source>Once that's done, we simply right-click on our &lt;code&gt;index.html&lt;/code&gt; file and select the Debug option. This launches Chrome and then stops at the breakpoint defined in our code inside IntelliJ IDEA, from where we can evaluate expressions, step through code, etc.</source>
          <target state="translated">완료되면 &lt;code&gt;index.html&lt;/code&gt; 파일을 마우스 오른쪽 버튼으로 클릭 하고 디버그 옵션을 선택하십시오. Chrome을 시작한 다음 IntelliJ IDEA 내부의 코드에 정의 된 중단 점에서 중지합니다. 여기서 표현식을 평가하고 코드를 통과하는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3775c8ff21ba04eef02e13e8e82e7fea59a82c9d" translate="yes" xml:space="preserve">
          <source>Once the IDE has finished creating the new project, we should be left with the following layout</source>
          <target state="translated">IDE가 새 프로젝트 생성을 마치면 다음 레이아웃을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9769c12f9ad9598db953dee152f3b5b5ad3daf0" translate="yes" xml:space="preserve">
          <source>Once the code is ready, select a fragment you want a learner to fill in, invoke &lt;strong&gt;Add Answer Placeholder&lt;/strong&gt; command from the right-click menu and add the placeholder text and some hints to help the learner find the right solution:</source>
          <target state="translated">코드가 준비되면 학습자가 채울 조각을 선택 하고 마우스 오른쪽 버튼 메뉴에서 &lt;strong&gt;답변 자리 표시 자 추가&lt;/strong&gt; 명령을 호출 하고 자리 표시 자 텍스트와 힌트를 추가하여 학습자가 올바른 솔루션을 찾을 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="46c1b63ed4fbeaebfc1fd631405807b64e959941" translate="yes" xml:space="preserve">
          <source>Once the dependency is included, we can access the different interfaces provided to generate DOM. The code below will add a new &lt;code&gt;span&lt;/code&gt; tag with the text &lt;code&gt;Hello&lt;/code&gt; inside a &lt;code&gt;div&lt;/code&gt; on the &lt;code&gt;window.load&lt;/code&gt; event.</source>
          <target state="translated">종속성이 포함되면 DOM을 생성하기 위해 제공된 다른 인터페이스에 액세스 할 수 있습니다. 아래 코드 는 &lt;code&gt;window.load&lt;/code&gt; 이벤트 의 &lt;code&gt;div&lt;/code&gt; 안에 &lt;code&gt;Hello&lt;/code&gt; 텍스트 가 포함 된 새 &lt;code&gt;span&lt;/code&gt; 태그를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="5f0142e56236eba7d0f9779ea0961db259aa8e0d" translate="yes" xml:space="preserve">
          <source>Once the file is created, add the &lt;code&gt;main&lt;/code&gt; function which is the entry point to a Kotlin application. IntelliJ IDEA offers a template to do this quickly. Just type &lt;em&gt;main&lt;/em&gt; and press tab.</source>
          <target state="translated">파일이 작성되면 Kotlin 애플리케이션의 진입 점 인 &lt;code&gt;main&lt;/code&gt; 기능을 추가하십시오 . IntelliJ IDEA는이를 신속하게 수행 할 수있는 템플릿을 제공합니다. &lt;em&gt;main을&lt;/em&gt; 입력 하고 tab을 누릅니다.</target>
        </trans-unit>
        <trans-unit id="c73312381dcc07c6b7a625ba7ed9e57ac7440a0f" translate="yes" xml:space="preserve">
          <source>Once the plugin is installed and Eclipse is restarted, make sure the plugin is installed correctly: open the &lt;strong&gt;Kotlin perspective&lt;/strong&gt; in the menu &lt;strong&gt;Window | Open Perspective | Other&amp;hellip;&lt;/strong&gt;</source>
          <target state="translated">플러그인이 설치되고 Eclipse가 다시 시작되면 플러그인이 올바르게 설치되었는지 확인하십시오 . 메뉴 &lt;strong&gt;창&lt;/strong&gt; 에서 &lt;strong&gt;Kotlin Perspective를여십시오. &lt;/strong&gt;&lt;strong&gt;열린 관점 | 다른&amp;hellip;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea14fe002f3a94c4720dab1f2d5b5523e7e10653" translate="yes" xml:space="preserve">
          <source>Once we do that, we can start the app by running the following command</source>
          <target state="translated">그렇게하면 다음 명령을 실행하여 앱을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0796366ca4be24e6c9cb8aea2efb2652251fe7de" translate="yes" xml:space="preserve">
          <source>Once we do that, we can then invoke the corresponding extensions, which are properties named after the views in the XML file. For example, for this view:</source>
          <target state="translated">그렇게하면 XML 파일의 뷰 이름을 딴 속성 인 해당 확장을 호출 할 수 있습니다. 예를 들어,이보기의 경우 :</target>
        </trans-unit>
        <trans-unit id="1c271397461aeb676abb2a2efff251e0af0e8c64" translate="yes" xml:space="preserve">
          <source>Once we have the build script defined with the correct dependencies, we can now create a controller</source>
          <target state="translated">올바른 의존성으로 빌드 스크립트를 정의했으면 이제 컨트롤러를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a08b600d20b04c79c7a79b722bf898a01cce7fce" translate="yes" xml:space="preserve">
          <source>Once we have the definition file ready, we can create project files and open the project in an IDE.</source>
          <target state="translated">정의 파일이 준비되면 프로젝트 파일을 생성하고 IDE에서 프로젝트를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8045dca300b9f4677fd2c5dc7702ace1a03cfe2" translate="yes" xml:space="preserve">
          <source>Once we have the file generated, we can simply include it in our project and use it:</source>
          <target state="translated">파일이 생성되면 간단히 프로젝트에 파일을 포함하고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd56b1bd7445724ec0021ec14943c2a384d08186" translate="yes" xml:space="preserve">
          <source>Once we run the application (using this previous run configuration), and on successful deployment, we should be able to navigate to the browser with the correct url and see the response:</source>
          <target state="translated">응용 프로그램을 실행하고 (이 이전 실행 구성을 사용하여) 성공적으로 배포되면 올바른 URL로 브라우저를 탐색하고 응답을 볼 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b6604db47f0dce985d7de59d4f23c0c4c5c9cca" translate="yes" xml:space="preserve">
          <source>Once you complete the steps, Android Studio creates a project. The project already contains all the code and resources for building an application that can run on your Android device or an emulator.</source>
          <target state="translated">단계를 완료하면 Android Studio가 프로젝트를 생성합니다. 프로젝트에는 이미 Android 장치 또는 에뮬레이터에서 실행할 수있는 응용 프로그램을 빌드하기위한 모든 코드와 리소스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c62572d32f4ddef7a4fab02344f0c5993a4073" translate="yes" xml:space="preserve">
          <source>Once you have IntelliJ IDEA installed, it's time to create your first Kotlin application.</source>
          <target state="translated">IntelliJ IDEA를 설치했으면 이제 첫 번째 Kotlin 응용 프로그램을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="57c7fbdcf305fcf640a6242dec4553b583c17b02" translate="yes" xml:space="preserve">
          <source>Once you have a source file, add the &lt;code&gt;main&lt;/code&gt; function - the entry point to a Kotlin application. You can simply type &lt;code&gt;main&lt;/code&gt; and invoke code completion by hitting &lt;code&gt;Ctrl + Space&lt;/code&gt;.</source>
          <target state="translated">소스 파일이 있으면 &lt;code&gt;main&lt;/code&gt; 기능인 Kotlin 응용 프로그램의 진입 점을 추가하십시오 . &lt;code&gt;Ctrl + Space&lt;/code&gt; 누르면 &lt;code&gt;main&lt;/code&gt; 을 입력 하고 코드 완성을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e85f75a1aece4509c955931a0b0a7c85d0dc463" translate="yes" xml:space="preserve">
          <source>Once you have finished writing your code in a scratch or a worksheet, click &lt;strong&gt;Run&lt;/strong&gt;. The execution results will appear in the lines opposite your code.</source>
          <target state="translated">스크래치 또는 워크 시트에 코드 작성을 마쳤 으면 &lt;strong&gt;실행을&lt;/strong&gt; 클릭 합니다. 실행 결과는 코드 반대 줄에 나타납니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
