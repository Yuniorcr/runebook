<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="c5fa62c81704299df516dd7c041a8d480c196b9b" translate="yes" xml:space="preserve">
          <source>If a default type qualifier uses a type qualifier nickname and they are both &lt;code&gt;@UnderMigration&lt;/code&gt;, the status from the default type qualifier is used.</source>
          <target state="translated">기본 유형 한정자가 유형 한정자 닉네임을 사용하고 둘 다 &lt;code&gt;@UnderMigration&lt;/code&gt; 인 경우 기본 유형 한정자의 상태가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb1b7879228c51bc49251497614be1617615253" translate="yes" xml:space="preserve">
          <source>If a file doesn't declare a package, it belongs to the nameless &lt;em&gt;default package&lt;/em&gt;. This should be avoided, as it will make it hard to reference the symbols from that file in case of naming conflicts (you can't explicitly import the empty package).</source>
          <target state="translated">파일이 패키지를 선언하지 않으면 이름이없는 &lt;em&gt;기본 패키지에&lt;/em&gt; 속합니다 . 이름 충돌이 발생하는 경우 해당 파일에서 기호를 참조하기가 어려워 지므로 피해야합니다 (빈 패키지를 명시 적으로 가져올 수 없음).</target>
        </trans-unit>
        <trans-unit id="f5fbea4c3aea4496e7e7b00414d2fcaa5869dd61" translate="yes" xml:space="preserve">
          <source>If a function does not return any useful value, its return type is &lt;code&gt;Unit&lt;/code&gt;. &lt;code&gt;Unit&lt;/code&gt; is a type with only one value - &lt;code&gt;Unit&lt;/code&gt;. This value does not have to be returned explicitly:</source>
          <target state="translated">함수가 유용한 값을 반환하지 않으면 반환 유형은 &lt;code&gt;Unit&lt;/code&gt; 입니다. &lt;code&gt;Unit&lt;/code&gt; 는 단 하나의 값인 &lt;code&gt;Unit&lt;/code&gt; 입니다. 이 값을 명시 적으로 반환 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="586ae5a6f0a2e9992a680dbe096f9f0a203405b4" translate="yes" xml:space="preserve">
          <source>If a function returns Unit, the return type should be omitted:</source>
          <target state="translated">함수가 Unit을 반환하면 반환 유형을 생략해야합니다.</target>
        </trans-unit>
        <trans-unit id="26ffbbf2f8c7a69e516fd6f5e5fb01c4807e2577" translate="yes" xml:space="preserve">
          <source>If a generic type has several type parameters each of them can be projected independently. For example, if the type is declared as &lt;code&gt;interface Function&amp;lt;in T, out U&amp;gt;&lt;/code&gt; we can imagine the following star-projections:</source>
          <target state="translated">일반 유형에 여러 유형 매개 변수가있는 경우 각 유형 매개 변수를 독립적으로 투사 할 수 있습니다. 예를 들어, 유형이 &lt;code&gt;interface Function&amp;lt;in T, out U&amp;gt;&lt;/code&gt; 로 선언 되면 다음과 같은 별 투영법을 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70975e077538a847ffe5a0e5b87f2c6b9c2f7e0c" translate="yes" xml:space="preserve">
          <source>If a library author marks a declaration from a library's API as &lt;a href=&quot;#requiring-opt-in-for-api&quot;&gt;&lt;em&gt;requiring opt-in&lt;/em&gt;&lt;/a&gt;, you should give an explicit consent for using it in your code. There are several ways to opt in to such APIs, all applicable without technical limitations. You are free to choose the way that you find best for your situation.</source>
          <target state="translated">라이브러리 작성자가 라이브러리 API의 선언을 &lt;a href=&quot;#requiring-opt-in-for-api&quot;&gt;&lt;em&gt;opt-in&lt;/em&gt;&lt;/a&gt; 을 &lt;em&gt;요구하는&lt;/em&gt; 것으로 표시하는 경우 코드에서이를 사용하는 데 명시적인 동의를 제공해야합니다. 이러한 API에 옵트 인하는 방법에는 여러 가지가 있으며 모두 기술적 제한없이 적용 할 수 있습니다. 자신의 상황에 가장 적합한 방법을 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54bed7a1e50c0cec37b385196df44d20ab05f40" translate="yes" xml:space="preserve">
          <source>If a library consumer defines variants that are missing in the library, they need to provide matching fallbacks. For example, if a library does not have or does not publish a staging build type, the library consumer must provide a fallback for the consumers who have such a build type, specifying at least one of the build types that the library publishes:</source>
          <target state="translated">라이브러리 소비자가 라이브러리에서 누락 된 변형을 정의하는 경우 일치하는 대체를 제공해야합니다. 예를 들어 라이브러리에 스테이징 빌드 유형이 없거나 게시하지 않은 경우 라이브러리 소비자는 라이브러리가 게시하는 빌드 유형 중 하나 이상을 지정하여 이러한 빌드 유형을 가진 소비자에 대한 대체를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="de5d80fa791bb5a89bb7999f43e44154d9f7a1b7" translate="yes" xml:space="preserve">
          <source>If a library has a 'root' publication, the consumer may specify a single dependency on the library as a whole in a common source set, and a corresponding platform-specific variant will be chosen, if available, for each of the compilations that include this dependency. Consider a &lt;code&gt;sample-lib&lt;/code&gt; library built for the JVM and JS and published with a 'root' publication:</source>
          <target state="translated">라이브러리에 '루트'발행물이있는 경우 소비자는 공통 소스 세트에서 라이브러리 전체에 단일 종속성을 지정할 수 있으며, 사용 가능한 경우 포함 된 각 컴파일에 대해 해당 플랫폼 별 변형이 선택됩니다. 이 의존성. JVM 및 JS 용으로 빌드되고 '루트'공개로 공개 된 &lt;code&gt;sample-lib&lt;/code&gt; 라이브러리를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b6d1027059f87a94c39781325c4a38d3fd36ee6" translate="yes" xml:space="preserve">
          <source>If a member function or property is declared as &lt;code&gt;open&lt;/code&gt;, subclasses may &lt;em&gt;override&lt;/em&gt; it by providing a new implementation. Let's say that &lt;code&gt;MotorVehicle&lt;/code&gt; declares this function:</source>
          <target state="translated">멤버 함수 또는 속성이 &lt;code&gt;open&lt;/code&gt; 으로 선언 되면 하위 클래스는 새로운 구현을 제공하여이를 &lt;em&gt;재정의&lt;/em&gt; 할 수 &lt;em&gt;있습니다&lt;/em&gt; . &lt;code&gt;MotorVehicle&lt;/code&gt; 이이 함수를 선언 한다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="3b05658c0676c78c2f6ecac73f01698365f225fb" translate="yes" xml:space="preserve">
          <source>If a method has N parameters and M of which have default values, M overloads are generated: the first one takes N-1 parameters (all but the last one that takes a default value), the second takes N-2 parameters, and so on.</source>
          <target state="translated">메소드에 N 개의 매개 변수가 있고 M에 기본값이있는 경우 M 과부하가 생성됩니다. 첫 번째 매개 변수는 N-1 매개 변수 (모두 마지막 값을 제외하고 기본값)를 취하고 두 번째 매개 변수는 N-2 매개 변수를 사용합니다. 의 위에.</target>
        </trans-unit>
        <trans-unit id="a6a3dbe7a3c930fff25db8be2ac42bb4869e7083" translate="yes" xml:space="preserve">
          <source>If a module is an endpoint application which is not published, use &lt;code&gt;implementation&lt;/code&gt; dependencies instead of &lt;code&gt;api&lt;/code&gt; dependencies.</source>
          <target state="translated">모듈이 게시되지 않은 엔드 포인트 애플리케이션 인 경우 &lt;code&gt;api&lt;/code&gt; 종속성 대신 &lt;code&gt;implementation&lt;/code&gt; 종속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="187f8c5b91bd6882618c5a62bdf223a239fa7e78" translate="yes" xml:space="preserve">
          <source>If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary constructor with no arguments. The visibility of the constructor will be public. If you do not want your class to have a public constructor, you need to declare an empty primary constructor with non-default visibility:</source>
          <target state="translated">비추 상 클래스가 생성자 (기본 또는 보조)를 선언하지 않으면 생성 된 기본 생성자가 인수없이 생성됩니다. 생성자의 가시성은 공개됩니다. 클래스에 퍼블릭 생성자를 가지지 않으려면 기본 가시성이 아닌 빈 기본 생성자를 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="29905ed43abbefe9d905d1bc7ab8a797a47bb7d9" translate="yes" xml:space="preserve">
          <source>If a project consists of both Kotlin and Java source code, while it is possible to use &lt;em&gt;kotlinc&lt;/em&gt;, to avoid repetition of task parameters, it is recommended to use &lt;em&gt;withKotlin&lt;/em&gt; task:</source>
          <target state="translated">프로젝트가 Kotlin과 Java 소스 코드로 구성된 경우 &lt;em&gt;kotlinc&lt;/em&gt; 를 사용 하여 작업 매개 변수의 반복을 피할 수 있지만 &lt;em&gt;Kotlin&lt;/em&gt; 작업과 함께 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="609654c2fad938d0263a48e6bf332c23223482ab" translate="yes" xml:space="preserve">
          <source>If a project consists of multiple source roots, use &lt;em&gt;src&lt;/em&gt; as elements to define paths:</source>
          <target state="translated">프로젝트가 여러 소스 루트로 구성된 경우 &lt;em&gt;src&lt;/em&gt; 를 요소로 사용하여 경로를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="6ed938136219853ee5b7c06664d635c5b5eff6f0" translate="yes" xml:space="preserve">
          <source>If a sequence operation returns another sequence, which is produced lazily, it's called &lt;em&gt;intermediate&lt;/em&gt;. Otherwise, the operation is &lt;em&gt;terminal&lt;/em&gt;. Examples of terminal operations are &lt;a href=&quot;constructing-collections#copying&quot;&gt;&lt;code&gt;toList()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;collection-aggregate&quot;&gt;&lt;code&gt;sum()&lt;/code&gt;&lt;/a&gt;. Sequence elements can be retrieved only with terminal operations.</source>
          <target state="translated">시퀀스 연산이 느리게 생성 된 다른 시퀀스를 반환하면이를 &lt;em&gt;중간&lt;/em&gt; 이라고 합니다. 그렇지 않으면 작업은 &lt;em&gt;터미널&lt;/em&gt; 입니다. 터미널 연산의 예는 &lt;a href=&quot;constructing-collections#copying&quot;&gt; &lt;code&gt;toList()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;collection-aggregate&quot;&gt; &lt;code&gt;sum()&lt;/code&gt; &lt;/a&gt; 입니다. 시퀀스 요소는 터미널 조작으로 만 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30e6ccb06323d447af741e2670a8825971c56bf1" translate="yes" xml:space="preserve">
          <source>If a supertype has a constructor, appropriate constructor parameters must be passed to it. Many supertypes may be specified as a comma-separated list after the colon:</source>
          <target state="translated">수퍼 타입에 생성자가 있으면 적절한 생성자 매개 변수를 전달해야합니다. 콜론 다음에 많은 수퍼 타입이 쉼표로 구분 된 목록으로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ee75455c68258fcc7798b0e5a90d8dadcef5cd" translate="yes" xml:space="preserve">
          <source>If a supertype has the &lt;code&gt;componentN()&lt;/code&gt; functions that are &lt;em&gt;open&lt;/em&gt; and return compatible types, the corresponding functions are generated for the data class and override those of the supertype. If the functions of the supertype cannot be overridden due to incompatible signatures or being final, an error is reported;</source>
          <target state="translated">수퍼 타입 에 &lt;em&gt;open&lt;/em&gt; 및 return 호환 가능 유형 인 &lt;code&gt;componentN()&lt;/code&gt; 함수가 &lt;em&gt;있는&lt;/em&gt; 경우 해당 함수가 데이터 클래스에 대해 생성되고 수퍼 타입의 함수를 대체합니다. 호환되지 않는 서명으로 인해 수퍼 타입의 기능을 대체 할 수 없거나 오류가 발생하면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="28f4bb4cbd876a2710b0efbbf4b0592357748708" translate="yes" xml:space="preserve">
          <source>If a top-level declaration is marked &lt;em&gt;private&lt;/em&gt;, it is private to the file it's declared in (see &lt;a href=&quot;visibility-modifiers&quot;&gt;Visibility Modifiers&lt;/a&gt;).</source>
          <target state="translated">최상위 선언이 &lt;em&gt;private&lt;/em&gt; 로 표시 되면 선언 된 파일에 대해 비공개입니다 ( &lt;a href=&quot;visibility-modifiers&quot;&gt;가시성 수정 자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f9335847e2c530d21bcd3080b073f4d1f543f5f" translate="yes" xml:space="preserve">
          <source>If all you want to do with a constructor parameter value is to assign it to a property with the same name, you can declare the property in the primary constructor parameter list (the oneliner below is sufficient for both declaring the properties, declaring the constructor parameters, and initializing the properties with the parameters):</source>
          <target state="translated">생성자 매개 변수 값으로 수행하려는 모든 작업이 동일한 이름의 속성에 할당하는 것이라면 기본 생성자 매개 변수 목록에서 속성을 선언 할 수 있습니다 (아래의 oneliner는 속성을 선언하고 생성자 매개 변수를 선언하는 데 충분합니다). 매개 변수를 사용하여 속성 초기화) :</target>
        </trans-unit>
        <trans-unit id="286a0bf4d2cc8a5a12f2292b0ceccc9207bc4770" translate="yes" xml:space="preserve">
          <source>If an annotation is used as a parameter of another annotation, its name is not prefixed with the @ character:</source>
          <target state="translated">주석이 다른 주석의 매개 변수로 사용되는 경우 이름 앞에 @ 문자가 붙지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10147e3b40c783598d2bd9a60f764d64051cd74f" translate="yes" xml:space="preserve">
          <source>If an annotation type is annotated with both &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierNickname.html&quot;&gt;&lt;code&gt;@TypeQualifierNickname&lt;/code&gt;&lt;/a&gt; and JSR-305 &lt;code&gt;@Nonnull&lt;/code&gt; (or its another nickname, such as &lt;code&gt;@CheckForNull&lt;/code&gt;), then the annotation type is itself used for retrieving precise nullability and has the same meaning as that nullability annotation:</source>
          <target state="translated">주석 형 양쪽 주석 경우 &lt;a href=&quot;https://aalmiray.github.io/jsr-305/apidocs/javax/annotation/meta/TypeQualifierNickname.html&quot;&gt; &lt;code&gt;@TypeQualifierNickname&lt;/code&gt; &lt;/a&gt; 및 JSR-305 &lt;code&gt;@Nonnull&lt;/code&gt; (예 또는 다른 닉네임 &lt;code&gt;@CheckForNull&lt;/code&gt; 예), 주석 형 자체 정확한 Null 허용 입수 사용이 널 (NULL) 주석과 같은 의미를 갖는다 :</target>
        </trans-unit>
        <trans-unit id="f981f8a8e6f98948229b86561835f71dd548b23d" translate="yes" xml:space="preserve">
          <source>If an extension is declared outside its receiver type, such an extension cannot access the receiver's &lt;code&gt;private&lt;/code&gt; members.</source>
          <target state="translated">확장이 수신자 유형 외부에서 선언되면 해당 확장은 수신자의 &lt;code&gt;private&lt;/code&gt; 멤버에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="61dcbc44eee3bab1f0e103c1b87baa369fec0f94" translate="yes" xml:space="preserve">
          <source>If an external build system is used for configuring the project, and it's been decided not to share &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, Kotlin Coding Conventions can be forced with an additional property:</source>
          <target state="translated">외부 빌드 시스템을 사용하여 프로젝트를 구성하고 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 폴더 를 공유하지 않기로 결정한 경우 Kotlin Coding Conventions에 추가 속성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d93cee5a226e1db8584fc451a3062eec2e7267d3" translate="yes" xml:space="preserve">
          <source>If an object is frozen it can be checked with an extension property &lt;code&gt;isFrozen&lt;/code&gt;, and if it is, object sharing is allowed. Currently, Kotlin/Native runtime only freezes the enum objects after creation, although additional autofreezing of certain provably immutable objects could be implemented in the future.</source>
          <target state="translated">객체가 고정 된 경우 확장 속성 &lt;code&gt;isFrozen&lt;/code&gt; 을 사용하여 확인할 수 있으며 , 그렇지 않은 경우 객체 공유가 허용됩니다. 현재 Kotlin / Native 런타임은 생성 후에 열거 형 객체 만 고정하지만 향후에는 불변의 특정 객체에 대한 추가 자동 동결이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d745839ade06f63274de839883364751868e1c68" translate="yes" xml:space="preserve">
          <source>If an object is transferred in &lt;code&gt;UNSAFE&lt;/code&gt; mode and is still accessible from multiple concurrent executors, program will likely crash unexpectedly, so consider that last resort in optimizing, not a general purpose mechanism.</source>
          <target state="translated">개체가 &lt;code&gt;UNSAFE&lt;/code&gt; 모드 로 전송되고 여러 동시 실행 프로그램에서 여전히 액세스 할 수있는 경우 프로그램이 예기치 않게 중단 될 수 있으므로 범용 메커니즘이 아닌 최적화의 최후의 수단을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2fbb13db366dcb9336c03ff5dd678511b1b8d160" translate="yes" xml:space="preserve">
          <source>If any errors occur during the copying, then further actions will depend on the result of the call to &lt;code&gt;onError(File, IOException)&lt;/code&gt; function, that will be called with arguments, specifying the file that caused the error and the exception itself. By default this function rethrows exceptions.</source>
          <target state="translated">복사 중에 오류가 발생하면 &lt;code&gt;onError(File, IOException)&lt;/code&gt; 함수 에 대한 호출 결과에 따라 추가 조치가 발생합니다.이 함수는 인수와 함께 호출되어 오류를 일으킨 파일과 예외 자체를 지정합니다. 기본적으로이 함수는 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="aad3cd8dfcbdf7511572b2939855bed2ac55b99b" translate="yes" xml:space="preserve">
          <source>If any of arrays contains itself on any nesting level that reference is rendered as &lt;code&gt;&quot;[...]&quot;&lt;/code&gt; to prevent recursion.</source>
          <target state="translated">배열 중 하나라도 중첩 수준에 포함 된 경우 해당 참조는 재귀를 방지하기 위해 &lt;code&gt;&quot;[...]&quot;&lt;/code&gt; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3f9db9bf25bbec3f31f98164a22576425cc669b" translate="yes" xml:space="preserve">
          <source>If any of arrays contains itself on any nesting level the behavior is undefined.</source>
          <target state="translated">배열 중 하나라도 중첩 수준에 포함 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c5d9097483a5bb9ad684d81ab29afc4db54e1ed" translate="yes" xml:space="preserve">
          <source>If any of elements is &lt;code&gt;NaN&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">요소 중 하나 인 경우 &lt;code&gt;NaN&lt;/code&gt; 이는 반환 &lt;code&gt;NaN&lt;/code&gt; 이를 .</target>
        </trans-unit>
        <trans-unit id="97176cd6bad6dda53932f8ad2eae19bbc9012e41" translate="yes" xml:space="preserve">
          <source>If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6fdd79609c8f85fa31ce635ac8b9cd8b21fe6cf8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.Array((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.Array((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd1a69eb514868f3014ac9ebddc5f5d735edf89e" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Iterable((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Iterable((kotlin.collections.maxOf.T)),%20kotlin.Function1((kotlin.collections.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e189e501066f4ac42ca51a4be243a3ad0abadf5" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Map((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.collections%24maxOf(kotlin.collections.Map((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOf.K,%20kotlin.collections.maxOf.V)),%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="96b36a40f387f4c8df6c324c6dc2b703f21da3c2" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.sequences%24maxOf(kotlin.sequences.Sequence((kotlin.sequences.maxOf.T)),%20kotlin.Function1((kotlin.sequences.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.sequences%24maxOf(kotlin.sequences.Sequence((kotlin.sequences.maxOf.T)),%20kotlin.Function1((kotlin.sequences.maxOf.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b32c87f07f448e5c852864c4c07255913a33f154" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of#kotlin.text%24maxOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of#kotlin.text%24maxOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="973ed91938d379c81da13b3ca48e010cd6c1309f" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.Array((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.Array((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2466fddfdfd68288ce0227609640affb7f9beb8c" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Iterable((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Iterable((kotlin.collections.maxOfOrNull.T)),%20kotlin.Function1((kotlin.collections.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="30f52c50e23a311e6818d0613ec256f55699413d" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Map((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.collections%24maxOfOrNull(kotlin.collections.Map((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.maxOfOrNull.K,%20kotlin.collections.maxOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ccf1c9aefb939e391c556149e3b88356bdd369b8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.sequences%24maxOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.maxOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.sequences%24maxOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.maxOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.maxOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c39e75bf5be9b08a47160d2b17149dae147dbe4d" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;max-of-or-null#kotlin.text%24maxOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;max-of-or-null#kotlin.text%24maxOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3801e7c556a007fa15fa5fdf086b701342f4493" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.Array((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.Array((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f54dcaf8c15a4fde48f9f8e9fd9ddcdcff34c0f" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Iterable((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Iterable((kotlin.collections.minOf.T)),%20kotlin.Function1((kotlin.collections.minOf.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59f702b5ac5ebb0f583e7b36eff4014222ccd52b" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Map((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.collections%24minOf(kotlin.collections.Map((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOf.K,%20kotlin.collections.minOf.V)),%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36401114fbe626769f0b61474ddddd4a4ed62ae5" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.sequences%24minOf(kotlin.sequences.Sequence((kotlin.sequences.minOf.T)),%20kotlin.Function1((kotlin.sequences.minOf.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.sequences%24minOf(kotlin.sequences.Sequence((kotlin.sequences.minOf.T)),%20kotlin.Function1((kotlin.sequences.minOf.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5171cee310607ada547cb3abbac9f3369902a249" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of#kotlin.text%24minOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of#kotlin.text%24minOf(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b49ed92744163e0134f5a22997e4ff3f21ace05b" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.Array((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.Array((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9e966ce954bca5aa6b1bada8a82e7e213dd4409" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Iterable((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Iterable((kotlin.collections.minOfOrNull.T)),%20kotlin.Function1((kotlin.collections.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="365af754bf462620905ac7411eb64305bc2de60a" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Map((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.collections%24minOfOrNull(kotlin.collections.Map((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Function1((kotlin.collections.Map.Entry((kotlin.collections.minOfOrNull.K,%20kotlin.collections.minOfOrNull.V)),%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="27e14e82baa65c311737fe2d312029df3d459372" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.sequences%24minOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.minOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.sequences%24minOfOrNull(kotlin.sequences.Sequence((kotlin.sequences.minOfOrNull.T)),%20kotlin.Function1((kotlin.sequences.minOfOrNull.T,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7bf89b40a8581dc5e193197a15170ae1446fe0c8" translate="yes" xml:space="preserve">
          <source>If any of values produced by &lt;a href=&quot;min-of-or-null#kotlin.text%24minOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;selector&lt;/a&gt; function is &lt;code&gt;NaN&lt;/code&gt;, the returned result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;min-of-or-null#kotlin.text%24minOfOrNull(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.Double)))/selector&quot;&gt;선택자&lt;/a&gt; 함수에 의해 생성 된 값 이 &lt;code&gt;NaN&lt;/code&gt; 이면 반환 된 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79cd9f8134bc36e93ee0b5b0096e84d02bfcaf30" translate="yes" xml:space="preserve">
          <source>If any two characters are equal, the last one gets added to the map.</source>
          <target state="translated">두 문자가 같으면 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c6357923841ba1ceaab6f1a6e9f84f8606ef1c" translate="yes" xml:space="preserve">
          <source>If any two characters are equal, the last one overwrites the former value in the map.</source>
          <target state="translated">두 문자가 같으면 마지막 문자가 맵의 이전 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="2f26706708ad295a2d4220fcac5447f101089a9f" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 리턴 된 동일한 키를 가진 두 문자가있는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5497c944eda344c5ee4cce041575eba3fa47949a" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by#kotlin.text%24associateBy%28kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 리턴 된 동일한 키를 가진 두 문자가있는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7367590726f3c52d91d710c14fe80d9003935516" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 문자가 &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f4bfe6665fd01c25b2660723aa26cfcba03b745a" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 문자가 &lt;a href=&quot;associate-by#kotlin.text%24associateBy(kotlin.CharSequence,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="00f0b6493f2eb1f51451a75f987e59fc400e809f" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 리턴 된 동일한 키를 가진 두 문자가있는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e75792e6117ae62d34357ae99163b28e3ae87d39" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">&lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo%28kotlin.CharSequence%2C+kotlin.text.associateByTo.M%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.Char%2C+kotlin.text.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 리턴 된 동일한 키를 가진 두 문자가있는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6c92aff3ac1f8cdea6651367e77533f526cbf74d" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 문자가 &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d21785fb11026ac029e1cf094d66a51ca1f63f36" translate="yes" xml:space="preserve">
          <source>If any two characters would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 문자가 &lt;a href=&quot;associate-by-to#kotlin.text%24associateByTo(kotlin.CharSequence,%20kotlin.text.associateByTo.M,%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.K)),%20kotlin.Function1((kotlin.Char,%20kotlin.text.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 문자가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4222526855776d5fea3d288e6bf28ef40486cfda" translate="yes" xml:space="preserve">
          <source>If any two elements are equal, the last one gets added to the map.</source>
          <target state="translated">두 요소가 같으면 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="52ae8f33e4fce4d2bff00b2205f42a03dc6b6dc5" translate="yes" xml:space="preserve">
          <source>If any two elements are equal, the last one overwrites the former value in the map.</source>
          <target state="translated">두 요소가 같으면 마지막 요소가 맵의 이전 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="b0b36918b10e47a460b56e912f87552132811b0f" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e4f7e861149810b95e4b66a62c5652d10a7c2b34" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.Array%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="346c57febb657aa512596a792a1d6c53c4a5c173" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3287da59db6cb14700469a6de2aad1297af6a1ee" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy%28kotlin.collections.Iterable%28%28kotlin.collections.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateBy.T%2C+kotlin.collections.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c619123b46fe6a76412a4dab4a539323c02514b" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2babce65c3c6822f47e0eae410ad672aa2260fa3" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.Array((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="00d01f2707a1118799d1a79e26193669d53741bc" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="aec1ca56633469f54f0e46f095a2dbcb21ce1243" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by#kotlin.collections%24associateBy(kotlin.collections.Iterable((kotlin.collections.associateBy.T)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.K)),%20kotlin.Function1((kotlin.collections.associateBy.T,%20kotlin.collections.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="00e86e26effea5e2019fdb8f013dd65c8b5af777" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4e0bb8aab998beb153e618c68711e8ed1f5b4f" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateBy.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateBy.T%2C+kotlin.sequences.associateBy.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cb5d5aa23c9cfd8ca4685ccfe7640b8caaa4a65d" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="76aca80e5881d814494f769e4c11ea9e94782b66" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by#kotlin.sequences%24associateBy(kotlin.sequences.Sequence((kotlin.sequences.associateBy.T)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.K)),%20kotlin.Function1((kotlin.sequences.associateBy.T,%20kotlin.sequences.associateBy.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c3d37381e9e97d902481d1677ee619ffffeec57b" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8a54ba887f98592eb00ea24f27934531d1671f80" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.Array%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ab1f15270d6a111ddaa8968f8a8f226b8f79ddf4" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f68c68a34d4b5715504c8f74b425b62b183fef" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo%28kotlin.collections.Iterable%28%28kotlin.collections.associateByTo.T%29%29%2C+kotlin.collections.associateByTo.M%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.collections.associateByTo.T%2C+kotlin.collections.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2386ebd4075f829eb97b39509e81199143026c" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bda745e6086dfd43e37448ecd0f17912a83dae" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.Array((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b8b9cc802fea2f7d48329645a48c226c92d43891" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="069e0778324065ee5d06336752a03ef494d33fe8" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by-to#kotlin.collections%24associateByTo(kotlin.collections.Iterable((kotlin.collections.associateByTo.T)),%20kotlin.collections.associateByTo.M,%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.K)),%20kotlin.Function1((kotlin.collections.associateByTo.T,%20kotlin.collections.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7fef979d1100c793011b653d677a5f4789c9ce5c" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4cd25d85f79262f8b0d5f4a453055241040829" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소 중 &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.associateByTo.T%29%29%2C+kotlin.sequences.associateByTo.M%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.K%29%29%2C+kotlin.Function1%28%28kotlin.sequences.associateByTo.T%2C+kotlin.sequences.associateByTo.V%29%29%29%2FkeySelector&quot;&gt;keySelector&lt;/a&gt; 에서 리턴 한 동일한 키가있는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="65555fa738d49de3541dbc9b7c338a18ba8e97bd" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="96ed486305c1c1d3ee98ba620ab2f351eaa38c63" translate="yes" xml:space="preserve">
          <source>If any two elements would have the same key returned by &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)),%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; the last one gets added to the map.</source>
          <target state="translated">두 요소가 &lt;a href=&quot;associate-by-to#kotlin.sequences%24associateByTo(kotlin.sequences.Sequence((kotlin.sequences.associateByTo.T)),%20kotlin.sequences.associateByTo.M,%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.K)),%20kotlin.Function1((kotlin.sequences.associateByTo.T,%20kotlin.sequences.associateByTo.V)))/keySelector&quot;&gt;keySelector&lt;/a&gt; 에 의해 반환 된 동일한 키를 갖는 경우 마지막 요소가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="110a007329fb036d6903df69176601b85d25191e" translate="yes" xml:space="preserve">
          <source>If any type from a dependency is used in the public API of the current module, use an &lt;code&gt;api&lt;/code&gt; dependency.</source>
          <target state="translated">현재 모듈의 공개 API에서 종속성의 유형이 사용되는 경우 &lt;code&gt;api&lt;/code&gt; 종속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eca190cfc6a29e9601e43afc0d741e161268772e" translate="yes" xml:space="preserve">
          <source>If any value is &lt;code&gt;NaN&lt;/code&gt;, returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">임의의 값인 경우 &lt;code&gt;NaN&lt;/code&gt; 이 반환 &lt;code&gt;NaN&lt;/code&gt; 이를 .</target>
        </trans-unit>
        <trans-unit id="15a7c9b40dd906acf8613adf81beb5022ec43a6e" translate="yes" xml:space="preserve">
          <source>If assigning a label for a lambda, do not put a space between the label and the opening curly brace:</source>
          <target state="translated">람다에 레이블을 할당하는 경우 레이블과 여는 중괄호 사이에 공백을 두지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a820210cdda09e6106a20c2689836d5711b2d033" translate="yes" xml:space="preserve">
          <source>If atomic reference value is attempted to be set to non-frozen value runtime exception is thrown.</source>
          <target state="translated">원자 참조 값을 고정되지 않은 값으로 설정하려고하면 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6340b7de91bcf9810532c03cd005ea252c107ff" translate="yes" xml:space="preserve">
          <source>If binary was compiled in debug mode.</source>
          <target state="translated">바이너리가 디버그 모드에서 컴파일 된 경우.</target>
        </trans-unit>
        <trans-unit id="2d8589cc3e699ddd4e97fa2ba29db1785486ed75" translate="yes" xml:space="preserve">
          <source>If either value is &lt;code&gt;NaN&lt;/code&gt;, returns &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">하나 값이면 &lt;code&gt;NaN&lt;/code&gt; 이 반환 &lt;code&gt;NaN&lt;/code&gt; 이를 .</target>
        </trans-unit>
        <trans-unit id="a91c0067bcc4bc2dc899d9a2f5799f4eb73c4ee3" translate="yes" xml:space="preserve">
          <source>If either value is &lt;code&gt;NaN&lt;/code&gt;, then the result is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">두 값 중 하나가 &lt;code&gt;NaN&lt;/code&gt; 이면 결과는 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f3e1f12baf2d25f74fb62aefb55ff3c7223ad4c" translate="yes" xml:space="preserve">
          <source>If everything went well, you'll see the result in the &lt;strong&gt;Console&lt;/strong&gt; window.</source>
          <target state="translated">모든 것이 제대로 되었다면 &lt;strong&gt;콘솔&lt;/strong&gt; 창에 결과가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="b99457c74d09db32d851769270d759bf6b0bed1e" translate="yes" xml:space="preserve">
          <source>If everything went well, you'll see the result in the &lt;strong&gt;Run&lt;/strong&gt; tool window.</source>
          <target state="translated">모든 것이 잘 진행되면 &lt;strong&gt;Run&lt;/strong&gt; tool 창에 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f44e8e73afacbc926ee5ae8b0a40c2caa8a431c0" translate="yes" xml:space="preserve">
          <source>If for some reason you want to store a different value in the backing field than the value that is being assigned to the property, you're free to do that, but then you will probably want a getter to give the calling code back what they expect: if you say &lt;code&gt;field = value * 2&lt;/code&gt; in the setter and &lt;code&gt;this.age = age * 2&lt;/code&gt; in the initializer block, you should also have &lt;code&gt;get() = field / 2&lt;/code&gt;.</source>
          <target state="translated">어떤 이유로 든 속성에 할당되는 값과 다른 값을 백킹 필드에 저장하려는 경우 자유롭게 할 수 있지만 getter가 호출 코드에 원하는 값을 돌려주는 것을 원할 것입니다 예상 : setter에서 &lt;code&gt;field = value * 2&lt;/code&gt; 라고 말하면 &lt;code&gt;this.age = age * 2&lt;/code&gt; 초기화 블록에서 this.age = age * 2라고 하면 &lt;code&gt;get() = field / 2&lt;/code&gt; 도 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="4edefded820cd80aae935341ea1dcb1006c317d1" translate="yes" xml:space="preserve">
          <source>If many cases should be handled in the same way, the branch conditions may be combined with a comma:</source>
          <target state="translated">많은 경우를 동일한 방식으로 처리해야하는 경우 분기 조건을 쉼표와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce48d9ac76717b44d2ca9ae647c75c587720e7e" translate="yes" xml:space="preserve">
          <source>If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.</source>
          <target state="translated">여러 쌍의 키가 동일한 경우 결과 맵에는 해당 쌍의 마지막 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ea3319b4e276d7c3ea13314c77acc34629c044" translate="yes" xml:space="preserve">
          <source>If necessary, specify dependencies between modules:</source>
          <target state="translated">필요한 경우 모듈 간의 종속성을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c2f6abafe51dcf05f7cf659caae54fb0bbb624da" translate="yes" xml:space="preserve">
          <source>If no elements match the predicate, both functions throw exceptions. To avoid them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first-or-null&quot;&gt;&lt;code&gt;firstOrNull()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-or-null&quot;&gt;&lt;code&gt;lastOrNull()&lt;/code&gt;&lt;/a&gt; instead: they return &lt;code&gt;null&lt;/code&gt; if no matching elements are found.</source>
          <target state="translated">술어와 일치하는 요소가 없으면 두 함수 모두 예외를 발생시킵니다. 이를 피하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first-or-null&quot;&gt; &lt;code&gt;firstOrNull()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-or-null&quot;&gt; &lt;code&gt;lastOrNull()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오. &lt;code&gt;null&lt;/code&gt; 일치하는 요소가 없으면 널 합니다.</target>
        </trans-unit>
        <trans-unit id="8ce45b90b7ed5e84a37f6079dd50b9e40c3acc1b" translate="yes" xml:space="preserve">
          <source>If not null and else shorthand</source>
          <target state="translated">null이 아니고 속기가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="c3119c5c318b3c1bb9ef4c81af371e666f2e1406" translate="yes" xml:space="preserve">
          <source>If not null shorthand</source>
          <target state="translated">속기가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="f0a31ecbf625068fa2a79a659389ab370dd6f36e" translate="yes" xml:space="preserve">
          <source>If present, specifies a code fragment which should be used as a replacement for the deprecated API usage.</source>
          <target state="translated">있는 경우 더 이상 사용되지 않는 API 사용을 대체 할 코드 조각을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="9664a874b8c0300219353ed51ac375519b83e9fe" translate="yes" xml:space="preserve">
          <source>If rebuilding is performed on App Store side, then &lt;code&gt;.dSYM&lt;/code&gt; of rebuilt &lt;em&gt;dynamic&lt;/em&gt; framework seems discarded and not downloadable from App Store Connect. So in this case it may be required to make the framework static, e.g. with</source>
          <target state="translated">재 구축이 App Store 측에서 수행되는 경우 재 구축 된 &lt;em&gt;동적&lt;/em&gt; 프레임 워크의 &lt;code&gt;.dSYM&lt;/code&gt; 은 폐기 된 것처럼 보이고 App Store Connect에서 다운로드 할 수 없습니다. 따라서이 경우 프레임 워크를 정적으로 만들어야 할 수 있습니다. 예를 들어&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5b87a1191a07e9f1f10d2d86fbeef8f4c6e6b20" translate="yes" xml:space="preserve">
          <source>If some directories on a way to the &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; are missing, then they will be created. If the &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; file already exists, this function will fail unless &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;대상&lt;/a&gt; 으로가는 도중에 일부 디렉토리 가 누락되면 작성됩니다. 경우 &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;대상&lt;/a&gt; 파일이 이미 존재하지 않는 한,이 기능은 실패합니다 &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;덮어 쓰기&lt;/a&gt; 인수로 설정 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f01a59b3c6eaf0fa829c89cc9cc51b75a98bb1df" translate="yes" xml:space="preserve">
          <source>If some directories on a way to the &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; are missing, then they will be created. If the &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; file already exists, this function will fail unless &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;대상&lt;/a&gt; 으로가는 도중에 일부 디렉토리 가 누락 된 경우 생성됩니다. 경우 &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;대상&lt;/a&gt; 파일이 이미 존재하지 않는 한,이 기능은 실패합니다 &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;덮어 쓰기&lt;/a&gt; 인수로 설정되어 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69564edb6644d0771a0b53f00a1f0ee73a8d9530" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, then the elements being aggregated for that key are never considered as &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo%28kotlin.collections.Grouping%28%28kotlin.collections.aggregateTo.T%2C+kotlin.collections.aggregateTo.K%29%29%2C+kotlin.collections.aggregateTo.M%2C+kotlin.Function4%28%28kotlin.collections.aggregateTo.K%2C+kotlin.collections.aggregateTo.R%2C+kotlin.collections.aggregateTo.T%2C+kotlin.Boolean%2C+kotlin.collections.aggregateTo.R%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도 이미 몇 가지 키에 해당하는 값을 가지고, 다음 요소로 간주되지 않습니다 그 키에 대한 집계되고 &lt;code&gt;first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b97d2cb76e358bd05b416fac37404ef523495356" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo(kotlin.collections.Grouping((kotlin.collections.aggregateTo.T,%20kotlin.collections.aggregateTo.K)),%20kotlin.collections.aggregateTo.M,%20kotlin.Function4((kotlin.collections.aggregateTo.K,%20kotlin.collections.aggregateTo.R?,%20kotlin.collections.aggregateTo.T,%20kotlin.Boolean,%20kotlin.collections.aggregateTo.R)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, then the elements being aggregated for that key are never considered as &lt;code&gt;first&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;aggregate-to#kotlin.collections%24aggregateTo(kotlin.collections.Grouping((kotlin.collections.aggregateTo.T,%20kotlin.collections.aggregateTo.K)),%20kotlin.collections.aggregateTo.M,%20kotlin.Function4((kotlin.collections.aggregateTo.K,%20kotlin.collections.aggregateTo.R?,%20kotlin.collections.aggregateTo.T,%20kotlin.Boolean,%20kotlin.collections.aggregateTo.R)))/destination&quot;&gt;대상&lt;/a&gt; 지도 이미 몇 가지 키에 해당하는 값을 가지고, 다음 요소로 간주되지 않습니다 그 키에 대한 집계되고 &lt;code&gt;first&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b6595d56ce18db4a67782306e25689cafd4cbf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt; already exists, it will be deleted before copying when the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; parameter permits so.</source>
          <target state="translated">경우 &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;대상이&lt;/a&gt; 이미 존재,이 때 복사하기 전에 삭제됩니다 &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Foverwrite&quot;&gt;덮어 쓰기&lt;/a&gt; 매개 변수가 너무 허용합니다.</target>
        </trans-unit>
        <trans-unit id="72642c2dc2e392596a7e9e14969c3eba6a9b65c7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt; already exists, it will be deleted before copying when the &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/overwrite&quot;&gt;overwrite&lt;/a&gt; parameter permits so.</source>
          <target state="translated">는 IF &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;대상이&lt;/a&gt; 이미 존재,이 경우 복사하기 전에 삭제됩니다 &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/overwrite&quot;&gt;덮어 쓰기&lt;/a&gt; 매개 변수가 너무 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9f9b5e8d1feceda52168174d03a6fd1853068274" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the counter for that group.</source>
          <target state="translated">&lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo%28kotlin.collections.Grouping%28%28kotlin.collections.eachCountTo.T%2C+kotlin.collections.eachCountTo.K%29%29%2C+kotlin.collections.eachCountTo.M%29%2Fdestination&quot;&gt;목적지 인&lt;/a&gt; 경우 지도 이미 일부 그룹의 키에 해당하는 값을 가지며, 그 값은 그 그룹의 카운터의 초기 값으로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="294cca51ae0758313aa7d288e6e1a35754d699c1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo(kotlin.collections.Grouping((kotlin.collections.eachCountTo.T,%20kotlin.collections.eachCountTo.K)),%20kotlin.collections.eachCountTo.M)/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the counter for that group.</source>
          <target state="translated">경우] &lt;a href=&quot;each-count-to#kotlin.collections%24eachCountTo(kotlin.collections.Grouping((kotlin.collections.eachCountTo.T,%20kotlin.collections.eachCountTo.K)),%20kotlin.collections.eachCountTo.M)/destination&quot;&gt;대상&lt;/a&gt; 지도 이미 일부 그룹의 키에 해당하는 값을 가지며, 그 값은 그 그룹의 카운터의 초기 값으로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="8e5524567ae268875bd1ad8d3089898977c657ab" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, that value is used as an initial value of the accumulator for that group and the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2FinitialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt; function is not called for that group.</source>
          <target state="translated">경우] &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도 이미 일부 키에 대응하는 값을 가지며, 그 값은 그 그룹에 대한 상기 어큐뮬레이터의 초기 값으로서 사용된다 &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.Function2%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.R%29%29%2C+kotlin.Function3%28%28kotlin.collections.foldTo.K%2C+kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2FinitialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt; 해당 그룹 호출되지 함수.</target>
        </trans-unit>
        <trans-unit id="c2e00bc5fd9ad4886018856e815daa5b47301e4d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group.</source>
          <target state="translated">&lt;a href=&quot;fold-to#kotlin.collections%24foldTo%28kotlin.collections.Grouping%28%28kotlin.collections.foldTo.T%2C+kotlin.collections.foldTo.K%29%29%2C+kotlin.collections.foldTo.M%2C+kotlin.collections.foldTo.R%2C+kotlin.Function2%28%28kotlin.collections.foldTo.R%2C+kotlin.collections.foldTo.T%2C+%29%29%29%2Fdestination&quot;&gt;목적지 인&lt;/a&gt; 경우 지도 이미 일부 그룹의 키에 해당하는 값을 가지며, 그 값은 그 그룹에 대한 어큐뮬레이터의 초기 값으로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="92a0a868acf0fdba94e948380117659b082b2d8a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to some key, that value is used as an initial value of the accumulator for that group and the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/initialValueSelector&quot;&gt;initialValueSelector&lt;/a&gt; function is not called for that group.</source>
          <target state="translated">경우] &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;대상&lt;/a&gt; 지도 이미 일부 키에 대응하는 값을 가지며, 그 값은 그 그룹에 대한 상기 어큐뮬레이터의 초기 값으로서 사용된다 &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.Function2((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.R)),%20kotlin.Function3((kotlin.collections.foldTo.K,%20kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/initialValueSelector&quot;&gt;initialValueSelector의&lt;/a&gt; 해당 그룹 호출되지 함수.</target>
        </trans-unit>
        <trans-unit id="61fb3080e7ad416c3c4c97afdd9493927e20f8d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.collections.foldTo.R,%20kotlin.Function2((kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group.</source>
          <target state="translated">경우] &lt;a href=&quot;fold-to#kotlin.collections%24foldTo(kotlin.collections.Grouping((kotlin.collections.foldTo.T,%20kotlin.collections.foldTo.K)),%20kotlin.collections.foldTo.M,%20kotlin.collections.foldTo.R,%20kotlin.Function2((kotlin.collections.foldTo.R,%20kotlin.collections.foldTo.T,%20)))/destination&quot;&gt;대상&lt;/a&gt; 지도 이미 일부 그룹의 키에 해당하는 값을 가지며, 그 값은 그 그룹에 대한 어큐뮬레이터의 초기 값으로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="a5e416dc2da9d5eff4e49855727e16479b47d6e8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="a66362906cf4418648a9a5554323ed383b8c8eea" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.Array%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="659f4cba1d89d61c23bd0ba52a22f40e8ccd83db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="8871905aa80191cdc602c425bf96156ef25f5e60" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.Array%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e297805d5d494bda3a0385ad18c3569e75f14c7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="4c007633067610794e36b0b3cc51865ca8352f19" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.BooleanArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6039a3964776e721bd806c0a81307a0abf13a4c0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="fc5816f698f9795e7dd6086d1ef8ccfaae63b27a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.BooleanArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7d2330d71db6f764d35eea14e9ab73aac72b9c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="8b70a8c2ba34131364e28b2512d35483af00f19a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44768c507a4b76808d52b98c0254864df2b87ee5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="f43d6c6804b42a2af7611d19f88a2487e6000d7d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.ByteArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c1eabbbf7b712271d653fdcbd433c34590b4d2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="87b690a93b6a351a33df7161fb636a57f37c003d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.CharArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="241fbd990a613b4ddb1929a451c61d8c2e0d5edd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="b8b15067f57d32d666005f69272a8002614e5c40" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.CharArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9330d9da57aef0aed8c13aee6dc337fbeb829bff" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="6c4f88ba4389bfc9a900b68407e80b12b5ae9b02" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.DoubleArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10f0cc22e805af048a8e1811a9b67195fd374456" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="4dfbdf3e234c922a5068cafdfeeced9cce315c84" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.DoubleArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4839668bfa4ee00994900630081eeb5714f95752" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="0e047d5c3d28e4eb74b19b8706f2359f4a496d1c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.FloatArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36ed57a482212b43296278a3f740dad9f4d581db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="00d6097085f2efeb6f60d64620ecac34ef7d8a30" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.FloatArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33490febae2a178f4655be7a154612da34a0c4a5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="9d2ed5d24fc59700154e317864d8c0e6739505a7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.IntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c696e216e6286ada0cb5195502952a789b32f98a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="292f4907701770c13a3d993a8fbab1351a08f93b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.IntArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f087deed2fca1a1e09b14c363914201ae8d71a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="256c8bdcf7db878fc6b6b13f96f3eeecab8e97a4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.LongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a243908860038c9462a433c221a21a1025d24e0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="78cc83cee81cdb56f83d5139ff270e833535dfdf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.LongArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="999680793def1bf95ce65d25a967348c34b8ed9d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="343f876e9f1eb0b0c40cd9f7901fcfe6d86bd975" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f013fc6e90baae75eb837993cde762ea2af5800" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="58754cd9e0e7d7a8702d78a5c9ba2d2f0156bea9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.ShortArray%24get(kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e96f00fc82613fc72e45bd901e49fdbd42b006e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 문자열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 의 동작은 정의되어 있지 않기 때문에 어디 코 틀린 / JS를 제외하고.</target>
        </trans-unit>
        <trans-unit id="121146c1773ced51b85c510f0c9a740fcee4401a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.String%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 문자열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="7f767176ab77d40deae0e60f62a498403a05d542" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;인덱스가&lt;/a&gt; 이 문자열의 범위 외에, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 의 동작은 정의되어 있지 않기 때문에 어디 코 틀린 / JS를 제외하고.</target>
        </trans-unit>
        <trans-unit id="46f07635940947a7d146432e3e2c1f7467a6f5db" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this string, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;get#kotlin.String%24get(kotlin.Int)/index&quot;&gt;인덱스가&lt;/a&gt; 이 문자열의 범위 외에, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b4a8848b9c8e64b348afb59840b8348887cc19" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.UByteArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="1e7b8e174e484d14d4beffbac84f58ae1fb244d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UByteArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.UByteArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="c42b44be3aa2af1c6b520077f8536d89266d3575" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UIntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.UIntArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="2e0b0214b72fe8c7cf14b755a41ea870bd89d740" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UIntArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.UIntArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="9aa63b031868d224c7a7f44af55292bbb50b21f2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ULongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.ULongArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="f9de9e44f5252019b83cabd1b363c2f8b0aa829b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.ULongArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.ULongArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="5f0b48aa5778c165df7d576ad84fb99a045c6acc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">&lt;a href=&quot;get#kotlin.UShortArray%24get%28kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이 발생합니다.&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="75d4175ea3cfca94ca7e47438e4bdab18fab5198" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;get#kotlin.UShortArray%24get(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;get#kotlin.UShortArray%24get(kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="3832840323d1968de06c86d1668de66bc5395923" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;function&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; the directory is not entered and neither it nor its files are visited.</source>
          <target state="translated">&lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter%28kotlin.Function1%28%28java.io.File%2C+kotlin.Boolean%29%29%29%2Ffunction&quot;&gt;함수&lt;/a&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 디렉토리가 입력되지 않고이나 그 파일도 방문한다.</target>
        </trans-unit>
        <trans-unit id="76181a81bd674f99c87a97a3e1468fb754d1fc87" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter(kotlin.Function1((java.io.File,%20kotlin.Boolean)))/function&quot;&gt;function&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; the directory is not entered and neither it nor its files are visited.</source>
          <target state="translated">은 IF &lt;a href=&quot;on-enter#kotlin.io.FileTreeWalk%24onEnter(kotlin.Function1((java.io.File,%20kotlin.Boolean)))/function&quot;&gt;함수가&lt;/a&gt; 반환 &lt;code&gt;false&lt;/code&gt; 디렉토리가 입력되지 않고이나 그 파일도 방문한다.</target>
        </trans-unit>
        <trans-unit id="0a2285dd49856fe4825e17e694cf3fa18696091c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group and the first element of that group is also subjected to the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Foperation&quot;&gt;operation&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 지도 이미 일부 그룹의 키에 해당하는 값을 가지며, 그 값도 실시되는 그룹과 해당 그룹의 첫 번째 요소의 어큐뮬레이터의 초기 값으로 사용되는 &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo%28kotlin.collections.Grouping%28%28kotlin.collections.reduceTo.T%2C+kotlin.collections.reduceTo.K%29%29%2C+kotlin.collections.reduceTo.M%2C+kotlin.Function3%28%28kotlin.collections.reduceTo.K%2C+kotlin.collections.reduceTo.S%2C+kotlin.collections.reduceTo.T%2C+%29%29%29%2Foperation&quot;&gt;조작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aaabd446cf116a2750ab94bb32f8d62327631fb7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/destination&quot;&gt;destination&lt;/a&gt; map already has a value corresponding to the key of some group, that value is used as an initial value of the accumulator for that group and the first element of that group is also subjected to the &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/operation&quot;&gt;operation&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/destination&quot;&gt;대상&lt;/a&gt; 지도 이미 일부 그룹의 키에 해당하는 값을 가지며, 그 값도 실시되는 그룹과 해당 그룹의 첫 번째 요소의 어큐뮬레이터의 초기 값으로 사용되는 &lt;a href=&quot;reduce-to#kotlin.collections%24reduceTo(kotlin.collections.Grouping((kotlin.collections.reduceTo.T,%20kotlin.collections.reduceTo.K)),%20kotlin.collections.reduceTo.M,%20kotlin.Function3((kotlin.collections.reduceTo.K,%20kotlin.collections.reduceTo.S,%20kotlin.collections.reduceTo.T,%20)))/operation&quot;&gt;조작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c1cf29eaa37e1a848f362e9496c70a7361cc3c0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="b4795422de28a107d2b93ad77a19fea520c69382" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.Array%24set%28kotlin.Int%2C+kotlin.Array.T%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="3500c6a3ccdfdd558e70d61568491d24a57dba35" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="07848e5d2cb6b751154cf49081d01d01ad9a0467" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.Array%24set(kotlin.Int,%20kotlin.Array.T)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad0c6c091ccda18739aa6f3577cd89dd09841078" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="835319d043a0f65a5eee60807011570250691591" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.BooleanArray%24set%28kotlin.Int%2C+kotlin.Boolean%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="7b50c553e7ac61ad18a55fb2deb2fd76235f23fd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="07ab11928fd8cb50782aa576d57f34d36dac144c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.BooleanArray%24set(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="527f471fdf4e268be1d4b9f1ebfd516bc71f229b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="42963185cae43f2e758e143f41ae72d95b5c4100" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.ByteArray%24set%28kotlin.Int%2C+kotlin.Byte%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="cdf2a2f9fb25aa14921ec99b9c2441f2f3aa607b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="e63aef66dc4f176a6824753a6cdeb0ca0faba262" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.ByteArray%24set(kotlin.Int,%20kotlin.Byte)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8618ed56cd06c8c291f923aab1b1a054f5002b8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="16b81d70965f40eb90b072a5e9edb009e7b41db0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.CharArray%24set%28kotlin.Int%2C+kotlin.Char%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="ff5ba893f49fd7a741281bd097b53c6298362fcd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="3e60264d0d2c56881b96bac79b4666814c5f9bc5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.CharArray%24set(kotlin.Int,%20kotlin.Char)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="684c4e170a424d705f9e13c5cda4d575a1e09f13" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="f733c2a99de30ff7689107b0fce91469fa4b4623" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.DoubleArray%24set%28kotlin.Int%2C+kotlin.Double%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="b3adc428d0247ef8e64e3b606fc8678debad6823" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="1f1fe770f48c4c991ab6ba93f5448bca6a109d8e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.DoubleArray%24set(kotlin.Int,%20kotlin.Double)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09664e73fde927f6d22f3ea9f4070e59236e924f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="dde11a436e59034272f619d39049718d3c4685e2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.FloatArray%24set%28kotlin.Int%2C+kotlin.Float%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="ab4dcb980391ca205a536de0ce8e05a3c6d15d9b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="d5712029ee942822232df2cd5dbe660126d19048" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.FloatArray%24set(kotlin.Int,%20kotlin.Float)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1000d31cc93809459dc4dbcc455954d9ddc757d2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="ab2984691cfff299ebe407e2aee780db1db59dff" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.IntArray%24set%28kotlin.Int%2C+kotlin.Int%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="a3d5f8f3a49afff92d2de250d1c268d9641231e3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="b0d669004672e2a64c3a7a12296c03199c121a94" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.IntArray%24set(kotlin.Int,%20kotlin.Int)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f173e322ccd56addf649214d8ae7803d5dfa5b94" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="f409e29966bb054dfd47826d8dd2e870d206d24a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.LongArray%24set%28kotlin.Int%2C+kotlin.Long%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="1fba4254a8fc486709d4c8d0c1ff6c237b4ac68e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="64c2d595bfbfd6b07a001299c27dab6257d421de" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.LongArray%24set(kotlin.Int,%20kotlin.Long)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8044147072cea61ae2e90888654fdcbbe920ee" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="382bd7e3336be8af1102464e37fa8b63b568ca7c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;set#kotlin.ShortArray%24set%28kotlin.Int%2C+kotlin.Short%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 가이 배열의 범위를 벗어나 면 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="a1175979092412882336d28661ca4a85fdaf319b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="e23f36b4d54bf9c3c45bcbc7bf634715deb9f3f1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set#kotlin.ShortArray%24set(kotlin.Int,%20kotlin.Short)/index&quot;&gt;인덱스는&lt;/a&gt; 이 배열의 범위를 벗어난, 발생 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb1e18b251850707f84797db758d97e17b714305" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.UByteArray%24set%28kotlin.Int%2C+kotlin.UByte%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="adbaf189ba58957d0a7656eeb77ad6d9cf651830" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UByteArray%24set(kotlin.Int,%20kotlin.UByte)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.UByteArray%24set(kotlin.Int,%20kotlin.UByte)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="2b01aefe6d05f741cac19ebae49684d8f27b7c15" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.UIntArray%24set%28kotlin.Int%2C+kotlin.UInt%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="2f924e8f004a96424c06cbbda49ed1c933ecc51d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UIntArray%24set(kotlin.Int,%20kotlin.UInt)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.UIntArray%24set(kotlin.Int,%20kotlin.UInt)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="e0298f72be4df89660cb3cbfa8ca0b544a87436d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.ULongArray%24set%28kotlin.Int%2C+kotlin.ULong%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="e62a1584079789f235cbabd8612798e3939dc325" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.ULongArray%24set(kotlin.Int,%20kotlin.ULong)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.ULongArray%24set(kotlin.Int,%20kotlin.ULong)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="c204bddc743f17a6a83f3273732caa9abcce98a1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.UShortArray%24set%28kotlin.Int%2C+kotlin.UShort%29%2Findex&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="0fe9e7ed96bb0f5a9326e0294c5697a26a4745c9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set#kotlin.UShortArray%24set(kotlin.Int,%20kotlin.UShort)/index&quot;&gt;index&lt;/a&gt; is out of bounds of this array, throws an &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">상기 중간 &lt;a href=&quot;set#kotlin.UShortArray%24set(kotlin.Int,%20kotlin.UShort)/index&quot;&gt;색인&lt;/a&gt; 이 배열의 범위 외에, 슬로우 &lt;a href=&quot;../-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;에서 IndexOutOfBoundsException&lt;/a&gt; 동작은 불특정 여기서 코 틀린 / JS 제외.</target>
        </trans-unit>
        <trans-unit id="fd938f2e10e2d0fb410305f424f6360cc9c56338" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt; is less than the current length, it is changed to the specified &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;. Otherwise, null characters '\u0000' are appended to this string builder until its length is less than the &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;는 newLength가&lt;/a&gt; 현재 길이보다 작은, 그것은 지정된로 변경 &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;는 newLength&lt;/a&gt; . 그렇지 않으면 길이가 &lt;a href=&quot;set-length#kotlin.text.StringBuilder%24setLength(kotlin.Int)/newLength&quot;&gt;newLength&lt;/a&gt; 보다 적을 때까지 널 문자 '\ u0000'이이 문자열 작성기에 추가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd0d3eb59459a0737a168b08758efee370cf55de" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall be invoked at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">는 IF &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록이&lt;/a&gt; 특별한 반환 &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d#kotlin.coroutines.experimental.intrinsics%24COROUTINE_SUSPENDED&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; 값을, 기능을 중지 그것은 수단은 실행을 중단했고, 즉시 결과를 반환하지 않습니다. 이 경우, &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation/index&quot;&gt;Continuation&lt;/a&gt; 이 &lt;a href=&quot;suspend-coroutine-or-return#kotlin.coroutines.experimental.intrinsics%24suspendCoroutineOrReturn%28kotlin.Function1%28%28kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.suspendCoroutineOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록에&lt;/a&gt; 제공되었습니다. 은 나중에 결과가 계산을 재개 할 수있게 될 때 언젠가 호출되어야한다.</target>
        </trans-unit>
        <trans-unit id="05d3b99631a5ed6456bedf676a61766834d5fac4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; shall be resumed by invoking &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">는 IF &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록이&lt;/a&gt; 특별한 반환 &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; 값을, 기능을 중지 그것은 수단은 실행을 중단했고, 즉시 결과를 반환하지 않습니다. 이 경우, &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;연속&lt;/a&gt; 받는 제공된 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn%28kotlin.Function1%28%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T%29%29%2C+kotlin.Any%29%29%29%2Fblock&quot;&gt;블록&lt;/a&gt; 호출 재개한다 &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith을&lt;/a&gt; 결과의 계산을 재개 할 수있게되면 미래의 어떤 순간.</target>
        </trans-unit>
        <trans-unit id="ef7f7d6c898b2802fb6d15ca777d3c99d22a1440" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;block&lt;/a&gt; returns the special &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; value, it means that suspend function did suspend the execution and will not return any result immediately. In this case, the &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; provided to the &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;block&lt;/a&gt; shall be resumed by invoking &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; at some moment in the future when the result becomes available to resume the computation.</source>
          <target state="translated">는 IF &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;블록이&lt;/a&gt; 특별한 반환 &lt;a href=&quot;-c-o-r-o-u-t-i-n-e_-s-u-s-p-e-n-d-e-d&quot;&gt;COROUTINE_SUSPENDED&lt;/a&gt; 값을, 기능을 중지 그것은 수단은 실행을 중단했고, 즉시 결과를 반환하지 않습니다. 이 경우, &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;연속&lt;/a&gt; 받는 제공된 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return#kotlin.coroutines.intrinsics%24suspendCoroutineUninterceptedOrReturn(kotlin.Function1((kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.suspendCoroutineUninterceptedOrReturn.T)),%20kotlin.Any?)))/block&quot;&gt;블록&lt;/a&gt; 호출 재개한다 &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith을&lt;/a&gt; 결과의 계산을 재개 할 수있게되면 미래의 어떤 순간.</target>
        </trans-unit>
        <trans-unit id="8c3e8a5ebbcd7a703e634eecad27bcd0557ad20c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;until#kotlin.ranges%24until%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;to&lt;/a&gt; value is less than or equal to &lt;code&gt;this&lt;/code&gt; value, then the returned range is empty.</source>
          <target state="translated">경우] &lt;a href=&quot;until#kotlin.ranges%24until%28kotlin.Int%2C+kotlin.Byte%29%2Fto&quot;&gt;에&lt;/a&gt; 값보다 작거나 같은 &lt;code&gt;this&lt;/code&gt; 값을 다음 반환 범위는 비어있다.</target>
        </trans-unit>
        <trans-unit id="fc10efd6ed805281fe18f00e48398e62a4bc01b4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;until#kotlin.ranges%24until(kotlin.Int,%20kotlin.Byte)/to&quot;&gt;to&lt;/a&gt; value is less than or equal to &lt;code&gt;this&lt;/code&gt; value, then the returned range is empty.</source>
          <target state="translated">경우] &lt;a href=&quot;until#kotlin.ranges%24until(kotlin.Int,%20kotlin.Byte)/to&quot;&gt;에&lt;/a&gt; 값보다 작거나 같은 &lt;code&gt;this&lt;/code&gt; 값을 다음 반환 범위는 비어있다.</target>
        </trans-unit>
        <trans-unit id="5345ec6188f99db607179fac5ae96cec3bb7c52f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;@Nonnull(when = ...)&lt;/code&gt; value is &lt;code&gt;When.ALWAYS&lt;/code&gt;, the annotated type is treated as non-null; &lt;code&gt;When.MAYBE&lt;/code&gt; and &lt;code&gt;When.NEVER&lt;/code&gt; denote a nullable type; and &lt;code&gt;When.UNKNOWN&lt;/code&gt; forces the type to be &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform one&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;code&gt;@Nonnull(when = ...)&lt;/code&gt; 값이 &lt;code&gt;When.ALWAYS&lt;/code&gt; , 주석 타입은 비 - 널로서 취급되고 &lt;code&gt;When.MAYBE&lt;/code&gt; 및 &lt;code&gt;When.NEVER&lt;/code&gt; 는 널 입력 가능 유형을 나타냅니다. 그리고 &lt;code&gt;When.UNKNOWN&lt;/code&gt; 은 타입을 &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;플랫폼 1로&lt;/a&gt; 만듭니다.</target>
        </trans-unit>
        <trans-unit id="45b12756de222f5e29c382cd94f13f3b7d5d58e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(java.lang.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">지정된 &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(java.lang.StringBuilder,%20kotlin.Int)/index&quot;&gt;인덱스&lt;/a&gt; 의 &lt;code&gt;Char&lt;/code&gt; 가 보조 코드 포인트의 일부인 경우이 메서드는 전체 보조 문자를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="688090999735051d0000ff7dba5c2c4568402fb2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">지정된 &lt;a href=&quot;delete-at#kotlin.text%24deleteAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;인덱스&lt;/a&gt; 의 &lt;code&gt;Char&lt;/code&gt; 가 보조 코드 포인트의 일부인 경우이 메서드는 전체 보조 문자를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19c4aa235fc87bd1ef34ff709c6ee8e008a72969" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-at#kotlin.text.StringBuilder%24deleteAt(kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">지정된 &lt;a href=&quot;delete-at#kotlin.text.StringBuilder%24deleteAt(kotlin.Int)/index&quot;&gt;인덱스&lt;/a&gt; 의 &lt;code&gt;Char&lt;/code&gt; 가 보조 코드 포인트의 일부인 경우이 메서드는 전체 보조 문자를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64b90c92ca7b8330c526871505c4db9b681716bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Char&lt;/code&gt; at the specified &lt;a href=&quot;delete-char-at#kotlin.text%24deleteCharAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; is part of a supplementary code point, this method does not remove the entire supplementary character.</source>
          <target state="translated">지정된 &lt;a href=&quot;delete-char-at#kotlin.text%24deleteCharAt(kotlin.text.StringBuilder,%20kotlin.Int)/index&quot;&gt;인덱스&lt;/a&gt; 의 &lt;code&gt;Char&lt;/code&gt; 가 보조 코드 포인트의 일부인 경우이 메서드는 전체 보조 문자를 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ab41cb28f87df4bf85af33067d923e82cb67834" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; argument in Java has an array type, it becomes a &lt;code&gt;vararg&lt;/code&gt; parameter in Kotlin:</source>
          <target state="translated">Java 의 &lt;code&gt;value&lt;/code&gt; 인수에 배열 유형이 있으면 Kotlin에서 &lt;code&gt;vararg&lt;/code&gt; 매개 변수가됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ef38c717fdd1e4d50094959ff3c7a5a376b3eb" translate="yes" xml:space="preserve">
          <source>If the Java class has multiple methods taking functional interfaces, you can choose the one you need to call by using an adapter function that converts a lambda to a specific SAM type. Those adapter functions are also generated by the compiler when needed:</source>
          <target state="translated">Java 클래스에 기능 인터페이스를 사용하는 여러 메소드가있는 경우 람다를 특정 SAM 유형으로 변환하는 어댑터 함수를 사용하여 호출해야하는 메소드를 선택할 수 있습니다. 이러한 어댑터 기능은 필요할 때 컴파일러에서 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ced4c8b1c0812e2f37b8f765b9bf671545680b65" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">배열에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+java.util.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt; 와 동일한 요소가 여러 개 포함되어 있으면 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6466c3976ded360fb3b54d0482a0da85fa3ffd46" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">배열에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.Array%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt; 와 동일한 요소가 여러 개 포함되어 있으면 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5cf73d9390119493522582bc92cc73759f93e8a" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20java.util.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">배열에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20java.util.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt; 와 동일한 요소가 여러 개 포함되어있는 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2bd4827f31d12e8989eabcece2a2e85f2897dbd2" translate="yes" xml:space="preserve">
          <source>If the array contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">배열에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.Array((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt; 와 동일한 요소가 여러 개 포함되어있는 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="857a406fa492096552a539094a05e74a8ae0e4fe" translate="yes" xml:space="preserve">
          <source>If the backing storage of this string builder is larger than necessary to hold its current contents, then it may be resized to become more space efficient. Calling this method may, but is not required to, affect the value of the &lt;a href=&quot;capacity#kotlin.text.StringBuilder%24capacity()&quot;&gt;capacity&lt;/a&gt; property.</source>
          <target state="translated">이 문자열 작성기의 백업 저장소가 현재 콘텐츠를 유지하는 데 필요한 것보다 큰 경우 공간 효율성을 높이기 위해 크기를 조정할 수 있습니다. 이 메서드를 호출하면 &lt;a href=&quot;capacity#kotlin.text.StringBuilder%24capacity()&quot;&gt;용량&lt;/a&gt; 속성 값에 영향을 줄 수 있지만 반드시 필요한 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="fa8581b13c8fdd01f13e98c50d4e7d29550396fc" translate="yes" xml:space="preserve">
          <source>If the behavior for a certain platform needs to be modified, you can use a format like &lt;code&gt;compilerOpts.osx&lt;/code&gt; or &lt;code&gt;compilerOpts.linux&lt;/code&gt; to provide platform-specific values to the options.</source>
          <target state="translated">특정 플랫폼의 동작을 수정해야하는 경우 &lt;code&gt;compilerOpts.osx&lt;/code&gt; 또는 &lt;code&gt;compilerOpts.linux&lt;/code&gt; 와 같은 형식을 사용 하여 옵션에 플랫폼 별 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996cca3563bf26540aaf4288dff8af8f84e60dcc" translate="yes" xml:space="preserve">
          <source>If the callback doesn't run in the main thread, it is mandatory to init the &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime by calling &lt;code&gt;kotlin.native.initRuntimeIfNeeded()&lt;/code&gt;.</source>
          <target state="translated">콜백이 메인 스레드에서 실행되지 않으면 &lt;code&gt;kotlin.native.initRuntimeIfNeeded()&lt;/code&gt; 를 호출 하여 &lt;em&gt;Kotlin / Native&lt;/em&gt; 런타임 을 초기화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="71e01fbddfaf8e865fcef95f03a855f99eabb469" translate="yes" xml:space="preserve">
          <source>If the class (or any of its superclasses) is annotated with &lt;code&gt;com.my.Annotation&lt;/code&gt;, the class itself and all its members will become open.</source>
          <target state="translated">클래스 (또는 그 수퍼 클래스)에 &lt;code&gt;com.my.Annotation&lt;/code&gt; 으로 주석을 달면 클래스 자체와 모든 멤버가 열립니다.</target>
        </trans-unit>
        <trans-unit id="1d6fb5abda1df282cf7b793af04d339e6c8b07ca" translate="yes" xml:space="preserve">
          <source>If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class is done using the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">클래스에 기본 생성자가 있으면 각 보조 생성자는 다른 보조 생성자를 통해 직접 또는 간접적으로 기본 생성자에게 위임해야합니다. 같은 클래스의 다른 생성자에 대한 위임은 &lt;em&gt;this&lt;/em&gt; 키워드를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1becbc997c1b9834ca68a14f7454678bc5ce31a3" translate="yes" xml:space="preserve">
          <source>If the classes represent &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;, then &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt; objects of their element types are equal.</source>
          <target state="translated">수업이 나타내는 경우 &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;배열을&lt;/a&gt; , 다음 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;클래스는&lt;/a&gt; 자신의 요소 유형이 동일의 객체.</target>
        </trans-unit>
        <trans-unit id="77b2beaaa166a8ca8a0f2117bf08b50328d632d2" translate="yes" xml:space="preserve">
          <source>If the classes represent &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;Array&lt;/a&gt;, then &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;Class&lt;/a&gt; objects of their element types are equal.</source>
          <target state="translated">수업이 나타내는 경우 &lt;a href=&quot;../../kotlin/-array/index#kotlin.Array&quot;&gt;배열을&lt;/a&gt; , 다음 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html&quot;&gt;클래스는&lt;/a&gt; 자신의 요소 유형이 동일의 객체.</target>
        </trans-unit>
        <trans-unit id="944291945314272d9d50e4311dd336ba21bad448" translate="yes" xml:space="preserve">
          <source>If the classes represent Array, then Class objects of their element types are equal.</source>
          <target state="translated">클래스가 Array를 나타내는 경우, 해당 요소 유형의 Class 오브젝트는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="79031f7fd8baac9875032a654d3a81aa8ce76daf" translate="yes" xml:space="preserve">
          <source>If the code block contains a single function with &lt;code&gt;it&lt;/code&gt; as an argument, you can use the method reference (&lt;code&gt;::&lt;/code&gt;) instead of the lambda:</source>
          <target state="translated">코드 블록은 단일 기능이 포함되어있는 경우 &lt;code&gt;it&lt;/code&gt; 인수로를, 당신은 방법 참조 (사용할 수 있습니다 &lt;code&gt;::&lt;/code&gt; 대신 람다의) :</target>
        </trans-unit>
        <trans-unit id="d97d691977b15199380af830d5ad236bbf75524c" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 클 수 있는 경우 음이 아닌 값 &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit을&lt;/a&gt; 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 &lt;a href=&quot;join-to#kotlin.collections%24joinTo%28kotlin.Array%28%28kotlin.collections.joinTo.T%29%29%2C+kotlin.collections.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e8468dd252fe0ffd6b4a3af71f464889fa3a1a39" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 거대 할 수 있는 경우 &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit의&lt;/a&gt; 음이 아닌 값을 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 그 뒤에 &lt;a href=&quot;join-to#kotlin.collections%24joinTo(kotlin.Array((kotlin.collections.joinTo.T)),%20kotlin.collections.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8f5b1dc0c41182773d56507020b349e5e7ed653a" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 클 수 있는 경우 음이 아닌 값 &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit을&lt;/a&gt; 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 &lt;a href=&quot;join-to#kotlin.sequences%24joinTo%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinTo.T%29%29%2C+kotlin.sequences.joinTo.A%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinTo.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="08d4d8884be2c52559e13b59134a10b3b85cf098" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 거대 할 수 있는 경우 &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit의&lt;/a&gt; 음이 아닌 값을 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/limit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 그 뒤에 &lt;a href=&quot;join-to#kotlin.sequences%24joinTo(kotlin.sequences.Sequence((kotlin.sequences.joinTo.T)),%20kotlin.sequences.joinTo.A,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinTo.T,%20kotlin.CharSequence)))/truncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb18d53f708d0c262ed97ec04392d87077ad40e" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 클 수 있는 경우 음이 아닌 값 &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit을&lt;/a&gt; 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString%28kotlin.Array%28%28kotlin.collections.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.collections.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1d93c35f86678bc28fc865390dd8cf2eb747038c" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 거대 할 수 있는 경우 &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit의&lt;/a&gt; 음이 아닌 값을 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 그 뒤에 &lt;a href=&quot;join-to-string#kotlin.collections%24joinToString(kotlin.Array((kotlin.collections.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.collections.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bbf01993f693a43b2b5c8b4e4105a26cb7dc269a" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 클 수 있는 경우 음이 아닌 값 &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;limit을&lt;/a&gt; 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Flimit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString%28kotlin.sequences.Sequence%28%28kotlin.sequences.joinToString.T%29%29%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.Int%2C+kotlin.CharSequence%2C+kotlin.Function1%28%28kotlin.sequences.joinToString.T%2C+kotlin.CharSequence%29%29%29%2Ftruncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9854e1b0b2258416f93294b380cf1572214c823f" translate="yes" xml:space="preserve">
          <source>If the collection could be huge, you can specify a non-negative value of &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt;, in which case only the first &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit&lt;/a&gt; elements will be appended, followed by the &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;truncated&lt;/a&gt; string (which defaults to &quot;...&quot;).</source>
          <target state="translated">컬렉션이 거대 할 수 있는 경우 &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;limit의&lt;/a&gt; 음이 아닌 값을 지정할 수 있습니다 .이 경우 첫 번째 &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/limit&quot;&gt;제한&lt;/a&gt; 요소 만 추가되고 그 뒤에 &lt;a href=&quot;join-to-string#kotlin.sequences%24joinToString(kotlin.sequences.Sequence((kotlin.sequences.joinToString.T)),%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Function1?((kotlin.sequences.joinToString.T,%20kotlin.CharSequence)))/truncated&quot;&gt;잘린&lt;/a&gt; 문자열 (기본값은 &quot;...&quot;)이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="da05b4ffa7db8223c058fb5dd70605340f6d4abf" translate="yes" xml:space="preserve">
          <source>If the compiler can figure the signature out itself, it is allowed not to declare the only parameter and omit &lt;code&gt;-&amp;gt;&lt;/code&gt;. The parameter will be implicitly declared under the name &lt;code&gt;it&lt;/code&gt;:</source>
          <target state="translated">컴파일러가 서명 자체를 알아낼 수있는 경우 유일한 매개 변수를 선언하고 생략 할 수 없습니다 &lt;code&gt;-&amp;gt;&lt;/code&gt; . 매개 변수는 암시 적으로 이름으로 선언합니다 &lt;code&gt;it&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="599643b28c2249744c642d762df9eef25c3f1489" translate="yes" xml:space="preserve">
          <source>If the condition of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;when&lt;/code&gt; statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by 4 spaces relative to statement begin. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;when&lt;/code&gt; 문의 조건 이 여러 줄이면 항상 문장 본문 주위에 중괄호를 사용하십시오. 명령문 시작과 관련하여 조건의 각 후속 행을 4 칸씩 들여 씁니다. 조건의 닫는 괄호를 여는 중괄호와 함께 별도의 줄에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="98f9b69afd4c5b26ac6e15a0b936fff143ad40e0" translate="yes" xml:space="preserve">
          <source>If the condition of an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;when&lt;/code&gt; statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to statement begin. Put the closing parentheses of the condition together with the opening curly brace on a separate line:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;when&lt;/code&gt; 문의 조건 이 여러 줄이면 항상 문의 본문 주위에 중괄호를 사용합니다. 문 시작을 기준으로 조건의 각 후속 줄을 공백 4 개로 들여 씁니다. 조건의 닫는 괄호를 여는 중괄호와 함께 별도의 줄에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="2257c88010b27895c6524d9c1e2196bb7e536709" translate="yes" xml:space="preserve">
          <source>If the constructor has annotations or visibility modifiers, the &lt;em&gt;constructor&lt;/em&gt; keyword is required, and the modifiers go before it:</source>
          <target state="translated">생성자에 주석 또는 가시성 수정자가 있으면 &lt;em&gt;생성자&lt;/em&gt; 키워드가 필요하며 수정자는 그 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="8e6824b3ec6e98e5575247ecc8ff5b7a4046e476" translate="yes" xml:space="preserve">
          <source>If the corresponding binary function (i.e. &lt;code&gt;plus()&lt;/code&gt; for &lt;code&gt;plusAssign()&lt;/code&gt;) is available too, report error (ambiguity),</source>
          <target state="translated">(즉, 해당 이항 함수 경우 &lt;code&gt;plus()&lt;/code&gt; 에 대한 &lt;code&gt;plusAssign()&lt;/code&gt; )도 가능하며, 보고서 오류 (모호성)</target>
        </trans-unit>
        <trans-unit id="750feaab46d025f60b60595fd5b6464a238bc26d" translate="yes" xml:space="preserve">
          <source>If the current capacity is less than the &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, a new backing storage is allocated with greater capacity. Otherwise, this method takes no action and simply returns.</source>
          <target state="translated">현재 용량이 &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt; 보다 작 으면 새 백업 스토리지가 더 큰 용량으로 할당됩니다. 그렇지 않으면이 메서드는 아무 작업도 수행하지 않고 단순히 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3beb3ca0f76030c28cffd99a1ef390c7748ebe7c" translate="yes" xml:space="preserve">
          <source>If the derived class has a primary constructor, the base class can (and must) be initialized right there, using the parameters of the primary constructor.</source>
          <target state="translated">파생 클래스에 기본 생성자가 있으면 기본 생성자의 매개 변수를 사용하여 기본 클래스를 바로 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ea87c7c846a5bc82b765d82616bbeeb4342e98" translate="yes" xml:space="preserve">
          <source>If the derived class has no primary constructor, then each secondary constructor has to initialize the base type using the &lt;em&gt;super&lt;/em&gt; keyword, or to delegate to another constructor which does that. Note that in this case different secondary constructors can call different constructors of the base type:</source>
          <target state="translated">파생 클래스에 기본 생성자가 없으면 각 보조 생성자는 &lt;em&gt;super&lt;/em&gt; 키워드를 사용하여 기본 유형을 초기화 하거나이를 수행하는 다른 생성자에게 위임해야합니다. 이 경우 다른 보조 생성자는 기본 유형의 다른 생성자를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bdcd3a2cd6234626ea8fd7aebd3dff5dd746817" translate="yes" xml:space="preserve">
          <source>If the enum class defines any members, separate the enum constant definitions from the member definitions with a semicolon.</source>
          <target state="translated">열거 형 클래스가 멤버를 정의하는 경우 세미콜론으로 멤버 정의에서 열거 형 상수 정의를 분리합니다.</target>
        </trans-unit>
        <trans-unit id="4f83e9cb6ca713b30ca5975229637ad37ddf0b2e" translate="yes" xml:space="preserve">
          <source>If the expression to the left of &lt;code&gt;?:&lt;/code&gt; is not null, the elvis operator returns it, otherwise it returns the expression to the right. Note that the right-hand side expression is evaluated only if the left-hand side is null.</source>
          <target state="translated">&lt;code&gt;?:&lt;/code&gt; 의 왼쪽에있는 표현식 이 널이 아닌 경우 elvis 연산자는이를 리턴하고 그렇지 않으면 표현식을 오른쪽에 리턴합니다. 오른쪽 표현식은 왼쪽이 널인 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="435bd7ef9c1ca0e75781f37812da8cdd0434ce4a" translate="yes" xml:space="preserve">
          <source>If the file path given is just a file, walker iterates only it. If the file path given does not exist, walker iterates nothing, i.e. it's equivalent to an empty sequence.</source>
          <target state="translated">주어진 파일 경로가 단지 파일 인 경우, Walker는 해당 파일 경로 만 반복합니다. 주어진 파일 경로가 존재하지 않으면, Walker는 아무것도 반복하지 않습니다. 즉, 빈 시퀀스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="950981d3a093a2bbe4e3f81e6b27e0b947e8539d" translate="yes" xml:space="preserve">
          <source>If the files reside in locations different from the current directory, use relative paths.</source>
          <target state="translated">파일이 현재 디렉토리와 다른 위치에있는 경우 상대 경로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="341f4361aea5609d460e0b76db7e4ec05c60a0bb" translate="yes" xml:space="preserve">
          <source>If the function from the right column is available</source>
          <target state="translated">오른쪽 열의 기능을 사용할 수있는 경우</target>
        </trans-unit>
        <trans-unit id="baaa08a62689c9d8bfb298957d5ecaaa332cecf1" translate="yes" xml:space="preserve">
          <source>If the function has an expression body that doesn't fit in the same line as the declaration, put the &lt;code&gt;=&lt;/code&gt; sign on the first line. Indent the expression body by 4 spaces.</source>
          <target state="translated">함수에 선언과 같은 줄에 맞지 않는 표현식 본문이 있으면 첫 번째 줄에 &lt;code&gt;=&lt;/code&gt; 기호를 넣으십시오 . 표현식 본문을 4 칸 들여 쓰기하십시오.</target>
        </trans-unit>
        <trans-unit id="70135d84f18dddfdfe73a753ae1ea55edda69b5b" translate="yes" xml:space="preserve">
          <source>If the function has an expression body that doesn't fit in the same line as the declaration, put the &lt;code&gt;=&lt;/code&gt; sign on the first line. Indent the expression body by four spaces.</source>
          <target state="translated">함수에 선언과 같은 줄에 맞지 않는 식 본문이있는 경우 첫 줄에 &lt;code&gt;=&lt;/code&gt; 기호를 입력합니다. 식 본문을 공백 4 개로 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="29229e1e579d9295bd8f3ae80b55b98deb32a290" translate="yes" xml:space="preserve">
          <source>If the function is absent or ambiguous, it is a compilation error;</source>
          <target state="translated">함수가 없거나 모호한 경우 컴파일 오류입니다.</target>
        </trans-unit>
        <trans-unit id="6df6274a785959a141d5be93cbbade7433fe3f26" translate="yes" xml:space="preserve">
          <source>If the function is present and its return type is &lt;code&gt;R&lt;/code&gt;, the expression &lt;code&gt;+a&lt;/code&gt; has type &lt;code&gt;R&lt;/code&gt;;</source>
          <target state="translated">함수가 존재하고 리턴 유형이 &lt;code&gt;R&lt;/code&gt; 이면 표현식 &lt;code&gt;+a&lt;/code&gt; 는 &lt;code&gt;R&lt;/code&gt; 을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0e5095d3d7b34d609b680d7fa5506874cf55c9e5" translate="yes" xml:space="preserve">
          <source>If the function signature doesn't fit on a single line, use the following syntax:</source>
          <target state="translated">함수 서명이 한 줄에 맞지 않으면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="da5a14c8b54552ea732a4d4e6142a3943b4cd96d" translate="yes" xml:space="preserve">
          <source>If the group in the regular expression is optional and there were no match captured by that group, corresponding component value is an empty string.</source>
          <target state="translated">정규식의 그룹이 선택적이고 해당 그룹에서 일치하는 항목이없는 경우 해당 구성 요소 값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d430ff9c1ba01bf9a8c783998530df052f55721e" translate="yes" xml:space="preserve">
          <source>If the group in the regular expression is optional and there were no match captured by that group, corresponding item in &lt;a href=&quot;group-values&quot;&gt;groupValues&lt;/a&gt; is an empty string.</source>
          <target state="translated">정규식의 그룹이 선택적이고 해당 그룹에서 일치하는 항목이없는 경우 &lt;a href=&quot;group-values&quot;&gt;groupValues의&lt;/a&gt; 해당 항목 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="2c92efac4e6ff6397d8d9d74602f3a7f95aa695d" translate="yes" xml:space="preserve">
          <source>If the hours component absolute value of this duration is greater than &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, it is replaced with &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, so the infinite duration is formatted as `&quot;PT2147483647H&quot;.</source>
          <target state="translated">이 기간의 시간 성분의 절대 값이보다 큰 경우 &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; , 그것으로 치환 &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 무한 지속 시간 ' &quot;PT2147483647H&quot;으로 포맷 있도록.</target>
        </trans-unit>
        <trans-unit id="643fa02b9a8df93d52958425162d28c0e98f33e6" translate="yes" xml:space="preserve">
          <source>If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.</source>
          <target state="translated">값의 초기화에서 예외가 발생하면 다음에 액세스 할 때 값을 다시 초기화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="70f53db00bc0a33bccdcb28704c5331a818e66f8" translate="yes" xml:space="preserve">
          <source>If the innermost applied &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; has &lt;code&gt;suppress=true&lt;/code&gt;, the type is generated without wildcards. If the innermost applied &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; has &lt;code&gt;suppress=false&lt;/code&gt;, the type is generated with wildcards.</source>
          <target state="translated">가장 안쪽에 적용된 &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; 에 &lt;code&gt;suppress=true&lt;/code&gt; 가 있으면 유형은 와일드 카드없이 생성됩니다. 가장 안쪽에 적용된 &lt;code&gt;@JvmSuppressWildcards&lt;/code&gt; 에 &lt;code&gt;suppress=false&lt;/code&gt; 가있는 경우 유형은 와일드 카드로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="eee51b4527104383bc254754abf4668fd83fd300" translate="yes" xml:space="preserve">
          <source>If the lambda is the only argument to that call, the parentheses can be omitted entirely:</source>
          <target state="translated">람다가 해당 호출에 대한 유일한 인수 인 경우 괄호를 완전히 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1de53ed9727d06b3c7bd0607d6d4643e9b89c9f3" translate="yes" xml:space="preserve">
          <source>If the lambda parameter is unused, you can place an underscore instead of its name:</source>
          <target state="translated">lambda 매개 변수를 사용하지 않으면 이름 대신 밑줄을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c6142f7e98803bfddded146b81383e4a0f40e4" translate="yes" xml:space="preserve">
          <source>If the last argument after default parameters is a &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;, it can be passed in either as a named argument or &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;outside the parentheses&lt;/a&gt;:</source>
          <target state="translated">기본 매개 변수 다음의 마지막 인수가 &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt; 인 경우 명명 된 인수 또는 &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;괄호 외부&lt;/a&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="228e14748a5781e0c8dfea5c0e0f424d49c4dd7a" translate="yes" xml:space="preserve">
          <source>If the last argument after default parameters is a &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;lambda&lt;/a&gt;, you can pass it either as a named argument or &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;outside the parentheses&lt;/a&gt;:</source>
          <target state="translated">기본 매개 변수 뒤의 마지막 인수가 &lt;a href=&quot;lambdas#lambda-expression-syntax&quot;&gt;람다&lt;/a&gt; 인 경우 명명 된 인수로 전달하거나 &lt;a href=&quot;lambdas#passing-a-lambda-to-the-last-parameter&quot;&gt;괄호 외부에&lt;/a&gt; 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b64359d957702bc4133d8dddc95300b39134cda9" translate="yes" xml:space="preserve">
          <source>If the library you are adding has dependencies on &lt;a href=&quot;#npm-dependencies&quot;&gt;packages from npm&lt;/a&gt;, Gradle will automatically resolve these transitive dependencies as well.</source>
          <target state="translated">추가하는 라이브러리에 &lt;a href=&quot;#npm-dependencies&quot;&gt;npm의 패키지에&lt;/a&gt; 대한 종속성이있는 경우 Gradle은 이러한 전 이적 종속성도 자동으로 해결합니다.</target>
        </trans-unit>
        <trans-unit id="bc94874fad8d6a3f9e943d1975b7337b73e5e96a" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">목록에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Comparator%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt; 와 동일한 요소가 여러 개 포함 된 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="283094cd40b3e90a305fdcb2b91ad3b0c2c41453" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">목록에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.collections.binarySearch.T%2C+kotlin.Int%2C+kotlin.Int%29%2Felement&quot;&gt;element&lt;/a&gt; 와 동일한 요소가 여러 개 포함 된 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="791c40d36929cc71b9e4bc35ccf6279a3a20c0ac" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">목록에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.collections.binarySearch.T,%20kotlin.Comparator((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;요소&lt;/a&gt; 와 동일한 요소가 여러 개 포함되어있는 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="44a57d6c0b8b204d89d02d382bc44b25184c5e7e" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements equal to the specified &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T?)),%20kotlin.collections.binarySearch.T?,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;element&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">목록에 지정된 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T?)),%20kotlin.collections.binarySearch.T?,%20kotlin.Int,%20kotlin.Int)/element&quot;&gt;요소&lt;/a&gt; 와 동일한 요소가 여러 개 포함되어있는 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="79a654f17dffc6680bd32da28acb61ad45511a3b" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements for which &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearch.T%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;comparison&lt;/a&gt; returns zero, there is no guarantee which one will be found.</source>
          <target state="translated">&lt;a href=&quot;binary-search#kotlin.collections%24binarySearch%28kotlin.collections.List%28%28kotlin.collections.binarySearch.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearch.T%2C+kotlin.Int%29%29%29%2Fcomparison&quot;&gt;비교에&lt;/a&gt; 0을 반환 하는 여러 요소가 목록에 포함되어 있으면 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="196e625da9b2a4c97eb60bc8e8aa4a4acff994c2" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements for which &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;comparison&lt;/a&gt; returns zero, there is no guarantee which one will be found.</source>
          <target state="translated">목록에 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;비교&lt;/a&gt; 가 0을 반환 하는 여러 요소가 포함 된 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c27e8d39625b1f210692fb3e472e2e70d219112" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements with the specified &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;key&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">목록에 지정된 &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy%28kotlin.collections.List%28%28kotlin.collections.binarySearchBy.T%29%29%2C+kotlin.collections.binarySearchBy.K%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Function1%28%28kotlin.collections.binarySearchBy.T%2C+kotlin.collections.binarySearchBy.K%29%29%29%2Fkey&quot;&gt;key를&lt;/a&gt; 가진 여러 요소가 포함되어 있으면 어떤 요소를 찾을 수 있는지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="954563aad1a60c6b8d078907859e9fc7093c613a" translate="yes" xml:space="preserve">
          <source>If the list contains multiple elements with the specified &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy(kotlin.collections.List((kotlin.collections.binarySearchBy.T)),%20kotlin.collections.binarySearchBy.K?,%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearchBy.T,%20kotlin.collections.binarySearchBy.K?)))/key&quot;&gt;key&lt;/a&gt;, there is no guarantee which one will be found.</source>
          <target state="translated">목록에 지정된 &lt;a href=&quot;binary-search-by#kotlin.collections%24binarySearchBy(kotlin.collections.List((kotlin.collections.binarySearchBy.T)),%20kotlin.collections.binarySearchBy.K?,%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearchBy.T,%20kotlin.collections.binarySearchBy.K?)))/key&quot;&gt;key&lt;/a&gt; 가있는 여러 요소가 포함 된 경우 어떤 요소를 찾을 지 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="faaba4525f66a7ceffb2e5046c2260e6c103509f" translate="yes" xml:space="preserve">
          <source>If the list size is less than the specified index, an exception is thrown. There are two other functions that help you avoid such exceptions:</source>
          <target state="translated">목록 크기가 지정된 색인보다 작 으면 예외가 발생합니다. 이러한 예외를 피하는 데 도움이되는 다른 두 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9933a4cb9e8666aba0e0d81ce03883cc01e6a2" translate="yes" xml:space="preserve">
          <source>If the map was created by &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;, resorts to its &lt;code&gt;defaultValue&lt;/code&gt; provider function instead of throwing an exception.</source>
          <target state="translated">지도에 의해 생성 된 경우 &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt; , 그에게 의지한다 &lt;code&gt;defaultValue&lt;/code&gt; 제공 기능을 대신 예외를 throw.</target>
        </trans-unit>
        <trans-unit id="b065f87a2aa4168218c6dc371595cc4dd1e98fe7" translate="yes" xml:space="preserve">
          <source>If the memory leak checker is activated, by default &lt;code&gt;true&lt;/code&gt; in debug mode, &lt;code&gt;false&lt;/code&gt; in release. When memory leak checker is activated, and leak is detected during last Kotlin context deinitialization process - error message with leak information is printed and application execution is aborted.</source>
          <target state="translated">메모리 누수 검사기가 활성화 된 경우 디버그 모드에서는 기본적으로 &lt;code&gt;true&lt;/code&gt; , 릴리스 에서는 &lt;code&gt;false&lt;/code&gt; 입니다. 메모리 누수 검사기가 활성화되고 마지막 Kotlin 컨텍스트 초기화 해제 프로세스 중에 누수가 감지되면 누수 정보가 포함 된 오류 메시지가 인쇄되고 애플리케이션 실행이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="c1f1e713ff8c23832b76dce0f833606cef70aca6" translate="yes" xml:space="preserve">
          <source>If the name of the property starts with &lt;code&gt;is&lt;/code&gt;, a different name mapping rule is used: the name of the getter will be the same as the property name, and the name of the setter will be obtained by replacing &lt;code&gt;is&lt;/code&gt; with &lt;code&gt;set&lt;/code&gt;. For example, for a property &lt;code&gt;isOpen&lt;/code&gt;, the getter will be called &lt;code&gt;isOpen()&lt;/code&gt; and the setter will be called &lt;code&gt;setOpen()&lt;/code&gt;. This rule applies for properties of any type, not just &lt;code&gt;Boolean&lt;/code&gt;.</source>
          <target state="translated">속성 이름이 시작하는 경우 &lt;code&gt;is&lt;/code&gt; 게터의 이름 속성의 이름과 동일 할 것이며, 세터의 이름을 대체함으로써 얻어 질 것이다 : 다른 이름 매핑 규칙이 사용되는 &lt;code&gt;is&lt;/code&gt; 로 &lt;code&gt;set&lt;/code&gt; . 예를 들어 &lt;code&gt;isOpen&lt;/code&gt; 속성의 경우 getter는 &lt;code&gt;isOpen()&lt;/code&gt; 이고 setter는 &lt;code&gt;setOpen()&lt;/code&gt; 입니다. 이 규칙은 &lt;code&gt;Boolean&lt;/code&gt; 뿐만 아니라 모든 유형의 속성에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3332fa3bdec15301400b043f38b9641d591bc5f4" translate="yes" xml:space="preserve">
          <source>If the object is an instance of a functional Java interface (i.e. a Java interface with a single abstract method), you can create it using a lambda expression prefixed with the type of the interface:</source>
          <target state="translated">객체가 기능적인 Java 인터페이스의 인스턴스 인 경우 (예 : 단일 추상 메소드가있는 Java 인터페이스) 인터페이스 유형이 접두어로 붙인 람다 식을 사용하여 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="079d14d9fa4b11b9fed1da4e6938934fb59ac4b3" translate="yes" xml:space="preserve">
          <source>If the original list is mutable, all its changes reflect in its reversed views and vice versa.</source>
          <target state="translated">원본 목록이 변경 가능한 경우 모든 변경 사항이 반대보기에 반영되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f199eb80255475df9da84da09551f8bd23017106" translate="yes" xml:space="preserve">
          <source>If the package is not specified, the contents of such a file belong to &quot;default&quot; package that has no name.</source>
          <target state="translated">패키지가 지정되지 않은 경우 해당 파일의 내용은 이름이없는 &quot;기본&quot;패키지에 속합니다.</target>
        </trans-unit>
        <trans-unit id="607e0590c98b31f775522f050ca8e1b54f20a06e" translate="yes" xml:space="preserve">
          <source>If the package is not specified, the contents of such a file belong to the default package that has no name.</source>
          <target state="translated">패키지가 지정되지 않은 경우 이러한 파일의 내용은 이름이없는 기본 패키지에 속합니다.</target>
        </trans-unit>
        <trans-unit id="e2bbcc7a5d6ec12b113958618724012f588f92a6" translate="yes" xml:space="preserve">
          <source>If the parameter list is too long to fit on a line, put the arrow on a separate line:</source>
          <target state="translated">매개 변수 목록이 너무 길어서 한 줄에 들어 가지 않으면 화살표를 별도의 줄에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="65d840640485aeb56113ca2dcd5f195cfe9368f9" translate="yes" xml:space="preserve">
          <source>If the parameters or return types of the members of a variant type are themselves variant, it gets a bit complicated. Function types in parameters and return types make it even more challenging. If you're wondering whether it's safe to use a variant type parameter &lt;code&gt;T&lt;/code&gt; in a particular position, ask yourself:</source>
          <target state="translated">변형 유형의 멤버의 매개 변수 또는 반환 유형이 자체 변형 인 경우 약간 복잡합니다. 매개 변수와 리턴 유형의 함수 유형은 훨씬 더 어려워집니다. 특정 위치에서 변형 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 사용하는 것이 안전한지 궁금한 경우 스스로에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="a18d633a4ebf37f8c95ff8f80627508e8e6e0a0d" translate="yes" xml:space="preserve">
          <source>If the primary constructor does not have any annotations or visibility modifiers, the &lt;em&gt;constructor&lt;/em&gt; keyword can be omitted:</source>
          <target state="translated">기본 생성자에 주석 또는 가시성 수정자가 없으면 &lt;em&gt;constructor&lt;/em&gt; 키워드를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6331b4a5547ad93c58b05b7df58bb3cc81e3498" translate="yes" xml:space="preserve">
          <source>If the repository of the dependency you wish to use does not provide TypeScript definitions, you can also use types provided via the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; repository. In this case, make sure you add &lt;code&gt;npm&lt;/code&gt; dependencies for both &lt;code&gt;your-package&lt;/code&gt; and &lt;code&gt;@types/your-package&lt;/code&gt; (with &lt;code&gt;generateExternals = true&lt;/code&gt;).</source>
          <target state="translated">사용하려는 종속성의 저장소가 TypeScript 정의를 제공하지 않는 경우 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; 저장소 를 통해 제공된 유형을 사용할 수도 있습니다 . 이 경우 &lt;code&gt;your-package&lt;/code&gt; 및 &lt;code&gt;@types/your-package&lt;/code&gt; 모두에 대해 &lt;code&gt;npm&lt;/code&gt; 종속성을 추가해야합니다 ( &lt;code&gt;generateExternals = true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="47e17a53862f3b306373aab1293af010a48f2c36" translate="yes" xml:space="preserve">
          <source>If the same kind of ambiguity arises when a dependency is added to a custom configuration rather than one of the configurations created by the plugin, you can add the attributes to the configuration in the same way:</source>
          <target state="translated">플러그인이 작성한 구성 중 하나가 아닌 사용자 정의 구성에 종속성을 추가 할 때 동일한 종류의 모호성이 발생하는 경우 동일한 방식으로 속성을 구성에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2003e3c2a4c342bc0df488d2992403b24e0a68f" translate="yes" xml:space="preserve">
          <source>If the second-to-last line compiled, it would allow us to put a pear into what is ostensibly a bowl of only apples, and your code would explode when it tried to extract the &quot;apple&quot; from the bowl. However, it's frequently useful to be able to let the type hierarchy of a generic type parameter &quot;flow&quot; to the generic class. As we saw above, though, some care must be taken - the solution is to restrict the direction in which you can move data in and out of the generic object.</source>
          <target state="translated">마지막 두 번째 줄이 컴파일되면, 아마도 사과 그릇에 배를 넣을 수 있으며 그릇에서 &quot;사과&quot;를 추출하려고 할 때 코드가 폭발 할 것입니다. 그러나 제네릭 형식 매개 변수의 형식 계층 구조를 제네릭 클래스로 &quot;흐르게&quot;할 수있게하는 것이 유용한 경우가 많습니다. 위에서 보았 듯이 약간의주의가 필요합니다. 해결책은 일반 객체 안팎으로 데이터를 이동할 수있는 방향을 제한하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e1d01b7eb886e9322c190422643ee87c94b9cb3" translate="yes" xml:space="preserve">
          <source>If the sequence operation returns another sequence, which is produced lazily, it's called &lt;em&gt;intermediate&lt;/em&gt;, and otherwise the operation is &lt;em&gt;terminal&lt;/em&gt;. Examples of terminal operations are &lt;a href=&quot;to-list&quot;&gt;kotlin.sequences.Sequence.toList&lt;/a&gt;, kotlin.sequences.Sequence.max.</source>
          <target state="translated">시퀀스 연산이 느리게 생성 된 다른 시퀀스를 반환하는 경우이를 &lt;em&gt;중간 (intermediate&lt;/em&gt; ) 이라고 하며, 그렇지 않으면 &lt;em&gt;터미널 (&lt;/em&gt; operation)은 &lt;em&gt;터미널&lt;/em&gt; 입니다. 터미널 연산의 예는 &lt;a href=&quot;to-list&quot;&gt;kotlin.sequences.Sequence.toList&lt;/a&gt; , kotlin.sequences.Sequence.max입니다.</target>
        </trans-unit>
        <trans-unit id="44fdc9a07256ffbf20d393bac49e51adf9b4b7af" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 1, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">이 배열의 크기가 1보다 작은 경우 동작이 지정되지 않은 Kotlin / JS를 제외하고 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2773fd03bef38a23b5651a21ca7d831595d79640" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 2, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">이 배열의 크기가 2보다 작 으면 동작이 지정되지 않은 Kotlin / JS를 제외하고 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a0294e2f74afcb56591a07671514765850b0c72" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 3, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">이 배열의 크기가 3보다 작 으면 동작이 지정되지 않은 Kotlin / JS를 제외하고 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da2e1fd0a51d8f47f0a64c24600fb4365faadd98" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 4, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">이 배열의 크기가 4보다 작 으면 동작이 지정되지 않은 Kotlin / JS를 제외하고 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9b9ee92ddb8bbb5a34fed19ad7463f35b65299f8" translate="yes" xml:space="preserve">
          <source>If the size of this array is less than 5, throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; except in Kotlin/JS where the behavior is unspecified.</source>
          <target state="translated">이 배열의 크기가 5보다 작 으면 동작이 지정되지 않은 Kotlin / JS를 제외하고 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f129a501ea48f8a97397e0402d32e22a0e66393" translate="yes" xml:space="preserve">
          <source>If the source set &lt;code&gt;jvmMain&lt;/code&gt; depends on a source set &lt;code&gt;commonMain&lt;/code&gt; then:</source>
          <target state="translated">소스가 설정 한 경우 &lt;code&gt;jvmMain&lt;/code&gt; 는 소스 설정에 따라 달라집니다 &lt;code&gt;commonMain&lt;/code&gt; 다음 :</target>
        </trans-unit>
        <trans-unit id="aea8a32a75a7deb90bc9b2784a7bca89130df6d4" translate="yes" xml:space="preserve">
          <source>If the supertype has a constructor, it must be invoked with parentheses after the supertype name. You can specify multiple supertypes if need be (but as usual, at most one superclass).</source>
          <target state="translated">수퍼 타입에 생성자가 있으면 수퍼 타입 ​​이름 뒤에 괄호를 사용하여 호출해야합니다. 필요한 경우 여러 수퍼 타입을 지정할 수 있습니다 (그러나 평소와 같이 최대 수퍼 클래스).</target>
        </trans-unit>
        <trans-unit id="f754e813201e3d3c1d7a4229841ecfb54eadad53" translate="yes" xml:space="preserve">
          <source>If the target meta-annotation is not present on an annotation declaration, the annotation is applicable to the following elements: &lt;a href=&quot;../-annotation-target/-c-l-a-s-s#kotlin.annotation.AnnotationTarget.CLASS&quot;&gt;CLASS&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y#kotlin.annotation.AnnotationTarget.PROPERTY&quot;&gt;PROPERTY&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-f-i-e-l-d#kotlin.annotation.AnnotationTarget.FIELD&quot;&gt;FIELD&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE&quot;&gt;LOCAL_VARIABLE&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER&quot;&gt;VALUE_PARAMETER&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-c-o-n-s-t-r-u-c-t-o-r#kotlin.annotation.AnnotationTarget.CONSTRUCTOR&quot;&gt;CONSTRUCTOR&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-f-u-n-c-t-i-o-n#kotlin.annotation.AnnotationTarget.FUNCTION&quot;&gt;FUNCTION&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER&quot;&gt;PROPERTY_GETTER&lt;/a&gt;, &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER&quot;&gt;PROPERTY_SETTER&lt;/a&gt;.</source>
          <target state="translated">대상 메타 주석이 주석 선언에 없으면 주석은 &lt;a href=&quot;../-annotation-target/-c-l-a-s-s#kotlin.annotation.AnnotationTarget.CLASS&quot;&gt;CLASS&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y#kotlin.annotation.AnnotationTarget.PROPERTY&quot;&gt;PROPERTY&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-f-i-e-l-d#kotlin.annotation.AnnotationTarget.FIELD&quot;&gt;FIELD&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE&quot;&gt;LOCAL_VARIABLE&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER&quot;&gt;VALUE_PARAMETER&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-c-o-n-s-t-r-u-c-t-o-r#kotlin.annotation.AnnotationTarget.CONSTRUCTOR&quot;&gt;CONSTRUCTOR&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-f-u-n-c-t-i-o-n#kotlin.annotation.AnnotationTarget.FUNCTION&quot;&gt;FUNCTION&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER&quot;&gt;PROPERTY_GETTER&lt;/a&gt; , &lt;a href=&quot;../-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER&quot;&gt;PROPERTY_SETTER&lt;/a&gt; 요소에 적용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="8a35d20b281a1e85d8a06fc803c1646e572b36e8" translate="yes" xml:space="preserve">
          <source>If the transformation produces &lt;code&gt;null&lt;/code&gt; on certain elements, you can filter out the &lt;code&gt;null&lt;/code&gt;s from the result collection by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-not-null&quot;&gt;&lt;code&gt;mapNotNull()&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;map()&lt;/code&gt;, or &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed-not-null&quot;&gt;&lt;code&gt;mapIndexedNotNull()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;mapIndexed()&lt;/code&gt;.</source>
          <target state="translated">변화가 발생하면 &lt;code&gt;null&lt;/code&gt; 특정 요소에는 필터링 할 수 &lt;code&gt;null&lt;/code&gt; 호출하여 결과 컬렉션들 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-not-null&quot;&gt; &lt;code&gt;mapNotNull()&lt;/code&gt; &lt;/a&gt; 함수를 대신 &lt;code&gt;map()&lt;/code&gt; 또는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed-not-null&quot;&gt; &lt;code&gt;mapIndexedNotNull()&lt;/code&gt; &lt;/a&gt; 대신 &lt;code&gt;mapIndexed()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9296b27a4d8120036a7decf816cb92c4373c8a8" translate="yes" xml:space="preserve">
          <source>If the type of the last parameter to a function is a function type and you want to supply a lambda expression, you can place the lambda expression &lt;em&gt;outside&lt;/em&gt; of the parameter parentheses. If the lambda expression is the only parameter, you can omit the parentheses entirely. This is very useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;constructing DSLs&lt;/a&gt;.</source>
          <target state="translated">함수의 마지막 매개 변수 유형이 함수 유형이고 람다 식을 제공하려는 경우 람다 식을 매개 변수 괄호 &lt;em&gt;외부&lt;/em&gt; 에 배치 할 수 있습니다 . 람다식이 유일한 매개 변수이면 괄호를 완전히 생략 할 수 있습니다. 이것은 &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL&lt;/a&gt; 을 구성 할 때 매우 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="a6b8f4ffb4740b781007cf6d0bbe0282c0376673" translate="yes" xml:space="preserve">
          <source>If the value doesn't fit in the range of &lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; type, it is coerced into that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-int#kotlin.Double%24toInt()&quot;&gt;Double.toInt&lt;/a&gt; for details.</source>
          <target state="translated">값이 &lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; 유형 의 범위에 맞지 않으면 해당 범위로 강제 변환됩니다 . 자세한 내용은 &lt;a href=&quot;../../kotlin/-double/to-int#kotlin.Double%24toInt()&quot;&gt;Double.toInt 변환&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="e29d1de77f34d3695193f07bd125bf5fcf617a87" translate="yes" xml:space="preserve">
          <source>If the value doesn't fit in the range of &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; type, it is coerced into that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong&lt;/a&gt; for details.</source>
          <target state="translated">값이 &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 유형 의 범위에 맞지 않으면 해당 범위로 강제 변환됩니다 . 자세한 내용은 &lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong 변환&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="d77bf30b739c2514d63ed87849b1332700a2c8b6" translate="yes" xml:space="preserve">
          <source>If the value has a receiver type, the receiver object should be passed as the first argument. Another way to invoke a value of a function type with receiver is to prepend it with the receiver object, as if the value were an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;: &lt;code&gt;1.foo(2)&lt;/code&gt;,</source>
          <target state="translated">값에 수신자 유형이 있으면 수신자 오브젝트가 첫 번째 인수로 전달되어야합니다. 수신자와 함께 함수 유형의 값을 호출하는 또 다른 방법은 값이 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 인 것처럼 수신자 오브젝트 앞에 추가하는 것입니다 . &lt;code&gt;1.foo(2)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="08b10da0a2b6c0dae39cbc760c047dc614066a39" translate="yes" xml:space="preserve">
          <source>If the value of a read-only property is known at the compile time, mark it as a &lt;em&gt;compile time constant&lt;/em&gt; using the &lt;em&gt;const&lt;/em&gt; modifier. Such properties need to fulfil the following requirements:</source>
          <target state="translated">읽기 전용 속성의 값이 컴파일 타임에 알려진 경우 &lt;em&gt;const&lt;/em&gt; 한정자를 사용하여 &lt;em&gt;컴파일 시간 상수&lt;/em&gt; 로 표시합니다 . 이러한 속성은 다음 요구 사항을 충족해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ec8c7f7b7e4402c0d35a4121dd40caffc8d7c935" translate="yes" xml:space="preserve">
          <source>If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#initialValue()&quot;&gt;ThreadLocal.initialValue&lt;/a&gt; method. Then if it is still &lt;code&gt;null&lt;/code&gt;, the provided &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet%28java.lang.ThreadLocal%28%28kotlin.concurrent.getOrSet.T%29%29%2C+kotlin.Function0%28%28kotlin.concurrent.getOrSet.T%29%29%29%2Fdefault&quot;&gt;default&lt;/a&gt; function is called and its result is stored for the current thread and then returned.</source>
          <target state="translated">변수에 현재 스레드에 대한 값이 없으면 먼저 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/ThreadLocal.html#initialValue()&quot;&gt;ThreadLocal.initialValue&lt;/a&gt; 메소드를 호출하여 리턴 된 값으로 초기화됩니다 . 그런 다음 여전히 &lt;code&gt;null&lt;/code&gt; 인 경우 제공된 &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet%28java.lang.ThreadLocal%28%28kotlin.concurrent.getOrSet.T%29%29%2C+kotlin.Function0%28%28kotlin.concurrent.getOrSet.T%29%29%29%2Fdefault&quot;&gt;기본&lt;/a&gt; 함수가 호출되고 해당 결과가 현재 스레드에 저장되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="55d02f7ccfe9e99651ab411f3283f4f1c75cff68" translate="yes" xml:space="preserve">
          <source>If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the ThreadLocal.initialValue method. Then if it is still &lt;code&gt;null&lt;/code&gt;, the provided &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet(java.lang.ThreadLocal((kotlin.concurrent.getOrSet.T)),%20kotlin.Function0((kotlin.concurrent.getOrSet.T)))/default&quot;&gt;default&lt;/a&gt; function is called and its result is stored for the current thread and then returned.</source>
          <target state="translated">변수에 현재 스레드에 대한 값이 없으면 먼저 ThreadLocal.initialValue 메서드 호출에 의해 반환 된 값으로 초기화됩니다. 그런 다음 여전히 &lt;code&gt;null&lt;/code&gt; 인 경우 제공된 &lt;a href=&quot;get-or-set#kotlin.concurrent%24getOrSet(java.lang.ThreadLocal((kotlin.concurrent.getOrSet.T)),%20kotlin.Function0((kotlin.concurrent.getOrSet.T)))/default&quot;&gt;기본&lt;/a&gt; 함수가 호출되고 그 결과가 현재 스레드에 대해 저장되고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3f98dbe730a8c5b27f6e85f63d1bb117f2681dde" translate="yes" xml:space="preserve">
          <source>If there are clients that use your Kotlin interfaces compiled without the new &lt;code&gt;-Xjvm-default=all&lt;/code&gt; option, then they can be incompatible with the same code compiled with this option.</source>
          <target state="translated">새로운 &lt;code&gt;-Xjvm-default=all&lt;/code&gt; 옵션 없이 컴파일 된 Kotlin 인터페이스를 사용하는 클라이언트가 있는 경우이 옵션으로 컴파일 된 동일한 코드와 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc77a995f63cb6e01033f3a55686b845948a61a" translate="yes" xml:space="preserve">
          <source>If there are explicit implementations of &lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; or &lt;code&gt;toString()&lt;/code&gt; in the data class body or &lt;em&gt;final&lt;/em&gt; implementations in a superclass, then these functions are not generated, and the existing implementations are used;</source>
          <target state="translated">데이터 클래스 본문 에 &lt;code&gt;equals()&lt;/code&gt; , &lt;code&gt;hashCode()&lt;/code&gt; 또는 &lt;code&gt;toString()&lt;/code&gt; 의 명시 적 구현이 있거나 수퍼 클래스의 &lt;em&gt;최종&lt;/em&gt; 구현이있는 경우 이러한 함수가 생성되지 않고 기존 구현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="706d1394b60969b44602412d2be62295a909c4ef" translate="yes" xml:space="preserve">
          <source>If there are multiple equal maximal values, returns the first of them.</source>
          <target state="translated">동일한 최대 값이 여러 개인 경우 그 중 첫 번째 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca6054fd048270c35ac42f250ec06387cb65b331" translate="yes" xml:space="preserve">
          <source>If there are multiple equal minimal values, returns the first of them.</source>
          <target state="translated">동일한 최소값이 여러 개 있으면 그 중 첫 번째 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a22fd4a7c09aa2ff0cda3088cc25dcaf533edd1f" translate="yes" xml:space="preserve">
          <source>If there are no errors during compilation, we should see the result of the execution of our program, which on execution should output the contents of the site &lt;code&gt;http://example.com&lt;/code&gt;</source>
          <target state="translated">컴파일하는 동안 오류가 없으면 프로그램 실행 결과를 볼 수 있으며 실행시 사이트의 내용을 출력해야합니다 &lt;code&gt;http://example.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9edcba1fdea56091b72b70d9544284be2a9b118c" translate="yes" xml:space="preserve">
          <source>If there is a name clash, we can disambiguate by using &lt;em&gt;as&lt;/em&gt; keyword to locally rename the clashing entity:</source>
          <target state="translated">이름 충돌이있는 경우 키워드 &lt;em&gt;로&lt;/em&gt; 키워드를 사용 하여 충돌 엔티티 이름을 로컬로 바꾸면 명확 해집니다 .</target>
        </trans-unit>
        <trans-unit id="b4b2b7e97af6db9e9aed9e5719f03ea30bf0227c" translate="yes" xml:space="preserve">
          <source>If there is a naming conflict, you should usually import just one of the symbols and fully qualify the usages of the other. If both are heavily used, you can rename the symbol at import time:</source>
          <target state="translated">명명 충돌이있는 경우 일반적으로 기호 중 하나만 가져오고 다른 기호의 사용법을 완전히 규정해야합니다. 둘 다 많이 사용하는 경우 가져 오기시에 심볼의 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65b66d3772f31ab93bac26e3026245f1a24b319" translate="yes" xml:space="preserve">
          <source>If there's no nice way around it, and you need to take special actions based on what type something is or to access functions/properties that only exist on some classes, you can use &lt;code&gt;is&lt;/code&gt; to check if the real type of an object is a particular class or a subclass thereof (or an implementor of an interface). When this is used as the condition in an &lt;code&gt;if&lt;/code&gt;, the compiler will let you perform type-specific operations on the object inside the &lt;code&gt;if&lt;/code&gt; body:</source>
          <target state="translated">거기 주위에 좋은 방법이 없습니다, 당신은 어떤 종류의 뭔가에 따라 특별한 조치를 취할 필요가있는 경우 또는 일부 클래스에 존재하는 액세스 기능 / 특성, 사용할 수 &lt;code&gt;is&lt;/code&gt; 객체의 실제 타입이 특정인지 확인합니다 클래스 또는 그 서브 클래스 (또는 인터페이스의 구현 자). 이것이 &lt;code&gt;if&lt;/code&gt; 의 조건으로 사용될 때 , 컴파일러는 &lt;code&gt;if&lt;/code&gt; 본문 안의 객체에 대해 유형별 작업을 수행 할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="c2cd9a7ecd8b049bc616a7923c1daf215620a583" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;depth&lt;/code&gt; function is called for a &lt;code&gt;deepTree&lt;/code&gt; it produces StackOverflowError because of deep recursion. However, the &lt;code&gt;depth&lt;/code&gt; function can be rewritten using &lt;code&gt;DeepRecursiveFunction&lt;/code&gt; in the following way, and then it successfully computes &lt;a href=&quot;../invoke&quot;&gt;&lt;code&gt;depth(deepTree)&lt;/code&gt;&lt;/a&gt; expression:</source>
          <target state="translated">이 &lt;code&gt;depth&lt;/code&gt; 함수가 &lt;code&gt;deepTree&lt;/code&gt; 에 대해 호출 되면 깊은 재귀로 인해 StackOverflowError가 생성됩니다. 그러나 &lt;code&gt;depth&lt;/code&gt; 함수는 다음과 같은 방법으로 &lt;code&gt;DeepRecursiveFunction&lt;/code&gt; 을 사용하여 다시 작성할 수 있으며 &lt;a href=&quot;../invoke&quot;&gt; &lt;code&gt;depth(deepTree)&lt;/code&gt; &lt;/a&gt; 표현식을 성공적으로 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="83d0b5382998741d7aeea7ea3925f51e48120ef6" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사로&lt;/a&gt; 끝나는 경우 , 접미사가 제거 된 새로운 문자 순서를 반환합니다. 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2980e3e7312daa7fe514fbd075be82c6980d9ab3" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 시퀀스가 ​​주어진 &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;접미사로&lt;/a&gt; 끝나는 경우 , 접미사가 제거 된 새 문자 시퀀스를 반환합니다. 그렇지 않으면 동일한 문자로 새 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f68e5f9283a11982ac4d9ee4f72f23e35be2e15" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사로&lt;/a&gt; 끝나는 경우 , 접미사가 제거 된 새로운 문자 순서를 반환합니다. 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a30b2abbbd6e4e6955f1d30edef72f53b5797930" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 시퀀스가 ​​주어진 &lt;a href=&quot;../remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;접미사로&lt;/a&gt; 끝나는 경우 , 접미사가 제거 된 새 문자 시퀀스를 반환합니다. 그렇지 않으면 동일한 문자로 새 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1d9aa147865687623fa05e3a2703d76d90d9924" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사로&lt;/a&gt; 끝나는 경우 , 접미사가 제거 된 새로운 문자 순서를 반환합니다. 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="066696f2f807a663e1d7eba4412c839322bfaa9e" translate="yes" xml:space="preserve">
          <source>If this char sequence ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence with the suffix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 시퀀스가 ​​주어진 &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;접미사로&lt;/a&gt; 끝나는 경우 , 접미사가 제거 된 새 문자 시퀀스를 반환합니다. 그렇지 않으면 동일한 문자로 새 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="393978ca2e4989e43b2a725707449d745979c2c2" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix로&lt;/a&gt; 시작 하면 접두사가 제거 된 새 문자 순서를 반환합니다. 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbd91d26d2ddcfad42a009559f504981281599d6" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 시퀀스가 ​​지정된 &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;접두사로&lt;/a&gt; 시작 하면 접두사가 제거 된 새 문자 시퀀스를 반환합니다. 그렇지 않으면 동일한 문자로 새 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4551b66808b7a93bcbea0cb98dbc6cf03713996" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix로&lt;/a&gt; 시작 하면 접두사가 제거 된 새 문자 순서를 반환합니다. 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1cdbb98160c7143e8a1010edb16577923755a13" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 시퀀스가 ​​지정된 &lt;a href=&quot;../remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;접두사로&lt;/a&gt; 시작 하면 접두사가 제거 된 새 문자 시퀀스를 반환합니다. 그렇지 않으면 동일한 문자로 새 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5eb3f5440c96a359b2e662128e4b4a2fe2e0c6d" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix로&lt;/a&gt; 시작 하면 접두사가 제거 된 새 문자 순서를 반환합니다. 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18964490a2097748cf26c9bc99dc2e1219bd1083" translate="yes" xml:space="preserve">
          <source>If this char sequence starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a new char sequence with the prefix removed. Otherwise, returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 시퀀스가 ​​지정된 &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;접두사로&lt;/a&gt; 시작 하면 접두사가 제거 된 새 문자 시퀀스를 반환합니다. 그렇지 않으면 동일한 문자로 새 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e50b89219e8ed48483bbf130e9adaab263424db1" translate="yes" xml:space="preserve">
          <source>If this file is a directory, it is copied without its content, i.e. an empty &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; directory is created. If you want to copy directory including its contents, use &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;.</source>
          <target state="translated">이 파일이 디렉토리이면 내용없이 복사됩니다. 즉, 빈 &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;대상&lt;/a&gt; 디렉토리가 작성됩니다. 내용을 포함하여 디렉토리를 복사하려면 &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="794fbb14ba44c0a10efb47ff1391acfc97fac0ad" translate="yes" xml:space="preserve">
          <source>If this file is a directory, it is copied without its content, i.e. an empty &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; directory is created. If you want to copy directory including its contents, use &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively&lt;/a&gt;.</source>
          <target state="translated">이 파일이 디렉토리이면 내용없이 복사됩니다. 즉, 빈 &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;대상&lt;/a&gt; 디렉토리가 생성됩니다. 내용을 포함한 디렉토리를 복사하려면 &lt;a href=&quot;copy-recursively&quot;&gt;copyRecursively를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="696bc35b6b7c9124fdae8a289c38873049e01372" translate="yes" xml:space="preserve">
          <source>If this file path points to a single file, then it will be copied to a file with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;. If this file path points to a directory, then its children will be copied to a directory with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">이 파일 경로가 단일 파일을 가리키는 경우 경로가 &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target 인&lt;/a&gt; 파일로 복사됩니다 . 이 파일 경로가 디렉토리를 가리키는 경우, 그 하위는 경로가 &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Function2%28%28java.io.File%2C+java.io.IOException%2C+kotlin.io.OnErrorAction%29%29%29%2Ftarget&quot;&gt;target 인&lt;/a&gt; 디렉토리로 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="f19f7f0e9647874289c7ec01aa0daf1c28a6e17f" translate="yes" xml:space="preserve">
          <source>If this file path points to a single file, then it will be copied to a file with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;. If this file path points to a directory, then its children will be copied to a directory with the path &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt;.</source>
          <target state="translated">이 파일 경로가 단일 파일을 가리키는 경우 &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt; 경로가있는 파일에 복사됩니다 . 이 파일 경로가 디렉토리를 가리키는 경우 하위 항목은 &lt;a href=&quot;copy-recursively#kotlin.io%24copyRecursively(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Function2((java.io.File,%20java.io.IOException,%20kotlin.io.OnErrorAction)))/target&quot;&gt;target&lt;/a&gt; 경로가있는 디렉토리에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="822fa875865380bffd3780f735dc7821bbfbc1dd" translate="yes" xml:space="preserve">
          <source>If this function is invoked on other &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; instances it returns &lt;code&gt;this&lt;/code&gt; continuation unchanged.</source>
          <target state="translated">다른 &lt;a href=&quot;../kotlin.coroutines/-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서이 함수를 호출 &lt;code&gt;this&lt;/code&gt; 연속이 변경되지 않은 상태로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="000d49e516219b57649db3a4add8aedc933ac12a" translate="yes" xml:space="preserve">
          <source>If this is the first time you're adding a Kotlin file to this project, IntelliJ IDEA will prompt you to add the required Kotlin runtime. For a Java project, configure the Kotlin runtime as a &lt;strong&gt;Kotlin Java Module&lt;/strong&gt;.</source>
          <target state="translated">이 프로젝트에 Kotlin 파일을 처음 추가하는 경우 IntelliJ IDEA에서 필요한 Kotlin 런타임을 추가하라는 메시지를 표시합니다. Java 프로젝트의 경우 Kotlin 런타임을 &lt;strong&gt;Kotlin Java 모듈&lt;/strong&gt; 로 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5452ff7f47b8e841bbf674d6743480276ef5195d" translate="yes" xml:space="preserve">
          <source>If this list doesn&amp;rsquo;t cover your needs, you can find more options in the &lt;a href=&quot;https://github.com/thomasnield/kotlin-data-science-resources&quot;&gt;&lt;strong&gt;Kotlin Data Science Resources&lt;/strong&gt;&lt;/a&gt; digest from Thomas Nield.</source>
          <target state="translated">이 목록이 요구 사항을 충족하지 않는 경우 Thomas Nield 의 &lt;a href=&quot;https://github.com/thomasnield/kotlin-data-science-resources&quot;&gt;&lt;strong&gt;Kotlin 데이터 과학 리소스&lt;/strong&gt;&lt;/a&gt; 다이제스트에서 더 많은 옵션을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ef8c14fd9985248743a7603b2080574686a18ae" translate="yes" xml:space="preserve">
          <source>If this reference is &lt;a href=&quot;../-c-pointer/index&quot;&gt;CPointer&lt;/a&gt;, returns this pointer, otherwise allocate storage value in the scope and return it.</source>
          <target state="translated">이 참조가 &lt;a href=&quot;../-c-pointer/index&quot;&gt;CPointer&lt;/a&gt; 인 경우 ,이 포인터를 리턴하고, 그렇지 않으면 범위에 스토리지 값을 할당하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="b3b7f842b5ea81c3f4b90a34bcfe922201e07ced" translate="yes" xml:space="preserve">
          <source>If this reference is &lt;a href=&quot;index&quot;&gt;CPointer&lt;/a&gt;, returns this pointer, otherwise allocate storage value in the scope and return it.</source>
          <target state="translated">이 참조가 &lt;a href=&quot;index&quot;&gt;CPointer&lt;/a&gt; 인 경우 ,이 포인터를 리턴하고, 그렇지 않으면 범위에 스토리지 값을 할당하고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="daa765d4ed09a47719a46eaa22921d3d6383a5b1" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 지정된 &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미어로&lt;/a&gt; 끝나는 경우 접미사가 제거 된이 문자열의 사본을 리턴합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7dc1cbcb6a32aa88b8d844adc9e841c43d6e6b8" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 주어진 &lt;a href=&quot;../../kotlin.text/remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix로&lt;/a&gt; 끝나면 접미사가 제거 된 문자열의 복사본을 반환합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe146357dbe5d233f80385c4622bdabdf282c2ff" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 지정된 &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix%28kotlin.String%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미어로&lt;/a&gt; 끝나는 경우 접미사가 제거 된이 문자열의 사본을 리턴합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="709bfa613cc84c58d0e77dbf11164343f90ebae6" translate="yes" xml:space="preserve">
          <source>If this string ends with the given &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a copy of this string with the suffix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 주어진 &lt;a href=&quot;remove-suffix#kotlin.text%24removeSuffix(kotlin.String,%20kotlin.CharSequence)/suffix&quot;&gt;suffix로&lt;/a&gt; 끝나면 접미사가 제거 된 문자열의 복사본을 반환합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eef5abc7cbd0224a64b4e2e54624e8e1396be8a5" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 지정된 &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix로&lt;/a&gt; 시작 하면 접두사가 제거 된이 문자열의 사본을 리턴합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92c6be29a5671e41239ef25ada1ea6fe1003a0b7" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 주어진 &lt;a href=&quot;../../kotlin.text/remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix로&lt;/a&gt; 시작 하면 접두사가 제거 된이 문자열의 복사본을 반환합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9adf224f013e9757a5b20a24dd0cebbc9d578cc5" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 지정된 &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix%28kotlin.String%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix로&lt;/a&gt; 시작 하면 접두사가 제거 된이 문자열의 사본을 리턴합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e98d4d193636df70b1b850a20d5da773ecb938f" translate="yes" xml:space="preserve">
          <source>If this string starts with the given &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt;, returns a copy of this string with the prefix removed. Otherwise, returns this string.</source>
          <target state="translated">이 문자열이 주어진 &lt;a href=&quot;remove-prefix#kotlin.text%24removePrefix(kotlin.String,%20kotlin.CharSequence)/prefix&quot;&gt;prefix로&lt;/a&gt; 시작 하면 접두사가 제거 된이 문자열의 복사본을 반환합니다. 그렇지 않으면이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eaa08b32eac3b33ecf492f621bff941ea4a9fcd4" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt; 에 있으면 결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fc02da33b8b0ff318b09d189a23b770163982e91" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt; 에 있으면 결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="490305470096f372ac8119db4e004b84e91a7481" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-byte/-m-i-n_-v-a-l-u-e#kotlin.Byte.Companion%24MIN_VALUE&quot;&gt;Byte.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt; 에 있으면 결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f92846150c40dce3860615a8d63e6d463453288e" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 에 있으면 결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6a741800a8dda50919fa61b7fa403325e77f2e0d" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt; 에 있으면 결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="005b91e001ae975c4aa32f3aea7b1ec2812c965b" translate="yes" xml:space="preserve">
          <source>If this value is in &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt;..&lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-short/-m-i-n_-v-a-l-u-e#kotlin.Short.Companion%24MIN_VALUE&quot;&gt;Short.MIN_VALUE&lt;/a&gt; .. &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt; 에 있으면 결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="db0284f249225c9c93443ff06ef1c4250bc05e17" translate="yes" xml:space="preserve">
          <source>If this value is in the range of &lt;code&gt;Char&lt;/code&gt; codes &lt;code&gt;Char.MIN_VALUE..Char.MAX_VALUE&lt;/code&gt;, the resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value.</source>
          <target state="translated">이 값이 &lt;code&gt;Char&lt;/code&gt; 코드 &lt;code&gt;Char.MIN_VALUE..Char.MAX_VALUE&lt;/code&gt; 범위에 있으면 결과 &lt;code&gt;Char&lt;/code&gt; 코드는이 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba8d6d461e9008017be587a9202d1b43cf4ff54e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 . 그렇지 않으면 결과는 음수입니다.</target>
        </trans-unit>
        <trans-unit id="df39050abae12f0e8e01436504cfef55ec387e2d" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="4978f90a7ed1a79fd218cf1590a5d83b0509d961" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6ca047505e5da8d6c0e87f024f03aaab76397dfc" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Byte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-byte/-m-a-x_-v-a-l-u-e#kotlin.Byte.Companion%24MAX_VALUE&quot;&gt;Byte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e4c48fdf984577c7db86ab572e1f6df4cdbfd866" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 . 그렇지 않으면 결과는 음수입니다.</target>
        </trans-unit>
        <trans-unit id="558a6d1dd84324e1f32448d5639a910b9702fe85" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d5c7b7a5156a004ef779605c60b74b3e30f938ab" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 . 그렇지 않으면 결과는 음수입니다.</target>
        </trans-unit>
        <trans-unit id="4d043b90606414b70c2e38bef9430e4d147c520b" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="30cf5a989061d05ea8b8590b44fff20c1be5f179" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1a549db6113eee376be4eec1673b56713351397d" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;. Otherwise the result is negative.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-short/-m-a-x_-v-a-l-u-e#kotlin.Short.Companion%24MAX_VALUE&quot;&gt;Short.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 . 그렇지 않으면 결과는 음수입니다.</target>
        </trans-unit>
        <trans-unit id="7879809b5daf67a980acd328829f4454ce83b90e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bcead8032199b4164256add596a32cf9db97266e" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1121ef81db7e8693e07be091631a7082321f06c6" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="81dc4365e9ac822eeb6e28d60dee107cd6132748" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE 이하인&lt;/a&gt; 경우, 결과의 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 와 같은 수치를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3c9c01de18ce638bd129bff08018567a3e4127c6" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a6f6b5210b89a3892e478e42ca97672805905a83" translate="yes" xml:space="preserve">
          <source>If this value is less than or equals to &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;ULong&lt;/code&gt;.</source>
          <target state="translated">이 값이 &lt;a href=&quot;../-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b503698fc5df8a655c9e1e6ad1697e72a8fc230d" translate="yes" xml:space="preserve">
          <source>If this value is non-negative, the resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value.</source>
          <target state="translated">이 값이 음수가 아닌 경우 결과 &lt;code&gt;Char&lt;/code&gt; 코드는이 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2db0fef9187625217d9cbad099e4b7a81b501888" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이고 &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="92dfb012b562ce6d901306be8ab16c8954d89a73" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이고 &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="953da8b824c2844b89e1295212fa13c1e2d80e5e" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이고 &lt;a href=&quot;-u-byte/-m-a-x_-v-a-l-u-e&quot;&gt;UByte.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9fa06c56030e25a9536cc3f63946d539809dea9f" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이고 &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="50d4512f22b639993dc1259c1108fdebd639d406" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이고 &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8dadb1990a07a6ce6e741d4f630eb1d46e9ed4a3" translate="yes" xml:space="preserve">
          <source>If this value is positive and less than or equals to &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt;, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이고 &lt;a href=&quot;-u-short/-m-a-x_-v-a-l-u-e&quot;&gt;UShort.MAX_VALUE&lt;/a&gt; 보다 작거나 같은 경우 결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f89685f072ef956cdc798c29edd60c19b535cdfe" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UByte&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이면 결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="509d2f430404b1731ac6b4aaf8d343dae3f0754b" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수인 경우 결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="273aa3ecdd133965b3ad433946ad9ef5ed7f4eee" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수인 경우 결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="2607741fe174b50565a03e15e9436cf3b0a3f525" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이면 결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0f095f5bb49dc6a53286dbebb4a62e97505f3fa8" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이면 결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c42bf5546a05357422f652dbab02ab2c5562b1b9" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이면 결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1c908d0ebe8742d6be314405ace34fa252b6ec7d" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Long&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이면 결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 과 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b851c29ac8506df58c238a4d6e63ef0a6ce3bf18" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수이면 결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a4186277a2fae421e55cc11af12fc473065dce40" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수인 경우 결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f91f720debed186fe9dc1691606e3420ca01e262" translate="yes" xml:space="preserve">
          <source>If this value is positive, the resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">이 값이 양수인 경우 결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b92f3912f030b245b906c1d0285095411d239059" translate="yes" xml:space="preserve">
          <source>If two corresponding elements are nested arrays, they are also compared deeply. If any of arrays contains itself on any nesting level the behavior is undefined.</source>
          <target state="translated">두 개의 해당 요소가 중첩 배열이면 깊이 비교됩니다. 배열 중 하나라도 중첩 수준에 포함 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c426df69b29a4f2a8f05ed102d4c7c508452b26" translate="yes" xml:space="preserve">
          <source>If two objects are equal according to the &lt;code&gt;equals()&lt;/code&gt; method, then calling the &lt;code&gt;hashCode&lt;/code&gt; method on each of the two objects must produce the same integer result.</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; 메소드 에 따라 두 오브젝트가 동일한 경우 두 오브젝트 각각 에서 &lt;code&gt;hashCode&lt;/code&gt; 메소드 를 호출 하면 동일한 정수 결과가 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="848bd4767d40a5b040578d4b4acc3831b4a5c116" translate="yes" xml:space="preserve">
          <source>If using Android Studio, the following needs to be added under android:</source>
          <target state="translated">Android Studio를 사용하는 경우 android 아래에 다음을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="835af367bcaa35713fbb44c63e3433507604b4f9" translate="yes" xml:space="preserve">
          <source>If using Ant or Maven, the same configuration applies. The only difference being that the Runner Type would be Ant or Maven respectively.</source>
          <target state="translated">Ant 또는 Maven을 사용하는 경우 동일한 구성이 적용됩니다. 유일한 차이점은 러너 유형이 각각 Ant 또는 Maven이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="00e086822c4cc4c3d86e846ccfc2b1c6bbc7e5e5" translate="yes" xml:space="preserve">
          <source>If using Ant, Maven or Gradle, the setup process is straightforward. All that is needed is to define the Build Step. In our case, if using Gradle we'd simply define the required parameters such as the Step Name and Gradle tasks that need executing for the Runner Type.</source>
          <target state="translated">Ant, Maven 또는 Gradle을 사용하는 경우 설정 프로세스가 간단합니다. 필요한 것은 빌드 단계를 정의하는 것입니다. 이 경우 Gradle을 사용하는 경우 단계 이름 및 Gradle 태스크와 같은 필수 매개 변수를 러너 유형에 대해 실행해야하는 것으로 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6d1aa0dbbc7faa5d8c75c6b538e6bd8ea6617548" translate="yes" xml:space="preserve">
          <source>If using IntelliJ IDEA build system with TeamCity, we need to make sure that the version of Kotlin being used by IntelliJ IDEA is the same as that that TeamCity runs. This would mean that we need to download the specific version of the Kotlin plugin and install it on TeamCity.</source>
          <target state="translated">TeamCity와 함께 IntelliJ IDEA 빌드 시스템을 사용하는 경우 IntelliJ IDEA에서 사용중인 Kotlin 버전이 TeamCity가 실행되는 버전과 동일해야합니다. 이는 특정 버전의 Kotlin 플러그인을 다운로드하여 TeamCity에 설치해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1ff8b36dc1a6a3cc57b717edeaeb3788168f606b" translate="yes" xml:space="preserve">
          <source>If using Maven or Gradle, we can also configure the module output format. For more information see &lt;a href=&quot;http://kotlinlang.org/docs/reference/js-modules.html&quot;&gt;JavaScript Modules&lt;/a&gt;.</source>
          <target state="translated">Maven 또는 Gradle을 사용하는 경우 모듈 출력 형식을 구성 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;http://kotlinlang.org/docs/reference/js-modules.html&quot;&gt;JavaScript 모듈을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a4dc0ed9963550c2c79f4e04423d9486f9f6cf" translate="yes" xml:space="preserve">
          <source>If using a Continuous Integration tool different to TeamCity, as long as it supports any of the build tools, or calling command line tools, compiling Kotlin and automating things as part of a CI process should be possible.</source>
          <target state="translated">TeamCity와 다른 Continuous Integration 도구를 사용하는 경우 빌드 도구 중 하나를 지원하거나 명령 줄 도구를 호출하면 Kotlin을 컴파일하고 CI 프로세스의 일부로 자동화 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6bd5591695bc9bb315e16734b0ff743bacc22bbf" translate="yes" xml:space="preserve">
          <source>If using a previous version, refer to the &lt;a href=&quot;https://confluence.jetbrains.com/display/TCD9/Working+with+Meta-Runner&quot;&gt;documentation on how to add meta-runners&lt;/a&gt;.</source>
          <target state="translated">이전 버전을 사용하는 경우 &lt;a href=&quot;https://confluence.jetbrains.com/display/TCD9/Working+with+Meta-Runner&quot;&gt;메타 러너 추가 방법에&lt;/a&gt; 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="449042335ccaad499545704799876f951b9d4d55" translate="yes" xml:space="preserve">
          <source>If values are equal, returns the first one.</source>
          <target state="translated">값이 같으면 첫 번째 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f746ae601b0ca7798611e8dc917365449e6e394e" translate="yes" xml:space="preserve">
          <source>If we are computing the numbers with some CPU-consuming blocking code (each computation taking 100ms), then we can represent the numbers using a &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/index&quot;&gt;Sequence&lt;/a&gt;:</source>
          <target state="translated">CPU를 사용하는 차단 코드 (각 계산에 100ms 소요)로 숫자를 계산하는 경우 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/index&quot;&gt;Sequence를&lt;/a&gt; 사용하여 숫자를 나타낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b672336c863c791a792cf43720020da0742ad23" translate="yes" xml:space="preserve">
          <source>If we are using IntelliJ IDEA as our development environment, we can find the &lt;code&gt;run&lt;/code&gt; action in the Gradle tool window:</source>
          <target state="translated">IntelliJ IDEA를 개발 환경으로 사용 하는 경우 Gradle 도구 창에서 &lt;code&gt;run&lt;/code&gt; 작업을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5d0a72271531597b020177163056bb930e197fe" translate="yes" xml:space="preserve">
          <source>If we are using the set of example tests shown in the snippet above, one test passes, and one test breaks, which gives us the resulting total of 50% successful tests. To get more information about individual test cases, we can navigate via the provided hyperlinks:</source>
          <target state="translated">위의 스 니펫에 표시된 예제 테스트 세트를 사용하는 경우 하나의 테스트가 통과되고 하나의 테스트가 중단되어 총 50 %의 성공적인 테스트를 얻을 수 있습니다. 개별 테스트 케이스에 대한 자세한 정보를 얻으려면 제공된 하이퍼 링크를 통해 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bba64879e65ddd90a5f852a3b397bb4e81ce686" translate="yes" xml:space="preserve">
          <source>If we are working from inside IntelliJ IDEA, we can pass the same flag via the &lt;em&gt;run configuration&lt;/em&gt;. After running the Gradle &lt;code&gt;run&lt;/code&gt; task for the first time from the IDE, IntelliJ IDEA automatically generates a run configuration for it, which we can edit:</source>
          <target state="translated">IntelliJ IDEA 내부에서 작업하는 경우 &lt;em&gt;실행 구성을&lt;/em&gt; 통해 동일한 플래그를 전달할 수 &lt;em&gt;있습니다&lt;/em&gt; . IDE에서 처음으로 Gradle &lt;code&gt;run&lt;/code&gt; 작업을 실행 한 후 IntelliJ IDEA는 자동으로 실행 구성을 생성하여 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ff93c719c3677a5febd54d97d72cdccbce6a99" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;c.foo()&lt;/code&gt; of any &lt;code&gt;c&lt;/code&gt; of type &lt;code&gt;C&lt;/code&gt;, it will print &quot;member&quot;, not &quot;extension&quot;.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 타입 &lt;code&gt;c&lt;/code&gt; 의 &lt;code&gt;c.foo()&lt;/code&gt; 를 호출하면 &quot;extension&quot;이 아닌 &quot;member&quot;를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="379283767448c54e1e97c1028507253f860becb5" translate="yes" xml:space="preserve">
          <source>If we choose a non-null type, the compiler will emit an assertion upon assignment. This prevents Kotlin's non-null variables from holding nulls. Assertions are also emitted when we pass platform values to Kotlin functions expecting non-null values etc. Overall, the compiler does its best to prevent nulls from propagating far through the program (although sometimes this is impossible to eliminate entirely, because of generics).</source>
          <target state="translated">널이 아닌 유형을 선택하면 할당시 컴파일러가 어설 션을 생성합니다. 이것은 Kotlin의 널이 아닌 변수가 널을 보유하지 못하게합니다. 널값이 아닌 값을 기대하는 Kotlin 함수에 플랫폼 값을 전달할 때 어설 션도 생성됩니다. 전반적으로 컴파일러는 널이 프로그램을 통해 멀리 전파되는 것을 막기 위해 최선을 다합니다 (종종 제네릭 때문에 완전히 제거 할 수는 없지만).</target>
        </trans-unit>
        <trans-unit id="bdbae50858519197b3fe083596ba04b9db8edf5b" translate="yes" xml:space="preserve">
          <source>If we define a custom setter, it will be called every time we assign a value to the property. A custom setter looks like this:</source>
          <target state="translated">커스텀 세터를 정의하면 속성에 값을 할당 할 때마다 호출됩니다. 커스텀 세터는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="d5788a5cd4b3c40d8ba64eb6708ad2b0a9b603bc" translate="yes" xml:space="preserve">
          <source>If we didn't specify the &lt;code&gt;@JsName&lt;/code&gt; annotation, the name of the corresponding function would contain a suffix calculated from the function signature, for example &lt;code&gt;hello_61zpoe$&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@JsName&lt;/code&gt; 어노테이션을 지정하지 않으면 해당 함수의 이름에 함수 서명에서 계산 된 접미 부가 포함됩니다 (예 : &lt;code&gt;hello_61zpoe$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="966f788e727a4b595780377e8042611cc0480c54" translate="yes" xml:space="preserve">
          <source>If we had wanted to express the same thing in Python, it would have looked like this, and we would be hamstrung by the fact that lambda functions can only contain one expression, so we need explicit function definitions for everything but the oneliners:</source>
          <target state="translated">파이썬에서 같은 것을 표현하고 싶다면 다음과 같이 보일 것입니다. 람다 함수에는 하나의 표현식 만 포함될 수 있으므로 oneliners 이외의 모든 것에 대한 명시적인 함수 정의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dc0fca0f296a8cb428a1796bfc197561c1551e47" translate="yes" xml:space="preserve">
          <source>If we leave all the optional annotations out, what's left looks like this:</source>
          <target state="translated">모든 선택적 주석을 생략하면 왼쪽은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f0622f86bfe1754250cfd5960f42eb9787c1baa" translate="yes" xml:space="preserve">
          <source>If we need to use a member of a class, or an extension function, it needs to be qualified, e.g. &lt;code&gt;String::toCharArray&lt;/code&gt;.</source>
          <target state="translated">클래스의 멤버 또는 확장 함수를 사용해야하는 경우 &lt;code&gt;String::toCharArray&lt;/code&gt; 와 같이 정규화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06f2f1ba4877a89d728de7b4cb1810c2c9646349" translate="yes" xml:space="preserve">
          <source>If we need wildcards where they are not generated by default, we can use the &lt;code&gt;@JvmWildcard&lt;/code&gt; annotation:</source>
          <target state="translated">기본적으로 생성되지 않은 와일드 카드가 필요한 경우 &lt;code&gt;@JvmWildcard&lt;/code&gt; 주석을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8622531a5c0429cfdda336ff31f83fe890fe02ca" translate="yes" xml:space="preserve">
          <source>If we try to use the same non-blocking &lt;code&gt;delay()&lt;/code&gt; function directly inside &lt;code&gt;main()&lt;/code&gt;, we'll get a compiler error:</source>
          <target state="translated">&lt;code&gt;main()&lt;/code&gt; 내 에서 동일한 비 차단 &lt;code&gt;delay()&lt;/code&gt; 함수를 직접 사용하려고 하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40479a99caad7c4a33dc795543afa14441ffca7a" translate="yes" xml:space="preserve">
          <source>If we use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; terminal operator after &lt;code&gt;onEach&lt;/code&gt;, then the code after it will wait until the flow is collected:</source>
          <target state="translated">&lt;code&gt;onEach&lt;/code&gt; 이후에 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; 터미널 연산자를 사용하면 이후 코드는 흐름이 수집 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="eec42d7483409e40f6e340d8a3d88fe567b92801" translate="yes" xml:space="preserve">
          <source>If we want to call the synthetic properties on &lt;code&gt;View&lt;/code&gt;, we should also import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.view.*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;View&lt;/code&gt; 에서 합성 속성을 호출하려면 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.view.*&lt;/code&gt; 도 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="b22d5f997bc9d10a51a59c8d992a6139a9878201" translate="yes" xml:space="preserve">
          <source>If we want, we can add tests to a specific platform, then it will be executed only as part of these platform tests.</source>
          <target state="translated">원하는 경우 특정 플랫폼에 테스트를 추가하면 이러한 플랫폼 테스트의 일부로 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="df31a64d374ba97c421367b3cdcce507cbe75299" translate="yes" xml:space="preserve">
          <source>If we want, we can add tests to a specific platform, then it will be executed only as part of these platform tests. For example, we can add UTF-16 tests on JVM. Just follow the same steps as before, but create file in &lt;code&gt;jvmTest/kotlin/jetbrains/base64&lt;/code&gt;:</source>
          <target state="translated">원하는 경우 특정 플랫폼에 테스트를 추가 할 수 있으며 이러한 플랫폼 테스트의 일부로 만 실행됩니다. 예를 들어 JVM에서 UTF-16 테스트를 추가 할 수 있습니다. 이전과 동일한 단계를 &lt;code&gt;jvmTest/kotlin/jetbrains/base64&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ba8fe72a36f3192d28c0b1bb2a6adebf2c73a672" translate="yes" xml:space="preserve">
          <source>If we were to introduce another class &lt;code&gt;Bicycle&lt;/code&gt;, which should be neither a subclass nor a superclass of &lt;code&gt;MotorVehicle&lt;/code&gt;, we could still make it implement &lt;code&gt;Driveable&lt;/code&gt;, as long as we declare &lt;code&gt;maxSpeed&lt;/code&gt; and &lt;code&gt;drive&lt;/code&gt; in &lt;code&gt;Bicycle&lt;/code&gt;.</source>
          <target state="translated">하위 클래스 나 &lt;code&gt;MotorVehicle&lt;/code&gt; 의 수퍼 클래스가 아니어야하는 또 다른 클래스 &lt;code&gt;Bicycle&lt;/code&gt; 을 소개 &lt;code&gt;Driveable&lt;/code&gt; , &lt;code&gt;maxSpeed&lt;/code&gt; 를 선언 하고 &lt;code&gt;Bicycle&lt;/code&gt; &lt;code&gt;drive&lt;/code&gt; 한 여전히 Driveable 을 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84ed0f9beb7f91564144926831adc67accd41344" translate="yes" xml:space="preserve">
          <source>If we're not using IntelliJ IDEA, we can configure the &lt;code&gt;pom.xml&lt;/code&gt; file manually to target JavaScript, by adding the following entries</source>
          <target state="translated">IntelliJ IDEA를 사용하지 않는 경우 다음 항목을 추가하여 JavaScript를 대상으로 &lt;code&gt;pom.xml&lt;/code&gt; 파일을 수동으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4acfe17479a9d138aec02a2b5400d83b9dbad62" translate="yes" xml:space="preserve">
          <source>If what the overriding function wants to do is an extension of what the overridden function did, you can call the overridden function via &lt;code&gt;super&lt;/code&gt; (either before, after, or between other code):</source>
          <target state="translated">재정의 함수가 수행하려는 작업이 재정의 된 함수의 확장 인 경우 &lt;code&gt;super&lt;/code&gt; 를 통해 (이전, 이후 또는 다른 코드간에) 재정의 된 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e616deeae977bea1b9ac2aaff006d6b429ca59f" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;https://developer.android.com/jetpack/compose/setup?hl=en&quot;&gt;enable Jetpack Compose&lt;/a&gt;, you will automatically be opted in to the new JVM backend without needing to specify the compiler option in &lt;code&gt;kotlinOptions&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/jetpack/compose/setup?hl=en&quot;&gt;Jetpack Compose&lt;/a&gt; 를 활성화 하면 &lt;code&gt;kotlinOptions&lt;/code&gt; 에서 컴파일러 옵션을 지정할 필요없이 자동으로 새 JVM 백엔드에 옵트 인 됩니다.</target>
        </trans-unit>
        <trans-unit id="d45490f38e7e6ac42b22f89099d8ed55b7cb4a46" translate="yes" xml:space="preserve">
          <source>If you agree, it will run migration code inspections that will check your code and suggest corrections for anything that doesn't work or that is not recommended in 1.4.0.</source>
          <target state="translated">동의하는 경우 마이그레이션 코드 검사를 실행하여 코드를 확인하고 작동하지 않거나 1.4.0에서 권장되지 않는 항목에 대한 수정을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="859a34cc0f1bc449ccdc83a5bb060605e6dcaa25" translate="yes" xml:space="preserve">
          <source>If you already &lt;strong&gt;have a Java project&lt;/strong&gt;, you can:</source>
          <target state="translated">이미 &lt;strong&gt;Java 프로젝트가있는&lt;/strong&gt; 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c93cd73e42edadff5832f929c0b9aee1adf9c114" translate="yes" xml:space="preserve">
          <source>If you already have an &lt;code&gt;Iterable&lt;/code&gt; object (such as a &lt;code&gt;List&lt;/code&gt; or a &lt;code&gt;Set&lt;/code&gt;), you can create a sequence from it by calling &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/as-sequence&quot;&gt;&lt;code&gt;asSequence()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; 객체 (예 : &lt;code&gt;List&lt;/code&gt; 또는 &lt;code&gt;Set&lt;/code&gt; ) 가 이미있는 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/as-sequence&quot;&gt; &lt;code&gt;asSequence()&lt;/code&gt; &lt;/a&gt; 를 호출하여 해당 객체 에서 시퀀스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc29b28eefcc5ecff8f112f0914c7751c0121584" translate="yes" xml:space="preserve">
          <source>If you already have the Java classes, you can just copy them to the project directories.</source>
          <target state="translated">Java 클래스가 이미있는 경우 프로젝트 디렉토리로 복사하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6b839b9469fa700514c4a020dc91dfcc6a1e8d21" translate="yes" xml:space="preserve">
          <source>If you are creating a library that will be consumed from JavaScript or a Node.js file, and want to use a different module system, the instructions are slightly different.</source>
          <target state="translated">JavaScript 또는 Node.js 파일에서 사용할 라이브러리를 만들고 다른 모듈 시스템을 사용하려는 경우 지침이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4e80a816776f6d15384568dae346e099a9c4bc29" translate="yes" xml:space="preserve">
          <source>If you are new to the JVM and Java, check out the &lt;a href=&quot;http://hadihariri.com/2013/12/29/jvm-minimal-survival-guide-for-the-dotnet-developer/&quot;&gt;JVM Minimal Survival Guide&lt;/a&gt;. If you are new to IntelliJ IDEA, check out the &lt;a href=&quot;http://hadihariri.com/2014/01/06/intellij-idea-minimal-survival-guide/&quot;&gt;The IntelliJ IDEA Minimal Survival Guide&lt;/a&gt;.</source>
          <target state="translated">JVM 및 Java를 처음 사용하는 경우 &lt;a href=&quot;http://hadihariri.com/2013/12/29/jvm-minimal-survival-guide-for-the-dotnet-developer/&quot;&gt;JVM 최소 생존 안내서를&lt;/a&gt; 확인하십시오 . IntelliJ IDEA를 처음 사용하는 경우 &lt;a href=&quot;http://hadihariri.com/2014/01/06/intellij-idea-minimal-survival-guide/&quot;&gt;IntelliJ IDEA 최소 생존 안내서를 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a098b59cc7c828b6cf7a7a722a6433f92888a1c" translate="yes" xml:space="preserve">
          <source>If you are using IntelliJ IDEA, start with &lt;a href=&quot;getting-started&quot;&gt;Getting Started&lt;/a&gt; and then work your way through the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA를 사용하는 경우 &lt;a href=&quot;getting-started&quot;&gt;시작하기&lt;/a&gt; 로 시작한 다음 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans를&lt;/a&gt; 통해 작업하십시오 .</target>
        </trans-unit>
        <trans-unit id="92c9f5001a0b1041d30c375e3f64079f5f4024cf" translate="yes" xml:space="preserve">
          <source>If you are using IntelliJ IDEA, start with &lt;a href=&quot;getting-started&quot;&gt;Getting Started&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA를 사용하는 경우 시작 &lt;a href=&quot;getting-started&quot;&gt;하기로 시작하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="288920b3c9422f077df54c1f4e25ceb3fa6051e0" translate="yes" xml:space="preserve">
          <source>If you are using the command line compiler, start with &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt; and then work your way through the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;;</source>
          <target state="translated">명령 행 컴파일러를 사용하는 경우 명령 행 컴파일러 &lt;a href=&quot;command-line&quot;&gt;작업으로&lt;/a&gt; 시작한 다음 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans를&lt;/a&gt; 통해 작업하십시오 .</target>
        </trans-unit>
        <trans-unit id="30938b7e8379a33204d1fef78a0ab9d4d4d9e21f" translate="yes" xml:space="preserve">
          <source>If you are writing an external declaration for a JavaScript function which has an optional parameter, use &lt;code&gt;definedExternally&lt;/code&gt;. This delegates the generation of the default values to the JavaScript function itself:</source>
          <target state="translated">선택적 매개 변수가있는 JavaScript 함수에 대한 외부 선언을 작성하는 경우 &lt;code&gt;definedExternally&lt;/code&gt; 를 사용 하십시오 . 이것은 기본값 생성을 JavaScript 함수 자체에 위임합니다.</target>
        </trans-unit>
        <trans-unit id="f2a50c48e84ca80688cd2b0e1b9297326e7b2f1d" translate="yes" xml:space="preserve">
          <source>If you build your module with Gradle, you can add arguments like this:</source>
          <target state="translated">Gradle로 모듈을 빌드하면 다음과 같은 인수를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3aa7d69244f58e95e8689b9c6402ed443bb559" translate="yes" xml:space="preserve">
          <source>If you consider all the APIs of your module experimental, you can mark the entire module as such with the compiler argument &lt;code&gt;-Xexperimental&lt;/code&gt; as described in &lt;a href=&quot;#module-wide-use&quot;&gt;Module-wide use&lt;/a&gt;.</source>
          <target state="translated">모듈의 모든 API를 실험적으로 &lt;a href=&quot;#module-wide-use&quot;&gt;사용하는 경우 모듈 전체 사용에&lt;/a&gt; 설명 된대로 컴파일러 인수 &lt;code&gt;-Xexperimental&lt;/code&gt; 을 사용 하여 전체 모듈을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e700eece24a382c6a466861314d880f1c63adba4" translate="yes" xml:space="preserve">
          <source>If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class.</source>
          <target state="translated">클래스의 팩토리 함수를 선언하는 경우 클래스 자체와 동일한 이름을 지정하지 마십시오. 팩토리 기능의 동작이 특별한 이유를 명확하게하는 고유 한 이름을 사용하는 것이 좋습니다. 실제로 특별한 의미가없는 경우에만 클래스와 동일한 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1ed8ae699e2f0e0c43725a76e755048bb606787" translate="yes" xml:space="preserve">
          <source>If you declare a standard library dependency explicitly (for example, if you need a different version), the Kotlin Gradle plugin won&amp;rsquo;t override it or add a second standard library.</source>
          <target state="translated">표준 라이브러리 종속성을 명시 적으로 선언하면 (예 : 다른 버전이 필요한 경우) Kotlin Gradle 플러그인이이를 재정의하거나 두 번째 표준 라이브러리를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a09dc2e7a857fda68536a28e258f8622ea168f72" translate="yes" xml:space="preserve">
          <source>If you declare your Kotlin code in a package, &lt;code&gt;main&lt;/code&gt; would be followed by a package definition part. For example, this goes after the &lt;code&gt;main&lt;/code&gt; declaration if you put your &lt;code&gt;main&lt;/code&gt; function in the &lt;code&gt;org.example.hellojs&lt;/code&gt; package:</source>
          <target state="translated">Kotlin 코드를 패키지에 선언하면 &lt;code&gt;main&lt;/code&gt; 다음에 패키지 정의 부분이옵니다. 예를 들어, &lt;code&gt;main&lt;/code&gt; 함수를 &lt;code&gt;org.example.hellojs&lt;/code&gt; 패키지 에 넣으면 &lt;code&gt;main&lt;/code&gt; 선언을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="9bc82014d1e005bd252c8fd44c4f86ea4b0260b5" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t use the Project Wizard to create your project, you can &lt;a href=&quot;using-gradle#set-dependencies-on-test-libraries&quot;&gt;add the dependencies manually&lt;/a&gt;.</source>
          <target state="translated">프로젝트 마법사를 사용하여 프로젝트를 생성하지 않은 경우 &lt;a href=&quot;using-gradle#set-dependencies-on-test-libraries&quot;&gt;종속성을 수동으로 추가&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9f4c0d0e98edca70ce37e016401b88c44c12e52" translate="yes" xml:space="preserve">
          <source>If you do not need a standard library at all, you can add the opt-out flag to the &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="translated">표준 라이브러리가 전혀 필요하지 않은 경우 &lt;code&gt;gradle.properties&lt;/code&gt; 에 옵트 아웃 플래그를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d0c772b88930f846f25631788c26caf89a248c8" translate="yes" xml:space="preserve">
          <source>If you do not specify any visibility modifier, &lt;code&gt;public&lt;/code&gt; is used by default, which means that your declarations will be visible everywhere;</source>
          <target state="translated">가시성 수정자를 지정하지 않으면 기본적으로 &lt;code&gt;public&lt;/code&gt; 이 사용됩니다. 즉, 선언이 모든 곳에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cadfb46ca63577b7ac5a59ea3e20f042f8a1e23b" translate="yes" xml:space="preserve">
          <source>If you don't care about the return value from the function, but you want to make one or more calls involving something that might be null and then keep on using that value, try &lt;code&gt;apply()&lt;/code&gt;, which returns the value it's called on. This is particularly useful if you want to work with many members of the object in question:</source>
          <target state="translated">함수의 반환 값에 신경 쓰지 않지만 null 일 수있는 무언가를 포함하는 하나 이상의 호출을 만들고 그 값을 계속 사용 &lt;code&gt;apply()&lt;/code&gt; 시도 하십시오.이 값은 호출 된 값을 반환합니다. 이는 해당 객체의 많은 멤버와 작업하려는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="25be6af74cab7ee5d3f6a46048e18b2c9c41852a" translate="yes" xml:space="preserve">
          <source>If you don't care about the return value, you don't need to assign it to anything.</source>
          <target state="translated">반환 값에 신경 쓰지 않으면 아무것도 할당하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="b5e43077cfafc57268582f5f13c46e3f8aaffa0e" translate="yes" xml:space="preserve">
          <source>If you don't have an instance of the class, you can get the class metadata with &lt;code&gt;String::class.java&lt;/code&gt; (but you can't invoke any of its members until you have an instance).</source>
          <target state="translated">클래스의 인스턴스가 없으면 &lt;code&gt;String::class.java&lt;/code&gt; 사용하여 클래스 메타 데이터를 얻을 수 있지만 인스턴스가있을 때까지 멤버를 호출 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef8266bd47e097890ef64d7166bd8dd100eb20ff" translate="yes" xml:space="preserve">
          <source>If you don't have any idea (or don't care) what the generic type might be, you can use a &lt;em&gt;star-projection&lt;/em&gt;:</source>
          <target state="translated">제네릭 형식이 무엇인지 전혀 모르거나 신경 쓰지 않으면 &lt;em&gt;별 투영을&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e3d1700eb36e84d61d0cc0f83792e108ac15508" translate="yes" xml:space="preserve">
          <source>If you don't need a variable in the destructuring declaration, you can place an underscore instead of its name:</source>
          <target state="translated">파괴 선언에 변수가 필요하지 않으면 이름 대신 밑줄을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22b00c7537a626ef39f32b96fa84adefd77db83f" translate="yes" xml:space="preserve">
          <source>If you don't specify a use-site target, the target is chosen according to the &lt;code&gt;@Target&lt;/code&gt; annotation of the annotation being used. If there are multiple applicable targets, the first applicable target from the following list is used:</source>
          <target state="translated">사용 사이트 대상을 지정하지 않으면 사용 중인 주석의 &lt;code&gt;@Target&lt;/code&gt; 주석 에 따라 대상이 선택 됩니다. 적용 가능한 대상이 여러 개인 경우 다음 목록의 첫 번째 적용 가능한 대상이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="311d02e910900437e250a96c50bd0e61d68e28d2" translate="yes" xml:space="preserve">
          <source>If you don't specify the minimum target version and a dependency Pod requires a higher deployment target, you may get an error.</source>
          <target state="translated">최소 대상 버전을 지정하지 않고 종속성 포드에 더 높은 배포 대상이 필요한 경우 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91ea08ad1a525edd6dec0bb4e202636f7932a646" translate="yes" xml:space="preserve">
          <source>If you don't use Gradle or Maven, make sure you have &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; in the classpath of your project. In other supported cases (IntelliJ IDEA projects, using command-line compiler or Ant), it is added by default. In command-line compiler and Ant, you can use &lt;code&gt;-no-reflect&lt;/code&gt; compiler option to exclude &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; from the classpath.</source>
          <target state="translated">Gradle 또는 Maven을 사용하지 않는 경우 프로젝트의 클래스 경로에 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 이 있는지 확인 하세요. 기타 지원되는 경우 (IntelliJ IDEA 프로젝트, 명령 줄 컴파일러 또는 Ant 사용)는 기본적으로 추가됩니다. 명령 줄 컴파일러 및 Ant에서 &lt;code&gt;-no-reflect&lt;/code&gt; 컴파일러 옵션을 사용 하여 클래스 경로에서 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 을 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="508516363f92e5f2f533651260b76217ec5964d8" translate="yes" xml:space="preserve">
          <source>If you don't use a SAM conversion, you will need to write code like this:</source>
          <target state="translated">SAM 변환을 사용하지 않는 경우 다음과 같은 코드를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3774ed57fc20d87b5d40f08286d6544810927195" translate="yes" xml:space="preserve">
          <source>If you don't want to annotate every usage of APIs that require opt-in, you can opt in to them for your whole module. To opt in to using an API in a module, compile it with the argument &lt;code&gt;-Xopt-in&lt;/code&gt;, specifying the fully qualified name of the opt-in requirement annotation of the API you use: &lt;code&gt;-Xopt-in=org.mylibrary.OptInAnnotation&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@OptIn(OptInAnnotation::class)&lt;/code&gt;.</source>
          <target state="translated">옵트 인이 필요한 모든 API 사용에 주석을 달고 싶지 않은 경우 전체 모듈에 대해 옵트 인 할 수 있습니다. 모듈에서 API 사용을 옵트 &lt;code&gt;-Xopt-in&lt;/code&gt; 려면 사용하는 API 의 옵트 인 요구 사항 주석의 완전한 이름을 지정하여 -Xopt-in 인수로 컴파일하십시오 . &lt;code&gt;-Xopt-in=org.mylibrary.OptInAnnotation&lt;/code&gt; . 이 인수로 컴파일하면 모듈의 모든 선언에 &lt;code&gt;@OptIn(OptInAnnotation::class)&lt;/code&gt; 주석이있는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fedc784120817cc87cdecd3df22bdeb6a5e4e0c" translate="yes" xml:space="preserve">
          <source>If you don't want to annotate every usage of experimental APIs in your code, you can accept the experimental status for your whole module. Module-wide use of experimental APIs can be propagating and non-propagating as well:</source>
          <target state="translated">코드에서 실험용 API의 모든 사용법에 주석을 달지 않으려면 전체 모듈에 대한 실험 상태를 수락 할 수 있습니다. 실험용 API를 모듈 전체에서 사용하면 전파 및 전파되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a0c51574e240459eda5d6b9335be253ee68042" translate="yes" xml:space="preserve">
          <source>If you find that an interface that you want a class to implement is already implemented by one of the properties of the class, you can &lt;em&gt;delegate&lt;/em&gt; the implementation of that interface to that property with &lt;code&gt;by&lt;/code&gt;:</source>
          <target state="translated">당신은 당신이 구현하는 클래스가 이미 클래스의 속성 중 하나에 의해 구현하고자하는 인터페이스, 당신은 할 수 찾아내는 경우에 &lt;em&gt;위임&lt;/em&gt; 하여 해당 속성에 해당 인터페이스의 구현을 &lt;code&gt;by&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8261f1da9a2137ff384a6fcdb0fdc9e9eb256bac" translate="yes" xml:space="preserve">
          <source>If you find the &lt;code&gt;this&lt;/code&gt; syntax to be confusing, you can use &lt;code&gt;also&lt;/code&gt; instead, which takes ordinary lambdas:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 구문이 혼동 되는 것을 발견하면 대신 일반적인 람다를 사용하는 대신 사용할 &lt;code&gt;also&lt;/code&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fec69f93ca0bc139456ed1755b8b6f4c32f1863" translate="yes" xml:space="preserve">
          <source>If you have a backend written in Kotlin, you can &lt;strong&gt;share common code&lt;/strong&gt; such as data models or validation logic with a frontend written in Kotlin/JS, allowing you to &lt;strong&gt;write and maintain full-stack web applications&lt;/strong&gt;.</source>
          <target state="translated">Kotlin으로 작성된 백엔드가있는 경우 데이터 모델 또는 유효성 검사 로직과 같은 &lt;strong&gt;공통 코드&lt;/strong&gt; 를 Kotlin / JS로 작성된 프런트 엔드와 공유하여 &lt;strong&gt;전체 스택 웹 애플리케이션&lt;/strong&gt; 을 &lt;strong&gt;작성하고 유지 관리&lt;/strong&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b72e9d9abf32110dc1b1cda54fc1754195041c56" translate="yes" xml:space="preserve">
          <source>If you have a collection of elements of a nullable type and want to filter non-null elements, you can do so by using &lt;code&gt;filterNotNull&lt;/code&gt;:</source>
          <target state="translated">널 입력 가능 유형의 요소 콜렉션이 있고 널이 아닌 요소를 필터링하려는 경우 &lt;code&gt;filterNotNull&lt;/code&gt; 을 사용하여 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3854a89fb1eb0d55d0045c79155df3bda3823777" translate="yes" xml:space="preserve">
          <source>If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it:</source>
          <target state="translated">코드베이스에서 여러 번 사용되는 기능 유형 또는 유형 매개 변수가있는 유형의 경우 유형 별명을 정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="160be5812cd4b3879f4656323f6abb0ca91c7f96" translate="yes" xml:space="preserve">
          <source>If you have a platform-specific library that you want to use in common code while providing your own implementation for another platform, you can provide a typealias to an existing class as the actual declaration:</source>
          <target state="translated">다른 플랫폼에 대한 자체 구현을 제공하면서 공통 코드에서 사용하려는 플랫폼 별 라이브러리가있는 경우 실제 선언으로 기존 클래스에 유형을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322a5539762befa5e3e19013d91d7e3d04d9849f" translate="yes" xml:space="preserve">
          <source>If you have a platform-specific library that you want to use in shared code while providing your own implementation for another platform, you can provide a &lt;code&gt;typealias&lt;/code&gt; to an existing class as the actual declaration:</source>
          <target state="translated">다른 플랫폼에 대한 자체 구현을 제공하면서 공유 코드에서 사용하려는 플랫폼 별 라이브러리가 있는 경우 실제 선언으로 기존 클래스에 &lt;code&gt;typealias&lt;/code&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6e93137d89d2551a056f737e4db196d1978cfc3" translate="yes" xml:space="preserve">
          <source>If you have a value that is truly constant, and the value is a string or a primitive type (see below) that is known at compile-time, you can declare an actual constant instead. You can only do this at the top level of a file or inside an &lt;a href=&quot;objects-and-companion-objects#object-declarations&quot;&gt;object declaration&lt;/a&gt; (but not inside a class declaration):</source>
          <target state="translated">진정으로 일정한 값이 있고 값이 컴파일 타임에 알려진 문자열 또는 기본 유형 (아래 참조) 인 경우 실제 상수를 대신 선언 할 수 있습니다. 파일의 최상위 레벨이나 &lt;a href=&quot;objects-and-companion-objects#object-declarations&quot;&gt;객체 선언&lt;/a&gt; 내부에서만 (클래스 선언 내부에서는 불가능) 이 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3734595028b6b703699f95d53623d869e9b5b43" translate="yes" xml:space="preserve">
          <source>If you have an account on &lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik&lt;/a&gt;, you can easily upload your course there, update it anytime you need, and &lt;a href=&quot;https://blog.jetbrains.com/pycharm/2017/06/integration-with-stepik-for-educators/&quot;&gt;share publicly or privately&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stepik.org/&quot;&gt;Stepik에&lt;/a&gt; 계정이있는 경우 코스를 쉽게 업로드하고 필요할 때 언제든지 업데이트 &lt;a href=&quot;https://blog.jetbrains.com/pycharm/2017/06/integration-with-stepik-for-educators/&quot;&gt;하고 공개 또는 비공개로 공유&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07988c0863287cce070542583bc572c93b997f2d" translate="yes" xml:space="preserve">
          <source>If you have an archive &lt;code&gt;sample-library.jar&lt;/code&gt;, which contains &lt;code&gt;sample-library.js&lt;/code&gt; and &lt;code&gt;sample-library.meta.js&lt;/code&gt;, you can use the following command</source>
          <target state="translated">&lt;code&gt;sample-library.js&lt;/code&gt; 및 &lt;code&gt;sample-library.meta.js&lt;/code&gt; 를 포함하는 &lt;code&gt;sample-library.jar&lt;/code&gt; 아카이브가있는 경우 다음 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca8fa744fdcf13cab8a2d83ad8ba290dd0853cd" translate="yes" xml:space="preserve">
          <source>If you have an instance of &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt;, and you want to refer to it as a &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt;, you can safely &lt;em&gt;get&lt;/em&gt; instances of the generic type parameter from it - these will truly be instances of &lt;code&gt;Subtype&lt;/code&gt; (because they come from an instance of &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt;), but they will appear to you as instances of &lt;code&gt;Supertype&lt;/code&gt; (because you've told the compiler that you have a &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt;). This is safe; it is called &lt;em&gt;covariance&lt;/em&gt;, and Kotlin lets you do &lt;em&gt;declaration-site covariance&lt;/em&gt; by putting &lt;code&gt;out&lt;/code&gt; in front of the generic type parameter. If you do, you may only use that type parameter as a return type, not as a parameter type. Here is the simplest useful covariant interface:</source>
          <target state="translated">&lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt; 의 인스턴스가 있고 이를 &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt; 으로 참조하려는 경우 GenericType 매개 변수의 인스턴스를 안전하게 &lt;em&gt;가져올&lt;/em&gt; 수 있습니다. 이것들은 실제로 &lt;code&gt;Subtype&lt;/code&gt; 의 인스턴스 일 것입니다. &lt;code&gt;Generic&amp;lt;Subtype&amp;gt;&lt;/code&gt; 의 인스턴스 )이지만 컴파일러에 &lt;code&gt;Generic&amp;lt;Supertype&amp;gt;&lt;/code&gt; 이 있다고 말했기 때문에 &lt;code&gt;Supertype&lt;/code&gt; 의 인스턴스로 표시됩니다 . 이것은 안전합니다. 그것은이라고 &lt;em&gt;공분산&lt;/em&gt; , 그리고 코 틀린 당신이 할 수 있습니다 &lt;em&gt;선언 사이트 공분산을&lt;/em&gt; 넣어 &lt;code&gt;out&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;제네릭 형식 매개 변수 앞에 그렇게하면 해당 유형 매개 변수 만 매개 변수 유형이 아닌 리턴 유형으로 사용할 수 있습니다. 가장 간단한 유용한 공변량 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76b81d78f8b362115f861d43270c94c40851a654" translate="yes" xml:space="preserve">
          <source>If you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions.</source>
          <target state="translated">다른 수퍼 클래스 생성자를 호출하지 않고 기본 인수 값을 가진 단일 생성자로 줄일 수없는 여러 오버로드 생성자가있는 객체가있는 경우 오버로드 된 생성자를 팩토리 함수로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="70df85ffca23dcd7199954503a1af44f76e8932e" translate="yes" xml:space="preserve">
          <source>If you have business logic that is common for all platforms, you don&amp;rsquo;t need to write the same code for each platform &amp;ndash; just share it in the common source set.</source>
          <target state="translated">모든 플랫폼에 공통적 인 비즈니스 로직이있는 경우 각 플랫폼에 대해 동일한 코드를 작성할 필요가 없습니다. 공통 소스 세트에서 공유하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="639c565d65e0763691e2c7a9e8d90030330f0cc8" translate="yes" xml:space="preserve">
          <source>If you have explicitly set your module kind to be &lt;code&gt;plain&lt;/code&gt;, Kotlin creates an object that contains all Kotlin declarations from the current module. This is done to prevent spoiling the global object. This means that for a module &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via the &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">모듈 종류를 &lt;code&gt;plain&lt;/code&gt; 로 명시 적으로 설정 한 경우 Kotlin은 현재 모듈의 모든 Kotlin 선언을 포함하는 객체를 만듭니다. 이것은 전역 개체가 손상되는 것을 방지하기 위해 수행됩니다. 이는 &lt;code&gt;myModule&lt;/code&gt; 모듈의 경우 &lt;code&gt;myModule&lt;/code&gt; 객체 를 통해 JavaScript에서 모든 선언을 사용할 수 있음을 의미 합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c8853dee9818f39e3759ffe7b639b9f7bc068972" translate="yes" xml:space="preserve">
          <source>If you have multiple annotations with the same target, you can avoid repeating the target by adding brackets after the target and putting all the annotations inside the brackets:</source>
          <target state="translated">동일한 대상에 여러 주석이있는 경우 대상 뒤에 괄호를 추가하고 모든 주석을 괄호 안에 넣어서 대상을 반복하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4458460acc96ecaa2c9621b4261e57a18ecc54c" translate="yes" xml:space="preserve">
          <source>If you insist on using a plain editor and the command line, see &lt;a href=&quot;../command-line&quot;&gt;these instructions instead&lt;/a&gt;. In short, you need to &lt;em&gt;compile&lt;/em&gt; your Kotlin code before running it. Assuming that your Kotlin file is called &lt;code&gt;program.kt&lt;/code&gt;:</source>
          <target state="translated">일반 편집기 및 명령 행 사용을 주장하는 경우 &lt;a href=&quot;../command-line&quot;&gt;대신이 지시 사항을&lt;/a&gt; 참조하십시오 . 요컨대, Kotlin 코드를 실행하기 전에 &lt;em&gt;컴파일&lt;/em&gt; 해야합니다. Kotlin 파일이 &lt;code&gt;program.kt&lt;/code&gt; 라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2b7c0495898685e9252662cc7dfb4430876f43" translate="yes" xml:space="preserve">
          <source>If you intend to use the APIs from the 1.1 Standard Library, or language features that depend on those APIs, you should upgrade the dependency to the version 1.1.</source>
          <target state="translated">1.1 표준 라이브러리의 API 또는 해당 API에 의존하는 언어 기능을 사용하려는 경우 종속성을 버전 1.1로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="9dac576da363f8811fb3df384398b7619989e0f8" translate="yes" xml:space="preserve">
          <source>If you like a &amp;ldquo;hands-on&amp;rdquo; learning, try &lt;a href=&quot;https://play.kotlinlang.org/koans&quot;&gt;Kotlin Koans online&lt;/a&gt; to get familiar with Kotlin;</source>
          <target state="translated">&quot;실습&quot;학습을 좋아하는 경우 &lt;a href=&quot;https://play.kotlinlang.org/koans&quot;&gt;Kotlin Koans 온라인&lt;/a&gt; 을 통해 Kotlin에 익숙해 지십시오.</target>
        </trans-unit>
        <trans-unit id="d82ca3a290ad528cc2bae1e2cb08d2ecdafea630" translate="yes" xml:space="preserve">
          <source>If you mark a declaration &lt;code&gt;private&lt;/code&gt;, it will only be visible inside the file containing the declaration;</source>
          <target state="translated">선언을 &lt;code&gt;private&lt;/code&gt; 로 표시하면 선언이 포함 된 파일 내에서만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b38ef20d54a5b26492d65004e55d4d4d8807d1f" translate="yes" xml:space="preserve">
          <source>If you mark it &lt;code&gt;internal&lt;/code&gt;, it is visible everywhere in the same &lt;a href=&quot;#modules&quot;&gt;module&lt;/a&gt;;</source>
          <target state="translated">당신이 그것을 표시하면 &lt;code&gt;internal&lt;/code&gt; , 같은 도처 볼 &lt;a href=&quot;#modules&quot;&gt;모듈&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="23d6510bb7782c43d563dd375dee713e5d305e0b" translate="yes" xml:space="preserve">
          <source>If you need a &lt;em&gt;singleton&lt;/em&gt; - a class that only has got one instance - you can declare the class in the usual way, but use the &lt;code&gt;object&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">인스턴스가 하나 뿐인 클래스 인 &lt;em&gt;싱글 톤&lt;/em&gt; 이 필요한 경우 일반적인 방법으로 클래스를 선언 할 수 있지만 &lt;code&gt;class&lt;/code&gt; 대신 &lt;code&gt;object&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a043b2872924b750f016ebe9ba4d0f3aca66ca85" translate="yes" xml:space="preserve">
          <source>If you need a dependency only for a specific platform, you can still use platform-specific variants of standard and kotlinx libraries with such suffixes as &lt;code&gt;-jvm&lt;/code&gt; or&lt;code&gt; -js&lt;/code&gt;, for example &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;.</source>
          <target state="translated">특정 플랫폼에 대해서만 종속성이 필요한 경우 &lt;code&gt;-jvm&lt;/code&gt; 또는 &lt;code&gt; -js&lt;/code&gt; 와 같은 접미사가있는 표준 및 kotlinx 라이브러리의 플랫폼 별 변형 ( 예 : &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; )을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc8467398b87bfa40771e50f53a8a177a25657b1" translate="yes" xml:space="preserve">
          <source>If you need a fancier way of reading or writing file data, you have access to the full Java suite of I/O classes - in particular, &lt;code&gt;Scanner&lt;/code&gt;, which can parse numbers and other data types from files or other streams, and &lt;code&gt;BufferedReader&lt;/code&gt; (which is good for efficient reading of large amounts of data), which you can obtain by calling &lt;code&gt;bufferedReader()&lt;/code&gt; on a file or stream. See any Java tutorial for how to use these.</source>
          <target state="translated">당신은 파일 데이터를 읽거나 쓰는 애호가 방법이 필요하면 I / O 클래스의 전체 Java 제품군에 액세스 할 수 - 특히, &lt;code&gt;Scanner&lt;/code&gt; , 파일이나 다른 스트림과에서 번호 및 기타 데이터 유형을 분석 할 수있는 &lt;code&gt;BufferedReader&lt;/code&gt; 로를 (이 파일이나 스트림에서 &lt;code&gt;bufferedReader()&lt;/code&gt; 를 호출하여 얻을 수있는 대량의 데이터를 효율적으로 읽는 데 유용 합니다. 이를 사용하는 방법에 대한 Java 자습서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f682f64379a16ca3dc7552b97dee19da35ecf1f" translate="yes" xml:space="preserve">
          <source>If you need a full report containing the state of each coroutine and its stack, right-click inside the &lt;strong&gt;Coroutines&lt;/strong&gt; tab, and then click &lt;strong&gt;Get Coroutines Dump&lt;/strong&gt;. Currently, the coroutines dump is rather simple, but we&amp;rsquo;re going to make it more readable and helpful in future versions of Kotlin.</source>
          <target state="translated">각 코 루틴과 스택의 상태를 포함하는 전체 보고서를 필요로하는 경우, 내부 마우스 오른쪽 단추로 클릭 &lt;strong&gt;코 루틴&lt;/strong&gt; 탭을 클릭 한 다음 &lt;strong&gt;가져 오기 코 루틴 덤프&lt;/strong&gt; . 현재 코 루틴 덤프는 다소 간단하지만 향후 Kotlin 버전에서 더 읽기 쉽고 유용 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="54e87845252769ababaaab1c06f5bd872659abd6" translate="yes" xml:space="preserve">
          <source>If you need a function or a property to be tied to a class rather than to instances of it (similar to &lt;code&gt;@staticmethod&lt;/code&gt; in Python), you can declare it inside a &lt;em&gt;companion object&lt;/em&gt;:</source>
          <target state="translated">함수 또는 속성을 인스턴스가 아닌 클래스에 묶어야하는 경우 ( Python의 &lt;code&gt;@staticmethod&lt;/code&gt; 와 유사 ) &lt;em&gt;동반자 객체&lt;/em&gt; 내에서 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8de1431e2a233483ba705c03102c9221f4f2f632" translate="yes" xml:space="preserve">
          <source>If you need multiple ways to initialize a class, you can create &lt;em&gt;secondary constructors&lt;/em&gt;, each of which looks like a function whose name is &lt;code&gt;constructor&lt;/code&gt;. Every secondary constructor must invoke another (primary or secondary) constructor by using the &lt;code&gt;this&lt;/code&gt; keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</source>
          <target state="translated">클래스를 초기화하는 여러 방법이 필요한 경우 &lt;em&gt;보조 생성자를&lt;/em&gt; 만들 수 있습니다 . 각 &lt;em&gt;생성자&lt;/em&gt; 는 이름이 &lt;code&gt;constructor&lt;/code&gt; 인 함수처럼 보입니다 . 모든 2 차 생성자는 &lt;code&gt;this&lt;/code&gt; 키워드를 함수 인 것처럼 사용하여 다른 (1 차 또는 2 차) 생성자를 호출해야합니다 (따라서 모든 인스턴스 구성은 결국 1 차 생성자를 호출합니다).</target>
        </trans-unit>
        <trans-unit id="e23221640befe2f0b60d6c58ea9b02d7e3a97b07" translate="yes" xml:space="preserve">
          <source>If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the &lt;code&gt;external&lt;/code&gt; modifier. (In Kotlin 1.0, the &lt;code&gt;@native&lt;/code&gt; annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM &lt;code&gt;Node&lt;/code&gt; class:</source>
          <target state="translated">타입 안전 방식으로 Kotlin에서 JavaScript로 구현 된 클래스에 액세스해야하는 경우 &lt;code&gt;external&lt;/code&gt; 수정자를 사용하여 Kotlin 선언을 작성할 수 있습니다 . (Kotlin 1.0에서는 &lt;code&gt;@native&lt;/code&gt; 주석이 대신 사용되었습니다.) JVM 대상과 달리 JS는 클래스 및 속성과 함께 외부 수정자를 사용할 수 있습니다. 예를 들어 DOM &lt;code&gt;Node&lt;/code&gt; 클래스를 선언하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88668422727a4a9adc62e3d3eeac4b8edf7e7d30" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from a shared native source set, IntelliJ IDEA will help you detect common declarations that you can use in the shared native code. For other cases, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">공유 네이티브 소스 세트에서 플랫폼 별 API에 액세스해야하는 경우 IntelliJ IDEA는 공유 네이티브 코드에서 사용할 수있는 공통 선언을 감지하는 데 도움이됩니다. 다른 경우에는 &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;예상 및 실제 선언&lt;/a&gt; 의 Kotlin 메커니즘을 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="f99443af480d55217c4ce0d28159d54e4f7cf72b" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from the shared code, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">공유 코드에서 플랫폼 별 API에 액세스해야하는 경우 &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;예상 및 실제 선언&lt;/a&gt; 의 Kotlin 메커니즘을 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="d4e8082dbfdacd1170b034e190a7f81841b9039b" translate="yes" xml:space="preserve">
          <source>If you need to annotate the primary constructor of a class, you need to add the &lt;em&gt;constructor&lt;/em&gt; keyword to the constructor declaration, and add the annotations before it:</source>
          <target state="translated">클래스의 기본 생성자에 주석을 달아야하는 경우 생성자 선언에 &lt;em&gt;생성자&lt;/em&gt; 키워드를 추가하고 그 앞에 주석을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e462275c07255513e75672de08e598bdce5e271f" translate="yes" xml:space="preserve">
          <source>If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:</source>
          <target state="translated">접근 자의 가시성을 변경하거나 주석을 달아야하지만 기본 구현을 변경할 필요가없는 경우 본문을 정의하지 않고 접근자를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3059f730cef9912ce6c198f14d3446e4eb2b9509" translate="yes" xml:space="preserve">
          <source>If you need to compile something other than production code and unit tests, for example, integration or performance tests, create a custom compilation.</source>
          <target state="translated">통합 또는 성능 테스트와 같이 프로덕션 코드 및 단위 테스트 이외의 것을 컴파일해야하는 경우 사용자 지정 컴파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a9bce9b39aad7abcf18408f893ff0de2f69a4bc8" translate="yes" xml:space="preserve">
          <source>If you need to compile something other than production code and unit tests, for example, integration or performance tests, you can &lt;a href=&quot;#create-a-custom-compilation&quot;&gt;create a custom compilation&lt;/a&gt;.</source>
          <target state="translated">통합 또는 성능 테스트와 같이 프로덕션 코드 및 단위 테스트 이외의 것을 컴파일해야하는 경우 &lt;a href=&quot;#create-a-custom-compilation&quot;&gt;사용자 지정 컴파일을 만들&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4613a8244834c0ecb89ce0d825ca742a6fa51707" translate="yes" xml:space="preserve">
          <source>If you need to expose a Kotlin property as a field in Java, annotate it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt;&lt;code&gt;@JvmField&lt;/code&gt;&lt;/a&gt; annotation. The field will have the same visibility as the underlying property. You can annotate a property with &lt;code&gt;@JvmField&lt;/code&gt; if it has a backing field, is not private, does not have &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; modifiers, and is not a delegated property.</source>
          <target state="translated">Java에서 Kotlin 특성을 필드로 노출해야하는 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt; &lt;code&gt;@JvmField&lt;/code&gt; &lt;/a&gt; 어노테이션으로 주석을 답니다 . 필드는 기본 속성과 동일한 가시성을 갖습니다. 지원 필드가 있고 개인 필드가 아니고 &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;override&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 한정 자가없고 위임 된 속성이 아닌 경우 &lt;code&gt;@JvmField&lt;/code&gt; 로 속성에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3648463615f31d33dec14dff446661a5d42afc8" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating over something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">무언가를 반복 할 때 현재 요소의 인덱스를 알아야한다면 &lt;code&gt;enumerate()&lt;/code&gt; 해당하는 &lt;code&gt;withIndex()&lt;/code&gt; 사용할 수 있습니다 . 두 개의 속성 (인덱스 및 값)과 &lt;code&gt;component1()&lt;/code&gt; 및 &lt;code&gt;component2()&lt;/code&gt; 라는 두 개의 특수하게 명명 된 접근 자 함수를 갖는 일련의 객체를 생성합니다 . Kotlin을 사용하면 이러한 객체를 선언으로 분해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89e90e48358e19dcdf7d70c38acd3455ecae2039" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating through something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">무언가를 반복 할 때 현재 요소의 색인을 알아야하는 경우 &lt;code&gt;enumerate()&lt;/code&gt; 해당하는 &lt;code&gt;withIndex()&lt;/code&gt; 사용할 수 있습니다 . 두 개의 속성 (인덱스 및 값)과 &lt;code&gt;component1()&lt;/code&gt; 및 &lt;code&gt;component2()&lt;/code&gt; 라는 특수하게 명명 된 두 가지 접근 자 함수를 가진 일련의 객체를 생성합니다 . Kotlin을 사용하면 이러한 객체를 선언으로 구조화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c304182ad4dffb827b2cd5041835d4a1290ba5c" translate="yes" xml:space="preserve">
          <source>If you need to look up the class dynamically as well, you can use &lt;code&gt;Class.forName()&lt;/code&gt; and supply the fully-qualified name of the class.</source>
          <target state="translated">클래스를 동적으로 조회해야하는 경우 &lt;code&gt;Class.forName()&lt;/code&gt; 사용 하고 클래스의 완전한 이름을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb05e76a6c128f62bf211b270ee1f300cbc3d9aa" translate="yes" xml:space="preserve">
          <source>If you need to retrieve an arbitrary element of a collection, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; function. You can call it without arguments or with a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; object as a source of the randomness.</source>
          <target state="translated">컬렉션의 임의의 요소를 검색해야하는 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt; 의 소스로 인수없이 또는 Random 개체를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c6c6ff6a76abad65e2d1d67dae2bda5a0418cb0" translate="yes" xml:space="preserve">
          <source>If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;&lt;code&gt;joinToString()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt;&lt;code&gt;joinTo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컬렉션 내용을 읽을 수있는 형식으로 검색해야하는 경우 컬렉션을 문자열로 변환하는 함수 인 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt; &lt;code&gt;joinToString()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt; &lt;code&gt;joinTo()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27633af274eff8d8c59fb2e4a25231c59018307c" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</source>
          <target state="translated">주석의 인수로 클래스를 지정해야하는 경우 Kotlin 클래스 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; )를 사용하세요. Kotlin 컴파일러는이를 자바 클래스로 자동 변환하므로 자바 코드가 주석과 인수에 정상적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="993106f4a5b27e1d574e1151066452d4ad416447" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments normally.</source>
          <target state="translated">클래스를 주석의 인수로 지정해야하는 경우 Kotlin 클래스 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; )를 사용하십시오. Kotlin 컴파일러는이를 자동으로 Java 클래스로 변환하므로 Java 코드가 주석 및 인수를 정상적으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7448bb25e266494ddde684c5929327a96a8fb964" translate="yes" xml:space="preserve">
          <source>If you need to use a nullable &lt;code&gt;Boolean&lt;/code&gt; in a conditional statement, use &lt;code&gt;if (value == true)&lt;/code&gt; or &lt;code&gt;if (value == false)&lt;/code&gt; checks.</source>
          <target state="translated">조건문에 널 입력 가능 &lt;code&gt;Boolean&lt;/code&gt; 을 사용해야하는 &lt;code&gt;if (value == true)&lt;/code&gt; 또는 &lt;code&gt;if (value == false)&lt;/code&gt; 검사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c201a6c8803ec9d0564e44a48fc6ef8489585c2" translate="yes" xml:space="preserve">
          <source>If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an &lt;a href=&quot;object-declarations&quot;&gt;object declaration&lt;/a&gt; inside that class.</source>
          <target state="translated">클래스 인스턴스없이 호출 할 수 있지만 클래스의 내부 (예 : 팩토리 메서드)에 액세스해야하는 함수를 작성해야하는 경우 해당 클래스 내 에서 &lt;a href=&quot;object-declarations&quot;&gt;객체 선언&lt;/a&gt; 의 멤버로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f584df433485780683ca571ae5a89e659948c6b" translate="yes" xml:space="preserve">
          <source>If you only want to call the function and don't care about the metadata, use a function type, e.g. &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; for an ordinary function reference or a bound member function reference, or &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; for an unbound member function reference on &lt;code&gt;A&lt;/code&gt;. Note that &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; and its subinterfaces are only available for declared functions (obtained either by explicitly referencing it in the code, or through reflection, as shown later) - only function types are available for function literals (lambda expressions or anonymous functions).</source>
          <target state="translated">함수 만 호출하고 메타 데이터에 신경 쓰지 않으 려면 일반 함수 참조 또는 바운드 멤버 함수 참조에 대해 &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; 또는 A와 같은 함수 유형을 사용하십시오 &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; 에 결합되지 않은 멤버 함수 참조 . 참고 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; (이후에 도시 된 바와 같이, 명시 적 코드를 참조하여 어느 수득하거나 반사를 통해) 그 서브 선언 기능 만 사용할 - 전용 기능 유형 함수 리터럴 (람다 식 또는 익명 함수)에 사용할 수있는 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8014e84399844604d4127e5bfb102e3054b9b7f6" translate="yes" xml:space="preserve">
          <source>If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful.</source>
          <target state="translated">중첩 컬렉션을 운영하는 경우 중첩 컬렉션 요소에 대한 평평한 액세스를 제공하는 표준 라이브러리 함수가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8d397c2c2050d55c50d82eec1a501b49617481" translate="yes" xml:space="preserve">
          <source>If you override a &lt;code&gt;protected&lt;/code&gt; member and do not specify the visibility explicitly, the overriding member will also have &lt;code&gt;protected&lt;/code&gt; visibility.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 멤버 를 재정의 하고 가시성을 명시 적으로 지정하지 않으면 재정의 멤버도 &lt;code&gt;protected&lt;/code&gt; 가시성을 갖게 됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd8f947a24ab8c99f576a413b868a14fd70348dc" translate="yes" xml:space="preserve">
          <source>If you previously used the &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android support&lt;/a&gt; for annotation processors, replace usages of the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration with &lt;code&gt;kapt&lt;/code&gt;. If your project contains Java classes, &lt;code&gt;kapt&lt;/code&gt; will also take care of them.</source>
          <target state="translated">이전 에 주석 프로세서에 대한 &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android 지원&lt;/a&gt; 을 사용한 경우 &lt;code&gt;annotationProcessor&lt;/code&gt; 구성 사용법을 &lt;code&gt;kapt&lt;/code&gt; 로 바꾸 십시오 . 프로젝트에 Java 클래스가 포함 된 경우 &lt;code&gt;kapt&lt;/code&gt; 도이를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="94aa78de26a564fc468e55c702b46b061a65c43e" translate="yes" xml:space="preserve">
          <source>If you publish multiple independent features that require opt-in, declare an annotation for each. This makes the use of API safer for your clients: they can use only the features that they explicitly accept. This also lets you remove the opt-in requirements from the features independently.</source>
          <target state="translated">선택이 필요한 여러 독립 기능을 게시하는 경우 각각에 대한 주석을 선언하십시오. 이렇게하면 클라이언트가 API를 더 안전하게 사용할 수 있습니다. 클라이언트는 명시 적으로 허용하는 기능 만 사용할 수 있습니다. 또한 기능에서 독립적으로 옵트 인 요구 사항을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3126f475d393c0188e7088d866ab3c517a722979" translate="yes" xml:space="preserve">
          <source>If you publish several features in the experimental state, declare a marker for each. Separate markers make the use of experimental features safer for your clients: they'll be able to use only the features that they explicitly accept. This also lets you graduate the features to stable independently.</source>
          <target state="translated">실험 상태에서 여러 기능을 게시하는 경우 각각에 대한 마커를 선언하십시오. 별도의 마커를 사용하면 고객에게 실험 기능을보다 안전하게 사용할 수 있습니다. 고객은 명시 적으로 허용하는 기능 만 사용할 수 있습니다. 또한 기능을 독립적으로 안정화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df8a586d7260c254feebf62ecf6abe57e497a3fe" translate="yes" xml:space="preserve">
          <source>If you really really need a mixed-type collection, you can use the element type &lt;code&gt;Any&lt;/code&gt; - but you'll need typecasting to get the elements back to their proper type again, so if what you want is a multiple-value return from a function, please use the per-element-typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Triple&lt;/code&gt; instead. If you need four or more elements, consider making a &lt;a href=&quot;classes#data-classes&quot;&gt;data class&lt;/a&gt; for the return type instead (which you should ideally do for two or three elements as well, especially if it's a public function, since it gives you proper names for the elements) - it's very easy and usually a oneliner.</source>
          <target state="translated">실제로 혼합 유형 컬렉션이 필요한 경우 요소 유형 &lt;code&gt;Any&lt;/code&gt; 를 사용할 수 있지만 요소를 올바른 유형으로 다시 가져 오려면 유형 캐스팅이 필요하므로 원하는 경우 함수에서 다중 값 반환이 필요합니다 대신 요소 별 유형의 &lt;code&gt;Pair&lt;/code&gt; 또는 &lt;code&gt;Triple&lt;/code&gt; 사용하십시오. 네 개 이상의 요소가 필요한 경우 대신 반환 유형에 대한 &lt;a href=&quot;classes#data-classes&quot;&gt;데이터 클래스&lt;/a&gt; 를 만드는 것이 좋습니다 (특히 두 개 또는 세 개의 요소, 특히 공용 함수 인 경우 요소의 적절한 이름을 제공하므로). 매우 쉽고 일반적으로 oneliner입니다.</target>
        </trans-unit>
        <trans-unit id="cbc8324a9f6502600707b1d372c5b0e01758d5e6" translate="yes" xml:space="preserve">
          <source>If you really want to, you can both initialize and specify the type on the same line. This is mostly useful if you're dealing with a class hierarchy (more on that later) and you want the variable type to be a base type of the value's class:</source>
          <target state="translated">실제로 원하는 경우 동일한 줄에서 유형을 초기화하고 지정할 수 있습니다. 이것은 클래스 계층 구조를 처리하고 (나중에 자세히 설명 할 때) 변수 유형이 값 클래스의 기본 유형이되기를 원하는 경우에 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c6599b66c1550e4e193ba560f565b728a822797c" translate="yes" xml:space="preserve">
          <source>If you run a command-line compiler, add the compiler arguments directly to the utility call or write them into an &lt;a href=&quot;#argfile&quot;&gt;argfile&lt;/a&gt;. For example:</source>
          <target state="translated">명령 줄 컴파일러를 실행하는 경우 컴파일러 인수를 유틸리티 호출에 직접 추가하거나 &lt;a href=&quot;#argfile&quot;&gt;argfile에&lt;/a&gt; 씁니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="13648197906f478e28c0bcf3383cb817c3e322b6" translate="yes" xml:space="preserve">
          <source>If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</source>
          <target state="translated">위의 코드를 실행하면 항상 0이 출력되는 것은 아니지만 머신의 타이밍에 따라 달라질 수 있지만 실제로 0이 아닌 값을 보려면이 예제에서 타임 아웃을 조정해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3a00df64d22ebf69e57bb704a9d62539a93298" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; by &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 &lt;code&gt;thread&lt;/code&gt; 로 교체하여 시작 하면 컴파일러에서 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1244c242be7001db0fa42d5a34807cd464a4c723" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; with &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 &lt;code&gt;thread&lt;/code&gt; 로 바꾸는 것으로 시작 하면 컴파일러에서 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="589b4c81823f6922542c45e2902c148531d2b494" translate="yes" xml:space="preserve">
          <source>If you target JavaScript, use the &lt;code&gt;stdlib-js&lt;/code&gt; dependency.</source>
          <target state="translated">JavaScript를 대상으로하는 경우 &lt;code&gt;stdlib-js&lt;/code&gt; 종속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf587872264afbd1369b320aaae73dd1b3673d1b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;enable caching for them manually&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt; 를 사용 하는 경우 kapt 주석 처리 작업은 기본적으로 캐시되지 않습니다. 그러나 &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;수동으로 캐싱을 활성화&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39efa722c74de834ad1bd8a4e4c201bd7dac494b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can enable caching for them manually. See the &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt page&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt; 를 사용하는 경우 , kapt 주석 처리 태스크는 기본적으로 캐시되지 않습니다. 그러나 수동으로 캐싱을 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a73c7aeee6bdc5c7806d3e53e9294fc8ac4610bf" translate="yes" xml:space="preserve">
          <source>If you use Spring, you can enable the &lt;em&gt;kotlin-spring&lt;/em&gt; compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way.</source>
          <target state="translated">Spring을 사용 하는 경우 Spring 주석을 수동으로 지정하는 대신 &lt;em&gt;kotlin-spring&lt;/em&gt; 컴파일러 플러그인 을 사용할 수 있습니다. kotlin-spring은 완전 개방형 위에있는 래퍼이며 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="611d8f619bf7a7948c981fe9d16f096526d50981" translate="yes" xml:space="preserve">
          <source>If you use a kotlinx library and need a platform-specific dependency, you can use platform-specific variants of libraries with suffixes such as &lt;code&gt;-jvm&lt;/code&gt; or &lt;code&gt;-js&lt;/code&gt;, for example, &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;. You can also use the library base artifact name instead &amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt;.</source>
          <target state="translated">kotlinx 라이브러리를 사용하고 플랫폼 별 종속성이 필요한 경우 &lt;code&gt;-jvm&lt;/code&gt; 또는 &lt;code&gt;-js&lt;/code&gt; 와 같은 접미사가있는 플랫폼 별 라이브러리 변형을 사용할 수 있습니다 ( 예 : &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; ) . 대신 라이브러리 기본 아티팩트 이름 인 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7efa55746211a1f8112a9a60777f3c462da2efbd" translate="yes" xml:space="preserve">
          <source>If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library base artifact name, such as &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; or &lt;code&gt;ktor-client-core&lt;/code&gt;.</source>
          <target state="translated">다중 플랫폼 라이브러리를 사용하고 공유 코드에 의존해야하는 경우 공유 소스 세트에서 종속성을 한 번만 설정하십시오. &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 또는 &lt;code&gt;ktor-client-core&lt;/code&gt; 와 같은 라이브러리 기본 아티팩트 이름을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bce77e8c93a7ca161789d86b2fef454e9ed0e0f" translate="yes" xml:space="preserve">
          <source>If you use annotation processors for your &lt;code&gt;androidTest&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; sources, the respective &lt;code&gt;kapt&lt;/code&gt; configurations are named &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt;. Note that &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt; extends &lt;code&gt;kapt&lt;/code&gt;, so you can just provide the &lt;code&gt;kapt&lt;/code&gt; dependency and it will be available both for production sources and tests.</source>
          <target state="translated">&lt;code&gt;androidTest&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 소스에 주석 프로세서를 사용하는 경우 해당 &lt;code&gt;kapt&lt;/code&gt; 구성의 이름은 &lt;code&gt;kaptAndroidTest&lt;/code&gt; 및 &lt;code&gt;kaptTest&lt;/code&gt; 입니다. 참고 것을 &lt;code&gt;kaptAndroidTest&lt;/code&gt; 및 &lt;code&gt;kaptTest&lt;/code&gt; 는 확장 &lt;code&gt;kapt&lt;/code&gt; 를 그냥 제공 할 수 있도록, &lt;code&gt;kapt&lt;/code&gt; 의 의존성을하고 생산 소스와 테스트를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e98efb35675e1c9619917853c6319e94bee5daa4" translate="yes" xml:space="preserve">
          <source>If you use libraries published with metadata, you only have to specify dependencies on them only once in the shared source set, as opposed to specifying dependencies on different variants of the same library in the shared and platform-specific source sets prior to 1.4.0.</source>
          <target state="translated">메타 데이터와 함께 게시 된 라이브러리를 사용하는 경우 1.4.0 이전의 공유 및 플랫폼 별 소스 세트에서 동일한 라이브러리의 다른 변형에 대한 종속성을 지정하는 것과는 반대로 공유 소스 세트에서 종속성을 한 번만 지정하면됩니다. .</target>
        </trans-unit>
        <trans-unit id="33f8dde1a7f866c06f2a153c28219ec09cc0d77e" translate="yes" xml:space="preserve">
          <source>If you use opt-in requirements for features that are not stable yet, carefully handle the API graduation to avoid breaking the client code.</source>
          <target state="translated">아직 안정적이지 않은 기능에 대한 옵트 인 요구 사항을 사용하는 경우 API 등급을 신중하게 처리하여 클라이언트 코드가 손상되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="8e5fa9bba802b4996dceed857e221c7dc79c3552" translate="yes" xml:space="preserve">
          <source>If you use the NV Kotlin compiler and have the OV standard library or the OV reflection library in the classpath, it can be a sign that the project is misconfigured. To prevent unexpected problems during compilation or at runtime, we suggest either updating the dependencies to NV, or specifying the API version / language version arguments explicitly. Otherwise the compiler detects that something can go wrong and reports a warning.</source>
          <target state="translated">NV Kotlin 컴파일러를 사용하고 클래스 경로에 OV 표준 라이브러리 또는 OV 리플렉션 라이브러리가있는 경우 프로젝트가 잘못 구성되었다는 신호일 수 있습니다. 컴파일 중 또는 런타임에 예기치 않은 문제를 방지하려면 종속성을 NV로 업데이트하거나 API 버전 / 언어 버전 인수를 명시 적으로 지정하는 것이 좋습니다. 그렇지 않으면 컴파일러는 무언가 잘못 될 수 있음을 감지하고 경고를보고합니다.</target>
        </trans-unit>
        <trans-unit id="f69388ccfa9be1025c7351e156b510d0110f1b95" translate="yes" xml:space="preserve">
          <source>If you want a literal &lt;code&gt;$&lt;/code&gt;, you need to escape it: &lt;code&gt;\$&lt;/code&gt;. Escaping generally works the same way as in Python, with a similar set of standard escape sequences.</source>
          <target state="translated">리터럴 &lt;code&gt;$&lt;/code&gt; 를 원하면 이스케이프해야합니다 : &lt;code&gt;\$&lt;/code&gt; . 이스케이프 처리는 일반적으로 유사한 표준 이스케이프 시퀀스 세트를 사용하여 Python과 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="542e15c450e9d7499e5b8e3fd1eff9a8b7386f93" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;start from scratch&lt;/strong&gt;, you can &lt;a href=&quot;jvm-get-started&quot;&gt;create a basic Kotlin application&lt;/a&gt;. Once you&amp;rsquo;ve created the application, you can dive deeper into Kotlin syntax:</source>
          <target state="translated">당신이 원하는 경우 &lt;strong&gt;처음부터 다시 시작&lt;/strong&gt; , 당신은 수있는 &lt;a href=&quot;jvm-get-started&quot;&gt;기본 코 틀린 응용 프로그램을 만듭니다&lt;/a&gt; . 애플리케이션을 만든 후에는 Kotlin 구문에 대해 자세히 알아볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc75b83f1a6aedb14b4da0cf0332f54ec31285c" translate="yes" xml:space="preserve">
          <source>If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the &lt;code&gt;@Throws&lt;/code&gt; annotation. Read more about using this annotation &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;for Java&lt;/a&gt; as well as &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;for Swift and Objective-C&lt;/a&gt;.</source>
          <target state="translated">Java, Swift 또는 Objective-C에서 Kotlin 코드를 호출 할 때 발생 가능한 예외를 호출자에게 알리려면 &lt;code&gt;@Throws&lt;/code&gt; 주석을 사용할 수 있습니다 . 이 주석 &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;을 Java&lt;/a&gt; 와 &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;Swift 및 Objective-C&lt;/a&gt; 에 사용하는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="aeb2cd1321a6da714d1670aa5db99ba2841082d1" translate="yes" xml:space="preserve">
          <source>If you want to be able to intercept an assignment and &quot;veto&quot; it, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">할당을 가로 채고이를 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt; 하려면 &lt;code&gt;observable()&lt;/code&gt; 대신 vetoable ()을 사용하십시오 . &lt;code&gt;vetoable&lt;/code&gt; 전달 된 핸들러 는 새 특성 값 지정이 수행 &lt;em&gt;되기 전에&lt;/em&gt; 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="bfcb549b385e785251e8b67f2103cc999018679b" translate="yes" xml:space="preserve">
          <source>If you want to be more explicit about the fact that you're creating a function, you can make an &lt;em&gt;anonymous function&lt;/em&gt;, which is still an expression rather than a declaration:</source>
          <target state="translated">함수를 작성하고 있다는 사실에 대해 더 명확하게 설명하려면 &lt;em&gt;익명 함수&lt;/em&gt; 를 작성할 수 있습니다.이 &lt;em&gt;함수&lt;/em&gt; 는 여전히 선언이 아니라 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="696e4536ad6464f41098a1506dbe37ed6e039609" translate="yes" xml:space="preserve">
          <source>If you want to check for &lt;em&gt;not&lt;/em&gt; being an instance of a type, use &lt;code&gt;!is&lt;/code&gt;. Note that &lt;code&gt;null&lt;/code&gt; is never an instance of any non-nullable type, but it is always an &quot;instance&quot; of any nullable type (even though it technically isn't an instance, but an absence of any instance).</source>
          <target state="translated">유형의 인스턴스가 &lt;em&gt;아닌지&lt;/em&gt; 확인 하려면 &lt;code&gt;!is&lt;/code&gt; 사용하십시오 . 참고 &lt;code&gt;null&lt;/code&gt; 아닌 nullable 형식의 인스턴스 적이 없지만, 항상 (기술적으로 인스턴스가 아닌 경우에도,하지만 인스턴스의 부재) 어떤 nullable 형식의 &quot;인스턴스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="da257f8128fc0a8ca8d706e6f33a71205b6846f0" translate="yes" xml:space="preserve">
          <source>If you want to customize your builds or run configuration, refer to the Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">빌드를 사용자 정의하거나 구성을 실행하려면 Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6811d9ac7923673de93e7c6cb86e0dcf12f4b539" translate="yes" xml:space="preserve">
          <source>If you want to declare your module's API as experimental, create an annotation class to use as its &lt;em&gt;experimental marker&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;:</source>
          <target state="translated">모듈의 API를 실험적으로 선언하려면 &lt;em&gt;실험 마커&lt;/em&gt; 로 사용할 주석 클래스를 만듭니다 . 이 클래스에는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt; 로 주석을 달아야합니다 .</target>
        </trans-unit>
        <trans-unit id="03930681c826a10c017d1c305e0dfdcd631eb099" translate="yes" xml:space="preserve">
          <source>If you want to do something that does not fit into this &quot;implicit backing field&quot; scheme, you can always fall back to having a &lt;em&gt;backing property&lt;/em&gt;:</source>
          <target state="translated">이 &quot;암시 적 백업 필드&quot;체계에 맞지 않는 작업을 수행하려는 경우 항상 &lt;em&gt;백업 특성&lt;/em&gt; 을 갖는 것으로 넘어갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="469cbead1816f95552e8fb9afc4584e38910eba1" translate="yes" xml:space="preserve">
          <source>If you want to exclude the last value, use &lt;code&gt;until&lt;/code&gt;:</source>
          <target state="translated">마지막 값을 제외하려면 &lt;code&gt;until&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="21db5d6173e4569eae43123218189b3a3fd619bd" translate="yes" xml:space="preserve">
          <source>If you want to group elements and then apply an operation to all groups at one time, use the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt;&lt;code&gt;groupingBy()&lt;/code&gt;&lt;/a&gt;. It returns an instance of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt;&lt;code&gt;Grouping&lt;/code&gt;&lt;/a&gt; type. The &lt;code&gt;Grouping&lt;/code&gt; instance lets you apply operations to all groups in a lazy manner: the groups are actually built right before the operation execution.</source>
          <target state="translated">요소를 그룹화 한 다음 한 번에 모든 그룹에 조작을 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt; &lt;code&gt;groupingBy()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt; &lt;code&gt;Grouping&lt;/code&gt; &lt;/a&gt; 유형 의 인스턴스를 리턴합니다 . &lt;code&gt;Grouping&lt;/code&gt; 그룹이 실제로 바로 작업을 실행하기 전에 내장되어 있습니다 : 예는 게으른 방식으로 모든 그룹에 작업을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03cd0cd3cc1cb5ea27db0072e091a1e185cd704d" translate="yes" xml:space="preserve">
          <source>If you want to have full control over the declarations generated by Dukat, want to apply manual adjustments, or if you're running into trouble with the auto-generated externals, you can also trigger the creation of the declarations for all your npm dependencies manually via the Gradle task &lt;code&gt;generateExternals&lt;/code&gt;. This will generate declarations in a directory titled &lt;code&gt;externals&lt;/code&gt; in your project root. Here, you can review the generated code and copy any parts you would like to use to your source directories.</source>
          <target state="translated">Dukat에서 생성 한 선언을 완전히 제어하고 싶거나, 수동 조정을 적용하고 싶거나, 자동 생성 된 외부에 문제가있는 경우, 모든 npm 종속성에 대한 선언 생성을 수동으로 트리거 할 수도 있습니다. Gradle 작업 &lt;code&gt;generateExternals&lt;/code&gt; 를 통해 . 그러면 프로젝트 루트의 &lt;code&gt;externals&lt;/code&gt; 라는 디렉토리에 선언이 생성됩니다 . 여기에서 생성 된 코드를 검토하고 사용하려는 부분을 소스 디렉토리에 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c8357f8e591acaadaa35ef0312974da5893976" translate="yes" xml:space="preserve">
          <source>If you want to impose additional constraints, you must use a separate &lt;code&gt;where&lt;/code&gt; clause, in which case the type parameter must be a subclass of the given class (if you specify a class, and you can specify at most one) &lt;em&gt;and&lt;/em&gt; implement all the given interfaces. You may then access all the public members of all the given types whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">추가 제약 조건을 부과하려는 경우 별도의 사용해야합니다 &lt;code&gt;where&lt;/code&gt; 절은,이 경우 형식 매개 변수가 지정된 클래스의 서브 클래스해야합니다 (당신이 클래스를 지정하는 경우, 당신은 대부분의 일에서 지정할 수 있습니다) &lt;em&gt;및&lt;/em&gt; 모든 주어진 구현 인터페이스. 그런 다음 &lt;code&gt;T&lt;/code&gt; 유형의 값을 가질 때마다 주어진 모든 유형의 모든 공용 멤버에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e91febbc6ec64c3a83c00953396a7246b3b6ef2" translate="yes" xml:space="preserve">
          <source>If you want to intercept assignments and &quot;veto&quot; them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">할당을 가로 채서 &quot;거부&quot;하려면 &lt;code&gt;observable()&lt;/code&gt; 대신 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt; 사용하십시오 . &lt;code&gt;vetoable&lt;/code&gt; 전달 된 핸들러 는 새 속성 값 할당이 수행 &lt;em&gt;되기 전에&lt;/em&gt; 호출 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad4ce20803bf2d9ea3efb4e51b2111ecb76db405" translate="yes" xml:space="preserve">
          <source>If you want to iterate through an array or a list with an index, you can do it this way:</source>
          <target state="translated">배열이나 인덱스가있는 목록을 반복하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="125c434fa84549730a675353dd139689f7b256f9" translate="yes" xml:space="preserve">
          <source>If you want to keep a whole package or module from elimination, you can use its fully qualified name as it appears in the generated JavaScript code.</source>
          <target state="translated">전체 패키지 또는 모듈이 제거되지 않도록하려면 생성 된 JavaScript 코드에 나타나는 정규화 된 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6675875ca0e15a9e0e94e4e62bcc35aa2271753" translate="yes" xml:space="preserve">
          <source>If you want to keep your code compatible with the 1.0 standard library, you can pass &lt;code&gt;-api-version 1.0&lt;/code&gt;.</source>
          <target state="translated">코드가 1.0 표준 라이브러리와 호환되도록하려면 &lt;code&gt;-api-version 1.0&lt;/code&gt; 을 전달하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="a90f40cf003c1ca63835c4f5252dade99a0b6302" translate="yes" xml:space="preserve">
          <source>If you want to learn different Kotlin features, try &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">다른 Kotlin 기능을 배우려면 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans를&lt;/a&gt; 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="00db4d51336388a60b35cfdb52f35a642fd46d81" translate="yes" xml:space="preserve">
          <source>If you want to look at the metadata of a function (e.g. its name), use &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; or one of its subinterfaces, where &lt;code&gt;V&lt;/code&gt; is the function's return type. Here's a basic example:</source>
          <target state="translated">함수의 메타 데이터 (예 : 이름)를 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 또는 해당 서브 인터페이스 중 하나를 사용하십시오. 여기서 &lt;code&gt;V&lt;/code&gt; 는 함수의 반환 유형입니다. 기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b301496262ace39d5d4ef8977ee4d6171448d2c" translate="yes" xml:space="preserve">
          <source>If you want to make further adjustments to the webpack configuration, place your additional configuration files inside a directory called &lt;code&gt;webpack.config.d&lt;/code&gt; in the root of your project. When building your project, all &lt;code&gt;.js&lt;/code&gt; configuration files will automatically be merged into the &lt;code&gt;build/js/packages/projectName/webpack.config.js&lt;/code&gt; file. To add a new &lt;a href=&quot;https://webpack.js.org/loaders/&quot;&gt;webpack loader&lt;/a&gt;, for example, add the following to a &lt;code&gt;.js&lt;/code&gt; file inside the &lt;code&gt;webpack.config.d&lt;/code&gt;:</source>
          <target state="translated">웹팩 구성을 추가로 조정하려면 프로젝트 루트의 &lt;code&gt;webpack.config.d&lt;/code&gt; 라는 디렉토리에 추가 구성 파일을 배치하십시오 . 프로젝트를 빌드 할 때 모든 &lt;code&gt;.js&lt;/code&gt; 구성 파일이 자동으로 &lt;code&gt;build/js/packages/projectName/webpack.config.js&lt;/code&gt; 파일에 병합 됩니다. 새로운 추가하려면 &lt;a href=&quot;https://webpack.js.org/loaders/&quot;&gt;웹팩 로더를&lt;/a&gt; , 예를 들어, A를 다음과 같은 추가 &lt;code&gt;.js&lt;/code&gt; 내부 파일 &lt;code&gt;webpack.config.d&lt;/code&gt; 을 :</target>
        </trans-unit>
        <trans-unit id="49c6ac403c1f5c69a934ea0d8c7e8d3612d277ad" translate="yes" xml:space="preserve">
          <source>If you want to require explicit consent to using your module's API, create an annotation class to use as an &lt;em&gt;opt-in requirement annotation&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-requires-opt-in/index&quot;&gt;@RequiresOptIn&lt;/a&gt;:</source>
          <target state="translated">모듈의 API 사용에 대한 명시적인 동의를 &lt;em&gt;요구&lt;/em&gt; 하려면 &lt;em&gt;옵트 인 요구 사항 주석&lt;/em&gt; 으로 사용할 주석 클래스를 만듭니다 . 이 클래스는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-requires-opt-in/index&quot;&gt;@RequiresOptIn&lt;/a&gt; 으로 주석 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d1730df83789869c0eec8797d86c76b973936cd" translate="yes" xml:space="preserve">
          <source>If you want to restrict the set of subclasses of a base class, you can declare the base class to be &lt;code&gt;sealed&lt;/code&gt; (which also makes it abstract), in which case you can only declare subclasses in the same file. The compiler then knows the complete set of possible subclasses, which will let you do exhaustive &lt;code&gt;when&lt;/code&gt; expression for all the possible subtypes without the need for an &lt;code&gt;else&lt;/code&gt; clause (and if you add another subclass in the future and forget to update the &lt;code&gt;when&lt;/code&gt;, the compiler will let you know).</source>
          <target state="translated">기본 클래스의 서브 클래스 세트를 제한하려면 기본 클래스가 &lt;code&gt;sealed&lt;/code&gt; 되도록 선언 하면 (이를 추상적으로 작성),이 경우 동일한 파일에서만 서브 클래스를 선언 할 수 있습니다. 그런 다음 컴파일러는 가능한 서브 클래스의 전체 세트를 알고 있으므로 &lt;code&gt;else&lt;/code&gt; 절이 필요하지 않고 가능한 모든 서브 타입에 대한 표현식을 표현할 &lt;code&gt;when&lt;/code&gt; 철저한 작업을 수행 할 수 있습니다 (나중에 다른 서브 클래스를 추가하고 &lt;code&gt;when&lt;/code&gt; , 컴파일러 업데이트를 잊어 버린 경우 알려드립니다).</target>
        </trans-unit>
        <trans-unit id="24aa907f13ca700b9ceeaa1262123234a9393fc1" translate="yes" xml:space="preserve">
          <source>If you want to see all available options run</source>
          <target state="translated">사용 가능한 모든 옵션을 보려면</target>
        </trans-unit>
        <trans-unit id="2d21aa936de4e7ff46724ca50ee4a418c4b5e521" translate="yes" xml:space="preserve">
          <source>If you want to see how your task will be look to the learner, right-click the &lt;code&gt;Task.kt&lt;/code&gt; file in the &lt;strong&gt;Project&lt;/strong&gt; tool window, and choose &lt;strong&gt;Course Creator -&amp;gt; Show Preview&lt;/strong&gt;:</source>
          <target state="translated">작업이 학습자에게 어떻게 보일지 보려면 &lt;strong&gt;프로젝트&lt;/strong&gt; 도구 창 에서 &lt;code&gt;Task.kt&lt;/code&gt; 파일을 마우스 오른쪽 단추로 클릭 하고 &lt;strong&gt;코스 생성자-&amp;gt; 미리보기 표시를&lt;/strong&gt; 선택하십시오 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9a25bc71220d18fbd536e1d59a05a1130584e1bb" translate="yes" xml:space="preserve">
          <source>If you want to skip tests, add the line &lt;code&gt;enabled = false&lt;/code&gt; to the &lt;code&gt;testTask&lt;/code&gt;.</source>
          <target state="translated">당신이 검사를 생략 라인을 추가 할 경우 &lt;code&gt;enabled = false&lt;/code&gt; 받는 &lt;code&gt;testTask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81dec7b57d1ae160cc859398f6b261d2b3f48fa4" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</source>
          <target state="translated">링크에 대한 사용자 정의 레이블을 지정하려면 마크 다운 참조 스타일 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8b98cb29aff85793ce838953d8ec8871fe09a05" translate="yes" xml:space="preserve">
          <source>If you want to start from scratch with the task, use the &lt;strong&gt;Reset&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel:</source>
          <target state="translated">작업을 처음부터 시작하려면 &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 맨 위에 있는 &lt;strong&gt;재설정&lt;/strong&gt; 아이콘을 사용하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377ee38e06516840389b0006f62da827c729d93" translate="yes" xml:space="preserve">
          <source>If you want to start using Kotlin for Android development, read &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google&amp;rsquo;s recommendation for getting started with Kotlin on Android&lt;/a&gt;.</source>
          <target state="translated">Android 개발 용 Kotlin을 사용하려면 Android &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;에서 Kotlin을 시작하기위한 Google의 권장 사항을&lt;/a&gt; 읽어 보세요 .</target>
        </trans-unit>
        <trans-unit id="ef089a53351dae0337ca675a4a633d10abb6eccf" translate="yes" xml:space="preserve">
          <source>If you want to use a value only if it satisfies a certain condition, try &lt;code&gt;takeIf()&lt;/code&gt;, which returns the value it's called on if it satisfies the given predicate, and null otherwise. There's also &lt;code&gt;takeUnless()&lt;/code&gt;, which inverts the logic. You can follow this with a &lt;code&gt;?.&lt;/code&gt; to perform an operation on the value only if it satisfies the predicate. Below, we compute the square of some expression, but only if the expression value is at least 42:</source>
          <target state="translated">특정 조건을 만족하는 경우에만 값을 사용 하려면 주어진 술어를 만족하면 호출되는 값을 리턴하는 &lt;code&gt;takeIf()&lt;/code&gt; 시도 하십시오 . 그렇지 않으면 널입니다. 로직을 반전시키는 &lt;code&gt;takeUnless()&lt;/code&gt; 도 있습니다 . 다음과 같이 &lt;code&gt;?.&lt;/code&gt; 사용할 수 있습니다 . 술어를 만족하는 경우에만 값에 대한 조작을 수행합니다. 아래에서는 표현식 값이 42 이상인 경우에만 일부 표현식의 제곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="39803479c2452982a2bf2e4068e689f82660ee9c" translate="yes" xml:space="preserve">
          <source>If you want to use dependencies on local pods from Kotlin code, import the corresponding packages.</source>
          <target state="translated">Kotlin 코드에서 로컬 포드에 대한 종속성을 사용하려면 해당 패키지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="be96354e6d849f99091812f51218336ab205ca9c" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;Teaching Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">교육에 EduTools 플러그인을 사용하려면 EduTools 플러그인으로 &lt;a href=&quot;edu-tools-educator&quot;&gt;Kotlin&lt;/a&gt; 교육을 읽어 보세요 .</target>
        </trans-unit>
        <trans-unit id="67fb2febabe66895070c2641c4d6f978cdb57747" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin to learn Kotlin, read &lt;a href=&quot;edu-tools-learner&quot;&gt;Learning Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">EduTools 플러그인을 사용하여 Kotlin을 배우려면 EduTools 플러그인으로 Kotlin &lt;a href=&quot;edu-tools-learner&quot;&gt;학습을&lt;/a&gt; 읽어 보세요 .</target>
        </trans-unit>
        <trans-unit id="4008289e8be7206e3604bd36b66d2e732e4dca59" translate="yes" xml:space="preserve">
          <source>If you want to use the IR compiler backend for your project, you need to &lt;strong&gt;update all Kotlin dependencies to versions that support this new backend&lt;/strong&gt;. Libraries published by JetBrains for Kotlin 1.4+ targeting Kotlin/JS already contain all artifacts required for usage with the new IR compiler backend.</source>
          <target state="translated">프로젝트에 IR 컴파일러 백엔드를 사용하려면 &lt;strong&gt;모든 Kotlin 종속성을이 새로운 백엔드를 지원하는 버전&lt;/strong&gt; 으로 &lt;strong&gt;업데이트&lt;/strong&gt; 해야합니다 . Kotlin / JS를 대상으로하는 Kotlin 1.4+ 용 JetBrains에서 게시 한 라이브러리에는 이미 새로운 IR 컴파일러 백엔드와 함께 사용하는 데 필요한 모든 아티팩트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="87bc643ce85513f6868cb2e9de9823d1f4369259" translate="yes" xml:space="preserve">
          <source>If you want to write strings gradually, you need to create an &lt;code&gt;OutputStreamWriter&lt;/code&gt; by calling &lt;code&gt;writer()&lt;/code&gt; on the file object. You can write binary data to a file by calling &lt;code&gt;outputStream()&lt;/code&gt; on a file object and use the resulting &lt;code&gt;OutputStream&lt;/code&gt; to write bytes.</source>
          <target state="translated">문자열을 점진적으로 쓰려면 파일 객체에서 &lt;code&gt;writer()&lt;/code&gt; 를 호출 하여 &lt;code&gt;OutputStreamWriter&lt;/code&gt; 를 만들어야 합니다. 파일 객체에서 &lt;code&gt;outputStream()&lt;/code&gt; 을 호출하여 이진 데이터를 파일에 쓰고 결과 &lt;code&gt;OutputStream&lt;/code&gt; 을 사용하여 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41befb145b42cbf8131f21728e484a8a91115d2" translate="yes" xml:space="preserve">
          <source>If you write the same without &lt;code&gt;let&lt;/code&gt;, you'll have to introduce a new variable and repeat its name whenever you use it.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 없이 동일 하게 작성하면 새 변수를 도입하고 사용할 때마다 그 이름을 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ea1c290d713b3b54603ea5a070a3770513b0c88" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re developing a multiplatform application that needs to access platform-specific APIs that implement the required functionality, use the Kotlin mechanism of &lt;em&gt;expected and actual declarations&lt;/em&gt;.</source>
          <target state="translated">필수 기능을 구현하는 플랫폼 별 API에 액세스해야하는 다중 플랫폼 애플리케이션을 개발하는 경우 &lt;em&gt;예상 및 실제 선언&lt;/em&gt; 의 Kotlin 메커니즘을 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="0a3aaf1f9dd9fea6023de83a437602a5eadebf5e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 16.04 or later, you can install the compiler from the command line:</source>
          <target state="translated">Ubuntu 16.04 이상을 사용하는 경우 명령 행에서 컴파일러를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef3b492d472d99a86a122fa8edba6106fbe3c08" translate="yes" xml:space="preserve">
          <source>If you'd rather do &lt;code&gt;x.unsigned&lt;/code&gt;, you can define an extension property:</source>
          <target state="translated">당신이 오히려 할 줄 경우 &lt;code&gt;x.unsigned&lt;/code&gt; , 당신은 확장 속성을 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="07dd95cbbfcdccfc3f0d530d8306040139f15ae7" translate="yes" xml:space="preserve">
          <source>If you're a &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; user, you can install the compiler with:</source>
          <target state="translated">당신이 경우 &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts를의&lt;/a&gt; 사용자, 당신과 함께 컴파일러를 설치할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d4d4dba6c4489bae4eb7e70ee6038d13984170c1" translate="yes" xml:space="preserve">
          <source>If you're a library maintainer who is looking to provide compatibility with the default backend as well as the new IR compiler backend, a setting for the compiler selection is available that allows you to create artifacts for both backends, allowing you to keep compatibility for your existing users while providing support for the next generation of Kotlin compiler. This so-called &lt;code&gt;both&lt;/code&gt;-mode can be turned on using the &lt;code&gt;kotlin.js.compiler=both&lt;/code&gt; setting in your &lt;code&gt;gradle.properties&lt;/code&gt; file, or can be set as one of the project-specific options inside your &lt;code&gt;js&lt;/code&gt; block inside the &lt;code&gt;build.gradle(.kts)&lt;/code&gt; file:</source>
          <target state="translated">기본 백엔드 및 새로운 IR 컴파일러 백엔드와의 호환성을 제공하려는 라이브러리 유지 관리자라면 두 백엔드에 대한 아티팩트를 생성 할 수있는 컴파일러 선택 설정을 사용할 수 있으므로 호환성을 유지할 수 있습니다. 차세대 Kotlin 컴파일러에 대한 지원을 제공하면서 기존 사용자에게 이 소위 &lt;code&gt;both&lt;/code&gt; 모드는 &lt;code&gt;gradle.properties&lt;/code&gt; 파일 의 &lt;code&gt;kotlin.js.compiler=both&lt;/code&gt; 설정 을 사용하여 켜 거나 &lt;code&gt;build.gradle(.kts)&lt;/code&gt; 내부의 &lt;code&gt;js&lt;/code&gt; 블록 내에서 프로젝트 별 옵션 중 하나로 설정할 수 있습니다. .kts) 파일 :</target>
        </trans-unit>
        <trans-unit id="0509d81eee59f0e681a0c3f0c84d5a54a79b4f26" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can build the &lt;em&gt;.jar&lt;/em&gt; file without including the Kotlin runtime into it.</source>
          <target state="translated">다른 Kotlin 애플리케이션에서 사용할 라이브러리를 개발하는 경우 Kotlin 런타임을 포함하지 않고 &lt;em&gt;.jar&lt;/em&gt; 파일을 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="368782cf6eaff197b952127bcc0c0565b3479378" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can produce the .jar file without including the Kotlin runtime into it.</source>
          <target state="translated">다른 Kotlin 응용 프로그램에서 사용할 라이브러리를 개발하는 경우 Kotlin 런타임을 포함하지 않고 .jar 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da5d517a7b5384e2a44811f79965cdbfc0afba2" translate="yes" xml:space="preserve">
          <source>If you're new to Android and want to learn to create applications with Kotlin, check out &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;this Udacity course&lt;/a&gt;.</source>
          <target state="translated">Android를 처음 사용하고 Kotlin으로 애플리케이션을 만드는 방법을 배우고 싶다면 &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;이 Udacity 과정을&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="f128e1fe8c8eb81ea54217b5ba66f82b1c59b061" translate="yes" xml:space="preserve">
          <source>If you're new to Kotlin, a good first step would be to familiarise yourself with the &lt;a href=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt; of the language.</source>
          <target state="translated">Kotlin을 처음 사용하는 경우 첫 번째 단계는 언어 의 &lt;a href=&quot;basic-syntax&quot;&gt;기본 구문&lt;/a&gt; 에 익숙해지는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="766f702953f8980e6bc50e185cc1d656f34dfbc1" translate="yes" xml:space="preserve">
          <source>If you're targeting JDK 7 or JDK 8, you can use extended versions of the Kotlin standard library which contain additional extension functions for APIs added in new JDK versions. Instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;, use &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; or &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, depending on your JDK version (for Kotlin 1.1.x use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; as the &lt;code&gt;jdk&lt;/code&gt; counterparts were introduced in 1.2.0).</source>
          <target state="translated">JDK 7 또는 JDK 8을 대상으로하는 경우 새 JDK 버전에 추가 된 API에 대한 추가 확장 기능이 포함 된 Kotlin 표준 라이브러리의 확장 버전을 사용할 수 있습니다. 대신에 &lt;code&gt;kotlin-stdlib&lt;/code&gt; , 사용 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 또는 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; , 당신의 JDK 버전에 따라 (코 틀린 1.1.x의 사용을 위해 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 과 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 는 AS &lt;code&gt;jdk&lt;/code&gt; 대응 1.2에서 소개 .0).</target>
        </trans-unit>
        <trans-unit id="b775395194955c271aef49dac84498fbe90d7450" translate="yes" xml:space="preserve">
          <source>If you're targeting the JVM platform, you can also use Java's reflection system directly. In this example, we grab a function reference from an object's class by specifying the function's name as a string (if the function takes parameters, you also need to specify their types), and then we call it. Note that we didn't mention &lt;code&gt;String&lt;/code&gt; anywhere - this technique works without knowing what the object's class is, but it will raise an exception if the object's class doesn't have the requested function. However, Java-style function references do not have type information, so you won't get verification of the parameter types, and you must cast the return value:</source>
          <target state="translated">JVM 플랫폼을 대상으로하는 경우 Java 리플렉션 시스템을 직접 사용할 수도 있습니다. 이 예제에서는 함수 이름을 문자열로 지정하여 객체의 클래스에서 함수 참조를 가져옵니다 (함수가 매개 변수를 사용하는 경우 해당 유형도 지정해야 함). 우리는 어디서나 &lt;code&gt;String&lt;/code&gt; 을 언급하지 않았습니다. 이 기술은 객체의 클래스가 무엇인지 알지 못하고 작동하지만 객체의 클래스에 요청 된 기능이 없으면 예외가 발생합니다. 그러나 Java 스타일 함수 참조에는 유형 정보가 없으므로 매개 변수 유형을 확인할 수 없으므로 리턴 값을 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a761f12674bd3c30efe00ec7ea6eb2be1927a55" translate="yes" xml:space="preserve">
          <source>If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the &lt;code&gt;webpackTask&lt;/code&gt; configuration block. For example, to switch to CommonJS, use:</source>
          <target state="translated">브라우저를 대상으로하고 UMD와 다른 모듈 시스템을 사용하려는 경우 &lt;code&gt;webpackTask&lt;/code&gt; 구성 블록 에서 원하는 모듈 유형을 지정할 수 있습니다 . 예를 들어 CommonJS로 전환하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d2933676dc2f7e28b956599b006e00954f9395f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;em&gt;if&lt;/em&gt; as an expression rather than a statement (for example, returning its value or assigning it to a variable), the expression is required to have an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">&lt;em&gt;if&lt;/em&gt; 대신 명령문을 표현식으로 사용하는 &lt;em&gt;경우&lt;/em&gt; (예 : 값을 리턴하거나 변수에 지정) 표현식에는 &lt;code&gt;else&lt;/code&gt; 분기 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="54106dba9eedca9003087d15e44d20a53dd58c38" translate="yes" xml:space="preserve">
          <source>If you're using Gradle, specify the compiler arguments in the &lt;code&gt;kotlinOptions&lt;/code&gt; property of the Kotlin compilation task. For details, see &lt;a href=&quot;using-gradle#compiler-options&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">Gradle을 사용하는 경우 Kotlin 컴파일 작업 의 &lt;code&gt;kotlinOptions&lt;/code&gt; 속성에 컴파일러 인수를 지정합니다 . 자세한 내용은 &lt;a href=&quot;using-gradle#compiler-options&quot;&gt;Gradle 사용을&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="a7e4c1b85a590c2220f5ee4ee7e8642ea497c364" translate="yes" xml:space="preserve">
          <source>If you're using Maven, specify the compiler arguments in the &lt;code&gt;&amp;lt;configuration&amp;gt;&lt;/code&gt; element of the Maven plugin node. For details, see &lt;a href=&quot;using-maven#specifying-compiler-options&quot;&gt;Using Maven&lt;/a&gt;.</source>
          <target state="translated">Maven을 사용하는 경우 Maven 플러그인 노드 의 &lt;code&gt;&amp;lt;configuration&amp;gt;&lt;/code&gt; 요소에 컴파일러 인수를 지정 합니다. 자세한 내용은 &lt;a href=&quot;using-maven#specifying-compiler-options&quot;&gt;Maven 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51fc2cadbf8df70dee87fb5d749d2ee884d218b0" translate="yes" xml:space="preserve">
          <source>If you're using a generic class whose type parameters haven't been declared in a variant way (either because its authors didn't think of it, or because the type parameters can't have either variance kind because they are used both as parameter types and return types), you can still use it in a variant way thanks to &lt;em&gt;type projection&lt;/em&gt;. The term &quot;projection&quot; refers to the fact that when you do this, you might restrict yourself to using only some of its members - so you're in a sense only seeing a partial, or &quot;projected&quot; version of the class. Let's look again at our &lt;code&gt;Bowl&lt;/code&gt; class, but without the variant interfaces this time:</source>
          <target state="translated">형식 매개 변수가 변형 방식으로 선언되지 않은 제네릭 클래스를 사용하는 경우 (작성자가 생각하지 않았거나 형식 매개 변수가 다음과 같이 모두 사용되므로 분산 유형을 가질 수 없기 때문에) 매개 변수 유형 및 반환 유형)의 경우 &lt;em&gt;유형 투영&lt;/em&gt; 덕분에 변형 방식으로 계속 사용할 수 있습니다 . &quot;투영&quot;이라는 용어는이 작업을 수행 할 때 일부 멤버 만 사용하도록 제한 할 수 있다는 점을 의미하므로 클래스의 일부 또는 &quot;예상 된&quot;버전 만 볼 수 있습니다. &lt;code&gt;Bowl&lt;/code&gt; 클래스를 다시 살펴 보지만 이번에는 변형 인터페이스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6e51da97890d2ae9ab3d189065498b378cc4fb2" translate="yes" xml:space="preserve">
          <source>If you've got one string that you want to write to a file, overwriting the existing contents if the file already exists, do this (again, UTF-8 is the default encoding):</source>
          <target state="translated">파일에 쓰려는 문자열이 하나 있으면, 파일이 이미 존재하는 경우 기존 내용을 덮어 쓰십시오. 이렇게하면 UTF-8이 기본 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="d91079d5275bf77f335cf6cb84c315d0b54d9ee8" translate="yes" xml:space="preserve">
          <source>If you've just upgraded to Kotlin 1.1 but can not use new language features yet (e.g. because some of your teammates may not have upgraded), you can pass &lt;code&gt;-language-version 1.0&lt;/code&gt;, which will restrict all APIs and language features to 1.0.</source>
          <target state="translated">Kotlin 1.1로 업그레이드했지만 아직 새로운 언어 기능을 사용할 수없는 경우 (예 : 일부 팀원이 업그레이드하지 않았을 수 있음) &lt;code&gt;-language-version 1.0&lt;/code&gt; 을 전달하면 모든 API 및 언어 기능이 1.0으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb0fce206872389875749705970d5e6f4cde62d" translate="yes" xml:space="preserve">
          <source>If your Gradle module is a multiplatform module, use the &lt;code&gt;useExperimentalAnnotation&lt;/code&gt; method:</source>
          <target state="translated">Gradle 모듈이 다중 플랫폼 모듈 인 경우 &lt;code&gt;useExperimentalAnnotation&lt;/code&gt; 메서드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6a4d49a0aa58db91f5538f1484a110d84d269171" translate="yes" xml:space="preserve">
          <source>If your application already uses DBFlow, you can safely introduce Kotlin into your project. You can gradually convert existing code to Kotlin (ensuring that everything compiles along the way). The converted code doesn't differ much from Java. For instance, declaring a table looks similar to Java with the small difference that default values for properties must be specified explicitly:</source>
          <target state="translated">애플리케이션이 이미 DBFlow를 사용하는 경우 Kotlin을 프로젝트에 안전하게 소개 할 수 있습니다. 기존 코드를 Kotlin으로 점차 변환 할 수 있습니다 (모든 것이 진행되는 동안 컴파일되도록 보장). 변환 된 코드는 Java와 크게 다르지 않습니다. 예를 들어, 테이블 선언은 속성의 기본값을 명시 적으로 지정해야한다는 점이 약간 다르지만 Java와 비슷해 보입니다.</target>
        </trans-unit>
        <trans-unit id="f63962aa6cf85ec6f47c280bebab4a954c284cd2" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, write it inside a companion class:</source>
          <target state="translated">클래스에 고급 직렬화 논리가 필요한 경우 동반 클래스 내부에 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3503de21b9cb0b7cba965dc4634f2918727f903d" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, you can write it inside a companion class:</source>
          <target state="translated">클래스에 고급 직렬화 논리가 필요한 경우 컴패니언 클래스 안에 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacc53066a886e6486df3248d96a52d89fd95863" translate="yes" xml:space="preserve">
          <source>If your code is too clever for the compiler, and you know without the help of &lt;code&gt;is&lt;/code&gt; that &lt;code&gt;x&lt;/code&gt; is an instance of &lt;code&gt;Person&lt;/code&gt; but the compiler doesn't, you can &lt;em&gt;cast&lt;/em&gt; your value with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">코드는 컴파일러 너무 영리하고, 당신의 도움없이 알고있는 경우 &lt;code&gt;is&lt;/code&gt; 것을 &lt;code&gt;x&lt;/code&gt; 가 의 인스턴스 인 &lt;code&gt;Person&lt;/code&gt; 있지만, 컴파일러, 당신은 할 수 없습니다 &lt;em&gt;캐스트&lt;/em&gt; 로 값을 &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2ecf8bd14ee3aa94f5fa13c2b5cd616c3b320e5a" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well. The artifact IDs are &lt;code&gt;kotlin-reflect&lt;/code&gt; for the reflection library, and &lt;code&gt;kotlin-test&lt;/code&gt; and &lt;code&gt;kotlin-test-junit&lt;/code&gt; for the testing libraries.</source>
          <target state="translated">프로젝트에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin 리플렉션&lt;/a&gt; 또는 테스트 기능을 사용 하는 경우 해당 종속성도 추가해야합니다. 아티팩트 ID는 리플렉션 라이브러리에 대해 &lt;code&gt;kotlin-reflect&lt;/code&gt; 이고 &lt;code&gt;kotlin-test&lt;/code&gt; 라이브러리에 대해서는 kotlin-test 및 &lt;code&gt;kotlin-test-junit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aaffb39c3271a99cd3c6b1dcd26285bb7f6d4133" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well:</source>
          <target state="translated">프로젝트에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin 리플렉션&lt;/a&gt; 또는 테스트 기능을 사용 하는 경우 해당 종속성도 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff4ecabd35e3e545f9518b5b102d6fa77c32607a" translate="yes" xml:space="preserve">
          <source>If, by any chance, we need &quot;just an object&quot;, with no nontrivial supertypes, we can simply say:</source>
          <target state="translated">우발적이지 않은 슈퍼 타입이없는 &quot;단지 객체&quot;가 필요한 경우 간단히 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f78ba0d5d02014df85f65107c7688ad5093fc4b0" translate="yes" xml:space="preserve">
          <source>If, upon updating from one version to another, some code that used to work doesn't work any more, it is an &lt;em&gt;incompatible change&lt;/em&gt; in the language (sometimes referred to as &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work any more&quot; means precisely in some cases, but it definitely includes the following:</source>
          <target state="translated">한 버전에서 다른 버전으로 업데이트 할 때 작동하는 데 사용 된 일부 코드가 더 이상 작동하지 않으면 언어 의 &lt;em&gt;호환되지 않는 변경&lt;/em&gt; (때로는 &quot;중단 변경&quot;이라고 함)입니다. 어떤 경우에는 &quot;더 이상 작동하지 않는다&quot;는 것이 무엇을 의미하는지에 대한 논쟁이있을 수 있지만, 반드시 다음을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="906f0c92cf03edbafe4a5d12e37d92701ba25962" translate="yes" xml:space="preserve">
          <source>IllegalCallableAccessException</source>
          <target state="translated">IllegalCallableAccessException</target>
        </trans-unit>
        <trans-unit id="6bfee05d69b5aa826fde5d373d8ebea121200b58" translate="yes" xml:space="preserve">
          <source>IllegalCharacterConversionException</source>
          <target state="translated">IllegalCharacterConversionException</target>
        </trans-unit>
        <trans-unit id="6d13e3edbafba5c6ba6e57ae6bc8267296d1bf66" translate="yes" xml:space="preserve">
          <source>IllegalPropertyDelegateAccessException</source>
          <target state="translated">IllegalPropertyDelegateAccessException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="33f05a29887232f2adef5f1b64b04d6cf8bd78f2" translate="yes" xml:space="preserve">
          <source>ImageBitmapOptions</source>
          <target state="translated">ImageBitmapOptions</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="1a722437bfbd0c07b7f837b5b4332fd5d966ead2" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContextSettings</source>
          <target state="translated">ImageBitmapRenderingContextSettings</target>
        </trans-unit>
        <trans-unit id="b28af413c72a2e03556905d9b27766a80ae5dd7b" translate="yes" xml:space="preserve">
          <source>ImageBitmapSource</source>
          <target state="translated">ImageBitmapSource</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="2217055c382ca08984df9c834dee428b5ed7c541" translate="yes" xml:space="preserve">
          <source>ImageOrientation</source>
          <target state="translated">ImageOrientation</target>
        </trans-unit>
        <trans-unit id="3394b71415cd8bd55fc9255b5d6beaf734d6f770" translate="yes" xml:space="preserve">
          <source>ImageSmoothingQuality</source>
          <target state="translated">ImageSmoothingQuality</target>
        </trans-unit>
        <trans-unit id="f98fd49f8f974a3886c42cb3693e5ffdf40539ee" translate="yes" xml:space="preserve">
          <source>Immediate superclasses of this class, in the order they are listed in the source code. Includes superclasses and superinterfaces of the class, but does not include the class itself.</source>
          <target state="translated">소스 코드에 나열된 순서대로이 클래스의 즉시 수퍼 클래스입니다. 클래스의 수퍼 클래스 및 수퍼 인터페이스를 포함하지만 클래스 자체는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="bb86d1b762a23d9068f4510901eeff7d18242638" translate="yes" xml:space="preserve">
          <source>Immutability in Kotlin/Native</source>
          <target state="translated">코 틀린 / 네이티브의 불변성</target>
        </trans-unit>
        <trans-unit id="7f8782e7a667262dd5095f5ff184ddd709f4772b" translate="yes" xml:space="preserve">
          <source>Immutability is a runtime property in Kotlin/Native, and can be applied to an arbitrary object subgraph using the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; function. It makes all the objects reachable from the given one immutable, such a transition is a one-way operation (i.e., objects cannot be unfrozen later). Some naturally immutable objects such as &lt;code&gt;kotlin.String&lt;/code&gt;, &lt;code&gt;kotlin.Int&lt;/code&gt;, and other primitive types, along with &lt;code&gt;AtomicInt&lt;/code&gt; and &lt;code&gt;AtomicReference&lt;/code&gt; are frozen by default. If a mutating operation is applied to a frozen object, an &lt;code&gt;InvalidMutabilityException&lt;/code&gt; is thrown.</source>
          <target state="translated">불변성은 Kotlin / Native의 런타임 속성이며 &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; 함수를 사용하여 임의의 개체 하위 그래프에 적용 할 수 있습니다 . 주어진 객체에서 모든 객체에 도달 할 수 없게 만듭니다. 이러한 전환은 단방향 작업입니다 (즉, 객체는 나중에 고정 해제 할 수 없음). &lt;code&gt;AtomicInt&lt;/code&gt; 및 &lt;code&gt;AtomicReference&lt;/code&gt; 와 함께 &lt;code&gt;kotlin.String&lt;/code&gt; , &lt;code&gt;kotlin.Int&lt;/code&gt; 및 기타 기본 유형과 같은 자연적으로 변경 불가능한 일부 객체 는 기본적으로 고정됩니다. 고정 작업이 고정 된 개체에 적용되면 &lt;code&gt;InvalidMutabilityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed22a68de3c3f3cb15e1268df39db4a167fd746d" translate="yes" xml:space="preserve">
          <source>ImmutableBlob</source>
          <target state="translated">ImmutableBlob</target>
        </trans-unit>
        <trans-unit id="575d550105355ba3be5a6608f83817426c2bd97c" translate="yes" xml:space="preserve">
          <source>Imperative finally block</source>
          <target state="translated">명령 적 최종 차단</target>
        </trans-unit>
        <trans-unit id="56a6489b53e94ff44d4b5586ba1f1332d73844a1" translate="yes" xml:space="preserve">
          <source>Imperative versus declarative</source>
          <target state="translated">명령형 대 선언적</target>
        </trans-unit>
        <trans-unit id="ee7341a728a58d68c7532bf18aeb0fac4452b6b5" translate="yes" xml:space="preserve">
          <source>Implementation by Delegation</source>
          <target state="translated">위임에 의한 구현</target>
        </trans-unit>
        <trans-unit id="c0f0a132ab68a72286213758ce660b7e042cb87b" translate="yes" xml:space="preserve">
          <source>Implementation note: the current reading value is stored as a &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number of nanoseconds, thus it's capable to represent a time range of approximately &amp;plusmn;292 years. Should the reading value overflow as the result of &lt;a href=&quot;plus-assign&quot;&gt;plusAssign&lt;/a&gt; operation, an &lt;a href=&quot;../../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; is thrown.</source>
          <target state="translated">구현 참고 사항 : 현재 판독 값은 &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;긴&lt;/a&gt; 나노초 수로 저장 되므로 약 &amp;plusmn; 292 년의 시간 범위를 나타낼 수 있습니다. &lt;a href=&quot;plus-assign&quot;&gt;plusAssign&lt;/a&gt; 작업 의 결과로 읽기 값이 오버플로되면 &lt;a href=&quot;../../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc1735ad8ce42355f885445d5ba551e409b9c86b" translate="yes" xml:space="preserve">
          <source>Implementations of the interface can override default methods.</source>
          <target state="translated">인터페이스 구현은 기본 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d5f96768fee4f4899fb4ea94381d1c87db0a66" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces</source>
          <target state="translated">인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="d640e1d5eb2b7a283f3bc3070dd151afc512fb6c" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces in Enum Classes</source>
          <target state="translated">열거 형 클래스에서 인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="b2153d6fa67762548da1f8fe28f3d481ede48834" translate="yes" xml:space="preserve">
          <source>Implements the core logic of a property delegate for a read/write property that calls callback functions when changed.</source>
          <target state="translated">변경시 콜백 함수를 호출하는 읽기 / 쓰기 속성에 대한 속성 대리자의 핵심 논리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b1af49118602d4ab9bd26831d35fc303f95ea13f" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">암시 적 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="febd7a841f47bb67cef7b18f13ac806c637192b6" translate="yes" xml:space="preserve">
          <source>Important: files marked with &lt;code&gt;@file:JsModule&lt;/code&gt; annotation can't declare non-external members. The example below produces compile-time error:</source>
          <target state="translated">중요 : &lt;code&gt;@file:JsModule&lt;/code&gt; 주석으로 표시된 파일은 외부가 아닌 멤버를 선언 할 수 없습니다. 아래 예제는 컴파일 타임 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e45479a7a7959d4875b5ea4acddae533ace5e782" translate="yes" xml:space="preserve">
          <source>Importing deeper package hierarchies</source>
          <target state="translated">더 깊은 패키지 계층 가져 오기</target>
        </trans-unit>
        <trans-unit id="a932c1ce87f097109d85ae710ba5975b2888a20e" translate="yes" xml:space="preserve">
          <source>Importing synthetic properties</source>
          <target state="translated">합성 속성 가져 오기</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="3b7090ba2b2cc222b6a645f1eb051b20d9654d8e" translate="yes" xml:space="preserve">
          <source>Improved *.gradle.kts support in the IDE</source>
          <target state="translated">IDE에서 * .gradle.kts 지원 개선</target>
        </trans-unit>
        <trans-unit id="513df22c9887b1f085e00ef3b729d3f007cfd9d9" translate="yes" xml:space="preserve">
          <source>Improved import handling</source>
          <target state="translated">수입 취급 개선</target>
        </trans-unit>
        <trans-unit id="315a432d3c7693ed151796f4c20766973b95d237" translate="yes" xml:space="preserve">
          <source>Improved management for npm dependencies, with mandatory version numbers or &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;semver&lt;/a&gt; version ranges, as well as support for &lt;em&gt;development&lt;/em&gt;, &lt;em&gt;peer&lt;/em&gt;, and &lt;em&gt;optional&lt;/em&gt; npm dependencies using &lt;code&gt;devNpm&lt;/code&gt;, &lt;code&gt;optionalNpm&lt;/code&gt; and &lt;code&gt;peerNpm&lt;/code&gt;. Read more about dependency management for npm packages directly from Gradle &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">필수 버전 번호 또는 &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;semver&lt;/a&gt; 버전 범위 를 사용하여 npm 종속성에 대한 관리를 개선 하고 &lt;code&gt;devNpm&lt;/code&gt; , &lt;code&gt;optionalNpm&lt;/code&gt; 및 &lt;code&gt;peerNpm&lt;/code&gt; 을 사용 하는 &lt;em&gt;개발&lt;/em&gt; , &lt;em&gt;피어&lt;/em&gt; 및 &lt;em&gt;선택적&lt;/em&gt; npm 종속성에 대한 지원을 제공합니다 . &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;여기&lt;/a&gt; 에서 Gradle 에서 직접 npm 패키지의 종속성 관리에 대해 자세히 알아 보세요 .</target>
        </trans-unit>
        <trans-unit id="fd53d3f3315c4c0f3364235c04212b30cd118e2f" translate="yes" xml:space="preserve">
          <source>Improved support for Kotlin Gradle DSL in the IDE</source>
          <target state="translated">IDE에서 Kotlin Gradle DSL에 대한 지원이 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8972a1f28a588591d73ee09ddd836428eaca222" translate="yes" xml:space="preserve">
          <source>Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:</source>
          <target state="translated">함수의 호출 결과와 전달 된 인수 값 사이의 관계를 선언하여 스마트 캐스트 분석을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="c202358d520e5f37257d179570305668ee990cdc" translate="yes" xml:space="preserve">
          <source>Improving the existing API</source>
          <target state="translated">기존 API 개선</target>
        </trans-unit>
        <trans-unit id="3ea84fc4dca92bbd95cba0393e768bc0dbac665a" translate="yes" xml:space="preserve">
          <source>Improving the variable initialization analysis in the presence of high-order functions:</source>
          <target state="translated">고차 함수가있을 때 변수 초기화 분석 개선 :</target>
        </trans-unit>
        <trans-unit id="1a9aa64fd2cf728e6a54a37ad269e224c4406ae7" translate="yes" xml:space="preserve">
          <source>In &quot;clever words&quot; they say that the class &lt;code&gt;C&lt;/code&gt; is &lt;strong&gt;covariant&lt;/strong&gt; in the parameter &lt;code&gt;T&lt;/code&gt;, or that &lt;code&gt;T&lt;/code&gt; is a &lt;strong&gt;covariant&lt;/strong&gt; type parameter. You can think of &lt;code&gt;C&lt;/code&gt; as being a &lt;strong&gt;producer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s, and NOT a &lt;strong&gt;consumer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s.</source>
          <target state="translated">&quot;영리한 단어&quot;에서 그들은 클래스 &lt;code&gt;C&lt;/code&gt; 가 매개 변수 &lt;code&gt;T&lt;/code&gt; 에서 &lt;strong&gt;공변량&lt;/strong&gt; 이거나 &lt;code&gt;T&lt;/code&gt; 가 &lt;strong&gt;공변량&lt;/strong&gt; 유형 매개 변수 라고 말합니다 . 당신은 생각할 수있는 &lt;code&gt;C&lt;/code&gt; 것으로 &lt;strong&gt;생산자&lt;/strong&gt; 의 &lt;code&gt;T&lt;/code&gt; 의, 아닌 &lt;strong&gt;소비자&lt;/strong&gt; 의 &lt;code&gt;T&lt;/code&gt; 의.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6019b82a793e669523c1435271b5d51f4ccb4ffc" translate="yes" xml:space="preserve">
          <source>In 1.3 we reworked the entire multiplatform model. The &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;new DSL&lt;/a&gt; we have for describing multiplatform Gradle projects is much more flexible, and we'll keep working on it to make project configuration straightforward.</source>
          <target state="translated">1.3에서 우리는 전체 멀티 플랫폼 모델을 재 작업했습니다. &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;새로운 DSL&lt;/a&gt; 멀티 Gradle을 프로젝트를 설명하는 우리가 훨씬 더 유연, 우리는 프로젝트 구성 간단을하도록 노력하겠습니다.</target>
        </trans-unit>
        <trans-unit id="08f9bdd95bef61c2c357a6e138e1e9a913682812" translate="yes" xml:space="preserve">
          <source>In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!</source>
          <target state="translated">1.3에서는 표현력과 유연성을 향상시키고 공통 코드를 더 쉽게 공유 할 수 있도록 멀티 플랫폼 프로젝트 모델을 완전히 재 작업했습니다. 또한 Kotlin / Native가 이제 대상 중 하나로 지원됩니다!</target>
        </trans-unit>
        <trans-unit id="213381945926ceb74a0743ef803e1aae21bbb519" translate="yes" xml:space="preserve">
          <source>In 1.3.70 we introduced two new features for improving the performance of Kotlin/Native compilation: &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native&quot;&gt;caching project dependencies and running the compiler from the Gradle daemon&lt;/a&gt;. Since that time, we&amp;rsquo;ve managed to fix numerous issues and improve the overall stability of these features.</source>
          <target state="translated">1.3.70에서는 Kotlin / Native 컴파일의 성능을 개선하기위한 두 가지 새로운 기능, 즉 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/03/kotlin-1-3-70-released/#kotlin-native&quot;&gt;프로젝트 종속성 캐싱 및 Gradle 데몬에서 컴파일러 실행을 도입했습니다&lt;/a&gt; . 그 이후로 우리는 수많은 문제를 해결하고 이러한 기능의 전반적인 안정성을 개선했습니다.</target>
        </trans-unit>
        <trans-unit id="f8879cf64a06b7b628772713a32dffa84200aa1c" translate="yes" xml:space="preserve">
          <source>In 1.4.0, Kotlin/Native got a significant number of new features and improvements, including:</source>
          <target state="translated">1.4.0에서 Kotlin / Native는 다음과 같은 많은 새로운 기능과 개선 사항을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="a15eb3cdff900df751ecc01f9df494a4b1d439fc" translate="yes" xml:space="preserve">
          <source>In 1.4.0, scripting in Kotlin benefits from a number of functional and performance improvements along with other updates. Here are some of the key changes:</source>
          <target state="translated">1.4.0에서 Kotlin의 스크립팅은 다른 업데이트와 함께 다양한 기능 및 성능 개선의 이점을 누립니다. 주요 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f9c2fe76d2a17f7c4f9ec731f1abfee212c135b" translate="yes" xml:space="preserve">
          <source>In 1.4.0, the standard library includes a number of useful functions for working with &lt;strong&gt;collections&lt;/strong&gt;:</source>
          <target state="translated">1.4.0에서 표준 라이브러리에는 &lt;strong&gt;컬렉션&lt;/strong&gt; 작업에 유용한 여러 기능이 포함되어 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="033b388a365ea25e3654d39784a4aac0e59b6a41" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we add the basic support for suspending functions in Swift and Objective-C. Now, when you compile a Kotlin module into an Apple framework, suspending functions are available in it as functions with callbacks (&lt;code&gt;completionHandler&lt;/code&gt; in the Swift/Objective-C terminology). When you have such functions in the generated framework&amp;rsquo;s header, you can call them from your Swift or Objective-C code and even override them.</source>
          <target state="translated">1.4.0에서는 Swift 및 Objective-C의 기능 일시 중지에 대한 기본 지원이 추가되었습니다. 당신이 애플 프레임 워크에 코 틀린 모듈을 컴파일 할 때 지금, 정지 기능이 콜백과 기능 (로 사용할 수 있습니다 &lt;code&gt;completionHandler&lt;/code&gt; 스위프트 / 목표 - C 용어로). 생성 된 프레임 워크의 헤더에 이러한 함수가 있으면 Swift 또는 Objective-C 코드에서 호출하고 재정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a6df711b0b9f7fdf8c3bc58b1703c03d295ebc7" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we continued improving the IDE support for Gradle Kotlin DSL scripts (&lt;code&gt;*.gradle.kts&lt;/code&gt; files). Here is what the new version brings:</source>
          <target state="translated">1.4.0에서는 Gradle Kotlin DSL 스크립트 ( &lt;code&gt;*.gradle.kts&lt;/code&gt; 파일)에 대한 IDE 지원을 계속 개선했습니다 . 새 버전이 제공하는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eac832f0ecfb5c80421d8f75ff875507a4728bfb" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we have added new features to improve your experience with delegated properties in Kotlin:</source>
          <target state="translated">1.4.0에서는 Kotlin의 위임 된 속성 사용 환경을 개선하기 위해 새로운 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3d296b88303d152ba0a9aadb06847e0102aa46ad" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we slightly change the Swift API generated from Kotlin with respect to the way exceptions are translated. There is a fundamental difference in error handling between Kotlin and Swift. All Kotlin exceptions are unchecked, while Swift has only checked errors. Thus, to make Swift code aware of expected exceptions, Kotlin functions should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of potential exception classes.</source>
          <target state="translated">1.4.0에서는 예외가 번역되는 방식과 관련하여 Kotlin에서 생성 된 Swift API를 약간 변경했습니다. Kotlin과 Swift의 오류 처리에는 근본적인 차이가 있습니다. 모든 Kotlin 예외는 확인되지 않은 반면 Swift는 오류 만 확인했습니다. 따라서 Swift 코드가 예상되는 예외를 인식하도록하려면 Kotlin 함수 에 잠재적 예외 클래스 목록을 지정하는 &lt;code&gt;@Throws&lt;/code&gt; 주석을 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="939973482b04c9dfe37b17beb6dea441e65e3874" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we&amp;rsquo;ve introduced a new API for resolving external dependencies (such as Maven artifacts), along with implementations for it. This API is published in the new artifacts &lt;code&gt;kotlin-scripting-dependencies&lt;/code&gt; and &lt;code&gt;kotlin-scripting-dependencies-maven&lt;/code&gt;. The previous dependency resolution functionality in &lt;code&gt;kotlin-script-util&lt;/code&gt; library is now deprecated.</source>
          <target state="translated">1.4.0에서는 외부 종속성 (예 : Maven 아티팩트)을 해결하기위한 새로운 API와 이에 대한 구현을 도입했습니다. 이 API는 새로운 아티팩트 &lt;code&gt;kotlin-scripting-dependencies&lt;/code&gt; 및 &lt;code&gt;kotlin-scripting-dependencies-maven&lt;/code&gt; 에 게시됩니다 . &lt;code&gt;kotlin-script-util&lt;/code&gt; 라이브러리 의 이전 종속성 해결 기능 은 이제 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fe67da7ef7bd9edb03b06fd394c5b605f7d8102" translate="yes" xml:space="preserve">
          <source>In 1.4.0, we've added a new mode for generating default methods: &lt;code&gt;-Xjvm-default=all&lt;/code&gt; compiles &lt;em&gt;all&lt;/em&gt; non-abstract methods of Kotlin interfaces to &lt;code&gt;default&lt;/code&gt; Java methods. For compatibility with the code that uses the interfaces compiled without &lt;code&gt;default&lt;/code&gt;, we also added &lt;code&gt;all-compatibility&lt;/code&gt; mode.</source>
          <target state="translated">1.4.0에서는 기본 메소드 생성을위한 새 모드를 추가했습니다. &lt;code&gt;-Xjvm-default=all&lt;/code&gt; 은 Kotlin 인터페이스의 &lt;em&gt;모든&lt;/em&gt; 비추 상 메소드를 &lt;code&gt;default&lt;/code&gt; 자바 메소드로 컴파일 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;default&lt;/code&gt; 없이 컴파일 된 인터페이스를 사용하는 코드와의 호환성을 위해 &lt;code&gt;all-compatibility&lt;/code&gt; 모드 도 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="5745802255877abfa046b72cbccdadc8221d5622" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering&lt;/a&gt;, we describe operations that retrieve collection elements in specific orders. For mutable lists, the standard library offers similar extension functions that perform the same ordering operations in place. When you apply such an operation to a list instance, it changes the order of elements in that exact instance.</source>
          <target state="translated">&lt;a href=&quot;collection-ordering&quot;&gt;콜렉션 순서&lt;/a&gt; 에서는 콜렉션 요소를 특정 순서로 검색하는 오퍼레이션을 설명합니다. 가변 목록의 경우 표준 라이브러리는 동일한 순서 지정 작업을 수행하는 유사한 확장 기능을 제공합니다. 이러한 작업을 목록 인스턴스에 적용하면 해당 인스턴스의 요소 순서가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="be8a31aea4fdca8e3b9bdedb1958918e98cae1d2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collections-overview#map&quot;&gt;maps&lt;/a&gt;, types of both keys and values are user-defined. Key-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values. On this page, we provide descriptions of the map processing functions from the standard library.</source>
          <target state="translated">에서 &lt;a href=&quot;collections-overview#map&quot;&gt;지도&lt;/a&gt; , 모두 키와 값의 유형은 사용자 정의입니다. 맵 항목에 대한 키 기반 액세스는 키별로 값을 얻는 것부터 키와 값을 별도로 필터링하는 것까지 다양한 맵 특정 처리 기능을 가능하게합니다. 이 페이지에서는 표준 라이브러리의 맵 처리 기능에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7454358e40f9eaf26ccc7cd55f4c30f555918de5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;the previous tutorial&lt;/a&gt; we created a &lt;code&gt;lib.h&lt;/code&gt; file. This time, we are going to include those declarations directly into the &lt;code&gt;interop.def&lt;/code&gt; file, after the &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">에서 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;이전 튜토리얼&lt;/a&gt; 우리는 생성 &lt;code&gt;lib.h&lt;/code&gt; 파일을. 이번에 는 &lt;code&gt;---&lt;/code&gt; 구분자 행 다음에 해당 선언을 &lt;code&gt;interop.def&lt;/code&gt; 파일에 직접 포함시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f0454a21172602b262219293f4778fc730c2daf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;build.gradle.kts&lt;/code&gt; (or &lt;code&gt;build.gradle&lt;/code&gt;) of your IDEA project, apply the CocoaPods plugin as well as the Kotlin Multiplatform plugin.</source>
          <target state="translated">에서 &lt;code&gt;build.gradle.kts&lt;/code&gt; (또는 &lt;code&gt;build.gradle&lt;/code&gt; ) 당신의 IDEA 프로젝트의 CocoaPods가 코 틀린 멀티 플러그인뿐만 아니라 플러그인 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f2d8d96fc34753484a87526254e4a4f003f9c05" translate="yes" xml:space="preserve">
          <source>In Android projects, additional Kotlin source sets are created for each &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android source set&lt;/a&gt;. If the Android target has a name &lt;code&gt;foo&lt;/code&gt;, the Android source set &lt;code&gt;bar&lt;/code&gt; gets a Kotlin source set counterpart &lt;code&gt;fooBar&lt;/code&gt;. The Kotlin compilations, however, are able to consume Kotlin sources from all of the directories &lt;code&gt;src/bar/java&lt;/code&gt;, &lt;code&gt;src/bar/kotlin&lt;/code&gt;, and &lt;code&gt;src/fooBar/kotlin&lt;/code&gt;. Java sources are only read from the first of these directories.</source>
          <target state="translated">Android 프로젝트에서 각 &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android 소스 세트&lt;/a&gt; 마다 추가 Kotlin 소스 세트가 작성 됩니다 . Android 대상의 이름이 &lt;code&gt;foo&lt;/code&gt; 인 경우 Android 소스 세트 &lt;code&gt;bar&lt;/code&gt; 는 Kotlin 소스 세트 대응 &lt;code&gt;fooBar&lt;/code&gt; 를 가져 옵니다 . 그러나 Kotlin 컴파일은 &lt;code&gt;src/bar/java&lt;/code&gt; , &lt;code&gt;src/bar/kotlin&lt;/code&gt; 및 &lt;code&gt;src/fooBar/kotlin&lt;/code&gt; 디렉토리에서 Kotlin 소스를 사용할 수 있습니다 . Java 소스는이 디렉토리 중 첫 번째 디렉토리에서만 읽습니다.</target>
        </trans-unit>
        <trans-unit id="257732c8dc478843fa9cbb50bd51c9bd28228b70" translate="yes" xml:space="preserve">
          <source>In Android, make sure you use the Android Gradle plugin version 3.2 or higher, which can correctly process jar files with module-info.</source>
          <target state="translated">Android에서는 module-info로 jar 파일을 올바르게 처리 할 수있는 Android Gradle 플러그인 버전 3.2 이상을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="33342ff8fe9e060731185ad7c136d99b9461055f" translate="yes" xml:space="preserve">
          <source>In Gradle</source>
          <target state="translated">Gradle에서</target>
        </trans-unit>
        <trans-unit id="9ffad76a20436e6770075c18f7fc5a623588a28f" translate="yes" xml:space="preserve">
          <source>In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't include any module metadata by default. To enable module metadata publishing, add &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; to the root project's &lt;code&gt;settings.gradle&lt;/code&gt; file. With older Gradle versions, this is also required for module metadata consumption.</source>
          <target state="translated">Gradle 5.3 이상에서 모듈 메타 데이터는 항상 종속성 해결 중에 사용되지만 발행물에는 기본적으로 모듈 메타 데이터가 포함되어 있지 않습니다. 모듈 메타 데이터 게시를 활성화하려면 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 를 루트 프로젝트의 &lt;code&gt;settings.gradle&lt;/code&gt; 파일에 추가하십시오. 이전 Gradle 버전에서는 모듈 메타 데이터 소비에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="689d572315ca41a5147e4a6e26331b2145e72a29" translate="yes" xml:space="preserve">
          <source>In Gradle 6.0 and above, you can explicitly apply changes by clicking &lt;strong&gt;Load Gradle Changes&lt;/strong&gt; or by reimporting the Gradle project.</source>
          <target state="translated">Gradle 6.0 이상에서는 &lt;strong&gt;Load Gradle Changes&lt;/strong&gt; 를 클릭 하거나 Gradle 프로젝트를 다시 가져 와서 &lt;strong&gt;변경&lt;/strong&gt; 사항을 명시 적으로 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db8d93f584f6cd9be9c19cceb09290c42348f8b6" translate="yes" xml:space="preserve">
          <source>In Gradle command line parameters: add the parameter &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; or &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; with the boolean value reflecting the usage of incremental compilation. Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">Gradle 명령 행 매개 변수에서 : 증분 컴파일 사용법을 반영하는 부울 값과 함께 &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; 또는 &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; 매개 변수를 추가하십시오 . 이 경우, 각 후속 빌드에 매개 변수를 추가해야하며, 증분 컴파일이 비활성화 된 빌드는 증분 캐시를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="d95af6982c4662ae34dc8dfd04c6f3d77bb71544" translate="yes" xml:space="preserve">
          <source>In Gradle configuration files: add the line &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JVM or &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JS projects either to &lt;code&gt;gradle.properties&lt;/code&gt; or to &lt;code&gt;local.properties&lt;/code&gt; file. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is a boolean value reflecting the usage of incremental compilation.</source>
          <target state="translated">Gradle을 구성 파일 : 광고 추가 &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; 코 틀린 / 또는 JVM위한 &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; 에 어느 코 틀린 / JS 프로젝트 &lt;code&gt;gradle.properties&lt;/code&gt; 거나 &lt;code&gt;local.properties&lt;/code&gt; 의 파일. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 는 증분 컴파일 사용법을 반영하는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="1f0dee881e670d1f97f2d917d6284d13c20aff3f" translate="yes" xml:space="preserve">
          <source>In Gradle versions earlier than 6.0, you need to manually load the script configuration by clicking &lt;strong&gt;Load Configuration&lt;/strong&gt; in the editor.</source>
          <target state="translated">6.0 이전의 Gradle 버전에서는 편집기에서 &lt;strong&gt;구성로드&lt;/strong&gt; 를 클릭하여 스크립트 구성을 수동으로로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="537c1a3af537507e4b627b3261006ddbdae522fd" translate="yes" xml:space="preserve">
          <source>In Gradle:</source>
          <target state="translated">Gradle에서 :</target>
        </trans-unit>
        <trans-unit id="d2d1d0c783432497ec07d157b951c4e78d7cc0b8" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt; and check the &lt;em&gt;Create from archetype&lt;/em&gt; box:</source>
          <target state="translated">IntelliJ IDEA에서 &lt;em&gt;파일-&amp;gt; 새로 작성&amp;gt; 프로젝트&amp;hellip;&lt;/em&gt; 로 이동하여 &lt;em&gt;아키 타입&lt;/em&gt; 에서 &lt;em&gt;작성&lt;/em&gt; 상자를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4d485a76c7a3760895d18fab529fc51f77b28063" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt;:</source>
          <target state="translated">IntelliJ IDEA에서 &lt;em&gt;File-&amp;gt; New&amp;gt; Project&amp;hellip;로 이동하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1602732a6a8d6badfddfb46b91b51e47005a6da3" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA, select &lt;strong&gt;File&lt;/strong&gt; | &lt;strong&gt;New&lt;/strong&gt; | &lt;strong&gt;Project&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA에서 &lt;strong&gt;File&lt;/strong&gt; | &lt;strong&gt;새로운&lt;/strong&gt; | &lt;strong&gt;프로젝트&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c5abe7664486d0a3820c82f8b82f8f0d75b700ae" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA, write in the compiler arguments in the &lt;strong&gt;Additional command-line parameters&lt;/strong&gt; text box in &lt;strong&gt;Settings | Build, Execution, Deployment | Compilers | Kotlin Compiler&lt;/strong&gt;</source>
          <target state="translated">하게 IntelliJ IDEA에서,의 컴파일러 인수에 쓰기 &lt;strong&gt;추가 명령 줄 매개 변수&lt;/strong&gt; 텍스트 상자 &lt;strong&gt;설정 | 빌드, 실행, 배포 | 컴파일러 | Kotlin 컴파일러&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9cc14db5a6e801d7da035df405c7d7827fc53b41" translate="yes" xml:space="preserve">
          <source>In JVM platform code:</source>
          <target state="translated">JVM 플랫폼 코드에서 :</target>
        </trans-unit>
        <trans-unit id="513ad5f28a98a53d38c2cd4b1ebf3e53ba78a0e9" translate="yes" xml:space="preserve">
          <source>In Java you specify &lt;code&gt;Dagger&lt;/code&gt; as &lt;code&gt;annotationProcessor&lt;/code&gt; (or &lt;code&gt;apt&lt;/code&gt;) dependency:</source>
          <target state="translated">Java에서는 &lt;code&gt;Dagger&lt;/code&gt; 를 &lt;code&gt;annotationProcessor&lt;/code&gt; (또는 &lt;code&gt;apt&lt;/code&gt; ) 종속성으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e76e330054ec3492dbde5d95b20d3d1c9ac12e6f" translate="yes" xml:space="preserve">
          <source>In Java, we are used to classes named &quot;*Utils&quot;: &lt;code&gt;FileUtils&lt;/code&gt;, &lt;code&gt;StringUtils&lt;/code&gt; and so on. The famous &lt;code&gt;java.util.Collections&lt;/code&gt; belongs to the same breed. And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</source>
          <target state="translated">Java에서는 &quot;* Utils&quot;라는 클래스 , &lt;code&gt;FileUtils&lt;/code&gt; , &lt;code&gt;StringUtils&lt;/code&gt; 등이 사용됩니다. 유명한 &lt;code&gt;java.util.Collections&lt;/code&gt; 는 동일한 유형에 속합니다. 이 Utils 클래스에 대한 불쾌한 부분은이를 사용하는 코드가 다음과 같다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">자바에서 :</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">JavaScript에서는 프로토 타입 또는 클래스 자체에서 멤버를 정의 할 수 있습니다. 즉 :</target>
        </trans-unit>
        <trans-unit id="592ce5c07c0fe6dc9a4e0ec16760d4af84a287b3" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself:</source>
          <target state="translated">JavaScript에서는 프로토 타입이나 클래스 자체에서 멤버를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.0에서 &lt;code&gt;td&lt;/code&gt; 에 전달 된 람다의 코드는 3 개의 암시 적 수신자에 액세스 할 수 있습니다. 하나는 &lt;code&gt;table&lt;/code&gt; , &lt;code&gt;tr&lt;/code&gt; 및 &lt;code&gt;td&lt;/code&gt; 에 전달됩니다 . 이를 통해 컨텍스트에서 의미가없는 메소드를 호출 할 수 있습니다. 예를 들어 &lt;code&gt;td&lt;/code&gt; 내부에서 &lt;code&gt;tr&lt;/code&gt; 을 호출 하여 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 태그 를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">코 틀린 1.1에서는 암시 적 수신기에 정의 된 메소드 만 그래서, 그것을 제한 할 수 있습니다 &lt;code&gt;td&lt;/code&gt; 람다가 전달 내에서 사용할 수 &lt;code&gt;td&lt;/code&gt; . &lt;code&gt;@DslMarker&lt;/code&gt; 메타 주석으로 표시된 주석을 정의 하고 태그 클래스의 기본 클래스에 적용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">Kotlin 1.1.x에서는 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">Kotlin 1.3에서는 주석에 중첩 클래스, 인터페이스, 객체 및 컴패니언이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">Kotlin 1.3에서는 이제 변수 가 &lt;code&gt;when&lt;/code&gt; 를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f37a85c51fbb026184df241508ddfb560773d59" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, the last expression inside a lambda wasn&amp;rsquo;t smart cast unless you specified the expected type. Thus, in the following example, Kotlin 1.3 infers &lt;code&gt;String?&lt;/code&gt; as the type of the &lt;code&gt;result&lt;/code&gt; variable:</source>
          <target state="translated">Kotlin 1.3에서 람다 내부의 마지막 표현식은 예상 유형을 지정하지 않는 한 스마트 캐스트가 아닙니다. 따라서 다음 예에서 Kotlin 1.3은 &lt;code&gt;String?&lt;/code&gt; &lt;code&gt;result&lt;/code&gt; 변수 의 유형 :</target>
        </trans-unit>
        <trans-unit id="22e077400784df8fb4e1901ad7292c2554138fbc" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, when you called a function with &lt;a href=&quot;functions#named-arguments&quot;&gt;named arguments&lt;/a&gt;, you had to place all the arguments without names (positional arguments) before the first named argument. For example, you could call &lt;code&gt;f(1, y = 2)&lt;/code&gt;, but you couldn't call &lt;code&gt;f(x = 1, 2)&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.3에서는 &lt;a href=&quot;functions#named-arguments&quot;&gt;이름이 지정된 arguments&lt;/a&gt; 로 함수를 호출 할 때 이름이없는 모든 인수 (위치 인수)를 첫 번째 이름이 지정된 인수 앞에 배치해야했습니다. 예를 들어 &lt;code&gt;f(1, y = 2)&lt;/code&gt; 호출 할 수 있지만 &lt;code&gt;f(x = 1, 2)&lt;/code&gt; 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a475b20752c24d40f5224875251af51b65720545" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you could not use unqualified &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; inside &lt;code&gt;when&lt;/code&gt; expressions included in loops. The reason was that these keywords were reserved for possible &lt;a href=&quot;https://en.wikipedia.org/wiki/Switch_statement#Fallthrough&quot;&gt;fall-through behavior&lt;/a&gt; in &lt;code&gt;when&lt;/code&gt; expressions.</source>
          <target state="translated">코 틀린 1.3, 당신은 자격이 사용할 수없는 &lt;code&gt;break&lt;/code&gt; 하고 &lt;code&gt;continue&lt;/code&gt; 내부 &lt;code&gt;when&lt;/code&gt; 표현 루프에 포함되어 있습니다. 그 이유는 이러한 키워드가 &lt;code&gt;when&lt;/code&gt; 표현식 에서 가능한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Switch_statement#Fallthrough&quot;&gt;폴 스루 동작&lt;/a&gt; 을 위해 예약 되었기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="b974ce10e6832a604b02d997fda0b13d1262981d" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you couldn&amp;rsquo;t access a member reference of a smart cast type. Now in Kotlin 1.4 you can:</source>
          <target state="translated">Kotlin 1.3에서는 스마트 캐스트 유형의 멤버 참조에 액세스 할 수 없습니다. 이제 Kotlin 1.4에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59a10d530fe4140dc151e0b8f7cbd865add4eedd" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you needed to introduce an explicit lambda parameter or replace &lt;code&gt;to&lt;/code&gt; with a &lt;code&gt;Pair&lt;/code&gt; constructor with explicit generic arguments to make it work.</source>
          <target state="translated">Kotlin 1.3에서는 명시 적 람다 매개 변수를 도입하거나 를 명시 적 제네릭 인수가 있는 &lt;code&gt;Pair&lt;/code&gt; 생성자로 대체 &lt;code&gt;to&lt;/code&gt; 작동하도록해야했습니다.</target>
        </trans-unit>
        <trans-unit id="459625eab3e8c1c93d88f051a772819b50973feb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you often needed to add explicit casts (either &lt;code&gt;!!&lt;/code&gt; or type casts like &lt;code&gt;as String&lt;/code&gt;) to make such cases work, and now these casts have become unnecessary.</source>
          <target state="translated">Kotlin 1.3에서는 이러한 경우가 작동하도록 명시 적 캐스트 ( &lt;code&gt;!!&lt;/code&gt; 또는 &lt;code&gt;as String&lt;/code&gt; 과 같은 유형 캐스트) 를 추가해야하는 경우가 많았 으며 이제 이러한 캐스트가 불필요 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="b1e46759775714e2bcf79ff28b8ed72dd56567d1" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, you would have had to declare the function &lt;code&gt;foo&lt;/code&gt; above in Java code to perform a SAM conversion.</source>
          <target state="translated">Kotlin 1.3에서는 SAM 변환을 수행하기 위해 Java 코드에서 위의 &lt;code&gt;foo&lt;/code&gt; 함수를 선언 해야했습니다.</target>
        </trans-unit>
        <trans-unit id="4780e01f08d257fbc2b0ac706bfcbbb52154825a" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, debugging coroutines is now much more convenient with the new functionality shipped with the Kotlin plugin.</source>
          <target state="translated">Kotlin 1.4에서는 Kotlin 플러그인과 함께 제공되는 새로운 기능을 사용하여 코 루틴 디버깅이 훨씬 더 편리해졌습니다.</target>
        </trans-unit>
        <trans-unit id="c83ca71d5cf2a3ede274dccc4461018d08bea733" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, thanks to the new inference algorithm, the last expression inside a lambda gets smart cast, and this new, more precise type is used to infer the resulting lambda type. Thus, the type of the &lt;code&gt;result&lt;/code&gt; variable becomes &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.4에서는 새로운 추론 알고리즘 덕분에 람다 내부의 마지막 표현식이 스마트 캐스트되고이 새롭고 더 정확한 유형이 결과 람다 유형을 추론하는 데 사용됩니다. 따라서 &lt;code&gt;result&lt;/code&gt; 변수 의 유형 은 &lt;code&gt;String&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="c138e260059efc2e42dd28d292a8e504c0bd71f8" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, there is no such limitation &amp;ndash; you can now specify a name for an argument in the middle of a set of positional arguments. Moreover, you can mix positional and named arguments any way you like, as long as they remain in the correct order.</source>
          <target state="translated">Kotlin 1.4에는 이러한 제한이 없습니다. 이제 위치 인수 집합 중간에 인수 이름을 지정할 수 있습니다. 또한 위치 및 명명 된 인수가 올바른 순서로 유지되는 한 원하는 방식으로 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17850e337195432d24d049a8cddcfff57e5bda7d" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; without labels inside &lt;code&gt;when&lt;/code&gt; expressions included in loops. They behave as expected by terminating the nearest enclosing loop or proceeding to its next step.</source>
          <target state="translated">Kotlin 1.4에서는 표현식이 루프에 포함될 &lt;code&gt;when&lt;/code&gt; 내부 레이블없이 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 를 사용할 수 있습니다 . 가장 가까운 둘러싸는 루프를 종료하거나 다음 단계로 진행하여 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a91dfb7becc799d0a4c9f2c3750f3bb6f56f95da" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use Java SAM interfaces in Kotlin and apply SAM conversions to them.</source>
          <target state="translated">Kotlin 1.4에서는 Kotlin의 자바 SAM 인터페이스를 사용하고 여기에 SAM 변환을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bcf048388e07b049f121a6138fdee8bc3c8bbd0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4, you can use callable references to functions returning any type in &lt;code&gt;Unit&lt;/code&gt;-returning functions. Before Kotlin 1.4, you could only use lambda arguments in this case. Now you can use both lambda arguments and callable references.</source>
          <target state="translated">Kotlin 1.4에서는 &lt;code&gt;Unit&lt;/code&gt; 반환 함수 에서 모든 유형을 반환하는 함수에 대한 호출 가능 참조를 사용할 수 있습니다 . Kotlin 1.4 이전에는이 ​​경우 람다 인수 만 사용할 수있었습니다. 이제 람다 인수와 호출 가능 참조를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6cbd7b692f016e4b1961c027250fe1af453741" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.4.0, we ship a number of improvements in all of its components, with the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/&quot;&gt;focus on quality and performance&lt;/a&gt;. Below you will find the list of the most important changes in Kotlin 1.4.0.</source>
          <target state="translated">Kotlin 1.4.0에서는 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/&quot;&gt;품질과 성능에 중점을두고&lt;/a&gt; 모든 구성 요소에서 여러 가지 개선 사항을 제공 합니다 . 아래에서 Kotlin 1.4.0의 가장 중요한 변경 사항 목록을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">Kotlin에서 함수는 파일에서 최상위 레벨로 선언 될 수 있습니다. 즉, Java, C # 또는 Scala와 같은 언어로 수행해야하는 함수를 보유하기 위해 클래스를 작성할 필요가 없습니다. Kotlin 함수는 최상위 함수 외에도 멤버 함수 및 확장 함수로 로컬로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">코 틀린에는 두 가지 유형의 평등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">Kotlin 에서이 줄 은 정수 목록에서 &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;파괴 선언&lt;/a&gt; 을 사용하여 다음 문장으로 간결하게 구문 분석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">Kotlin에서는 일반 유형에 대한 상한을 제공 할 수 있습니다. Objective-C도이를 지원하지만보다 복잡한 경우에는 지원되지 않으며 현재 Kotlin-Objective-C interop에서는 지원되지 않습니다. 여기서 null이 아닌 상한 인 경우 Objective-C 메서드 / 속성이 null이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">Kotlin에서는 필드로 직접 작업 할 수 없으며 &lt;a href=&quot;../reference/properties&quot;&gt;properties로&lt;/a&gt; 작업 할 수 있습니다 . 속성에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">코 틀린에서 당신은 추가 할 필요가 &lt;code&gt;kotlin-kapt&lt;/code&gt; 수 있도록 플러그인을 &lt;code&gt;kapt&lt;/code&gt; 하고 대체 &lt;code&gt;annotationProcessor&lt;/code&gt; 을 함께 &lt;code&gt;kapt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">Kotlin에서는 &lt;code&gt;annotationProcessor&lt;/code&gt; 대신 &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation Processing Tool&lt;/a&gt; ( &lt;code&gt;kapt&lt;/code&gt; )을 사용하여 Java와 유사한 방식으로 종속성을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">Kotlin에서는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; ) 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;-&lt;/code&gt; ) 연산자가 콜렉션에 대해 정의됩니다. 그들은 첫 번째 피연산자로 컬렉션을 취합니다. 두 번째 피연산자는 요소 또는 다른 컬렉션 일 수 있습니다. 반환 값은 새로운 읽기 전용 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="78f4990d53a6e7c8067b2fe1adea30492b815286" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; can also be used as an expression:</source>
          <target state="translated">Kotlin에서 &lt;em&gt;if&lt;/em&gt; 는 표현식으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">Kotlin에서 &lt;em&gt;if&lt;/em&gt; 는 표현식입니다. 즉, 값을 반환합니다. 따라서 평범한 &lt;em&gt;경우이&lt;/em&gt; 역할에서 잘 작동 하기 때문에 삼항 연산자 (조건? then : else)는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">Kotlin에서는 모든 예외가 선택 해제되어있어 컴파일러가 강제로 예외를 포착하지 않습니다. 따라서 확인 된 예외를 선언하는 Java 메소드를 호출 할 때 Kotlin은 다음을 수행하도록 강요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1bf5763a1f21717d603f8b9877cdae5c9f323e3" translate="yes" xml:space="preserve">
          <source>In Kotlin, data serialization tools are available in a separate component, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;&lt;em&gt;kotlinx.serialization&lt;/em&gt;&lt;/a&gt;. It consists of two main parts: the Gradle plugin &amp;ndash;&lt;code&gt;org.jetbrains.kotlin.plugin.serialization&lt;/code&gt; and the runtime libraries.</source>
          <target state="translated">Kotlin에서 데이터 직렬화 도구는 별도의 구성 요소 인 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;&lt;em&gt;kotlinx.serialization&lt;/em&gt;&lt;/a&gt; 에서 사용할 수 있습니다 . Gradle 플러그인 &amp;ndash; &lt;code&gt;org.jetbrains.kotlin.plugin.serialization&lt;/code&gt; 및 런타임 라이브러리 의 두 가지 주요 부분으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">Kotlin에서 모든 것은 모든 변수에서 멤버 함수 및 속성을 호출 할 수 있다는 의미에서 객체입니다. 일부 유형은 특수한 내부 표현을 가질 수 있습니다 (예 : 숫자, 문자 및 부울은 런타임시 기본 값으로 표시 될 수 있음). 그러나 사용자에게는 일반 클래스처럼 보입니다. 이 섹션에서는 Kotlin에서 사용되는 기본 유형 인 숫자, 문자, 부울, 배열 및 문자열에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">Kotlin에서 기능 유형은 다른 수의 매개 변수를 갖는 일반 클래스로 표시됩니다. &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; ,&amp;hellip;이 방법은이 목록이 유한하다는 문제가 있습니다. 현재 &lt;code&gt;Function22&lt;/code&gt; 로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlin에서 구현 상속은 다음 규칙에 의해 규제됩니다. 클래스가 직속 슈퍼 클래스에서 동일한 멤버의 많은 구현을 상속하는 경우이 멤버를 무시하고 자체 구현 (아마 상속 된 클래스 중 하나 사용)을 제공해야합니다. 상속 구현이 촬영되는 슈퍼 타입을 표시하기 위해, 우리가 사용하는 &lt;em&gt;슈퍼&lt;/em&gt; 꺾쇠 괄호 상위 유형의 이름으로 규정, 예를 들어 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e8de20bd90cf59ff062bcee3a6b6475fd0af4bb" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlin에서 구현 상속은 다음 규칙에 의해 규제됩니다. 클래스가 직계 수퍼 클래스에서 동일한 멤버의 여러 구현을 상속하는 경우이 멤버를 재정의하고 자체 구현을 제공해야합니다 (상속 된 항목 중 하나를 사용). 상속 된 구현을 가져 오는 상위 유형을 표시하기 위해 꺾쇠 괄호 안에있는 상위 유형 이름에 의해 정규화 된 &lt;em&gt;super&lt;/em&gt; 를 사용합니다 ( 예 : &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">Kotlin에서 가져 오기는 컴파일 타임 개념입니다. 무언가를 가져 오면 실제로 코드가 실행되지 않습니다 (파이썬과 달리 파일의 모든 최상위 문은 가져 오기 시간에 실행 됨). 따라서 순환 가져 오기는 허용되지만 코드에서 디자인 문제를 암시 할 수 있습니다. 그러나 실행하는 동안 클래스 (또는 해당 속성 또는 함수)가 처음 참조 될 때 클래스가로드되고 클래스로드로 인해 &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;컴패니언 개체&lt;/a&gt; 가 초기화되므로 순환 종속성이있는 경우 런타임 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">Kotlin에서 다형성은 클래스 계층 구조를 통해 달성되므로 속성이나 함수가 누락 된 상황에 빠질 수 없습니다. 기본 규칙은 선언 된 유형이 &lt;code&gt;A&lt;/code&gt; 인 변수 / 속성 / 매개 변수가 &lt;code&gt;B&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 의 하위 유형 인 경우에만 클래스 &lt;code&gt;B&lt;/code&gt; 의 인스턴스를 참조 할 수 있다는 것 입니다. 즉, &lt;code&gt;A&lt;/code&gt; 는 클래스 여야 하고 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 서브 클래스 여야 하거나 &lt;code&gt;A&lt;/code&gt; 는 인터페이스 여야 하고 &lt;code&gt;B&lt;/code&gt; 는 해당 인터페이스를 구현하는 클래스이거나 수행하는 클래스의 서브 클래스 여야합니다. 이전 섹션의 클래스와 인터페이스를 사용하여 다음 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ea4efcee086c70a1dc18d5edfeb999729e27f06" translate="yes" xml:space="preserve">
          <source>In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</source>
          <target state="translated">Kotlin에서 세미콜론은 선택 사항이므로 줄 바꿈이 중요합니다. 언어 디자인은 Java 스타일 중괄호를 가정하고 다른 형식화 ​​스타일을 사용하려고하면 놀라운 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">코 틀린에서의 기본 구현 &lt;code&gt;List&lt;/code&gt; 입니다 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; 에&lt;/a&gt; 당신이 크기 조정 배열로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">Kotlin에서, 기본값에 대한 표현식은 함수가 호출 될 때마다 평가됩니다. 따라서 평가 될 때마다 새 목록을 생성하는 표현식을 사용하는 한 위의 트랩을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">코 틀린에서는 객체의 순서를 여러 가지 방법으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">Kotlin에서 형식 시스템은 &lt;em&gt;null&lt;/em&gt; 을 보유 할 수있는 참조 (널링 가능 참조)와 그렇지 않은 참조를 구분합니다 (Null이 아닌 참조). 예를 들어, &lt;code&gt;String&lt;/code&gt; 유형의 일반 변수는 &lt;em&gt;null을&lt;/em&gt; 보유 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">Kotlin에는 규칙이 있습니다. 함수의 마지막 매개 변수가 함수이면 해당 인수로 전달 된 람다 식을 괄호 밖에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">코 틀린에는 이런 종류의 것을 컴파일러에게 설명 할 수있는 방법이 있습니다. 이것을 &lt;strong&gt;선언 사이트 분산&lt;/strong&gt; 이라고합니다 . &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; 멤버로부터 만 &lt;strong&gt;반환&lt;/strong&gt; (생산)되고 소비되지 않도록 Source 의 &lt;strong&gt;형식 매개 변수 &lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; 에 주석을 달 수 있습니다 . 이를 위해 &lt;strong&gt;out&lt;/strong&gt; 수정자를 제공합니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">Kotlin에서 Java 또는 C #과 달리 클래스에는 정적 메소드가 없습니다. 대부분의 경우 패키지 수준 함수를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">Kotlin에서는 정규화되지 않은 정규 &lt;code&gt;return&lt;/code&gt; 만 사용 하여 명명 된 함수 또는 익명 함수를 종료 할 수 있습니다. 이것은 람다를 종료하려면 &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt; 을 사용해야 하고 람다는 둘러싼 함수를 반환 할 수 없기 때문에 람다 내에서 베어 &lt;code&gt;return&lt;/code&gt; 이 금지됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d39c4582a1b13add9eb003022ccb3a007508d4c5" translate="yes" xml:space="preserve">
          <source>In Kotlin, we have three backends that generate executables: Kotlin/JVM, Kotlin/JS, and Kotlin/Native. Kotlin/JVM and Kotlin/JS don't share much code since they were developed independently of each other. Kotlin/Native is based on a new infrastructure built around an intermediate representation (IR) for Kotlin code.</source>
          <target state="translated">Kotlin에는 Kotlin / JVM, Kotlin / JS, Kotlin / Native의 세 가지 백엔드가 있습니다. Kotlin / JVM과 Kotlin / JS는 서로 독립적으로 개발 되었기 때문에 많은 코드를 공유하지 않습니다. Kotlin / Native는 Kotlin 코드의 IR (중간 표현)을 기반으로 구축 된 새로운 인프라를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="0bc591251b1866272d3defd4ab24986b180f3e99" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.</source>
          <target state="translated">StringBuilder의 Kotlin / JS 구현에서 초기 용량은 작업의 추가 성능에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d25d5f146a0d36095ac2d2fbada4dfa30e5c1b3" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</source>
          <target state="translated">In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</target>
        </trans-unit>
        <trans-unit id="9c5a4446d1a6bca7a876f80da83f707725750c3e" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</source>
          <target state="translated">In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</target>
        </trans-unit>
        <trans-unit id="be7a0e0448f643a881b7fca70d06192aeb1ec087" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.</source>
          <target state="translated">StringBuilder의 Kotlin / JS 구현에서이 메서드에서 반환 된 값은 백업 저장소의 실제 크기를 나타내지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d924e5bfc344bb39ea0863e63e91640453cecc" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS projects, all dependencies can be managed through the Gradle plugin. This includes Kotlin/Multiplatform libraries such as &lt;code&gt;kotlinx.coroutines&lt;/code&gt;, &lt;code&gt;kotlinx.serialization&lt;/code&gt;, or &lt;code&gt;ktor-client&lt;/code&gt;.</source>
          <target state="translated">Kotlin / JS 프로젝트에서 모든 종속성은 Gradle 플러그인을 통해 관리 할 수 ​​있습니다. 여기에는 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; , &lt;code&gt;kotlinx.serialization&lt;/code&gt; 또는 &lt;code&gt;ktor-client&lt;/code&gt; 와 같은 Kotlin / Multiplatform 라이브러리가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">메이븐에서</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">Maven에서 &lt;code&gt;jpa&lt;/code&gt; 플러그인을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">Maven에서 &lt;code&gt;spring&lt;/code&gt; 플러그인을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="14be0db4481edc4ab423c4343db7ab0c7cfdc4a9" translate="yes" xml:space="preserve">
          <source>In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</source>
          <target state="translated">In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</target>
        </trans-unit>
        <trans-unit id="2fde5916b654de021cf5316e7c8446b2d071c3b3" translate="yes" xml:space="preserve">
          <source>In Maven:</source>
          <target state="translated">In Maven:</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">Python에서 함수 이름은 모듈 또는 클래스 내에서 고유해야합니다. Kotlin에서는 함수 를 &lt;em&gt;오버로드&lt;/em&gt; 할 수 있습니다. 이름이 같은 함수를 여러 번 선언 할 수 있습니다. 과부하 된 기능은 파라미터 목록을 통해 서로 구별 할 수 있어야합니다. (반환 유형과 함께 매개 변수 목록의 유형을 함수의 &lt;em&gt;시그니처&lt;/em&gt; 라고 하지만, 리턴 유형을 사용하여 오버로드 된 기능을 명확하게하는 데 사용할 수 없습니다.) 예를 들어,이 두 기능을 동일한 파일에 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">Python에서 기본값에 대한 표현식은 함수 정의시 한 번 평가됩니다. 이 고전적인 함정으로 이어집니다. 개발자는 &lt;code&gt;numbers&lt;/code&gt; 값없이 함수가 호출 될 때마다 새로운 빈 목록을 얻으려고 하지만 매번 동일한 목록이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">A의 &lt;code&gt;when&lt;/code&gt; 지점이 한 줄보다 더 많은 경우 문, 빈 라인과 인접한 경우 블록에서 분리 고려 :</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">오래 실행되는 응용 프로그램에서는 백그라운드 코 루틴에 대한 세밀한 제어가 필요할 수 있습니다. 예를 들어, 사용자가 코 루틴을 시작한 페이지를 닫았을 때 결과가 더 이상 필요하지 않고 작업을 취소 할 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;발사&lt;/a&gt; 함수는 반환 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업&lt;/a&gt; 실행중인 코 루틴을 취소 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">(A)의 부재 &lt;a href=&quot;classes#inheritance&quot;&gt;클래스&lt;/a&gt; , &lt;em&gt;이&lt;/em&gt; 클래스의 현재 오브젝트를 말한다.</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">간단히 말해서 Kotlin 프로젝트에서 &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; 과 같은 라이브러리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93e3893822831ac714d40df8280535305e6147f7" translate="yes" xml:space="preserve">
          <source>In a similar way to the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html&quot;&gt;collectLatest&lt;/a&gt; operator, that was shown in &lt;a href=&quot;#processing-the-latest-value&quot;&gt;&quot;Processing the latest value&quot;&lt;/a&gt; section, there is the corresponding &quot;Latest&quot; flattening mode where a collection of the previous flow is cancelled as soon as new flow is emitted. It is implemented by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html&quot;&gt;flatMapLatest&lt;/a&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;#processing-the-latest-value&quot;&gt;&quot;최신 값 처리&quot;&lt;/a&gt; 섹션 에 표시된 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html&quot;&gt;collectLatest&lt;/a&gt; 연산자 와 유사한 방식 으로 새 흐름이 생성되는 즉시 이전 흐름의 수집이 취소되는 해당 &quot;최신&quot;평면화 모드가 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html&quot;&gt;flatMapLatest&lt;/a&gt; 연산자에 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="15ca24684023d67ef7c14fca042f392a78539627" translate="yes" xml:space="preserve">
          <source>In a typical multiplatform project with two iOS-related targets &amp;ndash; &lt;code&gt;iosArm64&lt;/code&gt; and &lt;code&gt;iosX64&lt;/code&gt;, the hierarchical structure includes an intermediate source set (&lt;code&gt;iosMain&lt;/code&gt;), which is used by the platform-specific source sets.</source>
          <target state="translated">두 개의 iOS 관련 대상 ( &lt;code&gt;iosArm64&lt;/code&gt; 및 &lt;code&gt;iosX64&lt;/code&gt; ) 이있는 일반적인 멀티 플랫폼 프로젝트 에서 계층 구조에는 플랫폼 별 소스 세트에서 사용 하는 중간 소스 세트 ( &lt;code&gt;iosMain&lt;/code&gt; )가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bc60b5f1d9e8600ceb6b31da789280579a4f556c" translate="yes" xml:space="preserve">
          <source>In actual applications a scope will come from an entity with a limited lifetime. As soon as the lifetime of this entity is terminated the corresponding scope is cancelled, cancelling the collection of the corresponding flow. This way the pair of &lt;code&gt;onEach { ... }.launchIn(scope)&lt;/code&gt; works like the &lt;code&gt;addEventListener&lt;/code&gt;. However, there is no need for the corresponding &lt;code&gt;removeEventListener&lt;/code&gt; function, as cancellation and structured concurrency serve this purpose.</source>
          <target state="translated">실제 응용 프로그램에서 범위는 제한된 수명을 가진 엔터티에서 제공됩니다. 이 엔터티의 수명이 종료되는 즉시 해당 범위가 취소되고 해당 흐름의 수집이 취소됩니다. 이렇게하면 &lt;code&gt;onEach { ... }.launchIn(scope)&lt;/code&gt; &lt;code&gt;addEventListener&lt;/code&gt; 처럼 작동합니다 . 그러나 취소 및 구조화 된 동시성이이 목적을 수행 하므로 해당 &lt;code&gt;removeEventListener&lt;/code&gt; 함수 가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b7464c5f857646c373051a91afcc2339f5f7b93" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;#common-target-configuration&quot;&gt;common target configuration&lt;/a&gt;, &lt;code&gt;jvm&lt;/code&gt; targets have a specific function:</source>
          <target state="translated">이외에 &lt;a href=&quot;#common-target-configuration&quot;&gt;공통 타겟 구성&lt;/a&gt; , &lt;code&gt;jvm&lt;/code&gt; 대상은 특정 기능을 가지고</target>
        </trans-unit>
        <trans-unit id="b9d98c12799fcb8ef0ae80c451d81a3c8245f3f0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, a collector can also use a &lt;code&gt;finally&lt;/code&gt; block to execute an action upon &lt;code&gt;collect&lt;/code&gt; completion.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 외에도 수집기는 &lt;code&gt;finally&lt;/code&gt; 블록을 사용 하여 &lt;code&gt;collect&lt;/code&gt; 완료 시 작업을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">뿐만 아니라 &lt;strong&gt;밖으로&lt;/strong&gt; , 코 틀린은 보완 분산 주석을 제공 : &lt;strong&gt;에&lt;/strong&gt; . 유형 매개 변수를 &lt;strong&gt;반 변형으로&lt;/strong&gt; 만듭니다 . 소비 만 가능하며 절대로 생산할 수 없습니다. contravariant 유형의 좋은 예입니다 &lt;code&gt;Comparable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">&lt;a href=&quot;collection-parts&quot;&gt;콜렉션은 파트 콜렉션 검색에&lt;/a&gt; 대한 공통 조작 외에도 지정된 요소 범위의보기를 목록으로 리턴하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt; 함수를 제공 합니다. 따라서 원본 컬렉션의 요소가 변경되면 이전에 만든 하위 목록에서도 변경되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f8a12fad9d12380d0581bf388509c212413ee01b" translate="yes" xml:space="preserve">
          <source>In addition to predefined compilations, you can create your own custom compilations. To create a custom compilation, add a new item into the &lt;code&gt;compilations&lt;/code&gt; collection. If using Kotlin Gradle DSL, mark custom compilations &lt;code&gt;by creating&lt;/code&gt;.</source>
          <target state="translated">미리 정의 된 컴파일 외에도 사용자 지정 컴파일을 만들 수 있습니다. 사용자 지정 편집을 만들려면 &lt;code&gt;compilations&lt;/code&gt; 컬렉션에 새 항목을 추가합니다 . 코 틀린 Gradle을 DSL, 마크 사용자 정의 컴파일을 사용하는 경우 &lt;code&gt;by creating&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">요소를 제거하는 것 외에도 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt; 는 목록을 반복하면서 요소를 삽입하고 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">범위 함수 외에도 표준 라이브러리에는 &lt;code&gt;takeIf&lt;/code&gt; 및 &lt;code&gt;takeUnless&lt;/code&gt; 함수가 포함 됩니다. 이 함수를 사용하면 콜 체인에 객체 상태 확인을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1257110cb9cb8a007e2fdc06c4e2227ea7a3c26" translate="yes" xml:space="preserve">
          <source>In addition to suspend conversion on lambdas, Kotlin now supports suspend conversion on callable references starting from version 1.4.0.</source>
          <target state="translated">람다에서 변환을 일시 중지하는 것 외에도 Kotlin은 이제 버전 1.4.0부터 호출 가능한 참조에 대한 변환 일시 중지를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">또한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; 를 사용 하여 클래스에 해당하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; 인스턴스 에 액세스 할 수 있습니다 . &lt;code&gt;JsClass&lt;/code&gt; 의 인스턴스 생성자 자체 기능에 대한 참조이다. 생성자에 대한 참조가 필요한 JS 함수와 상호 운용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90b7801c53c4e41da0228b0d27c84622a6be4c2" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/JS compiler has the options listed below.</source>
          <target state="translated">&lt;a href=&quot;#common-options&quot;&gt;일반적인 옵션&lt;/a&gt; 외에도 Kotlin / JS 컴파일러에는 아래 나열된 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="858ccef9738a93100e88ac347adf42b1aff3915a" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/JVM compiler has the options listed below.</source>
          <target state="translated">&lt;a href=&quot;#common-options&quot;&gt;일반적인 옵션&lt;/a&gt; 외에도 Kotlin / JVM 컴파일러에는 아래 나열된 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c87fecf2d35b4b8f103d9e391aeb9f3722b8880" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#common-options&quot;&gt;common options&lt;/a&gt;, Kotlin/Native compiler has the options listed below.</source>
          <target state="translated">&lt;a href=&quot;#common-options&quot;&gt;일반적인 옵션&lt;/a&gt; 외에도 Kotlin / Native 컴파일러에는 아래 나열된 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b7ccec26bcb88294baf54023cc9ae72ecaa90f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt;&lt;code&gt;as&lt;/code&gt;, which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt;&lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt;, &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</source>
          <target state="translated">In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt; &lt;code&gt;as&lt;/code&gt; , which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt; &lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt; , &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">위에 표시된 &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 종속성 외에도 Kotlin 표준 라이브러리에 대한 종속성을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">빌드 작업 외에도 Gradle 빌드에는 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; 및 &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; 를 통해 애플리케이션을 직접 실행하는 유용한 작업이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">설명 컬렉션 수정 작업 외에도 &lt;a href=&quot;collection-write&quot;&gt;컬렉션 쓰기 작업&lt;/a&gt; , &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능한&lt;/a&gt; 목록은 특정 쓰기 작업을 지원합니다. 이러한 작업은 색인을 사용하여 요소에 액세스하여 목록 수정 기능을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">명령 행 컴파일러 및 IntelliJ IDEA 외에도 Ant, Maven 및 Gradle을 사용하여 Kotlin 프로젝트를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">다른 빌더가 제공하는 코 루틴 범위 외에도 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 빌더를 사용하여 고유 한 범위를 선언 할 수 있습니다 . 코 루틴 범위를 작성하고 시작된 모든 하위 항목이 완료 될 때까지 완료되지 않습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 과 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 의 주요 차이점 은 후자가 모든 자식이 완료 될 때까지 기다리는 동안 현재 스레드를 차단하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5077ac7f8cceff0957d255db71b0d1a0a24a0ba" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</source>
          <target state="translated">In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">출력 JavaScript 파일 외에도 플러그인은 기본적으로 이진 설명자가 포함 된 추가 JS 파일을 만듭니다. 이 파일은 다른 Kotlin 모듈이 의존 할 수있는 재사용 가능한 라이브러리를 작성하고 번역 결과와 함께 배포해야하는 경우에 필요합니다. 생성은 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">또한 Rx는 오류 처리에 대해 좀 더 멋진 접근 방식을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">또한 이들 각각에는 리플렉션 및 기타 기능에 사용되는 해당 &lt;code&gt;{file}.meta.js&lt;/code&gt; 메타 파일도 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">모든 경우에 C 문자열은 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">기본적으로 getter 및 setter를 사용하여 개인 속성에 대한 액세스가 최적화되어 함수 호출 오버 헤드가 발생하지 않기 때문에 이는 Java와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">에 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 또는 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기 기능 리터럴 &lt;/a&gt;&lt;em&gt;이&lt;/em&gt; 나타낸다 &lt;em&gt;수신&lt;/em&gt; 점의 좌측에 전달되는 파라미터.</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">인라인 함수 정의에서 함수 유형 매개 변수 앞에 &lt;code&gt;noinline&lt;/code&gt; 을 사용 하여 전달되는 람다가 인라인되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">모든 목록에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 요소의 위치를 ​​찾을 수 있습니다 . 리스트에서 주어진 인수와 같은 요소의 첫 번째와 마지막 위치를 리턴합니다. 그러한 요소가 없으면 두 함수 모두 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="28ad7357688ca2a3f1fc903df2a6eb9517f15794" translate="yes" xml:space="preserve">
          <source>In any target block, you can use the following declarations:</source>
          <target state="translated">모든 대상 블록에서 다음 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">접근 방식에서는 Future와 매우 유사하지만 Future를 개별 요소를 반환하는 것으로 생각할 수 있습니다. Rx는 스트림을 반환합니다. 그러나 이전과 마찬가지로 프로그래밍 모델에 대한 완전히 새로운 사고 방식을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">두 항목이 동일한 키에 매핑되는 경우 후자의 값이 이전의 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; 에서 예외가 발생하여 자원이 닫히고 예외가 발생 하여 종료에 실패한 경우에는 전자가 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;억제 된&lt;/a&gt; 예외에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="753affb3f26053a8d6fe6a50898f37935f2da6a8" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</source>
          <target state="translated">In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">공백 문자 앞에 공백 문자가없는 경우 (공백 없음) 공통 들여 쓰기는 0이므로이 함수는 들여 쓰기를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">디스패치 수신기와 확장 수신기의 구성원간에 이름이 충돌하는 경우 확장 수신기가 우선합니다. 디스패치 수신자의 멤버를 참조하기 위해 &lt;a href=&quot;this-expressions#qualified&quot;&gt;규정 된 &lt;code&gt;this&lt;/code&gt; 구문을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">클래스의 확장 속성의 경우 클래스의 인스턴스가 먼저 전달되고 확장 수신기의 인스턴스가 두 번째로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">이 유형이 내부 클래스를 기반으로하는 경우, 리턴 된 목록에는 가장 안쪽 클래스에 먼저 제공된 유형 인수가 포함 된 다음 외부 클래스 등이 포함됩니다. 예를 들어, &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; 에서 리턴 된 목록은 &lt;code&gt;[C, D, A, B]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">인라인 함수로 전달 된 일부 람다 만 인라인되도록하려면 &lt;code&gt;noinline&lt;/code&gt; 수정자를 사용하여 일부 함수 매개 변수를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">함수 인 &lt;code&gt;use&lt;/code&gt; 가 어떻게 그런 블록 뒤에 올 수 있는지 궁금하다면 &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL 지원&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">일반적인 코드에서 :</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">본질적으로 이것은 다음 코드를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">실제로 Kotlin은 속성을 선언하고 기본 생성자에서 초기화하기 위해 간결한 구문을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">추가 섹션에서 이러한 개념은 프로젝트에서 구성하기 위해 DSL과 함께 자세히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="b8f977357563759de0c40c521cc75a6bcef24abd" translate="yes" xml:space="preserve">
          <source>In future versions, the hierarchical project structure will become default for Kotlin multiplatform project, so we strongly encourage you to start using it now.</source>
          <target state="translated">향후 버전에서는 계층 적 프로젝트 구조가 Kotlin 멀티 플랫폼 프로젝트의 기본값이 될 것이므로 지금 사용을 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7ca8fe04f8968119833a10d8a0204e9737ceb843" translate="yes" xml:space="preserve">
          <source>In future versions, the hierarchical project structure with the usage of platform-dependent libraries in shared source sets will be the default in multiplatform projects. So the sooner you support it, the sooner users will be able to migrate. We&amp;rsquo;ll also be very grateful if you report any bugs you find to our &lt;a href=&quot;http://kotl.in/issue&quot;&gt;issue tracker.&lt;/a&gt;</source>
          <target state="translated">향후 버전에서는 공유 소스 세트에서 플랫폼 종속 라이브러리를 사용하는 계층 적 프로젝트 구조가 다중 플랫폼 프로젝트의 기본값이 될 것입니다. 따라서 더 빨리 지원할수록 사용자가 더 빨리 마이그레이션 할 수 있습니다. 또한 발견 한 버그를 &lt;a href=&quot;http://kotl.in/issue&quot;&gt;이슈 트래커에&lt;/a&gt; 보고 해 주시면 매우 감사하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">일반적으로 소규모 프로젝트의 경우 모든 파일을 한 번에 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">일반적으로 식별자는 문자, 숫자 및 밑줄로 구성 될 수 있으며 숫자로 시작하지 않을 수 있습니다. 그러나 식별자를 기반으로 JSON을 자동 생성하는 코드를 작성하고 있고 JSON 키가 이러한 규칙을 따르지 않거나 키워드와 충돌하는 문자열이되도록하려면 코드를 백틱으로 묶을 &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; 는 유효한 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">일반적으로 Kotlin의 특정 구문 구조가 선택적이고 IDE에서 중복으로 강조 표시되는 경우 코드에서 생략해야합니다. &quot;명확성을 위해&quot;불필요한 구문 요소를 코드에 두지 마십시오.</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">일반적으로 이러한 클래스의 인스턴스를 만들려면 형식 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">생성 된 코드에서 Kotlin 컴파일러 는 각 인라인 클래스에 대한 &lt;em&gt;래퍼&lt;/em&gt; 를 유지합니다 . 인라인 클래스 인스턴스는 런타임시 랩퍼 또는 기본 유형으로 표시 될 수 있습니다. 이것은 &lt;code&gt;Int&lt;/code&gt; 가 프리미티브 &lt;code&gt;int&lt;/code&gt; 또는 래퍼 &lt;code&gt;Integer&lt;/code&gt; 로 &lt;a href=&quot;basic-types#representation&quot;&gt;표시&lt;/a&gt; 되는 방법과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">람다 식에서 매개 변수를 본문과 구분하는 화살표뿐만 아니라 중괄호 주위에 공백을 사용해야합니다. 호출이 단일 람다를 사용하는 경우 가능할 때마다 괄호 외부로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">짧고 중첩되지 않은 람다에서는 매개 변수를 명시 적으로 선언하는 대신 &lt;code&gt;it&lt;/code&gt; 규칙 을 사용하는 것이 좋습니다 . 매개 변수가있는 중첩 된 람다에서 매개 변수는 항상 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">긴 인수 목록에서 여는 괄호 뒤에 줄 바꿈을 넣으십시오. 인수를 4 칸 들여 쓰기 밀접하게 관련된 여러 인수를 같은 줄에 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">대부분의 경우 컴파일러는 Kotlin에서 명시 적 캐스트 연산자를 사용할 필요가 없습니다. 컴파일러는 &lt;code&gt;is&lt;/code&gt; - checks 및 불변 값에 대한 &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;명시 적 캐스트&lt;/a&gt; 를 추적하고 필요할 때 자동으로 삽입 (안전한) 캐스트를 추적하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">혼합 언어 프로젝트에서 Kotlin 소스 파일은 Java 소스 파일과 동일한 소스 루트에 있어야하며 동일한 디렉토리 구조를 따라야합니다 (각 파일은 각 패키지 명령문에 해당하는 디렉토리에 저장되어야 함).</target>
        </trans-unit>
        <trans-unit id="75f610c8e81d1558fc92e1b43e9b512e7f4028a1" translate="yes" xml:space="preserve">
          <source>In modules that don't expose their own API, such as applications, you can opt in to using APIs without propagating the opt-in requirement to your code. In this case, mark your declaration with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-opt-in/index&quot;&gt;@OptIn&lt;/a&gt; passing the opt-in requirement annotation as its argument:</source>
          <target state="translated">애플리케이션과 같이 자체 API를 노출하지 않는 모듈에서는 옵트 인 요구 사항을 코드에 전파하지 않고 API 사용을 옵트 인 할 수 있습니다. 이 경우 옵트 인 요구 사항 주석을 인수로 전달하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-opt-in/index&quot;&gt;@OptIn으로&lt;/a&gt; 선언을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">응용 프로그램 모듈과 같이 자체 API를 제공하지 않는 모듈에서는 실험 상태를 코드로 전파하지 않고도 실험용 API를 사용할 수 있습니다. 이 경우 실험 API의 마커 주석을 지정하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental (Marker :: class)&lt;/a&gt; 주석으로 코드를 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">대부분의 경우 Kotlin은 Java 코딩 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">여러 줄 모드에서 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 식은 각각 줄 종결 자 또는 입력 시퀀스의 끝 바로 앞 또는 바로 앞과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">애플리케이션을 어셈블하려면 Kotlin 표준 라이브러리 (예 : 종속성으로 포함 된 &lt;code&gt;kotlin.js&lt;/code&gt; )와 다른 라이브러리 (있는 경우)도 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">Xcode 빌드 중에 호환성 문제를 피하려면 플러그인에 &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle 래퍼를&lt;/a&gt; 사용해야합니다 . &lt;code&gt;podspec&lt;/code&gt; 태스크 실행 중 랩퍼를 자동으로 생성하려면 &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; 매개 변수 를 사용하여 랩퍼를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c80bd17bf7329417ed7785f5f956f7d5c5ca2880" translate="yes" xml:space="preserve">
          <source>In order to avoid confusion about artifact names, we&amp;rsquo;ve renamed &lt;code&gt;kotlin-scripting-jsr223-embeddable&lt;/code&gt; and &lt;code&gt;kotlin-scripting-jvm-host-embeddable&lt;/code&gt; to just &lt;code&gt;kotlin-scripting-jsr223&lt;/code&gt; and &lt;code&gt;kotlin-scripting-jvm-host&lt;/code&gt;. These artifacts depend on the &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; artifact, which shades the bundled third-party libraries to avoid usage conflicts. With this renaming, we&amp;rsquo;re making the usage of &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; (which is safer in general) the default for scripting artifacts. If, for some reason, you need artifacts that depend on the unshaded &lt;code&gt;kotlin-compiler&lt;/code&gt;, use the artifact versions with the &lt;code&gt;-unshaded&lt;/code&gt; suffix, such as &lt;code&gt;kotlin-scripting-jsr223-unshaded&lt;/code&gt;. Note that this renaming affects only the scripting artifacts that are supposed to be used directly; names of other artifacts remain unchanged.</source>
          <target state="translated">아티팩트 이름에 대한 혼동을 피하기 위해 &lt;code&gt;kotlin-scripting-jsr223-embeddable&lt;/code&gt; 및 &lt;code&gt;kotlin-scripting-jvm-host-embeddable&lt;/code&gt; 을 &lt;code&gt;kotlin-scripting-jsr223&lt;/code&gt; 및 &lt;code&gt;kotlin-scripting-jvm-host&lt;/code&gt; 로 변경했습니다 . 이러한 아티팩트는 &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; 아티팩트 에 의존하며, 사용 충돌을 피하기 위해 번들로 제공되는 타사 라이브러리를 음영 처리합니다. 이 이름 변경으로 &lt;code&gt;kotlin-compiler-embeddable&lt;/code&gt; (일반적으로 더 안전함)을 스크립팅 아티팩트의 기본값으로 사용합니다. 어떤 이유로 음영 처리 &lt;code&gt;kotlin-compiler&lt;/code&gt; 않은 kotlin-compiler 에 의존하는 아티팩트가 필요한 경우 다음과 같이 &lt;code&gt;-unshaded&lt;/code&gt; 접미사가 있는 아티팩트 버전을 사용하십시오. &lt;code&gt;kotlin-scripting-jsr223-unshaded&lt;/code&gt; . 이 이름 변경은 직접 사용되어야하는 스크립팅 아티팩트에만 영향을 미칩니다. 다른 유물의 이름은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="320ea67fc7a407c39652cf848b66d1bac7958814" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</source>
          <target state="translated">In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">Gradle을 가진 코 틀린 프로젝트를 구축하기 위해, 당신은해야 &lt;a href=&quot;#plugin-and-versions&quot;&gt;셋업 &lt;em&gt;코 틀린-Gradle을&lt;/em&gt; 플러그인을&lt;/a&gt; , &lt;a href=&quot;#targeting-the-jvm&quot;&gt;적용&lt;/a&gt; 프로젝트와 &lt;a href=&quot;#configuring-dependencies&quot;&gt;추가 &lt;em&gt;- 다음 stdlib 코 틀린&lt;/em&gt; 종속성을&lt;/a&gt; . 이러한 조치는 IntelliJ IDEA에서 &lt;strong&gt;도구 | 코 틀린 | &lt;/strong&gt;&lt;strong&gt;프로젝트&lt;/strong&gt; 작업 에서 &lt;strong&gt;Kotlin&lt;/strong&gt; 을 &lt;strong&gt;구성하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">JavaScript 코드를 컴파일 하려면 &lt;code&gt;compile&lt;/code&gt; 실행을 위해 &lt;code&gt;js&lt;/code&gt; 및 &lt;code&gt;test-js&lt;/code&gt; 목표 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">IntelliJ IDEA를 사용하여 응용 프로그램을 디버깅하려면 다음 두 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">이러한 바인딩 을 생성하려면 생성해야하는 헤더에 대한 정보가 포함 된 라이브러리 정의 &lt;code&gt;.def&lt;/code&gt; 파일 을 작성 해야합니다. 우리의 경우 유명한 &lt;code&gt;libcurl&lt;/code&gt; 라이브러리 를 사용하여 HTTP 호출을 만들고 &lt;code&gt;libcurl.def&lt;/code&gt; 때문에 다음 내용으로 libcurl.def 라는 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">실행하려면 배포 할 해당 WAR이 필요합니다. IntelliJ IDEA의 Gradle 도구 창을 통해 쉽게 실행할 수있는 Gradle 의 &lt;em&gt;war&lt;/em&gt; 태스크를 사용하여이를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">프로젝트 개발자 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 폴더 에서 변경 사항을 공유하려면 VCS에 커밋해야합니다. 대안 &lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;쓸모가&lt;/strong&gt; Gradle을 구성 또는 메이븐 프로젝트에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">모든 프로젝트 개발자를 위해 이러한 변경 사항을 공유하려면 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 폴더를 VCS에 커밋해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">모듈 종류를 지정하기 위해 다음과 같이 플러그인에 구성을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">잠재적으로 널 입력 가능 유형을 지원하려면 Objc 헤더가 널 입력 가능 리턴 값으로 &lt;code&gt;myVal&lt;/code&gt; 을 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="de88f4d0de61705bae1956451c94335904114bb9" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">자바 스크립트를 대상으로 Gradle을을 사용하기 위해, 우리는 사용할 필요가 &lt;code&gt;kotlin2js&lt;/code&gt; 받는 반대로 플러그인 &lt;code&gt;kotlin&lt;/code&gt; 플러그인을.</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">node.js와 함께 Kotlin을 사용하려면 CommonJS를 사용하도록 컴파일러 옵션을 설정해야합니다. 그렇게하면 노드 모듈 시스템을 사용하여 응용 프로그램의 출력에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">코 루틴을 사용하고이 안내서의 예를 따르려면 &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;README 프로젝트에&lt;/a&gt; 설명 된 대로 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 모듈 에 대한 종속성을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc71e5241592939229f3aa2e6f5ed18f17024e17" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">패키지에서 무언가를 사용하려면 패키지 이름을 사용하여 심볼을 사용하는 위치에서 심볼 이름을 완전히 규정하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">이를 사용하려면 응용 프로그램에 Kotlin 표준 라이브러리 (예 : 종속성으로 포함 된 &lt;code&gt;kotlin.js&lt;/code&gt; )도 포함해야합니다. 기본적으로 Maven은 빌드 프로세스의 일부로 JAR을 확장하지 않으므로 빌드에 추가 단계를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">다시 말해, 인라인 클래스 는 기존 유형에 대한 대체 이름 (별칭) 만 도입하는 유형 별명과 달리 진정으로 &lt;em&gt;새로운&lt;/em&gt; 유형을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">DSL에서 모든 태그 클래스는 동일한 수퍼 클래스 &lt;code&gt;Tag&lt;/code&gt; 를 확장합니다 . &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 로 수퍼 클래스에만 주석을 달면 충분하며 그 후에 Kotlin 컴파일러는 상속 된 모든 클래스를 주석이 달린 것으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 빌더를 사용하여 코 루틴으로 변환되는 &lt;code&gt;main&lt;/code&gt; 기능이 있습니다. &lt;code&gt;runBlocking&lt;/code&gt; 을 포함한 모든 코 루틴 빌더 는 코드 블록의 범위에 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; 인스턴스를 추가합니다 . 범위에서 실행 된 모든 코 루틴이 완료 될 때까지 외부 코 루틴 (이 예에서는 &lt;code&gt;runBlocking&lt;/code&gt; )이 완료되지 않으므로이 범위에서 코 루틴을 명시 적으로 &lt;code&gt;join&lt;/code&gt; 하지 않고도 실행할 수 있습니다 . 따라서 예제를 더 단순하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b76b0743b9831752920932ff5a5625568afac3" translate="yes" xml:space="preserve">
          <source>In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt; , adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine ( &lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">우리의 주요 함수에서 우리는 활동을 생성하고, 테스트 &lt;code&gt;doSomething&lt;/code&gt; 함수를 호출하고 , 500ms 후에 활동을 파괴합니다. 이렇게하면 시작된 모든 코 루틴이 취소되며, 기다릴 경우 더 이상 화면에 인쇄되지 않음을 확인하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8567ecf52dbb46832894d62cc3534eccec93e924" translate="yes" xml:space="preserve">
          <source>In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt;. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</source>
          <target state="translated">In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt; . We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">특히이 클래스의 모든 클라이언트와 관련된 클래스의 확장 함수를 정의 할 때는 클래스 자체가 정의 된 동일한 파일에 추가하십시오. 특정 클라이언트에게만 적합한 확장 기능을 정의 할 때는 해당 클라이언트의 코드 옆에 두십시오. &quot;Foo의 모든 확장명&quot;을 담기 위해 파일을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">실제로 컴파일시 일부 변경 사항을 정확하게 감지 할 수 없으므로 경고를보고 할 수 없지만 최소한 버전 A의 릴리스 정보를 통해 버전 B에서 변경 사항이 있음을 사용자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">실제로는 약간의 코드가 영향을 받기 때문에 주요 코드 스타일 업데이트로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">실제로 스레드 제한은 큰 청크로 수행됩니다. 예를 들어 상태 업데이트 비즈니스 로직의 큰 부분이 단일 스레드로 제한됩니다. 다음 예제는 단일 스레드 컨텍스트에서 각 코 루틴을 실행하여 시작합니다.</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">프로그레시브 모드에서는 언어 시맨틱의 일부 수정 사항이 즉시 도착할 수 있습니다. 이 모든 수정에는 두 가지 중요한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe450a289b0de3b7d5e96c5607691481e36cec05" translate="yes" xml:space="preserve">
          <source>In projects created from IntelliJ IDEA or AppCode templates these &lt;code&gt;.dSYM&lt;/code&gt; bundles are then discovered by Xcode automatically.</source>
          <target state="translated">IntelliJ IDEA 또는 AppCode 템플릿에서 생성 된 프로젝트에서 이러한 &lt;code&gt;.dSYM&lt;/code&gt; 번들은 Xcode에 의해 자동으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="eff40107a95c01dec77eae6fb0ec0b96a075ea6f" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</source>
          <target state="translated">In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">순수한 Kotlin 프로젝트에서 권장되는 디렉토리 구조는 공통 루트 패키지가 생략 된 패키지 구조를 따르는 것입니다 (예 : 프로젝트의 모든 코드가 &quot;org.example.kotlin&quot;패키지 및 하위 패키지에있는 경우 &quot;org .example.kotlin &quot;패키지는 소스 루트 바로 아래에 배치해야하며&quot;org.example.kotlin.foo.bar &quot;의 파일은 소스 루트의&quot;foo / bar &quot;하위 디렉토리에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c30c378469f41e6f1d1072007ebada7e490b3451" translate="yes" xml:space="preserve">
          <source>In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">간단히 말하면 &lt;em&gt;정수 선언을 신중하게 생각하고 값이 유형의 한계보다 클 필요는 없다는 것을 절대적으로 확신하십시오! &lt;/em&gt;무제한 크기의 정수가 필요한 경우 기본이 아닌 유형 &lt;code&gt;BigInteger&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">이와 같은 상황에서는 &lt;code&gt;dynamic&lt;/code&gt; 유형을 사용하여 JavaScript를 타겟팅 할 때 동적 유형으로 작업 할 수 있습니다. 다음 변수는 &lt;code&gt;dynamic&lt;/code&gt; 으로 선언되어 우리가 호출하는 것이 컴파일 타임 오류를 일으키지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">일부 경우 (예 : 과부하 지원) Kotlin 컴파일러는 생성 된 함수의 이름과 JavaScript 코드에서 속성을 맹 글링합니다. 생성 된 이름을 제어하기 위해 &lt;code&gt;@JsName&lt;/code&gt; 어노테이션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1f62f22b0a379feb738d1ada9b061745859834e" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">경우에 따라 인수가없는 함수는 읽기 전용 속성과 호환 될 수 있습니다. 시맨틱은 유사하지만 서로 선호하는시기에 대한 스타일 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">어떤 방식으로, 조작이 값에 적용되는 순서대로 지정되므로 읽기가 더 쉽습니다. 결과는 불변 인 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;T&lt;/code&gt; 는 사용하는 변환에 의해 생성되는 유형 (이 경우 &lt;code&gt;String&lt;/code&gt; )입니다. 변경 가능한 목록이 필요한 경우 마지막에 &lt;code&gt;toMutableList()&lt;/code&gt; 를 호출 하십시오. 세트를 원하면 &lt;code&gt;toSet()&lt;/code&gt; 또는 &lt;code&gt;toMutableSet()&lt;/code&gt; 을 호출 하십시오. 콜렉션을 맵으로 변환하려는 경우 &lt;code&gt;associateBy()&lt;/code&gt; 호출하십시오.이 메소드 는 각 요소에서 키와 값을 추출하는 방법을 지정하는 두 개의 람다를 사용합니다. &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; 전체 요소를 값으로 사용하려면 두 번째 람다를 생략 하고 결과를 변경하려면 끝에 &lt;code&gt;toMutableMap()&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">사용중인 &lt;code&gt;object&lt;/code&gt; 키워드 에도 불구하고 객체 표현식이 평가 될 때마다 익명 클래스의 새 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">이 구문상의 편의성에도 불구하고 동반 객체는 자체적으로 적절한 객체이며 자체 슈퍼 유형을 가질 수 있으며 변수에 할당하고 전달할 수 있습니다. Java 코드와 통합하고 진정한 &lt;code&gt;static&lt;/code&gt; 멤버 가 필요한 경우 &lt;code&gt;@JvmStatic&lt;/code&gt; 을 사용 하여 컴패니언 객체 내부에 멤버에 &lt;a href=&quot;annotations&quot;&gt;주석을 달&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">이후의 자습서에서는 위치, 접두사 및 접미사 변경과 같이 생성 된 파일에 영향을 줄 수있는 방법과 모듈 작업 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bc19aea0692b9f67e799748ba127b1fc2dfa9708" translate="yes" xml:space="preserve">
          <source>In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">테스트 (및 테스트에서만)에는 공백으로 백틱으로 묶인 메소드 이름을 사용할 수 있습니다. (이러한 메소드 이름은 현재 Android 런타임에서 지원되지 않습니다.) 메소드 이름의 밑줄도 테스트 코드에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">이 경우 스프레드 연산자 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 &lt;code&gt;IntArray&lt;/code&gt; 를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a1e90ae09efa8b0693d6eb0e54489eb2ffa5613b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</source>
          <target state="translated">In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">에서 &lt;a href=&quot;#enabling-experimental-features&quot;&gt;실험 모드&lt;/a&gt; , 당신은 어떤 변형 이름 (뿐만 아니라 맛), 예를 지정할 수 있습니다 &lt;code&gt;freeDebug&lt;/code&gt; 을 하거나 &lt;code&gt;freeRelease&lt;/code&gt; 는 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">에서 &lt;code&gt;libnative_api.h&lt;/code&gt; , 우리는 다음과 같은 코드를 찾을 수 있습니다. 이해하기 쉽도록 코드를 부분적으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6da10c50e0a522e1434416a4209979f6b0add877" translate="yes" xml:space="preserve">
          <source>In the &lt;strong&gt;Coroutines&lt;/strong&gt; tab, you can see that there are two coroutines running concurrently. The flow collector and emitter run in separate coroutines because of the &lt;code&gt;buffer()&lt;/code&gt; function. The &lt;code&gt;buffer()&lt;/code&gt; function buffers emitted values from the flow. The emitter coroutine has the &lt;strong&gt;RUNNING&lt;/strong&gt; status, and the collector coroutine has the &lt;strong&gt;SUSPENDED&lt;/strong&gt; status.</source>
          <target state="translated">에서 &lt;strong&gt;코 루틴&lt;/strong&gt; 탭, 당신은 동시에 실행되는 두 개의 코 루틴이 있다는 것을 알 수있다. 흐름 수집기와 이미 터는 &lt;code&gt;buffer()&lt;/code&gt; 함수로 인해 별도의 코 루틴에서 실행됩니다 . &lt;code&gt;buffer()&lt;/code&gt; 함수는 버퍼 흐름 값을 출사. 이미 터 코 루틴은 &lt;strong&gt;RUNNING&lt;/strong&gt; 상태이고 컬렉터 코 루틴은 &lt;strong&gt;SUSPENDED&lt;/strong&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Gradle 의존성에서 &lt;code&gt;kotlin-kapt&lt;/code&gt; 플러그인을 추가하고 &lt;code&gt;annotationProcessor&lt;/code&gt; 를 &lt;code&gt;kapt&lt;/code&gt; 로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">JavaScript 세계에서는 완전히 다른 API 세트를 사용할 수 있으므로 대신 콘솔에 로깅을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="028c1035d4940563c6ebb4f5acb53d3747a67767" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, the most common way to manage dependencies is &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;. It offers the biggest public repository of JavaScript modules.</source>
          <target state="translated">JavaScript 세계에서 종속성을 관리하는 가장 일반적인 방법은 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 입니다. JavaScript 모듈의 가장 큰 공용 저장소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc47ebd8b09857b2d92aa6e80c268cb28a620e3a" translate="yes" xml:space="preserve">
          <source>In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</source>
          <target state="translated">In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</target>
        </trans-unit>
        <trans-unit id="f4819cf70d4fd8479a3ad5972f4f49ad73e7b787" translate="yes" xml:space="preserve">
          <source>In the build script of an existing project.</source>
          <target state="translated">기존 프로젝트의 빌드 스크립트에서.</target>
        </trans-unit>
        <trans-unit id="f33ac82cc0a362095e9dc9d1c2c9f6a2f067dea1" translate="yes" xml:space="preserve">
          <source>In the case where you have a busy loop with coroutines you must explicitly check for cancellation. You can add &lt;code&gt;.onEach { currentCoroutineContext().ensureActive() }&lt;/code&gt;, but there is a ready-to-use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html&quot;&gt;cancellable&lt;/a&gt; operator provided to do that:</source>
          <target state="translated">코 루틴이있는 바쁜 루프가있는 경우 취소 여부를 명시 적으로 확인해야합니다. &lt;code&gt;.onEach { currentCoroutineContext().ensureActive() }&lt;/code&gt; 추가 할 수 있지만이를 위해 즉시 사용할 수있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/cancellable.html&quot;&gt;취소 가능한&lt;/a&gt; 연산자가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">위의 코드에서, 매개 변수는 &lt;code&gt;combine&lt;/code&gt; 갖는 &lt;a href=&quot;#function-types&quot;&gt;기능 타입 &lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; 가 수용되도록 타입의 두 개의 인자를 취하는 함수 &lt;code&gt;R&lt;/code&gt; 과 &lt;code&gt;T&lt;/code&gt; 형의 복귀 값 &lt;code&gt;R&lt;/code&gt; 을 . 그것은되는 &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;호출&lt;/a&gt; 공진 영역 &lt;em&gt;에 대한&lt;/em&gt; -loop 및 반환 값은 다음에 할당 된 &lt;code&gt;accumulator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">위의 예에서 JVM 대상의 프로덕션 소스는 &lt;code&gt;main&lt;/code&gt; 컴파일에 의해 컴파일되므로 소스 세트 &lt;code&gt;jvmMain&lt;/code&gt; 및 &lt;code&gt;commonMain&lt;/code&gt; 의 소스 및 종속성 ( 관계에 &lt;em&gt;따라 달라짐&lt;/em&gt; )이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;DbModel&lt;/code&gt; 기본 클래스가 있고 모든 하위 클래스에 매개 변수가없는 기본 생성자 가 있다고 가정합니다 . 인라인 함수에서 &lt;code&gt;T&lt;/code&gt; 가 구체화되어 클래스 메타 데이터를 얻을 수 있습니다. 우리는 이것을 데이터베이스와 대화하는 실제 작업을 수행하는 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">이 예에서는 C 언어로 문자열을 전달하거나받는 가장 일반적인 방법이 있습니다. &lt;code&gt;return_string&lt;/code&gt; 을주의 해서 반환해야 합니다. 일반적으로 올바른 함수를 사용하여 반환 된 &lt;code&gt;char*&lt;/code&gt; 를 올바른 &lt;code&gt;free(..)&lt;/code&gt; 함수 호출 과 함께 처리하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9c4a8189e026c3c979db7e1d0680469a7fc5819f" translate="yes" xml:space="preserve">
          <source>In the file &lt;code&gt;build.gradle&lt;/code&gt;(&lt;code&gt;.kts&lt;/code&gt;), it creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level, which includes configuration for &lt;a href=&quot;#targets&quot;&gt;targets&lt;/a&gt;, &lt;a href=&quot;#source-sets&quot;&gt;source sets&lt;/a&gt;, and dependencies.</source>
          <target state="translated">&lt;code&gt;build.gradle&lt;/code&gt; ( &lt;code&gt;.kts&lt;/code&gt; ) 파일 에서 최상위 수준에 &lt;code&gt;kotlin&lt;/code&gt; 확장을 생성하며 여기에는 &lt;a href=&quot;#targets&quot;&gt;targets&lt;/a&gt; , &lt;a href=&quot;#source-sets&quot;&gt;source sets&lt;/a&gt; 및 종속성에 대한 구성이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">다음 예제에서 &lt;code&gt;findViewById()&lt;/code&gt; 는 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="85d9d8db073dbd0210787c9cf3ee16c0de44fcc4" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;@Foo&lt;/code&gt; annotation on the &lt;code&gt;String&lt;/code&gt; type can be emitted to the bytecode and then used by the library code:</source>
          <target state="translated">다음 예제 에서 &lt;code&gt;String&lt;/code&gt; 유형 의 &lt;code&gt;@Foo&lt;/code&gt; 주석을 바이트 코드로 내 보낸 다음 라이브러리 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6112ecb85c5a211c4961aa021f824a1d2e0e8f5" translate="yes" xml:space="preserve">
          <source>In the future, we are going to make the Kotlin Project Wizard even more flexible by adding more configuration options and templates.</source>
          <target state="translated">앞으로 더 많은 구성 옵션과 템플릿을 추가하여 Kotlin 프로젝트 마법사를 더욱 유연하게 만들 예정입니다.</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">생성 된 Kotlin 선언에서 &lt;code&gt;str&lt;/code&gt; 이 &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; . 타입은 nullable이며, Kotlin &lt;code&gt;null&lt;/code&gt; 을 파라미터 값으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">생성 된 코드에서 &lt;code&gt;provideDelegate&lt;/code&gt; 메소드가 호출되어 보조 &lt;code&gt;prop$delegate&lt;/code&gt; 특성 을 초기화합니다 . 속성 선언 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 에 대해 생성 된 코드를 &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;위&lt;/a&gt; 의 생성 된 코드와 비교하십시오 ( &lt;code&gt;provideDelegate&lt;/code&gt; 메소드가없는 경우).</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">마지막 행 에서 &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; 플러그인을 사용하여 &lt;code&gt;id&lt;/code&gt; 로 &lt;code&gt;button&lt;/code&gt; 을 참조합니다 . 이 플러그인을 대안으로 사용하여 바인딩 로직을 코드로 유지하고 간결한 구문을 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">마지막 줄에는 암시적인 내용 &lt;code&gt;this.&lt;/code&gt; &lt;code&gt;memberFunction()&lt;/code&gt; 및 &lt;code&gt;memberProperty&lt;/code&gt; (이는 &lt;code&gt;someExpression&lt;/code&gt; 유형에있는 경우 ) 앞에 있습니다. 리턴 값은 마지막 표현식의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">다음 대화 상자에서 프로젝트 세부 사항을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">이전 모델에서는 공통 및 플랫폼 별 코드를 &lt;code&gt;expectedBy&lt;/code&gt; 종속성으로 연결된 별도의 모듈에 배치해야했습니다 . 이제 공통 및 플랫폼 별 코드가 동일한 모듈의 다른 소스 루트에 배치되어 프로젝트를보다 쉽게 ​​구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4616b5b5607f26fa0ff8085e2e0b28efc427ec9" translate="yes" xml:space="preserve">
          <source>In the panel on the left, select &lt;strong&gt;Kotlin&lt;/strong&gt;.</source>
          <target state="translated">왼쪽 패널에서 &lt;strong&gt;Kotlin을&lt;/strong&gt; 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; 플러그인 이 있으면 빌드 된 모든 바이너리에 대한 발행물이 작성됩니다. 플러그인은 Gradle 메타 데이터를 사용하여 아티팩트를 공개하므로이 기능을 사용해야합니다 ( &lt;a href=&quot;#dependencies&quot;&gt;종속성&lt;/a&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">이전 예제에서 JavaScript 모듈은 단일 패키지를 내 보냅니다. 그러나 일부 JavaScript 라이브러리는 모듈 내에서 여러 패키지를 내 보냅니다. 이 사례는 Kotlin에서도 지원되지만 가져 오는 각 패키지에 대해 새 &lt;code&gt;.kt&lt;/code&gt; 파일 을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2335f133bdfdd7a364b034cd26ff1377b715b5ad" translate="yes" xml:space="preserve">
          <source>In the progressive mode, deprecations and bug fixes for unstable code take effect immediately, instead of going through a graceful migration cycle. Code written in the progressive mode is backwards compatible; however, code written in a non-progressive mode may cause compilation errors in the progressive mode.</source>
          <target state="translated">프로그레시브 모드에서는 정상적인 마이그레이션주기를 거치지 않고 불안정한 코드에 대한 지원 중단 및 버그 수정이 즉시 적용됩니다. 프로그레시브 모드로 작성된 코드는 이전 버전과 호환됩니다. 그러나 비 프로그레시브 모드로 작성된 코드는 프로그레시브 모드에서 컴파일 오류를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">튜토리얼에서 우리는 배울 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">튜토리얼에서 우리는 :</target>
        </trans-unit>
        <trans-unit id="91d34ec07b8ea3ab8718a88b953168add8f0c256" translate="yes" xml:space="preserve">
          <source>In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">이 경우 플러그인에서 컴파일러를 다운로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">이 경우 JQuery를 &lt;code&gt;jquery&lt;/code&gt; 라는 모듈로 가져 옵니다 . 또는 Kotlin 컴파일러가 사용하도록 구성된 모듈 시스템에 따라 $ -object로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">이 경우 컴파일 결과를 &lt;code&gt;scripts&lt;/code&gt; 폴더로 설정했습니다. 응용 프로그램을 실행하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b5a6a88d0b58461497da6e47e4eb3bdd5fbf2b22" translate="yes" xml:space="preserve">
          <source>In this case, you can share code across native targets in your project using the hierarchical structure.</source>
          <target state="translated">이 경우 계층 구조를 사용하여 프로젝트의 기본 대상간에 코드를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">이 고밀도 코드에서 수집 변환뿐만 아니라, 당신은 편리한 코 틀린 지역 함수로 기능하고 볼 수있는 &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;연산자를 엘비스 &lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 표현할 수 있도록하는 &lt;a href=&quot;../reference/idioms&quot;&gt;숙어&lt;/a&gt; 간결한와 &quot;는 긍정적 그렇지 않으면 사용 길이의 경우는 값을&quot;과 같은를 &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; 와 같이 읽을 수있는 표현식 이지만 Kotlin을 사용하면 추가 가변 변수를 만들고 동일한 코드를 명령형 스타일로 표현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">이 문서에서는 표현식에 의해 생성되는 유형을 강조하기 위해 불필요하게 유형을 지정하는 경우가 있습니다. 또한 좋은 IDE는 결과 유형을 보여줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">이 문서에서는 여러 종류의 호환성을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">이 예에서는 가장 가까운 암시 적 수신자 &lt;code&gt;this@head&lt;/code&gt; 멤버 만 사용 가능해야합니다. &lt;code&gt;head()&lt;/code&gt; 는 외부 수신자 &lt;code&gt;this@html&lt;/code&gt; 의 멤버 이므로 호출하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="9c36d65c210f75f6cba412252945fedc98c222bc" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; , no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">이 예제에서는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default를&lt;/a&gt; 사용하여 백그라운드 스레드 풀에서 새 코 루틴을 시작 하므로 스레드 풀과 다른 스레드에서 작동하지만 여전히 스레드 로컬 변수의 값을 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; 사용하여 지정한 값입니다. 코 루틴이 실행되는 스레드에 관계없이 (value = &quot;launch&quot;) . 따라서 출력 ( &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug 포함&lt;/a&gt; )은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">이 예에서, C API &lt;code&gt;new_menu()&lt;/code&gt; 전달 된 모든 값은 그것이 속하는 가장 안쪽 &lt;code&gt;memScope&lt;/code&gt; 의 수명을 갖 습니다. 제어 흐름이 &lt;code&gt;memScoped&lt;/code&gt; 범위를 벗어나 면 C 포인터가 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">이 예제에서 생성자는 맵을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">이 예에서, 시퀀스 처리는리스트와 동일한 작업을 수행하기 위해 23 단계 대신 18 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">이 예제 에서 이전 섹션의 &lt;code&gt;Person&lt;/code&gt; 및 &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; 을 사용하여 이름으로 멤버 함수 참조를 찾아서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">이 함수에서 &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 은 서스펜션 기능이 실행되는 동일한 스택 프레임에서 동 기적으로 또는 나중에 동일한 스레드에서 또는 다른 실행 스레드에서 비동기 적으로 사용될 수 있습니다. 재개 함수를 반복해서 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">이 함수에서 &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 은 서스펜션 기능이 실행되는 동일한 스택 프레임에서 동 기적으로 또는 나중에 동일한 스레드에서 또는 다른 실행 스레드에서 비동기 적으로 사용될 수 있습니다. 이력서 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">이 섹션에는 주석 처리 된 DSL이 표시됩니다. 이 플러그인을 사용하는 프로젝트 예 (예 : &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt; , &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http 클라이언트)도 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">이 학습서에서는 다음을 수행하는 방법을 학습합니다.</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">그러나이 튜토리얼에서는 &lt;code&gt;libcurl&lt;/code&gt; 과 같은 특정 라이브러리를 사용하는 방법을 살펴 봅니다 . 우리는 배울 것이다</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">이 튜토리얼에서 우리는 :</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">이 튜토리얼에서는 Kotlin / Native에서 C 문자열을 처리하는 방법을 살펴 봅니다. 우리는 방법을 배울 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">이 튜토리얼에서는 Kotlin의 코드 공유 기능을 사용하여 iOS 및 Android 애플리케이션을 작성합니다. 안드로이드의 경우 Kotlin / JVM을 사용하고 iOS의 경우 Kotlin / Native가됩니다.</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">이 튜토리얼에서 우리는</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">이 학습서에서는 Kotlin Android Extensions 플러그인을 사용하여 Android 개발 경험을 향상시키는 데 필요한 단계를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">이 자습서에서는 필요한 단계를 안내합니다. Spring Boot 및 Kotlin에 대한 자세한 설명은 Spring Boot 및 Kotlin을 &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;사용하여 웹 애플리케이션 빌드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">이 자습서에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼에서는 IntelliJ IDEA를 사용합니다. 명령 행 컴파일러를 사용하여 Kotlin 애플리케이션을 컴파일하고 실행하는 방법에 대한 지시 사항은 명령 행 컴파일러 &lt;a href=&quot;command-line&quot;&gt;작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">이 튜토리얼에서는 JavaScript를 대상으로하는 Kotlin 애플리케이션을 생성하고 디버깅하며 컴파일러 옵션을 설정하는 방법을 살펴 보았습니다. 다른 튜토리얼에서는 DOM과의 상호 작용 등과 같은 더 자세한 주제를 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">이 학습서에서는 Kotlin / Native에 표시되는 C 데이터 유형과 그 반대에 대해 알아 봅니다. 우리는 :</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">이 학습서에서는 기존 기본 애플리케이션 또는 라이브러리의 Kotlin / Native 코드를 사용하는 방법을 살펴 봅니다. 이를 위해 Kotlin 코드를 동적 라이브러리 &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.dylib&lt;/code&gt; 및 &lt;code&gt;.dll&lt;/code&gt; 로 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0865fef18032d86f743ee83bf90f480e5f932289" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native.</source>
          <target state="translated">이 튜토리얼에서는 JVM, JS 및 Native의 세계에서 사용할 수있는 작은 라이브러리를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">이 학습서에서는 JVM, JS 및 Native의 세계에서 사용 가능한 작은 라이브러리를 빌드합니다. 다른 공통 코드 (예 : Android 및 iOS와 공유되는 코드)에서 사용할 수있는 멀티 플랫폼 라이브러리를 만드는 방법과 모든 플랫폼에서 실행되고 효율적인 테스트를 작성하는 방법을 단계별로 학습합니다. 구체적인 플랫폼에 의해 제공되는 구현.</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">이 튜토리얼에서는 macOS 및 iOS에서 Objective-C 및 Swift 애플리케이션의 Kotlin / 네이티브 코드를 사용하는 방법을 살펴 봅니다. Kotlin 코드에서 프레임 워크를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">이 자습서에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">이 자습서에서는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼에서는 Gradle을 사용하지만 IntelliJ IDEA 프로젝트 구조 또는 Maven을 사용하여 동일하게 수행 할 수 있습니다. Kotlin과 함께 작동하도록 Gradle 설정에 대한 자세한 내용은 Gradle &lt;a href=&quot;../reference/using-gradle&quot;&gt;사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">이 튜토리얼에서는 Gradle을 사용하지만 IntelliJ IDEA 프로젝트 구조 또는 Maven을 사용하여 동일하게 수행 할 수 있습니다. Kotlin과 함께 작동하도록 Gradle 설정에 대한 자세한 내용은 Gradle &lt;a href=&quot;../reference/using-gradle&quot;&gt;사용을&lt;/a&gt; 참조하십시오 . HTTP 서블릿 사용에 필요한 주요 종속성은 JavaEE API입니다.</target>
        </trans-unit>
        <trans-unit id="40ab0f9121b36c46d899b6425de4821ece3db190" translate="yes" xml:space="preserve">
          <source>In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</source>
          <target state="translated">In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">차례로, &lt;code&gt;let&lt;/code&gt; 하고 &lt;code&gt;also&lt;/code&gt; 람다 인수로 컨텍스트 개체가 있습니다. 인수 이름을 지정하지 않으면 암시 적 기본 이름 인 &lt;code&gt;it&lt;/code&gt; 의해 오브젝트에 액세스 합니다 . &lt;code&gt;it&lt;/code&gt; 보다 짧은 &lt;code&gt;this&lt;/code&gt; 와와 표현 &lt;code&gt;it&lt;/code&gt; 일반적으로 읽기 쉽다. 오브젝트의 기능이나 속성을 호출 할 때, 당신은 암시 적으로 같이 사용할 수있는 오브젝트가없는 &lt;code&gt;this&lt;/code&gt; . 따라서 객체가 함수 호출에서 인수로 주로 사용될 때 컨텍스트 객체를 사용 &lt;code&gt;it&lt;/code&gt; 것이 좋습니다. &lt;code&gt;it&lt;/code&gt; 당신이 코드 블록에 여러 변수를 사용하는 경우 더 나은이기도합니다.</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">결과적으로 변경 가능한 컬렉션은 공변량이 아닙니다. 그렇지 않으면 런타임 오류가 발생합니다. 경우 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 의 하위 유형이었다 &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; , 당신은 다른 삽입 할 수 &lt;code&gt;Shape&lt;/code&gt; (예를 들어, 상속자를 &lt;code&gt;Circle&lt;/code&gt; 따라서 그 위반, 그것으로) &lt;code&gt;Rectangle&lt;/code&gt; 타입의 인수를.</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">차례로 set은 &lt;a href=&quot;collections-overview&quot;&gt;정의에&lt;/a&gt; 따라 정렬 된 컬렉션이 아닙니다 . 그러나 Kotlin &lt;code&gt;Set&lt;/code&gt; 는 특정 순서로 요소를 저장합니다. 삽입 순서 ( &lt;code&gt;LinkedHashSet&lt;/code&gt; ), 자연 정렬 순서 ( &lt;code&gt;SortedSet&lt;/code&gt; ) 또는 다른 순서 일 수 있습니다. 요소 집합의 순서도 알 수 없습니다. 이러한 경우 요소는 여전히 순서대로 정렬되므로 요소 위치에 의존하는 함수는 여전히 결과를 반환합니다. 그러나 사용 된 &lt;code&gt;Set&lt;/code&gt; 의 특정 구현을 모르면 이러한 결과는 호출자에게 예측할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="26d300702c75a3b26e8ba1f4228f68dc28aca421" translate="yes" xml:space="preserve">
          <source>In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</source>
          <target state="translated">In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">처음부터 새로운 함수와 클래스를 포함하여 유효한 Kotlin 코드를 작성할 수 있습니다. IntelliJ IDEA의 구문 강조, 자동 완성 및 기타 코드 편집 기능은 처음부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5ab1113b4018a56db06428b02b9d9a142cf8f11e" translate="yes" xml:space="preserve">
          <source>Include Java sources in JVM compilations</source>
          <target state="translated">JVM 컴파일에 Java 소스 포함</target>
        </trans-unit>
        <trans-unit id="3348bba79393338a33249573a6e3c773462946f1" translate="yes" xml:space="preserve">
          <source>Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</source>
          <target state="translated">Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</target>
        </trans-unit>
        <trans-unit id="a9e17f8d5ea37546d212a719c404957805afefc8" translate="yes" xml:space="preserve">
          <source>Include the Kotlin runtime into the resulting JAR file. Makes the resulting archive runnable on any Java-enabled environment.</source>
          <target state="translated">결과 JAR 파일에 Kotlin 런타임을 포함합니다. 결과 아카이브를 모든 Java 사용 환경에서 실행할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="bcb9fe75af30595cd7b7cb634e1bb8d624522edb" translate="yes" xml:space="preserve">
          <source>Include the native bitcode library.</source>
          <target state="translated">네이티브 비트 코드 라이브러리를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="e2d58567583dee9bd57b8d9341149118d1dbe174" translate="yes" xml:space="preserve">
          <source>Includes Java sources into the JVM target&amp;rsquo;s compilations.</source>
          <target state="translated">JVM 대상의 컴파일에 Java 소스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">klib에 정적 라이브러리 포함</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="c39322316343eb0abd4a312f2f7bc80b85919258" translate="yes" xml:space="preserve">
          <source>Inconsistent behavior of floating-point number comparisons</source>
          <target state="translated">부동 소수점 숫자 비교의 일관되지 않은 동작</target>
        </trans-unit>
        <trans-unit id="972d0a464d55eb6f53d336a20851a05ba6148f80" translate="yes" xml:space="preserve">
          <source>Incorrect generic signature in annotations when KClass is used as a generic parameter</source>
          <target state="translated">KClass가 일반 매개 변수로 사용될 때 주석의 잘못된 일반 서명</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">증분 컴파일</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">증분 주석 처리 (1.3.30부터)</target>
        </trans-unit>
        <trans-unit id="29106d30f82b4fbf8a046db084591a963e0208cc" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">증분 컴파일</target>
        </trans-unit>
        <trans-unit id="3bb3cfba326a2bdc90f381639a6d53003c8fb9e7" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</source>
          <target state="translated">Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">Kotlin / JVM 및 Kotlin / JS 프로젝트에 대해 증분 컴파일이 지원됩니다. Kotlin / JVM의 경우 Kotlin 1.1.1 및 Kotlin / JS의 경우 1.3.20부터 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">증분 릴리스는 툴링 (종종 기능 포함), 성능 개선 및 버그 수정에 대한 업데이트를 제공합니다. 우리는 그러한 버전을 서로 호환되도록 유지하려고 노력하므로 컴파일러의 변경은 대부분 최적화 및 경고 추가 / 제거입니다. 실험 기능은 물론 언제든지 추가, 제거 또는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36431db4a12e3c14e9de849f36b5befe35ed62b5" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;델타&lt;/a&gt; 단위로 값을 증가시키고 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0f32b37b99e84f7a892589880d018ef9b908ef9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;델타&lt;/a&gt; 단위로 값을 증가시키고 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="166f962aa69e44913e0b39e6fa68583a02fd3a79" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">이 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">값을 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="e3d31147233f60ba2779d580d821b70c26574217" translate="yes" xml:space="preserve">
          <source>Indeed, its design was inspired by Reactive Streams and its various implementations. But Flow main goal is to have as simple design as possible, be Kotlin and suspension friendly and respect structured concurrency. Achieving this goal would be impossible without reactive pioneers and their tremendous work. You can read the complete story in &lt;a href=&quot;https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4&quot;&gt;Reactive Streams and Kotlin Flows&lt;/a&gt; article.</source>
          <target state="translated">실제로 그 디자인은 Reactive Streams와 다양한 구현에서 영감을 받았습니다. 그러나 Flow의 주요 목표는 가능한 한 단순한 디자인을 유지하고 Kotlin 및 서스펜션 친화적이며 구조화 된 동시성을 존중하는 것입니다. 이 목표를 달성하는 것은 반응적인 개척자와 그들의 엄청난 노력 없이는 불가능할 것입니다. &lt;a href=&quot;https://medium.com/@elizarov/reactive-streams-and-kotlin-flows-bfd12772cda4&quot;&gt;Reactive Streams 및 Kotlin Flows&lt;/a&gt; 문서 에서 전체 스토리를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">인덱스 액세스 연산자</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="2606e49e237c315e21ba9ad3205e46744904acbb" translate="yes" xml:space="preserve">
          <source>Indexing suffix</source>
          <target state="translated">Indexing suffix</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">다른 객체가이 객체와 &quot;동일한 지&quot;여부를 나타냅니다. 구현은 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">정규식이 지정된 &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;입력&lt;/a&gt; 에서 하나 이상의 일치 항목을 찾을 수 있는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="51429e87bd819bb2f3942329861eee4721f512b8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">정규식이 전체 &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;입력&lt;/a&gt; 과 일치하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b98c0b71834f5e2d5a0d8cf79e50cdeebb2945aa" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">명명 된 함수에 대한 호출 호출</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">삽입 함수 호출은 산술 연산자, 유형 캐스트 ​​및 &lt;code&gt;rangeTo&lt;/code&gt; 연산자 보다 우선 순위가 낮습니다 . 다음 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">삽입 기능</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">접두사 표기</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">명시 적 캐스트의 정보는 유형 유추에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">자바 클래스로부터 상속</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 충돌로 이어지는 상속 은 Kotlin 1.2에서 경고로 더 이상 사용되지 않으며 Kotlin 1.3에서 오류가됩니다.</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">상속 된 함수</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">상속 된 속성</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">상속 된 내장 함수</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 유형 또는 기본 유형 의 값으로 초기화</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">초기화되지 않은 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 값 에 동시에 액세스하면 초기화 기능을 여러 번 호출 할 수 있지만 첫 번째로 반환 된 값만 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 의 값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">리스트의 이니셜 라이저 기능</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">아직 초기화되지 않은 경우 현재 스레드에 대한 Kotlin 런타임을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="4bf76bf156ef56b953245fb5da4ea73be4ae4d91" translate="yes" xml:space="preserve">
          <source>Initiates a call to this deep recursive function, forming a root of the call tree.</source>
          <target state="translated">Initiates a call to this deep recursive function, forming a root of the call tree.</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">inlinable lambdas는 인라인 함수 내에서만 호출되거나 inlinable 인수로 전달 될 수 있지만, &lt;code&gt;noinline&lt;/code&gt; 람다는 필드에 저장하거나 전달하는 등 원하는 방식으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">인라인 JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">인라인 마크 업</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">인라인 클래스</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">인라인 클래스는 인터페이스에서 상속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">인라인 클래스는 Kotlin 1.3 이후로만 제공되며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 세부 사항을 참조하십시오 &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;아래를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">인라인 클래스는 Kotlin 1.3 이후로만 제공되며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 에서 자세한 내용을 참조하십시오 &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe109e560117398094720f2c3a634950943781d" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6ad02ddc63db8ea1a5da350db44423e72064462a" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">인라인 클래스는 일반 클래스의 일부 기능을 지원합니다. 특히 속성과 함수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">인라인 클래스와 타입 별칭</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">플랫폼 유형의 널값에서 호출 된 인라인 확장 함수는 수신자가 널을 검사하지 않아 널이 다른 코드로 이스케이프되도록 허용합니다. Kotlin 1.2는 콜 사이트에서이 검사를 강제 실행하고 수신자가 null 인 경우 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">인라인 함수는 &lt;a href=&quot;inline-functions&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">인라인 함수는 이제 인라인 된 기능 매개 변수에 대한 기본값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;형식&lt;/a&gt; 이 지정된 매개 변수 가있는 인라인 함수에는 각 호출 사이트에 실제 형식 인수가 인라인되어 있습니다. &lt;code&gt;arg is T&lt;/code&gt; 형식 매개 변수에 대한 T 검사이지만 &lt;code&gt;arg&lt;/code&gt; 가 일반 형식의 인스턴스 인 경우 &lt;em&gt;해당&lt;/em&gt; 형식 인수는 여전히 지워집니다. 예:</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">기본 기능 매개 변수가있는 인라인 함수</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">인라인 속성 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">인라인 속성 접근 자</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">인라이닝하면 생성 된 코드가 커질 수 있습니다. 그러나 합리적인 방법으로 (즉, 큰 함수를 인라인하지 않는 경우) 수행하면 특히 루프 내부의 &quot;거시적 인&quot;콜 사이트에서 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">내부 수업</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">외부 클래스에서 일반 매개 변수를 캡처하는 &lt;code&gt;Throwable&lt;/code&gt; 을 상속 하는 내부 클래스</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; 에서 상속되는 제네릭 형식의 내부 클래스는 throw-catch 시나리오에서 형식 안전성을 위반할 수 있으므로 Kotlin 1.2의 경고와 Kotlin 1.3의 오류와 함께 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 컬렉션 요소의 모든 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 를 지정된 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의이 목록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="005fc2603487998262e6a4431116600f620b75a0" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 컬렉션 요소의 모든 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 를 지정된 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의이 목록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="602fbcd913879c3c9b700203739e32c4a9b2050d" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="043751f897f4eb9dc49253608d3dad5a3c113e89" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="dc5d1b50a39baeed86e36617a548438e3f127155" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="8e37de1820797a87c23300e79e4b0ed919d09e2a" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="27480ec1869e9733f33a48ab29f659fcb2a460a3" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="0751e96b7b08da95e20ff3bc7df0567c20077897" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="3e04a0c39fa9e9ba6f8f7b53f66419ea35f91587" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="990caaef55fa9369abe10fe21e08b659ee5241e9" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="56381b6576df78ab7498f4c21ed74ffb38fce356" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="13ca00255e68344adaf9baf7d5fd54a64418b339" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="f16ec6bfc81f5c607f3cb9b48f5e7a410c32c025" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="b15a142e3f1c0e94cad906174d3311d39fef798f" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="98e8ddbbdefb8f6d9c8e1f1a1ec159981fb75050" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="8bd299382c17ed7be741a94000ce27e3cb569545" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="c10488d941ff5f739e50f3ed8d100fc28145f09c" translate="yes" xml:space="preserve">
          <source>Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="ad678e17f874b23d4231a5cb1e5b3edfa0684922" translate="yes" xml:space="preserve">
          <source>Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
