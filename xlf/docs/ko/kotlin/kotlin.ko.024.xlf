<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="ac3430431502d340786bc5ac5f5a79619bd1b1b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mapping&lt;/em&gt; transformation creates a collection from the results of a function on the elements of another collection. The basic mapping function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt;. It applies the given lambda function to each subsequent element and returns the list of the lambda results. The order of results is the same as the original order of elements. To apply a transformation that additionally uses the element index as an argument, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt;&lt;code&gt;mapIndexed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;맵핑&lt;/em&gt; 변환은 다른 집합의 요소의 기능의 결과로부터 집합을 생성한다. 기본 매핑 함수는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 입니다. 주어진 람다 함수를 각 후속 요소에 적용하고 람다 결과 목록을 반환합니다. 결과 순서는 원래 요소 순서와 같습니다. 요소 인덱스를 추가로 인수로 사용하는 변환을 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-indexed&quot;&gt; &lt;code&gt;mapIndexed()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f10d769163cad6919d11542a05d27b21373fb57" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;no-arg&lt;/em&gt; compiler plugin generates an additional zero-argument constructor for classes with a specific annotation.</source>
          <target state="translated">는 &lt;em&gt;인수 없음의&lt;/em&gt; 컴파일러 플러그인은 특정 주석을 가진 클래스에 대한 추가 제로 인수 생성자를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5691855d07c59433c1b89721a503fe2ada65d67c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Circle.draw()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Shape.fill()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">&lt;code&gt;Circle.draw()&lt;/code&gt; 에는 &lt;em&gt;재정의&lt;/em&gt; 수정자가 필요합니다 . 누락 된 경우 컴파일러가 불평합니다. &lt;code&gt;Shape.fill()&lt;/code&gt; 과 같은 함수에 &lt;em&gt;열린&lt;/em&gt; 수정자가 없는 경우 하위 클래스에서 동일한 서명을 가진 메서드를 선언하는 것은 &lt;em&gt;재정의를 사용&lt;/em&gt; 하거나 사용하지 않고 불법 입니다. &lt;em&gt;열린&lt;/em&gt; 최종 클래스 (예. 아니오 클래스의 멤버에 추가 할 때 수정이 적용되지 않습니다 &lt;em&gt;열어&lt;/em&gt; 수정).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c23eadbd5827ce2bda3043305cafb8fee54b97d1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;override&lt;/em&gt; modifier is required for &lt;code&gt;Derived.v()&lt;/code&gt;. If it were missing, the compiler would complain. If there is no &lt;em&gt;open&lt;/em&gt; modifier on a function, like &lt;code&gt;Base.nv()&lt;/code&gt;, declaring a method with the same signature in a subclass is illegal, either with &lt;em&gt;override&lt;/em&gt; or without it. The &lt;em&gt;open&lt;/em&gt; modifier has no effect when added on members of a final class (i.e.. a class with no &lt;em&gt;open&lt;/em&gt; modifier).</source>
          <target state="translated">&lt;em&gt;재정의&lt;/em&gt; 수정이 필요 &lt;code&gt;Derived.v()&lt;/code&gt; . 누락 된 경우 컴파일러가 불평합니다. 함수에 &lt;code&gt;Base.nv()&lt;/code&gt; 와 같은 &lt;em&gt;열린&lt;/em&gt; 수정자가 없는 경우 , 서브 클래스에서 동일한 서명을 가진 메소드를 &lt;em&gt;재정의&lt;/em&gt; 하거나 사용하지 않고 선언하는 것은 유효 하지 않습니다. &lt;em&gt;열린&lt;/em&gt; 최종 클래스 (즉. 아니오 클래스의 멤버에 추가 할 때 수정이 적용되지 않습니다 &lt;em&gt;열어&lt;/em&gt; 수정).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7a6efa4e40ec720cdbba584f5f17332e3c02e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primitive data types&lt;/em&gt; are the most fundamental types in Kotlin; all other types are built up of these types and arrays thereof. Their representation is very efficient (both in terms of memory and CPU time), as they map to small byte groups that are directly manipulatable by the CPU.</source>
          <target state="translated">&lt;em&gt;기본 데이터 타입은&lt;/em&gt; 코 틀린 가장 기본적인 종류; 다른 모든 유형은 이러한 유형과 그 배열로 구성됩니다. CPU에서 직접 조작 할 수있는 작은 바이트 그룹에 매핑되므로 메모리 및 CPU 시간 측면에서 매우 효율적으로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="487cd135e968638b95e9f2832e5094575fc75a4e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;return&lt;/em&gt;-expression returns from the nearest enclosing function, i.e. &lt;code&gt;foo&lt;/code&gt;. (Note that such non-local returns are supported only for lambda expressions passed to &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt;.) If we need to return from a lambda expression, we have to label it and qualify the &lt;em&gt;return&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;반환&lt;/em&gt; 가장 가까운 바깥 쪽 함수의 -expression 반환, 즉 &lt;code&gt;foo&lt;/code&gt; 는 . (로컬이 아닌 리턴은 &lt;a href=&quot;inline-functions&quot;&gt;인라인 함수에&lt;/a&gt; 전달 된 람다 표현식에만 지원됩니다 .) 람다 표현식에서 리턴해야하는 경우 레이블을 지정하고 &lt;em&gt;리턴을 규정&lt;/em&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cafe8afb40f89fdcda59dc51de02a6061deac76b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sam-with-receiver&lt;/em&gt; compiler plugin makes the first parameter of the annotated Java &quot;single abstract method&quot; (SAM) interface method a receiver in Kotlin. This conversion only works when the SAM interface is passed as a Kotlin lambda, both for SAM adapters and SAM constructors (see the &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;documentation&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;em&gt;SAM-와 수신기&lt;/em&gt; 컴파일러 플러그인은 주석 자바 &quot;하나의 추상적 인 방법&quot;(SAM) 인터페이스 메서드의 첫 번째 매개 변수 코 틀린에 수신기를한다. 이 변환은 SAM 인터페이스가 SAM 어댑터 및 SAM 생성자 모두에 대해 Kotlin 람다로 전달 될 때만 작동합니다 (자세한 내용은 &lt;a href=&quot;java-interop#sam-conversions&quot;&gt;설명서&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="2b5aab8f26eb6a59834e5185db5f935d540467ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;this&lt;/em&gt; keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). Now, we can call such a function on any &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">확장 함수 내부 의 &lt;em&gt;this&lt;/em&gt; 키워드는 수신자 객체 (점 앞에 전달 된)에 해당합니다. 이제 모든 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; 에서 이러한 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="610610ce4b9c2a06c0d2c740b86b1595d612ed87" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;when&lt;/em&gt; expression replaces the switch statement in C-like languages. In the simplest form it looks like this</source>
          <target state="translated">&lt;em&gt;때&lt;/em&gt; 표현 언어 C - 같은 스위치 문을 대체합니다. 가장 간단한 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4474dcb438fb0b1d5730dee1b01c00e81230dea0" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Debug&lt;/strong&gt; tool window contains the &lt;strong&gt;Coroutines&lt;/strong&gt; tab. In this tab, you can find information about both currently running and suspended coroutines. The coroutines are grouped by the dispatcher they are running on.</source>
          <target state="translated">&lt;strong&gt;디버그&lt;/strong&gt; 도구 창은 포함 &lt;strong&gt;코 루틴&lt;/strong&gt; 탭을 선택합니다. 이 탭에서 현재 실행중인 코 루틴과 일시 중단 된 코 루틴에 대한 정보를 찾을 수 있습니다. 코 루틴은 실행중인 디스패처별로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="64ff96f8d5986618b0177325f56f06db0b6ef27e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cinterop&lt;/strong&gt; tool produces &lt;code&gt;.klib&lt;/code&gt; wrappers for native libraries as its main output. For example, using the simple &lt;code&gt;libgit2.def&lt;/code&gt; native library definition file provided in your Kotlin/Native distribution</source>
          <target state="translated">&lt;strong&gt;cinterop의&lt;/strong&gt; 도구 생산 &lt;code&gt;.klib&lt;/code&gt; 주요 출력으로 네이티브 라이브러리에 대해 래퍼를. 예를 들어 Kotlin / Native 배포에 제공된 간단한 &lt;code&gt;libgit2.def&lt;/code&gt; 기본 라이브러리 정의 파일 사용</target>
        </trans-unit>
        <trans-unit id="3afe66cbf747b6ceb2175d27e523f7de3f8680c5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;klib&lt;/strong&gt; library management utility allows you to inspect and install the libraries.</source>
          <target state="translated">&lt;strong&gt;klib의&lt;/strong&gt; 라이브러리 관리 유틸리티를 사용하면 검사하고 라이브러리를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4754f312fedbc815f86ed89afbc9edf502f5ba2a" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;out&lt;/strong&gt; modifier is called a &lt;strong&gt;variance annotation&lt;/strong&gt;, and since it is provided at the type parameter declaration site, we talk about &lt;strong&gt;declaration-site variance&lt;/strong&gt;. This is in contrast with Java's &lt;strong&gt;use-site variance&lt;/strong&gt; where wildcards in the type usages make the types covariant.</source>
          <target state="translated">&lt;strong&gt;아웃&lt;/strong&gt; 수정은이라고 &lt;strong&gt;분산 주석을&lt;/strong&gt; , 그리고 그것은 형식 매개 변수 선언 사이트에서 제공되기 때문에, 우리는 이야기 &lt;strong&gt;선언 사이트 분산&lt;/strong&gt; . 이는 유형 사용에서 와일드 카드가 유형을 공변량으로 만드는 Java의 &lt;strong&gt;사용 사이트 차이&lt;/strong&gt; 와 대조적입니다 .</target>
        </trans-unit>
        <trans-unit id="e4cdeee14d0ede31e2c00aaa982268d6ad103b09" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;wildcard type argument&lt;/strong&gt;&lt;code&gt;? extends E&lt;/code&gt; indicates that this method accepts a collection of objects of &lt;code&gt;E&lt;/code&gt;&lt;em&gt;or some subtype of&lt;/em&gt;&lt;code&gt;E&lt;/code&gt;, not just &lt;code&gt;E&lt;/code&gt; itself. This means that we can safely &lt;strong&gt;read&lt;/strong&gt;&lt;code&gt;E&lt;/code&gt;'s from items (elements of this collection are instances of a subclass of E), but &lt;strong&gt;cannot write&lt;/strong&gt; to it since we do not know what objects comply to that unknown subtype of &lt;code&gt;E&lt;/code&gt;. In return for this limitation, we have the desired behaviour: &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; a subtype of &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt;. In &quot;clever words&quot;, the wildcard with an &lt;strong&gt;extends&lt;/strong&gt;-bound (&lt;strong&gt;upper&lt;/strong&gt; bound) makes the type &lt;strong&gt;covariant&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;와일드 카드 형식 인수 &lt;/strong&gt; &lt;code&gt;? extends E&lt;/code&gt; 이 방법의 개체의 컬렉션 받아들이는 것을 나타냅니다 &lt;code&gt;E&lt;/code&gt; &lt;em&gt;또는 일부 하위 유형 &lt;/em&gt; &lt;code&gt;E&lt;/code&gt; 를 , 그냥 &lt;code&gt;E&lt;/code&gt; 자체를. 즉 , 항목에서 &lt;code&gt;E&lt;/code&gt; 를 안전하게 &lt;strong&gt;읽을&lt;/strong&gt; 수 있지만 (이 컬렉션의 요소는 E의 하위 클래스 인스턴스 임) 알 수없는 &lt;code&gt;E&lt;/code&gt; 의 하위 유형을 준수하는 개체가 무엇인지 알 &lt;strong&gt;수 없으므로 쓸 수 없습니다&lt;/strong&gt; . 이 제한에 대한 대가로, 원하는 동작이 있습니다 : &lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt; &lt;em&gt;은 &lt;/em&gt; &lt;code&gt;Collection&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 의 하위 유형 입니까? Object&amp;gt;를 확장합니다 . &quot;영리한 단어&quot;에서 &lt;strong&gt;확장&lt;/strong&gt; 범위가 있는 와일드 카드 ( &lt;strong&gt;위&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;bound) 유형을 &lt;strong&gt;공변량으로&lt;/strong&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1a90eeb87b3e982cfd1ef4a4b65cfd6c27586462" translate="yes" xml:space="preserve">
          <source>The Android world has many popular frameworks simplifying development. You can use the same frameworks if you develop in Kotlin, often as easily as you'd do that in Java. This tutorial provides examples and highlights the differences in settings.</source>
          <target state="translated">Android 세계에는 개발을 단순화하는 인기있는 프레임 워크가 많이 있습니다. Kotlin에서 개발하는 경우 Java에서와 마찬가지로 쉽게 동일한 프레임 워크를 사용할 수 있습니다. 이 학습서는 예제를 제공하고 설정의 차이점을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="d41ba3261445c389f8874772f5879ab48af811af" translate="yes" xml:space="preserve">
          <source>The C data variable containing the pointer to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">포인터 함유 C 데이터 변수 &lt;code&gt;T&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="05360f394dd3e60e07e614be2588088eb89e3b72" translate="yes" xml:space="preserve">
          <source>The C data variable located in memory.</source>
          <target state="translated">메모리에있는 C 데이터 변수</target>
        </trans-unit>
        <trans-unit id="cf919179eecf4647d490ce563cdd6bff132af96d" translate="yes" xml:space="preserve">
          <source>The C function.</source>
          <target state="translated">C 함수.</target>
        </trans-unit>
        <trans-unit id="d36502dcbc1bebedd6773776218e3117a26820bc" translate="yes" xml:space="preserve">
          <source>The C primitive-typed variable located in memory.</source>
          <target state="translated">메모리에있는 C 기본 유형 변수입니다.</target>
        </trans-unit>
        <trans-unit id="639b72b8a51545cc688d8100df8871c5e14d7a1a" translate="yes" xml:space="preserve">
          <source>The C struct-typed variable located in memory.</source>
          <target state="translated">메모리에있는 C 구조체 유형 변수</target>
        </trans-unit>
        <trans-unit id="c4b0fbfe88d7c41e706fcbcc447e39c33c492192" translate="yes" xml:space="preserve">
          <source>The CocoaPods plugin also allows using CocoaPods libraries without manual configuring cinterop parameters (see the &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;corresponding section&lt;/a&gt; of the multiplatform plugin documentation). The &lt;code&gt;cocoapods { ... }&lt;/code&gt; code block allows you to add dependencies on CocoaPods libraries.</source>
          <target state="translated">CocoaPods 플러그인을 사용하면 cinterop 매개 변수를 수동으로 구성하지 않고도 CocoaPods 라이브러리를 사용할 수 있습니다 ( 멀티 플랫폼 플러그인 문서 의 &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;해당 섹션&lt;/a&gt; 참조 ). &lt;code&gt;cocoapods { ... }&lt;/code&gt; 코드 블록은 CocoaPods 라이브러리에 종속성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8779fd3a2cac48558378b86549bbda66333c4276" translate="yes" xml:space="preserve">
          <source>The CocoaPods support is implemented in a separate Gradle plugin: &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt;.</source>
          <target state="translated">CocoaPods 지원은 별도의 Gradle 플러그인 &lt;code&gt;org.jetbrains.kotlin.native.cocoapods&lt;/code&gt; 에서 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd3aa1e3e57f3eb3ef63cd39980df09053647402" translate="yes" xml:space="preserve">
          <source>The Coroutine Debugger of the Kotlin plugin simplifies debugging coroutines in IntelliJ IDEA.</source>
          <target state="translated">Kotlin 플러그인의 코 루틴 디버거는 IntelliJ IDEA에서 코 루틴 디버깅을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="24a56079ca4afabfa7a909e10193add3dd7a492a" translate="yes" xml:space="preserve">
          <source>The DOM also provides us a way to retrieve a specific element by ID, name, class name, tag name and so on. All returned elements are of type &lt;code&gt;NodeList&lt;/code&gt;, and to access members we need to cast them to the specific type of element. The code below shows how we could access an input element on the page:</source>
          <target state="translated">DOM은 또한 ID, 이름, 클래스 이름, 태그 이름 등으로 특정 요소를 검색하는 방법을 제공합니다. 반환 된 모든 요소는 &lt;code&gt;NodeList&lt;/code&gt; 유형 이며 멤버에 액세스하려면 특정 유형의 요소로 캐스트해야합니다. 아래 코드는 페이지의 입력 요소에 액세스하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="325910eae4ee7077ed16505d94cb7161a53ff4ff" translate="yes" xml:space="preserve">
          <source>The Entry Point</source>
          <target state="translated">진입 점</target>
        </trans-unit>
        <trans-unit id="c1f2de3caa83760aa037581086bf37c054caebbb" translate="yes" xml:space="preserve">
          <source>The Gradle file is pretty much standard for Spring Boot. The only differences are the structure layout for source folders for Kotlin, the required Kotlin dependencies and the &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle plugin (CGLIB proxies used for example for &lt;code&gt;@Configuration&lt;/code&gt; and &lt;code&gt;@Bean&lt;/code&gt; processing require &lt;code&gt;open&lt;/code&gt; classes).</source>
          <target state="translated">Gradle 파일은 Spring Boot의 표준입니다. 유일한 차이점은 Kotlin의 소스 폴더, 필요한 Kotlin 종속성 및 &lt;a href=&quot;../reference/compiler-plugins#kotlin-spring-compiler-plugi&quot;&gt;&lt;em&gt;kotlin-spring&lt;/em&gt;&lt;/a&gt; Gradle 플러그인 의 구조 레이아웃입니다 (예 : &lt;code&gt;@Configuration&lt;/code&gt; 및 &lt;code&gt;@Bean&lt;/code&gt; 처리에 사용되는 CGLIB 프록시 에는 &lt;code&gt;open&lt;/code&gt; 클래스가 필요함 ).</target>
        </trans-unit>
        <trans-unit id="af4ea41e06d67df72de18198c84923c5e721e071" translate="yes" xml:space="preserve">
          <source>The Gradle plugin provides a separate task that creates a universal framework for iOS targets from several regular ones. The example below shows how to use this task. Note that the fat framework must have the same base name as the initial frameworks.</source>
          <target state="translated">Gradle 플러그인은 여러 일반 대상에서 iOS 대상에 대한 범용 프레임 워크를 작성하는 별도의 태스크를 제공합니다. 아래 예는이 작업을 사용하는 방법을 보여줍니다. 팻 프레임 워크는 초기 프레임 워크와 기본 이름이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c9686505fe7f54579b832493ec5b1983b12000c6" translate="yes" xml:space="preserve">
          <source>The JS typed arrays support that translates Kotlin primitive arrays, such as &lt;code&gt;IntArray&lt;/code&gt;, &lt;code&gt;DoubleArray&lt;/code&gt;, into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript typed arrays&lt;/a&gt;, that was previously an opt-in feature, has been enabled by default.</source>
          <target state="translated">JS 유형 배열 지원은 &lt;code&gt;IntArray&lt;/code&gt; , &lt;code&gt;DoubleArray&lt;/code&gt; 와 같은 Kotlin 기본 배열 을 이전에 옵트 인 기능인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays&quot;&gt;JavaScript 유형 배열&lt;/a&gt; 로 변환 하는 기능을 기본적으로 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="37ed5aeb9956cf68199e058567f26ab71cd7268f" translate="yes" xml:space="preserve">
          <source>The JSR-305 checks can be configured by adding the &lt;code&gt;-Xjsr305&lt;/code&gt; compiler flag with the following options (and their combination):</source>
          <target state="translated">JSR-305 검사는 다음 옵션 (및 그 조합)과 함께 &lt;code&gt;-Xjsr305&lt;/code&gt; 컴파일러 플래그를 추가하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8614662835decc941fb88cef784012c8f902a438" translate="yes" xml:space="preserve">
          <source>The Kotlin Android Extensions plugin allows us to obtain the same experience we have with some of these libraries, without having to add any extra code.</source>
          <target state="translated">Kotlin Android Extensions 플러그인을 사용하면 추가 코드를 추가하지 않고도 이러한 라이브러리 중 일부와 동일한 경험을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fa035c9f4f03b0b989b6313990e3a366a7fc07b" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin 1.4.10 works with Gradle 5.4 and later. The &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin requires Gradle 6.0 or later.</source>
          <target state="translated">Kotlin Gradle 플러그인 1.4.10은 Gradle 5.4 이상에서 작동합니다. &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인은 Gradle을 6.0 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b801cd7f041e6d90c21e7238c859980046339a8a" translate="yes" xml:space="preserve">
          <source>The Kotlin Gradle plugin supports incremental compilation. Incremental compilation tracks changes of source files between builds so only files affected by these changes would be compiled.</source>
          <target state="translated">Kotlin Gradle 플러그인은 증분 컴파일을 지원합니다. 증분 컴파일은 빌드 간의 소스 파일 변경을 추적하므로 이러한 변경의 영향을받는 파일 만 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="11818c172874b525f41c4774ffd3a8d06183ee2a" translate="yes" xml:space="preserve">
          <source>The Kotlin Maven Plugin needs to be referenced to compile the sources:</source>
          <target state="translated">소스를 컴파일하려면 Kotlin Maven 플러그인을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="e701f1b663fc8e1d541e7d7bed4b022ef1cd48e3" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides a comprehensive set of tools for managing &lt;em&gt;collections&lt;/em&gt; &amp;ndash; groups of a variable number of items (possibly zero) that share significance to the problem being solved and are operated upon commonly.</source>
          <target state="translated">코 틀린 표준 라이브러리 (Kotlin Standard Library)는 &lt;em&gt;수집&lt;/em&gt; 을 관리하기위한 포괄적 인 도구 세트를 제공 합니다.이 문제는 해결해야 할 문제의 중요성을 공유하고 일반적으로 운영되는 다양한 수의 항목 그룹 (아마도 0)입니다.</target>
        </trans-unit>
        <trans-unit id="8a031299bd7c193b637e92a822d8538f69af9b3a" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides implementations for basic collection types: sets, lists, and maps. A pair of interfaces represent each collection type:</source>
          <target state="translated">Kotlin 표준 라이브러리는 기본 컬렉션 유형 (세트, 목록 및 맵)에 대한 구현을 제공합니다. 한 쌍의 인터페이스는 각 컬렉션 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f614163c9f0e1a9b558eccd140b5d89bbaff4cb" translate="yes" xml:space="preserve">
          <source>The Kotlin Standard Library provides living essentials for everyday work with Kotlin. These include:</source>
          <target state="translated">Kotlin 표준 라이브러리는 Kotlin과 일상적인 작업에 필요한 생활 필수 요소를 제공합니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="33a29a3734d935aaab60c852c81fd82eccf705fa" translate="yes" xml:space="preserve">
          <source>The Kotlin code is turned into very similar looking code in Swift. There are some small differences, though. In Kotlin any &lt;code&gt;object&lt;/code&gt; has only one instance. Kotlin &lt;code&gt;object Object&lt;/code&gt; now has a constructor in Swift, and we use the &lt;code&gt;Object()&lt;/code&gt; syntax to access the only instance of it. The instance is always the same in Swift, so that &lt;code&gt;Object() === Object()&lt;/code&gt; is true. Methods and property names are translated as-is. Kotlin &lt;code&gt;String&lt;/code&gt; is turned into Swift &lt;code&gt;String&lt;/code&gt; too. Swift hides &lt;code&gt;NSNumber*&lt;/code&gt; boxing from us too. We pass Swift closure to Kotlin and call a Kotlin lambda function from Swift too.</source>
          <target state="translated">코 틀린 코드는 스위프트에서 매우 유사한 코드로 바뀌었다. 그래도 약간의 차이가 있습니다. Kotlin에서는 모든 &lt;code&gt;object&lt;/code&gt; 인스턴스가 하나만 있습니다. Kotlin &lt;code&gt;object Object&lt;/code&gt; 이제 Swift에 생성자를 가지며 &lt;code&gt;Object()&lt;/code&gt; 구문을 사용하여 유일한 인스턴스에 액세스합니다. Swift에서 인스턴스는 항상 동일하므로 &lt;code&gt;Object() === Object()&lt;/code&gt; 가 true입니다. 메서드와 속성 이름은있는 그대로 번역됩니다. Kotlin &lt;code&gt;String&lt;/code&gt; 도 Swift &lt;code&gt;String&lt;/code&gt; 으로 바뀝니다 . Swift는 &lt;code&gt;NSNumber*&lt;/code&gt; 권투도 숨 깁니다 . 우리는 Swift 클로저를 Kotlin으로 전달하고 Swift에서도 Kotlin 람다 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a82d7ab28c8dc762af0699f165239106b9d7ca89" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package contains extension functions for popular operations on sets: finding intersections, merging, or subtracting collections from each other.</source>
          <target state="translated">Kotlin 컬렉션 패키지에는 교차로 찾기, 병합 또는 서로 빼기 모음의 인기있는 작업을위한 확장 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5352e834912895fb7e864dc749c6a67a63a5c1bd" translate="yes" xml:space="preserve">
          <source>The Kotlin collections package provides functions for sorting collections in natural, custom, and even random orders. On this page, we'll describe sorting functions that apply to &lt;a href=&quot;collections-overview#collection-types&quot;&gt;read-only&lt;/a&gt; collections. These functions return their result as a new collection containing the elements of the original collection in the requested order. To learn about functions for sorting &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; collections in place, see the &lt;a href=&quot;list-operations#sorting&quot;&gt;List Specific Operations&lt;/a&gt;.</source>
          <target state="translated">Kotlin 컬렉션 패키지는 컬렉션을 자연스럽고, 맞춤이며, 무작위 순서로 정렬하는 기능을 제공합니다. 이 페이지에서는 &lt;a href=&quot;collections-overview#collection-types&quot;&gt;읽기 전용&lt;/a&gt; 컬렉션에 적용되는 정렬 기능에 대해 설명합니다 . 이 함수는 요청 된 순서로 원래 컬렉션의 요소를 포함하는 새 컬렉션으로 결과를 반환합니다. &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능한&lt;/a&gt; 콜렉션을 적절히 정렬하는 기능에 대해 배우려면 &lt;a href=&quot;list-operations#sorting&quot;&gt;목록 특정 조작을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="606ec4093466ccf8ac7dfb28ac45fda128eb6073" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler can now use information from type casts in type inference. If you&amp;rsquo;re calling a generic method that returns a type parameter &lt;code&gt;T&lt;/code&gt; and casting the return value to a specific type &lt;code&gt;Foo&lt;/code&gt;, the compiler now understands that &lt;code&gt;T&lt;/code&gt; for this call needs to be bound to the type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">코 틀린 컴파일러는 이제 타입 추론에서 타입 캐스트의 정보를 사용할 수 있습니다. 형식 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 반환 하고 반환 값을 특정 형식 &lt;code&gt;Foo&lt;/code&gt; 로 캐스팅 하는 제네릭 메서드를 호출하는 경우 이제 컴파일러 는이 호출의 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;Foo&lt;/code&gt; 형식에 바인딩되어야 함을 이해합니다 .</target>
        </trans-unit>
        <trans-unit id="3ccc8c3cdb40fba2c36169a3fed32ce41fa13cee" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler does extensive static analysis to provide warnings and reduce boilerplate. One of the most notable features is smartcasts &amp;mdash; with the ability to perform a cast automatically based on the performed type checks:</source>
          <target state="translated">Kotlin 컴파일러는 광범위한 정적 분석을 수행하여 경고를 제공하고 상용구를 줄입니다. 가장 주목할만한 기능 중 하나는 스마트 캐스트입니다. 수행 된 유형 검사에 따라 자동으로 캐스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9028d4b3725e4248715dfa8cff6060191e14fa" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler provides all the necessary information about &lt;code&gt;prop&lt;/code&gt; in the arguments: the first argument &lt;code&gt;this&lt;/code&gt; refers to an instance of the outer class &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;this::prop&lt;/code&gt; is a reflection object of the &lt;code&gt;KProperty&lt;/code&gt; type describing &lt;code&gt;prop&lt;/code&gt; itself.</source>
          <target state="translated">코 틀린 컴파일러에 대한 모든 필요한 정보를 제공 &lt;code&gt;prop&lt;/code&gt; 인수하여 : 첫번째 인수 &lt;code&gt;this&lt;/code&gt; 외부 클래스의 인스턴스를 지칭 &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;this::prop&lt;/code&gt; 의 반사 목적 &lt;code&gt;KProperty&lt;/code&gt; 의 기술 유형 &lt;code&gt;prop&lt;/code&gt; 자체.</target>
        </trans-unit>
        <trans-unit id="d8f9b6bf737be7b0aa49748489bb11aedc0ed8e0" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler tries to comply with the following goals:</source>
          <target state="translated">Kotlin 컴파일러는 다음 목표를 준수하려고합니다.</target>
        </trans-unit>
        <trans-unit id="84694c64245d13b803ebc2f9a85d6bc26cef8561" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will prefer using underlying types instead of wrappers to produce the most performant and optimized code. However, sometimes it is necessary to keep wrappers around. As a rule of thumb, inline classes are boxed whenever they are used as another type.</source>
          <target state="translated">Kotlin 컴파일러는 래퍼 대신 기본 형식을 사용하여 성능이 뛰어나고 최적화 된 코드를 생성하는 것을 선호합니다. 그러나 때때로 랩퍼를 유지해야합니다. 일반적으로 인라인 클래스는 다른 유형으로 사용될 때마다 상자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1defae0fa9dbdfd545ce26ab8cc2b793d3d11fe" translate="yes" xml:space="preserve">
          <source>The Kotlin compiler will use this restriction to aggressively optimize runtime representation of inline classes and substitute their instances with the value of the underlying property where possible removing constructor calls, GC pressure, and enabling other optimizations:</source>
          <target state="translated">Kotlin 컴파일러는이 제한 사항을 사용하여 인라인 클래스의 런타임 표현을 적극적으로 최적화하고 생성자 호출, GC 압력을 제거하고 다른 최적화를 가능하게하는 기본 속성 값으로 인스턴스를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="d850079f06081665ec514cb65c4f969e8d679814" translate="yes" xml:space="preserve">
          <source>The Kotlin language and toolset are divided into many components such as the compilers for the JVM, JS and Native targets, the Standard Library, various accompanying tools and so on. Many of these components were officially released as &lt;strong&gt;Stable&lt;/strong&gt; which means that they are evolved in the backward-compatible way following the &lt;a href=&quot;kotlin-evolution&quot;&gt;principles&lt;/a&gt; of &lt;em&gt;Comfortable Updates&lt;/em&gt; and &lt;em&gt;Keeping the Language Modern&lt;/em&gt;. Among such stable components are, for example, the Kotlin compiler for the JVM, the Standard Library, and Coroutines.</source>
          <target state="translated">Kotlin 언어 및 도구 세트는 JVM, JS 및 Native 대상 용 컴파일러, 표준 라이브러리, 다양한 부속 도구 등과 같은 여러 구성 요소로 나뉩니다. 이러한 구성 요소 중 많은 부분이 공식적으로 &lt;strong&gt;Stable로&lt;/strong&gt; 출시되었습니다. 즉 , &lt;em&gt;Comfortable Updates&lt;/em&gt; 및 &lt;em&gt;최신 언어 유지 &lt;/em&gt;&lt;a href=&quot;kotlin-evolution&quot;&gt;원칙&lt;/a&gt; 에 따라 이전 버전과 호환되는 방식으로 발전했습니다 . 이러한 안정적인 구성 요소 중에는 예를 들어 JVM 용 Kotlin 컴파일러, 표준 라이브러리 및 코 루틴이 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="421148b46361ca016988f110ea6a768864eebc2b" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin also bundles a Java to Kotlin converter (&lt;em&gt;J2K&lt;/em&gt;) that automatically converts Java files to Kotlin. To use J2K on a file, click &lt;strong&gt;Convert Java File to Kotlin File&lt;/strong&gt; in its context menu or in the &lt;strong&gt;Code&lt;/strong&gt; menu of IntelliJ IDEA.</source>
          <target state="translated">Kotlin 플러그인은 Java 파일을 Kotlin으로 자동 변환 하는 Java to Kotlin 변환기 ( &lt;em&gt;J2K&lt;/em&gt; ) 도 번들로 제공합니다 . 파일에서 J2K를 사용하려면 컨텍스트 메뉴 또는 IntelliJ IDEA 의 &lt;strong&gt;코드&lt;/strong&gt; 메뉴 에서 &lt;strong&gt;Java 파일을 Kotlin 파일&lt;/strong&gt; 로 &lt;strong&gt;변환을&lt;/strong&gt; 클릭 &lt;strong&gt;하십시오&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2e3c8e9ac9f87a3c6a3c66f4442bdb2dd4de716" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;&lt;em&gt;scratches&lt;/em&gt;&lt;/a&gt; and &lt;em&gt;worksheets.&lt;/em&gt;</source>
          <target state="translated">IntelliJ IDEA 용 Kotlin 플러그인은 &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;&lt;em&gt;스크래치&lt;/em&gt;&lt;/a&gt; 및 &lt;em&gt;워크 시트를&lt;/em&gt; 지원합니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d656f515ef009525fec5de5fd6f927dce6dbed0" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt; (Gradle version 4.3 and above is required; caching is disabled with lower versions).</source>
          <target state="translated">Kotlin 플러그인은 &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache를&lt;/a&gt; 지원합니다 (Gradle 버전 4.3 이상이 필요합니다. 캐싱은 하위 버전에서 비활성화 됨).</target>
        </trans-unit>
        <trans-unit id="bb12e098841b4fa9ff61972654d2907071becf6c" translate="yes" xml:space="preserve">
          <source>The Kotlin plugin supports &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle Build Cache&lt;/a&gt;.</source>
          <target state="translated">Kotlin 플러그인은 &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle 빌드 캐시를&lt;/a&gt; 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="4e886321a88f27f1211fc7e6327218f1b649f0a9" translate="yes" xml:space="preserve">
          <source>The Kotlin sources are arranged into &lt;a href=&quot;#configuring-source-sets&quot;&gt;source sets&lt;/a&gt;. In addition to Kotlin source files and resources, each source set may have its own dependencies. Source sets form a hierarchy that is built with the &lt;em&gt;&quot;depends on&quot;&lt;/em&gt; relation. A source set by itself is platform agnostic, but it may contain platform-specific code and dependencies if it's only compiled for a single platform.</source>
          <target state="translated">Kotlin 소스는 &lt;a href=&quot;#configuring-source-sets&quot;&gt;소스 세트&lt;/a&gt; 로 정렬됩니다 . Kotlin 소스 파일 및 리소스 외에도 각 소스 세트에는 고유 한 종속성이있을 수 있습니다. 소스 세트는 &lt;em&gt;&quot;종속&quot;&lt;/em&gt; 관계로 빌드 된 계층을 형성합니다 . 소스 세트 자체는 플랫폼에 구애받지 않지만 단일 플랫폼 용으로 컴파일 된 경우에는 플랫폼 별 코드와 종속성이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16279f302f8a88f25bf841c70c273ae22857462c" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library &lt;code&gt;kotlin-stdlib&lt;/code&gt; targets Java 6 and above. There are extended versions of the standard library that add support for some of the features of JDK 7 and JDK 8. To use these versions, add one of the following dependencies instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;:</source>
          <target state="translated">Kotlin 표준 라이브러리 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 는 Java 6 이상을 대상으로합니다. JDK 7 및 JDK 8의 일부 기능에 대한 지원을 추가하는 표준 라이브러리의 확장 버전이 있습니다.이 버전을 사용하려면 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 대신 다음 종속성 중 하나를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e19faba3d18413b5a548d796d002602d1f6b7b0d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains extension functions for retrieving parts of a collection. These functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others.</source>
          <target state="translated">Kotlin 표준 라이브러리에는 콜렉션의 일부를 검색하기위한 확장 기능이 있습니다. 이 함수는 결과 수집을위한 요소를 선택하는 다양한 방법을 제공합니다. 위치를 명시 적으로 나열하고 결과 크기를 지정하는 등의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aee8a9e1bcfd6364e58b2c53a697014bcd222ec2" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a &lt;a href=&quot;lambdas&quot;&gt;lambda expression&lt;/a&gt; provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called &lt;em&gt;scope functions&lt;/em&gt;. There are five of them: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;.</source>
          <target state="translated">Kotlin 표준 라이브러리에는 객체 컨텍스트 내에서 코드 블록을 실행하는 것이 유일한 목적인 여러 함수가 포함되어 있습니다. &lt;a href=&quot;lambdas&quot;&gt;람다식이&lt;/a&gt; 제공된 객체에서 이러한 함수를 호출 하면 임시 범위가 형성됩니다. 이 범위에서 이름없이 개체에 액세스 할 수 있습니다. 이러한 기능을 &lt;em&gt;범위 기능&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; 및 &lt;code&gt;also&lt;/code&gt; 중 다섯 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41ab82952f2d2fb6d715a1d54dee47f369b23a5d" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is available on &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; and we can simply include it in our &lt;code&gt;package.json&lt;/code&gt; as a dependency.</source>
          <target state="translated">Kotlin 표준 라이브러리는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm에서&lt;/a&gt; 사용할 수 있으며이를 &lt;code&gt;package.json&lt;/code&gt; 에 종속성으로 간단히 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa008c18e28c0e852d10e5f6a39e59c2d9ab879a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library is now fully compatible with the Java 9 module system, which forbids split packages (multiple jar files declaring classes in the same package). In order to support that, new artifacts &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; are introduced, which replace the old &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt;.</source>
          <target state="translated">Kotlin 표준 라이브러리는 이제 Java 9 모듈 시스템과 완전히 호환되므로 분할 패키지 (같은 패키지의 클래스를 선언하는 여러 jar 파일)를 금지합니다. 이를 지원하기 위해 새로운 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; 이 도입되어 기존 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="870dd777a08235fb630e1002ab11ba8d4d93e900" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library offers a broad variety of functions for performing operations on collections. This includes simple operations, such as getting or adding elements, as well as more complex ones including search, sorting, filtering, transformations, and so on.</source>
          <target state="translated">Kotlin 표준 라이브러리는 컬렉션에서 작업을 수행하기위한 다양한 기능을 제공합니다. 여기에는 요소 가져 오기 또는 추가와 같은 간단한 작업뿐만 아니라 검색, 정렬, 필터링, 변환 등을 포함한보다 복잡한 작업이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7504a2da20208970eadd23d20d879fda0292513a" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a series of wrappers around the JavaScript API for interacting with documents. The main component we'd usually access is the variable &lt;code&gt;document&lt;/code&gt;. Given we have access to this, we can simply read and write to the corresponding properties. For instance, to set the background of the page we can do</source>
          <target state="translated">Kotlin 표준 라이브러리는 문서와 상호 작용하기 위해 JavaScript API를 중심으로 일련의 래퍼를 제공합니다. 우리가 일반적으로 액세스하는 주요 구성 요소는 변수 &lt;code&gt;document&lt;/code&gt; 입니다. 이에 액세스 할 수 있으면 해당 속성을 읽고 쓸 수 있습니다. 예를 들어 페이지의 배경을 설정하려면</target>
        </trans-unit>
        <trans-unit id="d4672fe3591cd8e490f322d7264f5d7b48dbb930" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides a set of extension functions for collection &lt;em&gt;transformations&lt;/em&gt;. These functions build new collections from existing ones based on the transformation rules provided. In this page, we'll give an overview of the available collection transformation functions.</source>
          <target state="translated">Kotlin 표준 라이브러리는 콜렉션 &lt;em&gt;변환을&lt;/em&gt; 위한 확장 기능 세트를 제공합니다 . 이 함수는 제공된 변환 규칙을 기반으로 기존 컬렉션에서 새 컬렉션을 만듭니다. 이 페이지에서는 사용 가능한 컬렉션 변환 기능에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d403b1b6b6cec3fc85d2c8444ad4595fd15211b" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides developers with a mechanism for creating and using &lt;em&gt;experimental&lt;/em&gt; APIs. This mechanism lets library authors inform users that certain components of their API, such as classes or functions, are unstable and are likely to change in the future. Such changes may require rewriting and recompiling the client code. To prevent potential compatibility issues, the compiler warns users of the experimental status of such APIs and may require them to give their explicit consent to use the API.</source>
          <target state="translated">Kotlin 표준 라이브러리는 개발자에게 &lt;em&gt;실험적인&lt;/em&gt; API 를 만들고 사용하기위한 메커니즘을 제공합니다 . 이 메커니즘을 통해 라이브러리 작성자는 클래스 또는 함수와 같은 API의 특정 구성 요소가 불안정하고 향후 변경 될 수 있음을 사용자에게 알릴 수 있습니다. 이러한 변경은 클라이언트 코드를 다시 작성하고 다시 컴파일해야 할 수도 있습니다. 잠재적 인 호환성 문제를 방지하기 위해 컴파일러는 사용자에게 이러한 API의 실험 상태를 경고하고 API 사용에 대한 명시 적 동의를 요구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25b12f54730219e6bd01543d34c7f6d86941696e" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides extension functions for grouping collection elements. The basic function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt;&lt;code&gt;groupBy()&lt;/code&gt;&lt;/a&gt; takes a lambda function and returns a &lt;code&gt;Map&lt;/code&gt;. In this map, each key is the lambda result and the corresponding value is the &lt;code&gt;List&lt;/code&gt; of elements on which this result is returned. This function can be used, for example, to group a list of &lt;code&gt;String&lt;/code&gt;s by their first letter.</source>
          <target state="translated">Kotlin 표준 라이브러리는 컬렉션 요소를 그룹화하기위한 확장 기능을 제공합니다. 기본 함수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/group-by&quot;&gt; &lt;code&gt;groupBy()&lt;/code&gt; &lt;/a&gt; 는 람다 함수를 사용하여 &lt;code&gt;Map&lt;/code&gt; 을 반환합니다 . 이 맵에서 각 키는 람다 결과이고 해당 값은 이 결과가 반환되는 요소 &lt;code&gt;List&lt;/code&gt; 입니다. 예를 들어,이 함수를 사용 하여 첫 번째 문자 로 &lt;code&gt;String&lt;/code&gt; 목록을 그룹화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d49763e3623bb841ba6b661af00bff69df48a815" translate="yes" xml:space="preserve">
          <source>The Kotlin standard library provides factory methods for several useful kinds of delegates.</source>
          <target state="translated">Kotlin 표준 라이브러리는 여러 유용한 종류의 델리게이트에 대한 팩토리 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d4752902cbbab973b31545d271408bf4e6b55c29" translate="yes" xml:space="preserve">
          <source>The Kotlin team offers a set of tools for Android development that goes beyond the standard language features:</source>
          <target state="translated">Kotlin 팀은 표준 언어 기능을 능가하는 Android 개발 도구 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3835dcf5cfa983896474e2202e8aad1e87118beb" translate="yes" xml:space="preserve">
          <source>The Kotlin visibilities are mapped to Java in the following way:</source>
          <target state="translated">Kotlin 가시성은 다음과 같은 방식으로 Java에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="ed293f7536e6525a4d07d9691dc5108b394e4a3c" translate="yes" xml:space="preserve">
          <source>The Kotlin visibility modifiers map to Java in the following way:</source>
          <target state="translated">Kotlin 가시성 수정자는 다음과 같은 방식으로 자바에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="f818f7eac72c440d892f7b7bd134c99b2cf031b4" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin handles DCE automatically when you build a &lt;strong&gt;production bundle&lt;/strong&gt;, for example by using the &lt;code&gt;browserProductionWebpack&lt;/code&gt; task. &lt;strong&gt;Development bundling&lt;/strong&gt; tasks (like &lt;code&gt;browserDevelopmentWebpack&lt;/code&gt;) don't include DCE.</source>
          <target state="translated">Kotlin / JS Gradle 플러그인은 예를 들어 &lt;code&gt;browserProductionWebpack&lt;/code&gt; 작업 을 사용하여 &lt;strong&gt;프로덕션 번들&lt;/strong&gt; 을 빌드 할 때 DCE를 자동으로 처리합니다 . &lt;strong&gt;개발 번들링&lt;/strong&gt; 작업 (예 : &lt;code&gt;browserDevelopmentWebpack&lt;/code&gt; )에는 DCE가 포함되지 않습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e48978274145dccf82bae99c2dc2a30b0c91f68" translate="yes" xml:space="preserve">
          <source>The Kotlin/JS Gradle plugin includes a &lt;a href=&quot;https://wikipedia.org/wiki/Dead_code_elimination&quot;&gt;&lt;em&gt;dead code elimination&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;DCE&lt;/em&gt;) tool. Dead code elimination is often also called &lt;em&gt;tree shaking&lt;/em&gt;. It reduces the size or the resulting JavaScript code by removing unused properties, functions, and classes.</source>
          <target state="translated">Kotlin / JS Gradle 플러그인에는 &lt;a href=&quot;https://wikipedia.org/wiki/Dead_code_elimination&quot;&gt;&lt;em&gt;데드 코드 제거&lt;/em&gt;&lt;/a&gt; ( &lt;em&gt;DCE&lt;/em&gt; ) 도구가 포함되어 있습니다. 데드 코드 제거는 종종 &lt;em&gt;트리 쉐이킹&lt;/em&gt; 이라고도 &lt;em&gt;합니다&lt;/em&gt; . 사용하지 않는 속성, 함수 및 클래스를 제거하여 크기 또는 결과 JavaScript 코드를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="6d899757cb2398280c10acb19695bbcab979ce63" translate="yes" xml:space="preserve">
          <source>The Kotlin/Native compiler is available for macOS, Linux, and Windows. It supports different targets including iOS (arm32, arm64, simulator x86_64), Windows (mingw32 and x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM. For the full list of targets we can refer to the &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt;. While cross-platform compilation is possible (i.e., using one platform to compile for another), in this first tutorial we are only compiling for the operating system we're running on.</source>
          <target state="translated">Kotlin / Native 컴파일러는 macOS, Linux 및 Windows에서 사용할 수 있습니다. iOS (arm32, arm64, 시뮬레이터 x86_64), Windows (mingw32 및 x86_64), Linux (x86_64, arm64, MIPS), macOS (x86_64), Raspberry PI, SMT32, WASM 등 다양한 대상을 지원합니다. 전체 대상 목록은 &lt;a href=&quot;../../reference/native-overview&quot;&gt;Kotlin / Native 개요를&lt;/a&gt; 참조하십시오 . 플랫폼 간 컴파일이 가능하지만 (예 : 한 플랫폼을 사용하여 다른 플랫폼을 위해 컴파일)이 첫 번째 자습서에서는 실행중인 운영 체제에 대해서만 컴파일하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="81130cfc1e83adbcab9e6da86955c53516b100d6" translate="yes" xml:space="preserve">
          <source>The Language Committee makes final decisions on what incompatible changes will be made and what exact measures should be taken to make user updates comfortable. In doing so, it relies on a set of guidelines available &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">언어위원회는 호환되지 않는 변경 사항과 사용자 업데이트를 편하게하기 위해 어떤 조치를 취해야하는지에 대한 최종 결정을 내립니다. 이를 위해 &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;여기&lt;/a&gt; 에있는 일련의 지침에 의존 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef80e6d685a55893a99e950f4ed7fce2a86a1387" translate="yes" xml:space="preserve">
          <source>The Maven coordinates can be altered and additional artifact files may be added to the publications within the &lt;code&gt;targets { ... }&lt;/code&gt; block or the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL:</source>
          <target state="translated">Maven 좌표를 변경하고 &lt;code&gt;targets { ... }&lt;/code&gt; 블록 또는 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL 내의 게시에 추가 아티팩트 파일을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88e2042b128835939040b35b47b76d2e41113fdc" translate="yes" xml:space="preserve">
          <source>The Node.js target provided by Kotlin/JS enables you to create applications that &lt;strong&gt;run on a server&lt;/strong&gt; or get &lt;strong&gt;executed on serverless infrastructure&lt;/strong&gt;. You benefit from the same advantages as other applications executing in a JavaScript runtime, such as &lt;strong&gt;faster startup speed&lt;/strong&gt; and a &lt;strong&gt;reduced memory footprint&lt;/strong&gt;. With &lt;a href=&quot;https://github.com/Kotlin/kotlinx-nodejs&quot;&gt;&lt;code&gt;kotlinx-nodejs&lt;/code&gt;&lt;/a&gt;, you have typesafe access to the &lt;a href=&quot;https://nodejs.org/docs/latest/api/&quot;&gt;Node.js API&lt;/a&gt; directly from your Kotlin code.</source>
          <target state="translated">Kotlin / JS에서 제공하는 Node.js 타겟을 사용하면 &lt;strong&gt;서버에서 &lt;/strong&gt;&lt;strong&gt;실행&lt;/strong&gt; 되거나 &lt;strong&gt;서버리스 인프라에서 실행되는&lt;/strong&gt; 애플리케이션을 만들 수 있습니다 . &lt;strong&gt;더 빠른 시작 속도&lt;/strong&gt; 및 &lt;strong&gt;감소 된 메모리 공간&lt;/strong&gt; 과 같은 JavaScript 런타임에서 실행되는 다른 애플리케이션과 동일한 이점을 누릴 수 있습니다 . 함께 &lt;a href=&quot;https://github.com/Kotlin/kotlinx-nodejs&quot;&gt; &lt;code&gt;kotlinx-nodejs&lt;/code&gt; &lt;/a&gt; , 당신은 형태 보증 된 액세스가 &lt;a href=&quot;https://nodejs.org/docs/latest/api/&quot;&gt;Node.js를 API&lt;/a&gt; 당신의 코 틀린 코드에서 직접합니다.</target>
        </trans-unit>
        <trans-unit id="cc27fb0be25fb775df8eea4ef2ba6465502161d0" translate="yes" xml:space="preserve">
          <source>The Nothing type</source>
          <target state="translated">아무것도없는 타입</target>
        </trans-unit>
        <trans-unit id="8cc0334fa925283a3687c8c8309944d9801a3bf7" translate="yes" xml:space="preserve">
          <source>The REPL command line interface opens. You can enter any valid Kotlin code and see the result. Results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">REPL 명령 행 인터페이스가 열립니다. 유효한 Kotlin 코드를 입력하고 결과를 볼 수 있습니다. 결과는 &lt;code&gt;res*&lt;/code&gt; 와 같이 자동 생성 된 이름을 가진 변수로 인쇄됩니다 . 나중에 REPL에서 실행하는 코드에서 이러한 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd3a2d7df046fd886264d64f792856593ec9b52" translate="yes" xml:space="preserve">
          <source>The REPL command line interface will open. You can enter any valid Kotlin code and see the result. The results are printed as variables with auto-generated names like &lt;code&gt;res*&lt;/code&gt;. You can later use such variables in the code you run in REPL.</source>
          <target state="translated">REPL 명령 줄 인터페이스가 열립니다. 유효한 Kotlin 코드를 입력하고 결과를 볼 수 있습니다. 결과는 &lt;code&gt;res*&lt;/code&gt; 와 같이 자동 생성 된 이름을 가진 변수로 인쇄됩니다 . 나중에 REPL에서 실행하는 코드에서 이러한 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b7ee6e00ac4369b5da7230befe3c113bdc4222a" translate="yes" xml:space="preserve">
          <source>The above code compiles. However, it will produce a runtime error if the object is not properly initialised before use or if &lt;code&gt;callAnything()&lt;/code&gt; is not defined at runtime.</source>
          <target state="translated">위의 코드는 컴파일됩니다. 그러나 사용하기 전에 객체가 올바르게 초기화되지 않았거나 런타임에 &lt;code&gt;callAnything()&lt;/code&gt; 이 정의되어 있지 않으면 런타임 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f67cd69d25bde43de96336b3847aa293b8518b9e" translate="yes" xml:space="preserve">
          <source>The above code indicates that the function is defined externally. The &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; annotation allows us to map the name at runtime to &lt;code&gt;$&lt;/code&gt;. For more details on external declarations, please refer to the &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop documentation&lt;/a&gt;.</source>
          <target state="translated">위의 코드는 함수가 외부에서 정의되었음을 나타냅니다. &lt;code&gt;@JsName(&quot;$&quot;)&lt;/code&gt; 주석은 우리가 런타임에 이름을 매핑 할 수 있습니다 &lt;code&gt;$&lt;/code&gt; . 외부 선언에 대한 자세한 내용은 &lt;a href=&quot;../../reference/js-interop#external-modifier&quot;&gt;JavaScript interop 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5749a0f0fe8aac855f406af86fe841d365cd7cde" translate="yes" xml:space="preserve">
          <source>The above could also be a oneliner - and note that the compiler knows that because the &lt;code&gt;throw&lt;/code&gt; will prevent &lt;code&gt;y&lt;/code&gt; from coming into existence if &lt;code&gt;x&lt;/code&gt; is null, &lt;code&gt;y&lt;/code&gt; must be non-null if we reach the line below. Contrast this with &lt;code&gt;x?.importantFunction()&lt;/code&gt;, which is a no-op if &lt;code&gt;x&lt;/code&gt; is null.</source>
          <target state="translated">위의 내용은 oneliner 일 수도 있습니다. 컴파일러는 &lt;code&gt;x&lt;/code&gt; 가 null 인 경우 &lt;code&gt;throw&lt;/code&gt; 로 인해 &lt;code&gt;y&lt;/code&gt; 가 존재 하지 못하게 되므로 아래 줄에 도달하면 &lt;code&gt;y&lt;/code&gt; 가 null 이 아니어야합니다. 이것을 &lt;code&gt;x?.importantFunction()&lt;/code&gt; 과 대조하십시오 . &lt;code&gt;x&lt;/code&gt; 가 null 이면 no-op 입니다.</target>
        </trans-unit>
        <trans-unit id="a87217033eafba44229106ab25d3816102c24f78" translate="yes" xml:space="preserve">
          <source>The above is preferable to:</source>
          <target state="translated">위의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83d32caa4c432fbb23e6f884577d8ac97faf56a2" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;contravariant&lt;/em&gt;. Denoted by the &lt;code&gt;in&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">영향을받는 유형 매개 변수 또는 유형은 &lt;em&gt;반 변형&lt;/em&gt; 입니다. 에 의해 표시 &lt;code&gt;in&lt;/code&gt; 소스 코드의 수정.</target>
        </trans-unit>
        <trans-unit id="c340d256f4b2e039e4cb98547a639c6b4f11b7ba" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;covariant&lt;/em&gt;. Denoted by the &lt;code&gt;out&lt;/code&gt; modifier in the source code.</source>
          <target state="translated">영향을받는 유형 매개 변수 또는 유형은 &lt;em&gt;공변량&lt;/em&gt; 입니다. 에 의해 표시 &lt;code&gt;out&lt;/code&gt; 소스 코드의 수정.</target>
        </trans-unit>
        <trans-unit id="dff58c2fdf74d3cdbb35c54ab0e0155e83797493" translate="yes" xml:space="preserve">
          <source>The affected type parameter or type is &lt;em&gt;invariant&lt;/em&gt;, which means it has no variance applied to it.</source>
          <target state="translated">영향을받는 유형 매개 변수 또는 유형이 &lt;em&gt;변하지&lt;/em&gt; 않으므로 적용되는 분산이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e638916d7acda84432e87e4a36d2e48c0c286bc5" translate="yes" xml:space="preserve">
          <source>The annotation also works for constructors, static methods, and so on. It can't be used on abstract methods, including methods defined in interfaces.</source>
          <target state="translated">주석은 생성자, 정적 메서드 등에서도 작동합니다. 인터페이스에 정의 된 메소드를 포함한 추상 메소드에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="718f26b180ad67d2a1e20d6b7d4406049d2961a3" translate="yes" xml:space="preserve">
          <source>The annotation can be used on top-level external declarations (classes, properties, functions) and files. In case of file (which can't be &lt;code&gt;external&lt;/code&gt;) the following rule applies: all the declarations in the file must be &lt;code&gt;external&lt;/code&gt;. By applying &lt;code&gt;@JsModule(...)&lt;/code&gt; on a file you tell the compiler to import a JavaScript object that contain all the declarations from the file.</source>
          <target state="translated">주석은 최상위 외부 선언 (클래스, 속성, 함수) 및 파일에서 사용할 수 있습니다. 파일 ( &lt;code&gt;external&lt;/code&gt; 수 없음 )의 경우 다음 규칙이 적용됩니다. 파일의 모든 선언은 &lt;code&gt;external&lt;/code&gt; 이어야합니다 . 파일에 &lt;code&gt;@JsModule(...)&lt;/code&gt; 을 적용 하면 파일에서 모든 선언을 포함하는 JavaScript 객체를 가져 오도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ac7d8e089591134bac44995dadba571525f38003" translate="yes" xml:space="preserve">
          <source>The annotation has effect only in Kotlin/Native platform.</source>
          <target state="translated">주석은 Kotlin / Native 플랫폼에서만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="993a0bc9861bdf8ea351a5eb1dd7c588f24a97de" translate="yes" xml:space="preserve">
          <source>The annotations for marking and using experimental APIs (&lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;@UseExperimental&lt;/code&gt;) are &lt;em&gt;experimental&lt;/em&gt; in Kotlin 1.3. See details &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">실험적 API ( &lt;code&gt;@Experimental&lt;/code&gt; 및 &lt;code&gt;@UseExperimental&lt;/code&gt; ) 를 표시하고 사용하기위한 주석은 Kotlin 1.3에서 &lt;em&gt;실험적&lt;/em&gt; 입니다. 세부 사항을 참조하십시오 &lt;a href=&quot;#experimental-status-of-experimental-api-markers&quot;&gt;아래를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb7079c4ed4f36ab04fb8b963913758bd291799" translate="yes" xml:space="preserve">
          <source>The anonymous function syntax allows you to specify the receiver type of a function literal directly. This can be useful if you need to declare a variable of a function type with receiver, and to use it later.</source>
          <target state="translated">익명 함수 구문을 사용하면 함수 리터럴의 수신자 유형을 직접 지정할 수 있습니다. 리시버로 함수 타입의 변수를 선언하고 나중에 사용해야 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99a96b83211ab5edf0514b0e8d206e232457fc5" translate="yes" xml:space="preserve">
          <source>The application we're going to create will simply show &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; on Android and &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; on iOS. The idea is to share the code that generates this message.</source>
          <target state="translated">우리가 만들 응용 프로그램은 Android의 Android에서는 &lt;code&gt;Kotlin Rocks on iOS &amp;lt;version&amp;gt;&lt;/code&gt; 에서는 &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 표시 합니다. 이 메시지를 생성하는 코드를 공유하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c116b8d3b85f1f036748497d93f617762a69f1eb" translate="yes" xml:space="preserve">
          <source>The array literal syntax is constrained to annotation arguments.</source>
          <target state="translated">배열 리터럴 구문은 주석 인수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="e6585b22e37432101f079b3e68122b140a6c8d0b" translate="yes" xml:space="preserve">
          <source>The arrow notation is right-associative, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; is equivalent to the previous example, but not to &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt;.</source>
          <target state="translated">화살표 표기법은 오른쪽 연관이며, &lt;code&gt;(Int) -&amp;gt; (Int) -&amp;gt; Unit&lt;/code&gt; 은 이전 예제와 동일하지만 &lt;code&gt;((Int) -&amp;gt; (Int)) -&amp;gt; Unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eff75fbb6c3dbfe907753b9474216f02d469cd66" translate="yes" xml:space="preserve">
          <source>The author strongly recommends that you use an IDE with Kotlin support, as the static typing allows an IDE to do reliable navigation and code completion. I recommend &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, which is built by the same company that created Kotlin. The Community Edition is free; see &lt;a href=&quot;../getting-started&quot;&gt;instructions for getting started&lt;/a&gt; (it comes bundled with Kotlin, and you can run your program from the IDE).</source>
          <target state="translated">정적 타이핑을 사용하면 IDE에서 안정적인 탐색 및 코드 완성을 수행 할 수 있으므로 저자는 Kotlin을 지원하는 IDE를 사용하는 것이 좋습니다. Kotlin을 만든 회사에서 만든 &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA를&lt;/a&gt; 권장 합니다. Community Edition은 무료입니다. &lt;a href=&quot;../getting-started&quot;&gt;시작 지침을&lt;/a&gt; 참조하십시오 (Kotlin과 함께 제공되며 IDE에서 프로그램을 실행할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="031b37e00f6cc7d0005e366d6305ce9ae5158eb7" translate="yes" xml:space="preserve">
          <source>The available options for persistence include direct JDBC access, JPA, as well as using NoSQL databases through their Java drivers. For JPA, the &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa compiler plugin&lt;/a&gt; adapts Kotlin-compiled classes to the requirements of the framework.</source>
          <target state="translated">지속성에 사용 가능한 옵션에는 직접 JDBC 액세스, JPA 및 Java 드라이버를 통한 NoSQL 데이터베이스 사용이 포함됩니다. JPA의 경우, &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;kotlin-jpa 컴파일러 플러그인&lt;/a&gt; 은 Kotlin으로 컴파일 된 클래스를 프레임 워크의 요구 사항에 맞게 조정합니다.</target>
        </trans-unit>
        <trans-unit id="f64d03b5ac4e40dff196fed46f6ad483b559e0ca" translate="yes" xml:space="preserve">
          <source>The base class for all errors and exceptions. Only instances of this class can be thrown or caught.</source>
          <target state="translated">모든 오류 및 예외의 기본 클래스입니다. 이 클래스의 인스턴스 만 던지거나 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9567e5bd74f98cde043ce2604d36c00a7448fbca" translate="yes" xml:space="preserve">
          <source>The base exception class is &lt;code&gt;Throwable&lt;/code&gt; (but it is more common to extend its subclass &lt;code&gt;Exception&lt;/code&gt;), and there are a ton of built-in exception classes. If you don't find one that match your needs, you can create your own by inheriting from an existing exception class.</source>
          <target state="translated">기본 예외 클래스는 &lt;code&gt;Throwable&lt;/code&gt; 이지만 (하위 클래스 &lt;code&gt;Exception&lt;/code&gt; 확장하는 것이 더 일반적 임), 많은 내장 예외 클래스가 있습니다. 필요에 맞는 것을 찾지 못하면 기존 예외 클래스에서 상속하여 직접 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9ecc0f2cf4982d26aff3dd399995b9e266ca38f" translate="yes" xml:space="preserve">
          <source>The basic association function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt;&lt;code&gt;associateWith()&lt;/code&gt;&lt;/a&gt; creates a &lt;code&gt;Map&lt;/code&gt; in which the elements of the original collection are keys, and values are produced from them by the given transformation function. If two elements are equal, only the last one remains in the map.</source>
          <target state="translated">기본 연관 함수 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/associate-with&quot;&gt; &lt;code&gt;associateWith()&lt;/code&gt; &lt;/a&gt; 는 원래 컬렉션의 요소가 키이고 지정된 변환 함수에 의해 값이 생성되는 &lt;code&gt;Map&lt;/code&gt; 을 만듭니다 . 두 요소가 같으면 마지막 요소 만 맵에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="8747487378c0fd48a48984cf8a26dd2308ffac09" translate="yes" xml:space="preserve">
          <source>The basic filtering function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;. When called with a predicate, &lt;code&gt;filter()&lt;/code&gt; returns the collection elements that match it. For both &lt;code&gt;List&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;, the resulting collection is a &lt;code&gt;List&lt;/code&gt;, for &lt;code&gt;Map&lt;/code&gt; it's a &lt;code&gt;Map&lt;/code&gt; as well.</source>
          <target state="translated">기본 필터링 함수는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 입니다. 술어와 함께 호출되면 &lt;code&gt;filter()&lt;/code&gt; 는 일치하는 콜렉션 요소를 리턴합니다. &lt;code&gt;List&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 모두 결과 컬렉션은 &lt;code&gt;List&lt;/code&gt; 이며 &lt;code&gt;Map&lt;/code&gt; 의 경우 &lt;code&gt;Map&lt;/code&gt; 이기도합니다.</target>
        </trans-unit>
        <trans-unit id="699437afba4c1eb6f2aa1a305318c9d9571a4fe8" translate="yes" xml:space="preserve">
          <source>The basic functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt;&lt;code&gt;sortedDescending()&lt;/code&gt;&lt;/a&gt; return elements of a collection sorted into ascending and descending sequence according to their natural order. These functions apply to collections of &lt;code&gt;Comparable&lt;/code&gt; elements.</source>
          <target state="translated">기본 함수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-descending&quot;&gt; &lt;code&gt;sortedDescending()&lt;/code&gt; &lt;/a&gt; 은 자연 순서에 따라 오름차순 및 내림차순으로 정렬 된 컬렉션의 요소를 반환합니다. 이러한 기능은 &lt;code&gt;Comparable&lt;/code&gt; 요소의 모음에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="176655605bee6eae4892bd4ec703e94408b0c3f3" translate="yes" xml:space="preserve">
          <source>The best place to start is &lt;a href=&quot;https://kotlinlang.org&quot;&gt;this website&lt;/a&gt;. From there you can download the compiler, &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;try it online&lt;/a&gt; as well as get access to resources, &lt;a href=&quot;index&quot;&gt;reference documentation&lt;/a&gt; and &lt;a href=&quot;../tutorials/index&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">시작하기 가장 좋은 곳은 &lt;a href=&quot;https://kotlinlang.org&quot;&gt;이 웹 사이트&lt;/a&gt; 입니다. 여기에서 컴파일러를 다운로드하고 &lt;a href=&quot;https://play.kotlinlang.org&quot;&gt;온라인&lt;/a&gt; 으로 시도 할 수있을 뿐만 아니라 리소스, &lt;a href=&quot;index&quot;&gt;참조 설명서&lt;/a&gt; 및 &lt;a href=&quot;../tutorials/index&quot;&gt;자습서에&lt;/a&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00b10508469a6652d6e476b8749625b68deb8ad" translate="yes" xml:space="preserve">
          <source>The best way to see what C data types are visible in Kotlin is to try it</source>
          <target state="translated">Kotlin에서 C 데이터 유형을 볼 수있는 가장 좋은 방법은 시도하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8cccc62dffea928c706df5dfd73f9995b0b8212a" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between C and Kotlin languages is to try it out on a small example. We will create a small library headers for that. First, we need to create a &lt;code&gt;lib.h&lt;/code&gt; file with the following declaration of functions that deal with the C strings:</source>
          <target state="translated">C와 Kotlin 언어 간의 매핑을 이해하는 가장 좋은 방법은 간단한 예를 통해 시험해 보는 것입니다. 이를 위해 작은 라이브러리 헤더를 만들 것입니다. 먼저 C 문자열을 다루는 다음 함수 선언으로 &lt;code&gt;lib.h&lt;/code&gt; 파일 을 만들어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ffd6c6681f86404c6d10fd90b4e30255a8c338ed" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.</source>
          <target state="translated">Kotlin과 C의 매핑을 이해하는 가장 좋은 방법은 작은 예를 시도하는 것입니다. 함수 포인터를 매개 변수로 받아들이는 함수와 함수 포인터를 반환하는 다른 함수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="6537550691113ba29bcd420ea4633f14458a70b1" translate="yes" xml:space="preserve">
          <source>The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.</source>
          <target state="translated">Kotlin과 C의 매핑을 이해하는 가장 좋은 방법은 작은 예를 시도하는 것입니다. 우리는 C 언어로 구조체와 공용체를 선언하여 코 틀린에 어떻게 매핑되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4232ac266b4561b99b9bc10fa2be9171a24a3226" translate="yes" xml:space="preserve">
          <source>The best way to understand these techniques is to try them out. Let's create a first tiny Kotlin library and use it from a C program.</source>
          <target state="translated">이러한 기술을 이해하는 가장 좋은 방법은 시험해 보는 것입니다. 첫 번째 작은 Kotlin 라이브러리를 만들어 C 프로그램에서 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="eaa47ef7640a883ac2445b67958ca2668d316a2e" translate="yes" xml:space="preserve">
          <source>The best way to use the Kotlin/Native compiler is with a build system. It helps by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, and running the compiler and tests. It caches the compilation results too. A build system can also be used by an IDE to understand the project layout.</source>
          <target state="translated">Kotlin / Native 컴파일러를 사용하는 가장 좋은 방법은 빌드 시스템을 사용하는 것입니다. 전이 의존성이있는 Kotlin / Native 컴파일러 바이너리 및 라이브러리를 다운로드 및 캐싱하고 컴파일러 및 테스트를 실행하면 도움이됩니다. 컴파일 결과도 캐시합니다. IDE에서 빌드 시스템을 사용하여 프로젝트 레이아웃을 이해할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9af9e08ad353ac6ed57e0041c23dca829fbff7c4" translate="yes" xml:space="preserve">
          <source>The binaries DSL allows not only creating binaries but also accessing already created ones to configure them or get their properties (e.g. path to an output file). The &lt;code&gt;binaries&lt;/code&gt; collection implements the &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt;&lt;code&gt;DomainObjectSet&lt;/code&gt;&lt;/a&gt; interface and provides methods like &lt;code&gt;all&lt;/code&gt; or &lt;code&gt;matching&lt;/code&gt; allowing configuring groups of elements.</source>
          <target state="translated">바이너리 DSL을 사용하면 바이너리를 생성 할뿐만 아니라 이미 생성 된 바이너리에 액세스하여이를 구성하거나 속성 (예 : 출력 파일 경로)을 얻을 수 있습니다. &lt;code&gt;binaries&lt;/code&gt; 컬렉션 구현 &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/DomainObjectSet.html&quot;&gt; &lt;code&gt;DomainObjectSet&lt;/code&gt; 의&lt;/a&gt; 인터페이스와 같은 방법을 제공하는 &lt;code&gt;all&lt;/code&gt; 또는 &lt;code&gt;matching&lt;/code&gt; 요소의 그룹을 구성 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="bc8bcc38381183bfcc94707aa9b37df0e52f23b1" translate="yes" xml:space="preserve">
          <source>The binary files are created in the &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; or &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; folders respectively. The file has a &lt;code&gt;.kexe&lt;/code&gt; extension on Linux and macOS and an &lt;code&gt;.exe&lt;/code&gt; extension on Windows. Use the following command to instruct the build to produce binaries:</source>
          <target state="translated">이진 파일은 각각 &lt;code&gt;build/bin/native/debugExecutable&lt;/code&gt; 또는 &lt;code&gt;build/bin/native/releaseExecutable&lt;/code&gt; 폴더에 생성됩니다. 파일은 Linux 및 macOS에서 확장자 가 &lt;code&gt;.kexe&lt;/code&gt; 이고 Windows에서 확장자 가 &lt;code&gt;.exe&lt;/code&gt; 입니다. 바이너리를 생성하도록 빌드에 지시하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="54650137fcf92a797ec9822a89e0e51a3d74473c" translate="yes" xml:space="preserve">
          <source>The block after &lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; is the first function literal with receiver, which will be passed to &lt;code&gt;tree()&lt;/code&gt; as the &lt;code&gt;initialize&lt;/code&gt; parameter. According to the parameter list of &lt;code&gt;tree()&lt;/code&gt;, the receiver is of type &lt;code&gt;TreeNode&lt;/code&gt;, and therefore, &lt;code&gt;tree()&lt;/code&gt; can call &lt;code&gt;initialize()&lt;/code&gt; on &lt;code&gt;root&lt;/code&gt;. &lt;code&gt;root&lt;/code&gt; then becomes &lt;code&gt;this&lt;/code&gt; inside the scope of that lambda expression, so when we call &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt;, it implicitly says &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt;, where &lt;code&gt;this&lt;/code&gt; refers to the same &lt;code&gt;TreeNode&lt;/code&gt; as &lt;code&gt;root&lt;/code&gt;. The next block is passed to &lt;code&gt;TreeNode.node()&lt;/code&gt;, and is invoked on the first child of the &lt;code&gt;root&lt;/code&gt; node, namely &lt;code&gt;math&lt;/code&gt;, and inside it, &lt;code&gt;this&lt;/code&gt; will refer to &lt;code&gt;math&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tree(&quot;root&quot;)&lt;/code&gt; 뒤의 블록 은 수신자가있는 첫 번째 함수 리터럴이며 &lt;code&gt;initialize&lt;/code&gt; 매개 변수 로 &lt;code&gt;tree()&lt;/code&gt; 전달됩니다 . &lt;code&gt;tree()&lt;/code&gt; 의 매개 변수 목록에 따르면 수신자는 &lt;code&gt;TreeNode&lt;/code&gt; 유형 이므로 &lt;code&gt;tree()&lt;/code&gt; 는 &lt;code&gt;root&lt;/code&gt; 에서 &lt;code&gt;initialize()&lt;/code&gt; 를 호출 할 수 있습니다 . &lt;code&gt;root&lt;/code&gt; 다음이된다 &lt;code&gt;this&lt;/code&gt; 그 람다 식의 범위 내에서, 그래서 우리는 호출 할 때 &lt;code&gt;node(&quot;math&quot;)&lt;/code&gt; , 그것은 암시 적으로 말한다 &lt;code&gt;this.node(&quot;math&quot;)&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; 같은를 의미 &lt;code&gt;TreeNode&lt;/code&gt; 를 같은 &lt;code&gt;root&lt;/code&gt; . 다음 블록에 전달됩니다 &lt;code&gt;TreeNode.node()&lt;/code&gt; 과의 첫 번째 자식에 호출 &lt;code&gt;root&lt;/code&gt; 노드, 즉 &lt;code&gt;math&lt;/code&gt; , 그리고 그 안에, &lt;code&gt;this&lt;/code&gt; 참조됩니다 &lt;code&gt;math&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="299004dba6c7ef441e08541633a7bed7d65922cd" translate="yes" xml:space="preserve">
          <source>The body can be a block.</source>
          <target state="translated">몸은 블록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17dad4981064bd9e13820de989411c6afec8c62" translate="yes" xml:space="preserve">
          <source>The body of an object expression may access, and possibly modify, the local variables of the containing scope.</source>
          <target state="translated">객체 표현식의 본문은 포함하는 범위의 로컬 변수에 액세스하고 가능하면 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb082a62156761cbe45120602d0be4ff5a5d1b2" translate="yes" xml:space="preserve">
          <source>The box classes used for capturing mutable closure variables in lambdas no longer have volatile fields. This change improves performance, but can lead to new race conditions in some rare usage scenarios. If you're affected by this, you need to provide your own synchronization for accessing the variables.</source>
          <target state="translated">람다에서 가변 클로저 변수를 캡처하는 데 사용되는 박스 클래스에는 더 이상 휘발성 필드가 없습니다. 이 변경으로 성능이 향상되지만 드문 사용 시나리오에서 새로운 경쟁 조건이 발생할 수 있습니다. 이로 인해 영향을받는 경우 변수에 액세스하기위한 고유 한 동기화를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0bb1979f4fa500a54eb079957dc97f38da2dd0fd" translate="yes" xml:space="preserve">
          <source>The build generates the following files under the &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; folder, depending on the host OS:</source>
          <target state="translated">빌드 는 호스트 OS에 따라 &lt;code&gt;build/bin/native/debugShared&lt;/code&gt; 폴더 아래에 다음 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="8d7f1cfca83f4be43b98d7bc6f3dc13e77358eda" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;C().foo(1)&lt;/code&gt; will print &quot;extension&quot;.</source>
          <target state="translated">&lt;code&gt;C().foo(1)&lt;/code&gt; 대한 호출 은 &quot;extension&quot;을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5986952e4227de9affa4abe69a35c446c0bfc14d" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;execute&lt;/code&gt; uses a function passed as its second parameter to produce an object subgraph (i.e. set of mutually referring objects) which is then passed as a whole to that worker, it is then no longer available to the thread that initiated the request. This property is checked if the first parameter is &lt;code&gt;TransferMode.SAFE&lt;/code&gt; by graph traversal and is just assumed to be true, if it is &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt;. The last parameter to &lt;code&gt;execute&lt;/code&gt; is a special Kotlin lambda, which is not allowed to capture any state, and is actually invoked in the target worker's context. Once processed, the result is transferred to whatever consumes it in the future, and it is attached to the object graph of that worker/thread.</source>
          <target state="translated">&lt;code&gt;execute&lt;/code&gt; 호출 은 두 번째 매개 변수로 전달 된 함수를 사용하여 오브젝트 서브 그래프 (즉, 상호 참조 오브젝트 세트)를 생성 한 다음 해당 워커에 전체적으로 전달하여 요청을 시작한 스레드에서 더 이상 사용할 수 없게합니다. 첫 번째 변수 인 경우이 속성 판정 &lt;code&gt;TransferMode.SAFE&lt;/code&gt; 이 그래프 순회로하고 있는지 바로 진정한 것으로 가정 &lt;code&gt;TransferMode.UNSAFE&lt;/code&gt; 이 . 마지막으로 &lt;code&gt;execute&lt;/code&gt; 매개 변수 는 특수한 Kotlin 람다로, 상태를 캡처 할 수 없으며 실제로 대상 작업자의 컨텍스트에서 호출됩니다. 일단 처리되면 결과는 나중에 소비되는 모든 항목으로 전송되고 해당 작업자 / 스레드의 개체 그래프에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="cf4d64ccc981a36348dc5e3486734b7a527c1cd6" translate="yes" xml:space="preserve">
          <source>The callback which is called after the change of the property is made. The value of the property has already been changed when this callback is invoked.</source>
          <target state="translated">속성 변경 후 호출되는 콜백이 작성됩니다. 이 콜백이 호출 될 때 속성 값이 이미 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="f46a88a879fdbb85f0bd5182483f8be3f20e50d2" translate="yes" xml:space="preserve">
          <source>The callback which is called before a change to the property value is attempted. The value of the property hasn't been changed yet, when this callback is invoked. If the callback returns &lt;code&gt;true&lt;/code&gt; the value of the property is being set to the new value, and if the callback returns &lt;code&gt;false&lt;/code&gt; the new value is discarded and the property remains its old value.</source>
          <target state="translated">특성 값을 변경하기 전에 호출되는 콜백입니다. 이 콜백이 호출 될 때 속성 값이 아직 변경되지 않았습니다. 콜백이 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 속성 값이 새 값으로 설정되고 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 새 값이 삭제되고 속성은 이전 값으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e3032cd7941afef1fb6a2120a573d1232d288d72" translate="yes" xml:space="preserve">
          <source>The calls that affect inference are either members of the receiver type of an annotated function parameter or extensions for that type. The extensions must be themselves annotated with &lt;code&gt;@BuilderInference&lt;/code&gt;.</source>
          <target state="translated">추론에 영향을 미치는 호출은 어노테이션이있는 함수 매개 변수의 수신자 유형 또는 해당 유형의 확장입니다. 확장명에는 반드시 &lt;code&gt;@BuilderInference&lt;/code&gt; 로 주석을 달아야 합니다.</target>
        </trans-unit>
        <trans-unit id="5833c1f716afd68e76f6ee63506f61a1ac4d8150" translate="yes" xml:space="preserve">
          <source>The changes in dependencies are &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; compatible. For example, the only changes are in method bodies.</source>
          <target state="translated">종속성 변경은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Application_binary_interface&quot;&gt;ABI&lt;/a&gt; 와 호환됩니다. 예를 들어, 메소드 본문에서만 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca6d3d47c03bc25dbb852207c0d849513ed5fbaf" translate="yes" xml:space="preserve">
          <source>The channels shown so far had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (aka rendezvous). If send is invoked first, then it is suspended until receive is invoked, if receive is invoked first, it is suspended until send is invoked.</source>
          <target state="translated">지금까지 표시된 채널에는 버퍼가 없습니다. 송신자와 수신자가 서로 만날 때 버퍼되지 않은 채널 전송 요소 (일명 랑데부). send가 먼저 호출되면 receive가 호출 될 때까지 일시 중단되고 receive가 먼저 호출되면 send가 호출 될 때까지 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="fa768c5c4432c77d50de790cda1c8c687dccf1cc" translate="yes" xml:space="preserve">
          <source>The character &quot; &amp;ndash; quotation mark</source>
          <target state="translated">문자 &quot;&amp;ndash; 인용 부호</target>
        </trans-unit>
        <trans-unit id="10c860623b3bfd4256ce034a4fa10ecca2e8d17c" translate="yes" xml:space="preserve">
          <source>The character $ &amp;ndash; dollar sign</source>
          <target state="translated">문자 $ &amp;ndash; 달러 기호</target>
        </trans-unit>
        <trans-unit id="bb0b9f77aa3a2b1b235948227a9bb6e95724f73c" translate="yes" xml:space="preserve">
          <source>The character &amp;Dagger;</source>
          <target state="translated">캐릭터 &amp;Dagger;</target>
        </trans-unit>
        <trans-unit id="97d065e0957f914068e24066c8bc53313cb9196a" translate="yes" xml:space="preserve">
          <source>The character &amp;Prime;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="697b0963155a10d5f080f157c0e1d9c9aacc9b21" translate="yes" xml:space="preserve">
          <source>The character &amp;amp; &amp;ndash; ampersand</source>
          <target state="translated">캐릭터 &amp;amp; &amp;ndash; 앰퍼샌드</target>
        </trans-unit>
        <trans-unit id="094872d2798a25e27adaff380803676c236be373" translate="yes" xml:space="preserve">
          <source>The character &amp;asymp;</source>
          <target state="translated">캐릭터 &amp;asymp;</target>
        </trans-unit>
        <trans-unit id="41d60c0526caa8463741bd966759bf19026cb739" translate="yes" xml:space="preserve">
          <source>The character &amp;bdquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="fff1f1e9d607e97e90b4bc028bb0cc7f10c48e01" translate="yes" xml:space="preserve">
          <source>The character &amp;bull;</source>
          <target state="translated">캐릭터 &amp;bull;</target>
        </trans-unit>
        <trans-unit id="143c3fcec665ebddc83c2753db67d88e2fbaf38a" translate="yes" xml:space="preserve">
          <source>The character &amp;cent;</source>
          <target state="translated">캐릭터 &amp;cent;</target>
        </trans-unit>
        <trans-unit id="ee171eaf967121aa215c85e62d2ec509ebb04257" translate="yes" xml:space="preserve">
          <source>The character &amp;copy;</source>
          <target state="translated">캐릭터 &amp;copy;</target>
        </trans-unit>
        <trans-unit id="314c38bf0716b200771c1a885fab69a9b65b99c6" translate="yes" xml:space="preserve">
          <source>The character &amp;dagger;</source>
          <target state="translated">캐릭터 &amp;dagger;</target>
        </trans-unit>
        <trans-unit id="6f9bd3084db43833f63880cca5d946309a97ca39" translate="yes" xml:space="preserve">
          <source>The character &amp;deg;</source>
          <target state="translated">문자 &amp;deg;</target>
        </trans-unit>
        <trans-unit id="0e423b28ce34d3cf18fda3a07cf0dfa515d8890e" translate="yes" xml:space="preserve">
          <source>The character &amp;euro;</source>
          <target state="translated">캐릭터 &amp;euro;</target>
        </trans-unit>
        <trans-unit id="b1449855c21d4fd06c0d5e74b5a2a7a14edf968a" translate="yes" xml:space="preserve">
          <source>The character &amp;frac12;</source>
          <target state="translated">캐릭터 &amp;frac12;</target>
        </trans-unit>
        <trans-unit id="1fa4a09afc8d4c4f53c306db471f300c4497957c" translate="yes" xml:space="preserve">
          <source>The character &amp;ge;</source>
          <target state="translated">문자 &amp;ge;</target>
        </trans-unit>
        <trans-unit id="3dfbeeaef1c98d8a22709ebef333428072939a42" translate="yes" xml:space="preserve">
          <source>The character &amp;gt; &amp;ndash; greater-than sign</source>
          <target state="translated">문자&amp;gt; &amp;ndash;보다 큼 부호</target>
        </trans-unit>
        <trans-unit id="6eb5e1e14a002081da7d716b380be22cde00b939" translate="yes" xml:space="preserve">
          <source>The character &amp;hellip;</source>
          <target state="translated">캐릭터 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a01873a887462b6593c2f5f42a550b38052e578a" translate="yes" xml:space="preserve">
          <source>The character &amp;laquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="e667dca130564a78a41110f6cbd1264a713d8dd2" translate="yes" xml:space="preserve">
          <source>The character &amp;ldquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="950de0de2afce4fa96ad4f62ca4dab286d3d82a8" translate="yes" xml:space="preserve">
          <source>The character &amp;le;</source>
          <target state="translated">문자 &amp;le;</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">캐릭터 '</target>
        </trans-unit>
        <trans-unit id="e9f2776cd83195ab61d81c705eb53d1d3649fd0e" translate="yes" xml:space="preserve">
          <source>The character &amp;lt; &amp;ndash; less-than sign</source>
          <target state="translated">문자 &amp;lt;&amp;ndash;보다 작은 부호</target>
        </trans-unit>
        <trans-unit id="7e613a75a280526a06a5c3a8cccd7722979dfc79" translate="yes" xml:space="preserve">
          <source>The character &amp;mdash;</source>
          <target state="translated">캐릭터 -</target>
        </trans-unit>
        <trans-unit id="257dd2718c3d554488c288a2e9f88456100a73ef" translate="yes" xml:space="preserve">
          <source>The character &amp;middot;</source>
          <target state="translated">캐릭터 &amp;middot;</target>
        </trans-unit>
        <trans-unit id="b00154ce5f2758f6abb5e4356e419ba3e2aed105" translate="yes" xml:space="preserve">
          <source>The character &amp;ndash;</source>
          <target state="translated">캐릭터 -</target>
        </trans-unit>
        <trans-unit id="aad571a2b53620d99840a4d55bce3f5907371d75" translate="yes" xml:space="preserve">
          <source>The character &amp;ne;</source>
          <target state="translated">문자 &amp;ne;</target>
        </trans-unit>
        <trans-unit id="a360453c2e244288bd242eeb7641ad601e593f75" translate="yes" xml:space="preserve">
          <source>The character &amp;para;</source>
          <target state="translated">캐릭터 &amp;para;</target>
        </trans-unit>
        <trans-unit id="1c97c4311adda721fa170a84ab8496cb5535afa3" translate="yes" xml:space="preserve">
          <source>The character &amp;plusmn;</source>
          <target state="translated">문자 &amp;plusmn;</target>
        </trans-unit>
        <trans-unit id="55144636deb97ada56b2d29a7bb655a9f22ea932" translate="yes" xml:space="preserve">
          <source>The character &amp;pound;</source>
          <target state="translated">캐릭터 &amp;pound;</target>
        </trans-unit>
        <trans-unit id="09c581b6f45120a7ecac89f6de96696cea52b01c" translate="yes" xml:space="preserve">
          <source>The character &amp;prime;</source>
          <target state="translated">캐릭터 '</target>
        </trans-unit>
        <trans-unit id="c49eacef46814486b9678b461b5fad7053d65453" translate="yes" xml:space="preserve">
          <source>The character &amp;raquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="b94a5614ad8379d659840f63e74a095d51d6a7c0" translate="yes" xml:space="preserve">
          <source>The character &amp;rdquo;</source>
          <target state="translated">캐릭터 &quot;</target>
        </trans-unit>
        <trans-unit id="be87e8e3080722678155d4e087ea1bf466788605" translate="yes" xml:space="preserve">
          <source>The character &amp;reg;</source>
          <target state="translated">캐릭터 &amp;reg;</target>
        </trans-unit>
        <trans-unit id="e6daa833ce04c765a61d1650a1e4e3d75924ca44" translate="yes" xml:space="preserve">
          <source>The character &amp;rsquo;</source>
          <target state="translated">캐릭터 '</target>
        </trans-unit>
        <trans-unit id="43ad6d82b90d71d375e73e1b9402ca5934e45166" translate="yes" xml:space="preserve">
          <source>The character &amp;sbquo;</source>
          <target state="translated">캐릭터 ,</target>
        </trans-unit>
        <trans-unit id="4139cb770ca9a15c26a42368989f1dc39e1910da" translate="yes" xml:space="preserve">
          <source>The character &amp;sect;</source>
          <target state="translated">캐릭터 &amp;sect;</target>
        </trans-unit>
        <trans-unit id="98e7fc24f032b2c1437d0f55811d67ee1de7b88e" translate="yes" xml:space="preserve">
          <source>The character &amp;times;</source>
          <target state="translated">캐릭터 &amp;times;</target>
        </trans-unit>
        <trans-unit id="f6467d07a9719c1073ddb29614f3d2a5ac72dfb3" translate="yes" xml:space="preserve">
          <source>The character &amp;trade;</source>
          <target state="translated">캐릭터 &amp;trade;</target>
        </trans-unit>
        <trans-unit id="1789ee1227acc918fbc63737b2058bf75be81287" translate="yes" xml:space="preserve">
          <source>The class can also declare &lt;strong&gt;secondary constructors&lt;/strong&gt;, which are prefixed with &lt;em&gt;constructor&lt;/em&gt;:</source>
          <target state="translated">클래스는 &lt;strong&gt;2 차 생성자를&lt;/strong&gt; 선언 할 수 있으며 , &lt;em&gt;생성자&lt;/em&gt; 앞에 접두사가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="bc78b13ff48b9fc50475495610ff41f558bf6256" translate="yes" xml:space="preserve">
          <source>The class declaration consists of the class name, the class header (specifying its type parameters, the primary constructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional; if the class has no body, curly braces can be omitted.</source>
          <target state="translated">클래스 선언은 클래스 이름, 클래스 헤더 (유형 매개 변수 지정, 기본 생성자 등) 및 중괄호로 묶인 클래스 본문으로 구성됩니다. 헤더와 본문은 모두 선택 사항입니다. 클래스에 본문이 없으면 중괄호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20fb66c6dd38ed7ad8f3ab7df8f07a3ccc7c3a1d" translate="yes" xml:space="preserve">
          <source>The class file with a kind not listed here is treated as a non-Kotlin file.</source>
          <target state="translated">여기에 나열되지 않은 종류의 클래스 파일은 코 틀린이 아닌 파일로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="8d923d6e9fe47217a8cbe28cd4bc0054618db9f2" translate="yes" xml:space="preserve">
          <source>The code above uses a &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;bound class reference&lt;/a&gt;, which is supported since Kotlin 1.1. You can also use the &lt;code&gt;javaClass&lt;/code&gt; extension property:</source>
          <target state="translated">위의 코드는 &lt;a href=&quot;reflection#bound-class-references-since-11&quot;&gt;바운드 클래스 참조를&lt;/a&gt; 사용하며 , Kotlin 1.1부터 지원됩니다. &lt;code&gt;javaClass&lt;/code&gt; 확장 등록 정보를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="732a1f0dd7bc7add2cc125d4681e9dd3eef05206" translate="yes" xml:space="preserve">
          <source>The code in object expressions can access variables from the enclosing scope.</source>
          <target state="translated">개체 식의 코드는 바깥 쪽 범위에서 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a037143482eba48d7a06126430f1e3e039ee172" translate="yes" xml:space="preserve">
          <source>The code in question is from the &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;simple&lt;/a&gt; example (comments removed for brevity)</source>
          <target state="translated">문제의 코드는 &lt;a href=&quot;https://curl.haxx.se/libcurl/c/simple.html&quot;&gt;간단한&lt;/a&gt; 예 에서 나온 것입니다.</target>
        </trans-unit>
        <trans-unit id="02b7f3091db5cc1f6df8785c890e5a0df1e43276" translate="yes" xml:space="preserve">
          <source>The code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 파일 의 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8051836ca1f9bfcf8f55044dce46370d2274f4e3" translate="yes" xml:space="preserve">
          <source>The code in the final &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">최종 &lt;code&gt;hello.kt&lt;/code&gt; 파일 의 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53a9cf6b4f40ef47e2031c236bc499f1385bb27e" translate="yes" xml:space="preserve">
          <source>The code is full of Objective-C attributes, which are intended to help the use of the framework from both Objective-C and Swift languages. &lt;code&gt;DemoClazz&lt;/code&gt;, &lt;code&gt;DemoInterface&lt;/code&gt;, and &lt;code&gt;DemoObject&lt;/code&gt; are created for &lt;code&gt;Clazz&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt; respectively. The &lt;code&gt;Interface&lt;/code&gt; is turned into &lt;code&gt;@protocol&lt;/code&gt;, both a &lt;code&gt;class&lt;/code&gt; and an &lt;code&gt;object&lt;/code&gt; are represented as &lt;code&gt;@interface&lt;/code&gt;. The &lt;code&gt;Demo&lt;/code&gt; prefix comes from the &lt;code&gt;-output&lt;/code&gt; parameter of the &lt;code&gt;kotlinc-native&lt;/code&gt; compiler and the framework name. We see here that the nullable return type &lt;code&gt;ULong?&lt;/code&gt; is turned into &lt;code&gt;DemoLong*&lt;/code&gt; in Objective-C.</source>
          <target state="translated">이 코드는 Objective-C 및 Swift 언어의 프레임 워크 사용을 돕기 위해 Objective-C 속성으로 가득합니다. &lt;code&gt;DemoClazz&lt;/code&gt; 는 , &lt;code&gt;DemoInterface&lt;/code&gt; 및 &lt;code&gt;DemoObject&lt;/code&gt; 가 만들어집니다 &lt;code&gt;Clazz&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt; 각각. &lt;code&gt;Interface&lt;/code&gt; 로 전환되는 &lt;code&gt;@protocol&lt;/code&gt; 둘 다를, &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;object&lt;/code&gt; 로 표현된다 &lt;code&gt;@interface&lt;/code&gt; . &lt;code&gt;Demo&lt;/code&gt; 접두사는에서 온다 &lt;code&gt;-output&lt;/code&gt; 의 매개 변수 &lt;code&gt;kotlinc-native&lt;/code&gt; 컴파일러와 프레임 워크의 이름입니다. 여기서는 nullable 반환 유형이 &lt;code&gt;ULong?&lt;/code&gt; Objective-C에서 &lt;code&gt;DemoLong*&lt;/code&gt; 으로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="bb3f232ccbe55c8a64749007e2a52df82753b753" translate="yes" xml:space="preserve">
          <source>The code is still written as if we were writing synchronous code, top-down, without the need of any special syntax, beyond the use of a function called &lt;code&gt;launch&lt;/code&gt; which essentially kicks-off the coroutine (covered in other tutorials).</source>
          <target state="translated">코드는 우리가 동기식 코드를 작성하는 것처럼 작성됩니다. 특별한 구문이 필요하지 않고 본질적으로 코 루틴을 &lt;code&gt;launch&lt;/code&gt; 하는 함수 (다른 튜토리얼에서 다루어 짐)를 사용하는 것 외에도 특별한 구문이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a467b8b9b7ee4d493e257af4cbf437bbbbde6f1c" translate="yes" xml:space="preserve">
          <source>The code or data pointed by the value of this variable.</source>
          <target state="translated">이 변수의 값이 가리키는 코드 또는 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="02020b547b7971154705decbe3b4487f3a320a20" translate="yes" xml:space="preserve">
          <source>The code reads as follows. We have the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure, which defines all the functions that Kotlin/Native and our library provides us. It uses nested anonymous structures heavily to mimic packages. The &lt;code&gt;libnative_&lt;/code&gt; prefix comes from the library name.</source>
          <target state="translated">코드는 다음과 같이 읽습니다. Kotlin / Native와 라이브러리가 제공하는 모든 함수를 정의 하는 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 구조가 있습니다. 패키지를 모방하기 위해 중첩 된 익명 구조를 많이 사용합니다. &lt;code&gt;libnative_&lt;/code&gt; 접두사는 라이브러리 이름에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="38d106af82f35f678ad2690b0baa41429ea7b73f" translate="yes" xml:space="preserve">
          <source>The code uses anonymous structure declarations. The code &lt;code&gt;struct { .. } foo&lt;/code&gt; declares a field in the outer struct of that anonymous structure type, the type with no name.</source>
          <target state="translated">이 코드는 익명 구조 선언을 사용합니다. 코드 &lt;code&gt;struct { .. } foo&lt;/code&gt; 는 익명 구조 유형의 외부 구조에서 이름이없는 유형의 필드를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="5a75d5c9d164b0af6fa981261ed056bb33166b99" translate="yes" xml:space="preserve">
          <source>The collection interfaces and related functions are located in the kotlin.collections package. Let's get an overview of its contents.</source>
          <target state="translated">수집 인터페이스 및 관련 기능은 kotlin.collections 패키지에 있습니다. 내용에 대한 개요를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="8eb00e1a99072f02da7c9734f0160d0f6d88090d" translate="yes" xml:space="preserve">
          <source>The command produces the &lt;code&gt;main.exe&lt;/code&gt; file, which we can run.</source>
          <target state="translated">이 명령은 우리가 실행할 수 있는 &lt;code&gt;main.exe&lt;/code&gt; 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c3c76c63d39731dfbcdc20b108a998ffa2cab356" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">모든 열거 형 클래스의 공통 기본 클래스입니다. 열거 형 클래스에 대한 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/enum-classes&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0aedfb3fef921fc9d29c01593b4d03896cda204" translate="yes" xml:space="preserve">
          <source>The common base class of all enum classes. See the &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information on enum classes.</source>
          <target state="translated">모든 열거 형 클래스의 공통 기본 클래스입니다. 열거 형 클래스에 대한 자세한 내용은 &lt;a href=&quot;../../../../../docs/reference/enum-classes&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="81167d80c8bd1494ae8b5c6e43cfe5f3d98e0f63" translate="yes" xml:space="preserve">
          <source>The common code is &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt;, where &lt;code&gt;platformName()&lt;/code&gt; is a function that is declared using the &lt;code&gt;expect&lt;/code&gt; keyword. The &lt;code&gt;actual&lt;/code&gt; implementation will be specific to the platform.</source>
          <target state="translated">공통 코드는 &lt;code&gt;&quot;Kotlin Rocks on ${platformName()}&quot;&lt;/code&gt; . 여기서 &lt;code&gt;platformName()&lt;/code&gt; 은 &lt;code&gt;expect&lt;/code&gt; 키워드를 사용하여 선언 된 함수입니다 . &lt;code&gt;actual&lt;/code&gt; 구현은 플랫폼에 특정한 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="26e2504fa6bfc493ea02066bb2b03d45d4bc4811" translate="yes" xml:space="preserve">
          <source>The common source sets cannot include Java sources.</source>
          <target state="translated">공통 소스 세트는 Java 소스를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95ec79a350a2b7276da32a4ea5b29db260f72d85" translate="yes" xml:space="preserve">
          <source>The common supertype for all callable references is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt;&lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;R&lt;/code&gt; is the return value type, which is the property type for properties, and the constructed type for constructors.</source>
          <target state="translated">호출 가능한 모든 참조의 공통 수퍼 타입은 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-callable/index&quot;&gt; &lt;code&gt;KCallable&amp;lt;out R&amp;gt;&lt;/code&gt; &lt;/a&gt; . 여기서 &lt;code&gt;R&lt;/code&gt; 은 리턴 값 유형입니다. 이는 특성의 특성 유형이고 생성자의 생성 된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="b490df5b9d3260a0f0b5037a5c6848fe5e1088c0" translate="yes" xml:space="preserve">
          <source>The companion object &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; is the default instance of &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt;.</source>
          <target state="translated">컴패니언 객체 &lt;a href=&quot;-default/index&quot;&gt;Random.Default&lt;/a&gt; 는 &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; 의 기본 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="d53a914136005ae6f435321f1dcd61b723a192c1" translate="yes" xml:space="preserve">
          <source>The companion object is a singleton, and its members can be accessed directly via the name of the containing class (although you can also insert the name of the companion object if you want to be explicit about accessing the companion object):</source>
          <target state="translated">컴패니언 객체는 싱글 톤이며 포함하는 클래스의 이름을 통해 멤버에 직접 액세스 할 수 있습니다 (컴패니언 객체에 액세스하는 것에 대해 명시 적으로 나타내려면 컴패니언 객체의 이름을 삽입 할 수도 있음).</target>
        </trans-unit>
        <trans-unit id="1e2216eb9ae725f1d6c56e917607f0c9488b74a1" translate="yes" xml:space="preserve">
          <source>The compiler automatically derives the following members from all properties declared in the primary constructor:</source>
          <target state="translated">컴파일러는 기본 생성자에 선언 된 모든 속성에서 다음 멤버를 자동으로 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6577ea37c1117c7a1d89eaf0755007d75c98ca87" translate="yes" xml:space="preserve">
          <source>The compiler can infer the function types for variables if there is enough information:</source>
          <target state="translated">충분한 정보가있는 경우 컴파일러는 변수의 함수 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c9d4888e9777e469bf8f8415875e00d70265bbb" translate="yes" xml:space="preserve">
          <source>The compiler ensures that every expected declaration has actual declarations in all platform modules that implement the corresponding common module, and reports an error if any actual declarations are missing. The IDE provides tools that help you create the missing actual declarations.</source>
          <target state="translated">컴파일러는 모든 예상 선언에 해당 공통 모듈을 구현하는 모든 플랫폼 모듈에서 실제 선언이 있는지 확인하고 실제 선언이 누락 된 경우 오류를보고합니다. IDE는 누락 된 실제 선언을 작성하는 데 도움이되는 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1bc9fa0ea96f6adbeae3b32244221538e36f7db6" translate="yes" xml:space="preserve">
          <source>The compiler generates an executable called &lt;code&gt;a.out&lt;/code&gt;. We need to run it to see in action the Kotlin code being executed from C library. On Linux, we'll need to include &lt;code&gt;.&lt;/code&gt; into the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; to let the application know to load the &lt;code&gt;libnative.so&lt;/code&gt; library from the current folder.</source>
          <target state="translated">컴파일러는 &lt;code&gt;a.out&lt;/code&gt; 이라는 실행 파일을 생성합니다 . C 라이브러리에서 실행되는 Kotlin 코드를 실제로 보려면이를 실행해야합니다. Linux에서는을 포함해야합니다 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 에 삽입하여 응용 프로그램 이 현재 폴더에서 &lt;code&gt;libnative.so&lt;/code&gt; 라이브러리 를로드하도록 알립니다 .</target>
        </trans-unit>
        <trans-unit id="9c32f1ebf038bdf8cbaba8702b89e98ca18e811a" translate="yes" xml:space="preserve">
          <source>The compiler is smart enough to know a cast to be safe if a negative check leads to a return:</source>
          <target state="translated">컴파일러는 음수 검사가 반환으로 이어질 경우 캐스트가 안전하다는 것을 알기에 충분히 똑똑합니다.</target>
        </trans-unit>
        <trans-unit id="6c760f17f753a0cd7195aa08e67eb2dc50e9752a" translate="yes" xml:space="preserve">
          <source>The compiler now inlines values of &lt;code&gt;const val&lt;/code&gt; properties into the locations where they are used.</source>
          <target state="translated">컴파일러는 &lt;code&gt;const val&lt;/code&gt; 속성의 값을 사용 된 위치에 인라인합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba2b709c858d08263f181dafb3aabf655fd192d" translate="yes" xml:space="preserve">
          <source>The compiler now provides an option to treat all warnings as errors. Use &lt;code&gt;-Werror&lt;/code&gt; on the command line, or the following Gradle snippet:</source>
          <target state="translated">컴파일러는 이제 모든 경고를 오류로 처리하는 옵션을 제공합니다. 명령 행에서 &lt;code&gt;-Werror&lt;/code&gt; 를 사용 하거나 다음 Gradle 스 니펫을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="71411ab1eb04e1e2a8b1556ddf262cc1922d7424" translate="yes" xml:space="preserve">
          <source>The compiler performs the following steps for resolution of an operator in the &lt;em&gt;postfix&lt;/em&gt; form, e.g. &lt;code&gt;a++&lt;/code&gt;:</source>
          <target state="translated">컴파일러는 &lt;em&gt;접미사&lt;/em&gt; 형식으로 연산자를 해결하기 위해 다음과 같은 단계를 수행합니다 ( 예 : &lt;code&gt;a++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ade270e63280116ba329a9222cd68e987a0137a2" translate="yes" xml:space="preserve">
          <source>The compiler produces a warning for the cast in the last line. The cast cannot be fully checked at runtime and provides no guarantee that the values in the map are &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 마지막 행에서 캐스트에 대한 경고를 생성합니다. 캐스트는 런타임에 완전히 확인할 수 없으며 맵의 값이 &lt;code&gt;Int&lt;/code&gt; 라는 보장을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c187f47b8c07f5d91c0556c45f360de519c42c3f" translate="yes" xml:space="preserve">
          <source>The compiler produces the code relevant for the target module system, for example, in case of CommonJS, it will import the declaration via the &lt;code&gt;require(...)&lt;/code&gt; function.</source>
          <target state="translated">컴파일러는 대상 모듈 시스템과 관련된 코드를 생성합니다. 예를 들어 CommonJS의 경우 &lt;code&gt;require(...)&lt;/code&gt; 함수 를 통해 선언을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8552578d258f1326cbba27a9248961d718afcda8" translate="yes" xml:space="preserve">
          <source>The compiler tracks the information about the check you performed, and allows the call to &lt;code&gt;length&lt;/code&gt; inside the &lt;em&gt;if&lt;/em&gt;. More complex conditions are supported as well:</source>
          <target state="translated">컴파일러는 수행 한 검사에 대한 정보를 추적 하고 &lt;em&gt;if&lt;/em&gt; 내에서 호출 &lt;code&gt;length&lt;/code&gt; 허용합니다 . 더 복잡한 조건도 지원됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9778744271ecf22c5df54071242110d274ebb382" translate="yes" xml:space="preserve">
          <source>The compiler will allow this function to be called as e.g. &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt;, but not as &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; or &lt;code&gt;test(null, null)&lt;/code&gt;. Calling &lt;code&gt;test(a, b)&lt;/code&gt; is only allowed if the compiler can prove that &lt;code&gt;a&lt;/code&gt; cannot possibly be null. Inside of &lt;code&gt;test&lt;/code&gt;, the compiler will not allow you to do anything with &lt;code&gt;b&lt;/code&gt; that would result in an exception if &lt;code&gt;b&lt;/code&gt; should happen to be null - so you can do &lt;code&gt;a.length&lt;/code&gt;, but not &lt;code&gt;b.length&lt;/code&gt;. However, once you're inside a conditional where you have checked that &lt;code&gt;b&lt;/code&gt; is not null, you can do it:</source>
          <target state="translated">컴파일러는이 함수를 &lt;code&gt;test(&quot;a&quot;, &quot;b&quot;)&lt;/code&gt; 또는 &lt;code&gt;test(&quot;a&quot;, null)&lt;/code&gt; 로 호출 할 수 있지만 &lt;code&gt;test(null, &quot;b&quot;)&lt;/code&gt; 또는 &lt;code&gt;test(null, null)&lt;/code&gt; 로 호출 할 수 없습니다 . 컴파일러가 &lt;code&gt;a&lt;/code&gt; 가 null 일 수 없음을 증명할 수있는 경우에만 &lt;code&gt;test(a, b)&lt;/code&gt; 호출 이 허용됩니다 . &lt;code&gt;test&lt;/code&gt; 내 에서 컴파일러는 &lt;code&gt;b&lt;/code&gt; 를 사용 하여 b 를 수행 할 수 없도록합니다. &lt;code&gt;b&lt;/code&gt; 가 null이어야 하는 경우 예외 가 발생하므로 &lt;code&gt;a.length&lt;/code&gt; 는 할 수 있지만 &lt;code&gt;b.length&lt;/code&gt; 는 할 수 없습니다 . 그러나 &lt;code&gt;b&lt;/code&gt; 가 null이 아닌지 확인한 조건부 안에 들어가면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2b29d9a02116dffd597657f45323e8d260b605c" translate="yes" xml:space="preserve">
          <source>The compiler will generate something like this (except that &lt;code&gt;start&lt;/code&gt; won't collide with any other identifiers with the same name):</source>
          <target state="translated">컴파일러는 다음과 같은 것을 생성합니다 ( &lt;code&gt;start&lt;/code&gt; 이 동일한 이름을 가진 다른 식별자와 충돌하지 않는 경우 제외 ).</target>
        </trans-unit>
        <trans-unit id="93c0badc9698bd83e21fa61741e490ba8801596d" translate="yes" xml:space="preserve">
          <source>The compiler will not let you perform checks that can't possibly succeed because the declared type of the variable is a class that is on an unrelated branch of the class hierarchy from the class you're checking against - if the declared type of &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;MotorVehicle&lt;/code&gt;, you can't check if &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;. If the right-hand side of &lt;code&gt;is&lt;/code&gt; is an interface, Kotlin will allow the type of the left-hand side to be any interface or open class, because it could be that some subclass thereof implements the interface.</source>
          <target state="translated">선언 된 변수 유형이 검사중인 클래스와 관련이없는 클래스 계층 구조의 분기에있는 클래스이므로 컴파일러는 성공할 수없는 검사를 수행 할 수 없습니다. 선언 된 &lt;code&gt;x&lt;/code&gt; 유형 이 &lt;code&gt;MotorVehicle&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;Person&lt;/code&gt; 인지 확인할 수 없습니다 . 오른쪽의 경우 &lt;code&gt;is&lt;/code&gt; 인터페이스는 그것이 몇몇 그 서브 클래스가 구현하는 인터페이스가 될 수 있기 때문에, 코 틀린는 좌측의 타입이 임의의 인터페이스 또는 개방 클래스 수 있도록한다.</target>
        </trans-unit>
        <trans-unit id="945c10a176528faf419fb001b8765fc6d7f48809" translate="yes" xml:space="preserve">
          <source>The complete list of options for the Gradle tasks is the following:</source>
          <target state="translated">Gradle 작업에 대한 전체 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbc4e4912fffd8b8c15a7f1685ee311f7de94af5" translate="yes" xml:space="preserve">
          <source>The consumer may only need to add the attribute to a single target where the ambiguity arises.</source>
          <target state="translated">소비자는 모호성이 발생하는 단일 대상에 속성을 추가하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa143f534ac2f4a54ee1e8593acf92219a64686" translate="yes" xml:space="preserve">
          <source>The contents of our &lt;code&gt;main.js&lt;/code&gt; would be:</source>
          <target state="translated">&lt;code&gt;main.js&lt;/code&gt; 의 내용 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccc1b0f9d51d769d3aac8a2e95f9b22ce641f370" translate="yes" xml:space="preserve">
          <source>The context of the coroutine that corresponds to this continuation.</source>
          <target state="translated">이 연속에 해당하는 코 루틴의 맥락.</target>
        </trans-unit>
        <trans-unit id="347bd2f03e4af765cba7e04d72d0cecc9c6bb8cc" translate="yes" xml:space="preserve">
          <source>The contract description must be at the beginning of a function and have at least one effect.</source>
          <target state="translated">계약 설명은 기능의 시작 부분에 있어야하며 최소한 하나의 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="4954ad3fce80d9310d9ce43541aaf17e0123a4ea" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter of a function-typed return type (the user will call the returned function with something that can consume any &lt;code&gt;Fruit&lt;/code&gt;, so it's okay to return a function that expects to receive something that can handle &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 타입의 리턴 타입 파라미터의 반 변형 타입 파라미터 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 를 소비 할 수있는 것으로 리턴 된 함수를 호출 하므로 &lt;code&gt;Apple&lt;/code&gt; 을 처리 할 수있는 무언가를받을 것으로 예상되는 함수를 반환해도됩니다 )</target>
        </trans-unit>
        <trans-unit id="fc9281a07f7c7bacfae7f8c712a66286fa4aa11c" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of a parameter type (the user is passing a consumer that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">매개 변수 유형의 contravariant 유형 매개 변수 (사용자는 처리 할 수있는 소비자 통과 &lt;code&gt;Fruit&lt;/code&gt; 하고는 주어질 것이다 &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3b2df0437d1139299375d04a6b3d749596fe34b3" translate="yes" xml:space="preserve">
          <source>The contravariant type parameter of the return type of a function-typed parameter (the user is passing a function that will return a consumer of any &lt;code&gt;Fruit&lt;/code&gt;, and the returned consumer will be given &lt;code&gt;Apple&lt;/code&gt; instances)</source>
          <target state="translated">함수 유형 매개 변수의 반환 유형에 대한 반 변형 유형 매개 변수 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 의 소비자를 반환하는 함수를 전달하고 반환 된 소비자 에게는 &lt;code&gt;Apple&lt;/code&gt; 인스턴스 가 제공됨 )</target>
        </trans-unit>
        <trans-unit id="3ed87fa7f81c4d406e21bd5206fb7068af42bc61" translate="yes" xml:space="preserve">
          <source>The convention that is followed is that each library gets its own definition file, usually named the same as the library. For more information on all the options available to &lt;code&gt;cinterop&lt;/code&gt;, see &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;the Interop documentation&lt;/a&gt;</source>
          <target state="translated">따르는 규칙은 각 라이브러리가 일반적으로 라이브러리와 동일한 이름을 가진 자체 정의 파일을 얻는다는 것입니다. &lt;code&gt;cinterop&lt;/code&gt; 에 사용 가능한 모든 옵션에 대한 자세한 내용 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;은 Interop 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c72d89d38289079cb805c34b2308d4dfa8c2fd72" translate="yes" xml:space="preserve">
          <source>The coroutine context includes a &lt;em&gt;coroutine dispatcher&lt;/em&gt; (see &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html&quot;&gt;CoroutineDispatcher&lt;/a&gt;) that determines what thread or threads the corresponding coroutine uses for its execution. The coroutine dispatcher can confine coroutine execution to a specific thread, dispatch it to a thread pool, or let it run unconfined.</source>
          <target state="translated">코 루틴 컨텍스트에는 해당 코 루틴이 실행을 위해 사용하는 스레드를 결정 하는 &lt;em&gt;코 루틴 디스패처&lt;/em&gt; ( &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html&quot;&gt;CoroutineDispatcher&lt;/a&gt; 참조 )가 포함됩니다. 코 루틴 디스패처는 코 루틴 실행을 특정 스레드로 제한하거나 스레드 풀로 디스패치하거나 제한없이 실행되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4ce8b1f45a5d6806ad09e59cc85adf7dc80106f" translate="yes" xml:space="preserve">
          <source>The coroutine context is a set of various elements. The main elements are the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the coroutine, which we've seen before, and its dispatcher, which is covered in this section.</source>
          <target state="translated">코 루틴 문맥은 다양한 요소의 집합입니다. 주요 요소는 이전에 본 코 루틴 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업&lt;/a&gt; 과이 섹션에서 다루는 디스패처입니다.</target>
        </trans-unit>
        <trans-unit id="09d67675b7aec2c1bf9665203e1b50714b4ffefe" translate="yes" xml:space="preserve">
          <source>The coroutine is started directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the completion's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established.</source>
          <target state="translated">코 루틴은 완료의 &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext에&lt;/a&gt; 존재할 수있는 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 를 거치지 않고 호출자의 스레드에서 직접 시작됩니다 . 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="5075509aaa121a034050446e85498c3f79064890" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context, and can be retrieved from it using the &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">코 루틴의 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; 은 컨텍스트의 일부이며 &lt;code&gt;coroutineContext[Job]&lt;/code&gt; 표현식을 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3db3fa62931fade33326b38aff7867fe578bfdd9" translate="yes" xml:space="preserve">
          <source>The coroutine's &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; is part of its context. The coroutine can retrieve it from its own context using &lt;code&gt;coroutineContext[Job]&lt;/code&gt; expression:</source>
          <target state="translated">코 루틴의 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;직업&lt;/a&gt; 은 그 맥락의 일부입니다. 코 루틴은 &lt;code&gt;coroutineContext[Job]&lt;/code&gt; 표현식을 사용하여 자체 컨텍스트에서이를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5769f42ad3e1d523865b402b5e67bd28e7b20bad" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;sourceSets&lt;/code&gt; property should be updated if not using the default convention:</source>
          <target state="translated">기본 규칙을 사용하지 않는 경우 해당 &lt;code&gt;sourceSets&lt;/code&gt; 속성을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1d461218111d234968b7db694b9b764401c60b6" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;em&gt;sourceSets&lt;/em&gt; property should be updated if not using the default convention:</source>
          <target state="translated">기본 규칙을 사용하지 않는 경우 해당 &lt;em&gt;sourceSets&lt;/em&gt; 특성을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="16c7a1a50f1d32fc204564f81e6d0304f7356ed7" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a read-only property type (the user is expecting a producer of &lt;code&gt;Fruit&lt;/code&gt;, and gets a producer of &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">읽기 전용 속성 유형의 공변량 유형 매개 변수 (사용자는 &lt;code&gt;Fruit&lt;/code&gt; 의 생산자를 기대하고 &lt;code&gt;Apple&lt;/code&gt; 의 생산자를 얻습니다 )</target>
        </trans-unit>
        <trans-unit id="7d1a94c8808bc3894d49e0ec4259312cbb359362" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of a return type (the user is expecting that the returned value will produce a &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">리턴 유형의 공변량 유형 매개 변수 (사용자는 리턴 된 값이 &lt;code&gt;Fruit&lt;/code&gt; 을 생성 할 것으로 예상 하므로 실제로 &lt;code&gt;Apple&lt;/code&gt; 을 생성해도 괜찮습니다 )</target>
        </trans-unit>
        <trans-unit id="ec6f1c24b0cd8b11d61e4f25576ab198b6bece55" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt; producer, and it will be given an &lt;code&gt;Apple&lt;/code&gt; producer)</source>
          <target state="translated">함수 형식의 매개 변수의 매개 변수 형식의 공변 형식 매개 변수 (사용자는 처리 할 수있는 기능을 전달하고 &lt;code&gt;Fruit&lt;/code&gt; 생산을하고는 주어질 것이다 &lt;code&gt;Apple&lt;/code&gt; 프로듀서)</target>
        </trans-unit>
        <trans-unit id="bc2c5c3395341afe0bbd48554537d9a1ac25a9db" translate="yes" xml:space="preserve">
          <source>The covariant type parameter of the return type of a function-typed return type (the user expects the returned function to return something that produces &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really produces &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 형식의 반환 형식의 반환 형식의 공변 형식 매개 변수 (사용자가 반환 된 함수가 생산 뭔가 복귀 할 것으로 예상 &lt;code&gt;Fruit&lt;/code&gt; 정말 생산하는 경우 괜찮아, 그래서 &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a39f5e4ad2c9626d5a5f458b4068b5771d3c11f9" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;StableRef&lt;/code&gt; should eventually be manually disposed using the &lt;code&gt;.dispose()&lt;/code&gt; method to prevent memory leaks:</source>
          <target state="translated">생성 된 &lt;code&gt;StableRef&lt;/code&gt; 는 결국 메모리 누수를 방지하기 위해 &lt;code&gt;.dispose()&lt;/code&gt; 메소드를 사용하여 수동으로 폐기해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7dc376ddde1c64329f76a2fdf0f77fd2f42853b6" translate="yes" xml:space="preserve">
          <source>The created iOS application is ready to run on the iOS emulator or on the iOS device. The device run may require an Apple developer account and to issue a developer certificate. Xcode does its best to guide us through the process.</source>
          <target state="translated">작성된 iOS 애플리케이션은 iOS 에뮬레이터 또는 iOS 디바이스에서 실행할 수 있습니다. 장치를 실행하려면 Apple 개발자 계정이 필요하고 개발자 인증서를 발급해야합니다. Xcode는 프로세스를 안내하기 위해 최선을 다합니다.</target>
        </trans-unit>
        <trans-unit id="e20d095cd0f1efef77b1627ffafe7b1dfa3d28bf" translate="yes" xml:space="preserve">
          <source>The curly braces around a body can be omitted if the body is a oneliner. This is discouraged unless the body goes on the same line as the condition, because it makes it easy to make this mistake, especially when one is used to Python:</source>
          <target state="translated">바디가 원 라이너 인 경우 바디 주변의 중괄호는 생략 할 수 있습니다. 신체가 조건과 같은 줄에 있지 않으면, 특히 파이썬에 익숙 할 때이 실수를 쉽게 할 수 있기 때문에 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcfce21884a60ba71ce3d59d9e2af53e74e2e10c" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.3.41, published on July 4, 2019.</source>
          <target state="translated">현재 출시 된 버전은 1.3.41이며 2019 년 7 월 4 일에 게시되었습니다.</target>
        </trans-unit>
        <trans-unit id="b5744a90420458acc57f96347ae2c3cc6f2d50b3" translate="yes" xml:space="preserve">
          <source>The currently released version is 1.4.10, published on September 10, 2020.</source>
          <target state="translated">현재 출시 된 버전은 2020 년 9 월 10 일에 게시 된 1.4.10입니다.</target>
        </trans-unit>
        <trans-unit id="99a5ae4aba1310a5ec2c1c1ea8e6bbd89807b2b1" translate="yes" xml:space="preserve">
          <source>The declaration of the classifier used in this type. For example, in the type &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; the classifier would be the &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;KClass&lt;/a&gt; instance for &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt;.</source>
          <target state="translated">이 유형에 사용 된 분류기의 선언. 예를 들어, &lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt; 유형 에서 분류 &lt;a href=&quot;../-k-class/index#kotlin.reflect.KClass&quot;&gt;자는 &lt;/a&gt;&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 의 KClass 인스턴스가 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4cb77989b70ae7af02cc584cc3eb602ad306980" translate="yes" xml:space="preserve">
          <source>The declarations in the new artifacts are visible under the same package names from the Kotlin point of view, but have different package names for Java. Therefore, switching to the new artifacts will not require any changes to your source code.</source>
          <target state="translated">새로운 아티팩트의 선언은 Kotlin 관점에서 동일한 패키지 이름으로 볼 수 있지만 Java의 패키지 이름은 다릅니다. 따라서 새 아티팩트로 전환하면 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="38a82a6bd4d8bda70773fac15ae91a2110030d1c" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;encoding&lt;/a&gt; is UTF-8, but you can specify it if you need something else:</source>
          <target state="translated">기본 &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;인코딩&lt;/a&gt; 은 UTF-8이지만 다른 것이 필요한 경우 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7643db7f540eca7261e951018ad1bc000680e9fc" translate="yes" xml:space="preserve">
          <source>The default artifact IDs follow the pattern &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt;, for example &lt;code&gt;sample-lib-nodejs&lt;/code&gt; for a target named &lt;code&gt;nodeJs&lt;/code&gt; in a project &lt;code&gt;sample-lib&lt;/code&gt;.</source>
          <target state="translated">기본 아티팩트 ID는 &lt;code&gt;&amp;lt;projectName&amp;gt;-&amp;lt;targetNameToLowerCase&amp;gt;&lt;/code&gt; 패턴을 따릅니다 ( 예 : 프로젝트 &lt;code&gt;sample-lib&lt;/code&gt; 에서 &lt;code&gt;nodeJs&lt;/code&gt; 라는 대상의 &lt;code&gt;sample-lib-nodejs&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="960beb3d459f57914f0b08a89c8e7a0ae2d213a2" translate="yes" xml:space="preserve">
          <source>The default dispatcher that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses a shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">코 루틴이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 시작될 때 사용되는 기본 디스패처는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; 로 표시되며 스레드의 공유 백그라운드 풀을 사용하므로 &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; 는 &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; 와 동일한 디스패처를 사용합니다 . .} .</target>
        </trans-unit>
        <trans-unit id="b76c41789282ed3ab00f219e4dbda9192589571a" translate="yes" xml:space="preserve">
          <source>The default dispatcher, that is used when coroutines are launched in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, is represented by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; and uses shared background pool of threads, so &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; uses the same dispatcher as &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt;.</source>
          <target state="translated">코 루틴이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 시작될 때 사용되는 기본 디스패처는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; 로 표시되며 공유 백그라운드 스레드 풀을 사용하므로 &lt;code&gt;launch(Dispatchers.Default) { ... }&lt;/code&gt; 는 &lt;code&gt;GlobalScope.launch { ... }&lt;/code&gt; 와 동일한 디스패처를 사용합니다 . ..} .</target>
        </trans-unit>
        <trans-unit id="034812e12bafb58c2506d45936895dac0de7b559" translate="yes" xml:space="preserve">
          <source>The default implementation is available for Java classes implementing the interface.</source>
          <target state="translated">기본 구현은 인터페이스를 구현하는 Java 클래스에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eae7fdc4a8ba33e2f9213a2722bb2903c080bbc0" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt;&lt;code&gt;LinkedHashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion when iterating the map. In turn, an alternative implementation &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/a&gt; &amp;ndash; says nothing about the elements order.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-map/index&quot;&gt; &lt;code&gt;LinkedHashMap&lt;/code&gt; &lt;/a&gt; &amp;ndash; 의 기본 구현은 맵을 반복 할 때 요소 삽입 순서를 유지합니다. 또한 대체 구현 인 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-hash-map/index&quot;&gt; &lt;code&gt;HashMap&lt;/code&gt; &lt;/a&gt; 은 요소 순서에 대해 아무 것도 말하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d4f4ecafdd233f07d5e3f6afd06222be0312077" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt;&lt;code&gt;LinkedHashSet&lt;/code&gt;&lt;/a&gt; &amp;ndash; preserves the order of elements insertion. Hence, the functions that rely on the order, such as &lt;code&gt;first()&lt;/code&gt; or &lt;code&gt;last()&lt;/code&gt;, return predictable results on such sets.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; &amp;ndash; &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-linked-hash-set/index&quot;&gt; &lt;code&gt;LinkedHashSet&lt;/code&gt; &lt;/a&gt; &amp;ndash; 의 기본 구현 은 요소 삽입 순서를 유지합니다. 따라서 순서에 의존하는 함수 &lt;code&gt;first()&lt;/code&gt; 예 : first () 또는 &lt;code&gt;last()&lt;/code&gt; 는 그러한 세트에서 예측 가능한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bed0e18ec00404266f1579a08902984894034905" translate="yes" xml:space="preserve">
          <source>The default nullability is used when a type itself is not annotated by a nullability annotation, and the default is determined by the innermost enclosing element annotated with a type qualifier default annotation with the &lt;code&gt;ElementType&lt;/code&gt; matching the type usage.</source>
          <target state="translated">기본 null 허용 여부는 형식 자체에 Null 허용 주석이 표시되지 않은 경우에 사용되며 기본값은 형식 사용법 과 일치하는 &lt;code&gt;ElementType&lt;/code&gt; 을 가진 형식 한정자 기본 주석으로 주석이 달린 가장 안쪽의 둘러싸는 요소에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d69906046e2ddf59f421f52ac090513e9b9f2a3" translate="yes" xml:space="preserve">
          <source>The default random number generator.</source>
          <target state="translated">기본 난수 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="f9ef35e4ea1c850fbe5f46bb280445cc0cd754fc" translate="yes" xml:space="preserve">
          <source>The default source set &lt;code&gt;commonMain&lt;/code&gt; is added to each production (application or library) variant's compilation. The &lt;code&gt;commonTest&lt;/code&gt; source set is, similarly, added to the compilations of unit test and instrumented test variants.</source>
          <target state="translated">기본 소스 세트 &lt;code&gt;commonMain&lt;/code&gt; 이 각 프로덕션 (애플리케이션 또는 라이브러리) 변형의 컴파일에 추가됩니다. &lt;code&gt;commonTest&lt;/code&gt; 소스 세트는 유사하게, 부 검사의 컴파일에 첨가하고, 계측 시험 변종.</target>
        </trans-unit>
        <trans-unit id="c561b55e89597682ebf08bcc014c20773fedb83e" translate="yes" xml:space="preserve">
          <source>The default upper bound (if none specified) is &lt;code&gt;Any?&lt;/code&gt;. Only one upper bound can be specified inside the angle brackets. If the same type parameter needs more than one upper bound, we need a separate &lt;strong&gt;where&lt;/strong&gt;-clause:</source>
          <target state="translated">기본 상한 (지정되지 않은 경우)은 &lt;code&gt;Any?&lt;/code&gt; . 꺾쇠 괄호 안에 하나의 상한 만 지정할 수 있습니다. 동일한 유형 매개 변수에 둘 이상의 상한이 필요한 경우 별도의 &lt;strong&gt;where&lt;/strong&gt; -clause 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7b5f3fac0dd293e61c74032e957e6e608fec3b05" translate="yes" xml:space="preserve">
          <source>The default value is provided at the declaration of this parameter.</source>
          <target state="translated">이 값을 선언하면 기본값이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="44653ab72c57ae2dec40031a1386b4afc98b3166" translate="yes" xml:space="preserve">
          <source>The definitions part shows how Kotlin primitive types map into C primitive types. We discussed reverse mapping in the &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt; tutorial.</source>
          <target state="translated">정의 부분은 Kotlin 기본 유형이 C 기본 유형으로 맵핑되는 방법을 보여줍니다. &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C&lt;/a&gt; 자습서의 기본 데이터 형식 매핑에서 리버스 매핑에 대해 설명했습니다 .</target>
        </trans-unit>
        <trans-unit id="7879370b21d5da1f44f128551f264e026a0fb9ed" translate="yes" xml:space="preserve">
          <source>The delegate class may implement one of the interfaces &lt;code&gt;ReadOnlyProperty&lt;/code&gt; and &lt;code&gt;ReadWriteProperty&lt;/code&gt; containing the required &lt;code&gt;operator&lt;/code&gt; methods. These interfaces are declared in the Kotlin standard library:</source>
          <target state="translated">델리게이트 클래스는 필수 &lt;code&gt;operator&lt;/code&gt; 메소드를 포함하는 &lt;code&gt;ReadOnlyProperty&lt;/code&gt; 및 &lt;code&gt;ReadWriteProperty&lt;/code&gt; 인터페이스 중 하나를 구현할 수 있습니다 . 이러한 인터페이스는 Kotlin 표준 라이브러리에 선언되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="42bebb3adac2ab3e00fbad0af368d0931c57bd77" translate="yes" xml:space="preserve">
          <source>The delegated property can be used like this to declare a property in &lt;code&gt;Person&lt;/code&gt; - note the use of &lt;code&gt;by&lt;/code&gt; instead of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">위임 된 속성은 &lt;code&gt;Person&lt;/code&gt; 에서 속성을 선언하기 위해 이와 같이 사용될 수 있습니다 . &lt;code&gt;=&lt;/code&gt; 대신에 &lt;code&gt;by&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="898cc738a761dcd3be73120e07ea5697ac2725df" translate="yes" xml:space="preserve">
          <source>The dependencies configuration has been changed; dependencies are now specified separately for each source root.</source>
          <target state="translated">종속성 구성이 변경되었습니다. 종속성은 이제 각 소스 루트에 대해 별도로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="973f16e5337bff9eb9481252b3daeac2f25a5f4f" translate="yes" xml:space="preserve">
          <source>The dependencies declared in this way are added in the podspec file and downloaded during the execution of &lt;code&gt;pod install&lt;/code&gt;.</source>
          <target state="translated">이러한 방식으로 선언 된 종속성은 podspec 파일에 추가되고 &lt;code&gt;pod install&lt;/code&gt; 실행 중에 다운로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e289438644482986fe5eb08aaf9b0616f49cac1" translate="yes" xml:space="preserve">
          <source>The described mechanism for marking and using experimental APIs is itself experimental in Kotlin 1.3. This means that in future releases it may be changed in ways that make it incompatible. To make the users of annotations &lt;code&gt;@Experimental&lt;/code&gt; and &lt;code&gt;UseExperimental&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="translated">실험적 API를 표시하고 사용하기위한 설명 된 메커니즘은 Kotlin 1.3에서 실험적입니다. 이는 향후 릴리스에서 호환되지 않는 방식으로 변경 될 수 있음을 의미합니다. &lt;code&gt;@Experimental&lt;/code&gt; 및 &lt;code&gt;UseExperimental&lt;/code&gt; 주석 사용자가 실험 상태를 인식 하도록하기 위해 컴파일러는 다음 주석으로 코드를 컴파일 할 때 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="cf37d613f63880e424569836a2ab82c0f6bbbfbf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is experimental, meaning that this feature is &lt;em&gt;moving fast&lt;/em&gt; and no compatibility guarantees are given. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature is experimental.</source>
          <target state="translated">인라인 클래스의 디자인은 실험적이며,이 기능은 &lt;em&gt;빠르게 움직이고&lt;/em&gt; 호환성이 보장되지 않습니다. Kotlin 1.3 이상에서 인라인 클래스를 사용하는 경우이 기능이 실험 중임을 나타내는 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="530e7472ee58bdd7a4958120705547c1d20c1ddf" translate="yes" xml:space="preserve">
          <source>The design of inline classes is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;, meaning that no compatibility guarantees are given for future versions. When using inline classes in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable.</source>
          <target state="translated">인라인 클래스의 디자인은 &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt; 이므로 향후 버전에 대한 호환성 보장이 제공되지 않습니다. Kotlin 1.3 이상에서 인라인 클래스를 사용하는 경우이 기능이 안정적으로 출시되지 않았 음을 나타내는 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="b65859994bf9d4a7fb5d934baaf88e39c3f04558" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is experimental, meaning that this feature is moving fast and no compatibility guarantees are given. When using unsigned arithmetics in Kotlin 1.3+, warning will be reported, indicating that this feature is experimental. To remove warning, you have to opt-in for experimental usage of unsigned types.</source>
          <target state="translated">서명되지 않은 유형의 디자인은 실험적이므로이 기능은 빠르게 움직이고 호환성 보장이 제공되지 않습니다. Kotlin 1.3+에서 부호없는 산술을 사용하는 경우이 기능이 실험 중임을 나타내는 경고가보고됩니다. 경고를 제거하려면 서명되지 않은 유형의 실험적 사용을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2b28866ac37f05ef8569c7d67a02f97e240cc06" translate="yes" xml:space="preserve">
          <source>The design of unsigned types is in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;, meaning that its compatibility is best-effort only and not guaranteed. When using unsigned arithmetics in Kotlin 1.3+, a warning will be reported, indicating that this feature has not been released as stable. To remove the warning, you have to opt in for usage of unsigned types.</source>
          <target state="translated">서명되지 않은 유형의 디자인은 &lt;a href=&quot;evolution/components-stability&quot;&gt;베타 버전&lt;/a&gt; 이므로 호환성이 최선일 뿐이며 보장되지는 않습니다. Kotlin 1.3 이상에서 서명되지 않은 산술을 사용하는 경우이 기능이 안정적으로 출시되지 않았 음을 나타내는 경고가보고됩니다. 경고를 제거하려면 서명되지 않은 유형의 사용을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0d2b5a6b59247ce3c2ac4eba75f43c56acf4c3d" translate="yes" xml:space="preserve">
          <source>The difference between the two functions is that &lt;code&gt;fold()&lt;/code&gt; takes an initial value and uses it as the accumulated value on the first step, whereas the first step of &lt;code&gt;reduce()&lt;/code&gt; uses the first and the second elements as operation arguments on the first step.</source>
          <target state="translated">두 함수의 차이점은 &lt;code&gt;fold()&lt;/code&gt; 는 초기 값을 가져 와서 첫 번째 단계에서 누적 된 값으로 사용하는 반면, &lt;code&gt;reduce()&lt;/code&gt; 의 첫 번째 단계 는 첫 번째 및 두 번째 요소를 첫 번째 단계에서 조작 인수로 사용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16d1b90dc650643e776a4004ab589d677449c331" translate="yes" xml:space="preserve">
          <source>The directories containing the source files to compile</source>
          <target state="translated">컴파일 할 소스 파일이 포함 된 디렉토리</target>
        </trans-unit>
        <trans-unit id="f28bb53a04db0fb8fa17ba4aa3c143de9bce62e3" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM</source>
          <target state="translated">JVM을 대상으로하는 코드에서 동적 유형이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52d4bb2170c55ab0a1a89bfce15477357b84c2db" translate="yes" xml:space="preserve">
          <source>The dynamic type is not supported in code targeting the JVM.</source>
          <target state="translated">JVM을 대상으로하는 코드에서는 동적 유형이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1e94b86df57391ab40db234f4362544f610c993" translate="yes" xml:space="preserve">
          <source>The easiest way to create a new application targeting JavaScript with Maven is to allow IntelliJ IDEA to configure the Maven project for us. Simply create a new Maven project in IntelliJ IDEA and once the project is created, add a new folder to host the Kotlin source code, removing the default Java one. The project should end up with the following structure</source>
          <target state="translated">Maven으로 JavaScript를 대상으로하는 새로운 응용 프로그램을 만드는 가장 쉬운 방법은 IntelliJ IDEA가 Maven 프로젝트를 구성 할 수 있도록하는 것입니다. IntelliJ IDEA에서 새 Maven 프로젝트를 작성하고 프로젝트가 작성되면 Kotlin 소스 코드를 호스팅 할 새 폴더를 추가하여 기본 Java 코드를 제거하십시오. 프로젝트는 다음과 같은 구조로 끝나야합니다</target>
        </trans-unit>
        <trans-unit id="171e3cf4fb89f709d12d970ce788f0d3a1e1b68e" translate="yes" xml:space="preserve">
          <source>The effect of computing the expression is:</source>
          <target state="translated">식 계산의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff0a9ac30d7664a4e4282016eea87cab13969066" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;append-element#kotlin.dom%24appendElement(org.w3c.dom.Element,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">요소는 지정된 &lt;a href=&quot;append-element#kotlin.dom%24appendElement(org.w3c.dom.Element,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; 함수로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="d9a189a8bbd800a60d20579c11365537800d1c5b" translate="yes" xml:space="preserve">
          <source>The element is initialized with the specified &lt;a href=&quot;create-element#kotlin.dom%24createElement(org.w3c.dom.Document,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">요소는 지정된 &lt;a href=&quot;create-element#kotlin.dom%24createElement(org.w3c.dom.Document,%20kotlin.String,%20kotlin.Function1((org.w3c.dom.Element,%20kotlin.Unit)))/init&quot;&gt;init&lt;/a&gt; 함수로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a6537bfaccb8cddd8c481ef1fab76499f34a316" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">요소는 지정된 &lt;a href=&quot;append-element#kotlin.dom%24appendElement%28org.w3c.dom.Element%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;초기화&lt;/a&gt; 기능으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="3c970d5af5c7c3d91e3eb72687259d2ce93c168c" translate="yes" xml:space="preserve">
          <source>The element is initialized with the speicifed &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;init&lt;/a&gt; function.</source>
          <target state="translated">요소는 지정된 &lt;a href=&quot;create-element#kotlin.dom%24createElement%28org.w3c.dom.Document%2C+kotlin.String%2C+kotlin.Function1%28%28org.w3c.dom.Element%2C+kotlin.Unit%29%29%29%2Finit&quot;&gt;초기화&lt;/a&gt; 기능으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="4479436b9b0ce8aa0beac7c43130aa60627f658c" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">요소는 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 컬렉션에 나타나는 순서대로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="544e4fbca97528fef2325c3afe55cace763538a4" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">요소는 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;요소&lt;/a&gt; 컬렉션에 나타나는 순서대로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="23022bf4214f0845c5b1a370815de8e19dc6515a" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">요소는 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 컬렉션에 나타나는 순서대로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="82095a92897d87f6ce531db50ce0bc12db68723f" translate="yes" xml:space="preserve">
          <source>The elements are appended in the order they appear in the &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; collection.</source>
          <target state="translated">요소는 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;요소&lt;/a&gt; 컬렉션에 나타나는 순서대로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="daa9aa5d9ebd8b42b1bcdf3100554fd92ca03d09" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">요소는 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; 함수 와 동일한 지 비교 됩니다. 부동 소수점 숫자의 경우 &lt;code&gt;NaN&lt;/code&gt; 이 자체와 같고 &lt;code&gt;-0.0&lt;/code&gt; 이 &lt;code&gt;0.0&lt;/code&gt; 과 같지 않음 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="aad20466e5a76028e3397e50e8845f24663b34cf" translate="yes" xml:space="preserve">
          <source>The elements are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">요소는 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;같음&lt;/a&gt; 함수를 사용하여 같은지 비교 됩니다. 부동 소수점 숫자의 경우 &lt;code&gt;NaN&lt;/code&gt; 이 자신과 같고 &lt;code&gt;-0.0&lt;/code&gt; 이 &lt;code&gt;0.0&lt;/code&gt; 과 같지 않음 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d4f10d9d6ff53cf3cb02a56dcf3900dc9233c7" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source array.</source>
          <target state="translated">결과 목록의 요소는 소스 배열의 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4758b35da216c6ed38b8e3b01e9232e835ffdf62" translate="yes" xml:space="preserve">
          <source>The elements in the resulting list are in the same order as they were in the source collection.</source>
          <target state="translated">결과 목록의 요소는 소스 콜렉션에있는 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="925245d7080579f68b367dc0eefbb0c6350a2c59" translate="yes" xml:space="preserve">
          <source>The elements in the resulting sequence are in the same order as they were in the source sequence.</source>
          <target state="translated">결과 시퀀스의 요소는 소스 시퀀스와 동일한 순서입니다.</target>
        </trans-unit>
        <trans-unit id="62f13d9c86bbfcad668fdecca43def6919a28064" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 요소는 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals%28kotlin.Any%29&quot;&gt;equals&lt;/a&gt; 함수 와 동일한 지 비교 됩니다. 부동 소수점 숫자의 경우 &lt;code&gt;NaN&lt;/code&gt; 이 자체와 같고 &lt;code&gt;-0.0&lt;/code&gt; 이 &lt;code&gt;0.0&lt;/code&gt; 과 같지 않음 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="410a7c8a1416b4dffdf86f7b2fb29d1be03e7884" translate="yes" xml:space="preserve">
          <source>The elements of other types are compared for equality with the &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; function. For floating point numbers it means that &lt;code&gt;NaN&lt;/code&gt; is equal to itself and &lt;code&gt;-0.0&lt;/code&gt; is not equal to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">다른 유형의 요소는 &lt;a href=&quot;../kotlin/-any/equals#kotlin.Any%24equals(kotlin.Any?)&quot;&gt;equals&lt;/a&gt; 함수를 사용하여 동일한 지 비교 됩니다. 부동 소수점 숫자의 경우 &lt;code&gt;NaN&lt;/code&gt; 이 자신과 같고 &lt;code&gt;-0.0&lt;/code&gt; 이 &lt;code&gt;0.0&lt;/code&gt; 과 같지 않음 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="bb685b2c6e5acf402eac7fe67da99cd138309729" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스가 제거 된 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="11df9d3925f0418a6e38aed874d509daf4025048" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange%28kotlin.String%2C+kotlin.ranges.IntRange%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스가 제거 된 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="67fcbb6ac3e2a5c62cd2e430c9777a067763d923" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.CharSequence,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.CharSequence,%20kotlin.ranges.IntRange)/range&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스 는 제거 된 부분에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7aa81f1705dd0f516aa78c926061ad0c0bdec167" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.String,%20kotlin.ranges.IntRange)/range&quot;&gt;range&lt;/a&gt; is included in the removed part.</source>
          <target state="translated">&lt;a href=&quot;remove-range#kotlin.text%24removeRange(kotlin.String,%20kotlin.ranges.IntRange)/range&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스 는 제거 된 부분에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="88ef0ef1c8adfc13f79b17d279153b4deca66c2a" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.CharSequence%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 최종 지수는 교체 할 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="110043ac6542bd5ea84cfa58a2ba979b14417af8" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange%28kotlin.String%2C+kotlin.ranges.IntRange%2C+kotlin.CharSequence%29%2Frange&quot;&gt;범위&lt;/a&gt; 의 최종 지수는 교체 할 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="265808d7f064c65b3e4484a504c21278573abe5f" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.CharSequence,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.CharSequence,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스는 교체 할 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2757b02f416ac5f1c57fe37f28ebb5f19a2beb88" translate="yes" xml:space="preserve">
          <source>The end index of the &lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.String,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;range&lt;/a&gt; is included in the part to be replaced.</source>
          <target state="translated">&lt;a href=&quot;replace-range#kotlin.text%24replaceRange(kotlin.String,%20kotlin.ranges.IntRange,%20kotlin.CharSequence)/range&quot;&gt;범위&lt;/a&gt; 의 끝 인덱스는 교체 할 부품에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bb3fe28b22f0be53eb5ccfae4478026ce71334" translate="yes" xml:space="preserve">
          <source>The entity which has an associated native pointer. Subtypes are supposed to represent interpretations of the pointed data or code.</source>
          <target state="translated">연결된 기본 포인터가있는 엔터티입니다. 하위 유형은 지정된 데이터 또는 코드의 해석을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2c6bd81b6f529ef522b5222f238d9ced96f1bfdb" translate="yes" xml:space="preserve">
          <source>The enum constants also implement the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; interface, with the natural order being the order in which they are defined in the enum class.</source>
          <target state="translated">열거 형 상수는 또한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparable/index&quot;&gt;Comparable&lt;/a&gt; 인터페이스를 구현하며 자연 순서는 열거 형 클래스에 정의 된 순서입니다.</target>
        </trans-unit>
        <trans-unit id="1f86188b4a8b45564220a022aed934fe72f40d6e" translate="yes" xml:space="preserve">
          <source>The example above shows the difference: &lt;code&gt;fold()&lt;/code&gt; is used for calculating the sum of doubled elements. If you pass the same function to &lt;code&gt;reduce()&lt;/code&gt;, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</source>
          <target state="translated">위의 예는 차이점을 보여줍니다. &lt;code&gt;fold()&lt;/code&gt; 는 배가 된 요소의 합을 계산하는 데 사용됩니다. 동일한 함수를 &lt;code&gt;reduce()&lt;/code&gt; 에 전달하면 첫 번째 단계에서 목록의 첫 번째 요소와 두 번째 요소를 인수로 사용하므로 첫 번째 요소가 두 배가되지 않기 때문에 다른 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b596f3f6b2203ee7818d443ce1a3eb3a2049daee" translate="yes" xml:space="preserve">
          <source>The example above will work for Android libraries with no product flavors. For a library with product flavors, the variant names also contain the flavors, like &lt;code&gt;fooBarDebug&lt;/code&gt; or &lt;code&gt;fooBazRelease&lt;/code&gt;.</source>
          <target state="translated">위 예제는 제품 버전이없는 Android 라이브러리에서 작동합니다. 제품 플레이버가있는 라이브러리의 경우 변형 이름에도 &lt;code&gt;fooBarDebug&lt;/code&gt; 또는 &lt;code&gt;fooBazRelease&lt;/code&gt; 와 같은 플레이버가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="2034baca1648e38acba659c7ed9ab52779def3a9" translate="yes" xml:space="preserve">
          <source>The example of using &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;convert&lt;/code&gt; 를 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="18829b154c907ba2a13646994ee9e04f0d08452d" translate="yes" xml:space="preserve">
          <source>The exception thrown when a character encoding or decoding error occurs.</source>
          <target state="translated">문자 인코딩 또는 디코딩 오류가 발생하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15573b104c4da364167fd1f5ed5ef94aba8df42c" translate="yes" xml:space="preserve">
          <source>The experimental marker for associated objects API.</source>
          <target state="translated">관련 개체 API의 실험용 마커입니다.</target>
        </trans-unit>
        <trans-unit id="6d95121d07b3626cf990aefa17a36910bfcf4f29" translate="yes" xml:space="preserve">
          <source>The experimental marker for type inference augmenting annotations.</source>
          <target state="translated">타입 추론 증강 주석에 대한 실험 마커.</target>
        </trans-unit>
        <trans-unit id="deb8aac7cf53fe1202db4a3293685d56f19ee1b3" translate="yes" xml:space="preserve">
          <source>The experimental multiplatform support API marker.</source>
          <target state="translated">실험적인 멀티 플랫폼 지원 API 마커.</target>
        </trans-unit>
        <trans-unit id="0428313ba384ac9c0b8833c120ad8f95ce4ede3d" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;::x&lt;/code&gt; evaluates to a property object of type &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt;, which allows us to read its value using &lt;code&gt;get()&lt;/code&gt; or retrieve the property name using the &lt;code&gt;name&lt;/code&gt; property. For more information, please refer to the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;docs on the &lt;code&gt;KProperty&lt;/code&gt; class&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;::x&lt;/code&gt; 표현식 은 &lt;code&gt;KProperty&amp;lt;Int&amp;gt;&lt;/code&gt; 유형의 속성 객체로 평가 되므로 &lt;code&gt;get()&lt;/code&gt; 사용하여 값을 읽 거나 &lt;code&gt;name&lt;/code&gt; 속성을 사용하여 속성 이름을 검색 할 수 있습니다. 자세한 내용 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-property/index&quot;&gt;은 &lt;code&gt;KProperty&lt;/code&gt; 클래스&lt;/a&gt; 의 문서 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="788ff064b8ecef1f248204a84772fdfe4508eee7" translate="yes" xml:space="preserve">
          <source>The file is missing the &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; block, which is not needed for our example, but may be necessary if we use C++ and overloaded functions. The &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C++ compatibility&lt;/a&gt; thread contains more details on this.</source>
          <target state="translated">이 파일에는 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 블록이 없습니다.이 예에서는 필요하지 않지만 C ++ 및 오버로드 된 함수를 사용하는 경우 필요할 수 있습니다. &lt;a href=&quot;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&quot;&gt;C ++ 호환성&lt;/a&gt; 실이에 대한 자세한 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2828031dfb85b70cc7191c0b9ade03e3586cc60a" translate="yes" xml:space="preserve">
          <source>The file system locations for the Java sources are different from the &lt;code&gt;java&lt;/code&gt; plugin's defaults. The Java source files need to be placed in the sibling directories of the Kotlin source roots. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are:</source>
          <target state="translated">Java 소스의 파일 시스템 위치는 &lt;code&gt;java&lt;/code&gt; 플러그인의 기본값 과 다릅니다 . Java 소스 파일은 Kotlin 소스 루트의 형제 디렉토리에 있어야합니다. 예를 들어 JVM 대상의 기본 이름이 &lt;code&gt;jvm&lt;/code&gt; 인 경우 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a63cb5acdae60d6976d603a52addbcfa0b41167c" translate="yes" xml:space="preserve">
          <source>The file we're mostly interested in is &lt;code&gt;ConsoleOutput.js&lt;/code&gt;</source>
          <target state="translated">우리가 주로 관심있는 파일은 &lt;code&gt;ConsoleOutput.js&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b2c228ca59fbecd7257e251a141cb2c1718c2ba0" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like that:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 파일 의 최종 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="994c32d45d717275b8093d1a6c05a756a3faeb93" translate="yes" xml:space="preserve">
          <source>The final code in the &lt;code&gt;hello.kt&lt;/code&gt; file may look like this:</source>
          <target state="translated">&lt;code&gt;hello.kt&lt;/code&gt; 파일 의 최종 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="845eeef01520a4662cdfbe660097ba30ecf3f4fb" translate="yes" xml:space="preserve">
          <source>The final step is to define the actual compilation of the project, which uses the standard IntelliJ IDEA Runner Type</source>
          <target state="translated">마지막 단계는 표준 IntelliJ IDEA 러너 유형을 사용하는 프로젝트의 실제 컴파일을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="64ebebb6a3a3dfec1d013df86e5fccb457a8633c" translate="yes" xml:space="preserve">
          <source>The final step is to make Xcode call our Gradle build to prepare the &lt;code&gt;SharedCode&lt;/code&gt; framework before each run. We open the &lt;em&gt;Build Phases&lt;/em&gt; tab and click &lt;code&gt;+&lt;/code&gt; to add the &lt;em&gt;New Run Script Phase&lt;/em&gt; and add the following code into it:</source>
          <target state="translated">마지막 단계는 Xcode에서 Gradle 빌드를 호출하여 각 실행 전에 &lt;code&gt;SharedCode&lt;/code&gt; 프레임 워크 를 준비하는 것 입니다. 우리는 열 &lt;em&gt;빌드 페이즈의&lt;/em&gt; 탭을 클릭 &lt;code&gt;+&lt;/code&gt; 추가하는 &lt;em&gt;새로운 스크립트 실행 단계를&lt;/em&gt; 하고 그것으로 다음 코드를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="18cac2860812daece2680c18729b8285d0c95c2d" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;, the second one refers to the result of &lt;code&gt;firstFunction()&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt; will be the result of &lt;code&gt;secondFunction()&lt;/code&gt; (or null if &lt;code&gt;maybeNull&lt;/code&gt; or any of the intermediate results were null).</source>
          <target state="translated">먼저 &lt;code&gt;this&lt;/code&gt; 지칭 &lt;code&gt;maybeNull&lt;/code&gt; 는 , 상기 제 하나의 결과를 말한다 &lt;code&gt;firstFunction()&lt;/code&gt; 및 &lt;code&gt;result&lt;/code&gt; 의 결과 일 것이다 &lt;code&gt;secondFunction()&lt;/code&gt; IF (또는 널 &lt;code&gt;maybeNull&lt;/code&gt; 또는 중간 결과가 널 (NULL)이었다).</target>
        </trans-unit>
        <trans-unit id="4fdd8b62987d88f8c4db3a2a41e10fc4d1887b5c" translate="yes" xml:space="preserve">
          <source>The first argument in this example allows one to set a name prefix for the created binaries which is used to access them in the buildscript (see the &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;Accessing binaries&quot;&lt;/a&gt; section). Also this prefix is used as a default name for the binary file. For example on Windows the sample above produces files &lt;code&gt;foo.exe&lt;/code&gt; and &lt;code&gt;bar.exe&lt;/code&gt;.</source>
          <target state="translated">이 예제의 첫 번째 인수는 작성된 바이너리에 대한 이름 접두사를 빌드 스크립트에서 액세스하는 데 사용되는 이름 접두어를 설정할 수있게합니다 ( &lt;a href=&quot;#accessing-binaries&quot;&gt;&quot;바이너리 액세스&quot;&lt;/a&gt; 섹션 참조). 또한이 접두사는 이진 파일의 기본 이름으로 사용됩니다. 예를 들어 Windows에서 위의 샘플은 &lt;code&gt;foo.exe&lt;/code&gt; 및 &lt;code&gt;bar.exe&lt;/code&gt; 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2fc302c51d198c918ae55a3c30c065988889b3c8" translate="yes" xml:space="preserve">
          <source>The first call in the chain usually should have a line break before it, but it's OK to omit it if the code makes more sense that way.</source>
          <target state="translated">체인의 첫 번째 호출은 일반적으로 앞에 줄 바꿈이 있어야하지만 코드가 더 의미가있는 경우 생략하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b4e33fae8e821602ad4182a2f8cd98570f5752fb" translate="yes" xml:space="preserve">
          <source>The first element in the progression.</source>
          <target state="translated">진행의 첫 번째 요소.</target>
        </trans-unit>
        <trans-unit id="f74c962485a9f3f35870c553a197b5ef319d5a35" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">첫 번째 예 는 동일한 코드에서 &lt;em&gt;비 차단 &lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; 과 &lt;em&gt;차단 &lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; 을 혼합 합니다. 어느 것이 막히고 어떤 것이 막히지 않았는지 쉽게 잃을 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 빌더를 사용하여 차단하는 것에 대해 명시 적으로 설명하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1aa4bbc7c819801ad00e125d4e56e82f4c2f67c5" translate="yes" xml:space="preserve">
          <source>The first example mixes &lt;em&gt;non-blocking&lt;/em&gt;&lt;code&gt;delay(...)&lt;/code&gt; and &lt;em&gt;blocking&lt;/em&gt;&lt;code&gt;Thread.sleep(...)&lt;/code&gt; in the same code. It is easy to lose track of which one is blocking and which one is not. Let's be explicit about blocking using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder:</source>
          <target state="translated">첫 번째 예제 는 동일한 코드에서 &lt;em&gt;non-blocking &lt;/em&gt; &lt;code&gt;delay(...)&lt;/code&gt; 와 &lt;em&gt;차단 &lt;/em&gt; &lt;code&gt;Thread.sleep(...)&lt;/code&gt; 을 혼합 합니다. 어느 쪽이 막고 있는지, 어느 쪽이 아닌지 추적하기 쉽습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 빌더를 사용하여 차단에 대해 명시 적으로 설명하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b2d66cf460f6f78061ad6d5f7262d3436e850f41" translate="yes" xml:space="preserve">
          <source>The first extension takes a &lt;code&gt;char *&lt;/code&gt; as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.</source>
          <target state="translated">첫 번째 확장은 &lt;code&gt;char *&lt;/code&gt; 를 UTF-8 문자열로 사용하여 문자열로 바꿉니다. 두 번째 함수는 동일하지만 넓은 UTF-16 문자열에 대해 수행합니다.</target>
        </trans-unit>
        <trans-unit id="60455f009d759b3a711a0c86694ca0f8e3417539" translate="yes" xml:space="preserve">
          <source>The first four elements are added to the buffer and the sender suspends when trying to send the fifth one.</source>
          <target state="translated">처음 4 개의 요소가 버퍼에 추가되고 5 번째 요소를 보내려고하면 발신자가 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="ab32e32b6495f8ef1ecac2deb728551ecd768355" translate="yes" xml:space="preserve">
          <source>The first function is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt;. You can call it on a collection of collections, for example, a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt;s. The function returns a single &lt;code&gt;List&lt;/code&gt; of all the elements of the nested collections.</source>
          <target state="translated">첫 번째 함수는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt; 입니다. 컬렉션 모음 (예 : &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Set&lt;/code&gt; ) 에서 호출 할 수 있습니다 . 이 함수는 중첩 컬렉션의 모든 요소에 대한 단일 &lt;code&gt;List&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bb9b81609c647210d6aacd108c4c1230b4870b5f" translate="yes" xml:space="preserve">
          <source>The first line of the input contains two integers &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;</source>
          <target state="translated">입력의 첫 번째 줄에는 두 개의 정수 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;k&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a973365d252e2f2156e9bff5ffce49da12fd36a5" translate="yes" xml:space="preserve">
          <source>The first list contains the first elements of each &lt;code&gt;Pair&lt;/code&gt; in the original list.</source>
          <target state="translated">첫 번째 목록에는 원본 목록에서 각 &lt;code&gt;Pair&lt;/code&gt; 의 첫 번째 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="79bda60284dc4aa80a7917505f3968fd9009f668" translate="yes" xml:space="preserve">
          <source>The first step of using an actor is to define a class of messages that an actor is going to process. Kotlin's &lt;a href=&quot;../sealed-classes&quot;&gt;sealed classes&lt;/a&gt; are well suited for that purpose. We define &lt;code&gt;CounterMsg&lt;/code&gt; sealed class with &lt;code&gt;IncCounter&lt;/code&gt; message to increment a counter and &lt;code&gt;GetCounter&lt;/code&gt; message to get its value. The later needs to send a response. A &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred&lt;/a&gt; communication primitive, that represents a single value that will be known (communicated) in the future, is used here for that purpose.</source>
          <target state="translated">액터를 사용하는 첫 번째 단계는 액터가 처리 할 메시지 클래스를 정의하는 것입니다. 코 틀린의 &lt;a href=&quot;../sealed-classes&quot;&gt;봉인 수업&lt;/a&gt; 은 그 목적에 적합합니다. 카운터를 증가시키기 위해 &lt;code&gt;IncCounter&lt;/code&gt; 메시지와 그 값을 얻기 위해 &lt;code&gt;GetCounter&lt;/code&gt; 메시지를 사용하여 &lt;code&gt;CounterMsg&lt;/code&gt; 밀봉 클래스를 정의 합니다. 나중에 응답을 보내야합니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-completable-deferred/index.html&quot;&gt;CompletableDeferred의&lt;/a&gt; 미래에 공지 (전달) 될 단일 값을 나타내는 원시 통신은, 그 목적을 위해 여기에 사용된다.</target>
        </trans-unit>
        <trans-unit id="38481ec6d5c41bf35d07d09bc7535247f80dee43" translate="yes" xml:space="preserve">
          <source>The first thing we'll need is a Kotlin file called &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; with the &lt;code&gt;main&lt;/code&gt; function defined in it and then proceed to translate each line</source>
          <target state="translated">가장 먼저 필요한 것은 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 라는 Kotlin 파일 입니다. 여기에 &lt;code&gt;main&lt;/code&gt; 함수가 정의되어 있고 각 줄을 번역하십시오.</target>
        </trans-unit>
        <trans-unit id="6f6aa8f820f0284bd28697b0207de3b2578af79f" translate="yes" xml:space="preserve">
          <source>The following attributes are supported:</source>
          <target state="translated">다음과 같은 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d555f20ea9bbf2028964527e2711757cec45ebd4" translate="yes" xml:space="preserve">
          <source>The following code launches a long-running coroutine in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; that prints &quot;I'm sleeping&quot; twice a second and then returns from the main function after some delay:</source>
          <target state="translated">다음 코드는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 오래 실행되는 코 루틴을 시작하여 1 초에 두 번 &quot;잠자고 있습니다&quot;를 인쇄 한 다음 약간의 지연 후에 기본 기능에서 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="ead88ea1dd6b3e545d54d2d74bc4d103e0cfff51" translate="yes" xml:space="preserve">
          <source>The following commands are available.</source>
          <target state="translated">다음과 같은 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55be4cb42f91b956f18957a0a075265fb24672f6" translate="yes" xml:space="preserve">
          <source>The following example demonstrates this concept:</source>
          <target state="translated">다음 예제는이 개념을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="40d8cb89ac87b573a486f4f8fe49663dde1297b2" translate="yes" xml:space="preserve">
          <source>The following example prints the first ten prime numbers, running the whole pipeline in the context of the main thread. Since all the coroutines are launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine we don't have to keep an explicit list of all the coroutines we have started. We use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; extension function to cancel all the children coroutines after we have printed the first ten prime numbers.</source>
          <target state="translated">다음 예제는 메인 스레드의 컨텍스트에서 전체 파이프 라인을 실행하는 처음 10 개의 소수를 인쇄합니다. 모든 코 루틴은 기본 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 의 범위에서 시작되므로 시작한 모든 코 루틴의 목록을 명시 적으로 유지할 필요는 없습니다. 우리는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/kotlin.coroutines.-coroutine-context/cancel-children.html&quot;&gt;cancelChildren&lt;/a&gt; 확장 기능을 사용 하여 처음 10 개의 소수를 인쇄 한 후 모든 자식 코 루틴을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="9f818012b8152abe166a094d93ab2ca0ec79eab1" translate="yes" xml:space="preserve">
          <source>The following example shows how to use these settings.</source>
          <target state="translated">다음 예는 이러한 설정을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="29c80399d536894a6ec94c527a731166260c49c2" translate="yes" xml:space="preserve">
          <source>The following example shows their use outside of coroutine:</source>
          <target state="translated">다음 예는 코 루틴 밖에서의 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b39c4c0b095563ff59ef483ec27836f8b662f2fa" translate="yes" xml:space="preserve">
          <source>The following examples show different possibilities of configuring the Gradle plugin:</source>
          <target state="translated">다음 예제는 Gradle 플러그인 구성의 다양한 가능성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e712d7790d39e907b7ee7e8cb60e61e0c86b31e2" translate="yes" xml:space="preserve">
          <source>The following identifiers are defined by the compiler in specific contexts and can be used as regular identifiers in other contexts:</source>
          <target state="translated">다음 식별자는 특정 컨텍스트에서 컴파일러에 의해 정의되며 다른 컨텍스트에서 일반 식별자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf95dedf99c3841e1d5196a0ba2d969912347f7d" translate="yes" xml:space="preserve">
          <source>The following is an example interface of the JDK implemented by &lt;code&gt;StringBuilder&lt;/code&gt; class:</source>
          <target state="translated">다음은 &lt;code&gt;StringBuilder&lt;/code&gt; 클래스로 구현 된 JDK의 인터페이스 예입니다 .</target>
        </trans-unit>
        <trans-unit id="8e29598dc88ea6b0ec70ab50aa2a4cfa741c6e7f" translate="yes" xml:space="preserve">
          <source>The following pipeline stage filters an incoming stream of numbers, removing all the numbers that are divisible by the given prime number:</source>
          <target state="translated">다음 파이프 라인 단계는 들어오는 숫자 스트림을 필터링하여 지정된 소수로 나눌 수있는 모든 숫자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="29b7ef083a5e449cb9ecea68dfa0ae64024fefca" translate="yes" xml:space="preserve">
          <source>The following podspec fields are required by CocoaPods:</source>
          <target state="translated">CocoaPod에는 다음 podspec 필드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="21b0584d86535ffda98821a37bb76687f7207959" translate="yes" xml:space="preserve">
          <source>The following sections explain in more detail the concepts mentioned so far.</source>
          <target state="translated">다음 섹션에서는 지금까지 언급 한 개념에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5472a88e6462dc9e30567cf6b7a816998c79c200" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in modifier lists of declarations and can be used as identifiers in other contexts:</source>
          <target state="translated">다음 토큰은 수정 자 선언 목록에서 키워드 역할을하며 다른 컨텍스트에서 식별자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c62886b027ba800287b4be18a333a156fdeb309b" translate="yes" xml:space="preserve">
          <source>The following tokens act as keywords in the context when they are applicable and can be used as identifiers in other contexts:</source>
          <target state="translated">다음 토큰은 해당되는 경우 컨텍스트에서 키워드 역할을하며 다른 컨텍스트에서 식별자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71c4c5ec356525034ad2f877a92ba2dfdfffc609" translate="yes" xml:space="preserve">
          <source>The following tokens are always interpreted as keywords and cannot be used as identifiers:</source>
          <target state="translated">다음 토큰은 항상 키워드로 해석되며 식별자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0493d41eaaff9f9930d4990e582a0014dff8b09e" translate="yes" xml:space="preserve">
          <source>The following workflow is expected when interacting with the native library.</source>
          <target state="translated">기본 라이브러리와 상호 작용할 때 다음과 같은 워크 플로우가 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="41bde8cb095fdaa39e87c44d34bec8992402e368" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 반환이 경우 제로 &lt;code&gt;Double&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; 미만의 경우 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7dbd577dd676bd08f82b2f5d51d9ac8e4bfc959" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 반환이 경우 제로 &lt;code&gt;Double&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE로부터&lt;/a&gt; 미만의 경우 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 로부터 , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;로부터 Long.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c24376936f310cfc6a2b02ee789c1ab9c4a079c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 음수 이면 0을 반환하고 &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; 보다 크면 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="19ac86b4bcb26b195d587cd10aa019f5e68922bb" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 음수 이면 0을 반환하고 &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; 보다 크면 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a03b953ac3fd08a46517db9b02880729ef0942e5" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 반환이 경우 제로 &lt;code&gt;Float&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; 그 이하의 경우 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8f1f7669eb111859c7b969d69798041d2a9b37e" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 반환이 경우 제로 &lt;code&gt;Float&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE로부터&lt;/a&gt; 그 이하의 경우 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 로부터 , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;로부터 Long.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43741e55696c4613d380e3f315ef0bfbfc2d96be" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 이 &lt;code&gt;Float&lt;/code&gt; 값이 음수 이면 0 , &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; 보다 크면 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3fd2c9a0fe0f333063fc214dadef0239e9bff9de" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down towards zero. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">분수 부분이있는 경우 0을 향해 내림됩니다. 이 &lt;code&gt;Float&lt;/code&gt; 값이 음수 이면 0을 반환하고 &lt;code&gt;NaN&lt;/code&gt; , &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; 보다 크면 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="46d230bab2ec3e41d052e1e397afc7cc1e96642c" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 반환이 경우 제로 &lt;code&gt;Double&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; 미만의 경우 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7c04cb487d62c119eaf78735ad59d58fbbea7f7" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 인 경우 0을 , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; 보다 작은 경우 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="986d603361e48796a38eb31b882249f0e0fb1907" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 음수 이면 0을 &lt;code&gt;NaN&lt;/code&gt; 하고 &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="db89446a546caa08c045751959e85b9b42af6661" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Double&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 음수 이면 0을 &lt;code&gt;NaN&lt;/code&gt; 하고 &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6c0d7df43097a38a432b999c674eaa178ec96a50" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Int.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Int.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 반환이 경우 제로 &lt;code&gt;Float&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-int/-m-i-n_-v-a-l-u-e#kotlin.Int.Companion%24MIN_VALUE&quot;&gt;Int.MIN_VALUE&lt;/a&gt; 그 이하의 경우 &lt;code&gt;Int.MIN_VALUE&lt;/code&gt; , &lt;a href=&quot;../-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Int.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="234cddb40ea7edc20ba16f302fd45e435a6a6dbf" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE&lt;/a&gt; if it's less than &lt;code&gt;Long.MIN_VALUE&lt;/code&gt;, &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;Long.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;Long.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 반환이 경우 제로 &lt;code&gt;Float&lt;/code&gt; 값이 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;../-long/-m-i-n_-v-a-l-u-e#kotlin.Long.Companion%24MIN_VALUE&quot;&gt;Long.MIN_VALUE로부터&lt;/a&gt; 그 이하의 경우 &lt;code&gt;Long.MIN_VALUE&lt;/code&gt; 로부터 , &lt;a href=&quot;../-long/-m-a-x_-v-a-l-u-e#kotlin.Long.Companion%24MAX_VALUE&quot;&gt;로부터 Long.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;Long.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a1bb43be34e6fb6de623932b67b670ae0006852" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 &lt;code&gt;Float&lt;/code&gt; 값이 음수 인 경우 0을 &lt;code&gt;NaN&lt;/code&gt; 하고 &lt;a href=&quot;-u-int/-m-a-x_-v-a-l-u-e&quot;&gt;UInt.MAX_VALUE&lt;/a&gt; 보다 큰 경우 &lt;code&gt;UInt.MAX_VALUE&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1fdd0d739f0100ce802b95ab4a4c9b2532feeff0" translate="yes" xml:space="preserve">
          <source>The fractional part, if any, is rounded down. Returns zero if this &lt;code&gt;Float&lt;/code&gt; value is negative or &lt;code&gt;NaN&lt;/code&gt;, &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; if it's bigger than &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt;.</source>
          <target state="translated">소수 부분은 반올림됩니다. 이 경우 0을 반환 &lt;code&gt;Float&lt;/code&gt; 값이 음수이거나 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;a href=&quot;-u-long/-m-a-x_-v-a-l-u-e&quot;&gt;ULong.MAX_VALUE&lt;/a&gt; 그것보다 더 큰 경우 &lt;code&gt;ULong.MAX_VALUE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea6eb6722ce134e1e96c66df47559354876af311" translate="yes" xml:space="preserve">
          <source>The framework that we compiled with Kotlin/Native has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift. As a result, we'll have the following code in &lt;code&gt;main.swift&lt;/code&gt;:</source>
          <target state="translated">우리가 Kotlin / Native로 컴파일 한 프레임 워크에는 Swift에서 더 쉽게 사용할 수 있도록 돕는 속성이 있습니다. 이전 Objective-C 예제를 Swift로 변환 해 봅시다. 결과적으로 &lt;code&gt;main.swift&lt;/code&gt; 에 다음 코드가 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="229775820ba0ca0053d7b140e68dd9b3ed428ae4" translate="yes" xml:space="preserve">
          <source>The full build script for the sample project can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;here&lt;/a&gt;. You can also look at the converted code for &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;the Android sample&lt;/a&gt;.</source>
          <target state="translated">샘플 프로젝트의 전체 빌드 스크립트는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/kotlin-dagger/build.gradle&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 . 당신은 또한 &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-dagger&quot;&gt;안드로이드 샘플에&lt;/a&gt; 대한 변환 된 코드를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e62bc4cb51ca1d1cddfe4e1d3d510caa93dee388" translate="yes" xml:space="preserve">
          <source>The full list of arguments that can be used is shown when you run &lt;code&gt;kotlinc -help&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kotlinc -help&lt;/code&gt; 를 실행할 때 사용할 수있는 전체 인수 목록이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="02b69f589be9184eaa6e08d9fb77b12e7b2d6da2" translate="yes" xml:space="preserve">
          <source>The full list of supported use-site targets is:</source>
          <target state="translated">지원되는 사용 사이트 대상의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58018a7c2f7cccce2f2841705c78d55576a7e56f" translate="yes" xml:space="preserve">
          <source>The full syntactic form of lambda expressions is as follows:</source>
          <target state="translated">람다 식의 전체 구문 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1347221f9ac10fa3f9465e07c5ca87cc27e8a8e6" translate="yes" xml:space="preserve">
          <source>The full syntax for declaring a property is</source>
          <target state="translated">속성을 선언하는 전체 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="905c760b34a0beb7b5d4d319c2f007dd8ebd0fd3" translate="yes" xml:space="preserve">
          <source>The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with &lt;code&gt;val&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt; and does not allow a setter:</source>
          <target state="translated">읽기 전용 속성 선언의 전체 구문은 다음 두 가지 측면에서 변경 가능한 것과 다릅니다. &lt;code&gt;var&lt;/code&gt; 대신 &lt;code&gt;val&lt;/code&gt; 로 시작 하고 setter를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="776f7d695f882be224aebfaccabd52b1c0591bc5" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or a class of an anonymous object.</source>
          <target state="translated">점으로 구분 된 클래스의 정규화 된 이름입니다 . 클래스가 로컬이거나 익명 개체의 클래스 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ee52f844a0963f3db9f0478ccd20b13916c48b9" translate="yes" xml:space="preserve">
          <source>The fully qualified dot-separated name of the class, or &lt;code&gt;null&lt;/code&gt; if the class is local or it is an anonymous object literal.</source>
          <target state="translated">정규화 된 점으로 구분 된 클래스 이름이거나 클래스가 로컬이거나 익명 객체 리터럴 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6c5b38e497b6843a07b1a8945d528e3c7606264" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-list#kotlin.collections%24List(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.List.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="translated">&lt;a href=&quot;-list#kotlin.collections%24List(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.List.T)))/init&quot;&gt;init&lt;/a&gt; 함수 는 첫 번째 요소부터 순차적으로 각 목록 요소에 대해 호출됩니다. 인덱스가 주어진 목록 요소의 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7696926a08823163fe79a297a106aabaf3f3d399" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-mutable-list#kotlin.collections%24MutableList(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.MutableList.T)))/init&quot;&gt;init&lt;/a&gt; is called for each list element sequentially starting from the first one. It should return the value for a list element given its index.</source>
          <target state="translated">&lt;a href=&quot;-mutable-list#kotlin.collections%24MutableList(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.collections.MutableList.T)))/init&quot;&gt;init&lt;/a&gt; 함수 는 첫 번째 요소부터 순차적으로 각 목록 요소에 대해 호출됩니다. 인덱스가 주어진 목록 요소의 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed3c35965fc33462a41df8d6c5d69d9f13434071" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-byte-array#kotlin%24UByteArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UByte)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">&lt;a href=&quot;-u-byte-array#kotlin%24UByteArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UByte)))/init&quot;&gt;init&lt;/a&gt; 함수 는 첫 번째 요소부터 순차적으로 각 배열 요소에 대해 호출됩니다. 인덱스가 주어진 배열 요소의 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="acfbb507b912e298abe7a785c884c806da178f93" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-int-array#kotlin%24UIntArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UInt)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">&lt;a href=&quot;-u-int-array#kotlin%24UIntArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UInt)))/init&quot;&gt;init&lt;/a&gt; 함수 는 첫 번째 요소부터 순차적으로 각 배열 요소에 대해 호출됩니다. 인덱스가 주어진 배열 요소의 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="804f600305f25777086b4066f40ae2670855676b" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-long-array#kotlin%24ULongArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.ULong)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">&lt;a href=&quot;-u-long-array#kotlin%24ULongArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.ULong)))/init&quot;&gt;init&lt;/a&gt; 함수 는 첫 번째 요소부터 순차적으로 각 배열 요소에 대해 호출됩니다. 인덱스가 주어진 배열 요소의 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="98c90b068891a2e0a90f241b535756a6f3e22982" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;-u-short-array#kotlin%24UShortArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UShort)))/init&quot;&gt;init&lt;/a&gt; is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">&lt;a href=&quot;-u-short-array#kotlin%24UShortArray(kotlin.Int,%20kotlin.Function1((kotlin.Int,%20kotlin.UShort)))/init&quot;&gt;init&lt;/a&gt; 함수 는 첫 번째 요소부터 순차적으로 각 배열 요소에 대해 호출됩니다. 인덱스가 주어진 배열 요소의 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="39a40c87789f813fc496dc5468cc91805583814e" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;libnative_symbols&lt;/code&gt; allows us to open the way from the native code to the Kotlin/Native library. This is the entry point we use. The library name is used as a prefix for the function name.</source>
          <target state="translated">&lt;code&gt;libnative_symbols&lt;/code&gt; 함수를 사용하면 원시 코드에서 Kotlin / Native 라이브러리로가는 길을 열 수 있습니다. 이것이 우리가 사용하는 진입 점입니다. 라이브러리 이름은 함수 이름의 접두사로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ecf68a80d3d421d1a3dac0bf6a7b99795040c5e0" translate="yes" xml:space="preserve">
          <source>The function body is delimited by curly braces - indentation is generally not significant in Kotlin, but you should of course indent your code properly for the benefit of human readers.</source>
          <target state="translated">함수 본문은 중괄호로 구분됩니다. 들여 쓰기는 일반적으로 Kotlin에서 중요하지 않지만, 인간 독자의 이익을 위해 코드를 올바르게 들여 쓰기해야합니다.</target>
        </trans-unit>
        <trans-unit id="892b57cbc7486be03e2291de2837204f537e592b" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">이 기능은 필요한 경우 읽기에서 쓰기 잠금으로 업그레이드하지만 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt; 은 해당 업그레이드를 지원하지 않으므로이 업그레이드는 원 자성이 아닙니다 . 이러한 업그레이드를 수행하기 위해이 기능은 먼저이 스레드가 보유한 모든 읽기 잠금을 해제 한 다음 쓰기 잠금을 획득 한 후 해제 한 후 다시 읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="41eab38f14ba2d1160f8a85b6cc897eb549e21ad" translate="yes" xml:space="preserve">
          <source>The function does upgrade from read to write lock if needed, but this upgrade is not atomic as such upgrade is not supported by &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;. In order to do such upgrade this function first releases all read locks held by this thread, then acquires write lock, and after releasing it acquires read locks back again.</source>
          <target state="translated">이 함수는 필요한 경우 읽기에서 쓰기 잠금으로 업그레이드하지만 이러한 업그레이드는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html&quot;&gt;ReentrantReadWriteLock에서&lt;/a&gt; 지원되지 않으므로이 업그레이드는 원 자성이 아닙니다 . 이러한 업그레이드를 수행하기 위해이 함수는 먼저이 스레드가 보유한 모든 읽기 잠금을 해제 한 다음 쓰기 잠금을 획득하고 해제 한 후 다시 읽기 잠금을 획득합니다.</target>
        </trans-unit>
        <trans-unit id="11c5bbd79a2512e469db0fde4da38bfd3abb594c" translate="yes" xml:space="preserve">
          <source>The function init is called for each array element sequentially starting from the first one. It should return the value for an array element given its index.</source>
          <target state="translated">init 함수는 첫 번째 요소부터 순차적으로 각 배열 요소에 대해 호출됩니다. 인덱스가 주어진 배열 요소의 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="47e9d14611b3a1f9114880a2ff853190d9e97c10" translate="yes" xml:space="preserve">
          <source>The function signature remains exactly the same. The only difference is &lt;code&gt;suspend&lt;/code&gt; being added to it. The return type however is the type we want to be returned.</source>
          <target state="translated">함수 서명은 정확히 동일하게 유지됩니다. 유일한 차이점은 &lt;code&gt;suspend&lt;/code&gt; 이 추가되는 것입니다. 그러나 반환 유형은 반환하려는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f6772ad37911fb29515e5ecad2f466bed6bdb7cd" translate="yes" xml:space="preserve">
          <source>The function type notation can optionally include names for the function parameters: &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt;. These names can be used for documenting the meaning of the parameters.</source>
          <target state="translated">함수 유형 표기법은 선택적으로 함수 매개 변수의 이름을 포함 할 수 있습니다 : &lt;code&gt;(x: Int, y: Int) -&amp;gt; Point&lt;/code&gt; . 이 이름은 매개 변수의 의미를 문서화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f62a960bb01edb991f086fcecfa3233b3994fce" translate="yes" xml:space="preserve">
          <source>The functions include trigonometric, hyperbolic, exponentiation and power, logarithmic, rounding, sign and absolute value.</source>
          <target state="translated">함수에는 삼각법, 쌍곡선, 지수 및 거듭 제곱, 로그, 반올림, 부호 및 절대 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="332c4fb906dbcda140f018d0de201e8c1ce3d30d" translate="yes" xml:space="preserve">
          <source>The general rule is: when a type parameter &lt;code&gt;T&lt;/code&gt; of a class &lt;code&gt;C&lt;/code&gt; is declared &lt;strong&gt;out&lt;/strong&gt;, it may occur only in &lt;strong&gt;out&lt;/strong&gt;-position in the members of &lt;code&gt;C&lt;/code&gt;, but in return &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; can safely be a supertype of &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">일반적인 규칙은 다음과 같습니다 매개 변수 유형 때 &lt;code&gt;T&lt;/code&gt; 클래스의 &lt;code&gt;C&lt;/code&gt; 가 선언 &lt;strong&gt;밖으로&lt;/strong&gt; , 그것은 단지에서 발생할 수있는 &lt;strong&gt;아웃&lt;/strong&gt; 의 구성원의 &amp;alpha; 위치 &lt;code&gt;C&lt;/code&gt; ,하지만 반환에 &lt;code&gt;C&amp;lt;Base&amp;gt;&lt;/code&gt; 안전의 슈퍼 될 수있다 &lt;code&gt;C&amp;lt;Derived&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47a803852f9a44b2a9ede00ebab7d2f5f19ab5c5" translate="yes" xml:space="preserve">
          <source>The general rule:</source>
          <target state="translated">일반적인 규칙 :</target>
        </trans-unit>
        <trans-unit id="39d2229c00faf1c133ef862b873c7364c63bd099" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessarily synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">스레드와 코 루틴 모두에서 작동하는 일반적인 솔루션은 공유 상태에서 수행해야하는 해당 작업에 필요한 모든 동기화를 제공하는 스레드 안전 (일명 동기화, 선형화 또는 원자) 데이터 구조를 사용하는 것입니다. 간단한 카운터의 경우 &lt;code&gt;AtomicInteger&lt;/code&gt; 클래스를 사용하여 atomic &lt;code&gt;incrementAndGet&lt;/code&gt; 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e700b89372f9cc694759aa68e2252618aa967c7" translate="yes" xml:space="preserve">
          <source>The general solution that works both for threads and for coroutines is to use a thread-safe (aka synchronized, linearizable, or atomic) data structure that provides all the necessary synchronization for the corresponding operations that needs to be performed on a shared state. In the case of a simple counter we can use &lt;code&gt;AtomicInteger&lt;/code&gt; class which has atomic &lt;code&gt;incrementAndGet&lt;/code&gt; operations:</source>
          <target state="translated">스레드와 코 루틴 모두에 대해 작동하는 일반적인 솔루션은 공유 상태에서 수행해야하는 해당 작업에 필요한 모든 동기화를 제공하는 스레드로부터 안전한 (동기화, 선형화 가능 또는 원자 적) 데이터 구조를 사용하는 것입니다. 간단한 카운터의 경우 원자 &lt;code&gt;incrementAndGet&lt;/code&gt; 연산 이있는 &lt;code&gt;AtomicInteger&lt;/code&gt; 클래스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe194a34c4e181902ef2477861ca1a56a0c14e72" translate="yes" xml:space="preserve">
          <source>The generated constructor is synthetic so it can&amp;rsquo;t be directly called from Java or Kotlin, but it can be called using reflection.</source>
          <target state="translated">생성 된 생성자는 합성이므로 Java 또는 Kotlin에서 직접 호출 할 수 없지만 리플렉션을 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c09ea74ea1b03fd685bbe5f94354a8374db022b3" translate="yes" xml:space="preserve">
          <source>The getter of this property, used to obtain the value of the property.</source>
          <target state="translated">이 프로퍼티의 getter. 프로퍼티의 값을 취득하는데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5599725590a9016e21ca4310f17eb7b2b01a0483" translate="yes" xml:space="preserve">
          <source>The globs are applied to the header paths relative to the appropriate include path elements, e.g. &lt;code&gt;time.h&lt;/code&gt; or &lt;code&gt;curl/curl.h&lt;/code&gt;. So if the library is usually included with &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt;, then it would probably be correct to filter headers with</source>
          <target state="translated">글로브는 적절한 포함 경로 요소, 예를 들어 &lt;code&gt;time.h&lt;/code&gt; 또는 &lt;code&gt;curl/curl.h&lt;/code&gt; 와 관련하여 헤더 경로에 적용됩니다 . 따라서 라이브러리가 일반적으로 &lt;code&gt;#include &amp;lt;SomeLbrary/Header.h&amp;gt;&lt;/code&gt; 에 포함되어 있으면 헤더를 필터링하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a57ffec5971f7b3f89d004ca095f66feb86eb296" translate="yes" xml:space="preserve">
          <source>The goal of the tutorial is to demonstrate Kotlin code re-use between Android and iOS. Let's start by manually creating the &lt;code&gt;SharedCode&lt;/code&gt; sub-project in our Gradle project. The source code from the &lt;code&gt;SharedCode&lt;/code&gt; project will be shared between platforms. We will create several new files in our project to implement that.</source>
          <target state="translated">이 튜토리얼의 목표는 Android와 iOS 간의 Kotlin 코드 재사용을 보여주는 것입니다. Gradle 프로젝트에서 &lt;code&gt;SharedCode&lt;/code&gt; 하위 프로젝트를 수동으로 생성하여 시작하겠습니다 . &lt;code&gt;SharedCode&lt;/code&gt; 프로젝트 의 소스 코드 는 플랫폼간에 공유됩니다. 이를 구현하기 위해 프로젝트에 여러 개의 새 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="068a964193217c327091688b8b7de38e4eb4f3e1" translate="yes" xml:space="preserve">
          <source>The header files merely contain function declarations for functionality that is defined at runtime. For instance, we could define a &lt;code&gt;jQuery&lt;/code&gt; function like so</source>
          <target state="translated">헤더 파일에는 런타임시 정의 된 기능에 대한 함수 선언 만 포함됩니다. 예를 들어, &lt;code&gt;jQuery&lt;/code&gt; 함수를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce2e166fe215303244aa3044be29e2844cbf2bc" translate="yes" xml:space="preserve">
          <source>The iOS simulator requires a framework compiled for the &lt;code&gt;ios_x64&lt;/code&gt; target, the &lt;code&gt;iOS_sim&lt;/code&gt; folder in our case.</source>
          <target state="translated">iOS 시뮬레이터에는 우리의 경우 &lt;code&gt;iOS_sim&lt;/code&gt; 폴더 인 &lt;code&gt;ios_x64&lt;/code&gt; 대상을 위해 컴파일 된 프레임 워크가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="31859b6cbcfb9892316b62d967e1f5ae2235d5ef" translate="yes" xml:space="preserve">
          <source>The idea behind Rx is to move towards what's called &lt;code&gt;observable streams&lt;/code&gt; where by we now think of data as streams (infinite amounts of data) and these streams can be observed. In practical terms, Rx is simply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer Pattern&lt;/a&gt; with a series of extensions which allow us to operate on the data.</source>
          <target state="translated">Rx의 기본 개념 은 데이터를 스트림 (무한량의 데이터)으로 생각하고이 스트림을 관찰 할 수있는 관찰 &lt;code&gt;observable streams&lt;/code&gt; 이동하는 것입니다. 실제로 Rx는 단순히 데이터를 조작 할 수있는 일련의 확장 기능을 가진 &lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;Observer 패턴&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a752acd40500d4af1aa6897c4527c1276e603455" translate="yes" xml:space="preserve">
          <source>The idea behind futures or promises (there are also other terms these can be referred to depending on language/platform), is that when we make a call, we're promised that at some point it will return with an object called a Promise, which can then be operated on.</source>
          <target state="translated">선물이나 약속 뒤에있는 아이디어 (언어 / 플랫폼에 따라 다른 용어가있을 수도 있음)는 전화를 걸 때 언젠가 약속이라는 물건으로 돌아올 것이라고 약속합니다. 그런 다음 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5a5ec78c5bbba1d9a9593b45aa36ac04ad75c" translate="yes" xml:space="preserve">
          <source>The idea is to make every platform show similar text: &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; and &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt;, depending on the platform. We will reuse the way we generate the message. Let's create the file (and missing directories) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; with the following contents under the project root directory</source>
          <target state="translated">: 아이디어는 모든 플랫폼이 유사한 텍스트를 표시하는 것입니다 &lt;code&gt;Kotlin Rocks on Android&lt;/code&gt; 와 &lt;code&gt;Kotlin Rocks on iOS&lt;/code&gt; 플랫폼에 따라. 메시지 생성 방식을 재사용 할 것입니다. 프로젝트 루트 디렉토리 아래에 다음 내용으로 파일 (및 누락 된 디렉토리) &lt;code&gt;SharedCode/src/commonMain/kotlin/common.kt&lt;/code&gt; 를 작성해 봅시다</target>
        </trans-unit>
        <trans-unit id="82fd6cd237e491604315526b684dbfedf391a053" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="6ba732549bab36d600a33b057cb1445e14d3cdfc" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="e80ec37934bbec50821c43bd38cce1238a634038" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="9ab2ec2a4f2966a3555f9fce9c9ee7c196c5adc8" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="41ae2cd6b24e4bafa0efb17c582aa2f3dbd61174" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="b29deea1bb921913df3a5fadba5cd74a8f4acd5e" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;../../kotlin.collections/-mutable-set/index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="a6579034caa6bf530c44ba48e1557ccf3e4b94a3" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-hash-map/index#kotlin.collections.HashMap&quot;&gt;HashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="a009a3a444f03e70f059b3c04a3a49cc825d720d" translate="yes" xml:space="preserve">
          <source>The implementation of the &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; interface, backed by a &lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../-linked-hash-map/index#kotlin.collections.LinkedHashMap&quot;&gt;LinkedHashMap&lt;/a&gt; 인스턴스가 지원 하는 &lt;a href=&quot;index#kotlin.collections.MutableSet&quot;&gt;MutableSet&lt;/a&gt; 인터페이스 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="fa50aaadf0215e23e542746cdfa2658460833341" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; property, which should return read-only set of map entries.</source>
          <target state="translated">구현자는 &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야하며, 읽기 전용 맵 항목 세트를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d9844010488cdb05175b5fbda28866913c16552" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">구현자는 &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야하며,이 속성은 변경 가능한 맵 항목 집합을 반환하고 함수를 &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;넣어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4c2bcd3066d4911e1651a3eb4e73833cb38dc376" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">구현자는 변경 가능한 맵 항목 집합을 반환하고 함수를 &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;넣어야&lt;/a&gt; 하는 &lt;a href=&quot;../-mutable-map/entries#kotlin.collections.MutableMap%24entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b072b8461d749216f126589f253d2136dcee5a49" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">구현자는 &lt;a href=&quot;entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야하며,이 속성은 변경 가능한 맵 항목 집합을 반환하고 함수를 &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put%28kotlin.collections.AbstractMutableMap.K%2C+kotlin.collections.AbstractMutableMap.V%29&quot;&gt;넣어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="de6f180abcaad3c2e2c4cd19c5f847e641f85c21" translate="yes" xml:space="preserve">
          <source>The implementor is required to implement &lt;a href=&quot;entries&quot;&gt;entries&lt;/a&gt; property, which should return mutable set of map entries, and &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;put&lt;/a&gt; function.</source>
          <target state="translated">구현자는 변경 가능한 맵 항목 집합을 반환하고 함수를 &lt;a href=&quot;put#kotlin.collections.AbstractMutableMap%24put(kotlin.collections.AbstractMutableMap.K,%20kotlin.collections.AbstractMutableMap.V)&quot;&gt;넣어야&lt;/a&gt; 하는 &lt;a href=&quot;entries&quot;&gt;항목&lt;/a&gt; 속성 을 구현 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b4d84ada0a069eb9728359000c31d5443cb7fe8c" translate="yes" xml:space="preserve">
          <source>The in-place sorting functions have similar names to the functions that apply to read-only lists, but without the &lt;code&gt;ed/d&lt;/code&gt; suffix:</source>
          <target state="translated">내부 정렬 기능은 읽기 전용 목록에 적용되지만 &lt;code&gt;ed/d&lt;/code&gt; 접미사가 없는 기능과 이름이 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="ad88781015ab91e944a6d24ed6740d21e1a613c0" translate="yes" xml:space="preserve">
          <source>The indentation in front of the accessors is due to convention; like elsewhere in Kotlin, it has no syntactic significance. The compiler can tell which accessors belong to which properties because the only legal place for an accessor is immediately after the property declaration (and there can be at most one getter and one setter) - so you can't split the property declaration and the accessor declarations. However, the order of the accessors doesn't matter.</source>
          <target state="translated">접근 자 앞의 들여 쓰기는 컨벤션 때문입니다. Kotlin의 다른 곳과 마찬가지로 구문상의 의미가 없습니다. 접근자는 접근자가 접근 할 수있는 유일한 법적 장소가 속성 선언 바로 뒤에 있기 때문에 어떤 접근자가 어떤 속성에 속하는지 알 수 있습니다 (최대 하나의 getter와 하나의 setter가있을 수 있음) 선언. 그러나 접근 자의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a438c4c204700f052b62784ad094f3d42692c3e5" translate="yes" xml:space="preserve">
          <source>The inheritors are used in &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; to describe the contract of a function.</source>
          <target state="translated">상속자는 함수의 계약을 설명하기 위해 &lt;a href=&quot;-contract-builder/index&quot;&gt;ContractBuilder&lt;/a&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="927c0a69730a98787dc84c53359365aef174d24b" translate="yes" xml:space="preserve">
          <source>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer (or from the getter return type, as shown below).</source>
          <target state="translated">이니셜 라이저, 게터 및 세터는 선택 사항입니다. 이니셜 라이저 (또는 아래에 표시된 게터 리턴 유형)에서 유추 할 수있는 경우 특성 유형은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="df4b9318a341c1f296940189b67832418073c297" translate="yes" xml:space="preserve">
          <source>The inserted characters go in same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; character array, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">삽입 된 문자 는 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; 에서 시작 하여 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;값&lt;/a&gt; 문자 배열 과 동일한 순서로 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="1d6b868449af039ece3f79e19a7f1bdef4bb1a01" translate="yes" xml:space="preserve">
          <source>The inserted characters go in the same order as in the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; character sequence, starting at &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">삽입 된 문자 는 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; 에서 시작 하는 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;값&lt;/a&gt; 문자 시퀀스 와 동일한 순서로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="73ab217fa7b8d452fbb508f24860b5983aed819b" translate="yes" xml:space="preserve">
          <source>The insertion order is preserved by maintaining a doubly-linked list of all of its entries.</source>
          <target state="translated">삽입 순서는 모든 항목의 이중 연결 목록을 유지하여 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ac540734122ad9d9f148278a049a69e4049649" translate="yes" xml:space="preserve">
          <source>The instance of the object declaration, or &lt;code&gt;null&lt;/code&gt; if this class is not an object declaration.</source>
          <target state="translated">객체 선언의 인스턴스. 이 클래스가 객체 선언이 아닌 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e1a88c47519272f4d061661530035978afeff04" translate="yes" xml:space="preserve">
          <source>The interoperability tool analyses C headers and produces a &quot;natural&quot; mapping of the types, functions, and constants into the Kotlin world. The generated stubs can be imported into an IDE for the purpose of code completion and navigation.</source>
          <target state="translated">상호 운용성 도구는 C 헤더를 분석하고 유형, 함수 및 상수를 Kotlin 세계에 &quot;자연스럽게&quot;매핑합니다. 생성 된 스텁은 코드 완성 및 탐색을 위해 IDE로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78163206f8e53ce50e1eec86f00b2814cc4b80d9" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. However, annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. If the annotation processors used in the build cannot be properly cached, it is possible to disable caching for kapt entirely by adding the following lines to the build script, in order to avoid false-positive cache hits for the kapt tasks:</source>
          <target state="translated">kapt 주석 처리 작업은 기본적으로 &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle&lt;/a&gt; 에 캐시됩니다 . 그러나 주석 프로세서는 작업 입력을 출력으로 변환 할 필요가없는 임의의 코드를 실행하고 Gradle 등에서 추적하지 않는 파일에 액세스하고 수정할 수 있습니다. 빌드에 사용 된 주석 프로세서를 제대로 캐시 할 수없는 경우 다음을 수행 할 수 있습니다. kapt 태스크에 대해 거짓 긍정 캐시 적중을 방지하기 위해 빌드 스크립트에 다음 행을 추가하여 kapt에 대한 캐싱을 완전히 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="0c34ac28f0b47dc2a95569e5a72bbe09867d14d5" translate="yes" xml:space="preserve">
          <source>The kapt annotation processing tasks are not &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;cached in Gradle&lt;/a&gt; by default. Annotation processors run arbitrary code that may not necessarily transform the task inputs into the outputs, might access and modify the files that are not tracked by Gradle etc. To enable caching for kapt anyway, add the following lines to the build script:</source>
          <target state="translated">kapt 주석 처리 작업은 기본적으로 &lt;a href=&quot;https://guides.gradle.org/using-build-cache/&quot;&gt;Gradle&lt;/a&gt; 에 캐시 되지 않습니다 . 어노테이션 프로세서는 태스크 입력을 출력으로 변환 할 필요가없는 임의의 코드를 실행하고, Gradle 등에서 추적하지 않는 파일에 액세스하고 수정할 수 있습니다. 어쨌든 kapt에 대한 캐싱을 사용하려면 빌드 스크립트에 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0d265db62daefe24281a53daa642fa0260c64977" translate="yes" xml:space="preserve">
          <source>The key benefit of using sealed classes comes into play when you use them in a &lt;a href=&quot;control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt;. If it's possible to verify that the statement covers all cases, you don't need to add an &lt;code&gt;else&lt;/code&gt; clause to the statement. However, this works only if you use &lt;code&gt;when&lt;/code&gt; as an expression (using the result) and not as a statement.</source>
          <target state="translated">봉인 된 클래스를 사용하는 경우의 주요 이점은 &lt;a href=&quot;control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt; 에서 사용할 때 사용됩니다 . 명령문이 모든 경우에 적용되는지 확인할 수 있으면 &lt;code&gt;else&lt;/code&gt; 절을 명령문 에 추가 할 필요가 없습니다 . 그러나 이것은 명령문이 아닌 표현식 (결과 사용)으로 사용할 &lt;code&gt;when&lt;/code&gt; 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="60878e19d1626a7113513294279d9306ebdfd3af" translate="yes" xml:space="preserve">
          <source>The key differences to the old model are:</source>
          <target state="translated">이전 모델과의 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba83743a7b4886ce5d922ef71ed4bc654a53eba4" translate="yes" xml:space="preserve">
          <source>The key for each element is provided by the &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; function.</source>
          <target state="translated">각 요소의 키는 &lt;a href=&quot;-grouping/key-of&quot;&gt;Grouping.keyOf&lt;/a&gt; 함수에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7780b4923a988af8ea0601856ae08a944187203" translate="yes" xml:space="preserve">
          <source>The key new feature in Kotlin 1.1 is &lt;em&gt;coroutines&lt;/em&gt;, bringing the support of &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt; and similar programming patterns. The key feature of Kotlin's design is that the implementation of coroutine execution is part of the libraries, not the language, so you aren't bound to any specific programming paradigm or concurrency library.</source>
          <target state="translated">Kotlin 1.1의 주요 새로운 기능은 코 &lt;em&gt;루틴&lt;/em&gt; 으로 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; , &lt;code&gt;yield&lt;/code&gt; 및 유사한 프로그래밍 패턴을 지원합니다. 코 틀린 디자인의 주요 특징은 코 루틴 실행의 구현이 언어가 아닌 라이브러리의 일부이므로 특정 프로그래밍 패러다임 또는 동시성 라이브러리에 구속되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="255ddce16ff2d3386fde18744e92b0919a0c3dcd" translate="yes" xml:space="preserve">
          <source>The key that defines &lt;em&gt;the&lt;/em&gt; context interceptor.</source>
          <target state="translated">컨텍스트 인터셉터 를 정의 &lt;em&gt;하는&lt;/em&gt; 키입니다 .</target>
        </trans-unit>
        <trans-unit id="f78236335bddfda90f254cf18135e3e283c652aa" translate="yes" xml:space="preserve">
          <source>The key to understanding why this trick works is rather simple: if you can only &lt;strong&gt;take&lt;/strong&gt; items from a collection, then using a collection of &lt;code&gt;String&lt;/code&gt;s and reading &lt;code&gt;Object&lt;/code&gt;s from it is fine. Conversely, if you can only &lt;em&gt;put&lt;/em&gt; items into the collection, it's OK to take a collection of &lt;code&gt;Object&lt;/code&gt;s and put &lt;code&gt;String&lt;/code&gt;s into it: in Java we have &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; a &lt;strong&gt;supertype&lt;/strong&gt; of &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 트릭이 작동하는 이유를 이해하는 열쇠는 다소 간단합니다. 컬렉션 에서만 항목을 &lt;strong&gt;가져올&lt;/strong&gt; 수 있다면 &lt;code&gt;String&lt;/code&gt; 컬렉션을 사용하고 &lt;code&gt;Object&lt;/code&gt; 에서 객체를 읽는 것이 좋습니다. 만 할 수 있다면 반대로 &lt;em&gt;넣어&lt;/em&gt; 컬렉션에 항목을, 그것의 확인 모음 취할 &lt;code&gt;Object&lt;/code&gt; 들 넣어 &lt;code&gt;String&lt;/code&gt; 그것으로들 : 자바 우리가 가지고있는 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; &lt;strong&gt;슈퍼 타입&lt;/strong&gt; 의 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e72d25f147746520f953f90cd2e72b99d7c03c99" translate="yes" xml:space="preserve">
          <source>The kind of JS module generated by the compiler</source>
          <target state="translated">컴파일러가 생성 한 JS 모듈의 종류</target>
        </trans-unit>
        <trans-unit id="d05fefa144a9bfaff0069cb495aef5fbbe9dc415" translate="yes" xml:space="preserve">
          <source>The language settings are checked for consistency between source sets depending on each other. Namely, if &lt;code&gt;foo&lt;/code&gt; depends on &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">언어 설정은 서로에 따라 소스 세트 간의 일관성을 검사합니다. 즉, &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;bar&lt;/code&gt; 에 의존하는 경우 :</target>
        </trans-unit>
        <trans-unit id="7ae80735e57bee13b52032eac31a1a1787272a8f" translate="yes" xml:space="preserve">
          <source>The language settings for a source set can be specified as follows:</source>
          <target state="translated">소스 세트의 언어 설정은 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbaea25f697b924abdcdee8361823761cf7fe6eb" translate="yes" xml:space="preserve">
          <source>The language used to document Kotlin code (the equivalent of Java's JavaDoc) is called &lt;strong&gt;KDoc&lt;/strong&gt;. In its essence, KDoc combines JavaDoc's syntax for block tags (extended to support Kotlin's specific constructs) and Markdown for inline markup.</source>
          <target state="translated">Kotlin 코드 (Java의 JavaDoc에 해당)를 문서화하는 데 사용되는 언어를 &lt;strong&gt;KDoc&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 본질적으로 KDoc은 블록 태그에 대한 JavaDoc의 구문 (Kotlin의 특정 구성을 지원하도록 확장)과 인라인 마크 업에 대한 Markdown을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="6bd524ff724eae23548f42d94d576b7a82d79f24" translate="yes" xml:space="preserve">
          <source>The last element in the progression.</source>
          <target state="translated">진행의 마지막 요소.</target>
        </trans-unit>
        <trans-unit id="5ac343906b9635efc6bc3ea707e0886b7e34f40a" translate="yes" xml:space="preserve">
          <source>The last element of the progression is calculated to find the maximum value not greater than the end value for a positive step or the minimum value not less than the end value for a negative step such that &lt;code&gt;(last - first) % step == 0&lt;/code&gt;.</source>
          <target state="translated">진행의 마지막 요소는 음 단계되도록 덜 최종 값 이상의 포지티브 단계 또는 최소 값의 최종 값보다 크지 않은 최대 값을 찾기 위해 계산 &lt;code&gt;(last - first) % step == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01b3b5a6efe68e4716a891433d6bbbed0351ca8d" translate="yes" xml:space="preserve">
          <source>The last line is invoking the function itself and passing as argument &lt;code&gt;kotlin&lt;/code&gt;, which refers to the standard library. This can be obtained in one of two ways:</source>
          <target state="translated">마지막 줄은 함수 자체를 호출 하고 표준 라이브러리를 참조하는 &lt;code&gt;kotlin&lt;/code&gt; 인수로 전달 합니다. 이것은 두 가지 방법 중 하나로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="538d53f2bc70104b650857f7bb5ca32765c9300b" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 목록의 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.collections%24chunked%28kotlin.collections.Iterable%28%28kotlin.collections.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff4c16017113383cfa2553bc4b666ff8af31f35a" translate="yes" xml:space="preserve">
          <source>The last list in the resulting list may have less elements than the given &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 목록의 마지막 목록에는 주어진 &lt;a href=&quot;chunked#kotlin.collections%24chunked(kotlin.collections.Iterable((kotlin.collections.chunked.T)),%20kotlin.Int)/size&quot;&gt;크기&lt;/a&gt; 보다 적은 요소가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df81eba7c4b794145b48baa6539e2f2979a8d58f" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 시퀀스의 마지막 목록은 주어진 &lt;a href=&quot;chunked#kotlin.sequences%24chunked%28kotlin.sequences.Sequence%28%28kotlin.sequences.chunked.T%29%29%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 요소를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4ef2ba5891ebf7ffa1b88944ac0282efb5fecf2" translate="yes" xml:space="preserve">
          <source>The last list in the resulting sequence may have less elements than the given &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 시퀀스의 마지막 목록에는 주어진 &lt;a href=&quot;chunked#kotlin.sequences%24chunked(kotlin.sequences.Sequence((kotlin.sequences.chunked.T)),%20kotlin.Int)/size&quot;&gt;크기&lt;/a&gt; 보다 적은 요소가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19dcc0ec6fdfe1941cf804b7c1eaf5c5297a4c82" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 목록의 마지막 문자열은 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01c80e09f206886b89d00be2fa9ab43305c32874" translate="yes" xml:space="preserve">
          <source>The last string in the resulting list may have less characters than the given &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 목록의 마지막 문자열은 주어진 &lt;a href=&quot;chunked#kotlin.text%24chunked(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5264566740d059c5fcc7247f9b4782bf04dc775d" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 시퀀스의 마지막 문자열은 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence%28kotlin.CharSequence%2C+kotlin.Int%29%2Fsize&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ebb5e898a1a9ea0d92ef57e7df9d364782eae89" translate="yes" xml:space="preserve">
          <source>The last string in the resulting sequence may have less characters than the given &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;size&lt;/a&gt;.</source>
          <target state="translated">결과 시퀀스의 마지막 문자열은 주어진 &lt;a href=&quot;chunked-sequence#kotlin.text%24chunkedSequence(kotlin.CharSequence,%20kotlin.Int)/size&quot;&gt;크기&lt;/a&gt; 보다 적은 문자를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34c76d76568703e916e3116e8326427af7debc51" translate="yes" xml:space="preserve">
          <source>The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.</source>
          <target state="translated">lastIndex는 다음 일치를 시작할 인덱스를 지정하는 정규식의 읽기 / 쓰기 정수 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9d0eba273c11a973f53f6330c745e78d9f5b9345" translate="yes" xml:space="preserve">
          <source>The latter is called &lt;strong&gt;contravariance&lt;/strong&gt;, and you can only call methods that take String as an argument on &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (e.g., you can call &lt;code&gt;add(String)&lt;/code&gt; or &lt;code&gt;set(int, String)&lt;/code&gt;), while if you call something that returns &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, you don't get a &lt;code&gt;String&lt;/code&gt;, but an &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">후자를 &quot; &lt;strong&gt;contravariance&quot;&lt;/strong&gt; 라고하며 , String을 인수로 사용하는 메소드 만 &lt;code&gt;List&amp;lt;? super String&amp;gt;&lt;/code&gt; (예를 들어, &lt;code&gt;add(String)&lt;/code&gt; 또는 &lt;code&gt;set(int, String)&lt;/code&gt; 을 호출 할 수 있음 ) 반면 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 를 반환하는 것을 호출 하면 &lt;code&gt;String&lt;/code&gt; 이 아니라 &lt;code&gt;Object&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="86eeb4f1664e3df8b781582839802549edf89327" translate="yes" xml:space="preserve">
          <source>The layout of a Kotlin multiplatform project is constructed out of the following building blocks:</source>
          <target state="translated">Kotlin 멀티 플랫폼 프로젝트의 레이아웃은 다음 빌딩 블록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dc4b69a6e38939f4509626db77c33dd8c679086f" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4f0f34d38c4a4771a59f6d35fcaf5f32f9d5a113" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="db7d64a40964cbcc91041fe9c6abd3a6f883ba7c" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="96755580626f22c0780c08fafc24e52c9efd9ea9" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="805e1d578ae5895787cd7c80c9a6f84d9875cbdf" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 16 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e2d7f90749fa8a275417e31e2a951b621f7bdd7e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 16 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 16 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="382a5532019e821cafc1c9ca21454b43f1f91a60" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Short&lt;/code&gt; value, whereas the most significant 48 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;Short&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="98d7b8a419dc2e1a1e55aeb89fee5123de4a6b5e" translate="yes" xml:space="preserve">
          <source>The least significant 16 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UShort&lt;/code&gt; value, whereas the most significant 48 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트는 이 &lt;code&gt;UShort&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 48 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="b511f5bcb1b166f6a21672ecd3a364142d43ef6e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;Int&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="8552752324805690a09e930c3347d0b3b76fb45a" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;UInt&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="13513c5d8d4b778bf7d2d02871ec67b342f92eb3" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Int&lt;/code&gt; value, whereas the most significant 32 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;Int&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="098196788f072e1b90241673f7cd1c8d4ddc487e" translate="yes" xml:space="preserve">
          <source>The least significant 32 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UInt&lt;/code&gt; value, whereas the most significant 32 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트는 이 &lt;code&gt;UInt&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 32 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1e95934eab4e475329950f2eb8e7a3a03516b89c" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Char&lt;/code&gt; code are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1ccfa3d5b3f0d4c2cadb8ddee394a5e74b7f3fb0" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="682e9bb2df532a75f2a73fb4a8682c3fe53c3f6f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Int&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="740b8988c3d828c3ba10680439510f32d7f08bd4" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="f2986e4bdb9623eb7b0be806904f6c45008e66a1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Long&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="da411f42fa8b3bbe7fd6d9ed1a7edbedcead90c8" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="dbca88370b969aea0b645fa67d458151bf144ef3" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;Short&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="0705f7403c9d4340ca48e777c703d467c71d6c8f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 24 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e35a3b71a791931b3596ab2bd1edb46d9365dda1" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UInt&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 24 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 24 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="fbe359060636f5088c741be0b327d7d46254bbcd" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 56 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="9d9c37d2ab226e9ed58e44937eac9a5c2afe8841" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;ULong&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 56 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 56 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="573a497b93bab09d8947aa89f58fd5f36237628f" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;Byte&lt;/code&gt; value, whereas the most significant 8 bits are filled with the sign bit of this value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;Byte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는이 값의 부호 비트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="d49f6edce25857427bee05e2a6463c8f203f6aab" translate="yes" xml:space="preserve">
          <source>The least significant 8 bits of the resulting &lt;code&gt;UShort&lt;/code&gt; value are the same as the bits of this &lt;code&gt;UByte&lt;/code&gt; value, whereas the most significant 8 bits are filled with zeros.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트는 이 &lt;code&gt;UByte&lt;/code&gt; 값 의 비트와 동일 하지만 최상위 8 비트는 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1511f8695777128c7450dc6f9cc52fbdbfc512c7" translate="yes" xml:space="preserve">
          <source>The less obvious cases that belong to the &quot;grey area&quot; include handling corner cases differently, throwing an exception of a different type than before, changing behavior observable only through reflection, changes in undocumented/undefined behavior, renaming binary artifacts, etc. Sometimes such changes are very important and affect migration experience dramatically, sometimes they are insignificant.</source>
          <target state="translated">&quot;회색 영역&quot;에 속하는 덜 명백한 경우에는 코너 케이스를 다르게 처리하고, 이전과 다른 유형의 예외를 던지거나, 리플렉션을 통해서만 관찰 가능한 동작 변경, 문서화되지 않은 / 정의되지 않은 동작의 변경, 이진 아티팩트 이름 바꾸기 등이 있습니다. 변경은 매우 중요하며 마이그레이션 환경에 큰 영향을 미치며 때로는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd894256ff253457e13d98fae75ab576481e876c" translate="yes" xml:space="preserve">
          <source>The library format</source>
          <target state="translated">라이브러리 형식</target>
        </trans-unit>
        <trans-unit id="c48fdef888f67d5a66f513cae58be8d045c058e0" translate="yes" xml:space="preserve">
          <source>The library has been created in the current directory:</source>
          <target state="translated">라이브러리는 현재 디렉토리에 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="cff219119dad603b83453d082db1d0aa5cce3800" translate="yes" xml:space="preserve">
          <source>The lines returned do not include terminating line separators.</source>
          <target state="translated">반환 된 줄에는 종료 줄 구분 기호가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ec3834f8762f850d976d74a3444d0d24d17d417" translate="yes" xml:space="preserve">
          <source>The list is expected to be sorted so that the signs of the &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;comparison&lt;/a&gt; function's return values ascend on the list elements, i.e. negative values come before zero and zeroes come before positive values. Otherwise, the result is undefined.</source>
          <target state="translated">목록은 &lt;a href=&quot;binary-search#kotlin.collections%24binarySearch(kotlin.collections.List((kotlin.collections.binarySearch.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Function1((kotlin.collections.binarySearch.T,%20kotlin.Int)))/comparison&quot;&gt;비교&lt;/a&gt; 함수의 반환 값의 부호가 목록 요소에서 오름차순 으로 정렬 됩니다. 즉, 음수 값은 0 이전에, 0은 양수 값 앞에 오도록합니다. 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecc031fda17a51efc3a0c6e7f3483a236bf69e52" translate="yes" xml:space="preserve">
          <source>The list of immediate supertypes of this class, in the order they are listed in the source code.</source>
          <target state="translated">이 클래스의 직속 슈퍼 타입 목록은 소스 코드에 나열된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="37daaa29c5ab04c74e60f96a3c80a72671943c78" translate="yes" xml:space="preserve">
          <source>The list of possible time measurement units, in which a duration can be expressed.</source>
          <target state="translated">기간을 표현할 수있는 가능한 시간 측정 단위 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e7cfcc4e5ebb2fa63d0c44bdcf02351c03c9e8d4" translate="yes" xml:space="preserve">
          <source>The list of the immediate subclasses if this class is a sealed class, or an empty list otherwise.</source>
          <target state="translated">이 클래스가 봉인 된 클래스 인 경우 직접 서브 클래스의 목록이거나 그렇지 않은 경우 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="af028a3423820dfb61266857373312e6321072a9" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this callable.</source>
          <target state="translated">이 호출 가능의 유형 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3983145b3c17efebd4ca1c3dd6839e784929aaa8" translate="yes" xml:space="preserve">
          <source>The list of type parameters of this class. This list does &lt;em&gt;not&lt;/em&gt; include type parameters of outer classes.</source>
          <target state="translated">이 클래스의 타입 파라미터의리스트입니다. 이 목록에는 외부 클래스의 유형 매개 변수가 포함 되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd6f3d5d8e8c83c9d11a7ed45e7362cc872b1a5" translate="yes" xml:space="preserve">
          <source>The locking in this example is fine-grained, so it pays the price. However, it is a good choice for some situations where you absolutely must modify some shared state periodically, but there is no natural thread that this state is confined to.</source>
          <target state="translated">이 예제의 잠금은 세밀하게 구성되어 있으므로 가격을 지불합니다. 그러나 일부 공유 상태를 주기적으로 절대적으로 수정해야하지만이 상태가 제한되는 자연스러운 스레드는없는 일부 상황에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="993a245cc6dcc5a6d2356a7f7d1259d26b6ea137" translate="yes" xml:space="preserve">
          <source>The loop variable(s), if any, must be declared outside of the &lt;code&gt;while&lt;/code&gt; loop, and are therefore available for inspection afterwards, at which point they will contain the value(s) that made the loop condition false.</source>
          <target state="translated">루프 변수 (있는 경우)는 &lt;code&gt;while&lt;/code&gt; 루프 외부에서 선언해야하며 이후에 검사에 사용할 수 있으며이 시점에서 루프 조건을 거짓으로 만든 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f10abe77e5b16e3b7aa73cabd19e9ac919e5868d" translate="yes" xml:space="preserve">
          <source>The main code is straightforward:</source>
          <target state="translated">기본 코드는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="21b17843ae6bab256e1f2d7c26e40966048480db" translate="yes" xml:space="preserve">
          <source>The main code starts and connects the whole pipeline:</source>
          <target state="translated">기본 코드는 전체 파이프 라인을 시작하고 연결합니다.</target>
        </trans-unit>
        <trans-unit id="1415e580114f63d99c0e8622a1104c3c733c68ba" translate="yes" xml:space="preserve">
          <source>The main disadvantage of changing the code style in an existing project is that the blame/annotate VCS feature will point to irrelevant commits more often. While each VCS has some kind of way to deal with this problem (&lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;Annotate Previous Revision&quot;&lt;/a&gt; can be used in IntelliJ IDEA), it's important to decide if a new style is worth all the effort. The practice of separating reformatting commits from meaningful changes can help a lot with later investigations.</source>
          <target state="translated">기존 프로젝트에서 코드 스타일을 변경하는 주된 단점은 VCS 기능에 대한 책임 / 주석이 관련없는 커밋을 더 자주 지적한다는 것입니다. 각 VCS에는이 문제를 처리 할 수있는 방법이 있지만 ( &lt;a href=&quot;https://www.jetbrains.com/help/idea/investigate-changes.html&quot;&gt;&quot;&lt;/a&gt; IntelliJ IDEA에서 &quot;주석 수정 주석 &quot;을 사용할 수 있음) 새로운 스타일이 모든 노력에 가치가 있는지 여부를 결정하는 것이 중요합니다. 재 포맷 커밋을 의미있는 변경과 분리하면 나중에 조사 할 때 많은 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0255c27371bb337a0275ae99c66e66aefbb2cf2" translate="yes" xml:space="preserve">
          <source>The main function just launches a coroutine to print results of &lt;code&gt;switchMapDeferreds&lt;/code&gt; and sends some test data to it:</source>
          <target state="translated">메인 함수는 코 루틴을 시작하여 &lt;code&gt;switchMapDeferreds&lt;/code&gt; 의 결과를 인쇄 하고 테스트 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c0a11bc5688f898de97456dfcb543cf05d79b8a1" translate="yes" xml:space="preserve">
          <source>The main thread (that runs the &lt;code&gt;main()&lt;/code&gt; function) must wait until our coroutine completes, otherwise the program ends before &lt;code&gt;Hello&lt;/code&gt; is printed.</source>
          <target state="translated">메인 스레드 ( &lt;code&gt;main()&lt;/code&gt; 함수 를 실행하는 )는 코 루틴이 완료 될 때까지 기다려야합니다. 그렇지 않으면 &lt;code&gt;Hello&lt;/code&gt; 가 인쇄 되기 전에 프로그램이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c831066dd6087f2516b15d01bfb68e39b9bcf05" translate="yes" xml:space="preserve">
          <source>The maximum number of substrings to return. Zero by default means no limit is set.</source>
          <target state="translated">반환 할 최대 부분 문자열 수입니다. 기본적으로 0은 제한이 설정되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4e76f165176d7e28c6b59c285a7ee8af5a71fc72" translate="yes" xml:space="preserve">
          <source>The maximum radix available for conversion to and from strings.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최대 기수입니다.</target>
        </trans-unit>
        <trans-unit id="38f9246447f2685e9dd36b4c8d7e0bf7ff2fb023" translate="yes" xml:space="preserve">
          <source>The maximum value in the range (inclusive).</source>
          <target state="translated">범위 내 최대 값입니다 (포함).</target>
        </trans-unit>
        <trans-unit id="cc9397547e8b9fc8e2131246f8cce9b80a975147" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">유니 코드 코드 포인트의 최대 값 코 틀린 / 네이티브 전용.</target>
        </trans-unit>
        <trans-unit id="af496c450bf387c2b7d7ee0dc32c766b9f1b66c1" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">유니 코드 상위 대리 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="68f9d655dde4db0c3b71fc09c97d0f87e103d52b" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">유니 코드 낮은 대리 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="0cb5887284a08dd04202e0863d133d8ed431392d" translate="yes" xml:space="preserve">
          <source>The maximum value of a Unicode surrogate code unit.</source>
          <target state="translated">유니 코드 대리 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="ea009c16dc0030623058aff99eec7f7c7973366c" translate="yes" xml:space="preserve">
          <source>The maximum value of a character code unit.</source>
          <target state="translated">문자 코드 단위의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="dce9edb79f3aca5450e6dfb555e231182e2c5340" translate="yes" xml:space="preserve">
          <source>The meaning of a visibility modifier depends on whether it's applied to a top-level declaration or to a declaration inside a class. For top-level declarations:</source>
          <target state="translated">가시성 수정 자의 의미는 최상위 선언에 적용되는지 또는 클래스 내부의 선언에 적용되는지에 따라 다릅니다. 최상위 선언의 경우 :</target>
        </trans-unit>
        <trans-unit id="2f5715d8d7aab68289e0b8a47e46f1764f30f76e" translate="yes" xml:space="preserve">
          <source>The message explaining the deprecation and recommending an alternative API to use.</source>
          <target state="translated">지원 중단을 설명하고 사용할 대체 API를 권장하는 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="1d7af1b2ed876762350f57904a38e801662ebbf4" translate="yes" xml:space="preserve">
          <source>The meta-runner for Kotlin is available on &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub&lt;/a&gt;. If using TeamCity 9 or above, we can now simply import that meta-runner from the TeamCity user interface</source>
          <target state="translated">Kotlin의 메타 러너는 &lt;a href=&quot;https://github.com/jonnyzzz/Kotlin.TeamCity&quot;&gt;GitHub에서&lt;/a&gt; 사용할 수 있습니다 . TeamCity 9 이상을 사용하는 경우 TeamCity 사용자 인터페이스에서 해당 메타 러너를 간단히 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbb5d37dc4d790a9dba2a103cd7fc2ea1af9db2f" translate="yes" xml:space="preserve">
          <source>The minimum radix available for conversion to and from strings.</source>
          <target state="translated">문자열로 /에서 변환 할 수있는 최소 기수입니다.</target>
        </trans-unit>
        <trans-unit id="3eb6b21e0f2a2eb117e5ca90292e6def24614862" translate="yes" xml:space="preserve">
          <source>The minimum value in the range.</source>
          <target state="translated">범위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="480df25e783a3ddb0c5eabcc07d40b9a21fd328e" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode code point. Kotlin/Native specific.</source>
          <target state="translated">유니 코드 코드 포인트의 최소값입니다. 코 틀린 / 네이티브 전용.</target>
        </trans-unit>
        <trans-unit id="c11b4b4a4cfd50662da801109ced72e7ef8083ad" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode high-surrogate code unit.</source>
          <target state="translated">유니 코드 상위 대리 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="7a57e546e08f3cd66a3ed8cebd57f37a4137a78d" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode low-surrogate code unit.</source>
          <target state="translated">유니 코드 낮은 대리 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="47b523f1a39e9c9f7bda17fc85b300ab3e0da311" translate="yes" xml:space="preserve">
          <source>The minimum value of a Unicode surrogate code unit.</source>
          <target state="translated">유니 코드 대리 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="e3fc4d1ab4988e695801daf57bd33d3f470c3668" translate="yes" xml:space="preserve">
          <source>The minimum value of a character code unit.</source>
          <target state="translated">문자 코드 단위의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="d80a9d6c0ddeb1216ece2df4cc2d7d63382408e4" translate="yes" xml:space="preserve">
          <source>The minimum value of a supplementary code point, &lt;code&gt;\u0x10000&lt;/code&gt;. Kotlin/Native specific.</source>
          <target state="translated">보조 코드 포인트의 최소값, &lt;code&gt;\u0x10000&lt;/code&gt; . 코 틀린 / 네이티브 전용.</target>
        </trans-unit>
        <trans-unit id="39042f06ab046e1bfc15de4ecf52d5a28eec3294" translate="yes" xml:space="preserve">
          <source>The modifier can be used on &lt;code&gt;var&lt;/code&gt; properties declared inside the body of a class (not in the primary constructor, and only when the property does not have a custom getter or setter) and, since Kotlin 1.2, for top-level properties and local variables. The type of the property or variable must be non-null, and it must not be a primitive type.</source>
          <target state="translated">이 수정자는 클래스 본문 내부에 선언 된 &lt;code&gt;var&lt;/code&gt; 속성 (기본 생성자가 아닌 속성에 사용자 지정 getter 또는 setter가없는 경우에만) 및 Kotlin 1.2부터 최상위 속성 및 로컬 변수에 사용할 수 있습니다. . 특성 또는 변수의 유형은 널이 아니어야하며 기본 유형이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb919d11f95900a1425b0a32e4257389d1fc669f" translate="yes" xml:space="preserve">
          <source>The most &quot;natural&quot; placement is in the object &lt;code&gt;nativeHeap&lt;/code&gt;. It corresponds to allocating native memory with &lt;code&gt;malloc&lt;/code&gt; and provides an additional &lt;code&gt;.free()&lt;/code&gt; operation to free allocated memory:</source>
          <target state="translated">가장 자연스러운 위치는 &lt;code&gt;nativeHeap&lt;/code&gt; 객체에 있습니다 . &lt;code&gt;malloc&lt;/code&gt; 에 기본 메모리를 할당하는 것에 해당하며 할당 된 메모리를 해제하기 위해 추가 &lt;code&gt;.free()&lt;/code&gt; 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d14eba091c54d0c22e0562741651e98077e032c" translate="yes" xml:space="preserve">
          <source>The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a statically known Kotlin class, you can use the &lt;em&gt;class literal&lt;/em&gt; syntax:</source>
          <target state="translated">가장 기본적인 리플렉션 기능은 Kotlin 클래스에 대한 런타임 참조를 얻는 것입니다. 정적으로 알려진 Kotlin 클래스에 대한 참조를 얻으려면 &lt;em&gt;클래스 리터럴&lt;/em&gt; 구문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae0dbb4ff6b4fc6cc9b694111494978916ff6daf" translate="yes" xml:space="preserve">
          <source>The most basic usage of enum classes is implementing type-safe enums:</source>
          <target state="translated">열거 형 클래스의 가장 기본적인 사용법은 형식 안전 열거 형을 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="564a165b2993e039b868e117559d08b7cdc98e88" translate="yes" xml:space="preserve">
          <source>The most common kind of properties simply reads from (and maybe writes to) a backing field. On the other hand, with custom getters and setters one can implement any behaviour of a property. Somewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values, reading from a map by a given key, accessing a database, notifying listener on access, etc.</source>
          <target state="translated">가장 일반적인 종류의 속성은 단순히 지원 필드에서 읽거나 쓸 수 있습니다. 반면에 커스텀 게터와 세터를 사용하면 속성의 모든 동작을 구현할 수 있습니다. 그 사이 어딘가에는 속성이 작동하는 방식에 대한 일반적인 패턴이 있습니다. 몇 가지 예 : 게으른 값, 주어진 키로 맵에서 읽기, 데이터베이스에 액세스, 리스너에게 액세스에 알리기 등</target>
        </trans-unit>
        <trans-unit id="d5cbdfb8e81de653dd867a75b87523ff1d242141" translate="yes" xml:space="preserve">
          <source>The most common type of constraint is an &lt;strong&gt;upper bound&lt;/strong&gt; that corresponds to Java's &lt;em&gt;extends&lt;/em&gt; keyword:</source>
          <target state="translated">가장 일반적인 제약 유형은 Java의 &lt;em&gt;extends&lt;/em&gt; 키워드에 해당 하는 &lt;strong&gt;상한&lt;/strong&gt; 입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="368d747cfcb5fb4e353c85a7469dfacbb5453495" translate="yes" xml:space="preserve">
          <source>The most common way to create a collection is with the standard library functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt;&lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt;&lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt;&lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt;&lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. If you provide a comma-separated list of collection elements as arguments, the compiler detects the element type automatically. When creating empty collections, specify the type explicitly.</source>
          <target state="translated">컬렉션을 만드는 가장 일반적인 방법은 표준 라이브러리 함수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/list-of&quot;&gt; &lt;code&gt;listOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/set-of&quot;&gt; &lt;code&gt;setOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-list-of&quot;&gt; &lt;code&gt;mutableListOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-set-of&quot;&gt; &lt;code&gt;mutableSetOf&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt; 입니다. 쉼표로 구분 된 컬렉션 요소 목록을 인수로 제공하면 컴파일러는 요소 유형을 자동으로 감지합니다. 빈 모음을 만들 때는 유형을 명시 적으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b853cf446ccffab0ecfd031a6ec9cd9f7555703c" translate="yes" xml:space="preserve">
          <source>The most notable change is in the continuation indentation policy. There's a nice idea to use the double indent for showing that a multi-line expression hasn't ended on the previous line. This is a very simple and general rule, but several Kotlin constructions look a bit awkward when they are formatted this way. In Kotlin Coding Conventions it's recommended to use a single indent in cases where the long continuation indent has been forced before</source>
          <target state="translated">가장 눈에 띄는 변화는 연속 들여 쓰기 정책입니다. 여러 줄로 된 표현식이 이전 줄에서 끝나지 않았 음을 보여주기 위해 이중 들여 쓰기를 사용하는 것이 좋습니다. 이것은 매우 간단하고 일반적인 규칙이지만 여러 Kotlin 구조는 이러한 방식으로 형식이 지정되면 약간 어색해 보입니다. Kotlin Coding Conventions에서는 이전에 긴 연속 들여 쓰기를 강요 한 경우 단일 들여 쓰기를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8c58687aab400a3400843ec6513c56c72bdb694" translate="yes" xml:space="preserve">
          <source>The most obvious practical reason to cancel execution of a coroutine is because its execution time has exceeded some timeout. While you can manually track the reference to the corresponding &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; and launch a separate coroutine to cancel the tracked one after delay, there is a ready to use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; function that does it. Look at the following example:</source>
          <target state="translated">코 루틴 실행을 취소하는 가장 확실한 실제 이유는 실행 시간이 시간 초과를 초과했기 때문입니다. 해당 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업에&lt;/a&gt; 대한 참조를 수동으로 추적하고 별도의 코 루틴을 실행하여 지연된 후 추적 된 것을 취소 할 수는 있지만이를 수행 할 수있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;with timeout&lt;/a&gt; 기능이 있습니다. 다음 예를보십시오.</target>
        </trans-unit>
        <trans-unit id="d08f23af81c5dad7c4dca8d8027b602b0ab864b4" translate="yes" xml:space="preserve">
          <source>The most peculiar feature of &lt;code&gt;dynamic&lt;/code&gt; is that we are allowed to call &lt;strong&gt;any&lt;/strong&gt; property or function with any parameters on a &lt;code&gt;dynamic&lt;/code&gt; variable:</source>
          <target state="translated">의 가장 독특한 기능 &lt;code&gt;dynamic&lt;/code&gt; 우리가 전화를 허용한다는 것입니다 &lt;strong&gt;어떤&lt;/strong&gt; A의 매개 변수와 속성이나 기능 &lt;code&gt;dynamic&lt;/code&gt; 변수를 :</target>
        </trans-unit>
        <trans-unit id="3c05df95cb8e9db1a4f2601246ac944d5c8bd276" translate="yes" xml:space="preserve">
          <source>The multiplatform projects and multiplatform libraries are discussed in the &lt;a href=&quot;../../reference/multiplatform&quot;&gt;documentation&lt;/a&gt; too.</source>
          <target state="translated">멀티 플랫폼 프로젝트 및 멀티 플랫폼 라이브러리는 &lt;a href=&quot;../../reference/multiplatform&quot;&gt;문서&lt;/a&gt; 에서도 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="6595e5fe1547363b463835d421622aad398ae9cc" translate="yes" xml:space="preserve">
          <source>The name contains the following parts (some of them may be empty):</source>
          <target state="translated">이름에는 다음과 같은 부분이 포함됩니다 (일부는 비어있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="705b141c8de1d697224950845ea5a1b7afb58d54" translate="yes" xml:space="preserve">
          <source>The name of a class is usually a noun or a noun phrase explaining what the class &lt;em&gt;is&lt;/em&gt;: &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;PersonReader&lt;/code&gt;.</source>
          <target state="translated">클래스의 이름은 일반적으로 클래스가 무엇인지 설명하는 명사 또는 명사구 &lt;em&gt;입니다&lt;/em&gt; . &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;PersonReader&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2218455df585d83e3681475aae4631f54b57ae59" translate="yes" xml:space="preserve">
          <source>The name of a class used by itself (not as a qualifier to another name) acts as a reference to the companion object of the class (whether named or not):</source>
          <target state="translated">다른 이름의 한정자가 아닌 자체적으로 사용되는 클래스 이름은 클래스의 동반 객체에 대한 참조 역할을합니다 (이름 지정 여부에 관계없이).</target>
        </trans-unit>
        <trans-unit id="07fe46086dbe239fd375c49037bb37bff00ee0c4" translate="yes" xml:space="preserve">
          <source>The name of a method is usually a verb or a verb phrase saying what the method &lt;em&gt;does&lt;/em&gt;: &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;readPersons&lt;/code&gt;. The name should also suggest if the method is mutating the object or returning a new one. For instance &lt;code&gt;sort&lt;/code&gt; is sorting a collection in place, while &lt;code&gt;sorted&lt;/code&gt; is returning a sorted copy of the collection.</source>
          <target state="translated">방법의 이름은 일반적으로 동사 또는 방법은 무엇을 말하는 동사 구문입니다 &lt;em&gt;않습니다&lt;/em&gt; : &lt;code&gt;close&lt;/code&gt; , &lt;code&gt;readPersons&lt;/code&gt; . 이름은 또한 메소드가 오브젝트를 변경하거나 새 오브젝트를 리턴하는지 제안해야합니다. 예를 들어 &lt;code&gt;sort&lt;/code&gt; 는 컬렉션을 제자리에 정렬하는 반면 &lt;code&gt;sorted&lt;/code&gt; 는 컬렉션의 정렬 된 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07c434a5d635392f2cc52f562338d62b0cd9ae9a" translate="yes" xml:space="preserve">
          <source>The name of the companion object can be omitted, in which case the name &lt;code&gt;Companion&lt;/code&gt; will be used:</source>
          <target state="translated">컴패니언 객체의 이름은 생략 할 수 있으며,이 경우 &lt;code&gt;Companion&lt;/code&gt; 이름 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba35193d0490ae1490a81583acf93693abaa382e" translate="yes" xml:space="preserve">
          <source>The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as &quot;Util&quot; in file names.</source>
          <target state="translated">파일 이름은 파일의 코드가 수행하는 작업을 설명해야합니다. 따라서 파일 이름에 &quot;Util&quot;과 같은 의미없는 단어를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3aecf5d5ce4130f99667312567cec868e0f727ee" translate="yes" xml:space="preserve">
          <source>The name of the generated Java class can be changed using the &lt;code&gt;@JvmName&lt;/code&gt; annotation:</source>
          <target state="translated">생성 된 Java 클래스의 이름은 &lt;code&gt;@JvmName&lt;/code&gt; 주석을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5f1bfd2676f7023c48bd8f681608f158236c940" translate="yes" xml:space="preserve">
          <source>The name of the target (if specified) or the project</source>
          <target state="translated">대상 (지정된 경우) 또는 프로젝트의 이름</target>
        </trans-unit>
        <trans-unit id="cbba3c187c456ab45b79f8154b1183097b8b2546" translate="yes" xml:space="preserve">
          <source>The name of this callable as it was declared in the source code. If the callable has no name, a special invented name is created. Nameless callables include:</source>
          <target state="translated">소스 코드에서 선언 된이 호출 가능의 이름입니다. 호출 가능한 이름이 없으면 특별한 발명 된 이름이 만들어집니다. 이름없는 콜 러블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="688bb052b4a717479ab8663cafb721fc37d4378a" translate="yes" xml:space="preserve">
          <source>The name of this type parameter as it was declared in the source code.</source>
          <target state="translated">소스 코드에서 선언 된이 유형 매개 변수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="25f073ea1bd96da303a6eb4e8f3418d2fb774887" translate="yes" xml:space="preserve">
          <source>The names of Kotlin classes and interfaces are prefixed when imported to Objective-C. The prefix is derived from the framework name.</source>
          <target state="translated">Kotlin 클래스 및 인터페이스 이름은 Objective-C로 가져올 때 접두사가 붙습니다. 접두사는 프레임 워크 이름에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="69675486a4053839ac9b38d8b7b0c3ec7c01c08b" translate="yes" xml:space="preserve">
          <source>The names of the tasks in Android Projects contain the &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;build variant&lt;/a&gt; names and follow the pattern &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt;, for example, &lt;code&gt;compileDebugKotlin&lt;/code&gt;, &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt;.</source>
          <target state="translated">Android 프로젝트의 태스크 이름에는 &lt;a href=&quot;https://developer.android.com/studio/build/build-variants.html&quot;&gt;빌드 변형&lt;/a&gt; 이름이 포함되어 있으며 &lt;code&gt;compile&amp;lt;BuildVariant&amp;gt;Kotlin&lt;/code&gt; 패턴 ( 예 : &lt;code&gt;compileDebugKotlin&lt;/code&gt; , &lt;code&gt;compileReleaseUnitTestKotlin&lt;/code&gt; )을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="b01e22b1729a53f5c38e9b03b567bbe208d510c5" translate="yes" xml:space="preserve">
          <source>The names of these tasks were created from the formula: &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt;, where &lt;code&gt;target name&lt;/code&gt; is the capitalized target name that we specified in the &lt;code&gt;build.gradle.kts&lt;/code&gt;&lt;code&gt;build.gradle&lt;/code&gt; file out of our build, &lt;code&gt;&quot;native&quot;&lt;/code&gt; in our case. Let's run the task in the IDE. For that, let's open the Gradle Tool Window and find the task in the list:</source>
          <target state="translated">이러한 작업의 이름은 다음 공식에서 작성되었습니다. &lt;code&gt;run[Debug|Release]Executable&amp;lt;target name&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;target name&lt;/code&gt; 은 빌드 에서 &lt;code&gt;build.gradle.kts&lt;/code&gt; &lt;code&gt;build.gradle&lt;/code&gt; 파일에 지정한 대문자로 된 대상 이름입니다 . 우리의 경우 &lt;code&gt;&quot;native&quot;&lt;/code&gt; . IDE에서 작업을 실행 해 봅시다. 이를 위해 Gradle Tool 창을 열고 목록에서 작업을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="f0aa5ea5557fedda4c5d2598dc5dd22d0363ac01" translate="yes" xml:space="preserve">
          <source>The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (&lt;code&gt;Manager&lt;/code&gt;, &lt;code&gt;Wrapper&lt;/code&gt; etc.) in names.</source>
          <target state="translated">이름은 엔티티의 목적이 무엇인지 명확히해야하므로 이름에 의미없는 단어 ( &lt;code&gt;Manager&lt;/code&gt; , &lt;code&gt;Wrapper&lt;/code&gt; 등)를 사용하지 않는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="73a31785499746e1755c5fd02e03d5e8b58c34d0" translate="yes" xml:space="preserve">
          <source>The native memory can be allocated using the &lt;code&gt;NativePlacement&lt;/code&gt; interface, e.g.</source>
          <target state="translated">네이티브 메모리는 &lt;code&gt;NativePlacement&lt;/code&gt; 인터페이스를 사용하여 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="183994f4ebd6d698ee09d0ba15ca6b6ca68c9e19" translate="yes" xml:space="preserve">
          <source>The next lines are about providing linker and compiler options, which can vary depending on different target platforms. In our case, we are defining it for macOS (the &lt;code&gt;.osx&lt;/code&gt; suffix) and Linux (the &lt;code&gt;.linux&lt;/code&gt; suffix). Parameters without a suffix is also possible (e.g. &lt;code&gt;linkerOpts=&lt;/code&gt;) and will be applied to all platforms.</source>
          <target state="translated">다음 행은 링커 및 컴파일러 옵션을 제공하는 방법으로, 대상 플랫폼에 따라 달라질 수 있습니다. 우리의 경우, 우리는 맥 OS 위해를 정의합니다 ( &lt;code&gt;.osx&lt;/code&gt; 접미사)와 리눅스합니다 ( &lt;code&gt;.linux&lt;/code&gt; 접미사). 접미사가없는 매개 변수 (예 : &lt;code&gt;linkerOpts=&lt;/code&gt; ) 도 가능 하며 모든 플랫폼에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a6c6de321d2f0ef15a3d35472d5a5225a93083f" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; contains number type mappings between Kotlin/Native and &lt;code&gt;NSNumber&lt;/code&gt;. We have the base class called &lt;code&gt;DemoNumber&lt;/code&gt; in Objective-C and &lt;code&gt;KotlinNumber&lt;/code&gt; in Swift. It extends &lt;code&gt;NSNumber&lt;/code&gt;. There are also child classes per Kotlin number type:</source>
          <target state="translated">&lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 의 다음 부분 에는 Kotlin / Native와 &lt;code&gt;NSNumber&lt;/code&gt; 사이의 숫자 유형 매핑이 포함되어 있습니다 . Objective-C에 &lt;code&gt;DemoNumber&lt;/code&gt; 라는 기본 클래스 와 Swift에 &lt;code&gt;KotlinNumber&lt;/code&gt; 가 있습니다. &lt;code&gt;NSNumber&lt;/code&gt; 를 확장 합니다. Kotlin 숫자 유형마다 하위 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe4a47831305057cc6388a57b9e77a3a7e3a7a8" translate="yes" xml:space="preserve">
          <source>The next part of the &lt;code&gt;libnative_api.h&lt;/code&gt; file contains definitions of the types that are used in the library:</source>
          <target state="translated">&lt;code&gt;libnative_api.h&lt;/code&gt; 파일 의 다음 부분 에는 라이브러리에서 사용되는 유형의 정의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc72aec2231c401cec520bbf86ad2595019584f0" translate="yes" xml:space="preserve">
          <source>The next step is going to prompt us on the Kotlin runtime library. By default the plugin selects the one that is associated to the currently installed version. Unless we want to create a different one, we can click Finish at this point after entering the project name and location.</source>
          <target state="translated">다음 단계는 Kotlin 런타임 라이브러리에 대한 프롬프트입니다. 기본적으로 플러그인은 현재 설치된 버전과 관련된 플러그인을 선택합니다. 다른 것을 작성하지 않으려면 프로젝트 이름과 위치를 입력 한 후이 시점에서 Finish를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="93716c2cabdff509bf9835ed635452819990ca4f" translate="yes" xml:space="preserve">
          <source>The next step is to call a C function pointer from a C pointer that we have from the &lt;code&gt;supply_fun()&lt;/code&gt; call:</source>
          <target state="translated">다음 단계는 &lt;code&gt;supply_fun()&lt;/code&gt; 호출 에서 가지고있는 C 포인터에서 C 함수 포인터를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c075c67c98b72698b50bde83417679cfcaad540" translate="yes" xml:space="preserve">
          <source>The next step is to compile our application. We already covered the basics of compiling a Kotlin/Native application from the command line in the &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;A Basic Kotlin/Native application&lt;/a&gt; tutorial. The only difference in this case is that the &lt;code&gt;cinterop&lt;/code&gt; generated part is implicitly included into the build: Let's call the following command:</source>
          <target state="translated">다음 단계는 애플리케이션을 컴파일하는 것입니다. 우리는 이미 &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;기본 Kotlin / Native 애플리케이션&lt;/a&gt; 튜토리얼 의 커맨드 라인에서 Kotlin / Native 애플리케이션을 컴파일하는 기본 사항을 다루었습니다 . 이 경우의 유일한 차이점은 &lt;code&gt;cinterop&lt;/code&gt; 생성 파트가 빌드에 내재적으로 포함 된다는 것입니다 . 다음 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="29eb1a88978e11cb19e6153185329a8fdd184b9c" translate="yes" xml:space="preserve">
          <source>The next step is to create Greeting Data class that has two properties: &lt;em&gt;id&lt;/em&gt; and a &lt;em&gt;content&lt;/em&gt;</source>
          <target state="translated">다음 단계는 &lt;em&gt;id&lt;/em&gt; 와 &lt;em&gt;content&lt;/em&gt; 라는 두 가지 속성이있는 Greeting Data 클래스를 만드는 것입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f2ba2b214cfaccb2ec50010bfe1a0d121ee2cd4b" translate="yes" xml:space="preserve">
          <source>The next step is to create a Run Configuration in IntelliJ IDEA under Tomcat / Local which deploys the WAR and starts up Tomcat.</source>
          <target state="translated">다음 단계는 Tomcat / Local 아래 IntelliJ IDEA에서 Run Configuration을 생성하여 WAR을 배포하고 Tomcat을 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="27ce517e143c3dea9eb55849f860e4c5596ec3f9" translate="yes" xml:space="preserve">
          <source>The next step is to decide which modules to configure (if the project has more than one module) and whether you want to add the runtime library to the project or use those provided by the current Kotlin plugin.</source>
          <target state="translated">다음 단계는 구성 할 모듈 (프로젝트에 둘 이상의 모듈이있는 경우) 및 런타임 라이브러리를 프로젝트에 추가할지 또는 현재 Kotlin 플러그인에서 제공 한 모듈을 사용할지 여부를 결정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="22779d3ccc120e4892af96a829245aa095780550" translate="yes" xml:space="preserve">
          <source>The non-abstract subclasses should represent the (complete) C data type and thus specify size and alignment. Each such subclass must have a companion object which is a &lt;a href=&quot;-type/index&quot;&gt;Type&lt;/a&gt;.</source>
          <target state="translated">비추 상 서브 클래스는 (완전한) C 데이터 유형을 나타내므로 크기와 정렬을 지정해야합니다. 이러한 각 서브 클래스는 &lt;a href=&quot;-type/index&quot;&gt;Type 인&lt;/a&gt; 도우미 객체를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="fc28129df689ae65c9fd83a31b9aa03dac9e8ced" translate="yes" xml:space="preserve">
          <source>The non-breaking space character</source>
          <target state="translated">비 공백 공백 문자</target>
        </trans-unit>
        <trans-unit id="e8f00eeeaaa301ab094d387f05d45fa33541dead" translate="yes" xml:space="preserve">
          <source>The nullable version &lt;code&gt;Nothing?&lt;/code&gt; will be used by the compiler when something is initialized with null and there is no other type information. In &lt;code&gt;val x = null&lt;/code&gt;, the type of &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;Nothing?&lt;/code&gt;. This type does not have the &quot;never returns normally&quot; semantics; instead, the compiler knows that the value will always be null.</source>
          <target state="translated">nullable 버전이 &lt;code&gt;Nothing?&lt;/code&gt; 무언가가 null로 초기화되고 다른 유형 정보가 없을 때 컴파일러가 사용합니다. 에서 &lt;code&gt;val x = null&lt;/code&gt; 의 종류 &lt;code&gt;x&lt;/code&gt; 것 &lt;code&gt;Nothing?&lt;/code&gt; . 이 유형에는 &quot;정상적으로 리턴하지 않음&quot;의미가 없습니다. 대신 컴파일러는 값이 항상 null임을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="77363aca1573dd5dba20e28ad666c9c7fd83436a" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">숫자는 문자열로 변환 된 다음 문자열은 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal로 변환&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb7b619e5deab250c82714dad5c6223da422d99" translate="yes" xml:space="preserve">
          <source>The number is converted to a string and then the string is converted to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal&lt;/a&gt;.</source>
          <target state="translated">숫자가 문자열로 변환 된 다음 문자열이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html&quot;&gt;BigDecimal로 변환&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9979a04405cfcd09395aa075f56f352dfb5b1c" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent a Char in a binary form.</source>
          <target state="translated">Char를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a5aabbd23fb87b74097e1ccd4055f0b183ecbf87" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Byte in a binary form.</source>
          <target state="translated">Byte 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="fc5f8fcea457f48ba61aea0a6c6364e750d35bba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Double in a binary form.</source>
          <target state="translated">이진 형식으로 Double 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="3ac96a9235bc1077029c5934186d743a5b00c197" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Float in a binary form.</source>
          <target state="translated">이진 형식으로 Float 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="0f9c3201d4f3bb80740106fd705fe9901bfc9490" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Int in a binary form.</source>
          <target state="translated">Int 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="881c588a79332a9f90d40c26e737596c51909376" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Long in a binary form.</source>
          <target state="translated">Long 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="3a2fa986a400a5de2289aa09e08c447c811e1ab0" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of Short in a binary form.</source>
          <target state="translated">이진 형식으로 Short 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b557b6ad22e0d4a32e6ecf5e7c42a83086397f62" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UByte in a binary form.</source>
          <target state="translated">이진 형식으로 UByte 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="04a46c8fcf471f6f7a2489fd5541b67d79b2dbba" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UInt in a binary form.</source>
          <target state="translated">이진 형식으로 UInt 인스턴스를 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="970f51f6cf41ca82dcda9c5384dd1584581a3241" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of ULong in a binary form.</source>
          <target state="translated">ULong 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="f405dad940dd8a9ba9986616021e6669d81ef332" translate="yes" xml:space="preserve">
          <source>The number of bits used to represent an instance of UShort in a binary form.</source>
          <target state="translated">UShort 인스턴스를 이진 형식으로 나타내는 데 사용되는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="7fca3ee96d6d11e61b4e40ce8aef39bbd3166f00" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent a Char in a binary form.</source>
          <target state="translated">Char를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d455af0205d71a29c80b7797e96f36f72c818b20" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Byte in a binary form.</source>
          <target state="translated">바이트 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="cfb84d55b9d6ee08abf33db55d2a61462dded701" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Double in a binary form.</source>
          <target state="translated">이진 형식으로 Double 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="080e5eee27bb967010b8c2b300a0c20e8300d7a1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Float in a binary form.</source>
          <target state="translated">이진 형식으로 Float 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="012737f61c97912b11277e0542ab793fcecbd8f6" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Int in a binary form.</source>
          <target state="translated">Int 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="ac50dee558bf2179b63147e5d4abcf881946deb1" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Long in a binary form.</source>
          <target state="translated">Long 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d47711ab000d6ab309cdde940a4d6cc83958bbb7" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of Short in a binary form.</source>
          <target state="translated">이진 형식으로 Short 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="5da103d9bfe814cb16e570a63e8fffdec6abede9" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UByte in a binary form.</source>
          <target state="translated">이진 형식으로 UByte 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="7aa018571731f4dfc20dc2f2b40bc661649fe4df" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UInt in a binary form.</source>
          <target state="translated">이진 형식으로 UInt 인스턴스를 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="c4d88684784d0b5692fee9bc8fbbdcbfde1bb159" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of ULong in a binary form.</source>
          <target state="translated">ULong 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="de97fd8a16a598b6d753acf6fc495d892600d39e" translate="yes" xml:space="preserve">
          <source>The number of bytes used to represent an instance of UShort in a binary form.</source>
          <target state="translated">UShort 인스턴스를 이진 형식으로 나타내는 데 사용되는 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="802421b7bac6f95ce971296bce66f238a1ca7ee6" translate="yes" xml:space="preserve">
          <source>The official docs also have a very cool example with a &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt; DSL for constructing HTML documents&lt;/a&gt;.</source>
          <target state="translated">공식 문서는 &lt;a href=&quot;../../reference/type-safe-builders&quot;&gt;HTML 문서를 구성하기위한 DSL&lt;/a&gt; 과 함께 아주 멋진 예를 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9824ffa4fbac1aa2ba4df2857cc7d27ae42fbdf3" translate="yes" xml:space="preserve">
          <source>The only target for which it is not available is &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt;.</source>
          <target state="translated">사용할 수없는 대상은 &lt;a href=&quot;https://en.wikipedia.org/wiki/WebAssembly&quot;&gt;WebAssembly&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20601b96604d0e7211b7510d021f94ac0577f4a7" translate="yes" xml:space="preserve">
          <source>The only thing left to do is compile our application (Build|Build Project), and once the JavaScript files have been generated, we can open the &lt;code&gt;index.html&lt;/code&gt; file in the browser and see the result in the console debug window.</source>
          <target state="translated">남은 것은 애플리케이션 (Build | Build Project)을 컴파일하는 것입니다. JavaScript 파일이 생성되면 브라우저에서 &lt;code&gt;index.html&lt;/code&gt; 파일을 열고 콘솔 디버그 창에서 결과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="940b1bdb9d47159d1535cf808141916fc2b5f10e" translate="yes" xml:space="preserve">
          <source>The operation doesn't preserve copied file attributes such as creation/modification date, permissions, etc.</source>
          <target state="translated">작업은 생성 / 수정 날짜, 권한 등과 같은 복사 된 파일 속성을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9a452f893e9486c5fbe89e3c1a52b0da8c35684" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt;.</source>
          <target state="translated">작업은 &lt;em&gt;중간 &lt;/em&gt;&lt;em&gt;상태&lt;/em&gt; 이며 &lt;em&gt;상태 저장&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64f2d6f436a63697c12d9826dd0b449a2c8ece4d" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; and &lt;em&gt;stateless&lt;/em&gt;.</source>
          <target state="translated">작업은 &lt;em&gt;중간 &lt;/em&gt;&lt;em&gt;상태&lt;/em&gt; 이며 &lt;em&gt;상태 비 저장&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f74c9f051d5d0a5178895ef9787aac4f50f4820" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">동작은 &lt;em&gt;중간&lt;/em&gt; 이 순서 및 &lt;em&gt;단말기&lt;/em&gt; 및 &lt;em&gt;상태&lt;/em&gt; 용 &lt;a href=&quot;minus#kotlin.sequences%24minus%28kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.sequences.minus.T%29%29%29%2Felements&quot;&gt;소자&lt;/a&gt; 시퀀스.</target>
        </trans-unit>
        <trans-unit id="790886232e90f42fd32ca4859b4baabd53b9cbd8" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;intermediate&lt;/em&gt; for this sequence and &lt;em&gt;terminal&lt;/em&gt; and &lt;em&gt;stateful&lt;/em&gt; for the &lt;a href=&quot;minus#kotlin.sequences%24minus(kotlin.sequences.Sequence((kotlin.sequences.minus.T)),%20kotlin.sequences.Sequence((kotlin.sequences.minus.T)))/elements&quot;&gt;elements&lt;/a&gt; sequence.</source>
          <target state="translated">동작은 &lt;em&gt;중간&lt;/em&gt; 이 순서 및 &lt;em&gt;단말기&lt;/em&gt; 및 &lt;em&gt;상태&lt;/em&gt; 용 &lt;a href=&quot;minus#kotlin.sequences%24minus(kotlin.sequences.Sequence((kotlin.sequences.minus.T)),%20kotlin.sequences.Sequence((kotlin.sequences.minus.T)))/elements&quot;&gt;소자&lt;/a&gt; 시퀀스.</target>
        </trans-unit>
        <trans-unit id="f90173c5f7dc2e732f31878b5387f1009c2ad309" translate="yes" xml:space="preserve">
          <source>The operation is &lt;em&gt;terminal&lt;/em&gt;.</source>
          <target state="translated">작업은 &lt;em&gt;터미널&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24cec715dc71cea63c8c77aa342afd935860c2d6" translate="yes" xml:space="preserve">
          <source>The operations on floating point numbers discussed in this section are:</source>
          <target state="translated">이 섹션에서 설명한 부동 소수점 숫자에 대한 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c81054e9fa59c990a7f0009d1471af7d0d80d085" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;plus&lt;/code&gt; provides a way to add key-value pair(s) to a read-only map producing a new map, however there was not a simple way to do the opposite: to remove a key from the map you have to resort to less straightforward ways to like &lt;code&gt;Map.filter()&lt;/code&gt; or &lt;code&gt;Map.filterKeys()&lt;/code&gt;. Now the operator &lt;code&gt;minus&lt;/code&gt; fills this gap. There are 4 overloads available: for removing a single key, a collection of keys, a sequence of keys and an array of keys.</source>
          <target state="translated">연산자 &lt;code&gt;plus&lt;/code&gt; 는 키-값 쌍을 읽기 전용 맵에 추가하여 새 맵을 생성하는 방법을 제공하지만 그 반대의 간단한 방법은 없었습니다. 맵에서 키를 제거하는 방법 &lt;code&gt;Map.filter()&lt;/code&gt; 또는 &lt;code&gt;Map.filterKeys()&lt;/code&gt; 와 같은 간단한 방법 . 이제 연산자 &lt;code&gt;minus&lt;/code&gt; 가이 간격을 채 웁니다. 단일 키, 키 모음, 일련의 키 및 키 배열을 제거하기위한 4 가지 오버로드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3dfe13bda3af06c0e25457985a11e6db0a3ea90" translate="yes" xml:space="preserve">
          <source>The order of elements is an important aspect of certain collection types. For example, two lists of the same elements are not equal if their elements are ordered differently.</source>
          <target state="translated">요소의 순서는 특정 컬렉션 유형의 중요한 측면입니다. 예를 들어, 요소가 다르게 정렬 된 경우 동일한 요소의 두 목록이 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97cb339b9434116a61ea466562966c5cfa7e6e7a" translate="yes" xml:space="preserve">
          <source>The order of operations execution is different as well: &lt;code&gt;Sequence&lt;/code&gt; performs all the processing steps one-by-one for every single element. In turn, &lt;code&gt;Iterable&lt;/code&gt; completes each step for the whole collection and then proceeds to the next step.</source>
          <target state="translated">작업 실행 순서도 다릅니다. &lt;code&gt;Sequence&lt;/code&gt; 는 모든 단일 요소에 대해 모든 처리 단계를 하나씩 수행합니다. 차례로, &lt;code&gt;Iterable&lt;/code&gt; 전체 컬렉션의 각 단계를 완료 한 후 다음 단계로 진행된다.</target>
        </trans-unit>
        <trans-unit id="812e3a1f04f0d82a55115416fefd4d8f871219e6" translate="yes" xml:space="preserve">
          <source>The original exception is handled by the parent only when all its children terminate, which is demonstrated by the following example.</source>
          <target state="translated">원래 예외는 모든 자식이 종료 될 때만 부모에 의해 처리됩니다. 이는 다음 예제에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21b2e4b0974b9e68e9c52fc5e687c75f3f109501" translate="yes" xml:space="preserve">
          <source>The output it produces with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is similar to:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM 옵션으로 생성되는 출력 은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="335f16bba6cd2578184d6190d9013ac4ec39e185" translate="yes" xml:space="preserve">
          <source>The output of a config script with &lt;code&gt;--libs&lt;/code&gt; will be passed as a &lt;code&gt;-linkedArgs&lt;/code&gt;&lt;code&gt;kotlinc&lt;/code&gt; flag value (quoted) when compiling.</source>
          <target state="translated">&lt;code&gt;--libs&lt;/code&gt; 를 사용하는 구성 스크립트의 출력은 컴파일 할 때 &lt;code&gt;-linkedArgs&lt;/code&gt; &lt;code&gt;kotlinc&lt;/code&gt; 플래그 값 (인용) 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a335f7db5ad6c9bad17c284454dcaeefbd6be278" translate="yes" xml:space="preserve">
          <source>The output of this code is (with &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;):</source>
          <target state="translated">이 코드의 출력은 (함께 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutine-context-and-dispatchers.md#debugging-coroutines-and-threads&quot;&gt;디버그&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="d91d0dd8fa3a619861392f5c074fea2d8db4eaf2" translate="yes" xml:space="preserve">
          <source>The output of this code is:</source>
          <target state="translated">이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="647a971dfd3700d13cfdc057be9aa0bc71494501" translate="yes" xml:space="preserve">
          <source>The output of this code shows that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are called only when building the result list. So, you first see the line of text &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; and then the sequence processing starts. Note that for elements left after filtering, the map executes before filtering the next element. When the result size reaches 4, the processing stops because it's the largest possible size that &lt;code&gt;take(4)&lt;/code&gt; can return.</source>
          <target state="translated">이 코드의 결과는 &lt;code&gt;filter()&lt;/code&gt; 및 &lt;code&gt;map()&lt;/code&gt; 함수가 결과 목록을 작성할 때만 호출 됨을 보여줍니다 . 먼저, &lt;code&gt;&amp;ldquo;Lengths of..&amp;rdquo;&lt;/code&gt; 텍스트 줄이 나타난 다음 시퀀스 처리가 시작됩니다. 필터링 후 남은 요소의 경우 다음 요소를 필터링하기 전에 맵이 실행됩니다. 결과 크기가 4에 도달하면 &lt;code&gt;take(4)&lt;/code&gt; 가 리턴 할 수 있는 최대 크기이므로 처리가 중지됩니다 .</target>
        </trans-unit>
        <trans-unit id="4914ca42a65eab132541007ef394cf246de086f7" translate="yes" xml:space="preserve">
          <source>The output of this code with &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM 옵션 을 사용한 이 코드의 출력은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ef205ce911c3cb52ce12493307210d6d78d5dcb8" translate="yes" xml:space="preserve">
          <source>The output of this code with the &lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM option is:</source>
          <target state="translated">&lt;code&gt;-Dkotlinx.coroutines.debug&lt;/code&gt; JVM 옵션을 사용한이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdcf4102afb246d995583e41d5abf443dc9b24d6" translate="yes" xml:space="preserve">
          <source>The output of this example is:</source>
          <target state="translated">이 예제의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7f56deac4aeaab1be47a9075fd39d0cd515a13f" translate="yes" xml:space="preserve">
          <source>The output of this is a blank page that prints &lt;code&gt;Hello JavaScript!&lt;/code&gt; to the console.</source>
          <target state="translated">이 결과는 &lt;code&gt;Hello JavaScript!&lt;/code&gt; 를 인쇄하는 빈 페이지입니다 ! 콘솔에.</target>
        </trans-unit>
        <trans-unit id="c7adcbeb9a00e6f9f8d55d348527ceb949cebeb0" translate="yes" xml:space="preserve">
          <source>The output should be:</source>
          <target state="translated">출력은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="0b8e02788f842ec131e59334f158260f8f72ffc7" translate="yes" xml:space="preserve">
          <source>The output will be similar to the the following one, albeit the processor ids that receive each specific integer may be different:</source>
          <target state="translated">각 특정 정수를받는 프로세서 ID는 다를 수 있지만 출력은 다음과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="dacb06aada01cf9353bf2a419b476781dd3c13a9" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="translated">전체적인 효과는 마치 &lt;code&gt;value.toString()&lt;/code&gt; 메서드에 의해 &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Any?)/value&quot;&gt;값&lt;/a&gt; 이 문자열로 변환 된 다음 해당 문자열이이 문자열 작성기에 추가 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fa46c20aa677e08c4fbabd2c01f13037e7e1a67" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was appended to this string builder.</source>
          <target state="translated">전체적인 효과는 마치 &lt;code&gt;value.toString()&lt;/code&gt; 메서드에 의해 &lt;a href=&quot;append#kotlin.text.StringBuilder%24append(kotlin.Boolean)/value&quot;&gt;값&lt;/a&gt; 이 문자열로 변환 된 다음 해당 문자열이이 문자열 작성기에 추가 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d95d1d469be2176ebbc72a21468acef591255ad" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">전체적인 효과는 마치 &lt;code&gt;value.toString()&lt;/code&gt; 메서드에 의해 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;값&lt;/a&gt; 이 문자열로 변환 된 다음 해당 문자열이 지정된 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; 에있는이 문자열 작성기에 삽입 된 것과 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="76acc76cfe7700de42074cf269fd6d05489f7e96" translate="yes" xml:space="preserve">
          <source>The overall effect is exactly as if the &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; were converted to a string by the &lt;code&gt;value.toString()&lt;/code&gt; method, and then that string was inserted into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">전체적인 효과는 마치 &lt;code&gt;value.toString()&lt;/code&gt; 메서드에 의해 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;값&lt;/a&gt; 이 문자열로 변환 된 다음 해당 문자열이 지정된 &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; 에있는이 문자열 작성기에 삽입 된 것과 똑같습니다 .</target>
        </trans-unit>
        <trans-unit id="b56500d82b30990e46ae5220b62e1c3f4e225003" translate="yes" xml:space="preserve">
          <source>The overriding constructor must have the same parameter names and types as the overridden one.</source>
          <target state="translated">재정의 생성자는 재정의 생성자와 동일한 매개 변수 이름과 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="d0fd3de86e4826ba8c7cde26e87523bae54839bc" translate="yes" xml:space="preserve">
          <source>The packages from platform libraries are available by default. No special link flags need to be specified to use them. &lt;code&gt;Kotlin/Native&lt;/code&gt; compiler automatically detects which of the platform libraries have been accessed and automatically links the needed libraries.</source>
          <target state="translated">플랫폼 라이브러리의 패키지는 기본적으로 사용 가능합니다. 특별한 링크 플래그를 지정하지 않아도 사용할 수 있습니다. &lt;code&gt;Kotlin/Native&lt;/code&gt; 컴파일러는 액세스 한 플랫폼 라이브러리를 자동으로 감지하여 필요한 라이브러리를 자동으로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f9eac82235030e7e86a0bff236552f847d9867dd" translate="yes" xml:space="preserve">
          <source>The parameter is declared in a member function and one of the corresponding parameters in the super functions is optional.</source>
          <target state="translated">매개 변수는 멤버 함수에서 선언되며 수퍼 함수의 해당 매개 변수 중 하나는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="1a311c087dc5f415abb270981ad04ec98ba47164" translate="yes" xml:space="preserve">
          <source>The parameter must not &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;accept variable number of arguments&lt;/a&gt; and must have no &lt;a href=&quot;#default-arguments&quot;&gt;default value&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;#variable-number-of-arguments-varargs&quot;&gt;가변 개수의 인수를 허용&lt;/a&gt; 하지 않아야하며 &lt;a href=&quot;#default-arguments&quot;&gt;기본값&lt;/a&gt; 이 없어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="85604054f8838d2bde0848abdc31a44140b69283" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;@JsName&lt;/code&gt; is required to be a constant string literal which is a valid identifier. The compiler will report an error on any attempt to pass non-identifier string to &lt;code&gt;@JsName&lt;/code&gt;. The following example produces a compile-time error:</source>
          <target state="translated">&lt;code&gt;@JsName&lt;/code&gt; 의 매개 변수 는 유효한 식별자 인 상수 문자열 리터럴이어야합니다. 컴파일러는 식별자가 아닌 문자열을 &lt;code&gt;@JsName&lt;/code&gt; 에 전달하려는 시도에서 오류를보고합니다 . 다음 예제는 컴파일 타임 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d09d94c8171c7316821713755fce66dc3c85e74a" translate="yes" xml:space="preserve">
          <source>The parameter of &lt;code&gt;js&lt;/code&gt; is required to be a string constant. So, the following code is incorrect:</source>
          <target state="translated">&lt;code&gt;js&lt;/code&gt; 의 매개 변수 는 문자열 상수 여야합니다. 따라서 다음 코드는 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64419b25b7715086a3a5cdbe138547b81a0a98a1" translate="yes" xml:space="preserve">
          <source>The parameter type of a function-typed parameter (the user is passing a function that can handle any &lt;code&gt;Fruit&lt;/code&gt;, and it will be given an &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 형식의 매개 변수의 매개 변수 유형 (사용자는 처리 할 수있는 기능을 전달하고 &lt;code&gt;Fruit&lt;/code&gt; 하고는 주어질 것이다 &lt;code&gt;Apple&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6ef05f581070101fa2afecc255e98671537cdea0" translate="yes" xml:space="preserve">
          <source>The parameters and the return type are specified in the same way as for regular functions, except that the parameter types can be omitted if they can be inferred from context:</source>
          <target state="translated">매개 변수 및 리턴 유형은 컨텍스트에서 유추 할 수있는 경우 매개 변수 유형을 생략 할 수 있다는 점을 제외하고 일반 함수와 동일한 방식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d2818a5f4b17e0f3d50df0846a19518863e09067" translate="yes" xml:space="preserve">
          <source>The parameters of &lt;code&gt;provideDelegate&lt;/code&gt; are the same as for &lt;code&gt;getValue&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;provideDelegate&lt;/code&gt; 의 매개 변수는 &lt;code&gt;getValue&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="87e2c98795ae2a97eb179a3bb9ccc1f2e2c982d8" translate="yes" xml:space="preserve">
          <source>The passed type must satisfy all conditions of the &lt;code&gt;where&lt;/code&gt; clause simultaneously. In the above example, the &lt;code&gt;T&lt;/code&gt; type must implement &lt;em&gt;both&lt;/em&gt;&lt;code&gt;CharSequence&lt;/code&gt; and &lt;code&gt;Comparable&lt;/code&gt;.</source>
          <target state="translated">전달 된 유형은 &lt;code&gt;where&lt;/code&gt; 절의 모든 조건을 동시에 만족해야합니다 . 위 예제에서 &lt;code&gt;T&lt;/code&gt; 유형은 &lt;code&gt;CharSequence&lt;/code&gt; 및 &lt;code&gt;Comparable&lt;/code&gt; 을&lt;em&gt;모두&lt;/em&gt; 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f70942d020a14104380fd6e7920e316921b42c6" translate="yes" xml:space="preserve">
          <source>The path refers to the default output location that IntelliJ IDEA uses when we compile the application. Below we'll see how to change this.</source>
          <target state="translated">경로는 응용 프로그램을 컴파일 할 때 IntelliJ IDEA가 사용하는 기본 출력 위치를 나타냅니다. 아래에서이를 변경하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="38dc6771af81ffcbac99f06b8c7fb1ebccf80f9d" translate="yes" xml:space="preserve">
          <source>The pattern string of this regular expression.</source>
          <target state="translated">이 정규식의 패턴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1144f4eed1bc15fed420102b18cb1c4e49c25335" translate="yes" xml:space="preserve">
          <source>The pattern where a coroutine is producing a sequence of elements is quite common. This is a part of &lt;em&gt;producer-consumer&lt;/em&gt; pattern that is often found in concurrent code. You could abstract such a producer into a function that takes channel as its parameter, but this goes contrary to common sense that results must be returned from functions.</source>
          <target state="translated">코 루틴이 일련의 요소를 생성하는 패턴은 매우 일반적입니다. 이것은 종종 동시 코드에서 발견되는 &lt;em&gt;생산자-소비자&lt;/em&gt; 패턴 의 일부입니다 . 그러한 생산자를 채널을 매개 변수로 사용하는 함수로 추상화 할 수는 있지만 결과는 함수에서 반환되어야한다는 상식과 상반됩니다.</target>
        </trans-unit>
        <trans-unit id="0452bcbdd609690466ea082ea5af90749aa8dcc5" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; should be replaced with one of the plugin names that can be found in further sections.</source>
          <target state="translated">플레이스 홀더 &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 는 추가 섹션에서 찾을 수있는 플러그인 이름 중 하나로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="02d885dcfef73f7197c98c6f94fc980ae42855f5" translate="yes" xml:space="preserve">
          <source>The plugin allows you to customize the pom generated for the publication with the &lt;code&gt;pom&lt;/code&gt; code block available for every component:</source>
          <target state="translated">플러그인을 사용하면 모든 컴포넌트에 사용 가능한 &lt;code&gt;pom&lt;/code&gt; 코드 블록을 사용 하여 발행물에 대해 생성 된 pom을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73896d94724b0c15c533e7832f50fc2c5d439771" translate="yes" xml:space="preserve">
          <source>The plugin allows you to declare dependencies on files and other projects using traditional Gradle's mechanism of configurations. The plugin supports Kotlin multiplatform projects allowing you to declare the &lt;code&gt;expectedBy&lt;/code&gt; dependencies</source>
          <target state="translated">플러그인을 사용하면 전통적인 Gradle의 구성 메커니즘을 사용하여 파일 및 기타 프로젝트에 대한 종속성을 선언 할 수 있습니다. 이 플러그인은 Kotlin 멀티 플랫폼 프로젝트를 지원하므로 &lt;code&gt;expectedBy&lt;/code&gt; 종속성 을 선언 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e2b8c11954d8c4f9f34c307b3e3ea0e12583e5af" translate="yes" xml:space="preserve">
          <source>The plugin builds a test executable for all the targets specified for the &lt;code&gt;test&lt;/code&gt; component. If the current host platform is included in this list the test running tasks are also created. To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">플러그인은 &lt;code&gt;test&lt;/code&gt; 구성 요소에 지정된 모든 대상에 대해 테스트 실행 파일을 빌드합니다 . 현재 호스트 플랫폼이이 목록에 포함되어 있으면 테스트 실행 작업도 생성됩니다. 테스트를 실행하려면 표준 수명주기 &lt;code&gt;check&lt;/code&gt; 작업을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbd612ac393a456f8773735c05ddbd5f91419396" translate="yes" xml:space="preserve">
          <source>The plugin creates a compilation task for each combination of the target, output kind, and build type. The tasks have the following naming convention:</source>
          <target state="translated">플러그인은 대상, 출력 종류 및 빌드 유형의 각 조합에 대한 컴파일 작업을 만듭니다. 작업에는 다음과 같은 명명 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7797d4ea1281347f08b98f3d1593b5740b623cc" translate="yes" xml:space="preserve">
          <source>The plugin is shipped with a customized version of the &lt;code&gt;kotlinx.serialization&lt;/code&gt; plugin. To use it you don't have to add new buildscript dependencies, just apply the plugins and add a dependency on the serialization library:</source>
          <target state="translated">플러그인은 사용자 정의 된 &lt;code&gt;kotlinx.serialization&lt;/code&gt; 플러그인 버전과 함께 제공됩니다 . 그것을 사용하려면 새로운 빌드 스크립트 의존성을 추가 할 필요가 없으며 플러그인을 적용하고 직렬화 라이브러리에 의존성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a5b5cad9084adc7ffa681b4e8b7b6b009920bbab" translate="yes" xml:space="preserve">
          <source>The plugin option format is: &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;. Options can be repeated.</source>
          <target state="translated">플러그인 옵션 형식은 &lt;code&gt;-P plugin:&amp;lt;plugin id&amp;gt;:&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 입니다. 옵션을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b96dd9cca135b083ee411ceef82d46edf74c104" translate="yes" xml:space="preserve">
          <source>The plugin specifies the following annotations: &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt;&lt;code&gt;@Async&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt;&lt;code&gt;@Cacheable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt;&lt;code&gt;@SpringBootTest&lt;/code&gt;&lt;/a&gt;. Thanks to meta-annotations support classes annotated with &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt;&lt;code&gt;@Configuration&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt;&lt;code&gt;@RestController&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt;&lt;code&gt;@Service&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt;&lt;/a&gt; are automatically opened since these annotations are meta-annotated with &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플러그인은 &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html&quot;&gt; &lt;code&gt;@Async&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html&quot;&gt; &lt;code&gt;@Transactional&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html&quot;&gt; &lt;code&gt;@Cacheable&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/context/SpringBootTest.html&quot;&gt; &lt;code&gt;@SpringBootTest&lt;/code&gt; &lt;/a&gt; 주석을 지정합니다 . 메타 주석 덕분에 &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html&quot;&gt; &lt;code&gt;@Configuration&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html&quot;&gt; &lt;code&gt;@Controller&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html&quot;&gt; &lt;code&gt;@RestController&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/stereotype/Service.html&quot;&gt; &lt;code&gt;@Service&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html&quot;&gt; &lt;code&gt;@Repository&lt;/code&gt; &lt;/a&gt; 로 주석이 달린 클래스 가 주석이 &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html&quot;&gt; &lt;code&gt;@Component&lt;/code&gt; &lt;/a&gt; 로 메타 주석이기 때문에 자동으로 열립니다 .</target>
        </trans-unit>
        <trans-unit id="422a0ed13a769b30fb09b25e92467921db8dd51b" translate="yes" xml:space="preserve">
          <source>The plugin uses the same notation as the compiler. By default, test component uses the same targets as specified for the main one.</source>
          <target state="translated">플러그인은 컴파일러와 동일한 표기법을 사용합니다. 기본적으로 테스트 구성 요소는 기본 구성 요소에 지정된 것과 동일한 대상을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f3c2f2fca540697d8f63e00a5a21435f0484957" translate="yes" xml:space="preserve">
          <source>The podspec generated includes a path to an output framework and script phases which automate building this framework during a build process of an Xcode project. Some fields of the podspec file can be configured using the &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; code block.</source>
          <target state="translated">생성 된 podspec에는 출력 프레임 워크에 대한 경로와 Xcode 프로젝트의 빌드 프로세스 중에이 프레임 워크 빌드를 자동화하는 스크립트 단계가 포함됩니다. podlin 파일의 일부 필드는 &lt;code&gt;kotlin.cocoapods { ... }&lt;/code&gt; 코드 블록을 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f2f6c39a4cfc0d578583a59ccc054d34affa473" translate="yes" xml:space="preserve">
          <source>The pointer with an opaque type.</source>
          <target state="translated">불투명 한 타입의 포인터.</target>
        </trans-unit>
        <trans-unit id="cac38148225622f1c3ccca3dceed3d6a499e0217" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">가능한 value &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns%28kotlin.Any%29%2Fvalue&quot;&gt;값&lt;/a&gt; 은 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff2c8804ee232db23ae3d579f25ad98024549ce9" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns(kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; are limited to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">가능한 value &lt;a href=&quot;returns#kotlin.contracts.ContractBuilder%24returns(kotlin.Any?)/value&quot;&gt;값&lt;/a&gt; 은 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="db453765e0a754bcf108983d99d14a9cceb4e257" translate="yes" xml:space="preserve">
          <source>The predicates in &lt;code&gt;filter()&lt;/code&gt; can only check the values of the elements. If you want to use element positions in the filter, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt;&lt;code&gt;filterIndexed()&lt;/code&gt;&lt;/a&gt;. It takes a predicate with two arguments: the index and the value of an element.</source>
          <target state="translated">&lt;code&gt;filter()&lt;/code&gt; 의 술어 는 요소의 값만 확인할 수 있습니다. 필터에서 요소 위치를 사용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-indexed&quot;&gt; &lt;code&gt;filterIndexed()&lt;/code&gt; &lt;/a&gt; . 인덱스와 요소의 값이라는 두 개의 인수가있는 술어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="273bc9daf88463decafd479d30c651cc98374847" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cda211d823296d73d5059839d0f82ff49bb5da0" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-groovy-macos-mac.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-framework-kotlin-macos-mac.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83fad008770a134699f224ecf517dfb249b17b87" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be directly downloaded from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-linux.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-macos.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-groovy-windows.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-linux.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-macos.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-shared-lib-kotlin-windows.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47fbf2be0cf9555e26f724c9cc904699b4e6d2c6" translate="yes" xml:space="preserve">
          <source>The prepared project sources can be downloaded directly from &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub&lt;/a&gt;. &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">준비된 프로젝트 소스는 &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-macos-c.zip&quot;&gt;GitHub&lt;/a&gt; 에서 직접 다운로드 할 수 있습니다 . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-linux-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-groovy-windows-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-macos-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-linux-c.zip&quot;&gt;GitHub의&lt;/a&gt; . &lt;a href=&quot;https://github.com/kotlin/web-site-samples/archive/mpp-kn-app-kotlin-windows-c.zip&quot;&gt;GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b884226386a575e859d8ba59646588a18cff524" translate="yes" xml:space="preserve">
          <source>The preset functions return an existing target if there is one. This can be used to configure an existing target:</source>
          <target state="translated">사전 설정 기능은 기존 대상이있는 경우 기존 대상을 반환합니다. 기존 대상을 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94b4a93f08efae43f49ccc9068c6ccc45a749339" translate="yes" xml:space="preserve">
          <source>The primary constructor cannot contain any code. Initialization code can be placed in &lt;strong&gt;initializer blocks&lt;/strong&gt;, which are prefixed with the &lt;em&gt;init&lt;/em&gt; keyword.</source>
          <target state="translated">기본 생성자는 코드를 포함 할 수 없습니다. 초기화 코드는 &lt;strong&gt;이니셜 라이저 블록에&lt;/strong&gt; 배치 될 수 있으며, &lt;strong&gt;초기화 블록&lt;/strong&gt; 은 &lt;em&gt;init&lt;/em&gt; 키워드 가 접두어로 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="9fdf36149a4f79a1bb95fdb86a615c52def92e79" translate="yes" xml:space="preserve">
          <source>The primary constructor needs to have at least one parameter;</source>
          <target state="translated">기본 생성자에는 하나 이상의 매개 변수가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="da3ee8bb58d5e5b4db4f578cf06329f7adf39108" translate="yes" xml:space="preserve">
          <source>The principles of Keeping the Language Modern and Comfortable Updates suggest that incompatible changes are sometimes necessary, but they should be introduced carefully. Our goal is to make the users aware of upcoming changes well in advance to let them migrate their code comfortably.</source>
          <target state="translated">언어를 현대적이고 편안한 업데이트로 유지하는 원칙에 따르면 호환되지 않는 변경이 필요할 수도 있지만 신중하게 소개해야합니다. 우리의 목표는 사용자에게 향후 변경 사항을 미리 알리고 코드를 편안하게 마이그레이션 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="9c66b2fe04efcfddbeb39708f916ac0b213e981b" translate="yes" xml:space="preserve">
          <source>The problem is that in Kotlin we can say &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt;, but in Java that would be impossible, because in Java the class &lt;code&gt;Box&lt;/code&gt; is &lt;em&gt;invariant&lt;/em&gt; in its parameter &lt;code&gt;T&lt;/code&gt;, and thus &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; is not a subtype of &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt;. To make it work in Java we'd have to define &lt;code&gt;unboxBase&lt;/code&gt; as follows:</source>
          <target state="translated">문제는 코 틀린에 우리가 말할 수 있다는 것입니다 &lt;code&gt;unboxBase(boxDerived(&quot;s&quot;))&lt;/code&gt; 하지만, 자바 클래스 때문에 자바 즉, 불가능하다 &lt;code&gt;Box&lt;/code&gt; 입니다 &lt;em&gt;불변&lt;/em&gt; 의 매개 변수 &lt;code&gt;T&lt;/code&gt; 따라서, 그리고 &lt;code&gt;Box&amp;lt;Derived&amp;gt;&lt;/code&gt; 서브 타입 아니다 의 &lt;code&gt;Box&amp;lt;Base&amp;gt;&lt;/code&gt; . Java에서 작동하게하려면 다음과 같이 &lt;code&gt;unboxBase&lt;/code&gt; 를 정의 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d0d37636a32f4cdf2f104260760bfa7761da1ecf" translate="yes" xml:space="preserve">
          <source>The process of building and running the Kotlin application in Android Studio is exactly the same as with Java.</source>
          <target state="translated">Android Studio에서 Kotlin 애플리케이션을 빌드하고 실행하는 프로세스는 Java와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5333ca5a84bee1fa54c6c2c65a4ed24b1d5a7d39" translate="yes" xml:space="preserve">
          <source>The programming model and APIs remain the same. We can continue to use loops, exception handling, etc. and there's no need to learn a complete set of new APIs</source>
          <target state="translated">프로그래밍 모델과 API는 동일하게 유지됩니다. 루프, 예외 처리 등을 계속 사용할 수 있으며 완전한 새로운 API 세트를 배울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cbc23b45ec695a38d5e9af2e658da812853cfa4f" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange%28kotlin.Char%2C+kotlin.Char%2C+kotlin.Int%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3cfecf27df2864c65a3a1ce3c515f4f228c95a52" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;단계를&lt;/a&gt; 사용하여 rangeStart 값을 제외하지 않고 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값 으로 이동합니다 . 뒤로 이동하려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.CharProgression.Companion%24fromClosedRange(kotlin.Char,%20kotlin.Char,%20kotlin.Int)/step&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8d272fe15b8cfff505d8d535e47fe9213e3e4bb4" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange%28kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2c4a6206c951ddbe8fde808b1243da3bfe938dbc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;단계를&lt;/a&gt; 사용하여 rangeStart 값을 제외하지 않고 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값 으로 이동합니다 . 뒤로 이동하려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.IntProgression.Companion%24fromClosedRange(kotlin.Int,%20kotlin.Int,%20kotlin.Int)/step&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="84ee7e5946067792bd4d0c03b228099a9bd9d9cd" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange%28kotlin.Long%2C+kotlin.Long%2C+kotlin.Long%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d9d863d5adbc27747b9056e74161d14934d72f8c" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;단계를&lt;/a&gt; 사용하여 rangeStart 값을 제외하지 않고 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값 으로 이동합니다 . 뒤로 이동하려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.LongProgression.Companion%24fromClosedRange(kotlin.Long,%20kotlin.Long,%20kotlin.Long)/step&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8d8b7627f24846e9a31abff3ae25964002a498bf" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange%28kotlin.UInt%2C+kotlin.UInt%2C+kotlin.Int%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="890067d4bb4a41e1198a024fd7c7c538b8728df3" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;단계를&lt;/a&gt; 사용하여 rangeStart 값을 제외하지 않고 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값 으로 이동합니다 . 뒤로 이동하려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.UIntProgression.Companion%24fromClosedRange(kotlin.UInt,%20kotlin.UInt,%20kotlin.Int)/step&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="bc7d38b12995812c4efea617bb206ec4460e9ccc" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;step을&lt;/a&gt; 제외 하고 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2FrangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값을 제외하고 진행 합니다. 뒤로 가려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange%28kotlin.ULong%2C+kotlin.ULong%2C+kotlin.Long%29%2Fstep&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cfd566a721eacfbba5c78dd8988340e1f6d111e0" translate="yes" xml:space="preserve">
          <source>The progression starts with the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; value and goes toward the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; value not excluding it, with the specified &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt;. In order to go backwards the &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;step&lt;/a&gt; must be negative.</source>
          <target state="translated">진행은 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeStart&quot;&gt;rangeStart&lt;/a&gt; 값으로 시작 하여 지정된 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;단계를&lt;/a&gt; 사용하여 rangeStart 값을 제외하지 않고 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/rangeEnd&quot;&gt;rangeEnd&lt;/a&gt; 값 으로 이동합니다 . 뒤로 이동하려면 &lt;a href=&quot;from-closed-range#kotlin.ranges.ULongProgression.Companion%24fromClosedRange(kotlin.ULong,%20kotlin.ULong,%20kotlin.Long)/step&quot;&gt;단계&lt;/a&gt; 가 음수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f35887cf67bb91d63b75657011139a4b8f31176b" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">프로젝트 파일은 C interop을 빌드의 추가 단계로 구성합니다. &lt;code&gt;interop.def&lt;/code&gt; 파일을 &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; 디렉토리 로 이동하십시오 . Gradle은 구성 대신 규칙을 사용하는 것이 좋습니다. 예를 들어 소스 파일은 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더에 있어야 합니다. 기본적으로 C의 모든 심볼을 &lt;code&gt;interop&lt;/code&gt; 패키지로 가져옵니다. 전체 패키지를 &lt;code&gt;.kt&lt;/code&gt; 파일 로 가져 오는 것이 좋습니다 . &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인 문서를 확인하여 구성 할 수있는 모든 다른 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="c7f7aa55f08a335c3d3db3f646f14c719c538320" translate="yes" xml:space="preserve">
          <source>The project file configures the C interop as an additional step of the build. Let's move the &lt;code&gt;interop.def&lt;/code&gt; file to the &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder. By default, all the symbols from C are imported to the &lt;code&gt;interop&lt;/code&gt; package, we may want to import the whole package in our &lt;code&gt;.kt&lt;/code&gt; files. Check out the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin documentation to learn about all the different ways you could configure it.</source>
          <target state="translated">프로젝트 파일은 빌드의 추가 단계로 C interop을 구성합니다. 하자가 이동 &lt;code&gt;interop.def&lt;/code&gt; 을 받는 파일을 &lt;code&gt;src/nativeInterop/cinterop&lt;/code&gt; 디렉토리. Gradle은 구성 대신 규칙을 사용할 것을 권장합니다. 예를 들어 소스 파일은 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더에 있어야 합니다. 기본적으로 C의 모든 기호는 &lt;code&gt;interop&lt;/code&gt; 패키지로 가져 &lt;code&gt;.kt&lt;/code&gt; 파일 의 전체 패키지를 가져올 수 있습니다. 구성 할 수있는 모든 다양한 방법에 대해 알아 보려면 &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인 문서를 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="04a29f21fc01df00a35820fecf66f137da298242" translate="yes" xml:space="preserve">
          <source>The project is ready. The next step is to open it in IntelliJ IDEA. For advanced build scenarios, it is recommended to refer to the &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;more detailed&lt;/a&gt; documentation.</source>
          <target state="translated">프로젝트가 준비되었습니다. 다음 단계는 IntelliJ IDEA에서 여는 것입니다. 고급 빌드 시나리오의 경우 &lt;a href=&quot;../../reference/building-mpp-with-gradle#setting-up-a-multiplatform-project&quot;&gt;자세한&lt;/a&gt; 문서 를 참조하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b358195ade68af7da060ed2c5bd98eb5f625c0a9" translate="yes" xml:space="preserve">
          <source>The project source roots</source>
          <target state="translated">프로젝트 소스 루트</target>
        </trans-unit>
        <trans-unit id="6b692a2a5504099d52b9ee1d8cd9e82682b0438b" translate="yes" xml:space="preserve">
          <source>The project structure looks like this:</source>
          <target state="translated">프로젝트 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85001da371d8ff3d4160eee8edd3719f9a8a82c8" translate="yes" xml:space="preserve">
          <source>The project's source files are unchanged.</source>
          <target state="translated">프로젝트의 소스 파일은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe6d1020447b5badd7227ed9268d67a33471daca" translate="yes" xml:space="preserve">
          <source>The property that can be used as a placeholder for statements and values that are defined in JavaScript.</source>
          <target state="translated">JavaScript로 정의 된 명령문 및 값의 플레이스 홀더로 사용할 수있는 특성입니다.</target>
        </trans-unit>
        <trans-unit id="fe5ea5ce74d05b50ab08ac3eaf5980cd10f01114" translate="yes" xml:space="preserve">
          <source>The property which this accessor is originated from.</source>
          <target state="translated">이 접근자가 시작된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="f478ed7d5b12b6f5e34c37814b287211378258c6" translate="yes" xml:space="preserve">
          <source>The provisions of the &lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin evolution policy&lt;/a&gt; fully apply only to components that have reached Full Stability (FS). From that point on incompatible changes have to be approved by the Language Committee.</source>
          <target state="translated">&lt;a href=&quot;kotlin-evolution&quot;&gt;Kotlin 진화 정책&lt;/a&gt; 의 조항은 전체 안정성 (FS)에 도달 한 구성 요소에만 완전히 적용됩니다. 그 시점부터 언어위원회는 호환되지 않는 변경 사항을 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e0268d689de7d5f78e70c6cb1e82a66dc683856" translate="yes" xml:space="preserve">
          <source>The publication of this target is handled by the Kotlin plugin and doesn't require the steps that are specific to the Java plugin, such as manually creating a publication and configuring it as &lt;code&gt;from(components.java)&lt;/code&gt;.</source>
          <target state="translated">이 대상의 공개는 Kotlin 플러그인에 의해 처리되며 공개를 수동으로 작성하고 &lt;code&gt;from(components.java)&lt;/code&gt; 로 구성하는 것과 같이 Java 플러그인에 특정한 단계가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="38341133c8abc06ea8b313769f8407419006fee4" translate="yes" xml:space="preserve">
          <source>The purpose of this code is to write out some text in the console. In order to use this from the browser, load it, preferably from inside an HTML page:</source>
          <target state="translated">이 코드의 목적은 콘솔에서 일부 텍스트를 작성하는 것입니다. 브라우저에서 이것을 사용하려면 HTML 페이지 내부에서로드하십시오.</target>
        </trans-unit>
        <trans-unit id="dc84bc4a3671f7fd39fcbdb5d811a4f7dfb04fdc" translate="yes" xml:space="preserve">
          <source>The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">C의 API 매핑을 시도하는 가장 빠른 방법은 모든 C 선언하는 것입니다 &lt;code&gt;interop.def&lt;/code&gt; 의 어떤 생성하지 않고, 파일을 &lt;code&gt;.h&lt;/code&gt; 의 &lt;code&gt;.c&lt;/code&gt; 인 모든에서 파일을. 그런 다음 특수 &lt;code&gt;---&lt;/code&gt; 구분 기호 줄 뒤에 &lt;code&gt;.def&lt;/code&gt; 파일 에 C 선언을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="086ba4582c0f9ff5d704a53067f7ea26f2bef36a" translate="yes" xml:space="preserve">
          <source>The range of indices in the input string where group was captured.</source>
          <target state="translated">그룹이 캡처 된 입력 문자열의 인덱스 범위입니다.</target>
        </trans-unit>
        <trans-unit id="d16563c64c4aedfc780b010fa9c5624f673175d2" translate="yes" xml:space="preserve">
          <source>The range of indices in the original string where match was captured.</source>
          <target state="translated">일치가 캡처 된 원래 문자열의 인덱스 범위입니다.</target>
        </trans-unit>
        <trans-unit id="199d1e88f27ba9b05b8adc73d8d822df0cadd36a" translate="yes" xml:space="preserve">
          <source>The read-only collection types are &lt;a href=&quot;generics#variance&quot;&gt;covariant&lt;/a&gt;. This means that, if a &lt;code&gt;Rectangle&lt;/code&gt; class inherits from &lt;code&gt;Shape&lt;/code&gt;, you can use a &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; anywhere the &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; is required. In other words, the collection types have the same subtyping relationship as the element types. Maps are covariant on the value type, but not on the key type.</source>
          <target state="translated">읽기 전용 콜렉션 유형은 &lt;a href=&quot;generics#variance&quot;&gt;공변량&lt;/a&gt; 입니다. 즉, &lt;code&gt;Rectangle&lt;/code&gt; 클래스가 &lt;code&gt;Shape&lt;/code&gt; 에서 상속되는 경우 &lt;code&gt;List&amp;lt;Shape&amp;gt;&lt;/code&gt; 이 필요한 곳이면 &lt;code&gt;List&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 사용할 수 있습니다 . 즉, 컬렉션 유형은 요소 유형과 동일한 하위 유형 관계를 갖습니다. 지도는 값 유형에 대해 공변량이지만 키 유형에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ddb83b3e5eaf3228b8ed04e27d5be844d1ede7b" translate="yes" xml:space="preserve">
          <source>The reason we're seeing the actual output is because the call &lt;code&gt;curl_easy_perform&lt;/code&gt; prints the result to the standard output. We could hide this using &lt;code&gt;curl_easy_setopt&lt;/code&gt;.</source>
          <target state="translated">실제 출력을 보는 이유는 &lt;code&gt;curl_easy_perform&lt;/code&gt; 호출 이 결과를 표준 출력에 인쇄 하기 때문 입니다. &lt;code&gt;curl_easy_setopt&lt;/code&gt; 를 사용하여 이것을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4670c1839cea0120059e336f30de1dda186179ab" translate="yes" xml:space="preserve">
          <source>The recommended way to use Kotlin/JS is via the &lt;code&gt;kotlin.js&lt;/code&gt; and &lt;code&gt;kotlin.multiplatform&lt;/code&gt; Gradle plugins. They provide a central and convenient way to set up and control Kotlin projects targeting JavaScript. This includes essential functionality such as controlling the bundling of your application, adding JavaScript dependencies directly from npm, and more. To get an overview of the available options, check out the &lt;a href=&quot;js-project-setup&quot;&gt;Kotlin/JS project setup&lt;/a&gt; documentation.</source>
          <target state="translated">Kotlin / JS를 사용하는 권장 방법은 &lt;code&gt;kotlin.js&lt;/code&gt; 및 &lt;code&gt;kotlin.multiplatform&lt;/code&gt; Gradle 플러그인을 사용하는 것입니다. JavaScript를 대상으로하는 Kotlin 프로젝트를 설정하고 제어하는 ​​중앙의 편리한 방법을 제공합니다. 여기에는 애플리케이션 번들링 제어, npm에서 직접 JavaScript 종속성 추가 등과 같은 필수 기능이 포함됩니다. 사용 가능한 옵션에 대한 개요를 보려면 &lt;a href=&quot;js-project-setup&quot;&gt;Kotlin / JS 프로젝트 설정&lt;/a&gt; 문서를 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="58ca5ea2bf2b7e6112a4ed6c521b74a4fb8e1b96" translate="yes" xml:space="preserve">
          <source>The reference is a value of type &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;.</source>
          <target state="translated">참조는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; 유형의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="225d32a1d2d879830740b8e0770ecbbb02de2cc7" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, and &lt;code&gt;this&lt;/code&gt; is frozen - it must be frozen or permanent object.</source>
          <target state="translated">참조 된 값. 값을 가져 오거나 새 값을 설정합니다. 새 값이 null이 아닌 경우 및 &lt;code&gt;this&lt;/code&gt; 냉동 - 그것은 냉동 또는 고정 된 물체해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e1c9e946585f6c5b784f91adc26c58c91e5a3c2" translate="yes" xml:space="preserve">
          <source>The referenced value. Gets the value or sets the new value. If new value is not null, it must be frozen or permanent object.</source>
          <target state="translated">참조 된 값. 값을 가져 오거나 새 값을 설정합니다. 새 값이 null이 아닌 경우 고정되거나 영구 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="04f24df5fbabe6af37ab1161e95151a96c9196e9" translate="yes" xml:space="preserve">
          <source>The repositories where the library will be published are added via the &lt;code&gt;repositories&lt;/code&gt; block in the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL, as explained in &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin. Repositories&lt;/a&gt;.</source>
          <target state="translated">라이브러리가 게시 될 &lt;code&gt;repositories&lt;/code&gt; 는 &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven:repositories&quot;&gt;Maven Publish Plugin에&lt;/a&gt; 설명 된대로 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL 의 리포지토리 블록을 통해 추가됩니다 . 리포지토리 .</target>
        </trans-unit>
        <trans-unit id="7ffbb195d8e128e52d788e2edb39be54dd761c55" translate="yes" xml:space="preserve">
          <source>The rest of the procedure works in exactly the same way as in Java.</source>
          <target state="translated">나머지 절차는 Java에서와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="81a9c69ffb22a2342532cf8251cc7d0415b9dbb2" translate="yes" xml:space="preserve">
          <source>The result is an object which represents a reference to the property (the &quot;Platonic ideal&quot; property, not a property on a particular instance). There's a type hierarchy for property objects: the base interface is &lt;code&gt;KProperty&lt;/code&gt;, which lets you get metadata about the property, such as its name and type. If you want to use the property object to read or modify the property's value in an object, you need to use a subinterface that specifies what kind of property it is. Immutable properties typically are &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;, and mutable properties typically are &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt;. Both of these are generic interfaces, with &lt;code&gt;R&lt;/code&gt; being the receiver type (the type on which the property is declared, in this case &lt;code&gt;Person&lt;/code&gt;) and &lt;code&gt;V&lt;/code&gt; being the type of the property's value.</source>
          <target state="translated">결과는 속성 (특정 인스턴스의 속성이 아닌 &quot;Platonic ideal&quot;속성)에 대한 참조를 나타내는 객체입니다. 속성 객체에 대한 유형 계층이 있습니다. 기본 인터페이스는 &lt;code&gt;KProperty&lt;/code&gt; 이며, 속성 및 속성과 같은 속성에 대한 메타 데이터를 가져올 수 있습니다. 속성 개체를 사용하여 개체의 속성 값을 읽거나 수정하려면 속성의 종류를 지정하는 하위 인터페이스를 사용해야합니다. 불변 속성은 일반적으로 &lt;code&gt;KProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; 이며, 불변 속성은 일반적으로 &lt;code&gt;KMutableProperty1&amp;lt;R, V&amp;gt;&lt;/code&gt; 입니다. 둘 다 일반 인터페이스이며 &lt;code&gt;R&lt;/code&gt; 은 수신자 유형 (속성이 선언 된 유형 (이 경우 &lt;code&gt;Person&lt;/code&gt; ) 임)) 및 &lt;code&gt;V&lt;/code&gt; 는 속성 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1a8aae926c8fa4cd902ab72788ba84f110e52d36" translate="yes" xml:space="preserve">
          <source>The result is computed as &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; where &lt;code&gt;q&lt;/code&gt; is the quotient of division rounded to the nearest integer, &lt;code&gt;q = round(this / other)&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;r = this - (q * divisor)&lt;/code&gt; 로 계산됩니다. 여기서 &lt;code&gt;q&lt;/code&gt; 는 가장 가까운 정수로 반올림 한 몫의 정수입니다. &lt;code&gt;q = round(this / other)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8346187656aa601c46c1b882160101b5d70d1783" translate="yes" xml:space="preserve">
          <source>The result is going to be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f757614cb2200a5a31db5b9a50190e9f1a783287" translate="yes" xml:space="preserve">
          <source>The result is the same, but this code uses only non-blocking &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt;. The main thread invoking &lt;code&gt;runBlocking&lt;/code&gt;&lt;em&gt;blocks&lt;/em&gt; until the coroutine inside &lt;code&gt;runBlocking&lt;/code&gt; completes.</source>
          <target state="translated">결과는 동일하지만이 코드는 비 블로킹 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;지연&lt;/a&gt; 만 사용합니다 . 호출 메인 스레드 &lt;code&gt;runBlocking&lt;/code&gt; &lt;em&gt;블록&lt;/em&gt; 내부의 코 루틴까지 &lt;code&gt;runBlocking&lt;/code&gt; 의 완료.</target>
        </trans-unit>
        <trans-unit id="80513416e38e21b1cd6b19983bdbc1cd0f8dbc1d" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;minus&lt;/code&gt; contains the elements of the original collection &lt;em&gt;except&lt;/em&gt; the elements from the second operand. If it's an element, &lt;code&gt;minus&lt;/code&gt; removes its &lt;em&gt;first&lt;/em&gt; occurrence; if it's a collection, &lt;em&gt;all&lt;/em&gt; occurrences of its elements are removed.</source>
          <target state="translated">&lt;code&gt;minus&lt;/code&gt; 결과 에는 두 번째 피연산자의 요소를 &lt;em&gt;제외하고&lt;/em&gt; 원래 컬렉션 의 요소가 포함됩니다. 요소 인 경우 &lt;code&gt;minus&lt;/code&gt; 하면 &lt;em&gt;첫 번째&lt;/em&gt; 항목이 제거됩니다 . 이 콜렉션의 경우, &lt;em&gt;모든&lt;/em&gt; 요소의 발생이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9f4386a5cc0897ae566404e34449e10c9271784f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;plus&lt;/code&gt; contains the elements from the original collection &lt;em&gt;and&lt;/em&gt; from the second operand.</source>
          <target state="translated">&lt;code&gt;plus&lt;/code&gt; 결과 에는 원래 컬렉션 &lt;em&gt;과&lt;/em&gt; 두 번째 피연산자 의 요소가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ff8add7f5e14fd024c26ef191ab483a18b621fed" translate="yes" xml:space="preserve">
          <source>The result of the future computation. Blocks execution until the future is ready. Second attempt to get will result in an error.</source>
          <target state="translated">미래 계산의 결과. 미래가 준비 될 때까지 실행을 차단합니다. 두 번째로 시도하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b0a33939298c1573b79334a09954b9afb450d438" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in mode detail:</source>
          <target state="translated">이 코드의 결과는 매우 흥미 롭기 때문에 모드를 자세히 분석 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a889b01b76fad01cdae52fa6c7d371792173b90" translate="yes" xml:space="preserve">
          <source>The result of this code is quite interesting, so we'll analyze it in more detail:</source>
          <target state="translated">이 코드의 결과는 매우 흥미 롭기 때문에 더 자세히 분석 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a92982b6e3242403fa82d0db42fdb4534028b312" translate="yes" xml:space="preserve">
          <source>The result of this code is:</source>
          <target state="translated">이 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee6868c39ff4d2539255b06db5a2381813300a75" translate="yes" xml:space="preserve">
          <source>The result of this code:</source>
          <target state="translated">이 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4844d20ae5c2024023a55c2b6b3214cb6ce72593" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">결과 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; 은 자연 정렬 순서에 따라 키의 동등성과 순서를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e25355ad3b686053cc1bc487b49186167f01eccb" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to the sorting order provided by the given &lt;a href=&quot;sorted-map-of#kotlin.collections%24sortedMapOf(java.util.Comparator((kotlin.collections.sortedMapOf.K)),%20kotlin.Array((kotlin.Pair((kotlin.collections.sortedMapOf.K,%20kotlin.collections.sortedMapOf.V)))))/comparator&quot;&gt;comparator&lt;/a&gt;.</source>
          <target state="translated">결과 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; 은 주어진 &lt;a href=&quot;sorted-map-of#kotlin.collections%24sortedMapOf(java.util.Comparator((kotlin.collections.sortedMapOf.K)),%20kotlin.Array((kotlin.Pair((kotlin.collections.sortedMapOf.K,%20kotlin.collections.sortedMapOf.V)))))/comparator&quot;&gt;비교기가&lt;/a&gt; 제공하는 정렬 순서에 따라 키의 동일성과 순서를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="634514a1676e5366bef12944cb3543ffee02d086" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; determines the equality and order of keys according to their natural sorting order.</source>
          <target state="translated">결과 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/SortedMap.html&quot;&gt;SortedMap&lt;/a&gt; 은 자연스러운 정렬 순서에 따라 키의 동일성과 순서를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8f890bef6e41ea49023cd4e145c9ac8e02777347" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UByte&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bcc21fce83c8a76fb70c4188dec066655dc99e5f" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toByte()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toByte()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="500fd389152dfac3d3a3bdf516db69049b6112d1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5d708d0dd756dc92bd87189470b9a3b0f187bad" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1c617d1ad1ce5e0250376516d3fc7acee8c76a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c0aa6565c5cc7948d96b6aa45e671f5d970085c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 . 결과 &lt;code&gt;Byte&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd46bb58530a520cf29001659a58a32130329b50" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 . 결과 &lt;code&gt;Byte&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0796ad9fb92ce12d111b3b2e535fa3a4138ff67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Byte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value. Note that the resulting &lt;code&gt;Byte&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Byte&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 . 결과 &lt;code&gt;Byte&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dcececb10dcdcffc92e35f3fc84338088990b5d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is equal to this value reinterpreted as an unsigned number, i.e. it has the same binary representation as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드는 부호없는 숫자로 재 해석 된이 값과 같습니다. 즉,이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 이진 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d3990133293f18f718906ea26c50d316e7978f0" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드는이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드는이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toChar()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Float&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 . 결과적인 &lt;code&gt;Int&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toShort()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 . 결과 &lt;code&gt;Short&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 . 결과 &lt;code&gt;Short&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Long&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Double&lt;/code&gt; 입니다. 이 &lt;code&gt;Long&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Double&lt;/code&gt; 사이에 있는 경우 최소 유효 비트 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;ULong&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Double&lt;/code&gt; 입니다. 이 &lt;code&gt;ULong&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Double&lt;/code&gt; 사이에 있는 경우, 적어도 유의 한 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Double&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Int&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Int&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Long&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Long&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;UInt&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;UInt&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;ULong&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;ULong&lt;/code&gt; 값이 정확히 2 개의 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 유의 한 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">익명 함수에 대한 리턴 유형 유추는 일반 함수와 동일하게 작동합니다. 리턴 유형은 표현식 본문이있는 익명 함수에 대해 자동으로 추론 되며 블록 본문이있는 익명 함수에 대해 명시 적으로 지정되거나 &lt;code&gt;Unit&lt;/code&gt; 으로 간주되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 타입 리턴 타입의 리턴 타입 (사용자는 리턴 된 함수가 &lt;code&gt;Fruit&lt;/code&gt; 을 리턴 할 것으로 예상 하므로 실제로 &lt;code&gt;Apple&lt;/code&gt; 을 리턴해도 괜찮습니다 )</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">람다 식의 반환 형식은 그 안에있는 마지막 식의 형식 (또는 람다식이 할당 된 변수 / 매개 변수의 함수 형식)에서 유추됩니다. 람다식이 함수 매개 변수 (일반적인 용도)로 전달되거나 선언 된 유형의 변수에 지정된 경우 Kotlin은 매개 변수 유형도 유추 할 수 있으며 해당 이름 만 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">의 반환 값 &lt;code&gt;apply&lt;/code&gt; 하고 &lt;code&gt;also&lt;/code&gt; 상황에 맞는 객체 자체입니다. 따라서 이러한 &lt;em&gt;단계는&lt;/em&gt; 호출 &lt;em&gt;단계에 부가 단계&lt;/em&gt; 로 포함될 수 있습니다 . 함수 호출은 이후에 동일한 객체에서 함수 호출을 계속 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">리턴 된 인스턴스는 지정된 &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;잠금&lt;/a&gt; 오브젝트를 사용하여 동기화합니다. 하면 &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;잠금이&lt;/a&gt; 이 경우 자체에 동기화 할 수있는 인스턴스 용도를 지정하지 않은 것이 실수로 교착 상태가 발생할 수 있으므로 반환 된 인스턴스의 외부 코드에서 동기화하지 않습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b93655dba3d2a18324e24a42bc0aa37bcaff559" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">반환 된 인스턴스는 지정된 &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;잠금&lt;/a&gt; 개체를 사용하여 동기화합니다. 하면 &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;잠금이&lt;/a&gt; 이 경우 자체에 동기화 할 수있는 인스턴스 용도를 지정하지 않은 것이 실수로 교착 상태가 발생할 수 있으므로 반환 된 인스턴스의 외부 코드에서 동기화하지 않습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">이 문자 순서에 2 자 미만이 포함되어 있으면 리턴 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">이 컬렉션에 요소가 2 개 미만인 경우 반환 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">리턴 된 맵은 직렬화 가능 (JVM)입니다.</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">반환 된 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">반환 된 맵은 원래 배열에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">리턴 된 맵은 원래 문자 시퀀스에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">리턴 된 맵은 원래 콜렉션에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">반환 된 맵은 원래 시퀀스에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">반환 된 맵은 원래 배열의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">반환 된 맵은 원래 배열의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">리턴 된 맵은 원래 문자 시퀀스의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">반환 된 맵은 원본 컬렉션의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">반환 된 맵은 원본 컬렉션의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;쌍&lt;/a&gt; 은 고유 키가있는 경우 결국 반복된다.</target>
        </trans-unit>
        <trans-unit id="2699ea2c18d183922dd8db09dd9a3f0e18a1eb1d" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;쌍&lt;/a&gt; 은 고유 키가있는 경우 결국 반복된다.</target>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키를 가진 해당 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 배열 순서로 결국 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 그 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 고유 키와 함께의 순서로 결국 반복되는 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 그 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 고유 키와 함께의 순서로 결국 반복되는 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍의&lt;/a&gt; 순서.</target>
        </trans-unit>
        <trans-unit id="f1a276280301194297ba4dd69f82e32624b066f0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키가있는 이러한 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 배열 의 순서로 마지막에 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="60a4b6ca8bf806aec99d136cb53e3d0881c0b238" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키가있는 이러한 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 수집 순서대로 마지막에 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1d13bbc3f9bab24f8a9c962714d64145931ced0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키가있는 이러한 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 순서 대로 끝에서 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 이 맵에서 누락 된 다른 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;맵의&lt;/a&gt; 항목은 해당 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;맵&lt;/a&gt; 순서대로 끝까지 반복 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b1dd6b497b334d1c744c85f81ba4c2ff9742b26" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 이 맵에서 누락 된 다른 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;맵의&lt;/a&gt; 항목은 해당 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;맵&lt;/a&gt; 의 순서대로 마지막에 반복 됩니다 .</target>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">리턴 된 맵은 원래 순서의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">리턴 된 맵은 원래 순서의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">리턴 된 맵은 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">반환 된 시퀀스는 한 번만 반복되도록 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">이 시퀀스에 요소가 2 개 미만인 경우 반환 된 시퀀스가 ​​비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="3daac3d7a93bd39f019e22a0fe48ced02c6896f9" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">리턴 된 세트는 원래 문자 순서의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">반환 된 집합은 원본 컬렉션의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원본 컬렉션의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="c4910c50663c8a64b733d52ca426f65568fa0287" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원래 컬렉션의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">리턴 된 세트는 원래 순서의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">리턴 된 세트는 원래 세트의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">리턴 된 세트는 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;y&lt;/code&gt; 되도록 &lt;code&gt;sinh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;y&lt;/code&gt; 되도록 &lt;code&gt;tanh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">반환 값은 양수 &lt;code&gt;y&lt;/code&gt; 이므로 &lt;code&gt;cosh(y) == x&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; -expression 의 리턴 값은 &lt;em&gt;try&lt;/em&gt; 블록의 마지막 표현식 이거나 &lt;em&gt;catch&lt;/em&gt; 블록 (또는 블록) 의 마지막 표현식입니다 . &lt;em&gt;finally&lt;/em&gt; 블록의 내용은 표현식 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin 클래스 계층의 루트 모든 Kotlin 클래스에는 &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; 가 수퍼 클래스로 있습니다.</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin 클래스 계층의 루트 모든 Kotlin 클래스에는 &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; 가 수퍼 클래스로 있습니다.</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">러너는 system.path.macro.KOTLIN.BUNDLED 속성의 값을 IntelliJ IDEA 프로젝트의 경로 설정에 따라 올바른 값으로 설정합니다. 그러나이 값은 TeamCity에서 정의해야하며 임의의 값으로 설정할 수 있습니다. 따라서 시스템 변수로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt; 함수가있는 맵에서도 동일하게 사용할 수 있습니다 . 지도의 키와 값은 &lt;code&gt;Pair&lt;/code&gt; 객체 로 전달됩니다 (보통 함수를 사용 &lt;code&gt;to&lt;/code&gt; 생성 ).</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Kotlin / Native 컴파일러 는 모든 플랫폼에 대해 &lt;code&gt;.h&lt;/code&gt; 파일 을 생성하기 위해 동일한 규칙을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;Float&lt;/code&gt; 인수 에도 동일한 함수 세트 (상수는 없음)를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">동일한 구문을 사용하여 전체 파일에 주석을 달 수 있습니다. 이렇게하려면 , 파일이 기본 패키지에있는 경우, 파일의 최상위 레벨, 패키지 지시문 앞 또는 모든 가져 오기 전에 대상 &lt;code&gt;file&lt;/code&gt; 에 주석을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">형식 인수를 고려하지 않은 캐스트에 대해서는 형식 인수가 생략 된 동일한 구문을 사용할 수 있습니다. &lt;code&gt;list as ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;getX()&lt;/code&gt; 함수와 함께 &lt;code&gt;x&lt;/code&gt; 속성이 필요한 경우에도 동일한 트릭이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">공변량 및 반 변량 예측에 동일한 유형 매개 변수를 사용할 수 있습니다 (유형 매개 변수가 아닌 투영되는 일반 클래스이므로).</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">결과의 스케일의 스케일과 동일하다 &lt;code&gt;this&lt;/code&gt; (divident) 및 라운딩 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; 라운딩 모드를 사용한다.</target>
        </trans-unit>
        <trans-unit id="862c489ca779c92aa7c1ebb24e7220c5850ae722" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">결과의 스케일은 &lt;code&gt;this&lt;/code&gt; (나누기) 스케일과 동일 하며 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; 반올림 모드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">범위 함수는 반환 결과에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">스코프 함수는 새로운 기술 기능을 도입하지 않지만 코드를보다 간결하고 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">두 번째 줄은 &lt;code&gt;headerFilter&lt;/code&gt; 입니다. 이것은 정확히 우리가 포함하고 싶은 것을 나타내는 데 사용됩니다. C에서 한 파일이 &lt;code&gt;#include&lt;/code&gt; 지시문으로 다른 파일을 참조 하면 모든 헤더도 포함됩니다. 때때로 이것은 필요하지 않을 수 있으며, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;glob 패턴을&lt;/a&gt; 사용하여이 매개 변수를 사용하여 사물을 미세 조정할 수 있습니다. 참고 것을 &lt;code&gt;headerFilter&lt;/code&gt; 는 선택적 인수이며, 대부분은 단지 우리가 사용하고있는 라이브러리가 시스템 라이브러리로 설치하는 경우에 사용, 우리는 (예 : 시스템과 같은 외부 종속성을 가져하지 않으 &lt;code&gt;stdint.h&lt;/code&gt; 의 우리의 상호 운용성 라이브러리에 헤더를). 라이브러리 크기를 최적화하고 시스템과 Kotlin / Native 제공 컴파일 환경 간의 잠재적 충돌을 수정하는 것이 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">두 번째 목록에는 두 번째 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">두 번째 관찰 은 채널이 이미 닫혀 있으면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; 이 즉시 선택 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">두 번째 단계는 생성 된 바이너리의 프레임 워크 검색 경로를 구성하는 것입니다. &lt;code&gt;rpath&lt;/code&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;런타임 검색 경로&lt;/a&gt; 라고도 합니다 . 바이너리는 경로를 사용하여 필요한 프레임 워크를 찾습니다. 필요하지 않은 경우 추가 프레임 워크를 OS에 설치하지 않는 것이 좋습니다. 예를 들어, 향후 응용 프로그램의 레이아웃을 이해해야합니다. 예를 들어, 사용하는 모든 프레임 워크와 함께 응용 프로그램 번들 아래에 &lt;code&gt;Frameworks&lt;/code&gt; 폴더 가있을 수 있습니다. &lt;code&gt;@rpath&lt;/code&gt; 의 파라미터 엑스 코드로 구성 될 수있다. &lt;em&gt;프로젝트&lt;/em&gt; 구성 을 열고 &lt;code&gt;Runpath Search Paths&lt;/code&gt; 섹션을 찾아야합니다 . 여기서는 컴파일 된 프레임 워크의 상대 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">두 번째 단계는 &lt;em&gt;대상&lt;/em&gt; 구성 페이지 의 &lt;code&gt;Build Settings&lt;/code&gt; 섹션에있는 &lt;code&gt;Framework Search Paths&lt;/code&gt; 블록에 프레임 워크 경로를 포함시키는 것 입니다. 사용할 수 있습니다 &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; 설정을 단순화하기 위해 매크로를.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">두 번째 방법은 형식화 된 게터를 사용하는 것입니다. 이 게터를 사용하면 이름 접두사 및 빌드 유형으로 특정 유형의 이진 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">순서는 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed로&lt;/a&gt; 시작할 때마다 여러 번 반복 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc73d4e6f9fffbb0e65e07b8a9240c6689985bdd" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">시퀀스는 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed로&lt;/a&gt; 시작할 때마다 여러 번 반복 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">시퀀스는 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">순서는 잠재적으로 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">주어진 반복자가 반환 한 값의 시퀀스는 잠재적으로 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">시퀀스 작업은 상태 요구 사항과 관련하여 다음 그룹으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">시퀀스 처리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값 이 발생할 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction의&lt;/a&gt; 반환 &lt;code&gt;null&lt;/code&gt; , 빈 시퀀스를 생성한다.</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값 이 발생할 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;씨앗&lt;/a&gt; 이다 &lt;code&gt;null&lt;/code&gt; 빈 시퀀스가 생성된다.</target>
        </trans-unit>
        <trans-unit id="7f85b3586f825638607e86e68f4e2c3390aaa658" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값을 만날 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction의&lt;/a&gt; 반환 &lt;code&gt;null&lt;/code&gt; , 빈 시퀀스를 생성한다.</target>
        </trans-unit>
        <trans-unit id="2bd1e283bb0d03da60d7adf31bcae11b19146a2e" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값을 만날 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;씨앗&lt;/a&gt; 이다 &lt;code&gt;null&lt;/code&gt; 빈 시퀀스가 생성된다.</target>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">주어진 형식 매개 변수로 대체 할 수있는 모든 가능한 형식 집합은 &lt;strong&gt;일반 제약 조건에&lt;/strong&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">이 정규 표현식을 작성하는 데 사용 된 옵션 세트.</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">대상 플랫폼 세트는 다중 플랫폼 라이브러리 작성자가 정의하며 라이브러리에 대한 모든 플랫폼 별 구현을 제공해야합니다. 소비자 측에서 멀티 플랫폼 라이브러리에 대한 새 대상 추가는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">속성 값을 변경하는 데 사용되는이 가변 속성의 setter입니다.</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">의 서명 &lt;code&gt;greet()&lt;/code&gt; 입니다 &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; 이 켜져 함수이기 때문에 &lt;code&gt;Person&lt;/code&gt; 소요 &lt;code&gt;String&lt;/code&gt; 과 리턴 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">멤버 함수 또는 &lt;a href=&quot;extension-functionsproperties&quot;&gt;확장 함수&lt;/a&gt; 의 서명은 &lt;em&gt;수신자 (&lt;/em&gt; 함수를 호출 할 수있는 유형)로 시작합니다 . 예를 들어 &lt;code&gt;toString()&lt;/code&gt; 의 서명 은 &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; -null이 아닌 객체 (수신자)에서 호출 할 수 있으며 매개 변수를 사용하지 않고 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 . 이러한 서명으로 람다 함수를 작성할 수 있습니다.이를 &lt;em&gt;수신자와 함께 함수 리터럴&lt;/em&gt; 이라고하며 DSL을 작성하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">재정의 함수의 반환 유형이 재정의 된 함수의 반환 유형의 하위 유형일 수 있다는 점을 제외하고 재정의 함수의 서명은 재정의 된 서명과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb5cfcfa1d9e07364a5b05687e8945f6f792b6b5" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is a class of an anonymous object).</source>
          <target state="translated">소스 코드에 선언 된 클래스의 단순 이름 또는 클래스에 이름이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다 (예 : 익명 객체의 클래스 인 경우).</target>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">소스 코드에서 선언 된 클래스의 단순 이름이거나 클래스에 이름이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다 (예 : 익명의 객체 리터럴 인 경우).</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">가장 간단한 버전은 추가 매개 변수가 필요하지 않으며 각 빌드 유형마다 하나의 바이너리를 만듭니다. 현재 두 가지 빌드 유형이 있습니다. &lt;code&gt;DEBUG&lt;/code&gt; (디버그 정보가있는 최적화되지 않은 이진 파일을 생성 함 ) 및 &lt;code&gt;RELEASE&lt;/code&gt; (디버그 정보가없는 최적화 된 이진 파일을 생성 함). 결과적으로 다음 스 니펫은 디버그 및 릴리스라는 두 개의 실행 가능 바이너리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">불변의 단일 C 값 자체 포함되어 있으며 기본 메모리에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">단일 부모 규칙은 클래스 계층 구조의 서로 다른 브랜치에서 클래스 사이에 공통점이 있기 때문에 종종 너무 제한됩니다. 이러한 공통성은 &lt;em&gt;인터페이스&lt;/em&gt; 로 표현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">해결책은 &lt;em&gt;위임 된 속성으로&lt;/em&gt; , &lt;em&gt;속성&lt;/em&gt; 을 가져오고 설정하는 동작을 지정할 수 있습니다 &lt;code&gt;__setattribute__()&lt;/code&gt; 파이썬에서 &lt;code&gt;__getattribute__()&lt;/code&gt; 및 __setattribute __ () 구현과 비슷 하지만 한 번에 하나의 속성).</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">해결책은 대상을 사용자 지정 특성으로 표시하는 것입니다.이 특성은 종속성 해결 중에 Gradle에서 고려됩니다. 그러나 이것은 라이브러리 작성자와 소비자 측 모두에서 수행되어야하며 속성과 가능한 값을 소비자에게 전달하는 것은 라이브러리 작성자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">정렬이 &lt;em&gt;안정적&lt;/em&gt; 입니다. 즉, 동일한 요소가 정렬 후 서로에 대한 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">소스 세트 이름은 대소 문자를 구분합니다. 이름으로 기본 소스 세트를 참조 할 때 이름 &lt;code&gt;iosX64Main&lt;/code&gt; 두부가 대상의 이름과 일치하는지 확인하십시오 (예 : 대상 &lt;code&gt;iosX64&lt;/code&gt; 의 소스 세트 iosX64Main) .</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">소스 세트 DSL을 사용하여 소스 세트 간의 이러한 연결을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">소스 세트는 &lt;code&gt;kotlin { ... }&lt;/code&gt; 확장자 의 &lt;code&gt;sourceSets { ... }&lt;/code&gt; 블록 내에 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">위임 된 객체에 대한 요구 사항의 사양은 &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;아래에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d73e9a80f0bf586c373c77dd33cae5cc1f592da3" translate="yes" xml:space="preserve">
          <source>The specified arrays are also considered deeply equal if both are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 배열도 둘 다 &lt;code&gt;null&lt;/code&gt; 인 경우 완전히 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">표준 JavaDoc 생성 플러그인 ( &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; )은 Kotlin 코드를 지원하지 않습니다. Kotlin 프로젝트에 대한 문서를 생성하려면 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka를&lt;/a&gt; 사용하십시오 . 구성 지침 은 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 . Dokka는 혼합 언어 프로젝트를 지원하며 표준 JavaDoc을 포함하여 여러 형식으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">표준 라이브러리에는 단일 호출에서 모음을 필터링 할 수있는 확장 기능 그룹이 포함되어 있습니다. 이러한 함수는 원본 컬렉션을 변경하지 않고 &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능하고 읽기 전용&lt;/a&gt; 컬렉션 에 모두 사용할 수 있습니다 . 필터링 결과를 조작하려면 필터링 후 결과를 변수에 지정하거나 함수를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">표준 라이브러리는 값을 동적 유형으로 캐스팅하는 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt; 이라는 함수를 정의합니다 . jQuery를 사용하여 DOM 요소로 작업 한 이전 예를 &lt;code&gt;asDynamic()&lt;/code&gt; 이제이를 asDynamic () 과 결합 하여 결과에서 &lt;code&gt;dataTable()&lt;/code&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">표준 라이브러리는 이제 비교 ( &lt;code&gt;contentEquals&lt;/code&gt; 및 &lt;code&gt;contentDeepEquals&lt;/code&gt; ), 해시 코드 계산 ( &lt;code&gt;contentHashCode&lt;/code&gt; 및 &lt;code&gt;contentDeepHashCode&lt;/code&gt; ) 및 문자열로 변환 ( &lt;code&gt;contentToString&lt;/code&gt; 및 &lt;code&gt;contentDeepToString&lt;/code&gt; )에 대한 요소 별 조작을위한 함수 세트를 제공합니다 . JVM ( &lt;code&gt;java.util.Arrays&lt;/code&gt; 의 해당 함수에 대한 별명으로 작동 ) 및 JS (구현이 Kotlin 표준 라이브러리에서 제공되는 경우) 모두에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt; 을 제공합니다 . 그러나 대부분의 경우 명명 된 데이터 클래스는 속성에 의미있는 이름을 제공하여 코드를 더 읽기 쉽게하기 때문에 더 나은 디자인 선택입니다.</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">표준 라이브러리는 정적 타이핑을 사용하여 JavaScript를 다루는 함수뿐만 아니라 DOM에 대한 일련의 래퍼를 제공합니다. 그러나 jQuery와 같은 라이브러리를 사용하려면 어떻게됩니까? Kotlin에는 JavaScript 생태계에서 사용 가능한 모든 다른 라이브러리에 대한 자체 &quot;헤더&quot;파일이 없지만 TypeScript에는 있습니다. &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;확실히 입력 된 저장소는&lt;/a&gt; 헤더 파일의 매우 큰 선택을 우리에게 제공한다.</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">표준 라이브러리는 코 루틴을 사용 하여 &lt;code&gt;yield&lt;/code&gt; 및 &lt;code&gt;yieldAll&lt;/code&gt; 함수로 &lt;em&gt;느리게 생성 된 시퀀스&lt;/em&gt; 를 지원 합니다. 이러한 시퀀스에서 시퀀스 요소를 반환하는 코드 블록은 각 요소가 검색된 후 일시 중단되고 다음 요소가 요청되면 다시 시작됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">&lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; 의 상태 값 은 컴파일러가 Kotlin에서 어노테이션이있는 유형의 부적절한 사용법을 처리하는 방법을 지정합니다 (예 : &lt;code&gt;@MyNullable&lt;/code&gt; -어노테이션이있는 유형 값을 널이 아닌 것으로 사용).</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">진행의 단계.</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">단계 값은 양수 여야합니다. 아래로 계산해야하는 경우 포괄적 인 &lt;code&gt;downTo&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">서브 클래스 &lt;em&gt;는&lt;/em&gt; 수퍼 클래스에 존재하는 모든 멤버 (수퍼 클래스에 직접 정의 된 멤버와 수퍼 클래스 자체가 상속 한 멤버)를 모두 상속합니다. 이 예에서 &lt;code&gt;Car&lt;/code&gt; 는 다음 멤버를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">이 일치에 의해 캡처 된 입력 문자열의 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">구문은 &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; 입니다. 속성에 해당하는 &lt;code&gt;get()&lt;/code&gt; (및 &lt;code&gt;set()&lt;/code&gt; )이 &lt;code&gt;getValue()&lt;/code&gt; 및 &lt;code&gt;setValue()&lt;/code&gt; 메소드에 &lt;em&gt;위임&lt;/em&gt; 되기 때문에 &lt;em&gt;by by&lt;/em&gt; 뒤의 표현식 은 &lt;em&gt;delegate&lt;/em&gt; 입니다. 부동산 대표는 인터페이스를 구현할 필요는 없지만, 그들은 제공해야 &lt;code&gt;getValue()&lt;/code&gt; 함수를 (와 &lt;code&gt;setValue()&lt;/code&gt; - 대한 &lt;em&gt;VAR&lt;/em&gt; 들). 예를 들면 다음과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">아래 표는 Kotlin 개념이 Swift / Objective-C에 매핑되고 그 반대의 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">사전 설정에서 생성 된 대상이 &lt;code&gt;kotlin.targets&lt;/code&gt; 도메인 객체 컬렉션에 추가되어 이름으로 액세스하거나 모든 대상을 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">용어는 &lt;code&gt;var&lt;/code&gt; 가 &lt;em&gt;가변&lt;/em&gt; 변수를 선언하고 &lt;code&gt;val&lt;/code&gt; 이 &lt;em&gt;읽기 전용&lt;/em&gt; 또는 &lt;em&gt;한 번만 할당&lt;/em&gt; 변수를 선언 하므로 두 종류를 모두 &lt;em&gt;변수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;예제 프로젝트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">세 번째 옵션은 NPE 애호가를위한 것입니다. Null이 아닌 어설 션 연산자 ( &lt;code&gt;!!&lt;/code&gt; )는 모든 값을 Null이 아닌 유형으로 변환하고 값이 null 인 경우 예외를 throw합니다. 우리는 &lt;code&gt;b!!&lt;/code&gt; 를 쓸 수있다 !! 이 경우 null이 아닌 값 &lt;code&gt;b&lt;/code&gt; (예 : &lt;code&gt;String&lt;/code&gt; 가 반환 되거나 &lt;code&gt;b&lt;/code&gt; 가 null 인 경우 NPE가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">세 가지 대상은 &lt;a href=&quot;#default-project-layout&quot;&gt;기본 구성&lt;/a&gt; 을 제공 하는 사전 설정 함수 &lt;code&gt;jvm()&lt;/code&gt; , &lt;code&gt;js()&lt;/code&gt; 및 &lt;code&gt;mingwX64()&lt;/code&gt; 됩니다. &lt;a href=&quot;#supported-platforms&quot;&gt;지원되는&lt;/a&gt; 각 플랫폼에 대한 사전 설정이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="865a447cbe3c80dc40999ce2ca6d480bd87143d3" translate="yes" xml:space="preserve">
          <source>The timeout event in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is asynchronous with respect to the code running in its block and may happen at any time, even right before the return from inside of the timeout block. Keep this in mind if you open or acquire some resource inside the block that needs closing or release outside of the block.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; 의 시간 초과 이벤트는 해당 블록에서 실행중인 코드와 관련하여 비동기 적이며 시간 초과 블록 내부에서 반환되기 직전에 언제든지 발생할 수 있습니다. 블록 외부에서 닫거나 해제해야하는 블록 내부의 일부 리소스를 열거 나 획득하는 경우이를 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="04def297d18523cf309971345c57324bf9993c18" translate="yes" xml:space="preserve">
          <source>The title case of a character is usually the same as its upper case with several exceptions. The particular list of characters with the special title case form depends on the underlying platform.</source>
          <target state="translated">문자의 제목은 일반적으로 몇 가지 예외를 제외하고 대문자와 동일합니다. 특수 제목 케이스 형식의 특정 문자 목록은 기본 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">두 문자는 동일합니다 (== 연산자와 비교하여)</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; 유형 은 Java에서 자연스럽게 대응되지 않기 때문에 특별합니다. 실제로 &lt;code&gt;java.lang.Void&lt;/code&gt; 를 포함한 모든 Java 참조 유형 은 &lt;code&gt;null&lt;/code&gt; 을 값으로 허용 하며 &lt;code&gt;Nothing&lt;/code&gt; 조차도 허용하지 않습니다. 따라서이 유형은 Java 세계에서 정확하게 표현 될 수 없습니다. 이것이 Kotlin이 &lt;code&gt;Nothing&lt;/code&gt; 유형의 인수 가 사용되는 원시 유형을 생성하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 유형은 부울을 나타내며 &lt;em&gt;true&lt;/em&gt; 및 &lt;em&gt;false의&lt;/em&gt; 두 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 의 type 인수 &lt;code&gt;T&lt;/code&gt; 는 위에서 설명한 &quot;lvalue&quot;유형 중 하나 여야합니다. 예를 들어 C type &lt;code&gt;struct S*&lt;/code&gt; 는 &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; 에 매핑되고 &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; &lt;code&gt;int8_t*&lt;/code&gt; 는 CPointer &amp;lt;int_8tVar&amp;gt;에 매핑 되고 &lt;code&gt;char**&lt;/code&gt; 는 &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">일반 함수 호출의 유형 인수는 컴파일시에만 확인됩니다. 함수 본문 내에서 형식 매개 변수는 형식 검사에 사용할 수 없으며 형식 매개 변수에 대한 형식 캐스트 ( &lt;code&gt;foo as T&lt;/code&gt; )는 선택되지 않습니다. 그러나 인라인 함수의 &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;구체화 된 유형 매개 변수&lt;/a&gt; 는 호출 사이트에서 인라인 된 함수 본문의 실제 유형 인수로 대체되므로 위에서 설명한 일반 유형의 인스턴스에 대한 동일한 제한 사항으로 유형 검사 및 캐스트에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;safeDivide&lt;/code&gt; 의 유형 은 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 입니다. 함수 유형 선언과 달리 람다 식의 매개 변수 목록은 괄호로 묶어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">속성의 유형과 매개 변수에 사용되는 유형 및 함수의 반환 유형은 속성 / 함수 자체만큼 &quot;적어도 가시적&quot;이어야합니다. 예를 들어, 공용 함수는 전용 유형을 매개 변수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 표현식 의 유형은 특수 유형 &lt;code&gt;Nothing&lt;/code&gt; 입니다. 이 유형에는 값이 없으며 도달 할 수없는 코드 위치를 표시하는 데 사용됩니다. 자체 코드에서 &lt;code&gt;Nothing&lt;/code&gt; 을 사용 하여 절대 반환하지 않는 함수를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">이러한 표현식의 유형은 &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing 유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">이 호출 가능 객체가 반환 한 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin이 일반 선언 사용에 대해 수행하는 형식 안전 검사는 컴파일 타임에만 수행됩니다. 런타임시 일반 유형의 인스턴스는 실제 유형 인수에 대한 정보를 보유하지 않습니다. 유형 정보가 &lt;em&gt;지워&lt;/em&gt; 졌다고합니다 . 예를 들어 &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; 로 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">콜론 이후 지정된 유형 인 &lt;strong&gt;상한&lt;/strong&gt; 의 서브 타입 : &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; 치환 될 수 &lt;code&gt;T&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">투영에 지정된 유형이거나 별 투영 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">단 하나의 값을 가진 유형 : &lt;code&gt;Unit&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">단 하나의 값을 가진 유형 : &lt;code&gt;Unit&lt;/code&gt; 객체. 이 유형 은 Java 의 &lt;code&gt;void&lt;/code&gt; 유형에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">꺾쇠 괄호 안의 &lt;em&gt;유형을 일반 유형 매개 변수&lt;/em&gt; 라고하며 , 나중에 다루겠습니다. 즉, 다른 클래스 (예 : 요소 클래스에 연결된 컨테이너 클래스)에 연결된 클래스를 여러 클래스에 적용 할 수있는 유용한 기술입니다.</target>
        </trans-unit>
        <trans-unit id="608adb2d4b11107c32aaf63109063a2afc4cba2c" translate="yes" xml:space="preserve">
          <source>The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of a coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. The unconfined dispatcher should not be used in general code.</source>
          <target state="translated">제한되지 않은 디스패처는 코 루틴의 일부 작업을 즉시 수행해야하므로 나중에 실행하기 위해 코 루틴을 디스패치하지 않아도되거나 바람직하지 않은 부작용이 발생하는 특정 코너 경우에 도움이 될 수있는 고급 메커니즘입니다. 제한되지 않은 디스패처는 일반 코드에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">C의 사용법은 간단하고 복잡하지 않습니다. 다음 코드를 사용하여 &lt;code&gt;main.c&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">사용법은 모두 열기와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">sam-with-receiver에 내장 된 사전 설정이없고 고유 한 특수 처리 된 주석 목록을 지정해야한다는 점을 제외하면 사용법은 모두 열기 및 인수 없음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">서로 다른 기능의 사용 사례가 겹치므로 프로젝트 또는 팀에서 사용되는 특정 규칙에 따라 기능을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">투영에 지정된 사용 사이트 차이 또는 별 투영 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">이 클래스가 보유하고있는 가치.</target>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">값은 양수 여야하며 &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 를 사용하여 무제한 깊이를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">캡처 한 그룹의 가치.</target>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">이 변수의 값.</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer를&lt;/a&gt; 포함하는 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">이 주석으로 주석이 달린 클래스 파일의 바이트 코드 인터페이스 버전 (이름 지정 규칙, 서명).</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">이 주석의 인수에 제공된 메타 데이터의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">첫 번째 부분에는 표준 C / C ++ 헤더 및 바닥 글이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">가시성 수준 은 &lt;em&gt;기호&lt;/em&gt; 의 &lt;em&gt;어휘 적 가시성&lt;/em&gt; 에만 영향을 미칩니다. 즉, 컴파일러에서 기호를 입력 할 수 있습니다. &lt;em&gt;인스턴스&lt;/em&gt; 가 사용되는 위치에는 영향을 미치지 않습니다 . 예를 들어, 공개 최상위 함수는 반환 유형이 개인 클래스 이름을 언급하지 않고 대신에 공개 기본 클래스 인 경우 개인 클래스의 인스턴스를 반환 할 수 있습니다. 개인 클래스 (아마도 &lt;code&gt;Any&lt;/code&gt; ) 또는 개인 클래스가 구현하는 공용 인터페이스 &lt;a href=&quot;inheritance#subclassing&quot;&gt;클래스&lt;/a&gt; 를 서브 클래 싱 할 때 , 그 프라이빗 멤버도 서브 클래스에 의해 상속되지만 직접 액세스 할 수는 없습니다. 그러나 프라이빗 멤버에 접근하는 상속 된 퍼블릭 함수를 호출하면 좋습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">JavaScript에서 이것을 사용하는 방법 은 해당 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 요소 에서 &lt;code&gt;dataTable()&lt;/code&gt; 을 호출 하는 것입니다</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">컨텍스트 객체를 참조하는 방법</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">이 웹 사이트에는 커뮤니티 구성원의 &lt;a href=&quot;https://kotlin.link&quot;&gt;코 틀린 다이제스트&lt;/a&gt; , &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;뉴스 레터&lt;/a&gt; , &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;팟 캐스트&lt;/a&gt; 등을 포함한 다양한 &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;온라인 리소스가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">그런 다음 &lt;code&gt;dependencies&lt;/code&gt; 블록 에서 &lt;code&gt;kapt&lt;/code&gt; 구성을 사용하여 해당 종속성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">그런 다음 마법사 단계를 따르십시오. 당신은해야합니다 &lt;code&gt;build.gradle&lt;/code&gt; 의 코 틀린로 만든 파일에 따라 구성 &lt;a href=&quot;../../reference/using-gradle&quot;&gt;이 문서&lt;/a&gt; . Kotlin 1.3 이상으로 구성되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">그런 다음 마법사 단계를 따르십시오. 당신은해야합니다 &lt;code&gt;pom.xml&lt;/code&gt; 코 틀린로 만든 파일에 따라 구성 &lt;a href=&quot;../../reference/using-maven&quot;&gt;이 문서&lt;/a&gt; . Kotlin 1.3 이상으로 구성되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">그런 다음 다음 과 같이 &lt;code&gt;cinterop&lt;/code&gt; 도구를 실행하십시오 (sysroot 검색 경로에 포함되지 않은 호스트 라이브러리의 경우 헤더가 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">그런 다음 수신자가있는 SAM 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">그런 다음 클래스를 여는 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">그런 다음 인수없는 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">그런 다음 여러 프로세서 코 루틴을 가질 수 있습니다. 이 예에서는 ID와 수신 번호 만 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;액터&lt;/a&gt; 코 루틴 빌더를 사용하여 액터 를 시작하는 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">그런 다음 변형에 의해 컴파일 된 각 &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android 소스 세트&lt;/a&gt; 에 대해 Kotlin 소스 세트는 Android 소스 세트 &lt;code&gt;debug&lt;/code&gt; Kotlin 소스 세트 &lt;code&gt;androidDebug&lt;/code&gt; 및 &lt;code&gt;android&lt;/code&gt; 라는 Kotlin 타겟과 같이 대상 이름이 앞에 붙은 해당 소스 세트 이름 아래에 작성됩니다 . 이러한 Kotlin 소스 세트는 그에 따라 변형 컴파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">그런 다음 &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; 유형의 변수에 &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; 인스턴스에 대한 참조를 저장하는 것이 안전합니다 . 호출 할 소비자 메소드는 없습니다. 그러나 Java는 이것을 알지 못하고 여전히 금지합니다.</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">그런 다음 대상이 추가되면 기본 컴파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">그런 다음 얼마 후 사용 중단 레벨이 &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; 로 높아져 사용 중단 된 API를 사용하여 새로운 Kotlin 코드를 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">그렇다면 우리가 원하는 유일한 것은 &lt;code&gt;copy()&lt;/code&gt; 가 나쁜 일을하지 않는다는 것입니다. 우리는에서 그것을 금지 할 &lt;strong&gt;쓰기&lt;/strong&gt; 로 &lt;code&gt;from&lt;/code&gt; , 우리는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">Kevin Jones 의 &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;복수형 Kotlin 코스&lt;/a&gt; , Hadi Hariri 의 &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O'Reilly 코스&lt;/a&gt; 및 Peter Sommerhoff 의 &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin 코스&lt;/a&gt; 를 포함하여 Kotlin에 사용할 수있는 몇 가지 코스가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">Kotlin에는 내장 확장 기능 / 속성이 많이 &lt;code&gt;map()&lt;/code&gt; 예 : map () , &lt;code&gt;filter()&lt;/code&gt; . 기능 방식으로 컬렉션을 처리하기위한 나머지 프레임 워크는 확장 기능을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">Kotlin 팀원 인 Dmitry Jemerov와 &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Android 개발자를&lt;/a&gt; 대상으로 하는 Android 개발자를위한 Kotlin Svetlana Isakova가 제공하는 Kotlin &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;in Action&lt;/a&gt; 을 포함하여 Kotlin에 사용할 수 &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;있는 많은 책&lt;/a&gt; 이 이미 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt; 요소없이 컬렉션을 생성하는 함수도 있습니다 . 빈 모음을 만들 때는 모음에 보유 할 요소 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">특정 선택기 기능 또는 사용자 지정 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 가장 작은 요소와 가장 큰 요소를 검색하는 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">주어진 유형의 요소를 필터링하여 요소 유형을 좁히는 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">YouTube와 Vimeo에서 사용 가능한 &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin 대화&lt;/a&gt; 에 대한 많은 녹음 자료도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">더 구체적인 유형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">Kotlin과 C 문자열을 수동으로 변환하는 데 사용할 수있는 몇 가지 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">C 언어에는 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;restruct&lt;/code&gt; , &lt;code&gt;atomic&lt;/code&gt; 유형 한정자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">키를 필터링하고 값을 기준으로 맵을 필터링하는 두 가지 방법이 있습니다. 각 방법에는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt; 함수가 있습니다. 둘 다 주어진 술어와 일치하는 새로운 항목 맵을 리턴합니다. 의 술어 &lt;code&gt;filterKeys()&lt;/code&gt; 검사 만 요소 키에 대한 하나 &lt;code&gt;filterValues()&lt;/code&gt; 를 체크 값만.</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컬렉션의 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt; 요소와 마지막 요소 인 first () 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt; 를 검색하는 데 유용한 별칭도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">일반적인 종류의 속성이 있지만 필요할 때마다 수동으로 구현할 수 있지만 한 번에 구현하고 라이브러리에 넣는 것이 매우 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">맵에서 쓰기 조작을 정의하는 특정 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">그것을 확인하기 위해 몇 가지 관찰이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">이 클래스에는 정확히 &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; 등 네 개의 인스턴스가 있습니다. 이 클래스의 인스턴스는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 로 서로 비교할 수 있으며 &lt;code&gt;ContentKind.values()&lt;/code&gt; 사용하여 허용 가능한 모든 값을 얻을 수 있습니다 . 필요한 경우 각 인스턴스에 대한 자세한 정보를 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">이 문제에 대한 많은 접근 방식이 있으며 Kotlin 에서는 언어 수준에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; 지원을 제공 하고 대부분의 기능을 Kotlin의 철학에 따라 라이브러리에 위임 함으로써 매우 유연한 방법 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">호스트 및 크로스 컴파일 대상에 사용할 수있는 더 많은 플랫폼 라이브러리가 있습니다. &lt;code&gt;Kotlin/Native&lt;/code&gt; 배포는 해당 플랫폼 에서 &lt;code&gt;OpenGL&lt;/code&gt; , &lt;code&gt;zlib&lt;/code&gt; 및 기타 인기있는 기본 라이브러리에 대한 액세스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">Kotlin을 JavaScript로 컴파일하는 방법에는 여러 가지가 있습니다. 권장되는 접근 방식은 Gradle을 사용하는 것입니다. 원하는 경우 IntelliJ IDEA에서 직접 JavaScript 프로젝트를 빌드하거나 Maven을 사용하거나 명령 줄에서 코드를 수동으로 컴파일 할 수도 있습니다. JavaScript로 컴파일하는 방법에 대한 자세한 내용은 해당 자습서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">Kotlin 에는 &lt;code&gt;**kwargs&lt;/code&gt; 가 없지만 기본값을 사용하여 선택적 매개 변수를 정의 할 수 있으며 함수를 호출 할 때 매개 변수의 일부 또는 전체 이름을 지정할 수 있습니다 (기본값이 있는지 여부). 기본값을 가진 매개 변수는 여전히 유형을 명시 적으로 지정해야합니다. 파이썬에서와 같이 명명 된 인수는 호출 사이트에서 마음대로 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">부울로 자동 변환되지 않으므로 진리와 거짓 개념이 없습니다. 0, 비어 있거나 널에 대한 검사는 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 명시 적으로 수행해야합니다 . 대부분의 컬렉션 유형에는 &lt;code&gt;isEmpty()&lt;/code&gt; 및 &lt;code&gt;isNotEmpty()&lt;/code&gt; 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">이제 Java 7 및 8에 추가 된 새로운 JDK API를 지원하는 별도의 표준 라이브러리 버전이 있습니다. 새 API에 액세스해야하는 경우 표준 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 대신 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven 아티팩트를 사용하십시오. stdlib . 이 아티팩트는 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 의 작은 확장 이며 프로젝트에 전 이적 종속성으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="eb7a82db5fbadd7939003437756e36c07405db69" translate="yes" xml:space="preserve">
          <source>There are numerous ways that Kotlin/JS can be used. To provide you some inspiration, here's a non-exhaustive list of scenarios in which you can use Kotlin/JS.</source>
          <target state="translated">Kotlin / JS를 사용할 수있는 방법에는 여러 가지가 있습니다. 영감을주기 위해 Kotlin / JS를 사용할 수있는 시나리오 목록이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">함수 유형의 인스턴스를 얻는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">기본 설정을 재정의하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">다음과 같은 대상 플랫폼에 대해 사전 설정 기능을 사용하여 적용 할 수있는 대상 사전 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">정수 값에는 다음과 같은 종류의 리터럴 상수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">코 루틴은 세 가지가 있습니다. 주 코 루틴 (# 1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; 1 및 두 코 루틴 계산 지연 값 &lt;code&gt;a&lt;/code&gt; (# 2) 및 &lt;code&gt;b&lt;/code&gt; (# 3). 이들은 모두 &lt;code&gt;runBlocking&lt;/code&gt; 컨텍스트에서 실행되며 기본 스레드로 제한됩니다. 이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b170e6fd924b27994900ac3fea0116365dd9d5a3" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) inside &lt;code&gt;runBlocking&lt;/code&gt; and two coroutines computing the deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">세 개의 코 루틴이 있습니다. &lt;code&gt;runBlocking&lt;/code&gt; 내부의 메인 코 루틴 (# 1) 과 지연된 값 &lt;code&gt;a&lt;/code&gt; (# 2)와 &lt;code&gt;b&lt;/code&gt; (# 3)를 계산하는 두 개의 코 루틴 . 이들은 모두 &lt;code&gt;runBlocking&lt;/code&gt; 컨텍스트에서 실행되며 주 스레드에 국한됩니다. 이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">Kotlin을 사용하여 상장하기에는 너무 많은 회사가 있지만 공개적으로 Kotlin의 사용을 선언 한 더 눈에 띄는 회사는 블로그 게시물, GitHub 리포지토리 또는 대화를 통해 &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt; , &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt; , &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda를 포함&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">계산 코드를 취소 할 수있는 방법에는 두 가지가 있습니다. 첫 번째는 취소를 확인하는 일시 중단 기능을 주기적으로 호출하는 것입니다. 이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;항복&lt;/a&gt; 목적을위한 좋은 선택이다 기능. 다른 하나는 취소 상태를 명시 적으로 확인하는 것입니다. 후자의 접근법을 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">컴파일러에서 JavaScript로 동일한 이름을 제공하는 두 가지 함수 가 있습니다. 컴파일러에서 오류를보고하지 않도록 &lt;code&gt;@JsName(...)&lt;/code&gt; 으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">서명되지 않은 유형을 선택하는 두 가지 방법이 있습니다. API를 실험용으로 표시하거나 수행하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8fb334f842c55f58127659b8b13256439fde4f09" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with requiring an opt-in for your API, or without doing that.</source>
          <target state="translated">서명되지 않은 유형에 대해 옵트 인하는 방법에는 두 가지가 있습니다. API에 대한 옵트 인을 요구하거나 그렇게하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">구성 요소가 얼마나 빠르게 발전하고 있는지에 따라 다양한 안정성 모드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">이 문제를 해결하기위한 많은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">있다 &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; 의 나타내는 필드 &lt;code&gt;Clazz&lt;/code&gt; 코 틀린에서가. &lt;code&gt;Clazz#memberFunction&lt;/code&gt; 에 액세스 할 수 &lt;code&gt;memberFunction&lt;/code&gt; 의 필드. 유일한 차이점은 &lt;code&gt;memberFunction&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 참조를 첫 번째 매개 변수로 승인 한다는 것 입니다. C 언어는 개체를 지원하지 않으며, 이것은 전달하는 이유는 &lt;code&gt;this&lt;/code&gt; 명시 적으로 포인터를.</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">더 나은 해결책이 있습니다. 코드에서 구조적 동시성을 사용할 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 코 루틴을 시작하는 대신 , 일반적으로 스레드를 사용하는 것처럼 (스레드는 항상 글로벌 임) 수행중인 특정 작업 범위에서 코 루틴을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">String 클래스에는 유효하지 않은 숫자에 대한 예외를 발생시키지 않고 숫자로 변환하는 새로운 확장 기능이 많이 있습니다. &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; , &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; 기타</target>
        </trans-unit>
        <trans-unit id="2d16488afd500f574acdf4a610fe81c8b613729f" translate="yes" xml:space="preserve">
          <source>There is a common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">변수를 &lt;code&gt;volatile&lt;/code&gt; 만들면 동시성 문제가 해결 된다는 일반적인 오해가 있습니다. 시도해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">에서 생성자가 &lt;code&gt;Clazz&lt;/code&gt; 필드 (일명 &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; 의 인스턴스를 생성하는 생성자 함수이다) &lt;code&gt;Clazz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">편리한 코 루틴 빌더의 이름이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;생산&lt;/a&gt; 쉽게 바로 생산자 측에서 그것을 할 수 있습니다, 그리고 확장 기능 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt; A와 교체, &lt;code&gt;for&lt;/code&gt; 소비자 측 루프 :</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt; 값을 갖는 선택적 &lt;code&gt;start&lt;/code&gt; 매개 변수를 사용하여 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 하는 게으름 옵션이 있습니다 . 일부 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;대기자&lt;/a&gt; 가 결과를 필요로 하거나 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;시작&lt;/a&gt; 함수가 호출 된 경우 에만 코 루틴을 시작 합니다. 다음 예제를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">이를 수행 할 수있는 멋진 구문 설탕 조각이 있습니다 : &lt;em&gt;확장 함수&lt;/em&gt; 및 &lt;em&gt;확장 속성&lt;/em&gt; . 일반 멤버 함수 / 속성처럼 보이지만 클래스 외부에서 정의되어 있지만 클래스 이름을 참조하여 &lt;code&gt;this&lt;/code&gt; 사용할 수 있습니다 . 그러나 클래스의 보이는 멤버 만 (일반적으로 공개 멤버 만) 사용할 수 있습니다. 배후에서 대상 인스턴스를 매개 변수로 사용하는 일반 함수로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">&lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; 을 편리하게 나타내는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; 확장 함수 도 있습니다 . {...} 마지막으로 {mutex.unlock ()} 패턴을 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">술어를 가져 와서 일치하는 요소를 검색하는 함수 쌍도 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">액터의 우편함 채널을 범위로 편리하게 결합하여 송신 채널을 결과 작업 오브젝트로부터 수신하고 결합하여 액터에 대한 단일 참조를 처리 할 수 있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;액터&lt;/a&gt; 코 루틴 빌더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">이러한 경우 중복 어레이 생성을 제거하여 성능 저하를 방지하는 최적화가 있습니다. 단일 인수 형식은 Kotlin 1.2에서 경고를 생성하며 Kotlin 1.3에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">제품 플레이버별로 그룹화 된 변형을 게시 할 수있는 옵션이 있으므로 빌드 유형이 아티팩트의 분류자가되는 빌드 유형이 서로 다른 빌드 유형의 출력이 단일 모듈에 배치됩니다 (릴리스 빌드 유형은 분류자가없는 상태로 여전히 공개됨) ). 이 모드는 기본적으로 비활성화되어 있으며 다음과 같이 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">변수를 &lt;code&gt;volatile&lt;/code&gt; 만드는 것이 동시성 문제를 해결 한다는 일반적인 오해가 있습니다. 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">문자열에 대한 C 언어에는 전용 유형이 없습니다. 개발자는 주어진 &lt;code&gt;char *&lt;/code&gt; 가 컨텍스트에서 C 문자열을 의미 하는지 여부를 메소드 서명 또는 문서에서 알고 있습니다 . C 언어의 문자열은 null로 끝나고 문자열 시퀀스를 표시하기 위해 바이트 시퀀스의 끝에 후행 0 문자 &lt;code&gt;\0&lt;/code&gt; 이 추가됩니다. 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8로 인코딩 된 문자열&lt;/a&gt; 이 사용됩니다. UTF-8 인코딩은 가변 너비 문자를 사용하며 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; 와 역 호환됩니다 . Kotlin / Native는 기본적으로 UTF-8 문자 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">이 코드를 실행할 때 더 이상 예외가 없습니다.</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">이 클래스의 값에 첨부 된 의미는 없으며 어떤 목적으로도 사용할 수 있습니다. 쌍은 값 의미를 나타냅니다. 즉 두 구성 요소가 모두 같으면 두 쌍이 같습니다.</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">이 클래스의 값에 첨부 된 의미는 없으며 어떤 목적으로도 사용할 수 있습니다. 트리플은 가치 의미론을 나타냅니다. 즉, 세 구성 요소가 모두 같으면 두 트리플이 같습니다. 값으로 분해하는 예 :</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">C에서는 네임 스페이스가 지원되지 않으므로 Kotlin / Native 컴파일러는 기존 기본 프로젝트의 다른 기호와 충돌을 피하기 위해 긴 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9fc7acf9c721c77f449446dbc8b3636586ef2efc" translate="yes" xml:space="preserve">
          <source>There is no need to consider compatibility for new interfaces, as no clients have used them before. You can minimize the compatibility overhead by excluding these interfaces from the compatibility mode. To do this, annotate them with the &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; annotation. Such interfaces compile the same way as with &lt;code&gt;-Xjvm-default=all&lt;/code&gt;.</source>
          <target state="translated">새로운 인터페이스에 대한 호환성을 고려할 필요가 없습니다. 이전에 사용한 적이없는 클라이언트가 있기 때문입니다. 호환성 모드에서 이러한 인터페이스를 제외하여 호환성 오버 헤드를 최소화 할 수 있습니다. 이렇게하려면 &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; 어노테이션으로 어노테이션을 작성하십시오. 이러한 인터페이스는 &lt;code&gt;-Xjvm-default=all&lt;/code&gt; 과 같은 방식으로 컴파일 됩니다 .</target>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">경쟁 프로그래밍에서 형식이 잘못된 입력의 경우를 처리 할 필요가 없습니다. 경쟁 프로그래밍에서 입력 형식은 항상 정확하게 지정되며 실제 입력은 문제 설명의 입력 사양에서 벗어날 수 없습니다. 이것이 널 어설 션 연산자입니다 &lt;code&gt;!!&lt;/code&gt; 본질적으로-입력 문자열이 존재한다고 주장하고 그렇지 않으면 예외가 발생합니다. 마찬가지로 입력 문자열이 정수가 아닌 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt ()&lt;/a&gt; 함수는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c6d0ebaf0b7e6376420eb9484810949b156e1e12" translate="yes" xml:space="preserve">
          <source>There is no such syntax in Kotlin. However, in Kotlin we have &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;code&gt;companion&lt;/code&gt;&lt;/a&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; classes in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. &lt;code&gt;MyClass&lt;/code&gt; from the example above can be described as follows:</source>
          <target state="translated">Kotlin에는 이러한 구문이 없습니다. 그러나 Kotlin에는 &lt;a href=&quot;object-declarations#companion-objects&quot;&gt; &lt;code&gt;companion&lt;/code&gt; &lt;/a&gt; 객체가 있습니다. Kotlin은 &lt;code&gt;external&lt;/code&gt; 클래스 의 컴패니언 개체를 특별한 방식으로 처리합니다. 개체를 기대하는 대신 컴패니언 개체의 멤버를 클래스 자체의 멤버로 가정합니다. 위 예제의 &lt;code&gt;MyClass&lt;/code&gt; 는 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">현재 지원되는 플랫폼마다 다양한 &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;사전 설정 플랫폼 구성&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c9261e9c8424c9800b6b0327e8368a8f20c36c1" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;mpp-supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">이제 지원되는 다양한 &lt;a href=&quot;mpp-supported-platforms&quot;&gt;플랫폼에&lt;/a&gt; 대해 많은 사전 설정된 플랫폼 구성 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">객체 표현과 객체 선언 사이에는 중요한 의미 론적 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">목록에서 요소를 검색하는 또 다른 방법 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;이진 검색이&lt;/a&gt; 있습니다. 다른 내장 검색 기능보다 훨씬 빠르지 만 특정 순서에 따라 &lt;em&gt;목록을&lt;a href=&quot;collection-ordering&quot;&gt;&lt;/a&gt;&lt;/em&gt; 오름차순으로 &lt;em&gt;정렬&lt;/em&gt;&lt;em&gt; 해야합니다 (&lt;/em&gt; 자연 또는 함수 매개 변수에 제공된 다른 순서). 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">코 루틴의 실제 사용을 위해 여전히 바람직한 것이 있습니다. &lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 사용하면 최상위 코 루틴을 만듭니다. 가볍지 만 실행하는 동안 여전히 일부 메모리 리소스를 사용합니다. 새로 출시 된 코 루틴에 대한 참조를 유지하지 않으면 여전히 실행됩니다. 코 루틴의 코드가 멈 추면 (예를 들어, 너무 오래 지연되는 경우) 코 루틴을 너무 많이 시작하고 메모리가 부족하면 어떻게합니까? 실행 된 모든 코 루틴에 대한 참조를 수동으로 유지하고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;결합&lt;/a&gt; 해야하는 것은 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c2958b4b7d6ee3fe23d0044dbf293010b99dd8e5" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine, it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">코 루틴의 실제 사용을 위해 여전히 원하는 것이 있습니다. &lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 사용할 때 최상위 코 루틴을 만듭니다. 가볍지 만 실행하는 동안 여전히 일부 메모리 리소스를 소비합니다. 새로 시작된 코 루틴에 대한 참조를 유지하는 것을 잊더라도 여전히 실행됩니다. 코 루틴의 코드가 멈춘다면 (예를 들어, 너무 오래 지연되는 경우), 너무 많은 코 루틴을 시작하고 메모리가 부족하면 어떻게 될까요? 실행 된 모든 코 루틴에 대한 참조를 수동으로 유지하고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;조인&lt;/a&gt; 해야하는 것은 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="01079d64cb67e3f5b3eb1ab0a3228010e68dcdd0" translate="yes" xml:space="preserve">
          <source>There may be times when you need to quickly write and execute code outside of a project or application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look at three handy ways we can use to run Kotlin code quickly:</source>
          <target state="translated">프로젝트 또는 애플리케이션 외부에서 코드를 빠르게 작성하고 실행해야하는 경우가 있습니다. 예를 들어 Kotlin을 배우거나 표현식을 평가할 때 유용 할 수 있습니다. Kotlin 코드를 빠르게 실행하는 데 사용할 수있는 세 가지 편리한 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">&lt;em&gt;캐치&lt;/em&gt; 블록 이 0 개 이상있을 수 있습니다 . &lt;em&gt;마지막으로&lt;/em&gt; 블록은 생략 될 수 있습니다. 그러나 적어도 하나의 &lt;em&gt;catch&lt;/em&gt; 또는 &lt;em&gt;finally&lt;/em&gt; 블록이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 라는 속성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">이 클래스의 인스턴스는 하나 뿐이며 인스턴스 (스레드에 안전한 방식으로 처음 액세스 할 때 생성됨)는 클래스와 동일한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">람다 함수와 관련된 런타임 오버 헤드가 약간 있습니다. 실제로는 객체이므로 인스턴스화해야하며 (다른 함수와 마찬가지로) 호출하는 데 약간의 시간이 걸립니다. 함수에 &lt;code&gt;inline&lt;/code&gt; 키워드를 사용하면 컴파일러에 함수와 해당 람다 매개 변수 (있는 경우)를 모두 &lt;em&gt;인라인&lt;/em&gt; 하도록 지시 합니다. 즉, 컴파일러는 함수 코드 (및 람다 매개 변수)를 &lt;em&gt;모든&lt;/em&gt; 호출 사이트에 복사합니다. 따라서 람다 인스턴스화와 함수 호출 및 람다 모두의 오버 헤드를 제거합니다. &lt;code&gt;inline&lt;/code&gt; C 및 C ++과 달리 무조건적으로 발생합니다.컴파일러에 대한 힌트입니다. 이로 인해 컴파일 된 코드의 크기가 커지지 만 작지만 자주 호출되는 특정 기능에는 유용 ​​할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; 패키지&lt;/a&gt; 에는 다양한 기능적 프로그래밍 스타일 작업 모음이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">JavaScript에는 64 비트 정수 가 없으므로 &lt;code&gt;kotlin.Long&lt;/code&gt; 은 JavaScript 객체에 매핑되지 않으며 Kotlin 클래스에 의해 에뮬레이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">코 틀린에는 그러한 구문이 없습니다. 그러나 Kotlin에는 &lt;code&gt;companion&lt;/code&gt; 개체가 있습니다. Kotlin은 &lt;code&gt;external&lt;/code&gt; 클래스 의 컴패니언 객체를 특별한 방식으로 처리합니다. 객체를 기대하는 대신 컴패니언 객체의 멤버를 클래스 자체의 멤버로 가정합니다. 위 예제에서 &lt;code&gt;MyClass&lt;/code&gt; 를 설명하기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;definedExternally&lt;/code&gt; 를 사용하는 데는 두 가지 형태가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">따라서 일부 조건을 확인하여 쓰기 잠금 내부 의 &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;작업을&lt;/a&gt; 시작한 경우 가능한 경쟁을 피하기 위해 &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 내에서 조건을 다시 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e58964a321357f25142def10569f3d0cf1f1691d" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">따라서 쓰기 잠금 내부 &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;작업&lt;/a&gt; 이 일부 조건을 확인하여 시작된 경우 가능한 경합을 피하기 위해 &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;작업&lt;/a&gt; 내부에서 조건을 다시 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">따라서 다음 두 스 니펫은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">따라서 런타임에 제네릭 형식의 인스턴스가 특정 형식 인수를 사용하여 만들어 졌는지 여부를 확인하는 일반적인 방법은 없으며 컴파일러 &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;&lt;em&gt;는&lt;/em&gt;&lt;/a&gt; -checks를 금지&lt;em&gt;&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">이러한 &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;검사되지 않은 캐스트&lt;/a&gt; 는 유형 안전이 고급 프로그램 논리에 의해 암시되지만 컴파일러가 직접 유추 할 수없는 경우에 사용할 수 있습니다. 컴파일러는 검사되지 않은 캐스트에 대해 경고를 발행하고 런타임에 제네릭이 아닌 부분 만 검사합니다 ( &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">Kotlin 컬렉션 클래스를 구현할 때 이러한 추상 클래스를 기본 클래스로 사용할 수 있습니다. 읽기 전용 컬렉션을 구현하기 위해 &lt;code&gt;AbstractCollection&lt;/code&gt; , &lt;code&gt;AbstractList&lt;/code&gt; , &lt;code&gt;AbstractSet&lt;/code&gt; 및 &lt;code&gt;AbstractMap&lt;/code&gt; 이 있으며 변경 가능한 컬렉션에는 &lt;code&gt;AbstractMutableCollection&lt;/code&gt; , &lt;code&gt;AbstractMutableList&lt;/code&gt; , &lt;code&gt;AbstractMutableSet&lt;/code&gt; 및 &lt;code&gt;AbstractMutableMap&lt;/code&gt; 이 있습니다. JVM에서 이러한 추상 가변 콜렉션은 JDK의 추상 콜렉션에서 대부분의 기능을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">이들은입니다 &lt;a href=&quot;#default-project-layout&quot;&gt;기본 소스 세트 이름&lt;/a&gt; 위의 구성 대상에 대한 생산 및 테스트 소스. &lt;code&gt;commonMain&lt;/code&gt; 및 &lt;code&gt;commonTest&lt;/code&gt; 소스 세트 는 모든 대상의 프로덕션 및 테스트 컴파일에 각각 포함됩니다. 공통 소스 세트 &lt;code&gt;commonMain&lt;/code&gt; 및 &lt;code&gt;commonTest&lt;/code&gt; 에 대한 종속성 은 공통 아티팩트이며 플랫폼 라이브러리는 특정 대상의 소스 세트로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">이는 모든 수신기에 적용 가능한 3 가지 범용 확장 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">이러한 고려 사항은 다음 규칙으로 이어집니다. 공변량 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; (객체의 사용자가 &lt;code&gt;Fruit&lt;/code&gt; 라고 생각할 수 있지만 실제로는 객체가 &lt;code&gt;Apple&lt;/code&gt; 에 연결되어 있다고 생각할 수 있음)는 다음과 같이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">이 선언은 분명해 보인다. 모든 &lt;code&gt;char *&lt;/code&gt; 포인터는 &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 매개 변수 및 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 반환 형식으로. Kotlin은 &lt;code&gt;char&lt;/code&gt; 유형을 &lt;code&gt;kotlin.Byte&lt;/code&gt; 유형으로 변환 합니다. 일반적으로 8 비트 부호있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">이러한 기능은 아직 프로덕션 준비 상태로 간주되지 않으므로 &lt;code&gt;build.gradle&lt;/code&gt; 에서 &lt;em&gt;실험 모드&lt;/em&gt; 를 켜야 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">이 함수는 컬렉션을 다른 형식으로 변환하는데도 사용할 수 있습니다 (예 : 목록에서 집합을 빌드하거나 그 반대로).</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">이 기능을 사용하면 맵을 쉽게 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">이 함수는 두 개 또는 세 개의 주어진 값 중 가장 작은 값과 가장 큰 값을 찾는 데 사용할 수 있습니다. 여기서 값은 기본 숫자 또는 &lt;code&gt;Comparable&lt;/code&gt; 객체입니다. 자체 비교할 수없는 객체를 비교하려는 경우 추가 &lt;code&gt;Comparator&lt;/code&gt; 인스턴스 를 사용하는 각 함수의 오버로드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">이 함수는 Kotlin / Native 객체를 처리합니다. 통화 &lt;code&gt;DisposeStablePointer&lt;/code&gt; 코 틀린 객체와 해제 &lt;code&gt;DisposeString&lt;/code&gt; 가 갖는 코 틀린 문자열 해제 &lt;code&gt;char*&lt;/code&gt; 사용하는 것이 가능하다 C.에 입력 &lt;code&gt;IsInstance&lt;/code&gt; 의 코 틀린 종류 나 있는지 확인하는 기능을 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 는 다른 유형의 인스턴스이다. 생성되는 실제 작업 세트는 실제 사용법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">여기에는 특정 인스턴스의 멤버를 가리키는 &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;바인딩 된 호출 가능 참조&lt;/a&gt; 가 포함됩니다 ( &lt;code&gt;foo::toString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">이 연산자는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt; 함수에서만 작동하며, 사용자 정의 동등 검사 구현을 제공하기 위해 재정의 할 수 있습니다. &lt;code&gt;equals(other: Foo)&lt;/code&gt; 같은 이름을 가진 다른 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션은 clang의 &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; 및 swiftc의 &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; 와 거의 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">이러한 작업은 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant 버전 1.8.2+ 의 &lt;em&gt;lib&lt;/em&gt; 폴더 에있는 &lt;em&gt;kotlin-ant.jar&lt;/em&gt; 라이브러리에 정의되어 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35fb8f738b23790388f177e5975164208ed39249" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">이러한 작업은 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant 버전 1.8.2+ 의 &lt;em&gt;lib&lt;/em&gt; 폴더 에있는 &lt;em&gt;kotlin-ant.jar&lt;/em&gt; 라이브러리에 정의되어 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">이러한 변환은 &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; 에도 적용 할 수 있으며 , 이는 Python의 생성기와 유사하며 지연 평가를 허용합니다. 거대한 목록이 있고 지연 처리하려면 &lt;code&gt;asSequence()&lt;/code&gt; 를 호출 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">이 두 함수는 JVM 서명이 동일하므로 나란히 정의 할 수 없습니다. &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; . Kotlin에서 실제로 동일한 이름을 갖기를 원한다면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt; 으로 그들 중 하나 (또는 ​​둘 다)에 주석을 달고 다른 이름을 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">이 두 가지 옵션을 사용하면 코드에서 다음에 수행 할 작업에 따라 적절한 기능을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">이 유형은 박스형 Kotlin 숫자 유형을 Objective-C 및 Swift에 맵핑하는 데 사용됩니다. Swift에서 생성자를 호출하여 인스턴스를 생성 할 수 있습니다 &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; 예 : KotlinLong (value : 42)) .</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">이 유형에는 함수의 시그니처, 즉 매개 변수 및 리턴 값에 해당하는 특수 표기법이 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
