<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="2e3cf95b689244eb673190f3f6791a8430eef505" translate="yes" xml:space="preserve">
          <source>To run tests, execute the standard lifecycle &lt;code&gt;check&lt;/code&gt; task:</source>
          <target state="translated">테스트를 실행하려면 표준 수명주기 &lt;code&gt;check&lt;/code&gt; 작업을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="58d7a0df7bd3a304f110999cd04f5328dff8bc19" translate="yes" xml:space="preserve">
          <source>To run the application, right-click somewhere in the main file and select &lt;strong&gt;Run As | Kotlin Application&lt;/strong&gt;.</source>
          <target state="translated">응용 프로그램을 실행하려면 기본 파일에서 마우스 오른쪽 버튼을 클릭하고 &lt;strong&gt;Run As | 코 틀린 응용 프로그램&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="307aa135f670640b026c3a84d1ad04d1025f9beb" translate="yes" xml:space="preserve">
          <source>To run the tests in the browser, we can execute the &lt;code&gt;browserTest&lt;/code&gt; task via IntelliJ IDEA, or use the gutter icons to execute all or individual tests:</source>
          <target state="translated">브라우저에서 테스트를 실행하려면 IntelliJ IDEA를 통해 &lt;code&gt;browserTest&lt;/code&gt; 작업을 실행하거나 거터 아이콘을 사용하여 모든 또는 개별 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4d15311fa7cd994c8e9ce22c145ce856d694db" translate="yes" xml:space="preserve">
          <source>To save your course as a zip file, go to &lt;strong&gt;Course Creator -&amp;gt; Generate Course Archive&lt;/strong&gt; action. The generated archive can be opened via the &lt;strong&gt;Browse Courses&lt;/strong&gt; available from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; and in the &lt;strong&gt;File Menu&lt;/strong&gt; with the &lt;strong&gt;Import Course&lt;/strong&gt; icon:</source>
          <target state="translated">코스를 zip 파일로 저장하려면 &lt;strong&gt;코스 생성기-&amp;gt; 코스 아카이브 생성&lt;/strong&gt; 액션으로 이동하십시오. 생성 된 아카이브는을 통해 열 수 있습니다 &lt;strong&gt;찾아보기 코스&lt;/strong&gt; 로부터 가능한 &lt;strong&gt;시작 화면&lt;/strong&gt; 과의 &lt;strong&gt;파일 메뉴&lt;/strong&gt; 로 &lt;strong&gt;가져 오기 과정&lt;/strong&gt; 아이콘 :</target>
        </trans-unit>
        <trans-unit id="36a621d8894a43c60f62b88c51e7aa345450af8d" translate="yes" xml:space="preserve">
          <source>To search an element in a sorted list, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt;&lt;code&gt;binarySearch()&lt;/code&gt;&lt;/a&gt; function passing the value as an argument. If such an element exists, the function returns its index; otherwise, it returns &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; where &lt;code&gt;insertionPoint&lt;/code&gt; is the index where this element should be inserted so that the list remains sorted. If there is more than one element with the given value, the search can return any of their indices.</source>
          <target state="translated">정렬 된 목록에서 요소를 검색하려면 값을 인수로 전달하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt; &lt;code&gt;binarySearch()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . 이러한 요소가 존재하면 함수는 해당 인덱스를 리턴합니다. 그렇지 않으면 &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; 리턴합니다. 여기서 &lt;code&gt;insertionPoint&lt;/code&gt; 는 목록이 정렬 된 상태로 유지되도록이 요소를 삽입해야하는 색인입니다. 주어진 값을 가진 요소가 두 개 이상인 경우 검색은 색인을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf705e6bade184c44c4ccccae5cda8a8acf3a41e" translate="yes" xml:space="preserve">
          <source>To see how we can express how elements in the DOM can be created and structured in a concise way, check out the the &lt;a href=&quot;typesafe-html-dsl&quot;&gt;Typesafe HTML DSL&lt;/a&gt;.</source>
          <target state="translated">DOM의 요소를 간결하게 만들고 구조화하는 방법을 표현하는 방법을 보려면 &lt;a href=&quot;typesafe-html-dsl&quot;&gt;Typesafe HTML DSL을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="680ca05ae718e68cfb1629f08e49b399fcda4d93" translate="yes" xml:space="preserve">
          <source>To see the full Gradle script check out the source of the project on GitHub.</source>
          <target state="translated">전체 Gradle 스크립트를 보려면 GitHub에서 프로젝트 소스를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6bc22d1c45afda0ba0e9856d43874792a674530d" translate="yes" xml:space="preserve">
          <source>To select module kind, set the &lt;code&gt;moduleKind&lt;/code&gt; compiler option in the Gradle build script.</source>
          <target state="translated">To select module kind, set the &lt;code&gt;moduleKind&lt;/code&gt; compiler option in the Gradle build script.</target>
        </trans-unit>
        <trans-unit id="06d76d8df652a0954c4314eb6cd119fb4f22f648" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Gradle, you should set &lt;code&gt;moduleKind&lt;/code&gt; property, i.e.</source>
          <target state="translated">Gradle을 통해 컴파일 할 때 모듈 시스템을 선택하려면 &lt;code&gt;moduleKind&lt;/code&gt; 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="16681c84550456d5ff8bc73b03434df79d115f43" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Maven, you should set &lt;code&gt;moduleKind&lt;/code&gt; configuration property, i.e. your &lt;code&gt;pom.xml&lt;/code&gt; should look like this:</source>
          <target state="translated">Maven을 통해 컴파일 할 때 모듈 시스템을 선택하려면 &lt;code&gt;moduleKind&lt;/code&gt; 구성 속성을 설정해야 합니다. 즉, &lt;code&gt;pom.xml&lt;/code&gt; 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="45e994b1f4d37b99eaddc699cd613274dee03180" translate="yes" xml:space="preserve">
          <source>To set another location for project distribution files, add the &lt;code&gt;distribution&lt;/code&gt; block inside &lt;code&gt;browser&lt;/code&gt; in the build script and assign a value to the &lt;code&gt;directory&lt;/code&gt; property. Once you run a project build task, Gradle will save the output bundle in this location together with project resources.</source>
          <target state="translated">프로젝트 배포 파일의 다른 위치를 설정하려면 빌드 스크립트의 &lt;code&gt;browser&lt;/code&gt; 내에 &lt;code&gt;distribution&lt;/code&gt; 블록을 추가 하고 &lt;code&gt;directory&lt;/code&gt; 속성에 값을 할당 합니다. 프로젝트 빌드 작업을 실행하면 Gradle은 프로젝트 리소스와 함께이 위치에 출력 번들을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="269c5e540e50596c2266b2737868df5485939c07" translate="yes" xml:space="preserve">
          <source>To set the desired level, specify the &lt;code&gt;level&lt;/code&gt; parameter of the &lt;code&gt;@RequiresOptIn&lt;/code&gt; annotation.</source>
          <target state="translated">원하는 수준을 설정하려면 &lt;code&gt;@RequiresOptIn&lt;/code&gt; 주석 의 &lt;code&gt;level&lt;/code&gt; 매개 변수를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="5dfb90c4357595726b2e826922df2d26c2c78269" translate="yes" xml:space="preserve">
          <source>To setup a multiplatform project from scratch in a Gradle project, first apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to the project by adding the following to the beginning of the &lt;code&gt;build.gradle&lt;/code&gt; file:</source>
          <target state="translated">Gradle 프로젝트에서 멀티 플랫폼 프로젝트를 처음부터 새로 설정하려면 먼저 &lt;code&gt;build.gradle&lt;/code&gt; 파일 의 시작 부분에 다음을 추가하여 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인을 프로젝트에 적용 하십시오.</target>
        </trans-unit>
        <trans-unit id="c7e47d17458659905c4f2f62bdab7488ae50c7a1" translate="yes" xml:space="preserve">
          <source>To skip automatic conversion and ensure raw pointers are used in the bindings, a &lt;code&gt;noStringConversion&lt;/code&gt; statement in the &lt;code&gt;.def&lt;/code&gt; file could be used, i.e.</source>
          <target state="translated">자동 변환을 건너 뛰고 바인딩에 원시 포인터가 사용되도록 하려면 &lt;code&gt;.def&lt;/code&gt; 파일 의 &lt;code&gt;noStringConversion&lt;/code&gt; 문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db6bb94ddd68466610ca12cc204d3d3c6bd7dd12" translate="yes" xml:space="preserve">
          <source>To solve such issues, Kotlin introduces a special kind of class called an &lt;code&gt;inline class&lt;/code&gt;, which is declared by placing an &lt;code&gt;inline&lt;/code&gt; modifier before the name of the class:</source>
          <target state="translated">이러한 문제를 해결하기 위해 Kotlin은 &lt;code&gt;inline class&lt;/code&gt; 라는 특수한 클래스를 도입했습니다 . 클래스는 클래스 이름 앞에 &lt;code&gt;inline&lt;/code&gt; 수정자를 배치하여 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="885ff03b6c597841318a22240c06f643cf1cd5fb" translate="yes" xml:space="preserve">
          <source>To solve this, mark the targets on both the library author and consumer sides with a custom attribute, which Gradle uses during dependency resolution.</source>
          <target state="translated">이를 해결하려면 Gradle이 종속성 해결 중에 사용하는 커스텀 속성으로 라이브러리 작성자와 소비자 측 모두에서 대상을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c6edca763e12c6292a414b20b65eaba5f53f467b" translate="yes" xml:space="preserve">
          <source>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit &lt;em&gt;constructor&lt;/em&gt; keyword):</source>
          <target state="translated">클래스의 기본 생성자의 가시성을 지정하려면 다음 구문을 사용하십시오 (명시 적 &lt;em&gt;생성자&lt;/em&gt; 키워드 를 추가해야 함 ).</target>
        </trans-unit>
        <trans-unit id="419bcc45449c9e2a7d1fb4c22599e33f123b758a" translate="yes" xml:space="preserve">
          <source>To specify additional compilation options, use the &lt;code&gt;kotlinOptions&lt;/code&gt; property of a Kotlin compilation task.</source>
          <target state="translated">추가 컴파일 옵션을 지정하려면 Kotlin 컴파일 작업 의 &lt;code&gt;kotlinOptions&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ac203e68342bc2b26ca6bd486204285a11e36be" translate="yes" xml:space="preserve">
          <source>To specify that a function type is &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;nullable&lt;/a&gt;, use parentheses: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt;.</source>
          <target state="translated">함수 유형이 &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;널 입력 가능&lt;/a&gt; 하도록 지정하려면 괄호를 사용하십시오. &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa582abf300c214133b85270789a22565f82393f" translate="yes" xml:space="preserve">
          <source>To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</source>
          <target state="translated">To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</target>
        </trans-unit>
        <trans-unit id="e57f72b9d262e6ee5d6ce2e784cc4119575a7e41" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다. 결과 연속에서 재개 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="29211ac1a181cd4bb3901bb410d7de3d38f88156" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다. 결과 연속에서 재개 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="93a4c159e45ae9b13567d12cfe549a89c643e81c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="03689575e5ce0d05cb5875c63b25386ef2dc70ce" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b715c677cb96aa31e520707c8bf7a084527dde6c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다. 결과 연속에서 재개 함수를 반복적으로 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="7ae9d4ba7899cbe4180b0d690d30390847f2291f" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다. 결과 연속에서 재개 함수를 반복적으로 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="dfc6df82451691b1971099e0817380884cac3aec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="e102b42121057a6878b15b2e0b7a9abdd7059c88" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="a74d51560d5c774d1a56f8d84a208e43206f3604" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="aa80d28b000c404e7e7471739dc834ced4e443ec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="107268b53cdccea4df633455aa08e9eb59213796" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</target>
        </trans-unit>
        <trans-unit id="15c18083bec73d38fe935b18a61bfb26719f41fa" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</target>
        </trans-unit>
        <trans-unit id="e2482fe90c75c3748aeac1be942111f81e932b33" translate="yes" xml:space="preserve">
          <source>To start the course, go to &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt;. You will find a course plan, the list of lessons. Every lesson has a set of tasks and code exercises you need to solve. Start with the very first one:</source>
          <target state="translated">과정을 시작하려면 &lt;strong&gt;보기-&amp;gt; 도구 창-&amp;gt; 프로젝트로 이동하십시오&lt;/strong&gt; . 코스 계획, 수업 목록을 찾을 수 있습니다. 모든 수업에는 해결해야 할 일련의 작업과 코드 연습이 있습니다. 첫 번째로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="af4a3359bcc2d8aaecee721a7eaa5358429907bb" translate="yes" xml:space="preserve">
          <source>To start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;js-project-setup&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;, or pick a hands-on lab from the next section to work through.</source>
          <target state="translated">To start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;js-project-setup&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;, or pick a hands-on lab from the next section to work through.</target>
        </trans-unit>
        <trans-unit id="5f3ceec14c1433cf322f7865c09a18312ccb1945" translate="yes" xml:space="preserve">
          <source>To start with, we'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</source>
          <target state="translated">우선 x64_64 대상을 지원하는 Microsoft Visual C ++ 컴파일러가 설치되어 있어야합니다. 가장 쉬운 방법은 Windows 컴퓨터에 Microsoft Visual Studio 버전을 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="66185b084e5432ac45a03abd883161f880e5f11e" translate="yes" xml:space="preserve">
          <source>To switch to the old behavior, pass the fallback flag &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; to the compiler.</source>
          <target state="translated">이전 동작으로 전환하려면 폴백 플래그 &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; 를 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="cc3b8fe9e3a75acdfca2d542f5fc3f0b9c8e0c32" translate="yes" xml:space="preserve">
          <source>To switch to the old smart casts behavior, pass the fallback flag &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; as the compiler argument. It will become deprecated in Kotlin 1.3.</source>
          <target state="translated">이전 스마트 캐스트 동작으로 전환하려면 폴백 플래그 &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; 를 컴파일러 인수로 전달하십시오. Kotlin 1.3에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="526447430819405af6d133c6984847835417ebe8" translate="yes" xml:space="preserve">
          <source>To symbolicate addresses in Kotlin code (e.g. for stack trace elements corresponding to Kotlin code) &lt;code&gt;.dSYM&lt;/code&gt; bundle for Kotlin code is required.</source>
          <target state="translated">Kotlin 코드에서 주소를 기호화하려면 (예 : Kotlin 코드에 해당하는 스택 추적 요소의 경우) Kotlin 코드 용 &lt;code&gt;.dSYM&lt;/code&gt; 번들이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3ee56f12e381a099c59880a6823066a60e9d50df" translate="yes" xml:space="preserve">
          <source>To take all the elements except a given number of first or last elements, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt;&lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt;&lt;code&gt;dropLast()&lt;/code&gt;&lt;/a&gt; functions respectively.</source>
          <target state="translated">지정된 수의 첫 번째 또는 마지막 요소를 제외한 모든 요소를 ​​가져 오려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt; &lt;code&gt;dropLast()&lt;/code&gt; &lt;/a&gt; 함수를 각각 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="27b36af5861b299fc805f783568e62a3fc319e12" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin.</source>
          <target state="translated">To target the JVM, apply the Kotlin JVM plugin.</target>
        </trans-unit>
        <trans-unit id="ca844ba87cff8c023079c9be62782b3a3fde8a97" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin. Starting with Kotlin 1.1.1, the plugin can be applied using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;:</source>
          <target state="translated">JVM을 대상으로하려면 Kotlin JVM 플러그인을 적용하십시오. Kotlin 1.1.1부터 &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle 플러그인 DSL을&lt;/a&gt; 사용하여 플러그인을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="089288f0ea4e442474ea533e687f95ceb53b919e" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration. This means that you should omit bodies of &lt;code&gt;external&lt;/code&gt; declarations. For example:</source>
          <target state="translated">Kotlin에게 특정 선언이 순수 JavaScript로 작성되었음을 알리려면 &lt;code&gt;external&lt;/code&gt; 수정 자로 표시해야합니다 . 컴파일러는 이러한 선언을 볼 때 해당 클래스, 함수 또는 속성에 대한 구현이 개발자가 제공한다고 가정하므로 선언에서 JavaScript 코드를 생성하려고 시도하지 않습니다. 이것은 &lt;code&gt;external&lt;/code&gt; 선언의 본문을 생략해야 함을 의미합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c054ec329a7a56272832fde51ee7e82f8f4336b8" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with the &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided externally (by the developer or via an &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm dependency&lt;/a&gt;), and therefore does not try to generate any JavaScript code from the declaration. This is also why &lt;code&gt;external&lt;/code&gt; declarations can't have a body. For example:</source>
          <target state="translated">To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with the &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided externally (by the developer or via an &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm dependency&lt;/a&gt;), and therefore does not try to generate any JavaScript code from the declaration. This is also why &lt;code&gt;external&lt;/code&gt; declarations can't have a body. For example:</target>
        </trans-unit>
        <trans-unit id="13b684242eb1261a088744c1edd0d98430ef5246" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that an &lt;code&gt;external&lt;/code&gt; class, package, function or property is a JavaScript module, you can use &lt;code&gt;@JsModule&lt;/code&gt; annotation. Consider you have the following CommonJS module called &quot;hello&quot;:</source>
          <target state="translated">Kotlin에 &lt;code&gt;external&lt;/code&gt; 클래스, 패키지, 함수 또는 속성이 JavaScript 모듈 &lt;code&gt;@JsModule&lt;/code&gt; 위해 @JsModule 주석을 사용할 수 있습니다 . &quot;hello&quot;라는 다음 CommonJS 모듈이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9709dd3d7713138256dbb958ab241135af68f988" translate="yes" xml:space="preserve">
          <source>To test it, we'll use a simple async function that resolves to a specified string after a specified time:</source>
          <target state="translated">이를 테스트하기 위해 지정된 시간 후에 지정된 문자열로 해석되는 간단한 비동기 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1b99a15ae02c59db4c41dbf465be5149eb5f7541" translate="yes" xml:space="preserve">
          <source>To throw an exception object, use the &lt;em&gt;throw&lt;/em&gt;-expression:</source>
          <target state="translated">예외 객체를 던질하기 위해 사용 &lt;em&gt;던져&lt;/em&gt; -expression를 :</target>
        </trans-unit>
        <trans-unit id="c7a0e8b8a829212ce4bf38fa9f7e144c221c0093" translate="yes" xml:space="preserve">
          <source>To turn off DCE completely, use the &lt;code&gt;devMode&lt;/code&gt; option in the &lt;code&gt;dceTask&lt;/code&gt;:</source>
          <target state="translated">To turn off DCE completely, use the &lt;code&gt;devMode&lt;/code&gt; option in the &lt;code&gt;dceTask&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5d84f46ddf483c214d924898fdd70375c5841ef" translate="yes" xml:space="preserve">
          <source>To turn on CSS support in your project, set the &lt;code&gt;cssSupport.enabled&lt;/code&gt; flag in the Gradle build file for &lt;code&gt;webpackTask&lt;/code&gt;, &lt;code&gt;runTask&lt;/code&gt;, and &lt;code&gt;testTask&lt;/code&gt; respectively. This configuration is also enabled by default when creating a new project using the wizard.</source>
          <target state="translated">프로젝트에서 CSS 지원을 사용 설정하려면 각각 &lt;code&gt;webpackTask&lt;/code&gt; , &lt;code&gt;runTask&lt;/code&gt; 및 &lt;code&gt;testTask&lt;/code&gt; 에 대한 Gradle 빌드 파일에서 &lt;code&gt;cssSupport.enabled&lt;/code&gt; 플래그를 설정하십시오 . 이 구성은 마법사를 사용하여 새 프로젝트를 만들 때 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="374704e123399146f9a10acdf418e1645171dca5" translate="yes" xml:space="preserve">
          <source>To unwrap the reference:</source>
          <target state="translated">참조를 풀려면</target>
        </trans-unit>
        <trans-unit id="a91c18bfe059c0da75a37ebc4ffaf3efe0d2e769" translate="yes" xml:space="preserve">
          <source>To unzip a list of pairs, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt;&lt;code&gt;unzip()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쌍의 목록을 압축 해제하려면 unzip &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt; &lt;code&gt;unzip()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a0e0cb040b2c181af6e3ea61de668187d10e532" translate="yes" xml:space="preserve">
          <source>To use a property, simply refer to it by name:</source>
          <target state="translated">To use a property, simply refer to it by name:</target>
        </trans-unit>
        <trans-unit id="d8bf5ffe82f149520490d0887cef3348767dda39" translate="yes" xml:space="preserve">
          <source>To use a property, we simply refer to it by name, as if it were a field in Java:</source>
          <target state="translated">속성을 사용하려면 Java의 필드 인 것처럼 이름으로 간단히 참조하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f72769e7770abb5ce6cba411b555a198f8e3b8fb" translate="yes" xml:space="preserve">
          <source>To use an API that requires opt-in in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:OptIn&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">파일의 모든 함수 및 클래스에서 옵트 인이 필요한 API를 사용하려면 패키지 사양 및 가져 오기 전에 파일 수준 주석 &lt;code&gt;@file:OptIn&lt;/code&gt; 을 파일 상단에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="213ffc2b7aa1496be9528a577f9f8df930989d35" translate="yes" xml:space="preserve">
          <source>To use an EAP build instead, we need to specify its version in &lt;code&gt;ext.kotlin_version&lt;/code&gt; and add the corresponding repository to the &lt;code&gt;buildscript&lt;/code&gt; section (usually EAP builds are located on &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt;)</source>
          <target state="translated">대신 EAP 빌드를 사용하려면, 우리는 그것의 버전을 지정해야 &lt;code&gt;ext.kotlin_version&lt;/code&gt; 과에 해당 저장소를 추가 &lt;code&gt;buildscript&lt;/code&gt; 의 부분 (일반적으로 EAP가에있는 빌드 &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="95905a2dc80cd98916ed0f8c91572f9ae392d28e" translate="yes" xml:space="preserve">
          <source>To use an experimental API in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:UseExperimental&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">파일의 모든 함수와 클래스에서 실험용 API를 사용하려면 파일 사양 주석 &lt;code&gt;@file:UseExperimental&lt;/code&gt; 을 패키지 사양 및 가져 오기 전에 파일 맨 위에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7911ada2a93fd834ce5409496ee220d5914c628" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in a scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list.</source>
          <target state="translated">To use classes or functions from a project in a scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list.</target>
        </trans-unit>
        <trans-unit id="905c85d4c4dbeeb5849e639296b6ff9051d12bf0" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in the scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list. To rebuild the module automatically before running the scratch, select &lt;strong&gt;Make before Run&lt;/strong&gt;.</source>
          <target state="translated">스크래치에서 프로젝트의 클래스 또는 함수를 사용하려면 &lt;code&gt;import&lt;/code&gt; 문을 사용하여 평소와 같이 스크래치 파일로 가져 오십시오 . 그런 다음 코드를 작성하고 &lt;strong&gt;모듈&lt;/strong&gt; 목록의 &lt;strong&gt;클래스 경로 사용&lt;/strong&gt; 에서 선택한 적절한 모듈로 실행 하십시오. 스크래치를 실행하기 전에 모듈을 자동으로 다시 빌드하려면 실행 전에 작성을 선택 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5befb1fd889ec3d540fc6857e1cc44328178daf4" translate="yes" xml:space="preserve">
          <source>To use different modes for the same project, use &lt;code&gt;cssSupport.rules&lt;/code&gt;. Here, you can specify a list of &lt;code&gt;KotlinWebpackCssRules&lt;/code&gt;, each of which define a mode, as well as &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleinclude&quot;&gt;include&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleexclude&quot;&gt;exclude&lt;/a&gt; patterns.</source>
          <target state="translated">동일한 프로젝트에 다른 모드를 사용하려면 &lt;code&gt;cssSupport.rules&lt;/code&gt; 를 사용 하십시오 . 여기에서 &lt;code&gt;KotlinWebpackCssRules&lt;/code&gt; 목록을 지정할 수 있습니다 . 각 목록은 모드를 정의하고 패턴 을 &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleinclude&quot;&gt;포함&lt;/a&gt; 및 &lt;a href=&quot;https://webpack.js.org/configuration/module/#ruleexclude&quot;&gt;제외&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7e6f898d3fd804cbaaa8f5e41eecb4b87b3f095b" translate="yes" xml:space="preserve">
          <source>To use it with Kotlin configure annotation processing dependency using &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Kotlin과 함께 사용하려면 &lt;code&gt;kapt&lt;/code&gt; 를 사용하여 주석 처리 종속성을 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b18f46b3a0f449d7eb395f93e2e99d2ceb07f22" translate="yes" xml:space="preserve">
          <source>To use reflection in a Gradle or Maven project, add the dependency on &lt;code&gt;kotlin-reflect&lt;/code&gt;:</source>
          <target state="translated">To use reflection in a Gradle or Maven project, add the dependency on &lt;code&gt;kotlin-reflect&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a24de3bc480fd74ef920d5e8c2200b8ea53a9381" translate="yes" xml:space="preserve">
          <source>To use such an extension outside its declaring package, we need to import it at the call site:</source>
          <target state="translated">이러한 확장을 선언 패키지 외부에서 사용하려면 호출 사이트에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="f45da6c5e75b429df6c944cb1a348aa71eac1487" translate="yes" xml:space="preserve">
          <source>To use the Gradle worker API for parallel execution of kapt tasks, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">kapt 작업의 병렬 실행에 Gradle worker API를 사용하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b36ae1fba60b209f3facc66006c1d59e359e4b" translate="yes" xml:space="preserve">
          <source>To use the library just</source>
          <target state="translated">라이브러리를 사용하려면</target>
        </trans-unit>
        <trans-unit id="f8b6262cd9dc8c43d7c667ac936a5f2566f2a0e4" translate="yes" xml:space="preserve">
          <source>To use these dependencies from a Kotlin code, import a package &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;. In the example above, it's &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt;.</source>
          <target state="translated">Kotlin 코드에서 이러한 종속성을 사용하려면 &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; 패키지를 가져 오십시오 . 위의 예에서 &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fc228ddfd7202033ce71a7fc317732c5e0b0cb8d" translate="yes" xml:space="preserve">
          <source>To use these dependencies from the Kotlin code, import the packages &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">To use these dependencies from the Kotlin code, import the packages &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f56a6a1ece973c1e685039b7b24f3bed65f0bb" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to &lt;strong&gt;Settings | Editor | Inspections&lt;/strong&gt; and enable the &lt;strong&gt;Kotlin | Style issues | File is not formatted according to project settings&lt;/strong&gt; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">To verify that your code is formatted according to the style guide, go to &lt;strong&gt;Settings | Editor | Inspections&lt;/strong&gt; and enable the &lt;strong&gt;Kotlin | Style issues | File is not formatted according to project settings&lt;/strong&gt; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</target>
        </trans-unit>
        <trans-unit id="29ce373f521a913b58c57c24b3da2c509d708a6c" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to the inspection settings and enable the &quot;Kotlin | Style issues | File is not formatted according to project settings&quot; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">스타일 가이드에 따라 코드 형식이 지정되었는지 확인하려면 검사 설정으로 이동하여 &quot;Kotlin | 스타일 문제 | 파일이 프로젝트 설정에 따라 형식이 지정되지 않았습니다&quot;검사를 활성화하십시오. 스타일 가이드에 설명 된 다른 문제 (예 : 명명 규칙)를 확인하는 추가 검사는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4960c3af648de37ee9fc988a1b8a755e743e505" translate="yes" xml:space="preserve">
          <source>To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the &lt;code&gt;withTimeout&lt;/code&gt; block.</source>
          <target state="translated">To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the &lt;code&gt;withTimeout&lt;/code&gt; block.</target>
        </trans-unit>
        <trans-unit id="b6747c485a8043bd5cfaa965ac1719dda893a066" translate="yes" xml:space="preserve">
          <source>To wrap the reference:</source>
          <target state="translated">참조를 래핑하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a2b342afe760f02175e18eb57be53d77e5b4d945" translate="yes" xml:space="preserve">
          <source>Tools for Android Development</source>
          <target state="translated">안드로이드 개발 도구</target>
        </trans-unit>
        <trans-unit id="933c173dc4997663d3dd2b639f726f17d399abb1" translate="yes" xml:space="preserve">
          <source>Top level/global variables of non-primitive types are by default accessible in the main thread (i.e., the thread which initialized &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime first) only. Access from another thread will lead to an &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; being thrown. To make such variables accessible in other threads, you can use either the &lt;code&gt;@ThreadLocal&lt;/code&gt; annotation, and mark the value thread local or &lt;code&gt;@SharedImmutable&lt;/code&gt;, which will make the value frozen and accessible from other threads.</source>
          <target state="translated">기본이 아닌 유형의 최상위 레벨 / 글로벌 변수는 기본적으로 메인 스레드 (즉, &lt;em&gt;Kotlin / Native&lt;/em&gt; 런타임을 먼저 초기화 한 스레드 )에서만 액세스 할 수 있습니다 . 다른 스레드에서 액세스하면 &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; 이 발생합니다. 이러한 변수를 다른 스레드에서 액세스 할 수 있도록하려면 &lt;code&gt;@ThreadLocal&lt;/code&gt; 주석을 사용 하고 값 스레드를 로컬 또는 &lt;code&gt;@SharedImmutable&lt;/code&gt; 로 표시하면 다른 스레드에서 값을 고정하고 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10164060fa5359f1cc0440621a4aa0561a65a4b" translate="yes" xml:space="preserve">
          <source>Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</source>
          <target state="translated">최상위 클래스 Kotlin 함수 및 속성은 특수 클래스의 멤버로 액세스 할 수 있습니다. 각 Kotlin 파일은 이러한 클래스로 변환됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="72f832e9bb11ffaf0e6dadede4c2d82d643da82d" translate="yes" xml:space="preserve">
          <source>Top-level blocks</source>
          <target state="translated">최상위 블록</target>
        </trans-unit>
        <trans-unit id="2b1be77aa458090db17874852b17692b274f4c30" translate="yes" xml:space="preserve">
          <source>Top-level functions and properties</source>
          <target state="translated">최상위 기능 및 속성</target>
        </trans-unit>
        <trans-unit id="73a9d7257a50c4b586e17a750a9b120479406586" translate="yes" xml:space="preserve">
          <source>Top-level variables:</source>
          <target state="translated">최상위 변수 :</target>
        </trans-unit>
        <trans-unit id="093982a5b38ce32bb690b5df5afe9cfb58db39b3" translate="yes" xml:space="preserve">
          <source>Top-level, or member of an &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;object&lt;/em&gt; declaration&lt;/a&gt; or &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;a &lt;em&gt;companion object&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">의 최상위 또는 멤버 &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;객체&lt;/em&gt; 선언&lt;/a&gt; 또는 &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;em&gt;동반자 객체&lt;/em&gt;&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3f139abb7a549a1210b36f7dbf89215ad6c9902" translate="yes" xml:space="preserve">
          <source>Touch</source>
          <target state="translated">Touch</target>
        </trans-unit>
        <trans-unit id="1efa29eabe3ababde0e86df3b6d2edc46db3122e" translate="yes" xml:space="preserve">
          <source>TouchList</source>
          <target state="translated">TouchList</target>
        </trans-unit>
        <trans-unit id="86c192cdf813e67ab4284db18cce6c47a873de77" translate="yes" xml:space="preserve">
          <source>TrackEventInit</source>
          <target state="translated">TrackEventInit</target>
        </trans-unit>
        <trans-unit id="04a727b8d4352f2bb05170808566a662370f1470" translate="yes" xml:space="preserve">
          <source>Trailing comma</source>
          <target state="translated">후행 쉼표</target>
        </trans-unit>
        <trans-unit id="7b5b3a2e5f602edd973d6bc7c27d9b7106a52ef4" translate="yes" xml:space="preserve">
          <source>Trailing commas</source>
          <target state="translated">후행 쉼표</target>
        </trans-unit>
        <trans-unit id="10b9c6cd7256580987215cb5bd31fae33f7491a8" translate="yes" xml:space="preserve">
          <source>Trailing commas are entirely optional &amp;ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</source>
          <target state="translated">Trailing commas are entirely optional &amp;ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</target>
        </trans-unit>
        <trans-unit id="24c733cfc9ff52310bfeff0739e9d84bd974f090" translate="yes" xml:space="preserve">
          <source>Training Partners</source>
          <target state="translated">교육 파트너</target>
        </trans-unit>
        <trans-unit id="62000f6d60c7b6da6e48acb50b9e4d2454c263e3" translate="yes" xml:space="preserve">
          <source>TransferMode</source>
          <target state="translated">TransferMode</target>
        </trans-unit>
        <trans-unit id="5493525620b201e4aeb2e3e266e9b2a0148f6e9a" translate="yes" xml:space="preserve">
          <source>Transform operator</source>
          <target state="translated">변환 연산자</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="e58ba5ae9c3b287bdcbf2771b01865f2bca67751" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Iterable&lt;/code&gt; on &lt;code&gt;Sequence&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Sequence&lt;/code&gt; 에서 &lt;code&gt;Iterable&lt;/code&gt; 으로 변환</target>
        </trans-unit>
        <trans-unit id="81c5e51e91e71b63dc5528985dabb38605c21cee" translate="yes" xml:space="preserve">
          <source>Transformations to &lt;code&gt;Sequence&lt;/code&gt; on &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, and &lt;code&gt;Map&lt;/code&gt;</source>
          <target state="translated">로 변환 &lt;code&gt;Sequence&lt;/code&gt; 에서 &lt;code&gt;Iterable&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; 및 &lt;code&gt;Map&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45d5bc5a6500f8488347501d41f5194f063eae68" translate="yes" xml:space="preserve">
          <source>Transient</source>
          <target state="translated">Transient</target>
        </trans-unit>
        <trans-unit id="ba8d3f89d630067e3ad00c3e459e314bd98fb9a0" translate="yes" xml:space="preserve">
          <source>Transitive: for any non-null values &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if &lt;code&gt;x.equals(y)&lt;/code&gt; returns true and &lt;code&gt;y.equals(z)&lt;/code&gt; returns true, then &lt;code&gt;x.equals(z)&lt;/code&gt; should return true.</source>
          <target state="translated">전이 : 널이 아닌 값 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 경우 &lt;code&gt;x.equals(y)&lt;/code&gt; 가 true를 리턴하고 &lt;code&gt;y.equals(z)&lt;/code&gt; 가 true를 리턴하면 &lt;code&gt;x.equals(z)&lt;/code&gt; 는 true를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b98ac58ac04384390fe968f8d17e1762075dcc" translate="yes" xml:space="preserve">
          <source>Translate primitive arrays to JS typed arrays</source>
          <target state="translated">기본 배열을 JS 유형 배열로 변환</target>
        </trans-unit>
        <trans-unit id="a1e378439cd6792c22e6754f9de426ee92e8887a" translate="yes" xml:space="preserve">
          <source>Translated to</source>
          <target state="translated">로 번역</target>
        </trans-unit>
        <trans-unit id="bd2fa02487c23403447e0670b33275ea05db6a74" translate="yes" xml:space="preserve">
          <source>Translation Rules</source>
          <target state="translated">번역 규칙</target>
        </trans-unit>
        <trans-unit id="ab6dfa598f3ee1889c506fcb09d74fa1777c572b" translate="yes" xml:space="preserve">
          <source>Translation of type &lt;code&gt;Nothing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Nothing&lt;/code&gt; 의 번역</target>
        </trans-unit>
        <trans-unit id="6aceb57c8bb80570e896470165c635c1ee57a688" translate="yes" xml:space="preserve">
          <source>Translation rules</source>
          <target state="translated">Translation rules</target>
        </trans-unit>
        <trans-unit id="4d92e703a622ed46d6e27f0f0f77397beeb3e132" translate="yes" xml:space="preserve">
          <source>Transparent catch</source>
          <target state="translated">투명 캐치</target>
        </trans-unit>
        <trans-unit id="a15aca388afb19d901171e68fd72afd431d071e5" translate="yes" xml:space="preserve">
          <source>Traversing a map/list of pairs</source>
          <target state="translated">지도 / 쌍 목록 탐색</target>
        </trans-unit>
        <trans-unit id="c5549ac8b888e22b01fa637b7351d8e5201d7fba" translate="yes" xml:space="preserve">
          <source>TreeWalker</source>
          <target state="translated">TreeWalker</target>
        </trans-unit>
        <trans-unit id="bf7930508d19dc53b19991f963b30e949ffffae4" translate="yes" xml:space="preserve">
          <source>Trigonometric: &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt; and inverse of them: &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;;</source>
          <target state="translated">삼각법 : &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; 및 그 반대로 : &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;atan2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b9283be1760ffff3d2b71a4bf3400fc0c777b4fb" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">소스 문자열의 모든 행에서 선행 공백 문자 다음에 &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; 를 자르고 공백 이있는 경우 첫 번째와 마지막 행을 제거합니다 (공백 차이와 비어 있음).</target>
        </trans-unit>
        <trans-unit id="5480c14a1f35b84e453f6cd73b5a2004a2f5d464" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</target>
        </trans-unit>
        <trans-unit id="c35e61d912f4e00490fababb98d899c86bab87f9" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">소스 문자열의 모든 행에서 선행 공백 문자 다음에 &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; 를 자르고 공백 이있는 경우 첫 번째와 마지막 행을 제거합니다 (공백 차이와 비어 있음).</target>
        </trans-unit>
        <trans-unit id="84a97aca5ec5480f19364dafde3094ff54f3e81a" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</target>
        </trans-unit>
        <trans-unit id="ae1a12e0ad64ac32c1b6bcc5a4f65c861d2ccdb6" translate="yes" xml:space="preserve">
          <source>Triple</source>
          <target state="translated">Triple</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="dd25f60abb02d8a8fead2fd0c632ac71f7dc7572" translate="yes" xml:space="preserve">
          <source>True if this BitSet contains no bits set to true.</source>
          <target state="translated">이 BitSet에 비트가 true로 설정되어 있지 않으면 True입니다.</target>
        </trans-unit>
        <trans-unit id="ebadece2244cd8c3930af24f6efed50ba5303aeb" translate="yes" xml:space="preserve">
          <source>Try is an expression</source>
          <target state="translated">시도는 표현이다</target>
        </trans-unit>
        <trans-unit id="76626410fd299e2579daa03a6a8e059a7c331dac" translate="yes" xml:space="preserve">
          <source>Try running the following code:</source>
          <target state="translated">다음 코드를 실행 해보십시오.</target>
        </trans-unit>
        <trans-unit id="ab16b9ed40416d31269e0f90879c02e2beaffb5d" translate="yes" xml:space="preserve">
          <source>Try the following example:</source>
          <target state="translated">다음 예제를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="6598cd1f03cde7303010f8b82688f8cd83e05fd7" translate="yes" xml:space="preserve">
          <source>Try the hierarchical project structure</source>
          <target state="translated">계층 적 프로젝트 구조 시도</target>
        </trans-unit>
        <trans-unit id="6e8975e856a765f6b65172a38acea83accc861c3" translate="yes" xml:space="preserve">
          <source>Tuning the Gradle Build Script</source>
          <target state="translated">Gradle 빌드 스크립트 튜닝</target>
        </trans-unit>
        <trans-unit id="ea1b6a2e19cb07b905a5f8a640d896e87bcec9bf" translate="yes" xml:space="preserve">
          <source>Turn any warnings into a compilation error.</source>
          <target state="translated">모든 경고를 컴파일 오류로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="486df8c49f3484e79ec93676a1d2d32e3c21544f" translate="yes" xml:space="preserve">
          <source>Turn off the discovery of annotation processors in the compile classpath by adding this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가하여 컴파일 클래스 경로에서 주석 프로세서 감지를 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a8a70d82aa05be09e708b91e7f3e4c134d89ffcd" translate="yes" xml:space="preserve">
          <source>Two characters are considered the same ignoring case if at least one of the following is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">다음 중 적어도 하나 인 경우 두 문자는 같은 무시하는 경우 간주됩니다 &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab472c51dfbccf051740af19176dfafb00b61af8" translate="yes" xml:space="preserve">
          <source>Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.</source>
          <target state="translated">동일한 시드를 가진 두 개의 생성기는 동일한 버전의 Kotlin 런타임 내에서 동일한 순서의 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d137720f3328e5a478b178126ce3903c8817736d" translate="yes" xml:space="preserve">
          <source>Two maps containing the equal pairs are equal regardless of the pair order.</source>
          <target state="translated">동일한 쌍을 포함하는 두 맵은 쌍 순서에 관계없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="5f6616a8e5da9fee3d521ed755f2bea54b08215a" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: &amp;#x27;is&amp;#x27; and &amp;#x27;as&amp;#x27;</source>
          <target state="translated">유형 검사 및 캐스트 : 'is'및 'as'</target>
        </trans-unit>
        <trans-unit id="d6cc07866d5f06f3719a56316deb52a9dd1a6362" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: 'is' and 'as'</source>
          <target state="translated">유형 검사 및 캐스트 : 'is'및 'as'</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">유형 별명</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">타입 별칭</target>
        </trans-unit>
        <trans-unit id="723718d194ac3a64c7f264ffc4d4f72b344ce07d" translate="yes" xml:space="preserve">
          <source>Type aliases can have only one member, while functional interfaces can have multiple non-abstract members and one abstract member. Functional interfaces can also implement and extend other interfaces.</source>
          <target state="translated">형식 별칭에는 멤버가 하나만있을 수 있지만 기능 인터페이스에는 여러 비추 상 멤버와 하나의 추상 멤버가있을 수 있습니다. 기능 인터페이스는 다른 인터페이스를 구현하고 확장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="69c8e849ce31321a314a70ac8ad4ed39beff1378" translate="yes" xml:space="preserve">
          <source>Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; and use &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; in your code, the Kotlin compiler always expands it to &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt;. Thus you can pass a variable of your type whenever a general function type is required and vice versa:</source>
          <target state="translated">타입 별칭은 새로운 타입을 도입하지 않습니다. 해당하는 기본 유형과 같습니다. 코드에서 &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; 를 추가 하고 &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; 를 사용 하면 Kotlin 컴파일러는 항상 &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt; 확장합니다 . 따라서 일반 함수 유형이 필요할 때마다 유형의 변수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63f9c00fb5f4cc41a0eed5075c935b736c6b9723" translate="yes" xml:space="preserve">
          <source>Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.</source>
          <target state="translated">유형 별명은 기존 유형의 대체 이름을 제공합니다. 유형 이름이 너무 길면 더 짧은 다른 이름을 도입하고 대신 새 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2a8d10c5940641abcd5ce54fb8bcd8a1818a8ed" translate="yes" xml:space="preserve">
          <source>Type annotations in the JVM bytecode</source>
          <target state="translated">JVM 바이트 코드의 유형 주석</target>
        </trans-unit>
        <trans-unit id="c296bfc3cf8da18578c109dce183097398bf868c" translate="yes" xml:space="preserve">
          <source>Type annotations on method parameters, method return types and property types;</source>
          <target state="translated">메소드 매개 변수, 메소드 반환 유형 및 속성 유형에 대한 유형 주석</target>
        </trans-unit>
        <trans-unit id="e35e3a28b52f56ce98adcccb56e038088090c61a" translate="yes" xml:space="preserve">
          <source>Type arguments</source>
          <target state="translated">Type arguments</target>
        </trans-unit>
        <trans-unit id="f97f977bc0dba85c3cc52fd08f6033a3696be06a" translate="yes" xml:space="preserve">
          <source>Type arguments can be omitted if they can be inferred from the context, so the following example works as well:</source>
          <target state="translated">컨텍스트에서 유추 할 수있는 유형 인수는 생략 할 수 있으므로 다음 예제도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c98c974ad55a448f7905288ae79a3c29e3dafc00" translate="yes" xml:space="preserve">
          <source>Type arguments passed for the parameters of the classifier in this type. For example, in the type &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; the only type argument is &lt;code&gt;out Number&lt;/code&gt;.</source>
          <target state="translated">이 유형의 분류 자 ​​매개 변수에 전달 된 유형 인수. 예를 들어, &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; 유형에서 유일한 유형 인수는 &lt;code&gt;out Number&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17f4a34465afc16c831c4800dd92a48a4229a238" translate="yes" xml:space="preserve">
          <source>Type casts to generic types with concrete type arguments, e.g. &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt;, cannot be checked at runtime.</source>
          <target state="translated">구체적인 유형 인수 (예 : &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt; ) 가있는 일반 유형으로 유형 캐스트 는 런타임시 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="73156460a89d705ba62bd534bd81f39c8db2596a" translate="yes" xml:space="preserve">
          <source>Type checks and automatic casts</source>
          <target state="translated">Type checks and automatic casts</target>
        </trans-unit>
        <trans-unit id="793f10e89d89960ec6635302ed647f148619a822" translate="yes" xml:space="preserve">
          <source>Type erasure</source>
          <target state="translated">유형 삭제</target>
        </trans-unit>
        <trans-unit id="40dc0a7305bb05f3cc921959233fc31aff814e2e" translate="yes" xml:space="preserve">
          <source>Type erasure and generic type checks</source>
          <target state="translated">유형 삭제 및 일반 유형 검사</target>
        </trans-unit>
        <trans-unit id="3a57e7033772e15f6c935d00cab613d6b63a13b4" translate="yes" xml:space="preserve">
          <source>Type inference for variable and property types</source>
          <target state="translated">변수 및 속성 유형에 대한 유형 유추</target>
        </trans-unit>
        <trans-unit id="6468c2c68f3a4de506104359dc49acb341f7ce4b" translate="yes" xml:space="preserve">
          <source>Type of this parameter. For a &lt;code&gt;vararg&lt;/code&gt; parameter, this is the type of the corresponding array, not the individual element.</source>
          <target state="translated">이 매개 변수의 유형입니다. A의 &lt;code&gt;vararg&lt;/code&gt; 파라미터, 이는 해당 어레이가 아닌 개별 요소의 유형이다.</target>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="translated">유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="67db91aa392a58df5790c33c41ae1990e5a33a95" translate="yes" xml:space="preserve">
          <source>Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.</source>
          <target state="translated">유형 투영은 별 투영 또는 특정 유형과 선택적 분산으로 구성된 엔터티입니다.</target>
        </trans-unit>
        <trans-unit id="a1c1994c749574f626726569018d7132330feb4f" translate="yes" xml:space="preserve">
          <source>Type projections</source>
          <target state="translated">타입 투영</target>
        </trans-unit>
        <trans-unit id="390df132c9a4d4db52e48418904c22311abcfb25" translate="yes" xml:space="preserve">
          <source>Type projections (use-site covariance and contravariance)</source>
          <target state="translated">유형 예측 (사용 사이트 공분산 및 공분산)</target>
        </trans-unit>
        <trans-unit id="abe0a5c2d281fcb1877a803065e24a61b33d5485" translate="yes" xml:space="preserve">
          <source>Type qualifier defaults (since 1.1.50)</source>
          <target state="translated">한정자 기본값 (1.1.50부터)</target>
        </trans-unit>
        <trans-unit id="7774fb35aa4a81a2d582ed079ba64fde2c6c6958" translate="yes" xml:space="preserve">
          <source>Type qualifier nicknames (since 1.1.50)</source>
          <target state="translated">한정자 닉네임 (1.1.50부터)</target>
        </trans-unit>
        <trans-unit id="acbd0130304bd83955856731709666b221130b62" translate="yes" xml:space="preserve">
          <source>Type safety problem because of incorrect subtyping for intersection types</source>
          <target state="translated">교차 유형에 대한 잘못된 하위 유형 지정으로 인한 유형 안전성 문제</target>
        </trans-unit>
        <trans-unit id="9199f1fd6ec494778d67bf415e37aa0839ac622f" translate="yes" xml:space="preserve">
          <source>Type safety problem because of lack of captured conversion against nullable type argument</source>
          <target state="translated">nullable 형식 인수에 대해 캡처 된 변환이 없기 때문에 형식 안전성 문제</target>
        </trans-unit>
        <trans-unit id="bb995680367f27e40ce4ad1d6abb4c604f7187b7" translate="yes" xml:space="preserve">
          <source>Type safety problem because several equal type variables are instantiated with a different types</source>
          <target state="translated">여러 개의 동일한 유형 변수가 다른 유형으로 인스턴스화되기 때문에 유형 안전성 문제</target>
        </trans-unit>
        <trans-unit id="40de16300b7ec7ebb7fd5b46ebfe06fa7442e5d2" translate="yes" xml:space="preserve">
          <source>Type usage</source>
          <target state="translated">유형 사용법</target>
        </trans-unit>
        <trans-unit id="4903c79122878e4bb6246343ee54954a9e90d953" translate="yes" xml:space="preserve">
          <source>Type variable leaks from builder inference because of using &lt;code&gt;this&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 표현식 을 사용하기 때문에 빌더 추론에서 유형 변수 누출</target>
        </trans-unit>
        <trans-unit id="302ec0e139d68906dc0b295bb935fe896afa1e82" translate="yes" xml:space="preserve">
          <source>Type-Safe Builders</source>
          <target state="translated">유형 안전 빌더</target>
        </trans-unit>
        <trans-unit id="1c6379917dd2967a0cd2179d5b9d494b8ce1b4e8" translate="yes" xml:space="preserve">
          <source>Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Some of the example use cases for the builders are:</source>
          <target state="translated">유형 안전 빌더를 사용하면 복잡한 계층 적 데이터 구조를 반 선언적 방식으로 구축하는 데 적합한 Kotlin 기반 DSL (Domain-Specific Language)을 만들 수 있습니다. 빌더의 일부 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c15b26d8e7df3e3ffb8c17df0302ea2aa484921" translate="yes" xml:space="preserve">
          <source>TypeCastException</source>
          <target state="translated">TypeCastException</target>
        </trans-unit>
        <trans-unit id="5f0d1a781a66df1f72742486a55df1e5b04f2308" translate="yes" xml:space="preserve">
          <source>Typealias describing custom exception reporting hook.</source>
          <target state="translated">사용자 정의 예외보고 후크를 설명하는 유형별</target>
        </trans-unit>
        <trans-unit id="f3f4c434904369ad0a9f93c33f4c9768b4547a37" translate="yes" xml:space="preserve">
          <source>TypedArrays support enabled by default</source>
          <target state="translated">기본적으로 TypedArrays 지원 활성화</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5ee39ed12bcc53f39d2691296714b602c56e8452" translate="yes" xml:space="preserve">
          <source>Types in C Language</source>
          <target state="translated">C 언어의 유형</target>
        </trans-unit>
        <trans-unit id="9082e24429af3d96afc6c792bd53d243c13fe913" translate="yes" xml:space="preserve">
          <source>Types in Kotlin are optional in many places due to pervasive use of type-inference, but every declaration still has a well-defined static type that is known at compilation.</source>
          <target state="translated">Kotlin의 형식은 형식 유추를 광범위하게 사용하기 때문에 여러 곳에서 선택 사항이지만 모든 선언에는 여전히 컴파일시 알려진 잘 정의 된 정적 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="629a9e78a0114f36f48645e6ead99e73e5226592" translate="yes" xml:space="preserve">
          <source>Types mapping between C and Kotlin/Native</source>
          <target state="translated">C와 Kotlin / Native 사이의 유형 매핑</target>
        </trans-unit>
        <trans-unit id="23a10fa48ff804faeadfa8169422520460b61a41" translate="yes" xml:space="preserve">
          <source>Typesafe HTML DSL</source>
          <target state="translated">Typesafe HTML DSL</target>
        </trans-unit>
        <trans-unit id="f4beb9af58f792082d8857ce30b4be1bdbe9b57a" translate="yes" xml:space="preserve">
          <source>Typography</source>
          <target state="translated">Typography</target>
        </trans-unit>
        <trans-unit id="4ae5c7578750deca68bcc325a7a71916e13eb9f0" translate="yes" xml:space="preserve">
          <source>UArraysKt</source>
          <target state="translated">UArraysKt</target>
        </trans-unit>
        <trans-unit id="bf674fff56341390c001cb60679614bd8b320e06" translate="yes" xml:space="preserve">
          <source>UByte</source>
          <target state="translated">UByte</target>
        </trans-unit>
        <trans-unit id="ffb6040505a41eac67ecae4d97b182ca73c78ec7" translate="yes" xml:space="preserve">
          <source>UByteArray</source>
          <target state="translated">UByteArray</target>
        </trans-unit>
        <trans-unit id="d70700d1cf06666209f322639803c081fb20d34b" translate="yes" xml:space="preserve">
          <source>UByteIterator</source>
          <target state="translated">UByteIterator</target>
        </trans-unit>
        <trans-unit id="5c472b4b939131094e43f08559b073c75fc2a028" translate="yes" xml:space="preserve">
          <source>UByteVar</source>
          <target state="translated">UByteVar</target>
        </trans-unit>
        <trans-unit id="f25071b42b8c8e395a2b2b3981b7f23745b87556" translate="yes" xml:space="preserve">
          <source>UByteVarOf</source>
          <target state="translated">UByteVarOf</target>
        </trans-unit>
        <trans-unit id="7df33eb953a0db74ecea7bf713e814fb3abc743c" translate="yes" xml:space="preserve">
          <source>UIEventInit</source>
          <target state="translated">UIEventInit</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="e8203a992b0218cb4341f1de99192c75977adf66" translate="yes" xml:space="preserve">
          <source>UIntArray</source>
          <target state="translated">UIntArray</target>
        </trans-unit>
        <trans-unit id="107a5f6058e02cbfca8e781b5a2a6f523ad395cb" translate="yes" xml:space="preserve">
          <source>UIntIterator</source>
          <target state="translated">UIntIterator</target>
        </trans-unit>
        <trans-unit id="b426f73d819457b44ee2c1f6127ae0354bab9219" translate="yes" xml:space="preserve">
          <source>UIntProgression</source>
          <target state="translated">UIntProgression</target>
        </trans-unit>
        <trans-unit id="733f5415b770d705f77b9612bf3ea932f2bce7d0" translate="yes" xml:space="preserve">
          <source>UIntRange</source>
          <target state="translated">UIntRange</target>
        </trans-unit>
        <trans-unit id="c9533b600e74bcc2cae112123bf64c63ddcac0d1" translate="yes" xml:space="preserve">
          <source>UIntVar</source>
          <target state="translated">UIntVar</target>
        </trans-unit>
        <trans-unit id="77c6c1f150c9389635fa7924b4f92a8549cf352c" translate="yes" xml:space="preserve">
          <source>UIntVarOf</source>
          <target state="translated">UIntVarOf</target>
        </trans-unit>
        <trans-unit id="89e5acbaebf4cf3fe914f8e97ce3365330718921" translate="yes" xml:space="preserve">
          <source>ULong</source>
          <target state="translated">ULong</target>
        </trans-unit>
        <trans-unit id="0aede794cd54bbb254cbbba847a9015fdedd384b" translate="yes" xml:space="preserve">
          <source>ULongArray</source>
          <target state="translated">ULongArray</target>
        </trans-unit>
        <trans-unit id="f83610c14f64002be2365b4b214aea8d4eb7c555" translate="yes" xml:space="preserve">
          <source>ULongIterator</source>
          <target state="translated">ULongIterator</target>
        </trans-unit>
        <trans-unit id="7f4860e3cc03b10b3ed8b10361499545cea0082e" translate="yes" xml:space="preserve">
          <source>ULongProgression</source>
          <target state="translated">ULongProgression</target>
        </trans-unit>
        <trans-unit id="904eba861b0907dd0e83aefaefd037f230269422" translate="yes" xml:space="preserve">
          <source>ULongRange</source>
          <target state="translated">ULongRange</target>
        </trans-unit>
        <trans-unit id="c10238514adfeb120f1beff5e873dea7b5ed95a8" translate="yes" xml:space="preserve">
          <source>ULongVar</source>
          <target state="translated">ULongVar</target>
        </trans-unit>
        <trans-unit id="f9dbd48fa2388e1f99c73bab257c97f132eb1089" translate="yes" xml:space="preserve">
          <source>ULongVarOf</source>
          <target state="translated">ULongVarOf</target>
        </trans-unit>
        <trans-unit id="b9a5671fcf84e88d78fc3704de6f9b452eff55a8" translate="yes" xml:space="preserve">
          <source>UNASSIGNED</source>
          <target state="translated">UNASSIGNED</target>
        </trans-unit>
        <trans-unit id="67a492265c45012bb305d1d916be6fecf6ea8e3e" translate="yes" xml:space="preserve">
          <source>UNDEFINED</source>
          <target state="translated">UNDEFINED</target>
        </trans-unit>
        <trans-unit id="a7864204909e345af29e9c794841c9fe894997a9" translate="yes" xml:space="preserve">
          <source>UNIX_LINES</source>
          <target state="translated">UNIX_LINES</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="c12e2347be0a8619c1d9ecacaec292e6f681ff3c" translate="yes" xml:space="preserve">
          <source>UNSAFE</source>
          <target state="translated">UNSAFE</target>
        </trans-unit>
        <trans-unit id="260ff90ffb9b1a7afc1635ad4eeec327ff83ec80" translate="yes" xml:space="preserve">
          <source>UPPERCASE_LETTER</source>
          <target state="translated">UPPERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="b19e8d66e7f004e226c44a75766dadab7d09911a" translate="yes" xml:space="preserve">
          <source>URLSearchParams</source>
          <target state="translated">URLSearchParams</target>
        </trans-unit>
        <trans-unit id="91e7bf3c4d0ab9784e0c43761883c8268e94bc3e" translate="yes" xml:space="preserve">
          <source>US_ASCII</source>
          <target state="translated">US_ASCII</target>
        </trans-unit>
        <trans-unit id="3f4264aca0374d417f001d13663bbf89f0617103" translate="yes" xml:space="preserve">
          <source>UShort</source>
          <target state="translated">UShort</target>
        </trans-unit>
        <trans-unit id="c9c0b8b91e36fe7c1c4c0418920e6f5691e8c55a" translate="yes" xml:space="preserve">
          <source>UShortArray</source>
          <target state="translated">UShortArray</target>
        </trans-unit>
        <trans-unit id="6c3a83167054246ea25835255ce7b0e018316b2a" translate="yes" xml:space="preserve">
          <source>UShortIterator</source>
          <target state="translated">UShortIterator</target>
        </trans-unit>
        <trans-unit id="a33eeb13596790b08a6df8799ea234e412c8c47b" translate="yes" xml:space="preserve">
          <source>UShortVar</source>
          <target state="translated">UShortVar</target>
        </trans-unit>
        <trans-unit id="282cb40f96ea3b82ef408a23ef69ab3812e1c45c" translate="yes" xml:space="preserve">
          <source>UShortVarOf</source>
          <target state="translated">UShortVarOf</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="f0217f65f3e1f538b0d8cda26e80a2285c43df22" translate="yes" xml:space="preserve">
          <source>UTF-16 code unit (see the section on &lt;a href=&quot;strings&quot;&gt;strings&lt;/a&gt; - in most cases, this is one Unicode character, but it might be just one half of a Unicode character)</source>
          <target state="translated">UTF-16 코드 단위 ( &lt;a href=&quot;strings&quot;&gt;문자열&lt;/a&gt; 섹션 참조 -대부분의 경우 이것은 유니 코드 문자이지만 유니 코드 문자의 절반 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="3133dd8458a32c8b5ce4a722caa62b68748d9288" translate="yes" xml:space="preserve">
          <source>UTF_16</source>
          <target state="translated">UTF_16</target>
        </trans-unit>
        <trans-unit id="6ca2e2b19e1ecda564482fabe6d3670b269a5872" translate="yes" xml:space="preserve">
          <source>UTF_16BE</source>
          <target state="translated">UTF_16BE</target>
        </trans-unit>
        <trans-unit id="9754e677d06d03c4582e2dcf98147ca46f84d72e" translate="yes" xml:space="preserve">
          <source>UTF_16LE</source>
          <target state="translated">UTF_16LE</target>
        </trans-unit>
        <trans-unit id="447ed343c0ab25980389215d35f14db291c88450" translate="yes" xml:space="preserve">
          <source>UTF_32</source>
          <target state="translated">UTF_32</target>
        </trans-unit>
        <trans-unit id="92586032892e03cbec5d2f808289d67c3e5fe454" translate="yes" xml:space="preserve">
          <source>UTF_32BE</source>
          <target state="translated">UTF_32BE</target>
        </trans-unit>
        <trans-unit id="cbf0128f0e447f51c74b68507c6628894645216c" translate="yes" xml:space="preserve">
          <source>UTF_32LE</source>
          <target state="translated">UTF_32LE</target>
        </trans-unit>
        <trans-unit id="444b32f7d1774bb52a894fb896e3e3f1afe43c1f" translate="yes" xml:space="preserve">
          <source>UTF_8</source>
          <target state="translated">UTF_8</target>
        </trans-unit>
        <trans-unit id="ee17a2d4842b1562f38fb267817829d58a3dedfb" translate="yes" xml:space="preserve">
          <source>Uint16Array</source>
          <target state="translated">Uint16Array</target>
        </trans-unit>
        <trans-unit id="633c2aa79d88322b5d53222bfe0bb765531ece57" translate="yes" xml:space="preserve">
          <source>Uint32Array</source>
          <target state="translated">Uint32Array</target>
        </trans-unit>
        <trans-unit id="9dafd0a91ea1eadf5a4b323d71716a37f430543c" translate="yes" xml:space="preserve">
          <source>Uint8Array</source>
          <target state="translated">Uint8Array</target>
        </trans-unit>
        <trans-unit id="80d3d1902630c787d741b39af0ddaba8dab6c5b7" translate="yes" xml:space="preserve">
          <source>Uint8ClampedArray</source>
          <target state="translated">Uint8ClampedArray</target>
        </trans-unit>
        <trans-unit id="dbab18f3ded2bfe1f1beae0998ec97e669719cb0" translate="yes" xml:space="preserve">
          <source>Unary operations</source>
          <target state="translated">단항 연산</target>
        </trans-unit>
        <trans-unit id="700a41ed5d6a21b389d3a06a552007f7d4970e83" translate="yes" xml:space="preserve">
          <source>Unary operators &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, and a function &lt;code&gt;inv&lt;/code&gt;.</source>
          <target state="translated">단항 연산자 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;--&lt;/code&gt; 및 함수 &lt;code&gt;inv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7af4b44086924bef8511e74a06dc5652e98b37f" translate="yes" xml:space="preserve">
          <source>Unary prefix operators</source>
          <target state="translated">단항 접두사 연산자</target>
        </trans-unit>
        <trans-unit id="71f09f8fe1dde2289c868a03cb103ae030625690" translate="yes" xml:space="preserve">
          <source>Unchecked casts</source>
          <target state="translated">확인되지 않은 캐스트</target>
        </trans-unit>
        <trans-unit id="b8d5b81db1752990f9a00626b0f1fe949182953e" translate="yes" xml:space="preserve">
          <source>Unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. Unconfined dispatcher should not be used in general code.</source>
          <target state="translated">제한되지 않은 디스패처는 나중에 실행하기 위해 코 루틴을 디스패치 할 필요가 없거나 바람직하지 않은 부작용을 일으키는 특정 경우에 도움이 될 수있는 고급 메커니즘입니다. 코 루틴의 일부 작업은 즉시 수행해야하기 때문입니다. 제한되지 않은 디스패처는 일반 코드에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad54c8520658fa2b0366caffc5901ab7a388736" translate="yes" xml:space="preserve">
          <source>Unconfined vs confined dispatcher</source>
          <target state="translated">제한되지 않은 발송자 및 한정된 발송자</target>
        </trans-unit>
        <trans-unit id="a2570f4d995169cd25ade0e53aebb8dd50e4a603" translate="yes" xml:space="preserve">
          <source>Undefined bidirectional character type. Undefined &lt;code&gt;char&lt;/code&gt; values have undefined directionality in the Unicode specification.</source>
          <target state="translated">정의되지 않은 양방향 문자 유형. 정의되지 않은 &lt;code&gt;char&lt;/code&gt; 값은 유니 코드 사양에서 정의되지 않은 방향성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="36bdd28a04792d2d0be5dfb8e33b3534b2fbd55b" translate="yes" xml:space="preserve">
          <source>Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">모든 위임 된 속성에 대해 Kotlin 컴파일러는 보조 속성을 생성하고 위임합니다. 예를 들어 속성 &lt;code&gt;prop&lt;/code&gt; 의 경우 숨겨진 속성 &lt;code&gt;prop$delegate&lt;/code&gt; 가 생성되며 접근 자의 코드는 단순히이 추가 속성에 위임합니다.</target>
        </trans-unit>
        <trans-unit id="dd8b30eeb866c4439bd48cb8b3176d8c5f111d35" translate="yes" xml:space="preserve">
          <source>Under the hood, for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">Under the hood, for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</target>
        </trans-unit>
        <trans-unit id="3488dca90e45f8e2402977d7d251d68f390541e0" translate="yes" xml:space="preserve">
          <source>Underscore for unused variables (since 1.1)</source>
          <target state="translated">사용되지 않은 변수의 밑줄 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="fb79a41a5516422da2e439b9cf71e40fb6fb14d4" translate="yes" xml:space="preserve">
          <source>Underscores for unused parameters</source>
          <target state="translated">사용하지 않는 매개 변수의 밑줄</target>
        </trans-unit>
        <trans-unit id="c1313f733bf8697e7ec5cdf78f97cfd84d52c63d" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals</source>
          <target state="translated">숫자 리터럴의 밑줄</target>
        </trans-unit>
        <trans-unit id="a32a8ccb60d72fd24a8aa497590c0bf8ba9cd8dc" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals (since 1.1)</source>
          <target state="translated">숫자 리터럴의 밑줄 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="796b398098842ca0559820831bbb74bc385b8a80" translate="yes" xml:space="preserve">
          <source>Unexpected behavior with &lt;code&gt;in&lt;/code&gt; infix operator and &lt;code&gt;ConcurrentHashMap&lt;/code&gt;</source>
          <target state="translated">예기치 않은 행동 &lt;code&gt;in&lt;/code&gt; 중위 연산자와 &lt;code&gt;ConcurrentHashMap&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="1d199ddedf7802afc54d34deabe810e8a6bf5c4f" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you want an empty collection, you need to either declare the resulting collection type explicitly, or supply the element type(s) to the function that constructs the collection:</source>
          <target state="translated">불행히도 빈 컬렉션을 원하면 결과 컬렉션 유형을 명시 적으로 선언하거나 컬렉션을 구성하는 함수에 요소 유형을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e40bf9bbf42c1f6fc0258d8c13f458aad30b49f2" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code formatter built into IntelliJ IDEA had to work long before this document was released and now has a default setup that produces different formatting from what is now recommended.</source>
          <target state="translated">불행히도 IntelliJ IDEA에 내장 된 코드 포맷터는이 문서가 릴리스되기 오래 전에 작동해야했으며 이제는 현재 권장되는 것과 다른 형식을 생성하는 기본 설정을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="12945de7af176c634a0d8ce8b70c82d42353176c" translate="yes" xml:space="preserve">
          <source>Unfortunately, using this would require us to type &lt;code&gt;p.name.value&lt;/code&gt; every time we wanted to use the property. We could do the following, but that's also not great since it introduces an extra property:</source>
          <target state="translated">불행히도 이것을 사용하려면 속성을 사용하려고 할 때마다 &lt;code&gt;p.name.value&lt;/code&gt; 를 입력해야 합니다. 우리는 다음을 수행 할 수 있지만 추가 속성을 도입하기 때문에 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8837f610cd63014d412facb51aa6f98460391f9a" translate="yes" xml:space="preserve">
          <source>Unicode correctness can be onerous in Python 2, since the &quot;default&quot; string type &lt;code&gt;str&lt;/code&gt; is really just a byte array, while &lt;code&gt;unicode&lt;/code&gt; is actually a sequence of &lt;em&gt;code units&lt;/em&gt; (see below) - and whether the code units are 16 or 32 bits wide depends on how your Python distribution was built. In Kotlin, there's no such confusion: &lt;code&gt;String&lt;/code&gt;, which is what you get when you make a string literal (which you can only do with double quotes), is an immutable sequence of UTF-16 code units. &lt;code&gt;ByteArray&lt;/code&gt; is a fixed-size (but otherwise mutable) byte array (and &lt;code&gt;String&lt;/code&gt; can specifically &lt;em&gt;not&lt;/em&gt; be used as a byte array).</source>
          <target state="translated">&quot;default&quot;문자열 타입 &lt;code&gt;str&lt;/code&gt; 은 실제로는 바이트 배열이고, &lt;code&gt;unicode&lt;/code&gt; 는 실제로 &lt;em&gt;코드 단위&lt;/em&gt; 의 시퀀스이므로 (아래 참조) 유니 코드의 정확성은 번거로울 수 있습니다. 파이썬 배포판이 어떻게 만들어 졌는지에 대해 Kotlin에는 혼동이 없습니다. &lt;code&gt;String&lt;/code&gt; 은 문자열 리터럴 (큰 따옴표로만 할 수 있음)을 만들 때 얻을 수있는 UTF-16 코드 단위의 불변 시퀀스입니다. &lt;code&gt;ByteArray&lt;/code&gt; 는 고정 크기 (그렇지만 변경 가능) 바이트 배열입니다 (그리고 &lt;code&gt;String&lt;/code&gt; 은 바이트 배열로 구체적 으로 사용할 수 &lt;em&gt;없습니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="505d5c38054a74d4b2175415322819ae4849fcad" translate="yes" xml:space="preserve">
          <source>Unified Module Definitions (UMD), which is compatible with both &lt;em&gt;AMD&lt;/em&gt; and &lt;em&gt;CommonJS&lt;/em&gt;, and works as &quot;plain&quot; when neither &lt;em&gt;AMD&lt;/em&gt; nor &lt;em&gt;CommonJS&lt;/em&gt; is available at runtime.</source>
          <target state="translated">&lt;em&gt;AMD&lt;/em&gt; 및 &lt;em&gt;CommonJS&lt;/em&gt; 와 호환 되며 런타임에 &lt;em&gt;AMD&lt;/em&gt; 또는 &lt;em&gt;CommonJS&lt;/em&gt; 를 사용할 수 없는 경우 &quot;일반&quot;으로 작동 하는 UMD (Unified Module Definitions) .</target>
        </trans-unit>
        <trans-unit id="de5d8b50b3695e8d25f732afc1acabb23472bc08" translate="yes" xml:space="preserve">
          <source>Unified backends and extensibility</source>
          <target state="translated">통합 백엔드 및 확장 성</target>
        </trans-unit>
        <trans-unit id="cb8c9c639d9b52130075c5077a53018a3b076842" translate="yes" xml:space="preserve">
          <source>Unified exception type for null checks</source>
          <target state="translated">널 검사를위한 통합 예외 유형</target>
        </trans-unit>
        <trans-unit id="4b0e76a89bd66d41a17ed421fa008af6ae14f66f" translate="yes" xml:space="preserve">
          <source>Unified standard library</source>
          <target state="translated">통합 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="c4aff5fbbb595afd545658cb39aa6df5dcca07e6" translate="yes" xml:space="preserve">
          <source>Unify exceptions from null checks</source>
          <target state="translated">null 검사의 예외 통합</target>
        </trans-unit>
        <trans-unit id="c4f58ff59e65d2d98ffef40514cadc0e589f2165" translate="yes" xml:space="preserve">
          <source>Unify split by an empty match regex result across the platforms</source>
          <target state="translated">플랫폼에서 빈 일치 정규식 결과로 분할을 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="370ce5f1a9eb1b7143f06590af17c7841cb70b8d" translate="yes" xml:space="preserve">
          <source>UninitializedPropertyAccessException</source>
          <target state="translated">UninitializedPropertyAccessException</target>
        </trans-unit>
        <trans-unit id="a91e29c6a18b3d46ad21babc72fbe12a2806e9d6" translate="yes" xml:space="preserve">
          <source>UnionAudioTrackOrTextTrackOrVideoTrack</source>
          <target state="translated">UnionAudioTrackOrTextTrackOrVideoTrack</target>
        </trans-unit>
        <trans-unit id="b427069e00bef5cd6617471fa2f1c76d7e94c1b0" translate="yes" xml:space="preserve">
          <source>UnionClientOrMessagePortOrServiceWorker</source>
          <target state="translated">UnionClientOrMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="10052a20073fd80351eaa98a0618cc05908c3fe2" translate="yes" xml:space="preserve">
          <source>UnionElementOrHTMLCollection</source>
          <target state="translated">UnionElementOrHTMLCollection</target>
        </trans-unit>
        <trans-unit id="64df693fc6248e2d4b802ced57f664db2486df1a" translate="yes" xml:space="preserve">
          <source>UnionElementOrMouseEvent</source>
          <target state="translated">UnionElementOrMouseEvent</target>
        </trans-unit>
        <trans-unit id="5d95156c593ab4f5a1d6aa9b7adaaae5b5072eee" translate="yes" xml:space="preserve">
          <source>UnionElementOrProcessingInstruction</source>
          <target state="translated">UnionElementOrProcessingInstruction</target>
        </trans-unit>
        <trans-unit id="cb794bdbfe712bfdef6a341eb0ffeda3e61df94b" translate="yes" xml:space="preserve">
          <source>UnionElementOrRadioNodeList</source>
          <target state="translated">UnionElementOrRadioNodeList</target>
        </trans-unit>
        <trans-unit id="55e9b0c8b2893c068d7bad4f687cd74e04c97fae" translate="yes" xml:space="preserve">
          <source>UnionHTMLOptGroupElementOrHTMLOptionElement</source>
          <target state="translated">UnionHTMLOptGroupElementOrHTMLOptionElement</target>
        </trans-unit>
        <trans-unit id="9914d6bd1e51362b2ae64dd4e4f0c81df753f3a5" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrServiceWorker</source>
          <target state="translated">UnionMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="9f29b0aeda2c26ba869f1da1baf112b08de48285" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindow</source>
          <target state="translated">UnionMessagePortOrWindow</target>
        </trans-unit>
        <trans-unit id="0bdbd6bc95c6e23b6042a486f6d277c7a15fc86a" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindowProxy</source>
          <target state="translated">UnionMessagePortOrWindowProxy</target>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="6e47e918985f3919c21cc4a5d827ef9eada3d607" translate="yes" xml:space="preserve">
          <source>Unit return type. Must not be nullable</source>
          <target state="translated">단위 반환 유형. nullable이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc244abccf5ca3308a1494c12878b0d0e26feea" translate="yes" xml:space="preserve">
          <source>Unit-returning functions</source>
          <target state="translated">단위 반환 기능</target>
        </trans-unit>
        <trans-unit id="4e0950ee26dcc7da4ca806b4b340177a815e5066" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, the names of functions and modules can be &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;mangled&lt;/a&gt; in the generated JavaScript code. To keep such functions from elimination, use the mangled names in the &lt;code&gt;keep&lt;/code&gt; arguments as they appear in the generated JavaScript code.</source>
          <target state="translated">Unless specified otherwise, the names of functions and modules can be &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;mangled&lt;/a&gt; in the generated JavaScript code. To keep such functions from elimination, use the mangled names in the &lt;code&gt;keep&lt;/code&gt; arguments as they appear in the generated JavaScript code.</target>
        </trans-unit>
        <trans-unit id="e885d6886100fb26b71f7747ee932dbb05e71ce7" translate="yes" xml:space="preserve">
          <source>Unless you're working on a library, omit redundant modifiers (e.g. &lt;code&gt;public&lt;/code&gt;).</source>
          <target state="translated">라이브러리에서 작업하지 않는 한 중복 수정자를 생략하십시오 (예 : &lt;code&gt;public&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8feafcdb2005e6ef556074da45e878f1b7bc1d3a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; it does not intercept continuation.</source>
          <target state="translated">&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; 과 달리 연속을 가로 채지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5baaedd3e64f7be16b02c01618d1a48a2f53082" translate="yes" xml:space="preserve">
          <source>Unlike Java, Kotlin does not have a separate &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&quot;import static&quot;&lt;/a&gt; syntax; all of these declarations are imported using the regular &lt;code&gt;import&lt;/code&gt; keyword.</source>
          <target state="translated">Java와 달리 Kotlin에는 별도의 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&quot;import static&quot;&lt;/a&gt; 구문이 없습니다. 이러한 모든 선언은 일반 &lt;code&gt;import&lt;/code&gt; 키워드를 사용하여 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7e26e1701ff3fbdbd8ab214ddee2ab24ae9fb3e0" translate="yes" xml:space="preserve">
          <source>Unlike Java, block comments in Kotlin can be nested.</source>
          <target state="translated">Java와 달리 Kotlin의 블록 주석은 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71d4e303da5f24db04f06a7b993b10b6d2cf202" translate="yes" xml:space="preserve">
          <source>Unlike Python, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; is an expression: the last expression of the &lt;code&gt;try&lt;/code&gt; block (if it succeeds) or the chosen &lt;code&gt;catch&lt;/code&gt; block becomes the result value (&lt;code&gt;finally&lt;/code&gt; doesn't affect the result), so we can refactor the function body above to:</source>
          <target state="translated">파이썬과는 달리, &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 의 마지막 표현 : 표현이다 &lt;code&gt;try&lt;/code&gt; 블록 (성공할 경우) 또는 선택한 &lt;code&gt;catch&lt;/code&gt; 블록은 결과 값은 (된다 &lt;code&gt;finally&lt;/code&gt; 우리는 위의 함수 본문을 리팩토링 할 수 있도록 결과에 영향을주지 않습니다) :</target>
        </trans-unit>
        <trans-unit id="9ffcb8e6d8c0e1886c9139362bf8a80448f390b9" translate="yes" xml:space="preserve">
          <source>Unlike a queue, a channel can be closed to indicate that no more elements are coming. On the receiver side it is convenient to use a regular &lt;code&gt;for&lt;/code&gt; loop to receive elements from the channel.</source>
          <target state="translated">대기열과 달리 채널을 닫아 더 이상 요소가 없음을 나타냅니다. 수신기 측에서는 정기적 인 &lt;code&gt;for&lt;/code&gt; 루프를 사용 하여 채널에서 요소를 수신 하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="79736268c87ef812b5a0caf77be57b249d138010" translate="yes" xml:space="preserve">
          <source>Unlike docstrings, KDoc blocks are not available to the program at runtime.</source>
          <target state="translated">docstring과 달리 KDoc 블록은 런타임에 프로그램에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e77ba9444bad622fec50b4242ad0088f476d99f" translate="yes" xml:space="preserve">
          <source>Unlike other pointers, the parameters of type &lt;code&gt;const char*&lt;/code&gt; are represented as a Kotlin &lt;code&gt;String&lt;/code&gt;. So it is possible to pass any Kotlin string to a binding expecting a C string.</source>
          <target state="translated">다른 포인터와 달리 &lt;code&gt;const char*&lt;/code&gt; 유형의 매개 변수 는 Kotlin &lt;code&gt;String&lt;/code&gt; 으로 표시됩니다 . 따라서 모든 Kotlin 문자열을 C 문자열을 기대하는 바인딩에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3405f910e07d811413c0ab883fbacf2fe2d5fb" translate="yes" xml:space="preserve">
          <source>Unlike sources that can be fixed by hand in the worst case, binaries are a lot harder to migrate, and this makes backwards compatibility very important in the case of binaries. Incompatible changes to binaries can make updates very uncomfortable and thus should be introduced with even more care than those in the source language syntax.</source>
          <target state="translated">최악의 경우 손으로 수정할 수있는 소스와 달리 이진은 마이그레이션하기가 훨씬 어렵 기 때문에 이진의 경우 하위 호환성이 매우 중요합니다. 바이너리에 대한 호환되지 않는 변경은 업데이트를 매우 불편하게 만들 수 있으므로 소스 언어 구문의 것보다 더 조심스럽게 도입해야합니다.</target>
        </trans-unit>
        <trans-unit id="71ea4413722e85a3b020d9ed01e939aac7d2c7c0" translate="yes" xml:space="preserve">
          <source>Unlike the overload that accepts an argument of type &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, this function does not compare this string and the specified &lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt; in a synchronized block.</source>
          <target state="translated">Unlike the overload that accepts an argument of type &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, this function does not compare this string and the specified &lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt; in a synchronized block.</target>
        </trans-unit>
        <trans-unit id="418fd8181d764c26cb6aebed80be5ec76fed83e8" translate="yes" xml:space="preserve">
          <source>Unsafe mode is intended for most performance critical operations, where object graph ownership is expected to be correct (such as application debugged earlier in &lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt; mode), just transfers ownership without further checks.</source>
          <target state="translated">안전하지 않은 모드는 객체 그래프 소유권이 정확할 것으로 예상되는 (예 : &lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt; 모드 에서 이전에 디버깅 된 응용 프로그램) 대부분의 성능이 중요한 작업을 위해 고안되었으며 추가 검사없이 소유권을 이전합니다.</target>
        </trans-unit>
        <trans-unit id="eb25c274c554703f1d6ac7eff8cabedc73b12953" translate="yes" xml:space="preserve">
          <source>UnsafeVariance</source>
          <target state="translated">UnsafeVariance</target>
        </trans-unit>
        <trans-unit id="cfba46d6859cfbbcea2df0d333b94927ce585d13" translate="yes" xml:space="preserve">
          <source>Unsigned arithmetics</source>
          <target state="translated">부호없는 산술</target>
        </trans-unit>
        <trans-unit id="5c5289ec1ae0731b7a3321d477acd024a60473b2" translate="yes" xml:space="preserve">
          <source>Unsigned integers</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="5b676d18e8ccf61f5e227df4adab6b4ac25f32fd" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">부호없는 정수는 Kotlin 1.3부터 ​​사용 가능하며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 에서 자세한 내용을 참조하십시오 &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f300d5a964ee1dfe6f01eeb8815de2c1adedd0" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details in the &lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">Unsigned integers are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details in the &lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b747e738f03e7ea5b53d3e97fc3d06bb2fdd5460" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">부호없는 유형은 Kotlin 1.3 이후에만 사용할 수 있으며 현재 &lt;em&gt;실험적&lt;/em&gt; 입니다. 세부 사항을 참조하십시오 &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;아래를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d65bd8aeb4b2e88a04a2f25ed0b812fa94ab0cb" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details &lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">Unsigned types are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details &lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c69f19b70030748472412cf013c7f8262fa5cc73" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another experimental feature, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">부호없는 유형은 다른 실험 기능, 즉 &lt;a href=&quot;inline-classes&quot;&gt;인라인 클래스를&lt;/a&gt; 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="963c1b3d4bd7cb3c897cb1ca5167eb9af57242de" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another feature that's not yet stable, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">Unsigned types are implemented using another feature that's not yet stable, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="22647f2117d5ec2026da9b7edc1161d8603f0593" translate="yes" xml:space="preserve">
          <source>Unsigned types support most of the operations of their signed counterparts.</source>
          <target state="translated">서명되지 않은 유형은 서명 된 상대방의 대부분의 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a84f8397c523a0f7323640840daf25c5d28f242d" translate="yes" xml:space="preserve">
          <source>Unsound smartcasts on enum members</source>
          <target state="translated">열거 형 멤버의 들리지 않는 스마트 캐스트</target>
        </trans-unit>
        <trans-unit id="fb52c13a5d3c511932c9721a05a0f30bebc8f773" translate="yes" xml:space="preserve">
          <source>Unsupported</source>
          <target state="translated">Unsupported</target>
        </trans-unit>
        <trans-unit id="d6b9cc70af4626956ac004db8653f110603b7231" translate="yes" xml:space="preserve">
          <source>UnsupportedOperationException</source>
          <target state="translated">UnsupportedOperationException</target>
        </trans-unit>
        <trans-unit id="2ce01f081a0318f94ee11d34764838aaa22a8009" translate="yes" xml:space="preserve">
          <source>Unused declarations can appear in cases like:</source>
          <target state="translated">Unused declarations can appear in cases like:</target>
        </trans-unit>
        <trans-unit id="7d866719de20162a43b046be2b1dd937f0e0c8b0" translate="yes" xml:space="preserve">
          <source>Unzip the standalone compiler into a directory and optionally add the &lt;code&gt;bin&lt;/code&gt; directory to the system path. The &lt;code&gt;bin&lt;/code&gt; directory contains the scripts needed to compile and run Kotlin on Windows, OS X and Linux.</source>
          <target state="translated">독립형 컴파일러를 디렉토리에 압축 해제하고 선택적으로 &lt;code&gt;bin&lt;/code&gt; 디렉토리를 시스템 경로에 추가하십시오 . &lt;code&gt;bin&lt;/code&gt; 디렉토리는 컴파일 및 Windows, OS X 및 Linux에서 코 틀린를 실행하는 데 필요한 스크립트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7b8830d7d19c631f4db7f0e7cccdc5fc99c4ae" translate="yes" xml:space="preserve">
          <source>Update Gradle</source>
          <target state="translated">Gradle 업데이트</target>
        </trans-unit>
        <trans-unit id="bd35499f667636f0205aff356fc79aa271c4a159" translate="yes" xml:space="preserve">
          <source>Update the application</source>
          <target state="translated">응용 프로그램 업데이트</target>
        </trans-unit>
        <trans-unit id="756c6de970516b187b891362c635541de1071978" translate="yes" xml:space="preserve">
          <source>Update to version A (where the change is announced)</source>
          <target state="translated">버전 A로 업데이트 (변경 사항이 발표 된 곳)</target>
        </trans-unit>
        <trans-unit id="a8909313fb96928caf2b3605836e51265cd9382c" translate="yes" xml:space="preserve">
          <source>Update to version B (where the change happens)</source>
          <target state="translated">버전 B로 업데이트 (변경이 발생한 위치)</target>
        </trans-unit>
        <trans-unit id="bc69b0f01bd4bf2a5762f9802698425322ca8ecc" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">의 지정된지도 &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;에서&lt;/a&gt; 키 / 값 쌍으로이지도를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="bb9919809e0edbf2ce222896374072b2a1f62288" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9592e59ae4a1ea78ffeef819217ff2d297efc8bf" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">의 지정된지도 &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;에서&lt;/a&gt; 키 / 값 쌍으로이지도를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="2ea39222df240b93c342df8ff54a9cb5e6582800" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="d63c48198d515b24d1b1b235598c3c48c2a4be5a" translate="yes" xml:space="preserve">
          <source>Updating Gradle Scripts</source>
          <target state="translated">Gradle 스크립트 업데이트</target>
        </trans-unit>
        <trans-unit id="408c0db23a4308cddf6a6e9ce2a0a6679db93544" translate="yes" xml:space="preserve">
          <source>Updating elements</source>
          <target state="translated">요소 업데이트</target>
        </trans-unit>
        <trans-unit id="5db2b695ba29ebd7f0ca8dec803b6b54c73ec2a6" translate="yes" xml:space="preserve">
          <source>Upper bounds</source>
          <target state="translated">상한</target>
        </trans-unit>
        <trans-unit id="6fe7e1ccf58a63e3bc126e60c26bcc1a9fac8e17" translate="yes" xml:space="preserve">
          <source>Upper bounds, or generic constraints imposed on this type parameter. See the &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">이 유형 매개 변수에 부과 된 상한 또는 일반 제한 조건. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="034e0e826c171bc69a42734bf5f512ba3665a32d" translate="yes" xml:space="preserve">
          <source>Usage of the &lt;code&gt;!!&lt;/code&gt; operator that is described below;</source>
          <target state="translated">의 사용법 &lt;code&gt;!!&lt;/code&gt; 아래에 설명 된 연산자;</target>
        </trans-unit>
        <trans-unit id="e1820bd9f032e11eff310c40682c9835a9eb3203" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as a warning.</source>
          <target state="translated">더 이상 사용되지 않는 요소의 사용은 경고로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6da2a0224bff4d0cdbf931eb3f79ea3c663d17" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as an error.</source>
          <target state="translated">더 이상 사용되지 않는 요소의 사용은 오류로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2278b9118c021e0836f33b45c4b344bc07faf3" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; , or with the &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</target>
        </trans-unit>
        <trans-unit id="5b2bd12dd174680813870a73e531a53b2704ad9f" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; annotation, e.g. &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">&lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; 어노테이션 (예 : &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt; ) 또는 &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; 컴파일러 옵션이 명시 적으로 옵트 인되지 않는 한 이러한 API의 사용법은 경고로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="17a2b4afa5d97d07993ae00f2065c3a2c91e4e36" translate="yes" xml:space="preserve">
          <source>Usages of such annotations will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../../kotlin/-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalJsExport::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.js.ExperimentalJsExport&lt;/code&gt; compiler option is given.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin/-opt-in/index&quot;&gt;OptIn&lt;/a&gt; 주석 을 사용한 명시 적 옵트 인 &lt;code&gt;@OptIn(ExperimentalJsExport::class)&lt;/code&gt; 예 : @OptIn (ExperimentalJsExport :: class) ) 또는 &lt;code&gt;-Xopt-in=kotlin.js.ExperimentalJsExport&lt;/code&gt; 컴파일러 옵션이 제공 되지 않는 한 이러한 주석의 사용은 경고로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="5461bf95a53302a7c5df48274f6a4f3517903597" translate="yes" xml:space="preserve">
          <source>Usages of this annotation require an explicit compilation argument to be specified: either &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; or &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt;.</source>
          <target state="translated">이 어노테이션을 사용하려면 명시적인 컴파일 인수를 지정해야합니다 ( &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; 또는 &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="070afea0c959ac4ab2122b78be879a1236b7d5f2" translate="yes" xml:space="preserve">
          <source>Use 4 spaces for indentation. Do not use tabs.</source>
          <target state="translated">들여 쓰기를 위해 4 개의 공백을 사용하십시오. 탭을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="505b02e2c68810a100167ed2394b7b09d07536b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Kotlin from Swift&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Swift에서 Kotlin&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="259f61d0fe4d9980f69dcb9a143f67a783be3566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; function to describe a conditional effect that happens in such case.</source>
          <target state="translated">이러한 경우에 발생하는 조건부 효과를 설명 하려면 &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b3d7f2e06019f3ce17f9b7609b4e12a0a852225" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt;, &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; or &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt; extension functions to instantiate a &lt;code&gt;FileTreeWalk&lt;/code&gt; instance.</source>
          <target state="translated">사용 &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt; , &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; 또는 &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp의&lt;/a&gt; 확장 기능은 인스턴스화하는 &lt;code&gt;FileTreeWalk&lt;/code&gt; 의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="24479d1c98fbbe2aeb0187678fa3eb554ac97484" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891&quot;&gt;a workaround for the Bintray plugin&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/bintray/gradle-bintray-plugin/issues/229#issuecomment-473123891&quot;&gt;Bintray 플러그인에 대한 해결 방법&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="855c22b8caa56aad8a88d87618784ee61265712d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;apply&lt;/code&gt; for code blocks that don't return a value and mainly operate on the members of the receiver object. The common case for &lt;code&gt;apply&lt;/code&gt; is the object configuration. Such calls can be read as &amp;ldquo;&lt;em&gt;apply the following assignments to the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">값을 반환하지 않고 주로 수신자 객체의 멤버에서 작동하는 코드 블록에 &lt;code&gt;apply&lt;/code&gt; 을 사용하십시오 . 일반적인 &lt;code&gt;apply&lt;/code&gt; 사례 는 객체 구성입니다. 이러한 호출은 &quot; &lt;em&gt;다음 과제를 객체에 적용&lt;/em&gt; &quot;으로 읽을 수 있습니다 &lt;em&gt;. &lt;/em&gt;&quot;</target>
        </trans-unit>
        <trans-unit id="6ba975b0b8793e55988fa1e5cd1c3f8baae89326" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;arguments {}&lt;/code&gt; block to pass arguments to annotation processors:</source>
          <target state="translated">&lt;code&gt;arguments {}&lt;/code&gt; 블록을 사용 하여 인수를 주석 프로세서에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="9068946a50ad967859350bf76f77d127a3ad6ba3" translate="yes" xml:space="preserve">
          <source>Use C function pointer from Kotlin</source>
          <target state="translated">Kotlin의 C 함수 포인터 사용</target>
        </trans-unit>
        <trans-unit id="8d59d0d06987ce05b43d207e59345cd58bf6234b" translate="yes" xml:space="preserve">
          <source>Use Gradle 6.0 and above to generate wrapper (&lt;code&gt;gradle wrapper&lt;/code&gt;) in the project root directory to generate &lt;code&gt;gradlew&lt;/code&gt;, &lt;code&gt;gradlew.bat&lt;/code&gt;, and &lt;code&gt;gradle/wrapper/gradle-wrapper.jar&lt;/code&gt;.</source>
          <target state="translated">Gradle 6.0 이상을 사용 하여 프로젝트 루트 디렉토리에 래퍼 ( &lt;code&gt;gradle wrapper&lt;/code&gt; )를 생성하여 &lt;code&gt;gradlew&lt;/code&gt; , &lt;code&gt;gradlew.bat&lt;/code&gt; 및 &lt;code&gt;gradle/wrapper/gradle-wrapper.jar&lt;/code&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="7f14c4d527695edd872c7fe2172a6db2f31e9728" translate="yes" xml:space="preserve">
          <source>Use Kotlin from node.js with CommonJS</source>
          <target state="translated">CommonJS와 함께 node.js의 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="7955d34ca487ac99a425deedc1ddb62d16416242" translate="yes" xml:space="preserve">
          <source>Use Kotlin in the browser with AMD</source>
          <target state="translated">AMD 브라우저에서 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="80ebd15dbf9fc53c163f2e8494fee09225815763" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; for your reversed name by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${state.name.reversed()}&lt;/code&gt;.</source>
          <target state="translated">달러 기호 &lt;code&gt;$&lt;/code&gt; 를 추가하고 중괄호 &lt;code&gt;${state.name.reversed()}&lt;/code&gt; 반전 된 이름에 &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;문자열 템플릿&lt;/a&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="2449126f023eebada4dc8166f2d086abc1f70c85" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;string template&lt;/a&gt; to insert your name length into the string by adding a dollar sign &lt;code&gt;$&lt;/code&gt; and enclosing it in curly braces &amp;ndash; &lt;code&gt;${it.length}&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is the default name of a &lt;a href=&quot;../../reference/coding-conventions#lambda-parameters&quot;&gt;lambda parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../reference/basic-types#string-templates&quot;&gt;문자열 템플릿&lt;/a&gt; 을 사용하여 달러 기호 &lt;code&gt;$&lt;/code&gt; 를 추가하고 중괄호 ( &lt;code&gt;${it.length}&lt;/code&gt; 문자열에 이름 길이를 삽입합니다 . &lt;code&gt;it&lt;/code&gt; a의 기본 이름입니다 &lt;a href=&quot;../../reference/coding-conventions#lambda-parameters&quot;&gt;람다 매개 변수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="567ed77b3fedba236234b46ed9dd13b2639d5a1d" translate="yes" xml:space="preserve">
          <source>Use a Kotlin Gradle project as a CocoaPods dependency</source>
          <target state="translated">Use a Kotlin Gradle project as a CocoaPods dependency</target>
        </trans-unit>
        <trans-unit id="dad9d5856fb71823437fdf612d7806d4ef4bcde8" translate="yes" xml:space="preserve">
          <source>Use a custom JDK home directory to include into the classpath if it differs from the default &lt;code&gt;JAVA_HOME&lt;/code&gt;.</source>
          <target state="translated">기본 &lt;code&gt;JAVA_HOME&lt;/code&gt; 과 다른 경우 사용자 정의 JDK 홈 디렉토리를 사용하여 클래스 경로에 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="5dafba398135044480a3e13e8cf827e6d5239bcb" translate="yes" xml:space="preserve">
          <source>Use a function returning nullable value:</source>
          <target state="translated">널 입력 가능 값을 리턴하는 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="09ab22034a8c650e65b27de7b44cb4d61caf9b2b" translate="yes" xml:space="preserve">
          <source>Use a string template by adding a dollar sign &lt;code&gt;$&lt;/code&gt; before this variable name directly in the text output like this &amp;ndash; &lt;code&gt;$name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$name&lt;/code&gt; 과 같은 텍스트 출력에서이 변수 이름 앞에 달러 기호 &lt;code&gt;$&lt;/code&gt; 를 직접 추가하여 문자열 템플릿을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6761a777f295b6258dc7a19c0a25a2a4cc06a051" translate="yes" xml:space="preserve">
          <source>Use any members that don't mention the star-projected type parameter(s) at all</source>
          <target state="translated">별 투영 된 유형 매개 변수를 전혀 언급하지 않은 멤버를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="02c711d6a5cfe540ce71589b8b208d49d3883457" translate="yes" xml:space="preserve">
          <source>Use any members that return the star-projected type parameter(s), but the return type will appear to be &lt;code&gt;Any?&lt;/code&gt; (unless the type parameter is constrained, in which case you'll get the type mentioned in the constraint)</source>
          <target state="translated">별 투영 된 유형 매개 변수를 리턴하는 멤버를 사용하지만 리턴 유형은 &lt;code&gt;Any?&lt;/code&gt; (type 매개 변수가 제한되어 있지 않으면 제약 조건에 언급 된 유형이 표시됩니다)</target>
        </trans-unit>
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">사용 사례</target>
        </trans-unit>
        <trans-unit id="6914afc57d4eceefab3ce74c4e34c13830de00b1" translate="yes" xml:space="preserve">
          <source>Use dynamic to interact with libraries</source>
          <target state="translated">동적을 사용하여 라이브러리와 상호 작용</target>
        </trans-unit>
        <trans-unit id="a696c211088879b039bc564a3a89ee0e5d5cf819" translate="yes" xml:space="preserve">
          <source>Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</source>
          <target state="translated">확장 기능을 자유롭게 사용하십시오. 객체에서 주로 작동하는 함수가있을 때마다 해당 객체를 수신자로 받아들이는 확장 함수로 만드는 것이 좋습니다. API 오염을 최소화하려면 확장 기능의 가시성을 적절하게 제한하십시오. 필요에 따라 로컬 확장 기능, 멤버 확장 기능 또는 개인용 가시성이있는 최상위 확장 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d507109a798498dbaa1e633727d124b6d6bc26b0" translate="yes" xml:space="preserve">
          <source>Use for APIs which have a third-party implementation available at runtime.</source>
          <target state="translated">Use for APIs which have a third-party implementation available at runtime.</target>
        </trans-unit>
        <trans-unit id="3f1d8d5003fdff477f08dfe445e9b40450048a1d" translate="yes" xml:space="preserve">
          <source>Use for dependencies needed for the internal logic of a module.</source>
          <target state="translated">Use for dependencies needed for the internal logic of a module.</target>
        </trans-unit>
        <trans-unit id="f46a150eeba438f84a49eada07a259f489c6609a" translate="yes" xml:space="preserve">
          <source>Use four spaces for indentation. Do not use tabs.</source>
          <target state="translated">Use four spaces for indentation. Do not use tabs.</target>
        </trans-unit>
        <trans-unit id="ce69d8e8477848e488f670533689cb83c9f8c099" translate="yes" xml:space="preserve">
          <source>Use it &lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;from Android app&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;안드로이드 앱에서&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="62f9973d0d21db3635e8a7ac730a624b82c527d3" translate="yes" xml:space="preserve">
          <source>Use kotlinx.html to generate HTML</source>
          <target state="translated">kotlinx.html을 사용하여 HTML 생성</target>
        </trans-unit>
        <trans-unit id="c9f5118d1f54f80362016bfd5b442c56f51dfc9b" translate="yes" xml:space="preserve">
          <source>Use native libraries in the hierarchical structure</source>
          <target state="translated">계층 구조에서 네이티브 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="7f896877d7535f3235fee51d8eb8bb2fc4692498" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for constructor parameters.</source>
          <target state="translated">생성자 매개 변수에는 일반 들여 쓰기 (4 칸)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8e22c1db7346b432b927919ebe9e716628c63ef8" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for function parameters.</source>
          <target state="translated">함수 매개 변수에는 규칙적인 들여 쓰기 (4 칸)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b28f6c3f00f4a4b985821c624ebe6f5d2ab53f74" translate="yes" xml:space="preserve">
          <source>Use regular indent (four spaces) for constructor parameters.</source>
          <target state="translated">Use regular indent (four spaces) for constructor parameters.</target>
        </trans-unit>
        <trans-unit id="9f39c73e1f23d3754cec94f86de325d9e4b9a4f1" translate="yes" xml:space="preserve">
          <source>Use target shortcuts</source>
          <target state="translated">대상 바로 가기 사용</target>
        </trans-unit>
        <trans-unit id="6356c2b337336539cb098b460ea9fc43a2a742aa" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.text/replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt; function to remove the empty spaces in the name.</source>
          <target state="translated">이름에서 빈 공간을 제거 하려면 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.text/replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="72171ae8b75ba095394479592bf8ca1cc4cab18c" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../../../api/latest/jvm/stdlib/stdlib/kotlin.io/println&quot;&gt;&lt;code&gt;println()&lt;/code&gt;&lt;/a&gt; function to print computing status and the result of multiplication to the output.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/stdlib/kotlin.io/println&quot;&gt; &lt;code&gt;println()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 계산 상태와 곱셈 결과를 출력에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="be7280e72c76af98308a3c66e2b7e24f9cc56702" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;&lt;code&gt;await()&lt;/code&gt;&lt;/a&gt; function to await the computation result.</source>
          <target state="translated">계산 결과를 기다리 려면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt; &lt;code&gt;await()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0461db73580d6d4278fffb255e74938d931ed12e" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;&lt;code&gt;async()&lt;/code&gt;&lt;/a&gt; function to create coroutines that compute deferred values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt; &lt;code&gt;async()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 지연된 값 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 를 계산하는 코 루틴을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6065d1c978fbee3b2ff226845a77482cccebc712" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming blocking code. It suspends the coroutine for 100 ms without blocking the thread.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 CPU를 사용하는 차단 코드를 모방하십시오. 스레드를 차단하지 않고 100ms 동안 코 루틴을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b591373cb35b1a0f6e2219e8ca5964a4f1c5a083" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;&lt;code&gt;delay()&lt;/code&gt;&lt;/a&gt; function to imitate CPU-consuming code. It suspends the coroutine for 300 ms without blocking the thread.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt; &lt;code&gt;delay()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 CPU를 사용하는 코드를 모방 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 스레드를 차단하지 않고 300ms 동안 코 루틴을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="c33adc7173a74761298cf96415d2790cf72a0ec3" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;&lt;code&gt;runBlocking()&lt;/code&gt;&lt;/a&gt; block to wrap a coroutine.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt; &lt;code&gt;runBlocking()&lt;/code&gt; &lt;/a&gt; 블록을 사용하여 코 루틴을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="50099ad72d8ea21daa614b797c104f31da58f3d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;countDistinctCharacters()&lt;/code&gt; function to count the unique letters in your name.</source>
          <target state="translated">&lt;code&gt;countDistinctCharacters()&lt;/code&gt; 함수를 사용 하여 이름의 고유 한 문자를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4a252bcad831096a6694a845390d272ffaa5046b" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;plugin&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/publishing_maven.html&quot;&gt;플러그인을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2153a3c57b5ac237e2457368e65faee188870aa7" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;until&lt;/code&gt; function to loop over an open range:</source>
          <target state="translated">개방 범위를 반복 하려면 &lt;code&gt;until&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bd4c99e44de0d3ffdb3c45eb15b74d7b4c2b386" translate="yes" xml:space="preserve">
          <source>Use the IR backend</source>
          <target state="translated">Use the IR backend</target>
        </trans-unit>
        <trans-unit id="9e774b3c689a7ceab89fb14ac0440aed57436890" translate="yes" xml:space="preserve">
          <source>Use the Kotlin dynamic library from C</source>
          <target state="translated">C의 Kotlin 동적 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="44f7acf29bd5c28fb7d8d6e6f897b376b75ea2f3" translate="yes" xml:space="preserve">
          <source>Use the boxed version of an inline class in return type position for covariant and generic-specialized overrides</source>
          <target state="translated">공변 및 제네릭 특화 재정의를 위해 반환 유형 위치에서 인라인 클래스의 박스형 버전을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4f2625d939200fe0f3767b996a1eaa8c5f1f235d" translate="yes" xml:space="preserve">
          <source>Use the following factory methods to declare elements of the &lt;code&gt;binaries&lt;/code&gt; collection.</source>
          <target state="translated">다음 팩토리 메서드를 사용하여 &lt;code&gt;binaries&lt;/code&gt; 컬렉션의 요소를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="fca17390ef51588303bcc0395c954faa0b511dcd" translate="yes" xml:space="preserve">
          <source>Use the intention from the IDE to include the missing import line:</source>
          <target state="translated">누락 된 가져 오기 행을 포함 시키려면 IDE의 의도를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c9fe0e8ecff640eabedf59913fdfab4613b76bf4" translate="yes" xml:space="preserve">
          <source>Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of &lt;code&gt;Boolean&lt;/code&gt; type, unless the meaning of all parameters is absolutely clear from context.</source>
          <target state="translated">메소드가 동일한 기본 유형의 여러 매개 변수를 가져 오거나 &lt;code&gt;Boolean&lt;/code&gt; 유형의 매개 변수에 대해 컨텍스트에서 모든 매개 변수의 의미가 완전히 명확하지 않은 한 명명 된 인수 구문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="09617aa736694d6bc881574c01e808ebeb4fb7c7" translate="yes" xml:space="preserve">
          <source>Use the path to the Java runtime version 1.8 or 11 for the &lt;em&gt;Gradle JVM&lt;/em&gt; field. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt; for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">&lt;em&gt;Gradle JVM&lt;/em&gt; 필드에 Java 런타임 버전 1.8 또는 11의 경로를 사용하십시오 . 최상의 JRE, OpenJDK 또는 JDK 배포에 대해서는 &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; 또는 &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b686514332051bdffa546563fa862bdb9f30b3de" translate="yes" xml:space="preserve">
          <source>Use the scope function &lt;a href=&quot;../../reference/scope-functions#let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt; to run the function within the object context.</source>
          <target state="translated">범위 함수 &lt;a href=&quot;../../reference/scope-functions#let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 을 사용하여 개체 컨텍스트 내에서 함수를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="efe23756e108375f4f234fa62c62b1a3192f2334" translate="yes" xml:space="preserve">
          <source>Use the shared Kotlin library &lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;from iOS app&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;iOS 앱에서&lt;/a&gt; 공유 Kotlin 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="bdbe6eb3123e18a3df48280aadc1acf4ad69906d" translate="yes" xml:space="preserve">
          <source>Use the specified paths as base directories. Base directories are used for calculating relative paths in the source map.</source>
          <target state="translated">지정된 경로를 기본 디렉토리로 사용하십시오. 기본 디렉토리는 소스 맵에서 상대 경로를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e87c063aea31b41f461fabf9570d133ee5c90c0" translate="yes" xml:space="preserve">
          <source>Use the standard library function &lt;code&gt;reversed()&lt;/code&gt; to reverse your name.</source>
          <target state="translated">이름을 &lt;code&gt;reversed()&lt;/code&gt; 려면 표준 라이브러리 함수 reversed () 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9852a84398c6954bfc8ee0f3c95a700b78ffafb" translate="yes" xml:space="preserve">
          <source>Use the types &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; and &lt;code&gt;KotlinCompileCommon&lt;/code&gt; for the JS and Common targets, accordingly.</source>
          <target state="translated">JS 및 공통 대상에 &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; 및 &lt;code&gt;KotlinCompileCommon&lt;/code&gt; 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba751862add42b30b98929193759e854e81a1255" translate="yes" xml:space="preserve">
          <source>Use this function for projects that contain both Java and Kotlin source files. Note that the default source directories for Java sources don't follow the Java plugin's defaults. Instead, they are derived from the Kotlin source sets. For example, if the JVM target has the default name &lt;code&gt;jvm&lt;/code&gt;, the paths are &lt;code&gt;src/jvmMain/java&lt;/code&gt; (for production Java sources) and &lt;code&gt;src/jvmTest/java&lt;/code&gt; for test Java sources. Learn how to &lt;a href=&quot;mpp-configure-compilations#include-java-sources-in-jvm-compilations&quot;&gt;include Java sources in JVM compilations&lt;/a&gt;.</source>
          <target state="translated">자바 및 Kotlin 소스 파일이 모두 포함 된 프로젝트에이 함수를 사용하세요. Java 소스의 기본 소스 디렉토리는 Java 플러그인의 기본값을 따르지 않습니다. 대신 Kotlin 소스 세트에서 파생됩니다. 예를 들어, JVM 대상의 기본 이름이 &lt;code&gt;jvm&lt;/code&gt; 인 경우 경로는 &lt;code&gt;src/jvmMain/java&lt;/code&gt; (프로덕션 Java 소스의 경우) 및 테스트 Java 소스의 경우 &lt;code&gt;src/jvmTest/java&lt;/code&gt; 입니다. &lt;a href=&quot;mpp-configure-compilations#include-java-sources-in-jvm-compilations&quot;&gt;JVM 컴파일에 Java 소스&lt;/a&gt; 를 포함 하는 방법을 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="4e03be997274e2b63af86d76fc7bf98a2088dbc4" translate="yes" xml:space="preserve">
          <source>Use ts2kt to interact with libraries</source>
          <target state="translated">ts2kt를 사용하여 라이브러리와 상호 작용</target>
        </trans-unit>
        <trans-unit id="106c8f3de5148d18865fbc697fa5d5cdeecc28c4" translate="yes" xml:space="preserve">
          <source>Use-site variance: Type projections</source>
          <target state="translated">사용 사이트 차이 : 유형 투영</target>
        </trans-unit>
        <trans-unit id="e2476b5675d923b0014d65b682cc8d7c7848dd3a" translate="yes" xml:space="preserve">
          <source>UseExperimental</source>
          <target state="translated">UseExperimental</target>
        </trans-unit>
        <trans-unit id="5948d8b97ec29bff3672a84e9d432b919624dc55" translate="yes" xml:space="preserve">
          <source>Used both during compilation and at runtime and is exported to library consumers.</source>
          <target state="translated">Used both during compilation and at runtime and is exported to library consumers.</target>
        </trans-unit>
        <trans-unit id="8ac3c810c772a41c5e178656755fecd6523a14fa" translate="yes" xml:space="preserve">
          <source>Used during compilation and at runtime for the current module, but is not exposed for compilation of other modules depending on the one with the `implementation` dependency.</source>
          <target state="translated">Used during compilation and at runtime for the current module, but is not exposed for compilation of other modules depending on the one with the `implementation` dependency.</target>
        </trans-unit>
        <trans-unit id="73310b7839f171659371cc3680a3ce118bf8dc6d" translate="yes" xml:space="preserve">
          <source>Used for compilation of the current module and is not available at runtime nor during compilation of other modules.</source>
          <target state="translated">Used for compilation of the current module and is not available at runtime nor during compilation of other modules.</target>
        </trans-unit>
        <trans-unit id="06c609f5a60b09cc00048be8eb23732ff873a513" translate="yes" xml:space="preserve">
          <source>Used only with &lt;code&gt;-Xjvm-default=compatibility|all-compatibility&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-Xjvm-default=compatibility|all-compatibility&lt;/code&gt; 와 함께 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f27716b3301b8979f846685e09578fc4d968ef31" translate="yes" xml:space="preserve">
          <source>User-defined contracts</source>
          <target state="translated">User-defined contracts</target>
        </trans-unit>
        <trans-unit id="2546ff21c7035e67f381dd0185abecc195a459e2" translate="yes" xml:space="preserve">
          <source>Users of Kotlin on the Server Side</source>
          <target state="translated">서버 측 Kotlin 사용자</target>
        </trans-unit>
        <trans-unit id="47181373df2bd78be6294c0add1dbe6339b4681b" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 지정된 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3391e8d9489d92fff425335dfe200993b486d0ea" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 기본 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="704ebbde6e2b32eeb1c2f67d4e693a35f67af0fd" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</target>
        </trans-unit>
        <trans-unit id="aac052dc5a6c0e7fbd28f5bc3a043e4ecb32e5f5" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="0dd3b1deb8f1d7bfb8c12c5a14f2ab32a21d65af" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</target>
        </trans-unit>
        <trans-unit id="7a75a8ac839c741b8d08dc9c1deee0d88e4f979c" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 지정된 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9d3ac3ea11a7f22b1d758a682e71f98cc029fa36" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 기본 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="10dc34a2059cb8159f0a883b5dd86e0bc6137e07" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</target>
        </trans-unit>
        <trans-unit id="f82d324c322c9f91adb6f0983572279a3329ac89" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="65bfa57761f82862cfd81ebd5b8013f5e01aaad7" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</target>
        </trans-unit>
        <trans-unit id="42fcdb82df9fab88befa785457e65d1af96aa239" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">이 문자열을 형식 문자열로 사용하고 기본 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3f6866db3da817af6ed67e3dae70c3ec02de81e2" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">이 문자열을 형식 문자열로 사용하고 지정된 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6484cdf608c52e6f223f86ea931137798547136f" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="a6a6e896b98588b46d5642885789c195ba9adc2a" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="4e62e86755452347944ce24bc99c8763bab8c2b5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;receive&lt;/a&gt; suspending function we can receive &lt;em&gt;either&lt;/em&gt; from one channel or the other. But &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; expression allows us to receive from &lt;em&gt;both&lt;/em&gt; simultaneously using its &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; clauses:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;수신&lt;/a&gt; 일시 중단 기능을 사용하면 한 채널에서 수신 &lt;em&gt;하거나&lt;/em&gt; 다른 채널에서 수신 할 수 &lt;em&gt;있습니다&lt;/em&gt; . 그러나 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; 표현식을 사용하면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; 절을 사용하여 &lt;em&gt;두 가지를&lt;/em&gt; 동시에 받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08f3f41e2b1efe6c5dce0e5fec64099ed03bdf2b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;lambdas&quot;&gt;higher-order functions&lt;/a&gt; imposes certain runtime penalties: each function is an object, and it captures a closure, i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.</source>
          <target state="translated">&lt;a href=&quot;lambdas&quot;&gt;고차 함수를&lt;/a&gt; 사용하면 특정 런타임 처벌이 적용됩니다. 각 함수는 객체이며 클로저, 즉 함수 본문에서 액세스되는 변수를 캡처합니다. 메모리 할당 (함수 객체 및 클래스 모두) 및 가상 호출은 런타임 오버 헤드를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="491e6c994c3baf4cc8af39219068162e74e38931" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;::Foo&lt;/code&gt;, the zero-argument constructor of the class Foo, we can simply call it like this:</source>
          <target state="translated">&lt;code&gt;::Foo&lt;/code&gt; 클래스의 제로 인수 생성자 :: Foo를 사용하면 다음과 같이 간단히 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df28902f080c8e95c2e047504754d8fc98471dfb" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; inside &lt;code&gt;when&lt;/code&gt; expressions included in loops</source>
          <target state="translated">루프에 표현식이 포함 된 &lt;code&gt;when&lt;/code&gt; 내부에서 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="1288042cdb0bedb4cedef04fffbbc6421151560c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;when&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; expression 사용</target>
        </trans-unit>
        <trans-unit id="b4d45feb4cce668fd7098830e83bf2557a415c16" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;if&lt;/em&gt; as an expression:</source>
          <target state="translated">사용 &lt;em&gt;하는 경우&lt;/em&gt; 표현으로 :</target>
        </trans-unit>
        <trans-unit id="7956ce97b97e87d0f55a6ea0cc6e4e05373fcf15" translate="yes" xml:space="preserve">
          <source>Using AMD</source>
          <target state="translated">AMD 사용</target>
        </trans-unit>
        <trans-unit id="aae897c446cafc25370dcce91792d5e6dfa9a087" translate="yes" xml:space="preserve">
          <source>Using Ant</source>
          <target state="translated">개미 사용하기</target>
        </trans-unit>
        <trans-unit id="44ab2ab05f55d2266ffc569dcf7fc124a65679b4" translate="yes" xml:space="preserve">
          <source>Using C Interop and libcurl for an App</source>
          <target state="translated">앱에 C Interop 및 libcurl 사용</target>
        </trans-unit>
        <trans-unit id="a59cc5aadf82954e8f0283bd3dfcaae639efbadd" translate="yes" xml:space="preserve">
          <source>Using C library from Kotlin/Native</source>
          <target state="translated">Kotlin / Native의 C 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="d678710e9135632a43d33f3d5da6bf72dddacbe5" translate="yes" xml:space="preserve">
          <source>Using CommonJS</source>
          <target state="translated">CommonJS 사용</target>
        </trans-unit>
        <trans-unit id="e42f7c8cd0e8730768cbb184338fabc772fadfd5" translate="yes" xml:space="preserve">
          <source>Using Dynamic</source>
          <target state="translated">동적 사용</target>
        </trans-unit>
        <trans-unit id="cbe69bb9e7692bc07945db15e10c51c3ee312db2" translate="yes" xml:space="preserve">
          <source>Using Generated Headers from C</source>
          <target state="translated">C에서 생성 된 헤더 사용</target>
        </trans-unit>
        <trans-unit id="27c679a18ee1d9ed93d7a66b728665e446e0b013" translate="yes" xml:space="preserve">
          <source>Using Gradle</source>
          <target state="translated">Gradle 사용</target>
        </trans-unit>
        <trans-unit id="17fbd0b7659b724c4b82377e5e5b6176a4a4d7c0" translate="yes" xml:space="preserve">
          <source>Using Gradle Kotlin DSL</source>
          <target state="translated">Gradle Kotlin DSL 사용</target>
        </trans-unit>
        <trans-unit id="71d5b086b763a415271837d49bf05b383ed34176" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA Build System</source>
          <target state="translated">IntelliJ IDEA 빌드 시스템 사용</target>
        </trans-unit>
        <trans-unit id="be4003165448a14831defb73021c979f0b4b46d4" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA debugger, you can dig deeper into each coroutine to debug your code.</source>
          <target state="translated">IntelliJ IDEA 디버거를 사용하면 각 코 루틴을 더 깊이 파고 들어 코드를 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81cb9f3916c8314e916dfe4f86e42b9f41066648" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA we can easily run and debug the application in any of the possible application servers defined such as Tomcat, Glassfish or WildFly. In this case we're going to use Tomcat which has previously &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;been defined as an application server in IntelliJ IDEA&lt;/a&gt;. Note that application server support is only available in IntelliJ IDEA Ultimate.</source>
          <target state="translated">IntelliJ IDEA를 사용하면 Tomcat, Glassfish 또는 WildFly와 같이 정의 된 가능한 모든 응용 프로그램 서버에서 응용 프로그램을 쉽게 실행하고 디버깅 할 수 있습니다. 이 경우 이전 &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;에 IntelliJ IDEA에서 애플리케이션 서버로 정의 된&lt;/a&gt; Tomcat을 사용 합니다 . 응용 프로그램 서버 지원은 IntelliJ IDEA Ultimate에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4709ae28ff320dfabd65f0869103704aedfcf674" translate="yes" xml:space="preserve">
          <source>Using JNI with Kotlin</source>
          <target state="translated">Kotlin과 함께 JNI 사용</target>
        </trans-unit>
        <trans-unit id="2bbc39d0664d569562a91137d4d90178cf23c617" translate="yes" xml:space="preserve">
          <source>Using Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android 확장 사용</target>
        </trans-unit>
        <trans-unit id="b022874247f51c944909afa759f623b6478ca32e" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android Development</source>
          <target state="translated">안드로이드 개발에 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="60a1392d0c8d40966f3ba2738ae5f701e549f245" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android development, you can benefit from:</source>
          <target state="translated">Using Kotlin for Android development, you can benefit from:</target>
        </trans-unit>
        <trans-unit id="aaf246aafd7124667a554d398075e5452aa83ed4" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Server-side Development</source>
          <target state="translated">서버 측 개발에 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="2b0fb5591f02bcbebcc2bd375ac8a71d601338b0" translate="yes" xml:space="preserve">
          <source>Using Kotlin/Native Targets</source>
          <target state="translated">코 틀린 / 네이티브 대상 사용</target>
        </trans-unit>
        <trans-unit id="936b968752b32f197dc84832341b3f607b83a027" translate="yes" xml:space="preserve">
          <source>Using Maven</source>
          <target state="translated">메이븐 사용하기</target>
        </trans-unit>
        <trans-unit id="ef7af2346af2c37f7e6ee428aab1c98075a789a9" translate="yes" xml:space="preserve">
          <source>Using SharedCode from Android</source>
          <target state="translated">Android에서 SharedCode 사용</target>
        </trans-unit>
        <trans-unit id="603ab8042b5d1c17d5b50d529fa9db7d658d860a" translate="yes" xml:space="preserve">
          <source>Using Struct and Union Types from Kotlin</source>
          <target state="translated">Kotlin의 구조 및 공용체 유형 사용</target>
        </trans-unit>
        <trans-unit id="6e4c13998b5f91e0846d37840959ab407900c453" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 사용하기</target>
        </trans-unit>
        <trans-unit id="4fe7e2f58454fbb71457b9ce1e7ce104ef338243" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">사용 &lt;code&gt;while&lt;/code&gt; 루프를</target>
        </trans-unit>
        <trans-unit id="29dae43467cc406389583f725ed8cb7bcc1c247d" translate="yes" xml:space="preserve">
          <source>Using a Kotlin/JavaScript library.</source>
          <target state="translated">Kotlin / JavaScript 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="d3383ee07c516c1fa1802c63fcedaaefadd8e48c" translate="yes" xml:space="preserve">
          <source>Using a callable reference to an existing declaration:</source>
          <target state="translated">기존 선언에 대한 호출 가능한 참조 사용</target>
        </trans-unit>
        <trans-unit id="197fb49229d662d3379f8cffecb5a8e470235340" translate="yes" xml:space="preserve">
          <source>Using a code block within a function literal, in one of the forms:</source>
          <target state="translated">함수 리터럴 내에서 다음 형식 중 하나로 코드 블록 사용</target>
        </trans-unit>
        <trans-unit id="a7c34a78b0f5530284b929714a111e0120a19cb8" translate="yes" xml:space="preserve">
          <source>Using a standard build tool</source>
          <target state="translated">표준 빌드 도구 사용</target>
        </trans-unit>
        <trans-unit id="6825ce8ddbdb846319b075044bc1aefd9c058144" translate="yes" xml:space="preserve">
          <source>Using artifacts built with Kotlin 1.4.x in a Kotlin 1.3.x project</source>
          <target state="translated">Kotlin 1.3.x 프로젝트에서 Kotlin 1.4.x로 빌드 된 아티팩트 사용</target>
        </trans-unit>
        <trans-unit id="5a3edbb4ebc2b355b2a8f195be33f5a03ead3d30" translate="yes" xml:space="preserve">
          <source>Using bindings</source>
          <target state="translated">바인딩 사용</target>
        </trans-unit>
        <trans-unit id="92c77c8ea60a2ffe09d3b8484f979577fe3fe402" translate="yes" xml:space="preserve">
          <source>Using cinterop</source>
          <target state="translated">cinterop 사용</target>
        </trans-unit>
        <trans-unit id="6f335b7fd336f32636cf82fea33e6e5a118b4de7" translate="yes" xml:space="preserve">
          <source>Using collections</source>
          <target state="translated">컬렉션 사용</target>
        </trans-unit>
        <trans-unit id="ce4da38f792e511ab4d77c2e6a228d9a0f717f17" translate="yes" xml:space="preserve">
          <source>Using conditional expressions</source>
          <target state="translated">조건식 사용</target>
        </trans-unit>
        <trans-unit id="918641690842037efdc3f921e9d2a03a1b94d884" translate="yes" xml:space="preserve">
          <source>Using conditional statements</source>
          <target state="translated">조건문 사용</target>
        </trans-unit>
        <trans-unit id="3fc2b300fe4dab146a33f883986c605263212bcf" translate="yes" xml:space="preserve">
          <source>Using experimental APIs</source>
          <target state="translated">실험용 API 사용</target>
        </trans-unit>
        <trans-unit id="ebd9b5845829e10c5bf4bfdb285f0143f1b0cc17" translate="yes" xml:space="preserve">
          <source>Using extension functions</source>
          <target state="translated">확장 기능 사용</target>
        </trans-unit>
        <trans-unit id="b252910d4e8badbe4bca9df0c30fd5478c5c630b" translate="yes" xml:space="preserve">
          <source>Using in CLI</source>
          <target state="translated">CLI에서 사용</target>
        </trans-unit>
        <trans-unit id="30f417bc0504e6fe1552d975f144e48529a622bd" translate="yes" xml:space="preserve">
          <source>Using in Gradle</source>
          <target state="translated">Gradle에서 사용</target>
        </trans-unit>
        <trans-unit id="987fbf118a45b1d5fc70735f1b4a9cb07d729a9e" translate="yes" xml:space="preserve">
          <source>Using in Maven</source>
          <target state="translated">Maven에서 사용</target>
        </trans-unit>
        <trans-unit id="b58b6328c1df079d0d8cccee5234ec40deb70287" translate="yes" xml:space="preserve">
          <source>Using infix functions</source>
          <target state="translated">삽입 기능 사용</target>
        </trans-unit>
        <trans-unit id="a915c033f5e92eb86f6eb764c7d3fbfec97399c7" translate="yes" xml:space="preserve">
          <source>Using instances of a custom class that implements a function type as an interface:</source>
          <target state="translated">함수 유형을 인터페이스로 구현하는 사용자 정의 클래스 인스턴스 사용 :</target>
        </trans-unit>
        <trans-unit id="b7d1f08b0755e4efecc6155b06410d6d8f47dd0c" translate="yes" xml:space="preserve">
          <source>Using kotlinx.html</source>
          <target state="translated">kotlinx.html 사용</target>
        </trans-unit>
        <trans-unit id="e33a647f9d820f02525a9e589cf38c7cb15aa9e1" translate="yes" xml:space="preserve">
          <source>Using lambda expressions to filter and map collections:</source>
          <target state="translated">람다 식을 사용하여 컬렉션 필터링 및 매핑 :</target>
        </trans-unit>
        <trans-unit id="85b9a9b134d068b76d1d9da5eba9082360a75376" translate="yes" xml:space="preserve">
          <source>Using loops</source>
          <target state="translated">루프 사용</target>
        </trans-unit>
        <trans-unit id="e702f70d153e5bb48504257ee3c4806c305f3fd0" translate="yes" xml:space="preserve">
          <source>Using modules</source>
          <target state="translated">모듈 사용</target>
        </trans-unit>
        <trans-unit id="9af9fabd79c052500b25a5c07039f994d4da9bd7" translate="yes" xml:space="preserve">
          <source>Using nullable &lt;code&gt;Boolean&lt;/code&gt; values in conditions</source>
          <target state="translated">조건에서 널 입력 가능 &lt;code&gt;Boolean&lt;/code&gt; 값 사용</target>
        </trans-unit>
        <trans-unit id="d6a1a404256e60f476abcfdb633a3c534e236959" translate="yes" xml:space="preserve">
          <source>Using nullable values and checking for &lt;em&gt;null&lt;/em&gt;</source>
          <target state="translated">널 (NULL) 값을 사용하고 확인 &lt;em&gt;널 (null)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="872ffc0740cd8cd114c0bd134533ae0bef8b975c" translate="yes" xml:space="preserve">
          <source>Using our favorite editor, we create a new file called &lt;em&gt;library.kt&lt;/em&gt;:</source>
          <target state="translated">자주 사용하는 편집기를 사용하여 &lt;em&gt;library.kt&lt;/em&gt; 라는 새 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4b0f18fbc913dc4d928de83407023cd4eadce18c" translate="yes" xml:space="preserve">
          <source>Using packages from npm</source>
          <target state="translated">npm에서 패키지 사용</target>
        </trans-unit>
        <trans-unit id="550a8f8d20b2e8584106d065339f4d4da1689dfc" translate="yes" xml:space="preserve">
          <source>Using ranges</source>
          <target state="translated">범위 사용</target>
        </trans-unit>
        <trans-unit id="51f179a48f07181aae2f460999afe3b38f8238e7" translate="yes" xml:space="preserve">
          <source>Using scope functions apply/with/run/also/let</source>
          <target state="translated">범위 기능 사용 적용 / 사용 / 실행 / 또한 / let</target>
        </trans-unit>
        <trans-unit id="3ec4dda09fda63d9abb963027b78f1d3b6ffe21e" translate="yes" xml:space="preserve">
          <source>Using string templates</source>
          <target state="translated">문자열 템플릿 사용</target>
        </trans-unit>
        <trans-unit id="4e76a46a35a0080ea05cb7befbedfc77e476e034" translate="yes" xml:space="preserve">
          <source>Using strings</source>
          <target state="translated">문자열 사용</target>
        </trans-unit>
        <trans-unit id="e23bbbb1e9be4eb1c796c8553364504fb8af04eb" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; result type, means we can only return all the values at once. To represent the stream of values that are being asynchronously computed, we can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html&quot;&gt;&lt;code&gt;Flow&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;/a&gt; type just like we would use the &lt;code&gt;Sequence&amp;lt;Int&amp;gt;&lt;/code&gt; type for synchronously computed values:</source>
          <target state="translated">&lt;code&gt;List&amp;lt;Int&amp;gt;&lt;/code&gt; 결과 유형을 사용하면 한 번에 모든 값만 반환 할 수 있습니다. 비동기 적으로 계산되는 값의 스트림을 나타 내기 위해 동 기적으로 계산 된 값에 &lt;code&gt;Sequence&amp;lt;Int&amp;gt;&lt;/code&gt; 유형을 사용하는 것처럼 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html&quot;&gt; &lt;code&gt;Flow&amp;lt;Int&amp;gt;&lt;/code&gt; &lt;/a&gt; 유형을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18148327a2ccfbb8e71316dac9304b16aaccd2b3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin for building &lt;a href=&quot;multiplatform&quot;&gt;multiplatform projects&lt;/a&gt; is described in &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;Building Multiplatform Projects with Gradle&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;multiplatform&quot;&gt;멀티 플랫폼 프로젝트&lt;/a&gt; 를 빌드하기 위해 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 사용은 Gradle을 사용하여 멀티 플랫폼 프로젝트 &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;빌드에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="662526f9ec265672a8f5eadc1e458fce90d93089" translate="yes" xml:space="preserve">
          <source>Using the C Function Pointer from Kotlin</source>
          <target state="translated">Kotlin의 C 함수 포인터 사용</target>
        </trans-unit>
        <trans-unit id="3b3c88f2622b6c11af48eeafb534d5bf373c1268" translate="yes" xml:space="preserve">
          <source>Using the Code from Objective-C</source>
          <target state="translated">Objective-C의 코드 사용</target>
        </trans-unit>
        <trans-unit id="2751cf504326591f0615360e90b35bf6098ad931" translate="yes" xml:space="preserve">
          <source>Using the Code from Swift</source>
          <target state="translated">Swift에서 코드 사용하기</target>
        </trans-unit>
        <trans-unit id="d94748ae1985e15517523c51bbe68be1dc451c79" translate="yes" xml:space="preserve">
          <source>Using the Kotlin/JS IR compiler</source>
          <target state="translated">Kotlin / JS IR 컴파일러 사용</target>
        </trans-unit>
        <trans-unit id="51e131a08f907def09c45df11a971dfb390d42ac" translate="yes" xml:space="preserve">
          <source>Using the command line to run scripts</source>
          <target state="translated">명령 행을 사용하여 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="0dde1829bc0d42dfa9d3d99dc69c6583462ddf28" translate="yes" xml:space="preserve">
          <source>Using the tool &lt;code&gt;ts2kt&lt;/code&gt; (TypeScript to Kotlin) we can convert any &lt;code&gt;d.ts&lt;/code&gt; files to Kotlin. To install the tool we can use &lt;code&gt;npm&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ts2kt&lt;/code&gt; 도구 (TypeScript에서 Kotlin로)를 사용하여 &lt;code&gt;d.ts&lt;/code&gt; 파일을 Kotlin으로 변환 할 수 있습니다 . 도구를 설치하려면 &lt;code&gt;npm&lt;/code&gt; 을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a89a0f28e4e5bf44543e1c9581c55c0e6aecc40d" translate="yes" xml:space="preserve">
          <source>Using trailing commas has several benefits:</source>
          <target state="translated">Using trailing commas has several benefits:</target>
        </trans-unit>
        <trans-unit id="4ebccac5de220cac33103fa30ac3780779ac2fcd" translate="yes" xml:space="preserve">
          <source>Using ts2kt to generate header files for Kotlin</source>
          <target state="translated">ts2kt를 사용하여 Kotlin의 헤더 파일 생성</target>
        </trans-unit>
        <trans-unit id="e0fbba9738442b4c0647e5831e5969871c4f6a2a" translate="yes" xml:space="preserve">
          <source>Using type checks and automatic casts</source>
          <target state="translated">유형 검사 및 자동 캐스트 사용</target>
        </trans-unit>
        <trans-unit id="d8d81e999a726d52e9414f74a35f368a368d19de" translate="yes" xml:space="preserve">
          <source>Usually these fields are private but they can be exposed in one of the following ways:</source>
          <target state="translated">일반적으로 이러한 필드는 비공개이지만 다음 방법 중 하나로 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1278d398657af96687576590c71d68b9a3f58aa" translate="yes" xml:space="preserve">
          <source>Usually, a native binary can be compiled as &lt;em&gt;debug&lt;/em&gt; with more debug information and fewer optimizations, and &lt;em&gt;release&lt;/em&gt; where optimizations are enabled and there is no (or at least less) debug information available.</source>
          <target state="translated">일반적으로 기본 바이너리는 더 많은 디버그 정보와 더 적은 최적화 로 &lt;em&gt;디버그&lt;/em&gt; 로 컴파일 할 수 있으며 최적화가 활성화되고 사용 가능한 디버그 정보가없는 &lt;em&gt;릴리스를 릴리스&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="12caefb8a5010ce40aa23c1ea29352f8837f75ed" translate="yes" xml:space="preserve">
          <source>Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it &lt;em&gt;unsafe&lt;/em&gt;. The unsafe cast in Kotlin is done by the infix operator &lt;em&gt;as&lt;/em&gt; (see &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;operator precedence&lt;/a&gt;):</source>
          <target state="translated">일반적으로 캐스트가 불가능한 경우 캐스트 연산자는 예외를 발생시킵니다. 따라서 우리는 이것을 &lt;em&gt;안전하지 않은 것으로&lt;/em&gt; 부릅니다 . Kotlin의 안전하지 않은 캐스트는 다음 &lt;em&gt;과 같이&lt;/em&gt; 중위 연산자에 의해 수행됩니다 ( &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;연산자 우선 순위&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="078efedb0f7a9297e4a66c7bf48c73578606e64d" translate="yes" xml:space="preserve">
          <source>Utility functions for concurrent programming.</source>
          <target state="translated">동시 프로그래밍을위한 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="54a27f71a3926c933fffb4cc8fcd736d36aae00b" translate="yes" xml:space="preserve">
          <source>Utility functions for working with Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;streams&lt;/a&gt;.</source>
          <target state="translated">Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;스트림&lt;/a&gt; 작업을위한 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="70a0023fe530c9e1dc6b5efd1156df2342cee154" translate="yes" xml:space="preserve">
          <source>Utility functions for working with the browser DOM.</source>
          <target state="translated">브라우저 DOM 작업을위한 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="b48498a5cff3c4e7ce37b18fdd81413319dd4656" translate="yes" xml:space="preserve">
          <source>VALUE_PARAMETER</source>
          <target state="translated">VALUE_PARAMETER</target>
        </trans-unit>
        <trans-unit id="242cc9162b91c0b54499ac05fdd663dcea97e3ff" translate="yes" xml:space="preserve">
          <source>ValidityState</source>
          <target state="translated">ValidityState</target>
        </trans-unit>
        <trans-unit id="4ca51107e6a14998cd7631ba2234ead0b2f51037" translate="yes" xml:space="preserve">
          <source>Value arguments</source>
          <target state="translated">Value arguments</target>
        </trans-unit>
        <trans-unit id="bc813f9a338f88bada03e57203025b97e72de98e" translate="yes" xml:space="preserve">
          <source>Value parameter of a function or a constructor</source>
          <target state="translated">함수 또는 생성자의 값 매개 변수</target>
        </trans-unit>
        <trans-unit id="ae0d9f73010cf89531cbcdadc5148c931b0aba52" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;collected&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; function.</source>
          <target state="translated">값이된다 &lt;em&gt;수집&lt;/em&gt; 하여 흐름으로부터 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;수집&lt;/a&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="9d4b78efaf35ec9ac8ccb78b50e8f937f6c083fa" translate="yes" xml:space="preserve">
          <source>Values are &lt;em&gt;emitted&lt;/em&gt; from the flow using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html&quot;&gt;emit&lt;/a&gt; function.</source>
          <target state="translated">값이되어 &lt;em&gt;출사&lt;/em&gt; 하여 흐름 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html&quot;&gt;발광&lt;/a&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="ae7d4e58b65d5a70d4dfae24ee97f38d7c1a9ff0" translate="yes" xml:space="preserve">
          <source>Values can be updated. In turn, keys never change: once you add an entry, its key is constant.</source>
          <target state="translated">값을 업데이트 할 수 있습니다. 차례로 키는 변경되지 않습니다. 항목을 추가하면 해당 키는 일정합니다.</target>
        </trans-unit>
        <trans-unit id="83ce8efcd219286f9e80c1c630307f7c0a05ac1f" translate="yes" xml:space="preserve">
          <source>Values of an annotation instance are exposed as properties to Kotlin code:</source>
          <target state="translated">주석 인스턴스의 값은 Kotlin 코드에 속성으로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="e2e1116424b8a24a96cede1b506dcc3d11485f0b" translate="yes" xml:space="preserve">
          <source>VarType</source>
          <target state="translated">VarType</target>
        </trans-unit>
        <trans-unit id="42ec9490f36e6cae9913c4374b09e32237c707ad" translate="yes" xml:space="preserve">
          <source>Varargs and optional/named parameters</source>
          <target state="translated">Varargs 및 선택적 / 명명 된 매개 변수</target>
        </trans-unit>
        <trans-unit id="10eea16b487acafb1da690a6fa932f924aadcf7a" translate="yes" xml:space="preserve">
          <source>Variable inspection</source>
          <target state="translated">변수 검사</target>
        </trans-unit>
        <trans-unit id="342ee951b83918c9c708f1243be034edc6ba7220" translate="yes" xml:space="preserve">
          <source>Variable inspections for var variables works out of the box for primitive types. For non-primitive types there are custom pretty printers for lldb in &lt;code&gt;konan_lldb.py&lt;/code&gt;:</source>
          <target state="translated">var 변수에 대한 변수 검사는 기본 유형에 대해 즉시 작동합니다. 기본이 아닌 유형의 경우 &lt;code&gt;konan_lldb.py&lt;/code&gt; 에 lldb 용 사용자 정의 프린터가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a018b33a39aac69fe200a8b99412d4c30ecc8054" translate="yes" xml:space="preserve">
          <source>Variable names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">변수 이름은 &lt;code&gt;snake_case&lt;/code&gt; 대신 &lt;code&gt;lowerCamelCase&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="43edb35cae8befc5879d0b7aa2cd22c92255e5d7" translate="yes" xml:space="preserve">
          <source>Variable number of arguments (Varargs)</source>
          <target state="translated">가변 개수의 인수 (Varargs)</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="eaac90ed072370b9f57426b726154a33050c4fed" translate="yes" xml:space="preserve">
          <source>Variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; get the values returned by &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt; called on elements of the collection.</source>
          <target state="translated">변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 컬렉션의 요소에서 호출 된 &lt;code&gt;component1()&lt;/code&gt; 및 &lt;code&gt;component2()&lt;/code&gt; 의해 반환 된 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="808412b58bbf8525d5dac7961edbdfc05c3db76a" translate="yes" xml:space="preserve">
          <source>Variables that can be reassigned use the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">재 할당 할 수있는 변수는 &lt;code&gt;var&lt;/code&gt; 키워드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="1a91ea423a97d4a87943d588b081e7e38282531c" translate="yes" xml:space="preserve">
          <source>Variance directions</source>
          <target state="translated">차이 방향</target>
        </trans-unit>
        <trans-unit id="5c16bf6df0ccb8c8f8d9897278f38f99a8d180ae" translate="yes" xml:space="preserve">
          <source>Variant generics</source>
          <target state="translated">변형 제네릭</target>
        </trans-unit>
        <trans-unit id="48aeb525f24a17a17a2746ff3465033889ff970a" translate="yes" xml:space="preserve">
          <source>Various collections and sequences can be converted to flows using &lt;code&gt;.asFlow()&lt;/code&gt; extension functions.</source>
          <target state="translated">&lt;code&gt;.asFlow()&lt;/code&gt; 확장 함수를 사용하여 다양한 컬렉션과 시퀀스를 흐름으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ed714f305f37a57ecb8473b7415dfab9db01f6a" translate="yes" xml:space="preserve">
          <source>Various utilities for working with strings and char sequences.</source>
          <target state="translated">문자열 및 문자 시퀀스 작업을위한 다양한 유틸리티.</target>
        </trans-unit>
        <trans-unit id="280853b24c26b2f29a476f73ab7f87fbd08c6186" translate="yes" xml:space="preserve">
          <source>Vector128</source>
          <target state="translated">Vector128</target>
        </trans-unit>
        <trans-unit id="6c08e229ae1df722641eb28302211d6c86591e45" translate="yes" xml:space="preserve">
          <source>Vector128Var</source>
          <target state="translated">Vector128Var</target>
        </trans-unit>
        <trans-unit id="9ffb8650f3fdd46d87c18838f3017eda5ad872f4" translate="yes" xml:space="preserve">
          <source>Vector128VarOf</source>
          <target state="translated">Vector128VarOf</target>
        </trans-unit>
        <trans-unit id="288ce52d20fd503b110a72d86e9675e1c95e19eb" translate="yes" xml:space="preserve">
          <source>Verify the emulator configuration and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">에뮬레이터 구성을 확인하고 &lt;strong&gt;완료를&lt;/strong&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="de621f8c2654b2397c981cb428da06adf04bb6fe" translate="yes" xml:space="preserve">
          <source>Versioned separately from the language</source>
          <target state="translated">Versioned separately from the language</target>
        </trans-unit>
        <trans-unit id="84bee7b1488f1e88fea6081e11b80da21edf9ec4" translate="yes" xml:space="preserve">
          <source>VideoFacingModeEnum</source>
          <target state="translated">VideoFacingModeEnum</target>
        </trans-unit>
        <trans-unit id="fa871b63d316a5ccaf06d516a54da0961996827d" translate="yes" xml:space="preserve">
          <source>VideoResizeModeEnum</source>
          <target state="translated">VideoResizeModeEnum</target>
        </trans-unit>
        <trans-unit id="64fea40a0473c85795b9336e14b2b716b018b418" translate="yes" xml:space="preserve">
          <source>VideoTrack</source>
          <target state="translated">VideoTrack</target>
        </trans-unit>
        <trans-unit id="c02eab00438fffc417a6ac0aa9bb22fc06605beb" translate="yes" xml:space="preserve">
          <source>View binding</source>
          <target state="translated">뷰 바인딩</target>
        </trans-unit>
        <trans-unit id="db9fea7c8a56a15e997acc428b673797be1af865" translate="yes" xml:space="preserve">
          <source>View caching</source>
          <target state="translated">캐싱보기</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="0d73e14a3fcddf8956a7da60bbcb1e077c95f7a0" translate="yes" xml:space="preserve">
          <source>Visibility Modifiers</source>
          <target state="translated">가시성 수정 자</target>
        </trans-unit>
        <trans-unit id="28ffb1b2d0c701707ce3c73f2c7cf4a513706777" translate="yes" xml:space="preserve">
          <source>Visibility is an aspect of a Kotlin declaration regulating where that declaration is accessible in the source code. Visibility can be changed with one of the following modifiers: &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">가시성은 소스 코드에서 해당 선언에 액세스 할 수있는 위치를 규제하는 Kotlin 선언의 한 측면입니다. &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; 수정 자 중 하나를 사용하여 가시성을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="849b37d75d9e78cb34f760a7b86638406d0e4272" translate="yes" xml:space="preserve">
          <source>Visibility modifiers</source>
          <target state="translated">가시성 수정 자</target>
        </trans-unit>
        <trans-unit id="572b59949083550c2f89c909f2a69634e1647c72" translate="yes" xml:space="preserve">
          <source>Visibility modifiers are required for declarations if the default visibility exposes them to the public API. This helps ensure that no declarations are exposed to the public API unintentionally.</source>
          <target state="translated">기본 가시성이 공개 API에 노출되는 경우 선언에 가시성 수정자가 필요합니다. 이는 의도 치 않게 공개 API에 선언이 노출되지 않도록하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8ccb166e167967c0af7bc8270ccff3bc3f332444" translate="yes" xml:space="preserve">
          <source>Visibility modifiers can't be placed on local variables, since their visibility is always limited to the containing block.</source>
          <target state="translated">가시성은 항상 포함 블록으로 제한되므로 가시성 수정자는 로컬 변수에 배치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6cd8f7e2419769693129b0c2082de4e40a0da3a3" translate="yes" xml:space="preserve">
          <source>Visibility of Top-level Declarations</source>
          <target state="translated">최상위 선언의 가시성</target>
        </trans-unit>
        <trans-unit id="b794e604145c856d9c96b2bfb79a673421c9cf64" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;internal&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 수정 자로 표시된 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="63bf3a48e0f5fd4c5b7c9576056b33b03784b05d" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;private&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 수정 자로 표시된 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="d02ce232d311d05d3099c6a996cbef8c4dd286f9" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;protected&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 수정 자로 표시된 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="dd1c739248ca96578cca7f9bfb547899b54a876f" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;public&lt;/code&gt; modifier, or with no modifier at all.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 수정 자로 표시 되거나 수정자가없는 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="de706486df3bb39a3413cb5cbbb1d996126bda21" translate="yes" xml:space="preserve">
          <source>Visibility of this callable, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">이 콜 러블 의 가시성. Kotlin에서 가시성을 표현할 수없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dac6119f07007062b4875b1638bac8a721585f4a" translate="yes" xml:space="preserve">
          <source>Visibility of this class, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">이 클래스 의 가시성. Kotlin에서 가시성을 표현할 수없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aabca03bdef260f1cffd784ffe10c2b762503211" translate="yes" xml:space="preserve">
          <source>Visibility rules regarding complex class hierarchies with companion objects</source>
          <target state="translated">컴패니언 객체가있는 복잡한 클래스 계층 구조에 대한 가시성 규칙</target>
        </trans-unit>
        <trans-unit id="ac3022e113442db8619d262ae03fa9c0097a6e0d" translate="yes" xml:space="preserve">
          <source>Volatile</source>
          <target state="translated">Volatile</target>
        </trans-unit>
        <trans-unit id="74365b04f91d0aa9f5cfe78a2b9d8c743270db07" translate="yes" xml:space="preserve">
          <source>Volatiles are of no help</source>
          <target state="translated">휘발성 물질은 도움이되지 않습니다</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="4e946026a7ff331eb2b9dc124f891817863bd199" translate="yes" xml:space="preserve">
          <source>WASM</source>
          <target state="translated">WASM</target>
        </trans-unit>
        <trans-unit id="25ca2ee13f635d58b0c2cff69efbc6a4f1b88f58" translate="yes" xml:space="preserve">
          <source>WASM32</source>
          <target state="translated">WASM32</target>
        </trans-unit>
        <trans-unit id="406538ae6cd24bca924c59857d3c75a306aa56eb" translate="yes" xml:space="preserve">
          <source>WATCHOS</source>
          <target state="translated">WATCHOS</target>
        </trans-unit>
        <trans-unit id="b9fac4aec6291b1c5ab0f9569e59e39d2636356c" translate="yes" xml:space="preserve">
          <source>WCString</source>
          <target state="translated">WCString</target>
        </trans-unit>
        <trans-unit id="c1cd547450ddf19820dbba6198904ce66087e598" translate="yes" xml:space="preserve">
          <source>WHITESPACE</source>
          <target state="translated">WHITESPACE</target>
        </trans-unit>
        <trans-unit id="2e31950e28a56c4fe6e7025b187b2fd4fefe4871" translate="yes" xml:space="preserve">
          <source>WINDOWS</source>
          <target state="translated">WINDOWS</target>
        </trans-unit>
        <trans-unit id="d9fff1c0dfb1298ad2bb377a3be85896a8fef6d6" translate="yes" xml:space="preserve">
          <source>Waiting for a job</source>
          <target state="translated">일자리를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="43754c49f6c1a5cc1ea3d54dbf166c296a415ea2" translate="yes" xml:space="preserve">
          <source>Warning! Annotating your API with &lt;code&gt;@JvmDefault&lt;/code&gt; has serious implications on binary compatibility. Make sure to carefully read the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;reference page&lt;/a&gt; before using &lt;code&gt;@JvmDefault&lt;/code&gt; in production.</source>
          <target state="translated">경고! &lt;code&gt;@JvmDefault&lt;/code&gt; 로 API에 주석을 달면 이진 호환성에 심각한 영향을 미칩니다. 프로덕션에서 &lt;code&gt;@JvmDefault&lt;/code&gt; 를 사용하기 전에 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;참조 페이지&lt;/a&gt; 를주의해서 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7d38e4cd7c43347e6b57a76218aeff28900c3be2" translate="yes" xml:space="preserve">
          <source>Warning: using reflection is usually the wrong way to solve problems in Kotlin! In particular, if you have several classes that all have some common properties/functions and you want to write a function that can take an instance of any of those classes and use those properties, the correct approach is to define an interface with the common properties/functions and make all the relevant classes implement it; the function can then take that interface as a parameter. If you don't control those classes, you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter pattern&lt;/a&gt; and write wrapper classes that implement the interface - this is very easy thanks to Kotlin's &lt;a href=&quot;inheritance#delegation&quot;&gt;delegation feature&lt;/a&gt;. You can also get a lot of leverage out of using generics in clever ways.</source>
          <target state="translated">경고 : 리플렉션 사용은 일반적으로 Kotlin의 문제를 해결하는 잘못된 방법입니다! 특히, 일부 공통 속성 / 함수를 가진 여러 클래스가 있고 해당 클래스의 인스턴스를 가져 와서 해당 속성을 사용할 수있는 함수를 작성하려는 경우 올바른 접근 방식은 공통 속성으로 인터페이스를 정의하는 것입니다. / functions 및 모든 관련 클래스가이를 구현하도록합니다. 그러면 함수는 해당 인터페이스를 매개 변수로 사용할 수 있습니다. 이러한 클래스를 제어하지 않으면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;어댑터 패턴을&lt;/a&gt; 사용 하고 인터페이스를 구현하는 랩퍼 클래스를 작성할 수 있습니다. 이는 Kotlin의 &lt;a href=&quot;inheritance#delegation&quot;&gt;위임 기능&lt;/a&gt; 덕분에 매우 쉽습니다 . 또한 제네릭을 영리하게 사용하면 많은 활용 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5869fc3835710be9dffa94b09164944fe6c00863" translate="yes" xml:space="preserve">
          <source>Warnings as errors</source>
          <target state="translated">오류로서의 경고</target>
        </trans-unit>
        <trans-unit id="7d7a6c37ae0a89dc47c6393b7b23a560c9ff63a7" translate="yes" xml:space="preserve">
          <source>Watch for deprecation warnings in advance for the best update experience.</source>
          <target state="translated">Watch for deprecation warnings in advance for the best update experience.</target>
        </trans-unit>
        <trans-unit id="621508220c73315e0bfc68d68f589c562907f45d" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;SharedCode&lt;/code&gt; framework to the Xcode project. For that let's click on the root node of the &lt;em&gt;project navigator&lt;/em&gt; and select the &lt;em&gt;target&lt;/em&gt; settings. Next, we click on the &lt;code&gt;+&lt;/code&gt; in the &lt;em&gt;Embedded Binaries&lt;/em&gt; section, click &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; button in the dialog to choose the framework from the disk. We can point to the following folder:</source>
          <target state="translated">Xcode 프로젝트에 &lt;code&gt;SharedCode&lt;/code&gt; 프레임 워크를 추가합니다 . 이를 위해 &lt;em&gt;프로젝트 탐색기&lt;/em&gt; 의 루트 노드를 클릭 하고 &lt;em&gt;대상&lt;/em&gt; 설정을 선택하십시오 . 그런 다음 &lt;em&gt;Embedded Binaries&lt;/em&gt; 섹션 에서 &lt;code&gt;+&lt;/code&gt; 를 클릭 하고 대화 상자에서 &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; 버튼을 클릭 하여 디스크에서 프레임 워크를 선택합니다. 다음 폴더를 가리킬 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a9f25c8723418966c0e0b17f9549ea1ce5a5f99" translate="yes" xml:space="preserve">
          <source>We also need to use the &lt;em&gt;war&lt;/em&gt; plugin that helps us generate the corresponding WAR artifacts for running/deploying</source>
          <target state="translated">또한 실행 / 배포를위한 해당 WAR 아티팩트를 생성하는 데 도움이 되는 &lt;em&gt;war&lt;/em&gt; 플러그인 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f769d9a3ee354265c33ea15ceda2db82197765c" translate="yes" xml:space="preserve">
          <source>We are just trying out an idea and want some users to play with it and give feedback. If it doesn't work out, we may drop it any minute.</source>
          <target state="translated">We are just trying out an idea and want some users to play with it and give feedback. If it doesn't work out, we may drop it any minute.</target>
        </trans-unit>
        <trans-unit id="f808d588d4d3fcebee5f5b3ff2c14b3f46e0e3a6" translate="yes" xml:space="preserve">
          <source>We are now migrating Kotlin/JVM and Kotlin/JS to the same IR. As a result, all three backends share a lot of logic and have a unified pipeline. This allows us to implement most features, optimizations, and bug fixes only once for all platforms. Both new IR-based back-ends are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;.</source>
          <target state="translated">이제 Kotlin / JVM 및 Kotlin / JS를 동일한 IR로 마이그레이션하고 있습니다. 결과적으로 세 백엔드 모두 많은 논리를 공유하고 통합 파이프 라인을 갖습니다. 이를 통해 모든 플랫폼에 대해 대부분의 기능, 최적화 및 버그 수정을 한 번만 구현할 수 있습니다. 새로운 IR 기반 백엔드는 모두 &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05a06031f1e06a7952c57e44121ca5e185850421" translate="yes" xml:space="preserve">
          <source>We are now ready to start coding the iOS application and to use the Kotlin code from it</source>
          <target state="translated">이제 iOS 애플리케이션 코딩을 시작하고 Kotlin 코드를 사용할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="cff8cb63586d851860fe613c1e521ee0461e4b2e" translate="yes" xml:space="preserve">
          <source>We are ready to use the &lt;code&gt;SharedCode&lt;/code&gt; library from our Android and iOS applications.</source>
          <target state="translated">Android 및 iOS 애플리케이션에서 &lt;code&gt;SharedCode&lt;/code&gt; 라이브러리 를 사용할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="14edea8060ff3b0350a868b06c73ba61ae235890" translate="yes" xml:space="preserve">
          <source>We are starting with an implementation for the JVM. Let's create a file &lt;code&gt;Base64.kt&lt;/code&gt; in &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; folder and provide a simple implementation, which delegates to &lt;code&gt;java.util.Base64&lt;/code&gt;:</source>
          <target state="translated">우리는 JVM 구현으로 시작합니다. 하자는 파일 생성 &lt;code&gt;Base64.kt&lt;/code&gt; 에서 &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; 폴더를하고있는 대표 간단한 구현, 제공 &lt;code&gt;java.util.Base64&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="b38f2316b8757428d73f475d7c1fadf769b873b4" translate="yes" xml:space="preserve">
          <source>We are using &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; for this tutorial. Both the &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;free and open source&lt;/a&gt; IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;Community Edition&lt;/a&gt; and IntelliJ IDEA Ultimate Edition work for this tutorial. We can download and install both of them from &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; if necessary. The Kotlin plugin is included with IntelliJ IDEA by default, but still, we need to make sure the Kotlin plugin version is 1.3.41 (or newer) in the &lt;em&gt;Settings&lt;/em&gt; or &lt;em&gt;Preferences&lt;/em&gt; dialog, under the Language &amp;amp; Frameworks | Kotlin section.</source>
          <target state="translated">우리는 사용 &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;하게 IntelliJ IDEA를&lt;/a&gt; 이 튜토리얼. 둘 다 &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;무료 및 오픈 소스&lt;/a&gt; 인 IntelliJ의 IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;커뮤니티 에디션&lt;/a&gt; 과이 튜토리얼하게 IntelliJ IDEA 얼티미트 에디션 작동합니다. 필요한 경우 &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; 에서 두 가지를 모두 다운로드하여 설치할 수 있습니다 . Kotlin 플러그인은 기본적으로 IntelliJ IDEA에 포함되어 있지만 여전히 언어 또는 프레임 워크 | &lt;em&gt;설정&lt;/em&gt; 또는 &lt;em&gt;환경 설정&lt;/em&gt; 대화 상자 에서 Kotlin 플러그인 버전이 1.3.41 이상인지 확인해야합니다. 코 틀린 섹션.</target>
        </trans-unit>
        <trans-unit id="55cc632a1ea27e5e64ad2495a5384f62f48dbc86" translate="yes" xml:space="preserve">
          <source>We are using the &lt;code&gt;delay()&lt;/code&gt; function that's like &lt;code&gt;Thread.sleep()&lt;/code&gt;, but better: it &lt;em&gt;doesn't block a thread&lt;/em&gt;, but only suspends the coroutine itself. The thread is returned to the pool while the coroutine is waiting, and when the waiting is done, the coroutine resumes on a free thread in the pool.</source>
          <target state="translated">우리는 &lt;code&gt;Thread.sleep()&lt;/code&gt; 과 같은 &lt;code&gt;delay()&lt;/code&gt; 함수를 사용하고 있지만 더 좋습니다 : &lt;em&gt;thread를 차단하지는 않지만&lt;/em&gt; 코 루틴 자체를 일시 중단합니다. 코 루틴이 대기하는 동안 스레드가 풀로 리턴되고 대기가 완료되면 코 루틴이 풀의 사용 가능한 스레드에서 재개됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da1efc61212d59164e482ecaadd2d5e755cb8ec9" translate="yes" xml:space="preserve">
          <source>We believe that a lot of users could use a much faster cycle, where critical compiler bug fixes arrive immediately, making the code more safe and correct. So, Kotlin 1.3 introduces &lt;em&gt;progressive&lt;/em&gt; compiler mode, which can be enabled by passing the argument &lt;code&gt;-progressive&lt;/code&gt; to the compiler.</source>
          <target state="translated">우리는 많은 사용자들이 훨씬 빠른 사이클을 사용할 수 있다고 생각합니다. 중요한 컴파일러 버그 수정이 즉시 도착하여 코드가 더 안전하고 정확합니다. 따라서 Kotlin 1.3에는 &lt;em&gt;점진적&lt;/em&gt; 컴파일러 모드가 도입되었습니다.이 모드는 &lt;code&gt;-progressive&lt;/code&gt; 인수 를 컴파일러 에 전달하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e996e5615a264af995c203eaebe6185c018bf0a" translate="yes" xml:space="preserve">
          <source>We believe that the words &lt;strong&gt;in&lt;/strong&gt; and &lt;strong&gt;out&lt;/strong&gt; are self-explaining (as they were successfully used in C# for quite some time already), thus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:</source>
          <target state="translated">우리는 단어 믿고 &lt;strong&gt;에서&lt;/strong&gt; 와 &lt;strong&gt;밖으로&lt;/strong&gt; 따라서 위에서 언급 한 니모닉이 정말 필요하지, 자기 설명 (성공적 이미 꽤 많은 시간 동안 C #으로 사용했다), 그리고 하나는 높은 목적을 위해 그것을 바꿔 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a4b5a076e237cd86b9569bc0bd72070895b09bdf" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;lib.exe&lt;/code&gt; from the toolchain to generate the static library wrapper &lt;code&gt;libnative.lib&lt;/code&gt; that automates the DLL usage from the code:</source>
          <target state="translated">코드에서 DLL 사용을 자동화하는 정적 라이브러리 래퍼 &lt;code&gt;libnative.lib&lt;/code&gt; 를 생성하기 위해 툴체인에서 &lt;code&gt;lib.exe&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b380a7bf1b634600b0c261666fb452d97fe21714" translate="yes" xml:space="preserve">
          <source>We call Kotlin classes directly from Objective-C code. A Kotlin &lt;code&gt;object&lt;/code&gt; has the class method function &lt;code&gt;object&lt;/code&gt;, which allows us to get the only instance of the object and to call &lt;code&gt;Object&lt;/code&gt; methods on it. The widespread pattern is used to create an instance of the &lt;code&gt;Clazz&lt;/code&gt; class. We call the &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; on Objective-C. We may also use &lt;code&gt;[DemoClazz new]&lt;/code&gt; for constructors without parameters. Global declarations from the Kotlin sources are scoped under the &lt;code&gt;DemoLibKt&lt;/code&gt; class in Objective-C. All methods are turned into class methods of that class. The &lt;code&gt;strings&lt;/code&gt; function is turned into &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; function in Objective-C, we can pass &lt;code&gt;NSString&lt;/code&gt; directly to it. The return is visible as &lt;code&gt;NSString&lt;/code&gt; too.</source>
          <target state="translated">Objective-C 코드에서 Kotlin 클래스를 직접 호출합니다. Kotlin &lt;code&gt;object&lt;/code&gt; 에는 클래스 메소드 함수 &lt;code&gt;object&lt;/code&gt; 가 있습니다 .이를 통해 객체 의 유일한 인스턴스를 가져 와서 &lt;code&gt;Object&lt;/code&gt; 메소드 를 호출 할 수 있습니다. 널리 퍼진 패턴은 &lt;code&gt;Clazz&lt;/code&gt; 클래스 의 인스턴스를 작성하는 데 사용됩니다 . Objective-C 에서 &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; 를 호출합니다 . 파라미터가없는 생성자에 &lt;code&gt;[DemoClazz new]&lt;/code&gt; 를 사용할 수도 있습니다 . Kotlin 소스의 글로벌 선언은 Objective-C 의 &lt;code&gt;DemoLibKt&lt;/code&gt; 클래스 아래에 있습니다. 모든 메소드는 해당 클래스의 클래스 메소드로 바뀝니다. &lt;code&gt;strings&lt;/code&gt; 함수로 설정되어 &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; Objective-C에서 함수 를 사용하면 &lt;code&gt;NSString&lt;/code&gt; 을 직접 전달할 수 있습니다 . 리턴은 &lt;code&gt;NSString&lt;/code&gt; 으로 도 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6efbfc50d097338c67f6c25e5a2530e00802bbf1" translate="yes" xml:space="preserve">
          <source>We can also check a value for being &lt;em&gt;in&lt;/em&gt; or &lt;em&gt;!in&lt;/em&gt; a &lt;a href=&quot;ranges&quot;&gt;range&lt;/a&gt; or a collection:</source>
          <target state="translated">또한 &lt;a href=&quot;ranges&quot;&gt;범위&lt;/a&gt; 또는 컬렉션 &lt;em&gt;에&lt;/em&gt; 있거나 &lt;em&gt;!에&lt;/em&gt; 있는 값을 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d48b261007df82564fff9e248b32f0b0877a7db" translate="yes" xml:space="preserve">
          <source>We can also run the project from the command line, without using IntelliJ IDEA Ultimate, if we apply the gretty plugin. In order to do this, we need to make the following changes to build.gradle:</source>
          <target state="translated">We can also run the project from the command line, without using IntelliJ IDEA Ultimate, if we apply the gretty plugin. In order to do this, we need to make the following changes to build.gradle:</target>
        </trans-unit>
        <trans-unit id="be71c4616ae57b989081464748078b992e6a499b" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; option.</source>
          <target state="translated">또한 &lt;code&gt;sourceMap&lt;/code&gt; 옵션을 통해이를 표시하여 컴파일러가 소스 맵을 생성하도록할지 여부를 정의 할 수있는 방법도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db36be1716cde1f09b5bb491a1d29f546a1af582" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; parameter.</source>
          <target state="translated">또한 &lt;code&gt;sourceMap&lt;/code&gt; 매개 변수 를 통해이를 표시하여 컴파일러가 소스 맵을 생성하도록할지 여부를 정의 할 수있는 방법도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5bd60fd46fe6ea1c5b448761b2e310af9a2b34e" translate="yes" xml:space="preserve">
          <source>We can check whether an object conforms to a given type at runtime by using the &lt;code&gt;is&lt;/code&gt; operator or its negated form &lt;code&gt;!is&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 연산자 또는 부정 형식 인 &lt;code&gt;!is&lt;/code&gt; 를 사용하여 런타임에 객체가 주어진 유형을 따르는 지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80fca726c567776685be62a6f296ba802e4a0c48" translate="yes" xml:space="preserve">
          <source>We can choose to let &lt;code&gt;MotorVehicle&lt;/code&gt; implement that interface, since it's got the required members - but now we need to mark those members with &lt;code&gt;override&lt;/code&gt;, and we can remove &lt;code&gt;open&lt;/code&gt; since an overridden function is implicitly open:</source>
          <target state="translated">필요한 멤버가 있으므로 &lt;code&gt;MotorVehicle&lt;/code&gt; 이 해당 인터페이스를 구현 하도록 선택할 수 있습니다. 그러나 이제 해당 멤버를 &lt;code&gt;override&lt;/code&gt; 로 표시해야 하며 재정의 된 함수가 암시 적으로 열려 있으므로 &lt;code&gt;open&lt;/code&gt; 을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b29aa01092a4a2f64bc0e5bf97de56d6e4257337" translate="yes" xml:space="preserve">
          <source>We can click the file reference on the right to navigate directly to the corresponding statement. Alternatively, we can manually switch to the &lt;em&gt;Sources&lt;/em&gt; tab, and find the correct file in the file tree. Navigating to the Kotlin file actually shows us regular Kotlin code (as opposed to minified JavaScript):</source>
          <target state="translated">오른쪽에있는 파일 참조를 클릭하여 해당 명령문으로 직접 이동할 수 있습니다. 또는 &lt;em&gt;소스&lt;/em&gt; 탭 으로 수동으로 전환 하여 파일 트리에서 올바른 파일을 찾을 수 있습니다. Kotlin 파일로 이동하면 실제로 일반 Kotlin 코드가 표시됩니다 (축소 된 자바 스크립트가 아님).</target>
        </trans-unit>
        <trans-unit id="3df63e38e36909132576c3c502bfc7296d767131" translate="yes" xml:space="preserve">
          <source>We can combine the declarative nature of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html&quot;&gt;catch&lt;/a&gt; operator with a desire to handle all the exceptions, by moving the body of the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; operator into &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; and putting it before the &lt;code&gt;catch&lt;/code&gt; operator. Collection of this flow must be triggered by a call to &lt;code&gt;collect()&lt;/code&gt; without parameters:</source>
          <target state="translated">우리는의 선언적 성격 결합 할 수 있습니다 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html&quot;&gt;캐치&lt;/a&gt; 의 신체 이동하여 모든 예외를 처리하는 욕망 연산자를 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;수집&lt;/a&gt; 로 연산자를 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; 하고 전에 퍼팅 &lt;code&gt;catch&lt;/code&gt; 연산자. 이 흐름의 수집은 매개 변수없이 &lt;code&gt;collect()&lt;/code&gt; 호출에 의해 트리거되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ab28e12a4329ff5188bb6bb1c34f1f3bf4ce258" translate="yes" xml:space="preserve">
          <source>We can configure the Kotlin compiler option to use any of these. The last option (UMD) will generate UMD and fallback to the other options if one is not available. Currently Kotlin compiler options are per IntelliJ IDEA project as opposed to a Kotlin module.</source>
          <target state="translated">Kotlin 컴파일러 옵션을 구성하여 이들 중 하나를 사용할 수 있습니다. 마지막 옵션 (UMD)은 UMD를 생성하고 사용할 수없는 경우 다른 옵션으로 대체합니다. 현재 Kotlin 컴파일러 옵션은 Kotlin 모듈과 달리 IntelliJ IDEA 프로젝트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5b4c1b5549ed7b71f56b6d1ba48bd66bf46537dc" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with &quot;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">호출하는 비동기 스타일 함수를 정의 할 수 있습니다 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 명시 적 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 참조 가있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 코 루틴 빌더를 사용하여 doSomethingUsefulOne 및 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를&lt;em&gt;비동기 적으로&lt;/em&gt; . 이러한 함수의 이름을 &quot;Async&quot;접미사로 지정하면 비동기 계산 만 시작하고 결과를 얻기 위해 결과 지연된 값을 사용해야한다는 사실을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="452dc3c84f7cabd350d9558a57e866a1cf25ff79" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with the &quot;&amp;hellip;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; &lt;em&gt;asynchronously&lt;/em&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with the &quot;&amp;hellip;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</target>
        </trans-unit>
        <trans-unit id="4ecb356b303055242a64963a7b2a1f314c6be1d3" translate="yes" xml:space="preserve">
          <source>We can define custom accessors for a property. If we define a custom getter, it will be called every time we access the property (this allows us to implement a computed property). Here's an example of a custom getter:</source>
          <target state="translated">속성에 대한 사용자 지정 접근자를 정의 할 수 있습니다. 커스텀 게터를 정의하면 속성에 액세스 할 때마다 호출됩니다 (계산 된 속성을 구현할 수 있습니다). 맞춤 게터의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b31aa9761950ea554c775fecf5e0c018baf882fd" translate="yes" xml:space="preserve">
          <source>We can easily call it directly (&lt;code&gt;isOdd(5)&lt;/code&gt;), but we can also use it as a function type value, e.g. pass it to another function. To do this, we use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">쉽게 직접 호출 할 수 있지만 ( &lt;code&gt;isOdd(5)&lt;/code&gt; ), 함수 유형 값으로 사용할 수도 있습니다 (예 : 다른 함수에 전달). 이를 위해 &lt;code&gt;::&lt;/code&gt; 연산자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ae17c1ca56657ad30866237b96021ef47b3cda29" translate="yes" xml:space="preserve">
          <source>We can explicitly convert a character to an &lt;code&gt;Int&lt;/code&gt; number:</source>
          <target state="translated">문자를 &lt;code&gt;Int&lt;/code&gt; 숫자 로 명시 적으로 변환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d31ec9f07f4bc208cadad8ae2ec0b5f65d7cdf75" translate="yes" xml:space="preserve">
          <source>We can explicitly return a value from the lambda using the &lt;a href=&quot;returns#return-at-labels&quot;&gt;qualified return&lt;/a&gt; syntax. Otherwise, the value of the last expression is implicitly returned.</source>
          <target state="translated">&lt;a href=&quot;returns#return-at-labels&quot;&gt;정규화 된 반환&lt;/a&gt; 구문을 사용하여 람다에서 값을 명시 적으로 반환 할 수 있습니다 . 그렇지 않으면 마지막 표현식의 값이 내재적으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5af6b3dce006afd131588be4e84caa508a65cc20" translate="yes" xml:space="preserve">
          <source>We can import either a single name, e.g.</source>
          <target state="translated">단일 이름을 가져올 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8a9f3b72eb46629a298e0a057eccfdabab01c204" translate="yes" xml:space="preserve">
          <source>We can install &lt;code&gt;kotlinizer&lt;/code&gt; to the default repository:</source>
          <target state="translated">설치할 수있다 &lt;code&gt;kotlinizer&lt;/code&gt; 를 기본 저장소에 :</target>
        </trans-unit>
        <trans-unit id="6d3bad56e3c4235f442b8c993bfc65c9b26cdc43" translate="yes" xml:space="preserve">
          <source>We can now add our first Kotlin source code file and IntelliJ IDEA will prompt us to configure the project for Kotlin. On doing so, we should select as target JavaScript</source>
          <target state="translated">이제 첫 번째 Kotlin 소스 코드 파일을 추가 할 수 있으며 IntelliJ IDEA는 Kotlin에 대한 프로젝트를 구성하라는 메시지를 표시합니다. 이를 위해 대상 JavaScript로 선택해야합니다</target>
        </trans-unit>
        <trans-unit id="dc96081c653c84bb3dd3b5b83bfc524f3cd03b65" translate="yes" xml:space="preserve">
          <source>We can now do this (but it's still possible to call the function the normal way):</source>
          <target state="translated">우리는 이제 이것을 할 수 있습니다 (그러나 정상적인 방법으로 함수를 호출하는 것은 여전히 ​​가능합니다) :</target>
        </trans-unit>
        <trans-unit id="2028680260413907a6ff455452315ba4c9be7fe7" translate="yes" xml:space="preserve">
          <source>We can now start debugging our program. For example, we can set a breakpoint by clicking on one of the line numbers. The developer tools even support setting breakpoints within a statement. As with regular JavaScript code, any set breakpoints will persist across page reloads. This also makes it possible to debug Kotlin's main method which is executed when the script is first loaded.</source>
          <target state="translated">이제 프로그램 디버깅을 시작할 수 있습니다. 예를 들어, 줄 번호 중 하나를 클릭하여 중단 점을 설정할 수 있습니다. 개발자 도구는 문 내에서 중단 점 설정도 지원합니다. 일반 JavaScript 코드와 마찬가지로 설정된 중단 점은 페이지를 다시로드해도 유지됩니다. 이를 통해 스크립트가 처음로드 될 때 실행되는 Kotlin의 기본 메서드를 디버깅 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb97bda68a25be3b25091829fa426075294c2d71" translate="yes" xml:space="preserve">
          <source>We can now use any of the standard Gradle tasks for Spring Boot to run the application. As such, running</source>
          <target state="translated">Spring Boot에 대한 표준 Gradle 작업을 사용하여 응용 프로그램을 실행할 수 있습니다. 따라서, 달리기</target>
        </trans-unit>
        <trans-unit id="c6898463443208b858c46602bd14f4fe18a2e216" translate="yes" xml:space="preserve">
          <source>We can override a non-abstract open member with an abstract one</source>
          <target state="translated">추상적 인 멤버로 비 개방형 멤버를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="443dbeb7b5959da838f042d1c795f241e1156ec7" translate="yes" xml:space="preserve">
          <source>We can replace &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;delay&lt;/a&gt; with &lt;code&gt;Thread.sleep&lt;/code&gt; in the body of &lt;code&gt;simple&lt;/code&gt;'s &lt;code&gt;flow { ... }&lt;/code&gt; and see that the main thread is blocked in this case.</source>
          <target state="translated">우리는 &lt;code&gt;simple&lt;/code&gt; &lt;code&gt;flow { ... }&lt;/code&gt; 의 본문에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html&quot;&gt;지연&lt;/a&gt; 을 &lt;code&gt;Thread.sleep&lt;/code&gt; 으로 대체 할 수 있으며이 경우 메인 스레드가 차단 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec8ade084fb51f7b34b89fae3c572fe0de063884" translate="yes" xml:space="preserve">
          <source>We can run the compiler without parameters to have an interactive shell. We can type any valid Kotlin code and see the results.</source>
          <target state="translated">매개 변수없이 컴파일러를 실행하여 대화식 쉘을 가질 수 있습니다. 유효한 Kotlin 코드를 입력하고 결과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29622b395465874ab1409644634bdf5bd547c3e" translate="yes" xml:space="preserve">
          <source>We can see how the API is created. To start with, we need to initialize the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure. Let's take a look at the latest part of the &lt;code&gt;libnative_api.h&lt;/code&gt; for this:</source>
          <target state="translated">API가 어떻게 생성되는지 확인할 수 있습니다. 우선 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 구조 를 초기화해야합니다 . &lt;code&gt;libnative_api.h&lt;/code&gt; 의 최신 부분을 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="3d6f52d4243822ccee088838c7cbe381743f9a4c" translate="yes" xml:space="preserve">
          <source>We can see the completion cause is not null, because the flow was aborted due to downstream exception:</source>
          <target state="translated">다운 스트림 예외로 인해 흐름이 중단 되었기 때문에 완료 원인이 null이 아님을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d27d56a268fbe45c1d0688c4606abf60011997ba" translate="yes" xml:space="preserve">
          <source>We can simply refer to any class or member function inside our node.js code by simply importing the module using &lt;code&gt;require&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 를 사용하여 간단히 모듈을 가져 와서 node.js 코드 내에서 클래스 또는 멤버 함수를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="831ccd2e7105b549d27fa757caf8f798b465ce95" translate="yes" xml:space="preserve">
          <source>We can simulate custom infix operations by using &lt;a href=&quot;functions#infix-notation&quot;&gt;infix function calls&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#infix-notation&quot;&gt;infix 함수 호출&lt;/a&gt; 을 사용하여 사용자 정의 infix 작업을 시뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="509f912bd5b5b6af65e5240f9ef362cc1a5f0b3f" translate="yes" xml:space="preserve">
          <source>We can start by creating a library file in Kotlin and save it as &lt;code&gt;hello.kt&lt;/code&gt;:</source>
          <target state="translated">Kotlin에서 라이브러리 파일을 &lt;code&gt;hello.kt&lt;/code&gt; 로 저장할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="89f8fe8ceb180f0a0bdf079538aa483abb6121b4" translate="yes" xml:space="preserve">
          <source>We can then do this:</source>
          <target state="translated">그런 다음이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce9fbf3c0deb149f881d772488fa422e85d659ce" translate="yes" xml:space="preserve">
          <source>We can tune how tests are executed in Kotlin/JS by adjusting the settings available in the &lt;code&gt;testTask&lt;/code&gt; block in our &lt;code&gt;build.gradle.kts&lt;/code&gt;. For example, using the Karma test runner together with a headless instance of Chrome and an instance of Firefox looks like this:</source>
          <target state="translated">우리는 테스트가에서 사용할 수있는 설정을 조정하여 코 틀린 / JS에서 실행되는 방법을 조정할 수 &lt;code&gt;testTask&lt;/code&gt; 의 우리의 블록 &lt;code&gt;build.gradle.kts&lt;/code&gt; 을 . 예를 들어, 헤드리스 Chrome 인스턴스 및 Firefox 인스턴스와 함께 Karma 테스트 실행기를 사용하는 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b16a2933e2edce96547337fb1fedcb97e299ea34" translate="yes" xml:space="preserve">
          <source>We can use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;buffer&lt;/a&gt; operator on a flow to run emitting code of the &lt;code&gt;simple&lt;/code&gt; flow concurrently with collecting code, as opposed to running them sequentially:</source>
          <target state="translated">흐름에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html&quot;&gt;버퍼&lt;/a&gt; 연산자를 사용하여 순차적으로 실행하는 대신 &lt;code&gt;simple&lt;/code&gt; 흐름의 생성 코드를 코드 수집과 동시에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67a4cc600951e3a005f1c78d3f5d6ddad7aa6cbe" translate="yes" xml:space="preserve">
          <source>We can use arbitrary expressions (not only constants) as branch conditions</source>
          <target state="translated">상수 조건뿐만 아니라 임의의 표현식을 분기 조건으로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1d0515ada05fe82e395d7a6707b6351170a6e35a" translate="yes" xml:space="preserve">
          <source>We can use classes or functions from a Kotlin project, in our scratches and worksheets.</source>
          <target state="translated">We can use classes or functions from a Kotlin project, in our scratches and worksheets.</target>
        </trans-unit>
        <trans-unit id="8b191724788dd23ede6b8c2149628b7a54092d58" translate="yes" xml:space="preserve">
          <source>We can use explicit conversions to widen numbers</source>
          <target state="translated">숫자를 넓히기 위해 명시적인 변환을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="dfb0038c9e10b5e80574a36666be3c3e86aa4353" translate="yes" xml:space="preserve">
          <source>We collectively refer to &lt;em&gt;Experimental&lt;/em&gt;, &lt;em&gt;Alpha&lt;/em&gt; and &lt;em&gt;Beta&lt;/em&gt; as &lt;strong&gt;pre-stable&lt;/strong&gt; levels.</source>
          <target state="translated">We collectively refer to &lt;em&gt;Experimental&lt;/em&gt;, &lt;em&gt;Alpha&lt;/em&gt; and &lt;em&gt;Beta&lt;/em&gt; as &lt;strong&gt;pre-stable&lt;/strong&gt; levels.</target>
        </trans-unit>
        <trans-unit id="fca14a2211b4e71b478b08b4747bfb20c5dc2a24" translate="yes" xml:space="preserve">
          <source>We continue to explore more C language types and their representation in Kotlin/Native in our other tutorials:</source>
          <target state="translated">우리는 다른 튜토리얼에서 더 많은 C 언어 유형과 Kotlin / Native 표현을 계속 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="51b6f004886664d749f4d2984398143458f52375" translate="yes" xml:space="preserve">
          <source>We could call this using default arguments:</source>
          <target state="translated">기본 인수를 사용하여 이것을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ae10259ccef551da0909b6299a0fa1b0a4f1215" translate="yes" xml:space="preserve">
          <source>We could do a similar thing with contravariant projection by using &lt;code&gt;in&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 을 사용하여 반 변형 투영법과 비슷한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39a9864b239884664ddf63f83dbaeb179ea24a10" translate="yes" xml:space="preserve">
          <source>We could use the same means of synchronization that are applicable to threads (a &lt;code&gt;CountDownLatch&lt;/code&gt; is what crosses my mind in this case), but let's take a safer and cleaner path.</source>
          <target state="translated">스레드에 적용 할 수있는 동일한 동기화 수단을 사용할 수 있지만 (이 경우 &lt;code&gt;CountDownLatch&lt;/code&gt; 가 마음에 들지 않습니다 ) 더 안전하고 깔끔한 경로를 선택하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d12b57fa3f5ee09d20d2af80c6064fa21722785e" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="translated">&lt;a href=&quot;basic-kotlin-native-app#create-gradle-project&quot;&gt;기본 Kotlin / 네이티브 애플리케이션&lt;/a&gt; 튜토리얼 에서 Gradle을 사용하여 IDE 호환 프로젝트를 설정하는 기본 사항을 다루었습니다 . 새로운 Kotlin / Native 프로젝트를 시작하고 IntelliJ IDEA에서 여는 방법에 대한 자세한 첫 번째 단계와 지침을 찾으려면 확인하십시오. 이 튜토리얼에서는 Gradle을 사용한 Kotlin / Native 및 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;멀티 플랫폼&lt;/a&gt; 빌드 의 고급 C interop 관련 사용법을 살펴 봅니다 .</target>
        </trans-unit>
        <trans-unit id="34c7674c59bff58842f8120c227b39dfc459b5e2" translate="yes" xml:space="preserve">
          <source>We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;using-gradle&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</source>
          <target state="translated">We covered the basics of setting up an IDE compatible project with Gradle in the &lt;a href=&quot;using-gradle&quot;&gt;A Basic Kotlin/Native Application&lt;/a&gt; tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;multiplatform&lt;/a&gt; builds with Gradle.</target>
        </trans-unit>
        <trans-unit id="6b1e2f897849388e9b5afd5f5e40ff3ed5d9341c" translate="yes" xml:space="preserve">
          <source>We create &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">다음 내용으로 &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle 빌드 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d792e0e9b2d61d7c507d6ac3c55fb78219ae3d1b" translate="yes" xml:space="preserve">
          <source>We create a &lt;code&gt;lib.h&lt;/code&gt; file to see how C functions are mapped into Kotlin:</source>
          <target state="translated">C 함수가 Kotlin에 어떻게 매핑되는지 확인하기 위해 &lt;code&gt;lib.h&lt;/code&gt; 파일을 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="b48d0f7550a4bac04ad5285d58e805e5af18955b" translate="yes" xml:space="preserve">
          <source>We create a similar implementation file (and missing directories) for the iOS target in the &lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SharedCode/src/iosMain/kotlin/actual.kt&lt;/code&gt; 에서 iOS 대상에 대한 유사한 구현 파일 (및 누락 된 디렉토리)을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="785942d151a588aee24ed9a38ee1d8176b8dc181" translate="yes" xml:space="preserve">
          <source>We create the &lt;code&gt;hello.kt&lt;/code&gt; file with the library contents:</source>
          <target state="translated">라이브러리 내용으로 &lt;code&gt;hello.kt&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fcb050d7cd97c1f800f9df98029b55284f1e77b7" translate="yes" xml:space="preserve">
          <source>We decided to productize this idea, but it hasn't reached the final shape yet.</source>
          <target state="translated">We decided to productize this idea, but it hasn't reached the final shape yet.</target>
        </trans-unit>
        <trans-unit id="a6ed76b8d0d9018634906744837677e15921589b" translate="yes" xml:space="preserve">
          <source>We declare the generic type parameter before the function name for it to be available in the receiver type expression. See &lt;a href=&quot;generics&quot;&gt;Generic functions&lt;/a&gt;.</source>
          <target state="translated">수신자 유형 표현식에서 사용 가능하도록 함수 이름 앞에 일반 유형 매개 변수를 선언합니다. &lt;a href=&quot;generics&quot;&gt;일반 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="908a5325e4c7755c51db166d96c5a188313020b0" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t currently support sharing a source set for these combinations:</source>
          <target state="translated">현재 다음 조합에 대한 소스 세트 공유는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e038eb8a21b3199cc32241632b06a3909918bfe9" translate="yes" xml:space="preserve">
          <source>We don't have to annotate the &lt;code&gt;HTML&lt;/code&gt; or &lt;code&gt;Head&lt;/code&gt; classes with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; because their superclass is already annotated:</source>
          <target state="translated">슈퍼 클래스에 이미 주석이 &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 기 때문에 @HtmlTagMarker로 &lt;code&gt;HTML&lt;/code&gt; 또는 &lt;code&gt;Head&lt;/code&gt; 클래스 에 주석 을 달지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d7e408c93316e02af7f4048c236f0b36f5b8539" translate="yes" xml:space="preserve">
          <source>We encourage you to try out the new Kotlin/JVM backend, which is currently in Alpha, and to file any issues and feature requests to our &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;issue tracker&lt;/a&gt;. This will help us to unify the compiler pipelines and bring compiler extensions like Jetpack Compose to the Kotlin community more quickly.</source>
          <target state="translated">현재 알파 버전 인 새로운 Kotlin / JVM 백엔드를 사용해보고 문제 및 기능 요청을 &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;문제 추적기에&lt;/a&gt; 제출하는 것이 좋습니다. 이를 통해 컴파일러 파이프 라인을 통합하고 Jetpack Compose와 같은 컴파일러 확장을 Kotlin 커뮤니티에 더 빨리 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdd6ede6c8f3bf00110a9f180aa0db3e0e10e52" translate="yes" xml:space="preserve">
          <source>We encourage you to use our new &lt;a href=&quot;#new-jvm-ir-backend&quot;&gt;JVM IR&lt;/a&gt; and &lt;a href=&quot;#new-js-ir-backend&quot;&gt;JS IR&lt;/a&gt; backends, which are currently in Alpha, and share your feedback with us.</source>
          <target state="translated">현재 알파로 제공되는 새로운 &lt;a href=&quot;#new-jvm-ir-backend&quot;&gt;JVM IR&lt;/a&gt; 및 &lt;a href=&quot;#new-js-ir-backend&quot;&gt;JS IR&lt;/a&gt; 백엔드 를 사용하고 피드백을 공유하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8e3df53e494bf93b03698e74de62415d2b98fbd8" translate="yes" xml:space="preserve">
          <source>We evolve the Kotlin Standard Library (kotlin-stdlib) for stable platforms according to the principles stated above. Changes to the contracts for its API undergo the same procedures as changes in the language itself.</source>
          <target state="translated">위에서 언급 한 원칙에 따라 안정적인 플랫폼을 위해 Kotlin 표준 라이브러리 (kotlin-stdlib)를 발전시킵니다. API 계약 변경은 언어 자체의 변경과 동일한 절차를 거칩니다.</target>
        </trans-unit>
        <trans-unit id="a2535fe7404df5a6eb12c3a3917ab80b4135dbff" translate="yes" xml:space="preserve">
          <source>We frequently create classes whose main purpose is to hold data. In such a class some standard functionality and utility functions are often mechanically derivable from the data. In Kotlin, this is called a &lt;em&gt;data class&lt;/em&gt; and is marked as &lt;code&gt;data&lt;/code&gt;:</source>
          <target state="translated">우리는 종종 데이터를 보유하는 것이 주된 목적인 클래스를 만듭니다. 이러한 클래스에서 일부 표준 기능 및 유틸리티 기능은 종종 데이터에서 기계적으로 파생 될 수 있습니다. Kotlin에서는이를 &lt;em&gt;데이터 클래스&lt;/em&gt; 라고하며 &lt;em&gt;data&lt;/em&gt; 로 표시 &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a30f61b55b7b7e943a650a6aabc19b05c3bdf8d" translate="yes" xml:space="preserve">
          <source>We get only numbers up to 3 and a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; after trying to emit number 4:</source>
          <target state="translated">우리는 숫자 4를 내보내려고 시도한 후 3까지의 숫자와 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; 만 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="24aab8ad063fec7c5b2558d6a061d3a136f3a35e" translate="yes" xml:space="preserve">
          <source>We get quite a different output, where a line is printed at each emission from either &lt;code&gt;nums&lt;/code&gt; or &lt;code&gt;strs&lt;/code&gt; flows:</source>
          <target state="translated">&lt;code&gt;nums&lt;/code&gt; 또는 &lt;code&gt;strs&lt;/code&gt; 흐름 에서 방출 될 때마다 선이 인쇄되는 매우 다른 출력을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="5ee091486d809b243b18a19355b403e23f19e065" translate="yes" xml:space="preserve">
          <source>We have significantly reworked the API for JSON serialization to make it more consistent and easier to use. From now on, we'll continue developing the JSON serialization API in a backward-compatible manner. However, if you have used previous versions of it, you'll need to rewrite some of your code when migrating to 1.0.0-RC. To help you with this, we also offer the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md&quot;&gt;Kotlin Serialization Guide&lt;/a&gt; &amp;ndash; the complete set of documentation for &lt;code&gt;kotlinx.serialization&lt;/code&gt;. It will guide you through the process of using the most important features and it can help you address any issues that you might face.</source>
          <target state="translated">보다 일관되고 사용하기 쉽도록 JSON 직렬화 용 API를 대폭 재 작업했습니다. 이제부터는 이전 버전과 호환되는 방식으로 JSON 직렬화 API를 계속 개발할 것입니다. 그러나 이전 버전을 사용한 경우 1.0.0-RC로 마이그레이션 할 때 일부 코드를 다시 작성해야합니다. 이를 돕기 위해 &lt;code&gt;kotlinx.serialization&lt;/code&gt; 에 대한 전체 문서 세트 인 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md&quot;&gt;Kotlin 직렬화 가이드&lt;/a&gt; 도 제공합니다 . 가장 중요한 기능을 사용하는 과정을 안내하고 직면 할 수있는 문제를 해결하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1094efa9f8fd00ffe04a3c7c86c1ceab68f5986d" translate="yes" xml:space="preserve">
          <source>We make sure to document precisely which subcomponents are not stable. We also do our best to warn users where possible and ask to opt in explicitly to avoid accidental usages of features that have not been released as stable.</source>
          <target state="translated">We make sure to document precisely which subcomponents are not stable. We also do our best to warn users where possible and ask to opt in explicitly to avoid accidental usages of features that have not been released as stable.</target>
        </trans-unit>
        <trans-unit id="a128ace07ce2a614969d8901fa6d436be396c723" translate="yes" xml:space="preserve">
          <source>We manage a lifecycle of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that is tied to the lifecycle of our activity. &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as default dispatcher:</source>
          <target state="translated">우리는 활동의 라이프 사이클과 연결된 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; 의 인스턴스를 만들어 코 루틴의 라이프 사이클을 관리합니다 . &lt;code&gt;CoroutineScope&lt;/code&gt; 인스턴스는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope ()&lt;/a&gt; 또는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope ()&lt;/a&gt; 팩토리 함수 로 만들 수 있습니다 . 전자는 범용 범위를 작성하고 후자는 UI 애플리케이션에 대한 범위를 작성하고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatcher.Main&lt;/a&gt; 을 기본 디스패처 로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ccd2d1dce53a36cd421422934713d352fc3aea2f" translate="yes" xml:space="preserve">
          <source>We manage the lifecycles of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; tied to the lifecycle of our activity. A &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates a scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as the default dispatcher:</source>
          <target state="translated">We manage the lifecycles of our coroutines by creating an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; tied to the lifecycle of our activity. A &lt;code&gt;CoroutineScope&lt;/code&gt; instance can be created by the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html&quot;&gt;CoroutineScope()&lt;/a&gt; or &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-scope.html&quot;&gt;MainScope()&lt;/a&gt; factory functions. The former creates a general-purpose scope, while the latter creates a scope for UI applications and uses &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html&quot;&gt;Dispatchers.Main&lt;/a&gt; as the default dispatcher:</target>
        </trans-unit>
        <trans-unit id="b2f8eb551efabdb4e2888f30edf606cbdfff7bc8" translate="yes" xml:space="preserve">
          <source>We may find the whole sources from that tutorial on &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/tutorials/mpp-iOS-Android&quot;&gt;GitHub의&lt;/a&gt; 튜토리얼에서 전체 소스를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="990e3fee35a9a6ae47d7273521920489a64503a8" translate="yes" xml:space="preserve">
          <source>We may include all declarations directly into the &lt;code&gt;.def&lt;/code&gt; file after a &lt;code&gt;---&lt;/code&gt; separator. It can be helpful to include macros or other C defines into the code generated by the &lt;code&gt;cinterop&lt;/code&gt; tool. Method bodies are compiled and fully included into the binary too. Let's use that feature to have a runnable example without a need for a C compiler. To implement that, we need to add implementations to the C functions from the &lt;code&gt;lib.h&lt;/code&gt; file, and place these functions into a &lt;code&gt;.def&lt;/code&gt; file. We will have the following &lt;code&gt;interop.def&lt;/code&gt; result:</source>
          <target state="translated">&lt;code&gt;---&lt;/code&gt; 구분 기호 뒤에 모든 선언을 &lt;code&gt;.def&lt;/code&gt; 파일에 직접 포함시킬 수 있습니다 . &lt;code&gt;cinterop&lt;/code&gt; 도구로 생성 된 코드에 매크로 또는 다른 C 정의를 포함시키는 것이 도움이 될 수 있습니다 . 메소드 본문도 컴파일되어 바이너리에 완전히 포함됩니다. 이 기능을 사용하여 C 컴파일러없이 실행 가능한 예제를 작성해 봅시다. 이를 구현하려면 &lt;code&gt;lib.h&lt;/code&gt; 파일 에서 C 함수에 구현을 추가하고 이러한 함수를 &lt;code&gt;.def&lt;/code&gt; 파일에 배치해야 합니다. 다음 &lt;code&gt;interop.def&lt;/code&gt; 결과 가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="bb703fd0c61569a76d50c3b521794196aa1b8db0" translate="yes" xml:space="preserve">
          <source>We need to assign the &lt;code&gt;id&lt;/code&gt; to the &lt;code&gt;TextView&lt;/code&gt; control of our activity to access it from the code. Let's patch the &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; file (the name may be different if we changed it in the new project wizard) and add several more attributes to the &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">우리는 &lt;code&gt;id&lt;/code&gt; 코드에서 액티비티에 액세스하려면 액티비티 의 &lt;code&gt;TextView&lt;/code&gt; 컨트롤에 id . &lt;code&gt;app/src/main/res/layout/activity_main.xml&lt;/code&gt; 파일을 패치하고 (새 프로젝트 마법사에서 파일을 변경하면 이름이 다를 수 있음) &lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt; 요소 에 몇 가지 속성을 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6b59ffea87e48a8dddabef126cfdaa1e77887d03" translate="yes" xml:space="preserve">
          <source>We need to configure an Xcode project to use our framework. The configuration depends on the target platform.</source>
          <target state="translated">프레임 워크를 사용하려면 Xcode 프로젝트를 구성해야합니다. 구성은 대상 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8c3349f607cc5a810a187a7d773102a89d925fbd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial contains more explanations for that step. Let's assume, we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">머신에 Kotlin 컴파일러가 필요합니다. &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;기초적 코 틀린 응용 프로그램&lt;/a&gt; 튜토리얼은 해당 단계에 대한 자세한 설명이 포함되어 있습니다. &lt;code&gt;kotlinc-native&lt;/code&gt; , &lt;code&gt;cinterop&lt;/code&gt; 및 &lt;code&gt;klib&lt;/code&gt; 명령을 사용할 수 있는 콘솔이 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="027177ad8c50f7e3918b01a86e99731d536a90cd" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial covers that step in details. Let's assume that we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">머신에 Kotlin 컴파일러가 필요합니다. &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;기초적 코 틀린 응용 프로그램&lt;/a&gt; 튜토리얼 커버 세부 단계가. &lt;code&gt;kotlinc-native&lt;/code&gt; , &lt;code&gt;cinterop&lt;/code&gt; 및 &lt;code&gt;klib&lt;/code&gt; 명령을 사용할 수 있는 콘솔이 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="3c043e1a723b8be73d20799e39d49b6268885069" translate="yes" xml:space="preserve">
          <source>We need to have a Kotlin compiler on our machines. The &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;A Basic Kotlin Application&lt;/a&gt; tutorial explains the steps in detail. Let's assume we have a console, where the &lt;code&gt;kotlinc-native&lt;/code&gt;, &lt;code&gt;cinterop&lt;/code&gt;, and &lt;code&gt;klib&lt;/code&gt; commands are available.</source>
          <target state="translated">머신에 Kotlin 컴파일러가 필요합니다. &lt;a href=&quot;basic-kotlin-native-app#obtaining-the-compiler&quot;&gt;기초적 코 틀린 응용 프로그램&lt;/a&gt; 튜토리얼은 세부의 단계를 설명합니다. 콘솔이 있다고 가정 해 봅시다. &lt;code&gt;kotlinc-native&lt;/code&gt; , &lt;code&gt;cinterop&lt;/code&gt; 및 &lt;code&gt;klib&lt;/code&gt; 명령을 사용할 수 .</target>
        </trans-unit>
        <trans-unit id="ab5784dabb9482fdb660b478b956f2503674f995" translate="yes" xml:space="preserve">
          <source>We need to refresh the Gradle Project settings to apply these changes. Click on the &lt;code&gt;Sync Now&lt;/code&gt; link or use the &lt;em&gt;Gradle&lt;/em&gt; tool window and click the refresh action from the context menu on the root Gradle project.</source>
          <target state="translated">이러한 변경 사항을 적용하려면 Gradle Project 설정을 새로 고쳐야합니다. 온 클릭 &lt;code&gt;Sync Now&lt;/code&gt; 링크 또는 사용 &lt;em&gt;Gradle을&lt;/em&gt; 도구 창을 루트 Gradle을 프로젝트에 상황에 맞는 메뉴에서 새로 고침 작업을 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="e0a25a2206a6fb40af56c49d12ab94e8fd653881" translate="yes" xml:space="preserve">
          <source>We need to supply the right Framework out of those four depending on the selected target in the Xcode project. It depends on the target configuration selected in Xcode. Also, we'd like to make Xcode compile the Framework for us before the build. We need to include the additional task to the end of the &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; Gradle file:</source>
          <target state="translated">Xcode 프로젝트에서 선택한 대상에 따라 4 가지 중에서 올바른 프레임 워크를 제공해야합니다. Xcode에서 선택한 대상 구성에 따라 다릅니다. 또한 빌드 전에 Xcode가 Framework를 컴파일하도록 만들고 싶습니다. &lt;code&gt;SharedCode/build.gradle&lt;/code&gt; Gradle 파일 의 끝에 추가 작업을 포함시켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="27d58e7d45f1a7f3fbb5989a56fe0b4132ca9bca" translate="yes" xml:space="preserve">
          <source>We now define the &lt;em&gt;GreetingController&lt;/em&gt; which serves requests of the form &lt;em&gt;/greeting?name={value}&lt;/em&gt; and returns a JSON object representing an instance of &lt;em&gt;Greeting&lt;/em&gt;</source>
          <target state="translated">이제 폼의 요청을 처리 하는 &lt;em&gt;GreetingController&lt;/em&gt; 를 정의합니다.&lt;em&gt;/ greeting? name = {value}&lt;/em&gt; 인스턴스를 나타내는 JSON 객체를 반환하는 &lt;em&gt;GreetingController를 정의합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5172c1ac8d2fad040b4dc376d3d08d8d24a279b3" translate="yes" xml:space="preserve">
          <source>We now have a local variable &lt;code&gt;number&lt;/code&gt; whose value is 42 and whose type is &lt;code&gt;Int&lt;/code&gt; (because that's the type of the literal &lt;code&gt;42&lt;/code&gt;), and another local variable &lt;code&gt;message&lt;/code&gt; whose value is &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; and whose type is &lt;code&gt;String&lt;/code&gt;. Subsequent usages of the variable must use only the name, not &lt;code&gt;var&lt;/code&gt;:</source>
          <target state="translated">이제 값이 42이고 유형이 &lt;code&gt;Int&lt;/code&gt; (리터럴 &lt;code&gt;42&lt;/code&gt; 의 유형이므로) 인 로컬 변수 &lt;code&gt;number&lt;/code&gt; 와 값이 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; 이고 유형이 &lt;code&gt;String&lt;/code&gt; 인 다른 로컬 변수 &lt;code&gt;message&lt;/code&gt; 가 있습니다. 이후의 변수 사용법은 &lt;code&gt;var&lt;/code&gt; 가 아닌 이름 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfb0f090289673dd1e3bce3bdb08b454f3c07da9" translate="yes" xml:space="preserve">
          <source>We now need an HTML page to load the code, so we'll create a file called &lt;code&gt;index.html&lt;/code&gt;. If you want more information on how Kotlin compiles to JavaScript and the output generated, check out the &lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt; tutorial.</source>
          <target state="translated">이제 코드를로드하기 위해 HTML 페이지가 필요하므로 &lt;code&gt;index.html&lt;/code&gt; 이라는 파일을 만듭니다 . Kotlin이 JavaScript로 컴파일하는 방법과 생성 된 출력에 대한 자세한 정보를 보려면 &lt;a href=&quot;../kotlin-to-javascript/kotlin-to-javascript&quot;&gt;Kotlin to JavaScript&lt;/a&gt; 학습서 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ae2c927826795d420c34c1b15ddab31d41644c0" translate="yes" xml:space="preserve">
          <source>We observed that annotating your code almost hasn't changed when you switched to Kotlin. Now let's see what changes should be made to the build script.</source>
          <target state="translated">Kotlin으로 전환해도 코드에 주석을 달아도 거의 변하지 않는 것으로 나타났습니다. 이제 빌드 스크립트를 어떻게 변경해야하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="8ffa6d76c8e1bf7a1c5dd4d42cd1a6d0515ef81b" translate="yes" xml:space="preserve">
          <source>We open Xcode and select &lt;em&gt;Create a new Xcode project&lt;/em&gt; option. In the dialog, we choose the iOS target and select the &lt;em&gt;Single View App&lt;/em&gt;. Fill the next page with defaults, and use the &lt;code&gt;KotlinIOS&lt;/code&gt; (or something else) as the &lt;em&gt;Product Name&lt;/em&gt;. Let's select Swift as the language (it is possible to use Objective-C too). We should instruct Xcode to place the project into the &lt;code&gt;native&lt;/code&gt; folder under our project, later we will use relative paths in the configuration files.</source>
          <target state="translated">Xcode를 열고 &lt;em&gt;새 Xcode 프로젝트 작성&lt;/em&gt; 옵션을 선택 &lt;em&gt;하십시오&lt;/em&gt; . 대화 상자에서 iOS 대상을 선택하고 &lt;em&gt;Single View App을&lt;/em&gt; 선택하십시오 . 다음 페이지를 기본값으로 &lt;code&gt;KotlinIOS&lt;/code&gt; (또는 다른 것)를 &lt;em&gt;제품 이름으로 사용하십시오&lt;/em&gt; . 언어로 Swift를 선택합시다 (Objective-C도 사용 가능). Xcode에 프로젝트를 프로젝트의 &lt;code&gt;native&lt;/code&gt; 폴더에 배치하도록 지시해야 하며 나중에 구성 파일에서 상대 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a2530cc820c7c771c8fc29995c153d4bf24643ea" translate="yes" xml:space="preserve">
          <source>We provide &lt;em&gt;all-open&lt;/em&gt; plugin support both for Gradle and Maven with the complete IDE integration.</source>
          <target state="translated">우리가 제공하다 &lt;em&gt;&lt;/em&gt; 는 완전한 IDE 통합으로 Gradle과 Maven 모두에 대해 &lt;em&gt;개방형&lt;/em&gt; 플러그인 지원을&lt;em&gt; 합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8737e3b3a5c293a6cb9372838dbc9870d668570a" translate="yes" xml:space="preserve">
          <source>We provide the -language-version and -api-version flags that make a new version emulate the behaviour of an old one, for compatibility purposes. Normally, at least one previous version is supported. This effectively leaves a time span of two full feature release cycles for migration (which usually amounts to about two years). Using an older kotlin-stdlib or kotlin-reflect with a newer compiler without specifying compatibility flags is not recommended, and the compiler will report a &lt;a href=&quot;compatibility-modes&quot;&gt;warning&lt;/a&gt; when this happens.</source>
          <target state="translated">호환성을 위해 새 버전이 이전 버전의 동작을 에뮬레이트하는 -language-version 및 -api-version 플래그를 제공합니다. 일반적으로 하나 이상의 이전 버전이 지원됩니다. 이로 인해 마이그레이션을위한 2 개의 전체 기능 릴리스주기 (일반적으로 약 2 년)의 시간 범위가 효과적으로 유지됩니다. 호환성 플래그를 지정하지 않고 최신 컴파일러에서 이전 kotlin-stdlib 또는 kotlin-reflect를 사용하는 것은 권장되지 않으며 컴파일러에서 &lt;a href=&quot;compatibility-modes&quot;&gt;경고&lt;/a&gt; 를보고합니다 이 경우 합니다.</target>
        </trans-unit>
        <trans-unit id="e91c098e8aab839aef30caa8d584e2cae0663d0e" translate="yes" xml:space="preserve">
          <source>We qualified the type parameter with the &lt;code&gt;reified&lt;/code&gt; modifier, now it&amp;rsquo;s accessible inside the function, almost as if it were a normal class. Since the function is inlined, no reflection is needed, normal operators like &lt;code&gt;!is&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt; are working now. Also, we can call it as mentioned above: &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt;.</source>
          <target state="translated">우리는 &lt;code&gt;reified&lt;/code&gt; 수정자를 사용하여 type 매개 변수를 정규화했으며 이제는 거의 일반 클래스처럼 함수 내에서 액세스 할 수 있습니다. 함수가 인라인되어 있기 때문에, 더 반사가 같은 정상적인 운영을 필요하지 않습니다 &lt;code&gt;!is&lt;/code&gt; 와 &lt;code&gt;as&lt;/code&gt; 지금 노력하고 있습니다. 또한 위에서 언급 한대로 호출 할 수 있습니다. &lt;code&gt;myTree.findParentOfType&amp;lt;MyTreeNodeType&amp;gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7840bc09de48b5cc97bf23a9db5d15e17420d9fa" translate="yes" xml:space="preserve">
          <source>We recommend &lt;code&gt;with&lt;/code&gt; for calling functions on the context object without providing the lambda result. In the code, &lt;code&gt;with&lt;/code&gt; can be read as &amp;ldquo;&lt;em&gt;with this object, do the following.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">우리는 추천 &lt;code&gt;with&lt;/code&gt; 람다 결과를 제공하지 않고 상황에 맞는 객체에 함수를 호출합니다. 코드에서 &lt;code&gt;with&lt;/code&gt; 같이 &quot;&lt;em&gt; 이 객체로, 다음을 수행하십시오. &lt;/em&gt;&quot;</target>
        </trans-unit>
        <trans-unit id="ee965fb5c972bf1b84c2210f41280ef6b6a7b02d" translate="yes" xml:space="preserve">
          <source>We recommend that you use expected and actual declarations only for Kotlin declarations that have platform-specific dependencies. It is better to implement as much functionality as possible in the shared module even if doing so takes more time.</source>
          <target state="translated">플랫폼 별 종속성이있는 Kotlin 선언에만 예상 및 실제 선언을 사용하는 것이 좋습니다. 시간이 더 걸리더라도 공유 모듈에서 가능한 한 많은 기능을 구현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="55acd20cd8a96e52ff245292bd60de85bd57b76c" translate="yes" xml:space="preserve">
          <source>We see from these definitions that the Kotlin object &lt;code&gt;Object&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Object&lt;/code&gt;, and &lt;code&gt;Clazz&lt;/code&gt; is mapped into &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt;. Both structs contain nothing but the &lt;code&gt;pinned&lt;/code&gt; field with a pointer, the field type &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is defined as &lt;code&gt;void*&lt;/code&gt; above.</source>
          <target state="translated">우리는 코 틀린 오브젝트 것으로 이러한 정의에서 볼 &lt;code&gt;Object&lt;/code&gt; 에 매핑되는 &lt;code&gt;libnative_kref_example_Object&lt;/code&gt; 하고, &lt;code&gt;Clazz&lt;/code&gt; 로 매핑됩니다 &lt;code&gt;libnative_kref_example_Clazz&lt;/code&gt; . 두 구조체 모두 포인터가 있는 &lt;code&gt;pinned&lt;/code&gt; 필드 외에 아무것도 포함하지 않으며 필드 유형 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 은 위의 &lt;code&gt;void*&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6899aab23e93f36bbb67e40e2a50b9ebcd2d51b" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;cinterop&lt;/code&gt; generated wrapper types for our &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types. For &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; type declarations in C, we have the Kotlin classes &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; generated respectively. The wrappers inherit from the &lt;code&gt;CStructVar&lt;/code&gt; base class and declare all fields as Kotlin properties. It uses &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; to represent a by-value structure parameter and &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; to represent passing a pointer to a structure or a union.</source>
          <target state="translated">&lt;code&gt;cinterop&lt;/code&gt; 이 &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;union&lt;/code&gt; 유형에 대해 래퍼 유형을 생성 한 것을 볼 수 있습니다. 들어 &lt;code&gt;MyStruct&lt;/code&gt; 및 &lt;code&gt;MyUnion&lt;/code&gt; 의 C의 유형 선언, 우리는 코 틀린의 클래스가 &lt;code&gt;MyStruct&lt;/code&gt; 하고 &lt;code&gt;MyUnion&lt;/code&gt; 은 각각 생성. 랩퍼는 &lt;code&gt;CStructVar&lt;/code&gt; 기본 클래스 에서 상속되며 모든 필드를 Kotlin 특성으로 선언합니다. &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 를 사용하여 값별 구조 매개 변수를 나타냅니다. &lt;code&gt;CValuesRef&amp;lt;T&amp;gt;?&lt;/code&gt; 구조체 또는 공용체에 대한 포인터 전달을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f057034bf9d5d678ae656c6371649fbb0395e9c1" translate="yes" xml:space="preserve">
          <source>We see that Kotlin &lt;code&gt;String&lt;/code&gt; and Objective-C &lt;code&gt;NSString*&lt;/code&gt; are mapped transparently. Similarly, &lt;code&gt;Unit&lt;/code&gt; type from Kotlin is mapped to &lt;code&gt;void&lt;/code&gt;. We see primitive types are mapped directly. Non-nullable primitive types are mapped transparently. Nullable primitive types are mapped into &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; types, as shown in the table &lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;above&lt;/a&gt;. Both higher order functions &lt;code&gt;acceptFunF&lt;/code&gt; and &lt;code&gt;supplyFun&lt;/code&gt; are included, and accept Objective-C blocks.</source>
          <target state="translated">Kotlin &lt;code&gt;String&lt;/code&gt; 과 Objective-C &lt;code&gt;NSString*&lt;/code&gt; 이 투명하게 매핑되어 있습니다. 마찬가지로 Kotlin의 &lt;code&gt;Unit&lt;/code&gt; 유형은 &lt;code&gt;void&lt;/code&gt; 로 매핑됩니다 . 프리미티브 유형이 직접 매핑되는 것을 볼 수 있습니다. 널 입력 불가능 기본 유형은 투명하게 맵핑됩니다. &lt;a href=&quot;#kotlin-numbers-and-nsnumber&quot;&gt;위&lt;/a&gt; 의 표에 표시된 것처럼 &lt;code&gt;Kotlin&amp;lt;TYPE&amp;gt;*&lt;/code&gt; 가능 기본 유형은 Kotlin &amp;lt;TYPE&amp;gt; * 유형 으로 맵핑됩니다 . 고차 함수 &lt;code&gt;acceptFunF&lt;/code&gt; 및 &lt;code&gt;supplyFun&lt;/code&gt; 이 모두 포함되며 Objective-C 블록을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="35a16af72746a4a3a02afc71cbee1736ad51d23a" translate="yes" xml:space="preserve">
          <source>We see that our function typedef from C has been turned into Kotlin &lt;code&gt;typealias&lt;/code&gt;. It uses &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; type to represent the pointer parameters, and &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; to represent the function signature. There is an &lt;code&gt;invoke&lt;/code&gt; operator extension function available for all &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; types, so that it is possible to call it as we would call any other function in Kotlin.</source>
          <target state="translated">C의 typedef 함수가 Kotlin &lt;code&gt;typealias&lt;/code&gt; 로 바뀌 었음을 알 수 있습니다. 그것은 사용 &lt;code&gt;CPointer&amp;lt;..&amp;gt;&lt;/code&gt; 포인터 변수를 나타내는 타입 및 &lt;code&gt;CFunction&amp;lt;(Int)-&amp;gt;Int&amp;gt;&lt;/code&gt; 함수 특성을 나타내는. 모든 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 유형에 사용할 수 있는 &lt;code&gt;invoke&lt;/code&gt; 연산자 확장 함수 가 있으므로 Kotlin에서 다른 함수를 호출 할 때 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28a890b04741a752c8a070159a08ecb4fb5a731d" translate="yes" xml:space="preserve">
          <source>We see that while the first number was still being processed the second, and third were already produced, so the second one was &lt;em&gt;conflated&lt;/em&gt; and only the most recent (the third one) was delivered to the collector:</source>
          <target state="translated">첫 번째 번호가 아직 처리되는 동안 두 번째 번호와 세 번째 번호가 이미 생산되었으므로 두 번째 번호가 &lt;em&gt;합쳐&lt;/em&gt; 졌고 가장 최근 번호 (세 번째 번호) 만 수집가에게 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="c2878a9c7f0b432f6ca797d421e5946bffba2e7e" translate="yes" xml:space="preserve">
          <source>We should drag the created build phase to the top of the list</source>
          <target state="translated">생성 된 빌드 단계를 목록의 맨 위로 드래그해야합니다</target>
        </trans-unit>
        <trans-unit id="96dd80304356c421140b6cec43e73736a5d2cf73" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumBy()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="translated">우리는 단순히 모든 코 루틴을 가져 와서 그 결과를 &lt;code&gt;sumBy()&lt;/code&gt; 다음 모든 결과는 표준 라이브러리 함수 sumBy ()에 의해 함께 추가됩니다 . 그러나 컴파일러는 올바르게 불평합니다.</target>
        </trans-unit>
        <trans-unit id="256672724470d83204a91011d31c7585e8e896c2" translate="yes" xml:space="preserve">
          <source>We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumOf()&lt;/code&gt;. But the compiler rightfully complains:</source>
          <target state="translated">We simply take every coroutine and await its result here, then all results are added together by the standard library function &lt;code&gt;sumOf()&lt;/code&gt; . But the compiler rightfully complains:</target>
        </trans-unit>
        <trans-unit id="7d4baf88fc00c2c6a8043a4496a26dfca6b633d7" translate="yes" xml:space="preserve">
          <source>We start with a very simple action that increments a shared mutable variable using multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;.</source>
          <target state="translated">우리는 멀티 스레드를 사용하여 공유 가변 변수를 증가시키는 매우 간단한 조치로 시작합니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt; 디스패처를&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d6e2ee50e438c21fd164031d81fcec588a999b4f" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations as evident from the output of the above main function:</source>
          <target state="translated">위의 주요 기능의 출력에서 ​​알 수 있듯이 두 작업을 동시에 동시에 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d309cfebc83a39f58f865d0bd1891f05f3570150" translate="yes" xml:space="preserve">
          <source>We still have concurrent execution of both operations, as evident from the output of the above &lt;code&gt;main&lt;/code&gt; function:</source>
          <target state="translated">We still have concurrent execution of both operations, as evident from the output of the above &lt;code&gt;main&lt;/code&gt; function:</target>
        </trans-unit>
        <trans-unit id="c7c80eca3836dfb2ec346ec74a1498c04b650629" translate="yes" xml:space="preserve">
          <source>We suggest you try the method &lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines&lt;/a&gt; instead which closes the stream when the processing is complete.</source>
          <target state="translated">&lt;a href=&quot;../java.io.-file/use-lines&quot;&gt;useLines&lt;/a&gt; 메소드를 사용해보십시오.처리가 완료되면 스트림을 닫는 대신 사용하는 .</target>
        </trans-unit>
        <trans-unit id="1f5ae8ba8a817df47cdd30f0d60e67f7842b5f3f" translate="yes" xml:space="preserve">
          <source>We use a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; intermediate operator in this example to delay each element and make the code that emits sample flows more declarative and shorter.</source>
          <target state="translated">이 예제 에서는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; 중간 연산자를 사용하여 각 요소를 지연시키고 샘플 흐름을 내보내는 코드를보다 선언적이고 짧게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d00e20f64ce7aa51453973eb86f6197d3fb8aac0" translate="yes" xml:space="preserve">
          <source>We use a normal sequential invocation, because the code in the coroutine, just like in the regular code, is &lt;em&gt;sequential&lt;/em&gt; by default. The following example demonstrates it by measuring the total time it takes to execute both suspending functions:</source>
          <target state="translated">일반 코드와 마찬가지로 코 루틴 코드는 기본적 &lt;em&gt;으로 순차적&lt;/em&gt; 이기 때문에 정상적인 순차 호출을 사용합니다 . 다음 예는 두 일시 중단 기능을 실행하는 데 걸리는 총 시간을 측정하여이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aadde77016fbc4d33f0abaca395b0e32828abddd" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;import SharedCode&lt;/code&gt; to import our Framework, which we compiled with Kotlin/Native from Kotlin code. Next, we call the Kotlin function from it as &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt;. Follow the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial for more details on the Kotlin/Native to Swift (or Objective-C) interop.</source>
          <target state="translated">&lt;code&gt;import SharedCode&lt;/code&gt; 를 사용하여 Kotlin 코드에서 Kotlin / Native로 컴파일 한 Framework를 가져옵니다. 다음으로 Kotlin 함수를 &lt;code&gt;CommonKt.createApplicationScreenMessage()&lt;/code&gt; 로 호출합니다 . Kotlin / Native to Swift (또는 Objective-C) interop에 대한 자세한 내용은 Kotlin / Native를 &lt;a href=&quot;apple-framework&quot;&gt;Apple 프레임 워크&lt;/a&gt; 튜토리얼 로 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="085b9979a689e14ecd3808ec279a6c3ad33ba2ea" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;staticCFunction{..}&lt;/code&gt; helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It only allows having unbound and non-capturing lambda functions. For example, it is not able to use a local variable from the function. We may only use globally visible declarations. Throwing exceptions from a &lt;code&gt;staticCFunction{..}&lt;/code&gt; will end up in non-deterministic side-effects. It is vital to make sure that we are not throwing any sudden exceptions from it.</source>
          <target state="translated">Kotlin / Native 의 &lt;code&gt;staticCFunction{..}&lt;/code&gt; 도우미 함수를 사용하여 Kotlin 람다 함수를 C 함수 포인터로 래핑합니다. 언 바운드 및 비 캡처 람다 함수 만 허용합니다. 예를 들어, 함수에서 지역 변수를 사용할 수 없습니다. 전 세계적으로 보이는 선언 만 사용할 수 있습니다. &lt;code&gt;staticCFunction{..}&lt;/code&gt; 에서 예외 발생 이지 않은 부작용이 발생합니다. 갑자기 예외가 발생하지 않도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6d750a9144d219b73169d8ec8ee3282a5ce16530" translate="yes" xml:space="preserve">
          <source>We use the condition in the Gradle script to select the target platform for the framework. It is either &lt;code&gt;iOS arm64&lt;/code&gt; or &lt;code&gt;iOS x86_64&lt;/code&gt; depending on environment variables.</source>
          <target state="translated">Gradle 스크립트의 조건을 사용하여 프레임 워크의 대상 플랫폼을 선택합니다. 그것은 다음 중 하나입니다 &lt;code&gt;iOS arm64&lt;/code&gt; 또는 &lt;code&gt;iOS x86_64&lt;/code&gt; 환경 변수에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="87ead7e377be828bc8f924111dcab22679cf1455" translate="yes" xml:space="preserve">
          <source>We use the extension property &lt;code&gt;ptr&lt;/code&gt; which comes from &lt;code&gt;memScoped&lt;/code&gt; lambda receiver type to turn &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; instances into native pointers. Those pointers are only valid inside the &lt;code&gt;memScoped&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;memScoped&lt;/code&gt; lambda 수신자 유형 에서 제공되는 확장 특성 &lt;code&gt;ptr&lt;/code&gt; 을 사용하여 &lt;code&gt;MyStruct&lt;/code&gt; 및 &lt;code&gt;MyUnion&lt;/code&gt; 인스턴스를 기본 포인터로 변환합니다. 해당 포인터는 &lt;code&gt;memScoped&lt;/code&gt; 내에서만 유효합니다 . 블록 .</target>
        </trans-unit>
        <trans-unit id="3d19fb9c3674e9e7d03350ce663d175de7004c2d" translate="yes" xml:space="preserve">
          <source>We will be using &lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt; for the Android part of the tutorial. It is also possible to use &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; Community or Ultimate edition.</source>
          <target state="translated">우리는 튜토리얼의 안드로이드 부분에 &lt;a href=&quot;https://developer.android.com/studio/&quot;&gt;Android Studio&lt;/a&gt; 를 사용할 것 입니다. &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; Community 또는 Ultimate 에디션 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="495de00f60f65274c47ffb67586fe526a49cb4f3" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for the example. You need to make sure you have the latest version of the Kotlin plugin installed, 1.3.x or newer. We select &lt;em&gt;File | New | Project&lt;/em&gt;, select &lt;em&gt;Kotlin | Kotlin (Multiplatform Library)&lt;/em&gt; and configure the project in the way we want.</source>
          <target state="translated">이 예에서는 IntelliJ IDEA Community Edition을 사용합니다. 1.3.x 이상의 최신 버전의 Kotlin 플러그인이 설치되어 있는지 확인해야합니다. 우리는 선택 &lt;em&gt;파일 | 새로운 | 프로젝트&lt;/em&gt; , &lt;em&gt;Kotlin | Kotlin (Multiplatform Library)&lt;/em&gt; 을 사용하여 원하는 방식으로 프로젝트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="9c7906ddfb7d83aa5b930b2241b862ba86c46dd5" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well.</source>
          <target state="translated">이 튜토리얼에서는 IntelliJ IDEA Community Edition을 사용할 예정이지만 Ultimate 버전도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="240e26cd69c673ca5063d1fec6c288458947715f" translate="yes" xml:space="preserve">
          <source>We will be using IntelliJ IDEA Community Edition for this tutorial, though using Ultimate edition is possible as well. The Kotlin plugin 1.3.x or higher should be installed in the IDE. This can be verified via the &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE. Native part of this project is written using Mac OS X, but don't worry if you are using another platform, the platform affects only directory names in this particular tutorial.</source>
          <target state="translated">이 튜토리얼에서는 IntelliJ IDEA Community Edition을 사용하지만 Ultimate Edition도 사용할 수 있습니다. Kotlin 플러그인 1.3.x 이상이 IDE에 설치되어 있어야합니다. 이은을 통해 확인할 수 있습니다 &lt;em&gt;언어 및 프레임 워크 | &lt;/em&gt;IDE 의 &lt;em&gt;설정&lt;/em&gt; (또는 &lt;em&gt;환경 설정&lt;/em&gt; )의 &lt;em&gt;Kotlin 업데이트&lt;/em&gt; 섹션 이 프로젝트의 기본 부분은 Mac OS X을 사용하여 작성되었지만 다른 플랫폼을 사용하더라도 걱정하지 않아도됩니다. 플랫폼은이 특정 튜토리얼에서 디렉토리 이름에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a5df86530b0f4b4eea42ee317054bed9ca2a9e03" translate="yes" xml:space="preserve">
          <source>We will be using the &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; console. We'll see the shortcut to open the console in the start menu. It comes with a Microsoft Visual Studio package.</source>
          <target state="translated">우리는 사용됩니다 &lt;code&gt;x64 Native Tools Command Prompt &amp;lt;VERSION&amp;gt;&lt;/code&gt; 콘솔을. 시작 메뉴에서 콘솔을 여는 바로 가기가 표시됩니다. Microsoft Visual Studio 패키지와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="356ae5746574838fa3924ac6e010e44bd7dc600e" translate="yes" xml:space="preserve">
          <source>We will continue exploring more C language types and their representation in Kotlin/Native in next tutorials:</source>
          <target state="translated">다음 튜토리얼에서는 Kotlin / Native에서 더 많은 C 언어 유형과 그 표현을 계속 탐색 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5797487ddb0eb41e5d2e9c68ced4d766fd86f98" translate="yes" xml:space="preserve">
          <source>We will continue to explore more complicated C language types and their representation in Kotlin/Native in the next tutorials:</source>
          <target state="translated">다음 튜토리얼에서 더 복잡한 C 언어 유형과 Kotlin / Native의 표현을 계속 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cf9027aa102f6f0a5c64a43d077861c549d000f" translate="yes" xml:space="preserve">
          <source>We will cover this functionality with common tests and then publish the final library to Maven.</source>
          <target state="translated">이 기능을 일반적인 테스트로 다룬 다음 최종 라이브러리를 Maven에 게시합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="23c2f2e6b1a14ab9c7e2d8312c7379c2ecdd3c02" translate="yes" xml:space="preserve">
          <source>We will create a simple Kotlin/JavaScript library.</source>
          <target state="translated">간단한 Kotlin / JavaScript 라이브러리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="194f5ab4f85b03618fc04358b4a842a9d1306f59" translate="yes" xml:space="preserve">
          <source>We will then see something similar to this:</source>
          <target state="translated">그러면 이와 비슷한 것을 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a29960a39a18059d04b2735de83331640c538de" translate="yes" xml:space="preserve">
          <source>We would like to emphasize that extension functions are dispatched &lt;strong&gt;statically&lt;/strong&gt;, i.e. they are not virtual by receiver type. This means that the extension function being called is determined by the type of the expression on which the function is invoked, not by the type of the result of evaluating that expression at runtime. For example:</source>
          <target state="translated">우리는 확장 함수가 &lt;strong&gt;정적으로&lt;/strong&gt; 전달된다는 것을 강조하고 싶습니다 . 즉, 그것들은 수신자 유형에 따라 가상적이지 않습니다. 이는 호출되는 확장 함수가 런타임시 해당 표현식을 평가 한 결과의 유형이 아니라 함수가 호출 된 표현식의 유형에 의해 결정됨을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b83946b87080a81db62683de18b3b00c28f7ba2c" translate="yes" xml:space="preserve">
          <source>We wouldn't know if this function would be invoked on only activities from our sources or on plain Java activities also. Because of this, we don&amp;rsquo;t use caching there, even if &lt;code&gt;MyActivity&lt;/code&gt; instance from the previous example is passed as a receiver.</source>
          <target state="translated">우리는이 함수가 소스의 활동에서만 또는 일반 Java 활동에서도 호출되는지 알 수 없습니다. 이 때문에 이전 예제의 &lt;code&gt;MyActivity&lt;/code&gt; 인스턴스가 수신자로 전달 되더라도 캐싱을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="64fbc9430739427e8ecff708c04a32c1ecf8e64f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added a new API to &lt;code&gt;kotlin-reflect&lt;/code&gt; that can be used to enumerate all the direct subtypes of a &lt;code&gt;sealed&lt;/code&gt; class, namely &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kotlin-reflect&lt;/code&gt; 에 새로운 API를 추가하여 &lt;code&gt;sealed&lt;/code&gt; 클래스 의 모든 직접 하위 유형 , 즉 &lt;code&gt;KClass.sealedSubclasses&lt;/code&gt; 를 열거하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8104ed41ba0ad6b8cb42477062cc9a8702abbeec" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve added one more action in IntelliJ IDEA 2020.1 with Gradle 6.0 and above &amp;ndash; &lt;strong&gt;Load Script Configurations&lt;/strong&gt;, which loads changes to the script configurations without updating the whole project. This takes much less time than reimporting the whole project.</source>
          <target state="translated">Gradle 6.0 이상이 설치된 IntelliJ IDEA 2020.1 에 전체 프로젝트를 업데이트하지 않고 스크립트 구성에 대한 변경 사항을로드하는 &lt;strong&gt;Load Script Configurations&lt;/strong&gt; 작업이 하나 더 추가되었습니다 . 전체 프로젝트를 다시 가져 오는 것보다 훨씬 적은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="40438146e777422ec29b09a135f9a4faaaaf0ee2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve reworked how C interop libraries are built. With the new tooling, Kotlin/Native produces interop libraries up to 4 times as fast as before, and artifacts are 25% to 30% the size they used to be.</source>
          <target state="translated">C interop 라이브러리가 빌드되는 방식을 재 작업했습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 새로운 도구를 사용하여 Kotlin / Native는 이전보다 최대 4 배 빠르게 interop 라이브러리를 생성하고 아티팩트는 이전 크기의 25 ~ 30 %입니다.</target>
        </trans-unit>
        <trans-unit id="280290f99293d030e512b76f98e946df19f3aa24" translate="yes" xml:space="preserve">
          <source>We'd start solving it by creating a Kotlin source file with an arbitrary name. &lt;code&gt;A.kt&lt;/code&gt; will do well. First, we need to implement a function specified in the problem statement as:</source>
          <target state="translated">임의의 이름으로 Kotlin 소스 파일을 생성하여 문제를 해결하기 시작했습니다. &lt;code&gt;A.kt&lt;/code&gt; 가 잘 할 것입니다. 먼저, 문제 설명에 지정된 함수를 다음과 같이 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="48dd517a499e14c158e9fa4782184f8188502e0f" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;getting-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA (Ultimate 또는 Community Edition)를 사용합니다. IntelliJ IDEA에서 새 Kotlin 프로젝트를 시작하는 방법을 배우려면 &lt;a href=&quot;getting-started&quot;&gt;IntellJ IDEA 시작하기&lt;/a&gt; 자습서를 참조하십시오 . 빌드 도구를 사용하는 경우 &lt;a href=&quot;build-tools&quot;&gt;빌드 도구&lt;/a&gt; 아래의 해당 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13befb7a01cdbb85144f68b9efce98f561e6a626" translate="yes" xml:space="preserve">
          <source>We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;jvm-get-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</source>
          <target state="translated">We'll be using IntelliJ IDEA (Ultimate or Community edition). To learn how to start a new Kotlin project in IntelliJ IDEA, see the &lt;a href=&quot;jvm-get-started&quot;&gt;Getting Started with IntellJ IDEA&lt;/a&gt; tutorial. If you are using build tools, please see the corresponding entry under &lt;a href=&quot;build-tools&quot;&gt;Build Tools&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1f7aa73d697a63f1be8df9974161860c77d7f65f" translate="yes" xml:space="preserve">
          <source>We'll create a new Android project via &lt;em&gt;Start New Android Project&lt;/em&gt; item. If using IntelliJ IDEA, we need to select &lt;em&gt;Android&lt;/em&gt; in the left panel of the &lt;em&gt;New Project&lt;/em&gt; wizard.</source>
          <target state="translated">&lt;em&gt;Start New Android Project&lt;/em&gt; 항목을 통해 새 Android 프로젝트를 만듭니다 . IntelliJ IDEA를 사용하는 경우 &lt;em&gt;새 프로젝트&lt;/em&gt; 마법사 의 왼쪽 패널 에서 &lt;em&gt;Android&lt;/em&gt; 를 선택해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="adbf109def75db2c462938914849c5eb6eed73eb" translate="yes" xml:space="preserve">
          <source>We'll learn how to:</source>
          <target state="translated">다음과 같은 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="65dfa3289b9a70c638718585acaabd5931d1b082" translate="yes" xml:space="preserve">
          <source>We'll look at &lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt;, &lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt;, &lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt; and &lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlow&lt;/a&gt; (other frameworks can be set up similarly). All these frameworks work through annotation processing: you annotate the code to have the boiler-plate code generated for you. Annotations allow to hide all the verbosity and keep your code simple, and if you need to understand what actually happens at runtime, you can look at the generated code. Note that all these frameworks generate source code in Java, not Kotlin.</source>
          <target state="translated">&lt;a href=&quot;android-frameworks#dagger&quot;&gt;Dagger&lt;/a&gt; , &lt;a href=&quot;android-frameworks#butterknife&quot;&gt;Butterknife&lt;/a&gt; , &lt;a href=&quot;android-frameworks#data-binding&quot;&gt;Data Binding&lt;/a&gt; 및 &lt;a href=&quot;android-frameworks#dbflow&quot;&gt;DBFlow&lt;/a&gt; (다른 프레임 워크도 비슷하게 설정할 수 있음)를 살펴 보겠습니다 . 이러한 모든 프레임 워크는 주석 처리를 통해 작동합니다. 코드에 주석을 달아 보일러 플레이트 코드가 생성되도록합니다. 주석을 사용하면 모든 세부 정보를 숨기고 코드를 간단하게 유지할 수 있으며 런타임시 실제로 발생하는 상황을 이해해야하는 경우 생성 된 코드를 볼 수 있습니다. 이러한 모든 프레임 워크는 Kotlin이 아닌 Java로 소스 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c7ac9f8cb4bffee3deae462c300ad8acc7b22566" translate="yes" xml:space="preserve">
          <source>We'll use the following &lt;code&gt;build.gradle&lt;/code&gt;&lt;code&gt;build.gradle.kts&lt;/code&gt; Gradle build file with the following contents:</source>
          <target state="translated">우리는 다음과 같은 사용합니다 &lt;code&gt;build.gradle&lt;/code&gt; &lt;code&gt;build.gradle.kts&lt;/code&gt; 다음 내용을 Gradle을 빌드 파일을 :</target>
        </trans-unit>
        <trans-unit id="35e9daf2777de53728fdd63d8121926825802dd9" translate="yes" xml:space="preserve">
          <source>We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;boast()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; is a subclass of &lt;code&gt;MotorVehicle&lt;/code&gt;. We're allowed to pass a &lt;code&gt;Car&lt;/code&gt; to &lt;code&gt;ride()&lt;/code&gt; because &lt;code&gt;Car&lt;/code&gt; implements &lt;code&gt;Driveable&lt;/code&gt; (thanks to being a subclass &lt;code&gt;MotorVehicle&lt;/code&gt;). Inside &lt;code&gt;boast()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;MotorVehicle&lt;/code&gt;, even if we're in a situation where we know that it's really a &lt;code&gt;Car&lt;/code&gt; (because there could be other callers that pass a non-&lt;code&gt;Car&lt;/code&gt;). Inside &lt;code&gt;ride()&lt;/code&gt;, we're only allowed to access the members of the declared parameter type &lt;code&gt;Driveable&lt;/code&gt;. This ensures that every member lookup is safe - the compiler only allows you to pass objects that are guaranteed to have the necessary members. The downside is that you will sometimes be forced to declare &quot;unnecessary&quot; interfaces or wrapper classes in order to make a function accept instances of different classes.</source>
          <target state="translated">우리는 통과 할 수있는 &lt;code&gt;Car&lt;/code&gt; 에 &lt;code&gt;boast()&lt;/code&gt; 때문에 &lt;code&gt;Car&lt;/code&gt; 의 서브 클래스 &lt;code&gt;MotorVehicle&lt;/code&gt; 가 . 우리가 통과 할 수있는 &lt;code&gt;Car&lt;/code&gt; 를 &lt;code&gt;ride()&lt;/code&gt; 때문에 &lt;code&gt;Car&lt;/code&gt; 구현 &lt;code&gt;Driveable&lt;/code&gt; (서브 클래스 인 덕분에 &lt;code&gt;MotorVehicle&lt;/code&gt; ). &lt;code&gt;boast()&lt;/code&gt; 내 에서 선언 된 매개 변수 유형 &lt;code&gt;MotorVehicle&lt;/code&gt; 의 멤버에만 액세스 할 수 있습니다. 실제로 &lt;code&gt;Car&lt;/code&gt; 라는 사실을 알고있는 경우에도 (비 &lt;code&gt;Car&lt;/code&gt; 를 전달하는 다른 호출자가있을 수 있기 때문에) ). 내부 &lt;code&gt;ride()&lt;/code&gt; 선언 된 매개 변수 유형 &lt;code&gt;Driveable&lt;/code&gt; 의 멤버에만 액세스 할 수 있습니다 . 이렇게하면 모든 멤버 조회가 안전 해집니다. 컴파일러에서는 필요한 멤버가있는 객체 만 전달할 수 있습니다. 단점은 함수가 다른 클래스의 인스턴스를 허용하도록하기 위해 때때로 &quot;불필요한&quot;인터페이스 또는 랩퍼 클래스를 선언해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a12f1bb4ce7d202790746259d8059bc20b4c1c93" translate="yes" xml:space="preserve">
          <source>We're going to see how to set up TeamCity to build our Kotlin project. For more information and basics of TeamCity please check the &lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;Documentation page&lt;/a&gt; which contains information about installation, basic configuration, etc.</source>
          <target state="translated">Kotlin 프로젝트를 빌드하기 위해 TeamCity를 설정하는 방법을 살펴 보겠습니다. TeamCity에 대한 자세한 정보 및 기본 사항 은 설치, 기본 구성 등에 대한 정보가 포함 된 &lt;a href=&quot;https://www.jetbrains.com/teamcity/documentation/&quot;&gt;문서 페이지&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe8cb673d9e8e417b1ac641d5d52b9b44cf3e8b" translate="yes" xml:space="preserve">
          <source>We're not going to cover the &lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt;&lt;code&gt;when&lt;/code&gt; expression&lt;/a&gt; in depth here since it doesn't have a close equivalent in Python, but check it out - it's pretty nifty, as it lets you compare one expression against many kinds of expressions in a very compact way (but it's not a full functional-programming-style pattern matcher). For example:</source>
          <target state="translated">우리는 숨기려고하지 않을 &lt;a href=&quot;../../reference/control-flow#when-expression&quot;&gt; &lt;code&gt;when&lt;/code&gt; 표현&lt;/a&gt; 이 파이썬에서 가까운 상당을 가지고 있지만 그것을 확인하지 않기 때문에 여기에 깊이를 - 꽤 멋진, 그것은 당신이 매우 컴팩트 한 표현의 많은 종류에 대해 하나 개의 표현을 비교할 수 있습니다로 방법 (그러나 완전한 기능 프로그래밍 스타일 패턴 매처는 아닙니다). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="859b2e88a4b107551034ec5b70f0408cd92fac5e" translate="yes" xml:space="preserve">
          <source>We've also added the &lt;code&gt;ArrayDeque&lt;/code&gt; class &amp;ndash; an implementation of a double-ended queue. Double-ended queue lets you can add or remove elements both at the beginning and the end of the queue in an amortized constant time. You can use a double-ended queue by default when you need a queue or a stack in your code.</source>
          <target state="translated">또한 Double-ended 큐의 구현 인 &lt;code&gt;ArrayDeque&lt;/code&gt; 클래스를 추가했습니다 . 양단 대기열을 사용하면 상각 된 일정 시간 내에 대기열의 시작과 끝에서 요소를 추가하거나 제거 할 수 있습니다. 코드에 대기열이나 스택이 필요한 경우 기본적으로 이중 종료 대기열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6d4821c53a1c0b88e02c8ce15a60335e60fc0a" translate="yes" xml:space="preserve">
          <source>We've converted the ButterKnife &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;sample&lt;/a&gt; to Kotlin. The resulting code can be found &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">ButterKnife &lt;a href=&quot;https://github.com/JakeWharton/butterknife/tree/master/sample/app/src/main/java/com/example&quot;&gt;샘플&lt;/a&gt; 을 Kotlin으로 변환했습니다 . 결과 코드는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-butterknife&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30d2a23216aee2ca42dc00c09139bd8bf210d9fc" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;contains()&lt;/code&gt;, &lt;code&gt;indexOf()&lt;/code&gt;, and &lt;code&gt;lastIndexOf()&lt;/code&gt; extension functions of &lt;code&gt;FloatArray&lt;/code&gt; and &lt;code&gt;DoubleArray&lt;/code&gt; because they use the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt; standard equality, which contradicts the total order equality in some corner cases. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28753&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;FloatArray&lt;/code&gt; 및 &lt;code&gt;DoubleArray&lt;/code&gt; 의 &lt;code&gt;contains()&lt;/code&gt; , &lt;code&gt;indexOf()&lt;/code&gt; 및 &lt;code&gt;lastIndexOf()&lt;/code&gt; 확장 함수 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt; 표준 동등성 을 사용하므로 일부 코너 케이스에서 총 순서 동등성과 모순됩니다. 자세한 내용은 &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-28753&quot;&gt;이 호&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9565458367bc75e7700ec47534de831e4a66b878" translate="yes" xml:space="preserve">
          <source>We've deprecated the &lt;code&gt;min()&lt;/code&gt; and &lt;code&gt;max()&lt;/code&gt; collection functions in favor of &lt;code&gt;minOrNull()&lt;/code&gt; and &lt;code&gt;maxOrNull()&lt;/code&gt;, which more properly reflect their behavior &amp;ndash; returning &lt;code&gt;null&lt;/code&gt; on empty collections. See &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-38854&quot;&gt;this issue&lt;/a&gt; for details.</source>
          <target state="translated">우리는 &lt;code&gt;minOrNull()&lt;/code&gt; 및 &lt;code&gt;maxOrNull()&lt;/code&gt; 위해 &lt;code&gt;min()&lt;/code&gt; 및 &lt;code&gt;max()&lt;/code&gt; 컬렉션 함수를 더 이상 사용하지 않습니다.이 함수는 동작을 더 적절하게 반영합니다 . 빈 컬렉션에서 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다. 자세한 내용은 &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-38854&quot;&gt;이 호&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="215b5a7efdc1c89ee7092df264b96d7d1f704519" translate="yes" xml:space="preserve">
          <source>We've deprecated the functions &lt;code&gt;toShort()&lt;/code&gt; and &lt;code&gt;toByte()&lt;/code&gt; on &lt;code&gt;Double&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; because they could lead to unexpected results because of the narrow value range and smaller variable size.</source>
          <target state="translated">우리는 기능이 사용되지 않는 한 &lt;code&gt;toShort()&lt;/code&gt; 및 &lt;code&gt;toByte()&lt;/code&gt; 에 &lt;code&gt;Double&lt;/code&gt; 과 &lt;code&gt;Float&lt;/code&gt; 가 있기 때문에 좁은 값 범위의 예기치 않은 결과가 작은 변수 크기로 이어질 수 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="61c686dd7fee7d596ed3150966a1df858b5684ea" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">이제 모든 정의를 보았으므로 이제 코드를 수정해야합니다. &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE에서 &lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle 작업 을 실행하거나 다음 명령을 사용하여 코드를 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7303eeb28a81c2ad71ddaf7a7ef26c96a5d46db5" translate="yes" xml:space="preserve">
          <source>We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">We've now seen all the definitions and it is time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</target>
        </trans-unit>
        <trans-unit id="8159d531b6661d9ca1d3ee3cd78cdb26173e7e20" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">우리는 모든 정의를 보았고 이제 코드를 고칠 때입니다. &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE에서 &lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle 작업 을 실행하거나 다음 명령을 사용하여 코드를 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5060dcbe8547bb3d7e1fb6bf0d1175fce384646a" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">We've seen all definitions and it is the time to fix the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in IDE&lt;/a&gt; or use the following command to run the code:</target>
        </trans-unit>
        <trans-unit id="d875c328d56b6ba3de658fff30f901e7a7dadd62" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">우리는 모든 정의를 보았으며 이제 코드를 수정하고 실행할 차례입니다. &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE에서 &lt;/a&gt; &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle 작업 을 실행하거나 다음 명령을 사용하여 코드를 실행 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="6a79043503070152826fab6d2dc8528967704ffa" translate="yes" xml:space="preserve">
          <source>We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</source>
          <target state="translated">We've seen all definitions and it is time to fix and run the code. Let's run the &lt;code&gt;runDebugExecutableNative&lt;/code&gt; Gradle task &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or use the following command to run the code:</target>
        </trans-unit>
        <trans-unit id="a792d756a38347597c27360412bb8f8fa517b753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;AN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 캐릭터 타입 「AN」</target>
        </trans-unit>
        <trans-unit id="24dbecca4697c39dcb12d83d3e21e053a4fbf4ac" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;BN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 캐릭터 타입 「BN」</target>
        </trans-unit>
        <trans-unit id="b592dbfa74287749b5b330052c7e3f462ec0a974" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;CS&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 캐릭터 타입 「CS」</target>
        </trans-unit>
        <trans-unit id="d484194528c4965d5cfe46ac4072c437b4f7364f" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;EN&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 캐릭터 타입 「EN」</target>
        </trans-unit>
        <trans-unit id="73f96fcc50384aeb2e177d07991c8003c66a6753" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ES&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 문자 타입 &quot;ES&quot;</target>
        </trans-unit>
        <trans-unit id="818ef5444e8d72a94e14f04b5d6b122d1830655b" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;ET&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 캐릭터 타입 「ET」</target>
        </trans-unit>
        <trans-unit id="34c6763955af9013896491090181dbcd5a8dd74c" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;NSM&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 캐릭터 타입 「NSM」</target>
        </trans-unit>
        <trans-unit id="956c2a4c465d4b08d54fa1ddb34419c1810351ef" translate="yes" xml:space="preserve">
          <source>Weak bidirectional character type &quot;PDF&quot; in the Unicode specification.</source>
          <target state="translated">Unicode 사양의 약한 쌍방향 캐릭터 타입 「PDF」</target>
        </trans-unit>
        <trans-unit id="5ea903ebda4f9f28f642d78e916dc09051395c95" translate="yes" xml:space="preserve">
          <source>WeakReference</source>
          <target state="translated">WeakReference</target>
        </trans-unit>
        <trans-unit id="051061c35dede06e751f127657cfd8dabc9b47ce" translate="yes" xml:space="preserve">
          <source>WebAssembly</source>
          <target state="translated">WebAssembly</target>
        </trans-unit>
        <trans-unit id="10cf3089a5d1b6f0fd308ab8ea55feb903fcea98" translate="yes" xml:space="preserve">
          <source>WebAssembly (wasm32)</source>
          <target state="translated">웹 어셈블리 (wasm32)</target>
        </trans-unit>
        <trans-unit id="54a290ccb466e5479f81f8b2a84a8c409c89300b" translate="yes" xml:space="preserve">
          <source>WebGLActiveInfo</source>
          <target state="translated">WebGLActiveInfo</target>
        </trans-unit>
        <trans-unit id="e6b73caf842064140299b1ca0b4460e6e2d7b8db" translate="yes" xml:space="preserve">
          <source>WebGLContextAttributes</source>
          <target state="translated">WebGLContextAttributes</target>
        </trans-unit>
        <trans-unit id="4270da2ffdc4cd7b0f031d7be5d3da6756d9f418" translate="yes" xml:space="preserve">
          <source>WebGLContextEventInit</source>
          <target state="translated">WebGLContextEventInit</target>
        </trans-unit>
        <trans-unit id="40e776dc5c04c24ed694e56559baff72c6650985" translate="yes" xml:space="preserve">
          <source>WebGLObject</source>
          <target state="translated">WebGLObject</target>
        </trans-unit>
        <trans-unit id="21ae6cd2acfef9ca69acf1201e1d6a74d9cbc06a" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContext</source>
          <target state="translated">WebGLRenderingContext</target>
        </trans-unit>
        <trans-unit id="4801b56eb1b5d686e9a1febe6821b4d7326421a2" translate="yes" xml:space="preserve">
          <source>WebGLRenderingContextBase</source>
          <target state="translated">WebGLRenderingContextBase</target>
        </trans-unit>
        <trans-unit id="5484abb27b9c8304c0334e77ca1817b8faf244f4" translate="yes" xml:space="preserve">
          <source>WebGLShaderPrecisionFormat</source>
          <target state="translated">WebGLShaderPrecisionFormat</target>
        </trans-unit>
        <trans-unit id="598b5bbd37e1ce6914df736dcaf0620916e3e37e" translate="yes" xml:space="preserve">
          <source>WebGLUniformLocation</source>
          <target state="translated">WebGLUniformLocation</target>
        </trans-unit>
        <trans-unit id="3a3301048780c886766fd5f9fc46f7ed9edce741" translate="yes" xml:space="preserve">
          <source>Webpack provides two different &quot;flavors&quot; of CommonJS, &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, which affect the way your declarations are made available. While in most cases, you probably want &lt;code&gt;commonjs2&lt;/code&gt;, which adds the &lt;code&gt;module.exports&lt;/code&gt; syntax to the generated library, you can also opt for the &quot;pure&quot; &lt;code&gt;commonjs&lt;/code&gt; option, which implements the CommonJS specification exactly. To learn more about the difference between &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt;, check &lt;a href=&quot;https://github.com/webpack/webpack/issues/1114&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Webpack provides two different &quot;flavors&quot; of CommonJS, &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt; , which affect the way your declarations are made available. While in most cases, you probably want &lt;code&gt;commonjs2&lt;/code&gt; , which adds the &lt;code&gt;module.exports&lt;/code&gt; syntax to the generated library, you can also opt for the &quot;pure&quot; &lt;code&gt;commonjs&lt;/code&gt; option, which implements the CommonJS specification exactly. To learn more about the difference between &lt;code&gt;commonjs&lt;/code&gt; and &lt;code&gt;commonjs2&lt;/code&gt; , check &lt;a href=&quot;https://github.com/webpack/webpack/issues/1114&quot;&gt;here&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ee12f5d174e362fdee2c3d0937fed7a0a0418b29" translate="yes" xml:space="preserve">
          <source>What IDEs support Kotlin?</source>
          <target state="translated">Kotlin을 지원하는 IDE는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f19e03186b38de86427a604326b5e20ce36b16e0" translate="yes" xml:space="preserve">
          <source>What Java has that Kotlin does not</source>
          <target state="translated">코 틀린이 가지고 있지 않은 Java</target>
        </trans-unit>
        <trans-unit id="7c25e3810f499ecbecfd573d100c2992ec85dfee" translate="yes" xml:space="preserve">
          <source>What Kotlin has that Java does not</source>
          <target state="translated">Kotlin은 Java가 가지고 있지 않은 것</target>
        </trans-unit>
        <trans-unit id="a0618cd665f03aa3f49f142cd97a9d8c33d6f6d0" translate="yes" xml:space="preserve">
          <source>What advantages does Kotlin give me over the Java programming language?</source>
          <target state="translated">Kotlin은 Java 프로그래밍 언어보다 어떤 이점을 제공합니까?</target>
        </trans-unit>
        <trans-unit id="2ec574e0a3bc1f92310ec6597730108793dbab22" translate="yes" xml:space="preserve">
          <source>What are we building?</source>
          <target state="translated">우리는 무엇을 만들고 있습니까?</target>
        </trans-unit>
        <trans-unit id="54d0e194d6d22dc2c5cc598434a07c74290a1df0" translate="yes" xml:space="preserve">
          <source>What build tools support Kotlin?</source>
          <target state="translated">Kotlin을 지원하는 빌드 도구는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b663cb1b85b44f2ed22f76f75c249fd71cd30ee5" translate="yes" xml:space="preserve">
          <source>What can I use Kotlin for?</source>
          <target state="translated">Kotlin을 무엇에 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1c253aa8f7093e6c010267944ec10ed903d9b3d6" translate="yes" xml:space="preserve">
          <source>What companies are using Kotlin?</source>
          <target state="translated">어떤 회사에서 Kotlin을 사용하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="05e8ab4ca375bf042d9384276202b934420c2059" translate="yes" xml:space="preserve">
          <source>What do we do if need to invoke them &lt;em&gt;sequentially&lt;/em&gt; &amp;ndash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and compute the sum of their results? In practice we do this if we use the results of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="translated">&lt;em&gt;순차적으로&lt;/em&gt; 호출해야하는 경우 어떻게해야합니까 ? 먼저 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; &lt;em&gt;을 수행 한 다음 &lt;/em&gt; &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를 수행하고 결과의 합계를 계산하십시오. 실제로 첫 번째 함수의 결과를 사용하여 두 번째 함수를 호출해야하는지 또는 호출 방법을 결정해야하는지 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ec5e65d31d420634cb6bd22727661d2a91c1e71b" translate="yes" xml:space="preserve">
          <source>What do we do if we need them to be invoked &lt;em&gt;sequentially&lt;/em&gt; &amp;mdash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt;&lt;em&gt;and then&lt;/em&gt;&lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;, and compute the sum of their results? In practice we do this if we use the result of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</source>
          <target state="translated">What do we do if we need them to be invoked &lt;em&gt;sequentially&lt;/em&gt; &amp;mdash; first &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; &lt;em&gt;and then&lt;/em&gt; &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; , and compute the sum of their results? In practice we do this if we use the result of the first function to make a decision on whether we need to invoke the second one or to decide on how to invoke it.</target>
        </trans-unit>
        <trans-unit id="e75dc4fbbde8bc3398e1fc23b66dca3f704f50fe" translate="yes" xml:space="preserve">
          <source>What does Kotlin compile down to?</source>
          <target state="translated">코 틀린은 무엇으로 컴파일합니까?</target>
        </trans-unit>
        <trans-unit id="cbc1b72459c6cd091c4b5fc250725f50ac98c379" translate="yes" xml:space="preserve">
          <source>What does it print at the end? It is highly unlikely to ever print &quot;Counter = 100000&quot;, because a hundred coroutines increment the &lt;code&gt;counter&lt;/code&gt; concurrently from multiple threads without any synchronization.</source>
          <target state="translated">마지막에 무엇을 인쇄합니까? 백 코 루틴이 동기화없이 여러 스레드에서 동시에 &lt;code&gt;counter&lt;/code&gt; 증가시키기 때문에 &quot;카운터 = 100000&quot;을 인쇄 할 가능성이 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="18807a12b7e25a451e442847837857201bfc7505" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results in this kind of code all over the place:</source>
          <target state="translated">What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt; , some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt; . Why? Because it might be performing IO ( &lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt; )&amp;hellip; So it results in this kind of code all over the place:</target>
        </trans-unit>
        <trans-unit id="7f65d1bc84288a4305aabbbfaad8cd7fe25a6b3d" translate="yes" xml:space="preserve">
          <source>What does this signature say? It says that every time I append a string to something (a &lt;code&gt;StringBuilder&lt;/code&gt;, some kind of a log, a console, etc.) I have to catch those &lt;code&gt;IOExceptions&lt;/code&gt;. Why? Because it might be performing IO (&lt;code&gt;Writer&lt;/code&gt; also implements &lt;code&gt;Appendable&lt;/code&gt;)&amp;hellip; So it results into this kind of code all over the place:</source>
          <target state="translated">이 서명은 무엇을 말합니까? 그것은 무언가에 문자열을 추가 할 때마다 ( &lt;code&gt;StringBuilder&lt;/code&gt; , 일종의 로그, 콘솔 등) &lt;code&gt;IOExceptions&lt;/code&gt; 를 잡아야 한다고 말합니다 . 왜? IO를 수행 중일 수 있기 때문에 ( &lt;code&gt;Writer&lt;/code&gt; 는 &lt;code&gt;Appendable&lt;/code&gt; 도 구현합니다. ) 따라서 다음과 같은 종류의 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="683b8d36e158b49d7282ac38785e02d0ec00e146" translate="yes" xml:space="preserve">
          <source>What happens if multiple children of a coroutine throw an exception? The general rule is &quot;the first exception wins&quot;, so the first thrown exception is exposed to the handler. But that may cause lost exceptions, for example if coroutine throws an exception in its &lt;code&gt;finally&lt;/code&gt; block. So, additional exceptions are suppressed.</source>
          <target state="translated">코 루틴의 여러 자녀가 ​​예외를 던지면 어떻게됩니까? 일반적인 규칙은 &quot;첫 번째 예외 승리&quot;이므로 첫 번째 예외는 처리기에 노출됩니다. 그러나 코 루틴이 &lt;code&gt;finally&lt;/code&gt; 블록에 예외를 던지는 경우와 같이 예외가 손실 될 수 있습니다 . 따라서 추가 예외가 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="365b6a79e0879610a6d21849bc8cc5cf6d51d197" translate="yes" xml:space="preserve">
          <source>What has happened here is called &lt;strong&gt;type projection&lt;/strong&gt;: we said that &lt;code&gt;from&lt;/code&gt; is not simply an array, but a restricted (&lt;strong&gt;projected&lt;/strong&gt;) one: we can only call those methods that return the type parameter &lt;code&gt;T&lt;/code&gt;, in this case it means that we can only call &lt;code&gt;get()&lt;/code&gt;. This is our approach to &lt;strong&gt;use-site variance&lt;/strong&gt;, and corresponds to Java's &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, but in a slightly simpler way.</source>
          <target state="translated">여기서 발생한 것은 &lt;strong&gt;타입 프로젝션&lt;/strong&gt; 이라고 &lt;strong&gt;합니다&lt;/strong&gt; . 우리는 &lt;code&gt;from&lt;/code&gt; 단순히 배열이 아니라 제한된 ( &lt;strong&gt;투사 된&lt;/strong&gt; ) 배열 이라고 말했습니다 : 우리는 타입 매개 변수 &lt;code&gt;T&lt;/code&gt; 를 반환하는 메소드 만 호출 할 수 있습니다. &lt;code&gt;get()&lt;/code&gt; . 이것은 &lt;strong&gt;use-site variance에&lt;/strong&gt; 대한 우리의 접근 방식 이며 Java의 &lt;code&gt;Array&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 하지만 약간 더 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="77aa02de8be96f4d1a2d486916d80f88707bf2e0" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocation of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="translated">어떤이의 호출 사이에 종속성이없는 경우 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 및 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 은 우리가 모두 수행하여, 빠른 답변을 얻을하려는 &lt;em&gt;동시에&lt;/em&gt; ? 여기서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 가 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9d26c1d8e7803f441abc75ddaa9a3cb6ee5810" translate="yes" xml:space="preserve">
          <source>What if there are no dependencies between invocations of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</source>
          <target state="translated">What if there are no dependencies between invocations of &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and we want to get the answer faster, by doing both &lt;em&gt;concurrently&lt;/em&gt;? This is where &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; comes to help.</target>
        </trans-unit>
        <trans-unit id="e3c61df73a1cd1792c66d92381a767d6d084db44" translate="yes" xml:space="preserve">
          <source>What is Kotlin?</source>
          <target state="translated">코 틀린은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9c97b9a8111f68ce8c52dfe8c2a3959e4d0cfd92" translate="yes" xml:space="preserve">
          <source>What is the current version of Kotlin?</source>
          <target state="translated">코 틀린의 현재 버전은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="72b9dc537736b5c80161df96b96d566c2340d8ed" translate="yes" xml:space="preserve">
          <source>What types do we have in the C language? Let's first list all of them. I have used the &lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;C data types&lt;/a&gt; article from Wikipedia as a basis. There are following types in the C programming language:</source>
          <target state="translated">C 언어에는 어떤 유형이 있습니까? 먼저 모든 것을 나열합시다. Wikipedia 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/C_data_types&quot;&gt;C 데이터 형식&lt;/a&gt; 기사를 기본으로 사용했습니다. C 프로그래밍 언어에는 다음과 같은 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a3d061e51769639781e9a3b9954e0ba115ec4b" translate="yes" xml:space="preserve">
          <source>What we actually want is simply pass a type to this function, i.e. call it like this:</source>
          <target state="translated">실제로 원하는 것은 단순히이 함수에 타입을 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a50c7ef1f0fafc2256df6585bc99119f3c512a67" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.1</source>
          <target state="translated">Kotlin 1.1의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="9a4d9d06c26d113727033d8ae4c1b63e386642d5" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.2</source>
          <target state="translated">Kotlin 1.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="293419c5954282d33701ae5e04016a88fddb332a" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New in Kotlin 1.3</source>
          <target state="translated">Kotlin 1.3의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="9389cd373bffcc015f87751d1dc27567fa32b8ba" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.1</source>
          <target state="translated">Kotlin 1.1의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="39982142e8f2af3375fc2ff57e8c12a82c314d40" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.2</source>
          <target state="translated">Kotlin 1.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="215e0c6f310ade62568bdc051de3a2c9b6801880" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.3</source>
          <target state="translated">Kotlin 1.3의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="5d9f851e585b75f9f88496923e3d47ca44295647" translate="yes" xml:space="preserve">
          <source>What's New in Kotlin 1.4.0</source>
          <target state="translated">Kotlin 1.4.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="3d4b36bc57457b9920995102b0eb6da42363fb68" translate="yes" xml:space="preserve">
          <source>What's next?</source>
          <target state="translated">무엇 향후 계획?</target>
        </trans-unit>
        <trans-unit id="18389155bba5ed3245c0f065f5a1c5b22a9f917a" translate="yes" xml:space="preserve">
          <source>Whatever way you choose to solve koans, you can see the solution for each task: in the online version click on &quot;Show answer&quot;, inside EduTools plugin choose &quot;Peek solution&quot;. We recommend checking the solution after you implement the task to compare your solution with the proposed one. Make sure you don't cheat!</source>
          <target state="translated">koan을 해결하기 위해 어떤 방법을 선택하든 각 작업에 대한 솔루션을 볼 수 있습니다. 온라인 버전에서 &quot;응답 표시&quot;를 클릭하고 EduTools 플러그인 내에서 &quot;Peek solution&quot;을 선택하십시오. 작업을 구현 한 후 솔루션을 제안 된 솔루션과 비교하기 위해 솔루션을 확인하는 것이 좋습니다. 당신이 속이지 않는지 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="00a0667e561fb370ec041d741f3ea97adc25dc28" translate="yes" xml:space="preserve">
          <source>WheelEventInit</source>
          <target state="translated">WheelEventInit</target>
        </trans-unit>
        <trans-unit id="e3117f509259d5d29ab1ad441436b902cca8f031" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="translated">때 &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Foverwrite&quot;&gt;덮어 쓰기가&lt;/a&gt; 인 &lt;code&gt;true&lt;/code&gt; 및 &lt;a href=&quot;copy-to#kotlin.io%24copyTo%28java.io.File%2C+java.io.File%2C+kotlin.Boolean%2C+kotlin.Int%29%2Ftarget&quot;&gt;대상&lt;/a&gt; 디렉토리입니다, 비어있는 경우에만 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f0d8a684192ba53b6aed7c801b9b7ef648714954" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</source>
          <target state="translated">When &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/overwrite&quot;&gt;overwrite&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;a href=&quot;copy-to#kotlin.io%24copyTo(java.io.File,%20java.io.File,%20kotlin.Boolean,%20kotlin.Int)/target&quot;&gt;target&lt;/a&gt; is a directory, it is replaced only if it is empty.</target>
        </trans-unit>
        <trans-unit id="2d29ca92f5092a739732a54c47f3da4e556b36a7" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;mpp-create-lib&quot;&gt;creating a project with the Project Wizard&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mpp-create-lib&quot;&gt;프로젝트 마법사로 프로젝트를 생성&lt;/a&gt; 할 때 .</target>
        </trans-unit>
        <trans-unit id="9f50fe0838c0d3908e85b9819f34dd2e3eeee8c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="translated">When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</target>
        </trans-unit>
        <trans-unit id="44dcaec5d16f5bf398df957b0d47d8f09a80f320" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;launch { ... }&lt;/code&gt; is used without parameters, it inherits the context (and thus dispatcher) from the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; that it is being launched from. In this case, it inherits the context of the main &lt;code&gt;runBlocking&lt;/code&gt; coroutine which runs in the &lt;code&gt;main&lt;/code&gt; thread.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 을 매개 변수없이 사용 하면 시작 되는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; 에서 컨텍스트 (및 디스패처)를 상속합니다 . 이 경우 &lt;code&gt;main&lt;/code&gt; 스레드 에서 실행되는 메인 &lt;code&gt;runBlocking&lt;/code&gt; 코 루틴 의 컨텍스트를 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="a67ed24b676d6021025f2b0f67bd9c35fd94aa47" translate="yes" xml:space="preserve">
          <source>When Expression</source>
          <target state="translated">표현할 때</target>
        </trans-unit>
        <trans-unit id="e8a56a195bc479e7e07a6420a30ef594182bfdc7" translate="yes" xml:space="preserve">
          <source>When Java types are imported into Kotlin, all the references of the type &lt;code&gt;java.lang.Object&lt;/code&gt; are turned into &lt;code&gt;Any&lt;/code&gt;. Since &lt;code&gt;Any&lt;/code&gt; is not platform-specific, it only declares &lt;code&gt;toString()&lt;/code&gt;, &lt;code&gt;hashCode()&lt;/code&gt; and &lt;code&gt;equals()&lt;/code&gt; as its members, so to make other members of &lt;code&gt;java.lang.Object&lt;/code&gt; available, Kotlin uses &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;.</source>
          <target state="translated">자바 유형이 코 틀린에 가져 오면, 유형의 모든 참조 &lt;code&gt;java.lang.Object&lt;/code&gt; 상위 로 설정되어 &lt;code&gt;Any&lt;/code&gt; . &lt;code&gt;Any&lt;/code&gt; 는 플랫폼별로 다르지 않기 때문에 &lt;code&gt;toString()&lt;/code&gt; , &lt;code&gt;hashCode()&lt;/code&gt; 및 &lt;code&gt;equals()&lt;/code&gt; 만 멤버로 선언 하므로 &lt;code&gt;java.lang.Object&lt;/code&gt; 의 다른 멤버를 사용할 수 있도록 Kotlin은 &lt;a href=&quot;extensions&quot;&gt;확장 함수를&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="de657bff6abe90a927125239467dfc7f66aa4d06" translate="yes" xml:space="preserve">
          <source>When Kotlin classes make use of &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;declaration-site variance&lt;/a&gt;, there are two options of how their usages are seen from the Java code. Let's say we have the following class and two functions that use it:</source>
          <target state="translated">Kotlin 클래스가 &lt;a href=&quot;generics#declaration-site-variance&quot;&gt;declaration-site variance를&lt;/a&gt; 사용할 때 Java 코드에서 사용법을 보는 방법에는 두 가지 옵션이 있습니다. 다음 클래스와이를 사용하는 두 가지 함수가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="752a77d62b6432105ad9d079610666a77a3a539f" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;a href=&quot;exception-classes#kotlin.Throws%24exceptionClasses&quot;&gt;exceptionClasses&lt;/a&gt; or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="translated">Swift / Objective-C 코드에서 호출 된 Kotlin 함수가 &lt;a href=&quot;exception-classes#kotlin.Throws%24exceptionClasses&quot;&gt;exceptionClasses&lt;/a&gt; 또는 해당 하위 클래스 중 하나의 인스턴스 인 예외를 throw하면 &lt;code&gt;NSError&lt;/code&gt; 로 전파됩니다 . Swift / Objective-C에 도달하는 다른 Kotlin 예외는 처리되지 않은 것으로 간주되어 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8df342c27a1154aea786d8fd951c9e3bea894932" translate="yes" xml:space="preserve">
          <source>When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;code&gt;@Throws&lt;/code&gt;-specified classes or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt;. Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</source>
          <target state="translated">When Kotlin function called from Swift/Objective-C code throws an exception which is an instance of one of the &lt;code&gt;@Throws&lt;/code&gt; -specified classes or their subclasses, it is propagated as &lt;code&gt;NSError&lt;/code&gt; . Other Kotlin exceptions reaching Swift/Objective-C are considered unhandled and cause program termination.</target>
        </trans-unit>
        <trans-unit id="32316c9a35a40c6afef037fd3a597555044f54d5" translate="yes" xml:space="preserve">
          <source>When a C function takes or returns a struct / union &lt;code&gt;T&lt;/code&gt; by value, the corresponding argument type or return type is represented as &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">C 함수가 struct / union &lt;code&gt;T&lt;/code&gt; 를 값으로 가져 오거나 반환 하면 해당 인수 유형 또는 반환 유형이 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="dbdcfd2e9efefb419f2bd9e89cb02a695c22cf07" translate="yes" xml:space="preserve">
          <source>When a big team is migrating onto a new version, it may appear in a &quot;inconsistent state&quot; at some point, when some developers have already updated, and others haven't. To prevent the former from writing and committing code that others may not be able to compile, we provide the following command line switches (also available in the IDE and &lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt;/&lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven&lt;/a&gt;):</source>
          <target state="translated">대규모 팀이 새 버전으로 마이그레이션하는 경우 일부 개발자가 이미 업데이트했지만 다른 개발자가 아직 업데이트하지 않은 시점에서 &quot;일관되지 않은 상태&quot;로 나타날 수 있습니다. 전자가 다른 사람이 컴파일 할 수없는 코드를 작성하고 커밋하지 못하도록하기 위해 다음 명령 줄 스위치를 제공합니다 (IDE 및 &lt;a href=&quot;../using-gradle#compiler-options&quot;&gt;Gradle&lt;/a&gt; / &lt;a href=&quot;../using-maven#specifying-compiler-options&quot;&gt;Maven&lt;/a&gt; 에서도 사용 가능 ).</target>
        </trans-unit>
        <trans-unit id="18b8e63399abd55d3bbbdde25d3e2fcb80bd3160" translate="yes" xml:space="preserve">
          <source>When a coroutine is launched in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; of another coroutine, it inherits its context via &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt; and the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; of the new coroutine becomes a &lt;em&gt;child&lt;/em&gt; of the parent coroutine's job. When the parent coroutine is cancelled, all its children are recursively cancelled, too.</source>
          <target state="translated">코 루틴이 출시되면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; 다른 코 루틴의, 그것은을 통해 문맥을 상속 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/coroutine-context.html&quot;&gt;CoroutineScope.coroutineContext&lt;/a&gt; 과 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업&lt;/a&gt; 새로운 코 루틴의가 될 &lt;em&gt;아이&lt;/em&gt; 부모 코 루틴의 작업. 부모 코 루틴이 취소되면 모든 하위 항목도 재귀 적으로 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="8b40f9ca947a81bd12ef472c030664610317efac" translate="yes" xml:space="preserve">
          <source>When a data class derived from a type that already had the &lt;code&gt;copy&lt;/code&gt; function with the same signature, the &lt;code&gt;copy&lt;/code&gt; implementation generated for the data class used the defaults from the supertype, leading to counter-intuitive behavior, or failed at runtime if there were no default parameters in the supertype.</source>
          <target state="translated">동일한 서명을 가진 &lt;code&gt;copy&lt;/code&gt; 기능 이있는 유형에서 파생 된 데이터 클래스가 데이터 클래스에 대해 생성 된 &lt;code&gt;copy&lt;/code&gt; 구현에서 수퍼 유형의 기본값을 사용하여 반 직관적 인 동작이 발생하거나 기본값이없는 경우 런타임에 실패했습니다. 수퍼 타입의 매개 변수.</target>
        </trans-unit>
        <trans-unit id="e1f3667f48b1b3a74567f895c3f805750be29c9e" translate="yes" xml:space="preserve">
          <source>When a declaration has &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to project's static resources and include via &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; element. To tell Kotlin that it's ok to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from non-module environment, you should put &lt;code&gt;@JsNonModule&lt;/code&gt; declaration. For example, given JavaScript code:</source>
          <target state="translated">선언에 &lt;code&gt;@JsModule&lt;/code&gt; 이 있으면 JavaScript 모듈로 컴파일하지 않으면 Kotlin 코드에서 사용할 수 없습니다. 일반적으로 개발자는 라이브러리를 JavaScript 모듈과 다운로드 가능한 &lt;code&gt;.js&lt;/code&gt; 파일 로 배포 하여 프로젝트의 정적 리소스에 복사하고 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 요소 를 통해 포함시킬 수 있습니다 . Kotlin에 비 모듈 환경에서 &lt;code&gt;@JsModule&lt;/code&gt; 선언 을 사용하는 것이 좋다고 알리 려면 &lt;code&gt;@JsNonModule&lt;/code&gt; 선언을 넣어야 합니다. 예를 들어, 주어진 JavaScript 코드는 :</target>
        </trans-unit>
        <trans-unit id="cdc056f54b314225b42eb84b111e0f374e0f43fb" translate="yes" xml:space="preserve">
          <source>When a declaration is marked as &lt;code&gt;@JsModule&lt;/code&gt;, you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to your project's static resources and include via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. To tell Kotlin that it's okay to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from a non-module environment, add the &lt;code&gt;@JsNonModule&lt;/code&gt; annotation. For example, consider the following JavaScript code:</source>
          <target state="translated">When a declaration is marked as &lt;code&gt;@JsModule&lt;/code&gt; , you can't use it from Kotlin code when you don't compile it to a JavaScript module. Usually, developers distribute their libraries both as JavaScript modules and downloadable &lt;code&gt;.js&lt;/code&gt; files that you can copy to your project's static resources and include via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag. To tell Kotlin that it's okay to use a &lt;code&gt;@JsModule&lt;/code&gt; declaration from a non-module environment, add the &lt;code&gt;@JsNonModule&lt;/code&gt; annotation. For example, consider the following JavaScript code:</target>
        </trans-unit>
        <trans-unit id="6b2a92ee663b6eefd13c4799f36aa168f8eb6c67" translate="yes" xml:space="preserve">
          <source>When a flow represents partial results of the operation or operation status updates, it may not be necessary to process each value, but instead, only most recent ones. In this case, the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;conflate&lt;/a&gt; operator can be used to skip intermediate values when a collector is too slow to process them. Building on the previous example:</source>
          <target state="translated">흐름이 작업 또는 작업 상태 업데이트의 일부 결과를 나타내는 경우 각 값을 처리 할 필요가 없으며 대신 가장 최근 값만 처리 할 수 ​​있습니다. 이 경우 컬렉터가 너무 느려서 처리 할 수없는 중간 값을 건너 뛰기 위해 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html&quot;&gt;conflate&lt;/a&gt; 연산자를 사용할 수 있습니다. 이전 예제를 기반으로 작성 :</target>
        </trans-unit>
        <trans-unit id="06eb4fdaeb1116ee0773fa0c7742573f91abd273" translate="yes" xml:space="preserve">
          <source>When a function is called with both positional and named arguments, all the positional arguments should be placed before the first named one. For example, the call &lt;code&gt;f(1, y = 2)&lt;/code&gt; is allowed, but &lt;code&gt;f(x = 1, 2)&lt;/code&gt; is not.</source>
          <target state="translated">위치 인수와 명명 된 인수가 모두있는 함수를 호출하면 모든 위치 인수가 첫 번째 명명 된 인수 앞에 배치되어야합니다. 예를 들어, 호출 &lt;code&gt;f(1, y = 2)&lt;/code&gt; 는 허용되지만 &lt;code&gt;f(x = 1, 2)&lt;/code&gt; 는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c39ba3c630d6c34d1a8dfc3a61b0e9ace62da655" translate="yes" xml:space="preserve">
          <source>When a function of an external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="translated">When a function of an external base class is overloaded by signature, you can't override it in a derived class.</target>
        </trans-unit>
        <trans-unit id="f0551e05b4cdcabc413ed022b08af90ba98955ec" translate="yes" xml:space="preserve">
          <source>When a function of external base class is overloaded by signature, you can't override it in a derived class.</source>
          <target state="translated">외부 기본 클래스의 함수에 서명이 오버로드되면 파생 클래스에서이를 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cc5a0d8a7f78114a2ac1e09f9cb178d1a485871" translate="yes" xml:space="preserve">
          <source>When a function returns a single expression, the curly braces can be omitted and the body is specified after a &lt;strong&gt;=&lt;/strong&gt; symbol:</source>
          <target state="translated">함수가 단일 표현식을 반환하면 중괄호를 생략하고 본문은 &lt;strong&gt;=&lt;/strong&gt; 기호 뒤에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d60c7b0c4e08585362731f2e3c9cea8a0422110" translate="yes" xml:space="preserve">
          <source>When a variable is assigned from a safe call expression and checked for null, the smart cast is now applied to the safe call receiver as well:</source>
          <target state="translated">안전한 통화 식에서 변수를 할당하고 null을 확인하면 이제 스마트 캐스트가 안전한 통화 수신자에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="75ac04198276b2032c15af24079f880bbc7d4548" translate="yes" xml:space="preserve">
          <source>When an abstract class implements one or more interfaces, it is not required to provide definitions of the members of its interfaces (but it can if it wants to). It must still &lt;em&gt;declare&lt;/em&gt; such members, using &lt;code&gt;abstract override&lt;/code&gt; and not providing any body for the function or property:</source>
          <target state="translated">추상 클래스가 하나 이상의 인터페이스를 구현할 때 인터페이스 멤버의 정의를 제공 할 필요는 없지만 원하는 경우 가능합니다. 여전히 &lt;code&gt;abstract override&lt;/code&gt; 사용 하고 함수 또는 속성에 본문을 제공하지 않고 이러한 멤버를 &lt;em&gt;선언&lt;/em&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78ca79aa88621d9e1ad1b6380be2be6eed3fd311" translate="yes" xml:space="preserve">
          <source>When an equality check operands are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; (nullable or not), the check follows the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">동등성 검사 피연산자가 정적으로 &lt;code&gt;Float&lt;/code&gt; 또는 &lt;code&gt;Double&lt;/code&gt; (널링 가능 여부) 인 경우, 검사는 IEEE 754 부동 소수점 산술 표준을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="a72bfaeeae8d98102d2bd16c961c912a01957df4" translate="yes" xml:space="preserve">
          <source>When an inline function is &lt;code&gt;public&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt; and is not a part of a &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;internal&lt;/code&gt; declaration, it is considered a &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;module&lt;/a&gt;'s public API. It can be called in other modules and is inlined at such call sites as well.</source>
          <target state="translated">인라인 함수가 &lt;code&gt;public&lt;/code&gt; 이거나 &lt;code&gt;protected&lt;/code&gt; 되어 있고 &lt;code&gt;private&lt;/code&gt; 또는 &lt;code&gt;internal&lt;/code&gt; 선언 의 일부가 아닌 경우 &lt;a href=&quot;visibility-modifiers#modules&quot;&gt;모듈&lt;/a&gt; 의 공용 API로 간주 됩니다. 다른 모듈에서 호출 할 수 있으며 이러한 호출 사이트에서도 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="a8b8b82c3468010f3b6d8941f07253746e1af976" translate="yes" xml:space="preserve">
          <source>When an instance of a subclass is constructed, the superclass &quot;part&quot; is constructed first (via the superclass constructor). This means that during execution of the constructor of an open class, it could be that the object being constructed is an instance of a subclass, in which case the subclass-specific properties have not been initialized yet. For that reason, calling an open function from a constructor is risky: it might be overridden in the subclass, and if it is accessing subclass-specific properties, those won't be initialized yet.</source>
          <target state="translated">서브 클래스의 인스턴스가 생성 될 때, 수퍼 클래스 &quot;part&quot;가 (수퍼 클래스 생성자를 통해) 먼저 생성됩니다. 이것은 오픈 클래스의 생성자를 실행하는 동안 생성되는 객체가 서브 클래스의 인스턴스 일 수 있으며,이 경우 서브 클래스 별 특성이 아직 초기화되지 않았 음을 의미합니다. 따라서 생성자에서 열린 함수를 호출하는 것은 위험합니다. 서브 클래스에서 재정의 될 수 있으며 서브 클래스 특정 속성에 액세스하는 경우 아직 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b0f246d38c7c57581718b09879ae1a9f3dd0cfb" translate="yes" xml:space="preserve">
          <source>When applied to a class or a member with internal visibility allows to use it from public inline functions and makes it effectively public.</source>
          <target state="translated">클래스 또는 내부 가시성이있는 멤버에 적용되면 공용 인라인 함수에서 클래스를 사용하고 효과적으로 공개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2719f8cfa129fbdd0adc701d2dba400cfb7a4df" translate="yes" xml:space="preserve">
          <source>When applied to annotation class X specifies that X defines a DSL language</source>
          <target state="translated">주석 클래스 X에 적용될 때 X가 DSL 언어를 정의하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4383cdeb336d893261a8fd71ba6fa7f60d10ca1e" translate="yes" xml:space="preserve">
          <source>When applied, the CocoaPods plugin does the following:</source>
          <target state="translated">적용되면 CocoaPods 플러그인은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d3cb13a5dd74d5989c8544a9bd856469cfe20ca8" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;excludeDependentModules&lt;/code&gt; and &lt;code&gt;headerFilter&lt;/code&gt; are used, they are applied as an intersection.</source>
          <target state="translated">두 경우 &lt;code&gt;excludeDependentModules&lt;/code&gt; 및 &lt;code&gt;headerFilter&lt;/code&gt; 가 사용되는, 그들은 교차로로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5bd916e17d31ae892ecde1eb2457f0a21c18c0ca" translate="yes" xml:space="preserve">
          <source>When building a Kotlin/JS project using Kotlin 1.3.xx, you may encounter a Gradle error if one of your dependencies (or any transitive dependency) was built using Kotlin 1.4 or higher: &lt;code&gt;Could not determine the dependencies of task ':client:jsTestPackageJson'.&lt;/code&gt; / &lt;code&gt;Cannot choose between the following variants&lt;/code&gt;. This is a known problem, a workaround is provided &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-40226&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Kotlin 1.3.xx를 사용하여 Kotlin / JS 프로젝트를 빌드 할 때 종속성 (또는 전이 종속성) 중 하나가 Kotlin 1.4 이상을 사용하여 빌드 된 경우 Gradle 오류가 발생할 수 있습니다. &lt;code&gt;Could not determine the dependencies of task ':client:jsTestPackageJson'.&lt;/code&gt; / &lt;code&gt;Cannot choose between the following variants&lt;/code&gt; . 이것은 알려진 문제이며 &lt;a href=&quot;https://youtrack.jetbrains.com/issue/KT-40226&quot;&gt;여기에&lt;/a&gt; 해결 방법이 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f14a9a00a723afb155894bffae89af46e21d16f" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework or a native library (shared or static), you may need to pack not just the classes of the current project, but also the classes of its dependencies. Specify which dependencies to export to a binary using the &lt;code&gt;export&lt;/code&gt; method.</source>
          <target state="translated">Objective-C 프레임 워크 또는 네이티브 라이브러리 (공유 또는 정적)를 빌드 할 때 현재 프로젝트의 클래스뿐만 아니라 해당 종속성의 클래스도 압축해야 할 수 있습니다. &lt;code&gt;export&lt;/code&gt; 방법을 사용하여 바이너리로 내보낼 종속성을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="c05de934df0888bf3a4ea0106e90f35a575c92fc" translate="yes" xml:space="preserve">
          <source>When building an Objective-C framework, it is often necessary to pack not just the classes of the current project, but also the classes of some of its dependencies. The Binaries DSL allows one to specify which dependencies will be exported in the framework using the &lt;code&gt;export&lt;/code&gt; method. Note that only API dependencies of a corresponding source set can be exported.</source>
          <target state="translated">Objective-C 프레임 워크를 빌드 할 때 종종 현재 프로젝트의 클래스뿐만 아니라 일부 종속 클래스도 패키지해야합니다. 바이너리 DSL을 사용하면 &lt;code&gt;export&lt;/code&gt; 방법을 사용하여 프레임 워크에서 내보낼 종속성을 지정할 수 있습니다 . 해당 소스 세트의 API 종속성 만 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c939554f4725c1c653be2725d54eb9e654761fc" translate="yes" xml:space="preserve">
          <source>When building from Xcode, you can use CocoaPods libraries without writing .def files manually and setting cinterop tool parameters. In this case, all required parameters can be obtained from the Xcode project configured by CocoaPods.</source>
          <target state="translated">Xcode에서 빌드 할 때 .def 파일을 수동으로 작성하지 않고 cinterop 도구 매개 변수를 설정하지 않고도 CocoaPods 라이브러리를 사용할 수 있습니다. 이 경우 필요한 모든 매개 변수는 CocoaPods로 구성된 Xcode 프로젝트에서 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c700148c224a841d5e4fb27c316b7b0f072a2aee" translate="yes" xml:space="preserve">
          <source>When called on an object with a predicate provided, &lt;code&gt;takeIf&lt;/code&gt; returns this object if it matches the predicate. Otherwise, it returns &lt;code&gt;null&lt;/code&gt;. So, &lt;code&gt;takeIf&lt;/code&gt; is a filtering function for a single object. In turn, &lt;code&gt;takeUnless&lt;/code&gt; returns the object if it doesn't match the predicate and &lt;code&gt;null&lt;/code&gt; if it does. The object is available as a lambda argument (&lt;code&gt;it&lt;/code&gt;).</source>
          <target state="translated">술어가 제공된 오브젝트에서 호출되면 &lt;code&gt;takeIf&lt;/code&gt; 는이 술어가 술어와 일치하면이 오브젝트를 리턴합니다. 그렇지 않으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 . 따라서 &lt;code&gt;takeIf&lt;/code&gt; 는 단일 객체에 대한 필터링 기능입니다. 결과적으로 &lt;code&gt;takeUnless&lt;/code&gt; 는 술어와 일치하지 않으면 오브젝트를 리턴하고 일치하면 &lt;code&gt;null&lt;/code&gt; 합니다. 객체는 람다 인수 ( &lt;code&gt;it&lt;/code&gt; )로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="70ae5c844919498cf5a44f8ce155a9c7029cae97" translate="yes" xml:space="preserve">
          <source>When called on lists, &lt;code&gt;addAll()&lt;/code&gt; adds new elements in the same order as they go in the argument. You can also call &lt;code&gt;addAll()&lt;/code&gt; specifying an element position as the first argument. The first element of the argument collection will be inserted at this position. Other elements of the argument collection will follow it, shifting the receiver elements to the end.</source>
          <target state="translated">목록에서 호출되면 &lt;code&gt;addAll()&lt;/code&gt; 은 인수와 동일한 순서로 새 요소를 추가합니다. 요소 위치를 첫 번째 인수로 지정하여 &lt;code&gt;addAll()&lt;/code&gt; 호출 할 수도 있습니다 . 인수 콜렉션의 첫 번째 요소가이 위치에 삽입됩니다. 인수 콜렉션의 다른 요소가 뒤 따르며 수신자 요소를 끝으로 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="4503c0345f7f96c5163267795a01f8ff6d6296b7" translate="yes" xml:space="preserve">
          <source>When called with the default arguments, the functions return the result similar to calling &lt;code&gt;toString()&lt;/code&gt; on the collection: a &lt;code&gt;String&lt;/code&gt; of elements' string representations separated by commas with spaces.</source>
          <target state="translated">기본 인수로 호출 할 때, 함수 호출과 유사한 결과를 반환 &lt;code&gt;toString()&lt;/code&gt; 컬렉션에를하십시오 &lt;code&gt;String&lt;/code&gt; 요소의 문자열 표현의 공백으로 쉼표로 구분.</target>
        </trans-unit>
        <trans-unit id="4f800ac9ce646dbfd1c595ccbbdab36f597cb7a9" translate="yes" xml:space="preserve">
          <source>When called with the key present in the map, operators overwrite the values of the corresponding entries.</source>
          <target state="translated">맵에있는 키를 사용하여 호출하면 연산자는 해당 항목의 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="0e3f5ee2c33fac5afe961b2bc4ee6475eb75da8a" translate="yes" xml:space="preserve">
          <source>When calling Kotlin functions from Java, nobody prevents us from passing &lt;em&gt;null&lt;/em&gt; as a non-null parameter. That's why Kotlin generates runtime checks for all public functions that expect non-nulls. This way we get a &lt;code&gt;NullPointerException&lt;/code&gt; in the Java code immediately.</source>
          <target state="translated">Java에서 Kotlin 함수를 호출 할 때 아무도 &lt;em&gt;null&lt;/em&gt; 이 아닌 매개 변수로 null 을 전달하지 못합니다 . 이것이 Kotlin이 널이 아닌 것으로 예상되는 모든 공용 함수에 대한 런타임 검사를 생성하는 이유입니다. 이렇게 하면 Java 코드에서 &lt;code&gt;NullPointerException&lt;/code&gt; 이 즉시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5bf4931382d70d2a150fc1284b61bdc2c9c96f9a" translate="yes" xml:space="preserve">
          <source>When calling a function, you can name one or more of its arguments. This may be helpful when a function has a large number of arguments, and it's difficult to associate a value with an argument, especially if it's a boolean or &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">When calling a function, you can name one or more of its arguments. This may be helpful when a function has a large number of arguments, and it's difficult to associate a value with an argument, especially if it's a boolean or &lt;code&gt;null&lt;/code&gt; value.</target>
        </trans-unit>
        <trans-unit id="afccfc52da19240ad334120985339616ba8ee626" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; or the &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;@JsExport annotation&lt;/a&gt; to assign well-defined names to the functions that you want to call.</source>
          <target state="translated">When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; or the &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;@JsExport annotation&lt;/a&gt; to assign well-defined names to the functions that you want to call.</target>
        </trans-unit>
        <trans-unit id="a66c232a7677f7941a6400aa2f6dc79238791bec" translate="yes" xml:space="preserve">
          <source>When calling functions written in Kotlin on values of &lt;code&gt;dynamic&lt;/code&gt; type, keep in mind the name mangling performed by the Kotlin to JavaScript compiler. You may need to use the &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName annotation&lt;/a&gt; to assign well-defined names to the functions that you need to call.</source>
          <target state="translated">&lt;code&gt;dynamic&lt;/code&gt; 유형 값에 대해 Kotlin으로 작성된 함수를 호출 할 때 Kotlin to JavaScript 컴파일러에서 수행하는 이름 조작을 명심하십시오. 호출해야하는 함수에 잘 정의 된 이름을 지정하려면 &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;@JsName 어노테이션&lt;/a&gt; 을 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f401901149779f5935d80aef38d169d9b80565b3" translate="yes" xml:space="preserve">
          <source>When calling this function, you don&amp;rsquo;t have to name all its arguments:</source>
          <target state="translated">When calling this function, you don&amp;rsquo;t have to name all its arguments:</target>
        </trans-unit>
        <trans-unit id="a144ef75b391ae884d7e13a94311bf67580a2244" translate="yes" xml:space="preserve">
          <source>When chaining other functions after &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;, don't forget to perform the null check or the safe call (&lt;code&gt;?.&lt;/code&gt;) because their return value is nullable.</source>
          <target state="translated">&lt;code&gt;takeIf&lt;/code&gt; 및 &lt;code&gt;takeUnless&lt;/code&gt; 후에 다른 함수를 연결할 때 반환 값이 nullable이므로 null check 또는 safe call ( &lt;code&gt;?.&lt;/code&gt; ) 을 수행하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c0a48c6031f8ea84f7db041425c7fe40478df5e8" translate="yes" xml:space="preserve">
          <source>When compiling (we'll use this term interchangeably with &lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;transpiling&lt;/a&gt;) to JavaScript, Kotlin outputs two main files:</source>
          <target state="translated">Kotlin은 JavaScript로 컴파일 할 때 (이 용어를 &lt;a href=&quot;https://en.wiktionary.org/wiki/transpile&quot;&gt;transpiling&lt;/a&gt; 과 상호 교환 적으로 사용함 ) JavaScript를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="9a71722d03195d233742cd235099b2a024ee3092" translate="yes" xml:space="preserve">
          <source>When compiling Kotlin code to targets JVM 1.8 and above, you could compile non-abstract methods of Kotlin interfaces into Java's &lt;code&gt;default&lt;/code&gt; methods. For this purpose, there was a mechanism that includes the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation for marking such methods and the &lt;code&gt;-Xjvm-default&lt;/code&gt; compiler option that enables processing of this annotation.</source>
          <target state="translated">JVM 1.8 이상을 대상으로 Kotlin 코드를 컴파일 할 때 Kotlin 인터페이스의 비추 상 메서드를 자바의 &lt;code&gt;default&lt;/code&gt; 메서드 로 컴파일 할 수 있습니다. 이를 위해 이러한 메소드를 표시하기위한 &lt;code&gt;@JvmDefault&lt;/code&gt; 어노테이션 과이 어노테이션의 처리를 가능하게 하는 &lt;code&gt;-Xjvm-default&lt;/code&gt; 컴파일러 옵션을 포함하는 메커니즘이있었습니다 .</target>
        </trans-unit>
        <trans-unit id="8c097f144946019495809506583d55bf5b42ced5" translate="yes" xml:space="preserve">
          <source>When compiling to JVM byte codes, the compiler optimizes access to arrays so that there's no overhead introduced:</source>
          <target state="translated">JVM 바이트 코드로 컴파일 할 때 컴파일러는 오버 헤드가 발생하지 않도록 배열에 대한 액세스를 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="d5652ef4fdb2127a183b6f70658b4242e9138b50" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, methods having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. When such a method called through framework API throws an exception, it is either propagated as &lt;code&gt;NSError&lt;/code&gt; or considered unhandled (if exception &lt;code&gt;is&lt;/code&gt;&lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt; or &lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeException&lt;/a&gt;). In any case exception is not checked to be instance of one of the &lt;a href=&quot;exception-classes&quot;&gt;exceptionClasses&lt;/a&gt;.</source>
          <target state="translated">오브젝티브 C / 신속한 프레임 워크를 컴파일 할 때, 필요하거나 주석 상속 방법은 다음과 같이 표현된다 &lt;code&gt;NSError*&lt;/code&gt; 오브젝티브 C의 방법과 같은 -producing &lt;code&gt;throws&lt;/code&gt; 스위프트의 방법. 프레임 워크 API를 통해 호출 된 이러한 메소드가 예외를 발생 &lt;code&gt;NSError&lt;/code&gt; 전파 되거나 처리되지 않은 것으로 간주됩니다 (예외 &lt;code&gt;is&lt;/code&gt; &lt;a href=&quot;../../kotlin/-error/index#kotlin.Error&quot;&gt;kotlin.Error&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin/-runtime-exception/index#kotlin.RuntimeException&quot;&gt;kotlin.RuntimeException 인 경우&lt;/a&gt; ). 어떤 경우 예외들 중 하나의 인스턴스로 선택하지 &lt;a href=&quot;exception-classes&quot;&gt;exceptionClasses&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6587d9ea4d853cd6df9a3004ea764022f98d9281" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler.</source>
          <target state="translated">When compiling to Objective-C/Swift framework, non- &lt;code&gt;suspend&lt;/code&gt; functions having or inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt; -producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt; / &lt;code&gt;Error&lt;/code&gt; parameter in completion handler.</target>
        </trans-unit>
        <trans-unit id="488e4ca566eb9082ca3b6286ce0e3243bb17b8f2" translate="yes" xml:space="preserve">
          <source>When compiling to Objective-C/Swift framework, non-&lt;code&gt;suspend&lt;/code&gt; functions having or inheriting this annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift. Representations for &lt;code&gt;suspend&lt;/code&gt; functions always have &lt;code&gt;NSError*&lt;/code&gt;/&lt;code&gt;Error&lt;/code&gt; parameter in completion handler</source>
          <target state="translated">Objective-C / Swift 프레임 워크로 컴파일 할 때이 어노테이션을 갖거나 상속하는 비 &lt;code&gt;suspend&lt;/code&gt; 함수 는 Objective-C에서 &lt;code&gt;NSError*&lt;/code&gt; 생성 메소드 로 표시되고 Swift 에서는 &lt;code&gt;throws&lt;/code&gt; 메소드로 표시됩니다. &lt;code&gt;suspend&lt;/code&gt; 함수에 대한 표현에는 항상 완료 핸들러에 &lt;code&gt;NSError*&lt;/code&gt; / &lt;code&gt;Error&lt;/code&gt; 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9ee7ef1045f5338ee8701cbc0ba2b21b7f1d68" translate="yes" xml:space="preserve">
          <source>When compiling to Swift or the Objective-C framework, functions that have or are inheriting &lt;code&gt;@Throws&lt;/code&gt; annotation are represented as &lt;code&gt;NSError*&lt;/code&gt;-producing methods in Objective-C and as &lt;code&gt;throws&lt;/code&gt; methods in Swift.</source>
          <target state="translated">Swift 또는 Objective-C 프레임 워크로 컴파일 할 때 &lt;code&gt;@Throws&lt;/code&gt; 주석 을 가지고 있거나 상속하는 함수 는 Objective-C에서 &lt;code&gt;NSError*&lt;/code&gt; 생성 메서드로 , Swift 에서는 &lt;code&gt;throws&lt;/code&gt; 메서드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b96c28145bcb8f6ff8815136a3e9f396b218615b" translate="yes" xml:space="preserve">
          <source>When compiling, the compiler always outputs the kotlin.js file. The easiest way to reference this without having to refer to paths, is to set the output library folder for the compiler options to &lt;code&gt;node_modules&lt;/code&gt;. This way, Node will automatically pick it up as it does an exhaustive search for files under these folders</source>
          <target state="translated">컴파일 할 때 컴파일러는 항상 kotlin.js 파일을 출력합니다. 경로를 참조하지 않고 이것을 참조하는 가장 쉬운 방법은 컴파일러 옵션의 출력 라이브러리 폴더를 &lt;code&gt;node_modules&lt;/code&gt; 로 설정하는 것 입니다. 이런 식으로 노드는 이러한 폴더 아래의 파일을 철저하게 검색하므로 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5b6df5ad94ece159e4d2e7854f633a08ec2ced8b" translate="yes" xml:space="preserve">
          <source>When creating a new application or module that targets JavaScript, we need to select &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; as the target</source>
          <target state="translated">JavaScript를 대상으로하는 새 응용 프로그램 또는 모듈을 만들 때는 &lt;code&gt;Kotlin - JavaScript&lt;/code&gt; 를 대상으로 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="40c235de508210259df882cfb516e8a1d647fb3f" translate="yes" xml:space="preserve">
          <source>When declaring dependencies on npm packages, you are now required to explicitly specify a version or version range based on &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm&amp;rsquo;s semver syntax&lt;/a&gt;. Specifying multiple version ranges is also supported.</source>
          <target state="translated">npm 패키지에 대한 종속성을 선언 할 때 이제 &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm의 semver 구문을&lt;/a&gt; 기반으로 버전 또는 버전 범위를 명시 적으로 지정해야 합니다 . 여러 버전 범위 지정도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="03565eec78cb8bfb0c999a9b15ff0e6c755df92b" translate="yes" xml:space="preserve">
          <source>When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:</source>
          <target state="translated">여러 줄로 된 람다에서 매개 변수 이름을 선언 할 때 첫 번째 줄에 이름을 입력 한 다음 화살표와 줄 바꿈을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef5c76bfa4e43b35f38295e1d456c70ff2408cf" translate="yes" xml:space="preserve">
          <source>When executing this run configuration, we can note that the Gradle process continues watching for changes to the program:</source>
          <target state="translated">이 실행 구성을 실행할 때 Gradle 프로세스가 프로그램 변경 사항을 계속 감시하고 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04dc660c0cd261412da813263e6942fbca96f489" translate="yes" xml:space="preserve">
          <source>When flow collection completes (normally or exceptionally) it may need to execute an action. As you may have already noticed, it can be done in two ways: imperative or declarative.</source>
          <target state="translated">흐름 수집이 완료되면 (일반적으로 또는 예외적으로) 작업을 실행해야 할 수 있습니다. 이미 눈치 채 셨겠지만 명령형 또는 선언 형의 두 가지 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="210a72ecd64e91bda5f9f64c7a09dfe81ca0e12e" translate="yes" xml:space="preserve">
          <source>When flow represents the most recent value of a variable or operation (see also the related section on &lt;a href=&quot;#conflation&quot;&gt;conflation&lt;/a&gt;), it might be needed to perform a computation that depends on the most recent values of the corresponding flows and to recompute it whenever any of the upstream flows emit a value. The corresponding family of operators is called &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html&quot;&gt;combine&lt;/a&gt;.</source>
          <target state="translated">흐름이 변수 또는 작업의 가장 최근 값을 나타내는 경우 ( &lt;a href=&quot;#conflation&quot;&gt;conflation&lt;/a&gt; 관련 섹션 참조 ) 해당 흐름의 가장 최근 값에 따라 계산을 수행하고 업스트림이있을 때마다 다시 계산해야 할 수 있습니다. 흐름은 값을 내 보냅니다. 해당 연산자 계열을 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html&quot;&gt;결합&lt;/a&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="16ca0ed2cf53ba99dfc24939c39b34cc8182bea3" translate="yes" xml:space="preserve">
          <source>When given a &lt;code&gt;-library foo&lt;/code&gt; flag, the compiler searches the &lt;code&gt;foo&lt;/code&gt; library in the following order:</source>
          <target state="translated">주어진 때 &lt;code&gt;-library foo&lt;/code&gt; 는 플래그를, 컴파일러는 검색 &lt;code&gt;foo&lt;/code&gt; 는 다음과 같은 순서로 라이브러리를 :</target>
        </trans-unit>
        <trans-unit id="dd5a17a3b22c6470172a587dc5be67c1d1df4d62" translate="yes" xml:space="preserve">
          <source>When given the above snippet the &lt;code&gt;cinterop&lt;/code&gt; tool will search &lt;code&gt;libfoo.a&lt;/code&gt; in &lt;code&gt;/opt/local/lib&lt;/code&gt; and &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt;, and if it is found include the library binary into &lt;code&gt;klib&lt;/code&gt;.</source>
          <target state="translated">위의 스 니펫이 주어지면 &lt;code&gt;cinterop&lt;/code&gt; 도구는 &lt;code&gt;/opt/local/lib&lt;/code&gt; 및 &lt;code&gt;/usr/local/opt/curl/lib&lt;/code&gt; 에서 &lt;code&gt;libfoo.a&lt;/code&gt; 를 검색 하고 , 발견되면 라이브러리 바이너리를 &lt;code&gt;klib&lt;/code&gt; 에 포함 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="010f9a9f094ca37e15156897e51ac67f748d0305" translate="yes" xml:space="preserve">
          <source>When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation)</source>
          <target state="translated">인터페이스를 구현할 때 구현 구성원을 인터페이스 구성원과 동일한 순서로 유지하십시오 (필요한 경우 구현에 사용되는 추가 개인용 메소드와 함께 산재)</target>
        </trans-unit>
        <trans-unit id="27dfae03dd6477eb5611a6a8eca02c237e81ed5f" translate="yes" xml:space="preserve">
          <source>When in &lt;code&gt;both&lt;/code&gt; mode, the IR compiler backend and default compiler backend are both used when building a library from your sources (hence the name). This means that both &lt;code&gt;klib&lt;/code&gt; files with Kotlin IR as well as &lt;code&gt;jar&lt;/code&gt; files for the default compiler will be generated. When published under the same Maven coordinate, Gradle will automatically choose the right artifact depending on the use case &amp;ndash; &lt;code&gt;js&lt;/code&gt; for the old compiler, &lt;code&gt;klib&lt;/code&gt; for the new one. This enables you to compile and publish your library for projects that are using either of the two compiler backends.</source>
          <target state="translated">에 때 &lt;code&gt;both&lt;/code&gt; 당신의 소스 라이브러리 (따라서 이름)을 구축 할 때 모드, 적외선 컴파일러 백엔드 및 기본 컴파일러 백엔드가 모두 사용된다. 즉 , Kotlin IR이있는 &lt;code&gt;klib&lt;/code&gt; 파일과 기본 컴파일러 용 &lt;code&gt;jar&lt;/code&gt; 파일이 모두 생성됩니다. 동일한 Maven 좌표로 게시되면 Gradle은 사용 사례에 따라 올바른 아티팩트 ( 이전 컴파일러의 경우 &lt;code&gt;js&lt;/code&gt; , 새 컴파일러의 경우 &lt;code&gt;klib&lt;/code&gt; ) 를 자동으로 선택합니다 . 이렇게하면 두 컴파일러 백엔드 중 하나를 사용하는 프로젝트에 대해 라이브러리를 컴파일하고 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8190bf6bb340fcc1bfe9465dd44a27ec0f22ba" translate="yes" xml:space="preserve">
          <source>When installed for the first time, EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Educator&lt;/strong&gt; to enable course creation functionality:</source>
          <target state="translated">EduTools 플러그인을 처음 설치하면 학습자인지 교육자인지 묻습니다. 코스 생성 기능을 활성화하려면 &lt;strong&gt;교육자&lt;/strong&gt; 를 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="8932a8146c0a90dc2dd58707de728ef7a12acaa8" translate="yes" xml:space="preserve">
          <source>When installed for the first time, the EduTools plugin asks if you're a Learner or an Educator. Please choose &lt;strong&gt;Learner&lt;/strong&gt;:</source>
          <target state="translated">EduTools 플러그인을 처음 설치하면 학습자인지 교육자인지 묻습니다. &lt;strong&gt;학습자를&lt;/strong&gt; 선택하십시오 :</target>
        </trans-unit>
        <trans-unit id="10a5b3cb7bba7c274d069162e0ee74e696f381e7" translate="yes" xml:space="preserve">
          <source>When library headers are imported to a C program with the &lt;code&gt;#include&lt;/code&gt; directive, all of the headers included by these headers are also included in the program. So all header dependencies are included in generated stubs as well.</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 지시문 을 사용하여 라이브러리 헤더를 C 프로그램으로 가져 오면 이러한 헤더에 포함 된 모든 헤더도 프로그램에 포함됩니다. 따라서 모든 헤더 종속성이 생성 된 스텁에도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3922383306a8a09a6b0e8b2eb8f9a1db1f1ab0db" translate="yes" xml:space="preserve">
          <source>When list elements aren't &lt;code&gt;Comparable&lt;/code&gt;, you should provide a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt; to use in the binary search. The list must be sorted in ascending order according to this &lt;code&gt;Comparator&lt;/code&gt;. Let's have a look at an example:</source>
          <target state="translated">list 요소가 &lt;code&gt;Comparable&lt;/code&gt; 이 아닌 경우 이진 검색에 사용할 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 를 제공해야합니다 . 이 &lt;code&gt;Comparator&lt;/code&gt; 에 따라 목록을 오름차순으로 정렬해야합니다 . 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="eb20fed2a040f5bec7d775d79d512be41c67a260" translate="yes" xml:space="preserve">
          <source>When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.</source>
          <target state="translated">여러 고차 함수를 사용하는 복잡한 표현과 루프를 선택할 때 각 경우에 수행되는 작업 비용을 이해하고 성능 고려 사항을 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="34a85c247b6ac08983d01a72671ac866f48daed6" translate="yes" xml:space="preserve">
          <source>When multiple children of a coroutine fail with an exception, the general rule is &quot;the first exception wins&quot;, so the first exception gets handled. All additional exceptions that happen after the first one are attached to the first exception as suppressed ones.</source>
          <target state="translated">When multiple children of a coroutine fail with an exception, the general rule is &quot;the first exception wins&quot;, so the first exception gets handled. All additional exceptions that happen after the first one are attached to the first exception as suppressed ones.</target>
        </trans-unit>
        <trans-unit id="2970ac1e3a2dbc090d5bfcbffc924f278b84baec" translate="yes" xml:space="preserve">
          <source>When returning a value, the parser gives preference to the qualified return, i.e.</source>
          <target state="translated">값을 반환 할 때 파서는 정규화 된 반환 즉,</target>
        </trans-unit>
        <trans-unit id="91e0d5690967c5e3915ccf3388a11d3d82da8814" translate="yes" xml:space="preserve">
          <source>When running this example in the browser, the DOM will be assembled in a straightforward way. This is easily confirmed by checking the Elements of the website using the developer tools of our browser:</source>
          <target state="translated">브라우저에서이 예제를 실행하면 DOM이 간단한 방식으로 어셈블됩니다. 이는 브라우저의 개발자 도구를 사용하여 웹 사이트의 요소를 확인하여 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b57a6650ec36adfcbda42de47e0a60e863df953" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the experimental API used in its body.</source>
          <target state="translated">누군가 &lt;code&gt;getDate()&lt;/code&gt; 함수를 호출하면 본문에 사용 된 실험용 API에 대한 정보가 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfa8681d13a7c615930222f478ec4f7aeac79c5a" translate="yes" xml:space="preserve">
          <source>When somebody calls the function &lt;code&gt;getDate()&lt;/code&gt;, they won't be informed about the opt-in requirements for APIs used in its body.</source>
          <target state="translated">누군가 &lt;code&gt;getDate()&lt;/code&gt; 함수를 호출하면 본문에서 사용되는 API에 대한 옵트 인 요구 사항에 대한 정보를받지 못합니다.</target>
        </trans-unit>
        <trans-unit id="6e6f8bdf23dc342f6366d0ca972d7d991572a9e7" translate="yes" xml:space="preserve">
          <source>When supported by the platform adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">플랫폼에서 지원하는 경우이 예외를 전달하기 위해 억제 된 예외 목록에 지정된 예외를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6393b31c82857a557e8af4f2a0be0aaf5d58b5c5" translate="yes" xml:space="preserve">
          <source>When supported by the platform, adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</source>
          <target state="translated">When supported by the platform, adds the specified exception to the list of exceptions that were suppressed in order to deliver this exception.</target>
        </trans-unit>
        <trans-unit id="3c40217c2fbf96f7f32af012e76efee928b75c4a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, a different plugin should be applied:</source>
          <target state="translated">자바 스크립트를 타겟팅 할 때 다른 플러그인을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6febffb6e2904e4bbf90391b0727f1dbf05ee0c1" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlin2Js&lt;/code&gt; and &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; for custom source sets.</source>
          <target state="translated">JavaScript를 대상으로 할 때 작업을 각각 &lt;code&gt;compileKotlin2Js&lt;/code&gt; 및 &lt;code&gt;compileTestKotlin2Js&lt;/code&gt; 라고 하고 사용자 정의 소스 세트에 대해 &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin2Js&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fb89dbb9f04dc9361c7746b53e92457b21476e1a" translate="yes" xml:space="preserve">
          <source>When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlinJs&lt;/code&gt; and &lt;code&gt;compileTestKotlinJs&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;KotlinJs&lt;/code&gt; for custom source sets.</source>
          <target state="translated">When targeting JavaScript, the tasks are called &lt;code&gt;compileKotlinJs&lt;/code&gt; and &lt;code&gt;compileTestKotlinJs&lt;/code&gt; respectively, and &lt;code&gt;compile&amp;lt;Name&amp;gt;KotlinJs&lt;/code&gt; for custom source sets.</target>
        </trans-unit>
        <trans-unit id="68caa257adc3424d8615357e16a81ae92f1364f3" translate="yes" xml:space="preserve">
          <source>When targeting Node.js with Kotlin/JS, we can simply execute the &lt;code&gt;run&lt;/code&gt; Gradle task. This can be done for example via the command line, using the Gradle wrapper:</source>
          <target state="translated">Kotlin / JS로 Node.js를 대상으로 할 때 Gradle 작업 &lt;code&gt;run&lt;/code&gt; 간단히 실행할 수 있습니다 . 예를 들어 Gradle 래퍼를 사용하여 명령 줄을 통해이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8307ea9f68fd265bde506b102ae1144dc569ce2b" translate="yes" xml:space="preserve">
          <source>When targeting only JavaScript, use the &lt;code&gt;kotlin-js&lt;/code&gt; plugin. &lt;a href=&quot;js-project-setup&quot;&gt;Learn more&lt;/a&gt;</source>
          <target state="translated">When targeting only JavaScript, use the &lt;code&gt;kotlin-js&lt;/code&gt; plugin. &lt;a href=&quot;js-project-setup&quot;&gt;Learn more&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3700a9140aca950bb22b2b6e73a90e60e275240a" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, Kotlin produces Java compatible bytecode. When targeting JavaScript, Kotlin transpiles to ES5.1 and generates code which is compatible with module systems including AMD and CommonJS. When targeting native, Kotlin will produce platform-specific code (via LLVM).</source>
          <target state="translated">JVM을 대상으로 할 때 Kotlin은 Java 호환 바이트 코드를 생성합니다. JavaScript를 대상으로 할 때 Kotlin은 ES5.1로 변환하여 AMD 및 CommonJS를 포함한 모듈 시스템과 호환되는 코드를 생성합니다. 네이티브를 타겟팅 할 때 Kotlin은 플랫폼 별 코드 (LLVM을 통해)를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2fd9751d3f79fd88ae2a197e9ec6c24a47840b01" translate="yes" xml:space="preserve">
          <source>When targeting the JVM, the tasks are called &lt;code&gt;compileKotlin&lt;/code&gt; for production code and &lt;code&gt;compileTestKotlin&lt;/code&gt; for test code. The tasks for custom source sets are called accordingly to the &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; pattern.</source>
          <target state="translated">JVM이 목표로하는 경우, 작업이라고 &lt;code&gt;compileKotlin&lt;/code&gt; 을 생산 코드에 대한 &lt;code&gt;compileTestKotlin&lt;/code&gt; 테스트 코드. 사용자 정의 소스 세트에 대한 태스크는 &lt;code&gt;compile&amp;lt;Name&amp;gt;Kotlin&lt;/code&gt; 패턴 에 따라 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb9436a471e8dbc8503c3b6e6a7c9d3c34f6ebb0" translate="yes" xml:space="preserve">
          <source>When targeting the browser, our project is required to have an HTML page. This page will be served by the development server while we are working on our application, and should embed our compiled Kotlin/JS file. Create and fill an HTML file &lt;code&gt;/src/main/resources/index.html&lt;/code&gt;:</source>
          <target state="translated">브라우저를 대상으로 할 때 우리 프로젝트에는 HTML 페이지가 있어야합니다. 이 페이지는 애플리케이션에서 작업하는 동안 개발 서버에서 제공되며 컴파일 된 Kotlin / JS 파일을 포함해야합니다. HTML 파일 &lt;code&gt;/src/main/resources/index.html&lt;/code&gt; 생성 및 채우기 :</target>
        </trans-unit>
        <trans-unit id="f18755d5fafc0688db03f9113e5e8aba876e9f17" translate="yes" xml:space="preserve">
          <source>When the argument type is final, there's usually no point in generating the wildcard, so &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; is always &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt;, no matter what position it takes.</source>
          <target state="translated">인수 유형이 최종인 경우 일반적으로 와일드 카드를 생성 할 필요가 없으므로 &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; 은 위치에 관계없이 항상 &lt;code&gt;Box&amp;lt;String&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4260e7c630e27226c5f3f5f47519e7ba6fce2dbf" translate="yes" xml:space="preserve">
          <source>When the operands &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are statically known to be &lt;code&gt;Float&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt; or their nullable counterparts (the type is declared or inferred or is a result of a &lt;a href=&quot;typecasts#smart-casts&quot;&gt;smart cast&lt;/a&gt;), the operations on the numbers and the range that they form follow the IEEE 754 Standard for Floating-Point Arithmetic.</source>
          <target state="translated">피연산자 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 정적으로 &lt;code&gt;Float&lt;/code&gt; 또는 &lt;code&gt;Double&lt;/code&gt; 또는 널 입력 가능 항목 으로 알려진 경우 (유형이 선언되거나 유추되거나 &lt;a href=&quot;typecasts#smart-casts&quot;&gt;스마트 캐스트&lt;/a&gt; 의 결과 임 ) 숫자 및 범위에 대한 조작은 IEEE 754를 따릅니다. 부동 소수점 산술 표준.</target>
        </trans-unit>
        <trans-unit id="50fe39e80afdb0bafe5609ac0ee60d49bbca274d" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="translated">원래 &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;연속이&lt;/a&gt; 완료되면 코 루틴 프레임 워크는 &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; 을 인터셉트 된 경우 즉, &lt;code&gt;interceptContinuation&lt;/code&gt; 이 이전에 다른 연속 인스턴스를 리턴 한 경우 결과 연속으로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="41195e5948b5d9d14accce4fb777d5a5399f88d7" translate="yes" xml:space="preserve">
          <source>When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</source>
          <target state="translated">When the original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; completes, coroutine framework invokes &lt;a href=&quot;release-intercepted-continuation&quot;&gt;releaseInterceptedContinuation&lt;/a&gt; with the resulting continuation if it was intercepted, that is if &lt;code&gt;interceptContinuation&lt;/code&gt; had previously returned a different continuation instance.</target>
        </trans-unit>
        <trans-unit id="aee129400c7cdc16a95ec0912c8a4fd0a5a9f195" translate="yes" xml:space="preserve">
          <source>When the processing of an &lt;code&gt;Iterable&lt;/code&gt; includes multiple steps, they are executed eagerly: each processing step completes and returns its result &amp;ndash; an intermediate collection. The following step executes on this collection. In turn, multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; 처리에 여러 단계가 포함 된 경우 각 단계가 열성적으로 실행됩니다. 각 처리 단계가 완료되고 결과 (중간 콜렉션)가 리턴됩니다. 이 컬렉션에서 다음 단계가 실행됩니다. 결과적으로 가능한 경우 시퀀스의 다단계 처리가 느리게 실행됩니다. 실제 컴퓨팅은 전체 처리 체인의 결과가 요청 된 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="45bf077d097fcdb663238684f69205850ecd18da" translate="yes" xml:space="preserve">
          <source>When the project consists of exclusively Kotlin source code, the easiest way to compile the project is to use the &lt;em&gt;kotlinc&lt;/em&gt; task:</source>
          <target state="translated">프로젝트가 Kotlin 소스 코드로만 구성된 경우 프로젝트를 컴파일하는 가장 쉬운 방법은 &lt;em&gt;kotlinc&lt;/em&gt; 작업 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="de3a7fefd9c0e4fdceeb9aa1f2016defc2704512" translate="yes" xml:space="preserve">
          <source>When this annotation is placed on a generic function parameter of a function, it enables to infer the type arguments of that generic function from the lambda body passed to that parameter.</source>
          <target state="translated">이 주석이 함수의 일반 함수 매개 변수에 배치되면 해당 매개 변수에 전달 된 람다 본문에서 해당 일반 함수의 유형 인수를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4048f5f513aab453351704d3921c71dee68c7768" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;구분 기호로&lt;/a&gt; 시작하고 끝나는 경우이 &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;구분 기호&lt;/a&gt; 가 시작과 끝에서 모두 제거 된 새 문자 순서를 반환합니다 . 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71738510e58b58513693f2e894d632554b8f850d" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">When this char sequence starts with and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</target>
        </trans-unit>
        <trans-unit id="662d6d4b8c6d089b2ede0be25f7514459a1a7dc8" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;구분 기호로&lt;/a&gt; 시작하고 끝나는 경우이 &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;구분 기호&lt;/a&gt; 가 시작과 끝에서 모두 제거 된 새 문자 순서를 반환합니다 . 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7019a5ff21fc052821e44fe7b2517fb2a7e50ce1" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">When this char sequence starts with and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</target>
        </trans-unit>
        <trans-unit id="f0f3cdbdc4358626eb141b88edd210afb71fcf1c" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;구분 기호로&lt;/a&gt; 시작하고 끝나는 경우이 &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fdelimiter&quot;&gt;구분 기호&lt;/a&gt; 가 시작과 끝에서 모두 제거 된 새 문자 순서를 반환합니다 . 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1343302e14e8f4c4b12b4a77e8795e48eee2bf82" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">When this char sequence starts with and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt;, returns a new char sequence having this &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence)/delimiter&quot;&gt;delimiter&lt;/a&gt; removed both from the start and end. Otherwise returns a new char sequence with the same characters.</target>
        </trans-unit>
        <trans-unit id="451a99a6d4be3b4584fd97e74744059ae797634b" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;접두사로&lt;/a&gt; 시작 하여 지정된 &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사로&lt;/a&gt; 끝나면 지정된 &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;접두사&lt;/a&gt; 와 &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사&lt;/a&gt; 가 모두 제거 된 새 문자 순서를 반환합니다 . 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21ec09c18e0e164102ac5fa7a001d480731fe38a" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">When this char sequence starts with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../../kotlin.text/remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</target>
        </trans-unit>
        <trans-unit id="474027059649f995528fdc9848631cfc13badca6" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;접두사로&lt;/a&gt; 시작 하여 지정된 &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사로&lt;/a&gt; 끝나면 지정된 &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;접두사&lt;/a&gt; 와 &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사&lt;/a&gt; 가 모두 제거 된 새 문자 순서를 반환합니다 . 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1059589b0f168a1d76360357b34244200d2d5f4" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">When this char sequence starts with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;../remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</target>
        </trans-unit>
        <trans-unit id="b4f20b674cd62de8c48c773a81ba6fdddb62b434" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">이 문자 순서가 지정된 &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;접두사로&lt;/a&gt; 시작 하여 지정된 &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사로&lt;/a&gt; 끝나면 지정된 &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fprefix&quot;&gt;접두사&lt;/a&gt; 와 &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding%28kotlin.CharSequence%2C+kotlin.CharSequence%2C+kotlin.CharSequence%29%2Fsuffix&quot;&gt;접미사&lt;/a&gt; 가 모두 제거 된 새 문자 순서를 반환합니다 . 그렇지 않으면 같은 문자를 가진 새로운 문자 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cdb86094485044abedbde00e051a13f9d6e30f2e" translate="yes" xml:space="preserve">
          <source>When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</source>
          <target state="translated">When this char sequence starts with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and ends with the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt;, returns a new char sequence having both the given &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/prefix&quot;&gt;prefix&lt;/a&gt; and &lt;a href=&quot;remove-surrounding#kotlin.text%24removeSurrounding(kotlin.CharSequence,%20kotlin.CharSequence,%20kotlin.CharSequence)/suffix&quot;&gt;suffix&lt;/a&gt; removed. Otherwise returns a new char sequence with the same characters.</target>
        </trans-unit>
        <trans-unit id="81b6ffb12763bc2138c97cf448035b6d9b90a8a2" translate="yes" xml:space="preserve">
          <source>When this map already has an implicit default value provided with a former call to &lt;a href=&quot;with-default&quot;&gt;withDefault&lt;/a&gt;, it is being replaced by this call.</source>
          <target state="translated">이 맵에 이미 &lt;a href=&quot;with-default&quot;&gt;withDefault에&lt;/a&gt; 대한 이전 호출이 제공된 암시 적 기본값이 있으면이 호출 로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="4cb6af1ae576c542ddecdff3ea4125d59a9ee8e7" translate="yes" xml:space="preserve">
          <source>When to use</source>
          <target state="translated">사용시기</target>
        </trans-unit>
        <trans-unit id="d17ab536e904cdcbae105ffd675f6f9b2f2e25d6" translate="yes" xml:space="preserve">
          <source>When transforming maps, you have two options: transform keys leaving values unchanged and vice versa. To apply a given transformation to keys, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt;&lt;code&gt;mapKeys()&lt;/code&gt;&lt;/a&gt;; in turn, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt;&lt;code&gt;mapValues()&lt;/code&gt;&lt;/a&gt; transforms values. Both functions use the transformations that take a map entry as an argument, so you can operate both its key and value.</source>
          <target state="translated">맵을 변환 할 때 두 가지 옵션이 있습니다 : 값을 변경하지 않은 상태로 키 변환 및 그 반대로. 주어진 변환을 키에 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-keys&quot;&gt; &lt;code&gt;mapKeys()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 차례로 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-values&quot;&gt; &lt;code&gt;mapValues()&lt;/code&gt; &lt;/a&gt; 는 값을 변환합니다. 두 함수 모두 맵 항목을 인수로 사용하는 변환을 사용하므로 키와 값을 모두 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8770eb3127ee3d553d5540c7c283a25cbf45081e" translate="yes" xml:space="preserve">
          <source>When two or more function overloads have otherwise the same parameter lists that differ only in the return type of a functional parameter, this annotation enables overload selection by the type of the value returned from the lambda function passed to this functional parameter.</source>
          <target state="translated">둘 이상의 함수 오버로드에 함수 매개 변수의 반환 유형 만 다른 동일한 매개 변수 목록이있는 경우이 주석을 사용하면이 함수 매개 변수에 전달 된 람다 함수에서 반환 된 값의 유형별로 오버로드를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c33f3916421868809be7997c01c86f79f8dba67" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;, apply the Kotlin plugins using the &lt;code&gt;plugins { ... }&lt;/code&gt; block. If you apply them with &lt;code&gt;apply { plugin(...) }&lt;/code&gt; instead, you may encounter unresolved references to the extensions generated by Gradle Kotlin DSL. To resolve that, you can comment out the erroneous usages, run the Gradle task &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt;, then uncomment the usages back and rerun the build or reimport the project into the IDE.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle을 코 틀린 DSL을&lt;/a&gt; 의 사용하여 코 틀린 플러그인 적용 &lt;code&gt;plugins { ... }&lt;/code&gt; 블록을. 당신이 그들을 적용하는 경우 &lt;code&gt;apply { plugin(...) }&lt;/code&gt; 대신에, 당신은 Gradle을 코 틀린 DSL에 의해 생성 된 확장에 해결되지 않은 참조가 발생할 수 있습니다. 이를 해결하기 위해 잘못된 사용법 을 주석 처리하고 Gradle 태스크 &lt;code&gt;kotlinDslAccessorsSnapshot&lt;/code&gt; 을 실행 한 후 사용법을 주석 해제하고 빌드를 다시 실행하거나 프로젝트를 IDE로 다시 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="969e0f1eba169f04310601e387fff4607230faf4" translate="yes" xml:space="preserve">
          <source>When using AMD, we set the compiler option to use AMD. Once we do that, we can then reference any modules that we've defined as if they were regular AMD ones.</source>
          <target state="translated">AMD를 사용할 때 AMD를 사용하도록 컴파일러 옵션을 설정했습니다. 그렇게하면 일반 AMD 모듈 인 것처럼 정의한 모든 모듈을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53fe6e4bace8d3f91a163b97ab403728f060528c" translate="yes" xml:space="preserve">
          <source>When using DSLs, one might have come across the problem that too many functions can be called in the context. We can call methods of every available implicit receiver inside a lambda and therefore get an inconsistent result, like the tag &lt;code&gt;head&lt;/code&gt; inside another &lt;code&gt;head&lt;/code&gt;:</source>
          <target state="translated">DSL을 사용할 때 컨텍스트에서 너무 많은 함수를 호출 할 수 있다는 문제가 발생했을 수 있습니다. 우리는 람다 내부에서 사용 가능한 모든 암시 적 수신기의 메소드를 호출 할 수 있으므로 다른 &lt;code&gt;head&lt;/code&gt; 내부 의 태그 &lt;code&gt;head&lt;/code&gt; 와 같이 일관성없는 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fac3c8199ff8ff114bd0a9de76148fcb9a8c3dbd" translate="yes" xml:space="preserve">
          <source>When using UMD or CommonJS, for example, your callsite could look like this:</source>
          <target state="translated">When using UMD or CommonJS, for example, your callsite could look like this:</target>
        </trans-unit>
        <trans-unit id="7c361123f4c7cb5fe21faa0f281e0ce914b368c3" translate="yes" xml:space="preserve">
          <source>When using a generic type where you have star-projected one or more of its type parameters, you can:</source>
          <target state="translated">하나 이상의 유형 매개 변수를 스타 투영 한 일반 유형을 사용하는 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db42a19309e043040b1f118ec7a9ccf3b7c095b" translate="yes" xml:space="preserve">
          <source>When using an acronym as part of a declaration name, capitalize it if it consists of two letters (&lt;code&gt;IOStream&lt;/code&gt;); capitalize only the first letter if it is longer (&lt;code&gt;XmlFormatter&lt;/code&gt;, &lt;code&gt;HttpInputStream&lt;/code&gt;).</source>
          <target state="translated">선언 이름의 일부로 약어를 사용하는 경우 두 글자 ( &lt;code&gt;IOStream&lt;/code&gt; ) 로 구성되는 경우 대문자를 사용하십시오 . 첫 글자가 길면 대문자를 대문자로 입력하십시오 ( &lt;code&gt;XmlFormatter&lt;/code&gt; , &lt;code&gt;HttpInputStream&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3685d4fda3e975e4ad59872db610504afb8dcbd" translate="yes" xml:space="preserve">
          <source>When using if/else as an expression, the &lt;code&gt;else&lt;/code&gt; part is mandatory (but there can also be &lt;code&gt;else if&lt;/code&gt; parts). If the body that ends up being evaluated contains more than one line, it's the result of the last line that becomes the result of the &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;.</source>
          <target state="translated">if / else를 표현식으로 사용하는 경우 &lt;code&gt;else&lt;/code&gt; 부분은 필수입니다 (그러나 &lt;code&gt;else if&lt;/code&gt; 부분 도있을 수 있음 ). 평가되는 본문에 둘 이상의 행이 포함 된 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 의 결과가되는 마지막 행의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="c13d37c9e596a2177cf34971de8b2f9ef301b366" translate="yes" xml:space="preserve">
          <source>When using such &lt;code&gt;klib&lt;/code&gt; in your program, the library is linked automatically.</source>
          <target state="translated">프로그램에서 이러한 &lt;code&gt;klib&lt;/code&gt; 를 사용 하면 라이브러리가 자동으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="de988175b9de40e29ae018fb8ec5826b1dac85a5" translate="yes" xml:space="preserve">
          <source>When using the IR compiler, the &lt;code&gt;binaries.executable()&lt;/code&gt; instruction must be present in the &lt;code&gt;js&lt;/code&gt; target configuration block of your &lt;code&gt;build.gradle(.kts)&lt;/code&gt;. If this option is omitted, only Kotlin-internal library files are generated. These files can be used from other projects, but not run on their own.</source>
          <target state="translated">IR 컴파일러를 사용할 때 &lt;code&gt;binaries.executable()&lt;/code&gt; 명령어는 &lt;code&gt;build.gradle(.kts)&lt;/code&gt; 의 &lt;code&gt;js&lt;/code&gt; 대상 구성 블록에 있어야합니다 . 이 옵션을 생략하면 Kotlin 내부 라이브러리 파일 만 생성됩니다. 이러한 파일은 다른 프로젝트에서 사용할 수 있지만 자체적으로 실행할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6eb8f752ff8f2ca50e7eef437c4f1437c5c24a5d" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, add the compiler option &lt;code&gt;-Xuse-ir&lt;/code&gt;.</source>
          <target state="translated">명령 줄 컴파일러를 사용하는 경우 컴파일러 옵션 &lt;code&gt;-Xuse-ir&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="23eb1fb1d8c12c86796891c59eb085c47d128eb5" translate="yes" xml:space="preserve">
          <source>When using the command-line compiler, switch to explicit API mode by adding the &lt;code&gt;-Xexplicit-api&lt;/code&gt; compiler option with the value &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warning&lt;/code&gt;.</source>
          <target state="translated">명령 행 컴파일러를 사용할 때 &lt;code&gt;strict&lt;/code&gt; 또는 &lt;code&gt;warning&lt;/code&gt; 값과 함께 &lt;code&gt;-Xexplicit-api&lt;/code&gt; 컴파일러 옵션을 추가하여 명시 적 API 모드로 전환 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0acd4ad721ee61253910c4ba13a8be0c94889bbe" translate="yes" xml:space="preserve">
          <source>When we call a &lt;code&gt;vararg&lt;/code&gt;-function, we can pass arguments one-by-one, e.g. &lt;code&gt;asList(1, 2, 3)&lt;/code&gt;, or, if we already have an array and want to pass its contents to the function, we use the &lt;strong&gt;spread&lt;/strong&gt; operator (prefix the array with &lt;code&gt;*&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;vararg&lt;/code&gt; 함수를 호출하면 asList &lt;code&gt;asList(1, 2, 3)&lt;/code&gt; 과 같이 인수를 하나씩 전달 하거나 이미 배열이 있고 해당 내용을 함수에 전달하려는 경우 &lt;strong&gt;스프레드를&lt;/strong&gt; 사용합니다. 연산자 (배열 앞에 접두어 &lt;code&gt;*&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="79dc6e08abcd7d48d398a4ca21168dbf49b9bdf0" translate="yes" xml:space="preserve">
          <source>When we call methods on variables of platform types, Kotlin does not issue nullability errors at compile time, but the call may fail at runtime, because of a null-pointer exception or an assertion that Kotlin generates to prevent nulls from propagating:</source>
          <target state="translated">플랫폼 유형의 변수에 대해 메소드를 호출하면 Kotlin은 컴파일 타임에 nullability 오류를 발생시키지 않지만 null 포인터 예외 또는 Kotlin이 널 전파를 막기 위해 생성하는 어설 션 때문에 런타임에 호출에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1fe34b679899f7dee6782797e3bf361c2fe90a" translate="yes" xml:space="preserve">
          <source>When we declare many types in our supertype list, it may appear that we inherit more than one implementation of the same method. For example</source>
          <target state="translated">수퍼 타입 ​​목록에 많은 타입을 선언 할 때, 같은 메소드의 구현을 두 개 이상 상속 한 것으로 보일 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="08c1783813dd9fc626a089b7cae223c9d065db16" translate="yes" xml:space="preserve">
          <source>When we have a named function declared like this:</source>
          <target state="translated">명명 된 함수가 다음과 같이 선언 된 경우 :</target>
        </trans-unit>
        <trans-unit id="61f9a57deb03c55b45ac7741559138e62485b782" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;b&lt;/code&gt;, we can say &quot;if &lt;code&gt;b&lt;/code&gt; is not null, use it, otherwise use some non-null value&quot;:</source>
          <target state="translated">When we have a nullable reference &lt;code&gt;b&lt;/code&gt; , we can say &quot;if &lt;code&gt;b&lt;/code&gt; is not null, use it, otherwise use some non-null value&quot;:</target>
        </trans-unit>
        <trans-unit id="fbc0820779d8db91f205b3ecbf7db0ccf41073a0" translate="yes" xml:space="preserve">
          <source>When we have a nullable reference &lt;code&gt;r&lt;/code&gt;, we can say &quot;if &lt;code&gt;r&lt;/code&gt; is not null, use it, otherwise use some non-null value &lt;code&gt;x&lt;/code&gt;&quot;:</source>
          <target state="translated">널 입력 가능 참조 &lt;code&gt;r&lt;/code&gt; 이있을 때 &quot; &lt;code&gt;r&lt;/code&gt; 이 널이 아닌 경우이를 사용하십시오. 그렇지 않으면 널이 아닌 값 &lt;code&gt;x&lt;/code&gt; 를 사용하십시오 &quot;라고 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5732d17582b0ef91e5bb01d205646ae68f3db2fc" translate="yes" xml:space="preserve">
          <source>When we pass a lambda to a dynamic call, all of its parameters by default have the type &lt;code&gt;dynamic&lt;/code&gt;:</source>
          <target state="translated">람다를 동적 호출에 전달하면 기본적으로 모든 매개 변수의 유형은 &lt;code&gt;dynamic&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="0be162a260a9be965f47e4e14ba8852bd8d1fa24" translate="yes" xml:space="preserve">
          <source>When we read from &lt;code&gt;p&lt;/code&gt; that delegates to an instance of &lt;code&gt;Delegate&lt;/code&gt;, the &lt;code&gt;getValue()&lt;/code&gt; function from &lt;code&gt;Delegate&lt;/code&gt; is called, so that its first parameter is the object we read &lt;code&gt;p&lt;/code&gt; from and the second parameter holds a description of &lt;code&gt;p&lt;/code&gt; itself (e.g. you can take its name). For example:</source>
          <target state="translated">우리가 읽을 때 &lt;code&gt;p&lt;/code&gt; 의 인스턴스에 위임 것을 &lt;code&gt;Delegate&lt;/code&gt; 의 &lt;code&gt;getValue()&lt;/code&gt; 에서 기능 &lt;code&gt;Delegate&lt;/code&gt; 라고, 그래서 첫 번째 매개 변수 개체가 우리가 읽은 것을 &lt;code&gt;p&lt;/code&gt; 에서 두 번째 매개 변수에 대한 설명을 보유하고 &lt;code&gt;p&lt;/code&gt; 자체를 (예를 들어, 당신이 취할 수 그것의 이름). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="111d8dd13a5f3aef5861ae64c3f6c02ff4cb90bb" translate="yes" xml:space="preserve">
          <source>When working from IntelliJ IDEA, we can find the &lt;code&gt;run&lt;/code&gt; action in the Gradle tool window.</source>
          <target state="translated">IntelliJ IDEA에서 작업 할 때 Gradle 도구 창에서 &lt;code&gt;run&lt;/code&gt; 작업을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad6c6017c96852fa45cd533d083255cb214a9f4c" translate="yes" xml:space="preserve">
          <source>When wrapping chained calls, put the &lt;code&gt;.&lt;/code&gt; character or the &lt;code&gt;?.&lt;/code&gt; operator on the next line, with a single indent:</source>
          <target state="translated">체인 통화를 줄 바꿈 할 때는 &lt;code&gt;.&lt;/code&gt; 문자 또는 &lt;code&gt;?.&lt;/code&gt; 한 줄 들여 쓰기로 다음 줄에 연산자 :</target>
        </trans-unit>
        <trans-unit id="9f05d7113cc0860bca9dd1b2c8b1f2efc8346629" translate="yes" xml:space="preserve">
          <source>When writing Kotlin code, an object may need to be converted from a Kotlin type to the equivalent Swift/Objective-C type (or vice versa). In this case a plain old Kotlin cast can be used, e.g.</source>
          <target state="translated">Kotlin 코드를 작성할 때 객체를 Kotlin 유형에서 동등한 Swift / Objective-C 유형으로 (또는 그 반대로) 변환해야 할 수 있습니다. 이 경우 평범한 오래된 Kotlin 캐스트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cafd8bf742afb2fbc35d3c6537af8b35836e156" translate="yes" xml:space="preserve">
          <source>When writing libraries, it's recommended to follow an additional set of rules to ensure API stability:</source>
          <target state="translated">라이브러리를 작성할 때 API 안정성을 보장하기 위해 추가 규칙 세트를 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d741918b948509f4aba6408fd1ef9e8a1136bd6e" translate="yes" xml:space="preserve">
          <source>When writing native applications, oftentimes we need to access certain functionality that is not included in the Kotlin standard library, such as making HTTP requests, reading and writing from disk, etc.</source>
          <target state="translated">네이티브 응용 프로그램을 작성할 때 종종 HTTP 요청, 디스크 읽기 및 쓰기와 같은 Kotlin 표준 라이브러리에 포함되지 않은 특정 기능에 액세스해야하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="463d09586d01fae3ba7cf55cbbc35d4b7f20011b" translate="yes" xml:space="preserve">
          <source>When you &lt;a href=&quot;mpp-create-lib&quot;&gt;create a multiplatform project&lt;/a&gt;, the Project Wizard automatically applies the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; Gradle plugin in the file &lt;code&gt;build.gradle&lt;/code&gt;(&lt;code&gt;.kts&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;mpp-create-lib&quot;&gt;멀티 플랫폼 프로젝트&lt;/a&gt; 를 만들 때 프로젝트 마법사는 &lt;code&gt;build.gradle&lt;/code&gt; ( &lt;code&gt;.kts&lt;/code&gt; ) 파일에 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; Gradle 플러그인을 자동으로 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="f3156a4be9cfb99131296400d8e473f56e52183c" translate="yes" xml:space="preserve">
          <source>When you are ready, verify the task with the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If you passed, there will be the &lt;strong&gt;Congratulations!&lt;/strong&gt; message:</source>
          <target state="translated">준비가되면 &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 상단의 &lt;strong&gt;확인&lt;/strong&gt; 아이콘으로 작업을 &lt;strong&gt;확인하십시오&lt;/strong&gt; . 당신이 통과하면 &lt;strong&gt;축하합니다! &lt;/strong&gt;메시지:&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="598dab40b3272c1fb9a453390cd6e6de1808ea5d" translate="yes" xml:space="preserve">
          <source>When you call a member function on &lt;code&gt;this&lt;/code&gt;, you can skip the &lt;code&gt;this.&lt;/code&gt; part. If you have a non-member function with the same name, use this with caution, because in some cases it can be called instead:</source>
          <target state="translated">When you call a member function on &lt;code&gt;this&lt;/code&gt; , you can skip the &lt;code&gt;this.&lt;/code&gt; part. If you have a non-member function with the same name, use this with caution, because in some cases it can be called instead:</target>
        </trans-unit>
        <trans-unit id="bd4f91db759426c5c027f930c965bc523e90edeb" translate="yes" xml:space="preserve">
          <source>When you call this function, the compiler will know that the execution doesn't continue beyond the call:</source>
          <target state="translated">이 함수를 호출하면 컴파일러는 실행이 호출 이상으로 계속되지 않는다는 것을 알게됩니다.</target>
        </trans-unit>
        <trans-unit id="ebc718bb513c3e899345e0a1f6bade26496caf51" translate="yes" xml:space="preserve">
          <source>When you choose the JavaScript target, any Kotlin code that is part of the project as well as the standard library that ships with Kotlin is transpiled to JavaScript. However, this excludes the JDK and any JVM or Java framework or library used. Any file that is not Kotlin will be ignored during compilation.</source>
          <target state="translated">JavaScript 대상을 선택하면 프로젝트의 일부인 Kotlin 코드 및 Kotlin과 함께 제공되는 표준 라이브러리가 JavaScript로 변환됩니다. 그러나 JDK와 사용 된 JVM 또는 Java 프레임 워크 또는 라이브러리는 제외됩니다. Kotlin이 아닌 파일은 컴파일 중에 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="61cb3b5bb55f1ec33f90df7914d7d8c5178a623a" translate="yes" xml:space="preserve">
          <source>When you compile a multiplatform project for a specific platform, the code for both the common and platform-specific parts is generated.</source>
          <target state="translated">특정 플랫폼에 대한 멀티 플랫폼 프로젝트를 컴파일하면 공통 및 플랫폼 별 파트 모두에 대한 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a4955e4afeb340ef9f82c25ba0af627acbecccfb" translate="yes" xml:space="preserve">
          <source>When you create a multiplatform project, targets are added to the &lt;code&gt;kotlin&lt;/code&gt; block in the file &lt;code&gt;build.gradle&lt;/code&gt; (&lt;code&gt;build.gradle.kts&lt;/code&gt;).</source>
          <target state="translated">멀티 플랫폼 프로젝트를 생성하면 &lt;code&gt;build.gradle&lt;/code&gt; ( &lt;code&gt;build.gradle.kts&lt;/code&gt; ) 파일 의 &lt;code&gt;kotlin&lt;/code&gt; 블록에 대상이 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="487f53e65f3e40a392960d7ffe8fb70d789db81a" translate="yes" xml:space="preserve">
          <source>When you create a progression implicitly by iterating a range, this progression's &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; elements are the range's endpoints, and the &lt;code&gt;step&lt;/code&gt; is 1.</source>
          <target state="translated">범위를 반복하여 암시 적으로 진행을 만들면이 진행의 &lt;code&gt;first&lt;/code&gt; 요소 와 &lt;code&gt;last&lt;/code&gt; 요소는 범위의 끝점이며 &lt;code&gt;step&lt;/code&gt; 는 1입니다.</target>
        </trans-unit>
        <trans-unit id="51bafee0f48839d4b74895eeb5d22b3bc95f6844" translate="yes" xml:space="preserve">
          <source>When you create own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="translated">콜렉션 인터페이스의 자체 구현을 작성할 때 해당 멤버 함수를 구현해야합니다. 새로운 구현을보다 쉽게 ​​만들려면 표준 라이브러리에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt; &lt;code&gt;AbstractCollection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt; &lt;code&gt;AbstractSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt; &lt;code&gt;AbstractMap&lt;/code&gt; &lt;/a&gt; 및 해당 가변 인터페이스와 같은 컬렉션 인터페이스의 골격 구현을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="de5ca0060f568734c25c44dc064e42505647a415" translate="yes" xml:space="preserve">
          <source>When you create your own implementations of collection interfaces, you must implement their member functions. To make the creation of new implementations easier, use the skeletal implementations of collection interfaces from the standard library: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt;&lt;code&gt;AbstractCollection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt;&lt;code&gt;AbstractList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt;&lt;code&gt;AbstractSet&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt;&lt;code&gt;AbstractMap&lt;/code&gt;&lt;/a&gt;, and their mutable counterparts.</source>
          <target state="translated">컬렉션 인터페이스의 고유 한 구현을 만들 때 해당 멤버 함수를 구현해야합니다. 새로운 구현을 더 쉽게 만들려면 표준 라이브러리에서 컬렉션 인터페이스의 골격 구현을 사용합니다. &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-collection/index&quot;&gt; &lt;code&gt;AbstractCollection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-list/index&quot;&gt; &lt;code&gt;AbstractList&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-set/index&quot;&gt; &lt;code&gt;AbstractSet&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-abstract-map/index&quot;&gt; &lt;code&gt;AbstractMap&lt;/code&gt; &lt;/a&gt; 및 변경 가능한 대응 항목을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dc3c8353ca1e574cdd5fef24454fb4fda2fc3277" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Pair&lt;/code&gt;s, you can do the reverse transformation &amp;ndash; &lt;em&gt;unzipping&lt;/em&gt; &amp;ndash; that builds two lists from these pairs:</source>
          <target state="translated">당신이있을 때 &lt;code&gt;List&lt;/code&gt; 의 &lt;code&gt;Pair&lt;/code&gt; -들, 당신은 반대로 변환 할 수있는 &lt;em&gt;압축을 해제&lt;/em&gt; -이 쌍에서 두 개의리스트를 작성합니다 :</target>
        </trans-unit>
        <trans-unit id="5c27d02fe0802eb2c5dc736c355913900c0370a9" translate="yes" xml:space="preserve">
          <source>When you have a variable or parameter of function type (sometimes called a &lt;em&gt;function reference&lt;/em&gt;), you can call it as if it were an ordinary function, and that will cause the referenced function to be called:</source>
          <target state="translated">함수 유형의 변수 또는 매개 변수가있는 경우 (때로는 &lt;em&gt;함수 참조&lt;/em&gt; 라고 함 ) 일반 함수처럼 호출 할 수 있으며 참조 된 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e1aaa92f5ddb308d5297a444696d8b7457b69a72" translate="yes" xml:space="preserve">
          <source>When you have finished creating your course, it's a good idea to view your course from a learner's perspective and test it. Right-click on the course view and go to &lt;strong&gt;Course Creator -&amp;gt; Create Course Preview&lt;/strong&gt; to open your course in learner mode:</source>
          <target state="translated">코스 만들기를 마치면 학습자의 관점에서 코스를보고 테스트하는 것이 좋습니다. 코스보기를 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;코스 작성자-&amp;gt; 코스 미리보기 작성으로&lt;/strong&gt; 이동하여 학습자 모드에서 코스를여십시오.</target>
        </trans-unit>
        <trans-unit id="a3250cc79c522d1ac623227bb111869e351b8f95" translate="yes" xml:space="preserve">
          <source>When you run this code, you'll see that the &lt;code&gt;filter()&lt;/code&gt; and &lt;code&gt;map()&lt;/code&gt; functions are executed in the same order as they appear in the code. First, you see &lt;code&gt;filter:&lt;/code&gt; for all elements, then &lt;code&gt;length:&lt;/code&gt; for the elements left after filtering, and then the output of the two last lines. This is how the list processing goes:</source>
          <target state="translated">이 코드를 실행하면 &lt;code&gt;filter()&lt;/code&gt; 및 &lt;code&gt;map()&lt;/code&gt; 함수가 코드에 표시된 순서대로 실행됩니다. 먼저 모든 요소에 대해 &lt;code&gt;filter:&lt;/code&gt; , 필터링 후 남은 요소에 대해서는 &lt;code&gt;length:&lt;/code&gt; , 마지막 두 줄의 출력이 표시됩니다. 이것이리스트 처리 방법입니다 :</target>
        </trans-unit>
        <trans-unit id="05ad4ed8cb6fd5863366c2a4f1abcdd6e5010b48" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following with the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">코드에서 &lt;code&gt;also&lt;/code&gt; 볼 때 &quot;로 읽을 수 있으며 &lt;em&gt;객체로 다음을 수행 할 수도 있습니다.&lt;/em&gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6928284bef91c96791612dd21e00cae5d64a5053" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;also&lt;/code&gt; in the code, you can read it as &amp;ldquo;&lt;em&gt;and also do the following&lt;/em&gt;&amp;rdquo;.</source>
          <target state="translated">코드 &lt;code&gt;also&lt;/code&gt; 볼 수 있으면 &quot;&quot; &lt;em&gt;로도&lt;/em&gt; 읽을 수 있으며 &lt;em&gt;다음을 수행 할 수도 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8d24e43a2e1296ae8492ad2425aad4e306037e84" translate="yes" xml:space="preserve">
          <source>When you switch to Kotlin, your xml layout files don't change at all. For instance, you use &lt;code&gt;variable&lt;/code&gt; within &lt;code&gt;data&lt;/code&gt; to describe a variable that may be used within the layout. You can declare a variable of a Kotlin type:</source>
          <target state="translated">Kotlin으로 전환해도 xml 레이아웃 파일은 전혀 변경되지 않습니다. 예를 들어, 사용 &lt;code&gt;variable&lt;/code&gt; 내에서 &lt;code&gt;data&lt;/code&gt; 레이아웃 내에서 사용할 수있는 변수를 설명하는. Kotlin 유형의 변수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1239262e94d3c7df345c600c729ad2ad431b78a5" translate="yes" xml:space="preserve">
          <source>When you take an interface or an open class as a parameter, you generally don't know the real type of the parameter at runtime, since it could be an instance of a subclass or of any class that implements the interface. It is possible to check what the exact type is, but like in Python, you should generally avoid it and instead design your class hierarchy such that you can do what you need by proper overriding of functions or properties.</source>
          <target state="translated">인터페이스 또는 공개 클래스를 매개 변수로 사용하면 일반적으로 런타임에 매개 변수의 실제 유형을 알 수 없습니다. 매개 변수는 하위 클래스의 인스턴스이거나 인터페이스를 구현하는 모든 클래스의 인스턴스 일 수 있기 때문입니다. 정확한 유형이 무엇인지 확인할 수 있지만 Python과 마찬가지로 일반적으로 유형을 피하고 대신 클래스 계층 구조를 디자인하여 함수 또는 속성을 적절히 재정 의하여 필요한 것을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="08daa6c22199d25d4c67e8e2145164a79b9c18ed" translate="yes" xml:space="preserve">
          <source>When you use an API in the code intended for third-party use (a library), you can propagate its opt-in requirement to your API as well. To do this, annotate your declaration with the &lt;a href=&quot;#opt-in-requirement-annotations&quot;&gt;&lt;em&gt;opt-in requirement annotation&lt;/em&gt;&lt;/a&gt; of the API used in its body. This enables you to use the API elements marked with this annotation.</source>
          <target state="translated">타사 사용을위한 코드 (라이브러리)에서 API를 사용하는 경우 해당 옵트 인 요구 사항을 API에도 전파 할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이렇게하려면 본문에 사용 된 API 의 &lt;a href=&quot;#opt-in-requirement-annotations&quot;&gt;&lt;em&gt;옵트 인 요구 사항 주석&lt;/em&gt;&lt;/a&gt; 으로 선언에 주석을 추가합니다 . 이렇게하면이 주석으로 표시된 API 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a7fe00cf3644a358da554d74666746417284178" translate="yes" xml:space="preserve">
          <source>When you use an arithmetic operator on two integers of different types, the result is &quot;upgraded&quot; to the widest type. Note that the result might still overflow.</source>
          <target state="translated">다른 유형의 두 정수에 대해 산술 연산자를 사용하면 결과가 가장 넓은 유형으로 &quot;업그레이드&quot;됩니다. 결과가 여전히 오버플로 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c62a163cbef716d256d43a2d19d876bb12a78c5" translate="yes" xml:space="preserve">
          <source>When you use an experimental API in the code intended for third-party use (a library), you can mark your API as experimental as well. To do this, annotate your declaration with the &lt;em&gt;experimental marker annotation&lt;/em&gt; of the API used in its body. This enables you to use the API elements annotated with this marker.</source>
          <target state="translated">타 사용 코드 (라이브러리)에서 실험용 API를 사용하는 경우 API도 실험용으로 표시 할 수 있습니다. 이렇게하려면 본문에 사용 된 API 의 &lt;em&gt;실험 마커 주석&lt;/em&gt; 으로 선언에 주석을 답니다 . 이를 통해이 마커로 주석이 달린 API 요소를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b65a21854b89868579d67b03180df54f3544a9" translate="yes" xml:space="preserve">
          <source>When you use named arguments in a function call, you can freely change the order they are listed in, and if you want to use their default values you can just leave them out altogether.</source>
          <target state="translated">함수 호출에서 명명 된 인수를 사용할 때 나열되는 순서를 자유롭게 변경할 수 있으며 기본값을 사용하려는 경우 모두 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d4e3a5ba4e31277cb9f0e61d2e54f709bf8961" translate="yes" xml:space="preserve">
          <source>When you're annotating a property or a primary constructor parameter, there are multiple Java elements which are generated from the corresponding Kotlin element, and therefore multiple possible locations for the annotation in the generated Java bytecode. To specify how exactly the annotation should be generated, use the following syntax:</source>
          <target state="translated">속성 또는 기본 생성자 매개 변수에 주석을 달 때 해당 Kotlin 요소에서 생성되는 여러 Java 요소가 있으므로 생성 된 Java 바이트 코드에서 주석에 대한 여러 가능한 위치가 있습니다. 주석을 정확히 생성하는 방법을 지정하려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b61884cef7d3f26b08581a78b91851698ab0fd2b" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;jvmMain&lt;/code&gt; is compiled for a certain target, &lt;code&gt;commonMain&lt;/code&gt; takes part in that compilation as well and is also compiled into the same target binary form, such as JVM class files.</source>
          <target state="translated">때마다 &lt;code&gt;jvmMain&lt;/code&gt; 이 특정 대상에 대해 컴파일, &lt;code&gt;commonMain&lt;/code&gt; 은 그뿐만 아니라 편집에 참여한다하고 또한 JVM 클래스 파일로, 동일한 대상 바이너리 형태로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="89ad1e4f32412313aa6f0bd650dfc39dcb173e7f" translate="yes" xml:space="preserve">
          <source>Whenever it is invoked on the same object more than once, the &lt;code&gt;hashCode&lt;/code&gt; method must consistently return the same integer, provided no information used in &lt;code&gt;equals&lt;/code&gt; comparisons on the object is modified.</source>
          <target state="translated">동일한 객체에서 두 번 이상 호출 될 때마다 &lt;code&gt;hashCode&lt;/code&gt; 메소드는 객체의 &lt;code&gt;equals&lt;/code&gt; 비교에 사용 된 정보 가 수정 되지 않으면 동일한 정수를 일관되게 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="55d78075233bceac802e1984993c3d3b3088601f" translate="yes" xml:space="preserve">
          <source>Whenever you create an instance of this class, you must specify an actual type in place of &lt;code&gt;T&lt;/code&gt;, unless the compiler can infer it from the constructor parameters: &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; or &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt;. Every use of this instance will act as if it were an instance of a class that looks like this:</source>
          <target state="translated">이 클래스의 인스턴스를 작성할 때마다 컴파일러가 생성자 매개 변수 &lt;code&gt;TreeNode(&quot;foo&quot;)&lt;/code&gt; 또는 &lt;code&gt;TreeNode&amp;lt;String&amp;gt;(null)&lt;/code&gt; 에서 유추 할 수없는 경우 &lt;code&gt;T&lt;/code&gt; 대신 실제 유형을 지정해야합니다 . 이 인스턴스를 사용할 때마다 다음과 같은 클래스의 인스턴스처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8ca39f6f0f111844ff04d02c9f4bf0efee656845" translate="yes" xml:space="preserve">
          <source>Whenever you use an arithmetic operator on two integers of the same type (or when you use a unary operator like negation), &lt;em&gt;there is no automatic &quot;upgrading&quot; if the result doesn't fit in the type of the operands!&lt;/em&gt; Try this:</source>
          <target state="translated">동일한 유형의 두 정수에 대해 산술 연산자를 사용할 때마다 (또는 부정과 같은 단항 연산자를 사용할 때) &lt;em&gt;결과가 피연산자의 유형에 맞지 않으면 자동 &quot;업그레이드&quot;가 없습니다! &lt;/em&gt;이 시도:</target>
        </trans-unit>
        <trans-unit id="b65896c2c2c1091be4cf3076a04d4d7b1bc8f223" translate="yes" xml:space="preserve">
          <source>Whenever you want a variable that can only take on a limited number of values where the only feature of each value is that it's distinct from all the other values, you can create an &lt;em&gt;enum class&lt;/em&gt;:</source>
          <target state="translated">각 값의 유일한 특징이 다른 모든 값과 구별되는 것이 제한된 수의 값만 취할 수있는 변수를 원할 때마다 &lt;em&gt;열거 형 클래스를&lt;/em&gt; 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b72a1d211e3475b177a16c0ad833aad00f45de47" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;__TYPE__&lt;/code&gt; is one of the simple type names and &lt;code&gt;__CTYPE__&lt;/code&gt; is the related Objective-C type, e.g. &lt;code&gt;initWithChar(char)&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;__TYPE__&lt;/code&gt; 은 단순 유형 이름 중 하나이고 &lt;code&gt;__CTYPE__&lt;/code&gt; 은 관련된 Objective-C 유형입니다 (예 : &lt;code&gt;initWithChar(char)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="279ee64e67a8a3e973e45233e8ce0a407cbaf608" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;declarationToKeep&lt;/code&gt; has the following syntax:</source>
          <target state="translated">어디 &lt;code&gt;declarationToKeep&lt;/code&gt; 는 다음과 같은 구문이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="eb06827a60ce404697c981082d7a9ff58779079e" translate="yes" xml:space="preserve">
          <source>Where can I get an HD Kotlin logo?</source>
          <target state="translated">HD Kotlin 로고는 어디서 구할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="00d532d7604042ff0388fc0d8b327eb21555113f" translate="yes" xml:space="preserve">
          <source>Where can I learn more about Kotlin?</source>
          <target state="translated">Kotlin에 대한 자세한 정보는 어디서 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="60dc3003b0157a1bb3a0084a1e562958004b1c24" translate="yes" xml:space="preserve">
          <source>Whether a main function should be called</source>
          <target state="translated">메인 함수 호출 여부</target>
        </trans-unit>
        <trans-unit id="350fceb3b43601161521c9570f080755bec5203a" translate="yes" xml:space="preserve">
          <source>Whether metadata file with binary descriptors should be generated</source>
          <target state="translated">이진 설명자가 포함 된 메타 데이터 파일을 생성해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="b1689158ae06f88b863b7fd9b887d675c25f4bd4" translate="yes" xml:space="preserve">
          <source>Whether sourcemap file should be generated</source>
          <target state="translated">소스 맵 파일 생성 여부</target>
        </trans-unit>
        <trans-unit id="e52f46f155653a3c2a2e009ba12b0ccd1ff43ab6" translate="yes" xml:space="preserve">
          <source>Which prints:</source>
          <target state="translated">어떤 인쇄 :</target>
        </trans-unit>
        <trans-unit id="c668af734b8bab593fb373580041499369e8214b" translate="yes" xml:space="preserve">
          <source>Which versions of JVM does Kotlin target?</source>
          <target state="translated">Kotlin은 어떤 버전의 JVM을 타겟팅하나요?</target>
        </trans-unit>
        <trans-unit id="02402c88e9d606c5d9042e0b0c12d1739344aeb9" translate="yes" xml:space="preserve">
          <source>While Kotlin annotations look like Python decorators, they are far less flexible: they can generally only be used for metadata. They are pure data-containing classes, and do not contain any executable code. Some built-in annotations have an effect on the compilation process (such as &lt;code&gt;@JvmStatic&lt;/code&gt;), but custom annotations are only useful for providing metadata that can be inspected at runtime by the reflection system. We won't delve deeply into annotations here, but here is an example. The annotations on the annotation declaration itself specify what constructs the annotation may be applied to and whether it is available for runtime inspection.</source>
          <target state="translated">Kotlin 주석은 Python 데코레이터처럼 보이지만 유연성이 훨씬 떨어집니다. 일반적으로 메타 데이터에만 사용할 수 있습니다. 그것들은 순수한 데이터를 포함하는 클래스이며 실행 코드를 포함하지 않습니다. 일부 내장 주석은 컴파일 프로세스 (예 : &lt;code&gt;@JvmStatic&lt;/code&gt; ) 에 영향을 미치지 만 사용자 정의 주석은 리플렉션 시스템에서 런타임에 검사 할 수있는 메타 데이터를 제공하는 데만 유용합니다. 여기서는 주석에 대해 자세히 다루지 않지만 여기에 예가 있습니다. 어노테이션 선언 자체의 어노테이션은 어노테이션이 적용될 수있는 구문과 런타임 검사에 사용 가능한지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a68a67a970d91d390715c4a5723442211582200e" translate="yes" xml:space="preserve">
          <source>While Loops</source>
          <target state="translated">While 루프</target>
        </trans-unit>
        <trans-unit id="c1b7c19248a78707f3905a80fc2242e3ecc22b20" translate="yes" xml:space="preserve">
          <source>While being different, conceptually, Flow &lt;em&gt;is&lt;/em&gt; a reactive stream and it is possible to convert it to the reactive (spec and TCK compliant) Publisher and vice versa. Such converters are provided by &lt;code&gt;kotlinx.coroutines&lt;/code&gt; out-of-the-box and can be found in corresponding reactive modules (&lt;code&gt;kotlinx-coroutines-reactive&lt;/code&gt; for Reactive Streams, &lt;code&gt;kotlinx-coroutines-reactor&lt;/code&gt; for Project Reactor and &lt;code&gt;kotlinx-coroutines-rx2&lt;/code&gt;/&lt;code&gt;kotlinx-coroutines-rx3&lt;/code&gt; for RxJava2/RxJava3). Integration modules include conversions from and to &lt;code&gt;Flow&lt;/code&gt;, integration with Reactor's &lt;code&gt;Context&lt;/code&gt; and suspension-friendly ways to work with various reactive entities.</source>
          <target state="translated">개념적으로는 다르지만 Flow &lt;em&gt;는&lt;/em&gt; 반응 적 스트림이며 반응 형 (사양 및 TCK 준수) 게시자로 변환하거나 그 반대로 변환 할 수 있습니다. 그러한 컨버터에서 제공 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 아웃 오브 박스 (반응성 모듈을 대응에서 찾을 수 &lt;code&gt;kotlinx-coroutines-reactive&lt;/code&gt; 대하여 반응성 스트림 용 &lt;code&gt;kotlinx-coroutines-reactor&lt;/code&gt; 프로젝트 반응기위한 &lt;code&gt;kotlinx-coroutines-rx2&lt;/code&gt; / &lt;code&gt;kotlinx-coroutines-rx3&lt;/code&gt; RxJava2 / RxJava3 용 coroutines-rx3 ). 통합 모듈에는 &lt;code&gt;Flow&lt;/code&gt; 로의 변환 , Reactor의 &lt;code&gt;Context&lt;/code&gt; 와의 통합 및 다양한 반응 엔티티와 함께 ​​작동하는 서스펜션 친화적 인 방법이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="178ea4ef9776a99f280cbce3c37b6808c99bffb3" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, it does not scale well for larger projects with hundreds of files and libraries. For real-world projects it is recommended to use a &lt;a href=&quot;using-gradle&quot;&gt;build system&lt;/a&gt; and &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt;.</source>
          <target state="translated">콘솔에서 컴파일하는 것은 쉽고 명확 해 보이지만 수백 개의 파일과 라이브러리가있는 대규모 프로젝트에서는 제대로 확장되지 않습니다. 실제 프로젝트의 경우 &lt;a href=&quot;using-gradle&quot;&gt;빌드 시스템&lt;/a&gt; 과 &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="405a10cf31f596bca1e965bfbd41f2ec04a34af9" translate="yes" xml:space="preserve">
          <source>While compilation from the console seems to be easy and clear, we should notice, that it does not scale well for bigger projects with hundreds of files and libraries. In addition to this, the command line approach does not explain to an IDE how to open such a project, where the sources are located, what dependencies are used, or how the dependencies are downloaded and so on.</source>
          <target state="translated">콘솔에서 컴파일하는 것이 쉽고 분명한 것처럼 보이지만 수백 개의 파일과 라이브러리가있는 더 큰 프로젝트에는 적합하지 않습니다. 이 외에도 명령 줄 접근 방식은 IDE에 이러한 프로젝트를 여는 방법, 소스가있는 위치, 사용되는 종속성 또는 종속성을 다운로드하는 방법 등을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e744f3d4d9082a8982116fd4e4676866618d662" translate="yes" xml:space="preserve">
          <source>While cross-platform compilation is possible, which means using one platform to compile for a different one, in this case we'll be targeting the same platform we're compiling on.</source>
          <target state="translated">크로스 플랫폼 컴파일이 가능합니다. 즉, 하나의 플랫폼을 사용하여 다른 플랫폼을 컴파일하는 것을 의미하지만이 경우 컴파일하는 플랫폼과 동일한 플랫폼을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="6ce105800554de67a92cb5eed4d6aabf562edfb9" translate="yes" xml:space="preserve">
          <source>While doing so was not useful in this particular example, one could get interesting effects by adding an unprojected parameter type &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt;, in which case the generic type parameter of &lt;code&gt;via&lt;/code&gt; would be forced to be &quot;in-between&quot; those of &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">그렇게하는 것은이 특정 예제에서는 유용하지 않지만, &lt;code&gt;via: Bowl&amp;lt;T&amp;gt;&lt;/code&gt; 투사되지 않은 매개 변수 유형 을 추가하여 흥미로운 효과를 얻을 수 있습니다 . 이 경우 &lt;code&gt;via&lt;/code&gt; 의 일반 유형 매개 변수 는 &lt;code&gt;from&lt;/code&gt; 와 &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74f25352205ca76e991ebde88bff4a464449ff37" translate="yes" xml:space="preserve">
          <source>While it is possible in Kotlin to dynamically create new classes at runtime or to add members to a class, it's tricky and slow, and generally discouraged. However, it is easy to dynamically inspect an object to see e.g. what properties and functions it contains and which annotations exist on them. This is called &lt;em&gt;reflection&lt;/em&gt;, and it's not very performant, so avoid it unless you really need it.</source>
          <target state="translated">Kotlin에서는 런타임에 동적으로 새 클래스를 만들거나 멤버를 클래스에 추가 할 수 있지만 까다 롭고 느리고 일반적으로 권장하지 않습니다. 그러나 객체를 동적으로 검사하면 객체에 포함 된 속성 및 기능과 객체에 어떤 주석이 있는지 확인할 수 있습니다. 이것을 &lt;em&gt;reflection&lt;/em&gt; 이라고 하며 성능이 좋지 않으므로 실제로 필요하지 않으면 피하십시오.</target>
        </trans-unit>
        <trans-unit id="00ebcc3032e38c0f9dbd212c37ea7b7605032b6f" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="translated">명령 행을 직접 사용하거나 스크립트 파일 (예 : sh 또는 bat 파일)과 결합하여 사용할 수 있지만 수백 개의 파일 및 라이브러리가있는 큰 프로젝트에는 적합하지 않습니다. 그런 다음 Kotlin / Native 컴파일러 바이너리와 라이브러리를 전이 종속성으로 다운로드하고 캐시하고 컴파일러와 테스트를 실행하는 데 도움이되므로 Kotlin / Native 컴파일러를 빌드 시스템과 함께 사용하는 것이 좋습니다. Kotlin / Native는 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 통해 &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; 빌드 시스템을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccb7cdd4315f54dc22cc954a705304d8025d4496" translate="yes" xml:space="preserve">
          <source>While it is possible to use the command line, either directly or by combining it with a script file (i.e., sh or bat file), we should notice, that it does not scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin.</source>
          <target state="translated">명령 줄을 직접 사용하거나 스크립트 파일 (예 : sh 또는 bat 파일)과 결합하여 사용할 수 있지만 수백 개의 파일과 라이브러리가있는 큰 프로젝트에서는 확장되지 않는다는 점에 유의해야합니다. 그러면 빌드 시스템과 함께 Kotlin / Native 컴파일러를 사용하는 것이 좋습니다. 이는 전이 종속성이있는 Kotlin / Native 컴파일러 바이너리 및 라이브러리를 다운로드하고 캐시하고 컴파일러 및 테스트를 실행하는 데 도움이됩니다. Kotlin / Native는 &lt;a href=&quot;../../reference/mpp-discover-project#multiplatform-plugin&quot;&gt;kotlin-multiplatform을&lt;/a&gt; 통해 &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; 빌드 시스템을 사용할 수 있습니다. 플러그인을 .</target>
        </trans-unit>
        <trans-unit id="4688c1c9cfee712dab9268862c4aa04c7274850f" translate="yes" xml:space="preserve">
          <source>While it was already possible to extract this variable just before &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;val&lt;/code&gt; in &lt;code&gt;when&lt;/code&gt; has its scope properly restricted to the body of &lt;code&gt;when&lt;/code&gt;, and so preventing namespace pollution. See the full documentation on &lt;code&gt;when&lt;/code&gt;&lt;a href=&quot;control-flow#when-expression&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이는 직전이 변수를 추출하는 동안 이미 가능한 &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;val&lt;/code&gt; 의 &lt;code&gt;when&lt;/code&gt; 그 범위가 제대로의 본체에 제한 &lt;code&gt;when&lt;/code&gt; , 그리고되도록 공간 오염을 방지한다. 에 대한 전체 설명서를 참조 &lt;code&gt;when&lt;/code&gt; &lt;a href=&quot;control-flow#when-expression&quot;&gt;여기를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18fc211f02fff65fa62198ec0d6b2196f5fda852" translate="yes" xml:space="preserve">
          <source>While most IDE's including &lt;a href=&quot;https://www.jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; can generate the corresponding Gradle file, we're going to take a look at how to create this manually, to have a better understanding of how things work under the covers. If you'd like to use the IDE, check out &lt;a href=&quot;using-intellij-idea&quot;&gt;Using IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/idea&quot;&gt;IntelliJ IDEA를&lt;/a&gt; 포함한 대부분의 IDE 는 해당 Gradle 파일을 생성 할 수 있지만 , 내부에서 작동하는 방식을 더 잘 이해하기 위해 수동으로 생성하는 방법을 살펴 보겠습니다. IDE를 사용하려면 &lt;a href=&quot;using-intellij-idea&quot;&gt;IntelliJ IDEA 사용을&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="edf1dfe40b0f0a7f06896b58374c31b6b8d9a056" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.2 to Kotlin 1.3</source>
          <target state="translated">대부분의 언어 변경이 업데이트 변경 로그 또는 컴파일러 경고와 같은 다른 채널을 통해 이미 발표되었지만이 문서는 Kotlin 1.2에서 Kotlin 1.3으로의 마이그레이션에 대한 완전한 참조를 제공하여 모든 내용을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="b3798978e8389c22f139d4b97896bde1b7b9685d" translate="yes" xml:space="preserve">
          <source>While most of the language changes were already announced through other channels, like update changelogs or compiler warnings, this document summarizes them all, providing a complete reference for migration from Kotlin 1.3 to Kotlin 1.4.</source>
          <target state="translated">대부분의 언어 변경 사항은 업데이트 변경 로그 또는 컴파일러 경고와 같은 다른 채널을 통해 이미 발표되었지만이 문서는 모든 내용을 요약하여 Kotlin 1.3에서 Kotlin 1.4로 마이그레이션하기위한 완전한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="399ba37d2ce977b9a644dbef3594c75ca535f65a" translate="yes" xml:space="preserve">
          <source>While the above solution works well for situations in which we have a corresponding header file (be this something we've defined ourselves or converted from a TypeScript header), often times we need to work with some library that does not have a header. For instance, let's say we want to use a jQuery plugin, that allows us to convert an HTML table to a nice looking navigable grid.</source>
          <target state="translated">위의 솔루션은 해당 헤더 파일 (이것은 우리가 직접 정의하거나 TypeScript 헤더에서 변환 한 것)이있는 상황에서 잘 작동하지만 종종 헤더가없는 일부 라이브러리에서 작업 해야하는 경우가 있습니다. 예를 들어, jQuery 플러그인을 사용하여 HTML 테이블을 멋진 탐색 가능한 그리드로 변환 할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7193542d5cd6b24f8c9a4e41a255c37b1a878838" translate="yes" xml:space="preserve">
          <source>While the converter is not fool-proof, it does a pretty decent job of converting most boilerplate code from Java to Kotlin. Some manual tweaking however is sometimes required.</source>
          <target state="translated">이 변환기는 완벽하지는 않지만 대부분의 상용구 코드를 Java에서 Kotlin으로 변환하는 것은 꽤 괜찮은 일입니다. 그러나 일부 수동 조정이 필요한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3c9392710d351a08ea5a20fd29014ffdd0dc8f8" translate="yes" xml:space="preserve">
          <source>While the dots suggest that packages are nested inside each other, that's not actually the case from a language standpoint. While it's a good idea to organize your code such that the &quot;subpackages&quot; of &lt;code&gt;content&lt;/code&gt;, such as &lt;code&gt;content.exercises&lt;/code&gt; and &lt;code&gt;content.articles&lt;/code&gt;, both contain content-related code, these three packages are unrelated from a language standpoint. However, if you use &lt;em&gt;modules&lt;/em&gt; (as defined by your build system), it is typically the case that all &quot;subpackages&quot; go in the same module, in which case symbols with &lt;a href=&quot;visibility-modifiers&quot;&gt;&lt;code&gt;internal&lt;/code&gt; visibility&lt;/a&gt; are visible throughout the subpackages.</source>
          <target state="translated">점은 패키지가 서로 중첩되어 있음을 시사하지만 실제로 언어의 관점에서는 그렇지 않습니다. &lt;code&gt;content.exercises&lt;/code&gt; 및 &lt;code&gt;content.articles&lt;/code&gt; 와 같은 &lt;code&gt;content&lt;/code&gt; 의 &quot;하위 패키지&quot;에 모두 컨텐츠 관련 코드가 포함 되도록 코드를 구성하는 것이 좋습니다 .이 세 가지 패키지는 언어 관점과 관련이 없습니다. 그러나 (빌드 시스템에서 정의한대로) &lt;em&gt;모듈&lt;/em&gt; 을 사용 하는 경우 일반적으로 모든 &quot;하위 패키지&quot;가 동일한 모듈에 들어가는 경우가 있으며,이 경우 &lt;a href=&quot;visibility-modifiers&quot;&gt; &lt;code&gt;internal&lt;/code&gt; &lt;/a&gt; 가시성 이있는 기호가 하위 패키지 전체에 표시됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f4289b089753c293140e137503818ca7bef2f53" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself and the Gradle build system require a Java 1.8 or 11 runtime. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or another resource for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">컴파일러의 출력에는 종속성이나 가상 시스템 요구 사항이 없지만 컴파일러 자체와 Gradle 빌드 시스템에는 Java 1.8 또는 11 런타임이 필요합니다. 최상의 JRE, OpenJDK 또는 JDK 배포에 대해서는 &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; 또는 다른 리소스를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="10c2d0246f094d4009ab7bad0367365f4bcc7c84" translate="yes" xml:space="preserve">
          <source>While the output of the compiler does not have any dependencies or virtual machine requirements, the compiler itself requires &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;Java 1.8 or higher runtime&lt;/a&gt;.</source>
          <target state="translated">컴파일러의 출력에는 종속성이나 가상 머신 요구 사항이 없지만 컴파일러 자체에는 &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;Java 1.8 이상의 런타임이&lt;/a&gt; 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="34d621226a511f26c66770b36d29a5c867fde780" translate="yes" xml:space="preserve">
          <source>While this example happened to use the same expression, that is not necessary - overloaded functions can do completely different things if need be (although your code can get confusing if you make functions that have very different behavior be overloads of each other).</source>
          <target state="translated">이 예제는 동일한 표현식을 사용하는 동안 필요하지는 않습니다. 오버로드 된 함수는 필요한 경우 완전히 다른 작업을 수행 할 수 있습니다 (매우 다른 동작을하는 함수가 서로 오버로드되는 경우 코드가 혼동 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="68ab041f58d77da2145ef925bbf99b70a47a9c63" translate="yes" xml:space="preserve">
          <source>While uploading your library to Bintray, you will see multiple versions for each artifact (such as &lt;code&gt;my-library-jvm&lt;/code&gt;, &lt;code&gt;my-library-metadata&lt;/code&gt;, etc.). To fix this, add &lt;code&gt;systemProp.org.gradle.internal.publish.checksums.insecure=true&lt;/code&gt;. See &lt;a href=&quot;https://github.com/gradle/gradle/issues/11412&quot;&gt;this issue&lt;/a&gt; for details. This is a common Gradle 6.0 issue that is neither MPP nor Kotlin specific.</source>
          <target state="translated">라이브러리를 Bintray에 업로드하는 동안 각 아티팩트 (예 : &lt;code&gt;my-library-jvm&lt;/code&gt; , &lt;code&gt;my-library-metadata&lt;/code&gt; 등) 에 대해 여러 버전이 표시됩니다 . 이 문제를 해결하려면 &lt;code&gt;systemProp.org.gradle.internal.publish.checksums.insecure=true&lt;/code&gt; 를 추가하십시오 . 자세한 내용은 &lt;a href=&quot;https://github.com/gradle/gradle/issues/11412&quot;&gt;이 호&lt;/a&gt; 를 참조하십시오. 이것은 MPP도 Kotlin 과도 관련이없는 일반적인 Gradle 6.0 문제입니다.</target>
        </trans-unit>
        <trans-unit id="29d4507848ac2db4dd040b8f1b98e137154ce676" translate="yes" xml:space="preserve">
          <source>While we don&amp;rsquo;t recommend it, you can use a wildcard &lt;code&gt;*&lt;/code&gt; in place of a version number if you do not want to specify a version or version range explicitly.</source>
          <target state="translated">권장 하지는 않지만 버전 또는 버전 범위를 명시 적으로 지정하지 않으려는 경우 버전 번호 대신 와일드 카드 &lt;code&gt;*&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79482c24120b8d210f4051a8c238d3feb29fa237" translate="yes" xml:space="preserve">
          <source>Who develops Kotlin?</source>
          <target state="translated">코 틀린은 누가 개발합니까?</target>
        </trans-unit>
        <trans-unit id="6b8ca7e4bd278a327d17a1ff62cc87137c652d74" translate="yes" xml:space="preserve">
          <source>Why Kotlin/Native?</source>
          <target state="translated">왜 Kotlin / Native입니까?</target>
        </trans-unit>
        <trans-unit id="5327cb3e3f7820311f240e8254b2120a882043dc" translate="yes" xml:space="preserve">
          <source>Why not just add required manifest options to all Kotlin libraries</source>
          <target state="translated">모든 Kotlin 라이브러리에 필요한 매니페스트 옵션을 추가하지 않는 이유</target>
        </trans-unit>
        <trans-unit id="dc289721e21b7419371258307342fbd161fffe25" translate="yes" xml:space="preserve">
          <source>Wildcard-types</source>
          <target state="translated">Wildcard-types</target>
        </trans-unit>
        <trans-unit id="1a6e732a37845c36fcda3afa6f1ba0d920b0ebca" translate="yes" xml:space="preserve">
          <source>WindowEventHandlers</source>
          <target state="translated">WindowEventHandlers</target>
        </trans-unit>
        <trans-unit id="0be6c8c411ba30d8cffb7e90ca7acef58e77aa71" translate="yes" xml:space="preserve">
          <source>WindowLocalStorage</source>
          <target state="translated">WindowLocalStorage</target>
        </trans-unit>
        <trans-unit id="4695cae95157eec4a2f36b8710914191b7160a60" translate="yes" xml:space="preserve">
          <source>WindowOrWorkerGlobalScope</source>
          <target state="translated">WindowOrWorkerGlobalScope</target>
        </trans-unit>
        <trans-unit id="837e70bad69f4bf6bd4622325d1fb73918d9e99b" translate="yes" xml:space="preserve">
          <source>WindowSessionStorage</source>
          <target state="translated">WindowSessionStorage</target>
        </trans-unit>
        <trans-unit id="7d22ecce0385c959845f551d5a3b5ab183398dfa" translate="yes" xml:space="preserve">
          <source>Windowed</source>
          <target state="translated">Windowed</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="628596087f96fc1704310fa20e91f817ad0907ae" translate="yes" xml:space="preserve">
          <source>Windows (mingw x86_64, x86)</source>
          <target state="translated">Windows (mingw x86_64, x86)</target>
        </trans-unit>
        <trans-unit id="3501a24aebe2c74160390742479cffed6294f769" translate="yes" xml:space="preserve">
          <source>Windows targets require a Windows host;</source>
          <target state="translated">Windows 대상에는 Windows 호스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ce9d44e441b23e1629b147f917e9518ae0913959" translate="yes" xml:space="preserve">
          <source>Windows: &lt;code&gt;libnative_api.h&lt;/code&gt;, &lt;code&gt;libnative_symbols.def&lt;/code&gt; and &lt;code&gt;libnative.dll&lt;/code&gt;</source>
          <target state="translated">Windows : &lt;code&gt;libnative_api.h&lt;/code&gt; , &lt;code&gt;libnative_symbols.def&lt;/code&gt; 및 &lt;code&gt;libnative.dll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a374d672ab75b4235e338c90ddfcf6afbecca5" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes course creation for an educator. If you want to use EduTools plugin for learning, read &lt;a href=&quot;edu-tools-learner&quot;&gt;&quot;Learning Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; 플러그인을 사용하면 코드 연습 작업을 통해 Kotlin을 배우고 가르 칠 수 있습니다. &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; 및 &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; 모두에서 사용할 수 있습니다 . 이 학습서는 교육자를위한 코스 작성에 대해 설명합니다. 학습에 EduTools 플러그인을 사용하려면 &lt;a href=&quot;edu-tools-learner&quot;&gt;&quot;EduTools 플러그인으로 Kotlin 학습&quot;을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="d7e4afdf3ca90295d086cf8bfcf9a9049903e7a2" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; plugin you can learn and teach Kotlin through code practicing tasks. It is available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. This tutorial describes the interactive learning. If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;&quot;Teaching Kotlin with EduTools plugin&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools&lt;/a&gt; 플러그인을 사용하면 코드 연습 작업을 통해 Kotlin을 배우고 가르 칠 수 있습니다. &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; 및 &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; 모두에서 사용할 수 있습니다 . 이 학습서는 대화식 학습에 대해 설명합니다. 교육에 EduTools 플러그인을 사용하려면 &lt;a href=&quot;edu-tools-educator&quot;&gt;&quot;EduTools 플러그인으로 Kotlin 교육&quot;을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ddbee1008f9f20e446d88d4f79956907a6b4c399" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;the new hierarchical project structure support&lt;/a&gt;, you can share code among several targets in a multiplatform project. You can use platform-dependent libraries, such as &lt;code&gt;Foundation&lt;/code&gt;, &lt;code&gt;UIKit&lt;/code&gt;, and &lt;code&gt;posix&lt;/code&gt; in source sets shared among several native targets. This can help you share more native code without being limited by platform-specific dependencies.</source>
          <target state="translated">으로 &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;새로운 계층 적 프로젝트 구조 지원&lt;/a&gt; , 당신은 다중 프로젝트에서 여러 목표들 사이에서 코드를 공유 할 수 있습니다. 여러 기본 대상간에 공유되는 소스 세트에서 &lt;code&gt;Foundation&lt;/code&gt; , &lt;code&gt;UIKit&lt;/code&gt; 및 &lt;code&gt;posix&lt;/code&gt; 와 같은 플랫폼 종속 라이브러리를 사용할 수 있습니다 . 이를 통해 플랫폼 별 종속성의 제한없이 더 많은 네이티브 코드를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91c32707acceb3a92d660aaa2664e3b3b359ee59" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;let&lt;/code&gt;, you can rewrite it:</source>
          <target state="translated">함께 &lt;code&gt;let&lt;/code&gt; , 당신은 그것을 다시 작성할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="af688b954f4540e476c35b0f74f11c5204100c85" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lisa&lt;/code&gt; and &lt;code&gt;anne&lt;/code&gt; from the infix example, you can now do:</source>
          <target state="translated">와 &lt;code&gt;lisa&lt;/code&gt; 와 &lt;code&gt;anne&lt;/code&gt; 중위 예에서, 당신은 지금 할 수있는 :</target>
        </trans-unit>
        <trans-unit id="32acfa5cff03b7f1ee491ea16213412942069586" translate="yes" xml:space="preserve">
          <source>With Gradle 6.0 and above, you are now able to load all scripts at once as opposed to the previous implementation where they were loaded individually. Since each request requires the Gradle configuration phase to be executed, this could be resource-intensive for large Gradle projects.</source>
          <target state="translated">Gradle 6.0 이상에서는 개별적으로로드 된 이전 구현과 달리 이제 모든 스크립트를 한 번에로드 할 수 있습니다. 각 요청을 실행하려면 Gradle 구성 단계가 필요하므로 대규모 Gradle 프로젝트의 경우 리소스 집약적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2bc622686f7933d6457fe256aa33e7162dce61a" translate="yes" xml:space="preserve">
          <source>With Gradle Kotlin DSL, configure source sets with &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; instead.</source>
          <target state="translated">Gradle Kotlin DSL을 사용하면 &lt;code&gt;java.sourceSets { ... }&lt;/code&gt; 소스 세트를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf21fbd8ac94a33fdcdb64a0972b9b5c1c2c5132" translate="yes" xml:space="preserve">
          <source>With Gradle metadata enabled, an additional 'root' publication named &lt;code&gt;kotlinMultiplatform&lt;/code&gt; is added to the project's publications. The default artifact ID of this publication matches the project name without any additional suffix. To configure this publication, access it via the &lt;code&gt;publishing { ... }&lt;/code&gt; DSL of the &lt;code&gt;maven-publish&lt;/code&gt; plugin:</source>
          <target state="translated">Gradle 메타 데이터를 사용하면 &lt;code&gt;kotlinMultiplatform&lt;/code&gt; 이라는 추가 '루트'발행물 이 프로젝트 발행물에 추가됩니다. 이 발행물의 기본 이슈 ID는 추가 접미사없이 프로젝트 이름과 일치합니다. 이 게시를 구성하려면 &lt;code&gt;maven-publish&lt;/code&gt; 플러그인 의 &lt;code&gt;publishing { ... }&lt;/code&gt; DSL을 통해 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfc45b937026fd4fbaf26509635a71da2f380172" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.3, it is possible to mark members of a &lt;code&gt;companion&lt;/code&gt; object of interfaces with annotations &lt;code&gt;@JvmStatic&lt;/code&gt; and &lt;code&gt;@JvmField&lt;/code&gt;. In the classfile, such members will be lifted to the corresponding interface and marked as &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.3을 사용하면 &lt;code&gt;@JvmStatic&lt;/code&gt; 및 &lt;code&gt;@JvmField&lt;/code&gt; 주석으로 인터페이스 의 &lt;code&gt;companion&lt;/code&gt; 객체 멤버를 표시 할 수 있습니다 . 클래스 파일에서 이러한 멤버는 해당 인터페이스로 들어 올려 져 &lt;code&gt;static&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b65590d91561b1b8e789678b4dd06427d7909a3" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4 you can now add a trailing comma in enumerations such as argument and parameter lists, &lt;code&gt;when&lt;/code&gt; entries, and components of destructuring declarations. With a trailing comma, you can add new items and change their order without adding or removing commas.</source>
          <target state="translated">Kotlin 1.4를 사용하면 인수 및 매개 변수 목록과 같은 열거 형, &lt;code&gt;when&lt;/code&gt; 항목 및 파괴 선언의 구성 요소에 후행 쉼표를 추가 할 수 있습니다 . 후행 쉼표를 사용하면 쉼표를 추가하거나 제거하지 않고도 새 항목을 추가하고 순서를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="492f25a9a5171ae34e810e40b21b2cb1efcdaaeb" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4, you can use the new tools in IntelliJ IDEA to simplify Kotlin development:</source>
          <target state="translated">Kotlin 1.4에서는 IntelliJ IDEA의 새로운 도구를 사용하여 Kotlin 개발을 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ed9b754f624185d343cb02b0b8d34dd9ae4ed13" translate="yes" xml:space="preserve">
          <source>With Kotlin 1.4.0, we are shipping the first stable version of &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;kotlinx.serialization&lt;/a&gt; - 1.0.0-RC. Now we are pleased to declare the JSON serialization API in &lt;code&gt;kotlinx-serialization-core&lt;/code&gt; (previously known as &lt;code&gt;kotlinx-serialization-runtime&lt;/code&gt;) stable. Libraries for other serialization formats remain experimental, along with some advanced parts of the core library.</source>
          <target state="translated">Kotlin 1.4.0에서는 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;kotlinx.serialization&lt;/a&gt; 의 첫 번째 안정 버전 인 1.0.0-RC 를 출시 합니다. 이제 &lt;code&gt;kotlinx-serialization-core&lt;/code&gt; (이전에는 &lt;code&gt;kotlinx-serialization-runtime&lt;/code&gt; 으로 알려짐) 에서 JSON 직렬화 API를 안정적 으로 선언하게되어 기쁩니다 . 다른 직렬화 형식에 대한 라이브러리는 핵심 라이브러리의 일부 고급 부분과 함께 실험적인 상태로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6d7af5fe3aafc8094b8a2cfd86e6ef8192a99f" translate="yes" xml:space="preserve">
          <source>With Kotlin &lt;a href=&quot;../../reference/multiplatform&quot;&gt;multiplatform&lt;/a&gt; projects, it is possible to share the same Kotlin code between all the supported platforms. Check out the tutorial on &lt;a href=&quot;mpp-ios-android&quot;&gt;sharing Kotlin code between iOS and Android&lt;/a&gt; or have a look at how to build your own &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt;.</source>
          <target state="translated">Kotlin &lt;a href=&quot;../../reference/multiplatform&quot;&gt;다중 플랫폼&lt;/a&gt; 프로젝트를 사용 하면 지원되는 모든 플랫폼간에 동일한 Kotlin 코드를 공유 할 수 있습니다. &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS와 Android간에 Kotlin 코드 공유&lt;/a&gt; 에 대한 자습서를 확인 하거나 자신 만의 &lt;a href=&quot;../multiplatform-library&quot;&gt;멀티 플랫폼 라이브러리&lt;/a&gt; 를 빌드하는 방법을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="63565c10375a2623a1558273ad959c355a70e5ce" translate="yes" xml:space="preserve">
          <source>With Kotlin Gradle DSL, the sections of predefined source sets should be marked &lt;code&gt;by getting&lt;/code&gt;.</source>
          <target state="translated">Kotlin Gradle DSL을 사용하면 사전 정의 된 소스 세트의 섹션 &lt;code&gt;by getting&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec7fe3c48a3cadc6919466836bffd195ba2a63be" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform libraries, you can reuse the multiplatform logic in common and platform-specific code. Common code can rely on a set of libraries that cover everyday tasks such as &lt;a href=&quot;http://ktor.io/clients/http-client/multiplatform.html&quot;&gt;HTTP&lt;/a&gt;, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;serialization&lt;/a&gt;, and &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;managing coroutines&lt;/a&gt;.</source>
          <target state="translated">Kotlin 멀티 플랫폼 라이브러리를 사용하면 공통 및 플랫폼 별 코드에서 멀티 플랫폼 로직을 재사용 할 수 있습니다. 공통 코드는 &lt;a href=&quot;http://ktor.io/clients/http-client/multiplatform.html&quot;&gt;HTTP&lt;/a&gt; , &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization&quot;&gt;직렬화&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;코 루틴 관리&lt;/a&gt; 와 같은 일상적인 작업을 다루는 라이브러리 세트에 의존 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f3221afc2f20039e82884001a629bfe8610d1ab" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, share the code using the mechanisms Kotlin provides:</source>
          <target state="translated">Kotlin Multiplatform을 사용하면 Kotlin이 제공하는 메커니즘을 사용하여 코드를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adbab2d42979bafe508a0df0d9f59300200f67c7" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, spend less time on writing and maintaining the same code for &lt;a href=&quot;mpp-supported-platforms&quot;&gt;different platforms&lt;/a&gt; &amp;ndash; just share it using the mechanisms Kotlin provides:</source>
          <target state="translated">Kotlin Multiplatform을 사용하면 &lt;a href=&quot;mpp-supported-platforms&quot;&gt;서로 다른 플랫폼&lt;/a&gt; 에서 동일한 코드를 작성하고 유지하는 데 드는 시간을 줄일 수 있습니다. Kotlin이 제공하는 메커니즘을 사용하여 공유하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0e972123cd69ffcab96ad056c6c91d5aacf5be07" translate="yes" xml:space="preserve">
          <source>With Kotlin Multiplatform, you can share the code using the mechanisms Kotlin provides:</source>
          <target state="translated">Kotlin Multiplatform을 사용하면 Kotlin이 제공하는 메커니즘을 사용하여 코드를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3962fde44c4aec537b82dcd2abfc22db4cc626fa" translate="yes" xml:space="preserve">
          <source>With a value of 1, walker visits only the origin directory and all its immediate children, with a value of 2 also grandchildren, etc.</source>
          <target state="translated">값이 1이면 워커는 원본 디렉토리와 모든 직계 자식 만 방문하고 값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="ef51393788d21d74c116e9c29eea336ed0a6d471" translate="yes" xml:space="preserve">
          <source>With callbacks, the idea is to pass one function as a parameter to another function, and have this one invoked once the process has completed.</source>
          <target state="translated">콜백을 사용하면 한 함수를 다른 함수에 매개 변수로 전달하고 프로세스가 완료되면이 함수를 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="016040b5eae4bf27f5a939a1b5c8156662185437" translate="yes" xml:space="preserve">
          <source>With collections and functions, polymorphism becomes more complicated - see the section on &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">컬렉션과 함수를 사용하면 다형성이 더 복잡해집니다 . &lt;a href=&quot;generics&quot;&gt;제네릭&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1dcb9e12e7f211f30c8a5176d8ae68de49c58b9" translate="yes" xml:space="preserve">
          <source>With either version of the import, you can now simply do:</source>
          <target state="translated">가져 오기 버전 중 하나를 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe95a6fd3800d1f0d89afcda519d105e6e6110b2" translate="yes" xml:space="preserve">
          <source>With function literals, local functions and object expression, functions can be nested in Kotlin. Qualified &lt;em&gt;return&lt;/em&gt;s allow us to return from an outer function. The most important use case is returning from a lambda expression. Recall that when we write this:</source>
          <target state="translated">함수 리터럴, 로컬 함수 및 객체 표현을 사용하면 Kotlin에 함수를 중첩시킬 수 있습니다. 적격 &lt;em&gt;수익률&lt;/em&gt; 을 통해 외부 기능에서 복귀 할 수 있습니다. 가장 중요한 사용 사례는 람다 식에서 돌아 오는 것입니다. 우리가 이것을 쓸 때</target>
        </trans-unit>
        <trans-unit id="eb6ed75ff29820dbdcda23941139d4c1d4ba7dd2" translate="yes" xml:space="preserve">
          <source>With named arguments we can make the code much more readable:</source>
          <target state="translated">명명 된 인수를 사용하면 코드를 훨씬 더 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3450c7c71d6bf1ddf49a4323aca70311d456d430" translate="yes" xml:space="preserve">
          <source>With that, our project should now build and produce the corresponding artifacts.</source>
          <target state="translated">이를 통해 프로젝트는 이제 해당 아티팩트를 빌드하고 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="355ad4d87e7870b0c272b188aa3ef65d4dc920f9" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can learn Kotlin through code practicing tasks.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; 및 &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; 모두에서 사용할 수 있는 &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools 플러그인&lt;/a&gt; 을 사용 하면 코드 연습 작업을 통해 Kotlin을 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b14af153f14d3f9734df37394a46678fa4ba5c" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt;, available both in &lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android Studio&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;, you can teach Kotlin through code practicing tasks. Take a look at the &lt;a href=&quot;https://www.jetbrains.com/help/education/educator-start-guide.html?section=Kotlin&quot;&gt;Educator Start Guide&lt;/a&gt; to learn how to create a simple Kotlin course that includes a set of programming tasks and integrated tests.</source>
          <target state="translated">&lt;a href=&quot;https://developer.android.com/studio&quot;&gt;Android 스튜디오&lt;/a&gt; 와 &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; 모두에서 사용할 수 있는 &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools 플러그인&lt;/a&gt; 을 사용 하면 코드 연습 작업을 통해 Kotlin을 가르 칠 수 있습니다. &lt;a href=&quot;https://www.jetbrains.com/help/education/educator-start-guide.html?section=Kotlin&quot;&gt;교육자 시작 가이드&lt;/a&gt; 를 살펴보고 일련의 프로그래밍 작업과 통합 테스트가 포함 된 간단한 Kotlin 과정을 만드는 방법을 알아 보세요 .</target>
        </trans-unit>
        <trans-unit id="f5382fb55641e05a034b3ea5d0c0d4be768aee31" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PropertyDelegateProvider&lt;/code&gt; interface from the standard library, you can create delegate providers without creating new classes.</source>
          <target state="translated">표준 라이브러리 의 &lt;code&gt;PropertyDelegateProvider&lt;/code&gt; 인터페이스를 사용하면 새 클래스를 만들지 않고도 위임 공급자를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dadda346a2629bde84d619a153f6df49f573d66b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;cancellable&lt;/code&gt; operator only the numbers from 1 to 3 are collected:</source>
          <target state="translated">&lt;code&gt;cancellable&lt;/code&gt; 연산자를 사용하면 1에서 3까지의 숫자 만 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="7f45b301e2a74f1dd5893d4a531ceba47efa69ee" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin &lt;strong&gt;source&lt;/strong&gt;&lt;strong&gt;sets&lt;/strong&gt; are also used to group sources but source files for different platforms are located in different source sets. For each declared target two source sets are created: &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; and &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; containing product and test sources for this platform. Common for all platforms sources are located in &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; source sets created by default. More information about source sets can be found &lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">으로 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 &lt;strong&gt;소스 &lt;/strong&gt;&lt;strong&gt;세트는&lt;/strong&gt; 또한 다른 플랫폼 그룹 원하지만 소스 파일에 사용되는 다른 소스 세트에 있습니다. 선언 된 각 대상 에 대해이 플랫폼에 대한 제품 및 테스트 소스를 포함하는 &lt;code&gt;&amp;lt;target-name&amp;gt;Main&lt;/code&gt; 및 &lt;code&gt;&amp;lt;target-name&amp;gt;Test&lt;/code&gt; 두 소스 세트가 작성 됩니다. 모든 플랫폼 소스에 공통은 기본적으로 작성된 &lt;code&gt;commonMain&lt;/code&gt; 및 &lt;code&gt;commonTest&lt;/code&gt; 소스 세트에 있습니다. 소스 세트에 대한 자세한 내용은 &lt;a href=&quot;../building-mpp-with-gradle#configuring-source-sets&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d94234e74f15ed4145669bdb5e37f9dfb14ae3" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin a compilation always produces a &lt;code&gt;*.klib&lt;/code&gt; file. A separate &lt;code&gt;binaries&lt;/code&gt; block is used to configure what final native binaries should be produced by each target. Each binary can be configured independently including linker options, executable entry point etc.</source>
          <target state="translated">으로 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 컴파일 항상 생산 &lt;code&gt;*.klib&lt;/code&gt; 의 파일을. 별도의 &lt;code&gt;binaries&lt;/code&gt; 블록을 사용하여 각 대상에서 생성 할 최종 네이티브 바이너리를 구성합니다. 링커 옵션, 실행 가능 진입 점 등을 포함하여 각 바이너리를 독립적으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6cb3a91147cfe093062a0839b721e658dabc4bd" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin interops are configured as a part of a compilation (see details &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;here&lt;/a&gt;). The rest of an interop configuration is the same as for the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin.</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인을 사용하면 interops 가 컴파일의 일부로 구성됩니다 (자세한 내용은 &lt;a href=&quot;../building-mpp-with-gradle#cinterop-support&quot;&gt;여기&lt;/a&gt; 참조 ). interop 구성의 나머지는 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 플러그인과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1706d3b6b7ce15bdbf71dc7c9e04a857f530061f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin target platforms can be added into a project using special methods available in the &lt;code&gt;kotlin&lt;/code&gt; extension. Each method adds into a project one &lt;strong&gt;target&lt;/strong&gt; which can be accessed using the &lt;code&gt;targets&lt;/code&gt; property. Each target can be configured independently including output kinds, additional compiler options etc. See details about targets at the &lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;corresponding page&lt;/a&gt;.</source>
          <target state="translated">으로 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인을 대상 플랫폼은에서 사용할 수있는 특별한 방법을 사용하여 프로젝트에 추가 할 수있는 &lt;code&gt;kotlin&lt;/code&gt; 확장. 각 메소드는 &lt;code&gt;targets&lt;/code&gt; 속성을 사용하여 액세스 할 수있는 하나의 &lt;strong&gt;대상&lt;/strong&gt; 을 프로젝트에 추가 합니다. 출력 종류, 추가 컴파일러 옵션 등을 포함하여 각 대상을 독립적으로 구성 할 수 있습니다 . &lt;a href=&quot;../building-mpp-with-gradle#setting-up-targets&quot;&gt;해당 페이지&lt;/a&gt; 에서 대상에 대한 세부 사항을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="71022b4d02eeeda0e92ce39399dff9342c3334b7" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin a set of target platforms is specified as a list in properties of the main component:</source>
          <target state="translated">으로 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 플러그인을 대상 플랫폼의 세트는 주요 구성 요소의 특성 목록으로 지정됩니다</target>
        </trans-unit>
        <trans-unit id="6a03f6034b00496a7bad530da3196155a72cc860" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin dependencies are configured in a traditional for Gradle way by grouping them into configurations using the project &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">으로 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 플러그인 종속성은 프로젝트 사용하여 구성로 그룹화하여 Gradle을 방법에 대한 기존에 구성되어 &lt;code&gt;dependencies&lt;/code&gt; 블록 :</target>
        </trans-unit>
        <trans-unit id="e33e92feed8df1d895d9a97b45aacf36671d526c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin interop with a native library can be declared in component dependencies:</source>
          <target state="translated">으로 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 네이티브 라이브러리와 플러그인 상호 운용성 구성 요소 종속성을 선언 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a97bf25e776050662c47b29cee8cd98d22ea2c1d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin output kinds are specified as a list in properties of a component:</source>
          <target state="translated">&lt;code&gt;kotlin-platform-native&lt;/code&gt; 플러그인을 사용하면 출력 유형이 컴포넌트의 특성 목록으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="32e186967f7559f8d4cf421fcfd2faf96d838898" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;kotlin-platform-native&lt;/code&gt; plugin source sets are used to separate test and product sources. Also you can specify different sources for different platforms in the same source set:</source>
          <target state="translated">으로 &lt;code&gt;kotlin-platform-native&lt;/code&gt; 플러그인 소스 세트는 별도의 테스트 및 제품 소스에 사용됩니다. 또한 동일한 소스 세트에서 다른 플랫폼에 대해 다른 소스를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fa674450fbd80d59d43844df0d5a16d3f6b263d" translate="yes" xml:space="preserve">
          <source>With the coroutine debugger, you can:</source>
          <target state="translated">코 루틴 디버거를 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29b0fbf80a9fbc5a69ad66b25c87ece38e49f33b" translate="yes" xml:space="preserve">
          <source>With the flexible new Kotlin Project Wizard, you have a place to easily create and configure different types of Kotlin projects, including multiplatform projects, which can be difficult to configure without a UI.</source>
          <target state="translated">유연한 새 Kotlin 프로젝트 마법사를 사용하면 UI 없이는 구성하기 어려울 수있는 멀티 플랫폼 프로젝트를 포함하여 다양한 유형의 Kotlin 프로젝트를 쉽게 만들고 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5c6c878f4a74b6cd56b16a6f707da3f34b03dce" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following declarations for our C functions:</source>
          <target state="translated">IntelliJ IDEA의 &lt;em&gt;Goto Declaration&lt;/em&gt; 또는 컴파일러 오류를 통해 C 함수에 대한 다음 선언이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cf252d7abb4fe418f54b8621d262b977ba904b60" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions, &lt;code&gt;struct&lt;/code&gt;, and &lt;code&gt;union&lt;/code&gt;:</source>
          <target state="translated">IntelliJ IDEA의 &lt;em&gt;Goto Declaration&lt;/em&gt; 또는 컴파일러 오류를 통해 C 함수, &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;union&lt;/code&gt; 에 대해 다음과 같이 생성 된 API를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874119f71c620e91c1bb9c2e75fd174caab63b63" translate="yes" xml:space="preserve">
          <source>With the help of IntelliJ IDEA's &lt;em&gt;Goto Declaration&lt;/em&gt; or compiler errors we see the following generated API for our C functions:</source>
          <target state="translated">IntelliJ IDEA의 &lt;em&gt;Goto Declaration&lt;/em&gt; 또는 컴파일러 오류 의 도움으로 C 함수에 대해 다음과 같이 생성 된 API를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="566c1425784d4c2e6ede1f7dfe672ee70373f129" translate="yes" xml:space="preserve">
          <source>With the new &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt;&lt;code&gt;@JsExport&lt;/code&gt;&lt;/a&gt; annotation and the ability to &lt;strong&gt;&lt;a href=&quot;js-ir-compiler#preview-generation-of-typescript-declaration-files-dts&quot;&gt;generate TypeScript definitions&lt;/a&gt; from Kotlin code&lt;/strong&gt;, the Kotlin/JS IR compiler backend improves JavaScript &amp;amp; TypeScript interoperability. This also makes it easier to integrate Kotlin/JS code with existing tooling, to create &lt;strong&gt;hybrid applications&lt;/strong&gt; and leverage code-sharing functionality in multiplatform projects.</source>
          <target state="translated">새로운 &lt;a href=&quot;js-to-kotlin-interop#jsexport-annotation&quot;&gt; &lt;code&gt;@JsExport&lt;/code&gt; &lt;/a&gt; 주석과 &lt;strong&gt;Kotlin 코드에서 &lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;js-ir-compiler#preview-generation-of-typescript-declaration-files-dts&quot;&gt;TypeScript 정의&lt;/a&gt;&lt;/strong&gt; 를 &lt;strong&gt;생성&lt;/strong&gt; 하는 기능을 통해 Kotlin / JS IR 컴파일러 백엔드는 JavaScript 및 TypeScript 상호 운용성을 향상시킵니다. 이를 통해 Kotlin / JS 코드를 기존 도구와 더 쉽게 통합 하고 &lt;strong&gt;하이브리드 애플리케이션&lt;/strong&gt; 을 만들고 멀티 플랫폼 프로젝트에서 코드 공유 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bc753b11e4bb4891a70a654bb57daca9017fc7f" translate="yes" xml:space="preserve">
          <source>With the new hierarchical project structure support, you can share code among &lt;a href=&quot;mpp-supported-platforms&quot;&gt;several platforms&lt;/a&gt; in a &lt;a href=&quot;mpp-discover-project&quot;&gt;multiplatform project&lt;/a&gt;.</source>
          <target state="translated">새로운 계층 적 프로젝트 구조 지원 을 통해 &lt;a href=&quot;mpp-discover-project&quot;&gt;다중 플랫폼 프로젝트의 &lt;/a&gt;&lt;a href=&quot;mpp-supported-platforms&quot;&gt;여러 플랫폼&lt;/a&gt; 간에 코드를 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="574c1c740a16fa65a0f397005ee3b1c60f44325d" translate="yes" xml:space="preserve">
          <source>With these features, you can make your Gradle build file much more concise and easy to read:</source>
          <target state="translated">이러한 기능을 사용하면 Gradle 빌드 파일을 훨씬 간결하고 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55c0b9fe68cd1e4b20ebebcee0ed1689356c0a07" translate="yes" xml:space="preserve">
          <source>With these helpers, the part of code for reading input becomes simpler, closely following the input specification in the problem statement line by line:</source>
          <target state="translated">이러한 헬퍼를 사용하면 입력 문을 읽는 코드 부분이 한 줄씩 문제 설명의 입력 스펙을 밀접하게 따라갑니다.</target>
        </trans-unit>
        <trans-unit id="a228c17a745863a462bf780050c335cd1bf004e4" translate="yes" xml:space="preserve">
          <source>With these two interfaces, we can make a more versatile fruit bowl. The bowl itself needs to both produce and consume its generic type, so it can neither be covariant nor contravariant, but it can implement our covariant and contravariant interfaces:</source>
          <target state="translated">이 두 가지 인터페이스를 통해보다 다양한 과일 그릇을 만들 수 있습니다. 보울 자체는 제네릭 유형을 생성하고 소비해야하므로 공변량 또는 반 변형 일 수 없지만 공변량 및 반 변형 인터페이스를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7d204c839bbeda2e10e199023fa5b9c64dcb76" translate="yes" xml:space="preserve">
          <source>With this external declaration, you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments, where the default values are calculated by the JavaScript implementation of &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt;.</source>
          <target state="translated">이 외부 선언을 사용 하여 하나의 필수 인수와 두 개의 선택적 인수를 사용하여 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 를 호출 할 수 있습니다 . 여기서 기본값은 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 의 JavaScript 구현에 의해 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="72d67501a892da363116927ae13a84e4aecbce70" translate="yes" xml:space="preserve">
          <source>With this mechanism, a common source set defines an &lt;em&gt;expected declaration&lt;/em&gt;, and platform source sets must provide the &lt;em&gt;actual declaration&lt;/em&gt; that corresponds to the expected declaration. This works for most Kotlin declarations, such as functions, classes, interfaces, enumerations, properties, and annotations.</source>
          <target state="translated">이 메커니즘을 사용하면 공통 소스 세트가 &lt;em&gt;예상 선언을&lt;/em&gt; 정의 하고 플랫폼 소스 세트는 &lt;em&gt;실제 선언을&lt;/em&gt; 제공해야합니다.&lt;em&gt;&lt;/em&gt; 예상 선언에 해당하는 을 . 이는 함수, 클래스, 인터페이스, 열거 형, 속성 및 주석과 같은 대부분의 Kotlin 선언에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="717e11f293d4b13a9a59d035d72d380a87efce32" translate="yes" xml:space="preserve">
          <source>With this setup, we can access elements of our DOM. To access the properties of the &lt;code&gt;input&lt;/code&gt; field, we invoke &lt;code&gt;getElementById&lt;/code&gt; and cast it to &lt;code&gt;HTMLInputElement&lt;/code&gt;. We can then safely access its properties, such as &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="translated">이 설정을 통해 DOM의 요소에 액세스 할 수 있습니다. &lt;code&gt;input&lt;/code&gt; 필드 의 속성에 액세스하기 위해 &lt;code&gt;getElementById&lt;/code&gt; 를 호출 하고이를 &lt;code&gt;HTMLInputElement&lt;/code&gt; 로 캐스트합니다 . 그런 다음 &lt;code&gt;value&lt;/code&gt; 와 같은 속성에 안전하게 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41b77f41d3f8979c93fc79a64e556733e4160ef4" translate="yes" xml:space="preserve">
          <source>With this setup, we can recompile our project after each code change to see our changes. Kotlin/JS also supports a more convenient way of automatically rebuilding our application while we are developing it. To find out how to set up this &lt;em&gt;continuous mode&lt;/em&gt;, check out the &lt;a href=&quot;dev-server-continuous-compilation&quot;&gt;corresponding tutorial&lt;/a&gt;.</source>
          <target state="translated">이 설정을 사용하면 코드가 변경 될 때마다 프로젝트를 다시 컴파일하여 변경 사항을 확인할 수 있습니다. Kotlin / JS는 또한 애플리케이션을 개발하는 동안 애플리케이션을 자동으로 다시 빌드하는보다 편리한 방법을 지원합니다. 이 &lt;em&gt;연속 모드&lt;/em&gt; 를 설정하는 방법을 알아 보려면 &lt;a href=&quot;dev-server-continuous-compilation&quot;&gt;해당 자습서를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9928576b159a395a58ce4f2d7b6c66f40874468" translate="yes" xml:space="preserve">
          <source>With this, we can then access any of the functionality defined inside &lt;code&gt;customerBL&lt;/code&gt;.</source>
          <target state="translated">이를 통해 &lt;code&gt;customerBL&lt;/code&gt; 내부에 정의 된 기능에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8dacc9ec11c6c308f4e37da6d574002e02a0ff3a" translate="yes" xml:space="preserve">
          <source>Without the curly braces, only the first line is a part of the body. Indentation in Kotlin matters only for human readers, so the second print is outside the if and will always be executed.</source>
          <target state="translated">중괄호가 없으면 첫 번째 줄만 신체의 일부입니다. Kotlin의 들여 쓰기는 인간 독자에게만 중요하므로 두 번째 인쇄는 if 외부에 있으며 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d2ecf10500acdd56e5aa15cdc3d632f4d1b83484" translate="yes" xml:space="preserve">
          <source>Without this ability to intercept the binding between the property and its delegate, to achieve the same functionality you'd have to pass the property name explicitly, which isn't very convenient:</source>
          <target state="translated">속성과 대리자 사이의 바인딩을 가로 챌 수있는이 기능이 없으면 동일한 기능을 달성하기 위해 속성 이름을 명시 적으로 전달해야하므로 매우 편리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99edd8c8e615e373739d2cdd38a8942b8a573113" translate="yes" xml:space="preserve">
          <source>Worker</source>
          <target state="translated">Worker</target>
        </trans-unit>
        <trans-unit id="b539d8a8b3ce433f937b71658160ff7e5f64cd4c" translate="yes" xml:space="preserve">
          <source>Worker that &lt;a href=&quot;value&quot;&gt;value&lt;/a&gt; is bound to.</source>
          <target state="translated">&lt;a href=&quot;value&quot;&gt;가치&lt;/a&gt; 가 묶인 작업자 .</target>
        </trans-unit>
        <trans-unit id="a502b8bb9786901c6dc61e82d98c92b4b73ae927" translate="yes" xml:space="preserve">
          <source>WorkerBoundReference</source>
          <target state="translated">WorkerBoundReference</target>
        </trans-unit>
        <trans-unit id="74a0d635bad8cb921832f022e80f37a47e5b135d" translate="yes" xml:space="preserve">
          <source>WorkerLocation</source>
          <target state="translated">WorkerLocation</target>
        </trans-unit>
        <trans-unit id="315e6d0000af41369aa07e54a100988d3fd17dee" translate="yes" xml:space="preserve">
          <source>WorkerNavigator</source>
          <target state="translated">WorkerNavigator</target>
        </trans-unit>
        <trans-unit id="2c80abf6e395bd6f326cb30a261f19ee445cba02" translate="yes" xml:space="preserve">
          <source>WorkerOptions</source>
          <target state="translated">WorkerOptions</target>
        </trans-unit>
        <trans-unit id="87bb291b389446f9344ad088d8d62a7a62a19eca" translate="yes" xml:space="preserve">
          <source>WorkerType</source>
          <target state="translated">WorkerType</target>
        </trans-unit>
        <trans-unit id="b6ef3acd0f91c0c6e2a6bad2692c8aa84dfc4c73" translate="yes" xml:space="preserve">
          <source>Workers</source>
          <target state="translated">Workers</target>
        </trans-unit>
        <trans-unit id="4854bbfffb40975ef729e9def93b58f75765479a" translate="yes" xml:space="preserve">
          <source>Workers with message passing</source>
          <target state="translated">메시지 전달 작업자</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="7323cd213254c74db3a887f36bfadb481e7d4c0e" translate="yes" xml:space="preserve">
          <source>Working on all platforms is an explicit goal for Kotlin, but we see it as a premise to a much more important goal: sharing code between platforms. With support for JVM, Android, JavaScript, iOS, Linux, Windows, Mac and even embedded systems like STM32, Kotlin can handle any and all components of a modern application. And this brings the invaluable benefit of reuse for code and expertise, saving the effort for tasks more challenging than implementing everything twice or multiple times.</source>
          <target state="translated">모든 플랫폼에서 작업하는 것이 Kotlin에게는 명백한 목표이지만 플랫폼 간 코드 공유라는 훨씬 더 중요한 목표를 전제로합니다. Kotlin은 JVM, Android, JavaScript, iOS, Linux, Windows, Mac 및 STM32와 같은 내장 시스템을 지원하여 최신 응용 프로그램의 모든 구성 요소를 처리 할 수 ​​있습니다. 또한 코드 및 전문 지식 재사용의 귀중한 이점을 제공하여 모든 것을 두 번 또는 여러 번 구현하는 것보다 어려운 과제에 대한 노력을 절약합니다.</target>
        </trans-unit>
        <trans-unit id="f538870f3ed8ccb71b1f28d4023b06274de86076" translate="yes" xml:space="preserve">
          <source>Working with Build Tools</source>
          <target state="translated">빌드 도구 작업</target>
        </trans-unit>
        <trans-unit id="4c5d22ef62b4e454bd0bf1e1374aa13390ad7ed1" translate="yes" xml:space="preserve">
          <source>Working with C strings</source>
          <target state="translated">C 문자열을 사용한 작업</target>
        </trans-unit>
        <trans-unit id="9ac89fee8e06569c4ebc756f83cddf2bbd9a8ca8" translate="yes" xml:space="preserve">
          <source>Working with Enum Constants</source>
          <target state="translated">열거 형 상수 작업</target>
        </trans-unit>
        <trans-unit id="1f8482b2bf142fad82a2f635e71a135183f56a5d" translate="yes" xml:space="preserve">
          <source>Working with JavaScript</source>
          <target state="translated">자바 스크립트 작업</target>
        </trans-unit>
        <trans-unit id="8fc3285c1f9933f649e39499a1f3946c5619cf72" translate="yes" xml:space="preserve">
          <source>Working with Kotlin and JavaScript Modules</source>
          <target state="translated">Kotlin 및 JavaScript 모듈 작업</target>
        </trans-unit>
        <trans-unit id="9a49aac8293420ff01c5e9c031ff773d05799074" translate="yes" xml:space="preserve">
          <source>Working with nulls</source>
          <target state="translated">널 작업</target>
        </trans-unit>
        <trans-unit id="e5c0c5bddfae833279acedcc9a537af19daf0f06" translate="yes" xml:space="preserve">
          <source>Working with tasks</source>
          <target state="translated">작업 작업</target>
        </trans-unit>
        <trans-unit id="7d46e00971b365b4ef3386294882d7496a7f75ed" translate="yes" xml:space="preserve">
          <source>Working with the Command Line Compiler</source>
          <target state="translated">명령 행 컴파일러 작업</target>
        </trans-unit>
        <trans-unit id="f2a7db7b02d37c7f54b499213bb3a991f17a1744" translate="yes" xml:space="preserve">
          <source>Working with the strings</source>
          <target state="translated">문자열 다루기</target>
        </trans-unit>
        <trans-unit id="075cb3c4378fe512dd51ed618315bfebed19ab49" translate="yes" xml:space="preserve">
          <source>Worksheets automatically get access to classes and functions from the module where they reside.</source>
          <target state="translated">워크 시트는 상주하는 모듈에서 클래스 및 함수에 자동으로 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="298b3785e2ae406d29010843be91172dd4b7a909" translate="yes" xml:space="preserve">
          <source>Wraps the specified &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask%28kotlin.Function1%28%28java.util.TimerTask%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; in a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask%28kotlin.Function1%28%28java.util.TimerTask%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 을 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt; 에 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="bc7e6a2c63b3a339c10a75fe3c57e0e79aab2702" translate="yes" xml:space="preserve">
          <source>Wraps the specified &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask(kotlin.Function1((java.util.TimerTask,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; in a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/TimerTask.html&quot;&gt;TimerTask에&lt;/a&gt; 지정된 &lt;a href=&quot;timer-task#kotlin.concurrent%24timerTask(kotlin.Function1((java.util.TimerTask,%20kotlin.Unit)))/action&quot;&gt;작업&lt;/a&gt; 을 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="2525837a1ad8d7e8a649a7a5e6c45999c5553523" translate="yes" xml:space="preserve">
          <source>Write &lt;strong&gt;full, type-safe React applications with Kotlin/JS&lt;/strong&gt; using the &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;&lt;code&gt;kotlin-wrappers&lt;/code&gt;&lt;/a&gt; provided by JetBrains, which provide convenient abstractions and deep integrations for one of the most popular JavaScript frameworks. &lt;code&gt;kotlin-wrappers&lt;/code&gt; also provides support for a select number of adjacent technologies like &lt;code&gt;react-redux&lt;/code&gt;, &lt;code&gt;react-router&lt;/code&gt;, or &lt;code&gt;styled-components&lt;/code&gt;. Interoperability with the JavaScript ecosystem also means that you can also use third-party React components and component libraries.</source>
          <target state="translated">가장 인기있는 JavaScript 프레임 워크 중 하나에 편리한 추상화와 심층 통합을 제공하는 JetBrains에서 제공 하는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt; &lt;code&gt;kotlin-wrappers&lt;/code&gt; 를&lt;/a&gt; 사용하여 &lt;strong&gt;Kotlin / JS로 완전한 유형 안전 React 애플리케이션을&lt;/strong&gt; 작성 하세요 . &lt;code&gt;kotlin-wrappers&lt;/code&gt; 는 또한 &lt;code&gt;react-redux&lt;/code&gt; , &lt;code&gt;react-router&lt;/code&gt; 또는 &lt;code&gt;styled-components&lt;/code&gt; 와 같은 인접 기술의 수를 선택하여 지원합니다 . JavaScript 생태계와의 상호 운용성은 또한 타사 React 구성 요소 및 구성 요소 라이브러리를 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff7df02929ed6ce55a8f16204596caaf82c53075" translate="yes" xml:space="preserve">
          <source>Write operations</source>
          <target state="translated">쓰기 작업</target>
        </trans-unit>
        <trans-unit id="16f06037425e5570c7fb6c4cb0b8e9b025bb037c" translate="yes" xml:space="preserve">
          <source>Write the application</source>
          <target state="translated">신청서 작성</target>
        </trans-unit>
        <trans-unit id="5c829704c2a3eee8b986648971ed06cb5f976567" translate="yes" xml:space="preserve">
          <source>Write your code in the scratch and click &lt;strong&gt;Run&lt;/strong&gt;. The execution results will appear opposite the lines of your code.</source>
          <target state="translated">처음에 코드를 작성하고 &lt;strong&gt;실행을&lt;/strong&gt; 클릭 &lt;strong&gt;하십시오&lt;/strong&gt; . 실행 결과는 코드 줄 반대쪽에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d5a79e41535865d72222565d75328e9ec50eab15" translate="yes" xml:space="preserve">
          <source>Writeable Objective-C properties overriding read-only properties of the superclass are represented as &lt;code&gt;setFoo()&lt;/code&gt; method for the property &lt;code&gt;foo&lt;/code&gt;. Same goes for a protocol's read-only properties that are implemented as mutable.</source>
          <target state="translated">수퍼 클래스의 읽기 전용 속성을 재정의하는 쓰기 가능한 Objective-C 속성은 &lt;code&gt;foo&lt;/code&gt; 속성에 대한 &lt;code&gt;setFoo()&lt;/code&gt; 메서드 로 표시됩니다 . 변경 가능한 것으로 구현 된 프로토콜의 읽기 전용 속성도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b96451968bc66bdb3ac0027e8c45718ed0567089" translate="yes" xml:space="preserve">
          <source>Writing output in Kotlin is usually straightforward with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/println&quot;&gt;println(&amp;hellip;)&lt;/a&gt; calls and using Kotlin's &lt;a href=&quot;../reference/basic-types#string-templates&quot;&gt;string templates&lt;/a&gt;. However, care must be taken when output contains on order of 10&lt;sup&gt;5&lt;/sup&gt; lines or more. Issuing so many &lt;code&gt;println&lt;/code&gt; calls is too slow, since the output in Kotlin is automatically flushed after each line. A faster way to write many lines from an array or a list is using &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;joinToString()&lt;/a&gt; function with &lt;code&gt;&quot;\n&quot;&lt;/code&gt; as the separator, like this:</source>
          <target state="translated">Kotlin에서 출력을 작성하는 것은 대개 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.io/println&quot;&gt;println (&amp;hellip;)&lt;/a&gt; 호출과 Kotlin의 &lt;a href=&quot;../reference/basic-types#string-templates&quot;&gt;문자열 템플릿을&lt;/a&gt; 사용하여 간단 합니다 . 그러나 출력에 10 &lt;sup&gt;5&lt;/sup&gt; 라인 이상이 포함 된 경우주의를 기울여야합니다 . Kotlin의 출력이 각 라인마다 자동으로 플러시 되므로 너무 많은 &lt;code&gt;println&lt;/code&gt; 호출을 발행하면 너무 느립니다. 배열 또는 목록에서 많은 행을 작성하는 가장 빠른 방법은 다음 과 같이 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 을 구분 기호로 사용하여 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;joinToString ()&lt;/a&gt; 함수를 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ab2816d4bb9622be7220e5163963f6a9c487ee4d" translate="yes" xml:space="preserve">
          <source>Writing tests</source>
          <target state="translated">작문 시험</target>
        </trans-unit>
        <trans-unit id="9ef22deec2645bc05aadf8f135a7bff939813776" translate="yes" xml:space="preserve">
          <source>Written common tests which are executed on every platform.</source>
          <target state="translated">모든 플랫폼에서 수행되는 일반적인 테스트 작성.</target>
        </trans-unit>
        <trans-unit id="fd2be2d7287c5cdb16fe41c84b1e6ca191ff755e" translate="yes" xml:space="preserve">
          <source>Wrong common supertype between raw and integer literal type leads to unsound code</source>
          <target state="translated">원시 및 정수 리터럴 유형 사이의 잘못된 공통 상위 유형으로 인해 잘못된 코드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="854c8fc48ee154c6555f79a9bf3716b40f710db3" translate="yes" xml:space="preserve">
          <source>Wrong emission withContext</source>
          <target state="translated">컨텍스트가있는 잘못된 방출</target>
        </trans-unit>
        <trans-unit id="541421193abf48f2287369752c7bf0243245c291" translate="yes" xml:space="preserve">
          <source>Wrong overload resolution for contravariant types with nullable type arguments</source>
          <target state="translated">nullable 형식 인수가있는 반 변성 형식에 대한 잘못된 오버로드 확인</target>
        </trans-unit>
        <trans-unit id="f216eec525b148735e7bf76a9146b212361d45a9" translate="yes" xml:space="preserve">
          <source>Wrote common tests which are executed on every platform.</source>
          <target state="translated">모든 플랫폼에서 실행되는 공통 테스트를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="8bc69ef99140607442e7db36f023118fd57bd0f0" translate="yes" xml:space="preserve">
          <source>X64</source>
          <target state="translated">X64</target>
        </trans-unit>
        <trans-unit id="c5b176396b5ad771a343d5324e35e073e54c2249" translate="yes" xml:space="preserve">
          <source>X86</source>
          <target state="translated">X86</target>
        </trans-unit>
        <trans-unit id="5fff9cda50156cd056976ef35552984685930eca" translate="yes" xml:space="preserve">
          <source>XMLHttpRequestResponseType</source>
          <target state="translated">XMLHttpRequestResponseType</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
