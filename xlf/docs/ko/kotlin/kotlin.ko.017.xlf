<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">클래스 내에서 다른 클래스의 확장을 선언 할 수 있습니다. 이러한 확장에는 여러 개의 &lt;em&gt;암시 적 수신자&lt;/em&gt; 가 있으며, 한정자없이 오브젝트 멤버에 액세스 할 수 있습니다. 확장이 선언 된 클래스의 인스턴스를 &lt;em&gt;디스패치 수신기&lt;/em&gt; 라고 하고 확장 메소드의 수신자 유형 인스턴스는 &lt;em&gt;확장 수신기&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">함수, 안쪽 &lt;code&gt;vararg&lt;/code&gt; -parameter 타입 &lt;code&gt;T&lt;/code&gt; 는 배열로 표시되는 &lt;code&gt;T&lt;/code&gt; , 즉 &lt;code&gt;ts&lt;/code&gt; 입력 갖는 위의 예에서 변수 &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">수신자가있는 람다 식 내부에서 &lt;code&gt;this&lt;/code&gt; 사용 하여 수신자 객체 (이 경우 &lt;code&gt;car&lt;/code&gt; ) 를 참조 할 수 있습니다 . 평소와 같이 이름 충돌이없는 경우 &lt;code&gt;this&lt;/code&gt; 생략 할 수 있으므로 &lt;code&gt;${this.horsepowers}&lt;/code&gt; 대신 &lt;code&gt;$horsepowers&lt;/code&gt; 라고 간단히 말할 수 있습니다 . 그래서 코 틀린, 즉 조심 &lt;code&gt;this&lt;/code&gt; (가능하게 중첩)을 사용 내부 수신기와 람다 식, 그것은 수신기 최 둘러싸 람다 식의 수신기 객체를 참조하는 경우 : 문맥에 따라 다른 의미를 가질 수있다. 함수 리터럴을 &quot;분리&quot;하고 &quot;원본&quot;을 &lt;code&gt;this&lt;/code&gt; (내부 멤버 함수가 실행중인 인스턴스), &lt;code&gt;this@&lt;/code&gt; 뒤에 포함 클래스 이름을 언급하십시오. 따라서 Car 멤버 함수 내부에 수신자가있는 함수 리터럴 안에 있다면 &lt;code&gt;this@Car&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">내부 클래스 내에서 외부 클래스의 수퍼 클래스에 액세스하는 것은 외부 클래스 이름으로 &lt;em&gt;super&lt;/em&gt; 키워드를 사용하여 수행됩니다 : &lt;code&gt;super@Outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">내부 열거 형 항목이 아닌 &lt;code&gt;inner class&lt;/code&gt; 가 아닌 중첩 형식을 정의 하면 초기화 논리의 문제로 인해 더 이상 사용되지 않습니다. 이것은 Kotlin 1.2에서 경고를 발생시키고 Kotlin 1.3에서 오류가됩니다.</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">(가) 내부 &lt;code&gt;apply&lt;/code&gt; 블록을 &lt;code&gt;this&lt;/code&gt; 을 의미 &lt;code&gt;maybeNull&lt;/code&gt; . 암시 적있어 &lt;code&gt;this&lt;/code&gt; 앞에 &lt;code&gt;memberPropertyA&lt;/code&gt; , &lt;code&gt;memberPropertyB&lt;/code&gt; 및 &lt;code&gt;memberFunctionA&lt;/code&gt; (이되지 않는 존재하지 않는 &lt;code&gt;maybeNull&lt;/code&gt; 이 경우 그들이 포함하는 범위에서 찾았다됩니다). 그 후, &lt;code&gt;memberFunctionB()&lt;/code&gt; 또한 &lt;code&gt;maybeNull&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="201f7c7f50eead5096b8205dfcee81a61ab42986" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;kotlin&lt;/code&gt; section, you can manage the following aspects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">함수 리터럴의 몸 내부의 호출에 전달 된 수신기 객체가 될 &lt;em&gt;암시 &lt;/em&gt;&lt;em&gt;이&lt;/em&gt; , 그래서 당신이 사용하는 추가 규정 또는 액세스하지 않고 수신기 객체를 그 수신기 객체의 멤버에 액세스 할 수있는 &lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 표현&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">lateinit 속성을 선언하는 클래스 내에서 초기화되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">파일 내에서 모듈 전체 및 개별 패키지에 대한 설명서는 해당하는 첫 번째 수준 제목으로 소개됩니다. 표제의 텍스트는 모듈의 경우 &quot;모듈 &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &quot;이고 패키지의 경우 &quot;패키지 &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &quot; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">범위 함수의 람다 내에서 컨텍스트 오브젝트는 실제 이름 대신 짧은 참조로 사용 가능합니다. 각 범위 함수는 컨텍스트 객체에 액세스하는 두 가지 방법 중 하나를 사용합니다. 람다 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기&lt;/a&gt; ( &lt;code&gt;this&lt;/code&gt; ) 또는 람다 인수 ( &lt;code&gt;it&lt;/code&gt; ). 둘 다 동일한 기능을 제공하므로 서로 다른 경우에 대한 각각의 장단점을 설명하고 사용에 대한 권장 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">C 라이브러리에서 생성 된 Kotlin API 검사</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">세부 사항은 분배 의 &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; 의 내용을 검사 하십시오.</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">C 라이브러리에 대해 생성 된 Kotlin API 검사</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">처리되지 않은 사용자 지정 예외 후크를 설치하십시오. 이전 후크를 반환하거나 지정되지 않은 경우 null을 반환합니다. Kotlin 세계의 경계에 도달하지 않은 예외 (예 : 최상위 main ()) 또는 @Throws로 표시되지 않은 Objective-C에서 Kotlin 호출로 예외가 발생하면 후크가 호출됩니다. 후크는 고정 된 람다이어야하므로 모든 스레드 / 작업자에서 호출 할 수 있습니다. 후크가 한 번 호출 된 후 나중에 지워 지므로 사용자 정의 예외 후크에서도 메모리 누수 감지가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">libgit2를 설치하고 git 라이브러리를위한 스텁을 준비하십시오 :</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;Chrome&lt;/a&gt; 을 통해 IntelliJ IDEA 내에서 디버깅 할 수 있는 JetBrains Chrome 확장 프로그램 을 설치하십시오 . 이것은 Kotlin뿐만 아니라 IntelliJ IDEA로 개발 된 모든 유형의 웹 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="translated">Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="translated">Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt; &lt;code&gt;cocoapods-generate&lt;/code&gt; &lt;/a&gt; plugin.</target>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="translated">Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="translated">Install the CocoaPods dependency manager and plugin</target>
        </trans-unit>
        <trans-unit id="1a87099d120ccde681dac7b4563f2ddd1e2d4aca" translate="yes" xml:space="preserve">
          <source>Install the Kotlin Plugin 1.4.x or higher in the IDE. You can check the Kotlin version in &lt;strong&gt;Tools&lt;/strong&gt; | &lt;strong&gt;Kotlin&lt;/strong&gt; | &lt;strong&gt;Configure Plugin Updates&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">EduTools 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">인스턴스 확인</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">인스턴스 필드</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">멤버를 호출하는 데 필요한 인스턴스 또는 내부 클래스 생성자를위한 외부 클래스 인스턴스</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">함수 타입 인스턴스화</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="translated">Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">메소드 &lt;code&gt;matches&lt;/code&gt; 직접 호출하는 대신 참조를 저장합니다. 이러한 참조는 수신기에 바인딩됩니다. 함수 유형의 표현식이 필요할 때마다 직접 호출하거나 (위의 예와 같이) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aad6314ddaef7ba86c76eaf3164d0bca4da5fc5d" translate="yes" xml:space="preserve">
          <source>Instead of creating a class that implements a functional interface manually, you can use a lambda expression. With a SAM conversion, Kotlin can convert any lambda expression whose signature matches the signature of the interface's single method into an instance of a class that implements the interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">매개 변수에 대한 함수 객체를 만들고 호출을 생성하는 대신 컴파일러는 다음 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b156a4a7a7d22439a598737b46c70a6ec2b640" translate="yes" xml:space="preserve">
          <source>Instead of doing this, you can create a hierarchical structure with &lt;a href=&quot;mpp-share-on-platforms#use-target-shortcuts&quot;&gt;target shortcuts&lt;/a&gt; available for typical multi-target scenarios, or you can manually declare and connect the source sets. For example, you can create two iOS targets and a shared source set with the &lt;code&gt;ios()&lt;/code&gt; shortcut:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db904fe60f6fc13954beaf8c6781a1e474eddead" translate="yes" xml:space="preserve">
          <source>Instead of manually compiling and executing our Kotlin/JS project every time we want to see the changes we made, we can make use of the &lt;em&gt;continuous compilation&lt;/em&gt; mode. Instead of using the regular &lt;code&gt;run&lt;/code&gt; command, we instead invoke the Gradle wrapper in &lt;em&gt;continuous&lt;/em&gt; mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">스레드 대신 Kotlin / Native 런타임은 작업자의 개념을 제공합니다. 연관된 요청 큐와 함께 동시에 실행 된 제어 흐름 스트림. 워커는 액터 모델의 액터와 매우 유사합니다. 작업자는 Kotlin 개체를 다른 작업자와 교환 할 수 있으므로 언제든지 각 변경 가능한 개체를 단일 작업자가 소유하지만 소유권을 양도 할 수 있습니다. &lt;a href=&quot;#transfer&quot;&gt;개체 전송 및 고정&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">예를 들어 &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; 와 같이 선언 사이트 차이가있는 매개 변수에 해당하는 형식 인수에 대해 와일드 카드를 생성하거나 생략하도록 컴파일러에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">선언 사이트 편차가있는 매개 변수에 해당하는 주석이 달린 형식 인수에 대해 와일드 카드를 생성하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Kotlin 컴파일러에게이 속성에 대한 getter / setter를 생성하지 않고 필드로 노출하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">기본 매개 변수 값을 대체하는이 함수에 대한 과부하를 생성하도록 Kotlin 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">주석이 달린 Java 클래스를 주어진 Kotlin 인터페이스의 순수한 구현으로 취급하도록 Kotlin 컴파일러에 지시합니다. &quot;순수함&quot;은 클래스의 각 유형 매개 변수가 해당 인터페이스의 비 플랫폼 유형 인수가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Kotlin의 정수 유형 은 Python의 임의의 큰 정수와 달리 &lt;em&gt;크기&lt;/em&gt; 가 &lt;em&gt;제한되어 있습니다&lt;/em&gt; . 제한은 유형에 따라 달라지며, 숫자는 메모리에서 숫자가 차지하는 비트 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">통합 유형 범위 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt; )에는 추가 기능이 있습니다. 반복 할 수 있습니다. 이 범위는 해당 정수 유형의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;진행률&lt;/a&gt; 입니다. 이러한 범위는 일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 에서 반복에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</target>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</target>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA는 스크래치를 자동으로 실행할 수 있습니다. 짧은 시간 동안 입력을 중단 한 후에 실행 결과를 얻으려면 &lt;strong&gt;대화식 모드를&lt;/strong&gt; 켜십시오 .</target>
        </trans-unit>
        <trans-unit id="918971018a2752255f900c2cf2e714f49b6e48a7" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412b9a62ef1aac11c1728c644747bfbcd40b3ae6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA opens the &lt;strong&gt;Run&lt;/strong&gt; tab and shows the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA는 &lt;a href=&quot;#maven-configuration&quot;&gt;Maven 구성&lt;/a&gt; 에서 해당 항목을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="translated">IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">DOM과 상호 작용</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">DOM과의 상호 작용</target>
        </trans-unit>
        <trans-unit id="4ee5033c0dc3e88efff33103b78dd8f7118a9355" translate="yes" xml:space="preserve">
          <source>Interactive editors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">대화식 모드</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 인터셉트 계속 .</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 인터셉트 계속 .</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">위임 된 속성 바인딩 차단</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">이 연속을 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">인터페이스 구현 레이아웃</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 값을 리턴하는 서스펜션 지점 이후의 연속을 나타내는 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 값을 리턴하는 서스펜션 지점 이후의 연속을 나타내는 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">인터페이스 &lt;em&gt;A&lt;/em&gt; 와 &lt;em&gt;B는&lt;/em&gt; 모두 &lt;em&gt;foo ()&lt;/em&gt; 및 &lt;em&gt;bar ()&lt;/em&gt; 함수를 선언합니다 . 둘 다 &lt;em&gt;foo ()를&lt;/em&gt; 구현 하지만 &lt;em&gt;B&lt;/em&gt; 만 구현합니다. &lt;em&gt;bar ()&lt;/em&gt; ( &lt;em&gt;bar ()&lt;/em&gt; 는 &lt;em&gt;A&lt;/em&gt; 에서 abstract로 표시되지 않습니다 . 함수에 본문이 없으면 인터페이스의 기본값이므로). 이제 &lt;em&gt;A&lt;/em&gt; 에서 구체적인 클래스 &lt;em&gt;C&lt;/em&gt; 를 파생 시키면 &lt;em&gt;bar ()&lt;/em&gt; 를 재정의 하고 구현을 제공해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">인터페이스 상속</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin의 인터페이스는 Java 8과 매우 유사합니다. 여기에는 메소드 구현뿐만 아니라 추상 메소드 선언도 포함될 수 있습니다. 그것들을 추상 클래스와 다른 점은 인터페이스가 상태를 저장할 수 없다는 것입니다. 속성을 가질 수 있지만 이들은 추상적이거나 접근 자 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</target>
        </trans-unit>
        <trans-unit id="6f2e69a2381964d98d7dca2d48b42c9749b41571" translate="yes" xml:space="preserve">
          <source>Intermediate flow operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">Java와의 Interop</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Java 리플렉션과의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="translated">Interoperability with Java reflection</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Swift / Objective-C와의 상호 운용성도 제공되며 별도의 문서 &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md에서 다루고&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc3ed9f2e2ef0d7ff8b99c31c5f5dfba491948e8" translate="yes" xml:space="preserve">
          <source>Introduce a local variable &lt;code&gt;name&lt;/code&gt; with the keyword &lt;code&gt;val&lt;/code&gt;. It will get its value from an input where you will enter your name &amp;ndash; &lt;code&gt;readLine()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">로컬 범위에서 변수로 표현식 소개 : &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">코 틀린 소개 (러시아어)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">코 틀린 프로그래밍 소개</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="f4afeb75d0f49bdd06579dbdb4f04043561414aa" translate="yes" xml:space="preserve">
          <source>Invariant projections of type arguments, such as &lt;code&gt;Smth&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;, &lt;code&gt;Array&amp;lt;@Ann Foo&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">이 값의 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">이 값에서 부호 비트를 포함하는 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; 호출은 코 루틴의 &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; 에있을 수 있는 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 를 거치지 않고 호출자의 스레드에서 직접 코 루틴을 재개합니다 . 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;연속&lt;/a&gt; 인터셉트를 사용하여 인터셉트 연속을 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">연산자 호출</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">원래 연속이 완료되어 더 이상 사용되지 않을 때 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation에&lt;/a&gt; 의해 리턴 된 연속 인스턴스에 대해 호출됩니다 . 이 함수는 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 이 호출 된 인스턴스와 다른 연속 인스턴스를 리턴 한 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">호출 &lt;code&gt;call()&lt;/code&gt; 함수 객체에하면 함수를 호출합니다. 멤버 함수 인 경우 첫 번째 매개 변수는 &lt;em&gt;수신자&lt;/em&gt; (이 경우 &lt;code&gt;person&lt;/code&gt; 을 호출 할 오브젝트 )이고 나머지 매개 변수는 일반 함수 매개 변수 (이 경우 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ) 여야합니다. .</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">특히 대규모 뷰 계층 구조의 경우 &lt;code&gt;findViewById()&lt;/code&gt; 호출 이 느려질 수 있으므로 Android Extensions는 컨테이너에서 뷰를 캐싱하여 &lt;code&gt;findViewById()&lt;/code&gt; 호출 을 최소화하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">함수형 인스턴스 호출</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">다른 컬렉션에서 함수 호출</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">코 틀린은 객체 지향 언어입니까, 기능 언어입니까?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Kotlin은 Java 프로그래밍 언어와 호환됩니까?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">코 틀린은 무료입니까?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">코 틀린은 단단합니까?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">코 틀린은 소셜 미디어에 있습니까?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="translated">Is Kotlin on social media?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">확장 기능</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">코 틀린 회의가 있습니까?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">우리가 처음부터 원하는 것이 아닌가?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">별도의 JavaScript 객체에서 선언 분리</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="translated">Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">메타 주석과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 코 루틴을 생성하는 간단한 예제로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="translated">It can be demonstrated by the following example:</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">물론 단일 표현식으로 수행 할 수 있습니다 : &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">몇 가지 새로운 기술을 보여줍니다. 하나는 명시 적으로 지정된 컨텍스트와 함께 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 을 사용 하고 다른 하나는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; 함수를 사용하여 아래 출력에서 ​​볼 수있는 것과 동일한 코 루틴에 머물면서 코 루틴의 컨텍스트를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="translated">It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">액터 자체가 어떤 컨텍스트에서 실행되는지는 (정확성을 위해) 중요하지 않습니다. 액터는 코 루틴이고 코 루틴은 순차적으로 실행되므로 특정 코 루틴에 대한 상태의 제한은 공유 가능한 가변 상태 문제에 대한 해결책으로 작동합니다. 실제로 액터는 자신의 개인 상태를 수정할 수 있지만 메시지를 통해서만 서로에게 영향을 줄 수 있습니다 (잠금이 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">대상은 &lt;code&gt;writeLogMessage&lt;/code&gt; 에 플랫폼 별 구현을 제공 할 것으로 예상 되며, 공통 코드는 구현 방법을 고려하지 않고이 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">람다 대신 호출 가능한 참조가있을 때 사용하는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">프로젝트에서 모든 Kotlin 컴파일 작업을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">표준 Chrome 디버거를 사용하여 Kotlin 응용 프로그램을 디버깅 할 수도 있습니다. 소스 맵을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">임의의 단계 (필수 1은 아님)로 숫자를 반복 할 수도 있습니다. 이것은 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; 기능을 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">특정 레이아웃에 대한 모든 위젯 속성을 한 번에 가져 오는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">&lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 함수를 요소 소스 에 첨부하여 작성됩니다 . &lt;a href=&quot;index&quot;&gt;그룹화&lt;/a&gt; 인스턴스를 가져 오려면 &lt;code&gt;groupingBy&lt;/code&gt; 확장 함수 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6148f03cfc2015e2c10414350a23c5c6eccbddac" translate="yes" xml:space="preserve">
          <source>It is currently prohibited to export the following kinds of declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">실제로 시연하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">컴파일 된 Kotlin 코드를 C, C ++, Swift, Objective-C 및 기타 언어로 작성된 기존 프로젝트에 쉽게 포함시킬 수 있습니다. 또한 기존 네이티브 코드, 정적 또는 동적 &lt;a href=&quot;native/c_interop&quot;&gt;C 라이브러리&lt;/a&gt; , Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;프레임 워크&lt;/a&gt; , 그래픽 엔진 및 Kotlin / Native에서 직접 사용하는 모든 것을 쉽게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1e4c80fa63f2c717618535a583de6ba5b964535" translate="yes" xml:space="preserve">
          <source>It is easy to use flows to represent asynchronous events that are coming from some source. In this case, we need an analogue of the &lt;code&gt;addEventListener&lt;/code&gt; function that registers a piece of code with a reaction for incoming events and continues further work. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html&quot;&gt;onEach&lt;/a&gt; operator can serve this role. However, &lt;code&gt;onEach&lt;/code&gt; is an intermediate operator. We also need a terminal operator to collect the flow. Otherwise, just calling &lt;code&gt;onEach&lt;/code&gt; has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">Kotlin의 C &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;union&lt;/code&gt; 유형에 대해 생성 된 래퍼 클래스를 사용하는 것은 쉽습니다 . 생성 된 특성 덕분에 Kotlin 코드에서 자연스럽게 사용할 수 있습니다. 지금까지 유일한 질문은 이러한 클래스에서 새 인스턴스를 작성하는 방법입니다. &lt;code&gt;MyStruct&lt;/code&gt; 와 &lt;code&gt;MyUnion&lt;/code&gt; 의 선언에서 알 수 있듯이 생성자는 &lt;code&gt;NativePtr&lt;/code&gt; 이 필요합니다 . 물론, 우리는 포인터를 수동으로 다루려고하지 않습니다. 대신 Kotlin API를 사용하여 해당 객체를 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">이 Java 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">인라인 클래스가 클래스 계층에 참여하는 것은 금지되어 있습니다. 즉, 인라인 클래스는 다른 클래스를 확장 할 수 없으며 &lt;em&gt;최종&lt;/em&gt; 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin / Native 대상&lt;/a&gt; 중 일부 는 적절한 호스트 시스템으로 만 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">그것은 단지의 경우 같은 것을 이해하는 것이 중요합니다 &lt;code&gt;callAnything()&lt;/code&gt; 의 &lt;code&gt;dataTable()&lt;/code&gt; 함수는 런타임에 존재해야합니다. 우리의 경우 플러그인에 해당하는 스크립트 파일이 포함되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="12337a359954227bfe96e37274de5fc654fa35be" translate="yes" xml:space="preserve">
          <source>It is not recommended that you publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">종속 항목이 하나 일 경우 하나의 종속성 목록으로 병합되므로 변형이 다른 경우 제품 버전별로 그룹화 된 변형을 게시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">디렉토리 및 패키지와 일치 할 필요는 없습니다. 소스 파일은 파일 시스템에 임의로 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">이제 열거 형 클래스의 값을 일반적인 방식으로 열거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">플랫폼 독립적입니다. JVM, JavaScript 또는 기타 플랫폼을 대상으로 작성하든 작성하는 코드는 동일합니다. 커버 아래에서 컴파일러는 각 플랫폼에 맞게 컴파일러를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">클래스가 인터페이스 인 것처럼 함수 유형을 구현할 수 있습니다. 그런 다음 주어진 서명으로 &lt;code&gt;invoke&lt;/code&gt; 라는 연산자 함수를 제공해야하며 해당 클래스의 인스턴스를 해당 함수 유형의 변수에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">제네릭 형식의 형식 인수에 주석을 달아 nullable 정보도 제공 할 수 있습니다. 예를 들어, Java 선언에서 다음 주석을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">모든 소스 세트의 언어 설정을 한 번에 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;memScoped { ... }&lt;/code&gt; 에서 사용 가능한 &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 확장 등록 정보를 사용하여 &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 의 C 표현에 대한 범위 안정 포인터를 작성할 수 있습니다 . 수명이 특정 &lt;code&gt;MemScope&lt;/code&gt; 에 바인딩 된 C 포인터가 필요한 API를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="translated">It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt; &lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; . The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">자신의 함수에 대한 계약을 선언하는 것이 가능하지만 현재 구문이 초기 프로토 타입 상태이며 변경 될 가능성 이 있으므로이 기능은 &lt;strong&gt;실험적&lt;/strong&gt; 입니다. 또한 현재 Kotlin 컴파일러는 계약을 확인하지 않으므로 정확하고 건전한 계약을 작성하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">글롭으로 헤더를 필터링 할 수 있습니다. &lt;code&gt;.def&lt;/code&gt; 파일 의 &lt;code&gt;headerFilter&lt;/code&gt; 속성 값은 공백으로 구분 된 glob 목록으로 처리됩니다. 포함 된 헤더가 glob 중 하나와 일치하면이 헤더의 선언이 바인딩에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">다중 플랫폼 라이브러리에서 단일 플랫폼에 대해 둘 이상의 대상을 가질 수 있습니다. 예를 들어, 이러한 대상은 동일한 API를 제공 할 수 있으며 테스트 프레임 워크 또는 로깅 솔루션과 같이 런타임시 협력하는 라이브러리가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">바이너리를 생성하는 데 사용될 빌드 유형과 그렇지 않은 빌드 유형을 지정할 수 있습니다. 다음 예제에서는 디버그 실행 파일 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">키 목록을 갖고 이러한 키를 각각의 값과 연관시켜 맵을 작성하려는 경우는 매우 일반적인 상황입니다. &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 함수 를 사용하여 이전에 수행 할 수 있었지만 이제는보다 효율적이고 탐색하기 쉬운 대안을 제공합니다. &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af6059bcf4a05b2b995079d84a33266eddebc57" translate="yes" xml:space="preserve">
          <source>It is recommended to only provide external declarations manually in your source folder &lt;em&gt;or&lt;/em&gt; enabling the generation of external declarations at build time for any single dependency. Doing both can result in resolution issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; 으로 취급하는 것이 안전합니다. 그러면 &lt;code&gt;Apple&lt;/code&gt; 인스턴스 만 추가 할 수 있지만 &lt;code&gt;Fruit&lt;/code&gt; 을받을 수 있기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; 을 &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; &amp;gt; 인 것처럼 취급하는 것이 안전합니다. &lt;code&gt;Apple&lt;/code&gt; 인스턴스 만 생산할 수있는 것은 Apple 인스턴스이지만 &lt;code&gt;Apple&lt;/code&gt; 은 &lt;code&gt;Fruit&lt;/code&gt; 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 세트 의 hashCode와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">Kotlin 프로그램에서 C 함수를 사용해보십시오. &lt;code&gt;accept_fun&lt;/code&gt; 함수를 호출하고 C 함수 포인터를 Kotlin 람다에 전달합니다 :</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">으로 T 매개 변수 유형을 선언하는 것이 매우 편리 &lt;em&gt;밖으로&lt;/em&gt; 사용하는 사이트에 하위 유형와 회피 문제가 있지만, 일부 클래스는 &lt;strong&gt;할 수없는&lt;/strong&gt; 사실만을 반환에 제한 &lt;code&gt;T&lt;/code&gt; 의를! 이에 대한 좋은 예는 Array입니다.</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="translated">It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">100K 코 루틴을 시작하고 1 초 후에 각 코 루틴이 점을 인쇄합니다. 이제 스레드로 시도하십시오. 무슨 일이 일어날 지? (아마도 코드에서 일종의 메모리 부족 오류가 발생할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">코 틀린에서 볼 수있는 다음과 같은 서명으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="translated">It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</target>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="translated">It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">선언이 와일드 카드없이 Java에서 사용하기 불편한 경우에만 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">선언이 Java에서 사용하기 불편한 경우에만 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">IntelliJ IDEA에서 기본값을 전환하고 Kotlin Coding Conventions와 일치하도록 형식을 지정하여 이러한 모호성을 제거하는 것이 논리적으로 다음 단계로 보일 수 있습니다. 그러나 이것은 기존의 모든 Kotlin 프로젝트가 Kotlin 플러그인이 설치되는 순간 새로운 코드 스타일을 사용할 수 있음을 의미합니다. 플러그인 업데이트에 대한 예상 결과가 맞지 않습니까?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">이는 기본 클래스 생성자가 실행될 때 파생 클래스에서 선언되거나 재정의 된 속성이 아직 초기화되지 않았 음을 의미합니다. 이러한 속성 중 하나라도 기본 클래스 초기화 로직에서 사용되는 경우 (직접적으로 또는 다른 재정의 된 &lt;em&gt;오픈&lt;/em&gt; 멤버 구현을 통해 간접적으로 ) 잘못된 동작 또는 런타임 오류가 발생할 수 있습니다. 따라서 기본 클래스를 디자인 할 때는 생성자, 속성 이니셜 라이저 및 &lt;em&gt;init&lt;/em&gt; 블록 에서 &lt;em&gt;열린&lt;/em&gt; 멤버를 사용하지 않아야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">덜 구조화 된 입력 형식을 구문 분석 하기 위해 JVM의 &lt;code&gt;java.util.Scanner&lt;/code&gt; 클래스 를 사용하는 것이 좋습니다 . Kotlin은 JVM 라이브러리와 잘 호환되도록 설계되어 Kotlin에서 사용이 매우 자연 스럽습니다. 그러나 &lt;code&gt;java.util.Scanner&lt;/code&gt; 가 매우 느리다는 점에 유의하십시오 . 실제로 10 &lt;sup&gt;5&lt;/sup&gt; 개 이상의 정수 를 구문 분석 하는 것은 일반적인 2 초 시간 제한에 맞지 않을 수 있습니다. 이는 간단한 Kotlin의 &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; 이 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">용량이 &lt;em&gt;4 인&lt;/em&gt; 버퍼링 된 채널을 사용하여 &quot;보내기&quot;를 &lt;em&gt;다섯&lt;/em&gt; 번 인쇄합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">다음 줄을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4fc49613736421c5526df5f47051346dc40ed425" translate="yes" xml:space="preserve">
          <source>It prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;디버그 모드&lt;/a&gt; 에서 실행할 때와 같은 것을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="937e4c5bd1079031a2dfad58d8e0700ddac7f05b" translate="yes" xml:space="preserve">
          <source>It produces something like this, with the whole collection taking around 1200 ms (three numbers, 400 ms for each):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">다음과 같은 출력을 생성합니다 (다른 순서로 표시 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="020338510019284e271656ee98c10ee9502fa284" translate="yes" xml:space="preserve">
          <source>It produces the following three lines, each line appearing after each second:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b842d5f86ada273da6149c65d3d77df472ae9b5" translate="yes" xml:space="preserve">
          <source>It produces the same numbers just faster, as we have effectively created a processing pipeline, having to only wait 100 ms for the first number and then spending only 300 ms to process each number. This way it takes around 1000 ms to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">전달 된 두 함수의 구성을 리턴합니다. &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; . 이제 호출 가능한 참조에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="translated">It simplifies code generation, for example, for object initializers. The last element can also have a comma.</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">두 개의 &lt;code&gt;Int&lt;/code&gt; 매개 변수를 사용하고 &lt;code&gt;Double&lt;/code&gt; 을 반환 하므로 유형은 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 입니다. 이름 앞에 &lt;code&gt;::&lt;/code&gt; 접두사를 붙여 함수 자체를 참조 할 수 있고 변수에 할당 할 수 있습니다 (유형은 일반적으로 유추되지만 데모를 위해 형식 서명을 표시합니다).</target>
        </trans-unit>
        <trans-unit id="2543e91e8c67adc1567e54c9ccc67fdf2ca3724a" translate="yes" xml:space="preserve">
          <source>It was really annoying when all the arguments were in their correct positions but you wanted to specify a name for one argument in the middle. It was especially helpful for making absolutely clear which attribute a boolean or &lt;code&gt;null&lt;/code&gt; value belongs to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">플랫폼 별 공유 객체 (Linux에서는 .so, macOS에서는 .dylib, Windows에서는 .dll)와 C 언어 헤더를 생성하여 C /에서 Kotlin / Native 프로그램에서 사용할 수있는 모든 공용 API를 사용할 수 있습니다. C ++ 코드. 이러한 공유 객체를 사용하여 Python과 Kotlin / Native 간의 브리지를 제공하는 예제는 &lt;code&gt;samples/python_extension&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">플랫폼 별 정적 객체 (. 라이브러리 형식)와 C 언어 헤더를 생성하여 C / C ++ 코드에서 Kotlin / Native 프로그램에서 사용 가능한 모든 공용 API를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5675ec989f2dc249c2ff33b781d2949c2f52a5" translate="yes" xml:space="preserve">
          <source>It works only for interop libraries shipped with Kotlin/Native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="translated">It&amp;rsquo;s almost done, user feedback is especially important now.</target>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="translated">It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="translated">It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">안드로이드 개발을 위해 Kotlin을 사용하는 것은 매우 쉽습니다. 이 튜토리얼에서는 Android Studio의 워밍업 프로세스를 따릅니다. Android에서 Intellij IDEA를 사용하는 경우 프로세스는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 에서 동일한 배열을 전달 하고 대상 범위와 겹치도록 하위 범위를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 에서 동일한 배열을 전달 하고 대상 범위와 겹치도록 하위 범위를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</target>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">IntelliJ IDEA 코드 스타일을 프로젝트의 올바른 코드 스타일로 명시 적으로 설정할 수 있습니다. 받는 사람 그렇게하십시오 스위치를 수행 &lt;em&gt;프로젝트&lt;/em&gt; 의 계획 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; 선택 &lt;em&gt;&quot;코 틀린 쓸모하게 IntelliJ IDEA의 codestyle을&quot;&lt;/em&gt; 에 &lt;em&gt;&quot;에서 기본값 사용 :&quot;&lt;/em&gt; 온 &lt;em&gt;로드&lt;/em&gt; 탭을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">현재 varargs로 선언 된 메서드에는 &lt;em&gt;null&lt;/em&gt; 을 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">그것의 모두 상속 미세 와 &lt;code&gt;B&lt;/code&gt; , 그리고 우리는 아무런 문제가 없다 &lt;code&gt;a()&lt;/code&gt; 와 &lt;code&gt;b()&lt;/code&gt; 이후 &lt;code&gt;C&lt;/code&gt; 의 상속이 각각의 기능의 하나의 구현. 그러나 대한 &lt;code&gt;f()&lt;/code&gt; 우리는 상속이 구현이 &lt;code&gt;C&lt;/code&gt; 를 , 따라서 우리는 오버라이드 (override) 할 필요가 &lt;code&gt;f()&lt;/code&gt; 에 &lt;code&gt;C&lt;/code&gt; 와 우리 자신의 구현을 제거해 그 모호성을 제공합니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="translated">It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt; , but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt; , so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">작업이 끝나면 스트림을 닫는 것이 중요합니다. 그렇지 않으면 프로그램이 파일 핸들을 누출시킵니다. 이 작업을 잘 수행하는 방법은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Kotlin 지원 포함&lt;/em&gt; 확인란이 선택되어 있는지 확인해야합니다 . 지금은 마법사의 다음 단계에서 기본 설정을 그대로 둘 수 있습니다. 그런 다음 &lt;em&gt;Empty Activity&lt;/em&gt; 옵션 을 선택하고 &lt;em&gt;Next를&lt;/em&gt; 클릭 하고 마지막으로 &lt;em&gt;Finish를&lt;/em&gt; 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">이것이 이제는 기본 애플리케이션이며 런타임 또는 가상 머신이 필요하지 않음을 이해해야합니다. 이제 콘솔에서 컴파일 된 바이너리를 실행할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="translated">It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">과 코 틀린 플러그인을 적용하지 않는 것이 좋습니다 &lt;code&gt;apply&lt;/code&gt; Gradle을 코 틀린 DSL에. 자세한 내용은 &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;아래&lt;/a&gt; 에 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">&lt;em&gt;일부&lt;/em&gt; 속성을 변경 하지만 나머지는 변경하지 않고 객체를 복사해야하는 경우가 종종 있습니다. 이것이 &lt;code&gt;copy()&lt;/code&gt; 함수가 생성되는 것입니다. 위 의 &lt;code&gt;User&lt;/code&gt; 클래스의 경우 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">구성 요소에 대한 cinterop 종속성을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">이전에 maven 저장소에 게시 된 Kotlin / Native 라이브러리에 의존 할 수 있습니다. 플러그인은 Gradle의 &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;메타 데이터&lt;/a&gt; 지원 에 의존 하므로 해당 기능을 활성화해야합니다. &lt;code&gt;settings.gradle&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="translated">It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">이 주석으로 주석을 달아서 서명되지 않은 유형에 의존하는 API에 실험 상태를 전파하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">클라이언트가 API 사용을 명시 적으로 선택해야하는지 여부를 결정해야하지만 서명되지 않은 유형은 실험적인 기능이므로 언어 ​​변경으로 인해이를 사용하는 API가 갑자기 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="translated">It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">긴 제네릭 형식을 줄이는 것이 좋습니다. 예를 들어 컬렉션 유형을 축소하려는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">람다 식에 매개 변수가 하나만있는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">이 리더의 각 라인을 반복하고, 각 라인 읽기에 대한 &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 호출 하고 완료되면 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;리더를&lt;/a&gt; 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">컬렉션을 반복 :</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">범위에서 반복 :</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">주어진 문자 순서의 문자에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">Iterator &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; 함수를 호출 하여 &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;List&lt;/code&gt; 를 포함한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 인터페이스 의 상속자에 대해 반복자를 얻을 수 있습니다 . 반복자를 얻으면 컬렉션의 첫 번째 요소를 가리 킵니다. &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 함수를 호출하면 이 요소가 반환되고 이터레이터 위치가 있으면 다음 요소로 이동합니다. 반복자가 마지막 요소를 통과하면 더 이상 요소를 검색하는 데 사용할 수 없습니다. 이전 위치로 재설정 할 수도 없습니다. 콜렉션을 다시 반복하려면 새 반복자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">&lt;code&gt;androidMain&lt;/code&gt; 소스 세트 의 Android 프로젝트에 대한 JAR 파일</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA 지원</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="18acc06f648ff3dfaa92d38568a89dcb1c336e71" translate="yes" xml:space="preserve">
          <source>JS + Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305 ( &lt;code&gt;javax.annotation&lt;/code&gt; , 자세한 내용은 아래 참조)</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 지원</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="ba55f5a90bf0d3ce9f1b0f807b6ef302c9ac96c9" translate="yes" xml:space="preserve">
          <source>JVM + Android targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91c8eab1c7dd4c61791a6e6cea54a63f44fc1bc" translate="yes" xml:space="preserve">
          <source>JVM + JS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c072fe1de9573a0b46a9ce0b06fdf1d4adc47cb" translate="yes" xml:space="preserve">
          <source>JVM + JS + Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9d77993a56f0043f2307875f7d47573f436cff" translate="yes" xml:space="preserve">
          <source>JVM + Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM 백엔드</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVM 백엔드</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="translated">JVM dependency</target>
        </trans-unit>
        <trans-unit id="458cadbdc19f7b0625a6ae9eae43cf7d180c87dd" translate="yes" xml:space="preserve">
          <source>JVM modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7843626ea3524e7d3635490a634ced48fdacaeb5" translate="yes" xml:space="preserve">
          <source>JVM targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">항아리 파일</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">Java 7의 리소스를 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">Java 8 바이트 코드 지원</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Java 8 표준 라이브러리 지원</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">자바 주석</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">자바 배열</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http 서블릿은 다른 Java 라이브러리 또는 프레임 워크와 마찬가지로 Kotlin에서 사용할 수 있습니다. &quot;Hello, World!&quot;를 반환하는 간단한 컨트롤러를 만드는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">자바 상호 운용성</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">자바 리플렉션</target>
        </trans-unit>
        <trans-unit id="2fbdce03c9470f1b2722c2ee692684eb6163442c" translate="yes" xml:space="preserve">
          <source>Java SAM interfaces in Kotlin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVM 대상에서 Java 지원</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">자바 Varargs</target>
        </trans-unit>
        <trans-unit id="83c71cd47e81bcbb82cda5a763f3b5d7be5fba22" translate="yes" xml:space="preserve">
          <source>Java Virtual Machine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java 주석은 Kotlin과 100 % 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Java 클래스는 때때로 가변 개수의 인수 (varargs)와 함께 색인에 메소드 선언을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">자바 컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">코 틀린의 자바 제네릭</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">자바 상호 운용 :</target>
        </trans-unit>
        <trans-unit id="05bbb6e796992dd8a4fef0cfa9a4d27c4b673a12" translate="yes" xml:space="preserve">
          <source>Java libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java는 몇 년 전에 함수 유형과 람다 식만 지원했습니다. 이전에 Java는 인터페이스를 사용하여 함수 서명을 정의하고 인터페이스를 구현하는 클래스의 인라인 익명 정의를 허용하여이 문제를 해결했습니다. Kotlin에서도 부분적으로 Java 라이브러리와의 호환성을 위해 사용할 수 있으며, 특히 동일한 리스너 객체가 수신해야하는 이벤트 유형이 둘 이상인 경우 이벤트 핸들러를 지정하는 데 유용 할 수 있기 때문에이 기능을 사용할 수 있습니다. 인터페이스 또는 (아마도 추상적 인) 클래스와 그 인스턴스를 취하는 함수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Java 리플렉션은 Kotlin 클래스에서 작동하며 그 반대도 마찬가지입니다. 위에서 언급 한 것처럼 &lt;code&gt;instance::class.java&lt;/code&gt; , &lt;code&gt;ClassName::class.java&lt;/code&gt; 또는 &lt;code&gt;instance.javaClass&lt;/code&gt; 를 사용하여 &lt;code&gt;java.lang.Class&lt;/code&gt; 를 통해 Java 리플렉션을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="translated">Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt; , &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt; . You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">널 입력 가능 어노테이션이있는 Java 유형은 플랫폼 유형이 아니라 실제 널 입력 가능 또는 널이 아닌 Kotlin 유형으로 표시됩니다. 컴파일러는 다음을 포함하여 여러 가지 널 입력 가능 주석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Java의 배열은 &lt;a href=&quot;java-interop#java-arrays&quot;&gt;다음&lt;/a&gt; 과 같이 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">자바의 박스형 프리미티브 유형은 nullable Kotlin 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Java의 원시 유형은 별 투영법으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Java의 와일드 카드는 유형 투영으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">자바 기본 메소드 호출</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">자바 스타일 반영</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">Java2Kotlin 변환기</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">자바 스크립트 백엔드</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">자바 스크립트 DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="translated">JavaScript Dead Code Elimination (DCE)</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">자바 스크립트 모듈</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">자바 스크립트 리플렉션</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">자바 스크립트 백엔드</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">JavaScript 백엔드는 이제 더 정적으로 확인할 수있는 코드를 생성하는데,이 코드는 축소 기, 최적화 기, 린터 등과 같은 JS 코드 처리 도구에 더 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScript에는 패키지 (네임 스페이스) 개념이 없습니다. 일반적으로 중첩 된 객체에 의해 에뮬레이트됩니다. 컴파일러는 &lt;code&gt;external&lt;/code&gt; 선언에 대한 참조를 일반 접두사없는 일반 이름 ( &lt;em&gt;일반&lt;/em&gt; 모듈의 경우 ) 또는 일반 가져 오기로 바꿉니다 . 그러나 JavaScript 라이브러리가 선언을 패키지로 제공하면 이에 만족하지 않습니다. &lt;code&gt;@JsQualifier(...)&lt;/code&gt; 주석을 사용하여 &lt;code&gt;external&lt;/code&gt; 선언에 대한 참조 전에 추가 접두사를 생성하도록 컴파일러에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScript에는 인터페이스 개념이 없습니다. 함수가 해당 매개 변수가 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 메서드 를 지원할 것으로 예상하면 실제로 이러한 메서드가있는 객체를 전달하면됩니다. 정적으로 형식화 된 Kotlin에 대해 인터페이스를 사용하여이를 표현할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="translated">JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; , you would just pass in an object that actually has these methods.</target>
        </trans-unit>
        <trans-unit id="5b5802824529ccfad8f8c81c90d94e61f99e64f2" translate="yes" xml:space="preserve">
          <source>JavaScript targets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains는 React 커뮤니티를 위해 특별히 다음과 같은 몇 가지 도구를 개발하고 유지 관리합니다. &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React 바인딩&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;React Kotlin App 작성&lt;/a&gt; . 후자는 빌드 구성없이 Kotlin으로 React 앱을 빌드하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">맥락에서의 직업</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="translated">Join the Kotlin/JS community</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">관련 학습서에서 Kotlin / Native의 C 언어 유형 및 해당 표현을 계속 탐색하려면 우리와 함께하십시오.</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">코스 참여</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">여호수아 블로흐 그 당신은 개체를 호출 &lt;strong&gt;읽기&lt;/strong&gt; 에서 &lt;strong&gt;생산자&lt;/strong&gt; 는 만하고 &lt;strong&gt;쓰기&lt;/strong&gt; 에 &lt;strong&gt;소비자&lt;/strong&gt; . &quot; &lt;em&gt;유연성을 극대화하려면 생산자 또는 소비자를 나타내는 입력 매개 변수에 와일드 카드 유형을 사용&lt;/em&gt; 하고 다음 니모닉을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">스레드 간 점프</target>
        </trans-unit>
        <trans-unit id="c4dd39bfc503df3e7ae8d48062e97ce8c118b15c" translate="yes" xml:space="preserve">
          <source>Jupyter Kotlin kernel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">플러그인 JAR 파일을 컴파일러 플러그인 클래스 경로에 추가하고 sam-with-receiver 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Java 8에서와 마찬가지로 Kotlin은 이제 숫자 리터럴에서 밑줄을 사용하여 숫자 그룹을 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="884734e755cc6d6bbd1b938aff073932b22e3094" translate="yes" xml:space="preserve">
          <source>Just change the Kotlin version to &lt;code&gt;1.4.0&lt;/code&gt; and re-import your Gradle or Maven project. The IDE will then ask you about migration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Java 8과 마찬가지로 Kotlin은 SAM 변환을 지원합니다. 이는 인터페이스 메소드의 매개 변수 유형이 Kotlin 함수의 매개 변수 유형과 일치하는 경우 기본이 아닌 단일 메소드를 사용하여 Kotlin 함수 리터럴을 Java 인터페이스 구현으로 자동 변환 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">Java 및 JavaScript와 마찬가지로 Kotlin은 라인 끝 및 블록 주석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Java의 익명 내부 클래스와 마찬가지로 객체 표현식의 코드는 둘러싸는 범위에서 변수에 액세스 할 수 있습니다. Java와 달리 이는 최종 변수 또는 사실상 최종 변수로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Java와 마찬가지로 특별한 경우는 &lt;code&gt;value&lt;/code&gt; 매개 변수입니다. 명시적인 이름없이 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Java와 마찬가지로 Kotlin의 열거 형 클래스에는 정의 된 열거 형 상수를 나열하고 이름별로 열거 형 상수를 얻을 수있는 합성 메서드가 있습니다. 이러한 메소드의 서명은 다음과 같습니다 (enum 클래스의 이름이 &lt;code&gt;EnumClass&lt;/code&gt; 라고 가정 ).</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="translated">Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">컴패니언 객체의 일반 멤버와 마찬가지로 클래스 이름 만 한정자로 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27573ad44b2952298adae482665b1d05330c84b0" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/zip&quot;&gt;Sequence.zip&lt;/a&gt; extension function in the Kotlin standard library, flows have a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html&quot;&gt;zip&lt;/a&gt; operator that combines the corresponding values of two flows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">JavaDoc과 마찬가지로 KDoc 주석은 &lt;code&gt;/**&lt;/code&gt; 로 시작 하고 &lt;code&gt;*/&lt;/code&gt; 로 끝납니다 . 주석의 모든 줄은 별표로 시작할 수 있으며, 주석 내용의 일부로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="7d24ba100f0e49fea8997c1580577eea18ef483a" translate="yes" xml:space="preserve">
          <source>KAPT: Names of synthetic &lt;code&gt;$annotations()&lt;/code&gt; methods for properties have changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc 구문</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDoc은 현재 다음 블록 태그를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc은 &lt;code&gt;@deprecated&lt;/code&gt; 태그를 지원하지 않습니다 . 대신 &lt;code&gt;@Deprecated&lt;/code&gt; 주석을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc 구문</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="translated">KLib binaries</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt은 Kotlin 소스를 생성 할 수 있습니다. 생성 된 Kotlin 소스 파일을 &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; 로 지정된 디렉토리에 쓰면 이 파일들이 기본 소스와 함께 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt 컴파일러 플러그인은 Kotlin 컴파일러의 바이너리 배포판에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt는 Java 컴파일러를 사용하여 주석 프로세서를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">이것은 구문상의 설탕 일뿐입니다. 실제로 클래스 나 인스턴스를 수정하지는 않습니다. 따라서 클래스의 인스턴스와 함께 제공되지 않으므로 확장 기능 / 속성을 사용하려는 곳마다 가져와야합니다. 같은 이유로 확장 멤버를 재정의 할 수 없습니다. 하위 멤버에 대해 확장 멤버를 다시 구현할 수 있지만 호출하는 식의 정적 형식에 따라 컴파일 타임에 해결이 이루어집니다. 따라서 &lt;code&gt;Vehicle&lt;/code&gt; 에 대한 확장 함수 와 서브 클래스 &lt;code&gt;Car&lt;/code&gt; 에 대한 동일한 이름 및 서명을 가진 확장 함수를 선언 하고 다음을 수행하는 경우 &lt;code&gt;v&lt;/code&gt; 가 실제로 &lt;code&gt;Car&lt;/code&gt; 인 경우에도 호출 되는 &lt;code&gt;Vehicle&lt;/code&gt; 의 확장 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">수년간 언어를 현대적으로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="translated">Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Keepsafe의 App Lock 앱도 &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;100 % Kotlin&lt;/a&gt; 으로 변환 되어 소스 라인 수가 30 % 감소하고 분석법 수가 10 % 감소했습니다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; 요소의 키입니다 . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; 는이 키가있는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; 요소의 키입니다 . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; 는이 키가있는 요소 유형입니다. 컨텍스트의 키는 &lt;em&gt;참조&lt;/em&gt; 로 비교 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">키워드 및 연산자</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">컴파일러에 의해 생성 된 모듈의 종류</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">이 매개 변수의 종류</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind는 소스 코드에서 매개 변수 선언의 특정 위치 (예 : 확장 수신자 매개 변수 또는 값 매개 변수)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1은 비동기 비 차단 코드를 작성하는 새로운 방법 인 코 루틴을 도입했습니다. 이 학습서에서는 기존 Java 라이브러리에 대한 헬퍼 및 랩퍼 콜렉션 인 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 라이브러리 의 도움으로 Kotlin 코 루틴을 사용하는 몇 가지 기본 사항을 살펴 봅니다 .</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1은 Kotlin 1.0에 존재하는 봉인 및 데이터 클래스에 대한 일부 제한을 제거합니다. 이제 봉인 클래스의 중첩 클래스뿐만 아니라 동일한 파일에서 최상위 수준 봉인 클래스의 하위 클래스를 정의 할 수 있습니다. 데이터 클래스는 이제 다른 클래스를 확장 할 수 있습니다. 이를 통해 표현 클래스의 계층 구조를 훌륭하고 명확하게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2는 &lt;code&gt;BigInteger&lt;/code&gt; 및 &lt;code&gt;BigDecimal&lt;/code&gt; 과 함께 작동하고 다른 숫자 유형에서 작성하기 위한 함수 세트를 소개합니다 . 이것들은:</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3은 스크립팅 API를 지속적으로 개선하고 개선하여 외부 속성 추가, 정적 또는 동적 종속성 제공 등과 같은 스크립트 사용자 지정에 대한 실험적인 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3은 Native Target을 지속적으로 개선하고 개선합니다. 자세한 내용은 &lt;a href=&quot;native-overview&quot;&gt;Kotlin / Native 개요&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3은 매개 변수를 사용하지 않는 간단한 형식의 &lt;code&gt;main&lt;/code&gt; 을 도입했습니다 . 이제 Kotlin의 &quot;Hello, World&quot;는 19 자 더 짧습니다!</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3에는 새로운 종류의 선언 인 &lt;code&gt;inline class&lt;/code&gt; 도입되었습니다 . 인라인 클래스는 일반 클래스의 제한된 버전으로 볼 수 있습니다. 특히 인라인 클래스에는 정확히 하나의 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3은 Reflection API에서 일시 중단 기능과 Coroutines 지원에 대한 호출 가능한 참조를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3은 실행 가능한 Kotlin &lt;em&gt;스크래치 파일을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;스크래치 파일&lt;/em&gt; 은 편집기에서 직접 평가 결과를 얻을 수있는 .kts 확장자를 가진 kotlin 스크립트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3 은 IDE에서 &lt;a href=&quot;coding-conventions&quot;&gt;권장 코드 스타일&lt;/a&gt; 을 지원합니다 . 마이그레이션 지침은 &lt;a href=&quot;code-style-migration-guide&quot;&gt;이 페이지&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3에는 부호없는 정수 유형이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3은이 제한을 완화하고 더 큰 arity를 ​​가진 기능에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="066cd750e197b01a81e98cd924fadfe8604b9df8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 supports more cases for using callable references:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5350f6595e85d319ae1e0cc79c4bfec4d9dbf0c3" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4 uses a new, more powerful type inference algorithm. This new algorithm was already available to try in Kotlin 1.3 by specifying a compiler option, and now it&amp;rsquo;s used by default. You can find the full list of issues fixed in the new algorithm in &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT?q=Tag:%20fixed-in-new-inference%20&quot;&gt;YouTrack&lt;/a&gt;. Here you can find some of the most noticeable improvements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bc80b855b0a3b819dba3841d64e1cfc7470a8c4" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 adds &lt;code&gt;module-info.java&lt;/code&gt; module information to default standard library artifacts. This lets you use them with &lt;a href=&quot;https://docs.oracle.com/en/java/javase/11/tools/jlink.html&quot;&gt;&lt;strong&gt;jlink&lt;/strong&gt; tool&lt;/a&gt;, which generates custom Java runtime images containing only the platform modules that are required for your app. You could already use jlink with Kotlin standard library artifacts, but you had to use separate artifacts to do so &amp;ndash; the ones with the &amp;ldquo;modular&amp;rdquo; classifier &amp;ndash; and the whole setup wasn&amp;rsquo;t straightforward.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0378da784d7afe2b6f5df83cd22d948f8f205d9b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with a variety of different language features and improvements. They include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c73be7140ebf78f98979e2eca4cd593ef933ad" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 comes with lots of features and improvements in the tooling for multiplatform programming. Some of them just work out of the box on existing projects, and some require additional configuration steps. This guide will help you migrate your multiplatform projects to 1.4.0 and get the benefits of all its new features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e7a073ad0548ea1abeb025f0d02a8940c8b2833" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 does not provide a public API for such extensions yet, but we are working closely with our partners, including &lt;a href=&quot;https://developer.android.com/jetpack/compose&quot;&gt;Jetpack Compose&lt;/a&gt;, who are already building their compiler plugins using our new backend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119bb4e318a0a5c97768f9b15754a1c8be59df76" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 includes a number of JVM-specific improvements, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b88cbfefbff762c9e5fd3f41575d2d7448be9e" translate="yes" xml:space="preserve">
          <source>Kotlin 1.4.0 introduces the Alpha IR compiler for Kotlin/JS. For more detailed information about the Kotlin/JS IR compiler&amp;rsquo;s backend and how to configure it, consult the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;Any&lt;/code&gt; type</target>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;String&lt;/code&gt; type</target>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="translated">Kotlin &lt;code&gt;inline&lt;/code&gt; classes</target>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="translated">Kotlin &lt;code&gt;interface&lt;/code&gt; types</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; 는 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; 로 액세스 할 수 있습니다 . 있다 &lt;code&gt;_instance&lt;/code&gt; 의 개체의 유일한 인스턴스를 얻을 수있는 기능.</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">코 틀린 안드로이드 확장</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">코 틀린 코딩 규약 및 IntelliJ IDEA 포맷터</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">코 틀린 컬렉션 개요</target>
        </trans-unit>
        <trans-unit id="2e918bca9080c65d49a41d94237060bf519ea8e7" translate="yes" xml:space="preserve">
          <source>Kotlin Compiler Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">코 틀린 정의</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">코 틀린 교육용 플러그인</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">코 틀린 진화</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">코 틀린 예제</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradle 플러그인 1.3.41은 Android Gradle 플러그인 3.0 이상에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">코 틀린 JavaScript 개요</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C 페치 API&lt;/a&gt; 용 Kotlin JavaScript 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C 파일 API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt; 용 Kotlin JavaScript 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;웹 알림 API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">DOM API를위한 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">DOM CSS API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">DOM SVG API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">DOM URL API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">DOM 이벤트 API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">DOM 파싱 API를위한 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">WebGL API 용 Kotlin JavaScript 랩퍼.</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">코 틀린 코안</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans는 Kotlin 구문에 익숙해지는 일련의 연습입니다. 각 운동은 실패한 단위 테스트로 작성되며 귀하의 임무는 통과하는 것입니다. Kotlin Koans와 함께 다음 두 가지 방법 중 하나로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="409a3dab696a4f7e601ab24128dac2f50d01d468" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c495a5c1562a573edd3b920fba276a2422fbf84" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Gradle DSL Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="translated">Kotlin Multiplatform Mobile documentation</target>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="translated">Kotlin Multiplatform Mobile samples</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin Multiplatform 프로젝트에는 Gradle 버전 4.7 이상이 필요하며 이전 Gradle 버전은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">코 틀린 멀티 프로젝트는 제공함으로써 안드로이드 플랫폼을 지원하는 &lt;code&gt;android&lt;/code&gt; 프리셋을. Android 대상을 만들려면 &lt;code&gt;com.android.application&lt;/code&gt; 또는 &lt;code&gt;com.android.library&lt;/code&gt; 와 같은 Android Gradle 플러그인 중 하나가 프로젝트에 수동으로 적용되어야합니다. Gradle 하위 프로젝트 당 하나의 Android 대상 만 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">코 틀린 숫자와 NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">코 틀린 프로그래밍 : The Big Nerd Ranch Guide</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">코 틀린 스크립팅 API</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="translated">Kotlin 스크립팅 API 및 커스텀 호스트</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">코 틀린 스크립트 (* .kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">코 틀린 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin을 사용하면 유형에 대해 사전 정의 된 연산자 세트에 대한 구현을 제공 할 수 있습니다. 이 연산자에는 고정 된 기호 표시 ( &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; )와 고정 된 &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;우선 순위가&lt;/a&gt; 있습니다. 연산자를 구현 하기 위해 해당 유형에 대한 고정 이름을 가진 &lt;a href=&quot;functions#member-functions&quot;&gt;멤버 함수&lt;/a&gt; 또는 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 를 제공합니다 ( 예 : 이진 연산의 경우 왼쪽 유형 및 단항 연산의 경우 인수 유형). 연산자를 과부하시키는 기능은 &lt;code&gt;operator&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin을 사용하면 Kotlin 프로젝트를 널리 사용되는 모듈 시스템 용 JavaScript 모듈로 컴파일 할 수 있습니다. 사용 가능한 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin을 사용하면 &lt;em&gt;가시성 수정자를&lt;/em&gt; 통해 기호 가시성 (Python이 밑줄 규칙을 통해서만 수행함)을 적용 할 수 있습니다. 가시성 수정자를 제공하지 않으면 기본 가시성 수준 인 &lt;em&gt;public이 표시&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlin은 또한 &lt;code&gt;ByteArray&lt;/code&gt; , &lt;code&gt;ShortArray&lt;/code&gt; , &lt;code&gt;IntArray&lt;/code&gt; 등의 복싱 오버 헤드없이 기본 유형의 배열을 나타내는 특수화 된 클래스를 가지고 있습니다 . 이 클래스는 &lt;code&gt;Array&lt;/code&gt; 클래스와 상속 관계가 없지만 동일한 메서드 및 속성 집합이 있습니다. 그들 각각은 또한 해당 팩토리 기능을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin은 부동 소수점 숫자에 대한 일반적인 표기법도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin과 TeamCity와의 지속적인 통합</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="translated">Kotlin 및 자바 소스</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">코 틀린과 OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin과 Swift는 모두 형식 지정의 일부로 Null 허용 여부를 정의하고 Objc는 유형의 메서드 및 속성에 Null 허용 여부를 정의합니다. 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin과 Swift는 모두 유형 사양의 일부로 null 허용 여부를 정의하고 Objective-C는 유형의 메서드 및 속성에 대한 null 허용 여부를 정의합니다. 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlin 애플리케이션은 Amazon Web Services, Google Cloud Platform 등 Java 웹 애플리케이션을 지원하는 모든 호스트에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">정적 유형의 프로그래밍 언어 인 Kotlin은 Gradle 빌드 스크립트 작성에 적합합니다. 정적 형식 유추 덕분에 Kotlin 컴파일러는 오류를 미리 감지하고 중요한 컴파일 오류 메시지 및 경고를 표시합니다. IDE와 컴파일러 모두 유형에 대한 정보를 사용하여 주어진 범위에서 사용 가능한 함수와 속성을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="translated">예제 별 Kotlin</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin은 스크립팅 언어로도 사용할 수 있습니다. 스크립트는 최상위 실행 코드가있는 Kotlin 소스 파일 (.kts)입니다.</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="translated">Kotlin은 스크립팅 언어로도 사용할 수 있습니다. 스크립트는 최상위 실행 코드 가있는 Kotlin 소스 파일 ( &lt;em&gt;.kts&lt;/em&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin은 여러 플랫폼에 맞게 컴파일 할 수 있습니다. 이 문서에서는 대상 플랫폼이 Java 가상 머신으로 가정하여 추가 기능을 제공합니다. 특히 코드가 Java 바이트 코드로 컴파일되므로 대규모 Java 라이브러리 에코 시스템과 상호 운용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlin은 서버 측, 클라이언트 측 웹 및 Android 등 모든 종류의 개발에 사용할 수 있습니다. Kotlin / Native가 현재 작업 중이므로 임베디드 시스템, macOS 및 iOS와 같은 다른 플랫폼에 대한 지원이 제공됩니다. 사람들은 Kotlin을 모바일 및 서버 측 애플리케이션, JavaScript 또는 JavaFX를 사용하는 클라이언트 측 및 데이터 과학에 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin은 기존의 타사 라이브러리 및 jQuery 또는 React와 같은 프레임 워크와 함께 사용할 수 있습니다. 강력한 형식의 API로 타사 프레임 워크에 액세스하기 위해 &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; 도구를 사용하여 TypeScript 정의를 &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; 형식 정의 저장소에서 Kotlin으로 변환 할 수 있습니다 . 또는 &lt;a href=&quot;dynamic-type&quot;&gt;동적 유형&lt;/a&gt; 을 사용하여 강력한 타이핑없이 모든 프레임 워크에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ac487e3599218d513d99cbe95341abd1004db54" translate="yes" xml:space="preserve">
          <source>Kotlin can build a &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;source set hierarchy&lt;/a&gt; with the &lt;code&gt;dependsOn&lt;/code&gt; relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">코 틀린은 파이썬의 &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; comprehensions 의 압축에 매우 가깝습니다 . &lt;code&gt;people&lt;/code&gt; 이 &lt;code&gt;name&lt;/code&gt; 속성을 가진 &lt;code&gt;Person&lt;/code&gt; 객체 의 모음 이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1a109a14558842e44146557931b4bc933ed0c8e4" translate="yes" xml:space="preserve">
          <source>Kotlin can now generate type annotations in the JVM bytecode (target version 1.8+), so that they become available in Java reflection at runtime. To emit the type annotation in the bytecode, follow these steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01363668f0c8a96c308b85201388c8e9019873f8" translate="yes" xml:space="preserve">
          <source>Kotlin can use only Swift declarations marked with the &lt;code&gt;@objc&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin은 런타임에 숫자 유형을 구분할 수 없습니다 ( &lt;code&gt;kotlin.Long&lt;/code&gt; 제외 ). 예를 들어 다음 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="translated">Kotlin은 런타임에 숫자 유형을 구분할 수 없으므로 ( &lt;code&gt;kotlin.Long&lt;/code&gt; 제외 ) 다음 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlin은 코드의 안정성과 이전 버전과의 호환성에 대해 많은 관심을 갖고 있습니다. Kotlin 호환성 정책에 따르면 &quot;최신 변경 사항&quot;(예 : 더 이상 컴파일하지 않고 컴파일에 사용 된 코드를 만드는 변경)은 주요 릴리스 (1.2)에서만 도입 될 수 있습니다. , 1.3 등).</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">코 틀린 클래스와 인터페이스는 Swift / Objective-C 클래스와 프로토콜에 의해 서브 클래 싱 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Kotlin 클래스에는 Objective-C에 &lt;code&gt;KotlinBase&lt;/code&gt; 기본 클래스 가 있으며이 클래스는 &lt;code&gt;NSObject&lt;/code&gt; 클래스를 확장합니다 . 컬렉션과 예외에 대한 래퍼도 있습니다. 대부분의 컬렉션 유형은 다른 쪽에서 비슷한 컬렉션 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Kotlin 코드는 Java에서 쉽게 호출 할 수 있습니다. 예를 들어, Kotlin 클래스의 인스턴스는 Java 메소드에서 원활하게 작성하고 운영 할 수 있습니다. 그러나 Kotlin 코드를 Java에 통합 할 때주의를 기울여야하는 Java와 Kotlin의 특정 차이점이 있습니다. 이 페이지에서는 Kotlin 코드와 Java 클라이언트의 상호 운용성을 조정하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="translated">Kotlin 컬렉션 유형 및 하위 유형</target>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin 컬렉션 ( &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 등)은 특정 자바 스크립트 유형에 매핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin 컬렉션 (예 : &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 등)은 특정 JavaScript 유형에 매핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Kotlin 콜렉션은 위 표에 설명 된대로 Swift / Objective-C 콜렉션으로 변환됩니다. Swift / Objective-C 콜렉션은 &lt;code&gt;NSMutableSet&lt;/code&gt; 및 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 를 제외하고 동일한 방식으로 Kotlin에 맵핑됩니다 . &lt;code&gt;NSMutableSet&lt;/code&gt; 은 Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 로 변환되지 않습니다 . 코 틀린에 대한 객체 전달하려면 &lt;code&gt;MutableSet&lt;/code&gt; 을 , 당신은 예와 코 틀린에 그것을 만드는 중 하나에 의해 명시 적으로 코 틀린 수집의이 종류를 만들 수 있습니다 &lt;code&gt;mutableSetOf()&lt;/code&gt; , 또는 사용 &lt;code&gt;KotlinMutableSet&lt;/code&gt; 의 스위프트 (또는에서 클래스를 &lt;code&gt;${prefix}MutableSet&lt;/code&gt; 오브젝티브 C에 &lt;code&gt;prefix&lt;/code&gt; 프레임 워크 이름 접두사입니다). 동일은을 위해 보유하고 &lt;code&gt;MutableMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlin 컬렉션에는 일반적으로 사용되는 &lt;em&gt;집계 작업 (&lt;/em&gt; 컬렉션 내용에 따라 단일 값을 반환하는 작업)을 위한 함수가 포함되어 있습니다. 대부분은 잘 알려져 있으며 다른 언어에서와 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin 모음은 모음에서 단일 요소를 검색하기위한 일련의 기능을 제공합니다. 이 페이지에 설명 된 기능은 목록과 세트 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">코 틀린 커뮤니티는 개방적이고 도움이되고 환영합니다. 주저하지 말고 원하는 플랫폼에 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlin 컴파일러는 JavaScript 코드에서 자유롭게 사용할 수있는 일반 JavaScript 클래스, 함수 및 속성을 생성합니다. 그럼에도 불구하고 기억해야 할 미묘한 것들이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2af437257c982ea32c02d4a42942eceaf188caa" translate="yes" xml:space="preserve">
          <source>Kotlin compiler offers &lt;em&gt;explicit API mode&lt;/em&gt; for library authors. In this mode, the compiler performs additional checks that help make the library&amp;rsquo;s API clearer and more consistent. It adds the following requirements for declarations exposed to the library&amp;rsquo;s public API:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlin 컴파일러는 바이트 코드를 생성하므로 Kotlin 응용 프로그램의 모양과 느낌은 Java로 작성된 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">코 틀린 컴파일러 사양</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin 컴파일러는 다음과 같은 출력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="f142a3debb6f5ab93f8769b5839aca7d9de9a318" translate="yes" xml:space="preserve">
          <source>Kotlin compilers have a number of options for tailoring the compiling process. Compiler options for different targets are listed on this page together with a description of each one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlin 생성자는 초기화 자로 Swift / Objective-C로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin 설명서는 시작하기에 좋은 장소입니다. 발을 젖게하려면 다음 링크를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">Kotlin에는 Python의 &lt;em&gt;리소스 관리자&lt;/em&gt; 또는 Java의 &lt;em&gt;try-with-resources&lt;/em&gt; 가 없지만 확장 기능 덕분에 다음과 같은 &lt;code&gt;use&lt;/code&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">코 틀린은 &lt;a href=&quot;exceptions&quot;&gt;예외를&lt;/a&gt; 확인하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">코 틀린은 예외를 확인하지 않았습니다. 여기에는 여러 가지 이유가 있지만 간단한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Kotlin은 JavaScript에서 최상위 속성의 지연 초기화를 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlin은 컴파일 타임에 &lt;a href=&quot;generics&quot;&gt;제네릭&lt;/a&gt; 과 관련된 작업의 형식 안전성을 보장 하는 반면 런타임에 제네릭 형식의 인스턴스에는 실제 형식 인수에 대한 정보가 없습니다. 예를 들어 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; 는 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 로만 지워집니다 . 일반적으로 인스턴스가 런타임에 특정 유형 인수를 사용하여 일반 유형에 속하는지 여부를 확인할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin은 패키지 구조를 자바 스크립트에 노출하므로 루트 패키지에서 선언을 정의하지 않는 한 자바 스크립트에서 정규화 된 이름을 사용해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin은 패키지 구조를 JavaScript에 공개하므로 루트 패키지에 선언을 정의하지 않으면 JavaScript에서 정규화 된 이름을 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="translated">&quot;일반&quot;Kotlin 클래스에 대한 Kotlin 확장은 Swift 및 Objective-C에 각각 확장 및 카테고리 구성원으로 가져옵니다. 다른 유형에 대한 Kotlin 확장 은 추가 수신자 매개 변수가있는 &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;최상위 선언&lt;/a&gt; 으로 처리됩니다 . 이러한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin은 Java로 인해 발생하는 일련의 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Kotlin은 Java 명명 규칙을 따릅니다. 특히:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Android 사례 연구를위한 Kotlin</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">안드로이드 개발자를위한 코 틀린</target>
        </trans-unit>
        <trans-unit id="697d1de6e7cb2c06571dc421613de269a61dd215" translate="yes" xml:space="preserve">
          <source>Kotlin for Data Science</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Java 개발자를위한 Kotlin</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="translated">Kotlin 함수 유형 및 하위 유형</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin 함수 유형 객체 (예 : 람다)는 Swift 함수 / Objective-C 블록으로 변환됩니다. 그러나 함수와 함수 유형을 변환 할 때 매개 변수 유형과 반환 값이 매핑되는 방식에 차이가 있습니다. 후자의 경우 기본 유형이 상자 표시로 맵핑됩니다. 코 틀린 &lt;code&gt;Unit&lt;/code&gt; 반환 값은 Swift / Objective-C에서 해당 &lt;code&gt;Unit&lt;/code&gt; 싱글 톤 으로 표시됩니다 . 이 싱글 톤의 값은 다른 Kotlin &lt;code&gt;object&lt;/code&gt; 와 동일한 방식으로 검색 할 수 있습니다 (위의 싱글 톤 참조). 정리하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin 함수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;일류&lt;/em&gt;&lt;/a&gt; 이므로 변수 및 데이터 구조에 저장하고 인수로 전달하여 다른 &lt;a href=&quot;#higher-order-functions&quot;&gt;고차 함수&lt;/a&gt; 에서 반환 할 수 있습니다 . 다른 비 기능적 값에 대해 가능한 방식으로 기능으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin은 AMD (Asynchronous Module Definition), CommonJS 및 UMD (Universal Model Definition)와 호환되는 JavaScript 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin은 Java와 비슷한 방식으로 숫자를 처리하지만 정확히 동일하지는 않습니다. 예를 들어, 숫자에 대한 암시 적 확장 변환은 없으며 경우에 따라 리터럴이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlin은 런타임 파일 크기가 다소 작습니다. 라이브러리는 약 964KB입니다 (1.3.41 기준). 이것은 Kotlin이 .apk 파일 크기에 약간만 추가 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin에는 응용 프로그램에서 사용할 수있는 광범위한 표준 라이브러리가 있습니다. pom 파일에서 다음 종속성을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlin은 주요 회사에서 성공적으로 채택되었으며 그 중 일부는 다음과 같은 경험을 공유했습니다.</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin은 객체 지향 및 기능적 구성을 모두 가지고 있습니다. OO 및 FP 스타일 모두에서 사용하거나 두 가지 요소를 혼합하여 사용할 수 있습니다. 고차 함수, 함수 유형 및 람다와 같은 기능을 일류 지원하는 Kotlin은 함수형 프로그래밍을 수행하거나 탐색 할 때 탁월한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin은 기본적으로 클래스와 멤버를 &lt;code&gt;final&lt;/code&gt; 으로 가지고 있으므로 클래스를 &lt;code&gt;open&lt;/code&gt; 하는 Spring AOP와 같은 프레임 워크와 라이브러리를 사용하는 것이 불편합니다 . &lt;em&gt;모든 오픈&lt;/em&gt; 컴파일러 플러그인은 그 프레임 워크의 요구 사항에 코 틀린 적응하고 특정 주석을 주석 수업을하고 자신의 회원은 명시하지 않고 열 &lt;code&gt;open&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 자체 리플렉션 라이브러리를 가지고 있습니다 ( &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 는 빌드에 포함되어야합니다). JVM을 대상으로 할 때 Java 리플렉션 기능을 사용할 수도 있습니다. Kotlin 리플렉션은 아직 완전히 완성되지 않았으므로 특히 &lt;code&gt;String&lt;/code&gt; 과 같은 내장 클래스를 검사하는 데 사용할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">코 틀린은 I / O를 수행하는 Java의 fidgety (그러나 매우 유연한) 방식을 물려 받았지만 몇 가지 간단한 기능을 추가했습니다. 우리는 여기에 모든 것을 넣지 않을 것이므로 우선 초보자를 위해 파일의 모든 줄을 반복하는 방법입니다 ( &lt;code&gt;import java.io.File&lt;/code&gt; 이 필요합니다 ).</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 Java의 fidgety 배열 시스템을 상속 받았으므로 기본 유형에는 자체 배열 유형 및 변환 함수가 있으며 다른 유형은 일반 &lt;code&gt;Array&lt;/code&gt; 유형을 사용하며 &lt;code&gt;.toTypedArray()&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="translated">Kotlin에는 확인 된 예외의 개념이 없으며 모든 Kotlin 예외는 확인되지 않습니다. Swift는 오류 만 확인했습니다. 따라서 Swift 또는 Objective-C 코드가 처리 할 예외를 발생시키는 Kotlin 메서드를 호출하는 경우 Kotlin 메서드는 &quot;예상 된&quot;예외 클래스 목록을 지정하는 &lt;code&gt;@Throws&lt;/code&gt; 주석 으로 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 확인 된 예외 개념이 없으며 모든 Kotlin 예외는 확인되지 않습니다. Swift는 오류를 확인했습니다. 따라서 Swift 또는 Objective-C 코드가 처리 할 예외를 발생시키는 Kotlin 메소드를 호출하면 Kotlin 메소드에 &lt;code&gt;@Throws&lt;/code&gt; 주석 이 표시되어야합니다 . 이 경우 모든 Kotlin 예외 ( &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;RuntimeException&lt;/code&gt; 및 서브 클래스 제외)는 Swift error / &lt;code&gt;NSError&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin은 이제 Java 8 바이트 코드 ( &lt;code&gt;-jvm-target 1.8&lt;/code&gt; 명령 행 옵션 또는 Ant / Maven / Gradle의 해당 옵션)를 생성 할 수 있습니다. 지금은 바이트 코드의 의미를 변경하지 않지만 (특히 인터페이스와 람다의 기본 메소드는 Kotlin 1.0에서와 동일하게 생성됩니다) 나중에이를 더 활용할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">Kotlin은 Java의 SAM 변환과 달리 적절한 &lt;a href=&quot;lambdas#function-types&quot;&gt;함수 유형을&lt;/a&gt; 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bf97cc3e62a44a9f204f95382694f7ebe3c3d2c" translate="yes" xml:space="preserve">
          <source>Kotlin has supported SAM conversions for Java interfaces from the beginning, but there was one case that wasn&amp;rsquo;t supported, which was sometimes annoying when working with existing Java libraries. If you called a Java method that took two SAM interfaces as parameters, both arguments needed to be either lambdas or regular objects. You couldn't pass one argument as a lambda and another as an object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">코 틀린에는 세 가지 구조적 점프 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlin에는 두 가지 유형의 문자열 리터럴이 있습니다. 이스케이프 된 문자가 포함 된 이스케이프 된 문자열과 줄 바꿈 및 임의의 텍스트를 포함 할 수있는 원시 문자열입니다. 이스케이프 된 문자열은 Java 문자열과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="translated">Kotlin에는 두 가지 유형의 문자열 리터럴이 있습니다. 이스케이프 된 문자가있을 수있는 이스케이프 된 문자열과 줄 바꿈 및 임의의 텍스트를 포함 할 수있는 원시 문자열입니다. 다음은 이스케이프 된 문자열의 예입니다.</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">코 틀린의 행동</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlin은 부호없는 정수에 대해 다음 유형을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">코 틀린 (Kotlin)은 정적으로 형식화 된 컴파일 된 언어로, 해석되고 동적으로 형식화 된 파이썬에 익숙한 사람들에게 약간의 초기 장애를 제공 할 수 있습니다. 이 문서는 Kotlin의 구문과 개념 중 상당 부분을 Python의 해당 개념과 비교하는 방식으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Kotlin은 Android 애플리케이션 개발에 매우 ​​적합하며 새로운 제한을 도입하지 않고도 현대 언어의 모든 장점을 Android 플랫폼에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin은 서버 측 응용 프로그램 개발에 적합하여 기존 Java 기반 기술 스택 및 원활한 학습 곡선과의 완벽한 호환성을 유지하면서 간결하고 표현적인 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">코 틀린 (Kotlin)은 실용적이면서도 비언어적 인 언어로, 개발자를 어느쪽으로 든 강요하지 않고 명령형 및 함수형 프로그래밍 스타일을 모두 지원합니다. &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;꼬리 재귀&lt;/a&gt; 와 같은 Kotlin 기능을 사용하여 함수 &lt;code&gt;f&lt;/code&gt; 를 함수 스타일로 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="translated">Kotlin은 정적으로 입력 된 언어이므로 동적으로 입력되는 자바 스크립트와 다릅니다. JavaScript 코드와의 상호 운용을 용이하게하기 위해 Kotlin / JS는 &lt;code&gt;dynamic&lt;/code&gt; 유형을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin은 JVM, Android, JavaScript 및 Native를 대상으로하는 OSS 정적 유형의 프로그래밍 언어입니다. &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains에&lt;/a&gt; 의해 개발되었습니다 . 이 프로젝트는 2010 년에 시작되었으며 초기부터 오픈 소스였습니다. 최초의 공식 1.0 릴리스는 2016 년 2 월입니다.</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin은 JVM, Android, JavaScript 및 Native를 대상으로하는 오픈 소스 정적으로 형식화 된 프로그래밍 언어입니다. &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt; 에서 개발했습니다 . 이 프로젝트는 2010 년에 시작되었으며 초기부터 오픈 소스였습니다. 최초의 공식 1.0 릴리스는 2016 년 2 월이었습니다.</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin은 CommonJS, AMD 및 UMD와 호환되므로 &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;다른&lt;/a&gt; 모듈 시스템 과 쉽게 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bc1c7729db3b60c6d62ba20f7492d0f9556d43" translate="yes" xml:space="preserve">
          <source>Kotlin is concise, readable and easy to learn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin은 프로그래머를위한 실용적인 도구로 설계되었습니다. 언어 진화와 관련하여 실용적인 특성은 다음과 같은 원칙에 의해 포착됩니다.</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 Java를 이미 알고있는 사람들이 쉽게 배울 수 있도록 설계되었습니다. 차이점에 대한 빠른 개요 &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;는 공식 비교 페이지에서 제공&lt;/a&gt; 됩니다. 소프트웨어 개발자를위한 코 틀린의 기본 구문에 대한 짧은 소개가 시작 웹 사이트의 참조 섹션에서 직접 확인할 수 있습니다 &lt;a href=&quot;../reference/basic-syntax&quot;&gt;기본 구문&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Kotlin은 Java 상호 운용성을 염두에두고 설계되었습니다. 기존 Java 코드는 자연스러운 방식으로 Kotlin에서 호출 할 수 있으며 Kotlin 코드는 Java에서도 원활하게 사용할 수 있습니다. 이 섹션에서는 Kotlin에서 Java 코드 호출에 대한 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin은 &lt;code&gt;kotlin.js&lt;/code&gt; 표준 라이브러리와 함께 단일 파일로 배포되며 ,이 파일은 자체적으로 UMD 모듈로 컴파일되므로 위에서 설명한 모든 모듈 시스템과 함께 사용할 수 있습니다. 또한 NPM에서 &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt; 패키지 로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">Kotlin은 Kotlin / JS 표준 라이브러리와 함께 단일 파일로 배포되며, 자체적으로 UMD 모듈로 컴파일되므로 위에서 설명한 모든 모듈 시스템에서 사용할 수 있습니다. 대부분의 Kotlin / JS 사용 사례에서는 &lt;code&gt;kotlin-stdlib-js&lt;/code&gt; 에 Gradle 종속성을 사용하는 것이 좋지만 NPM에서도 &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt; 패키지 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlin은 Java, C #, JavaScript, Scala 및 Groovy와 같은 기존 언어에서 영감을 얻었습니다. 우리는 Kotlin이 배우기 쉽도록 노력하여 사람들이 며칠 만에 Kotlin을 쉽게 읽고 쓸 수 있도록했습니다. 관용적 코 틀린을 배우고 더 많은 고급 기능을 사용하는 데 시간이 조금 더 걸릴 수 있지만 전반적으로 복잡한 언어는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">코 틀린이 더 간결합니다. 대략적인 추정치에 따르면 코드 줄 수가 약 40 % 줄었습니다. 또한 형식이 더 안전합니다. 예를 들어 널 입력 불가능 유형을 지원하면 응용 프로그램이 NPE에 덜 취약합니다. 스마트 캐스팅, 고차 함수, 확장 기능 및 수신기가있는 람다를 포함한 다른 기능은 표현 코드를 작성하는 기능을 제공 할뿐만 아니라 DSL 작성을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin은 주로 JetBrains의 엔지니어 팀이 개발합니다 (현재 팀 규모는 100 명 이상). 수석 언어 디자이너는 &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt; 입니다. 핵심 팀 외에도 GitHub에는 250 명 이상의 외부 기여자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin은 주로 JetBrains의 엔지니어 팀 (현재 팀 규모는 50+ 이상)에 의해 개발되었습니다. 주요 언어 디자이너는 &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt; 입니다. 핵심 팀 외에도 GitHub에는 250 명 이상의 외부 기고자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt; , &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; 및 &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans를&lt;/a&gt; 포함한 모든 주요 Java IDE에서 지원됩니다 . 또한 &lt;a href=&quot;../tutorials/command-line&quot;&gt;명령 줄 컴파일러&lt;/a&gt; 를 사용할 수 있으며 응용 프로그램을 컴파일하고 실행하기위한 간단한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt; , &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; 및 &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans를&lt;/a&gt; 포함한 모든 주요 Java IDE에서 지원됩니다 . 또한 &lt;a href=&quot;../tutorials/command-line&quot;&gt;명령 줄 컴파일러&lt;/a&gt; 를 사용할 수 있으며 응용 프로그램 컴파일 및 실행에 대한 직접적인 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlin은 온라인 과정을 잘 다루고 있습니다. 여기에서 권장 과정을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="translated">Kotlin을 사용하면 실행할 JVM 버전을 선택할 수 있습니다. 기본적으로 Kotlin / JVM 컴파일러는 자바 6 호환 바이트 코드를 생성합니다. 최신 버전의 Java에서 사용 가능한 최적화를 사용하려면 8에서 13까지의 대상 Java 버전을 명시 적으로 지정할 수 있습니다.이 경우 결과 바이트 코드가 하위 버전에서 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">코 틀린은 쉽게 사용 값 범위 만들 수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt; 로부터 기능 &lt;code&gt;kotlin.ranges&lt;/code&gt; 의 패키지와 연산자 형태 &lt;code&gt;..&lt;/code&gt; . 일반적으로 &lt;code&gt;rangeTo()&lt;/code&gt; 는 &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;!in&lt;/code&gt; 함수로 보완됩니다 .</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin을 사용하면 컬렉션에 저장된 정확한 유형의 개체와 독립적으로 컬렉션을 조작 할 수 있습니다. 즉, 당신은 추가 &lt;code&gt;String&lt;/code&gt; 의 목록에 &lt;code&gt;String&lt;/code&gt; 당신이 할 것 같은의 같은 방식으로 &lt;code&gt;Int&lt;/code&gt; 의 또는 사용자 정의 클래스입니다. 따라서 Kotlin 표준 라이브러리는 모든 유형의 콜렉션을 작성, 채우기 및 관리하기위한 일반 인터페이스, 클래스 및 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a804893fba1e9dc304662ad5aa9e7244e8ba7e41" translate="yes" xml:space="preserve">
          <source>Kotlin libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">코 틀린 메타 데이터</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Kotlin 모듈은 프레임 워크로 컴파일 된 경우 Swift / Objective-C 코드에서 사용될 수 있습니다 ( &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle 플러그인 설명서의&lt;/a&gt; &quot;대상 및 출력 종류&quot;섹션 참조 ). &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;예제&lt;/a&gt; 는 계산기 샘플 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f16158d7bd59887136035c889e332065c93a9e3" translate="yes" xml:space="preserve">
          <source>Kotlin multiplatform projects use compilations for producing artifacts. Each target can have one or more compilations, for example, for production and test purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin은 이제 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223) 와 통합됩니다 . API를 사용하면 런타임시 코드 스 니펫을 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin은 이제 바이트 코드에 매개 변수 이름 저장을 지원합니다. &lt;code&gt;-java-parameters&lt;/code&gt; 명령 행 옵션을 사용하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; 을 제외한 Kotlin 숫자 유형 은 JavaScript Number에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin 객체는 고정 될 수 있습니다. 즉 메모리에서 해당 위치는 고정 해제 될 때까지 안정적으로 유지되며 이러한 객체 내부 데이터에 대한 포인터는 C 함수로 전달 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">Kotlin 플러그인 1.3.21 이상이 IDE에 설치되어 있어야합니다. &lt;em&gt;언어 및 프레임 워크&lt;/em&gt; 를 통해 확인할 수 있습니다. &lt;em&gt;| &lt;/em&gt;IDE 의 &lt;em&gt;설정&lt;/em&gt; (또는 &lt;em&gt;환경 설정&lt;/em&gt; )의 &lt;em&gt;Kotlin 업데이트&lt;/em&gt; 섹션</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEA 용 Kotlin 플러그인은 &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;스크래치를&lt;/a&gt; 지원합니다 . 스크래치를 사용하면 프로젝트와 동일한 IDE 창에서 코드 드래프트를 작성하여 즉시 실행할 수 있습니다. 흠집은 프로젝트와 관련이 없습니다. OS의 IntelliJ IDEA 창에서 모든 스크래치에 액세스하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin은 JavaScript에서 게으른 객체 초기화를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 &lt;code&gt;kotlin.Int&lt;/code&gt; , &lt;code&gt;kotlin.Byte&lt;/code&gt; , &lt;code&gt;kotlin.Short&lt;/code&gt; , &lt;code&gt;kotlin.Char&lt;/code&gt; 및 &lt;code&gt;kotlin.Long&lt;/code&gt; 에 대한 오버 플로우 의미를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlin 기본 유형 상자는 특수 Swift / Objective-C 클래스에 매핑됩니다. 예를 들어, &lt;code&gt;kotlin.Int&lt;/code&gt; 상자는 Swift에서 &lt;code&gt;KotlinInt&lt;/code&gt; 클래스 인스턴스 (또는 Objective-C의 &lt;code&gt;${prefix}Int&lt;/code&gt; 인스턴스 (여기서 &lt;code&gt;prefix&lt;/code&gt; 는 프레임 워크 이름 접두어 임))로 표시됩니다. 이러한 클래스는 &lt;code&gt;NSNumber&lt;/code&gt; 에서 파생 되므로 인스턴스는 모든 해당 작업을 지원하는 적절한 &lt;code&gt;NSNumber&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="translated">Kotlin 기본 유형</target>
        </trans-unit>
        <trans-unit id="231e51698e1b22447348936da3858b45208fbb94" translate="yes" xml:space="preserve">
          <source>Kotlin projects require a recent version of Gradle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">명명 된 객체 또는 컴패니언 객체에 선언 된 Kotlin 속성에는 해당 명명 된 객체 또는 컴패니언 객체를 포함하는 클래스에 정적 백업 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f8122e9d8ea69357864a2385801f06d58ec608" translate="yes" xml:space="preserve">
          <source>Kotlin provides &lt;a href=&quot;native/c_interop&quot;&gt;interoperability with native languages&lt;/a&gt; and DSL to configure this for a specific compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin은 IntelliJ IDEA에서도 액세스 할 수있는 일련의 컴파일러 옵션을 제공합니다. 방금 소스 맵을 생성하기 위해 본 것 외에도 설정할 수있는 기능이 있습니다</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="translated">Kotlin은 숫자를 나타내는 기본 제공 유형 집합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">: 코 틀린는 주어진 객체의 컨텍스트에서 코드 블록을 실행하는 다양한 기능을 제공 &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , 및 &lt;code&gt;also&lt;/code&gt; . 귀하의 경우에 적합한 범위의 기능을 선택에 대한 지침을 참조 &lt;a href=&quot;scope-functions&quot;&gt;스코프 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlin 은이를 위해 소위 &lt;strong&gt;스타-투영&lt;/strong&gt; 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="translated">Kotlin은 클래스에서 상속하거나 Decorator와 같은 디자인 패턴을 사용하지 않고도 새로운 기능으로 클래스를 확장 할 수있는 기능을 제공합니다. 이것은 &lt;em&gt;extensions&lt;/em&gt; 라는 특별한 선언을 통해 이루어집니다 . 예를 들어 수정할 수없는 타사 라이브러리의 클래스에 대한 새 함수를 작성할 수 있습니다. 이러한 함수는 원래 클래스의 메서드 인 것처럼 일반적인 방식으로 호출 할 수 있습니다. 이 메커니즘을 &lt;em&gt;확장 함수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 기존 클래스에 대한 새 속성을 정의 할 수있는 &lt;em&gt;확장 속성&lt;/em&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin은 JavaScript를 대상으로하는 기능을 제공합니다. Kotlin을 JavaScript로 변환하여 그렇게합니다. 현재 구현은 ECMAScript 5.1을 대상으로하지만 결국 ECMAScript 2015를 대상으로 할 계획도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin은 숫자를 나타내는 다음과 같은 내장 유형을 제공합니다 (이것은 Java에 가깝습니다).</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Kotlin은 Ant에 대한 세 가지 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin은 인스턴스 생성 중에 모든 멤버 속성을 초기화해야합니다. 때로는 클래스가 생성자에 모든 속성을 초기화하기위한 정보가 충분하지 않은 방식으로 사용되기도합니다 (빌더 클래스를 만들 때 또는 속성 기반 종속성 주입을 사용할 때). 이러한 속성을 nullable로 만들지 않으려면 &lt;em&gt;초기화&lt;/em&gt; 가 &lt;em&gt;늦은 속성을&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; 파일의 Kotlin 스크립트</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">(AN로 만든 코 틀린 싱글 &lt;code&gt;object&lt;/code&gt; 를 포함 선언, &lt;code&gt;companion object&lt;/code&gt; ) 단일 인스턴스와 클래스로 스위프트 / 오브젝티브 C로 가져옵니다. 인스턴스는 팩토리 메소드를 통해 사용할 수 있습니다 (예 : Objective-C의 &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; 및 Swift의 &lt;code&gt;MySingleton()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">코 틀린 싱글 톤</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">Kotlin 소스 파일 또는 컴파일 할 디렉토리</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlin 소스 세트는 &lt;em&gt;'depends on'&lt;/em&gt; 관계 와 연결될 수 있으므로 소스 세트 &lt;code&gt;foo&lt;/code&gt; 가 소스 세트 &lt;code&gt;bar&lt;/code&gt; 에 의존 하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin 소스는 동일한 폴더 또는 다른 폴더에서 Java 소스와 혼합 될 수 있습니다. 기본 규칙은 다른 폴더를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin 소스는 자바 소스와 함께 동일한 폴더에 저장되거나 다른 폴더에 배치 될 수 있습니다. 기본 규칙은 다른 폴더를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="448431d8ccbcd8c407715ad54cff923c4f538ad6" translate="yes" xml:space="preserve">
          <source>Kotlin standard libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin 표준 라이브러리 아티팩트 및 분할 패키지</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="translated">Objective-C 클래스의 Kotlin 하위 클래스</target>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Kotlin은 자바 및 &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin 인터페이스&lt;/a&gt; 모두에 대해 SAM 변환을 지원합니다 . 이 자바 지원은 인터페이스 메소드의 매개 변수 유형이 Kotlin 함수의 매개 변수 유형과 일치하는 한 Kotlin 함수 리터럴을 기본이 아닌 단일 메소드를 사용하여 Java 인터페이스 구현으로 자동 변환 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;테일 재귀&lt;/a&gt; 라고하는 기능 프로그래밍 스타일을 지원합니다 . 이것은 일반적으로 루프를 사용하여 작성되는 일부 알고리즘은 재귀 함수를 사용하여 작성되지만 스택 오버플로의 위험이 없습니다. 함수가 &lt;code&gt;tailrec&lt;/code&gt; 수정 자로 표시되고 필요한 양식을 충족하면 컴파일러는 재귀를 최적화하여 대신 빠르고 효율적인 루프 기반 버전을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;꼬리 재귀&lt;/a&gt; 로 알려진 함수형 프로그래밍 스타일을 지원합니다 . 이렇게하면 일반적으로 루프를 사용하여 작성되는 일부 알고리즘이 대신 재귀 함수를 사용하여 작성되지만 스택 오버플로 위험이 없습니다. 함수가 &lt;code&gt;tailrec&lt;/code&gt; 수정 자로 표시되고 필요한 형식을 충족하면 컴파일러가 재귀를 최적화하여 대신 빠르고 효율적인 루프 기반 버전을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 &lt;em&gt;Kotlin 주석 처리 도구&lt;/em&gt; ( &lt;code&gt;kapt&lt;/code&gt; ) 를 통한 음음 처리를 지원합니다 . Gradle과의 kapt 사용법은 kapt &lt;a href=&quot;kapt&quot;&gt;페이지&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 Kotlin 주석 처리 도구 &lt;a href=&quot;kapt&quot;&gt; &lt;code&gt;kapt&lt;/code&gt; &lt;/a&gt; 를 통한 주석 처리를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin은 로컬 함수, 즉 다른 함수 내부의 함수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin은 단일 부모 클래스 상속을 지원하므로 각 클래스 (루트 클래스 &lt;code&gt;Any&lt;/code&gt; 제외 )에는 &lt;em&gt;수퍼 클래스&lt;/em&gt; 라고하는 하나의 부모 클래스가 있습니다. Kotlin은 클래스 디자인을 통해 실제로 &lt;em&gt;서브 클래 싱&lt;/em&gt; 하는 것이 안전한지 확인 하기를 원하므로 클래스가 기본적으로 &lt;em&gt;닫히고&lt;/em&gt; 클래스를 &lt;em&gt;open&lt;/em&gt; 또는 &lt;em&gt;abstract&lt;/em&gt; 라고 명시 적으로 선언하지 않는 한 클래스를 상속받을 수 없습니다 . 그런 다음 콜론 뒤에 부모 클래스를 언급하는 새 클래스를 선언하여 해당 클래스에서 서브 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin은 다음 연산자와 특수 기호를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a681ed989bc5949117e886914d64403b1862e6f9" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following platforms and provides target presets for each platform. See how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;use a target preset&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 적절한 클래스의 멤버로 선언 된 숫자 ( &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; )에 대한 표준 산술 연산 집합을 지원합니다 (하지만 컴파일러는 해당 명령어에 따라 호출을 최적화합니다). &lt;a href=&quot;operator-overloading&quot;&gt;연산자 오버로딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 적절한 클래스의 멤버로 선언 된 숫자에 대한 표준 산술 연산 세트를 지원합니다 (하지만 컴파일러는 해당 명령어에 대한 호출을 최적화합니다). &lt;a href=&quot;operator-overloading&quot;&gt;연산자 과부하를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">코 틀린은 기존의 지원 &lt;em&gt;중단을&lt;/em&gt; 하고 &lt;em&gt;계속&lt;/em&gt; 루프 연산자를. &lt;a href=&quot;returns&quot;&gt;리턴 및 점프를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="translated">Kotlin은 다음과 같은 경우 후행 쉼표를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin은 인터페이스의 기본 메소드가 허용되지 않는 Java 6 및 Java 7을 포함한 광범위한 Java 버전을 대상으로합니다. 편의상 Kotlin 컴파일러는 이러한 제한을 해결하지만이 해결 방법은 Java 8에 도입 된 &lt;code&gt;default&lt;/code&gt; 방법 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">코 틀린에서 JavaScript로</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin은 일부 Java 유형을 특별히 처리합니다. 이러한 유형은 Java에서 &quot;있는 그대로&quot;로드되지 않지만 해당 Kotlin 유형에 &lt;em&gt;매핑&lt;/em&gt; 됩니다. 매핑은 컴파일 타임에만 중요하며 런타임 표현은 변경되지 않습니다. Java의 기본 유형은 해당 Kotlin 유형에 매핑됩니다 ( &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;플랫폼 유형&lt;/a&gt; 을 염두에 두십시오).</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin은 함수 포인터 리턴 유형을 널 입력 가능 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 오브젝트로 변환합니다. &lt;code&gt;null&lt;/code&gt; 을 명시 적으로 먼저 확인해야합니다 . 우리는이를 위해 &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis 연산자&lt;/a&gt; 를 사용합니다. &lt;code&gt;cinterop&lt;/code&gt; 의 도구는 우리가 코 틀린에 개체를 호출하기 쉬운로 C 함수 포인터를 설정하는 데 도움이됩니다. 이것이 우리가 마지막 줄에서 한 일입니다.</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">코 틀린 같은 기능 유형의 가족 사용 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; 선언에 대한 그 기능 거래 : &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin은 작성된 &lt;code&gt;libnative_api.h&lt;/code&gt; 파일 의 모든 선언에 &lt;code&gt;libnative_&lt;/code&gt; 접두사를 사용 합니다. 보다 읽기 쉬운 방식으로 타입의 매핑을 제시해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin은 Java 플랫폼과 쉽게 상호 운용되도록 설계되었습니다. Java 클래스는 Kotlin 클래스로, Java는 Kotlin 클래스를 Java 클래스로 간주합니다. 그러나 JavaScript는 동적 형식 언어이므로 컴파일 타임에 형식을 확인하지 않습니다. &lt;a href=&quot;dynamic-type&quot;&gt;동적&lt;/a&gt; 유형을 통해 Kotlin에서 JavaScript와 자유롭게 대화 할 수 있지만 Kotlin 유형 시스템의 모든 기능을 원한다면 JavaScript 라이브러리 용 Kotlin 헤더를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="translated">Kotlin은 Java 플랫폼과의 쉬운 상호 운용을 위해 처음 설계되었습니다. Java 클래스는 Kotlin 클래스로, Java는 Kotlin 클래스를 Java 클래스로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin은이 속성을 초기화하지 않고 선언 할 수 있으며 생성 후 어느 시점에서 (직접 또는 함수를 통해) 속성 값을 설정할 수 있습니다. 클래스 자체와 속성을 설정하기 전에 속성을 읽지 않도록주의하는 것은 클래스 자체의 책임이며 Kotlin에서는 &lt;code&gt;name&lt;/code&gt; 을 일반 null이 아닌 속성처럼 읽는 코드를 작성할 수 있습니다 . 그러나 컴파일러에서 올바른 사용법을 적용 할 수 없으므로 속성을 설정하기 전에 읽은 경우 런타임에 &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin은 Spring Boot와 매우 원활하게 작동 하며 RESTful 서비스를 만들기위한 &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; 에있는 많은 단계 를 Kotlin에 대해 그대로 사용할 수 있습니다. 그러나 Gradle 구성과 프로젝트 레이아웃 구조 및 초기화 코드를 정의 할 때 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin은 다른 &lt;a href=&quot;build-tools&quot;&gt;빌드 도구&lt;/a&gt; 와 함께 작동 하므로 Ant, Maven 또는 Gradle과 같은 표준 도구를 사용하는 경우 Kotlin 프로젝트를 설정하는 프로세스는 이러한 도구와 통합되는 다른 언어 나 라이브러리와 다르지 않습니다. 사소한 요구 사항과 차이점이있는 경우 JBS (IntelliJ IDEA에서 사용하는 내부 빌드 시스템)를 사용할 때 TeamCity에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlin의 비동기 코드 작업 방식은 코 루틴을 사용하는 것으로, 이는 일시 중단 가능한 계산, 즉 함수가 특정 시점에서 실행을 일시 중단하고 나중에 다시 시작할 수 있다는 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlin의 문서 생성 도구를 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt; 라고 합니다. 사용법에 대해서는 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlin의 문서 구문을 &lt;em&gt;KDoc&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . KDoc 블록은 설명하는 구문 위에 위치하며 &lt;code&gt;/**&lt;/code&gt; 로 시작하고 &lt;code&gt;*/&lt;/code&gt; 로 끝납니다 (한 줄에있을 수 있습니다. 그렇지 않은 경우 각 중간 줄은 정렬 된 별표로 시작해야합니다). 첫 번째 텍스트 블록은 요약입니다. 그런 다음 &lt;em&gt;블록 태그&lt;/em&gt; 를 사용 하여 구성의 특정 부분에 대한 정보를 제공 할 수 있습니다 . 일부 블록 태그는 함수 매개 변수 및 일반 형식 매개 변수의 경우 &lt;code&gt;@param&lt;/code&gt; 이고 &lt;code&gt;@return&lt;/code&gt; 경우 @return 입니다. 괄호 안의 식별자에 연결할 수 있습니다. 링크 및 블록 태그 이름 외부의 모든 텍스트는 마크 다운 형식입니다.</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlin의 제네릭은 Java와 약간 다릅니다 ( &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt; 참조 ). Java 유형을 Kotlin으로 가져올 때 몇 가지 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Kotlin의 루프는 Python과 유사합니다. &lt;code&gt;for&lt;/code&gt; 무엇이든을 반복하다 &lt;em&gt;반복자&lt;/em&gt; (AN이 아무것도 &lt;code&gt;iterator()&lt;/code&gt; 제공 기능 &lt;code&gt;Iterator&lt;/code&gt; 자체의 반복자, 또는 어떤 개체) :</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">코 틀린의 객체 모델은 파이썬과 실질적으로 다릅니다. 가장 중요한 점 은 런타임에 클래스를 동적으로 수정할 수 &lt;em&gt;없다는 것입니다&lt;/em&gt; ! (이이 일부 제한 예외,하지만 당신은 일반적으로 그것을하지 말아야하지만,. &lt;em&gt;입니다&lt;/em&gt; 동적으로 할 수 &lt;em&gt;검사&lt;/em&gt; 클래스와 기능이라고하여 런타임에 객체 &lt;em&gt;반사&lt;/em&gt; -.이 유용 할 수 있지만 신중하게 사용되어야한다) 모든 클래스에서 필요할 수있는 속성 (속성) 및 함수는 클래스 본문에서 직접 또는 &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;확장 함수&lt;/em&gt;&lt;/a&gt; 로 선언해야 하므로 클래스 디자인을 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="translated">Kotlin의 표준 라이브러리에는 항상 &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생 시키는 &lt;code&gt;TODO()&lt;/code&gt; 함수가 있습니다. 반환 유형은 &lt;code&gt;Nothing&lt;/code&gt; 이므로 예상 유형에 관계없이 사용할 수 있습니다. 이유 매개 변수를 허용하는 과부하도 있습니다.</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 형식 시스템은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 라고도하는 코드에서 null 참조의 위험을 제거하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 유형 시스템은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 로 알려진 코드에서 null 참조의 위험을 제거하는 데 목적 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlin의 형식 시스템은 코드에서 &lt;code&gt;NullPointerException&lt;/code&gt; 을 제거하는 것을 목표로 합니다. NPE의 유일한 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin은 언어로서 표준 라이브러리에서 최소한의 저수준 API 만 제공하여 다양한 다른 라이브러리가 코 루틴을 활용할 수 있도록합니다. 비슷한 기능을 가진 다른 많은 언어와 달리 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 는 Kotlin의 키워드가 아니며 표준 라이브러리의 일부도 아닙니다. 또한 Kotlin의 &lt;em&gt;일시 중단 기능&lt;/em&gt; 개념은 미래와 약속보다 비동기 작업에 대해 안전하고 오류가 발생하기 쉬운 추상화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">C # 및 Gosu와 유사한 Kotlin은 클래스에서 상속하거나 Decorator와 같은 모든 유형의 디자인 패턴을 사용하지 않고도 새로운 기능으로 클래스를 확장 할 수 있습니다. 이는 &lt;em&gt;extensions&lt;/em&gt; 라는 특수 선언을 통해 수행됩니다 . Kotlin은 &lt;em&gt;확장 기능&lt;/em&gt; 및 &lt;em&gt;확장 속성을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="translated">Kotlin / JS (기본 백엔드)</target>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="translated">Kotlin / JS (IR 기반)</target>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="translated">Kotlin / JS 개요</target>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="translated">Kotlin / JS를 사용하면 유형이 안전한 방식으로 &lt;strong&gt;강력한 브라우저 및 웹 API&lt;/strong&gt; 를 &lt;strong&gt;활용할&lt;/strong&gt; 수 있습니다 . DOM (문서 개체 모델)의 요소를 생성, 수정 및 상호 작용하고 Kotlin 코드를 사용하여 &lt;code&gt;canvas&lt;/code&gt; 또는 WebGL 구성 요소 의 렌더링을 제어하고 최신 브라우저에서 지원되는 더 많은 기능에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c551ceb4f789ea0a28725793cbf50b7fde3239c9" translate="yes" xml:space="preserve">
          <source>Kotlin/JS compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc555107bc3ab29b699e3ac57e1fb75bce2155ce" translate="yes" xml:space="preserve">
          <source>Kotlin/JS is also compatible with the most common module systems: UMD, CommonJS, and AMD. Being able to &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;produce and consume modules&lt;/a&gt; means that you can interact with the JavaScript ecosystem in a structured manner.</source>
          <target state="translated">Kotlin / JS는 가장 일반적인 모듈 시스템 인 UMD, CommonJS 및 AMD 와도 호환됩니다. &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;모듈&lt;/a&gt; 을 생성하고 사용할 수 있다는 것은 구조화 된 방식으로 JavaScript 생태계와 상호 작용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6c71e5ac2d4139fc0df7bb50e9a0d7dcc0b261db" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects can target two different execution environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd41eae9565ad317afb86080bea814ec06af110" translate="yes" xml:space="preserve">
          <source>Kotlin/JS projects use Gradle as a build system. To let developers easily manage their Kotlin/JS projects, we offer the &lt;code&gt;kotlin.js&lt;/code&gt; Gradle plugin that provides project configuration tools together with helper tasks for automating routines typical for JavaScript development. For example, the plugin downloads the &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; package manager for managing &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; dependencies in background and can build a JavaScript bundle from a Kotlin project using &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;. Dependency management and configuration adjustments can be done to a large part directly from the Gradle build file, with the option to override automatically generated configurations for full control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e221948b2977f48bf5440d552a61a97802b3f2" translate="yes" xml:space="preserve">
          <source>Kotlin/JS provides the ability to transpile your Kotlin code, the Kotlin standard library, and any compatible dependencies to JavaScript. The current implementation of Kotlin/JS targets &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5&lt;/a&gt;.</source>
          <target state="translated">Kotlin / JS는 Kotlin 코드, Kotlin 표준 라이브러리, 호환되는 모든 종속성을 자바 스크립트로 트랜스 파일하는 기능을 제공합니다. Kotlin / JS의 현재 구현은 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/5.1/&quot;&gt;ES5를&lt;/a&gt; 대상으로 합니다.</target>
        </trans-unit>
        <trans-unit id="e161bf22c4b5c5951be23fef6f0ff257426ebe17" translate="yes" xml:space="preserve">
          <source>Kotlin/JS, Today and Tomorrow</source>
          <target state="translated">Kotlin / JS, 오늘과 내일</target>
        </trans-unit>
        <trans-unit id="44cbff389316ebfe00ceb67daf169189d44ae420" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM</source>
          <target state="translated">Kotlin/JVM</target>
        </trans-unit>
        <trans-unit id="629649c3a6fde50e4105c70afe705d63afa55224" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM (IR-based)</source>
          <target state="translated">Kotlin / JVM (IR 기반)</target>
        </trans-unit>
        <trans-unit id="101afe89559b0f2b0c4257af7917cfec768ae3d7" translate="yes" xml:space="preserve">
          <source>Kotlin/JVM compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ce5e2461e87e30bf83a0eb1faafe214139a6af" translate="yes" xml:space="preserve">
          <source>Kotlin/Native</source>
          <target state="translated">Kotlin/Native</target>
        </trans-unit>
        <trans-unit id="ba24fc19201f933494d7dd5a5c0dfc8e159aaf9b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native &lt;a href=&quot;native/platform_libs&quot;&gt;libraries&lt;/a&gt; help to share Kotlin code between projects. POSIX, gzip, OpenGL, Metal, Foundation, and many other popular libraries and Apple frameworks are pre-imported and included as Kotlin/Native libraries into the compiler package.</source>
          <target state="translated">Kotlin / 네이티브 &lt;a href=&quot;native/platform_libs&quot;&gt;라이브러리&lt;/a&gt; 는 프로젝트간에 Kotlin 코드를 공유하는 데 도움이됩니다. POSIX, gzip, OpenGL, Metal, Foundation 및 기타 많은 인기있는 라이브러리 및 Apple 프레임 워크가 사전 가져 오기되어 Kotlin / Native 라이브러리로 컴파일러 패키지에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="87f61b22867c181628a95e8886f5b445415a504e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Gradle plugin</source>
          <target state="translated">Kotlin / Native Gradle 플러그인</target>
        </trans-unit>
        <trans-unit id="c83dbff85c7c1cfb09790c18b941a770c8cb6d04" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime</source>
          <target state="translated">Kotlin / 네이티브 런타임</target>
        </trans-unit>
        <trans-unit id="df149e18227e20b3ab9482b52698611b0a6fc13c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native Runtime Declarations</source>
          <target state="translated">코 틀린 / 네이티브 런타임 선언</target>
        </trans-unit>
        <trans-unit id="491c504edd0672427d971480838eef4206234894" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Apple technologies. The &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial explains how to compile Kotlin code into a framework for Swift and Objective-C.</source>
          <target state="translated">Kotlin / Native는 Apple 기술과 긴밀하게 통합되어 있습니다. &lt;a href=&quot;apple-framework&quot;&gt;애플 프레임 워크로 코 틀린 / 기본&lt;/a&gt; 튜토리얼은 스위프트와 목표 - C를위한 프레임 워크로 코 틀린 코드를 컴파일하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1d512deb7d342683898c6350ed1a11736984886b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native also has tight integration with Objective-C and Swift. It is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 Objective-C 및 Swift와 긴밀하게 통합되어 있습니다. &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native에서 Apple Framework&lt;/a&gt; 튜토리얼 로 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="08982dde24268c672ff4e00ffc1e0aa78c3c7edf" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as a Dynamic Library</source>
          <target state="translated">다이나믹 라이브러리로서의 Kotlin / Native</target>
        </trans-unit>
        <trans-unit id="9337f3778507f31504f20c46b400d4ffe737a776" translate="yes" xml:space="preserve">
          <source>Kotlin/Native as an Apple Framework</source>
          <target state="translated">애플 프레임 워크로서 Kotlin / Native</target>
        </trans-unit>
        <trans-unit id="5920643ed2bd803efde8c74d41d4425c7caa2ab6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native can be used for many &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;targets&lt;/a&gt; and applications, including, but not limited to macOS, Windows, Linux, and &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native는 macOS, Windows, Linux 및 &lt;a href=&quot;mpp-ios-android&quot;&gt;iOS를&lt;/a&gt; 포함하되 이에 국한되지 않는 많은 &lt;a href=&quot;basic-kotlin-native-app&quot;&gt;대상&lt;/a&gt; 및 응용 프로그램에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a86ebad61bd5c0feb7bd99b7af759453735031a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool, the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details are discussed in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공 되며이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c8a9d6995d5deeb05943192825e878fac0954ca5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial.</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공됩니다 . 이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 이에 대한 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f608852356bc7f03f212743cacdba0d3e22a135a" translate="yes" xml:space="preserve">
          <source>Kotlin/Native comes with the &lt;code&gt;cinterop&lt;/code&gt; tool; the tool generates bindings between the C language and Kotlin. It uses a &lt;code&gt;.def&lt;/code&gt; file to specify a C library to import. More details on this are in the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; tutorial. The quickest way to try out C API mapping is to have all C declarations in the &lt;code&gt;interop.def&lt;/code&gt; file, without creating any &lt;code&gt;.h&lt;/code&gt; of &lt;code&gt;.c&lt;/code&gt; files at all. Then place the C declarations in a &lt;code&gt;interop.def&lt;/code&gt; file after the special &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">Kotlin / Native는 &lt;code&gt;cinterop&lt;/code&gt; 도구 와 함께 제공됩니다 . 이 도구는 C 언어와 Kotlin 간의 바인딩을 생성합니다. 그것은 사용 &lt;code&gt;.def&lt;/code&gt; 수입에 C 라이브러리를 지정하는 파일을. 이에 대한 자세한 내용은 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;Interop with C Libraries&lt;/a&gt; 자습서에 있습니다. C의 API 매핑을 시도하는 가장 빠른 방법은 모든 C 선언하는 것입니다 &lt;code&gt;interop.def&lt;/code&gt; 의 어떤 생성하지 않고, 파일을 &lt;code&gt;.h&lt;/code&gt; 의 &lt;code&gt;.c&lt;/code&gt; 인 모든에서 파일을. 그런 다음 특수 &lt;code&gt;---&lt;/code&gt; 구분 기호 행 다음에 &lt;code&gt;interop.def&lt;/code&gt; 파일 에 C 선언을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="02527cf62d35559073254c9faa21884b055d8fe5" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a dynamic library out of the Kotlin code we have. A dynamic library often comes with a header file, a &lt;code&gt;.h&lt;/code&gt; file, which we will use to call compiled code from C.</source>
          <target state="translated">Kotlin / Native 컴파일러는 우리가 보유한 Kotlin 코드에서 동적 라이브러리를 생성 할 수 있습니다. 동적 라이브러리는 헤더 파일 인 &lt;code&gt;.h&lt;/code&gt; 파일 과 함께 제공 되며 C에서 컴파일 된 코드를 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4881e31bc09168e1508d74717ea87e97808663" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler can produce a framework for macOS and iOS out of the Kotlin code. The created framework contains all declarations and binaries needed to use it with Objective-C and Swift. The best way to understand the techniques is to try it for ourselves. Let's create a tiny Kotlin library first and use it from an Objective-C program.</source>
          <target state="translated">Kotlin / Native 컴파일러는 Kotlin 코드에서 macOS 및 iOS 용 프레임 워크를 생성 할 수 있습니다. 작성된 프레임 워크에는 Objective-C 및 Swift와 함께 사용하는 데 필요한 모든 선언 및 이진이 포함되어 있습니다. 기술을 이해하는 가장 좋은 방법은 직접 시도해 보는 것입니다. 작은 Kotlin 라이브러리를 먼저 만들어 Objective-C 프로그램에서 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b715f52434e20442ebb46ac504b8f84bf0548313" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler compiles Kotlin source files into native binaries for the &lt;a href=&quot;native-overview#target-platforms&quot;&gt;supported platforms&lt;/a&gt;. The command-line tool for Kotlin/Native compilation is &lt;code&gt;kotlinc-native&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72370bde43174b087fc25e3ae6d822902a3834d6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native compiler options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c8b720dae4415d29464c12eeee3db3497f57a4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native doesn't support Maven and IntelliJ IDEA native builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e70e70db2bb73d6cf1636bc883f8b53e7b6e7cb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native for Native</source>
          <target state="translated">코 틀린 / 네이티브 네이티브</target>
        </trans-unit>
        <trans-unit id="7c2c0a3630334c277a8dc79b0ff364b848f6cdc2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has bidirectional interop with Objective-C and Swift languages. Kotlin objects integrate with Objective-C/Swift reference counting. Unused Kotlin objects are automatically removed. The &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;Objective-C Interop&lt;/a&gt; article contains more information on the interop implementation details. Of course, it is possible to import an existing framework and use it from Kotlin. Kotlin/Native comes with a good set of pre-imported system frameworks.</source>
          <target state="translated">Kotlin / Native는 Objective-C 및 Swift 언어와 양방향 상호 운용성이 있습니다. Kotlin 객체는 Objective-C / Swift 참조 카운팅과 통합됩니다. 사용하지 않은 Kotlin 개체는 자동으로 제거됩니다. &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/OBJC_INTEROP.md&quot;&gt;목표 - C 상호 운용성의&lt;/a&gt; 기사는 상호 운용성 구현 세부 사항에 대한 자세한 정보가 포함되어 있습니다. 물론 기존 프레임 워크를 가져와 Kotlin에서 사용할 수 있습니다. Kotlin / Native는 사전에 가져온 시스템 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fb79704d30655deeda4430e028a0903e865692a2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has garbage collection, but it does not help us deal with Kotlin objects from the C language. Kotlin/Native has interop with Objective-C and Swift and integrates with their reference counters. The &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;Objective-C Interop&lt;/a&gt; documentation article contains more details on it. Also, there is the tutorial &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native에는 가비지 콜렉션이 있지만 C 언어의 Kotlin 오브젝트를 처리하는 데 도움이되지 않습니다. Kotlin / Native는 Objective-C 및 Swift와 상호 운용되며 참조 카운터와 통합됩니다. &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;목표 - C 상호 운용성의&lt;/a&gt; 문서 문서에서는에 대한 자세한 내용이 포함되어 있습니다. 또한 &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native&lt;/a&gt; 튜토리얼 이 Apple Framework로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3fb305a0493b588bb98fac3fd02dfc049654c2" translate="yes" xml:space="preserve">
          <source>Kotlin/Native has received a number of performance improvements that speed up both the development process and execution. Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bedc3bea01878b4fcc1d82e743d0490ea2316b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native implements strict mutability checks, ensuring the important invariant that the object is either immutable or accessible from the single thread at that moment in time (&lt;code&gt;mutable XOR global&lt;/code&gt;).</source>
          <target state="translated">Kotlin / Native는 엄격한 변경 가능성 검사를 구현하여 해당 시점에서 단일 스레드에서 객체를 변경할 수 없거나 액세스 할 수 있다는 중요한 불변성을 보장합니다 ( &lt;code&gt;mutable XOR global&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="36a59900f037725e245ca430f51e42774fdb92b1" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interop with Swift and Objective-C is covered in the &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;documentation&lt;/a&gt; article. Also, the same topic is covered in the &lt;a href=&quot;apple-framework&quot;&gt;Kotlin/Native as an Apple Framework&lt;/a&gt; tutorial.</source>
          <target state="translated">Swift 및 Objective-C와의 Kotlin / Native interop은 &lt;a href=&quot;../../reference/native/objc_interop&quot;&gt;문서&lt;/a&gt; 기사 에서 다룹니다 . 또한 &lt;a href=&quot;apple-framework&quot;&gt;Kotlin / Native에서 Apple Framework&lt;/a&gt; 튜토리얼 과 동일한 주제를 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="9fbae7a065c905b4b51aef1c8da31351fd4627d4" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability</source>
          <target state="translated">코 틀린 / 네이티브 상호 운용성</target>
        </trans-unit>
        <trans-unit id="1610b5a5d3e7a47921adb6d92cccbad92bdc99b6" translate="yes" xml:space="preserve">
          <source>Kotlin/Native interoperability with Swift/Objective-C</source>
          <target state="translated">Swift / Objective-C와의 Kotlin / Native 상호 운용성</target>
        </trans-unit>
        <trans-unit id="d8be23859d14973d71698ea0e5cefbc7c40946a7" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is a technology for compiling Kotlin code to native binaries, which can run without a virtual machine. It is an &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; based backend for the Kotlin compiler and native implementation of the Kotlin standard library.</source>
          <target state="translated">Kotlin / Native는 Kotlin 코드를 가상 머신없이 실행할 수있는 원시 바이너리로 컴파일하는 기술입니다. 그것은이다 &lt;a href=&quot;https://llvm.org/&quot;&gt;LLVM&lt;/a&gt; 코 틀린 컴파일러와 코 틀린 표준 라이브러리의 기본 구현을위한 백엔드를 기반으로.</target>
        </trans-unit>
        <trans-unit id="f0c84f3b6f232babbc963e394f0dc8678a4ccc49" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is currently &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;in the works&lt;/a&gt;. It compiles Kotlin to native code that can run without a VM. There is a Technology Preview released but it is not production-ready yet, and doesn&amp;rsquo;t yet target all the platforms that we plan to support for 1.0. For more information check out the &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;blog post announcing Kotlin/Native&lt;/a&gt;.</source>
          <target state="translated">Kotlin / Native는 현재 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/tag/native/&quot;&gt;작업 중&lt;/a&gt; 입니다. Kotlin을 VM없이 실행할 수있는 기본 코드로 컴파일합니다. Technology Preview가 릴리스되었지만 아직 프로덕션 준비가되지 않았으며 1.0을 지원할 모든 플랫폼을 아직 대상으로하지 않습니다. 자세한 내용은 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/04/kotlinnative-tech-preview-kotlin-without-a-vm/&quot;&gt;Kotlin / Native를 알리는 블로그 게시물을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e6e839c9eb016aad26e87b63395598581d37d86" translate="yes" xml:space="preserve">
          <source>Kotlin/Native is primarily designed to allow compilation for platforms where &lt;em&gt;virtual machines&lt;/em&gt; are not desirable or possible, for example, embedded devices or iOS. It solves the situations when a developer needs to produce a self-contained program that does not require an additional runtime or virtual machine.</source>
          <target state="translated">Kotlin / Native는 주로 임베디드 장치 또는 iOS와 같이 &lt;em&gt;가상 머신&lt;/em&gt; 이 바람직하지 않거나 불가능한 플랫폼에 대한 컴파일을 허용하도록 설계되었습니다 . 개발자가 추가 런타임 또는 가상 머신을 요구하지 않는 자체 포함 된 프로그램을 생성해야하는 상황을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="0a635a513919c15b75bf38827975739bea97d9aa" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries</source>
          <target state="translated">코 틀린 / 네이티브 도서관</target>
        </trans-unit>
        <trans-unit id="e52aa2cf9fdcb60b58b2f9cbee9d5268ded14cfd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native libraries are zip files containing a predefined directory structure, with the following layout:</source>
          <target state="translated">Kotlin / Native 라이브러리는 사전 정의 된 디렉토리 구조를 포함하는 zip 파일이며 다음과 같은 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0c6f4cb92f825877d15d4e0409193ad150464dfb" translate="yes" xml:space="preserve">
          <source>Kotlin/Native plugin requires a newer version of Gradle, let's patch the &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; and use the following &lt;code&gt;distrubutionUrl&lt;/code&gt;:</source>
          <target state="translated">Kotlin / Native 플러그인에는 최신 버전의 Gradle이 필요합니다. &lt;code&gt;gradle/wrapper/gradle-wrapper.properties&lt;/code&gt; 를 패치 하고 다음 &lt;code&gt;distrubutionUrl&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc9ab4e314800dbff8307a948abe9a382ccbda9f" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bi-directional interoperability with Objective-C/Swift. Objective-C frameworks and libraries can be used in Kotlin code. Kotlin modules can be used in Swift/Objective-C code too. Besides that, Kotlin/Native has &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop&lt;/a&gt;. There is also the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for more information.</source>
          <target state="translated">Kotlin / Native는 Objective-C / Swift와 양방향 상호 운용성을 제공합니다. Kotlin 코드에서 Objective-C 프레임 워크 및 라이브러리를 사용할 수 있습니다. Kotlin 모듈은 Swift / Objective-C 코드에서도 사용할 수 있습니다. 그 외에도 Kotlin / Native에는 &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/INTEROP.md&quot;&gt;C Interop이&lt;/a&gt; 있습니다. 자세한 내용 은 &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native as a Dynamic Library&lt;/a&gt; 자습서도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b2dc69e2661f2073dd575f2affbfbd48e1816c" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides bidirectional interoperability with Objective-C. Objective-C frameworks and libraries can be used in Kotlin code if properly imported to the build (system frameworks are imported by default). See e.g. &quot;Using cinterop&quot; in &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle plugin documentation&lt;/a&gt;. A Swift library can be used in Kotlin code if its API is exported to Objective-C with &lt;code&gt;@objc&lt;/code&gt;. Pure Swift modules are not yet supported.</source>
          <target state="translated">Kotlin / Native는 Objective-C와 양방향 상호 운용성을 제공합니다. 빌드로 올바르게 가져온 경우 Objective-C 프레임 워크 및 라이브러리를 Kotlin 코드에서 사용할 수 있습니다 (기본적으로 시스템 프레임 워크를 가져옵니다). &lt;a href=&quot;gradle_plugin#using-cinterop&quot;&gt;Gradle 플러그인 문서의&lt;/a&gt; &quot;cinterop 사용&quot;을 참조하십시오 . API가 &lt;code&gt;@objc&lt;/code&gt; 를 사용 하여 Objective-C로 내보내지면 Kotlin 코드에서 Swift 라이브러리를 사용할 수 있습니다 . Pure Swift 모듈은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70a326aefb047308c0a09cf46a7be9e9cca8e58e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides integration with the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;. You can add dependencies on Pod libraries stored in the CocoaPods repository or locally as well as use a multiplatform project with native targets as a CocoaPods dependency (Kotlin Pod).</source>
          <target state="translated">Kotlin / Native는 &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods 종속성 관리자&lt;/a&gt; 와의 통합을 제공합니다 . CocoaPods 저장소 또는 로컬에 저장된 Pod 라이브러리에 대한 종속성을 추가 할 수있을뿐만 아니라 CocoaPods 종속성 (Kotlin Pod)으로 네이티브 대상이있는 다중 플랫폼 프로젝트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c01f6b8c6b07e3bae6f070059599f6036610db" translate="yes" xml:space="preserve">
          <source>Kotlin/Native provides us with the ability to consume standard C libraries, opening up an entire ecosystem of functionality that exists for pretty much anything we could need. In fact, Kotlin/Native already ships with a set of prebuilt &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;platform libraries&lt;/a&gt; which provide some additional common functionality to that of the standard library.</source>
          <target state="translated">Kotlin / Native는 표준 C 라이브러리를 사용할 수있는 기능을 제공하여 필요한 거의 모든 기능이 포함 된 전체 기능 에코 시스템을 개방합니다. 실제로 Kotlin / Native는 이미 표준 라이브러리와 공통된 기능을 추가로 제공하는 사전 빌드 된 &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/blob/master/PLATFORM_LIBS.md&quot;&gt;플랫폼 라이브러리&lt;/a&gt; 세트 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d5389b5d85aa38736c73eb5aa9a313b033cc4d19" translate="yes" xml:space="preserve">
          <source>Kotlin/Native runtime doesn't encourage a classical thread-oriented concurrency model with mutually exclusive code blocks and conditional variables, as this model is known to be error-prone and unreliable. Instead, we suggest a collection of alternative approaches, allowing you to use hardware concurrency and implement blocking IO. Those approaches are as follows, and they will be elaborated on in further sections:</source>
          <target state="translated">Kotlin / Native 런타임은 상호 배타적 인 코드 블록과 조건 변수를 가진 고전적인 스레드 지향 동시성 모델을 권장하지 않습니다.이 모델은 오류가 발생하기 쉽고 신뢰할 수 없습니다. 대신, 하드웨어 동시성을 사용하고 블로킹 IO를 구현할 수있는 대체 접근 방식 모음을 제안합니다. 이러한 접근 방식은 다음과 같으며 추가 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ac06a1726ed52d913d8c1eb5dbb2c82e723e185d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples</source>
          <target state="translated">코 틀린 / 네이티브 소스 및 예제</target>
        </trans-unit>
        <trans-unit id="c4fa13c8ae49679dc61a192fdfe13c1f15f778dd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.tgz)</source>
          <target state="translated">Kotlin / 기본 소스 및 예 (.tgz)</target>
        </trans-unit>
        <trans-unit id="950455929874daa5e49199f24231f9f317130873" translate="yes" xml:space="preserve">
          <source>Kotlin/Native sources and examples (.zip)</source>
          <target state="translated">Kotlin / 기본 소스 및 예 (.zip)</target>
        </trans-unit>
        <trans-unit id="5729c05577d9982b3fa36c76507104ea69c51357" translate="yes" xml:space="preserve">
          <source>Kotlin/Native standard library provides primitives for safe working with concurrently mutable data, namely &lt;code&gt;AtomicInt&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt;, &lt;code&gt;AtomicNativePtr&lt;/code&gt;, &lt;code&gt;AtomicReference&lt;/code&gt; and &lt;code&gt;FreezableAtomicReference&lt;/code&gt; in the package &lt;code&gt;kotlin.native.concurrent&lt;/code&gt;. Atomic primitives allows concurrency-safe update operations, such as increment, decrement and compare-and-swap, along with value setters and getters. Atomic primitives are considered always frozen by the runtime, and while their fields can be updated with the regular &lt;code&gt;field.value += 1&lt;/code&gt;, it is not concurrency safe. Value must be be changed using dedicated operations, so it is possible to perform concurrent-safe global counters and similar data structures.</source>
          <target state="translated">코 틀린 / 기본 표준 라이브러리는 동시에 가변 데이터, 즉와 안전한 작업을위한 기본 요소 제공 &lt;code&gt;AtomicInt&lt;/code&gt; , &lt;code&gt;AtomicLong&lt;/code&gt; , &lt;code&gt;AtomicNativePtr&lt;/code&gt; , &lt;code&gt;AtomicReference&lt;/code&gt; 및 &lt;code&gt;FreezableAtomicReference&lt;/code&gt; 패키지에 &lt;code&gt;kotlin.native.concurrent&lt;/code&gt; 을 . 원자 적 프리미티브는 값 설정자 및 게터와 함께 증가, 감소 및 비교 및 ​​교환과 같은 동시성 안전한 업데이트 작업을 허용합니다. 원자 적 기본 요소는 런타임에 의해 항상 고정 된 것으로 간주되며 해당 필드는 일반 필드로 업데이트 될 수 있습니다. &lt;code&gt;field.value += 1&lt;/code&gt; , 동시성이 안전하지 않습니다. 전용 연산을 사용하여 값을 변경해야하므로 동시 안전 글로벌 카운터 및 유사한 데이터 구조를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="120d75c1b3c3fba55f52d619ebc338f3dea2b2f3" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports C interop too. Check out the &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin/Native as a Dynamic Library&lt;/a&gt; tutorial for that, or have a look at the &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; documentation article</source>
          <target state="translated">Kotlin / Native는 C interop도 지원합니다. 이를위한 &lt;a href=&quot;dynamic-libraries&quot;&gt;Kotlin / Native를 동적 라이브러리&lt;/a&gt; 학습서로 확인하거나 &lt;a href=&quot;../../reference/native/c_interop&quot;&gt;C Interop&lt;/a&gt; 문서 기사를보십시오.</target>
        </trans-unit>
        <trans-unit id="8011eb11da7ebe065e7322454c19657ef14fbebd" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports the following platforms:</source>
          <target state="translated">Kotlin / Native는 다음 플랫폼을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ab1b874667f8863029a4700ab21570b44d78ad0e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native supports two-way interoperability with the Native world. On the one hand, the compiler creates:</source>
          <target state="translated">Kotlin / Native는 기본 세계와 양방향 상호 운용성을 지원합니다. 한편으로 컴파일러는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6804afabbebdb0087394548cd2a9146eb760288b" translate="yes" xml:space="preserve">
          <source>Kotlin/Native target presets (see the &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;notes&lt;/a&gt; below):</source>
          <target state="translated">코 틀린 / 네이티브 대상 사전 설정 ( 아래 &lt;a href=&quot;#using-kotlinnative-targets&quot;&gt;참고&lt;/a&gt; 참조) :</target>
        </trans-unit>
        <trans-unit id="48119a00acf039b3da2d7a8a891256a947a47f3e" translate="yes" xml:space="preserve">
          <source>Kotlin/Native targets do not require additional test dependencies, and the &lt;code&gt;kotlin.test&lt;/code&gt; API implementations are built-in.</source>
          <target state="translated">Kotlin / Native 대상에는 추가 테스트 종속성이 필요하지 않으며 &lt;code&gt;kotlin.test&lt;/code&gt; API 구현이 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2754b26e3f7ed0f09f6ac7ae0bd6b529fb311d" translate="yes" xml:space="preserve">
          <source>Kotlin/Native uses the &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; build system through the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin. We'll look at how to configure a Gradle build below. For some corner cases, a Kotlin/Native compiler can still be obtained manually (not recommended) from the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;Kotlin releases page on GitHub&lt;/a&gt;. In the tutorial, we are focusing on using the Gradle builds.</source>
          <target state="translated">Kotlin / Native는 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 통해 &lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; 빌드 시스템을 사용합니다 . 아래에서 Gradle 빌드를 구성하는 방법을 살펴 보겠습니다. 일부 경우에는 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;GitHub&lt;/a&gt; 의 Kotlin 릴리스 페이지에서 Kotlin / Native 컴파일러를 수동으로 얻을 수 있습니다 (권장되지 않음) . 튜토리얼에서는 Gradle 빌드 사용에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="8a3c5258f5b49cfb85ed7f0dcaee614a131a77c3" translate="yes" xml:space="preserve">
          <source>Kotlin:</source>
          <target state="translated">Kotlin:</target>
        </trans-unit>
        <trans-unit id="b43ff6724657fd16732a9b1a55f67abda3312ad7" translate="yes" xml:space="preserve">
          <source>KotlinConf Spinner app</source>
          <target state="translated">KotlinConf Spinner 앱</target>
        </trans-unit>
        <trans-unit id="b1cd61d796dd3aa3454e388dffcf47f0812af913" translate="yes" xml:space="preserve">
          <source>KotlinConf app</source>
          <target state="translated">KotlinConf 앱</target>
        </trans-unit>
        <trans-unit id="6047c8afd00f076fe5dfb352137d01b27268ea83" translate="yes" xml:space="preserve">
          <source>KotlinNullPointerException</source>
          <target state="translated">KotlinNullPointerException</target>
        </trans-unit>
        <trans-unit id="ee7e86f4510f7d7092cbe3960fdb6815985528a4" translate="yes" xml:space="preserve">
          <source>KotlinReflectionNotSupportedError</source>
          <target state="translated">KotlinReflectionNotSupportedError</target>
        </trans-unit>
        <trans-unit id="4b1b0c248352273cdb7b000d38d1c480106dbb58" translate="yes" xml:space="preserve">
          <source>KotlinVersion</source>
          <target state="translated">KotlinVersion</target>
        </trans-unit>
        <trans-unit id="399d4d156e1a5773fbf3b4b0cfd04b6e517c9fca" translate="yes" xml:space="preserve">
          <source>KtFunction</source>
          <target state="translated">KtFunction</target>
        </trans-unit>
        <trans-unit id="57da6543f61562be137bdbd9c9e157724aeffda4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT</source>
          <target state="translated">LEFT_TO_RIGHT</target>
        </trans-unit>
        <trans-unit id="a75ecccfbf31bd489981a90341d7e832ee10f3c8" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_EMBEDDING</source>
          <target state="translated">LEFT_TO_RIGHT_EMBEDDING</target>
        </trans-unit>
        <trans-unit id="51859752bb5b0316e072d757734043db04448fc4" translate="yes" xml:space="preserve">
          <source>LEFT_TO_RIGHT_OVERRIDE</source>
          <target state="translated">LEFT_TO_RIGHT_OVERRIDE</target>
        </trans-unit>
        <trans-unit id="758213c577cf41a86fde124f3b88be88d415048d" translate="yes" xml:space="preserve">
          <source>LETTER_NUMBER</source>
          <target state="translated">LETTER_NUMBER</target>
        </trans-unit>
        <trans-unit id="e8e9a4d54a1399696ec25a431fcc0c615fbc2e7a" translate="yes" xml:space="preserve">
          <source>LINE_SEPARATOR</source>
          <target state="translated">LINE_SEPARATOR</target>
        </trans-unit>
        <trans-unit id="e84f54372586b1a789f2b6cf056c7a1173be8141" translate="yes" xml:space="preserve">
          <source>LINUX</source>
          <target state="translated">LINUX</target>
        </trans-unit>
        <trans-unit id="7ec99800d18c128a406891a50a13ae7030c97a75" translate="yes" xml:space="preserve">
          <source>LITERAL</source>
          <target state="translated">LITERAL</target>
        </trans-unit>
        <trans-unit id="e893e5d306bb8ac993e8000a6af037f4725105be" translate="yes" xml:space="preserve">
          <source>LOCAL_VARIABLE</source>
          <target state="translated">LOCAL_VARIABLE</target>
        </trans-unit>
        <trans-unit id="99de6ad7c4876501b047c66fac1fc218394c8386" translate="yes" xml:space="preserve">
          <source>LOWERCASE_LETTER</source>
          <target state="translated">LOWERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="ebb1178c70d79da7a0d8f3efa343b4f1b5b8c8bd" translate="yes" xml:space="preserve">
          <source>Lambda Expressions and Anonymous Functions</source>
          <target state="translated">람다 식 및 익명 함수</target>
        </trans-unit>
        <trans-unit id="41d636c884bc5c4615a06b36835ca61116f4c96a" translate="yes" xml:space="preserve">
          <source>Lambda expression syntax</source>
          <target state="translated">람다 식 구문</target>
        </trans-unit>
        <trans-unit id="0b86dab2bd78e474cfa2ccedae83439dde48687c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are 'function literals', i.e. functions that are not declared, but passed immediately as an expression. Consider the following example:</source>
          <target state="translated">Lambda 표현식과 익명 함수는 '함수 리터럴'입니다. 즉 선언되지 않았지만 즉시 표현식으로 전달되는 함수입니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5688b8dc62f61bfb17ef962f1f3970299059391c" translate="yes" xml:space="preserve">
          <source>Lambda expressions and anonymous functions are collectively called &lt;em&gt;function literals&lt;/em&gt;.</source>
          <target state="translated">Lambda 표현식과 익명 함수를 통칭하여 &lt;em&gt;함수 리터럴&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7575b2907cada2fd0b97a753d13dd1b9c1b841f5" translate="yes" xml:space="preserve">
          <source>Lambda expressions can be used as function literals with receiver when the receiver type can be inferred from context. One of the most important examples of their usage is &lt;a href=&quot;type-safe-builders&quot;&gt;type-safe builders&lt;/a&gt;:</source>
          <target state="translated">수신자 유형이 컨텍스트에서 유추 될 수있는 경우 수신자가있는 함수 리터럴로 Lambda 표현식을 사용할 수 있습니다. 사용법의 가장 중요한 예 중 하나는 &lt;a href=&quot;type-safe-builders&quot;&gt;유형 안전 빌더입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3d3ff2619991da585042e4417d2462b7beccf2" translate="yes" xml:space="preserve">
          <source>Lambda formatting</source>
          <target state="translated">람다 형식</target>
        </trans-unit>
        <trans-unit id="13d6fc1369e9172c884961d85e8a1601ad741c0d" translate="yes" xml:space="preserve">
          <source>Lambda parameters</source>
          <target state="translated">람다 매개 변수</target>
        </trans-unit>
        <trans-unit id="b220e56144b93a1600b71766a84e029644f0540d" translate="yes" xml:space="preserve">
          <source>Lambda result</source>
          <target state="translated">람다 결과</target>
        </trans-unit>
        <trans-unit id="ba9dfe5041cd205445df5b843e8a9dc628256415" translate="yes" xml:space="preserve">
          <source>Lambdas</source>
          <target state="translated">Lambdas</target>
        </trans-unit>
        <trans-unit id="92af1ed3cd8ff99b216bc082c8daaf4fcc54a009" translate="yes" xml:space="preserve">
          <source>Lambdas returning &lt;code&gt;kotlin.Result&lt;/code&gt; now return boxed value instead of unboxed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9f9099a35efc6c2d9f032d57efb49b93a9221c" translate="yes" xml:space="preserve">
          <source>Language and stdlib</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3f4623762408896074b73a50b22e0a64f2aec4" translate="yes" xml:space="preserve">
          <source>Language features and improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ddf0eb799de42693040dadaac202ba4004f236" translate="yes" xml:space="preserve">
          <source>Language settings</source>
          <target state="translated">언어 설정</target>
        </trans-unit>
        <trans-unit id="a69a0d9ceb988516811878ad5b3baf535d6a8d16" translate="yes" xml:space="preserve">
          <source>Language settings are checked for consistency in the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff5129754f331271a9a3fac5165d942c8cc5ff1" translate="yes" xml:space="preserve">
          <source>Language settings of a source set affect how the sources are analyzed in the IDE. Due to the current limitations, in a Gradle build, only the language settings of the compilation's default source set are used and are applied to all of the sources participating in the compilation.</source>
          <target state="translated">소스 세트의 언어 설정은 IDE에서 소스를 분석하는 방법에 영향을줍니다. 현재 제한 사항으로 인해 Gradle 빌드에서는 컴파일 기본 소스 세트의 언어 설정 만 사용되며 컴파일에 참여하는 모든 소스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6774da675388cdd08014c6406478bff14597287" translate="yes" xml:space="preserve">
          <source>Late-Initialized Properties and Variables</source>
          <target state="translated">늦은 초기 속성 및 변수</target>
        </trans-unit>
        <trans-unit id="99322069c074a7f591d86eb26eeac43fa69f34bd" translate="yes" xml:space="preserve">
          <source>Lateinit</source>
          <target state="translated">Lateinit</target>
        </trans-unit>
        <trans-unit id="f84a3ef3e20f72377a42e84bdb45e09bb7b7843f" translate="yes" xml:space="preserve">
          <source>Lateinit top-level properties and local variables</source>
          <target state="translated">Lateinit 최상위 특성 및 로컬 변수</target>
        </trans-unit>
        <trans-unit id="8958c019aa5a02d51718ce29ef1d34ac94e1a924" translate="yes" xml:space="preserve">
          <source>Launching flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bb9d6cae3f462e729059bd666f0ea34bc0ea80" translate="yes" xml:space="preserve">
          <source>Lazily started async</source>
          <target state="translated">게으른 비동기 시작</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="be5e08be6cf0006ff0c341fef7d3f6b41fb802ed" translate="yes" xml:space="preserve">
          <source>Lazy property</source>
          <target state="translated">게으른 속성</target>
        </trans-unit>
        <trans-unit id="54579fdbee70b6cb28a03b9cca5ce503dbf0fab9" translate="yes" xml:space="preserve">
          <source>LazyThreadSafetyMode</source>
          <target state="translated">LazyThreadSafetyMode</target>
        </trans-unit>
        <trans-unit id="88e85262e00274cab89a641da3cb45b95f5a2ce2" translate="yes" xml:space="preserve">
          <source>Learn &lt;a href=&quot;native/cocoapods&quot;&gt;how to add dependencies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca4dc328f8e03ba7e98c1efbf5068f7d83287c3" translate="yes" xml:space="preserve">
          <source>Learn Kotlin</source>
          <target state="translated">코 틀린 배우기</target>
        </trans-unit>
        <trans-unit id="e3737ad5066ff8c2efc62a80380f6fc54741a2ea" translate="yes" xml:space="preserve">
          <source>Learn about &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;multiplatform projects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2474d64d95d6b15d329e41bab7ed01766c506ac9" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configure compilations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcd0abba8e732ce3f464292f0728067fe8360ff" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-set-up-targets&quot;&gt;set up targets manually&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20953bfc9862dd27c555f29879ffef5ff21fa3c3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;build the hierarchy of source sets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ca28cd12d1bd44a1297fd960c1eedef1b345b3" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;using-gradle#dependency-on-the-standard-library&quot;&gt;change the default behavior&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64487eb003a10dbcb473f2557c19c16b00054e2a" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;#share-code-in-libraries&quot;&gt;sharing code in libraries&lt;/a&gt; and &lt;a href=&quot;#use-native-libraries-in-the-hierarchical-structure&quot;&gt;using Native libraries in the hierarchical structure&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed58d30a4c6366747487c1ab11dfdb8bd165900e" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin functional interfaces and SAM conversions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a266a26503caec98e47c6ba6a7a5accc48d540" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;js-project-setup&quot;&gt;configuring Kotlin/JS projects&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ece8a8530cbd084c4191e879166f55575d6c48" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-build-native-binaries&quot;&gt;building native binaries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7794648f1ef065710c83db4bd3fd00ce935fd99" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations&quot;&gt;configuring compilations&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35eb7e7ef591eb8121626725e4cbc15aad464688" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-configure-compilations#compilation-for-android&quot;&gt;compilation for Android&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82dbe77a2cb72a3eed96435795f26fc5fd861ab" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-discover-project#source-sets&quot;&gt;source sets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8403f45e73c3fa76d6076b7f5f4ef79b474eabc9" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-dsl-reference#common-target-configuration&quot;&gt;additional settings for targets&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4ffd267ae3e789bf0bdbf84175cab85c2a10c6" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;mpp-share-on-platforms#use-native-libraries-in-the-hierarchical-structure&quot;&gt;usage of platform-dependent libraries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bdd6e03dcdfbfdc0a865fbc438364cc7870614" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;using-gradle#configuring-dependencies&quot;&gt;configuring dependencies&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802c13534d20e4859719f8999764811676dc2ecd" translate="yes" xml:space="preserve">
          <source>Learn more about coroutines debugging in the &lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../tutorials/coroutines/debug-coroutines-with-idea&quot;&gt;튜토리얼&lt;/a&gt; 에서 코 루틴 디버깅에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="f0f6b2049ff0f8271b4ef5ecd9ffeb77c34f8ee0" translate="yes" xml:space="preserve">
          <source>Learn more about creating a &lt;a href=&quot;mpp-configure-compilations#create-a-custom-compilation&quot;&gt;custom compilation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e871fbb0e4ca02f35986ac2bcdf867ebcc67c62b" translate="yes" xml:space="preserve">
          <source>Learn more about debugging coroutines in &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/07/kotlin-1-4-rc-debugging-coroutines/&quot;&gt;this blog post&lt;/a&gt; and &lt;a href=&quot;https://www.jetbrains.com/help/idea/debug-kotlin-coroutines.html&quot;&gt;IntelliJ IDEA documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c350bcedee9353ee1217f26074d552b05f99da2b" translate="yes" xml:space="preserve">
          <source>Learn more about the &lt;a href=&quot;https://github.com/JetBrains/kotlin/blob/1.4.0/native/commonizer/README.md&quot;&gt;technical details&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382bc2b5420e5bc5b00d6eff83fe5cc43062a688" translate="yes" xml:space="preserve">
          <source>Learn more about the available features in the Kotlin/JS IR compiler backend in the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a7c9acfbc9796eb30e7c60b60f1b0ce15271c8" translate="yes" xml:space="preserve">
          <source>Learn more how to &lt;a href=&quot;mpp-configure-compilations#configure-interop-with-native-languages&quot;&gt;configure interop with native languages&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc982a7f5ebfb278a6eac9d43da3ac1981ee500" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;js-project-setup#choosing-execution-environment&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28b1c4866b45b6c232187eb0f49c55bd90b8a14" translate="yes" xml:space="preserve">
          <source>Learning Kotlin</source>
          <target state="translated">코 틀린 학습</target>
        </trans-unit>
        <trans-unit id="23f50e0c99ce18545a5c0af46eb7b9685859fd37" translate="yes" xml:space="preserve">
          <source>Learning Kotlin with EduTools plugin</source>
          <target state="translated">EduTools 플러그인으로 Kotlin 학습</target>
        </trans-unit>
        <trans-unit id="e19a030656541f97ece0fe153ca0f1966796261d" translate="yes" xml:space="preserve">
          <source>Leave other options with their default values and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">다른 옵션은 기본값으로두고 &lt;strong&gt;Finish를&lt;/strong&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8d43e4d61d6a5ac38163dd5c6fce699c5294311" translate="yes" xml:space="preserve">
          <source>Let us have two producers of strings: &lt;code&gt;fizz&lt;/code&gt; and &lt;code&gt;buzz&lt;/code&gt;. The &lt;code&gt;fizz&lt;/code&gt; produces &quot;Fizz&quot; string every 300 ms:</source>
          <target state="translated">&lt;code&gt;fizz&lt;/code&gt; 와 &lt;code&gt;buzz&lt;/code&gt; 의 두 문자열 제작자를 보자 . 이 &lt;code&gt;fizz&lt;/code&gt; 는 300 ms마다 &quot;Fizz&quot;문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d5d7818bcabda3185325fd62a8d08d65a192e5b3" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action a thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">100 개의 코 루틴이 모두 동일한 작업을 천 번 수행하도록합시다. 추가 비교를 위해 완료 시간도 측정합니다.</target>
        </trans-unit>
        <trans-unit id="97c13d20ca41b326b3be0985ea83f77551576d93" translate="yes" xml:space="preserve">
          <source>Let us launch a hundred coroutines all doing the same action thousand times. We'll also measure their completion time for further comparisons:</source>
          <target state="translated">모두 같은 행동을 천 번 수행하는 백 코 루틴을 시작합시다. 또한 추가 비교를 위해 완료 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="00337a32763192378fa8ed88a3475bc09950f868" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie activity's and coroutines lifecycles, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction that encapsulates that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">상황, 아동 및 직업에 대한 지식을 함께합시다. 애플리케이션에 수명주기가있는 객체가 있지만 해당 객체가 코 루틴이 아니라고 가정합니다. 예를 들어, Android 애플리케이션을 작성하고 Android 활동의 컨텍스트에서 다양한 코 루틴을 시작하여 데이터를 가져오고 업데이트하기 위해 비동기 작업을 수행하고 애니메이션을 수행하는 등의 작업을 수행해야합니다. 메모리 누수를 방지하기 위해 이러한 코 루틴을 모두 제거해야 활동이 중단됩니다 . 물론 활동과 코 루틴 라이프 사이클을 연결하기 위해 컨텍스트와 작업을 수동으로 조작 할 수 있지만 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 는 다음을 캡슐화하는 추상화를 제공합니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . 모든 코 루틴 빌더는 확장으로 선언되므로 코 루틴 범위에 대해 이미 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f1725d0b230accb8eeb7b1ecce985617d4f3a5c" translate="yes" xml:space="preserve">
          <source>Let us put our knowledge about contexts, children and jobs together. Assume that our application has an object with a lifecycle, but that object is not a coroutine. For example, we are writing an Android application and launch various coroutines in the context of an Android activity to perform asynchronous operations to fetch and update data, do animations, etc. All of these coroutines must be cancelled when the activity is destroyed to avoid memory leaks. We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but &lt;code&gt;kotlinx.coroutines&lt;/code&gt; provides an abstraction encapsulating that: &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</source>
          <target state="translated">상황, 아동 및 직업에 대한 지식을 함께 모 읍시다. 애플리케이션에 수명주기가있는 객체가 있지만 해당 객체가 코 루틴이 아니라고 가정합니다. 예를 들어, Android 애플리케이션을 작성하고 Android 활동 컨텍스트에서 다양한 코 루틴을 실행하여 데이터를 가져오고 업데이트하고 애니메이션을 수행하는 등의 비동기 작업을 수행합니다. 이러한 모든 코 루틴은 메모리를 피하기 위해 활동이 파괴 될 때 취소되어야합니다. 누출. 물론 우리는 컨텍스트와 작업을 수동으로 조작하여 액티비티와 코 루틴의 라이프 사이클을 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 수 있지만 kotlinx.coroutines 는이를 캡슐화하는 추상화를 제공합니다 : &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; . 모든 코 루틴 빌더는 확장으로 선언되어 있으므로 코 루틴 범위에 이미 익숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="f17004be77e3f7094989ac66ca7a6fcece2d7637" translate="yes" xml:space="preserve">
          <source>Let us run it all seven times:</source>
          <target state="translated">우리가 그것을 일곱 번 모두 실행합시다 :</target>
        </trans-unit>
        <trans-unit id="887399487cb35f46c356a942974d9aca65f7d75b" translate="yes" xml:space="preserve">
          <source>Let us start a dozen of them with a random delay.</source>
          <target state="translated">무작위 지연으로 12 가지를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="413db7e1244403c1e2eef1bc015d6f2b29e5c10d" translate="yes" xml:space="preserve">
          <source>Let us take &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutines builder is defined as extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; we need to have it in the scope and that is what &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;비동기&lt;/a&gt; 예제를 사용하여 Concurrent를 가져 와서 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 과 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를 동시에 수행 하고 결과의 합계를 반환 하는 함수를 추출 합시다 . 때문에 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 에 대한 확장으로 정의 빌더 코 루틴 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; 우리는 범위에 있고 그 무엇을 필요 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope의&lt;/a&gt; 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="bcdef397c512533845238594a2c065ab9f9b9332" translate="yes" xml:space="preserve">
          <source>Let us take the &lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; example and extract a function that concurrently performs &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; and returns the sum of their results. Because the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder is defined as an extension on &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt;, we need to have it in the scope and that is what the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; function provides:</source>
          <target state="translated">&lt;a href=&quot;#concurrent-using-async&quot;&gt;Concurrent using async&lt;/a&gt; 예제를 사용하여 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 및 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를 동시에 수행 하고 결과의 합계를 반환 하는 함수를 추출해 보겠습니다 . &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 코 루틴 빌더는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; 의 확장으로 정의 되기 때문에 범위에 있어야하며 이것이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 함수가 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4952c7e38d872a3739e9ba60b2855b8019e8b9ca" translate="yes" xml:space="preserve">
          <source>Let us write a channel producer function that consumes a channel of deferred string values, waits for each received deferred value, but only until the next deferred value comes over or the channel is closed. This example puts together &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; clauses in the same &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="translated">지연된 문자열 값의 채널을 소비하고 수신 된 각 지연된 값을 대기하지만 다음 지연된 값이 도달하거나 채널이 닫힐 때까지만 채널 생성기 함수를 작성해 봅시다. 이 예제는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/on-await.html&quot;&gt;onAwait&lt;/a&gt; 절을 동일한 &lt;code&gt;select&lt;/code&gt; 에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="4731fc0f08644e9fc8c26a8f5800aec92b69f2ee" translate="yes" xml:space="preserve">
          <source>Let us write an example of producer of integers that sends its values to a &lt;code&gt;side&lt;/code&gt; channel when the consumers on its primary channel cannot keep up with it:</source>
          <target state="translated">기본 채널의 소비자가 따라갈 수없는 경우 값을 &lt;code&gt;side&lt;/code&gt; 채널 로 보내는 정수 생산자의 예를 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="2a09d0572f014b56fede8ceb5d706fa8418ec701" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at how to serialize Kotlin objects into JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad40ae1c76d7921aa80d947aae7e4174122ffe9" translate="yes" xml:space="preserve">
          <source>Let's also make sure that our coroutines actually run in parallel. If we add a 1-second &lt;code&gt;delay()&lt;/code&gt; to each of the &lt;code&gt;async&lt;/code&gt;'s, the resulting program won't run for 1'000'000 seconds (over 11,5 days):</source>
          <target state="translated">코 루틴이 실제로 병렬로 실행되는지 확인합시다. 각 &lt;code&gt;async&lt;/code&gt; 1 초 &lt;code&gt;delay()&lt;/code&gt; 을 추가 하면 결과 프로그램은 1,000,000 초 (11,5 일 이상) 동안 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f68d829cd771ce134770e031cf5bf3966ac35a" translate="yes" xml:space="preserve">
          <source>Let's assume in the code above that &lt;code&gt;preparePost&lt;/code&gt; is a long-running process and consequently would block the user interface. What we can do is launch it in a separate thread. This would then allow us to avoid the UI from blocking. This is a very common technique, but has a series of drawbacks:</source>
          <target state="translated">위의 코드에서 &lt;code&gt;preparePost&lt;/code&gt; 는 오래 실행되는 프로세스이며 결과적으로 사용자 인터페이스를 차단 한다고 가정합니다 . 우리가 할 수있는 일은 별도의 스레드에서 시작하는 것입니다. 그러면 UI가 차단되는 것을 피할 수 있습니다. 이것은 매우 일반적인 기술이지만 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b36e6d9aeacb6946bbe6f44c31eebe2f8d34c7f" translate="yes" xml:space="preserve">
          <source>Let's call the framework from Objective-C. For that we create the &lt;code&gt;main.m&lt;/code&gt; file with the following content:</source>
          <target state="translated">Objective-C에서 프레임 워크를 호출 해 봅시다. 이를 위해 다음 내용으로 &lt;code&gt;main.m&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="de2db89a9bd54d886863702055b65232c802ea65" translate="yes" xml:space="preserve">
          <source>Let's check out the C API of our Kotlin library.`</source>
          <target state="translated">Kotlin 라이브러리의 C API를 확인하십시오 .`</target>
        </trans-unit>
        <trans-unit id="ccdc7274b76228eb418fb01b25e4e0b2b1a04fe1" translate="yes" xml:space="preserve">
          <source>Let's click on the &lt;code&gt;App&lt;/code&gt; run configuration to get our project running either on a real Android Device or on the emulator.</source>
          <target state="translated">&lt;code&gt;App&lt;/code&gt; 실행 구성을 클릭하여 프로젝트가 실제 Android 장치 또는 에뮬레이터에서 실행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="1f650b1ab54a0b4e48ce9f7def949cc9e4127516" translate="yes" xml:space="preserve">
          <source>Let's click the &lt;em&gt;Run&lt;/em&gt; button in Xcode, and we'll see our application running</source>
          <target state="translated">Xcode 에서 &lt;em&gt;Run&lt;/em&gt; 버튼을 클릭하면 응용 프로그램이 실행되는 것을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="735664d189535b1add7a525bb222b33a786f953e" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how C primitive type declarations are visible from Kotlin:</source>
          <target state="translated">하자가 생성 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; C 원시 형 선언은 코 틀린에서 볼 수 있습니다 방법을 보려면 다음과 같은 내용으로 스텁 파일 :</target>
        </trans-unit>
        <trans-unit id="10159fd0817061a10325f96cf0c251b77597ee1f" translate="yes" xml:space="preserve">
          <source>Let's create a &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; stub file with the following content to see how our C declarations are visible from Kotlin:</source>
          <target state="translated">Kotlin에서 C 선언이 어떻게 보이는지 확인하기 위해 다음 내용으로 &lt;code&gt;src/nativeMain/kotlin/hello.kt&lt;/code&gt; 스텁 파일을 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a7acdfe9286fc908f1acf3c36443211f26fc104a" translate="yes" xml:space="preserve">
          <source>Let's create a million coroutines again, keeping their &lt;code&gt;Deferred&lt;/code&gt; objects. Now there's no need in the atomic counter, as we can just return the numbers to be added from our coroutines:</source>
          <target state="translated">&lt;code&gt;Deferred&lt;/code&gt; 객체를 유지하면서 백만 개의 코 루틴을 다시 만들어 봅시다 . 이제 우리는 코 루틴에서 추가 할 숫자를 반환 할 수 있으므로 원자 카운터에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="996aed5293f16fb62ea0b0ffc195f181e0ae218e" translate="yes" xml:space="preserve">
          <source>Let's create the class &lt;code&gt;Base64Test&lt;/code&gt; in &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; folder and write the basic tests for Base64.</source>
          <target state="translated">하자는 클래스 생성 &lt;code&gt;Base64Test&lt;/code&gt; 에 &lt;code&gt;commonTest/kotlin/jetbrains/base64&lt;/code&gt; 폴더를 Base64로에 대한 기본 테스트를 작성.</target>
        </trans-unit>
        <trans-unit id="bbdbbcfe4f2f14866b323983f8f8272c8a107004" translate="yes" xml:space="preserve">
          <source>Let's denote a function f(x) in such a way: we add 1 to x, then, while there is at least one trailing zero in the resulting number, we remove that zero.</source>
          <target state="translated">이런 식으로 함수 f (x)를 표시해 봅시다. x에 1을 더한 다음 결과 숫자에 적어도 하나의 후행 0이있는 동안 해당 0을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b41c2ae19915325ca1208b1c0d9b4b01df9a8df1" translate="yes" xml:space="preserve">
          <source>Let's dig a little into what it means. The biggest merit of coroutines is that they can &lt;em&gt;suspend&lt;/em&gt; without blocking a thread. The compiler has to emit some special code to make this possible, so we have to mark functions that &lt;em&gt;may suspend&lt;/em&gt; explicitly in the code. We use the &lt;code&gt;suspend&lt;/code&gt; modifier for it:</source>
          <target state="translated">그것이 무엇을 의미하는지 조금 파헤쳐 봅시다. 코 루틴의 가장 큰 장점은 실을 막지 않고 &lt;em&gt;중단&lt;/em&gt; 할 수 있다는 것 입니다. 컴파일러는이를 가능하게하기 위해 특수 코드를 생성해야하므로 코드에서 명시 적으로 &lt;em&gt;일시 중단 될 수있는&lt;/em&gt; 함수를 표시 해야합니다. 우리는 사용 &lt;code&gt;suspend&lt;/code&gt; 그것에 대한 수정 :</target>
        </trans-unit>
        <trans-unit id="b909fa7b179bbce71ededd8361a6bf68ecb8e547" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code you get a new function with &lt;code&gt;suspend&lt;/code&gt; modifier. That is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions, like &lt;code&gt;delay&lt;/code&gt; in this example, to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 안의 코드 블록을 별도의 함수로 추출해 봅시다 . 이 코드에서 &quot;추출 기능&quot;리팩토링을 수행하면 &lt;code&gt;suspend&lt;/code&gt; 수정자를 사용 하여 새로운 기능을 얻게 됩니다. 이것이 첫 번째 &lt;em&gt;일시 중단 기능&lt;/em&gt; 입니다. 서 스펜 딩 함수는 일반 함수처럼 코 루틴 내에서 사용할 수 있지만 추가 기능은 이 예제의 &lt;code&gt;delay&lt;/code&gt; 과 같은 다른 서 스펜 딩 함수를 사용 하여 코 루틴 실행 을 &lt;em&gt;일시 중단&lt;/em&gt; 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61bad05f01a2e90a1664c7ea21ea22130405aa4e" translate="yes" xml:space="preserve">
          <source>Let's extract the block of code inside &lt;code&gt;launch { ... }&lt;/code&gt; into a separate function. When you perform &quot;Extract function&quot; refactoring on this code, you get a new function with the &lt;code&gt;suspend&lt;/code&gt; modifier. This is your first &lt;em&gt;suspending function&lt;/em&gt;. Suspending functions can be used inside coroutines just like regular functions, but their additional feature is that they can, in turn, use other suspending functions (like &lt;code&gt;delay&lt;/code&gt; in this example) to &lt;em&gt;suspend&lt;/em&gt; execution of a coroutine.</source>
          <target state="translated">&lt;code&gt;launch { ... }&lt;/code&gt; 내부의 코드 블록을 별도의 함수로 추출해 보겠습니다 . 이 코드에서 &quot;Extract function&quot;리팩토링을 수행하면 &lt;code&gt;suspend&lt;/code&gt; modifier 가있는 새 함수가 생성 됩니다. 이것은 첫 번째 &lt;em&gt;일시 중단 기능&lt;/em&gt; 입니다. 일시 중단 함수는 일반 함수와 마찬가지로 코 루틴 내부에서 사용할 수 있지만 추가 기능은 다른 일시 중단 함수 ( 이 예에서 &lt;code&gt;delay&lt;/code&gt; 과 같은 )를 사용 하여 코 루틴의 실행 을 &lt;em&gt;일시 중단&lt;/em&gt; 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7122eef62315ddd178e19521346dcd7b3d4f4ef" translate="yes" xml:space="preserve">
          <source>Let's first create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before new files are added.</source>
          <target state="translated">먼저 프로젝트 폴더를 만들어 봅시다. 이 자습서의 모든 경로는이 폴더를 기준으로합니다. 때때로 새 파일을 추가하기 전에 누락 된 디렉토리를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb38e1408559447345a86b525296d1eabcbbd05" translate="yes" xml:space="preserve">
          <source>Let's get straight to the point - type this into a file with the extension &lt;code&gt;.kt&lt;/code&gt;:</source>
          <target state="translated">이것을 &lt;code&gt;.kt&lt;/code&gt; 확장자를 가진 파일로 바로 입력 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="bd86f7e49e4cf62602c569422996655dedc19452" translate="yes" xml:space="preserve">
          <source>Let's include the dependency from the &lt;code&gt;SharedCode&lt;/code&gt; project to the Android project. We need to patch the &lt;code&gt;app/build.gradle&lt;/code&gt; file and include the following line into the &lt;code&gt;dependencies { .. }&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;SharedCode&lt;/code&gt; 프로젝트에서 Android 프로젝트 로의 종속성을 포함시킵니다 . &lt;code&gt;app/build.gradle&lt;/code&gt; 파일 을 패치하고 다음 행을 &lt;code&gt;dependencies { .. }&lt;/code&gt; 블록에 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="b82b4fa1803ecc5b171c4989f538f93a5e12eeda" translate="yes" xml:space="preserve">
          <source>Let's just check everything is right with the project so far, the project structure should be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3031affd63f3a34c70e027c9fb0083b3841cbbd1" translate="yes" xml:space="preserve">
          <source>Let's look at &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; which is implemented in an external library, &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt;:</source>
          <target state="translated">외부 라이브러리 인 &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines&quot;&gt;kotlinx.coroutines&lt;/a&gt; 에서 구현 된 &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 를 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="957a84aa6afafd513ebe49ba72fc204fd5a6b335" translate="yes" xml:space="preserve">
          <source>Let's look at a full program that uses &lt;code&gt;launch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;launch&lt;/code&gt; 를 사용하는 전체 프로그램을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="4e571fdb95d6ede65232f8b540598b12acfcf120" translate="yes" xml:space="preserve">
          <source>Let's look over it to spot what has changed. In Java you annotated the field, binding it with the corresponding view:</source>
          <target state="translated">무엇이 바뀌 었는지 찾아 보도록하겠습니다. Java에서는 필드에 주석을 달고 해당 뷰와 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="1fb40ced67af4648c46e396667df192d29c4d5c8" translate="yes" xml:space="preserve">
          <source>Let's make sure we can run the application on the iPhone emulator or device.</source>
          <target state="translated">iPhone 에뮬레이터 또는 장치에서 응용 프로그램을 실행할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4c1369d1fff2907e87dbe0e51a95a4a2b1d68308" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더로 옮깁니다 . 이것이 &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인이 사용될 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트가 동적 또는 공유 라이브러리를 생성하도록 구성합니다.</target>
        </trans-unit>
        <trans-unit id="254d91019bfe0a24fa67828566bb23aeecf078e8" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. That is the default path, where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더 로 이동하겠습니다 . &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 사용할 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트를 구성하여 동적 또는 공유 라이브러리를 생성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="684a72371b803184f7a1d16df5fdf49dd7a6a0de" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더로 옮깁니다 . &lt;a href=&quot;../../reference/building-mpp-with-gradle&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 사용할 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 프로젝트가 동적 또는 공유 라이브러리를 생성하도록 지시하고 구성합니다.</target>
        </trans-unit>
        <trans-unit id="034d9c3c346b06a98e0db9b883376985d9d3fdc3" translate="yes" xml:space="preserve">
          <source>Let's move the sources file into the &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; folder under the project. This is the default path, for where sources are located, when the &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; plugin is used. We use the following block to instruct and configure the project to generate a dynamic or shared library for us:</source>
          <target state="translated">소스 파일을 프로젝트 아래의 &lt;code&gt;src/nativeMain/kotlin&lt;/code&gt; 폴더 로 이동하겠습니다 . &lt;a href=&quot;../../reference/mpp-discover-project&quot;&gt;kotlin-multiplatform&lt;/a&gt; 플러그인을 사용할 때 소스가있는 기본 경로 입니다. 다음 블록을 사용하여 동적 또는 공유 라이브러리를 생성하도록 프로젝트를 지시하고 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a942f64f48ea1ece8880513eaa81ddefeb619b0a" translate="yes" xml:space="preserve">
          <source>Let's replace &lt;code&gt;testSolution()&lt;/code&gt; function content with the following:</source>
          <target state="translated">의 교체하자 &lt;code&gt;testSolution()&lt;/code&gt; 는 다음과 기능의 콘텐츠를 :</target>
        </trans-unit>
        <trans-unit id="4a173594d073c26a036c43463ffde9097189a153" translate="yes" xml:space="preserve">
          <source>Let's run a lot of them</source>
          <target state="translated">그들을 많이 봅시다</target>
        </trans-unit>
        <trans-unit id="4b01757c4af3890b2686d482b6ad16159167a6f9" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradle 태스크를 실행하여 &lt;a href=&quot;basic-kotlin-native-app#run-in-ide&quot;&gt;IDE&lt;/a&gt; 에서 라이브러리를 빌드 하거나 다음 콘솔 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="106249141867c6b57bd6484ccdc821cb560f7f5d" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library &lt;a href=&quot;using-intellij-idea&quot;&gt;in the IDE&lt;/a&gt; or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradle 작업을 실행하여 &lt;a href=&quot;using-intellij-idea&quot;&gt;IDE&lt;/a&gt; 에서 라이브러리를 빌드 하거나 다음 콘솔 명령을 호출 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="0027507ed05fb5770a6709f41c759d4f8b675c55" translate="yes" xml:space="preserve">
          <source>Let's run the &lt;code&gt;linkNative&lt;/code&gt; Gradle task to build the library in the IDE or by calling the following console command:</source>
          <target state="translated">&lt;code&gt;linkNative&lt;/code&gt; Gradle 작업을 실행하여 IDE에서 라이브러리를 빌드하거나 다음 콘솔 명령을 호출 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="ced335cd9fa401cb82913f0326e2577c06919225" translate="yes" xml:space="preserve">
          <source>Let's say that you're writing a simple ORM. Your database library represents a row as instances of a class &lt;code&gt;Entity&lt;/code&gt;, with functions like &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; and &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; for getting typed values from the given columns. We could create a typed wrapper class like this:</source>
          <target state="translated">간단한 ORM을 작성한다고 가정 해 봅시다. 데이터베이스 라이브러리는 주어진 열에서 유형이 지정된 값을 가져 오기위한 &lt;code&gt;getString(&quot;name&quot;)&lt;/code&gt; 및 &lt;code&gt;getLong(&quot;age&quot;)&lt;/code&gt; 과 같은 함수를 사용하여 &lt;code&gt;Entity&lt;/code&gt; 클래스의 인스턴스로 행을 나타냅니다 . 다음과 같이 유형이 지정된 래퍼 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a18f6d560df8733728d2795ff272c64a409b9516" translate="yes" xml:space="preserve">
          <source>Let's say we need to return two things from a function. For example, a result object and a status of some sort. A compact way of doing this in Kotlin is to declare a &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;data class&lt;/em&gt;&lt;/a&gt; and return its instance:</source>
          <target state="translated">함수에서 두 가지를 반환해야한다고 가정 해 봅시다. 예를 들어 결과 개체와 일종의 상태가 있습니다. Kotlin에서이를 수행하는 간단한 방법은 &lt;a href=&quot;data-classes&quot;&gt;&lt;em&gt;데이터 클래스&lt;/em&gt;&lt;/a&gt; 를 선언하고 해당 인스턴스를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8eba6223ee182cc016df2825ffe27a1806c3d5dd" translate="yes" xml:space="preserve">
          <source>Let's see how &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;object&lt;/code&gt; are mapped to Objective-C and Swift. The generated &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; file contains the exact definitions for &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;Interface&lt;/code&gt;, and &lt;code&gt;Object&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 와 &lt;code&gt;object&lt;/code&gt; 가 Objective-C와 Swift에 어떻게 매핑 되는지 봅시다 . 생성 된 &lt;code&gt;&amp;lt;Framework&amp;gt;/Headers/Demo.h&lt;/code&gt; 파일에는 &lt;code&gt;Class&lt;/code&gt; , &lt;code&gt;Interface&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt; 에 대한 정확한 정의가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="2abb7f43d07915bd385a08f6f8eca1904f202535" translate="yes" xml:space="preserve">
          <source>Let's see now &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; is turned to a pointer first:</source>
          <target state="translated">이제 &lt;code&gt;CValue&amp;lt;T&amp;gt;&lt;/code&gt; 가 먼저 포인터로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="0da8a1853bc3aa9296a82e748b06afcd60c8ff39" translate="yes" xml:space="preserve">
          <source>Let's summarize what we have in the table:</source>
          <target state="translated">표에있는 내용을 요약 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="29489a663f002abc7aabbc10da61ddf3922c9137" translate="yes" xml:space="preserve">
          <source>Let's switch back to the Android Studio and execute the &lt;code&gt;build&lt;/code&gt; target of the &lt;code&gt;SharedCode&lt;/code&gt; project from the &lt;em&gt;Gradle&lt;/em&gt; tool window. The task looks for environment variables set by the Xcode build and copies the right variant of the framework into the &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; folder. We then include the framework from that folder into the build</source>
          <target state="translated">Android Studio로 다시 전환 하고 &lt;em&gt;Gradle&lt;/em&gt; 도구 창 에서 &lt;code&gt;SharedCode&lt;/code&gt; 프로젝트 의 &lt;code&gt;build&lt;/code&gt; 대상을 실행하겠습니다 . 이 작업은 Xcode 빌드에서 설정 한 환경 변수를 찾고 올바른 프레임 워크 변형을 &lt;code&gt;SharedCode/build/xcode-frameworks&lt;/code&gt; 폴더에 복사합니다. 그런 다음 해당 폴더의 프레임 워크를 빌드에 포함시킵니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5c06386e1b74a742a7f7576c52eff2fd2031ee" translate="yes" xml:space="preserve">
          <source>Let's take a look at Kotlin runtime declarations first:</source>
          <target state="translated">Kotlin 런타임 선언을 먼저 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d3a04db62b13c25688a0e50c618e3bec15eb02a" translate="yes" xml:space="preserve">
          <source>Let's take a look at a concrete example.</source>
          <target state="translated">구체적인 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d83be9a947c4ef371bac95dfdb52ba3f51a09f86" translate="yes" xml:space="preserve">
          <source>Let's take a look at the &lt;code&gt;kotlin.root.example&lt;/code&gt; field, it mimics the package structure of our Kotlin code with a &lt;code&gt;kotlin.root.&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;kotlin.root.example&lt;/code&gt; 필드를 살펴보면 Kotlin 코드의 패키지 구조와 &lt;code&gt;kotlin.root.&lt;/code&gt; 모방합니다 . 접두사.</target>
        </trans-unit>
        <trans-unit id="7a1c41eab269c88a145c3bcd2eacac0f706a1202" translate="yes" xml:space="preserve">
          <source>Let's take a look at the difference between &lt;code&gt;Iterable&lt;/code&gt; and &lt;code&gt;Sequence&lt;/code&gt; with an example.</source>
          <target state="translated">&lt;code&gt;Iterable&lt;/code&gt; 과 &lt;code&gt;Sequence&lt;/code&gt; 의 차이점을 예제로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="683ff410a92468b732cdb32c98685fb25b7caa78" translate="yes" xml:space="preserve">
          <source>Let's take a look at the generated functions that take our &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt; as parameters. We see that by-value parameters are represented as &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt;. And for typed pointer parameters we see &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt;. Kotlin provides us with an API to deal with both types easily, let's try it and see.</source>
          <target state="translated">&lt;code&gt;MyStruct&lt;/code&gt; 와 &lt;code&gt;MyUnion&lt;/code&gt; 을 매개 변수 로 사용하는 생성 된 함수를 살펴 보겠습니다 . &lt;code&gt;kotlinx.cinterop.CValue&amp;lt;T&amp;gt;&lt;/code&gt; 매개 변수는 kotlinx.cinterop.CValue &amp;lt;T&amp;gt; 로 표시됩니다 . 그리고 입력 된 포인터 매개 변수의 경우 &lt;code&gt;kotlinx.cinterop.CValuesRef&amp;lt;T&amp;gt;&lt;/code&gt; 됩니다. Kotlin은 두 유형을 쉽게 처리 할 수있는 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="640f277dd088f13964789f8075c590d21d6b9dfc" translate="yes" xml:space="preserve">
          <source>Let's take pipelines to the extreme with an example that generates prime numbers using a pipeline of coroutines. We start with an infinite sequence of numbers.</source>
          <target state="translated">코 루틴 파이프 라인을 사용하여 소수를 생성하는 예제를 통해 파이프 라인을 최대한 활용 해 봅시다. 우리는 무한한 숫자 시퀀스로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3a85f4e1e0328af1a77f3960a6412ca2106e30f9" translate="yes" xml:space="preserve">
          <source>Let's try the same with coroutines:</source>
          <target state="translated">코 루틴으로 동일하게 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="7edcd7d839fe1e0dfdcd3a0fe161ec6c231e6fb0" translate="yes" xml:space="preserve">
          <source>Let's try to use the API from Kotlin. Let's call &lt;code&gt;pass_string&lt;/code&gt; first:</source>
          <target state="translated">Kotlin의 API를 사용해 봅시다. 먼저 &lt;code&gt;pass_string&lt;/code&gt; 을 호출 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="0627f0965e7ec33cbf1e065c2d05108d4f888350" translate="yes" xml:space="preserve">
          <source>Let's update the Gradle scripts now to implement that and configure our IDE.</source>
          <target state="translated">이를 구현하고 IDE를 구성하기 위해 Gradle 스크립트를 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="cd1102ed7118f5a51e4a3d98942ad07717eaabd4" translate="yes" xml:space="preserve">
          <source>Let's use it with channel &lt;code&gt;a&lt;/code&gt; that produces &quot;Hello&quot; string four times and channel &lt;code&gt;b&lt;/code&gt; that produces &quot;World&quot; four times:</source>
          <target state="translated">의 채널을 함께 사용하자 에 &quot;Hello&quot;문자열을 네 번 채널 생성 &lt;code&gt;b&lt;/code&gt; 네 번 &quot;세계&quot;를 생성합니다 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9dbe6646e8e9a0c1dd5558c986bbdc08c0c317a1" translate="yes" xml:space="preserve">
          <source>Let's walk through the interfaces and their implementations.</source>
          <target state="translated">인터페이스와 해당 구현을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="83d65fd8bdf3a04f906b52d7b1ba67e299c6332e" translate="yes" xml:space="preserve">
          <source>Let's walk through the mechanisms of implementing type-safe builders in Kotlin. First of all, we need to define the model we want to build, in this case we need to model HTML tags. It is easily done with a bunch of classes. For example, &lt;code&gt;HTML&lt;/code&gt; is a class that describes the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag, i.e. it defines children like &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. (See its declaration &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;below&lt;/a&gt;.)</source>
          <target state="translated">Kotlin에서 형식 안전 빌더를 구현하는 메커니즘을 살펴 보겠습니다. 우선, 빌드하려는 모델을 정의해야합니다.이 경우 HTML 태그를 모델링해야합니다. 많은 클래스로 쉽게 수행됩니다. 예를 들어 &lt;code&gt;HTML&lt;/code&gt; 은 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 태그 를 설명하는 클래스입니다 . 즉 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 와 같은 자식을 정의합니다 . ( &lt;a href=&quot;#full-definition-of-the-comexamplehtml-package&quot;&gt;아래&lt;/a&gt; 선언 참조 )</target>
        </trans-unit>
        <trans-unit id="7c7f5d049fad2569721d446c4a811f9bd5da5393" translate="yes" xml:space="preserve">
          <source>Level</source>
          <target state="translated">Level</target>
        </trans-unit>
        <trans-unit id="72a321ab062693e53bbb407257b25f97ff6f7e3d" translate="yes" xml:space="preserve">
          <source>Leveraging native libs in the hierarchical structure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="944db4e3c24472be792b2084d0de67b6c3f7f699" translate="yes" xml:space="preserve">
          <source>Libraries published with the hierarchical project structure are compatible with all kinds of projects, both with and without the hierarchical project structure. However, libraries published without the hierarchical project structure can&amp;rsquo;t be used in a shared native source set. So, for example, users with &lt;code&gt;ios()&lt;/code&gt; shortcuts in their &lt;code&gt;gradle.build&lt;/code&gt; files won&amp;rsquo;t be able to use your library in their iOS-shared code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f72e56b5ae78fda32dcd4978d25a113af870e2" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">라이브러리 작성자는 @Deprecated 및 &lt;a href=&quot;../opt-in-requirements&quot;&gt;@RequiresOptIn&lt;/a&gt; 주석을 사용하여 API 표면의 진화를 제어 할 수 있습니다 . @Deprecated (level = HIDDEN)는 API에서 제거 된 선언의 경우에도 바이너리 호환성을 유지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fbbbbc56ff7a0c7c22c830abedb5e3565e5058" translate="yes" xml:space="preserve">
          <source>Library authors can use the @Deprecated and @Experimental annotations to control the evolution of their API surface. Note that @Deprecated(level=HIDDEN) can be used to preserve binary compatibility even for declarations removed from the API.</source>
          <target state="translated">라이브러리 작성자는 @Deprecated 및 @Experimental 주석을 사용하여 API 표면의 진화를 제어 할 수 있습니다. @Deprecated (level = HIDDEN)를 사용하여 API에서 제거 된 선언의 경우에도 이진 호환성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0405ca8057bdd26aa8a71ed5b78eaef11cd20a80" translate="yes" xml:space="preserve">
          <source>Library code should always specify return types of public/protected functions and properties explicitly thus never relying on type inference for public API. Subtle changes in type inference may cause return types to change inadvertently, leading to binary compatibility issues.</source>
          <target state="translated">라이브러리 코드는 항상 반환 유형의 퍼블릭 / 보호 함수 및 속성을 명시 적으로 지정해야하므로 퍼블릭 API의 타입 유추에 의존하지 않습니다. 형식 유추의 미묘한 변경으로 인해 반환 형식이 실수로 변경되어 이진 호환성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7267839499feac3cd8daacca298c9e65946505b" translate="yes" xml:space="preserve">
          <source>Library search path. For more information, see &lt;a href=&quot;native/libraries#library-search-sequence&quot;&gt;Library search sequence&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc01b5cc1b2ec00feddd7cb533ccfb023b55321" translate="yes" xml:space="preserve">
          <source>Library search sequence</source>
          <target state="translated">도서관 검색 순서</target>
        </trans-unit>
        <trans-unit id="141acdd651d31f900ce141517e6e5b768c6f9865" translate="yes" xml:space="preserve">
          <source>Library support for the Kotlin annotation facility.</source>
          <target state="translated">Kotlin 주석 기능에 대한 라이브러리 지원</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ca0dc8586d3cb640a4422d4f36e3b18f79a2fc2" translate="yes" xml:space="preserve">
          <source>Like Java's, Kotlin's generics are not retained at runtime, i.e. objects do not carry information about actual type arguments passed to their constructors, i.e. &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; is indistinguishable from &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt;. This makes it impossible to perform &lt;em&gt;is&lt;/em&gt;-checks that take generics into account. Kotlin only allows &lt;em&gt;is&lt;/em&gt;-checks for star-projected generic types:</source>
          <target state="translated">Java와 마찬가지로 Kotlin의 제네릭은 런타임에 유지되지 않습니다. 즉 객체는 생성자에 전달 된 실제 유형 인수에 대한 정보를 전달하지 않습니다. 즉 &lt;code&gt;ArrayList&amp;lt;Integer&amp;gt;()&lt;/code&gt; 는 &lt;code&gt;ArrayList&amp;lt;Character&amp;gt;()&lt;/code&gt; 구별 할 수 없습니다 . 이것은 불가능 수행하기가 만드는 &lt;em&gt;것입니다&lt;/em&gt; 계정으로 제네릭을 -checks. 단지 수 있습니다 코 틀린은 &lt;em&gt;이다&lt;/em&gt; 스타 투영 일반적인 유형의 -checks :</target>
        </trans-unit>
        <trans-unit id="d1e9786250417dc0913291ad74e3ec7573630368" translate="yes" xml:space="preserve">
          <source>Like any other Gradle projects, Kotlin/JS projects support traditional Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/declaring_dependencies.html&quot;&gt;dependency declarations&lt;/a&gt; in the &lt;code&gt;dependencies&lt;/code&gt; section of the build script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134fca0c09908f36860692b90dc834d35d2666e9" translate="yes" xml:space="preserve">
          <source>Like in Python, functions in Kotlin are first-class values - they can be assigned to variables and passed around as parameters. The type a function is a &lt;em&gt;function type&lt;/em&gt;, which is indicated with a parenthesized parameter type list and an arrow to the return type. Consider this function:</source>
          <target state="translated">Python과 마찬가지로 Kotlin의 함수는 일류 값입니다. 변수에 할당하고 매개 변수로 전달할 수 있습니다. &lt;em&gt;함수 유형&lt;/em&gt; 은 &lt;em&gt;함수 유형&lt;/em&gt; 이며 괄호로 묶은 매개 변수 유형 목록과 리턴 유형에 대한 화살표로 표시됩니다. 이 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4ddd56354c9749dcb1f4e69de6ab93bcbbe060ca" translate="yes" xml:space="preserve">
          <source>Like in Python, statements may be terminated by a semicolon, but it's discouraged. There is no line continuation character; instead, a line is automatically joined with one or more of the subsequent lines if that's the only way to make the code parse correctly. In practice, that means that a statement continues on the next line if we're inside an open parenthesis (like in Python), or if the line ends with a &quot;dangling operator&quot; (unlike in Python) or the following line doesn't parse unless it's joined to the previous one (also unlike in Python). Note that this is pretty much &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;the opposite of JavaScript&lt;/a&gt;, which generally will keep joining lines as long as the resulting code still parses. Thus, the following is two expressions in Kotlin and in Python (because &lt;code&gt;+&lt;/code&gt; can be unary, so the second line parses on its own), but one in JavaScript:</source>
          <target state="translated">파이썬에서와 같이 문장은 세미콜론으로 끝날 수 있지만 권장하지 않습니다. 줄 연속 문자가 없습니다. 대신 코드가 올바르게 구문 분석 할 수있는 유일한 방법 인 경우 하나 이상의 후속 행과 함께 행이 자동으로 결합됩니다. 실제로 이것은 파이썬에서와 같이 열린 괄호 안에 있거나 줄이 &quot;댕글 링 연산자&quot;(파이썬에서와 달리)로 끝나거나 다음 줄이 그렇지 않으면 다음 줄에서 계속됩니다. 이전과 결합되지 않은 경우 구문 분석하십시오 (Python과 달리). 이것은 &lt;a href=&quot;https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi#2846298&quot;&gt;JavaScript&lt;/a&gt; 와 거의 반대입니다 . 결과 코드가 여전히 구문 분석되는 한 일반적으로 줄을 계속 연결합니다. 따라서 다음은 Kotlin과 Python에서 두 가지 표현입니다 ( &lt;code&gt;+&lt;/code&gt; 단항 일 수 있으므로 두 번째 줄은 자체적으로 구문 분석되지만 JavaScript에서는 하나입니다.</target>
        </trans-unit>
        <trans-unit id="36d262d6365f0d350e9446c742577b066fb40895" translate="yes" xml:space="preserve">
          <source>Like in Python, you can write &lt;em&gt;lambda expressions&lt;/em&gt;: unnamed function declarations with a very compact syntax, which evaluate to callable function objects. In Kotlin, lambdas can contain multiple statements, which make them useful for &lt;a href=&quot;functional-programming#receivers&quot;&gt;more complex tasks&lt;/a&gt; than the single-expression lambdas of Python. The last statement must be an expression, whose result will become the return value of the lambda (unless &lt;code&gt;Unit&lt;/code&gt; is the return type of the variable/parameter that the lambda expression is assigned to, in which case the lambda has no return value). A lambda expression is enclosed in curly braces, and begins by listing its parameter names and possibly their types (unless the types can be inferred from context):</source>
          <target state="translated">파이썬에서와 같이 &lt;em&gt;람다 식을&lt;/em&gt; 작성할 수 있습니다 . 호출 가능한 함수 객체로 평가되는 매우 간단한 구문으로 명명되지 않은 함수 선언입니다. Kotlin에서 람다는 여러 명령문을 포함 할 수 있으므로 단일 표현식 람다보다 &lt;a href=&quot;functional-programming#receivers&quot;&gt;복잡한 작업에&lt;/a&gt; 유용합니다 . 마지막 명령문은 표현식이어야하며 결과는 람다의 리턴 값이됩니다 ( &lt;code&gt;Unit&lt;/code&gt; 가 람다 표현식이 지정된 변수 / 매개 변수의 리턴 유형이 아닌 경우 람다는 리턴 값이 없음). 람다 식은 중괄호로 묶고 매개 변수 이름과 가능한 형식을 나열하여 시작합니다 (형식이 컨텍스트에서 유추되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="4ee83e74db24116986fa00ee2921b9703634e255" translate="yes" xml:space="preserve">
          <source>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</source>
          <target state="translated">숫자와 마찬가지로 널 입력 가능 참조가 필요할 때 문자가 상자로 표시됩니다. 복싱 작업으로 ID가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc3b674f534270e494afa035103eb57b636704df" translate="yes" xml:space="preserve">
          <source>Likewise, if a multiplatform library is published in the experimental &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle metadata publishing mode&lt;/a&gt; and the project is set up to consume the metadata as well, then it is enough to specify a dependency only once, for the common source set. Otherwise, each platform-specific source set should be provided with a corresponding platform module of the library, in addition to the common module, as shown above.</source>
          <target state="translated">마찬가지로 멀티 플랫폼 라이브러리가 실험적인 &lt;a href=&quot;#experimental-metadata-publishing-mode&quot;&gt;Gradle 메타 데이터 게시 모드로 게시&lt;/a&gt; 되고 프로젝트가 메타 데이터도 사용하도록 설정된 경우 공통 소스 세트에 대해 종속성을 한 번만 지정하면 충분합니다. 그렇지 않은 경우, 각 플랫폼 별 소스 세트에는 위에 표시된대로 공통 모듈 외에 라이브러리의 해당 플랫폼 모듈이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="f8233d6f380a149df94d518228f2e14afd396052" translate="yes" xml:space="preserve">
          <source>Linear search</source>
          <target state="translated">선형 검색</target>
        </trans-unit>
        <trans-unit id="b867f8dc43342a216856620ba5a0d8c96b534757" translate="yes" xml:space="preserve">
          <source>Link the library into the application</source>
          <target state="translated">라이브러리를 응용 프로그램에 연결</target>
        </trans-unit>
        <trans-unit id="51115a9035c7b2d5f77a89ba3f71882db009bed6" translate="yes" xml:space="preserve">
          <source>Link with the library. To learn about using libraries in Kotlin/native projects, see &lt;a href=&quot;native/libraries&quot;&gt;Kotlin/Native libraries&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0084b300581a4369f50268c2c401f96431ea7f31" translate="yes" xml:space="preserve">
          <source>LinkStyle</source>
          <target state="translated">LinkStyle</target>
        </trans-unit>
        <trans-unit id="07410b317023eeb58eba0c065fa4e8416575a68f" translate="yes" xml:space="preserve">
          <source>LinkedHashMap</source>
          <target state="translated">LinkedHashMap</target>
        </trans-unit>
        <trans-unit id="9e6a957a7c69081b233af13d7e01702499988584" translate="yes" xml:space="preserve">
          <source>LinkedHashSet</source>
          <target state="translated">LinkedHashSet</target>
        </trans-unit>
        <trans-unit id="778915b1ca69b860077b72be4fd2810162ac2e59" translate="yes" xml:space="preserve">
          <source>Linking to Elements</source>
          <target state="translated">요소에 연결</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="ff0484f6287dafcb08eb0a886ac73a7153824af7" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, MIPS, MIPS little endian, Raspberry Pi)</source>
          <target state="translated">Linux (x86_64, arm32, MIPS, MIPS 리틀 엔디안, 라즈베리 파이)</target>
        </trans-unit>
        <trans-unit id="c8306ed1ec95ef01523eab6c3a95dbeb9f6511fb" translate="yes" xml:space="preserve">
          <source>Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</source>
          <target state="translated">Linux (x86_64, arm32, arm64, MIPS, MIPS little endian)</target>
        </trans-unit>
        <trans-unit id="967dea98ac299ce02d355a430918fd09ccd9ae77" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430e92ad771f5c7d80b45e64d2d47aa39cd97e1b" translate="yes" xml:space="preserve">
          <source>Linux MIPS targets (&lt;code&gt;linuxMips32&lt;/code&gt; and &lt;code&gt;linuxMipsel32&lt;/code&gt;) require a Linux host. Other Linux targets can be built on any supported host;</source>
          <target state="translated">Linux MIPS 대상 ( &lt;code&gt;linuxMips32&lt;/code&gt; 및 &lt;code&gt;linuxMipsel32&lt;/code&gt; )에는 Linux 호스트가 필요합니다. 지원되는 모든 호스트에 다른 Linux 대상을 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11304ba6aa97ab18544ed05fda48e987cfe71d39" translate="yes" xml:space="preserve">
          <source>Linux on ARM64 platforms, for example, Raspberry Pi</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013bd415b99b4bdfce6cddaafa69bba3220fa741" translate="yes" xml:space="preserve">
          <source>Linux on MIPS platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ff9f10883bcb28fb147e475a8a0df8cd56c6a9" translate="yes" xml:space="preserve">
          <source>Linux on hard-float ARM (ARM32) platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c99b7625097db16217dc289034a1cae4cfdd98e" translate="yes" xml:space="preserve">
          <source>Linux on little-endian MIPS (mipsel) platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6493240830afc488468d930ec91963f82322598" translate="yes" xml:space="preserve">
          <source>Linux on x86_64 platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb299cccd6e6b52b05aad6a92f9e230c0c907cf" translate="yes" xml:space="preserve">
          <source>Linux: &lt;code&gt;libnative_api.h&lt;/code&gt; and &lt;code&gt;libnative.so&lt;/code&gt;</source>
          <target state="translated">Linux : &lt;code&gt;libnative_api.h&lt;/code&gt; 및 &lt;code&gt;libnative.so&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="1cf922153258f477bc71540c57fe2b01a501cd22" translate="yes" xml:space="preserve">
          <source>List Specific Operations</source>
          <target state="translated">특정 작업 목록</target>
        </trans-unit>
        <trans-unit id="a159771f6ea4355d13f8450d01c0373e1562c782" translate="yes" xml:space="preserve">
          <source>List elements (including nulls) can duplicate: a list can contain any number of equal objects or occurrences of a single object. Two lists are considered equal if they have the same sizes and &lt;a href=&quot;equality#structural-equality&quot;&gt;structurally equal&lt;/a&gt; elements at the same positions.</source>
          <target state="translated">목록 요소 (널 포함)는 복제 할 수 있습니다. 목록은 동일한 수의 동일한 객체 또는 단일 객체의 발생을 포함 할 수 있습니다. 동일한 위치에 동일한 크기와 &lt;a href=&quot;equality#structural-equality&quot;&gt;구조적으로 동일한&lt;/a&gt; 요소 가있는 경우 두 목록은 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="06c25d6b7dd57683933b41c5deaf09d2d0ac5990" translate="yes" xml:space="preserve">
          <source>List iterators</source>
          <target state="translated">반복자 목록</target>
        </trans-unit>
        <trans-unit id="b7bfa71d045baf9d165ce17f80e019c5294d5073" translate="yes" xml:space="preserve">
          <source>List the available hardware targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c411381841a95d683318d92c209a2833825015" translate="yes" xml:space="preserve">
          <source>List write operations</source>
          <target state="translated">쓰기 작업 목록</target>
        </trans-unit>
        <trans-unit id="7c5f57edf1aaa5196cbc6ba79770c80aef15f3e5" translate="yes" xml:space="preserve">
          <source>List.listIterator</source>
          <target state="translated">List.listIterator</target>
        </trans-unit>
        <trans-unit id="48fb7de1e7f4ec62a77ab4aa73ec82916ebe8c3e" translate="yes" xml:space="preserve">
          <source>ListIterator</source>
          <target state="translated">ListIterator</target>
        </trans-unit>
        <trans-unit id="a204aa282b7f9617db30e92246b8efaf427d19cd" translate="yes" xml:space="preserve">
          <source>Lists also offer a function to replace an element at a given position - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; and its operator form &lt;code&gt;[]&lt;/code&gt;. &lt;code&gt;set()&lt;/code&gt; doesn't change the indexes of other elements.</source>
          <target state="translated">리스트는 또한 주어진 위치에서 요소를 대체하는 함수를 제공합니다. &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 과 연산자 형태 &lt;code&gt;[]&lt;/code&gt; . &lt;code&gt;set()&lt;/code&gt; 은 다른 요소의 인덱스를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5a0dae9f70ca77cfff82765784d806c80043676" translate="yes" xml:space="preserve">
          <source>Lists and maps also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">목록과 맵은 요소 업데이트 작업도 제공합니다. &lt;a href=&quot;list-operations&quot;&gt;특정 작업 나열&lt;/a&gt; 및 &lt;a href=&quot;map-operations&quot;&gt;특정 작업 매핑&lt;/a&gt; 에서 설명 합니다. 세트의 경우 실제로 요소를 제거하고 다른 요소를 추가하기 때문에 업데이트가 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="290d0482de491a9f1d45c4e717b747b40f336dfe" translate="yes" xml:space="preserve">
          <source>Lists and sets also provide operations for updating elements. They are described in &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; and &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations&lt;/a&gt;. For sets, updating doesn't make sense since it's actually removing an element and adding another one.</source>
          <target state="translated">목록과 집합은 또한 요소 업데이트를위한 작업을 제공합니다. 이에 대해서는 &lt;a href=&quot;list-operations&quot;&gt;List Specific Operations&lt;/a&gt; 및 &lt;a href=&quot;map-operations&quot;&gt;Map Specific Operations에&lt;/a&gt; 설명되어 있습니다. 세트의 경우 업데이트는 실제로 요소를 제거하고 다른 요소를 추가하기 때문에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f70b0e65f09114560be2730b53b6dbbae2e2bd80" translate="yes" xml:space="preserve">
          <source>Lists support all common operations for element retrieval: &lt;code&gt;elementAt()&lt;/code&gt;, &lt;code&gt;first()&lt;/code&gt;, &lt;code&gt;last()&lt;/code&gt;, and others listed in &lt;a href=&quot;collection-elements&quot;&gt;Retrieving Single Elements&lt;/a&gt;. What is specific for lists is index access to the elements, so the simplest way to read an element is retrieving it by index. That is done with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; function with the index passed in the argument or the shorthand &lt;code&gt;[index]&lt;/code&gt; syntax.</source>
          <target state="translated">리스트는 &lt;code&gt;elementAt()&lt;/code&gt; , &lt;code&gt;first()&lt;/code&gt; , &lt;code&gt;last()&lt;/code&gt; 및 &lt;a href=&quot;collection-elements&quot;&gt;단일 요소 검색에&lt;/a&gt; 나열된 기타 요소 검색에 대한 모든 공통 조작을 지원합니다 . 목록에 특정한 것은 요소에 대한 인덱스 액세스이므로 요소를 읽는 가장 간단한 방법은 인덱스로 요소를 검색하는 것입니다. 인수 또는 속기 &lt;code&gt;[index]&lt;/code&gt; 구문으로 전달 된 색인으로 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b8cc7b0ac11bf88cf97ed5fc81444ae44893988" translate="yes" xml:space="preserve">
          <source>Literal Constants</source>
          <target state="translated">리터럴 상수</target>
        </trans-unit>
        <trans-unit id="4da0019bff16f0b757af8c7d691632f05ab7ce73" translate="yes" xml:space="preserve">
          <source>Literal constants</source>
          <target state="translated">리터럴 상수</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="a354c605a19a501459267f5d2d15e3813a2622ea" translate="yes" xml:space="preserve">
          <source>Local Delegated Properties (since 1.1)</source>
          <target state="translated">로컬 위임 속성 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="f5689c7ad8ad393161f3aa4e09dcfcbe8dae0b7c" translate="yes" xml:space="preserve">
          <source>Local Functions</source>
          <target state="translated">지역 기능</target>
        </trans-unit>
        <trans-unit id="d7250510c8081d4daaa6df727eb914db9c33da3c" translate="yes" xml:space="preserve">
          <source>Local annotation classes</source>
          <target state="translated">지역 주석 클래스</target>
        </trans-unit>
        <trans-unit id="69ebd822a58983be422bb598dba3c478ccd777d9" translate="yes" xml:space="preserve">
          <source>Local declarations</source>
          <target state="translated">지역 선언</target>
        </trans-unit>
        <trans-unit id="a1899e5981d8e839cbbac5a4b6b87631ee259818" translate="yes" xml:space="preserve">
          <source>Local delegated properties</source>
          <target state="translated">로컬 위임 속성</target>
        </trans-unit>
        <trans-unit id="bcdcbb7562bc0be9df365ffa539169787154eb55" translate="yes" xml:space="preserve">
          <source>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the &lt;em&gt;visited&lt;/em&gt; can be a local variable:</source>
          <target state="translated">로컬 함수는 외부 함수의 로컬 변수 (예 : 클로저)에 액세스 할 수 있으므로 위의 경우 &lt;em&gt;방문한&lt;/em&gt; 로컬 변수가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c81d1a5213298e456992ce397aa51ab435e7f9b2" translate="yes" xml:space="preserve">
          <source>Local functions</source>
          <target state="translated">지역 기능</target>
        </trans-unit>
        <trans-unit id="7a8cbb48d88b807f7bfba9d309d29524b5f02383" translate="yes" xml:space="preserve">
          <source>Local variable</source>
          <target state="translated">지역 변수</target>
        </trans-unit>
        <trans-unit id="e41667e2ac3ba5cde0fdffb1b6bacda9d66718d9" translate="yes" xml:space="preserve">
          <source>Local variables are typically declared and initialized at the same time, in which case the type of the variable is &lt;em&gt;inferred&lt;/em&gt; to be the type of the expression you initialize it with:</source>
          <target state="translated">지역 변수는 일반적으로 선언하고 변수의 타입이되는 경우에 같은 시간에 초기화 &lt;em&gt;유추&lt;/em&gt; 당신이 초기화 식의 유형으로 :</target>
        </trans-unit>
        <trans-unit id="ac8a58b4422a8352e1dd6a3c1ee5296717d9a865" translate="yes" xml:space="preserve">
          <source>Local variables, functions and classes can not have visibility modifiers.</source>
          <target state="translated">지역 변수, 함수 및 클래스는 가시성 수정자를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a78aea5b0abb85e3e611fbf1ec8a29dd64f3f7a3" translate="yes" xml:space="preserve">
          <source>LocaleOptions</source>
          <target state="translated">LocaleOptions</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="d42ac4c4f265835ce678f6a048de877eecd3678f" translate="yes" xml:space="preserve">
          <source>Location of Kotlin source files inside the source set directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="178313af6182f9b545c1f11580b0d5590fb118f3" translate="yes" xml:space="preserve">
          <source>Location of resources inside the source set directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a56ee9bffd6aa6b4bd69f9a8fcf34ef4736447e" translate="yes" xml:space="preserve">
          <source>Locks are used to ensure that only a single thread can initialize the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">잠금은 단일 스레드 만 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 초기화 할 수 있도록하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0003a9c1d32ac7d8fddd983e062e51e3d0daa934" translate="yes" xml:space="preserve">
          <source>Logarithms: &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;ln&lt;/code&gt;, &lt;code&gt;ln1p&lt;/code&gt;;</source>
          <target state="translated">로그 : &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;log2&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;ln&lt;/code&gt; , &lt;code&gt;ln1p&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3496a775372b202cf19086b7723a8ba07a1c1c15" translate="yes" xml:space="preserve">
          <source>Logos can be downloaded &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;here&lt;/a&gt;. When using the logos, please follow simple rules in the &lt;code&gt;guidelines.pdf&lt;/code&gt; inside the archive and &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin brand usage guidelines&lt;/a&gt;.</source>
          <target state="translated">로고는 &lt;a href=&quot;https://resources.jetbrains.com/storage/products/kotlin/docs/kotlin_logos.zip&quot;&gt;여기에서&lt;/a&gt; 다운로드 할 수 있습니다 . 로고를 사용하는 경우 아카이브 및 &lt;a href=&quot;https://kotlinlang.org/foundation/guidelines.html&quot;&gt;Kotlin 브랜드 사용 가이드 &lt;/a&gt; &lt;code&gt;guidelines.pdf&lt;/code&gt; 안에있는 Guidelines.pdf의 간단한 규칙을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="3171584f38872fa4d8f17811d91544f7756eaffd" translate="yes" xml:space="preserve">
          <source>Lombok (&lt;code&gt;lombok.NonNull&lt;/code&gt;).</source>
          <target state="translated">롬복 ( &lt;code&gt;lombok.NonNull&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="11eda67f9b15a760342f8e98a3fc78d8d3ea9945" translate="yes" xml:space="preserve">
          <source>Long</source>
          <target state="translated">Long</target>
        </trans-unit>
        <trans-unit id="28da0e058738129fbcd7e6f45b76bc71f8a53660" translate="yes" xml:space="preserve">
          <source>LongArray</source>
          <target state="translated">LongArray</target>
        </trans-unit>
        <trans-unit id="4fccaadf63b5fc52428c158f51d57e23e947d24e" translate="yes" xml:space="preserve">
          <source>LongIterator</source>
          <target state="translated">LongIterator</target>
        </trans-unit>
        <trans-unit id="5845d554e07454310db9770fb728d9756ce6dae1" translate="yes" xml:space="preserve">
          <source>LongProgression</source>
          <target state="translated">LongProgression</target>
        </trans-unit>
        <trans-unit id="4fb8ec4ef48e7913a58002b0e63b73c29bff9f39" translate="yes" xml:space="preserve">
          <source>LongRange</source>
          <target state="translated">LongRange</target>
        </trans-unit>
        <trans-unit id="0b1c8c87dc520b4e01071e91d1f6a9ceb7e0e408" translate="yes" xml:space="preserve">
          <source>LongVar</source>
          <target state="translated">LongVar</target>
        </trans-unit>
        <trans-unit id="181cf892b1895d898b9744877c740407129f49dc" translate="yes" xml:space="preserve">
          <source>LongVarOf</source>
          <target state="translated">LongVarOf</target>
        </trans-unit>
        <trans-unit id="fd6299f672ee9cc3b8def57411eb0d0d9a44147d" translate="yes" xml:space="preserve">
          <source>Longs are tagged by a capital &lt;code&gt;L&lt;/code&gt;: &lt;code&gt;123L&lt;/code&gt;</source>
          <target state="translated">Long은 대문자 &lt;code&gt;L&lt;/code&gt; : &lt;code&gt;123L&lt;/code&gt; 로 태그됩니다</target>
        </trans-unit>
        <trans-unit id="3e38e907fc0523189431e466a50de278a09267fc" translate="yes" xml:space="preserve">
          <source>Looking for more APIs? It is easy to create a &lt;a href=&quot;../multiplatform-library&quot;&gt;multiplatform library&lt;/a&gt; and share it!</source>
          <target state="translated">더 많은 API를 찾고 계십니까? &lt;a href=&quot;../multiplatform-library&quot;&gt;멀티 플랫폼 라이브러리&lt;/a&gt; 를 작성 하고 공유 하기가 쉽습니다 !</target>
        </trans-unit>
        <trans-unit id="0c661eae6b65f74e27c40369060777e2f1a666bd" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;inc()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters, applicable to the receiver of type &lt;code&gt;T&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 수신자에게 적용 가능한 매개 변수없이 &lt;code&gt;operator&lt;/code&gt; 수정자를 사용하여 &lt;code&gt;inc()&lt;/code&gt; 함수를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="06f3cb08bca38254cb72407f33d24848ac5110e5" translate="yes" xml:space="preserve">
          <source>Looks up a function &lt;code&gt;unaryPlus()&lt;/code&gt; with the &lt;code&gt;operator&lt;/code&gt; modifier and no parameters for the receiver &lt;code&gt;T&lt;/code&gt;, i.e. a member function or an extension function;</source>
          <target state="translated">함수 보인다 &lt;code&gt;unaryPlus()&lt;/code&gt; 와 &lt;code&gt;operator&lt;/code&gt; 개질제 및 수신기에 대한 매개 변수 &lt;code&gt;T&lt;/code&gt; , 즉 멤버 함수 또는 신장 기능;</target>
        </trans-unit>
        <trans-unit id="02720f9d38bf4f35e84ed5228689898bee176418" translate="yes" xml:space="preserve">
          <source>Loops</source>
          <target state="translated">Loops</target>
        </trans-unit>
        <trans-unit id="4c2bd8b7625ef46e049dcc97f3e97069511fe26a" translate="yes" xml:space="preserve">
          <source>Loops on ranges</source>
          <target state="translated">범위의 루프</target>
        </trans-unit>
        <trans-unit id="60369ad7d8b48a14f3d191172cf41bcfb71741f2" translate="yes" xml:space="preserve">
          <source>Low-level building blocks for libraries that provide coroutine-based APIs.</source>
          <target state="translated">코 루틴 기반 API를 제공하는 라이브러리의 저수준 빌딩 블록.</target>
        </trans-unit>
        <trans-unit id="33c64772edef0388f14ce1b4adb0c6c1bb1aa8e4" translate="yes" xml:space="preserve">
          <source>Luckily, Kotlin has got &lt;em&gt;reified type parameters&lt;/em&gt;, which alleviates some of these problems. By writing &lt;code&gt;reified&lt;/code&gt; in front of a generic type parameter, it does become available at runtime, and you'll get to write &lt;code&gt;T::class&lt;/code&gt; to get the &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;class metadata&lt;/a&gt;. You can only do this in inline functions (because an inline function will be compiled into its callsite, where the type information &lt;em&gt;is&lt;/em&gt; available at runtime), but it still goes a long way. For example, you can make an inline wrapper function for a big function that has got a less elegant signature.</source>
          <target state="translated">운 좋게도 Kotlin은 &lt;em&gt;유형 매개 변수를 수정&lt;/em&gt; 하여 이러한 문제 중 일부를 완화했습니다. 제네릭 형식 매개 변수 앞에 &lt;code&gt;reified&lt;/code&gt; 를 작성 하면 런타임에 사용할 수 있게되고 &lt;a href=&quot;member-references-and-reflection#obtaining-member-references-from-a-class-reference&quot;&gt;클래스 메타 데이터&lt;/a&gt; 를 가져 오기 위해 &lt;code&gt;T::class&lt;/code&gt; 를 작성하게 됩니다. 인라인 함수에서만이 작업을 수행 할 수 있습니다 (인라인 함수는 런타임에 유형 정보 &lt;em&gt;를&lt;/em&gt; 사용할 수 있는 콜 사이트로 컴파일되기 때문에 ). 예를 들어 덜 우아한 서명을 가진 큰 함수에 대해 인라인 랩퍼 함수를 ​​작성할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc6e5580de3bf07607e19a673cd1f05b259b2bd" translate="yes" xml:space="preserve">
          <source>MACOSX</source>
          <target state="translated">MACOSX</target>
        </trans-unit>
        <trans-unit id="c8341a27b6d81ce4872ef2e5c74c71c1fa656185" translate="yes" xml:space="preserve">
          <source>MATH_SYMBOL</source>
          <target state="translated">MATH_SYMBOL</target>
        </trans-unit>
        <trans-unit id="ccd2cb474249294edd8d61576efe0ac7d7c17d4c" translate="yes" xml:space="preserve">
          <source>MAX_CODE_POINT</source>
          <target state="translated">MAX_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="1a9fd1b3912908145111964e328d77ecf366fc06" translate="yes" xml:space="preserve">
          <source>MAX_COMPONENT_VALUE</source>
          <target state="translated">MAX_COMPONENT_VALUE</target>
        </trans-unit>
        <trans-unit id="6a3f20e248cb8672ba053480b2e5604ed15471fb" translate="yes" xml:space="preserve">
          <source>MAX_HIGH_SURROGATE</source>
          <target state="translated">MAX_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="93b95c89e3f09a5c822039fdb274e4e9543f7b4d" translate="yes" xml:space="preserve">
          <source>MAX_LOW_SURROGATE</source>
          <target state="translated">MAX_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="723df4d178ea35581b90fb4dff97fa4d9e1295a6" translate="yes" xml:space="preserve">
          <source>MAX_RADIX</source>
          <target state="translated">MAX_RADIX</target>
        </trans-unit>
        <trans-unit id="e1273ad446270c0c9cf3fd5cad44848e8250ffba" translate="yes" xml:space="preserve">
          <source>MAX_SURROGATE</source>
          <target state="translated">MAX_SURROGATE</target>
        </trans-unit>
        <trans-unit id="24fdbf54e8bc77709b6bd7478c1804e90d84d0ca" translate="yes" xml:space="preserve">
          <source>MAX_VALUE</source>
          <target state="translated">MAX_VALUE</target>
        </trans-unit>
        <trans-unit id="030147a88935a9397a9625c627fb1af71a30209e" translate="yes" xml:space="preserve">
          <source>MF</source>
          <target state="translated">MF</target>
        </trans-unit>
        <trans-unit id="784a46c14fea9ff3fb4d5c790913e2db7292c56e" translate="yes" xml:space="preserve">
          <source>MICROSECONDS</source>
          <target state="translated">MICROSECONDS</target>
        </trans-unit>
        <trans-unit id="370c3ba851aaa71b93e5d791ecaddbf60722fede" translate="yes" xml:space="preserve">
          <source>MILLISECONDS</source>
          <target state="translated">MILLISECONDS</target>
        </trans-unit>
        <trans-unit id="9c200cc936c861cebaa3fc9dbe92407a4a2f6d99" translate="yes" xml:space="preserve">
          <source>MINUTES</source>
          <target state="translated">MINUTES</target>
        </trans-unit>
        <trans-unit id="c93eded712b6299da78db6d4eb86c71d455d7389" translate="yes" xml:space="preserve">
          <source>MIN_CODE_POINT</source>
          <target state="translated">MIN_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="a8865ad11853a6b46e09f6d1cdddfd073f7d4851" translate="yes" xml:space="preserve">
          <source>MIN_HIGH_SURROGATE</source>
          <target state="translated">MIN_HIGH_SURROGATE</target>
        </trans-unit>
        <trans-unit id="bd2ef64ddf3863a50e14b7b72bf632b54603d300" translate="yes" xml:space="preserve">
          <source>MIN_LOW_SURROGATE</source>
          <target state="translated">MIN_LOW_SURROGATE</target>
        </trans-unit>
        <trans-unit id="91631ed7ebe4f66d93a855f168fd993a18bbb9ae" translate="yes" xml:space="preserve">
          <source>MIN_RADIX</source>
          <target state="translated">MIN_RADIX</target>
        </trans-unit>
        <trans-unit id="ff3ed914be4d85796f20ffe750d11ae41f0c093d" translate="yes" xml:space="preserve">
          <source>MIN_SUPPLEMENTARY_CODE_POINT</source>
          <target state="translated">MIN_SUPPLEMENTARY_CODE_POINT</target>
        </trans-unit>
        <trans-unit id="5aa1c9c7ed6ef1169c3e694d2e0558e797993672" translate="yes" xml:space="preserve">
          <source>MIN_SURROGATE</source>
          <target state="translated">MIN_SURROGATE</target>
        </trans-unit>
        <trans-unit id="ac7a7603646aca67877b81e10b36687c24f7d10a" translate="yes" xml:space="preserve">
          <source>MIN_VALUE</source>
          <target state="translated">MIN_VALUE</target>
        </trans-unit>
        <trans-unit id="9028a909c025cf9d16590fd055950504b793f600" translate="yes" xml:space="preserve">
          <source>MIPS32</source>
          <target state="translated">MIPS32</target>
        </trans-unit>
        <trans-unit id="ac1d1ed5dec64feab585fa1220864d5680a5811e" translate="yes" xml:space="preserve">
          <source>MIPSEL32</source>
          <target state="translated">MIPSEL32</target>
        </trans-unit>
        <trans-unit id="7b5afc2e6529ad3bd8e57a7791978e690003bcdd" translate="yes" xml:space="preserve">
          <source>MODIFIER_LETTER</source>
          <target state="translated">MODIFIER_LETTER</target>
        </trans-unit>
        <trans-unit id="8f6a3829c268c3a50caa5a3744901aba89c88358" translate="yes" xml:space="preserve">
          <source>MODIFIER_SYMBOL</source>
          <target state="translated">MODIFIER_SYMBOL</target>
        </trans-unit>
        <trans-unit id="84757851065b4eb5ddf781037790225276f37d3e" translate="yes" xml:space="preserve">
          <source>MULTILINE</source>
          <target state="translated">MULTILINE</target>
        </trans-unit>
        <trans-unit id="37a6f811775e72996553c62c5ef2ab8e4e658bea" translate="yes" xml:space="preserve">
          <source>MacOS (x86_64)</source>
          <target state="translated">맥 OS (x86_64)</target>
        </trans-unit>
        <trans-unit id="07a4d61f0acbbb95318a8a2d2e1f3a3b76934273" translate="yes" xml:space="preserve">
          <source>MacPorts</source>
          <target state="translated">MacPorts</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="9c574760a1e8c967bc35e78752b8950efd331477" translate="yes" xml:space="preserve">
          <source>Make frameworks static when using rebuild from bitcode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22d87ecdb73737e3e9e79d9b2b16c5c79a06654" translate="yes" xml:space="preserve">
          <source>Make sure its return type is &lt;code&gt;Unit&lt;/code&gt;, and report an error otherwise,</source>
          <target state="translated">반환 유형이 &lt;code&gt;Unit&lt;/code&gt; 인지 확인하고 그렇지 않으면 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="2fba991ad8d6b5e98b20f4c1f0a7d640d19bbf4f" translate="yes" xml:space="preserve">
          <source>Make sure that you have CocoaPods &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;installed&lt;/a&gt;. We recommend using CocoaPods 1.6.1 or later.</source>
          <target state="translated">CocoaPods가 &lt;a href=&quot;https://guides.cocoapods.org/using/getting-started.html#installation&quot;&gt;설치되어&lt;/a&gt; 있는지 확인하십시오 . CocoaPods 1.6.1 이상을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4666c5046e05de3ced6688314c5b8b2fdc5e809d" translate="yes" xml:space="preserve">
          <source>Make sure that you import the &lt;code&gt;react.dom.*&lt;/code&gt; and &lt;code&gt;styled.*&lt;/code&gt; packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46d38a6352744d726ba87d5e2a3fe0550a5b018" translate="yes" xml:space="preserve">
          <source>Make sure that you import the package &lt;code&gt;kotlinx.html.js.*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872ea4c8c9e3e67462cf45519bbed3ec439a01dd" translate="yes" xml:space="preserve">
          <source>Make sure that you load the &lt;code&gt;kotlin.js&lt;/code&gt; runtime first, and then your application.</source>
          <target state="translated">먼저 &lt;code&gt;kotlin.js&lt;/code&gt; 런타임 을로드 한 다음 애플리케이션 을로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="5aa48b84880f06c505b8b4e3340f284931cef8e6" translate="yes" xml:space="preserve">
          <source>Make sure that your declared annotation has a proper annotation target (Java&amp;rsquo;s &lt;code&gt;ElementType.TYPE_USE&lt;/code&gt; or Kotlin&amp;rsquo;s &lt;code&gt;AnnotationTarget.TYPE&lt;/code&gt;) and retention (&lt;code&gt;AnnotationRetention.RUNTIME&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5ad277768300cd65b74ec021eb800da7b06237" translate="yes" xml:space="preserve">
          <source>Make updating to new versions comfortable for the users.</source>
          <target state="translated">사용자에게 편안한 새 버전으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f677748d219b353836ae9469d4c8eb0bcdf46ffb" translate="yes" xml:space="preserve">
          <source>Makes Kotlin method in Objective-C class accessible through Objective-C dispatch to be used as action sent by control in UIKit or AppKit.</source>
          <target state="translated">Objective-C 디스패치를 ​​통해 Objective-C 클래스의 Kotlin 메소드에 액세스하여 UIKit 또는 AppKit의 제어에 의해 전송 된 조치로 사용되도록합니다.</target>
        </trans-unit>
        <trans-unit id="09f808d1435cc07cd95f3ecbee1a2efed0c87454" translate="yes" xml:space="preserve">
          <source>Makes Kotlin property in Objective-C class settable through Objective-C dispatch to be used as IB outlet.</source>
          <target state="translated">Objective-C 디스패치를 ​​통해 Objective-C 클래스의 Kotlin 속성을 IB 콘센트로 사용할 수 있도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="79cbb2384899cfe766ce2633e3ff22d2f36982b6" translate="yes" xml:space="preserve">
          <source>Makes Kotlin subclass of Objective-C class visible for runtime lookup after Kotlin &lt;code&gt;main&lt;/code&gt; function gets invoked.</source>
          <target state="translated">Kotlin &lt;code&gt;main&lt;/code&gt; 함수가 호출 된 후 런타임 조회에 Objective-C 클래스의 Kotlin 서브 클래스를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="f35a32ffaf96633b14ae608748f888d188401daf" translate="yes" xml:space="preserve">
          <source>Makes call to the specified &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380302710c7a9c26b7742a1058f704b9bb0ef0a3" translate="yes" xml:space="preserve">
          <source>Makes recursive call to this &lt;a href=&quot;../-deep-recursive-function/index&quot;&gt;DeepRecursiveFunction&lt;/a&gt; function putting the call activation frame on the heap, as opposed to the actual call stack that is used by a regular recursive call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b5071a9847a34a44b37d8ab94597a0b604b867" translate="yes" xml:space="preserve">
          <source>Makes the annotated annotation class an associated object key.</source>
          <target state="translated">주석이 달린 주석 클래스를 연관된 객체 키로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c05c0a0b46c6d81aa3deae4e473b3f5b195d9dae" translate="yes" xml:space="preserve">
          <source>Makes top level function available from C/C++ code with the given name.</source>
          <target state="translated">주어진 이름으로 C / C ++ 코드에서 최상위 레벨 기능을 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="33733bb607beb4f5ed38e06a91a784c426296320" translate="yes" xml:space="preserve">
          <source>Making busy flow cancellable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc9b78fb75740d031749aa0e1f6c2f20915be09" translate="yes" xml:space="preserve">
          <source>Making computation code cancellable</source>
          <target state="translated">계산 코드를 취소 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="d26e8b17246e39f5acbd44ce84cfe44e4708e7bc" translate="yes" xml:space="preserve">
          <source>Making frequent null checks is annoying, so if you have to allow for the possibility of nulls, there are several very useful operators in Kotlin to ease working with values that might be null, as described below.</source>
          <target state="translated">빈번한 null 검사는 성가신 일이므로 null 가능성을 허용 해야하는 경우 Kotlin에는 아래에 설명 된 것처럼 null 일 수있는 값을 쉽게 사용할 수있는 몇 가지 매우 유용한 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35727fd1febb5955e04a96a85cfbf28b11e18a0" translate="yes" xml:space="preserve">
          <source>Malformed byte sequences are replaced by the replacement char &lt;code&gt;\uFFFD&lt;/code&gt;.</source>
          <target state="translated">잘못된 바이트 시퀀스는 교체 char &lt;code&gt;\uFFFD&lt;/code&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2aee73bd2e79677bed872d3980e254bec42f2c5" translate="yes" xml:space="preserve">
          <source>Managing dependencies</source>
          <target state="translated">의존성 관리</target>
        </trans-unit>
        <trans-unit id="f45216dfe5658802d5da85dd6691495f1dd5ee41" translate="yes" xml:space="preserve">
          <source>Managing sources</source>
          <target state="translated">소스 관리</target>
        </trans-unit>
        <trans-unit id="b0426429a44f47228605bdec162f6e1798c46d34" translate="yes" xml:space="preserve">
          <source>Managing targets</source>
          <target state="translated">대상 관리</target>
        </trans-unit>
        <trans-unit id="dc1586db5c7b55a74cd10223f2e3a7fe8bf95caa" translate="yes" xml:space="preserve">
          <source>Mangling</source>
          <target state="translated">Mangling</target>
        </trans-unit>
        <trans-unit id="76f58e9ae1ecc3bcd5734ccddd0e7976cd032c5b" translate="yes" xml:space="preserve">
          <source>Manual Configuration</source>
          <target state="translated">수동 구성</target>
        </trans-unit>
        <trans-unit id="724adbdc3ff0031b5c79ad867a79546b920a65f6" translate="yes" xml:space="preserve">
          <source>Manual Install</source>
          <target state="translated">수동 설치</target>
        </trans-unit>
        <trans-unit id="4892a25af3b45967112eda593c6c4ff560c25b52" translate="yes" xml:space="preserve">
          <source>Manually apply an Android Gradle plugin &amp;ndash; &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6d42d1875648e1f154683fe273a941e93a43bb" translate="yes" xml:space="preserve">
          <source>Manually generating external declarations via Gradle task</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a73e4ea7721ba692baf916576f5d262d09eb6e" translate="yes" xml:space="preserve">
          <source>Many modern IDEs support Kotlin and help in writing idiomatic Kotlin code:</source>
          <target state="translated">많은 최신 IDE가 Kotlin을 지원하고 관용적 인 Kotlin 코드 작성을 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="564f728d4accd1cab1faa6abd0808aa411a7afbc" translate="yes" xml:space="preserve">
          <source>Many of the options can also be configured through properties:</source>
          <target state="translated">속성을 통해 많은 옵션을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e10c89b0b0ca5be3c7b04daef4c60db7fc1b6f90" translate="yes" xml:space="preserve">
          <source>Many people already use &lt;a href=&quot;coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; for asynchronous programming. But when it came to debugging, working with coroutines before Kotlin 1.4, could be a real pain. Since coroutines jumped between threads, it was difficult to understand what a specific coroutine was doing and check its context. In some cases, tracking steps over breakpoints simply didn&amp;rsquo;t work. As a result, you had to rely on logging or mental effort to debug code that used coroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe81b734a40201fad1b163bd75e5e8866ba447fc" translate="yes" xml:space="preserve">
          <source>Many startups and Fortune 500 companies have already developed Android applications using Kotlin &amp;ndash; see the list at &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;the Google website for Kotlin developers&lt;/a&gt;.</source>
          <target state="translated">많은 신생 기업과 Fortune 500 대 기업이 이미 Kotlin을 사용하여 Android 애플리케이션을 &lt;a href=&quot;https://developer.android.com/kotlin&quot;&gt;개발했습니다&lt;/a&gt; . Kotlin 개발자 용 Google 웹 사이트 의 목록을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="1a3e682ff2754ef0b1db9651d934d18042efd51a" translate="yes" xml:space="preserve">
          <source>Map Specific Operations</source>
          <target state="translated">특정 작업지도</target>
        </trans-unit>
        <trans-unit id="8a55ba4dc9c56793f4d86eafccdf893ff4dfc510" translate="yes" xml:space="preserve">
          <source>Map nullable value if not null</source>
          <target state="translated">널이 아닌 경우 널 입력 가능 값 맵핑</target>
        </trans-unit>
        <trans-unit id="154baeb185088267d2e04dd13fb49c8faf1731b4" translate="yes" xml:space="preserve">
          <source>Map write operations</source>
          <target state="translated">지도 쓰기 작업</target>
        </trans-unit>
        <trans-unit id="7c78455b5524d54dd5717439fdd75a3564e3b05c" translate="yes" xml:space="preserve">
          <source>Map.getValue()</source>
          <target state="translated">Map.getValue()</target>
        </trans-unit>
        <trans-unit id="ab6d914f12b0209ae12f1eaa021fab679f71fbd9" translate="yes" xml:space="preserve">
          <source>Map.minus(key)</source>
          <target state="translated">Map.minus(key)</target>
        </trans-unit>
        <trans-unit id="a1e3b9de38695948c83390c6219ada2b49d0eb03" translate="yes" xml:space="preserve">
          <source>Map.toMap() and Map.toMutableMap()</source>
          <target state="translated">Map.toMap () 및 Map.toMutableMap ()</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="ae3c45c6220c54a755f63c613acc1f9b440f728e" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointer Types from C</source>
          <target state="translated">C에서 함수 포인터 유형 매핑</target>
        </trans-unit>
        <trans-unit id="3629da3c88dfc6308c1eb31a6616f2493b1b3a4a" translate="yes" xml:space="preserve">
          <source>Mapping Function Pointers from C</source>
          <target state="translated">C에서 함수 포인터 매핑</target>
        </trans-unit>
        <trans-unit id="1ab023f41f65f5d65722a6148006ad3ade089fb2" translate="yes" xml:space="preserve">
          <source>Mapping Primitive Data Types from C</source>
          <target state="translated">C에서 기본 데이터 유형 매핑</target>
        </trans-unit>
        <trans-unit id="d6b4467553c4b4c986cbd21872e97a3c8e8ea762" translate="yes" xml:space="preserve">
          <source>Mapping Strings from C</source>
          <target state="translated">C에서 문자열 매핑</target>
        </trans-unit>
        <trans-unit id="76a029f685d2ba76aaeecfdb2224f273ebee328a" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union C types</source>
          <target state="translated">구조 및 유니온 C 유형 매핑</target>
        </trans-unit>
        <trans-unit id="565e074c9f98132ef0f9b4a1395ca391399b5fc8" translate="yes" xml:space="preserve">
          <source>Mapping Struct and Union Types from C</source>
          <target state="translated">C에서 구조 및 결합 유형 매핑</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="4811d5bdec38d0b9bed7265f0e3355c78194b1ff" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 구현이 빠른 인덱스 액세스를 지원함을 나타내는 마커 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="79f92c6a2f9b55de94523a0137df26f32b271fc3" translate="yes" xml:space="preserve">
          <source>Marker interface indicating that the &lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; implementation supports fast indexed access.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.collections/-list/index#kotlin.collections.List&quot;&gt;List&lt;/a&gt; 구현이 빠른 인덱스 액세스를 지원함을 나타내는 마커 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="deb9ed7bb61b8698d73e57af565358059241e0bd" translate="yes" xml:space="preserve">
          <source>Marking API elements</source>
          <target state="translated">마킹 API 요소</target>
        </trans-unit>
        <trans-unit id="39acae63028d11938c7d9a75f3ad9099e5f79972" translate="yes" xml:space="preserve">
          <source>Marking experimental API</source>
          <target state="translated">실험용 API 마킹</target>
        </trans-unit>
        <trans-unit id="72ca39cc361248a73db4aa376ff098d3162e32bf" translate="yes" xml:space="preserve">
          <source>Marking rules: an implicit receiver is considered marked with @Ann if</source>
          <target state="translated">표시 규칙 : 암시 적 수신자는 @Ann으로 표시된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="86bad6d0089ea3bb1c0a2e322f9709163fa38969" translate="yes" xml:space="preserve">
          <source>Marks a point in time on this time source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4db1b9cfb765a0420560d33f4c49a590513a4d0" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field as immutable. It is possible to share the value of such property between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">지원 필드가있는 최상위 속성을 변경 불가능으로 표시합니다. 이러한 속성의 값을 여러 스레드간에 공유 할 수는 있지만 깊이 고정되어 해당 상태 또는 참조하는 개체의 상태를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a224cc22214be0edab83e29fa79b9dd2dd10f50f" translate="yes" xml:space="preserve">
          <source>Marks a top level property with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">지원 필드 또는 개체가있는 최상위 속성을 스레드 로컬로 표시합니다. 객체는 변경 가능한 상태로 유지되고 상태를 변경할 수 있지만 모든 스레드는이 객체의 고유 한 복사본을 가지므로 한 스레드의 변경 사항이 다른 스레드에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33d0711db8fea3ba5bf0ebfba79cfe0cf8264458" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as immutable. It is possible to share such object between multiple threads, but it becomes deeply frozen, so no changes can be made to its state or the state of objects it refers to.</source>
          <target state="translated">백킹 필드 또는 객체가있는 최상위 변수를 변경할 수없는 것으로 표시합니다. 이러한 스레드를 여러 스레드간에 공유 할 수는 있지만 완전히 고정되므로 상태 또는 참조하는 개체의 상태를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c86911fdb83bb1e6cafe3509aa437cd672c34a9" translate="yes" xml:space="preserve">
          <source>Marks a top level variable with a backing field or an object as thread local. The object remains mutable and it is possible to change its state, but every thread will have a distinct copy of this object, so changes in one thread are not reflected in another.</source>
          <target state="translated">백킹 필드 또는 객체를 스레드 로컬로 사용하여 최상위 변수를 표시합니다. 객체는 변경 가능 상태를 유지하고 상태를 변경할 수 있지만 모든 스레드에는이 객체의 고유 한 사본이 있으므로 한 스레드의 변경 사항은 다른 스레드에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ec4d266890af2cb0a6aa9e1810055ba658008f8" translate="yes" xml:space="preserve">
          <source>Marks an expected annotation class that it isn't required to have actual counterparts in all platforms.</source>
          <target state="translated">예상되는 주석 클래스를 표시하여 모든 플랫폼에 실제 대응 클래스가 필요하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c6f17834ff35593c5226191e98557d99d755e77" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="292a3151e7a72885408caf9ee437ad5d8673be4a" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="5be31e799227d8931dded0eeace958d0a3e43418" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;../../kotlin.coroutines.experimental/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="589152c67b668bc3a0e5e851927c4f25196aa066" translate="yes" xml:space="preserve">
          <source>Marks coroutine context element that intercepts coroutine continuations. The coroutines framework uses &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; to retrieve the interceptor and intercepts all coroutine continuations with &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; invocations.</source>
          <target state="translated">코 루틴 연속을 가로채는 코 루틴 컨텍스트 요소를 표시합니다. 코 루틴 프레임 워크는 &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/-key&quot;&gt;ContinuationInterceptor.Key&lt;/a&gt; 를 사용 하여 인터셉터를 검색하고 &lt;a href=&quot;../../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 호출로 모든 코 루틴 연속을 인터셉트 합니다.</target>
        </trans-unit>
        <trans-unit id="e74d580f7febe5c2f5fce47ebee5f4b2a5e537e3" translate="yes" xml:space="preserve">
          <source>Marks experimental JS export annotations.</source>
          <target state="translated">실험적인 JS 내보내기 주석을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2df77c28828a089a19fdffaa1789ccacc76664f7" translate="yes" xml:space="preserve">
          <source>Marks the API that is dependent on the experimental unsigned types, including those types themselves.</source>
          <target state="translated">실험 자체의 서명되지 않은 유형 (종종 자체 포함)에 종속 된 API를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="73273d6a95cad7e50a139041438fbf00005e8089" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;transient&lt;/code&gt;, meaning that it is not part of the default serialized form of the object.</source>
          <target state="translated">어노테이션이있는 특성의 JVM 백업 필드를 &lt;code&gt;transient&lt;/code&gt; 로 표시 합니다. 이는 오브젝트의 기본 직렬화 된 양식의 일부가 아님을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fd02a709ebd5dfcba6e63db7078d9717fce347a3" translate="yes" xml:space="preserve">
          <source>Marks the JVM backing field of the annotated property as &lt;code&gt;volatile&lt;/code&gt;, meaning that writes to this field are immediately made visible to other threads.</source>
          <target state="translated">어노테이션이있는 특성의 JVM 백업 필드를 &lt;code&gt;volatile&lt;/code&gt; 로 표시합니다. 이는이 필드에 대한 쓰기가 다른 스레드에 즉시 표시됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1c403a59019182391a8ff7eb648d56329fc1e05f" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;strictfp&lt;/code&gt;, meaning that the precision of floating point operations performed inside the method needs to be restricted in order to achieve better portability.</source>
          <target state="translated">어노테이션이있는 함수에서 생성 된 JVM 메소드를 &lt;code&gt;strictfp&lt;/code&gt; 로 표시합니다. 즉, 더 나은 이식성을 달성하려면 메소드 내에서 수행되는 부동 소수점 연산의 정밀도를 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="58ecb1a8fc60ff73e8fc37346fd83ecb47a77bf8" translate="yes" xml:space="preserve">
          <source>Marks the JVM method generated from the annotated function as &lt;code&gt;synchronized&lt;/code&gt;, meaning that the method will be protected from concurrent execution by multiple threads by the monitor of the instance (or, for static methods, the class) on which the method is defined.</source>
          <target state="translated">어노테이션이있는 함수에서 생성 된 JVM 메소드를 &lt;code&gt;synchronized&lt;/code&gt; 된 것으로 표시합니다. 즉, 메소드가 정의 된 인스턴스 (또는 정적 메소드의 경우)의 모니터에 의해 메소드가 여러 스레드에 의해 동시 실행되지 않도록 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="fb96fdd73420dc05c701eb6e0838bd95d38438a9" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated.</source>
          <target state="translated">주석이 달린 선언을 더 이상 사용되지 않는 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7d98c397e94ce7053df95bf37d1da503360432a5" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">주석이 달린 선언을 더 이상 사용되지 않음으로 표시합니다. &lt;a href=&quot;-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt; 와 달리 보고 된 진단의 심각도는 상수 값이 아니지만 사용의 API 버전에 따라 다릅니다 ( 사용이있는 모듈을 컴파일 할 때 &lt;code&gt;-api-version&lt;/code&gt; 인수 의 값 ). API 버전이 &lt;a href=&quot;-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt; 보다 크거나 같으면 코드에서 선언에 액세스 할 수 없습니다 ( &lt;a href=&quot;-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt; 수준에서 더 이상 사용되지 않는 것처럼), 그렇지 않으면 API 버전이 &lt;a href=&quot;-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt; 보다 크거나 같으면 사용법이 표시됩니다. 오류로 ( &lt;a href=&quot;-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; 와 같이 ), 그렇지 않으면 API 버전이 &lt;a href=&quot;-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt; 보다 크거나 같은 경우, 사용은 경고로 표시됩니다 ( &lt;a href=&quot;-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt; 과 같이 ). 그렇지 않으면 주석이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="80f9c066c4fb389bf5a2648a88b9da8d8a5af0b6" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="translated">주석이 달린 선언을 더 이상 사용되지 않음으로 표시합니다. &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt; 와 달리 보고 된 진단의 심각도는 상수 값이 아니지만 사용의 API 버전에 따라 다릅니다 ( 사용이있는 모듈을 컴파일 할 때 &lt;code&gt;-api-version&lt;/code&gt; 인수 의 값 ). API 버전이 &lt;a href=&quot;../-deprecated-since-kotlin/hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt; 보다 크거나 같으면 코드에서 선언에 액세스 할 수 없습니다 ( &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt; 수준에서 더 이상 사용되지 않는 것처럼), 그렇지 않으면 API 버전이 &lt;a href=&quot;../-deprecated-since-kotlin/error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt; 보다 크거나 같으면 사용법이 표시됩니다. 오류로 ( &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; 와 같이 ), 그렇지 않으면 API 버전이 &lt;a href=&quot;../-deprecated-since-kotlin/warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt; 보다 크거나 같은 경우, 사용은 경고로 표시됩니다 ( &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt; 과 같이 ). 그렇지 않으면 주석이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fdea1abd24e2fec8414716149ca5d119c8a1c72d" translate="yes" xml:space="preserve">
          <source>Marks the annotated declaration as deprecated. In contrast to &lt;a href=&quot;../-deprecated/index#kotlin.Deprecated&quot;&gt;Deprecated&lt;/a&gt;, severity of the reported diagnostic is not a constant value, but differs depending on the API version of the usage (the value of the &lt;code&gt;-api-version&lt;/code&gt; argument when compiling the module where the usage is located). If the API version is greater or equal than &lt;a href=&quot;hidden-since#kotlin.DeprecatedSinceKotlin%24hiddenSince&quot;&gt;hiddenSince&lt;/a&gt;, the declaration will not be accessible from the code (as if it was deprecated with level &lt;a href=&quot;../-deprecation-level/-h-i-d-d-e-n#kotlin.DeprecationLevel.HIDDEN&quot;&gt;DeprecationLevel.HIDDEN&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;error-since#kotlin.DeprecatedSinceKotlin%24errorSince&quot;&gt;errorSince&lt;/a&gt;, the usage will be marked as an error (as with &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;), otherwise if the API version is greater or equal than &lt;a href=&quot;warning-since#kotlin.DeprecatedSinceKotlin%24warningSince&quot;&gt;warningSince&lt;/a&gt;, the usage will be marked as a warning (as with &lt;a href=&quot;../-deprecation-level/-w-a-r-n-i-n-g#kotlin.DeprecationLevel.WARNING&quot;&gt;DeprecationLevel.WARNING&lt;/a&gt;), otherwise the annotation is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849bb03707fb20c75be09bfab7269367951a2e2c" translate="yes" xml:space="preserve">
          <source>MatchGroup</source>
          <target state="translated">MatchGroup</target>
        </trans-unit>
        <trans-unit id="dca62bbed6a25edcb571ec2b8d04d93aa72d3b21" translate="yes" xml:space="preserve">
          <source>MatchGroupCollection</source>
          <target state="translated">MatchGroupCollection</target>
        </trans-unit>
        <trans-unit id="40ee7a3cd8703b1f6d5c39fe97ef7bdbddff913a" translate="yes" xml:space="preserve">
          <source>MatchNamedGroupCollection</source>
          <target state="translated">MatchNamedGroupCollection</target>
        </trans-unit>
        <trans-unit id="e5e10479d7e48ed2ed4d8e1de8fc8b3e40fd01eb" translate="yes" xml:space="preserve">
          <source>MatchResult</source>
          <target state="translated">MatchResult</target>
        </trans-unit>
        <trans-unit id="3edf0df49942da6d11a1a217e4d3af4a5a8e64f2" translate="yes" xml:space="preserve">
          <source>Math</source>
          <target state="translated">Math</target>
        </trans-unit>
        <trans-unit id="386de788c6f8f526adcdfcc95893611a4f0f2a05" translate="yes" xml:space="preserve">
          <source>Math operations in kotlin-stdlib</source>
          <target state="translated">kotlin-stdlib의 수학 연산</target>
        </trans-unit>
        <trans-unit id="0ada0ff6418289ab78ea96388455f7b6c8654ca4" translate="yes" xml:space="preserve">
          <source>Mathematical functions and constants.</source>
          <target state="translated">수학 함수와 상수.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
