<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="23d6510bb7782c43d563dd375dee713e5d305e0b" translate="yes" xml:space="preserve">
          <source>If you need a &lt;em&gt;singleton&lt;/em&gt; - a class that only has got one instance - you can declare the class in the usual way, but use the &lt;code&gt;object&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;:</source>
          <target state="translated">인스턴스가 하나 뿐인 클래스 인 &lt;em&gt;싱글 톤&lt;/em&gt; 이 필요한 경우 일반적인 방법으로 클래스를 선언 할 수 있지만 &lt;code&gt;class&lt;/code&gt; 대신 &lt;code&gt;object&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc8467398b87bfa40771e50f53a8a177a25657b1" translate="yes" xml:space="preserve">
          <source>If you need a fancier way of reading or writing file data, you have access to the full Java suite of I/O classes - in particular, &lt;code&gt;Scanner&lt;/code&gt;, which can parse numbers and other data types from files or other streams, and &lt;code&gt;BufferedReader&lt;/code&gt; (which is good for efficient reading of large amounts of data), which you can obtain by calling &lt;code&gt;bufferedReader()&lt;/code&gt; on a file or stream. See any Java tutorial for how to use these.</source>
          <target state="translated">당신은 파일 데이터를 읽거나 쓰는 애호가 방법이 필요하면 I / O 클래스의 전체 Java 제품군에 액세스 할 수 - 특히, &lt;code&gt;Scanner&lt;/code&gt; , 파일이나 다른 스트림과에서 번호 및 기타 데이터 유형을 분석 할 수있는 &lt;code&gt;BufferedReader&lt;/code&gt; 로를 (이 파일이나 스트림에서 &lt;code&gt;bufferedReader()&lt;/code&gt; 를 호출하여 얻을 수있는 대량의 데이터를 효율적으로 읽는 데 유용 합니다. 이를 사용하는 방법에 대한 Java 자습서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54e87845252769ababaaab1c06f5bd872659abd6" translate="yes" xml:space="preserve">
          <source>If you need a function or a property to be tied to a class rather than to instances of it (similar to &lt;code&gt;@staticmethod&lt;/code&gt; in Python), you can declare it inside a &lt;em&gt;companion object&lt;/em&gt;:</source>
          <target state="translated">함수 또는 속성을 인스턴스가 아닌 클래스에 묶어야하는 경우 ( Python의 &lt;code&gt;@staticmethod&lt;/code&gt; 와 유사 ) &lt;em&gt;동반자 객체&lt;/em&gt; 내에서 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8de1431e2a233483ba705c03102c9221f4f2f632" translate="yes" xml:space="preserve">
          <source>If you need multiple ways to initialize a class, you can create &lt;em&gt;secondary constructors&lt;/em&gt;, each of which looks like a function whose name is &lt;code&gt;constructor&lt;/code&gt;. Every secondary constructor must invoke another (primary or secondary) constructor by using the &lt;code&gt;this&lt;/code&gt; keyword as if it were a function (so that every instance construction eventually calls the primary constructor).</source>
          <target state="translated">클래스를 초기화하는 여러 방법이 필요한 경우 &lt;em&gt;보조 생성자를&lt;/em&gt; 만들 수 있습니다 . 각 &lt;em&gt;생성자&lt;/em&gt; 는 이름이 &lt;code&gt;constructor&lt;/code&gt; 인 함수처럼 보입니다 . 모든 2 차 생성자는 &lt;code&gt;this&lt;/code&gt; 키워드를 함수 인 것처럼 사용하여 다른 (1 차 또는 2 차) 생성자를 호출해야합니다 (따라서 모든 인스턴스 구성은 결국 1 차 생성자를 호출합니다).</target>
        </trans-unit>
        <trans-unit id="e23221640befe2f0b60d6c58ea9b02d7e3a97b07" translate="yes" xml:space="preserve">
          <source>If you need to access a class implemented in JavaScript from Kotlin in a typesafe way, you can write a Kotlin declaration using the &lt;code&gt;external&lt;/code&gt; modifier. (In Kotlin 1.0, the &lt;code&gt;@native&lt;/code&gt; annotation was used instead.) Unlike the JVM target, the JS one permits to use external modifier with classes and properties. For example, here's how you can declare the DOM &lt;code&gt;Node&lt;/code&gt; class:</source>
          <target state="translated">타입 안전 방식으로 Kotlin에서 JavaScript로 구현 된 클래스에 액세스해야하는 경우 &lt;code&gt;external&lt;/code&gt; 수정자를 사용하여 Kotlin 선언을 작성할 수 있습니다 . (Kotlin 1.0에서는 &lt;code&gt;@native&lt;/code&gt; 주석이 대신 사용되었습니다.) JVM 대상과 달리 JS는 클래스 및 속성과 함께 외부 수정자를 사용할 수 있습니다. 예를 들어 DOM &lt;code&gt;Node&lt;/code&gt; 클래스를 선언하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f99443af480d55217c4ce0d28159d54e4f7cf72b" translate="yes" xml:space="preserve">
          <source>If you need to access platform-specific APIs from the shared code, use the Kotlin mechanism of &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;expected and actual declarations&lt;/a&gt;.</source>
          <target state="translated">공유 코드에서 플랫폼 별 API에 액세스해야하는 경우 &lt;a href=&quot;mpp-connect-to-apis&quot;&gt;예상 및 실제 선언&lt;/a&gt; 의 Kotlin 메커니즘을 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="d4e8082dbfdacd1170b034e190a7f81841b9039b" translate="yes" xml:space="preserve">
          <source>If you need to annotate the primary constructor of a class, you need to add the &lt;em&gt;constructor&lt;/em&gt; keyword to the constructor declaration, and add the annotations before it:</source>
          <target state="translated">클래스의 기본 생성자에 주석을 달아야하는 경우 생성자 선언에 &lt;em&gt;생성자&lt;/em&gt; 키워드를 추가하고 그 앞에 주석을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e462275c07255513e75672de08e598bdce5e271f" translate="yes" xml:space="preserve">
          <source>If you need to change the visibility of an accessor or to annotate it, but don't need to change the default implementation, you can define the accessor without defining its body:</source>
          <target state="translated">접근 자의 가시성을 변경하거나 주석을 달아야하지만 기본 구현을 변경할 필요가없는 경우 본문을 정의하지 않고 접근자를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4613a8244834c0ecb89ce0d825ca742a6fa51707" translate="yes" xml:space="preserve">
          <source>If you need to expose a Kotlin property as a field in Java, annotate it with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt;&lt;code&gt;@JvmField&lt;/code&gt;&lt;/a&gt; annotation. The field will have the same visibility as the underlying property. You can annotate a property with &lt;code&gt;@JvmField&lt;/code&gt; if it has a backing field, is not private, does not have &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;override&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; modifiers, and is not a delegated property.</source>
          <target state="translated">Java에서 Kotlin 특성을 필드로 노출해야하는 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index&quot;&gt; &lt;code&gt;@JvmField&lt;/code&gt; &lt;/a&gt; 어노테이션으로 주석을 답니다 . 필드는 기본 속성과 동일한 가시성을 갖습니다. 지원 필드가 있고 개인 필드가 아니고 &lt;code&gt;open&lt;/code&gt; , &lt;code&gt;override&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 한정 자가없고 위임 된 속성이 아닌 경우 &lt;code&gt;@JvmField&lt;/code&gt; 로 속성에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3648463615f31d33dec14dff446661a5d42afc8" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating over something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">무언가를 반복 할 때 현재 요소의 인덱스를 알아야한다면 &lt;code&gt;enumerate()&lt;/code&gt; 해당하는 &lt;code&gt;withIndex()&lt;/code&gt; 사용할 수 있습니다 . 두 개의 속성 (인덱스 및 값)과 &lt;code&gt;component1()&lt;/code&gt; 및 &lt;code&gt;component2()&lt;/code&gt; 라는 두 개의 특수하게 명명 된 접근 자 함수를 갖는 일련의 객체를 생성합니다 . Kotlin을 사용하면 이러한 객체를 선언으로 분해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89e90e48358e19dcdf7d70c38acd3455ecae2039" translate="yes" xml:space="preserve">
          <source>If you need to know the index of the current element when you're iterating through something, you can use &lt;code&gt;withIndex()&lt;/code&gt;, which corresponds to &lt;code&gt;enumerate()&lt;/code&gt;. It produces a sequence of objects that have got two properties (the index and the value) and two specially-named accessor functions called &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt;; Kotlin lets you destructure such an object into a declaration:</source>
          <target state="translated">무언가를 반복 할 때 현재 요소의 색인을 알아야하는 경우 &lt;code&gt;enumerate()&lt;/code&gt; 해당하는 &lt;code&gt;withIndex()&lt;/code&gt; 사용할 수 있습니다 . 두 개의 속성 (인덱스 및 값)과 &lt;code&gt;component1()&lt;/code&gt; 및 &lt;code&gt;component2()&lt;/code&gt; 라는 특수하게 명명 된 두 가지 접근 자 함수를 가진 일련의 객체를 생성합니다 . Kotlin을 사용하면 이러한 객체를 선언으로 구조화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c304182ad4dffb827b2cd5041835d4a1290ba5c" translate="yes" xml:space="preserve">
          <source>If you need to look up the class dynamically as well, you can use &lt;code&gt;Class.forName()&lt;/code&gt; and supply the fully-qualified name of the class.</source>
          <target state="translated">클래스를 동적으로 조회해야하는 경우 &lt;code&gt;Class.forName()&lt;/code&gt; 사용 하고 클래스의 완전한 이름을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb05e76a6c128f62bf211b270ee1f300cbc3d9aa" translate="yes" xml:space="preserve">
          <source>If you need to retrieve an arbitrary element of a collection, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; function. You can call it without arguments or with a &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt; object as a source of the randomness.</source>
          <target state="translated">컬렉션의 임의의 요소를 검색해야하는 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.random/-random/index&quot;&gt; &lt;code&gt;Random&lt;/code&gt; &lt;/a&gt; 의 소스로 인수없이 또는 Random 개체를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c6c6ff6a76abad65e2d1d67dae2bda5a0418cb0" translate="yes" xml:space="preserve">
          <source>If you need to retrieve the collection content in a readable format, use functions that transform the collections to strings: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt;&lt;code&gt;joinToString()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt;&lt;code&gt;joinTo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컬렉션 내용을 읽을 수있는 형식으로 검색해야하는 경우 컬렉션을 문자열로 변환하는 함수 인 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to-string&quot;&gt; &lt;code&gt;joinToString()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/join-to&quot;&gt; &lt;code&gt;joinTo()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27633af274eff8d8c59fb2e4a25231c59018307c" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code can access the annotations and arguments normally.</source>
          <target state="translated">주석의 인수로 클래스를 지정해야하는 경우 Kotlin 클래스 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; )를 사용하세요. Kotlin 컴파일러는이를 자바 클래스로 자동 변환하므로 자바 코드가 주석과 인수에 정상적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="993106f4a5b27e1d574e1151066452d4ad416447" translate="yes" xml:space="preserve">
          <source>If you need to specify a class as an argument of an annotation, use a Kotlin class (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt;). The Kotlin compiler will automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments normally.</source>
          <target state="translated">클래스를 주석의 인수로 지정해야하는 경우 Kotlin 클래스 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect/-k-class/index&quot;&gt;KClass&lt;/a&gt; )를 사용하십시오. Kotlin 컴파일러는이를 자동으로 Java 클래스로 변환하므로 Java 코드가 주석 및 인수를 정상적으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7448bb25e266494ddde684c5929327a96a8fb964" translate="yes" xml:space="preserve">
          <source>If you need to use a nullable &lt;code&gt;Boolean&lt;/code&gt; in a conditional statement, use &lt;code&gt;if (value == true)&lt;/code&gt; or &lt;code&gt;if (value == false)&lt;/code&gt; checks.</source>
          <target state="translated">조건문에 널 입력 가능 &lt;code&gt;Boolean&lt;/code&gt; 을 사용해야하는 &lt;code&gt;if (value == true)&lt;/code&gt; 또는 &lt;code&gt;if (value == false)&lt;/code&gt; 검사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c201a6c8803ec9d0564e44a48fc6ef8489585c2" translate="yes" xml:space="preserve">
          <source>If you need to write a function that can be called without having a class instance but needs access to the internals of a class (for example, a factory method), you can write it as a member of an &lt;a href=&quot;object-declarations&quot;&gt;object declaration&lt;/a&gt; inside that class.</source>
          <target state="translated">클래스 인스턴스없이 호출 할 수 있지만 클래스의 내부 (예 : 팩토리 메서드)에 액세스해야하는 함수를 작성해야하는 경우 해당 클래스 내 에서 &lt;a href=&quot;object-declarations&quot;&gt;객체 선언&lt;/a&gt; 의 멤버로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f584df433485780683ca571ae5a89e659948c6b" translate="yes" xml:space="preserve">
          <source>If you only want to call the function and don't care about the metadata, use a function type, e.g. &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; for an ordinary function reference or a bound member function reference, or &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; for an unbound member function reference on &lt;code&gt;A&lt;/code&gt;. Note that &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; and its subinterfaces are only available for declared functions (obtained either by explicitly referencing it in the code, or through reflection, as shown later) - only function types are available for function literals (lambda expressions or anonymous functions).</source>
          <target state="translated">함수 만 호출하고 메타 데이터에 신경 쓰지 않으 려면 일반 함수 참조 또는 바운드 멤버 함수 참조에 대해 &lt;code&gt;(A, B) -&amp;gt; V&lt;/code&gt; 또는 A와 같은 함수 유형을 사용하십시오 &lt;code&gt;A.(B, C) -&amp;gt; V&lt;/code&gt; 에 결합되지 않은 멤버 함수 참조 . 참고 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; (이후에 도시 된 바와 같이, 명시 적 코드를 참조하여 어느 수득하거나 반사를 통해) 그 서브 선언 기능 만 사용할 - 전용 기능 유형 함수 리터럴 (람다 식 또는 익명 함수)에 사용할 수있는 . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8014e84399844604d4127e5bfb102e3054b9b7f6" translate="yes" xml:space="preserve">
          <source>If you operate nested collections, you may find the standard library functions that provide flat access to nested collection elements useful.</source>
          <target state="translated">중첩 컬렉션을 운영하는 경우 중첩 컬렉션 요소에 대한 평평한 액세스를 제공하는 표준 라이브러리 함수가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8d397c2c2050d55c50d82eec1a501b49617481" translate="yes" xml:space="preserve">
          <source>If you override a &lt;code&gt;protected&lt;/code&gt; member and do not specify the visibility explicitly, the overriding member will also have &lt;code&gt;protected&lt;/code&gt; visibility.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 멤버 를 재정의 하고 가시성을 명시 적으로 지정하지 않으면 재정의 멤버도 &lt;code&gt;protected&lt;/code&gt; 가시성을 갖게 됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd8f947a24ab8c99f576a413b868a14fd70348dc" translate="yes" xml:space="preserve">
          <source>If you previously used the &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android support&lt;/a&gt; for annotation processors, replace usages of the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration with &lt;code&gt;kapt&lt;/code&gt;. If your project contains Java classes, &lt;code&gt;kapt&lt;/code&gt; will also take care of them.</source>
          <target state="translated">이전 에 주석 프로세서에 대한 &lt;a href=&quot;https://developer.android.com/studio/build/gradle-plugin-3-0-0-migration.html#annotationProcessor_config&quot;&gt;Android 지원&lt;/a&gt; 을 사용한 경우 &lt;code&gt;annotationProcessor&lt;/code&gt; 구성 사용법을 &lt;code&gt;kapt&lt;/code&gt; 로 바꾸 십시오 . 프로젝트에 Java 클래스가 포함 된 경우 &lt;code&gt;kapt&lt;/code&gt; 도이를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="3126f475d393c0188e7088d866ab3c517a722979" translate="yes" xml:space="preserve">
          <source>If you publish several features in the experimental state, declare a marker for each. Separate markers make the use of experimental features safer for your clients: they'll be able to use only the features that they explicitly accept. This also lets you graduate the features to stable independently.</source>
          <target state="translated">실험 상태에서 여러 기능을 게시하는 경우 각각에 대한 마커를 선언하십시오. 별도의 마커를 사용하면 고객에게 실험 기능을보다 안전하게 사용할 수 있습니다. 고객은 명시 적으로 허용하는 기능 만 사용할 수 있습니다. 또한 기능을 독립적으로 안정화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df8a586d7260c254feebf62ecf6abe57e497a3fe" translate="yes" xml:space="preserve">
          <source>If you really really need a mixed-type collection, you can use the element type &lt;code&gt;Any&lt;/code&gt; - but you'll need typecasting to get the elements back to their proper type again, so if what you want is a multiple-value return from a function, please use the per-element-typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Triple&lt;/code&gt; instead. If you need four or more elements, consider making a &lt;a href=&quot;classes#data-classes&quot;&gt;data class&lt;/a&gt; for the return type instead (which you should ideally do for two or three elements as well, especially if it's a public function, since it gives you proper names for the elements) - it's very easy and usually a oneliner.</source>
          <target state="translated">실제로 혼합 유형 컬렉션이 필요한 경우 요소 유형 &lt;code&gt;Any&lt;/code&gt; 를 사용할 수 있지만 요소를 올바른 유형으로 다시 가져 오려면 유형 캐스팅이 필요하므로 원하는 경우 함수에서 다중 값 반환이 필요합니다 대신 요소 별 유형의 &lt;code&gt;Pair&lt;/code&gt; 또는 &lt;code&gt;Triple&lt;/code&gt; 사용하십시오. 네 개 이상의 요소가 필요한 경우 대신 반환 유형에 대한 &lt;a href=&quot;classes#data-classes&quot;&gt;데이터 클래스&lt;/a&gt; 를 만드는 것이 좋습니다 (특히 두 개 또는 세 개의 요소, 특히 공용 함수 인 경우 요소의 적절한 이름을 제공하므로). 매우 쉽고 일반적으로 oneliner입니다.</target>
        </trans-unit>
        <trans-unit id="cbc8324a9f6502600707b1d372c5b0e01758d5e6" translate="yes" xml:space="preserve">
          <source>If you really want to, you can both initialize and specify the type on the same line. This is mostly useful if you're dealing with a class hierarchy (more on that later) and you want the variable type to be a base type of the value's class:</source>
          <target state="translated">실제로 원하는 경우 동일한 줄에서 유형을 초기화하고 지정할 수 있습니다. 이것은 클래스 계층 구조를 처리하고 (나중에 자세히 설명 할 때) 변수 유형이 값 클래스의 기본 유형이되기를 원하는 경우에 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="13648197906f478e28c0bcf3383cb817c3e322b6" translate="yes" xml:space="preserve">
          <source>If you run the above code you'll see that it does not always print zero, though it may depend on the timings of your machine you may need to tweak timeouts in this example to actually see non-zero values.</source>
          <target state="translated">위의 코드를 실행하면 항상 0이 출력되는 것은 아니지만 머신의 타이밍에 따라 달라질 수 있지만 실제로 0이 아닌 값을 보려면이 예제에서 타임 아웃을 조정해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3a00df64d22ebf69e57bb704a9d62539a93298" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; by &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 &lt;code&gt;thread&lt;/code&gt; 로 교체하여 시작 하면 컴파일러에서 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1244c242be7001db0fa42d5a34807cd464a4c723" translate="yes" xml:space="preserve">
          <source>If you start by replacing &lt;code&gt;GlobalScope.launch&lt;/code&gt; with &lt;code&gt;thread&lt;/code&gt;, the compiler produces the following error:</source>
          <target state="translated">&lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 &lt;code&gt;thread&lt;/code&gt; 로 바꾸는 것으로 시작 하면 컴파일러에서 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="589b4c81823f6922542c45e2902c148531d2b494" translate="yes" xml:space="preserve">
          <source>If you target JavaScript, use the &lt;code&gt;stdlib-js&lt;/code&gt; dependency.</source>
          <target state="translated">JavaScript를 대상으로하는 경우 &lt;code&gt;stdlib-js&lt;/code&gt; 종속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf587872264afbd1369b320aaae73dd1b3673d1b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;enable caching for them manually&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt; 를 사용 하는 경우 kapt 주석 처리 작업은 기본적으로 캐시되지 않습니다. 그러나 &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;수동으로 캐싱을 활성화&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39efa722c74de834ad1bd8a4e4c201bd7dac494b" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt;, note that the kapt annotation processing tasks are not cached by default. However, you can enable caching for them manually. See the &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt page&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;kapt&quot;&gt;kapt&lt;/a&gt; 를 사용하는 경우 , kapt 주석 처리 태스크는 기본적으로 캐시되지 않습니다. 그러나 수동으로 캐싱을 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;kapt#gradle-build-cache-support-since-1220&quot;&gt;kapt 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a73c7aeee6bdc5c7806d3e53e9294fc8ac4610bf" translate="yes" xml:space="preserve">
          <source>If you use Spring, you can enable the &lt;em&gt;kotlin-spring&lt;/em&gt; compiler plugin instead of specifying Spring annotations manually. The kotlin-spring is a wrapper on top of all-open, and it behaves exactly the same way.</source>
          <target state="translated">Spring을 사용 하는 경우 Spring 주석을 수동으로 지정하는 대신 &lt;em&gt;kotlin-spring&lt;/em&gt; 컴파일러 플러그인 을 사용할 수 있습니다. kotlin-spring은 완전 개방형 위에있는 래퍼이며 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="611d8f619bf7a7948c981fe9d16f096526d50981" translate="yes" xml:space="preserve">
          <source>If you use a kotlinx library and need a platform-specific dependency, you can use platform-specific variants of libraries with suffixes such as &lt;code&gt;-jvm&lt;/code&gt; or &lt;code&gt;-js&lt;/code&gt;, for example, &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt;. You can also use the library base artifact name instead &amp;ndash; &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt;.</source>
          <target state="translated">kotlinx 라이브러리를 사용하고 플랫폼 별 종속성이 필요한 경우 &lt;code&gt;-jvm&lt;/code&gt; 또는 &lt;code&gt;-js&lt;/code&gt; 와 같은 접미사가있는 플랫폼 별 라이브러리 변형을 사용할 수 있습니다 ( 예 : &lt;code&gt;kotlinx-coroutines-core-jvm&lt;/code&gt; ) . 대신 라이브러리 기본 아티팩트 이름 인 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7efa55746211a1f8112a9a60777f3c462da2efbd" translate="yes" xml:space="preserve">
          <source>If you use a multiplatform library and need to depend on the shared code, set the dependency only once in the shared source set. Use the library base artifact name, such as &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; or &lt;code&gt;ktor-client-core&lt;/code&gt;.</source>
          <target state="translated">다중 플랫폼 라이브러리를 사용하고 공유 코드에 의존해야하는 경우 공유 소스 세트에서 종속성을 한 번만 설정하십시오. &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 또는 &lt;code&gt;ktor-client-core&lt;/code&gt; 와 같은 라이브러리 기본 아티팩트 이름을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bce77e8c93a7ca161789d86b2fef454e9ed0e0f" translate="yes" xml:space="preserve">
          <source>If you use annotation processors for your &lt;code&gt;androidTest&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; sources, the respective &lt;code&gt;kapt&lt;/code&gt; configurations are named &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt;. Note that &lt;code&gt;kaptAndroidTest&lt;/code&gt; and &lt;code&gt;kaptTest&lt;/code&gt; extends &lt;code&gt;kapt&lt;/code&gt;, so you can just provide the &lt;code&gt;kapt&lt;/code&gt; dependency and it will be available both for production sources and tests.</source>
          <target state="translated">&lt;code&gt;androidTest&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 소스에 주석 프로세서를 사용하는 경우 해당 &lt;code&gt;kapt&lt;/code&gt; 구성의 이름은 &lt;code&gt;kaptAndroidTest&lt;/code&gt; 및 &lt;code&gt;kaptTest&lt;/code&gt; 입니다. 참고 것을 &lt;code&gt;kaptAndroidTest&lt;/code&gt; 및 &lt;code&gt;kaptTest&lt;/code&gt; 는 확장 &lt;code&gt;kapt&lt;/code&gt; 를 그냥 제공 할 수 있도록, &lt;code&gt;kapt&lt;/code&gt; 의 의존성을하고 생산 소스와 테스트를 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e5fa9bba802b4996dceed857e221c7dc79c3552" translate="yes" xml:space="preserve">
          <source>If you use the NV Kotlin compiler and have the OV standard library or the OV reflection library in the classpath, it can be a sign that the project is misconfigured. To prevent unexpected problems during compilation or at runtime, we suggest either updating the dependencies to NV, or specifying the API version / language version arguments explicitly. Otherwise the compiler detects that something can go wrong and reports a warning.</source>
          <target state="translated">NV Kotlin 컴파일러를 사용하고 클래스 경로에 OV 표준 라이브러리 또는 OV 리플렉션 라이브러리가있는 경우 프로젝트가 잘못 구성되었다는 신호일 수 있습니다. 컴파일 중 또는 런타임에 예기치 않은 문제를 방지하려면 종속성을 NV로 업데이트하거나 API 버전 / 언어 버전 인수를 명시 적으로 지정하는 것이 좋습니다. 그렇지 않으면 컴파일러는 무언가 잘못 될 수 있음을 감지하고 경고를보고합니다.</target>
        </trans-unit>
        <trans-unit id="f69388ccfa9be1025c7351e156b510d0110f1b95" translate="yes" xml:space="preserve">
          <source>If you want a literal &lt;code&gt;$&lt;/code&gt;, you need to escape it: &lt;code&gt;\$&lt;/code&gt;. Escaping generally works the same way as in Python, with a similar set of standard escape sequences.</source>
          <target state="translated">리터럴 &lt;code&gt;$&lt;/code&gt; 를 원하면 이스케이프해야합니다 : &lt;code&gt;\$&lt;/code&gt; . 이스케이프 처리는 일반적으로 유사한 표준 이스케이프 시퀀스 세트를 사용하여 Python과 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="542e15c450e9d7499e5b8e3fd1eff9a8b7386f93" translate="yes" xml:space="preserve">
          <source>If you want to &lt;strong&gt;start from scratch&lt;/strong&gt;, you can &lt;a href=&quot;jvm-get-started&quot;&gt;create a basic Kotlin application&lt;/a&gt;. Once you&amp;rsquo;ve created the application, you can dive deeper into Kotlin syntax:</source>
          <target state="translated">당신이 원하는 경우 &lt;strong&gt;처음부터 다시 시작&lt;/strong&gt; , 당신은 수있는 &lt;a href=&quot;jvm-get-started&quot;&gt;기본 코 틀린 응용 프로그램을 만듭니다&lt;/a&gt; . 애플리케이션을 만든 후에는 Kotlin 구문에 대해 자세히 알아볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc75b83f1a6aedb14b4da0cf0332f54ec31285c" translate="yes" xml:space="preserve">
          <source>If you want to alert callers of possible exceptions when calling Kotlin code from Java, Swift, or Objective-C, you can use the &lt;code&gt;@Throws&lt;/code&gt; annotation. Read more about using this annotation &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;for Java&lt;/a&gt; as well as &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;for Swift and Objective-C&lt;/a&gt;.</source>
          <target state="translated">Java, Swift 또는 Objective-C에서 Kotlin 코드를 호출 할 때 발생 가능한 예외를 호출자에게 알리려면 &lt;code&gt;@Throws&lt;/code&gt; 주석을 사용할 수 있습니다 . 이 주석 &lt;a href=&quot;java-to-kotlin-interop#checked-exceptions&quot;&gt;을 Java&lt;/a&gt; 와 &lt;a href=&quot;native/objc_interop#errors-and-exceptions&quot;&gt;Swift 및 Objective-C&lt;/a&gt; 에 사용하는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="aeb2cd1321a6da714d1670aa5db99ba2841082d1" translate="yes" xml:space="preserve">
          <source>If you want to be able to intercept an assignment and &quot;veto&quot; it, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">할당을 가로 채고이를 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt; 하려면 &lt;code&gt;observable()&lt;/code&gt; 대신 vetoable ()을 사용하십시오 . &lt;code&gt;vetoable&lt;/code&gt; 전달 된 핸들러 는 새 특성 값 지정이 수행 &lt;em&gt;되기 전에&lt;/em&gt; 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="bfcb549b385e785251e8b67f2103cc999018679b" translate="yes" xml:space="preserve">
          <source>If you want to be more explicit about the fact that you're creating a function, you can make an &lt;em&gt;anonymous function&lt;/em&gt;, which is still an expression rather than a declaration:</source>
          <target state="translated">함수를 작성하고 있다는 사실에 대해 더 명확하게 설명하려면 &lt;em&gt;익명 함수&lt;/em&gt; 를 작성할 수 있습니다.이 &lt;em&gt;함수&lt;/em&gt; 는 여전히 선언이 아니라 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="696e4536ad6464f41098a1506dbe37ed6e039609" translate="yes" xml:space="preserve">
          <source>If you want to check for &lt;em&gt;not&lt;/em&gt; being an instance of a type, use &lt;code&gt;!is&lt;/code&gt;. Note that &lt;code&gt;null&lt;/code&gt; is never an instance of any non-nullable type, but it is always an &quot;instance&quot; of any nullable type (even though it technically isn't an instance, but an absence of any instance).</source>
          <target state="translated">유형의 인스턴스가 &lt;em&gt;아닌지&lt;/em&gt; 확인 하려면 &lt;code&gt;!is&lt;/code&gt; 사용하십시오 . 참고 &lt;code&gt;null&lt;/code&gt; 아닌 nullable 형식의 인스턴스 적이 없지만, 항상 (기술적으로 인스턴스가 아닌 경우에도,하지만 인스턴스의 부재) 어떤 nullable 형식의 &quot;인스턴스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="da257f8128fc0a8ca8d706e6f33a71205b6846f0" translate="yes" xml:space="preserve">
          <source>If you want to customize your builds or run configuration, refer to the Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">빌드를 사용자 정의하거나 구성을 실행하려면 Android Studio &lt;a href=&quot;https://developer.android.com/studio/run&quot;&gt;문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6811d9ac7923673de93e7c6cb86e0dcf12f4b539" translate="yes" xml:space="preserve">
          <source>If you want to declare your module's API as experimental, create an annotation class to use as its &lt;em&gt;experimental marker&lt;/em&gt;. This class must be annotated with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt;:</source>
          <target state="translated">모듈의 API를 실험적으로 선언하려면 &lt;em&gt;실험 마커&lt;/em&gt; 로 사용할 주석 클래스를 만듭니다 . 이 클래스에는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-experimental/index&quot;&gt;@Experimental&lt;/a&gt; 로 주석을 달아야합니다 .</target>
        </trans-unit>
        <trans-unit id="03930681c826a10c017d1c305e0dfdcd631eb099" translate="yes" xml:space="preserve">
          <source>If you want to do something that does not fit into this &quot;implicit backing field&quot; scheme, you can always fall back to having a &lt;em&gt;backing property&lt;/em&gt;:</source>
          <target state="translated">이 &quot;암시 적 백업 필드&quot;체계에 맞지 않는 작업을 수행하려는 경우 항상 &lt;em&gt;백업 특성&lt;/em&gt; 을 갖는 것으로 넘어갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="469cbead1816f95552e8fb9afc4584e38910eba1" translate="yes" xml:space="preserve">
          <source>If you want to exclude the last value, use &lt;code&gt;until&lt;/code&gt;:</source>
          <target state="translated">마지막 값을 제외하려면 &lt;code&gt;until&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="21db5d6173e4569eae43123218189b3a3fd619bd" translate="yes" xml:space="preserve">
          <source>If you want to group elements and then apply an operation to all groups at one time, use the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt;&lt;code&gt;groupingBy()&lt;/code&gt;&lt;/a&gt;. It returns an instance of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt;&lt;code&gt;Grouping&lt;/code&gt;&lt;/a&gt; type. The &lt;code&gt;Grouping&lt;/code&gt; instance lets you apply operations to all groups in a lazy manner: the groups are actually built right before the operation execution.</source>
          <target state="translated">요소를 그룹화 한 다음 한 번에 모든 그룹에 조작을 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/grouping-by&quot;&gt; &lt;code&gt;groupingBy()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-grouping/index&quot;&gt; &lt;code&gt;Grouping&lt;/code&gt; &lt;/a&gt; 유형 의 인스턴스를 리턴합니다 . &lt;code&gt;Grouping&lt;/code&gt; 그룹이 실제로 바로 작업을 실행하기 전에 내장되어 있습니다 : 예는 게으른 방식으로 모든 그룹에 작업을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c8357f8e591acaadaa35ef0312974da5893976" translate="yes" xml:space="preserve">
          <source>If you want to impose additional constraints, you must use a separate &lt;code&gt;where&lt;/code&gt; clause, in which case the type parameter must be a subclass of the given class (if you specify a class, and you can specify at most one) &lt;em&gt;and&lt;/em&gt; implement all the given interfaces. You may then access all the public members of all the given types whenever you've got a value of type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">추가 제약 조건을 부과하려는 경우 별도의 사용해야합니다 &lt;code&gt;where&lt;/code&gt; 절은,이 경우 형식 매개 변수가 지정된 클래스의 서브 클래스해야합니다 (당신이 클래스를 지정하는 경우, 당신은 대부분의 일에서 지정할 수 있습니다) &lt;em&gt;및&lt;/em&gt; 모든 주어진 구현 인터페이스. 그런 다음 &lt;code&gt;T&lt;/code&gt; 유형의 값을 가질 때마다 주어진 모든 유형의 모든 공용 멤버에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e91febbc6ec64c3a83c00953396a7246b3b6ef2" translate="yes" xml:space="preserve">
          <source>If you want to intercept assignments and &quot;veto&quot; them, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt;&lt;code&gt;vetoable()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;observable()&lt;/code&gt;. The handler passed to the &lt;code&gt;vetoable&lt;/code&gt; is called &lt;em&gt;before&lt;/em&gt; the assignment of a new property value has been performed.</source>
          <target state="translated">할당을 가로 채서 &quot;거부&quot;하려면 &lt;code&gt;observable()&lt;/code&gt; 대신 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable&quot;&gt; &lt;code&gt;vetoable()&lt;/code&gt; &lt;/a&gt; 사용하십시오 . &lt;code&gt;vetoable&lt;/code&gt; 전달 된 핸들러 는 새 속성 값 할당이 수행 &lt;em&gt;되기 전에&lt;/em&gt; 호출 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad4ce20803bf2d9ea3efb4e51b2111ecb76db405" translate="yes" xml:space="preserve">
          <source>If you want to iterate through an array or a list with an index, you can do it this way:</source>
          <target state="translated">배열이나 인덱스가있는 목록을 반복하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="125c434fa84549730a675353dd139689f7b256f9" translate="yes" xml:space="preserve">
          <source>If you want to keep a whole package or module from elimination, you can use its fully qualified name as it appears in the generated JavaScript code.</source>
          <target state="translated">전체 패키지 또는 모듈이 제거되지 않도록하려면 생성 된 JavaScript 코드에 나타나는 정규화 된 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6675875ca0e15a9e0e94e4e62bcc35aa2271753" translate="yes" xml:space="preserve">
          <source>If you want to keep your code compatible with the 1.0 standard library, you can pass &lt;code&gt;-api-version 1.0&lt;/code&gt;.</source>
          <target state="translated">코드가 1.0 표준 라이브러리와 호환되도록하려면 &lt;code&gt;-api-version 1.0&lt;/code&gt; 을 전달하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="a90f40cf003c1ca63835c4f5252dade99a0b6302" translate="yes" xml:space="preserve">
          <source>If you want to learn different Kotlin features, try &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;.</source>
          <target state="translated">다른 Kotlin 기능을 배우려면 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans를&lt;/a&gt; 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="00db4d51336388a60b35cfdb52f35a642fd46d81" translate="yes" xml:space="preserve">
          <source>If you want to look at the metadata of a function (e.g. its name), use &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; or one of its subinterfaces, where &lt;code&gt;V&lt;/code&gt; is the function's return type. Here's a basic example:</source>
          <target state="translated">함수의 메타 데이터 (예 : 이름)를 &lt;code&gt;KFunction&amp;lt;V&amp;gt;&lt;/code&gt; 또는 해당 서브 인터페이스 중 하나를 사용하십시오. 여기서 &lt;code&gt;V&lt;/code&gt; 는 함수의 반환 유형입니다. 기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d1730df83789869c0eec8797d86c76b973936cd" translate="yes" xml:space="preserve">
          <source>If you want to restrict the set of subclasses of a base class, you can declare the base class to be &lt;code&gt;sealed&lt;/code&gt; (which also makes it abstract), in which case you can only declare subclasses in the same file. The compiler then knows the complete set of possible subclasses, which will let you do exhaustive &lt;code&gt;when&lt;/code&gt; expression for all the possible subtypes without the need for an &lt;code&gt;else&lt;/code&gt; clause (and if you add another subclass in the future and forget to update the &lt;code&gt;when&lt;/code&gt;, the compiler will let you know).</source>
          <target state="translated">기본 클래스의 서브 클래스 세트를 제한하려면 기본 클래스가 &lt;code&gt;sealed&lt;/code&gt; 되도록 선언 하면 (이를 추상적으로 작성),이 경우 동일한 파일에서만 서브 클래스를 선언 할 수 있습니다. 그런 다음 컴파일러는 가능한 서브 클래스의 전체 세트를 알고 있으므로 &lt;code&gt;else&lt;/code&gt; 절이 필요하지 않고 가능한 모든 서브 타입에 대한 표현식을 표현할 &lt;code&gt;when&lt;/code&gt; 철저한 작업을 수행 할 수 있습니다 (나중에 다른 서브 클래스를 추가하고 &lt;code&gt;when&lt;/code&gt; , 컴파일러 업데이트를 잊어 버린 경우 알려드립니다).</target>
        </trans-unit>
        <trans-unit id="24aa907f13ca700b9ceeaa1262123234a9393fc1" translate="yes" xml:space="preserve">
          <source>If you want to see all available options run</source>
          <target state="translated">사용 가능한 모든 옵션을 보려면</target>
        </trans-unit>
        <trans-unit id="2d21aa936de4e7ff46724ca50ee4a418c4b5e521" translate="yes" xml:space="preserve">
          <source>If you want to see how your task will be look to the learner, right-click the &lt;code&gt;Task.kt&lt;/code&gt; file in the &lt;strong&gt;Project&lt;/strong&gt; tool window, and choose &lt;strong&gt;Course Creator -&amp;gt; Show Preview&lt;/strong&gt;:</source>
          <target state="translated">작업이 학습자에게 어떻게 보일지 보려면 &lt;strong&gt;프로젝트&lt;/strong&gt; 도구 창 에서 &lt;code&gt;Task.kt&lt;/code&gt; 파일을 마우스 오른쪽 단추로 클릭 하고 &lt;strong&gt;코스 생성자-&amp;gt; 미리보기 표시를&lt;/strong&gt; 선택하십시오 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="81dec7b57d1ae160cc859398f6b261d2b3f48fa4" translate="yes" xml:space="preserve">
          <source>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</source>
          <target state="translated">링크에 대한 사용자 정의 레이블을 지정하려면 마크 다운 참조 스타일 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8b98cb29aff85793ce838953d8ec8871fe09a05" translate="yes" xml:space="preserve">
          <source>If you want to start from scratch with the task, use the &lt;strong&gt;Reset&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel:</source>
          <target state="translated">작업을 처음부터 시작하려면 &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 맨 위에 있는 &lt;strong&gt;재설정&lt;/strong&gt; 아이콘을 사용하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c377ee38e06516840389b0006f62da827c729d93" translate="yes" xml:space="preserve">
          <source>If you want to start using Kotlin for Android development, read &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Google&amp;rsquo;s recommendation for getting started with Kotlin on Android&lt;/a&gt;.</source>
          <target state="translated">Android 개발 용 Kotlin을 사용하려면 Android &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;에서 Kotlin을 시작하기위한 Google의 권장 사항을&lt;/a&gt; 읽어 보세요 .</target>
        </trans-unit>
        <trans-unit id="ef089a53351dae0337ca675a4a633d10abb6eccf" translate="yes" xml:space="preserve">
          <source>If you want to use a value only if it satisfies a certain condition, try &lt;code&gt;takeIf()&lt;/code&gt;, which returns the value it's called on if it satisfies the given predicate, and null otherwise. There's also &lt;code&gt;takeUnless()&lt;/code&gt;, which inverts the logic. You can follow this with a &lt;code&gt;?.&lt;/code&gt; to perform an operation on the value only if it satisfies the predicate. Below, we compute the square of some expression, but only if the expression value is at least 42:</source>
          <target state="translated">특정 조건을 만족하는 경우에만 값을 사용 하려면 주어진 술어를 만족하면 호출되는 값을 리턴하는 &lt;code&gt;takeIf()&lt;/code&gt; 시도 하십시오 . 그렇지 않으면 널입니다. 로직을 반전시키는 &lt;code&gt;takeUnless()&lt;/code&gt; 도 있습니다 . 다음과 같이 &lt;code&gt;?.&lt;/code&gt; 사용할 수 있습니다 . 술어를 만족하는 경우에만 값에 대한 조작을 수행합니다. 아래에서는 표현식 값이 42 이상인 경우에만 일부 표현식의 제곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="39803479c2452982a2bf2e4068e689f82660ee9c" translate="yes" xml:space="preserve">
          <source>If you want to use dependencies on local pods from Kotlin code, import the corresponding packages.</source>
          <target state="translated">Kotlin 코드에서 로컬 포드에 대한 종속성을 사용하려면 해당 패키지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="be96354e6d849f99091812f51218336ab205ca9c" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin for teaching, read &lt;a href=&quot;edu-tools-educator&quot;&gt;Teaching Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">교육에 EduTools 플러그인을 사용하려면 EduTools 플러그인으로 &lt;a href=&quot;edu-tools-educator&quot;&gt;Kotlin&lt;/a&gt; 교육을 읽어 보세요 .</target>
        </trans-unit>
        <trans-unit id="67fb2febabe66895070c2641c4d6f978cdb57747" translate="yes" xml:space="preserve">
          <source>If you want to use the EduTools plugin to learn Kotlin, read &lt;a href=&quot;edu-tools-learner&quot;&gt;Learning Kotlin with EduTools plugin&lt;/a&gt;.</source>
          <target state="translated">EduTools 플러그인을 사용하여 Kotlin을 배우려면 EduTools 플러그인으로 Kotlin &lt;a href=&quot;edu-tools-learner&quot;&gt;학습을&lt;/a&gt; 읽어 보세요 .</target>
        </trans-unit>
        <trans-unit id="87bc643ce85513f6868cb2e9de9823d1f4369259" translate="yes" xml:space="preserve">
          <source>If you want to write strings gradually, you need to create an &lt;code&gt;OutputStreamWriter&lt;/code&gt; by calling &lt;code&gt;writer()&lt;/code&gt; on the file object. You can write binary data to a file by calling &lt;code&gt;outputStream()&lt;/code&gt; on a file object and use the resulting &lt;code&gt;OutputStream&lt;/code&gt; to write bytes.</source>
          <target state="translated">문자열을 점진적으로 쓰려면 파일 객체에서 &lt;code&gt;writer()&lt;/code&gt; 를 호출 하여 &lt;code&gt;OutputStreamWriter&lt;/code&gt; 를 만들어야 합니다. 파일 객체에서 &lt;code&gt;outputStream()&lt;/code&gt; 을 호출하여 이진 데이터를 파일에 쓰고 결과 &lt;code&gt;OutputStream&lt;/code&gt; 을 사용하여 바이트를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41befb145b42cbf8131f21728e484a8a91115d2" translate="yes" xml:space="preserve">
          <source>If you write the same without &lt;code&gt;let&lt;/code&gt;, you'll have to introduce a new variable and repeat its name whenever you use it.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 없이 동일 하게 작성하면 새 변수를 도입하고 사용할 때마다 그 이름을 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a3aaf1f9dd9fea6023de83a437602a5eadebf5e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re on Ubuntu 16.04 or later, you can install the compiler from the command line:</source>
          <target state="translated">Ubuntu 16.04 이상을 사용하는 경우 명령 행에서 컴파일러를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef3b492d472d99a86a122fa8edba6106fbe3c08" translate="yes" xml:space="preserve">
          <source>If you'd rather do &lt;code&gt;x.unsigned&lt;/code&gt;, you can define an extension property:</source>
          <target state="translated">당신이 오히려 할 줄 경우 &lt;code&gt;x.unsigned&lt;/code&gt; , 당신은 확장 속성을 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="07dd95cbbfcdccfc3f0d530d8306040139f15ae7" translate="yes" xml:space="preserve">
          <source>If you're a &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts&lt;/a&gt; user, you can install the compiler with:</source>
          <target state="translated">당신이 경우 &lt;a href=&quot;https://www.macports.org/&quot;&gt;MacPorts를의&lt;/a&gt; 사용자, 당신과 함께 컴파일러를 설치할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0509d81eee59f0e681a0c3f0c84d5a54a79b4f26" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can build the &lt;em&gt;.jar&lt;/em&gt; file without including the Kotlin runtime into it.</source>
          <target state="translated">다른 Kotlin 애플리케이션에서 사용할 라이브러리를 개발하는 경우 Kotlin 런타임을 포함하지 않고 &lt;em&gt;.jar&lt;/em&gt; 파일을 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="368782cf6eaff197b952127bcc0c0565b3479378" translate="yes" xml:space="preserve">
          <source>If you're developing a library to be used by other Kotlin applications, you can produce the .jar file without including the Kotlin runtime into it.</source>
          <target state="translated">다른 Kotlin 응용 프로그램에서 사용할 라이브러리를 개발하는 경우 Kotlin 런타임을 포함하지 않고 .jar 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da5d517a7b5384e2a44811f79965cdbfc0afba2" translate="yes" xml:space="preserve">
          <source>If you're new to Android and want to learn to create applications with Kotlin, check out &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;this Udacity course&lt;/a&gt;.</source>
          <target state="translated">Android를 처음 사용하고 Kotlin으로 애플리케이션을 만드는 방법을 배우고 싶다면 &lt;a href=&quot;https://www.udacity.com/course/developing-android-apps-with-kotlin--ud9012&quot;&gt;이 Udacity 과정을&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="f128e1fe8c8eb81ea54217b5ba66f82b1c59b061" translate="yes" xml:space="preserve">
          <source>If you're new to Kotlin, a good first step would be to familiarise yourself with the &lt;a href=&quot;basic-syntax&quot;&gt;Basic Syntax&lt;/a&gt; of the language.</source>
          <target state="translated">Kotlin을 처음 사용하는 경우 첫 번째 단계는 언어 의 &lt;a href=&quot;basic-syntax&quot;&gt;기본 구문&lt;/a&gt; 에 익숙해지는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="766f702953f8980e6bc50e185cc1d656f34dfbc1" translate="yes" xml:space="preserve">
          <source>If you're targeting JDK 7 or JDK 8, you can use extended versions of the Kotlin standard library which contain additional extension functions for APIs added in new JDK versions. Instead of &lt;code&gt;kotlin-stdlib&lt;/code&gt;, use &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; or &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt;, depending on your JDK version (for Kotlin 1.1.x use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; as the &lt;code&gt;jdk&lt;/code&gt; counterparts were introduced in 1.2.0).</source>
          <target state="translated">JDK 7 또는 JDK 8을 대상으로하는 경우 새 JDK 버전에 추가 된 API에 대한 추가 확장 기능이 포함 된 Kotlin 표준 라이브러리의 확장 버전을 사용할 수 있습니다. 대신에 &lt;code&gt;kotlin-stdlib&lt;/code&gt; , 사용 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 또는 &lt;code&gt;kotlin-stdlib-jdk8&lt;/code&gt; , 당신의 JDK 버전에 따라 (코 틀린 1.1.x의 사용을 위해 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 과 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 는 AS &lt;code&gt;jdk&lt;/code&gt; 대응 1.2에서 소개 .0).</target>
        </trans-unit>
        <trans-unit id="b775395194955c271aef49dac84498fbe90d7450" translate="yes" xml:space="preserve">
          <source>If you're targeting the JVM platform, you can also use Java's reflection system directly. In this example, we grab a function reference from an object's class by specifying the function's name as a string (if the function takes parameters, you also need to specify their types), and then we call it. Note that we didn't mention &lt;code&gt;String&lt;/code&gt; anywhere - this technique works without knowing what the object's class is, but it will raise an exception if the object's class doesn't have the requested function. However, Java-style function references do not have type information, so you won't get verification of the parameter types, and you must cast the return value:</source>
          <target state="translated">JVM 플랫폼을 대상으로하는 경우 Java 리플렉션 시스템을 직접 사용할 수도 있습니다. 이 예제에서는 함수 이름을 문자열로 지정하여 객체의 클래스에서 함수 참조를 가져옵니다 (함수가 매개 변수를 사용하는 경우 해당 유형도 지정해야 함). 우리는 어디서나 &lt;code&gt;String&lt;/code&gt; 을 언급하지 않았습니다. 이 기술은 객체의 클래스가 무엇인지 알지 못하고 작동하지만 객체의 클래스에 요청 된 기능이 없으면 예외가 발생합니다. 그러나 Java 스타일 함수 참조에는 유형 정보가 없으므로 매개 변수 유형을 확인할 수 없으므로 리턴 값을 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a761f12674bd3c30efe00ec7ea6eb2be1927a55" translate="yes" xml:space="preserve">
          <source>If you're targeting the browser and want to use a different module system than UMD, you can specify the desired module type in the &lt;code&gt;webpackTask&lt;/code&gt; configuration block. For example, to switch to CommonJS, use:</source>
          <target state="translated">브라우저를 대상으로하고 UMD와 다른 모듈 시스템을 사용하려는 경우 &lt;code&gt;webpackTask&lt;/code&gt; 구성 블록 에서 원하는 모듈 유형을 지정할 수 있습니다 . 예를 들어 CommonJS로 전환하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d2933676dc2f7e28b956599b006e00954f9395f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;em&gt;if&lt;/em&gt; as an expression rather than a statement (for example, returning its value or assigning it to a variable), the expression is required to have an &lt;code&gt;else&lt;/code&gt; branch.</source>
          <target state="translated">&lt;em&gt;if&lt;/em&gt; 대신 명령문을 표현식으로 사용하는 &lt;em&gt;경우&lt;/em&gt; (예 : 값을 리턴하거나 변수에 지정) 표현식에는 &lt;code&gt;else&lt;/code&gt; 분기 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="51fc2cadbf8df70dee87fb5d749d2ee884d218b0" translate="yes" xml:space="preserve">
          <source>If you're using a generic class whose type parameters haven't been declared in a variant way (either because its authors didn't think of it, or because the type parameters can't have either variance kind because they are used both as parameter types and return types), you can still use it in a variant way thanks to &lt;em&gt;type projection&lt;/em&gt;. The term &quot;projection&quot; refers to the fact that when you do this, you might restrict yourself to using only some of its members - so you're in a sense only seeing a partial, or &quot;projected&quot; version of the class. Let's look again at our &lt;code&gt;Bowl&lt;/code&gt; class, but without the variant interfaces this time:</source>
          <target state="translated">형식 매개 변수가 변형 방식으로 선언되지 않은 제네릭 클래스를 사용하는 경우 (작성자가 생각하지 않았거나 형식 매개 변수가 다음과 같이 모두 사용되므로 분산 유형을 가질 수 없기 때문에) 매개 변수 유형 및 반환 유형)의 경우 &lt;em&gt;유형 투영&lt;/em&gt; 덕분에 변형 방식으로 계속 사용할 수 있습니다 . &quot;투영&quot;이라는 용어는이 작업을 수행 할 때 일부 멤버 만 사용하도록 제한 할 수 있다는 점을 의미하므로 클래스의 일부 또는 &quot;예상 된&quot;버전 만 볼 수 있습니다. &lt;code&gt;Bowl&lt;/code&gt; 클래스를 다시 살펴 보지만 이번에는 변형 인터페이스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6e51da97890d2ae9ab3d189065498b378cc4fb2" translate="yes" xml:space="preserve">
          <source>If you've got one string that you want to write to a file, overwriting the existing contents if the file already exists, do this (again, UTF-8 is the default encoding):</source>
          <target state="translated">파일에 쓰려는 문자열이 하나 있으면, 파일이 이미 존재하는 경우 기존 내용을 덮어 쓰십시오. 이렇게하면 UTF-8이 기본 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="d91079d5275bf77f335cf6cb84c315d0b54d9ee8" translate="yes" xml:space="preserve">
          <source>If you've just upgraded to Kotlin 1.1 but can not use new language features yet (e.g. because some of your teammates may not have upgraded), you can pass &lt;code&gt;-language-version 1.0&lt;/code&gt;, which will restrict all APIs and language features to 1.0.</source>
          <target state="translated">Kotlin 1.1로 업그레이드했지만 아직 새로운 언어 기능을 사용할 수없는 경우 (예 : 일부 팀원이 업그레이드하지 않았을 수 있음) &lt;code&gt;-language-version 1.0&lt;/code&gt; 을 전달하면 모든 API 및 언어 기능이 1.0으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4d49a0aa58db91f5538f1484a110d84d269171" translate="yes" xml:space="preserve">
          <source>If your application already uses DBFlow, you can safely introduce Kotlin into your project. You can gradually convert existing code to Kotlin (ensuring that everything compiles along the way). The converted code doesn't differ much from Java. For instance, declaring a table looks similar to Java with the small difference that default values for properties must be specified explicitly:</source>
          <target state="translated">애플리케이션이 이미 DBFlow를 사용하는 경우 Kotlin을 프로젝트에 안전하게 소개 할 수 있습니다. 기존 코드를 Kotlin으로 점차 변환 할 수 있습니다 (모든 것이 진행되는 동안 컴파일되도록 보장). 변환 된 코드는 Java와 크게 다르지 않습니다. 예를 들어, 테이블 선언은 속성의 기본값을 명시 적으로 지정해야한다는 점이 약간 다르지만 Java와 비슷해 보입니다.</target>
        </trans-unit>
        <trans-unit id="f63962aa6cf85ec6f47c280bebab4a954c284cd2" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, write it inside a companion class:</source>
          <target state="translated">클래스에 고급 직렬화 논리가 필요한 경우 동반 클래스 내부에 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3503de21b9cb0b7cba965dc4634f2918727f903d" translate="yes" xml:space="preserve">
          <source>If your class requires more advanced serialization logic, you can write it inside a companion class:</source>
          <target state="translated">클래스에 고급 직렬화 논리가 필요한 경우 컴패니언 클래스 안에 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacc53066a886e6486df3248d96a52d89fd95863" translate="yes" xml:space="preserve">
          <source>If your code is too clever for the compiler, and you know without the help of &lt;code&gt;is&lt;/code&gt; that &lt;code&gt;x&lt;/code&gt; is an instance of &lt;code&gt;Person&lt;/code&gt; but the compiler doesn't, you can &lt;em&gt;cast&lt;/em&gt; your value with &lt;code&gt;as&lt;/code&gt;:</source>
          <target state="translated">코드는 컴파일러 너무 영리하고, 당신의 도움없이 알고있는 경우 &lt;code&gt;is&lt;/code&gt; 것을 &lt;code&gt;x&lt;/code&gt; 가 의 인스턴스 인 &lt;code&gt;Person&lt;/code&gt; 있지만, 컴파일러, 당신은 할 수 없습니다 &lt;em&gt;캐스트&lt;/em&gt; 로 값을 &lt;code&gt;as&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2ecf8bd14ee3aa94f5fa13c2b5cd616c3b320e5a" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well. The artifact IDs are &lt;code&gt;kotlin-reflect&lt;/code&gt; for the reflection library, and &lt;code&gt;kotlin-test&lt;/code&gt; and &lt;code&gt;kotlin-test-junit&lt;/code&gt; for the testing libraries.</source>
          <target state="translated">프로젝트에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin 리플렉션&lt;/a&gt; 또는 테스트 기능을 사용 하는 경우 해당 종속성도 추가해야합니다. 아티팩트 ID는 리플렉션 라이브러리에 대해 &lt;code&gt;kotlin-reflect&lt;/code&gt; 이고 &lt;code&gt;kotlin-test&lt;/code&gt; 라이브러리에 대해서는 kotlin-test 및 &lt;code&gt;kotlin-test-junit&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aaffb39c3271a99cd3c6b1dcd26285bb7f6d4133" translate="yes" xml:space="preserve">
          <source>If your project uses &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin reflection&lt;/a&gt; or testing facilities, you need to add the corresponding dependencies as well:</source>
          <target state="translated">프로젝트에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.reflect.full/index&quot;&gt;Kotlin 리플렉션&lt;/a&gt; 또는 테스트 기능을 사용 하는 경우 해당 종속성도 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff4ecabd35e3e545f9518b5b102d6fa77c32607a" translate="yes" xml:space="preserve">
          <source>If, by any chance, we need &quot;just an object&quot;, with no nontrivial supertypes, we can simply say:</source>
          <target state="translated">우발적이지 않은 슈퍼 타입이없는 &quot;단지 객체&quot;가 필요한 경우 간단히 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f78ba0d5d02014df85f65107c7688ad5093fc4b0" translate="yes" xml:space="preserve">
          <source>If, upon updating from one version to another, some code that used to work doesn't work any more, it is an &lt;em&gt;incompatible change&lt;/em&gt; in the language (sometimes referred to as &quot;breaking change&quot;). There can be debates as to what &quot;doesn't work any more&quot; means precisely in some cases, but it definitely includes the following:</source>
          <target state="translated">한 버전에서 다른 버전으로 업데이트 할 때 작동하는 데 사용 된 일부 코드가 더 이상 작동하지 않으면 언어 의 &lt;em&gt;호환되지 않는 변경&lt;/em&gt; (때로는 &quot;중단 변경&quot;이라고 함)입니다. 어떤 경우에는 &quot;더 이상 작동하지 않는다&quot;는 것이 무엇을 의미하는지에 대한 논쟁이있을 수 있지만, 반드시 다음을 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="ea0b39c7ffc510626fe28212437d8a57285e5a4c" translate="yes" xml:space="preserve">
          <source>IllegalArgumentException</source>
          <target state="translated">IllegalArgumentException</target>
        </trans-unit>
        <trans-unit id="906f0c92cf03edbafe4a5d12e37d92701ba25962" translate="yes" xml:space="preserve">
          <source>IllegalCallableAccessException</source>
          <target state="translated">IllegalCallableAccessException</target>
        </trans-unit>
        <trans-unit id="6bfee05d69b5aa826fde5d373d8ebea121200b58" translate="yes" xml:space="preserve">
          <source>IllegalCharacterConversionException</source>
          <target state="translated">IllegalCharacterConversionException</target>
        </trans-unit>
        <trans-unit id="6d13e3edbafba5c6ba6e57ae6bc8267296d1bf66" translate="yes" xml:space="preserve">
          <source>IllegalPropertyDelegateAccessException</source>
          <target state="translated">IllegalPropertyDelegateAccessException</target>
        </trans-unit>
        <trans-unit id="63b3abc14a5b2c9db143083b94887cb72910c4de" translate="yes" xml:space="preserve">
          <source>IllegalStateException</source>
          <target state="translated">IllegalStateException</target>
        </trans-unit>
        <trans-unit id="0ef9de975cdef9d9d9b896b68103ad59db30e33a" translate="yes" xml:space="preserve">
          <source>ImageBitmap</source>
          <target state="translated">ImageBitmap</target>
        </trans-unit>
        <trans-unit id="33f05a29887232f2adef5f1b64b04d6cf8bd78f2" translate="yes" xml:space="preserve">
          <source>ImageBitmapOptions</source>
          <target state="translated">ImageBitmapOptions</target>
        </trans-unit>
        <trans-unit id="91a39bdc5a33f203d5c2f138f0da931369fac84f" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContext</source>
          <target state="translated">ImageBitmapRenderingContext</target>
        </trans-unit>
        <trans-unit id="1a722437bfbd0c07b7f837b5b4332fd5d966ead2" translate="yes" xml:space="preserve">
          <source>ImageBitmapRenderingContextSettings</source>
          <target state="translated">ImageBitmapRenderingContextSettings</target>
        </trans-unit>
        <trans-unit id="b28af413c72a2e03556905d9b27766a80ae5dd7b" translate="yes" xml:space="preserve">
          <source>ImageBitmapSource</source>
          <target state="translated">ImageBitmapSource</target>
        </trans-unit>
        <trans-unit id="682b65e19d67a5e783299b757e21bec2832c6fb5" translate="yes" xml:space="preserve">
          <source>ImageData</source>
          <target state="translated">ImageData</target>
        </trans-unit>
        <trans-unit id="2217055c382ca08984df9c834dee428b5ed7c541" translate="yes" xml:space="preserve">
          <source>ImageOrientation</source>
          <target state="translated">ImageOrientation</target>
        </trans-unit>
        <trans-unit id="3394b71415cd8bd55fc9255b5d6beaf734d6f770" translate="yes" xml:space="preserve">
          <source>ImageSmoothingQuality</source>
          <target state="translated">ImageSmoothingQuality</target>
        </trans-unit>
        <trans-unit id="f98fd49f8f974a3886c42cb3693e5ffdf40539ee" translate="yes" xml:space="preserve">
          <source>Immediate superclasses of this class, in the order they are listed in the source code. Includes superclasses and superinterfaces of the class, but does not include the class itself.</source>
          <target state="translated">소스 코드에 나열된 순서대로이 클래스의 즉시 수퍼 클래스입니다. 클래스의 수퍼 클래스 및 수퍼 인터페이스를 포함하지만 클래스 자체는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="bb86d1b762a23d9068f4510901eeff7d18242638" translate="yes" xml:space="preserve">
          <source>Immutability in Kotlin/Native</source>
          <target state="translated">코 틀린 / 네이티브의 불변성</target>
        </trans-unit>
        <trans-unit id="7f8782e7a667262dd5095f5ff184ddd709f4772b" translate="yes" xml:space="preserve">
          <source>Immutability is a runtime property in Kotlin/Native, and can be applied to an arbitrary object subgraph using the &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; function. It makes all the objects reachable from the given one immutable, such a transition is a one-way operation (i.e., objects cannot be unfrozen later). Some naturally immutable objects such as &lt;code&gt;kotlin.String&lt;/code&gt;, &lt;code&gt;kotlin.Int&lt;/code&gt;, and other primitive types, along with &lt;code&gt;AtomicInt&lt;/code&gt; and &lt;code&gt;AtomicReference&lt;/code&gt; are frozen by default. If a mutating operation is applied to a frozen object, an &lt;code&gt;InvalidMutabilityException&lt;/code&gt; is thrown.</source>
          <target state="translated">불변성은 Kotlin / Native의 런타임 속성이며 &lt;code&gt;kotlin.native.concurrent.freeze&lt;/code&gt; 함수를 사용하여 임의의 개체 하위 그래프에 적용 할 수 있습니다 . 주어진 객체에서 모든 객체에 도달 할 수 없게 만듭니다. 이러한 전환은 단방향 작업입니다 (즉, 객체는 나중에 고정 해제 할 수 없음). &lt;code&gt;AtomicInt&lt;/code&gt; 및 &lt;code&gt;AtomicReference&lt;/code&gt; 와 함께 &lt;code&gt;kotlin.String&lt;/code&gt; , &lt;code&gt;kotlin.Int&lt;/code&gt; 및 기타 기본 유형과 같은 자연적으로 변경 불가능한 일부 객체 는 기본적으로 고정됩니다. 고정 작업이 고정 된 개체에 적용되면 &lt;code&gt;InvalidMutabilityException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed22a68de3c3f3cb15e1268df39db4a167fd746d" translate="yes" xml:space="preserve">
          <source>ImmutableBlob</source>
          <target state="translated">ImmutableBlob</target>
        </trans-unit>
        <trans-unit id="ee7341a728a58d68c7532bf18aeb0fac4452b6b5" translate="yes" xml:space="preserve">
          <source>Implementation by Delegation</source>
          <target state="translated">위임에 의한 구현</target>
        </trans-unit>
        <trans-unit id="dc1735ad8ce42355f885445d5ba551e409b9c86b" translate="yes" xml:space="preserve">
          <source>Implementations of the interface can override default methods.</source>
          <target state="translated">인터페이스 구현은 기본 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d5f96768fee4f4899fb4ea94381d1c87db0a66" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces</source>
          <target state="translated">인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="d640e1d5eb2b7a283f3bc3070dd151afc512fb6c" translate="yes" xml:space="preserve">
          <source>Implementing Interfaces in Enum Classes</source>
          <target state="translated">열거 형 클래스에서 인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="b2153d6fa67762548da1f8fe28f3d481ede48834" translate="yes" xml:space="preserve">
          <source>Implements the core logic of a property delegate for a read/write property that calls callback functions when changed.</source>
          <target state="translated">변경시 콜백 함수를 호출하는 읽기 / 쓰기 속성에 대한 속성 대리자의 핵심 논리를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b1af49118602d4ab9bd26831d35fc303f95ea13f" translate="yes" xml:space="preserve">
          <source>Implicit &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">암시 적 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="febd7a841f47bb67cef7b18f13ac806c637192b6" translate="yes" xml:space="preserve">
          <source>Important: files marked with &lt;code&gt;@file:JsModule&lt;/code&gt; annotation can't declare non-external members. The example below produces compile-time error:</source>
          <target state="translated">중요 : &lt;code&gt;@file:JsModule&lt;/code&gt; 주석으로 표시된 파일은 외부가 아닌 멤버를 선언 할 수 없습니다. 아래 예제는 컴파일 타임 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e45479a7a7959d4875b5ea4acddae533ace5e782" translate="yes" xml:space="preserve">
          <source>Importing deeper package hierarchies</source>
          <target state="translated">더 깊은 패키지 계층 가져 오기</target>
        </trans-unit>
        <trans-unit id="a932c1ce87f097109d85ae710ba5975b2888a20e" translate="yes" xml:space="preserve">
          <source>Importing synthetic properties</source>
          <target state="translated">합성 속성 가져 오기</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="513df22c9887b1f085e00ef3b729d3f007cfd9d9" translate="yes" xml:space="preserve">
          <source>Improved import handling</source>
          <target state="translated">수입 취급 개선</target>
        </trans-unit>
        <trans-unit id="d8972a1f28a588591d73ee09ddd836428eaca222" translate="yes" xml:space="preserve">
          <source>Improving smartcasts analysis by declaring the relation between a function's call outcome and the passed arguments values:</source>
          <target state="translated">함수의 호출 결과와 전달 된 인수 값 사이의 관계를 선언하여 스마트 캐스트 분석을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="3ea84fc4dca92bbd95cba0393e768bc0dbac665a" translate="yes" xml:space="preserve">
          <source>Improving the variable initialization analysis in the presence of high-order functions:</source>
          <target state="translated">고차 함수가있을 때 변수 초기화 분석 개선 :</target>
        </trans-unit>
        <trans-unit id="1a9aa64fd2cf728e6a54a37ad269e224c4406ae7" translate="yes" xml:space="preserve">
          <source>In &quot;clever words&quot; they say that the class &lt;code&gt;C&lt;/code&gt; is &lt;strong&gt;covariant&lt;/strong&gt; in the parameter &lt;code&gt;T&lt;/code&gt;, or that &lt;code&gt;T&lt;/code&gt; is a &lt;strong&gt;covariant&lt;/strong&gt; type parameter. You can think of &lt;code&gt;C&lt;/code&gt; as being a &lt;strong&gt;producer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s, and NOT a &lt;strong&gt;consumer&lt;/strong&gt; of &lt;code&gt;T&lt;/code&gt;'s.</source>
          <target state="translated">&quot;영리한 단어&quot;에서 그들은 클래스 &lt;code&gt;C&lt;/code&gt; 가 매개 변수 &lt;code&gt;T&lt;/code&gt; 에서 &lt;strong&gt;공변량&lt;/strong&gt; 이거나 &lt;code&gt;T&lt;/code&gt; 가 &lt;strong&gt;공변량&lt;/strong&gt; 유형 매개 변수 라고 말합니다 . 당신은 생각할 수있는 &lt;code&gt;C&lt;/code&gt; 것으로 &lt;strong&gt;생산자&lt;/strong&gt; 의 &lt;code&gt;T&lt;/code&gt; 의, 아닌 &lt;strong&gt;소비자&lt;/strong&gt; 의 &lt;code&gt;T&lt;/code&gt; 의.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6019b82a793e669523c1435271b5d51f4ccb4ffc" translate="yes" xml:space="preserve">
          <source>In 1.3 we reworked the entire multiplatform model. The &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;new DSL&lt;/a&gt; we have for describing multiplatform Gradle projects is much more flexible, and we'll keep working on it to make project configuration straightforward.</source>
          <target state="translated">1.3에서 우리는 전체 멀티 플랫폼 모델을 재 작업했습니다. &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;새로운 DSL&lt;/a&gt; 멀티 Gradle을 프로젝트를 설명하는 우리가 훨씬 더 유연, 우리는 프로젝트 구성 간단을하도록 노력하겠습니다.</target>
        </trans-unit>
        <trans-unit id="08f9bdd95bef61c2c357a6e138e1e9a913682812" translate="yes" xml:space="preserve">
          <source>In 1.3, we've completely reworked the model of multiplatform projects in order to improve expressiveness and flexibility, and to make sharing common code easier. Also, Kotlin/Native is now supported as one of the targets!</source>
          <target state="translated">1.3에서는 표현력과 유연성을 향상시키고 공통 코드를 더 쉽게 공유 할 수 있도록 멀티 플랫폼 프로젝트 모델을 완전히 재 작업했습니다. 또한 Kotlin / Native가 이제 대상 중 하나로 지원됩니다!</target>
        </trans-unit>
        <trans-unit id="5745802255877abfa046b72cbccdadc8221d5622" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collection-ordering&quot;&gt;Collection Ordering&lt;/a&gt;, we describe operations that retrieve collection elements in specific orders. For mutable lists, the standard library offers similar extension functions that perform the same ordering operations in place. When you apply such an operation to a list instance, it changes the order of elements in that exact instance.</source>
          <target state="translated">&lt;a href=&quot;collection-ordering&quot;&gt;콜렉션 순서&lt;/a&gt; 에서는 콜렉션 요소를 특정 순서로 검색하는 오퍼레이션을 설명합니다. 가변 목록의 경우 표준 라이브러리는 동일한 순서 지정 작업을 수행하는 유사한 확장 기능을 제공합니다. 이러한 작업을 목록 인스턴스에 적용하면 해당 인스턴스의 요소 순서가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="be8a31aea4fdca8e3b9bdedb1958918e98cae1d2" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;collections-overview#map&quot;&gt;maps&lt;/a&gt;, types of both keys and values are user-defined. Key-based access to map entries enables various map-specific processing capabilities from getting a value by key to separate filtering of keys and values. On this page, we provide descriptions of the map processing functions from the standard library.</source>
          <target state="translated">에서 &lt;a href=&quot;collections-overview#map&quot;&gt;지도&lt;/a&gt; , 모두 키와 값의 유형은 사용자 정의입니다. 맵 항목에 대한 키 기반 액세스는 키별로 값을 얻는 것부터 키와 값을 별도로 필터링하는 것까지 다양한 맵 특정 처리 기능을 가능하게합니다. 이 페이지에서는 표준 라이브러리의 맵 처리 기능에 대한 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7454358e40f9eaf26ccc7cd55f4c30f555918de5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;the previous tutorial&lt;/a&gt; we created a &lt;code&gt;lib.h&lt;/code&gt; file. This time, we are going to include those declarations directly into the &lt;code&gt;interop.def&lt;/code&gt; file, after the &lt;code&gt;---&lt;/code&gt; separator line:</source>
          <target state="translated">에서 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;이전 튜토리얼&lt;/a&gt; 우리는 생성 &lt;code&gt;lib.h&lt;/code&gt; 파일을. 이번에 는 &lt;code&gt;---&lt;/code&gt; 구분자 행 다음에 해당 선언을 &lt;code&gt;interop.def&lt;/code&gt; 파일에 직접 포함시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f0454a21172602b262219293f4778fc730c2daf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;build.gradle.kts&lt;/code&gt; (or &lt;code&gt;build.gradle&lt;/code&gt;) of your IDEA project, apply the CocoaPods plugin as well as the Kotlin Multiplatform plugin.</source>
          <target state="translated">에서 &lt;code&gt;build.gradle.kts&lt;/code&gt; (또는 &lt;code&gt;build.gradle&lt;/code&gt; ) 당신의 IDEA 프로젝트의 CocoaPods가 코 틀린 멀티 플러그인뿐만 아니라 플러그인 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f2d8d96fc34753484a87526254e4a4f003f9c05" translate="yes" xml:space="preserve">
          <source>In Android projects, additional Kotlin source sets are created for each &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android source set&lt;/a&gt;. If the Android target has a name &lt;code&gt;foo&lt;/code&gt;, the Android source set &lt;code&gt;bar&lt;/code&gt; gets a Kotlin source set counterpart &lt;code&gt;fooBar&lt;/code&gt;. The Kotlin compilations, however, are able to consume Kotlin sources from all of the directories &lt;code&gt;src/bar/java&lt;/code&gt;, &lt;code&gt;src/bar/kotlin&lt;/code&gt;, and &lt;code&gt;src/fooBar/kotlin&lt;/code&gt;. Java sources are only read from the first of these directories.</source>
          <target state="translated">Android 프로젝트에서 각 &lt;a href=&quot;https://developer.android.com/studio/build/#sourcesets&quot;&gt;Android 소스 세트&lt;/a&gt; 마다 추가 Kotlin 소스 세트가 작성 됩니다 . Android 대상의 이름이 &lt;code&gt;foo&lt;/code&gt; 인 경우 Android 소스 세트 &lt;code&gt;bar&lt;/code&gt; 는 Kotlin 소스 세트 대응 &lt;code&gt;fooBar&lt;/code&gt; 를 가져 옵니다 . 그러나 Kotlin 컴파일은 &lt;code&gt;src/bar/java&lt;/code&gt; , &lt;code&gt;src/bar/kotlin&lt;/code&gt; 및 &lt;code&gt;src/fooBar/kotlin&lt;/code&gt; 디렉토리에서 Kotlin 소스를 사용할 수 있습니다 . Java 소스는이 디렉토리 중 첫 번째 디렉토리에서만 읽습니다.</target>
        </trans-unit>
        <trans-unit id="33342ff8fe9e060731185ad7c136d99b9461055f" translate="yes" xml:space="preserve">
          <source>In Gradle</source>
          <target state="translated">Gradle에서</target>
        </trans-unit>
        <trans-unit id="9ffad76a20436e6770075c18f7fc5a623588a28f" translate="yes" xml:space="preserve">
          <source>In Gradle 5.3 and above, the module metadata is always used during dependency resolution, but publications don't include any module metadata by default. To enable module metadata publishing, add &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; to the root project's &lt;code&gt;settings.gradle&lt;/code&gt; file. With older Gradle versions, this is also required for module metadata consumption.</source>
          <target state="translated">Gradle 5.3 이상에서 모듈 메타 데이터는 항상 종속성 해결 중에 사용되지만 발행물에는 기본적으로 모듈 메타 데이터가 포함되어 있지 않습니다. 모듈 메타 데이터 게시를 활성화하려면 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 를 루트 프로젝트의 &lt;code&gt;settings.gradle&lt;/code&gt; 파일에 추가하십시오. 이전 Gradle 버전에서는 모듈 메타 데이터 소비에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="db8d93f584f6cd9be9c19cceb09290c42348f8b6" translate="yes" xml:space="preserve">
          <source>In Gradle command line parameters: add the parameter &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; or &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; with the boolean value reflecting the usage of incremental compilation. Note that in this case the parameter should be added to each subsequent build, and any build with disabled incremental compilation invalidates incremental caches.</source>
          <target state="translated">Gradle 명령 행 매개 변수에서 : 증분 컴파일 사용법을 반영하는 부울 값과 함께 &lt;code&gt;-Pkotlin.incremental&lt;/code&gt; 또는 &lt;code&gt;-Pkotlin.incremental.js&lt;/code&gt; 매개 변수를 추가하십시오 . 이 경우, 각 후속 빌드에 매개 변수를 추가해야하며, 증분 컴파일이 비활성화 된 빌드는 증분 캐시를 무효화합니다.</target>
        </trans-unit>
        <trans-unit id="d95af6982c4662ae34dc8dfd04c6f3d77bb71544" translate="yes" xml:space="preserve">
          <source>In Gradle configuration files: add the line &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JVM or &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; for Kotlin/JS projects either to &lt;code&gt;gradle.properties&lt;/code&gt; or to &lt;code&gt;local.properties&lt;/code&gt; file. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; is a boolean value reflecting the usage of incremental compilation.</source>
          <target state="translated">Gradle을 구성 파일 : 광고 추가 &lt;code&gt;kotlin.incremental=&amp;lt;value&amp;gt;&lt;/code&gt; 코 틀린 / 또는 JVM위한 &lt;code&gt;kotlin.incremental.js=&amp;lt;value&amp;gt;&lt;/code&gt; 에 어느 코 틀린 / JS 프로젝트 &lt;code&gt;gradle.properties&lt;/code&gt; 거나 &lt;code&gt;local.properties&lt;/code&gt; 의 파일. &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 는 증분 컴파일 사용법을 반영하는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="537c1a3af537507e4b627b3261006ddbdae522fd" translate="yes" xml:space="preserve">
          <source>In Gradle:</source>
          <target state="translated">Gradle에서 :</target>
        </trans-unit>
        <trans-unit id="d2d1d0c783432497ec07d157b951c4e78d7cc0b8" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt; and check the &lt;em&gt;Create from archetype&lt;/em&gt; box:</source>
          <target state="translated">IntelliJ IDEA에서 &lt;em&gt;파일-&amp;gt; 새로 작성&amp;gt; 프로젝트&amp;hellip;&lt;/em&gt; 로 이동하여 &lt;em&gt;아키 타입&lt;/em&gt; 에서 &lt;em&gt;작성&lt;/em&gt; 상자를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4d485a76c7a3760895d18fab529fc51f77b28063" translate="yes" xml:space="preserve">
          <source>In IntelliJ IDEA go to &lt;em&gt;File -&amp;gt; New &amp;gt; Project&amp;hellip;&lt;/em&gt;:</source>
          <target state="translated">IntelliJ IDEA에서 &lt;em&gt;File-&amp;gt; New&amp;gt; Project&amp;hellip;로 이동하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc14db5a6e801d7da035df405c7d7827fc53b41" translate="yes" xml:space="preserve">
          <source>In JVM platform code:</source>
          <target state="translated">JVM 플랫폼 코드에서 :</target>
        </trans-unit>
        <trans-unit id="513ad5f28a98a53d38c2cd4b1ebf3e53ba78a0e9" translate="yes" xml:space="preserve">
          <source>In Java you specify &lt;code&gt;Dagger&lt;/code&gt; as &lt;code&gt;annotationProcessor&lt;/code&gt; (or &lt;code&gt;apt&lt;/code&gt;) dependency:</source>
          <target state="translated">Java에서는 &lt;code&gt;Dagger&lt;/code&gt; 를 &lt;code&gt;annotationProcessor&lt;/code&gt; (또는 &lt;code&gt;apt&lt;/code&gt; ) 종속성으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e76e330054ec3492dbde5d95b20d3d1c9ac12e6f" translate="yes" xml:space="preserve">
          <source>In Java, we are used to classes named &quot;*Utils&quot;: &lt;code&gt;FileUtils&lt;/code&gt;, &lt;code&gt;StringUtils&lt;/code&gt; and so on. The famous &lt;code&gt;java.util.Collections&lt;/code&gt; belongs to the same breed. And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</source>
          <target state="translated">Java에서는 &quot;* Utils&quot;라는 클래스 , &lt;code&gt;FileUtils&lt;/code&gt; , &lt;code&gt;StringUtils&lt;/code&gt; 등이 사용됩니다. 유명한 &lt;code&gt;java.util.Collections&lt;/code&gt; 는 동일한 유형에 속합니다. 이 Utils 클래스에 대한 불쾌한 부분은이를 사용하는 코드가 다음과 같다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8310a54b24568803ae04cc82e73e4ed7d64a2ce9" translate="yes" xml:space="preserve">
          <source>In Java:</source>
          <target state="translated">자바에서 :</target>
        </trans-unit>
        <trans-unit id="abb66954294d1e4253f6894befd4961b0fc88ece" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself. I.e.:</source>
          <target state="translated">JavaScript에서는 프로토 타입 또는 클래스 자체에서 멤버를 정의 할 수 있습니다. 즉 :</target>
        </trans-unit>
        <trans-unit id="592ce5c07c0fe6dc9a4e0ec16760d4af84a287b3" translate="yes" xml:space="preserve">
          <source>In JavaScript you can define members either on a prototype or a class itself:</source>
          <target state="translated">JavaScript에서는 프로토 타입이나 클래스 자체에서 멤버를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73e80ab874eb4a673c8b0548f2f4b1a57e2e5b0" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.0, code in the lambda passed to &lt;code&gt;td&lt;/code&gt; has access to three implicit receivers: the one passed to &lt;code&gt;table&lt;/code&gt;, to &lt;code&gt;tr&lt;/code&gt; and to &lt;code&gt;td&lt;/code&gt;. This allows you to call methods that make no sense in the context - for example to call &lt;code&gt;tr&lt;/code&gt; inside &lt;code&gt;td&lt;/code&gt; and thus to put a &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; tag in a &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin 1.0에서 &lt;code&gt;td&lt;/code&gt; 에 전달 된 람다의 코드는 3 개의 암시 적 수신자에 액세스 할 수 있습니다. 하나는 &lt;code&gt;table&lt;/code&gt; , &lt;code&gt;tr&lt;/code&gt; 및 &lt;code&gt;td&lt;/code&gt; 에 전달됩니다 . 이를 통해 컨텍스트에서 의미가없는 메소드를 호출 할 수 있습니다. 예를 들어 &lt;code&gt;td&lt;/code&gt; 내부에서 &lt;code&gt;tr&lt;/code&gt; 을 호출 하여 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 태그 를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="faca07a0c2f2dcf45e7526d00d395e3cdc377fcb" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1, you can restrict that, so that only methods defined on the implicit receiver of &lt;code&gt;td&lt;/code&gt; will be available inside the lambda passed to &lt;code&gt;td&lt;/code&gt;. You do that by defining your annotation marked with the &lt;code&gt;@DslMarker&lt;/code&gt; meta-annotation and applying it to the base class of the tag classes.</source>
          <target state="translated">코 틀린 1.1에서는 암시 적 수신기에 정의 된 메소드 만 그래서, 그것을 제한 할 수 있습니다 &lt;code&gt;td&lt;/code&gt; 람다가 전달 내에서 사용할 수 &lt;code&gt;td&lt;/code&gt; . &lt;code&gt;@DslMarker&lt;/code&gt; 메타 주석으로 표시된 주석을 정의 하고 태그 클래스의 기본 클래스에 적용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="24a213ee88ffeaa2bec3378db48986b075744611" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.1.x, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; instead.</source>
          <target state="translated">Kotlin 1.1.x에서는 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; 을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ea3af6627b279c964f114bd464c51ab696c689f" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3 it is possible for annotations to have nested classes, interfaces, objects, and companions:</source>
          <target state="translated">Kotlin 1.3에서는 주석에 중첩 클래스, 인터페이스, 객체 및 컴패니언이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3098d1aa730f31e91846c87eaae7ac71342cdc7e" translate="yes" xml:space="preserve">
          <source>In Kotlin 1.3, it is now possible to capture the &lt;code&gt;when&lt;/code&gt; subject into variable:</source>
          <target state="translated">Kotlin 1.3에서는 이제 변수 가 &lt;code&gt;when&lt;/code&gt; 를 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a99d2573a55fb319e350044cce69239e344a488" translate="yes" xml:space="preserve">
          <source>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, which you are required to do in languages such as Java, C# or Scala. In addition to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</source>
          <target state="translated">Kotlin에서 함수는 파일에서 최상위 레벨로 선언 될 수 있습니다. 즉, Java, C # 또는 Scala와 같은 언어로 수행해야하는 함수를 보유하기 위해 클래스를 작성할 필요가 없습니다. Kotlin 함수는 최상위 함수 외에도 멤버 함수 및 확장 함수로 로컬로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5176ee2358fd7911cf590e90f48fd7d921131e2" translate="yes" xml:space="preserve">
          <source>In Kotlin there are two types of equality:</source>
          <target state="translated">코 틀린에는 두 가지 유형의 평등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1307e7346626ce5c88b95620e1843731ae3969f4" translate="yes" xml:space="preserve">
          <source>In Kotlin this line can be concisely parsed with the following statement using &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;destructuring declaration&lt;/a&gt; from a list of integers:</source>
          <target state="translated">Kotlin 에서이 줄 은 정수 목록에서 &lt;a href=&quot;../reference/multi-declarations#destructuring-declarations&quot;&gt;파괴 선언&lt;/a&gt; 을 사용하여 다음 문장으로 간결하게 구문 분석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2cb95a39c5087932a02f405cc63f954a5dedc22" translate="yes" xml:space="preserve">
          <source>In Kotlin you can provide upper bounds for a generic type. Objective-C also supports this, but that support is unavailable in more complex cases, and is currently not supported in the Kotlin - Objective-C interop. The exception here being a non-null upper bound will make Objective-C methods/properties non-null.</source>
          <target state="translated">Kotlin에서는 일반 유형에 대한 상한을 제공 할 수 있습니다. Objective-C도이를 지원하지만보다 복잡한 경우에는 지원되지 않으며 현재 Kotlin-Objective-C interop에서는 지원되지 않습니다. 여기서 null이 아닌 상한 인 경우 Objective-C 메서드 / 속성이 null이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef29e345af9c063df71b3f01a21f78a928c57611" translate="yes" xml:space="preserve">
          <source>In Kotlin you can't work with fields directly, you work with &lt;a href=&quot;../reference/properties&quot;&gt;properties&lt;/a&gt;. You annotate the property:</source>
          <target state="translated">Kotlin에서는 필드로 직접 작업 할 수 없으며 &lt;a href=&quot;../reference/properties&quot;&gt;properties로&lt;/a&gt; 작업 할 수 있습니다 . 속성에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="b1411aa40ea7c5b9a0de303333e37baf632f1665" translate="yes" xml:space="preserve">
          <source>In Kotlin you have to add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin to enable &lt;code&gt;kapt&lt;/code&gt;, and then replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">코 틀린에서 당신은 추가 할 필요가 &lt;code&gt;kotlin-kapt&lt;/code&gt; 수 있도록 플러그인을 &lt;code&gt;kapt&lt;/code&gt; 하고 대체 &lt;code&gt;annotationProcessor&lt;/code&gt; 을 함께 &lt;code&gt;kapt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da7a2b73e175cb7362740b3fbdff60c8cc8e5724" translate="yes" xml:space="preserve">
          <source>In Kotlin you specify the dependencies in a similar to Java way using &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation processing tool&lt;/a&gt; (&lt;code&gt;kapt&lt;/code&gt;) instead of &lt;code&gt;annotationProcessor&lt;/code&gt;.</source>
          <target state="translated">Kotlin에서는 &lt;code&gt;annotationProcessor&lt;/code&gt; 대신 &lt;a href=&quot;../reference/kapt&quot;&gt;Kotlin Annotation Processing Tool&lt;/a&gt; ( &lt;code&gt;kapt&lt;/code&gt; )을 사용하여 Java와 유사한 방식으로 종속성을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0a2601b06937bb12c0744830de8e7b372473464e" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt;&lt;code&gt;plus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;+&lt;/code&gt;) and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt;&lt;code&gt;minus&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;-&lt;/code&gt;) operators are defined for collections. They take a collection as the first operand; the second operand can be either an element or another collection. The return value is a new read-only collection:</source>
          <target state="translated">Kotlin에서는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/plus&quot;&gt; &lt;code&gt;plus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;+&lt;/code&gt; ) 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/minus&quot;&gt; &lt;code&gt;minus&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;-&lt;/code&gt; ) 연산자가 콜렉션에 대해 정의됩니다. 그들은 첫 번째 피연산자로 컬렉션을 취합니다. 두 번째 피연산자는 요소 또는 다른 컬렉션 일 수 있습니다. 반환 값은 새로운 읽기 전용 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="78f4990d53a6e7c8067b2fe1adea30492b815286" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; can also be used as an expression:</source>
          <target state="translated">Kotlin에서 &lt;em&gt;if&lt;/em&gt; 는 표현식으로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="630fd5574aed5de24f8dfa12e49c30f220082837" translate="yes" xml:space="preserve">
          <source>In Kotlin, &lt;em&gt;if&lt;/em&gt; is an expression, i.e. it returns a value. Therefore there is no ternary operator (condition ? then : else), because ordinary &lt;em&gt;if&lt;/em&gt; works fine in this role.</source>
          <target state="translated">Kotlin에서 &lt;em&gt;if&lt;/em&gt; 는 표현식입니다. 즉, 값을 반환합니다. 따라서 평범한 &lt;em&gt;경우이&lt;/em&gt; 역할에서 잘 작동 하기 때문에 삼항 연산자 (조건? then : else)는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="449834b1db02375da0148e9e57aea36e01ccf956" translate="yes" xml:space="preserve">
          <source>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything:</source>
          <target state="translated">Kotlin에서는 모든 예외가 선택 해제되어있어 컴파일러가 강제로 예외를 포착하지 않습니다. 따라서 확인 된 예외를 선언하는 Java 메소드를 호출 할 때 Kotlin은 다음을 수행하도록 강요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccb7acc6feff10a66296746e0c93a95c37a6267f" translate="yes" xml:space="preserve">
          <source>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some of the types can have a special internal representation - for example, numbers, characters and booleans can be represented as primitive values at runtime - but to the user they look like ordinary classes. In this section we describe the basic types used in Kotlin: numbers, characters, booleans, arrays, and strings.</source>
          <target state="translated">Kotlin에서 모든 것은 모든 변수에서 멤버 함수 및 속성을 호출 할 수 있다는 의미에서 객체입니다. 일부 유형은 특수한 내부 표현을 가질 수 있습니다 (예 : 숫자, 문자 및 부울은 런타임시 기본 값으로 표시 될 수 있음). 그러나 사용자에게는 일반 클래스처럼 보입니다. 이 섹션에서는 Kotlin에서 사용되는 기본 유형 인 숫자, 문자, 부울, 배열 및 문자열에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bcc1b8c2a992c6c34b455f92da91c74149cd8719" translate="yes" xml:space="preserve">
          <source>In Kotlin, functional types are represented as generic classes taking a different number of parameters: &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt;, &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt;, &amp;hellip; This approach has a problem in that this list is finite, and it currently ends with &lt;code&gt;Function22&lt;/code&gt;.</source>
          <target state="translated">Kotlin에서 기능 유형은 다른 수의 매개 변수를 갖는 일반 클래스로 표시됩니다. &lt;code&gt;Function0&amp;lt;R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function1&amp;lt;P0, R&amp;gt;&lt;/code&gt; , &lt;code&gt;Function2&amp;lt;P0, P1, R&amp;gt;&lt;/code&gt; ,&amp;hellip;이 방법은이 목록이 유한하다는 문제가 있습니다. 현재 &lt;code&gt;Function22&lt;/code&gt; 로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="dda94f8bd95fbc2c5d984c18e048611fb7b42dbc" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlin에서 구현 상속은 다음 규칙에 의해 규제됩니다. 클래스가 직속 슈퍼 클래스에서 동일한 멤버의 많은 구현을 상속하는 경우이 멤버를 무시하고 자체 구현 (아마 상속 된 클래스 중 하나 사용)을 제공해야합니다. 상속 구현이 촬영되는 슈퍼 타입을 표시하기 위해, 우리가 사용하는 &lt;em&gt;슈퍼&lt;/em&gt; 꺾쇠 괄호 상위 유형의 이름으로 규정, 예를 들어 &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7e8de20bd90cf59ff062bcee3a6b6475fd0af4bb" translate="yes" xml:space="preserve">
          <source>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits multiple implementations of the same member from its immediate superclasses, it must override this member and provide its own implementation (perhaps, using one of the inherited ones). To denote the supertype from which the inherited implementation is taken, we use &lt;em&gt;super&lt;/em&gt; qualified by the supertype name in angle brackets, e.g. &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Kotlin에서 구현 상속은 다음 규칙에 의해 규제됩니다. 클래스가 직계 수퍼 클래스에서 동일한 멤버의 여러 구현을 상속하는 경우이 멤버를 재정의하고 자체 구현을 제공해야합니다 (상속 된 항목 중 하나를 사용). 상속 된 구현을 가져 오는 상위 유형을 표시하기 위해 꺾쇠 괄호 안에있는 상위 유형 이름에 의해 정규화 된 &lt;em&gt;super&lt;/em&gt; 를 사용합니다 ( 예 : &lt;code&gt;super&amp;lt;Base&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dcc76eece2b8bf2e4ff6b5b682eb767b78c7f50" translate="yes" xml:space="preserve">
          <source>In Kotlin, importing is a compile-time concept - importing something does not actually cause any code to run (unlike Python, where all top-level statements in a file are executed at import time). Therefore, circular imports are allowed, but they might suggest a design problem in your code. However, during execution, a class will be loaded the first time it (or any of its properties or functions) is referenced, and class loading causes &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt; to be initialized - this can lead to runtime exceptions if you have circular dependencies.</source>
          <target state="translated">Kotlin에서 가져 오기는 컴파일 타임 개념입니다. 무언가를 가져 오면 실제로 코드가 실행되지 않습니다 (파이썬과 달리 파일의 모든 최상위 문은 가져 오기 시간에 실행 됨). 따라서 순환 가져 오기는 허용되지만 코드에서 디자인 문제를 암시 할 수 있습니다. 그러나 실행하는 동안 클래스 (또는 해당 속성 또는 함수)가 처음 참조 될 때 클래스가로드되고 클래스로드로 인해 &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;컴패니언 개체&lt;/a&gt; 가 초기화되므로 순환 종속성이있는 경우 런타임 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9724d2f4d0f2fb74f7ee2235878c749f495a0bad" translate="yes" xml:space="preserve">
          <source>In Kotlin, polymorphism is achieved via the class hierarchy, in such a way that it is impossible to run into a situation where a property or function is missing. The basic rule is that a variable/property/parameter whose declared type is &lt;code&gt;A&lt;/code&gt; may refer to an instance of a class &lt;code&gt;B&lt;/code&gt; if and only if &lt;code&gt;B&lt;/code&gt; is a subtype of &lt;code&gt;A&lt;/code&gt;. This means that either, &lt;code&gt;A&lt;/code&gt; must be a class and &lt;code&gt;B&lt;/code&gt; must be a subclass of &lt;code&gt;A&lt;/code&gt;, or that &lt;code&gt;A&lt;/code&gt; must be an interface and &lt;code&gt;B&lt;/code&gt; must be a class that implements that interface or be a subclass of a class that does. With our classes and interfaces from the previous sections, we can define these functions:</source>
          <target state="translated">Kotlin에서 다형성은 클래스 계층 구조를 통해 달성되므로 속성이나 함수가 누락 된 상황에 빠질 수 없습니다. 기본 규칙은 선언 된 유형이 &lt;code&gt;A&lt;/code&gt; 인 변수 / 속성 / 매개 변수가 &lt;code&gt;B&lt;/code&gt; 가 &lt;code&gt;A&lt;/code&gt; 의 하위 유형 인 경우에만 클래스 &lt;code&gt;B&lt;/code&gt; 의 인스턴스를 참조 할 수 있다는 것 입니다. 즉, &lt;code&gt;A&lt;/code&gt; 는 클래스 여야 하고 &lt;code&gt;B&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 의 서브 클래스 여야 하거나 &lt;code&gt;A&lt;/code&gt; 는 인터페이스 여야 하고 &lt;code&gt;B&lt;/code&gt; 는 해당 인터페이스를 구현하는 클래스이거나 수행하는 클래스의 서브 클래스 여야합니다. 이전 섹션의 클래스와 인터페이스를 사용하여 다음 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ea4efcee086c70a1dc18d5edfeb999729e27f06" translate="yes" xml:space="preserve">
          <source>In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.</source>
          <target state="translated">Kotlin에서 세미콜론은 선택 사항이므로 줄 바꿈이 중요합니다. 언어 디자인은 Java 스타일 중괄호를 가정하고 다른 형식화 ​​스타일을 사용하려고하면 놀라운 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea952e978cda6b66f0b076e1bf4afae5776a252" translate="yes" xml:space="preserve">
          <source>In Kotlin, the default implementation of &lt;code&gt;List&lt;/code&gt; is &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt;&lt;code&gt;ArrayList&lt;/code&gt;&lt;/a&gt; which you can think of as a resizable array.</source>
          <target state="translated">코 틀린에서의 기본 구현 &lt;code&gt;List&lt;/code&gt; 입니다 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-array-list/index&quot;&gt; &lt;code&gt;ArrayList&lt;/code&gt; 에&lt;/a&gt; 당신이 크기 조정 배열로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f2e47b033955ac0009c7acc59029af121c0f6e" translate="yes" xml:space="preserve">
          <source>In Kotlin, the expression for a default value is evaluated every time the function is invoked. Therefore, you will avoid the above trap as long as you use an expression that produces a new list every time it is evaluated:</source>
          <target state="translated">Kotlin에서, 기본값에 대한 표현식은 함수가 호출 될 때마다 평가됩니다. 따라서 평가 될 때마다 새 목록을 생성하는 표현식을 사용하는 한 위의 트랩을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f711d573309109397667a32c94fd541ceecdc60" translate="yes" xml:space="preserve">
          <source>In Kotlin, the orders of objects can be defined in several ways.</source>
          <target state="translated">코 틀린에서는 객체의 순서를 여러 가지 방법으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2339e3beff8d4c7968bd5b14328be82bd9a5b046" translate="yes" xml:space="preserve">
          <source>In Kotlin, the type system distinguishes between references that can hold &lt;em&gt;null&lt;/em&gt; (nullable references) and those that can not (non-null references). For example, a regular variable of type &lt;code&gt;String&lt;/code&gt; can not hold &lt;em&gt;null&lt;/em&gt;:</source>
          <target state="translated">Kotlin에서 형식 시스템은 &lt;em&gt;null&lt;/em&gt; 을 보유 할 수있는 참조 (널링 가능 참조)와 그렇지 않은 참조를 구분합니다 (Null이 아닌 참조). 예를 들어, &lt;code&gt;String&lt;/code&gt; 유형의 일반 변수는 &lt;em&gt;null을&lt;/em&gt; 보유 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="832014b08edc07489a35f79862dd60fe09daab6f" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a convention: if the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</source>
          <target state="translated">Kotlin에는 규칙이 있습니다. 함수의 마지막 매개 변수가 함수이면 해당 인수로 전달 된 람다 식을 괄호 밖에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a3923bf671e235e84ea1d045b896ec7fad1d7d" translate="yes" xml:space="preserve">
          <source>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called &lt;strong&gt;declaration-site variance&lt;/strong&gt;: we can annotate the &lt;strong&gt;type parameter&lt;/strong&gt;&lt;code&gt;T&lt;/code&gt; of Source to make sure that it is only &lt;strong&gt;returned&lt;/strong&gt; (produced) from members of &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt;, and never consumed. To do this we provide the &lt;strong&gt;out&lt;/strong&gt; modifier:</source>
          <target state="translated">코 틀린에는 이런 종류의 것을 컴파일러에게 설명 할 수있는 방법이 있습니다. 이것을 &lt;strong&gt;선언 사이트 분산&lt;/strong&gt; 이라고합니다 . &lt;code&gt;Source&amp;lt;T&amp;gt;&lt;/code&gt; 멤버로부터 만 &lt;strong&gt;반환&lt;/strong&gt; (생산)되고 소비되지 않도록 Source 의 &lt;strong&gt;형식 매개 변수 &lt;/strong&gt; &lt;code&gt;T&lt;/code&gt; 에 주석을 달 수 있습니다 . 이를 위해 &lt;strong&gt;out&lt;/strong&gt; 수정자를 제공합니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="feddf47fe54f2c3f729a6d26efa190cb7e973f88" translate="yes" xml:space="preserve">
          <source>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it's recommended to simply use package-level functions instead.</source>
          <target state="translated">Kotlin에서 Java 또는 C #과 달리 클래스에는 정적 메소드가 없습니다. 대부분의 경우 패키지 수준 함수를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d5e92ec06e3b15b62ad5ec58ebeffa93765ab71a" translate="yes" xml:space="preserve">
          <source>In Kotlin, we can only use a normal, unqualified &lt;code&gt;return&lt;/code&gt; to exit a named function or an anonymous function. This means that to exit a lambda, we have to use a &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt;, and a bare &lt;code&gt;return&lt;/code&gt; is forbidden inside a lambda, because a lambda cannot make the enclosing function return:</source>
          <target state="translated">Kotlin에서는 정규화되지 않은 정규 &lt;code&gt;return&lt;/code&gt; 만 사용 하여 명명 된 함수 또는 익명 함수를 종료 할 수 있습니다. 이것은 람다를 종료하려면 &lt;a href=&quot;returns#return-at-labels&quot;&gt;label&lt;/a&gt; 을 사용해야 하고 람다는 둘러싼 함수를 반환 할 수 없기 때문에 람다 내에서 베어 &lt;code&gt;return&lt;/code&gt; 이 금지됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0bc591251b1866272d3defd4ab24986b180f3e99" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.</source>
          <target state="translated">StringBuilder의 Kotlin / JS 구현에서 초기 용량은 작업의 추가 성능에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d25d5f146a0d36095ac2d2fbada4dfa30e5c1b3" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</source>
          <target state="translated">In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.</target>
        </trans-unit>
        <trans-unit id="9c5a4446d1a6bca7a876f80da83f707725750c3e" translate="yes" xml:space="preserve">
          <source>In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</source>
          <target state="translated">In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given &lt;a href=&quot;ensure-capacity#kotlin.text.StringBuilder%24ensureCapacity(kotlin.Int)/minimumCapacity&quot;&gt;minimumCapacity&lt;/a&gt;, thus calling this method has no effect on the further performance of operations.</target>
        </trans-unit>
        <trans-unit id="6b416b284c329b83d138fdf71a7f58ad406d7c9b" translate="yes" xml:space="preserve">
          <source>In Maven</source>
          <target state="translated">메이븐에서</target>
        </trans-unit>
        <trans-unit id="9ce095374b679dfd053dccebdba1f6ce80a67e34" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;jpa&lt;/code&gt; plugin:</source>
          <target state="translated">Maven에서 &lt;code&gt;jpa&lt;/code&gt; 플러그인을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cf1f43e65b88c5f6958702897fafbb7af63f2e9" translate="yes" xml:space="preserve">
          <source>In Maven, enable the &lt;code&gt;spring&lt;/code&gt; plugin:</source>
          <target state="translated">Maven에서 &lt;code&gt;spring&lt;/code&gt; 플러그인을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="14be0db4481edc4ab423c4343db7ab0c7cfdc4a9" translate="yes" xml:space="preserve">
          <source>In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</source>
          <target state="translated">In Maven, the &lt;code&gt;spring&lt;/code&gt; plugin is provided by the &lt;code&gt;kotlin-maven-allopen&lt;/code&gt; plugin dependency, so to enable it:</target>
        </trans-unit>
        <trans-unit id="2fde5916b654de021cf5316e7c8446b2d071c3b3" translate="yes" xml:space="preserve">
          <source>In Maven:</source>
          <target state="translated">In Maven:</target>
        </trans-unit>
        <trans-unit id="6dc887971001bc1cd4775889e759bfb59211b14c" translate="yes" xml:space="preserve">
          <source>In Python, function names must be unique within a module or a class. In Kotlin, we can &lt;em&gt;overload&lt;/em&gt; functions: there can be multiple declarations of functions that have the same name. Overloaded functions must be distinguishable from each other through their parameter lists. (The types of the parameter list, together with the return type, is known as a function's &lt;em&gt;signature&lt;/em&gt;, but the return type cannot be used to disambiguate overloaded functions.) For example, we can have both of these functions in the same file:</source>
          <target state="translated">Python에서 함수 이름은 모듈 또는 클래스 내에서 고유해야합니다. Kotlin에서는 함수 를 &lt;em&gt;오버로드&lt;/em&gt; 할 수 있습니다. 이름이 같은 함수를 여러 번 선언 할 수 있습니다. 과부하 된 기능은 파라미터 목록을 통해 서로 구별 할 수 있어야합니다. (반환 유형과 함께 매개 변수 목록의 유형을 함수의 &lt;em&gt;시그니처&lt;/em&gt; 라고 하지만, 리턴 유형을 사용하여 오버로드 된 기능을 명확하게하는 데 사용할 수 없습니다.) 예를 들어,이 두 기능을 동일한 파일에 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0f7f91981a6ecf109d226f21e3069c8aabc15a" translate="yes" xml:space="preserve">
          <source>In Python, the expression for a default value is evaluated once, at function definition time. That leads to this classic trap, where the developer hopes to get a new, empty list every time the function is called without a value for &lt;code&gt;numbers&lt;/code&gt;, but instead, the same list is being used every time:</source>
          <target state="translated">Python에서 기본값에 대한 표현식은 함수 정의시 한 번 평가됩니다. 이 고전적인 함정으로 이어집니다. 개발자는 &lt;code&gt;numbers&lt;/code&gt; 값없이 함수가 호출 될 때마다 새로운 빈 목록을 얻으려고 하지만 매번 동일한 목록이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3d02ed8996a5f9eaf8b21aad3a4aaadb80de18" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;when&lt;/code&gt; statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:</source>
          <target state="translated">A의 &lt;code&gt;when&lt;/code&gt; 지점이 한 줄보다 더 많은 경우 문, 빈 라인과 인접한 경우 블록에서 분리 고려 :</target>
        </trans-unit>
        <trans-unit id="3a1b36cf0bd1ee7bba19fe0760cca000ad48b849" translate="yes" xml:space="preserve">
          <source>In a long-running application you might need fine-grained control on your background coroutines. For example, a user might have closed the page that launched a coroutine and now its result is no longer needed and its operation can be cancelled. The &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; function returns a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;Job&lt;/a&gt; that can be used to cancel the running coroutine:</source>
          <target state="translated">오래 실행되는 응용 프로그램에서는 백그라운드 코 루틴에 대한 세밀한 제어가 필요할 수 있습니다. 예를 들어, 사용자가 코 루틴을 시작한 페이지를 닫았을 때 결과가 더 이상 필요하지 않고 작업을 취소 할 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;발사&lt;/a&gt; 함수는 반환 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html&quot;&gt;작업&lt;/a&gt; 실행중인 코 루틴을 취소 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e333c99581fbe52762649b5ab0c35c55ffcd093c" translate="yes" xml:space="preserve">
          <source>In a member of a &lt;a href=&quot;classes#inheritance&quot;&gt;class&lt;/a&gt;, &lt;em&gt;this&lt;/em&gt; refers to the current object of that class.</source>
          <target state="translated">(A)의 부재 &lt;a href=&quot;classes#inheritance&quot;&gt;클래스&lt;/a&gt; , &lt;em&gt;이&lt;/em&gt; 클래스의 현재 오브젝트를 말한다.</target>
        </trans-unit>
        <trans-unit id="15a56874c4866fabbe734af8a3fb102f28e0b12f" translate="yes" xml:space="preserve">
          <source>In a nutshell, you can use libraries such as &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; or &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; in your Kotlin projects.</source>
          <target state="translated">간단히 말해서 Kotlin 프로젝트에서 &lt;a href=&quot;https://google.github.io/dagger/&quot;&gt;Dagger&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding/index.html&quot;&gt;Data Binding&lt;/a&gt; 과 같은 라이브러리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5544e7dcfdd04da3eceaae6a1614ec1e4f550da9" translate="yes" xml:space="preserve">
          <source>In addition to &lt;strong&gt;out&lt;/strong&gt;, Kotlin provides a complementary variance annotation: &lt;strong&gt;in&lt;/strong&gt;. It makes a type parameter &lt;strong&gt;contravariant&lt;/strong&gt;: it can only be consumed and never produced. A good example of a contravariant type is &lt;code&gt;Comparable&lt;/code&gt;:</source>
          <target state="translated">뿐만 아니라 &lt;strong&gt;밖으로&lt;/strong&gt; , 코 틀린은 보완 분산 주석을 제공 : &lt;strong&gt;에&lt;/strong&gt; . 유형 매개 변수를 &lt;strong&gt;반 변형으로&lt;/strong&gt; 만듭니다 . 소비 만 가능하며 절대로 생산할 수 없습니다. contravariant 유형의 좋은 예입니다 &lt;code&gt;Comparable&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c6329f208d955601deb101d4b33fc1acdf8accac" translate="yes" xml:space="preserve">
          <source>In addition to common operations for &lt;a href=&quot;collection-parts&quot;&gt;Retrieving Collection Parts&lt;/a&gt;, lists provide the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt;&lt;code&gt;subList()&lt;/code&gt;&lt;/a&gt; function that returns a view of the specified elements range as a list. Thus, if an element of the original collection changes, it also changes in the previously created sublists and vice versa.</source>
          <target state="translated">&lt;a href=&quot;collection-parts&quot;&gt;콜렉션은 파트 콜렉션 검색에&lt;/a&gt; 대한 공통 조작 외에도 지정된 요소 범위의보기를 목록으로 리턴하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-list/sub-list&quot;&gt; &lt;code&gt;subList()&lt;/code&gt; &lt;/a&gt; 함수를 제공 합니다. 따라서 원본 컬렉션의 요소가 변경되면 이전에 만든 하위 목록에서도 변경되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="9674c96ddd7757af7200ad4daae22ce260bb2047" translate="yes" xml:space="preserve">
          <source>In addition to removing elements, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt;&lt;code&gt;MutableListIterator&lt;/code&gt;&lt;/a&gt; can also insert and replace elements while iterating the list.</source>
          <target state="translated">요소를 제거하는 것 외에도 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list-iterator/index&quot;&gt; &lt;code&gt;MutableListIterator&lt;/code&gt; &lt;/a&gt; 는 목록을 반복하면서 요소를 삽입하고 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a6e3c954dde3e3eb6edba41ad0b83ce52bd70c" translate="yes" xml:space="preserve">
          <source>In addition to scope functions, the standard library contains the functions &lt;code&gt;takeIf&lt;/code&gt; and &lt;code&gt;takeUnless&lt;/code&gt;. These functions let you embed checks of the object state in call chains.</source>
          <target state="translated">범위 함수 외에도 표준 라이브러리에는 &lt;code&gt;takeIf&lt;/code&gt; 및 &lt;code&gt;takeUnless&lt;/code&gt; 함수가 포함 됩니다. 이 함수를 사용하면 콜 체인에 객체 상태 확인을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acfd15e725bcfef6236f16c4782a0f3dc2126f4d" translate="yes" xml:space="preserve">
          <source>In addition to that, you can use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; to access the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; instance corresponding to the class. The &lt;code&gt;JsClass&lt;/code&gt; instance itself is a reference to the constructor function. This can be used to interoperate with JS functions that expect a reference to a constructor.</source>
          <target state="translated">또한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/js&quot;&gt;KClass.js&lt;/a&gt; 를 사용 하여 클래스에 해당하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/-js-class/index&quot;&gt;JsClass&lt;/a&gt; 인스턴스 에 액세스 할 수 있습니다 . &lt;code&gt;JsClass&lt;/code&gt; 의 인스턴스 생성자 자체 기능에 대한 참조이다. 생성자에 대한 참조가 필요한 JS 함수와 상호 운용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36b7ccec26bcb88294baf54023cc9ae72ecaa90f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt;&lt;code&gt;as&lt;/code&gt;, which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt;&lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt;&lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt;, &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</source>
          <target state="translated">In addition to the &lt;a href=&quot;typecasts#unsafe-cast-operator&quot;&gt;&quot;unsafe&quot; cast operator&lt;/a&gt; &lt;code&gt;as&lt;/code&gt; , which throws a &lt;code&gt;ClassCastException&lt;/code&gt; in case a cast is not possible, Kotlin/JS also provides &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.js/unsafe-cast&quot;&gt; &lt;code&gt;unsafeCast&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;/a&gt;. When using &lt;code&gt;unsafeCast&lt;/code&gt; , &lt;em&gt;no type checking is done at all&lt;/em&gt; during runtime. For example, consider the following two methods:</target>
        </trans-unit>
        <trans-unit id="5594aa712f7692fd1a48c40180fe2939a4654a66" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; dependency shown above, you need to add a dependency on the Kotlin standard library:</source>
          <target state="translated">위에 표시된 &lt;code&gt;kotlin-gradle-plugin&lt;/code&gt; 종속성 외에도 Kotlin 표준 라이브러리에 대한 종속성을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea7c2f23dd342e78eba03e7edea502fd9fbb6ef4" translate="yes" xml:space="preserve">
          <source>In addition to the build tasks, the Gradle build includes helpful tasks to run the application directly via &lt;code&gt;runDebugExecutableNative&lt;/code&gt; and &lt;code&gt;runReleaseExecutableNative&lt;/code&gt;.</source>
          <target state="translated">빌드 작업 외에도 Gradle 빌드에는 &lt;code&gt;runDebugExecutableNative&lt;/code&gt; 및 &lt;code&gt;runReleaseExecutableNative&lt;/code&gt; 를 통해 애플리케이션을 직접 실행하는 유용한 작업이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d5b7f7ad1a1556c56ce8e8eb4580dccfbc4c337" translate="yes" xml:space="preserve">
          <source>In addition to the collection modification operations described in &lt;a href=&quot;collection-write&quot;&gt;Collection Write Operations&lt;/a&gt;, &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable&lt;/a&gt; lists support specific write operations. Such operations use the index to access elements to broaden the list modification capabilities.</source>
          <target state="translated">설명 컬렉션 수정 작업 외에도 &lt;a href=&quot;collection-write&quot;&gt;컬렉션 쓰기 작업&lt;/a&gt; , &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능한&lt;/a&gt; 목록은 특정 쓰기 작업을 지원합니다. 이러한 작업은 색인을 사용하여 요소에 액세스하여 목록 수정 기능을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="edff8af41569526ee6f34e250c39b84435f2d3a3" translate="yes" xml:space="preserve">
          <source>In addition to the command line compiler and IntelliJ IDEA, you can also build Kotlin projects with Ant, Maven, and Gradle.</source>
          <target state="translated">명령 행 컴파일러 및 IntelliJ IDEA 외에도 Ant, Maven 및 Gradle을 사용하여 Kotlin 프로젝트를 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13939289a96ed1a1e50225139ac3fbd7b0bc2be9" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete. The main difference between &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; is that the latter does not block the current thread while waiting for all children to complete.</source>
          <target state="translated">다른 빌더가 제공하는 코 루틴 범위 외에도 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 빌더를 사용하여 고유 한 범위를 선언 할 수 있습니다 . 코 루틴 범위를 작성하고 시작된 모든 하위 항목이 완료 될 때까지 완료되지 않습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 과 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; 의 주요 차이점 은 후자가 모든 자식이 완료 될 때까지 기다리는 동안 현재 스레드를 차단하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5077ac7f8cceff0957d255db71b0d1a0a24a0ba" translate="yes" xml:space="preserve">
          <source>In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</source>
          <target state="translated">In addition to the coroutine scope provided by different builders, it is possible to declare your own scope using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; builder. It creates a coroutine scope and does not complete until all launched children complete.</target>
        </trans-unit>
        <trans-unit id="063fa2441ff30c74a010fc27ec5f2018d7ca4ef2" translate="yes" xml:space="preserve">
          <source>In addition to the output JavaScript file, the plugin by default creates an additional JS file with binary descriptors. This file is required if you're building a reusable library that other Kotlin modules can depend on, and should be distributed together with the result of translation. The generation is controlled by the &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; option:</source>
          <target state="translated">출력 JavaScript 파일 외에도 플러그인은 기본적으로 이진 설명자가 포함 된 추가 JS 파일을 만듭니다. 이 파일은 다른 Kotlin 모듈이 의존 할 수있는 재사용 가능한 라이브러리를 작성하고 번역 결과와 함께 배포해야하는 경우에 필요합니다. 생성은 &lt;code&gt;kotlinOptions.metaInfo&lt;/code&gt; 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c8c93a8699f08045725902510444a7e2a812bf3" translate="yes" xml:space="preserve">
          <source>In addition, Rx does introduce a somewhat nicer approach to error handling.</source>
          <target state="translated">또한 Rx는 오류 처리에 대해 좀 더 멋진 접근 방식을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="3434b058fadc1fd97196abc0cd226b5de0eff131" translate="yes" xml:space="preserve">
          <source>In addition, each of these also have a corresponding &lt;code&gt;{file}.meta.js&lt;/code&gt; meta file which will be used for reflection and other functionality.</source>
          <target state="translated">또한 이들 각각에는 리플렉션 및 기타 기능에 사용되는 해당 &lt;code&gt;{file}.meta.js&lt;/code&gt; 메타 파일도 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf05c9d4a5ea22db47de9f6cd0f0a1f61618f95" translate="yes" xml:space="preserve">
          <source>In all cases, the C string is supposed to be encoded as UTF-8.</source>
          <target state="translated">모든 경우에 C 문자열은 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad8a2cde437dc29e925bd2e2608bcf1efd428d2" translate="yes" xml:space="preserve">
          <source>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</source>
          <target state="translated">기본적으로 getter 및 setter를 사용하여 개인 속성에 대한 액세스가 최적화되어 함수 호출 오버 헤드가 발생하지 않기 때문에 이는 Java와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="af3fb6a2c1c95a7bcc9ea3f79ae7998d4cb1b27a" translate="yes" xml:space="preserve">
          <source>In an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; or a &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;&lt;em&gt;this&lt;/em&gt; denotes the &lt;em&gt;receiver&lt;/em&gt; parameter that is passed on the left-hand side of a dot.</source>
          <target state="translated">에 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 또는 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기 기능 리터럴 &lt;/a&gt;&lt;em&gt;이&lt;/em&gt; 나타낸다 &lt;em&gt;수신&lt;/em&gt; 점의 좌측에 전달되는 파라미터.</target>
        </trans-unit>
        <trans-unit id="751813b87d30d6501d1bf6ea23fd73a02ca28ea0" translate="yes" xml:space="preserve">
          <source>In an inline function definition, you can use &lt;code&gt;noinline&lt;/code&gt; in front of any function-typed parameter to prevent the lambda that will be passed to it from also being inlined.</source>
          <target state="translated">인라인 함수 정의에서 함수 유형 매개 변수 앞에 &lt;code&gt;noinline&lt;/code&gt; 을 사용 하여 전달되는 람다가 인라인되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="751fca68ff5e9efd6f13ba9f691a416e15e88e6e" translate="yes" xml:space="preserve">
          <source>In any lists, you can find the position of an element using the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt;&lt;code&gt;indexOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt;&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/a&gt;. They return the first and the last position of an element equal to the given argument in the list. If there are no such elements, both functions return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">모든 목록에서 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/index-of&quot;&gt; &lt;code&gt;indexOf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last-index-of&quot;&gt; &lt;code&gt;lastIndexOf()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 요소의 위치를 ​​찾을 수 있습니다 . 리스트에서 주어진 인수와 같은 요소의 첫 번째와 마지막 위치를 리턴합니다. 그러한 요소가 없으면 두 함수 모두 &lt;code&gt;-1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c3c35f058a2881495687f9b24556ffc42c9b3b89" translate="yes" xml:space="preserve">
          <source>In approach it's quite similar to Futures, but one can think of a Future as returning a discrete element, whereby Rx returns a stream. However, similar to the previous, it also introduces a complete new way of thinking about our programming model, famously phrased as</source>
          <target state="translated">접근 방식에서는 Future와 매우 유사하지만 Future를 개별 요소를 반환하는 것으로 생각할 수 있습니다. Rx는 스트림을 반환합니다. 그러나 이전과 마찬가지로 프로그래밍 모델에 대한 완전히 새로운 사고 방식을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="afaa57d188a4de777b467f6dcde31f2f2cfb5700" translate="yes" xml:space="preserve">
          <source>In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite the value associated with the former one.</source>
          <target state="translated">두 항목이 동일한 키에 매핑되는 경우 후자의 값이 이전의 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ab773dc6434fe9e51f59bd2f39f7407e2e315f54" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;suppressed&lt;/a&gt; exceptions of the former.</source>
          <target state="translated">&lt;a href=&quot;use#kotlin%24use%28kotlin.use.T%2C+kotlin.Function1%28%28kotlin.use.T%2C+kotlin.use.R%29%29%29%2Fblock&quot;&gt;block&lt;/a&gt; 에서 예외가 발생하여 자원이 닫히고 예외가 발생 하여 종료에 실패한 경우에는 전자가 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#addSuppressed(java.lang.Throwable)&quot;&gt;억제 된&lt;/a&gt; 예외에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="753affb3f26053a8d6fe6a50898f37935f2da6a8" translate="yes" xml:space="preserve">
          <source>In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</source>
          <target state="translated">In case if the resource is being closed due to an exception occurred in &lt;a href=&quot;use#kotlin%24use(kotlin.use.T,%20kotlin.Function1((kotlin.use.T,%20kotlin.use.R)))/block&quot;&gt;block&lt;/a&gt;, and the closing also fails with an exception, the latter is added to the suppressed exceptions of the former.</target>
        </trans-unit>
        <trans-unit id="a99d3de27a9334d7d61ccdc4fea1d3937e232802" translate="yes" xml:space="preserve">
          <source>In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the common indent is 0, and therefore this function doesn't change the indentation.</source>
          <target state="translated">공백 문자 앞에 공백 문자가없는 경우 (공백 없음) 공통 들여 쓰기는 0이므로이 함수는 들여 쓰기를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c60b20e0301bd757b71bb24ccc047d80b78f21b1" translate="yes" xml:space="preserve">
          <source>In case of a name conflict between the members of the dispatch receiver and the extension receiver, the extension receiver takes precedence. To refer to the member of the dispatch receiver you can use the &lt;a href=&quot;this-expressions#qualified&quot;&gt;qualified &lt;code&gt;this&lt;/code&gt; syntax&lt;/a&gt;.</source>
          <target state="translated">디스패치 수신기와 확장 수신기의 구성원간에 이름이 충돌하는 경우 확장 수신기가 우선합니다. 디스패치 수신자의 멤버를 참조하기 위해 &lt;a href=&quot;this-expressions#qualified&quot;&gt;규정 된 &lt;code&gt;this&lt;/code&gt; 구문을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2564f2a33e66657de3341732c5e625e51d4323de" translate="yes" xml:space="preserve">
          <source>In case of the extension property in a class, the instance of the class should be passed first and the instance of the extension receiver second.</source>
          <target state="translated">클래스의 확장 속성의 경우 클래스의 인스턴스가 먼저 전달되고 확장 수신기의 인스턴스가 두 번째로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1a1fb30f33e29cde0e4a9adce651bb450975c80d" translate="yes" xml:space="preserve">
          <source>In case this type is based on an inner class, the returned list contains the type arguments provided for the innermost class first, then its outer class, and so on. For example, in the type &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; the returned list is &lt;code&gt;[C, D, A, B]&lt;/code&gt;.</source>
          <target state="translated">이 유형이 내부 클래스를 기반으로하는 경우, 리턴 된 목록에는 가장 안쪽 클래스에 먼저 제공된 유형 인수가 포함 된 다음 외부 클래스 등이 포함됩니다. 예를 들어, &lt;code&gt;Outer&amp;lt;A, B&amp;gt;.Inner&amp;lt;C, D&amp;gt;&lt;/code&gt; 에서 리턴 된 목록은 &lt;code&gt;[C, D, A, B]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="744293bc64c3188af17bab32f33333fe2cad85c9" translate="yes" xml:space="preserve">
          <source>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function parameters with the &lt;code&gt;noinline&lt;/code&gt; modifier:</source>
          <target state="translated">인라인 함수로 전달 된 일부 람다 만 인라인되도록하려면 &lt;code&gt;noinline&lt;/code&gt; 수정자를 사용하여 일부 함수 매개 변수를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="816f79d2ddebc85fd82a80af3cc580e6eeb81694" translate="yes" xml:space="preserve">
          <source>In case you're wondering about how &lt;code&gt;use&lt;/code&gt;, which is a function, can just be followed by a block like that, see the section on &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL support&lt;/a&gt;.</source>
          <target state="translated">함수 인 &lt;code&gt;use&lt;/code&gt; 가 어떻게 그런 블록 뒤에 올 수 있는지 궁금하다면 &lt;a href=&quot;functional-programming#receivers&quot;&gt;DSL 지원&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de1e14373afc30cdce829d5ccf1028c05a1345bf" translate="yes" xml:space="preserve">
          <source>In common code:</source>
          <target state="translated">일반적인 코드에서 :</target>
        </trans-unit>
        <trans-unit id="dbd13320c78fae25fd6f48673f77aea087d10896" translate="yes" xml:space="preserve">
          <source>In essence, this allows for the following code:</source>
          <target state="translated">본질적으로 이것은 다음 코드를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b797e297636a01e5f39faa44903e3922322a2f0c" translate="yes" xml:space="preserve">
          <source>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</source>
          <target state="translated">실제로 Kotlin은 속성을 선언하고 기본 생성자에서 초기화하기 위해 간결한 구문을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8575e5bc9be645637c35224eaab5422d26408ea8" translate="yes" xml:space="preserve">
          <source>In further sections, these concepts are described in more detail along with the DSL to configure them in a project.</source>
          <target state="translated">추가 섹션에서 이러한 개념은 프로젝트에서 구성하기 위해 DSL과 함께 자세히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="093d33db378ee271b0948a0579ab35389d4e97d5" translate="yes" xml:space="preserve">
          <source>In general, for small projects, we recommend converting all the files at once.</source>
          <target state="translated">일반적으로 소규모 프로젝트의 경우 모든 파일을 한 번에 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2ad6bf46a8b188e9bc3522dea93919d7678b502b" translate="yes" xml:space="preserve">
          <source>In general, identifiers may consist of letters, digits, and underscores, and may not begin with a digit. However, if you are writing code that e.g. autogenerates JSON based on identifiers and you want the JSON key to be a string that does not conform to these rules or that collides with a keyword, you can enclose it in backticks: &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; is a valid identifier.</source>
          <target state="translated">일반적으로 식별자는 문자, 숫자 및 밑줄로 구성 될 수 있으며 숫자로 시작하지 않을 수 있습니다. 그러나 식별자를 기반으로 JSON을 자동 생성하는 코드를 작성하고 있고 JSON 키가 이러한 규칙을 따르지 않거나 키워드와 충돌하는 문자열이되도록하려면 코드를 백틱으로 묶을 &lt;code&gt;`I can't believe this is not an error!`&lt;/code&gt; 는 유효한 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="def8cf1480d12ae42f29a02a77be00f6fa6a05e6" translate="yes" xml:space="preserve">
          <source>In general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just &quot;for clarity&quot;.</source>
          <target state="translated">일반적으로 Kotlin의 특정 구문 구조가 선택적이고 IDE에서 중복으로 강조 표시되는 경우 코드에서 생략해야합니다. &quot;명확성을 위해&quot;불필요한 구문 요소를 코드에 두지 마십시오.</target>
        </trans-unit>
        <trans-unit id="01b3fb6a7b9e95b734c635ce49024c6d660e14c4" translate="yes" xml:space="preserve">
          <source>In general, to create an instance of such a class, we need to provide the type arguments:</source>
          <target state="translated">일반적으로 이러한 클래스의 인스턴스를 만들려면 형식 인수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="450c32ce21d7e1cf7d82473c6445b4ccee4985e3" translate="yes" xml:space="preserve">
          <source>In generated code, the Kotlin compiler keeps a &lt;em&gt;wrapper&lt;/em&gt; for each inline class. Inline class instances can be represented at runtime either as wrappers or as the underlying type. This is similar to how &lt;code&gt;Int&lt;/code&gt; can be &lt;a href=&quot;basic-types#representation&quot;&gt;represented&lt;/a&gt; either as a primitive &lt;code&gt;int&lt;/code&gt; or as the wrapper &lt;code&gt;Integer&lt;/code&gt;.</source>
          <target state="translated">생성 된 코드에서 Kotlin 컴파일러 는 각 인라인 클래스에 대한 &lt;em&gt;래퍼&lt;/em&gt; 를 유지합니다 . 인라인 클래스 인스턴스는 런타임시 랩퍼 또는 기본 유형으로 표시 될 수 있습니다. 이것은 &lt;code&gt;Int&lt;/code&gt; 가 프리미티브 &lt;code&gt;int&lt;/code&gt; 또는 래퍼 &lt;code&gt;Integer&lt;/code&gt; 로 &lt;a href=&quot;basic-types#representation&quot;&gt;표시&lt;/a&gt; 되는 방법과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="fd80bee1bf4ef4cc9fdfdeda947dd40e1e56db38" translate="yes" xml:space="preserve">
          <source>In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, it should be passed outside of parentheses whenever possible.</source>
          <target state="translated">람다 식에서 매개 변수를 본문과 구분하는 화살표뿐만 아니라 중괄호 주위에 공백을 사용해야합니다. 호출이 단일 람다를 사용하는 경우 가능할 때마다 괄호 외부로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="80c8a890c9d273e819066140d09ce2d0bc285c7d" translate="yes" xml:space="preserve">
          <source>In lambdas which are short and not nested, it's recommended to use the &lt;code&gt;it&lt;/code&gt; convention instead of declaring the parameter explicitly. In nested lambdas with parameters, parameters should be always declared explicitly.</source>
          <target state="translated">짧고 중첩되지 않은 람다에서는 매개 변수를 명시 적으로 선언하는 대신 &lt;code&gt;it&lt;/code&gt; 규칙 을 사용하는 것이 좋습니다 . 매개 변수가있는 중첩 된 람다에서 매개 변수는 항상 명시 적으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f96591676e8e90474bcc2e9cbd0fe550a87c6d7" translate="yes" xml:space="preserve">
          <source>In long argument lists, put a line break after the opening parenthesis. Indent arguments by 4 spaces. Group multiple closely related arguments on the same line.</source>
          <target state="translated">긴 인수 목록에서 여는 괄호 뒤에 줄 바꿈을 넣으십시오. 인수를 4 칸 들여 쓰기 밀접하게 관련된 여러 인수를 같은 줄에 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="e70f274fab45a9ad1cf0f5234b5a4c58fefd78f6" translate="yes" xml:space="preserve">
          <source>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the &lt;code&gt;is&lt;/code&gt;-checks and &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;explicit casts&lt;/a&gt; for immutable values and inserts (safe) casts automatically when needed:</source>
          <target state="translated">대부분의 경우 컴파일러는 Kotlin에서 명시 적 캐스트 연산자를 사용할 필요가 없습니다. 컴파일러는 &lt;code&gt;is&lt;/code&gt; - checks 및 불변 값에 대한 &lt;a href=&quot;#unsafe-cast-operator&quot;&gt;명시 적 캐스트&lt;/a&gt; 를 추적하고 필요할 때 자동으로 삽입 (안전한) 캐스트를 추적하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="d05a001b4fb4f64cd4a87d987f4f265545ae66a8" translate="yes" xml:space="preserve">
          <source>In mixed-language projects, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure (each file should be stored in the directory corresponding to each package statement).</source>
          <target state="translated">혼합 언어 프로젝트에서 Kotlin 소스 파일은 Java 소스 파일과 동일한 소스 루트에 있어야하며 동일한 디렉토리 구조를 따라야합니다 (각 파일은 각 패키지 명령문에 해당하는 디렉토리에 저장되어야 함).</target>
        </trans-unit>
        <trans-unit id="a772373d726c1ea1dd1e4b5bd74e75bb5171d98d" translate="yes" xml:space="preserve">
          <source>In modules that don't provide their own API, such as application modules, you can use experimental APIs without propagating the experimental status to your code. In this case, mark your code with the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental(Marker::class)&lt;/a&gt; annotation specifying the marker annotation of the experimental API:</source>
          <target state="translated">응용 프로그램 모듈과 같이 자체 API를 제공하지 않는 모듈에서는 실험 상태를 코드로 전파하지 않고도 실험용 API를 사용할 수 있습니다. 이 경우 실험 API의 마커 주석을 지정하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-use-experimental/index&quot;&gt;@UseExperimental (Marker :: class)&lt;/a&gt; 주석으로 코드를 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfed7f25e3bb00e2797542765d6c2ca96af68b87" translate="yes" xml:space="preserve">
          <source>In most cases, Kotlin follows the Java coding conventions.</source>
          <target state="translated">대부분의 경우 Kotlin은 Java 코딩 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d126b0359662ea6c66b61b9e3af53b0d85339044" translate="yes" xml:space="preserve">
          <source>In multiline mode the expressions &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; match just after or just before, respectively, a line terminator or the end of the input sequence.</source>
          <target state="translated">여러 줄 모드에서 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 식은 각각 줄 종결 자 또는 입력 시퀀스의 끝 바로 앞 또는 바로 앞과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6667a323602babcf47c04e12460b410e75814d22" translate="yes" xml:space="preserve">
          <source>In order to assemble an application, we also need to include the Kotlin standard library, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency, and the other libraries if any.</source>
          <target state="translated">애플리케이션을 어셈블하려면 Kotlin 표준 라이브러리 (예 : 종속성으로 포함 된 &lt;code&gt;kotlin.js&lt;/code&gt; )와 다른 라이브러리 (있는 경우)도 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="034cc52464c28236e3f8c4183a0d3673ce621a3f" translate="yes" xml:space="preserve">
          <source>In order to avoid compatibility issues during an Xcode build, the plugin requires using a &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle wrapper&lt;/a&gt;. To generate the wrapper automatically during execution of the &lt;code&gt;podspec&lt;/code&gt; task, run it with the parameter &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt;.</source>
          <target state="translated">Xcode 빌드 중에 호환성 문제를 피하려면 플러그인에 &lt;a href=&quot;https://docs.gradle.org/current/userguide/gradle_wrapper.html&quot;&gt;Gradle 래퍼를&lt;/a&gt; 사용해야합니다 . &lt;code&gt;podspec&lt;/code&gt; 태스크 실행 중 랩퍼를 자동으로 생성하려면 &lt;code&gt;-Pkotlin.native.cocoapods.generate.wrapper=true&lt;/code&gt; 매개 변수 를 사용하여 랩퍼를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="320ea67fc7a407c39652cf848b66d1bac7958814" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</source>
          <target state="translated">In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;apply the Kotlin Gradle plugin to your project&lt;/a&gt; and &lt;a href=&quot;#configuring-dependencies&quot;&gt;configure dependencies&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="4a047d1f6392366b3f681991fe461367b7be253f" translate="yes" xml:space="preserve">
          <source>In order to build a Kotlin project with Gradle, you should &lt;a href=&quot;#plugin-and-versions&quot;&gt;set up the &lt;em&gt;kotlin-gradle&lt;/em&gt; plugin&lt;/a&gt;, &lt;a href=&quot;#targeting-the-jvm&quot;&gt;apply it&lt;/a&gt; to your project and &lt;a href=&quot;#configuring-dependencies&quot;&gt;add &lt;em&gt;kotlin-stdlib&lt;/em&gt; dependencies&lt;/a&gt;. Those actions may also be performed automatically in IntelliJ IDEA by invoking &lt;strong&gt;Tools | Kotlin | Configure Kotlin&lt;/strong&gt; in &lt;strong&gt;Project&lt;/strong&gt; action.</source>
          <target state="translated">Gradle을 가진 코 틀린 프로젝트를 구축하기 위해, 당신은해야 &lt;a href=&quot;#plugin-and-versions&quot;&gt;셋업 &lt;em&gt;코 틀린-Gradle을&lt;/em&gt; 플러그인을&lt;/a&gt; , &lt;a href=&quot;#targeting-the-jvm&quot;&gt;적용&lt;/a&gt; 프로젝트와 &lt;a href=&quot;#configuring-dependencies&quot;&gt;추가 &lt;em&gt;- 다음 stdlib 코 틀린&lt;/em&gt; 종속성을&lt;/a&gt; . 이러한 조치는 IntelliJ IDEA에서 &lt;strong&gt;도구 | 코 틀린 | &lt;/strong&gt;&lt;strong&gt;프로젝트&lt;/strong&gt; 작업 에서 &lt;strong&gt;Kotlin&lt;/strong&gt; 을 &lt;strong&gt;구성하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e347f51a9c40cc493b347c1bed8c2d5285726dad" translate="yes" xml:space="preserve">
          <source>In order to compile JavaScript code, you need to use the &lt;code&gt;js&lt;/code&gt; and &lt;code&gt;test-js&lt;/code&gt; goals for the &lt;code&gt;compile&lt;/code&gt; execution:</source>
          <target state="translated">JavaScript 코드를 컴파일 하려면 &lt;code&gt;compile&lt;/code&gt; 실행을 위해 &lt;code&gt;js&lt;/code&gt; 및 &lt;code&gt;test-js&lt;/code&gt; 목표 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7888ab5509b34a7615518c3269c358c32f2dd548" translate="yes" xml:space="preserve">
          <source>In order to debug the application using IntelliJ IDEA, we need to perform two steps:</source>
          <target state="translated">IntelliJ IDEA를 사용하여 응용 프로그램을 디버깅하려면 다음 두 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d60abc6454bf0506cb62dd1ac746f025ab62610" translate="yes" xml:space="preserve">
          <source>In order to generate these bindings, we need to create a library definition &lt;code&gt;.def&lt;/code&gt; file that contains some information about the headers we need to generate. In our case we want to use the famous &lt;code&gt;libcurl&lt;/code&gt; library to make some HTTP calls, so we'll create a file named &lt;code&gt;libcurl.def&lt;/code&gt; with the following contents</source>
          <target state="translated">이러한 바인딩 을 생성하려면 생성해야하는 헤더에 대한 정보가 포함 된 라이브러리 정의 &lt;code&gt;.def&lt;/code&gt; 파일 을 작성 해야합니다. 우리의 경우 유명한 &lt;code&gt;libcurl&lt;/code&gt; 라이브러리 를 사용하여 HTTP 호출을 만들고 &lt;code&gt;libcurl.def&lt;/code&gt; 때문에 다음 내용으로 libcurl.def 라는 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ffbf97f9cc48e7603dadd7a45b25bf4f6b7e3989" translate="yes" xml:space="preserve">
          <source>In order to run, we need the corresponding WAR(s) for deploying. We can generate these using the &lt;em&gt;war&lt;/em&gt; task in Gradle which can easily be executed via the Gradle tool window in IntelliJ IDEA.</source>
          <target state="translated">실행하려면 배포 할 해당 WAR이 필요합니다. IntelliJ IDEA의 Gradle 도구 창을 통해 쉽게 실행할 수있는 Gradle 의 &lt;em&gt;war&lt;/em&gt; 태스크를 사용하여이를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24dcbfd34df21e70b79c4b2191a485e90cc3e450" translate="yes" xml:space="preserve">
          <source>In order to share the changes across the project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder, it has to be committed to VCS. Alternatively &lt;strong&gt;kotlin.code.style&lt;/strong&gt;=&lt;strong&gt;obsolete&lt;/strong&gt; can be used for projects configured with Gradle or Maven.</source>
          <target state="translated">프로젝트 개발자 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 폴더 에서 변경 사항을 공유하려면 VCS에 커밋해야합니다. 대안 &lt;strong&gt;kotlin.code.style&lt;/strong&gt; = &lt;strong&gt;쓸모가&lt;/strong&gt; Gradle을 구성 또는 메이븐 프로젝트에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="155fb0f00f3221a063feea137fb0401c04ce9dd5" translate="yes" xml:space="preserve">
          <source>In order to share those changes for all project developers &lt;code&gt;.idea/codeStyle&lt;/code&gt; folder have to be committed to VCS.</source>
          <target state="translated">모든 프로젝트 개발자를 위해 이러한 변경 사항을 공유하려면 &lt;code&gt;.idea/codeStyle&lt;/code&gt; 폴더를 VCS에 커밋해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa88cf692336fd455afd07788cc5c7d6ab06d938" translate="yes" xml:space="preserve">
          <source>In order to specify the module kind, we can add a configuration to our plugin as below</source>
          <target state="translated">모듈 종류를 지정하기 위해 다음과 같이 플러그인에 구성을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="59607fe0baf1ba77b3f9ca8983f516dc1d471c45" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objc header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">잠재적으로 널 입력 가능 유형을 지원하려면 Objc 헤더가 널 입력 가능 리턴 값으로 &lt;code&gt;myVal&lt;/code&gt; 을 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="de88f4d0de61705bae1956451c94335904114bb9" translate="yes" xml:space="preserve">
          <source>In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</source>
          <target state="translated">In order to support a potentially nullable type, the Objective-C header needs to define &lt;code&gt;myVal&lt;/code&gt; with a nullable return value.</target>
        </trans-unit>
        <trans-unit id="9aac89688353374371a7ae0f65a4346b1a58df3a" translate="yes" xml:space="preserve">
          <source>In order to use Gradle to target JavaScript, we need to use the &lt;code&gt;kotlin2js&lt;/code&gt; plugin as opposed to the &lt;code&gt;kotlin&lt;/code&gt; plugin.</source>
          <target state="translated">자바 스크립트를 대상으로 Gradle을을 사용하기 위해, 우리는 사용할 필요가 &lt;code&gt;kotlin2js&lt;/code&gt; 받는 반대로 플러그인 &lt;code&gt;kotlin&lt;/code&gt; 플러그인을.</target>
        </trans-unit>
        <trans-unit id="33526a8ed38f3fde7c6b4f6af71779367c169bbc" translate="yes" xml:space="preserve">
          <source>In order to use Kotlin with node.js, we need to set the compiler option to use CommonJS. Once we do that, the output of the application should be accessible using the node module system.</source>
          <target state="translated">node.js와 함께 Kotlin을 사용하려면 CommonJS를 사용하도록 컴파일러 옵션을 설정해야합니다. 그렇게하면 노드 모듈 시스템을 사용하여 응용 프로그램의 출력에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5bdfd7a958cb3b5e6a62acec15106d2a72aa846c" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">코 루틴을 사용하고이 안내서의 예를 따르려면 &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;README 프로젝트에&lt;/a&gt; 설명 된 대로 &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; 모듈 에 대한 종속성을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc71e5241592939229f3aa2e6f5ed18f17024e17" translate="yes" xml:space="preserve">
          <source>In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</source>
          <target state="translated">In order to use coroutines as well as follow the examples in this guide, you need to add a dependency on the &lt;code&gt;kotlinx-coroutines-core&lt;/code&gt; module as explained &lt;a href=&quot;https://github.com/kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects&quot;&gt;in the project README&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1cc60ead46c9defc457295413372bae706d2254f" translate="yes" xml:space="preserve">
          <source>In order to use something from a package, it is sufficient to use the package name to fully qualify the name of the symbol at the place where you use the symbol:</source>
          <target state="translated">패키지에서 무언가를 사용하려면 패키지 이름을 사용하여 심볼을 사용하는 위치에서 심볼 이름을 완전히 규정하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9abc8ef7836ac20fac6436adb16fe6c5da1f6518" translate="yes" xml:space="preserve">
          <source>In order to use this, we also need to include the Kotlin standard library in our application, i.e. &lt;code&gt;kotlin.js&lt;/code&gt;, which was included as a dependency. By default, Maven does not expand the JAR as part of the build process, so we would need to add an additional step in our build to do so.</source>
          <target state="translated">이를 사용하려면 응용 프로그램에 Kotlin 표준 라이브러리 (예 : 종속성으로 포함 된 &lt;code&gt;kotlin.js&lt;/code&gt; )도 포함해야합니다. 기본적으로 Maven은 빌드 프로세스의 일부로 JAR을 확장하지 않으므로 빌드에 추가 단계를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5c6ba86278357c55cc58dbde4e4e54ec8ffad3f" translate="yes" xml:space="preserve">
          <source>In other words, inline classes introduce a truly &lt;em&gt;new&lt;/em&gt; type, contrary to type aliases which only introduce an alternative name (alias) for an existing type:</source>
          <target state="translated">다시 말해, 인라인 클래스 는 기존 유형에 대한 대체 이름 (별칭) 만 도입하는 유형 별명과 달리 진정으로 &lt;em&gt;새로운&lt;/em&gt; 유형을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="2fcd261cf566bdf17c9a0226c120616065441d92" translate="yes" xml:space="preserve">
          <source>In our DSL all the tag classes extend the same superclass &lt;code&gt;Tag&lt;/code&gt;. It's enough to annotate only the superclass with &lt;code&gt;@HtmlTagMarker&lt;/code&gt; and after that the Kotlin compiler will treat all the inherited classes as annotated:</source>
          <target state="translated">DSL에서 모든 태그 클래스는 동일한 수퍼 클래스 &lt;code&gt;Tag&lt;/code&gt; 를 확장합니다 . &lt;code&gt;@HtmlTagMarker&lt;/code&gt; 로 수퍼 클래스에만 주석을 달면 충분하며 그 후에 Kotlin 컴파일러는 상속 된 모든 클래스를 주석이 달린 것으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="055ba8d22e98a479f59a07d7a075048bb0a20fe4" translate="yes" xml:space="preserve">
          <source>In our example, we have &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 코 루틴 빌더를 사용하여 코 루틴으로 변환되는 &lt;code&gt;main&lt;/code&gt; 기능이 있습니다. &lt;code&gt;runBlocking&lt;/code&gt; 을 포함한 모든 코 루틴 빌더 는 코드 블록의 범위에 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; 인스턴스를 추가합니다 . 범위에서 실행 된 모든 코 루틴이 완료 될 때까지 외부 코 루틴 (이 예에서는 &lt;code&gt;runBlocking&lt;/code&gt; )이 완료되지 않으므로이 범위에서 코 루틴을 명시 적으로 &lt;code&gt;join&lt;/code&gt; 하지 않고도 실행할 수 있습니다 . 따라서 예제를 더 단순하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b76b0743b9831752920932ff5a5625568afac3" translate="yes" xml:space="preserve">
          <source>In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt;, adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine (&lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</source>
          <target state="translated">In our example, we have a &lt;code&gt;main&lt;/code&gt; function that is turned into a coroutine using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; coroutine builder. Every coroutine builder, including &lt;code&gt;runBlocking&lt;/code&gt; , adds an instance of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html&quot;&gt;CoroutineScope&lt;/a&gt; to the scope of its code block. We can launch coroutines in this scope without having to &lt;code&gt;join&lt;/code&gt; them explicitly, because an outer coroutine ( &lt;code&gt;runBlocking&lt;/code&gt; in our example) does not complete until all the coroutines launched in its scope complete. Thus, we can make our example simpler:</target>
        </trans-unit>
        <trans-unit id="99c50d394fc235f8eeca8f1ea6662b1ec125d6bd" translate="yes" xml:space="preserve">
          <source>In our main function we create activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy activity after 500ms. This cancels all the coroutines that were launched which we can confirm by noting that it does not print onto the screen anymore if we wait:</source>
          <target state="translated">우리의 주요 함수에서 우리는 활동을 생성하고, 테스트 &lt;code&gt;doSomething&lt;/code&gt; 함수를 호출하고 , 500ms 후에 활동을 파괴합니다. 이렇게하면 시작된 모든 코 루틴이 취소되며, 기다릴 경우 더 이상 화면에 인쇄되지 않음을 확인하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8567ecf52dbb46832894d62cc3534eccec93e924" translate="yes" xml:space="preserve">
          <source>In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt;. We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</source>
          <target state="translated">In our main function we create the activity, call our test &lt;code&gt;doSomething&lt;/code&gt; function, and destroy the activity after 500ms. This cancels all the coroutines that were launched from &lt;code&gt;doSomething&lt;/code&gt; . We can see that because after the destruction of the activity no more messages are printed, even if we wait a little longer.</target>
        </trans-unit>
        <trans-unit id="4e33cfe3a798666f120dafc2300d3a53a316781b" translate="yes" xml:space="preserve">
          <source>In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file where the class itself is defined. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Do not create files just to hold &quot;all extensions of Foo&quot;.</source>
          <target state="translated">특히이 클래스의 모든 클라이언트와 관련된 클래스의 확장 함수를 정의 할 때는 클래스 자체가 정의 된 동일한 파일에 추가하십시오. 특정 클라이언트에게만 적합한 확장 기능을 정의 할 때는 해당 클라이언트의 코드 옆에 두십시오. &quot;Foo의 모든 확장명&quot;을 담기 위해 파일을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2683ff56288a092d85a9176c5ad7bb38fce09a9b" translate="yes" xml:space="preserve">
          <source>In practice some changes can't be accurately detected at compile time, so no warnings can be reported, but at least the users will be notified through Release notes of version A that a change is coming in version B.</source>
          <target state="translated">실제로 컴파일시 일부 변경 사항을 정확하게 감지 할 수 없으므로 경고를보고 할 수 없지만 최소한 버전 A의 릴리스 정보를 통해 버전 B에서 변경 사항이 있음을 사용자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="1e5d38479fe45d55c10d169d2b3903a772bc6139" translate="yes" xml:space="preserve">
          <source>In practice, quite a bit of code is affected, so this can be considered a major code style update.</source>
          <target state="translated">실제로는 약간의 코드가 영향을 받기 때문에 주요 코드 스타일 업데이트로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e5b70de31acdb27d8d2c67fea04b3d16fdd8a7" translate="yes" xml:space="preserve">
          <source>In practice, thread confinement is performed in large chunks, e.g. big pieces of state-updating business logic are confined to the single thread. The following example does it like that, running each coroutine in the single-threaded context to start with.</source>
          <target state="translated">실제로 스레드 제한은 큰 청크로 수행됩니다. 예를 들어 상태 업데이트 비즈니스 로직의 큰 부분이 단일 스레드로 제한됩니다. 다음 예제는 단일 스레드 컨텍스트에서 각 코 루틴을 실행하여 시작합니다.</target>
        </trans-unit>
        <trans-unit id="40969ff7e4fed85e58f626291a67f5273e20a573" translate="yes" xml:space="preserve">
          <source>In progressive mode, some fixes in language semantics can arrive immediately. All these fixes have two important properties:</source>
          <target state="translated">프로그레시브 모드에서는 언어 시맨틱의 일부 수정 사항이 즉시 도착할 수 있습니다. 이 모든 수정에는 두 가지 중요한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff40107a95c01dec77eae6fb0ec0b96a075ea6f" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</source>
          <target state="translated">In pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the &lt;code&gt;org.example.kotlin&lt;/code&gt; package and its subpackages, files with the &lt;code&gt;org.example.kotlin&lt;/code&gt; package should be placed directly under the source root, and files in &lt;code&gt;org.example.kotlin.network.socket&lt;/code&gt; should be in the &lt;code&gt;network/socket&lt;/code&gt; subdirectory of the source root.</target>
        </trans-unit>
        <trans-unit id="d10877f2d49f4fb7859f1ddc63051feb0cebe60b" translate="yes" xml:space="preserve">
          <source>In pure Kotlin projects, the recommended directory structure is to follow the package structure with the common root package omitted (e.g. if all the code in the project is in the &quot;org.example.kotlin&quot; package and its subpackages, files with the &quot;org.example.kotlin&quot; package should be placed directly under the source root, and files in &quot;org.example.kotlin.foo.bar&quot; should be in the &quot;foo/bar&quot; subdirectory of the source root).</source>
          <target state="translated">순수한 Kotlin 프로젝트에서 권장되는 디렉토리 구조는 공통 루트 패키지가 생략 된 패키지 구조를 따르는 것입니다 (예 : 프로젝트의 모든 코드가 &quot;org.example.kotlin&quot;패키지 및 하위 패키지에있는 경우 &quot;org .example.kotlin &quot;패키지는 소스 루트 바로 아래에 배치해야하며&quot;org.example.kotlin.foo.bar &quot;의 파일은 소스 루트의&quot;foo / bar &quot;하위 디렉토리에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c30c378469f41e6f1d1072007ebada7e490b3451" translate="yes" xml:space="preserve">
          <source>In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">In scratches and worksheets, you can write any valid Kotlin code. Syntax highlighting, auto-completion, and the other IntelliJ IDEA code editing features are all supported too. Note that there's no need for declaring the &lt;code&gt;main&lt;/code&gt; function: all the code you write is executed as if it would be in the body of &lt;code&gt;main&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5be9888b7ba5a318d3261861baf4d32fa8861a" translate="yes" xml:space="preserve">
          <source>In short: &lt;em&gt;think carefully through your declarations of integers, and be absolutely certain that the value will never ever need to be larger than the limits of the type!&lt;/em&gt; If you need an integer of unlimited size, use the non-primitive type &lt;code&gt;BigInteger&lt;/code&gt;.</source>
          <target state="translated">간단히 말하면 &lt;em&gt;정수 선언을 신중하게 생각하고 값이 유형의 한계보다 클 필요는 없다는 것을 절대적으로 확신하십시오! &lt;/em&gt;무제한 크기의 정수가 필요한 경우 기본이 아닌 유형 &lt;code&gt;BigInteger&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a3b75ce2c9b15401d05148e77e0306873596e7e" translate="yes" xml:space="preserve">
          <source>In situations like this we can use the &lt;code&gt;dynamic&lt;/code&gt; type, which allows us to work with dynamic types when targeting JavaScript. The following variable is declared as &lt;code&gt;dynamic&lt;/code&gt; meaning that whatever we invoke on it will not result in a compile-time error:</source>
          <target state="translated">이와 같은 상황에서는 &lt;code&gt;dynamic&lt;/code&gt; 유형을 사용하여 JavaScript를 타겟팅 할 때 동적 유형으로 작업 할 수 있습니다. 다음 변수는 &lt;code&gt;dynamic&lt;/code&gt; 으로 선언되어 우리가 호출하는 것이 컴파일 타임 오류를 일으키지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="55bd36b85c22e6a1c4d10234a638ea714c3940ad" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), Kotlin compiler mangles names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">일부 경우 (예 : 과부하 지원) Kotlin 컴파일러는 생성 된 함수의 이름과 JavaScript 코드에서 속성을 맹 글링합니다. 생성 된 이름을 제어하기 위해 &lt;code&gt;@JsName&lt;/code&gt; 어노테이션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1f62f22b0a379feb738d1ada9b061745859834e" translate="yes" xml:space="preserve">
          <source>In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</source>
          <target state="translated">In some cases (for example, to support overloads), the Kotlin compiler mangles the names of generated functions and attributes in JavaScript code. To control the generated names, you can use the &lt;code&gt;@JsName&lt;/code&gt; annotation:</target>
        </trans-unit>
        <trans-unit id="8f1f57175de66b286d8ac98729c81851940d41f3" translate="yes" xml:space="preserve">
          <source>In some cases functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.</source>
          <target state="translated">경우에 따라 인수가없는 함수는 읽기 전용 속성과 호환 될 수 있습니다. 시맨틱은 유사하지만 서로 선호하는시기에 대한 스타일 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4526b2f446cfa690eb7c5baadbe7c8dea021438f" translate="yes" xml:space="preserve">
          <source>In some ways, this is easier to read because the operations are specified in the order they are applied to the values. The result will be an immutable &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is whichever type is produced by the transformations you use (in this case, &lt;code&gt;String&lt;/code&gt;). If you need a mutable list, call &lt;code&gt;toMutableList()&lt;/code&gt; at the end. If you want a set, call &lt;code&gt;toSet()&lt;/code&gt; or &lt;code&gt;toMutableSet()&lt;/code&gt; at the end. If you want to transform a collection into a map, call &lt;code&gt;associateBy()&lt;/code&gt;, which takes two lambdas that specify how to extract the key and the value from each element: &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; (you can omit the second lambda if you want the entire element to be the value, and you can call &lt;code&gt;toMutableMap()&lt;/code&gt; at the end if you want the result to be mutable).</source>
          <target state="translated">어떤 방식으로, 조작이 값에 적용되는 순서대로 지정되므로 읽기가 더 쉽습니다. 결과는 불변 인 &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;T&lt;/code&gt; 는 사용하는 변환에 의해 생성되는 유형 (이 경우 &lt;code&gt;String&lt;/code&gt; )입니다. 변경 가능한 목록이 필요한 경우 마지막에 &lt;code&gt;toMutableList()&lt;/code&gt; 를 호출 하십시오. 세트를 원하면 &lt;code&gt;toSet()&lt;/code&gt; 또는 &lt;code&gt;toMutableSet()&lt;/code&gt; 을 호출 하십시오. 콜렉션을 맵으로 변환하려는 경우 &lt;code&gt;associateBy()&lt;/code&gt; 호출하십시오.이 메소드 는 각 요소에서 키와 값을 추출하는 방법을 지정하는 두 개의 람다를 사용합니다. &lt;code&gt;people.associateBy({it.ssn}, {it.name})&lt;/code&gt; 전체 요소를 값으로 사용하려면 두 번째 람다를 생략 하고 결과를 변경하려면 끝에 &lt;code&gt;toMutableMap()&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="482c7a83b939d337af8bf0cb41a70749c1cb67ed" translate="yes" xml:space="preserve">
          <source>In spite of the &lt;code&gt;object&lt;/code&gt; keyword being used, a new instance of the anonymous class will be created whenever the object expression is evaluated.</source>
          <target state="translated">사용중인 &lt;code&gt;object&lt;/code&gt; 키워드 에도 불구하고 객체 표현식이 평가 될 때마다 익명 클래스의 새 인스턴스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="10fed13cfcbccf5e09d7648e3ceabcf9a0d8e2f5" translate="yes" xml:space="preserve">
          <source>In spite of this syntactical convenience, the companion object is a proper object on its own, and can have its own supertypes - and you can assign it to a variable and pass it around. If you're integrating with Java code and need a true &lt;code&gt;static&lt;/code&gt; member, you can &lt;a href=&quot;annotations&quot;&gt;annotate&lt;/a&gt; a member inside a companion object with &lt;code&gt;@JvmStatic&lt;/code&gt;.</source>
          <target state="translated">이 구문상의 편의성에도 불구하고 동반 객체는 자체적으로 적절한 객체이며 자체 슈퍼 유형을 가질 수 있으며 변수에 할당하고 전달할 수 있습니다. Java 코드와 통합하고 진정한 &lt;code&gt;static&lt;/code&gt; 멤버 가 필요한 경우 &lt;code&gt;@JvmStatic&lt;/code&gt; 을 사용 하여 컴패니언 객체 내부에 멤버에 &lt;a href=&quot;annotations&quot;&gt;주석을 달&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8be34c3c318a79f1a61390cd86ad3bb03f42aee7" translate="yes" xml:space="preserve">
          <source>In subsequent tutorials we'll show how you can influence the files generated, for example, change location, prefix and suffixes, and how you can work with modules.</source>
          <target state="translated">이후의 자습서에서는 위치, 접두사 및 접미사 변경과 같이 생성 된 파일에 영향을 줄 수있는 방법과 모듈 작업 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bc19aea0692b9f67e799748ba127b1fc2dfa9708" translate="yes" xml:space="preserve">
          <source>In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">In tests (and &lt;strong&gt;only&lt;/strong&gt; in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</target>
        </trans-unit>
        <trans-unit id="de0700bb726b0915ca84006a652a9bb020053b41" translate="yes" xml:space="preserve">
          <source>In tests (and only in tests), it's acceptable to use method names with spaces enclosed in backticks. (Note that such method names are currently not supported by the Android runtime.) Underscores in method names are also allowed in test code.</source>
          <target state="translated">테스트 (및 테스트에서만)에는 공백으로 백틱으로 묶인 메소드 이름을 사용할 수 있습니다. (이러한 메소드 이름은 현재 Android 런타임에서 지원되지 않습니다.) 메소드 이름의 밑줄도 테스트 코드에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4ad3e9e93913c50444eb70a3c6d491b3cf74240" translate="yes" xml:space="preserve">
          <source>In that case you need to use the spread operator &lt;code&gt;*&lt;/code&gt; to pass the &lt;code&gt;IntArray&lt;/code&gt;:</source>
          <target state="translated">이 경우 스프레드 연산자 &lt;code&gt;*&lt;/code&gt; 를 사용 하여 &lt;code&gt;IntArray&lt;/code&gt; 를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a1e90ae09efa8b0693d6eb0e54489eb2ffa5613b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</source>
          <target state="translated">In the &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;, it outputs something like this:</target>
        </trans-unit>
        <trans-unit id="dfa4bedab09a124fc51fd33f0b20a721f3509f7a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#enabling-experimental-features&quot;&gt;experimental mode&lt;/a&gt;, you can specify any variant name (not only flavor), e.g. &lt;code&gt;freeDebug&lt;/code&gt; or &lt;code&gt;freeRelease&lt;/code&gt; will work as well.</source>
          <target state="translated">에서 &lt;a href=&quot;#enabling-experimental-features&quot;&gt;실험 모드&lt;/a&gt; , 당신은 어떤 변형 이름 (뿐만 아니라 맛), 예를 지정할 수 있습니다 &lt;code&gt;freeDebug&lt;/code&gt; 을 하거나 &lt;code&gt;freeRelease&lt;/code&gt; 는 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="34502d3bacebdc9ab51090cbc1ee8b5aa02dcb57" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;libnative_api.h&lt;/code&gt;, we'll find the following code. We will discuss the code in parts to make it easier to understand.</source>
          <target state="translated">에서 &lt;code&gt;libnative_api.h&lt;/code&gt; , 우리는 다음과 같은 코드를 찾을 수 있습니다. 이해하기 쉽도록 코드를 부분적으로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="97cbe1bbd40fde30fcff61322aab402c1acd97ce" translate="yes" xml:space="preserve">
          <source>In the Gradle dependencies you use add the &lt;code&gt;kotlin-kapt&lt;/code&gt; plugin and replace &lt;code&gt;annotationProcessor&lt;/code&gt; with &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Gradle 의존성에서 &lt;code&gt;kotlin-kapt&lt;/code&gt; 플러그인을 추가하고 &lt;code&gt;annotationProcessor&lt;/code&gt; 를 &lt;code&gt;kapt&lt;/code&gt; 로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="a87144873c9b9ee0a65c1c2fda83f3948fb32756" translate="yes" xml:space="preserve">
          <source>In the JavaScript world, a completely different set of APIs is availiable, so one could instead implement logging to the console:</source>
          <target state="translated">JavaScript 세계에서는 완전히 다른 API 세트를 사용할 수 있으므로 대신 콘솔에 로깅을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc47ebd8b09857b2d92aa6e80c268cb28a620e3a" translate="yes" xml:space="preserve">
          <source>In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</source>
          <target state="translated">In the Kotlin Gradle DSL, there is also a shortcut for setting the CommonJS module kind:</target>
        </trans-unit>
        <trans-unit id="952c75185ceff6a4ea2264e236a32b30e1121e70" translate="yes" xml:space="preserve">
          <source>In the code above, the parameter &lt;code&gt;combine&lt;/code&gt; has a &lt;a href=&quot;#function-types&quot;&gt;function type&lt;/a&gt;&lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt;, so it accepts a function that takes two arguments of types &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; and returns a value of type &lt;code&gt;R&lt;/code&gt;. It is &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;invoked&lt;/a&gt; inside the &lt;em&gt;for&lt;/em&gt;-loop, and the return value is then assigned to &lt;code&gt;accumulator&lt;/code&gt;.</source>
          <target state="translated">위의 코드에서, 매개 변수는 &lt;code&gt;combine&lt;/code&gt; 갖는 &lt;a href=&quot;#function-types&quot;&gt;기능 타입 &lt;/a&gt; &lt;code&gt;(R, T) -&amp;gt; R&lt;/code&gt; 가 수용되도록 타입의 두 개의 인자를 취하는 함수 &lt;code&gt;R&lt;/code&gt; 과 &lt;code&gt;T&lt;/code&gt; 형의 복귀 값 &lt;code&gt;R&lt;/code&gt; 을 . 그것은되는 &lt;a href=&quot;#invoking-a-function-type-instance&quot;&gt;호출&lt;/a&gt; 공진 영역 &lt;em&gt;에 대한&lt;/em&gt; -loop 및 반환 값은 다음에 할당 된 &lt;code&gt;accumulator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="983dc81454e62d4d8dfeb15d4d6704ae3670a9b1" translate="yes" xml:space="preserve">
          <source>In the example above, the production sources for the JVM target are compiled by its &lt;code&gt;main&lt;/code&gt; compilation and therefore include the sources and dependencies from the source sets &lt;code&gt;jvmMain&lt;/code&gt; and &lt;code&gt;commonMain&lt;/code&gt; (due to the &lt;em&gt;depends on&lt;/em&gt; relation):</source>
          <target state="translated">위의 예에서 JVM 대상의 프로덕션 소스는 &lt;code&gt;main&lt;/code&gt; 컴파일에 의해 컴파일되므로 소스 세트 &lt;code&gt;jvmMain&lt;/code&gt; 및 &lt;code&gt;commonMain&lt;/code&gt; 의 소스 및 종속성 ( 관계에 &lt;em&gt;따라 달라짐&lt;/em&gt; )이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="92a4732d4ba58bb8eb4b7a1a153809f54718cd39" translate="yes" xml:space="preserve">
          <source>In the example below, we assume that there is a &lt;code&gt;DbModel&lt;/code&gt; base class, and that every subclass has got a parameterless primary constructor. In the inline function, &lt;code&gt;T&lt;/code&gt; is reified, so we can get the class metadata. We pass this to the function that does the real work of talking to the database.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;DbModel&lt;/code&gt; 기본 클래스가 있고 모든 하위 클래스에 매개 변수가없는 기본 생성자 가 있다고 가정합니다 . 인라인 함수에서 &lt;code&gt;T&lt;/code&gt; 가 구체화되어 클래스 메타 데이터를 얻을 수 있습니다. 우리는 이것을 데이터베이스와 대화하는 실제 작업을 수행하는 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f9725b5629cf5c05b1dabad8df3abc795d27f14a" translate="yes" xml:space="preserve">
          <source>In the example we have the most popular ways to pass or receive a string in the C language. We should take the return of &lt;code&gt;return_string&lt;/code&gt; with care. In general, it is best to make sure we use the right function to dispose the returned &lt;code&gt;char*&lt;/code&gt; with the right &lt;code&gt;free(..)&lt;/code&gt; function call.</source>
          <target state="translated">이 예에서는 C 언어로 문자열을 전달하거나받는 가장 일반적인 방법이 있습니다. &lt;code&gt;return_string&lt;/code&gt; 을주의 해서 반환해야 합니다. 일반적으로 올바른 함수를 사용하여 반환 된 &lt;code&gt;char*&lt;/code&gt; 를 올바른 &lt;code&gt;free(..)&lt;/code&gt; 함수 호출 과 함께 처리하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="45b64e498fcd11490ca143779a88435b7d9e0b0c" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;findViewById()&lt;/code&gt; is only invoked once:</source>
          <target state="translated">다음 예제에서 &lt;code&gt;findViewById()&lt;/code&gt; 는 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8cf0c93c6e85cb80e10b5e71f71e2e6899fc70c7" translate="yes" xml:space="preserve">
          <source>In the generated Kotlin declarations, we see that &lt;code&gt;str&lt;/code&gt; is represented as &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt;. The type is nullable, and we can simply pass Kotlin &lt;code&gt;null&lt;/code&gt; as the parameter value.</source>
          <target state="translated">생성 된 Kotlin 선언에서 &lt;code&gt;str&lt;/code&gt; 이 &lt;code&gt;CValuesRef&amp;lt;ByteVar/&amp;gt;?&lt;/code&gt; . 타입은 nullable이며, Kotlin &lt;code&gt;null&lt;/code&gt; 을 파라미터 값으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ffd682e74db1be23092050eecf5e03af23b3260" translate="yes" xml:space="preserve">
          <source>In the generated code, the &lt;code&gt;provideDelegate&lt;/code&gt; method is called to initialize the auxiliary &lt;code&gt;prop$delegate&lt;/code&gt; property. Compare the generated code for the property declaration &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; with the generated code &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;above&lt;/a&gt; (when the &lt;code&gt;provideDelegate&lt;/code&gt; method is not present):</source>
          <target state="translated">생성 된 코드에서 &lt;code&gt;provideDelegate&lt;/code&gt; 메소드가 호출되어 보조 &lt;code&gt;prop$delegate&lt;/code&gt; 특성 을 초기화합니다 . 속성 선언 &lt;code&gt;val prop: Type by MyDelegate()&lt;/code&gt; 에 대해 생성 된 코드를 &lt;a href=&quot;delegated-properties#translation-rules&quot;&gt;위&lt;/a&gt; 의 생성 된 코드와 비교하십시오 ( &lt;code&gt;provideDelegate&lt;/code&gt; 메소드가없는 경우).</target>
        </trans-unit>
        <trans-unit id="f86f30c4d84e613891c93b386289b1fcc35ce4d5" translate="yes" xml:space="preserve">
          <source>In the last line &lt;code&gt;button&lt;/code&gt; is referenced by &lt;code&gt;id&lt;/code&gt; using the &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; plugin. Consider using this plugin as an alternative which allows you to keep binding logic in code and have the concise syntax at the same time.</source>
          <target state="translated">마지막 행 에서 &lt;a href=&quot;android-plugin&quot;&gt;Kotlin Android Extensions&lt;/a&gt; 플러그인을 사용하여 &lt;code&gt;id&lt;/code&gt; 로 &lt;code&gt;button&lt;/code&gt; 을 참조합니다 . 이 플러그인을 대안으로 사용하여 바인딩 로직을 코드로 유지하고 간결한 구문을 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da80e212e3fb5a8c2cf3d597abb266f174acf51" translate="yes" xml:space="preserve">
          <source>In the last line, there's an implicit &lt;code&gt;this.&lt;/code&gt; in front of both &lt;code&gt;memberFunction()&lt;/code&gt; and &lt;code&gt;memberProperty&lt;/code&gt; (if these exist on the type of &lt;code&gt;someExpression&lt;/code&gt;). The return value is that of the last expression.</source>
          <target state="translated">마지막 줄에는 암시적인 내용 &lt;code&gt;this.&lt;/code&gt; &lt;code&gt;memberFunction()&lt;/code&gt; 및 &lt;code&gt;memberProperty&lt;/code&gt; (이는 &lt;code&gt;someExpression&lt;/code&gt; 유형에있는 경우 ) 앞에 있습니다. 리턴 값은 마지막 표현식의 리턴 값입니다.</target>
        </trans-unit>
        <trans-unit id="21de312c94f28c9a74e944cc50e80500b0df440a" translate="yes" xml:space="preserve">
          <source>In the next dialog, provide the project details:</source>
          <target state="translated">다음 대화 상자에서 프로젝트 세부 사항을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="fb8d123847c0bf27cf6ffe6e978d7163ff9a921d" translate="yes" xml:space="preserve">
          <source>In the old model, common and platform-specific code needed to be placed in separate modules, linked by &lt;code&gt;expectedBy&lt;/code&gt; dependencies. Now, common and platform-specific code is placed in different source roots of the same module, making projects easier to configure.</source>
          <target state="translated">이전 모델에서는 공통 및 플랫폼 별 코드를 &lt;code&gt;expectedBy&lt;/code&gt; 종속성으로 연결된 별도의 모듈에 배치해야했습니다 . 이제 공통 및 플랫폼 별 코드가 동일한 모듈의 다른 소스 루트에 배치되어 프로젝트를보다 쉽게 ​​구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca766f4efd26534c30d9c87798187848fcb65628" translate="yes" xml:space="preserve">
          <source>In the presence of &lt;code&gt;maven-publish&lt;/code&gt; plugin the publications for all the binaries built are created. The plugin uses Gradle metadata to publish the artifacts so this feature must be enabled (see the &lt;a href=&quot;#dependencies&quot;&gt;dependencies&lt;/a&gt; section).</source>
          <target state="translated">&lt;code&gt;maven-publish&lt;/code&gt; 플러그인 이 있으면 빌드 된 모든 바이너리에 대한 발행물이 작성됩니다. 플러그인은 Gradle 메타 데이터를 사용하여 아티팩트를 공개하므로이 기능을 사용해야합니다 ( &lt;a href=&quot;#dependencies&quot;&gt;종속성&lt;/a&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="d60dd59e4676a95bd7097287912e2ec3768e0f9a" translate="yes" xml:space="preserve">
          <source>In the previous example the JavaScript module exports a single package. However, some JavaScript libraries export multiple packages from within a module. This case is also supported by Kotlin, though you have to declare a new &lt;code&gt;.kt&lt;/code&gt; file for each package you import.</source>
          <target state="translated">이전 예제에서 JavaScript 모듈은 단일 패키지를 내 보냅니다. 그러나 일부 JavaScript 라이브러리는 모듈 내에서 여러 패키지를 내 보냅니다. 이 사례는 Kotlin에서도 지원되지만 가져 오는 각 패키지에 대해 새 &lt;code&gt;.kt&lt;/code&gt; 파일 을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="42d1f7acaeec00a73953ae801ded4c35e710f59f" translate="yes" xml:space="preserve">
          <source>In the tutorial we will learn:</source>
          <target state="translated">튜토리얼에서 우리는 배울 것입니다 :</target>
        </trans-unit>
        <trans-unit id="5c983473a452d20ce90bb4b7f97f64c188d78e2f" translate="yes" xml:space="preserve">
          <source>In the tutorial we:</source>
          <target state="translated">튜토리얼에서 우리는 :</target>
        </trans-unit>
        <trans-unit id="91d34ec07b8ea3ab8718a88b953168add8f0c256" translate="yes" xml:space="preserve">
          <source>In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">In these examples &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</target>
        </trans-unit>
        <trans-unit id="095e7f10496f59e9c1f965ea0b808ca458b5529c" translate="yes" xml:space="preserve">
          <source>In this case the compiler will not be downloaded by the plugin.</source>
          <target state="translated">이 경우 플러그인에서 컴파일러를 다운로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1f881dff617021acda0968035a0c51bb38a1c2d" translate="yes" xml:space="preserve">
          <source>In this case, JQuery will be imported as a module named &lt;code&gt;jquery&lt;/code&gt;. Alternatively, it can be used as a $-object, depending on what module system Kotlin compiler is configured to use.</source>
          <target state="translated">이 경우 JQuery를 &lt;code&gt;jquery&lt;/code&gt; 라는 모듈로 가져 옵니다 . 또는 Kotlin 컴파일러가 사용하도록 구성된 모듈 시스템에 따라 $ -object로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c032e19443eb1eff2c0c1528c6eb2e5d72dfce23" translate="yes" xml:space="preserve">
          <source>In this case, we've set the output of our compilation to the &lt;code&gt;scripts&lt;/code&gt; folder. On running the application we should see the following output:</source>
          <target state="translated">이 경우 컴파일 결과를 &lt;code&gt;scripts&lt;/code&gt; 폴더로 설정했습니다. 응용 프로그램을 실행하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="de0ac72463e7c41b8825d92484726f740a2112b2" translate="yes" xml:space="preserve">
          <source>In this dense code, in addition to collection transformations, you can see such handy Kotlin features as local functions and the &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;elvis operator&lt;/a&gt;&lt;code&gt;?:&lt;/code&gt; that allow to express &lt;a href=&quot;../reference/idioms&quot;&gt;idioms&lt;/a&gt; like &quot;take the value if it is positive or else use length&quot; with a concise and readable expressions like &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt;, yet it is perfectly fine with Kotlin to create additional mutable variables and express the same code in imperative style, too.</source>
          <target state="translated">이 고밀도 코드에서 수집 변환뿐만 아니라, 당신은 편리한 코 틀린 지역 함수로 기능하고 볼 수있는 &lt;a href=&quot;../reference/null-safety#elvis-operator&quot;&gt;연산자를 엘비스 &lt;/a&gt; &lt;code&gt;?:&lt;/code&gt; 표현할 수 있도록하는 &lt;a href=&quot;../reference/idioms&quot;&gt;숙어&lt;/a&gt; 간결한와 &quot;는 긍정적 그렇지 않으면 사용 길이의 경우는 값을&quot;과 같은를 &lt;code&gt;.takeIf { it &amp;gt;= 0 } ?: s.length&lt;/code&gt; 와 같이 읽을 수있는 표현식 이지만 Kotlin을 사용하면 추가 가변 변수를 만들고 동일한 코드를 명령형 스타일로 표현하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e691bb86d414ab1eeeac0ce8d8cf107c13b24d6b" translate="yes" xml:space="preserve">
          <source>In this doc, we'll sometimes specify the type unnecessarily, in order to highlight what type is produced by an expression. (Also, a good IDE will be able to show you the resulting type.)</source>
          <target state="translated">이 문서에서는 표현식에 의해 생성되는 유형을 강조하기 위해 불필요하게 유형을 지정하는 경우가 있습니다. 또한 좋은 IDE는 결과 유형을 보여줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d12593ba02967f080622029b34989f6d346aaf9" translate="yes" xml:space="preserve">
          <source>In this document we introduce several kinds of compatibility:</source>
          <target state="translated">이 문서에서는 여러 종류의 호환성을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="537f8c16fc8f03cc135b33707b31eb29f9995ea0" translate="yes" xml:space="preserve">
          <source>In this example only members of the nearest implicit receiver &lt;code&gt;this@head&lt;/code&gt; must be available; &lt;code&gt;head()&lt;/code&gt; is a member of the outer receiver &lt;code&gt;this@html&lt;/code&gt;, so it must be illegal to call it.</source>
          <target state="translated">이 예에서는 가장 가까운 암시 적 수신자 &lt;code&gt;this@head&lt;/code&gt; 멤버 만 사용 가능해야합니다. &lt;code&gt;head()&lt;/code&gt; 는 외부 수신자 &lt;code&gt;this@html&lt;/code&gt; 의 멤버 이므로 호출하는 것은 불법입니다.</target>
        </trans-unit>
        <trans-unit id="9c36d65c210f75f6cba412252945fedc98c222bc" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different thread from the thread pool, but it still has the value of the thread local variable that we specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; , no matter which thread the coroutine is executed on. Thus, the output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</target>
        </trans-unit>
        <trans-unit id="67582c167007a9ba92244086b3d65c9a9e9700f4" translate="yes" xml:space="preserve">
          <source>In this example we launch a new coroutine in a background thread pool using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;, so it works on a different threads from a thread pool, but it still has the value of thread local variable, that we've specified using &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt;, no matter on what thread the coroutine is executed. Thus, output (with &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug&lt;/a&gt;) is:</source>
          <target state="translated">이 예제에서는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default를&lt;/a&gt; 사용하여 백그라운드 스레드 풀에서 새 코 루틴을 시작 하므로 스레드 풀과 다른 스레드에서 작동하지만 여전히 스레드 로컬 변수의 값을 &lt;code&gt;threadLocal.asContextElement(value = &quot;launch&quot;)&lt;/code&gt; 사용하여 지정한 값입니다. 코 루틴이 실행되는 스레드에 관계없이 (value = &quot;launch&quot;) . 따라서 출력 ( &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug 포함&lt;/a&gt; )은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="872d3ddd1be8b8c4ec3ab8cc792f3b5cde57d822" translate="yes" xml:space="preserve">
          <source>In this example, all values passed to the C API &lt;code&gt;new_menu()&lt;/code&gt; have a lifetime of the innermost &lt;code&gt;memScope&lt;/code&gt; it belongs to. Once the control flow leaves the &lt;code&gt;memScoped&lt;/code&gt; scope the C pointers become invalid.</source>
          <target state="translated">이 예에서, C API &lt;code&gt;new_menu()&lt;/code&gt; 전달 된 모든 값은 그것이 속하는 가장 안쪽 &lt;code&gt;memScope&lt;/code&gt; 의 수명을 갖 습니다. 제어 흐름이 &lt;code&gt;memScoped&lt;/code&gt; 범위를 벗어나 면 C 포인터가 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="5b70f0a7dd260f72c7acee91c3f5762c472a459a" translate="yes" xml:space="preserve">
          <source>In this example, the constructor takes a map:</source>
          <target state="translated">이 예제에서 생성자는 맵을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="06698ce38b883fc740d14dcc830fa9e382960eb5" translate="yes" xml:space="preserve">
          <source>In this example, the sequence processing takes 18 steps instead of 23 steps for doing the same with lists.</source>
          <target state="translated">이 예에서, 시퀀스 처리는리스트와 동일한 작업을 수행하기 위해 23 단계 대신 18 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="550b3c67b81cc4d4252fe83306649fc1df1e86da" translate="yes" xml:space="preserve">
          <source>In this example, using &lt;code&gt;Person&lt;/code&gt; and &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; from the previous section, we locate a member function reference by name and call it:</source>
          <target state="translated">이 예제 에서 이전 섹션의 &lt;code&gt;Person&lt;/code&gt; 및 &lt;code&gt;callAndPrintTwoParam()&lt;/code&gt; 을 사용하여 이름으로 멤버 함수 참조를 찾아서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="25017fcbb3e37d1b9106fc29788136cb1c456365" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where suspension function is run or asynchronously later in the same thread or from a different thread of execution. Repeated invocation of any resume function produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">이 함수에서 &lt;a href=&quot;-continuation/resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;-continuation/resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 은 서스펜션 기능이 실행되는 동일한 스택 프레임에서 동 기적으로 또는 나중에 동일한 스레드에서 또는 다른 실행 스레드에서 비동기 적으로 사용될 수 있습니다. 재개 함수를 반복해서 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a802dce08d5c39703b387f16a864974235e44de0" translate="yes" xml:space="preserve">
          <source>In this function both &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; and &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; can be used either synchronously in the same stack-frame where the suspension function is run or asynchronously later in the same thread or from a different thread of execution. Subsequent invocation of any resume function will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">이 함수에서 &lt;a href=&quot;resume&quot;&gt;Continuation.resume&lt;/a&gt; 및 &lt;a href=&quot;resume-with-exception&quot;&gt;Continuation.resumeWithException&lt;/a&gt; 은 서스펜션 기능이 실행되는 동일한 스택 프레임에서 동 기적으로 또는 나중에 동일한 스레드에서 또는 다른 실행 스레드에서 비동기 적으로 사용될 수 있습니다. 이력서 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="677125a2bada551194ff25d8eec9f1b62a3c4ba4" translate="yes" xml:space="preserve">
          <source>In this section a commented DSL is shown. See also the example projects that use this plugin, e.g. &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt;, &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http client&lt;/a&gt;</source>
          <target state="translated">이 섹션에는 주석 처리 된 DSL이 표시됩니다. 이 플러그인을 사용하는 프로젝트 예 (예 : &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Kotlinx.coroutines&lt;/a&gt; , &lt;a href=&quot;https://github.com/e5l/http-client-common/tree/master/samples/ios-test-application&quot;&gt;MPP http 클라이언트)도 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45d0e31509240af7f0d899e0847fb308f3f6c3d9" translate="yes" xml:space="preserve">
          <source>In this tutorial We will learn how to:</source>
          <target state="translated">이 학습서에서는 다음을 수행하는 방법을 학습합니다.</target>
        </trans-unit>
        <trans-unit id="b8d78e48aa113b25ef679f219669ead0543c6d9d" translate="yes" xml:space="preserve">
          <source>In this tutorial however, we'll see how to use some specific libraries, such as &lt;code&gt;libcurl&lt;/code&gt;. We'll learn to</source>
          <target state="translated">그러나이 튜토리얼에서는 &lt;code&gt;libcurl&lt;/code&gt; 과 같은 특정 라이브러리를 사용하는 방법을 살펴 봅니다 . 우리는 배울 것이다</target>
        </trans-unit>
        <trans-unit id="38ae904b992e64be7d6f1c95db212a698e90d2ef" translate="yes" xml:space="preserve">
          <source>In this tutorial we have:</source>
          <target state="translated">이 튜토리얼에서 우리는 :</target>
        </trans-unit>
        <trans-unit id="814c4fd32a87a880ed24663823d0826f5fba0218" translate="yes" xml:space="preserve">
          <source>In this tutorial we see how to deal with C strings in Kotlin/Native. We will learn how to:</source>
          <target state="translated">이 튜토리얼에서는 Kotlin / Native에서 C 문자열을 처리하는 방법을 살펴 봅니다. 우리는 방법을 배울 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f187570814c6d6abda5a2c00ead30d73ef74a12e" translate="yes" xml:space="preserve">
          <source>In this tutorial we will create an iOS and Android application, by making use of Kotlin's code sharing features. For Android we'll be using Kotlin/JVM, while for iOS it will be Kotlin/Native.</source>
          <target state="translated">이 튜토리얼에서는 Kotlin의 코드 공유 기능을 사용하여 iOS 및 Android 애플리케이션을 작성합니다. 안드로이드의 경우 Kotlin / JVM을 사용하고 iOS의 경우 Kotlin / Native가됩니다.</target>
        </trans-unit>
        <trans-unit id="e75dd7cce5c41f63288c1748bd5bfd1c78d1ff1b" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll see how to</source>
          <target state="translated">이 튜토리얼에서 우리는</target>
        </trans-unit>
        <trans-unit id="73192ff47f695a8d1b74a36ad93cdb6ae37eb2de" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required to use the Kotlin Android Extensions plugin, enhancing the experience of Android development.</source>
          <target state="translated">이 학습서에서는 Kotlin Android Extensions 플러그인을 사용하여 Android 개발 경험을 향상시키는 데 필요한 단계를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="f0e340bf119483d38d43d3af161837206adf260c" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll walk through the steps required. For a more thorough explanation of Spring Boot and Kotlin, please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;Building web applications with Spring Boot and Kotlin&lt;/a&gt;.</source>
          <target state="translated">이 자습서에서는 필요한 단계를 안내합니다. Spring Boot 및 Kotlin에 대한 자세한 설명은 Spring Boot 및 Kotlin을 &lt;a href=&quot;https://spring.io/guides/tutorials/spring-boot-kotlin/&quot;&gt;사용하여 웹 애플리케이션 빌드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ead99e3026a0a00111c1c9a4f51b0c3c739752" translate="yes" xml:space="preserve">
          <source>In this tutorial we'll:</source>
          <target state="translated">이 자습서에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0f464678d81fef87702589d2f00f58596a930600" translate="yes" xml:space="preserve">
          <source>In this tutorial we're going to use IntelliJ IDEA. For instructions on how to compile and execute Kotlin applications using the command line compiler, see &lt;a href=&quot;command-line&quot;&gt;Working with the Command Line Compiler&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼에서는 IntelliJ IDEA를 사용합니다. 명령 행 컴파일러를 사용하여 Kotlin 애플리케이션을 컴파일하고 실행하는 방법에 대한 지시 사항은 명령 행 컴파일러 &lt;a href=&quot;command-line&quot;&gt;작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5d5b9a27b34d95239a0c33821d0a9b033c40bd3" translate="yes" xml:space="preserve">
          <source>In this tutorial we've seen how to create a Kotlin application that targets JavaScript, debug it as well as set compiler options. In other tutorials we'll cover more in-depth topics such as interacting with the DOM, etc.</source>
          <target state="translated">이 튜토리얼에서는 JavaScript를 대상으로하는 Kotlin 애플리케이션을 생성하고 디버깅하며 컴파일러 옵션을 설정하는 방법을 살펴 보았습니다. 다른 튜토리얼에서는 DOM과의 상호 작용 등과 같은 더 자세한 주제를 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="15ab8dc4bd9f08f596ae63880b3958cb4434a6d7" translate="yes" xml:space="preserve">
          <source>In this tutorial, we learn what C data types are visible in Kotlin/Native and vice versa. We will:</source>
          <target state="translated">이 학습서에서는 Kotlin / Native에 표시되는 C 데이터 유형과 그 반대에 대해 알아 봅니다. 우리는 :</target>
        </trans-unit>
        <trans-unit id="8a05d2cdb1fd77bc1ee6b2a0bfc489f7b20f51b2" translate="yes" xml:space="preserve">
          <source>In this tutorial, we look at how we can use the Kotlin/Native code from existing native applications or libraries. For this, we need to compile our Kotlin code into a dynamic library, &lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dylib&lt;/code&gt;, and &lt;code&gt;.dll&lt;/code&gt;.</source>
          <target state="translated">이 학습서에서는 기존 기본 애플리케이션 또는 라이브러리의 Kotlin / Native 코드를 사용하는 방법을 살펴 봅니다. 이를 위해 Kotlin 코드를 동적 라이브러리 &lt;code&gt;.so&lt;/code&gt; , &lt;code&gt;.dylib&lt;/code&gt; 및 &lt;code&gt;.dll&lt;/code&gt; 로 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="701903e9f376cd1d8503774a4d299554e97196a0" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a small library available from the worlds of JVM, JS, and Native. You will learn step-by-step how to create a multiplatform library which can be used from any other common code (e.g., one shared with Android and iOS), and how to write tests which will be executed on all platforms and use an efficient implementation provided by the concrete platform.</source>
          <target state="translated">이 학습서에서는 JVM, JS 및 Native의 세계에서 사용 가능한 작은 라이브러리를 빌드합니다. 다른 공통 코드 (예 : Android 및 iOS와 공유되는 코드)에서 사용할 수있는 멀티 플랫폼 라이브러리를 만드는 방법과 모든 플랫폼에서 실행되고 효율적인 테스트를 작성하는 방법을 단계별로 학습합니다. 구체적인 플랫폼에 의해 제공되는 구현.</target>
        </trans-unit>
        <trans-unit id="8459da0cf638e813dae1e5c0fa95e9568c3582bd" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will look at how to use Kotlin/Native code from Objective-C and Swift applications on macOS and iOS. We will build a framework from Kotlin code.</source>
          <target state="translated">이 튜토리얼에서는 macOS 및 iOS에서 Objective-C 및 Swift 애플리케이션의 Kotlin / 네이티브 코드를 사용하는 방법을 살펴 봅니다. Kotlin 코드에서 프레임 워크를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="864dde628feba0ddb56fa697c290d183bee8b077" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will:</source>
          <target state="translated">이 자습서에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="98c10d04454a966f67cb1dfe790300722810cd2d" translate="yes" xml:space="preserve">
          <source>In this tutorial, we'll look at how to</source>
          <target state="translated">이 자습서에서는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0c3ebd5f96036d4c23f2a9d6d5dd9911faa69aff" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼에서는 Gradle을 사용하지만 IntelliJ IDEA 프로젝트 구조 또는 Maven을 사용하여 동일하게 수행 할 수 있습니다. Kotlin과 함께 작동하도록 Gradle 설정에 대한 자세한 내용은 Gradle &lt;a href=&quot;../reference/using-gradle&quot;&gt;사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa1a5fa948935055fc078b1993ec8baed9df514c" translate="yes" xml:space="preserve">
          <source>In this tutorial, we're going to be using Gradle but the same can be accomplished using either IntelliJ IDEA project structure or Maven. For details on setting up Gradle to work with Kotlin, see &lt;a href=&quot;../reference/using-gradle&quot;&gt;Using Gradle&lt;/a&gt;. The main dependency required for using HTTP servlets is the JavaEE API:</source>
          <target state="translated">이 튜토리얼에서는 Gradle을 사용하지만 IntelliJ IDEA 프로젝트 구조 또는 Maven을 사용하여 동일하게 수행 할 수 있습니다. Kotlin과 함께 작동하도록 Gradle 설정에 대한 자세한 내용은 Gradle &lt;a href=&quot;../reference/using-gradle&quot;&gt;사용을&lt;/a&gt; 참조하십시오 . HTTP 서블릿 사용에 필요한 주요 종속성은 JavaEE API입니다.</target>
        </trans-unit>
        <trans-unit id="40ab0f9121b36c46d899b6425de4821ece3db190" translate="yes" xml:space="preserve">
          <source>In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</source>
          <target state="translated">In this video, Kotlin Developer Advocate Sebastian Aigner will explain the main Kotlin/JS benefits to you, share some tips and use cases, and also tell you about the plans and upcoming features for Kotlin/JS.</target>
        </trans-unit>
        <trans-unit id="23e1b785f9b5814cd84a43b0c10801c0740b41ac" translate="yes" xml:space="preserve">
          <source>In turn, &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; have the context object as a lambda argument. If the argument name is not specified, the object is accessed by the implicit default name &lt;code&gt;it&lt;/code&gt;. &lt;code&gt;it&lt;/code&gt; is shorter than &lt;code&gt;this&lt;/code&gt; and expressions with &lt;code&gt;it&lt;/code&gt; are usually easier for reading. However, when calling the object functions or properties you don't have the object available implicitly like &lt;code&gt;this&lt;/code&gt;. Hence, having the context object as &lt;code&gt;it&lt;/code&gt; is better when the object is mostly used as an argument in function calls. &lt;code&gt;it&lt;/code&gt; is also better if you use multiple variables in the code block.</source>
          <target state="translated">차례로, &lt;code&gt;let&lt;/code&gt; 하고 &lt;code&gt;also&lt;/code&gt; 람다 인수로 컨텍스트 개체가 있습니다. 인수 이름을 지정하지 않으면 암시 적 기본 이름 인 &lt;code&gt;it&lt;/code&gt; 의해 오브젝트에 액세스 합니다 . &lt;code&gt;it&lt;/code&gt; 보다 짧은 &lt;code&gt;this&lt;/code&gt; 와와 표현 &lt;code&gt;it&lt;/code&gt; 일반적으로 읽기 쉽다. 오브젝트의 기능이나 속성을 호출 할 때, 당신은 암시 적으로 같이 사용할 수있는 오브젝트가없는 &lt;code&gt;this&lt;/code&gt; . 따라서 객체가 함수 호출에서 인수로 주로 사용될 때 컨텍스트 객체를 사용 &lt;code&gt;it&lt;/code&gt; 것이 좋습니다. &lt;code&gt;it&lt;/code&gt; 당신이 코드 블록에 여러 변수를 사용하는 경우 더 나은이기도합니다.</target>
        </trans-unit>
        <trans-unit id="812b574e96ace8dd4cdbeccd6ad6e3f2e4f0aabb" translate="yes" xml:space="preserve">
          <source>In turn, mutable collections aren't covariant; otherwise, this would lead to runtime failures. If &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; was a subtype of &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt;, you could insert other &lt;code&gt;Shape&lt;/code&gt; inheritors (for example, &lt;code&gt;Circle&lt;/code&gt;) into it, thus violating its &lt;code&gt;Rectangle&lt;/code&gt; type argument.</source>
          <target state="translated">결과적으로 변경 가능한 컬렉션은 공변량이 아닙니다. 그렇지 않으면 런타임 오류가 발생합니다. 경우 &lt;code&gt;MutableList&amp;lt;Rectangle&amp;gt;&lt;/code&gt; 의 하위 유형이었다 &lt;code&gt;MutableList&amp;lt;Shape&amp;gt;&lt;/code&gt; , 당신은 다른 삽입 할 수 &lt;code&gt;Shape&lt;/code&gt; (예를 들어, 상속자를 &lt;code&gt;Circle&lt;/code&gt; 따라서 그 위반, 그것으로) &lt;code&gt;Rectangle&lt;/code&gt; 타입의 인수를.</target>
        </trans-unit>
        <trans-unit id="2a50d6665033bbbaf15909f2a8b12edea9bb1926" translate="yes" xml:space="preserve">
          <source>In turn, set is not an ordered collection by &lt;a href=&quot;collections-overview&quot;&gt;definition&lt;/a&gt;. However, the Kotlin &lt;code&gt;Set&lt;/code&gt; stores elements in certain orders. These can be the order of insertion (in &lt;code&gt;LinkedHashSet&lt;/code&gt;), natural sorting order (in &lt;code&gt;SortedSet&lt;/code&gt;), or another order. The order of a set of elements can also be unknown. In such cases, the elements are still ordered somehow, so the functions that rely on the element positions still return their results. However, such results are unpredictable to the caller unless they know the specific implementation of &lt;code&gt;Set&lt;/code&gt; used.</source>
          <target state="translated">차례로 set은 &lt;a href=&quot;collections-overview&quot;&gt;정의에&lt;/a&gt; 따라 정렬 된 컬렉션이 아닙니다 . 그러나 Kotlin &lt;code&gt;Set&lt;/code&gt; 는 특정 순서로 요소를 저장합니다. 삽입 순서 ( &lt;code&gt;LinkedHashSet&lt;/code&gt; ), 자연 정렬 순서 ( &lt;code&gt;SortedSet&lt;/code&gt; ) 또는 다른 순서 일 수 있습니다. 요소 집합의 순서도 알 수 없습니다. 이러한 경우 요소는 여전히 순서대로 정렬되므로 요소 위치에 의존하는 함수는 여전히 결과를 반환합니다. 그러나 사용 된 &lt;code&gt;Set&lt;/code&gt; 의 특정 구현을 모르면 이러한 결과는 호출자에게 예측할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="26d300702c75a3b26e8ba1f4228f68dc28aca421" translate="yes" xml:space="preserve">
          <source>In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</source>
          <target state="translated">In turn, worksheets are project files: they are stored in project directories and tied to the project modules. Worksheets are useful for writing code parts that don't actually make a software unit but should still be stored together in a project. For example, you can use worksheets for education or demo materials.</target>
        </trans-unit>
        <trans-unit id="01b654ef30cda18991ddded390d4b967ccf9e9a4" translate="yes" xml:space="preserve">
          <source>In your scratch, you can write any valid Kotlin code, including new functions and classes. Syntax highlighting, auto-completion, and other code editing features of IntelliJ IDEA are supported in scratches.</source>
          <target state="translated">처음부터 새로운 함수와 클래스를 포함하여 유효한 Kotlin 코드를 작성할 수 있습니다. IntelliJ IDEA의 구문 강조, 자동 완성 및 기타 코드 편집 기능은 처음부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3348bba79393338a33249573a6e3c773462946f1" translate="yes" xml:space="preserve">
          <source>Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</source>
          <target state="translated">Include a custom JDK from the specified location into the classpath instead of the default JAVA_HOME</target>
        </trans-unit>
        <trans-unit id="f2699078d9287cbd90f76ee50448a4fec028de87" translate="yes" xml:space="preserve">
          <source>Including static library in your klib</source>
          <target state="translated">klib에 정적 라이브러리 포함</target>
        </trans-unit>
        <trans-unit id="84996d5891b1f1a645c33eb5c3b22433a18e3eec" translate="yes" xml:space="preserve">
          <source>Incompatible Changes</source>
          <target state="translated">호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="8d41722fdaa1b8acfa42d80a00302ec1d80e560e" translate="yes" xml:space="preserve">
          <source>IncorrectDereferenceException</source>
          <target state="translated">IncorrectDereferenceException</target>
        </trans-unit>
        <trans-unit id="7c15aa041f9a78e640a95e3034dce236ee5d488b" translate="yes" xml:space="preserve">
          <source>Incremental Compilation</source>
          <target state="translated">증분 컴파일</target>
        </trans-unit>
        <trans-unit id="1d25e364e8dc05079a68a8ada56d8fbeda70bc16" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing (since 1.3.30)</source>
          <target state="translated">증분 주석 처리 (1.3.30부터)</target>
        </trans-unit>
        <trans-unit id="29106d30f82b4fbf8a046db084591a963e0208cc" translate="yes" xml:space="preserve">
          <source>Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">Incremental annotation processing is enabled by default starting from version 1.3.50. To disable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</target>
        </trans-unit>
        <trans-unit id="b1262b9eb921db266028505964086f28ad7e7f94" translate="yes" xml:space="preserve">
          <source>Incremental compilation</source>
          <target state="translated">증분 컴파일</target>
        </trans-unit>
        <trans-unit id="3bb3cfba326a2bdc90f381639a6d53003c8fb9e7" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</source>
          <target state="translated">Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects.</target>
        </trans-unit>
        <trans-unit id="33b5061796594b36b41f624484bcfb3853bb6d0c" translate="yes" xml:space="preserve">
          <source>Incremental compilation is supported for Kotlin/JVM and Kotlin/JS projects. It's enabled by default since Kotlin 1.1.1 for Kotlin/JVM and 1.3.20 for Kotlin/JS.</source>
          <target state="translated">Kotlin / JVM 및 Kotlin / JS 프로젝트에 대해 증분 컴파일이 지원됩니다. Kotlin / JVM의 경우 Kotlin 1.1.1 및 Kotlin / JS의 경우 1.3.20부터 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6dbea2b53708e66e73d3f1a6a99defec97fa2a9" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Experimental features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">증분 릴리스는 툴링 (종종 기능 포함), 성능 개선 및 버그 수정에 대한 업데이트를 제공합니다. 우리는 그러한 버전을 서로 호환되도록 유지하려고 노력하므로 컴파일러의 변경은 대부분 최적화 및 경고 추가 / 제거입니다. 실험 기능은 물론 언제든지 추가, 제거 또는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36431db4a12e3c14e9de849f36b5befe35ed62b5" translate="yes" xml:space="preserve">
          <source>Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</source>
          <target state="translated">Incremental releases bring updates in the tooling (often including features), performance improvements and bug fixes. We try to keep such versions compatible with each other, so changes to the compiler are mostly optimizations and warning additions/removals. Pre-stable features may, of course, be added, removed or changed at any time.</target>
        </trans-unit>
        <trans-unit id="9c0b336ea67b1169e696bcad497094e1948f51aa" translate="yes" xml:space="preserve">
          <source>Increments and decrements</source>
          <target state="translated">증감</target>
        </trans-unit>
        <trans-unit id="51065cc396f6ec67a2538e872f538ab2d9ab75c9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet%28kotlin.Int%29%2Fdelta&quot;&gt;델타&lt;/a&gt; 단위로 값을 증가시키고 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0f32b37b99e84f7a892589880d018ef9b908ef9" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicInt%24addAndGet(kotlin.Int)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</target>
        </trans-unit>
        <trans-unit id="44233843d94836d1fccccf70b3b2b867d9acc067" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">&lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet%28kotlin.Long%29%2Fdelta&quot;&gt;델타&lt;/a&gt; 단위로 값을 증가시키고 새로운 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="166f962aa69e44913e0b39e6fa68583a02fd3a79" translate="yes" xml:space="preserve">
          <source>Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</source>
          <target state="translated">Increments the value by &lt;a href=&quot;add-and-get#kotlin.native.concurrent.AtomicLong%24addAndGet(kotlin.Long)/delta&quot;&gt;delta&lt;/a&gt; and returns the new value.</target>
        </trans-unit>
        <trans-unit id="28411949be3415589036a91826011ccfec40fbd4" translate="yes" xml:space="preserve">
          <source>Increments this value.</source>
          <target state="translated">이 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="b8fcfd847cda35bcb6945261dd3c4eb8f88f412a" translate="yes" xml:space="preserve">
          <source>Increments value by one.</source>
          <target state="translated">값을 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="83f705f84f3e506a637956b9907406ba6fe9f41e" translate="yes" xml:space="preserve">
          <source>IndexOutOfBoundsException</source>
          <target state="translated">IndexOutOfBoundsException</target>
        </trans-unit>
        <trans-unit id="4a12f879063aea0813ebab8015ddf21b727cd7af" translate="yes" xml:space="preserve">
          <source>Indexed access operator</source>
          <target state="translated">인덱스 액세스 연산자</target>
        </trans-unit>
        <trans-unit id="d4e1cf8d774b0c0bb9b5921ec7fa833544082d60" translate="yes" xml:space="preserve">
          <source>IndexedValue</source>
          <target state="translated">IndexedValue</target>
        </trans-unit>
        <trans-unit id="2606e49e237c315e21ba9ad3205e46744904acbb" translate="yes" xml:space="preserve">
          <source>Indexing suffix</source>
          <target state="translated">Indexing suffix</target>
        </trans-unit>
        <trans-unit id="4ad24986a96806bcf716cdb15281ed398b1a31f5" translate="yes" xml:space="preserve">
          <source>Indicates whether some other object is &quot;equal to&quot; this one. Implementations must fulfil the following requirements:</source>
          <target state="translated">다른 객체가이 객체와 &quot;동일한 지&quot;여부를 나타냅니다. 구현은 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="53f09d01b93a3110068a373094e1fb376a10c3c8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">정규식이 지정된 &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn%28kotlin.CharSequence%29%2Finput&quot;&gt;입력&lt;/a&gt; 에서 하나 이상의 일치 항목을 찾을 수 있는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="51429e87bd819bb2f3942329861eee4721f512b8" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">Indicates whether the regular expression can find at least one match in the specified &lt;a href=&quot;contains-match-in#kotlin.text.Regex%24containsMatchIn(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="cc670204f79af50c97c85084d6a41b77270ab6a4" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">정규식이 전체 &lt;a href=&quot;matches#kotlin.text.Regex%24matches%28kotlin.CharSequence%29%2Finput&quot;&gt;입력&lt;/a&gt; 과 일치하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b98c0b71834f5e2d5a0d8cf79e50cdeebb2945aa" translate="yes" xml:space="preserve">
          <source>Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</source>
          <target state="translated">Indicates whether the regular expression matches the entire &lt;a href=&quot;matches#kotlin.text.Regex%24matches(kotlin.CharSequence)/input&quot;&gt;input&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="767a32bb6d83112e90455e54a6dd8a16300ca86c" translate="yes" xml:space="preserve">
          <source>Infix calls for named functions</source>
          <target state="translated">명명 된 함수에 대한 호출 호출</target>
        </trans-unit>
        <trans-unit id="1cea4b28540c3fbdd2e2436ba68910be38a3f387" translate="yes" xml:space="preserve">
          <source>Infix function calls have lower precedence than the arithmetic operators, type casts, and the &lt;code&gt;rangeTo&lt;/code&gt; operator. The following expressions are equivalent:</source>
          <target state="translated">삽입 함수 호출은 산술 연산자, 유형 캐스트 ​​및 &lt;code&gt;rangeTo&lt;/code&gt; 연산자 보다 우선 순위가 낮습니다 . 다음 표현식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c345bbff4a1e1fc76b2e4ede7fbe52f5de947e6b" translate="yes" xml:space="preserve">
          <source>Infix functions</source>
          <target state="translated">삽입 기능</target>
        </trans-unit>
        <trans-unit id="19c6abcd2f2f19793afb1f4565bae99cd5d50667" translate="yes" xml:space="preserve">
          <source>Infix notation</source>
          <target state="translated">접두사 표기</target>
        </trans-unit>
        <trans-unit id="c5a135f955f6a2349a2d4263f326ff3a2a3304ed" translate="yes" xml:space="preserve">
          <source>Information from explicit casts is used for type inference</source>
          <target state="translated">명시 적 캐스트의 정보는 유형 유추에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fc3ff49d31fe091e3831cd8bc1f2e6d38992276d" translate="yes" xml:space="preserve">
          <source>Inheritance from Java classes</source>
          <target state="translated">자바 클래스로부터 상속</target>
        </trans-unit>
        <trans-unit id="060c830dba717926ce4d26ef9693decc297e0680" translate="yes" xml:space="preserve">
          <source>Inheritance that leads to a &lt;code&gt;copy&lt;/code&gt; conflict has become deprecated with a warning in Kotlin 1.2 and will be an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 충돌로 이어지는 상속 은 Kotlin 1.2에서 경고로 더 이상 사용되지 않으며 Kotlin 1.3에서 오류가됩니다.</target>
        </trans-unit>
        <trans-unit id="fe8f308745a21bdbf9c67ae8f86198813253366c" translate="yes" xml:space="preserve">
          <source>Inherited Functions</source>
          <target state="translated">상속 된 함수</target>
        </trans-unit>
        <trans-unit id="a97b2d009dc11ee2399b0468fc72e941eebbf165" translate="yes" xml:space="preserve">
          <source>Inherited Properties</source>
          <target state="translated">상속 된 속성</target>
        </trans-unit>
        <trans-unit id="f54b5bc69098e64d7fae998cd4e9df2d4fa8e7af" translate="yes" xml:space="preserve">
          <source>Inherited built-in functions</source>
          <target state="translated">상속 된 내장 함수</target>
        </trans-unit>
        <trans-unit id="af6ed82fe139bda1a895add0ffee5c78ca3dcf12" translate="yes" xml:space="preserve">
          <source>Inheritors</source>
          <target state="translated">Inheritors</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="100b184b34b9bc80bfe5761ad8aa4a5db3c27036" translate="yes" xml:space="preserve">
          <source>Initialized with a value of type &lt;code&gt;String&lt;/code&gt; or a primitive type</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 유형 또는 기본 유형 의 값으로 초기화</target>
        </trans-unit>
        <trans-unit id="0c55ba13e2bd9dbfd35641ebe93792c6061e39cd" translate="yes" xml:space="preserve">
          <source>Initializer</source>
          <target state="translated">Initializer</target>
        </trans-unit>
        <trans-unit id="cddbd43ce85bc15d27c1f2848a884d7030458b88" translate="yes" xml:space="preserve">
          <source>Initializer function can be called several times on concurrent access to uninitialized &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance value, but only the first returned value will be used as the value of &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance.</source>
          <target state="translated">초기화되지 않은 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 값 에 동시에 액세스하면 초기화 기능을 여러 번 호출 할 수 있지만 첫 번째로 반환 된 값만 &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스 의 값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8de9a4ea59b21de32db609afcfc607895faed0de" translate="yes" xml:space="preserve">
          <source>Initializer functions for lists</source>
          <target state="translated">리스트의 이니셜 라이저 기능</target>
        </trans-unit>
        <trans-unit id="db5e65d8fc7dddd98f6860c2416bcbcc90ec0fba" translate="yes" xml:space="preserve">
          <source>Initializers</source>
          <target state="translated">Initializers</target>
        </trans-unit>
        <trans-unit id="96e412fcc42808e35495dbc64ebcde5c69c261de" translate="yes" xml:space="preserve">
          <source>Initializes Kotlin runtime for the current thread, if not inited already.</source>
          <target state="translated">아직 초기화되지 않은 경우 현재 스레드에 대한 Kotlin 런타임을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="4bf76bf156ef56b953245fb5da4ea73be4ae4d91" translate="yes" xml:space="preserve">
          <source>Initiates a call to this deep recursive function, forming a root of the call tree.</source>
          <target state="translated">Initiates a call to this deep recursive function, forming a root of the call tree.</target>
        </trans-unit>
        <trans-unit id="be787dbbf62b5076f4a13439769f15509c2967ea" translate="yes" xml:space="preserve">
          <source>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments, but &lt;code&gt;noinline&lt;/code&gt; ones can be manipulated in any way we like: stored in fields, passed around etc.</source>
          <target state="translated">inlinable lambdas는 인라인 함수 내에서만 호출되거나 inlinable 인수로 전달 될 수 있지만, &lt;code&gt;noinline&lt;/code&gt; 람다는 필드에 저장하거나 전달하는 등 원하는 방식으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60019f47df04ae92897fa912c6748a6013313fa" translate="yes" xml:space="preserve">
          <source>Inline Functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="77dc1cce985d17f15f3bb54896d9ab82a2428c34" translate="yes" xml:space="preserve">
          <source>Inline JavaScript</source>
          <target state="translated">인라인 JavaScript</target>
        </trans-unit>
        <trans-unit id="62d048ab15fe71589a192aa32dfde8cfed8f778a" translate="yes" xml:space="preserve">
          <source>Inline Markup</source>
          <target state="translated">인라인 마크 업</target>
        </trans-unit>
        <trans-unit id="5d360c4149ca0224f961067c92c26613a7104175" translate="yes" xml:space="preserve">
          <source>Inline classes</source>
          <target state="translated">인라인 클래스</target>
        </trans-unit>
        <trans-unit id="9286e6770b0362425ca42b0e3ebc568ac630fc5b" translate="yes" xml:space="preserve">
          <source>Inline classes are allowed to inherit from interfaces:</source>
          <target state="translated">인라인 클래스는 인터페이스에서 상속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c5881ab063c0ce817cf6f52ab599309c2d3110f" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">인라인 클래스는 Kotlin 1.3 이후로만 제공되며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 세부 사항을 참조하십시오 &lt;a href=&quot;#experimental-status-of-inline-classes&quot;&gt;아래를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f253e2ca96472e7c3372c8639328c1d3867dc3b6" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">인라인 클래스는 Kotlin 1.3 이후로만 제공되며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 에서 자세한 내용을 참조하십시오 &lt;a href=&quot;inline-classes#experimental-status-of-inline-classes&quot;&gt;참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe109e560117398094720f2c3a634950943781d" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">Inline classes are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details in the &lt;a href=&quot;inline-classes#alpha-status-of-inline-classes&quot;&gt;reference&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6ad02ddc63db8ea1a5da350db44423e72064462a" translate="yes" xml:space="preserve">
          <source>Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">Inline classes are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Alpha&lt;/a&gt;. See details &lt;a href=&quot;#alpha-status-of-inline-classes&quot;&gt;below&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7a2cb12c8331fe8180ea13004fae9e89ef3e1fd" translate="yes" xml:space="preserve">
          <source>Inline classes support some functionality of regular classes. In particular, they are allowed to declare properties and functions:</source>
          <target state="translated">인라인 클래스는 일반 클래스의 일부 기능을 지원합니다. 특히 속성과 함수를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c7769b31582b2d304756a0e1ee20904b47b72a0" translate="yes" xml:space="preserve">
          <source>Inline classes vs type aliases</source>
          <target state="translated">인라인 클래스와 타입 별칭</target>
        </trans-unit>
        <trans-unit id="126b7ff7e58c488c8dbbe2c35dcf311f885d0926" translate="yes" xml:space="preserve">
          <source>Inline extension functions that were called on a null value of a platform type did not check the receiver for null and would thus allow null to escape into the other code. Kotlin 1.2 forces this check at the call sites, throwing an exception if the receiver is null.</source>
          <target state="translated">플랫폼 유형의 널값에서 호출 된 인라인 확장 함수는 수신자가 널을 검사하지 않아 널이 다른 코드로 이스케이프되도록 허용합니다. Kotlin 1.2는 콜 사이트에서이 검사를 강제 실행하고 수신자가 null 인 경우 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5c804513cadec43c33b180af13b2e9aec456a962" translate="yes" xml:space="preserve">
          <source>Inline functions</source>
          <target state="translated">인라인 함수</target>
        </trans-unit>
        <trans-unit id="9d0d1200e09d5fde96bd026c2e6ca0b2d04d5ad5" translate="yes" xml:space="preserve">
          <source>Inline functions are explained &lt;a href=&quot;inline-functions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">인라인 함수는 &lt;a href=&quot;inline-functions&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa8db13612a09f046bbacee8122bb577b38d70fa" translate="yes" xml:space="preserve">
          <source>Inline functions are now allowed to have default values for their inlined functional parameters:</source>
          <target state="translated">인라인 함수는 이제 인라인 된 기능 매개 변수에 대한 기본값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c978967701dd3225fcc54de37cf91805dd0b8d" translate="yes" xml:space="preserve">
          <source>Inline functions with &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; have their actual type arguments inlined at each call site, which enables &lt;code&gt;arg is T&lt;/code&gt; checks for the type parameters, but if &lt;code&gt;arg&lt;/code&gt; is an instance of a generic type itself, &lt;em&gt;its&lt;/em&gt; type arguments are still erased. Example:</source>
          <target state="translated">&lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;형식&lt;/a&gt; 이 지정된 매개 변수 가있는 인라인 함수에는 각 호출 사이트에 실제 형식 인수가 인라인되어 있습니다. &lt;code&gt;arg is T&lt;/code&gt; 형식 매개 변수에 대한 T 검사이지만 &lt;code&gt;arg&lt;/code&gt; 가 일반 형식의 인스턴스 인 경우 &lt;em&gt;해당&lt;/em&gt; 형식 인수는 여전히 지워집니다. 예:</target>
        </trans-unit>
        <trans-unit id="dad40d691cb152e5ea04161c10815db00953ebbb" translate="yes" xml:space="preserve">
          <source>Inline functions with default functional parameters</source>
          <target state="translated">기본 기능 매개 변수가있는 인라인 함수</target>
        </trans-unit>
        <trans-unit id="e60dd1451a60d33b2eca72439470d0150cb5cb84" translate="yes" xml:space="preserve">
          <source>Inline properties (since 1.1)</source>
          <target state="translated">인라인 속성 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="6fec8c0d06ca4be7ff0c4bc9fa753ee420aa8bbc" translate="yes" xml:space="preserve">
          <source>Inline property accessors</source>
          <target state="translated">인라인 속성 접근 자</target>
        </trans-unit>
        <trans-unit id="01185d7fc605bc19fbe95771073571a841e3e817" translate="yes" xml:space="preserve">
          <source>Inlining may cause the generated code to grow; however, if we do it in a reasonable way (i.e. avoiding inlining large functions), it will pay off in performance, especially at &quot;megamorphic&quot; call-sites inside loops.</source>
          <target state="translated">인라이닝하면 생성 된 코드가 커질 수 있습니다. 그러나 합리적인 방법으로 (즉, 큰 함수를 인라인하지 않는 경우) 수행하면 특히 루프 내부의 &quot;거시적 인&quot;콜 사이트에서 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="aacf14c4398ec9fe537fae7e92753856f34743cb" translate="yes" xml:space="preserve">
          <source>Inner classes</source>
          <target state="translated">내부 수업</target>
        </trans-unit>
        <trans-unit id="bc3fa717af37b9f1e13149ace0b8f86497367e3c" translate="yes" xml:space="preserve">
          <source>Inner classes inheriting &lt;code&gt;Throwable&lt;/code&gt; that capture generic parameters from the outer class</source>
          <target state="translated">외부 클래스에서 일반 매개 변수를 캡처하는 &lt;code&gt;Throwable&lt;/code&gt; 을 상속 하는 내부 클래스</target>
        </trans-unit>
        <trans-unit id="258becf2f7c7396759bd76072890548fa224b9a4" translate="yes" xml:space="preserve">
          <source>Inner classes of generic types that inherit from &lt;code&gt;Throwable&lt;/code&gt; could violate type-safety in a throw-catch scenario and thus have been deprecated, with a warning in Kotlin 1.2 and an error in Kotlin 1.3.</source>
          <target state="translated">&lt;code&gt;Throwable&lt;/code&gt; 에서 상속되는 제네릭 형식의 내부 클래스는 throw-catch 시나리오에서 형식 안전성을 위반할 수 있으므로 Kotlin 1.2의 경고와 Kotlin 1.3의 오류와 함께 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14a7c09e5913aa9efafcb8d3f6e59361da51506" translate="yes" xml:space="preserve">
          <source>InputEventInit</source>
          <target state="translated">InputEventInit</target>
        </trans-unit>
        <trans-unit id="081e0fb72f26260fc891fc2cb6cbf71cf9e0d97f" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 컬렉션 요소의 모든 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 를 지정된 &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의이 목록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="005fc2603487998262e6a4431116600f620b75a0" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts all of the elements of the specified collection &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;../-mutable-list/add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="887d8e7112f2b5499df8e54becfa68d97d70bd00" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 컬렉션 요소의 모든 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Felements&quot;&gt;요소&lt;/a&gt; 를 지정된 &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll%28kotlin.Int%2C+kotlin.collections.Collection%28%28kotlin.collections.MutableList.E%29%29%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의이 목록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="602fbcd913879c3c9b700203739e32c4a9b2050d" translate="yes" xml:space="preserve">
          <source>Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts all of the elements of the specified collection &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/elements&quot;&gt;elements&lt;/a&gt; into this list at the specified &lt;a href=&quot;add-all#kotlin.collections.MutableList%24addAll(kotlin.Int,%20kotlin.collections.Collection((kotlin.collections.MutableList.E)))/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d0c7a2de4f7654463ee73faa30f98d50a3b73e7e" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="043751f897f4eb9dc49253608d3dad5a3c113e89" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts an element into the list at the specified &lt;a href=&quot;../-mutable-list/add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="f6b6ae35f6d9d56e894884fb222d27eda900dc09" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add%28kotlin.Int%2C+kotlin.collections.AbstractMutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="dc5d1b50a39baeed86e36617a548438e3f127155" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.AbstractMutableList%24add(kotlin.Int,%20kotlin.collections.AbstractMutableList.E)/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6c1226de8bd8dc851fb3874b9c31e306f3fa56c5" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;add#kotlin.collections.MutableList%24add%28kotlin.Int%2C+kotlin.collections.MutableList.E%29%2Findex&quot;&gt;인덱스&lt;/a&gt; 의 목록에 요소를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="8e37de1820797a87c23300e79e4b0ed919d09e2a" translate="yes" xml:space="preserve">
          <source>Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Inserts an element into the list at the specified &lt;a href=&quot;add#kotlin.collections.MutableList%24add(kotlin.Int,%20kotlin.collections.MutableList.E)/index&quot;&gt;index&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="27480ec1869e9733f33a48ab29f659fcb2a460a3" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="0751e96b7b08da95e20ff3bc7df0567c20077897" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="3e04a0c39fa9e9ba6f8f7b53f66419ea35f91587" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subarray of the specified character array &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharArray,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="990caaef55fa9369abe10fe21e08b659ee5241e9" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;../insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="56381b6576df78ab7498f4c21ed74ffb38fce356" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/csq&quot;&gt;csq&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text%24insert(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence?,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="13ca00255e68344adaf9baf7d5fd54a64418b339" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(java.lang.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="f16ec6bfc81f5c607f3cb9b48f5e7a410c32c025" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text%24insertRange(kotlin.text.StringBuilder,%20kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="b15a142e3f1c0e94cad906174d3311d39fef798f" translate="yes" xml:space="preserve">
          <source>Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in a subsequence of the specified character sequence &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert-range#kotlin.text.StringBuilder%24insertRange(kotlin.Int,%20kotlin.CharSequence,%20kotlin.Int,%20kotlin.Int)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="98e8ddbbdefb8f6d9c8e1f1a1ec159981fb75050" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in the specified character array &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharArray)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="8bd299382c17ed7be741a94000ce27e3cb569545" translate="yes" xml:space="preserve">
          <source>Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts characters in the specified character sequence &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.CharSequence?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="c10488d941ff5f739e50f3ed8d100fc28145f09c" translate="yes" xml:space="preserve">
          <source>Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the specified character &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Char)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="ad678e17f874b23d4231a5cb1e5b3edfa0684922" translate="yes" xml:space="preserve">
          <source>Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the string &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.String?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="cb5279ca89113fa744f9ed912c21f45c93146fab" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the string representation of the specified boolean &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Boolean)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="b8ce5257d0d44bc8ee828b4f0aa168d27143f4fc" translate="yes" xml:space="preserve">
          <source>Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</source>
          <target state="translated">Inserts the string representation of the specified object &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/value&quot;&gt;value&lt;/a&gt; into this string builder at the specified &lt;a href=&quot;insert#kotlin.text.StringBuilder%24insert(kotlin.Int,%20kotlin.Any?)/index&quot;&gt;index&lt;/a&gt; and returns this instance.</target>
        </trans-unit>
        <trans-unit id="40e63a4d54fc0992dbc62da98003576fd7d50dbb" translate="yes" xml:space="preserve">
          <source>Inside a class, you can declare extensions for another class. Inside such an extension, there are multiple &lt;em&gt;implicit receivers&lt;/em&gt; - objects members of which can be accessed without a qualifier. The instance of the class in which the extension is declared is called &lt;em&gt;dispatch receiver&lt;/em&gt;, and the instance of the receiver type of the extension method is called &lt;em&gt;extension receiver&lt;/em&gt;.</source>
          <target state="translated">클래스 내에서 다른 클래스의 확장을 선언 할 수 있습니다. 이러한 확장에는 여러 개의 &lt;em&gt;암시 적 수신자&lt;/em&gt; 가 있으며, 한정자없이 오브젝트 멤버에 액세스 할 수 있습니다. 확장이 선언 된 클래스의 인스턴스를 &lt;em&gt;디스패치 수신기&lt;/em&gt; 라고 하고 확장 메소드의 수신자 유형 인스턴스는 &lt;em&gt;확장 수신기&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="97c34b033d93e70cd2130ab46bfa71cd52ac56f6" translate="yes" xml:space="preserve">
          <source>Inside a function a &lt;code&gt;vararg&lt;/code&gt;-parameter of type &lt;code&gt;T&lt;/code&gt; is visible as an array of &lt;code&gt;T&lt;/code&gt;, i.e. the &lt;code&gt;ts&lt;/code&gt; variable in the example above has type &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">함수, 안쪽 &lt;code&gt;vararg&lt;/code&gt; -parameter 타입 &lt;code&gt;T&lt;/code&gt; 는 배열로 표시되는 &lt;code&gt;T&lt;/code&gt; , 즉 &lt;code&gt;ts&lt;/code&gt; 입력 갖는 위의 예에서 변수 &lt;code&gt;Array&amp;lt;out T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="826cc6f6147dd291bf22ea4078acd71a79ba87cf" translate="yes" xml:space="preserve">
          <source>Inside a lambda expression with receiver, you can use &lt;code&gt;this&lt;/code&gt; to refer to the receiver object (in this case, &lt;code&gt;car&lt;/code&gt;). As usual, you can omit &lt;code&gt;this&lt;/code&gt; if there are no naming conflicts, which is why we can simply say &lt;code&gt;$horsepowers&lt;/code&gt; instead of &lt;code&gt;${this.horsepowers}&lt;/code&gt;. So beware that in Kotlin, &lt;code&gt;this&lt;/code&gt; can have different meanings depending on the context: if used inside (possibly nested) lambda expressions with receivers, it refers to the receiver object of the innermost enclosing lambda expression with receiver. If you need to &quot;break out&quot; of the function literal and get the &quot;original&quot; &lt;code&gt;this&lt;/code&gt; (the instance the member function you're inside is executing on), mention the containing class name after &lt;code&gt;this@&lt;/code&gt; - so if you're inside a function literal with receiver inside a member function of Car, use &lt;code&gt;this@Car&lt;/code&gt;.</source>
          <target state="translated">수신자가있는 람다 식 내부에서 &lt;code&gt;this&lt;/code&gt; 사용 하여 수신자 객체 (이 경우 &lt;code&gt;car&lt;/code&gt; ) 를 참조 할 수 있습니다 . 평소와 같이 이름 충돌이없는 경우 &lt;code&gt;this&lt;/code&gt; 생략 할 수 있으므로 &lt;code&gt;${this.horsepowers}&lt;/code&gt; 대신 &lt;code&gt;$horsepowers&lt;/code&gt; 라고 간단히 말할 수 있습니다 . 그래서 코 틀린, 즉 조심 &lt;code&gt;this&lt;/code&gt; (가능하게 중첩)을 사용 내부 수신기와 람다 식, 그것은 수신기 최 둘러싸 람다 식의 수신기 객체를 참조하는 경우 : 문맥에 따라 다른 의미를 가질 수있다. 함수 리터럴을 &quot;분리&quot;하고 &quot;원본&quot;을 &lt;code&gt;this&lt;/code&gt; (내부 멤버 함수가 실행중인 인스턴스), &lt;code&gt;this@&lt;/code&gt; 뒤에 포함 클래스 이름을 언급하십시오. 따라서 Car 멤버 함수 내부에 수신자가있는 함수 리터럴 안에 있다면 &lt;code&gt;this@Car&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d76861f103960eff4ae0c7430fef1ebd5d3e542c" translate="yes" xml:space="preserve">
          <source>Inside an inner class, accessing the superclass of the outer class is done with the &lt;em&gt;super&lt;/em&gt; keyword qualified with the outer class name: &lt;code&gt;super@Outer&lt;/code&gt;:</source>
          <target state="translated">내부 클래스 내에서 외부 클래스의 수퍼 클래스에 액세스하는 것은 외부 클래스 이름으로 &lt;em&gt;super&lt;/em&gt; 키워드를 사용하여 수행됩니다 : &lt;code&gt;super@Outer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8ccb5c0d6d5858f7a6cc2ca5c66201a3c3cecf82" translate="yes" xml:space="preserve">
          <source>Inside enum entries, defining a nested type that is not an &lt;code&gt;inner class&lt;/code&gt; has been deprecated due to issues in the initialization logic. This causes a warning in Kotlin 1.2 and will become an error in Kotlin 1.3.</source>
          <target state="translated">내부 열거 형 항목이 아닌 &lt;code&gt;inner class&lt;/code&gt; 가 아닌 중첩 형식을 정의 하면 초기화 논리의 문제로 인해 더 이상 사용되지 않습니다. 이것은 Kotlin 1.2에서 경고를 발생시키고 Kotlin 1.3에서 오류가됩니다.</target>
        </trans-unit>
        <trans-unit id="d5019da5c150ca59c7fa4dd453ea0a06cf96e080" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;apply&lt;/code&gt; block, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;maybeNull&lt;/code&gt;. There's an implicit &lt;code&gt;this&lt;/code&gt; in front of &lt;code&gt;memberPropertyA&lt;/code&gt;, &lt;code&gt;memberPropertyB&lt;/code&gt;, and &lt;code&gt;memberFunctionA&lt;/code&gt; (unless these don't exist on &lt;code&gt;maybeNull&lt;/code&gt;, in which case they'll be looked for in the containing scopes). Afterwards, &lt;code&gt;memberFunctionB()&lt;/code&gt; is also invoked on &lt;code&gt;maybeNull&lt;/code&gt;.</source>
          <target state="translated">(가) 내부 &lt;code&gt;apply&lt;/code&gt; 블록을 &lt;code&gt;this&lt;/code&gt; 을 의미 &lt;code&gt;maybeNull&lt;/code&gt; . 암시 적있어 &lt;code&gt;this&lt;/code&gt; 앞에 &lt;code&gt;memberPropertyA&lt;/code&gt; , &lt;code&gt;memberPropertyB&lt;/code&gt; 및 &lt;code&gt;memberFunctionA&lt;/code&gt; (이되지 않는 존재하지 않는 &lt;code&gt;maybeNull&lt;/code&gt; 이 경우 그들이 포함하는 범위에서 찾았다됩니다). 그 후, &lt;code&gt;memberFunctionB()&lt;/code&gt; 또한 &lt;code&gt;maybeNull&lt;/code&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f13d8be73f140532f836309395f0554a59c9c6f7" translate="yes" xml:space="preserve">
          <source>Inside the body of the function literal, the receiver object passed to a call becomes an &lt;em&gt;implicit&lt;/em&gt;&lt;em&gt;this&lt;/em&gt;, so that you can access the members of that receiver object without any additional qualifiers, or access the receiver object using a &lt;a href=&quot;this-expressions&quot;&gt;&lt;code&gt;this&lt;/code&gt; expression&lt;/a&gt;.</source>
          <target state="translated">함수 리터럴의 몸 내부의 호출에 전달 된 수신기 객체가 될 &lt;em&gt;암시 &lt;/em&gt;&lt;em&gt;이&lt;/em&gt; , 그래서 당신이 사용하는 추가 규정 또는 액세스하지 않고 수신기 객체를 그 수신기 객체의 멤버에 액세스 할 수있는 &lt;a href=&quot;this-expressions&quot;&gt; &lt;code&gt;this&lt;/code&gt; 표현&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2558cc93d05f62b7942210cca1e0fecc8bdce932" translate="yes" xml:space="preserve">
          <source>Inside the class that declares a lateinit property, you can check if it has been initialized:</source>
          <target state="translated">lateinit 속성을 선언하는 클래스 내에서 초기화되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="987506c0627eacba63113c8eade53536a31e1484" translate="yes" xml:space="preserve">
          <source>Inside the file, the documentation for the module as a whole and for individual packages is introduced by the corresponding first-level headings. The text of the heading must be &quot;Module &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt;&quot; for the module, and &quot;Package &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt;&quot; for a package.</source>
          <target state="translated">파일 내에서 모듈 전체 및 개별 패키지에 대한 설명서는 해당하는 첫 번째 수준 제목으로 소개됩니다. 표제의 텍스트는 모듈의 경우 &quot;모듈 &lt;code&gt;&amp;lt;module name&amp;gt;&lt;/code&gt; &quot;이고 패키지의 경우 &quot;패키지 &lt;code&gt;&amp;lt;package qualified name&amp;gt;&lt;/code&gt; &quot; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="493e88f297e12412d7ac95bb437b962fd0497829" translate="yes" xml:space="preserve">
          <source>Inside the lambda of a scope function, the context object is available by a short reference instead of its actual name. Each scope function uses one of two ways to access the context object: as a lambda &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;receiver&lt;/a&gt; (&lt;code&gt;this&lt;/code&gt;) or as a lambda argument (&lt;code&gt;it&lt;/code&gt;). Both provide the same capabilities, so we'll describe the pros and cons of each for different cases and provide recommendations on their use.</source>
          <target state="translated">범위 함수의 람다 내에서 컨텍스트 오브젝트는 실제 이름 대신 짧은 참조로 사용 가능합니다. 각 범위 함수는 컨텍스트 객체에 액세스하는 두 가지 방법 중 하나를 사용합니다. 람다 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기&lt;/a&gt; ( &lt;code&gt;this&lt;/code&gt; ) 또는 람다 인수 ( &lt;code&gt;it&lt;/code&gt; ). 둘 다 동일한 기능을 제공하므로 서로 다른 경우에 대한 각각의 장단점을 설명하고 사용에 대한 권장 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5003ad2518c8a72a35acc2813b3f299786173c02" translate="yes" xml:space="preserve">
          <source>Inspect Generated Kotlin APIs from a C library</source>
          <target state="translated">C 라이브러리에서 생성 된 Kotlin API 검사</target>
        </trans-unit>
        <trans-unit id="40cd793a9f0552fd84c4436f73c844d1482e9756" translate="yes" xml:space="preserve">
          <source>Inspect the contents of &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; of the distribution for the details.</source>
          <target state="translated">세부 사항은 분배 의 &lt;code&gt;dist/klib/platform/$target&lt;/code&gt; 의 내용을 검사 하십시오.</target>
        </trans-unit>
        <trans-unit id="125c70324902d1ea37a08feb6e548d2fa859e9e8" translate="yes" xml:space="preserve">
          <source>Inspecting Generated Kotlin APIs for a C library</source>
          <target state="translated">C 라이브러리에 대해 생성 된 Kotlin API 검사</target>
        </trans-unit>
        <trans-unit id="bc318e2b8cd3f066b53b59698e603a8b1ca8d81c" translate="yes" xml:space="preserve">
          <source>Install custom unhandled exception hook. Returns old hook, or null if it was not specified. Hook is invoked whenever there's uncaught exception reaching boundaries of the Kotlin world, i.e. top level main(), or when Objective-C to Kotlin call not marked with @Throws throws an exception. Hook must be a frozen lambda, so that it could be called from any thread/worker. Hook is invoked once, and is cleared afterwards, so that memory leak detection works as expected even with custom exception hooks.</source>
          <target state="translated">처리되지 않은 사용자 지정 예외 후크를 설치하십시오. 이전 후크를 반환하거나 지정되지 않은 경우 null을 반환합니다. Kotlin 세계의 경계에 도달하지 않은 예외 (예 : 최상위 main ()) 또는 @Throws로 표시되지 않은 Objective-C에서 Kotlin 호출로 예외가 발생하면 후크가 호출됩니다. 후크는 고정 된 람다이어야하므로 모든 스레드 / 작업자에서 호출 할 수 있습니다. 후크가 한 번 호출 된 후 나중에 지워 지므로 사용자 정의 예외 후크에서도 메모리 누수 감지가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61dc4e9bf861172198001de007eee7dfc119f627" translate="yes" xml:space="preserve">
          <source>Install libgit2 and prepare stubs for the git library:</source>
          <target state="translated">libgit2를 설치하고 git 라이브러리를위한 스텁을 준비하십시오 :</target>
        </trans-unit>
        <trans-unit id="55178375f2d34a4d0b5f0a6c687d2b1b982ae90c" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;JetBrains Chrome Extension&lt;/a&gt; which allows debugging inside IntelliJ IDEA via Chrome. This is useful for any type of web application developed with IntelliJ IDEA, not just Kotlin.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/jetbrains-ide-support/hmhgeddbohgjknpmjagkdomcpobmllji?hl=en&quot;&gt;Chrome&lt;/a&gt; 을 통해 IntelliJ IDEA 내에서 디버깅 할 수 있는 JetBrains Chrome 확장 프로그램 을 설치하십시오 . 이것은 Kotlin뿐만 아니라 IntelliJ IDEA로 개발 된 모든 유형의 웹 응용 프로그램에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cba3ec3086c29abcbfa73fe1ec7eb10077b3664f" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</source>
          <target state="translated">Install the &lt;a href=&quot;https://cocoapods.org/&quot;&gt;CocoaPods dependency manager&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7237a8f52f82477e8aca289f73e7feebfb253754" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt;&lt;code&gt;cocoapods-generate&lt;/code&gt;&lt;/a&gt; plugin.</source>
          <target state="translated">Install the &lt;a href=&quot;https://github.com/square/cocoapods-generate&quot;&gt; &lt;code&gt;cocoapods-generate&lt;/code&gt; &lt;/a&gt; plugin.</target>
        </trans-unit>
        <trans-unit id="d91d23355e44b9f891a149ed27d5dd594ef16726" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</source>
          <target state="translated">Install the &lt;a href=&quot;https://plugins.jetbrains.com/plugin/10081-edutools&quot;&gt;EduTools plugin&lt;/a&gt; for IDEA and complete exercises from the &lt;a href=&quot;https://www.jetbrains.com/help/education/learner-start-guide.html?section=Kotlin%20Koans&quot;&gt;Kotlin Koans course&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6c9c342f22b1bebf06cebee1a33f0bf01b82e59" translate="yes" xml:space="preserve">
          <source>Install the CocoaPods dependency manager and plugin</source>
          <target state="translated">Install the CocoaPods dependency manager and plugin</target>
        </trans-unit>
        <trans-unit id="fdaed5952d98f86231a297a2212142ac7c035122" translate="yes" xml:space="preserve">
          <source>Installing EduTools plugin</source>
          <target state="translated">EduTools 플러그인 설치</target>
        </trans-unit>
        <trans-unit id="2a79a656994e8f8c151cea0c7b39c2c9e4d16ed5" translate="yes" xml:space="preserve">
          <source>Instance Checks</source>
          <target state="translated">인스턴스 확인</target>
        </trans-unit>
        <trans-unit id="9e1218ddd72144e647203114e5a8e7ec310019cb" translate="yes" xml:space="preserve">
          <source>Instance fields</source>
          <target state="translated">인스턴스 필드</target>
        </trans-unit>
        <trans-unit id="808164c9992eeb307ee53ea9dae39f6fb259b6e5" translate="yes" xml:space="preserve">
          <source>Instance required to make a call to the member, or an outer class instance for an inner class constructor.</source>
          <target state="translated">멤버를 호출하는 데 필요한 인스턴스 또는 내부 클래스 생성자를위한 외부 클래스 인스턴스</target>
        </trans-unit>
        <trans-unit id="a15783fb8d36e7147f368f4e99e9d406c5062f79" translate="yes" xml:space="preserve">
          <source>Instantiating a function type</source>
          <target state="translated">함수 타입 인스턴스화</target>
        </trans-unit>
        <trans-unit id="323fad682a062c4a52dfeb27dd2280fe7981b362" translate="yes" xml:space="preserve">
          <source>Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</source>
          <target state="translated">Instead of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt;, we can use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html&quot;&gt;supervisorScope&lt;/a&gt; for &lt;em&gt;scoped&lt;/em&gt; concurrency. It propagates the cancellation in one direction only and cancels all its children only if it failed itself. It also waits for all children before completion just like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;coroutineScope&lt;/a&gt; does.</target>
        </trans-unit>
        <trans-unit id="4d2cc7618aade0b4e22b2f6e46628e00aba0ed39" translate="yes" xml:space="preserve">
          <source>Instead of calling the method &lt;code&gt;matches&lt;/code&gt; directly we are storing a reference to it. Such reference is bound to its receiver. It can be called directly (like in the example above) or used whenever an expression of function type is expected:</source>
          <target state="translated">메소드 &lt;code&gt;matches&lt;/code&gt; 직접 호출하는 대신 참조를 저장합니다. 이러한 참조는 수신기에 바인딩됩니다. 함수 유형의 표현식이 필요할 때마다 직접 호출하거나 (위의 예와 같이) 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8213790556130c398f868064e28de372b2469df8" translate="yes" xml:space="preserve">
          <source>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code:</source>
          <target state="translated">매개 변수에 대한 함수 객체를 만들고 호출을 생성하는 대신 컴파일러는 다음 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83cef13eec16cda3d2cf44a7d9356f601633a76" translate="yes" xml:space="preserve">
          <source>Instead of threads Kotlin/Native runtime offers the concept of workers: concurrently executed control flow streams with an associated request queue. Workers are very similar to the actors in the Actor Model. A worker can exchange Kotlin objects with another worker, so that at any moment each mutable object is owned by a single worker, but ownership can be transferred. See section &lt;a href=&quot;#transfer&quot;&gt;Object transfer and freezing&lt;/a&gt;.</source>
          <target state="translated">스레드 대신 Kotlin / Native 런타임은 작업자의 개념을 제공합니다. 연관된 요청 큐와 함께 동시에 실행 된 제어 흐름 스트림. 워커는 액터 모델의 액터와 매우 유사합니다. 작업자는 Kotlin 개체를 다른 작업자와 교환 할 수 있으므로 언제든지 각 변경 가능한 개체를 단일 작업자가 소유하지만 소유권을 양도 할 수 있습니다. &lt;a href=&quot;#transfer&quot;&gt;개체 전송 및 고정&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72f70be3d9872cba860894ac5cf17293ed0d78f8" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate or omit wildcards for type arguments corresponding to parameters with declaration-site variance, for example such as &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; has.</source>
          <target state="translated">예를 들어 &lt;code&gt;Collection&amp;lt;out T&amp;gt;&lt;/code&gt; 와 같이 선언 사이트 차이가있는 매개 변수에 해당하는 형식 인수에 대해 와일드 카드를 생성하거나 생략하도록 컴파일러에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="783a81e7c87c37045741ac6ac177384c0af024d5" translate="yes" xml:space="preserve">
          <source>Instructs compiler to generate wildcard for annotated type arguments corresponding to parameters with declaration-site variance.</source>
          <target state="translated">선언 사이트 편차가있는 매개 변수에 해당하는 주석이 달린 형식 인수에 대해 와일드 카드를 생성하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="2008818ef3a5b5313d7106b4d54dde4c0275e9fe" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler not to generate getters/setters for this property and expose it as a field.</source>
          <target state="translated">Kotlin 컴파일러에게이 속성에 대한 getter / setter를 생성하지 않고 필드로 노출하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="13386323cf0532c0c864d57e3f5e6f155f3a611f" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c90ad955a31d769d0ca4882df53d8563d188c893" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;../-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b0c8be222fd671f12f20bd767b02c4381772bb8" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;../../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7818697c4ce6725112184b56cee9c62bbd312790" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate a multifile class with top-level functions and properties declared in this file as one of its parts. Name of the corresponding multifile class is provided by the &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; annotation.</source>
          <target state="translated">Kotlin 컴파일러가이 파일에서 일부로 선언 된 최상위 함수 및 속성을 가진 다중 파일 클래스를 생성하도록 지시합니다. 해당 다중 파일 클래스의 이름은 &lt;a href=&quot;../kotlin.jvm/-jvm-name/index#kotlin.jvm.JvmName&quot;&gt;JvmName&lt;/a&gt; 주석으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b493b4c87b9464cb2f6602a1607cbc49417f03a7" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.</source>
          <target state="translated">기본 매개 변수 값을 대체하는이 함수에 대한 과부하를 생성하도록 Kotlin 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="b7b71d6677358cf2e0528038c668cb35b0db79e9" translate="yes" xml:space="preserve">
          <source>Instructs the Kotlin compiler to treat annotated Java class as pure implementation of given Kotlin interface. &quot;Pure&quot; means here that each type parameter of class becomes non-platform type argument of that interface.</source>
          <target state="translated">주석이 달린 Java 클래스를 주어진 Kotlin 인터페이스의 순수한 구현으로 취급하도록 Kotlin 컴파일러에 지시합니다. &quot;순수함&quot;은 클래스의 각 유형 매개 변수가 해당 인터페이스의 비 플랫폼 유형 인수가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="691e0102b6c4ff1f7d6b4b79971b501f00d71a45" translate="yes" xml:space="preserve">
          <source>Int16Array</source>
          <target state="translated">Int16Array</target>
        </trans-unit>
        <trans-unit id="5c193dd46f10dac764d5258087bf039ad767fbce" translate="yes" xml:space="preserve">
          <source>Int32Array</source>
          <target state="translated">Int32Array</target>
        </trans-unit>
        <trans-unit id="e088a2144c05ba06fd761a7dbefbb84d2fc79069" translate="yes" xml:space="preserve">
          <source>Int8Array</source>
          <target state="translated">Int8Array</target>
        </trans-unit>
        <trans-unit id="4e1eee767ff111b716b2cc9473b02ef4802f7fa3" translate="yes" xml:space="preserve">
          <source>IntArray</source>
          <target state="translated">IntArray</target>
        </trans-unit>
        <trans-unit id="80050b51df21784d163dd20b4b73efde68f88f12" translate="yes" xml:space="preserve">
          <source>IntIterator</source>
          <target state="translated">IntIterator</target>
        </trans-unit>
        <trans-unit id="5808b7bdff6fe2202d34d31f55aa02c48c8f9d57" translate="yes" xml:space="preserve">
          <source>IntProgression</source>
          <target state="translated">IntProgression</target>
        </trans-unit>
        <trans-unit id="1ecd34c101b616e04032d5f18915a529dbf2c1ba" translate="yes" xml:space="preserve">
          <source>IntRange</source>
          <target state="translated">IntRange</target>
        </trans-unit>
        <trans-unit id="122a70b702fe4ea6640b0afbf0db142a8ee86964" translate="yes" xml:space="preserve">
          <source>IntVar</source>
          <target state="translated">IntVar</target>
        </trans-unit>
        <trans-unit id="3d2bffbceb8bff9b98f810d1689ed67697bea8bf" translate="yes" xml:space="preserve">
          <source>IntVarOf</source>
          <target state="translated">IntVarOf</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">정수 타입</target>
        </trans-unit>
        <trans-unit id="dee1ac1dc651dc2435d67e71a4478aae5437b7bf" translate="yes" xml:space="preserve">
          <source>Integer types in Kotlin have a &lt;em&gt;limited size&lt;/em&gt;, as opposed to the arbitrarily large integers in Python. The limit depends on the type, which decides how many bits the number occupies in memory:</source>
          <target state="translated">Kotlin의 정수 유형 은 Python의 임의의 큰 정수와 달리 &lt;em&gt;크기&lt;/em&gt; 가 &lt;em&gt;제한되어 있습니다&lt;/em&gt; . 제한은 유형에 따라 달라지며, 숫자는 메모리에서 숫자가 차지하는 비트 수를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="cda60a10cf7788b96a2f3e8c4df843ff16bf37d4" translate="yes" xml:space="preserve">
          <source>Integral type ranges (&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt;&lt;code&gt;IntRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt;&lt;code&gt;LongRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt;&lt;code&gt;CharRange&lt;/code&gt;&lt;/a&gt;) have an extra feature: they can be iterated over. These ranges are also &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;progressions&lt;/a&gt; of the corresponding integral types. Such ranges are generally used for iteration in the &lt;code&gt;for&lt;/code&gt; loops.</source>
          <target state="translated">통합 유형 범위 ( &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-int-range/index&quot;&gt; &lt;code&gt;IntRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-long-range/index&quot;&gt; &lt;code&gt;LongRange&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/-char-range/index&quot;&gt; &lt;code&gt;CharRange&lt;/code&gt; &lt;/a&gt; )에는 추가 기능이 있습니다. 반복 할 수 있습니다. 이 범위는 해당 정수 유형의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic_progression&quot;&gt;진행률&lt;/a&gt; 입니다. 이러한 범위는 일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 에서 반복에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="13f8bf35d86cdecdc30977f1b4bf82da0dde4e54" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Change type arguments&quot; quick-fix. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</target>
        </trans-unit>
        <trans-unit id="2bee37b0cdd0528c3a6b459962cdaf6bec045292" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</source>
          <target state="translated">IntelliJ IDEA can also automatically generate the &lt;code&gt;@Suppress&lt;/code&gt; annotation. Open the intentions menu via the light bulb icon or Alt-Enter, and click the small arrow next to the &quot;Unchecked cast to external interface&quot; inspection. Here, you can select the suppression scope, and your IDE will add the annotation to your file accordingly.</target>
        </trans-unit>
        <trans-unit id="10bb7deeea7ab770c8cc611de5a7e9bd46c52593" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA can run the code from scratches and worksheets automatically. To get the execution results when you stop typing, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="8489966f59e24770658292f5a494ac85bfb4f6e0" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA can run your scratches automatically. To get the execution results once you stop typing for a short time, switch on the &lt;strong&gt;Interactive mode&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA는 스크래치를 자동으로 실행할 수 있습니다. 짧은 시간 동안 입력을 중단 한 후에 실행 결과를 얻으려면 &lt;strong&gt;대화식 모드를&lt;/strong&gt; 켜십시오 .</target>
        </trans-unit>
        <trans-unit id="11066aac7596078ae46263d8a457c412baa42d01" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA will add the corresponding entries for us in the &lt;a href=&quot;#maven-configuration&quot;&gt;Maven configuration&lt;/a&gt;.</source>
          <target state="translated">IntelliJ IDEA는 &lt;a href=&quot;#maven-configuration&quot;&gt;Maven 구성&lt;/a&gt; 에서 해당 항목을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="eff2bf29e6c4ca5eac858ebfb9f2e0be07577de6" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</source>
          <target state="translated">IntelliJ IDEA's kotlin plugin understands the semantics of &lt;code&gt;TODO()&lt;/code&gt; and automatically adds a code pointer in the TODO toolwindow.</target>
        </trans-unit>
        <trans-unit id="54d05b8bf6f20e0d324256cf774765900389821b" translate="yes" xml:space="preserve">
          <source>Interact with the DOM</source>
          <target state="translated">DOM과 상호 작용</target>
        </trans-unit>
        <trans-unit id="2c419294377dd8ca37e7cb76b4dea91ed19ea8dc" translate="yes" xml:space="preserve">
          <source>Interacting with the DOM</source>
          <target state="translated">DOM과의 상호 작용</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">대화식 모드</target>
        </trans-unit>
        <trans-unit id="b02084f4df61f4f1999048df4a4f737cbeb8d5d5" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 인터셉트 계속 .</target>
        </trans-unit>
        <trans-unit id="653ee20081a2ed0c0dfdeafb8d4cc56b1706495b" translate="yes" xml:space="preserve">
          <source>Intercept continuation with &lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines.experimental/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 인터셉트 계속 .</target>
        </trans-unit>
        <trans-unit id="ef76b9eb4630422886c9e0fac2f1db0f2f6f1af1" translate="yes" xml:space="preserve">
          <source>Interception of delegated property binding</source>
          <target state="translated">위임 된 속성 바인딩 차단</target>
        </trans-unit>
        <trans-unit id="fc7a4e9264f9fe99aec05e3498611be00e954e41" translate="yes" xml:space="preserve">
          <source>Intercepts this continuation with &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt;.</source>
          <target state="translated">이 연속을 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor로&lt;/a&gt; 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="16bd3eae0558639cfe5dccb9e5a929f401a38bef" translate="yes" xml:space="preserve">
          <source>Interface implementation layout</source>
          <target state="translated">인터페이스 구현 레이아웃</target>
        </trans-unit>
        <trans-unit id="b4d21bf63ded1f81b33de5ff71ef6ec0031cdd1f" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 값을 리턴하는 서스펜션 지점 이후의 연속을 나타내는 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="3d559a197ac3fd74c061414f5d71be30830c373e" translate="yes" xml:space="preserve">
          <source>Interface representing a continuation after a suspension point that returns value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 유형의 값을 리턴하는 서스펜션 지점 이후의 연속을 나타내는 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="3fb0788052e6b21a9e30969754a6a4b19102a8cb" translate="yes" xml:space="preserve">
          <source>Interfaces &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; both declare functions &lt;em&gt;foo()&lt;/em&gt; and &lt;em&gt;bar()&lt;/em&gt;. Both of them implement &lt;em&gt;foo()&lt;/em&gt;, but only &lt;em&gt;B&lt;/em&gt; implements &lt;em&gt;bar()&lt;/em&gt; (&lt;em&gt;bar()&lt;/em&gt; is not marked abstract in &lt;em&gt;A&lt;/em&gt;, because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class &lt;em&gt;C&lt;/em&gt; from &lt;em&gt;A&lt;/em&gt;, we, obviously, have to override &lt;em&gt;bar()&lt;/em&gt; and provide an implementation.</source>
          <target state="translated">인터페이스 &lt;em&gt;A&lt;/em&gt; 와 &lt;em&gt;B는&lt;/em&gt; 모두 &lt;em&gt;foo ()&lt;/em&gt; 및 &lt;em&gt;bar ()&lt;/em&gt; 함수를 선언합니다 . 둘 다 &lt;em&gt;foo ()를&lt;/em&gt; 구현 하지만 &lt;em&gt;B&lt;/em&gt; 만 구현합니다. &lt;em&gt;bar ()&lt;/em&gt; ( &lt;em&gt;bar ()&lt;/em&gt; 는 &lt;em&gt;A&lt;/em&gt; 에서 abstract로 표시되지 않습니다 . 함수에 본문이 없으면 인터페이스의 기본값이므로). 이제 &lt;em&gt;A&lt;/em&gt; 에서 구체적인 클래스 &lt;em&gt;C&lt;/em&gt; 를 파생 시키면 &lt;em&gt;bar ()&lt;/em&gt; 를 재정의 하고 구현을 제공해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99ffdc8085488e57490fe414d8c6f2ac4c1599ac" translate="yes" xml:space="preserve">
          <source>Interfaces Inheritance</source>
          <target state="translated">인터페이스 상속</target>
        </trans-unit>
        <trans-unit id="8b075e134839d5d81cca3ebe6834964746dbfa9f" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Kotlin의 인터페이스는 Java 8과 매우 유사합니다. 여기에는 메소드 구현뿐만 아니라 추상 메소드 선언도 포함될 수 있습니다. 그것들을 추상 클래스와 다른 점은 인터페이스가 상태를 저장할 수 없다는 것입니다. 속성을 가질 수 있지만 이들은 추상적이거나 접근 자 구현을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3dc6f1c623405f44dfc6225166b717008c4b39d3" translate="yes" xml:space="preserve">
          <source>Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</source>
          <target state="translated">Interfaces in Kotlin can contain declarations of abstract methods, as well as method implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have properties but these need to be abstract or to provide accessor implementations.</target>
        </trans-unit>
        <trans-unit id="f3a19a0ac9dc5495efba84238a1c889b8a1af7e4" translate="yes" xml:space="preserve">
          <source>Interop with Java</source>
          <target state="translated">Java와의 Interop</target>
        </trans-unit>
        <trans-unit id="c644acaf1f3c1a0ed7a1256f251846c1b5938545" translate="yes" xml:space="preserve">
          <source>InteropStubs</source>
          <target state="translated">InteropStubs</target>
        </trans-unit>
        <trans-unit id="e8ee8f70e7d8b9c0f444242c7791f8de975f2a89" translate="yes" xml:space="preserve">
          <source>Interoperability</source>
          <target state="translated">Interoperability</target>
        </trans-unit>
        <trans-unit id="68de227c33695f7eee1af76e54576c5f473dbabb" translate="yes" xml:space="preserve">
          <source>Interoperability With Java Reflection</source>
          <target state="translated">Java 리플렉션과의 상호 운용성</target>
        </trans-unit>
        <trans-unit id="2a2e730dccd30c2b052062769d22631b368b3446" translate="yes" xml:space="preserve">
          <source>Interoperability with Java reflection</source>
          <target state="translated">Interoperability with Java reflection</target>
        </trans-unit>
        <trans-unit id="768631baf54d445fa8bf1b363fe5b7347532e0f6" translate="yes" xml:space="preserve">
          <source>Interoperability with Swift/Objective-C is provided too and covered in a separate document &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md&lt;/a&gt;.</source>
          <target state="translated">Swift / Objective-C와의 상호 운용성도 제공되며 별도의 문서 &lt;a href=&quot;objc_interop&quot;&gt;OBJC_INTEROP.md에서 다루고&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0f2c7977d4a0d28911368671a5b929d3d0eeba" translate="yes" xml:space="preserve">
          <source>Introducing an expression as a variable in local scope: &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">로컬 범위에서 변수로 표현식 소개 : &lt;code&gt;let&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="32255fd1a8ee65ebb05876eff1fd292d27126703" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin (in Russian)</source>
          <target state="translated">코 틀린 소개 (러시아어)</target>
        </trans-unit>
        <trans-unit id="8907e06f66221d3c7deda7eaa03a2cc4d7313211" translate="yes" xml:space="preserve">
          <source>Introduction to Kotlin Programming</source>
          <target state="translated">코 틀린 프로그래밍 소개</target>
        </trans-unit>
        <trans-unit id="1a733ca17cc418ac2040451ede20832965697fc4" translate="yes" xml:space="preserve">
          <source>InvalidMutabilityException</source>
          <target state="translated">InvalidMutabilityException</target>
        </trans-unit>
        <trans-unit id="ed8bc42e69c9abe4619cbcab39f65339c9a9ce60" translate="yes" xml:space="preserve">
          <source>Inverts the bits in this value.</source>
          <target state="translated">이 값의 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="555df15449eba01e6d316f12f10d25ead6974375" translate="yes" xml:space="preserve">
          <source>Inverts the bits including the sign bit in this value.</source>
          <target state="translated">이 값에서 부호 비트를 포함하는 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="1808969803eb296cd6d4f6a8c06b19cec81c8416" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">&lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; 호출은 코 루틴의 &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; 에있을 수 있는 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 를 거치지 않고 호출자의 스레드에서 직접 코 루틴을 재개합니다 . 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.intercepted.T%29%29%29&quot;&gt;연속&lt;/a&gt; 인터셉트를 사용하여 인터셉트 연속을 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12923fefc07e48286763b781976e0602cda671d5" translate="yes" xml:space="preserve">
          <source>Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</source>
          <target state="translated">Invocation of &lt;a href=&quot;../kotlin.coroutines/-continuation/resume-with&quot;&gt;Continuation.resumeWith&lt;/a&gt; resumes coroutine directly in the invoker's thread without going through the &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; that might be present in the coroutine's &lt;a href=&quot;../kotlin.coroutines/-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt;. It is the invoker's responsibility to ensure that a proper invocation context is established. &lt;a href=&quot;intercepted#kotlin.coroutines.intrinsics%24intercepted(kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.intercepted.T)))&quot;&gt;Continuation.intercepted&lt;/a&gt; can be used to acquire the intercepted continuation.</target>
        </trans-unit>
        <trans-unit id="a142e8aa439986e2d57c987fdc039b4c2ce8b67d" translate="yes" xml:space="preserve">
          <source>InvocationKind</source>
          <target state="translated">InvocationKind</target>
        </trans-unit>
        <trans-unit id="32a85866515d2c40342d72243d3af2e2ade61880" translate="yes" xml:space="preserve">
          <source>Invoke operator</source>
          <target state="translated">연산자 호출</target>
        </trans-unit>
        <trans-unit id="90d36cdc449e51ffdeb986b93d9cc3791424dd45" translate="yes" xml:space="preserve">
          <source>Invoked for the continuation instance returned by &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; when the original continuation completes and will not be used anymore. This function is invoked only if &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; had returned a different continuation instance from the one it was invoked with.</source>
          <target state="translated">원래 연속이 완료되어 더 이상 사용되지 않을 때 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation에&lt;/a&gt; 의해 리턴 된 연속 인스턴스에 대해 호출됩니다 . 이 함수는 &lt;a href=&quot;intercept-continuation&quot;&gt;interceptContinuation&lt;/a&gt; 이 호출 된 인스턴스와 다른 연속 인스턴스를 리턴 한 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7b262710ce446d5dceec2a721a656e3054eebf5" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;call()&lt;/code&gt; on a function object will call the function. If it is a member function, the first parameter must be the &lt;em&gt;receiver&lt;/em&gt; (the object on which the function is to be invoked, in this case &lt;code&gt;person&lt;/code&gt;), and the remaining parameters must be the ordinary function parameters (in this case &lt;code&gt;&quot;Anne&quot;&lt;/code&gt;).</source>
          <target state="translated">호출 &lt;code&gt;call()&lt;/code&gt; 함수 객체에하면 함수를 호출합니다. 멤버 함수 인 경우 첫 번째 매개 변수는 &lt;em&gt;수신자&lt;/em&gt; (이 경우 &lt;code&gt;person&lt;/code&gt; 을 호출 할 오브젝트 )이고 나머지 매개 변수는 일반 함수 매개 변수 (이 경우 &lt;code&gt;&quot;Anne&quot;&lt;/code&gt; ) 여야합니다. .</target>
        </trans-unit>
        <trans-unit id="e517c0efd966757777074a55cf84552ef188ca9a" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;findViewById()&lt;/code&gt; can be slow, especially in case of huge view hierarchies, so Android Extensions tries to minimize &lt;code&gt;findViewById()&lt;/code&gt; calls by caching views in containers.</source>
          <target state="translated">특히 대규모 뷰 계층 구조의 경우 &lt;code&gt;findViewById()&lt;/code&gt; 호출 이 느려질 수 있으므로 Android Extensions는 컨테이너에서 뷰를 캐싱하여 &lt;code&gt;findViewById()&lt;/code&gt; 호출 을 최소화하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="55b7cc54c31bd895727aeb7e2e5dfcfeaf500f67" translate="yes" xml:space="preserve">
          <source>Invoking a function type instance</source>
          <target state="translated">함수형 인스턴스 호출</target>
        </trans-unit>
        <trans-unit id="609d1188a5fb6f3c57a44ee5ee27b2fb07938bf1" translate="yes" xml:space="preserve">
          <source>Invoking functions on other collections</source>
          <target state="translated">다른 컬렉션에서 함수 호출</target>
        </trans-unit>
        <trans-unit id="39f649540ce7c567f8fc21179741df12bdec413a" translate="yes" xml:space="preserve">
          <source>Is Kotlin an object-oriented language or a functional one?</source>
          <target state="translated">코 틀린은 객체 지향 언어입니까, 기능 언어입니까?</target>
        </trans-unit>
        <trans-unit id="0396150c49da7aa331143384cade7b9761b9c77b" translate="yes" xml:space="preserve">
          <source>Is Kotlin compatible with the Java programming language?</source>
          <target state="translated">Kotlin은 Java 프로그래밍 언어와 호환됩니까?</target>
        </trans-unit>
        <trans-unit id="d651f0b2ee6f868c27d5b6dae520cfb850abc9e7" translate="yes" xml:space="preserve">
          <source>Is Kotlin free?</source>
          <target state="translated">코 틀린은 무료입니까?</target>
        </trans-unit>
        <trans-unit id="4096c8e1086b327150a7292e4d2afe3394a12f6e" translate="yes" xml:space="preserve">
          <source>Is Kotlin hard?</source>
          <target state="translated">코 틀린은 단단합니까?</target>
        </trans-unit>
        <trans-unit id="9edc452dd78ce29f04fd4cdc3ccb57260c61debd" translate="yes" xml:space="preserve">
          <source>Is Kotlin on Social Media?</source>
          <target state="translated">코 틀린은 소셜 미디어에 있습니까?</target>
        </trans-unit>
        <trans-unit id="4e2b800e686ee55bbeca8de0e7c4e9007eb7822f" translate="yes" xml:space="preserve">
          <source>Is Kotlin on social media?</source>
          <target state="translated">Is Kotlin on social media?</target>
        </trans-unit>
        <trans-unit id="06373ad2bc61a9e4042f42be3c932a4374d09d55" translate="yes" xml:space="preserve">
          <source>Is extension function</source>
          <target state="translated">확장 기능</target>
        </trans-unit>
        <trans-unit id="84f7edacad77f3efea0c1f9a95023335afe8e98e" translate="yes" xml:space="preserve">
          <source>Is there a Kotlin conference?</source>
          <target state="translated">코 틀린 회의가 있습니까?</target>
        </trans-unit>
        <trans-unit id="23fb12980d63818dd24d249914c5dbde1e4eab5d" translate="yes" xml:space="preserve">
          <source>Isn't it what we wanted from the very beginning?</source>
          <target state="translated">우리가 처음부터 원하는 것이 아닌가?</target>
        </trans-unit>
        <trans-unit id="651e4641fbeb110db3b7fdfb2bb5a04a7dfe7d1b" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object</source>
          <target state="translated">별도의 JavaScript 객체에서 선언 분리</target>
        </trans-unit>
        <trans-unit id="d439914b4bf445ecb5fcbbcfd0b7501a29e97254" translate="yes" xml:space="preserve">
          <source>Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</source>
          <target state="translated">Isolating declarations in a separate JavaScript object in &lt;code&gt;plain&lt;/code&gt; mode</target>
        </trans-unit>
        <trans-unit id="ec40e8e2417f63763bc4005b1f45f89c4b9bd620" translate="yes" xml:space="preserve">
          <source>It also works with meta-annotations:</source>
          <target state="translated">메타 주석과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f49ae3f8f0dbf679bfc3c5ff95bf21f8e30ee20" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 코 루틴을 생성하는 간단한 예제로 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fafe915e21eb48d949ca0df5819ea5714df59866" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</source>
          <target state="translated">It can be demonstrated by a simple example that creates root coroutines using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="b2cb6066b03e8d078e05b9934f5a0885eb7115c7" translate="yes" xml:space="preserve">
          <source>It can be demonstrated by the following example:</source>
          <target state="translated">It can be demonstrated by the following example:</target>
        </trans-unit>
        <trans-unit id="c7f79c6fa89f2be4d0900a1df15f6e4c9cd6d6d8" translate="yes" xml:space="preserve">
          <source>It can of course be done as a single expression: &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt;.</source>
          <target state="translated">물론 단일 표현식으로 수행 할 수 있습니다 : &lt;code&gt;val x = javaFunctionThatYouKnowReturnsNonNull()!!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4869b700b07f0d7aa2566a42cedd6c00ff40027" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change a context of a coroutine while still staying in the same coroutine as you can see in the output below:</source>
          <target state="translated">몇 가지 새로운 기술을 보여줍니다. 하나는 명시 적으로 지정된 컨텍스트와 함께 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 을 사용 하고 다른 하나는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; 함수를 사용하여 아래 출력에서 ​​볼 수있는 것과 동일한 코 루틴에 머물면서 코 루틴의 컨텍스트를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="407d919d76eb160a2f5dfd9e474e1e25b6f6932e" translate="yes" xml:space="preserve">
          <source>It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</source>
          <target state="translated">It demonstrates several new techniques. One is using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; with an explicitly specified context, and the other one is using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext&lt;/a&gt; function to change the context of a coroutine while still staying in the same coroutine, as you can see in the output below:</target>
        </trans-unit>
        <trans-unit id="df6b25cff4a7799af9dc4369b6ce738113d68ee2" translate="yes" xml:space="preserve">
          <source>It does not matter (for correctness) what context the actor itself is executed in. An actor is a coroutine and a coroutine is executed sequentially, so confinement of the state to the specific coroutine works as a solution to the problem of shared mutable state. Indeed, actors may modify their own private state, but can only affect each other through messages (avoiding the need for any locks).</source>
          <target state="translated">액터 자체가 어떤 컨텍스트에서 실행되는지는 (정확성을 위해) 중요하지 않습니다. 액터는 코 루틴이고 코 루틴은 순차적으로 실행되므로 특정 코 루틴에 대한 상태의 제한은 공유 가능한 가변 상태 문제에 대한 해결책으로 작동합니다. 실제로 액터는 자신의 개인 상태를 수정할 수 있지만 메시지를 통해서만 서로에게 영향을 줄 수 있습니다 (잠금이 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="838f4ba272421d5995e2a80726c6cbb738d51748" translate="yes" xml:space="preserve">
          <source>It expects the targets to provide platform-specific implementations for &lt;code&gt;writeLogMessage&lt;/code&gt;, and the common code can now use this declaration without any consideration of how it is implemented.</source>
          <target state="translated">대상은 &lt;code&gt;writeLogMessage&lt;/code&gt; 에 플랫폼 별 구현을 제공 할 것으로 예상 되며, 공통 코드는 구현 방법을 고려하지 않고이 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acca4b75fdfdc287f94d60288ba8cbf8ea940d89" translate="yes" xml:space="preserve">
          <source>It is also convenient to use when you have a callable reference instead of the lambda:</source>
          <target state="translated">람다 대신 호출 가능한 참조가있을 때 사용하는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="db36d25fe18e1fa8b4a072e0b9e5e699d53ac00e" translate="yes" xml:space="preserve">
          <source>It is also possible to configure all Kotlin compilation tasks in the project:</source>
          <target state="translated">프로젝트에서 모든 Kotlin 컴파일 작업을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e799686fc388ae642c64e9044143db835d23770" translate="yes" xml:space="preserve">
          <source>It is also possible to debug Kotlin applications using the standard Chrome debugger. Just make sure that you do generate source maps.</source>
          <target state="translated">표준 Chrome 디버거를 사용하여 Kotlin 응용 프로그램을 디버깅 할 수도 있습니다. 소스 맵을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d484974349c030ade989fbea0475cbaae9e9d98" translate="yes" xml:space="preserve">
          <source>It is also possible to iterate over numbers with an arbitrary step (not necessarily 1). This is done via the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">임의의 단계 (필수 1은 아님)로 숫자를 반복 할 수도 있습니다. 이것은 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; 기능을 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc446105af35ae94e82863937d04520fa631bab7" translate="yes" xml:space="preserve">
          <source>It is convenient to import all widget properties for a specific layout in one go:</source>
          <target state="translated">특정 레이아웃에 대한 모든 위젯 속성을 한 번에 가져 오는 것이 편리합니다.</target>
        </trans-unit>
        <trans-unit id="ea87fa24d13265d437721a500dc610021a2b6ae7" translate="yes" xml:space="preserve">
          <source>It is created by attaching &lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; function to a source of elements. To get an instance of &lt;a href=&quot;index&quot;&gt;Grouping&lt;/a&gt; use one of &lt;code&gt;groupingBy&lt;/code&gt; extension functions:</source>
          <target state="translated">&lt;code&gt;keySelector: (T) -&amp;gt; K&lt;/code&gt; 함수를 요소 소스 에 첨부하여 작성됩니다 . &lt;a href=&quot;index&quot;&gt;그룹화&lt;/a&gt; 인스턴스를 가져 오려면 &lt;code&gt;groupingBy&lt;/code&gt; 확장 함수 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9817b3326fc94d2d632dd03bcb277b7bc5e546ba" translate="yes" xml:space="preserve">
          <source>It is easy to demonstrate it in action:</source>
          <target state="translated">실제로 시연하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="5057879a755e254fb21862c60fef7113f875d675" translate="yes" xml:space="preserve">
          <source>It is easy to include a compiled Kotlin code into existing projects written in C, C++, Swift, Objective-C, and other languages. It is also easy to use existing native code, static or dynamic &lt;a href=&quot;native/c_interop&quot;&gt;C libraries&lt;/a&gt;, Swift/Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;frameworks&lt;/a&gt;, graphical engines, and anything else directly from Kotlin/Native.</source>
          <target state="translated">컴파일 된 Kotlin 코드를 C, C ++, Swift, Objective-C 및 기타 언어로 작성된 기존 프로젝트에 쉽게 포함시킬 수 있습니다. 또한 기존 네이티브 코드, 정적 또는 동적 &lt;a href=&quot;native/c_interop&quot;&gt;C 라이브러리&lt;/a&gt; , Swift / Objective-C &lt;a href=&quot;native/objc_interop&quot;&gt;프레임 워크&lt;/a&gt; , 그래픽 엔진 및 Kotlin / Native에서 직접 사용하는 모든 것을 쉽게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f37ac7cf663ce39ab7cecdf53e288f77e8f878b" translate="yes" xml:space="preserve">
          <source>It is easy to use the generated wrapper classes for C &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how do we create a new instance on those classes. As we see from the declarations of &lt;code&gt;MyStruct&lt;/code&gt; and &lt;code&gt;MyUnion&lt;/code&gt;, their constructors require a &lt;code&gt;NativePtr&lt;/code&gt;. Of course, we are not willing to deal with pointers manually. Instead, we can use Kotlin API to have those objects instantiated for us.</source>
          <target state="translated">Kotlin의 C &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;union&lt;/code&gt; 유형에 대해 생성 된 래퍼 클래스를 사용하는 것은 쉽습니다 . 생성 된 특성 덕분에 Kotlin 코드에서 자연스럽게 사용할 수 있습니다. 지금까지 유일한 질문은 이러한 클래스에서 새 인스턴스를 작성하는 방법입니다. &lt;code&gt;MyStruct&lt;/code&gt; 와 &lt;code&gt;MyUnion&lt;/code&gt; 의 선언에서 알 수 있듯이 생성자는 &lt;code&gt;NativePtr&lt;/code&gt; 이 필요합니다 . 물론, 우리는 포인터를 수동으로 다루려고하지 않습니다. 대신 Kotlin API를 사용하여 해당 객체를 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a7c2154690aa37b95c233923686a0683d02a9e" translate="yes" xml:space="preserve">
          <source>It is equivalent to this Java code:</source>
          <target state="translated">이 Java 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd011ac428fa7a3101febe89637cd71887a4e771" translate="yes" xml:space="preserve">
          <source>It is forbidden for inline classes to participate in a class hierarchy. This means that inline classes cannot extend other classes and must be &lt;em&gt;final&lt;/em&gt;.</source>
          <target state="translated">인라인 클래스가 클래스 계층에 참여하는 것은 금지되어 있습니다. 즉, 인라인 클래스는 다른 클래스를 확장 할 수 없으며 &lt;em&gt;최종&lt;/em&gt; 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="baf0c1eedc3c7d76ed7d17e6f83833365d1074e5" translate="yes" xml:space="preserve">
          <source>It is important to note that some of the &lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin/Native targets&lt;/a&gt; may only be built with an appropriate host machine:</source>
          <target state="translated">&lt;a href=&quot;#supported-platforms&quot;&gt;Kotlin / Native 대상&lt;/a&gt; 중 일부 는 적절한 호스트 시스템으로 만 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="417f8643742c5b4b13e710785eaf864b3ada4be9" translate="yes" xml:space="preserve">
          <source>It is important to understand that just like in the case of &lt;code&gt;callAnything()&lt;/code&gt;, the &lt;code&gt;dataTable()&lt;/code&gt; function must exist at runtime. In our case, we need to make sure that the corresponding script file for our plugin is included:</source>
          <target state="translated">그것은 단지의 경우 같은 것을 이해하는 것이 중요합니다 &lt;code&gt;callAnything()&lt;/code&gt; 의 &lt;code&gt;dataTable()&lt;/code&gt; 함수는 런타임에 존재해야합니다. 우리의 경우 플러그인에 해당하는 스크립트 파일이 포함되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e863e2f2b3f4c7cb9be7530e2969137eb812edc" translate="yes" xml:space="preserve">
          <source>It is not recommended to publish variants grouped by the product flavor in case they have different dependencies, as those will be merged into one dependencies list.</source>
          <target state="translated">종속 항목이 하나 일 경우 하나의 종속성 목록으로 병합되므로 변형이 다른 경우 제품 버전별로 그룹화 된 변형을 게시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41a0e8e8363c715bede252f00decd03608d5ae6b" translate="yes" xml:space="preserve">
          <source>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</source>
          <target state="translated">디렉토리 및 패키지와 일치 할 필요는 없습니다. 소스 파일은 파일 시스템에 임의로 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed10861129de21214d3c19646f1725bf54132b36" translate="yes" xml:space="preserve">
          <source>It is now possible to enumerate the values of an enum class in a generic way.</source>
          <target state="translated">이제 열거 형 클래스의 값을 일반적인 방식으로 열거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7a4a5a763a24f82bedd348e3c81f2b59dad3138" translate="yes" xml:space="preserve">
          <source>It is platform independent. Whether we targeting JVM, JavaScript or any other platform, the code we write is the same. Under the covers the compiler takes care of adapting it to each platform.</source>
          <target state="translated">플랫폼 독립적입니다. JVM, JavaScript 또는 기타 플랫폼을 대상으로 작성하든 작성하는 코드는 동일합니다. 커버 아래에서 컴파일러는 각 플랫폼에 맞게 컴파일러를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="4d947185f89d323fe7c7abf6d8cbb01ea4b530eb" translate="yes" xml:space="preserve">
          <source>It is possible for a class to implement a function type as if it were an interface. It must then supply an operator function called &lt;code&gt;invoke&lt;/code&gt; with the given signature, and instances of that class may then be assigned to a variable of that function type:</source>
          <target state="translated">클래스가 인터페이스 인 것처럼 함수 유형을 구현할 수 있습니다. 그런 다음 주어진 서명으로 &lt;code&gt;invoke&lt;/code&gt; 라는 연산자 함수를 제공해야하며 해당 클래스의 인스턴스를 해당 함수 유형의 변수에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05ec15ebc6d7af617a86a57248adcf19a55ca53f" translate="yes" xml:space="preserve">
          <source>It is possible to annotate type arguments of generic types to provide nullability information for them as well. For example, consider these annotations on a Java declaration:</source>
          <target state="translated">제네릭 형식의 형식 인수에 주석을 달아 nullable 정보도 제공 할 수 있습니다. 예를 들어, Java 선언에서 다음 주석을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a4db969f6c44a5e65473207ba72459c76a3f1c8a" translate="yes" xml:space="preserve">
          <source>It is possible to configure the language settings of all source sets at once:</source>
          <target state="translated">모든 소스 세트의 언어 설정을 한 번에 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee4c90445d9b9d795928bb3dfbba324ab54fe64" translate="yes" xml:space="preserve">
          <source>It is possible to create a scope-stable pointer of C representation of &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; instance using the &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; extension property, available under &lt;code&gt;memScoped { ... }&lt;/code&gt;. It allows using the APIs which require C pointers with a lifetime bound to a certain &lt;code&gt;MemScope&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;memScoped { ... }&lt;/code&gt; 에서 사용 가능한 &lt;code&gt;CValues&amp;lt;T&amp;gt;.ptr&lt;/code&gt; 확장 등록 정보를 사용하여 &lt;code&gt;CValues&amp;lt;T&amp;gt;&lt;/code&gt; 인스턴스 의 C 표현에 대한 범위 안정 포인터를 작성할 수 있습니다 . 수명이 특정 &lt;code&gt;MemScope&lt;/code&gt; 에 바인딩 된 C 포인터가 필요한 API를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1c523500d91947ee9765a964b978e521350e87f" translate="yes" xml:space="preserve">
          <source>It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt;&lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt;&lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt;. The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</source>
          <target state="translated">It is possible to customize the default behavior of printing &lt;strong&gt;uncaught&lt;/strong&gt; exceptions to the console. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; context element on a &lt;em&gt;root&lt;/em&gt; coroutine can be used as generic &lt;code&gt;catch&lt;/code&gt; block for this root coroutine and all its children where custom exception handling may take place. It is similar to &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)&quot;&gt; &lt;code&gt;Thread.uncaughtExceptionHandler&lt;/code&gt; &lt;/a&gt;. You cannot recover from the exception in the &lt;code&gt;CoroutineExceptionHandler&lt;/code&gt; . The coroutine had already completed with the corresponding exception when the handler is called. Normally, the handler is used to log the exception, show some kind of error message, terminate, and/or restart the application.</target>
        </trans-unit>
        <trans-unit id="e9091ebea40cd5ed5eeeecc5f5fcdcb74a99a77f" translate="yes" xml:space="preserve">
          <source>It is possible to declare contracts for your own functions, but this feature is &lt;strong&gt;experimental,&lt;/strong&gt; as the current syntax is in a state of early prototype and will most probably be changed. Also, please note, that currently the Kotlin compiler does not verify contracts, so it's a programmer's responsibility to write correct and sound contracts.</source>
          <target state="translated">자신의 함수에 대한 계약을 선언하는 것이 가능하지만 현재 구문이 초기 프로토 타입 상태이며 변경 될 가능성 이 있으므로이 기능은 &lt;strong&gt;실험적&lt;/strong&gt; 입니다. 또한 현재 Kotlin 컴파일러는 계약을 확인하지 않으므로 정확하고 건전한 계약을 작성하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="dc3778d4014e6f71dce4d7d20c0e012498a2087a" translate="yes" xml:space="preserve">
          <source>It is possible to filter headers by globs. The &lt;code&gt;headerFilter&lt;/code&gt; property value from the &lt;code&gt;.def&lt;/code&gt; file is treated as a space-separated list of globs. If the included header matches any of the globs, then the declarations from this header are included into the bindings.</source>
          <target state="translated">글롭으로 헤더를 필터링 할 수 있습니다. &lt;code&gt;.def&lt;/code&gt; 파일 의 &lt;code&gt;headerFilter&lt;/code&gt; 속성 값은 공백으로 구분 된 glob 목록으로 처리됩니다. 포함 된 헤더가 glob 중 하나와 일치하면이 헤더의 선언이 바인딩에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="402a77d3239dcd76fb899799d8112b0ad86dfc4e" translate="yes" xml:space="preserve">
          <source>It is possible to have more than one target for a single platform in a multiplatform library. For example, these targets may provide the same API and differ in the libraries they cooperate with at runtime, like testing frameworks or logging solutions.</source>
          <target state="translated">다중 플랫폼 라이브러리에서 단일 플랫폼에 대해 둘 이상의 대상을 가질 수 있습니다. 예를 들어, 이러한 대상은 동일한 API를 제공 할 수 있으며 테스트 프레임 워크 또는 로깅 솔루션과 같이 런타임시 협력하는 라이브러리가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e301a8ab019737ffb1879efcfc2dbdf711dcf6a" translate="yes" xml:space="preserve">
          <source>It is possible to specify which build types will be used to create binaries and which won't. In the following example only debug executable is created.</source>
          <target state="translated">바이너리를 생성하는 데 사용될 빌드 유형과 그렇지 않은 빌드 유형을 지정할 수 있습니다. 다음 예제에서는 디버그 실행 파일 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c4c1947233d08bc7cc11e65c450d05edf9570b44" translate="yes" xml:space="preserve">
          <source>It is quite a common situation to have a list of keys and want to build a map by associating each of these keys with some value. It was possible to do it before with the &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; function, but now we&amp;rsquo;re introducing a more efficient and easy to explore alternative: &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt;.</source>
          <target state="translated">키 목록을 갖고 이러한 키를 각각의 값과 연관시켜 맵을 작성하려는 경우는 매우 일반적인 상황입니다. &lt;code&gt;associate { it to getValue(it) }&lt;/code&gt; 함수 를 사용하여 이전에 수행 할 수 있었지만 이제는보다 효율적이고 탐색하기 쉬운 대안을 제공합니다. &lt;code&gt;keys.associateWith { getValue(it) }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb237bed1931cb077bff53fe7955788594878ed8" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; as a &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; - you are then restricted to only adding &lt;code&gt;Apple&lt;/code&gt; instances to it, but that's okay, because it is capable of receiving any &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Consumer&amp;lt;Fruit&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Consumer&amp;lt;Apple&amp;gt;&lt;/code&gt; 으로 취급하는 것이 안전합니다. 그러면 &lt;code&gt;Apple&lt;/code&gt; 인스턴스 만 추가 할 수 있지만 &lt;code&gt;Fruit&lt;/code&gt; 을받을 수 있기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="dc95825b1857af449f9e7a03e1be3bb43d0ddb3a" translate="yes" xml:space="preserve">
          <source>It is safe to treat a &lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; as if it were a &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; - the only thing it will ever produce is &lt;code&gt;Apple&lt;/code&gt; instances, but that's okay, because an &lt;code&gt;Apple&lt;/code&gt; is a &lt;code&gt;Fruit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Producer&amp;lt;Apple&amp;gt;&lt;/code&gt; 을 &lt;code&gt;Producer&amp;lt;Fruit&amp;gt;&lt;/code&gt; &amp;gt; 인 것처럼 취급하는 것이 안전합니다. &lt;code&gt;Apple&lt;/code&gt; 인스턴스 만 생산할 수있는 것은 Apple 인스턴스이지만 &lt;code&gt;Apple&lt;/code&gt; 은 &lt;code&gt;Fruit&lt;/code&gt; 이기 때문에 괜찮습니다 .</target>
        </trans-unit>
        <trans-unit id="1cb7a9be64c1b10976e2826c53f2565e3ab27c33" translate="yes" xml:space="preserve">
          <source>It is the same as the hashCode of &lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;entries&lt;/a&gt; set.</source>
          <target state="translated">&lt;a href=&quot;../-map/entries#kotlin.collections.Map%24entries&quot;&gt;항목&lt;/a&gt; 세트 의 hashCode와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="638b2a44297b2347a2a9b3d378c007753c4381ba" translate="yes" xml:space="preserve">
          <source>It is the time to try using C Functions from our Kotlin program. Let's call the &lt;code&gt;accept_fun&lt;/code&gt; function and pass the C function pointer to a Kotlin lambda:</source>
          <target state="translated">Kotlin 프로그램에서 C 함수를 사용해보십시오. &lt;code&gt;accept_fun&lt;/code&gt; 함수를 호출하고 C 함수 포인터를 Kotlin 람다에 전달합니다 :</target>
        </trans-unit>
        <trans-unit id="d8fa5339a1950bfcc4e526f49360c54a4a63bc2d" translate="yes" xml:space="preserve">
          <source>It is very convenient to declare a type parameter T as &lt;em&gt;out&lt;/em&gt; and avoid trouble with subtyping on the use site, but some classes &lt;strong&gt;can't&lt;/strong&gt; actually be restricted to only return &lt;code&gt;T&lt;/code&gt;'s! A good example of this is Array:</source>
          <target state="translated">으로 T 매개 변수 유형을 선언하는 것이 매우 편리 &lt;em&gt;밖으로&lt;/em&gt; 사용하는 사이트에 하위 유형와 회피 문제가 있지만, 일부 클래스는 &lt;strong&gt;할 수없는&lt;/strong&gt; 사실만을 반환에 제한 &lt;code&gt;T&lt;/code&gt; 의를! 이에 대한 좋은 예는 Array입니다.</target>
        </trans-unit>
        <trans-unit id="776fdced037b223c21ef26795ae5fc999fa0ee3e" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</source>
          <target state="translated">It launches 100K coroutines and, after 5 seconds, each coroutine prints a dot.</target>
        </trans-unit>
        <trans-unit id="b163cb494d8f7133d17c75969b6f58ad44cf2144" translate="yes" xml:space="preserve">
          <source>It launches 100K coroutines and, after a second, each coroutine prints a dot. Now, try that with threads. What would happen? (Most likely your code will produce some sort of out-of-memory error)</source>
          <target state="translated">100K 코 루틴을 시작하고 1 초 후에 각 코 루틴이 점을 인쇄합니다. 이제 스레드로 시도하십시오. 무슨 일이 일어날 지? (아마도 코드에서 일종의 메모리 부족 오류가 발생할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="efa9aff9b6f6c29df2d20508228006677fa18621" translate="yes" xml:space="preserve">
          <source>It leads to the following signature seen in Kotlin:</source>
          <target state="translated">코 틀린에서 볼 수있는 다음과 같은 서명으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="31157cfdb7da2c923cc250df2cdef99f52021252" translate="yes" xml:space="preserve">
          <source>It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</source>
          <target state="translated">It makes it easy to add and reorder elements &amp;ndash; there is no need to add or delete the comma if you manipulate elements.</target>
        </trans-unit>
        <trans-unit id="17169e22fd37b9c0c61060b6531c5a37b04dbe03" translate="yes" xml:space="preserve">
          <source>It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</source>
          <target state="translated">It makes version-control diffs cleaner &amp;ndash; as all the focus is on the changed value.</target>
        </trans-unit>
        <trans-unit id="50a8da20f5180842f95e2e885ec1433b6eb6b732" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java without wildcard.</source>
          <target state="translated">선언이 와일드 카드없이 Java에서 사용하기 불편한 경우에만 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ead6eaf5a09cdd5203f3d7332c148b0e2afab55" translate="yes" xml:space="preserve">
          <source>It may be helpful only if declaration seems to be inconvenient to use from Java.</source>
          <target state="translated">선언이 Java에서 사용하기 불편한 경우에만 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92fc36943474eb17749f18ce6facbefadc2bd75a" translate="yes" xml:space="preserve">
          <source>It may seem a logical next step to remove this obscurity by switching the defaults in IntelliJ IDEA and make formatting consistent with the Kotlin Coding Conventions. But this would mean that all the existing Kotlin projects will have a new code style enabled the moment the Kotlin plugin is installed. Not really the expected result for plugin update, right?</source>
          <target state="translated">IntelliJ IDEA에서 기본값을 전환하고 Kotlin Coding Conventions와 일치하도록 형식을 지정하여 이러한 모호성을 제거하는 것이 논리적으로 다음 단계로 보일 수 있습니다. 그러나 이것은 기존의 모든 Kotlin 프로젝트가 Kotlin 플러그인이 설치되는 순간 새로운 코드 스타일을 사용할 수 있음을 의미합니다. 플러그인 업데이트에 대한 예상 결과가 맞지 않습니까?</target>
        </trans-unit>
        <trans-unit id="5a4d0a01a307589d4ada06d8aac41c245c2a1232" translate="yes" xml:space="preserve">
          <source>It means that, by the time of the base class constructor execution, the properties declared or overridden in the derived class are not yet initialized. If any of those properties are used in the base class initialization logic (either directly or indirectly, through another overridden &lt;em&gt;open&lt;/em&gt; member implementation), it may lead to incorrect behavior or a runtime failure. When designing a base class, you should therefore avoid using &lt;em&gt;open&lt;/em&gt; members in the constructors, property initializers, and &lt;em&gt;init&lt;/em&gt; blocks.</source>
          <target state="translated">이는 기본 클래스 생성자가 실행될 때 파생 클래스에서 선언되거나 재정의 된 속성이 아직 초기화되지 않았 음을 의미합니다. 이러한 속성 중 하나라도 기본 클래스 초기화 로직에서 사용되는 경우 (직접적으로 또는 다른 재정의 된 &lt;em&gt;오픈&lt;/em&gt; 멤버 구현을 통해 간접적으로 ) 잘못된 동작 또는 런타임 오류가 발생할 수 있습니다. 따라서 기본 클래스를 디자인 할 때는 생성자, 속성 이니셜 라이저 및 &lt;em&gt;init&lt;/em&gt; 블록 에서 &lt;em&gt;열린&lt;/em&gt; 멤버를 사용하지 않아야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="797f38dacaae5d59a26c62d2dd822a0488289854" translate="yes" xml:space="preserve">
          <source>It might be temping to use JVM's &lt;code&gt;java.util.Scanner&lt;/code&gt; class to parse less structured input formats. Kotlin is designed to interoperate well with JVM libraries, so that their use feels quite natural in Kotlin. However, beware that &lt;code&gt;java.util.Scanner&lt;/code&gt; is extremely slow. So slow, in fact, that parsing 10&lt;sup&gt;5&lt;/sup&gt; or more integers with it might not fit into a typical 2 second time-limit, which a simple Kotlin's &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; would handle.</source>
          <target state="translated">덜 구조화 된 입력 형식을 구문 분석 하기 위해 JVM의 &lt;code&gt;java.util.Scanner&lt;/code&gt; 클래스 를 사용하는 것이 좋습니다 . Kotlin은 JVM 라이브러리와 잘 호환되도록 설계되어 Kotlin에서 사용이 매우 자연 스럽습니다. 그러나 &lt;code&gt;java.util.Scanner&lt;/code&gt; 가 매우 느리다는 점에 유의하십시오 . 실제로 10 &lt;sup&gt;5&lt;/sup&gt; 개 이상의 정수 를 구문 분석 하는 것은 일반적인 2 초 시간 제한에 맞지 않을 수 있습니다. 이는 간단한 Kotlin의 &lt;code&gt;split(&quot; &quot;).map { it.toInt() }&lt;/code&gt; 이 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4dcefeb4f7398e3e9107786806cb210122661b33" translate="yes" xml:space="preserve">
          <source>It prints &quot;sending&quot; &lt;em&gt;five&lt;/em&gt; times using a buffered channel with capacity of &lt;em&gt;four&lt;/em&gt;:</source>
          <target state="translated">용량이 &lt;em&gt;4 인&lt;/em&gt; 버퍼링 된 채널을 사용하여 &quot;보내기&quot;를 &lt;em&gt;다섯&lt;/em&gt; 번 인쇄합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22cac1fe7a5de098526c35e5a30637b070cd91b6" translate="yes" xml:space="preserve">
          <source>It prints following lines:</source>
          <target state="translated">다음 줄을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c7f4b533e837bd7e46a9ce1a0a22fbfcd4d17d31" translate="yes" xml:space="preserve">
          <source>It produces something like that when running in &lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;debug mode&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#debugging-coroutines-and-threads&quot;&gt;디버그 모드&lt;/a&gt; 에서 실행할 때와 같은 것을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="438255e8d8df7e6af7b2286b9eb0a1ff8f4ea247" translate="yes" xml:space="preserve">
          <source>It produces something like this:</source>
          <target state="translated">다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fb781104064af1d8629d3a388a507c72839c91db" translate="yes" xml:space="preserve">
          <source>It produces the following output (maybe in different order):</source>
          <target state="translated">다음과 같은 출력을 생성합니다 (다른 순서로 표시 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="c9f7c3047939db3a0d1c9e3a0026fbe61df824db" translate="yes" xml:space="preserve">
          <source>It produces the following output:</source>
          <target state="translated">다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="17589c30d4bd3d4e252acd3e2fde1d3c719a5224" translate="yes" xml:space="preserve">
          <source>It returns a composition of two functions passed to it: &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt;. Now, you can apply it to callable references:</source>
          <target state="translated">전달 된 두 함수의 구성을 리턴합니다. &lt;code&gt;compose(f, g) = f(g(*))&lt;/code&gt; . 이제 호출 가능한 참조에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5dfacacd6fed6df8733c434a43165786f1b136" translate="yes" xml:space="preserve">
          <source>It simplifies code generation, for example, for object initializers. The last element can also have a comma.</source>
          <target state="translated">It simplifies code generation, for example, for object initializers. The last element can also have a comma.</target>
        </trans-unit>
        <trans-unit id="adaa459203490bc09b0dd6700bcf5aacd3687f3b" translate="yes" xml:space="preserve">
          <source>It takes two &lt;code&gt;Int&lt;/code&gt; parameters and returns a &lt;code&gt;Double&lt;/code&gt;, so its type is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. We can reference the function itself by prefixing its name with &lt;code&gt;::&lt;/code&gt;, and we can assign it to a variable (whose type would normally be inferred, but we show the type signature for demonstration):</source>
          <target state="translated">두 개의 &lt;code&gt;Int&lt;/code&gt; 매개 변수를 사용하고 &lt;code&gt;Double&lt;/code&gt; 을 반환 하므로 유형은 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 입니다. 이름 앞에 &lt;code&gt;::&lt;/code&gt; 접두사를 붙여 함수 자체를 참조 할 수 있고 변수에 할당 할 수 있습니다 (유형은 일반적으로 유추되지만 데모를 위해 형식 서명을 표시합니다).</target>
        </trans-unit>
        <trans-unit id="c85187abd273afe2d39456db809770ff8d17b7cc" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific shared object (.so on Linux, .dylib on macOS, and .dll on Windows targets) and a C language header, allowing the use of all public APIs available in your Kotlin/Native program from C/C++ code. See &lt;code&gt;samples/python_extension&lt;/code&gt; for an example of using such a shared object to provide a bridge between Python and Kotlin/Native.</source>
          <target state="translated">플랫폼 별 공유 객체 (Linux에서는 .so, macOS에서는 .dylib, Windows에서는 .dll)와 C 언어 헤더를 생성하여 C /에서 Kotlin / Native 프로그램에서 사용할 수있는 모든 공용 API를 사용할 수 있습니다. C ++ 코드. 이러한 공유 객체를 사용하여 Python과 Kotlin / Native 간의 브리지를 제공하는 예제는 &lt;code&gt;samples/python_extension&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b575c19d946e336100c7ed068ca562177833082" translate="yes" xml:space="preserve">
          <source>It will produce a platform-specific static object (.a library format) and a C language header, allowing you to use all the public APIs available in your Kotlin/Native program from C/C++ code.</source>
          <target state="translated">플랫폼 별 정적 객체 (. 라이브러리 형식)와 C 언어 헤더를 생성하여 C / C ++ 코드에서 Kotlin / Native 프로그램에서 사용 가능한 모든 공용 API를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77b95136e56addaaf94d730513b3a8bef6e57a3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s almost done, user feedback is especially important now.</source>
          <target state="translated">It&amp;rsquo;s almost done, user feedback is especially important now.</target>
        </trans-unit>
        <trans-unit id="039acb422f298b9e2dda428662093ea454940860" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</source>
          <target state="translated">It&amp;rsquo;s done. We will be evolving it according to our strict &lt;a href=&quot;https://kotlinlang.org/foundation/language-committee-guidelines.html&quot;&gt;backward compatibility rules&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b3d38eb85ce2f60386c4898b42f31b426d1bea2f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</source>
          <target state="translated">It&amp;rsquo;s easy to get started with Kotlin using the Kotlin plugin integrated in &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt;. Benefit from code highlighting, code completion, refactoring, debugging, and other features available for Kotlin.</target>
        </trans-unit>
        <trans-unit id="7d20f5ce9372886e3a18510e89bf62db3fa25cfc" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s extremely easy to start using Kotlin for Android development. In this tutorial we&amp;rsquo;ll follow the warming up process with Android Studio. If you're using Intellij IDEA with Android, the process is almost the same.</source>
          <target state="translated">안드로이드 개발을 위해 Kotlin을 사용하는 것은 매우 쉽습니다. 이 튜토리얼에서는 Android Studio의 워밍업 프로세스를 따릅니다. Android에서 Intellij IDEA를 사용하는 경우 프로세스는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0d25598a290d255bee23e0efee2aa27e246b4f17" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Array%28%28kotlin.collections.copyInto.T%29%29%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 에서 동일한 배열을 전달 하고 대상 범위와 겹치도록 하위 범위를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc637fca146e7aa9091977f4ab6a14a8ec874b0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">&lt;a href=&quot;copy-into#kotlin.collections%24copyInto%28kotlin.UIntArray%2C+kotlin.UIntArray%2C+kotlin.Int%2C+kotlin.Int%2C+kotlin.Int%29%2Fdestination&quot;&gt;대상&lt;/a&gt; 에서 동일한 배열을 전달 하고 대상 범위와 겹치도록 하위 범위를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c547761ff928eabb85ae6f68b2a8d06acf2434c8" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Array((kotlin.collections.copyInto.T)),%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</target>
        </trans-unit>
        <trans-unit id="0234d9c081afa271a5761a94d33278199b8154d0" translate="yes" xml:space="preserve">
          <source>It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</source>
          <target state="translated">It's allowed to pass the same array in the &lt;a href=&quot;copy-into#kotlin.collections%24copyInto(kotlin.UIntArray,%20kotlin.UIntArray,%20kotlin.Int,%20kotlin.Int,%20kotlin.Int)/destination&quot;&gt;destination&lt;/a&gt; and even specify the subrange so that it overlaps with the destination range.</target>
        </trans-unit>
        <trans-unit id="031250b72b284d8b276f90bf0d49fd6078c2857d" translate="yes" xml:space="preserve">
          <source>It's always possible to explicitly set the IntelliJ IDEA code style as the correct code style for the project. To do so please switch to the &lt;em&gt;Project&lt;/em&gt; scheme in &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; and select &lt;em&gt;&quot;Kotlin obsolete IntelliJ IDEA codestyle&quot;&lt;/em&gt; in the &lt;em&gt;&quot;Use defaults from:&quot;&lt;/em&gt; on the &lt;em&gt;Load&lt;/em&gt; tab.</source>
          <target state="translated">IntelliJ IDEA 코드 스타일을 프로젝트의 올바른 코드 스타일로 명시 적으로 설정할 수 있습니다. 받는 사람 그렇게하십시오 스위치를 수행 &lt;em&gt;프로젝트&lt;/em&gt; 의 계획 &lt;code&gt;Settings &amp;rarr; Editor &amp;rarr; Code Style &amp;rarr; Kotlin&lt;/code&gt; 선택 &lt;em&gt;&quot;코 틀린 쓸모하게 IntelliJ IDEA의 codestyle을&quot;&lt;/em&gt; 에 &lt;em&gt;&quot;에서 기본값 사용 :&quot;&lt;/em&gt; 온 &lt;em&gt;로드&lt;/em&gt; 탭을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6e80a1e74b8c8e47694ccc45eb2685d70fcb822d" translate="yes" xml:space="preserve">
          <source>It's currently not possible to pass &lt;em&gt;null&lt;/em&gt; to a method that is declared as varargs.</source>
          <target state="translated">현재 varargs로 선언 된 메서드에는 &lt;em&gt;null&lt;/em&gt; 을 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="114b9bcaf449cf9b870e05fba48add6ecc248f08" translate="yes" xml:space="preserve">
          <source>It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</source>
          <target state="translated">It's easy to forget to set the corresponding context element. The thread-local variable accessed from the coroutine may then have an unexpected value, if the thread running the coroutine is different. To avoid such situations, it is recommended to use the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/java.lang.-thread-local/ensure-present.html&quot;&gt;ensurePresent&lt;/a&gt; method and fail-fast on improper usages.</target>
        </trans-unit>
        <trans-unit id="acfee84980c04ef0fe85e54f28d399f66e64abaa" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, and we have no problems with &lt;code&gt;a()&lt;/code&gt; and &lt;code&gt;b()&lt;/code&gt; since &lt;code&gt;C&lt;/code&gt; inherits only one implementation of each of these functions. But for &lt;code&gt;f()&lt;/code&gt; we have two implementations inherited by &lt;code&gt;C&lt;/code&gt;, and thus we have to override &lt;code&gt;f()&lt;/code&gt; in &lt;code&gt;C&lt;/code&gt; and provide our own implementation that eliminates the ambiguity.</source>
          <target state="translated">그것의 모두 상속 미세 와 &lt;code&gt;B&lt;/code&gt; , 그리고 우리는 아무런 문제가 없다 &lt;code&gt;a()&lt;/code&gt; 와 &lt;code&gt;b()&lt;/code&gt; 이후 &lt;code&gt;C&lt;/code&gt; 의 상속이 각각의 기능의 하나의 구현. 그러나 대한 &lt;code&gt;f()&lt;/code&gt; 우리는 상속이 구현이 &lt;code&gt;C&lt;/code&gt; 를 , 따라서 우리는 오버라이드 (override) 할 필요가 &lt;code&gt;f()&lt;/code&gt; 에 &lt;code&gt;C&lt;/code&gt; 와 우리 자신의 구현을 제거해 그 모호성을 제공합니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04f1d0f6695973692315398bd64dee5cfdd7323c" translate="yes" xml:space="preserve">
          <source>It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt;, but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt;, so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</source>
          <target state="translated">It's fine to inherit from both &lt;code&gt;Rectangle&lt;/code&gt; and &lt;code&gt;Polygon&lt;/code&gt; , but both of them have their implementations of &lt;code&gt;draw()&lt;/code&gt; , so we have to override &lt;code&gt;draw()&lt;/code&gt; in &lt;code&gt;Square&lt;/code&gt; and provide its own implementation that eliminates the ambiguity.</target>
        </trans-unit>
        <trans-unit id="442e1f9409803560cb8db1e8e932691b852b50ed" translate="yes" xml:space="preserve">
          <source>It's important to close a stream when you're done with it; otherwise, your program will leak a file handle. See the next section for how do do this nicely.</source>
          <target state="translated">작업이 끝나면 스트림을 닫는 것이 중요합니다. 그렇지 않으면 프로그램이 파일 핸들을 누출시킵니다. 이 작업을 잘 수행하는 방법은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9346c60b395e4bb0937fa0abc8c38e87d658e069" translate="yes" xml:space="preserve">
          <source>It's important to make sure that the &lt;em&gt;Include Kotlin support&lt;/em&gt; checkbox is ticked. For now we can leave the default settings in the next step of the wizard. We then proceed to select the &lt;em&gt;Empty Activity&lt;/em&gt; option and click &lt;em&gt;Next&lt;/em&gt;, finally pressing &lt;em&gt;Finish&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Kotlin 지원 포함&lt;/em&gt; 확인란이 선택되어 있는지 확인해야합니다 . 지금은 마법사의 다음 단계에서 기본 설정을 그대로 둘 수 있습니다. 그런 다음 &lt;em&gt;Empty Activity&lt;/em&gt; 옵션 을 선택하고 &lt;em&gt;Next를&lt;/em&gt; 클릭 하고 마지막으로 &lt;em&gt;Finish를&lt;/em&gt; 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="3f80b2897a86bf69ce94fa9c91efda88ddaabb97" translate="yes" xml:space="preserve">
          <source>It's important to understand that this is now a native application, and no runtime or virtual machine is required. We can now run the compiled binary from the console:</source>
          <target state="translated">이것이 이제는 기본 애플리케이션이며 런타임 또는 가상 머신이 필요하지 않음을 이해해야합니다. 이제 콘솔에서 컴파일 된 바이너리를 실행할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="841256700fec240b48d1a1475f562513e2734121" translate="yes" xml:space="preserve">
          <source>It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</source>
          <target state="translated">It's not recommended that you apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL &amp;ndash; &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;see why&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="451aaccdf6c2eb6d6c44303ffdea63bce2a3d7a2" translate="yes" xml:space="preserve">
          <source>It's not recommended to apply Kotlin plugins with &lt;code&gt;apply&lt;/code&gt; in Gradle Kotlin DSL. The details are provided &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">과 코 틀린 플러그인을 적용하지 않는 것이 좋습니다 &lt;code&gt;apply&lt;/code&gt; Gradle을 코 틀린 DSL에. 자세한 내용은 &lt;a href=&quot;#using-gradle-kotlin-dsl&quot;&gt;아래&lt;/a&gt; 에 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="903ee30ab34cc6304b069dd5e5dba6a6e65093d1" translate="yes" xml:space="preserve">
          <source>It's often the case that we need to copy an object altering &lt;em&gt;some&lt;/em&gt; of its properties, but keeping the rest unchanged. This is what &lt;code&gt;copy()&lt;/code&gt; function is generated for. For the &lt;code&gt;User&lt;/code&gt; class above, its implementation would be as follows:</source>
          <target state="translated">&lt;em&gt;일부&lt;/em&gt; 속성을 변경 하지만 나머지는 변경하지 않고 객체를 복사해야하는 경우가 종종 있습니다. 이것이 &lt;code&gt;copy()&lt;/code&gt; 함수가 생성되는 것입니다. 위 의 &lt;code&gt;User&lt;/code&gt; 클래스의 경우 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5bc060842af3a7b6e0d01c24d0becf2bb7a201f" translate="yes" xml:space="preserve">
          <source>It's possible to declare a cinterop dependency for a component:</source>
          <target state="translated">구성 요소에 대한 cinterop 종속성을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2884706f64f3c6fe7682c1d6d6493a0cd7c7c71d" translate="yes" xml:space="preserve">
          <source>It's possible to depend on a Kotlin/Native library published earlier in a maven repo. The plugin relies on Gradle's &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;metadata&lt;/a&gt; support so the corresponding feature must be enabled. Add the following line in your &lt;code&gt;settings.gradle&lt;/code&gt;:</source>
          <target state="translated">이전에 maven 저장소에 게시 된 Kotlin / Native 라이브러리에 의존 할 수 있습니다. 플러그인은 Gradle의 &lt;a href=&quot;https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-specification.md&quot;&gt;메타 데이터&lt;/a&gt; 지원 에 의존 하므로 해당 기능을 활성화해야합니다. &lt;code&gt;settings.gradle&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c597ff748c96d1169a0e3b1f389a9e5bf8a14509" translate="yes" xml:space="preserve">
          <source>It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</source>
          <target state="translated">It's recommended that you use Android Studio for creating Android applications. &lt;a href=&quot;https://developer.android.com/studio/releases/gradle-plugin&quot;&gt;Learn how to use Android Gradle plugin&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="268bb3f4ba30e1a5b60f8f81ac29d4c03ccdf710" translate="yes" xml:space="preserve">
          <source>It's recommended to propagate the experimental status to the API that depends on unsigned types by annotating it with this annotation.</source>
          <target state="translated">이 주석으로 주석을 달아서 서명되지 않은 유형에 의존하는 API에 실험 상태를 전파하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d7daa3cad985a04d515f5a0b14e8155b1a6fab3e" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are an experimental feature, so API which uses them can be suddenly broken due to changes in language.</source>
          <target state="translated">클라이언트가 API 사용을 명시 적으로 선택해야하는지 여부를 결정해야하지만 서명되지 않은 유형은 실험적인 기능이므로 언어 ​​변경으로 인해이를 사용하는 API가 갑자기 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da8e68f5b23a3014c6d8de49b6e15eb047b18c62" translate="yes" xml:space="preserve">
          <source>It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</source>
          <target state="translated">It's up to you to decide if your clients have to explicitly opt-in into usage of your API, but bear in mind that unsigned types are not a stable feature, so API which uses them can be broken by changes in the language.</target>
        </trans-unit>
        <trans-unit id="9fa67b0c21d7b8170095650619f367328af7593f" translate="yes" xml:space="preserve">
          <source>It's useful to shorten long generic types. For instance, it's often tempting to shrink collection types:</source>
          <target state="translated">긴 제네릭 형식을 줄이는 것이 좋습니다. 예를 들어 컬렉션 유형을 축소하려는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50dbfd39b435235eb76a4c86249fda694136067" translate="yes" xml:space="preserve">
          <source>It's very common that a lambda expression has only one parameter.</source>
          <target state="translated">람다 식에 매개 변수가 하나만있는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="497cb9444d2d1993508a971a9e38bf60f29788e9" translate="yes" xml:space="preserve">
          <source>ItemArrayLike</source>
          <target state="translated">ItemArrayLike</target>
        </trans-unit>
        <trans-unit id="08ca6a3da933ca6826a2f4d3fcc919af71d7e380" translate="yes" xml:space="preserve">
          <source>Iterable</source>
          <target state="translated">Iterable</target>
        </trans-unit>
        <trans-unit id="dc8802d44941c46da0da729594bb50e6d441ce2d" translate="yes" xml:space="preserve">
          <source>Iterable.groupingBy</source>
          <target state="translated">Iterable.groupingBy</target>
        </trans-unit>
        <trans-unit id="380a211ab0a9e218f328f8421df21a0f64a31d3e" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">이 리더의 각 라인을 반복하고, 각 라인 읽기에 대한 &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine%28java.io.Reader%2C+kotlin.Function1%28%28kotlin.String%2C+kotlin.Unit%29%29%29%2Faction&quot;&gt;조치&lt;/a&gt; 를 호출 하고 완료되면 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;리더를&lt;/a&gt; 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="a23c7a347a61820ec903389403c010444ab83c86" translate="yes" xml:space="preserve">
          <source>Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</source>
          <target state="translated">Iterates through each line of this reader, calls &lt;a href=&quot;for-each-line#kotlin.io%24forEachLine(java.io.Reader,%20kotlin.Function1((kotlin.String,%20kotlin.Unit)))/action&quot;&gt;action&lt;/a&gt; for each line read and closes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/io/Reader.html&quot;&gt;Reader&lt;/a&gt; when it's completed.</target>
        </trans-unit>
        <trans-unit id="df79ba3f92580a38aac3b295d97ec6467bf9c601" translate="yes" xml:space="preserve">
          <source>Iterating over a collection:</source>
          <target state="translated">컬렉션을 반복 :</target>
        </trans-unit>
        <trans-unit id="cd542426f011094d421bd238597459f01a78a773" translate="yes" xml:space="preserve">
          <source>Iterating over a range:</source>
          <target state="translated">범위에서 반복 :</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="003d5d89ff75536e7c8fe75998f6c431dc6a6bfb" translate="yes" xml:space="preserve">
          <source>Iterator for characters of the given char sequence.</source>
          <target state="translated">주어진 문자 순서의 문자에 대한 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="506c9ecd5cb52c951984866e4ca884bba6f6ea5f" translate="yes" xml:space="preserve">
          <source>Iterators can be obtained for inheritors of the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt;&lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; interface, including &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;List&lt;/code&gt;, by calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt;&lt;code&gt;iterator()&lt;/code&gt;&lt;/a&gt; function. Once you obtain an iterator, it points to the first element of a collection; calling the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt; function returns this element and moves the iterator position to the following element if it exists. Once the iterator passes through the last element, it can no longer be used for retrieving elements; neither can it be reset to any previous position. To iterate through the collection again, create a new iterator.</source>
          <target state="translated">Iterator &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/iterator&quot;&gt; &lt;code&gt;iterator()&lt;/code&gt; &lt;/a&gt; 함수를 호출 하여 &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;List&lt;/code&gt; 를 포함한 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterable/index&quot;&gt; &lt;code&gt;Iterable&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt; 인터페이스 의 상속자에 대해 반복자를 얻을 수 있습니다 . 반복자를 얻으면 컬렉션의 첫 번째 요소를 가리 킵니다. &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-iterator/next&quot;&gt; &lt;code&gt;next()&lt;/code&gt; &lt;/a&gt; 함수를 호출하면 이 요소가 반환되고 이터레이터 위치가 있으면 다음 요소로 이동합니다. 반복자가 마지막 요소를 통과하면 더 이상 요소를 검색하는 데 사용할 수 없습니다. 이전 위치로 재설정 할 수도 없습니다. 콜렉션을 다시 반복하려면 새 반복자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="bc0b40497b63bea004394bd2f67e443f08b6588f" translate="yes" xml:space="preserve">
          <source>JAR file for the Android project, from the &lt;code&gt;androidMain&lt;/code&gt; source set</source>
          <target state="translated">&lt;code&gt;androidMain&lt;/code&gt; 소스 세트 의 Android 프로젝트에 대한 JAR 파일</target>
        </trans-unit>
        <trans-unit id="1c094e3ab7a1c494d642222b6728398ff3000b42" translate="yes" xml:space="preserve">
          <source>JPA support</source>
          <target state="translated">JPA 지원</target>
        </trans-unit>
        <trans-unit id="95f92b2f0cb530542d16d90a6c2af59e20759430" translate="yes" xml:space="preserve">
          <source>JS</source>
          <target state="translated">JS</target>
        </trans-unit>
        <trans-unit id="2ef44ba04cb41365765eba178e5fb528ee006a1b" translate="yes" xml:space="preserve">
          <source>JS:</source>
          <target state="translated">JS:</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="8262ef9c2c68924dbec9b88761bde41ad5ef98f3" translate="yes" xml:space="preserve">
          <source>JSR-305 (&lt;code&gt;javax.annotation&lt;/code&gt;, more details below)</source>
          <target state="translated">JSR-305 ( &lt;code&gt;javax.annotation&lt;/code&gt; , 자세한 내용은 아래 참조)</target>
        </trans-unit>
        <trans-unit id="5188151af5277b4d83b75fa70a7e55c37a18f211" translate="yes" xml:space="preserve">
          <source>JSR-305 Support</source>
          <target state="translated">JSR-305 지원</target>
        </trans-unit>
        <trans-unit id="bb63c86538bf1c2ee7cd6190cf88dd1f44d85eff" translate="yes" xml:space="preserve">
          <source>JVM</source>
          <target state="translated">JVM</target>
        </trans-unit>
        <trans-unit id="04a7d3f3683303c17ad132f382f6d0c911d30883" translate="yes" xml:space="preserve">
          <source>JVM 6</source>
          <target state="translated">JVM 6</target>
        </trans-unit>
        <trans-unit id="3430f69443094c1010f905be31e657db1bc9cecc" translate="yes" xml:space="preserve">
          <source>JVM Backend</source>
          <target state="translated">JVM 백엔드</target>
        </trans-unit>
        <trans-unit id="8a60d58cc6c328ec0b68627b45e8de68d5004fb4" translate="yes" xml:space="preserve">
          <source>JVM backend</source>
          <target state="translated">JVM 백엔드</target>
        </trans-unit>
        <trans-unit id="e314b08890e867b0e66c9aacb3731e2c760fd4e5" translate="yes" xml:space="preserve">
          <source>JVM dependency</source>
          <target state="translated">JVM dependency</target>
        </trans-unit>
        <trans-unit id="1e479037f37f3056da4dd3f4b8476891324342ba" translate="yes" xml:space="preserve">
          <source>JVM:</source>
          <target state="translated">JVM:</target>
        </trans-unit>
        <trans-unit id="4aa2729d3292a207da300462e1c7fb9e07fee8d1" translate="yes" xml:space="preserve">
          <source>Jar file</source>
          <target state="translated">항아리 파일</target>
        </trans-unit>
        <trans-unit id="c32dbe67bb4cda6c969b9b214ff6e46a25b2a0f2" translate="yes" xml:space="preserve">
          <source>Java 7's try with resources</source>
          <target state="translated">Java 7의 리소스를 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="ac187b2b88eb97c8a6d1b499783f3187c6ec8c0b" translate="yes" xml:space="preserve">
          <source>Java 8 bytecode support</source>
          <target state="translated">Java 8 바이트 코드 지원</target>
        </trans-unit>
        <trans-unit id="072e6f9a3196506ae761b516738d856e34828cc7" translate="yes" xml:space="preserve">
          <source>Java 8 standard library support</source>
          <target state="translated">Java 8 표준 라이브러리 지원</target>
        </trans-unit>
        <trans-unit id="01579d0353cd60180076cc09ff0d55781e923e55" translate="yes" xml:space="preserve">
          <source>Java Annotations</source>
          <target state="translated">자바 주석</target>
        </trans-unit>
        <trans-unit id="d04e5ac8f8fe9912f7302d2d4689867b318a2094" translate="yes" xml:space="preserve">
          <source>Java Arrays</source>
          <target state="translated">자바 배열</target>
        </trans-unit>
        <trans-unit id="860970d26c3938762fa2e2c7b7194b61a0231169" translate="yes" xml:space="preserve">
          <source>Java EE Http servlets can be used from Kotlin much like any other Java library or framework. We'll see how to make a simple controller that returns &quot;Hello, World!&quot;.</source>
          <target state="translated">Java EE Http 서블릿은 다른 Java 라이브러리 또는 프레임 워크와 마찬가지로 Kotlin에서 사용할 수 있습니다. &quot;Hello, World!&quot;를 반환하는 간단한 컨트롤러를 만드는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="98c55e3f9693daef863846ba04beb7a87639d58b" translate="yes" xml:space="preserve">
          <source>Java Interoperability</source>
          <target state="translated">자바 상호 운용성</target>
        </trans-unit>
        <trans-unit id="ab55871eec7aba9e50581782c94506d7b076be92" translate="yes" xml:space="preserve">
          <source>Java Reflection</source>
          <target state="translated">자바 리플렉션</target>
        </trans-unit>
        <trans-unit id="8b7c04d9bb7da5a0513e73469be371a892a0ddec" translate="yes" xml:space="preserve">
          <source>Java Support in JVM Targets</source>
          <target state="translated">JVM 대상에서 Java 지원</target>
        </trans-unit>
        <trans-unit id="027f8a4631110b77b693f662b6d14564e95f3ad5" translate="yes" xml:space="preserve">
          <source>Java Varargs</source>
          <target state="translated">자바 Varargs</target>
        </trans-unit>
        <trans-unit id="746c982d879f15c37e1edb8014f7e0a7a57db534" translate="yes" xml:space="preserve">
          <source>Java annotations are 100% compatible with Kotlin:</source>
          <target state="translated">Java 주석은 Kotlin과 100 % 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="85a2157de6f31be86d225df11c21c07e4164424b" translate="yes" xml:space="preserve">
          <source>Java classes sometimes use a method declaration for the indices with a variable number of arguments (varargs):</source>
          <target state="translated">Java 클래스는 때때로 가변 개수의 인수 (varargs)와 함께 색인에 메소드 선언을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="695cb4693d8f07873088e0e2ca1954a3e6b1dec0" translate="yes" xml:space="preserve">
          <source>Java compiler options</source>
          <target state="translated">자바 컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="53d9a40a89e185b3910817fb0920db3433576443" translate="yes" xml:space="preserve">
          <source>Java generics in Kotlin</source>
          <target state="translated">코 틀린의 자바 제네릭</target>
        </trans-unit>
        <trans-unit id="8de44c9537e6dbc55b9f15952d2d0c0a403f924d" translate="yes" xml:space="preserve">
          <source>Java interoperation:</source>
          <target state="translated">자바 상호 운용 :</target>
        </trans-unit>
        <trans-unit id="e832e4cfea4d9817c729a744a89f9449a5f1d1ee" translate="yes" xml:space="preserve">
          <source>Java only got support for function types and lambda expressions a few years ago. Previously, Java worked around this by using an interface to define a function signature and allowing an inline, anonymous definition of a class that implements the interface. This is also available in Kotlin, partly for compatibility with Java libraries and partly because it can be handy for specifying event handlers (in particular if there is more than one event type that must be listened for by the same listener object). Consider an interface or a (possibly abstract) class, as well a function that takes an instance of it:</source>
          <target state="translated">Java는 몇 년 전에 함수 유형과 람다 식만 지원했습니다. 이전에 Java는 인터페이스를 사용하여 함수 서명을 정의하고 인터페이스를 구현하는 클래스의 인라인 익명 정의를 허용하여이 문제를 해결했습니다. Kotlin에서도 부분적으로 Java 라이브러리와의 호환성을 위해 사용할 수 있으며, 특히 동일한 리스너 객체가 수신해야하는 이벤트 유형이 둘 이상인 경우 이벤트 핸들러를 지정하는 데 유용 할 수 있기 때문에이 기능을 사용할 수 있습니다. 인터페이스 또는 (아마도 추상적 인) 클래스와 그 인스턴스를 취하는 함수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1915d97968b458264a2f2dbd19e10237488a0c18" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;.</source>
          <target state="translated">Java 리플렉션은 Kotlin 클래스에서 작동하며 그 반대도 마찬가지입니다. 위에서 언급 한 것처럼 &lt;code&gt;instance::class.java&lt;/code&gt; , &lt;code&gt;ClassName::class.java&lt;/code&gt; 또는 &lt;code&gt;instance.javaClass&lt;/code&gt; 를 사용하여 &lt;code&gt;java.lang.Class&lt;/code&gt; 를 통해 Java 리플렉션을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef56a24f4d8f2d665c8315a53a8f2125506c9068" translate="yes" xml:space="preserve">
          <source>Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt;, &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt;. You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</source>
          <target state="translated">Java reflection works on Kotlin classes and vice versa. As mentioned above, you can use &lt;code&gt;instance::class.java&lt;/code&gt; , &lt;code&gt;ClassName::class.java&lt;/code&gt; or &lt;code&gt;instance.javaClass&lt;/code&gt; to enter Java reflection through &lt;code&gt;java.lang.Class&lt;/code&gt; . You may also use &lt;code&gt;ClassName::class.javaObjectType&lt;/code&gt; for getting primitive types wrappers.</target>
        </trans-unit>
        <trans-unit id="604557100ea734a8e508b4cfcd3fd0b6ae0fffe3" translate="yes" xml:space="preserve">
          <source>Java types which have nullability annotations are represented not as platform types, but as actual nullable or non-null Kotlin types. The compiler supports several flavors of nullability annotations, including:</source>
          <target state="translated">널 입력 가능 어노테이션이있는 Java 유형은 플랫폼 유형이 아니라 실제 널 입력 가능 또는 널이 아닌 Kotlin 유형으로 표시됩니다. 컴파일러는 다음을 포함하여 여러 가지 널 입력 가능 주석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dc024086aaa20e53d67ca09758f8c4d13c64cb3c" translate="yes" xml:space="preserve">
          <source>Java's arrays are mapped as mentioned &lt;a href=&quot;java-interop#java-arrays&quot;&gt;below&lt;/a&gt;:</source>
          <target state="translated">Java의 배열은 &lt;a href=&quot;java-interop#java-arrays&quot;&gt;다음&lt;/a&gt; 과 같이 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="a52c0cfe5cac6860cf184e57dfda94c4e4aab7eb" translate="yes" xml:space="preserve">
          <source>Java's boxed primitive types are mapped to nullable Kotlin types:</source>
          <target state="translated">자바의 박스형 프리미티브 유형은 nullable Kotlin 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a93aa77d99dfed9f4e64393e47b4458e7232bba4" translate="yes" xml:space="preserve">
          <source>Java's raw types are converted into star projections,</source>
          <target state="translated">Java의 원시 유형은 별 투영법으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b08bd53dd6ccc40659e0ead9c100bf1e91b5ac6" translate="yes" xml:space="preserve">
          <source>Java's wildcards are converted into type projections,</source>
          <target state="translated">Java의 와일드 카드는 유형 투영으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b7e0008cfda3632a9ce80870d8378b5ff1ce2de5" translate="yes" xml:space="preserve">
          <source>Java-default method calls</source>
          <target state="translated">자바 기본 메소드 호출</target>
        </trans-unit>
        <trans-unit id="28658a9e65ac1fce8b895da9099268ad9257b5a4" translate="yes" xml:space="preserve">
          <source>Java-style reflection</source>
          <target state="translated">자바 스타일 반영</target>
        </trans-unit>
        <trans-unit id="d3d2902f267714c4d2888df7a9cb53494548b955" translate="yes" xml:space="preserve">
          <source>Java2Kotlin converter</source>
          <target state="translated">Java2Kotlin 변환기</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="cb598ee02a2a4ba66a8b8c49bee0bba3cd995db7" translate="yes" xml:space="preserve">
          <source>JavaScript Backend</source>
          <target state="translated">자바 스크립트 백엔드</target>
        </trans-unit>
        <trans-unit id="7ceba75ee976f8baf2462d625f66425dd948bcef" translate="yes" xml:space="preserve">
          <source>JavaScript DCE</source>
          <target state="translated">자바 스크립트 DCE</target>
        </trans-unit>
        <trans-unit id="1731268deeec6a5538ea96e67d2bad77e86644c6" translate="yes" xml:space="preserve">
          <source>JavaScript Dead Code Elimination (DCE)</source>
          <target state="translated">JavaScript Dead Code Elimination (DCE)</target>
        </trans-unit>
        <trans-unit id="b3f888694954b41c7c2070331437408d8501d710" translate="yes" xml:space="preserve">
          <source>JavaScript Modules</source>
          <target state="translated">자바 스크립트 모듈</target>
        </trans-unit>
        <trans-unit id="8c784f817b830f35e8d38eb1b5afb3d6e6b36d02" translate="yes" xml:space="preserve">
          <source>JavaScript Reflection</source>
          <target state="translated">자바 스크립트 리플렉션</target>
        </trans-unit>
        <trans-unit id="6427edfd3be2acf2cb18120ef89fe67414e7fe92" translate="yes" xml:space="preserve">
          <source>JavaScript backend</source>
          <target state="translated">자바 스크립트 백엔드</target>
        </trans-unit>
        <trans-unit id="21bc6187f833ae0234195b5bb7f032fa9c9eddf3" translate="yes" xml:space="preserve">
          <source>JavaScript backend now generates more statically checkable code, which is friendlier to JS code processing tools, like minifiers, optimisers, linters, etc.</source>
          <target state="translated">JavaScript 백엔드는 이제 더 정적으로 확인할 수있는 코드를 생성하는데,이 코드는 축소 기, 최적화 기, 린터 등과 같은 JS 코드 처리 도구에 더 친숙합니다.</target>
        </trans-unit>
        <trans-unit id="18040e1d6c0077c2a62cb7d49ff581501d95859d" translate="yes" xml:space="preserve">
          <source>JavaScript does not have concept of packages (namespaces). They are usually emulated by nested objects. The compiler turns references to &lt;code&gt;external&lt;/code&gt; declarations either to plain unprefixed names (in case of &lt;em&gt;plain&lt;/em&gt; modules) or to plain imports. However, if a JavaScript library provides its declarations in packages, you won't be satisfied with this. You can tell the compiler to generate additional prefix before references to &lt;code&gt;external&lt;/code&gt; declarations using the &lt;code&gt;@JsQualifier(...)&lt;/code&gt; annotation.</source>
          <target state="translated">JavaScript에는 패키지 (네임 스페이스) 개념이 없습니다. 일반적으로 중첩 된 객체에 의해 에뮬레이트됩니다. 컴파일러는 &lt;code&gt;external&lt;/code&gt; 선언에 대한 참조를 일반 접두사없는 일반 이름 ( &lt;em&gt;일반&lt;/em&gt; 모듈의 경우 ) 또는 일반 가져 오기로 바꿉니다 . 그러나 JavaScript 라이브러리가 선언을 패키지로 제공하면 이에 만족하지 않습니다. &lt;code&gt;@JsQualifier(...)&lt;/code&gt; 주석을 사용하여 &lt;code&gt;external&lt;/code&gt; 선언에 대한 참조 전에 추가 접두사를 생성하도록 컴파일러에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95802660178652b3cea0422eb5403bb445448c4c" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; methods, you just pass objects that actually have these methods. You can use interfaces to express this for statically-typed Kotlin, for example:</source>
          <target state="translated">JavaScript에는 인터페이스 개념이 없습니다. 함수가 해당 매개 변수가 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 메서드 를 지원할 것으로 예상하면 실제로 이러한 메서드가있는 객체를 전달하면됩니다. 정적으로 형식화 된 Kotlin에 대해 인터페이스를 사용하여이를 표현할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db533d2ccc039c3271e49d0037285a95132804d3" translate="yes" xml:space="preserve">
          <source>JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt;, you would just pass in an object that actually has these methods.</source>
          <target state="translated">JavaScript does not have the concept of interfaces. When a function expects its parameter to support two methods &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; , you would just pass in an object that actually has these methods.</target>
        </trans-unit>
        <trans-unit id="fffb2c94a89ef37f4ff800dd4f2f3274e7b4c9bf" translate="yes" xml:space="preserve">
          <source>JetBrains develops and maintains several tools specifically for the React community: &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React bindings&lt;/a&gt; as well as &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;Create React Kotlin App&lt;/a&gt;. The latter helps you start building React apps with Kotlin with no build configuration.</source>
          <target state="translated">JetBrains는 React 커뮤니티를 위해 특별히 다음과 같은 몇 가지 도구를 개발하고 유지 관리합니다. &lt;a href=&quot;https://github.com/JetBrains/kotlin-wrappers&quot;&gt;React 바인딩&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/JetBrains/create-react-kotlin-app&quot;&gt;React Kotlin App 작성&lt;/a&gt; . 후자는 빌드 구성없이 Kotlin으로 React 앱을 빌드하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="0afbb0e9a99e99277b2f49549fedbc94a32802c2" translate="yes" xml:space="preserve">
          <source>Job in the context</source>
          <target state="translated">맥락에서의 직업</target>
        </trans-unit>
        <trans-unit id="06c75c90e1e9379a2cdd628513a60c328e9a2837" translate="yes" xml:space="preserve">
          <source>Join the Kotlin/JS community</source>
          <target state="translated">Join the Kotlin/JS community</target>
        </trans-unit>
        <trans-unit id="4f050b9ce8a72499f6d4325b437a4f8f851d64df" translate="yes" xml:space="preserve">
          <source>Join us to continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:</source>
          <target state="translated">관련 학습서에서 Kotlin / Native의 C 언어 유형 및 해당 표현을 계속 탐색하려면 우리와 함께하십시오.</target>
        </trans-unit>
        <trans-unit id="560f658735b552460323d7d08486e67939d8b69b" translate="yes" xml:space="preserve">
          <source>Joining a course</source>
          <target state="translated">코스 참여</target>
        </trans-unit>
        <trans-unit id="e14bf41ef01fdef5cf6b52dd5564ec2b2886f811" translate="yes" xml:space="preserve">
          <source>Joshua Bloch calls those objects you only &lt;strong&gt;read&lt;/strong&gt; from &lt;strong&gt;Producers&lt;/strong&gt;, and those you only &lt;strong&gt;write&lt;/strong&gt; to &lt;strong&gt;Consumers&lt;/strong&gt;. He recommends: &quot;&lt;em&gt;For maximum flexibility, use wildcard types on input parameters that represent producers or consumers&lt;/em&gt;&quot;, and proposes the following mnemonic:</source>
          <target state="translated">여호수아 블로흐 그 당신은 개체를 호출 &lt;strong&gt;읽기&lt;/strong&gt; 에서 &lt;strong&gt;생산자&lt;/strong&gt; 는 만하고 &lt;strong&gt;쓰기&lt;/strong&gt; 에 &lt;strong&gt;소비자&lt;/strong&gt; . &quot; &lt;em&gt;유연성을 극대화하려면 생산자 또는 소비자를 나타내는 입력 매개 변수에 와일드 카드 유형을 사용&lt;/em&gt; 하고 다음 니모닉을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="aaaf7cda9e752b334875dd3fb12220ae53318575" translate="yes" xml:space="preserve">
          <source>JsArray</source>
          <target state="translated">JsArray</target>
        </trans-unit>
        <trans-unit id="5cf2add42044a4a104180a92b4649ba344349b36" translate="yes" xml:space="preserve">
          <source>JsClass</source>
          <target state="translated">JsClass</target>
        </trans-unit>
        <trans-unit id="829d41f036e4b83f97d9207ff01e19270a103dc5" translate="yes" xml:space="preserve">
          <source>JsExport</source>
          <target state="translated">JsExport</target>
        </trans-unit>
        <trans-unit id="680d5016d394bd1910f8e79c1f48e1099ec8a45e" translate="yes" xml:space="preserve">
          <source>JsModule</source>
          <target state="translated">JsModule</target>
        </trans-unit>
        <trans-unit id="bb2ba9a64ec3ce618d8658d2bac2ab5b52799c41" translate="yes" xml:space="preserve">
          <source>JsName</source>
          <target state="translated">JsName</target>
        </trans-unit>
        <trans-unit id="285e217de7a6a19bb6ff3224730d97a2ffb8669c" translate="yes" xml:space="preserve">
          <source>JsNonModule</source>
          <target state="translated">JsNonModule</target>
        </trans-unit>
        <trans-unit id="4431c8a7c0e95318d4df4acc2fb68414f204013b" translate="yes" xml:space="preserve">
          <source>JsQualifier</source>
          <target state="translated">JsQualifier</target>
        </trans-unit>
        <trans-unit id="5e2ef85ac474ea70113e00f2d535adfcd131ef41" translate="yes" xml:space="preserve">
          <source>JsValue</source>
          <target state="translated">JsValue</target>
        </trans-unit>
        <trans-unit id="0e8b29f774aacb41aea9f3a3e3922bc27a5b2f86" translate="yes" xml:space="preserve">
          <source>Json</source>
          <target state="translated">Json</target>
        </trans-unit>
        <trans-unit id="ee67901393cc367dccd6b7380bc834e3173528f8" translate="yes" xml:space="preserve">
          <source>Jumping between threads</source>
          <target state="translated">스레드 간 점프</target>
        </trans-unit>
        <trans-unit id="35e8c2b0fe924d03188fa9d13f85d320bcb98681" translate="yes" xml:space="preserve">
          <source>Just add the plugin JAR file to the compiler plugin classpath and specify the list of sam-with-receiver annotations:</source>
          <target state="translated">플러그인 JAR 파일을 컴파일러 플러그인 클래스 경로에 추가하고 sam-with-receiver 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="23faffb10dc95518c4b08d2ccd86868a15d724ef" translate="yes" xml:space="preserve">
          <source>Just as in Java 8, Kotlin now allows to use underscores in numeric literals to separate groups of digits:</source>
          <target state="translated">Java 8에서와 마찬가지로 Kotlin은 이제 숫자 리터럴에서 밑줄을 사용하여 숫자 그룹을 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d8e794cae8b9d9de103c8c7346fbf29e3d8b66f" translate="yes" xml:space="preserve">
          <source>Just like Java 8, Kotlin supports SAM conversions. This means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Java 8과 마찬가지로 Kotlin은 SAM 변환을 지원합니다. 이는 인터페이스 메소드의 매개 변수 유형이 Kotlin 함수의 매개 변수 유형과 일치하는 경우 기본이 아닌 단일 메소드를 사용하여 Kotlin 함수 리터럴을 Java 인터페이스 구현으로 자동 변환 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="949a51b86664f4131dce0e0c1b95750468898210" translate="yes" xml:space="preserve">
          <source>Just like Java and JavaScript, Kotlin supports end-of-line and block comments.</source>
          <target state="translated">Java 및 JavaScript와 마찬가지로 Kotlin은 라인 끝 및 블록 주석을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="470dca02756a771de4224b1f3a4e099fc973e2f5" translate="yes" xml:space="preserve">
          <source>Just like Java's anonymous inner classes, code in object expressions can access variables from the enclosing scope. (Unlike Java, this is not restricted to final or effectively final variables.)</source>
          <target state="translated">Java의 익명 내부 클래스와 마찬가지로 객체 표현식의 코드는 둘러싸는 범위에서 변수에 액세스 할 수 있습니다. Java와 달리 이는 최종 변수 또는 사실상 최종 변수로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52bd785fc290723ed0a2f51dcda0df34f29bb395" translate="yes" xml:space="preserve">
          <source>Just like in Java, a special case is the &lt;code&gt;value&lt;/code&gt; parameter; its value can be specified without an explicit name:</source>
          <target state="translated">Java와 마찬가지로 특별한 경우는 &lt;code&gt;value&lt;/code&gt; 매개 변수입니다. 명시적인 이름없이 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e17eda787fc8a6435c74f86b6d7baef2f4cc5c" translate="yes" xml:space="preserve">
          <source>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list the defined enum constants and to get an enum constant by its name. The signatures of these methods are as follows (assuming the name of the enum class is &lt;code&gt;EnumClass&lt;/code&gt;):</source>
          <target state="translated">Java와 마찬가지로 Kotlin의 열거 형 클래스에는 정의 된 열거 형 상수를 나열하고 이름별로 열거 형 상수를 얻을 수있는 합성 메서드가 있습니다. 이러한 메소드의 서명은 다음과 같습니다 (enum 클래스의 이름이 &lt;code&gt;EnumClass&lt;/code&gt; 라고 가정 ).</target>
        </trans-unit>
        <trans-unit id="087fe94dcb6ae8bf0df1e1981129ddf1a93236a7" translate="yes" xml:space="preserve">
          <source>Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</source>
          <target state="translated">Just like most modern languages, Kotlin supports single-line (or &lt;em&gt;end-of-line&lt;/em&gt;) and multi-line (&lt;em&gt;block&lt;/em&gt;) comments.</target>
        </trans-unit>
        <trans-unit id="9137e7255bdeb308d1bb811a9d7f200fe163b672" translate="yes" xml:space="preserve">
          <source>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</source>
          <target state="translated">컴패니언 객체의 일반 멤버와 마찬가지로 클래스 이름 만 한정자로 사용하여 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0848ea7d6dc0355eb57cb3d83744477db1fa4d97" translate="yes" xml:space="preserve">
          <source>Just like with JavaDoc, KDoc comments start with &lt;code&gt;/**&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt;. Every line of the comment may begin with an asterisk, which is not considered part of the contents of the comment.</source>
          <target state="translated">JavaDoc과 마찬가지로 KDoc 주석은 &lt;code&gt;/**&lt;/code&gt; 로 시작 하고 &lt;code&gt;*/&lt;/code&gt; 로 끝납니다 . 주석의 모든 줄은 별표로 시작할 수 있으며, 주석 내용의 일부로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4d2de8b4148383d16c153caa1ed915e8e3e98f8" translate="yes" xml:space="preserve">
          <source>JvmDefault</source>
          <target state="translated">JvmDefault</target>
        </trans-unit>
        <trans-unit id="8d8475b40c0c838717c002d3eb803f88fd28b448" translate="yes" xml:space="preserve">
          <source>JvmDefaultWithoutCompatibility</source>
          <target state="translated">JvmDefaultWithoutCompatibility</target>
        </trans-unit>
        <trans-unit id="692baf8c605cdd872f8ac1b51f0db35d878fa6ec" translate="yes" xml:space="preserve">
          <source>JvmField</source>
          <target state="translated">JvmField</target>
        </trans-unit>
        <trans-unit id="8cafb887c2be5267183d19409f4ac9f885353c0a" translate="yes" xml:space="preserve">
          <source>JvmMultifileClass</source>
          <target state="translated">JvmMultifileClass</target>
        </trans-unit>
        <trans-unit id="2033eae859b01f53e2d78af856c5c34461b71b90" translate="yes" xml:space="preserve">
          <source>JvmName</source>
          <target state="translated">JvmName</target>
        </trans-unit>
        <trans-unit id="311d71c3b3f54390c29adff749b3edbb6a494b4a" translate="yes" xml:space="preserve">
          <source>JvmOverloads</source>
          <target state="translated">JvmOverloads</target>
        </trans-unit>
        <trans-unit id="747778441d808007d459844a0415514317ff72b7" translate="yes" xml:space="preserve">
          <source>JvmStatic</source>
          <target state="translated">JvmStatic</target>
        </trans-unit>
        <trans-unit id="6bc8e12710c62fe36d0378462ee3b1c664cd3300" translate="yes" xml:space="preserve">
          <source>JvmSuppressWildcards</source>
          <target state="translated">JvmSuppressWildcards</target>
        </trans-unit>
        <trans-unit id="a351df29143ba3c04cf22dc294f311273bb9b60f" translate="yes" xml:space="preserve">
          <source>JvmSynthetic</source>
          <target state="translated">JvmSynthetic</target>
        </trans-unit>
        <trans-unit id="85e086e57dc0c9b8c2d108ccec8876b36768e9b7" translate="yes" xml:space="preserve">
          <source>JvmWildcard</source>
          <target state="translated">JvmWildcard</target>
        </trans-unit>
        <trans-unit id="269b4c8f67d4bef3fb8e55e7c16a561a21d1145a" translate="yes" xml:space="preserve">
          <source>KAnnotatedElement</source>
          <target state="translated">KAnnotatedElement</target>
        </trans-unit>
        <trans-unit id="2380c006605522b5d08a2ee817a1eaa70c3eee66" translate="yes" xml:space="preserve">
          <source>KCallable</source>
          <target state="translated">KCallable</target>
        </trans-unit>
        <trans-unit id="638ba738d7801f4caebfacfc6daada8a29efaa3c" translate="yes" xml:space="preserve">
          <source>KClass</source>
          <target state="translated">KClass</target>
        </trans-unit>
        <trans-unit id="fab281a5b19ac7d1db397f74e48d5b9b12cc8340" translate="yes" xml:space="preserve">
          <source>KClass.cast</source>
          <target state="translated">KClass.cast</target>
        </trans-unit>
        <trans-unit id="acf5de634c6435ff94d10fad8e77c31d4afdb216" translate="yes" xml:space="preserve">
          <source>KClass.isInstance</source>
          <target state="translated">KClass.isInstance</target>
        </trans-unit>
        <trans-unit id="0eb6eed766c7bf5a996d5d184bea9e1688094497" translate="yes" xml:space="preserve">
          <source>KClass.safeCast</source>
          <target state="translated">KClass.safeCast</target>
        </trans-unit>
        <trans-unit id="64fa1008f290c0ccc3cc7c6ea0be14a5730d8c96" translate="yes" xml:space="preserve">
          <source>KClassifier</source>
          <target state="translated">KClassifier</target>
        </trans-unit>
        <trans-unit id="79b222c243d152a61ff297964121af433061592b" translate="yes" xml:space="preserve">
          <source>KClassifier.createType</source>
          <target state="translated">KClassifier.createType</target>
        </trans-unit>
        <trans-unit id="20cb65ed76161cb0b2be5e7c93b9d81ef134450b" translate="yes" xml:space="preserve">
          <source>KDeclarationContainer</source>
          <target state="translated">KDeclarationContainer</target>
        </trans-unit>
        <trans-unit id="7bf1a6c1fa5dce180803fdb8c3400d5e981f7201" translate="yes" xml:space="preserve">
          <source>KDoc Syntax</source>
          <target state="translated">KDoc 구문</target>
        </trans-unit>
        <trans-unit id="7d4c77574d0b857a214718597dca35a72ce59ec3" translate="yes" xml:space="preserve">
          <source>KDoc currently supports the following block tags:</source>
          <target state="translated">KDoc은 현재 다음 블록 태그를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fae5be3a00cdb97c4b5aa9435d19be927a5665ba" translate="yes" xml:space="preserve">
          <source>KDoc does not support the &lt;code&gt;@deprecated&lt;/code&gt; tag. Instead, please use the &lt;code&gt;@Deprecated&lt;/code&gt; annotation.</source>
          <target state="translated">KDoc은 &lt;code&gt;@deprecated&lt;/code&gt; 태그를 지원하지 않습니다 . 대신 &lt;code&gt;@Deprecated&lt;/code&gt; 주석을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="343a3fd44d3f90b682e5b8542c76a1c8f0dc43bf" translate="yes" xml:space="preserve">
          <source>KDoc syntax</source>
          <target state="translated">KDoc 구문</target>
        </trans-unit>
        <trans-unit id="cf7f75d8adb5a4855b94e1806ea4b9da20753a2a" translate="yes" xml:space="preserve">
          <source>KFunction</source>
          <target state="translated">KFunction</target>
        </trans-unit>
        <trans-unit id="ed5e1b52600600ea74e498fffdc8c815085f7d28" translate="yes" xml:space="preserve">
          <source>KLib binaries</source>
          <target state="translated">KLib binaries</target>
        </trans-unit>
        <trans-unit id="351228c4e54d9346ab6c9f3124cf8905349ef3f6" translate="yes" xml:space="preserve">
          <source>KMutableProperty</source>
          <target state="translated">KMutableProperty</target>
        </trans-unit>
        <trans-unit id="b8079b1b2c0efc81f1810eda68de2b7cfe28211b" translate="yes" xml:space="preserve">
          <source>KMutableProperty0</source>
          <target state="translated">KMutableProperty0</target>
        </trans-unit>
        <trans-unit id="ee64a1ab548503607558b0ae24255a9fb8d1bf97" translate="yes" xml:space="preserve">
          <source>KMutableProperty1</source>
          <target state="translated">KMutableProperty1</target>
        </trans-unit>
        <trans-unit id="b5a2a8a013bdb0ae3b43fd0eedfa92a1c579f8b7" translate="yes" xml:space="preserve">
          <source>KMutableProperty2</source>
          <target state="translated">KMutableProperty2</target>
        </trans-unit>
        <trans-unit id="3b161212f1754e4e1f54c5dee3fdb112a6efcc79" translate="yes" xml:space="preserve">
          <source>KParameter</source>
          <target state="translated">KParameter</target>
        </trans-unit>
        <trans-unit id="47dc03443aa940939b9abccc2588997b2fd72705" translate="yes" xml:space="preserve">
          <source>KProperty</source>
          <target state="translated">KProperty</target>
        </trans-unit>
        <trans-unit id="7c65965ff00632a4a27df6d2ccf39af470a5196a" translate="yes" xml:space="preserve">
          <source>KProperty0</source>
          <target state="translated">KProperty0</target>
        </trans-unit>
        <trans-unit id="8baedb2820a644b389145928c1658d83b9918bc5" translate="yes" xml:space="preserve">
          <source>KProperty1</source>
          <target state="translated">KProperty1</target>
        </trans-unit>
        <trans-unit id="8bf91abab2e2266a64dcd908bc6e070ddbaf118e" translate="yes" xml:space="preserve">
          <source>KProperty1.getDelegate</source>
          <target state="translated">KProperty1.getDelegate</target>
        </trans-unit>
        <trans-unit id="d8609e0c5b369de4819d2e07e76fd6ed37986905" translate="yes" xml:space="preserve">
          <source>KProperty2</source>
          <target state="translated">KProperty2</target>
        </trans-unit>
        <trans-unit id="fd138efe2eefe64c683fdbac01b4ebe15e42c11f" translate="yes" xml:space="preserve">
          <source>KProperty2.getDelegate</source>
          <target state="translated">KProperty2.getDelegate</target>
        </trans-unit>
        <trans-unit id="cddedd34830292c250dc6df0c7292dd170403bdb" translate="yes" xml:space="preserve">
          <source>KType</source>
          <target state="translated">KType</target>
        </trans-unit>
        <trans-unit id="f3764cdd111b81b5f82e469014413398559a3a69" translate="yes" xml:space="preserve">
          <source>KTypeParameter</source>
          <target state="translated">KTypeParameter</target>
        </trans-unit>
        <trans-unit id="a52a8fe183ee882846ec18218986d60cbd8b9caa" translate="yes" xml:space="preserve">
          <source>KTypeParameter.variance</source>
          <target state="translated">KTypeParameter.variance</target>
        </trans-unit>
        <trans-unit id="541ac7b02574ef282f5fea0a7caa24f963767d58" translate="yes" xml:space="preserve">
          <source>KTypeProjection</source>
          <target state="translated">KTypeProjection</target>
        </trans-unit>
        <trans-unit id="453bbaf5b6df4218f396acb7d784d58647332cd3" translate="yes" xml:space="preserve">
          <source>KVariance</source>
          <target state="translated">KVariance</target>
        </trans-unit>
        <trans-unit id="540dc0ef81ec2a035fa8eb530610a94d10ceaf33" translate="yes" xml:space="preserve">
          <source>KVisibility</source>
          <target state="translated">KVisibility</target>
        </trans-unit>
        <trans-unit id="89ee95ab7caa6f00ebf6ba552593878d5c2b4d1a" translate="yes" xml:space="preserve">
          <source>Kapt can generate Kotlin sources. Just write the generated Kotlin source files to the directory specified by &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt;, and these files will be compiled together with the main sources.</source>
          <target state="translated">Kapt은 Kotlin 소스를 생성 할 수 있습니다. 생성 된 Kotlin 소스 파일을 &lt;code&gt;processingEnv.options[&quot;kapt.kotlin.generated&quot;]&lt;/code&gt; 로 지정된 디렉토리에 쓰면 이 파일들이 기본 소스와 함께 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="115c000133ca0eeaa296737859925189dceee8bb" translate="yes" xml:space="preserve">
          <source>Kapt compiler plugin is available in the binary distribution of the Kotlin compiler.</source>
          <target state="translated">Kapt 컴파일러 플러그인은 Kotlin 컴파일러의 바이너리 배포판에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2790ed7723277b25aa2209903904a8c31657160" translate="yes" xml:space="preserve">
          <source>Kapt uses Java compiler to run annotation processors.</source>
          <target state="translated">Kapt는 Java 컴파일러를 사용하여 주석 프로세서를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ec688ce3d89067940f46fd29a7ea54660b831823" translate="yes" xml:space="preserve">
          <source>Keep in mind that this is just syntactic sugar - you're not actually modifying the class or its instances. Therefore, you have to import an extension function/property wherever you want to use it (since it isn't carried along with the instances of the class). For the same reason, you can not override extension members - you can reimplement them for subtypes, but the resolution happens at compile-time based on the static type of the expression you're invoking it on. So if you declare an extension function for &lt;code&gt;Vehicle&lt;/code&gt;, and one with the same name and signature for its subclass &lt;code&gt;Car&lt;/code&gt;, and you do the following, it's the extension function on &lt;code&gt;Vehicle&lt;/code&gt; that will be called, even though &lt;code&gt;v&lt;/code&gt; is really a &lt;code&gt;Car&lt;/code&gt;:</source>
          <target state="translated">이것은 구문상의 설탕 일뿐입니다. 실제로 클래스 나 인스턴스를 수정하지는 않습니다. 따라서 클래스의 인스턴스와 함께 제공되지 않으므로 확장 기능 / 속성을 사용하려는 곳마다 가져와야합니다. 같은 이유로 확장 멤버를 재정의 할 수 없습니다. 하위 멤버에 대해 확장 멤버를 다시 구현할 수 있지만 호출하는 식의 정적 형식에 따라 컴파일 타임에 해결이 이루어집니다. 따라서 &lt;code&gt;Vehicle&lt;/code&gt; 에 대한 확장 함수 와 서브 클래스 &lt;code&gt;Car&lt;/code&gt; 에 대한 동일한 이름 및 서명을 가진 확장 함수를 선언 하고 다음을 수행하는 경우 &lt;code&gt;v&lt;/code&gt; 가 실제로 &lt;code&gt;Car&lt;/code&gt; 인 경우에도 호출 되는 &lt;code&gt;Vehicle&lt;/code&gt; 의 확장 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="18218cc9fd8c5aa995704dae391402dc208f9851" translate="yes" xml:space="preserve">
          <source>Keep the language modern over the years.</source>
          <target state="translated">수년간 언어를 현대적으로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="07ccea1c92ddb53422b1f7f7120a95adacb8fcf2" translate="yes" xml:space="preserve">
          <source>Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</source>
          <target state="translated">Keeping whole packages or modules from elimination can prevent DCE from removing many unused declarations. Because of this, it is preferable to select individual declarations which should be excluded from DCE one by one.</target>
        </trans-unit>
        <trans-unit id="428b07e8e32e536ccaf4d9521cd95cadbf7fb10f" translate="yes" xml:space="preserve">
          <source>Keepsafe's App Lock app has also been &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;converted to 100% Kotlin&lt;/a&gt;, leading to a 30% decrease in source line count and 10% decrease in method count.</source>
          <target state="translated">Keepsafe의 App Lock 앱도 &lt;a href=&quot;https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6&quot;&gt;100 % Kotlin&lt;/a&gt; 으로 변환 되어 소스 라인 수가 30 % 감소하고 분석법 수가 10 % 감소했습니다.</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="4529f1f2ec7b60606af93bf0af48f282ccf9e92f" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; 요소의 키입니다 . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; 는이 키가있는 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="14a72bb7f1422b3f859b664b3562ae101c3c66b5" translate="yes" xml:space="preserve">
          <source>Key for the elements of &lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt;. &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; is a type of element with this key. Keys in the context are compared &lt;em&gt;by reference&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;CoroutineContext&lt;/a&gt; 요소의 키입니다 . &lt;a href=&quot;-key#E&quot;&gt;E&lt;/a&gt; 는이 키가있는 요소 유형입니다. 컨텍스트의 키는 &lt;em&gt;참조&lt;/em&gt; 로 비교 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7dea00f8bb18a0d2f420e398a89ddb4931a962cc" translate="yes" xml:space="preserve">
          <source>KeyboardEventInit</source>
          <target state="translated">KeyboardEventInit</target>
        </trans-unit>
        <trans-unit id="12698e3202bea6e77c14cc7645aefe1f40b4a95b" translate="yes" xml:space="preserve">
          <source>Keywords and Operators</source>
          <target state="translated">키워드 및 연산자</target>
        </trans-unit>
        <trans-unit id="e00ac23f2ac2ff73ad4f3c4b263d6c5bbfb80190" translate="yes" xml:space="preserve">
          <source>Kind</source>
          <target state="translated">Kind</target>
        </trans-unit>
        <trans-unit id="6d7060b8f0b142e9cc5d99251ae9bfc8344b5cdb" translate="yes" xml:space="preserve">
          <source>Kind of a module generated by compiler</source>
          <target state="translated">컴파일러에 의해 생성 된 모듈의 종류</target>
        </trans-unit>
        <trans-unit id="1d34a603bd791899c80e1dbe11daaee6bb135493" translate="yes" xml:space="preserve">
          <source>Kind of this parameter.</source>
          <target state="translated">이 매개 변수의 종류</target>
        </trans-unit>
        <trans-unit id="b295237940a339c9b3b99ec9fc0619f9bc3cd8b9" translate="yes" xml:space="preserve">
          <source>Kind represents a particular position of the parameter declaration in the source code, such as an instance, an extension receiver parameter or a value parameter.</source>
          <target state="translated">Kind는 소스 코드에서 매개 변수 선언의 특정 위치 (예 : 확장 수신자 매개 변수 또는 값 매개 변수)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="7205eb983ba710302eb6c62f19abead98485f315" translate="yes" xml:space="preserve">
          <source>Koans</source>
          <target state="translated">Koans</target>
        </trans-unit>
        <trans-unit id="cff7933a49bb6d767f24e765c4887a762a5f9c00" translate="yes" xml:space="preserve">
          <source>Konan_js_getProperty</source>
          <target state="translated">Konan_js_getProperty</target>
        </trans-unit>
        <trans-unit id="4b97a1cc4cde2d848838f0605a552d5704eea24b" translate="yes" xml:space="preserve">
          <source>Kotlin</source>
          <target state="translated">Kotlin</target>
        </trans-unit>
        <trans-unit id="ce2c3a212ddf8e8e1152459e5ba603b0e8d0abe9" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 introduced coroutines, a new way of writing asynchronous, non-blocking code (and much more). In this tutorial we will go through some basics of using Kotlin coroutines with the help of the &lt;code&gt;kotlinx.coroutines&lt;/code&gt; library, which is a collection of helpers and wrappers for existing Java libraries.</source>
          <target state="translated">Kotlin 1.1은 비동기 비 차단 코드를 작성하는 새로운 방법 인 코 루틴을 도입했습니다. 이 학습서에서는 기존 Java 라이브러리에 대한 헬퍼 및 랩퍼 콜렉션 인 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 라이브러리 의 도움으로 Kotlin 코 루틴을 사용하는 몇 가지 기본 사항을 살펴 봅니다 .</target>
        </trans-unit>
        <trans-unit id="63575fcf9f53cf161b23b5a5120b649f923aec04" translate="yes" xml:space="preserve">
          <source>Kotlin 1.1 removes some of the restrictions on sealed and data classes that were present in Kotlin 1.0. Now you can define subclasses of a top-level sealed class on the top level in the same file, and not just as nested classes of the sealed class. Data classes can now extend other classes. This can be used to define a hierarchy of expression classes nicely and cleanly:</source>
          <target state="translated">Kotlin 1.1은 Kotlin 1.0에 존재하는 봉인 및 데이터 클래스에 대한 일부 제한을 제거합니다. 이제 봉인 클래스의 중첩 클래스뿐만 아니라 동일한 파일에서 최상위 수준 봉인 클래스의 하위 클래스를 정의 할 수 있습니다. 데이터 클래스는 이제 다른 클래스를 확장 할 수 있습니다. 이를 통해 표현 클래스의 계층 구조를 훌륭하고 명확하게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b689f1de0358fa8de1c1a96775c0c0ab1538fa5" translate="yes" xml:space="preserve">
          <source>Kotlin 1.2 introduces a set of functions for operating with &lt;code&gt;BigInteger&lt;/code&gt; and &lt;code&gt;BigDecimal&lt;/code&gt; and creating them from other numeric types. These are:</source>
          <target state="translated">Kotlin 1.2는 &lt;code&gt;BigInteger&lt;/code&gt; 및 &lt;code&gt;BigDecimal&lt;/code&gt; 과 함께 작동하고 다른 숫자 유형에서 작성하기 위한 함수 세트를 소개합니다 . 이것들은:</target>
        </trans-unit>
        <trans-unit id="f18db78c63aaf770b997189868cab88ccb0ebc9f" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to evolve and improve scripting API, introducing some experimental support for scripts customization, such as adding external properties, providing static or dynamic dependencies, and so on.</source>
          <target state="translated">Kotlin 1.3은 스크립팅 API를 지속적으로 개선하고 개선하여 외부 속성 추가, 정적 또는 동적 종속성 제공 등과 같은 스크립트 사용자 지정에 대한 실험적인 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88e2adace5bac1e48c0adc9ef2ac271c679c842b" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 continues to improve and polish the Native target. See the &lt;a href=&quot;native-overview&quot;&gt;Kotlin/Native overview&lt;/a&gt; for details.</source>
          <target state="translated">Kotlin 1.3은 Native Target을 지속적으로 개선하고 개선합니다. 자세한 내용은 &lt;a href=&quot;native-overview&quot;&gt;Kotlin / Native 개요&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb394a79550e8145ec468f60617c81e553701477" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduced a simpler form of &lt;code&gt;main&lt;/code&gt; which takes no parameters. Now &amp;ldquo;Hello, World&amp;rdquo; in Kotlin is 19 characters shorter!</source>
          <target state="translated">Kotlin 1.3은 매개 변수를 사용하지 않는 간단한 형식의 &lt;code&gt;main&lt;/code&gt; 을 도입했습니다 . 이제 Kotlin의 &quot;Hello, World&quot;는 19 자 더 짧습니다!</target>
        </trans-unit>
        <trans-unit id="bfa732fa62960ffc201f7ae614e12c53ef901915" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces a new kind of declaration &amp;mdash; &lt;code&gt;inline class&lt;/code&gt;. Inline classes can be viewed as a restricted version of the usual classes, in particular, inline classes must have exactly one property:</source>
          <target state="translated">Kotlin 1.3에는 새로운 종류의 선언 인 &lt;code&gt;inline class&lt;/code&gt; 도입되었습니다 . 인라인 클래스는 일반 클래스의 제한된 버전으로 볼 수 있습니다. 특히 인라인 클래스에는 정확히 하나의 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="32e23fcaa9e8679e7038c793f0f15c69e36b0fe8" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces callable references on suspend-functions and support of Coroutines in the Reflection API.</source>
          <target state="translated">Kotlin 1.3은 Reflection API에서 일시 중단 기능과 Coroutines 지원에 대한 호출 가능한 참조를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="99e7bed5b89ef9affe2aabaa02c6b466182d4674" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for runnable Kotlin &lt;em&gt;scratch files&lt;/em&gt;. &lt;em&gt;Scratch file&lt;/em&gt; is a kotlin script file with a .kts extension which you can run and get evaluation results directly in the editor.</source>
          <target state="translated">Kotlin 1.3은 실행 가능한 Kotlin &lt;em&gt;스크래치 파일을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; . &lt;em&gt;스크래치 파일&lt;/em&gt; 은 편집기에서 직접 평가 결과를 얻을 수있는 .kts 확장자를 가진 kotlin 스크립트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="62694aae6035c5ad4972f2e14bf03a63310cd91a" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces support for the &lt;a href=&quot;coding-conventions&quot;&gt;recommended code style&lt;/a&gt; in the IDE. Check out &lt;a href=&quot;code-style-migration-guide&quot;&gt;this page&lt;/a&gt; for the migration guidelines.</source>
          <target state="translated">Kotlin 1.3 은 IDE에서 &lt;a href=&quot;coding-conventions&quot;&gt;권장 코드 스타일&lt;/a&gt; 을 지원합니다 . 마이그레이션 지침은 &lt;a href=&quot;code-style-migration-guide&quot;&gt;이 페이지&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="dae614ce706dcca5f69b1c3253fcc5bc2a15bada" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 introduces unsigned integer types:</source>
          <target state="translated">Kotlin 1.3에는 부호없는 정수 유형이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="29c35fc143ca98d825aae2e4d6224d719799d607" translate="yes" xml:space="preserve">
          <source>Kotlin 1.3 relaxes this limitation and adds support for functions with bigger arity:</source>
          <target state="translated">Kotlin 1.3은이 제한을 완화하고 더 큰 arity를 ​​가진 기능에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fab6809ce8d845633ec216cd46b20c0f5a989761" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;Any&lt;/code&gt; type</target>
        </trans-unit>
        <trans-unit id="1e0b4419e56e01f176b70724da2be7f1570af7d9" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;String&lt;/code&gt; type</source>
          <target state="translated">Kotlin &lt;code&gt;String&lt;/code&gt; type</target>
        </trans-unit>
        <trans-unit id="e0c3f493c89be1b94503fdc3f47d5c69cab752c8" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;inline&lt;/code&gt; classes</source>
          <target state="translated">Kotlin &lt;code&gt;inline&lt;/code&gt; classes</target>
        </trans-unit>
        <trans-unit id="c6f908927df8b995d9d09ec9bb214acf154074cf" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;interface&lt;/code&gt; types</source>
          <target state="translated">Kotlin &lt;code&gt;interface&lt;/code&gt; types</target>
        </trans-unit>
        <trans-unit id="efe980e61f0d5167fc83d8f145a3ab77bfa2773d" translate="yes" xml:space="preserve">
          <source>Kotlin &lt;code&gt;object Object&lt;/code&gt; is accessible as &lt;code&gt;kotlin.root.example.Object&lt;/code&gt;. There is the &lt;code&gt;_instance&lt;/code&gt; function to get the only instance of the object.</source>
          <target state="translated">Kotlin &lt;code&gt;object Object&lt;/code&gt; 는 &lt;code&gt;kotlin.root.example.Object&lt;/code&gt; 로 액세스 할 수 있습니다 . 있다 &lt;code&gt;_instance&lt;/code&gt; 의 개체의 유일한 인스턴스를 얻을 수있는 기능.</target>
        </trans-unit>
        <trans-unit id="0c1eb8d6dc73bce62ae72ba95f8c60b359816283" translate="yes" xml:space="preserve">
          <source>Kotlin Android Extensions</source>
          <target state="translated">코 틀린 안드로이드 확장</target>
        </trans-unit>
        <trans-unit id="7ffa31859972ce0a8778bfbe6687b81f154ab790" translate="yes" xml:space="preserve">
          <source>Kotlin Coding Conventions and IntelliJ IDEA formatter</source>
          <target state="translated">코 틀린 코딩 규약 및 IntelliJ IDEA 포맷터</target>
        </trans-unit>
        <trans-unit id="d072d7cbb3d097a577aaa31d4b14236492b51583" translate="yes" xml:space="preserve">
          <source>Kotlin Collections Overview</source>
          <target state="translated">코 틀린 컬렉션 개요</target>
        </trans-unit>
        <trans-unit id="e053b5d9a8bf9415ef3c2e418563c34aaf8713f7" translate="yes" xml:space="preserve">
          <source>Kotlin Define</source>
          <target state="translated">코 틀린 정의</target>
        </trans-unit>
        <trans-unit id="f0cb9aff4685505b6e4d1a7786d44dbe9c5c78a7" translate="yes" xml:space="preserve">
          <source>Kotlin Educational Plugin</source>
          <target state="translated">코 틀린 교육용 플러그인</target>
        </trans-unit>
        <trans-unit id="d2c2322d0e9d4d8a96800bd4df5ea6b0ed7d65ca" translate="yes" xml:space="preserve">
          <source>Kotlin Evolution</source>
          <target state="translated">코 틀린 진화</target>
        </trans-unit>
        <trans-unit id="5cd6704a0bf9c9ca5663fc3e713188fc0c5a8b1c" translate="yes" xml:space="preserve">
          <source>Kotlin Examples</source>
          <target state="translated">코 틀린 예제</target>
        </trans-unit>
        <trans-unit id="37cd15476fbbf200875db0672669c456999520ce" translate="yes" xml:space="preserve">
          <source>Kotlin Gradle plugin 1.3.41 works with Android Gradle Plugin 3.0 and later.</source>
          <target state="translated">Kotlin Gradle 플러그인 1.3.41은 Android Gradle 플러그인 3.0 이상에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4cd0aaf87578a00cb3abace9012077865b35012d" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript Overview</source>
          <target state="translated">코 틀린 JavaScript 개요</target>
        </trans-unit>
        <trans-unit id="59567d5d08261cc25efe7ed7644a3eac45c8cd4f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C fetch API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;W3C 페치 API&lt;/a&gt; 용 Kotlin JavaScript 랩퍼 .</target>
        </trans-unit>
        <trans-unit id="89d3498431602c2625879d1556695e73607eefba" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C file API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/FileAPI/&quot;&gt;W3C 파일 API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="87540457cfa4e684d01ade1be4ff2d537b4f72fb" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/XMLHttpRequest/&quot;&gt;XMLHttpRequest API&lt;/a&gt; 용 Kotlin JavaScript 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="e6596f2dab21e4e3036fba3783d7f4c0fbb0bb5f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/navigation-timing/&quot;&gt;Navigation Timing API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="449720a2299361e4c4ce93870004ed0025bd08d4" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;Web Notifications API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/notifications/&quot;&gt;웹 알림 API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="273f94ff92211232696d0bb0cccbbaefd99d6ca2" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the &lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/workers/&quot;&gt;Web Workers API&lt;/a&gt; 용 Kotlin JavaScript 래퍼 .</target>
        </trans-unit>
        <trans-unit id="60b8cb21a679faec431a00498befc15353dcf7ae" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM API.</source>
          <target state="translated">DOM API를위한 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="510e862b2092dfc113c9c6425e75519b326f41d7" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM CSS API.</source>
          <target state="translated">DOM CSS API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="f801c6554f4b1898140dcdff66b0ae475172001f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM SVG API.</source>
          <target state="translated">DOM SVG API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="ac97493032ddcd8ea7ab49e6704871e5d4e02a32" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM URL API.</source>
          <target state="translated">DOM URL API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="632516fede4eb8d78a61753d5a6b557583fae63f" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM events API.</source>
          <target state="translated">DOM 이벤트 API 용 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="9961d958d00f28d74f54365fb789a0a4c6ef0a4a" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the DOM parsing API.</source>
          <target state="translated">DOM 파싱 API를위한 Kotlin JavaScript 래퍼.</target>
        </trans-unit>
        <trans-unit id="1124adb3f39b71dbc17459b09b1abc27195f61e8" translate="yes" xml:space="preserve">
          <source>Kotlin JavaScript wrappers for the WebGL API.</source>
          <target state="translated">WebGL API 용 Kotlin JavaScript 랩퍼.</target>
        </trans-unit>
        <trans-unit id="c722e55da392cbca2ad7039aefd4506956b7b45a" translate="yes" xml:space="preserve">
          <source>Kotlin Koans</source>
          <target state="translated">코 틀린 코안</target>
        </trans-unit>
        <trans-unit id="8d8f55606ab1553a327fba954030ef9e92582959" translate="yes" xml:space="preserve">
          <source>Kotlin Koans are a series of exercises to get you familiar with the Kotlin Syntax. Each exercise is created as a failing unit test and your job is to make it pass. You can work with Kotlin Koans in one of following two ways:</source>
          <target state="translated">Kotlin Koans는 Kotlin 구문에 익숙해지는 일련의 연습입니다. 각 운동은 실패한 단위 테스트로 작성되며 귀하의 임무는 통과하는 것입니다. Kotlin Koans와 함께 다음 두 가지 방법 중 하나로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02527323fc74019fbf781a55d67bc6708fd5c80b" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile documentation</source>
          <target state="translated">Kotlin Multiplatform Mobile documentation</target>
        </trans-unit>
        <trans-unit id="79d51b4bb6a5d02df45fa0b0d8769519481f6142" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform Mobile samples</source>
          <target state="translated">Kotlin Multiplatform Mobile samples</target>
        </trans-unit>
        <trans-unit id="6c868382257c277087bdd2ca5e011f6e8a06d6f5" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects require Gradle version 4.7 and above, older Gradle versions are not supported.</source>
          <target state="translated">Kotlin Multiplatform 프로젝트에는 Gradle 버전 4.7 이상이 필요하며 이전 Gradle 버전은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5beef88265abf70b994272f6614d166413737387" translate="yes" xml:space="preserve">
          <source>Kotlin Multiplatform projects support the Android platform by providing the &lt;code&gt;android&lt;/code&gt; preset. Creating an Android target requires that one of the Android Gradle plugins, like &lt;code&gt;com.android.application&lt;/code&gt; or &lt;code&gt;com.android.library&lt;/code&gt; is manually applied to the project. Only one Android target may be created per Gradle subproject:</source>
          <target state="translated">코 틀린 멀티 프로젝트는 제공함으로써 안드로이드 플랫폼을 지원하는 &lt;code&gt;android&lt;/code&gt; 프리셋을. Android 대상을 만들려면 &lt;code&gt;com.android.application&lt;/code&gt; 또는 &lt;code&gt;com.android.library&lt;/code&gt; 와 같은 Android Gradle 플러그인 중 하나가 프로젝트에 수동으로 적용되어야합니다. Gradle 하위 프로젝트 당 하나의 Android 대상 만 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3e3dd997f7c2c71d9a81f4cdb39cd90d645230" translate="yes" xml:space="preserve">
          <source>Kotlin Numbers and NSNumber</source>
          <target state="translated">코 틀린 숫자와 NSNumber</target>
        </trans-unit>
        <trans-unit id="eb93d433c30733afdb11f2126d70c53184c02256" translate="yes" xml:space="preserve">
          <source>Kotlin Programming: The Big Nerd Ranch Guide</source>
          <target state="translated">코 틀린 프로그래밍 : The Big Nerd Ranch Guide</target>
        </trans-unit>
        <trans-unit id="7be628ef89900aa7e06bf8cc0824f551fbf7c2e0" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs</source>
          <target state="translated">코 틀린 스크립팅 API</target>
        </trans-unit>
        <trans-unit id="faea4ae8da7ddba5c8fa58aae401857d2734ca04" translate="yes" xml:space="preserve">
          <source>Kotlin Scripting APIs and custom hosts</source>
          <target state="translated">Kotlin 스크립팅 API 및 커스텀 호스트</target>
        </trans-unit>
        <trans-unit id="011d36adfc33756acd805d34ad317cbce9bd6e81" translate="yes" xml:space="preserve">
          <source>Kotlin Scripts (*.kts)</source>
          <target state="translated">코 틀린 스크립트 (* .kts)</target>
        </trans-unit>
        <trans-unit id="ede3b405bdfcccaf670f3a431d8f9e4a2a31a89a" translate="yes" xml:space="preserve">
          <source>Kotlin Standard Library</source>
          <target state="translated">코 틀린 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="f1cf27226d5b75bef32541fe78ffcb393aaf20fa" translate="yes" xml:space="preserve">
          <source>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation (like &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;) and fixed &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;precedence&lt;/a&gt;. To implement an operator, we provide a &lt;a href=&quot;functions#member-functions&quot;&gt;member function&lt;/a&gt; or an &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt; with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones. Functions that overload operators need to be marked with the &lt;code&gt;operator&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin을 사용하면 유형에 대해 사전 정의 된 연산자 세트에 대한 구현을 제공 할 수 있습니다. 이 연산자에는 고정 된 기호 표시 ( &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; )와 고정 된 &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;우선 순위가&lt;/a&gt; 있습니다. 연산자를 구현 하기 위해 해당 유형에 대한 고정 이름을 가진 &lt;a href=&quot;functions#member-functions&quot;&gt;멤버 함수&lt;/a&gt; 또는 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 를 제공합니다 ( 예 : 이진 연산의 경우 왼쪽 유형 및 단항 연산의 경우 인수 유형). 연산자를 과부하시키는 기능은 &lt;code&gt;operator&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b851c189b290bdaf55745756936a76cc50344467" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to compile your Kotlin projects to JavaScript modules for popular module systems. Here is the list of available options:</source>
          <target state="translated">Kotlin을 사용하면 Kotlin 프로젝트를 널리 사용되는 모듈 시스템 용 JavaScript 모듈로 컴파일 할 수 있습니다. 사용 가능한 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5fdfaaf9a73290e0eaf81fbe25051b78fa8542" translate="yes" xml:space="preserve">
          <source>Kotlin allows you to enforce symbol visibility (which Python only does via underscore conventions) via &lt;em&gt;visibility modifiers&lt;/em&gt;, which can be placed on symbol declarations. If you don't supply a visibility modifier, you get the default visibility level, which is &lt;em&gt;public&lt;/em&gt;.</source>
          <target state="translated">Kotlin을 사용하면 &lt;em&gt;가시성 수정자를&lt;/em&gt; 통해 기호 가시성 (Python이 밑줄 규칙을 통해서만 수행함)을 적용 할 수 있습니다. 가시성 수정자를 제공하지 않으면 기본 가시성 수준 인 &lt;em&gt;public이 표시&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="abf47a509d1576212045a5d60665d20e7353bdcd" translate="yes" xml:space="preserve">
          <source>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: &lt;code&gt;ByteArray&lt;/code&gt;, &lt;code&gt;ShortArray&lt;/code&gt;, &lt;code&gt;IntArray&lt;/code&gt; and so on. These classes have no inheritance relation to the &lt;code&gt;Array&lt;/code&gt; class, but they have the same set of methods and properties. Each of them also has a corresponding factory function:</source>
          <target state="translated">Kotlin은 또한 &lt;code&gt;ByteArray&lt;/code&gt; , &lt;code&gt;ShortArray&lt;/code&gt; , &lt;code&gt;IntArray&lt;/code&gt; 등의 복싱 오버 헤드없이 기본 유형의 배열을 나타내는 특수화 된 클래스를 가지고 있습니다 . 이 클래스는 &lt;code&gt;Array&lt;/code&gt; 클래스와 상속 관계가 없지만 동일한 메서드 및 속성 집합이 있습니다. 그들 각각은 또한 해당 팩토리 기능을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7c8be75b3b89d72e9e8ecc5a19439af68c79c8b1" translate="yes" xml:space="preserve">
          <source>Kotlin also supports a conventional notation for floating-point numbers:</source>
          <target state="translated">Kotlin은 부동 소수점 숫자에 대한 일반적인 표기법도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fdbc9c499ba317d1129cfbc92871c8a9261e88e6" translate="yes" xml:space="preserve">
          <source>Kotlin and Continuous Integration with TeamCity</source>
          <target state="translated">Kotlin과 TeamCity와의 지속적인 통합</target>
        </trans-unit>
        <trans-unit id="a29301ac26900a11e482b9b5b30d720163c72b02" translate="yes" xml:space="preserve">
          <source>Kotlin and Java sources</source>
          <target state="translated">Kotlin 및 자바 소스</target>
        </trans-unit>
        <trans-unit id="1c08b7274c4d1ababf7790a5bd9928dd47f39d9b" translate="yes" xml:space="preserve">
          <source>Kotlin and OSGi</source>
          <target state="translated">코 틀린과 OSGi</target>
        </trans-unit>
        <trans-unit id="b68da677f694a6554746e03538ca7213a7ff25e8" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objc defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin과 Swift는 모두 형식 지정의 일부로 Null 허용 여부를 정의하고 Objc는 유형의 메서드 및 속성에 Null 허용 여부를 정의합니다. 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de39894b7ea202f08e960c5e82b74ef66fdd95ec" translate="yes" xml:space="preserve">
          <source>Kotlin and Swift both define nullability as part of the type specification, while Objective-C defines nullability on methods and properties of a type. As such, the following:</source>
          <target state="translated">Kotlin과 Swift는 모두 유형 사양의 일부로 null 허용 여부를 정의하고 Objective-C는 유형의 메서드 및 속성에 대한 null 허용 여부를 정의합니다. 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fab22e5d648c157aabeded51b75888d84156c11e" translate="yes" xml:space="preserve">
          <source>Kotlin applications can be deployed into any host that supports Java Web applications, including Amazon Web Services, Google Cloud Platform and more.</source>
          <target state="translated">Kotlin 애플리케이션은 Amazon Web Services, Google Cloud Platform 등 Java 웹 애플리케이션을 지원하는 모든 호스트에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02f5529b0cc0cc0f331270b870a1119276c7c49" translate="yes" xml:space="preserve">
          <source>Kotlin as a statically typed programming language plays well for writing Gradle build scripts. Thanks to the static type inference, the Kotlin compiler detects errors earlier and shows important compilation error messages and warnings. Both an IDE and the compiler can use the information about types to infer the available functions and properties in a given scope.</source>
          <target state="translated">정적 유형의 프로그래밍 언어 인 Kotlin은 Gradle 빌드 스크립트 작성에 적합합니다. 정적 형식 유추 덕분에 Kotlin 컴파일러는 오류를 미리 감지하고 중요한 컴파일 오류 메시지 및 경고를 표시합니다. IDE와 컴파일러 모두 유형에 대한 정보를 사용하여 주어진 범위에서 사용 가능한 함수와 속성을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c6b22009eb8eb5969f5ded032f4849774e1cf34" translate="yes" xml:space="preserve">
          <source>Kotlin by Example</source>
          <target state="translated">예제 별 Kotlin</target>
        </trans-unit>
        <trans-unit id="6b0d896d7d9bc79daab4d58d21e623cb98946df3" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (.kts) with top level executable code.</source>
          <target state="translated">Kotlin은 스크립팅 언어로도 사용할 수 있습니다. 스크립트는 최상위 실행 코드가있는 Kotlin 소스 파일 (.kts)입니다.</target>
        </trans-unit>
        <trans-unit id="89f1b06f3d13062a764afffd52c7537a00883d5c" translate="yes" xml:space="preserve">
          <source>Kotlin can also be used as a scripting language. A script is a Kotlin source file (&lt;em&gt;.kts&lt;/em&gt;) with top level executable code.</source>
          <target state="translated">Kotlin은 스크립팅 언어로도 사용할 수 있습니다. 스크립트는 최상위 실행 코드 가있는 Kotlin 소스 파일 ( &lt;em&gt;.kts&lt;/em&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="c3ea6432cc5a54843d5885315d7e06f428855633" translate="yes" xml:space="preserve">
          <source>Kotlin can be compiled for several different platforms. In this document, we assume that the target platform is the Java virtual machine, which grants some extra capabilities - in particular, your code will be compiled to Java bytecode and will therefore be interoperable with the large ecosystem of Java libraries.</source>
          <target state="translated">Kotlin은 여러 플랫폼에 맞게 컴파일 할 수 있습니다. 이 문서에서는 대상 플랫폼이 Java 가상 머신으로 가정하여 추가 기능을 제공합니다. 특히 코드가 Java 바이트 코드로 컴파일되므로 대규모 Java 라이브러리 에코 시스템과 상호 운용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb59a20f7c43ef0e90a9a5fe239e22f7fac4ccd8" translate="yes" xml:space="preserve">
          <source>Kotlin can be used for any kind of development, be it server-side, client-side web and Android. With Kotlin/Native currently in the works, support for other platforms such as embedded systems, macOS and iOS is coming. People are using Kotlin for mobile and server-side applications, client-side with JavaScript or JavaFX, and data science, just to name a few possibilities.</source>
          <target state="translated">Kotlin은 서버 측, 클라이언트 측 웹 및 Android 등 모든 종류의 개발에 사용할 수 있습니다. Kotlin / Native가 현재 작업 중이므로 임베디드 시스템, macOS 및 iOS와 같은 다른 플랫폼에 대한 지원이 제공됩니다. 사람들은 Kotlin을 모바일 및 서버 측 애플리케이션, JavaScript 또는 JavaFX를 사용하는 클라이언트 측 및 데이터 과학에 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="521266653280c8e4a255fb437cafa5ed253cdca4" translate="yes" xml:space="preserve">
          <source>Kotlin can be used together with existing third-party libraries and frameworks, such as jQuery or React. To access third-party frameworks with a strongly-typed API, you can convert TypeScript definitions from the &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; type definitions repository to Kotlin using the &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; tool. Alternatively, you can use the &lt;a href=&quot;dynamic-type&quot;&gt;dynamic type&lt;/a&gt; to access any framework without strong typing.</source>
          <target state="translated">Kotlin은 기존의 타사 라이브러리 및 jQuery 또는 React와 같은 프레임 워크와 함께 사용할 수 있습니다. 강력한 형식의 API로 타사 프레임 워크에 액세스하기 위해 &lt;a href=&quot;https://github.com/kotlin/ts2kt&quot;&gt;ts2kt&lt;/a&gt; 도구를 사용하여 TypeScript 정의를 &lt;a href=&quot;http://definitelytyped.org/&quot;&gt;Definitely Typed&lt;/a&gt; 형식 정의 저장소에서 Kotlin으로 변환 할 수 있습니다 . 또는 &lt;a href=&quot;dynamic-type&quot;&gt;동적 유형&lt;/a&gt; 을 사용하여 강력한 타이핑없이 모든 프레임 워크에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c790b4c961dea3d891274def8258c901571e23a" translate="yes" xml:space="preserve">
          <source>Kotlin can get quite close to the compactness of Python's &lt;code&gt;list&lt;/code&gt;/&lt;code&gt;dict&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; comprehensions. Assuming that &lt;code&gt;people&lt;/code&gt; is a collection of &lt;code&gt;Person&lt;/code&gt; objects with a &lt;code&gt;name&lt;/code&gt; property:</source>
          <target state="translated">코 틀린은 파이썬의 &lt;code&gt;list&lt;/code&gt; / &lt;code&gt;dict&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; comprehensions 의 압축에 매우 가깝습니다 . &lt;code&gt;people&lt;/code&gt; 이 &lt;code&gt;name&lt;/code&gt; 속성을 가진 &lt;code&gt;Person&lt;/code&gt; 객체 의 모음 이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="88373e20528c6bc39fe448071ad8e0db31e3a229" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), i.e. the following code works:</source>
          <target state="translated">Kotlin은 런타임에 숫자 유형을 구분할 수 없습니다 ( &lt;code&gt;kotlin.Long&lt;/code&gt; 제외 ). 예를 들어 다음 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f14b3e6c2a42d2b616f9f3f45afd4a5a6fa4ccb2" translate="yes" xml:space="preserve">
          <source>Kotlin can't distinguish between numeric types at run time (except for &lt;code&gt;kotlin.Long&lt;/code&gt;), so the following code works:</source>
          <target state="translated">Kotlin은 런타임에 숫자 유형을 구분할 수 없으므로 ( &lt;code&gt;kotlin.Long&lt;/code&gt; 제외 ) 다음 코드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6add9a81cfef0c10e828238aa1031be87d4fbdd7" translate="yes" xml:space="preserve">
          <source>Kotlin cares a lot about stability and backward compatibility of code: Kotlin compatibility policy says that &quot;breaking changes&quot; (e.g., a change which makes the code that used to compile fine, not compile anymore) can be introduced only in the major releases (1.2, 1.3, etc.).</source>
          <target state="translated">Kotlin은 코드의 안정성과 이전 버전과의 호환성에 대해 많은 관심을 갖고 있습니다. Kotlin 호환성 정책에 따르면 &quot;최신 변경 사항&quot;(예 : 더 이상 컴파일하지 않고 컴파일에 사용 된 코드를 만드는 변경)은 주요 릴리스 (1.2)에서만 도입 될 수 있습니다. , 1.3 등).</target>
        </trans-unit>
        <trans-unit id="7c15ccd2ee8e753a90a11ef141acc11bda9b7db8" translate="yes" xml:space="preserve">
          <source>Kotlin classes and interfaces can be subclassed by Swift/Objective-C classes and protocols.</source>
          <target state="translated">코 틀린 클래스와 인터페이스는 Swift / Objective-C 클래스와 프로토콜에 의해 서브 클래 싱 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d314ecbc0aafe901079bc4583e826c76990ca2" translate="yes" xml:space="preserve">
          <source>Kotlin classes have a &lt;code&gt;KotlinBase&lt;/code&gt; base class in Objective-C, the class extends the &lt;code&gt;NSObject&lt;/code&gt; class there. We also have wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types from the other side:</source>
          <target state="translated">Kotlin 클래스에는 Objective-C에 &lt;code&gt;KotlinBase&lt;/code&gt; 기본 클래스 가 있으며이 클래스는 &lt;code&gt;NSObject&lt;/code&gt; 클래스를 확장합니다 . 컬렉션과 예외에 대한 래퍼도 있습니다. 대부분의 컬렉션 유형은 다른 쪽에서 비슷한 컬렉션 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8b117cc96a073696a10569a9a03f3366586d14" translate="yes" xml:space="preserve">
          <source>Kotlin code can be easily called from Java. For example, instances of a Kotlin class can be seamlessly created and operated in Java methods. However, there are certain differences between Java and Kotlin that require attention when integrating Kotlin code into Java. On this page, we'll describe the ways to tailor the interop of your Kotlin code with its Java clients.</source>
          <target state="translated">Kotlin 코드는 Java에서 쉽게 호출 할 수 있습니다. 예를 들어, Kotlin 클래스의 인스턴스는 Java 메소드에서 원활하게 작성하고 운영 할 수 있습니다. 그러나 Kotlin 코드를 Java에 통합 할 때주의를 기울여야하는 Java와 Kotlin의 특정 차이점이 있습니다. 이 페이지에서는 Kotlin 코드와 Java 클라이언트의 상호 운용성을 조정하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9fd6821c54cf8552d62d9de4efae79ccdf8ce19d" translate="yes" xml:space="preserve">
          <source>Kotlin collection types and subtypes</source>
          <target state="translated">Kotlin 컬렉션 유형 및 하위 유형</target>
        </trans-unit>
        <trans-unit id="315f6541c31d964f7f6872786a71a0ab54434ee9" translate="yes" xml:space="preserve">
          <source>Kotlin collections (&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin 컬렉션 ( &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 등)은 특정 자바 스크립트 유형에 매핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82a1593c6b9e1c8836da6d1fc4eb0ee62fff00f0" translate="yes" xml:space="preserve">
          <source>Kotlin collections (i.e. &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc) are not mapped to any specific JavaScript type.</source>
          <target state="translated">Kotlin 컬렉션 (예 : &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 등)은 특정 JavaScript 유형에 매핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89a478aadf91b074b0da52969af13f23d22bc823" translate="yes" xml:space="preserve">
          <source>Kotlin collections are converted to Swift/Objective-C collections as described in the table above. Swift/Objective-C collections are mapped to Kotlin in the same way, except for &lt;code&gt;NSMutableSet&lt;/code&gt; and &lt;code&gt;NSMutableDictionary&lt;/code&gt;. &lt;code&gt;NSMutableSet&lt;/code&gt; isn't converted to a Kotlin &lt;code&gt;MutableSet&lt;/code&gt;. To pass an object for Kotlin &lt;code&gt;MutableSet&lt;/code&gt;, you can create this kind of Kotlin collection explicitly by either creating it in Kotlin with e.g. &lt;code&gt;mutableSetOf()&lt;/code&gt;, or using the &lt;code&gt;KotlinMutableSet&lt;/code&gt; class in Swift (or &lt;code&gt;${prefix}MutableSet&lt;/code&gt; in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). The same holds for &lt;code&gt;MutableMap&lt;/code&gt;.</source>
          <target state="translated">Kotlin 콜렉션은 위 표에 설명 된대로 Swift / Objective-C 콜렉션으로 변환됩니다. Swift / Objective-C 콜렉션은 &lt;code&gt;NSMutableSet&lt;/code&gt; 및 &lt;code&gt;NSMutableDictionary&lt;/code&gt; 를 제외하고 동일한 방식으로 Kotlin에 맵핑됩니다 . &lt;code&gt;NSMutableSet&lt;/code&gt; 은 Kotlin &lt;code&gt;MutableSet&lt;/code&gt; 로 변환되지 않습니다 . 코 틀린에 대한 객체 전달하려면 &lt;code&gt;MutableSet&lt;/code&gt; 을 , 당신은 예와 코 틀린에 그것을 만드는 중 하나에 의해 명시 적으로 코 틀린 수집의이 종류를 만들 수 있습니다 &lt;code&gt;mutableSetOf()&lt;/code&gt; , 또는 사용 &lt;code&gt;KotlinMutableSet&lt;/code&gt; 의 스위프트 (또는에서 클래스를 &lt;code&gt;${prefix}MutableSet&lt;/code&gt; 오브젝티브 C에 &lt;code&gt;prefix&lt;/code&gt; 프레임 워크 이름 접두사입니다). 동일은을 위해 보유하고 &lt;code&gt;MutableMap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b92ab48756ee9ee4eecd8b48a584a882c8254f38" translate="yes" xml:space="preserve">
          <source>Kotlin collections contain functions for commonly used &lt;em&gt;aggregate operations&lt;/em&gt; &amp;ndash; operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</source>
          <target state="translated">Kotlin 컬렉션에는 일반적으로 사용되는 &lt;em&gt;집계 작업 (&lt;/em&gt; 컬렉션 내용에 따라 단일 값을 반환하는 작업)을 위한 함수가 포함되어 있습니다. 대부분은 잘 알려져 있으며 다른 언어에서와 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f6ae7c2ed581955837fb7fe33d78ac601409b90" translate="yes" xml:space="preserve">
          <source>Kotlin collections provide a set of functions for retrieving single elements from collections. Functions described on this page apply to both lists and sets.</source>
          <target state="translated">Kotlin 모음은 모음에서 단일 요소를 검색하기위한 일련의 기능을 제공합니다. 이 페이지에 설명 된 기능은 목록과 세트 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba542c391d818d9d92362b069b9bf7f9bd8bf71d" translate="yes" xml:space="preserve">
          <source>Kotlin community is open, helpful, and welcoming. Don't hesitate to join and ask on any platform you like:</source>
          <target state="translated">코 틀린 커뮤니티는 개방적이고 도움이되고 환영합니다. 주저하지 말고 원하는 플랫폼에 가입하십시오.</target>
        </trans-unit>
        <trans-unit id="4e7553781e500e3864ae344f47e5a7328b499d62" translate="yes" xml:space="preserve">
          <source>Kotlin compiler generates normal JavaScript classes, functions and properties you can freely use from JavaScript code. Nevertheless, there are some subtle things you should remember.</source>
          <target state="translated">Kotlin 컴파일러는 JavaScript 코드에서 자유롭게 사용할 수있는 일반 JavaScript 클래스, 함수 및 속성을 생성합니다. 그럼에도 불구하고 기억해야 할 미묘한 것들이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a4e8f76fdd58bb0af9bcb56f7360e7af41cc619" translate="yes" xml:space="preserve">
          <source>Kotlin compiler produces byte-code, thus there really is no difference in terms of look and feel of Kotlin applications versus those written in Java.</source>
          <target state="translated">Kotlin 컴파일러는 바이트 코드를 생성하므로 Kotlin 응용 프로그램의 모양과 느낌은 Java로 작성된 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="254a81c2b10749e0ebcc71c56165e699f0faa1e8" translate="yes" xml:space="preserve">
          <source>Kotlin compiler specifics</source>
          <target state="translated">코 틀린 컴파일러 사양</target>
        </trans-unit>
        <trans-unit id="9aad08d33b38b295c66376049aa54dafe55e242e" translate="yes" xml:space="preserve">
          <source>Kotlin compiler would generate the following output</source>
          <target state="translated">Kotlin 컴파일러는 다음과 같은 출력을 생성합니다</target>
        </trans-unit>
        <trans-unit id="4e6a12781a358b0632ea318dc28241e7061cc96f" translate="yes" xml:space="preserve">
          <source>Kotlin constructors are imported as initializers to Swift/Objective-C.</source>
          <target state="translated">Kotlin 생성자는 초기화 자로 Swift / Objective-C로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fd097194728e7a8d4e414220f1c3adc66a1135aa" translate="yes" xml:space="preserve">
          <source>Kotlin documentation is a good place to start, check out these links to get your feet wet:</source>
          <target state="translated">Kotlin 설명서는 시작하기에 좋은 장소입니다. 발을 젖게하려면 다음 링크를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="22a04b6935ed8f621d145360c7aea12d3366842f" translate="yes" xml:space="preserve">
          <source>Kotlin does not have Python's &lt;em&gt;resource managers&lt;/em&gt; or Java's &lt;em&gt;try-with-resources&lt;/em&gt;, but thanks to extension functions, there's &lt;code&gt;use&lt;/code&gt;:</source>
          <target state="translated">Kotlin에는 Python의 &lt;em&gt;리소스 관리자&lt;/em&gt; 또는 Java의 &lt;em&gt;try-with-resources&lt;/em&gt; 가 없지만 확장 기능 덕분에 다음과 같은 &lt;code&gt;use&lt;/code&gt; 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8da11f04c1c3d7dbbef032228e63afa6f04d63f3" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked &lt;a href=&quot;exceptions&quot;&gt;exceptions&lt;/a&gt;</source>
          <target state="translated">코 틀린은 &lt;a href=&quot;exceptions&quot;&gt;예외를&lt;/a&gt; 확인하지 않았습니다</target>
        </trans-unit>
        <trans-unit id="58e8fc7ba9fc6ab7f17a343e98ca51e5a850e480" translate="yes" xml:space="preserve">
          <source>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</source>
          <target state="translated">코 틀린은 예외를 확인하지 않았습니다. 여기에는 여러 가지 이유가 있지만 간단한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ea8df84918172c874d6ce26a2d2ac8d56eff8a7" translate="yes" xml:space="preserve">
          <source>Kotlin does not implement lazy initialization of top-level properties in JavaScript.</source>
          <target state="translated">Kotlin은 JavaScript에서 최상위 속성의 지연 초기화를 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c19ec6ca29946106579b7774a9f16c5845ebbc2" translate="yes" xml:space="preserve">
          <source>Kotlin ensures type safety of operations involving &lt;a href=&quot;generics&quot;&gt;generics&lt;/a&gt; at compile time, while, at runtime, instances of generic types hold no information about their actual type arguments. For example, &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; is erased to just &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt;. In general, there is no way to check whether an instance belongs to a generic type with certain type arguments at runtime.</source>
          <target state="translated">Kotlin은 컴파일 타임에 &lt;a href=&quot;generics&quot;&gt;제네릭&lt;/a&gt; 과 관련된 작업의 형식 안전성을 보장 하는 반면 런타임에 제네릭 형식의 인스턴스에는 실제 형식 인수에 대한 정보가 없습니다. 예를 들어 &lt;code&gt;List&amp;lt;Foo&amp;gt;&lt;/code&gt; 는 &lt;code&gt;List&amp;lt;*&amp;gt;&lt;/code&gt; 로만 지워집니다 . 일반적으로 인스턴스가 런타임에 특정 유형 인수를 사용하여 일반 유형에 속하는지 여부를 확인할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3093475043dd707a8b9c1069aead086bf16cf6d" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin은 패키지 구조를 자바 스크립트에 노출하므로 루트 패키지에서 선언을 정의하지 않는 한 자바 스크립트에서 정규화 된 이름을 사용해야합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="bbcaf4c7dfc1607eaa4b2ffde25fea37b6fff50b" translate="yes" xml:space="preserve">
          <source>Kotlin exposes its package structure to JavaScript, so unless you define your declarations in the root package, you have to use fully-qualified names in JavaScript. For example:</source>
          <target state="translated">Kotlin은 패키지 구조를 JavaScript에 공개하므로 루트 패키지에 선언을 정의하지 않으면 JavaScript에서 정규화 된 이름을 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7be04058c2375c4141e803b8f5f5c3ef0ebe450b" translate="yes" xml:space="preserve">
          <source>Kotlin extensions to &quot;regular&quot; Kotlin classes are imported to Swift and Objective-C as extensions and category members respectively. Kotlin extensions to other types are treated as &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;top-level declarations&lt;/a&gt; with an additional receiver parameter. These types include:</source>
          <target state="translated">&quot;일반&quot;Kotlin 클래스에 대한 Kotlin 확장은 Swift 및 Objective-C에 각각 확장 및 카테고리 구성원으로 가져옵니다. 다른 유형에 대한 Kotlin 확장 은 추가 수신자 매개 변수가있는 &lt;a href=&quot;#top-level-functions-and-properties&quot;&gt;최상위 선언&lt;/a&gt; 으로 처리됩니다 . 이러한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bd032e19c9c721a60ec9014384d50331ee1d338" translate="yes" xml:space="preserve">
          <source>Kotlin fixes a series of issues that Java suffers from:</source>
          <target state="translated">Kotlin은 Java로 인해 발생하는 일련의 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="2e70b9b4257b183b5c7e10570483451ad725fc8a" translate="yes" xml:space="preserve">
          <source>Kotlin follows the Java naming conventions. In particular:</source>
          <target state="translated">Kotlin은 Java 명명 규칙을 따릅니다. 특히:</target>
        </trans-unit>
        <trans-unit id="0548deb8694e8bfa87792c4e732edf938085eb1e" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Case Studies</source>
          <target state="translated">Android 사례 연구를위한 Kotlin</target>
        </trans-unit>
        <trans-unit id="c1441b497e656bddb290de8de9224360e00ecbdf" translate="yes" xml:space="preserve">
          <source>Kotlin for Android Developers</source>
          <target state="translated">안드로이드 개발자를위한 코 틀린</target>
        </trans-unit>
        <trans-unit id="7b2f1c8edda5c1d58bf2a573a1626581c631617c" translate="yes" xml:space="preserve">
          <source>Kotlin for Java Developers</source>
          <target state="translated">Java 개발자를위한 Kotlin</target>
        </trans-unit>
        <trans-unit id="e6f31bf50fe73009407bd97cfc46c1659646cb16" translate="yes" xml:space="preserve">
          <source>Kotlin function types and subtypes</source>
          <target state="translated">Kotlin 함수 유형 및 하위 유형</target>
        </trans-unit>
        <trans-unit id="fe6b04ae909883df5d80ca51aec87a07bb290e41" translate="yes" xml:space="preserve">
          <source>Kotlin function-typed objects (e.g. lambdas) are converted to Swift functions / Objective-C blocks. However there is a difference in how types of parameters and return values are mapped when translating a function and a function type. In the latter case primitive types are mapped to their boxed representation. Kotlin &lt;code&gt;Unit&lt;/code&gt; return value is represented as a corresponding &lt;code&gt;Unit&lt;/code&gt; singleton in Swift/Objective-C. The value of this singleton can be retrieved in the same way as it is for any other Kotlin &lt;code&gt;object&lt;/code&gt; (see singletons in the table above). To sum the things up:</source>
          <target state="translated">Kotlin 함수 유형 객체 (예 : 람다)는 Swift 함수 / Objective-C 블록으로 변환됩니다. 그러나 함수와 함수 유형을 변환 할 때 매개 변수 유형과 반환 값이 매핑되는 방식에 차이가 있습니다. 후자의 경우 기본 유형이 상자 표시로 맵핑됩니다. 코 틀린 &lt;code&gt;Unit&lt;/code&gt; 반환 값은 Swift / Objective-C에서 해당 &lt;code&gt;Unit&lt;/code&gt; 싱글 톤 으로 표시됩니다 . 이 싱글 톤의 값은 다른 Kotlin &lt;code&gt;object&lt;/code&gt; 와 동일한 방식으로 검색 할 수 있습니다 (위의 싱글 톤 참조). 정리하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6377c81eb40cd3205e240b814a78f31b9c3b2c4e" translate="yes" xml:space="preserve">
          <source>Kotlin functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;first-class&lt;/em&gt;&lt;/a&gt;, which means that they can be stored in variables and data structures, passed as arguments to and returned from other &lt;a href=&quot;#higher-order-functions&quot;&gt;higher-order functions&lt;/a&gt;. You can operate with functions in any way that is possible for other non-function values.</source>
          <target state="translated">Kotlin 함수는 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;&lt;em&gt;일류&lt;/em&gt;&lt;/a&gt; 이므로 변수 및 데이터 구조에 저장하고 인수로 전달하여 다른 &lt;a href=&quot;#higher-order-functions&quot;&gt;고차 함수&lt;/a&gt; 에서 반환 할 수 있습니다 . 다른 비 기능적 값에 대해 가능한 방식으로 기능으로 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06212cca9855d4bc50a6216a937f6da059a9c0cc" translate="yes" xml:space="preserve">
          <source>Kotlin generate JavaScript code that is compatible with Asynchronous Module Definition (AMD), CommonJS and Universal Model Definition (UMD).</source>
          <target state="translated">Kotlin은 AMD (Asynchronous Module Definition), CommonJS 및 UMD (Universal Model Definition)와 호환되는 JavaScript 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e3d5465bac3e356284fe278ce3583ae2129ce4a" translate="yes" xml:space="preserve">
          <source>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</source>
          <target state="translated">Kotlin은 Java와 비슷한 방식으로 숫자를 처리하지만 정확히 동일하지는 않습니다. 예를 들어, 숫자에 대한 암시 적 확장 변환은 없으며 경우에 따라 리터럴이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a419931ca3da367222b771f7660e3ff6428af9ed" translate="yes" xml:space="preserve">
          <source>Kotlin has a rather small runtime file size: the library is approximately 964KB (as of 1.3.41). This means Kotlin adds just a little to .apk file size.</source>
          <target state="translated">Kotlin은 런타임 파일 크기가 다소 작습니다. 라이브러리는 약 964KB입니다 (1.3.41 기준). 이것은 Kotlin이 .apk 파일 크기에 약간만 추가 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a3e60d485f88e60187d3caa5025c740961ab3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has an extensive standard library that can be used in your applications. Configure the following dependency in the pom file:</source>
          <target state="translated">Kotlin에는 응용 프로그램에서 사용할 수있는 광범위한 표준 라이브러리가 있습니다. pom 파일에서 다음 종속성을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="ab1e60d19725004dca25a2263f17ef1cdb84890e" translate="yes" xml:space="preserve">
          <source>Kotlin has been successfully adopted by major companies, and a few of them have shared their experiences:</source>
          <target state="translated">Kotlin은 주요 회사에서 성공적으로 채택되었으며 그 중 일부는 다음과 같은 경험을 공유했습니다.</target>
        </trans-unit>
        <trans-unit id="3ed9d85f3169bc5321f12531a1c541d127d00550" translate="yes" xml:space="preserve">
          <source>Kotlin has both object-oriented and functional constructs. You can use it in both OO and FP styles, or mix elements of the two. With first-class support for features such as higher-order functions, function types and lambdas, Kotlin is a great choice if you&amp;rsquo;re doing or exploring functional programming.</source>
          <target state="translated">Kotlin은 객체 지향 및 기능적 구성을 모두 가지고 있습니다. OO 및 FP 스타일 모두에서 사용하거나 두 가지 요소를 혼합하여 사용할 수 있습니다. 고차 함수, 함수 유형 및 람다와 같은 기능을 일류 지원하는 Kotlin은 함수형 프로그래밍을 수행하거나 탐색 할 때 탁월한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d0b80a6eafa346308b4f2ffbb72d503567999d28" translate="yes" xml:space="preserve">
          <source>Kotlin has classes and their members &lt;code&gt;final&lt;/code&gt; by default, which makes it inconvenient to use frameworks and libraries such as Spring AOP that require classes to be &lt;code&gt;open&lt;/code&gt;. The &lt;em&gt;all-open&lt;/em&gt; compiler plugin adapts Kotlin to the requirements of those frameworks and makes classes annotated with a specific annotation and their members open without the explicit &lt;code&gt;open&lt;/code&gt; keyword.</source>
          <target state="translated">Kotlin은 기본적으로 클래스와 멤버를 &lt;code&gt;final&lt;/code&gt; 으로 가지고 있으므로 클래스를 &lt;code&gt;open&lt;/code&gt; 하는 Spring AOP와 같은 프레임 워크와 라이브러리를 사용하는 것이 불편합니다 . &lt;em&gt;모든 오픈&lt;/em&gt; 컴파일러 플러그인은 그 프레임 워크의 요구 사항에 코 틀린 적응하고 특정 주석을 주석 수업을하고 자신의 회원은 명시하지 않고 열 &lt;code&gt;open&lt;/code&gt; 키워드.</target>
        </trans-unit>
        <trans-unit id="b816faaaa048d52b55167846f58533c82dcf332c" translate="yes" xml:space="preserve">
          <source>Kotlin has got its own reflection library (&lt;code&gt;kotlin-reflect.jar&lt;/code&gt; must be included in your build). When targeting the JVM, you can also use the Java reflection facilities. Note that the Kotlin reflection isn't quite feature-complete yet - in particular, you can't use it to inspect built-in classes like &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 자체 리플렉션 라이브러리를 가지고 있습니다 ( &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 는 빌드에 포함되어야합니다). JVM을 대상으로 할 때 Java 리플렉션 기능을 사용할 수도 있습니다. Kotlin 리플렉션은 아직 완전히 완성되지 않았으므로 특히 &lt;code&gt;String&lt;/code&gt; 과 같은 내장 클래스를 검사하는 데 사용할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="89599a2b8afb959091521970edd698c7f8696cca" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety (but very flexible) way of doing I/O, but with some simplifying extra features. We won't get into all of it here, so for starters, this is how to iterate through all the lines of a file (you'll need &lt;code&gt;import java.io.File&lt;/code&gt;):</source>
          <target state="translated">코 틀린은 I / O를 수행하는 Java의 fidgety (그러나 매우 유연한) 방식을 물려 받았지만 몇 가지 간단한 기능을 추가했습니다. 우리는 여기에 모든 것을 넣지 않을 것이므로 우선 초보자를 위해 파일의 모든 줄을 반복하는 방법입니다 ( &lt;code&gt;import java.io.File&lt;/code&gt; 이 필요합니다 ).</target>
        </trans-unit>
        <trans-unit id="789ece85cba2d7c5232dc414bc11dc159641da4f" translate="yes" xml:space="preserve">
          <source>Kotlin has inherited Java's fidgety array system, so primitive types have got their own array types and conversion functions, while any other type uses the generic &lt;code&gt;Array&lt;/code&gt; type, to which you can convert with &lt;code&gt;.toTypedArray()&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 Java의 fidgety 배열 시스템을 상속 받았으므로 기본 유형에는 자체 배열 유형 및 변환 함수가 있으며 다른 유형은 일반 &lt;code&gt;Array&lt;/code&gt; 유형을 사용하며 &lt;code&gt;.toTypedArray()&lt;/code&gt; 로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99a77fa93b5373d975ec4157225559f8cd6c6cb3" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation specifying a list of &quot;expected&quot; exception classes.</source>
          <target state="translated">Kotlin에는 확인 된 예외의 개념이 없으며 모든 Kotlin 예외는 확인되지 않습니다. Swift는 오류 만 확인했습니다. 따라서 Swift 또는 Objective-C 코드가 처리 할 예외를 발생시키는 Kotlin 메서드를 호출하는 경우 Kotlin 메서드는 &quot;예상 된&quot;예외 클래스 목록을 지정하는 &lt;code&gt;@Throws&lt;/code&gt; 주석 으로 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e626b593df468862004f3cb251d2e1710f0e139" translate="yes" xml:space="preserve">
          <source>Kotlin has no concept of checked exceptions, all Kotlin exceptions are unchecked. Swift has only checked errors. So if Swift or Objective-C code calls a Kotlin method which throws an exception to be handled, then the Kotlin method should be marked with a &lt;code&gt;@Throws&lt;/code&gt; annotation. In this case all Kotlin exceptions (except for instances of &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;RuntimeException&lt;/code&gt; and subclasses) are translated into a Swift error/&lt;code&gt;NSError&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 확인 된 예외 개념이 없으며 모든 Kotlin 예외는 확인되지 않습니다. Swift는 오류를 확인했습니다. 따라서 Swift 또는 Objective-C 코드가 처리 할 예외를 발생시키는 Kotlin 메소드를 호출하면 Kotlin 메소드에 &lt;code&gt;@Throws&lt;/code&gt; 주석 이 표시되어야합니다 . 이 경우 모든 Kotlin 예외 ( &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;RuntimeException&lt;/code&gt; 및 서브 클래스 제외)는 Swift error / &lt;code&gt;NSError&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="178ebff753223a76976f1b5505609a06e7a0941e" translate="yes" xml:space="preserve">
          <source>Kotlin has now the option of generating Java 8 bytecode (&lt;code&gt;-jvm-target 1.8&lt;/code&gt; command line option or the corresponding options in Ant/Maven/Gradle). For now this doesn't change the semantics of the bytecode (in particular, default methods in interfaces and lambdas are generated exactly as in Kotlin 1.0), but we plan to make further use of this later.</source>
          <target state="translated">Kotlin은 이제 Java 8 바이트 코드 ( &lt;code&gt;-jvm-target 1.8&lt;/code&gt; 명령 행 옵션 또는 Ant / Maven / Gradle의 해당 옵션)를 생성 할 수 있습니다. 지금은 바이트 코드의 의미를 변경하지 않지만 (특히 인터페이스와 람다의 기본 메소드는 Kotlin 1.0에서와 동일하게 생성됩니다) 나중에이를 더 활용할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="1b256a14cb898b1876ca682918ab4726ae689547" translate="yes" xml:space="preserve">
          <source>Kotlin has proper &lt;a href=&quot;lambdas#function-types&quot;&gt;function types&lt;/a&gt;, as opposed to Java's SAM-conversions</source>
          <target state="translated">Kotlin은 Java의 SAM 변환과 달리 적절한 &lt;a href=&quot;lambdas#function-types&quot;&gt;함수 유형을&lt;/a&gt; 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21d65ae753898818d1cd1395d2b3d50ce49c4d34" translate="yes" xml:space="preserve">
          <source>Kotlin has three structural jump expressions:</source>
          <target state="translated">코 틀린에는 세 가지 구조적 점프 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fab1b92010786ac4e42e500d9dbd613684af3aa" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</source>
          <target state="translated">Kotlin에는 두 가지 유형의 문자열 리터럴이 있습니다. 이스케이프 된 문자가 포함 된 이스케이프 된 문자열과 줄 바꿈 및 임의의 텍스트를 포함 할 수있는 원시 문자열입니다. 이스케이프 된 문자열은 Java 문자열과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="88377cf789dc237868418b003f1376d4a4fb9cfb" translate="yes" xml:space="preserve">
          <source>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. Here's an example of an escaped string:</source>
          <target state="translated">Kotlin에는 두 가지 유형의 문자열 리터럴이 있습니다. 이스케이프 된 문자가있을 수있는 이스케이프 된 문자열과 줄 바꿈 및 임의의 텍스트를 포함 할 수있는 원시 문자열입니다. 다음은 이스케이프 된 문자열의 예입니다.</target>
        </trans-unit>
        <trans-unit id="7c53d6c43db7159858e1b06d40910057344f857d" translate="yes" xml:space="preserve">
          <source>Kotlin in Action</source>
          <target state="translated">코 틀린의 행동</target>
        </trans-unit>
        <trans-unit id="897dddb8bded8aacac7c4f7f6865ba43edeed083" translate="yes" xml:space="preserve">
          <source>Kotlin introduces following types for unsigned integers:</source>
          <target state="translated">Kotlin은 부호없는 정수에 대해 다음 유형을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="1162e3ef7e5343b47c0a5de3586b0dd6d01591ce" translate="yes" xml:space="preserve">
          <source>Kotlin is a compiled, statically typed language, which might provide some initial hurdles for people who are used to the interpreted, dynamically typed Python. This document aims to explain a substantial portion of Kotlin's syntax and concepts in terms of how they compare to corresponding concepts in Python.</source>
          <target state="translated">코 틀린 (Kotlin)은 정적으로 형식화 된 컴파일 된 언어로, 해석되고 동적으로 형식화 된 파이썬에 익숙한 사람들에게 약간의 초기 장애를 제공 할 수 있습니다. 이 문서는 Kotlin의 구문과 개념 중 상당 부분을 Python의 해당 개념과 비교하는 방식으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="640ddadf7e88f55374061d5998c2bee5a53626f4" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing Android applications, bringing all of the advantages of a modern language to the Android platform without introducing any new restrictions:</source>
          <target state="translated">Kotlin은 Android 애플리케이션 개발에 매우 ​​적합하며 새로운 제한을 도입하지 않고도 현대 언어의 모든 장점을 Android 플랫폼에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b1f1b3f12f705373f46ad38b06f457675f0bb145" translate="yes" xml:space="preserve">
          <source>Kotlin is a great fit for developing server-side applications, allowing you to write concise and expressive code while maintaining full compatibility with existing Java-based technology stacks and a smooth learning curve:</source>
          <target state="translated">Kotlin은 서버 측 응용 프로그램 개발에 적합하여 기존 Java 기반 기술 스택 및 원활한 학습 곡선과의 완벽한 호환성을 유지하면서 간결하고 표현적인 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942fb98d86e153b0e83fe0d61de04cbccacbe8f7" translate="yes" xml:space="preserve">
          <source>Kotlin is a pragmatic and unopinionated language, supporting both imperative and function programming styles without pushing the developer towards either one. We can implement the function &lt;code&gt;f&lt;/code&gt; in functional style, using such Kotlin features as &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;tail recursion&lt;/a&gt;:</source>
          <target state="translated">코 틀린 (Kotlin)은 실용적이면서도 비언어적 인 언어로, 개발자를 어느쪽으로 든 강요하지 않고 명령형 및 함수형 프로그래밍 스타일을 모두 지원합니다. &lt;a href=&quot;../reference/functions#tail-recursive-functions&quot;&gt;꼬리 재귀&lt;/a&gt; 와 같은 Kotlin 기능을 사용하여 함수 &lt;code&gt;f&lt;/code&gt; 를 함수 스타일로 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0d8f4fd81a58ee08fc7afcc5cfdb0b02c31ab79" translate="yes" xml:space="preserve">
          <source>Kotlin is a statically typed language, which makes it different from the dynamically typed JavaScript. In order to facilitate interoperation with JavaScript code, Kotlin/JS offers the &lt;code&gt;dynamic&lt;/code&gt; type:</source>
          <target state="translated">Kotlin은 정적으로 입력 된 언어이므로 동적으로 입력되는 자바 스크립트와 다릅니다. JavaScript 코드와의 상호 운용을 용이하게하기 위해 Kotlin / JS는 &lt;code&gt;dynamic&lt;/code&gt; 유형을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f033af0ab747811276c086c79a9bfc947c92c7d6" translate="yes" xml:space="preserve">
          <source>Kotlin is an OSS statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin은 JVM, Android, JavaScript 및 Native를 대상으로하는 OSS 정적 유형의 프로그래밍 언어입니다. &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains에&lt;/a&gt; 의해 개발되었습니다 . 이 프로젝트는 2010 년에 시작되었으며 초기부터 오픈 소스였습니다. 최초의 공식 1.0 릴리스는 2016 년 2 월입니다.</target>
        </trans-unit>
        <trans-unit id="654d332c5c16069d8e33851920e04af4ba1633e6" translate="yes" xml:space="preserve">
          <source>Kotlin is an open-source statically typed programming language that targets the JVM, Android, JavaScript and Native. It&amp;rsquo;s developed by &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;. The project started in 2010 and was open source from very early on. The first official 1.0 release was in February 2016.</source>
          <target state="translated">Kotlin은 JVM, Android, JavaScript 및 Native를 대상으로하는 오픈 소스 정적으로 형식화 된 프로그래밍 언어입니다. &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt; 에서 개발했습니다 . 이 프로젝트는 2010 년에 시작되었으며 초기부터 오픈 소스였습니다. 최초의 공식 1.0 릴리스는 2016 년 2 월이었습니다.</target>
        </trans-unit>
        <trans-unit id="d9537d803964341dc28f1f4951da5b348b7b611e" translate="yes" xml:space="preserve">
          <source>Kotlin is compatible with CommonJS, AMD and UMD, &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;making interaction with different&lt;/a&gt; module systems straightforward.</source>
          <target state="translated">Kotlin은 CommonJS, AMD 및 UMD와 호환되므로 &lt;a href=&quot;../tutorials/javascript/working-with-modules/working-with-modules&quot;&gt;다른&lt;/a&gt; 모듈 시스템 과 쉽게 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3ca5bc7aa971f25976aff86462ee8c65c9cb7e" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be a pragmatic tool for programmers. When it comes to language evolution, its pragmatic nature is captured by the following principles:</source>
          <target state="translated">Kotlin은 프로그래머를위한 실용적인 도구로 설계되었습니다. 언어 진화와 관련하여 실용적인 특성은 다음과 같은 원칙에 의해 포착됩니다.</target>
        </trans-unit>
        <trans-unit id="93c08e581c43a4ec4822d841d4ddc6b6324821eb" translate="yes" xml:space="preserve">
          <source>Kotlin is designed to be easy to learn for people who already know Java. A quick overview of differences is given on &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;the official comparison page&lt;/a&gt;. A short introduction to the basic syntax of Kotlin for software developers can be found directly in the reference section of the web site starting from &lt;a href=&quot;../reference/basic-syntax&quot;&gt;basic syntax&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 Java를 이미 알고있는 사람들이 쉽게 배울 수 있도록 설계되었습니다. 차이점에 대한 빠른 개요 &lt;a href=&quot;../reference/comparison-to-java&quot;&gt;는 공식 비교 페이지에서 제공&lt;/a&gt; 됩니다. 소프트웨어 개발자를위한 코 틀린의 기본 구문에 대한 짧은 소개가 시작 웹 사이트의 참조 섹션에서 직접 확인할 수 있습니다 &lt;a href=&quot;../reference/basic-syntax&quot;&gt;기본 구문&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76527281e23251ab9b22562a01f9e2381d26e878" translate="yes" xml:space="preserve">
          <source>Kotlin is designed with Java Interoperability in mind. Existing Java code can be called from Kotlin in a natural way, and Kotlin code can be used from Java rather smoothly as well. In this section we describe some details about calling Java code from Kotlin.</source>
          <target state="translated">Kotlin은 Java 상호 운용성을 염두에두고 설계되었습니다. 기존 Java 코드는 자연스러운 방식으로 Kotlin에서 호출 할 수 있으며 Kotlin 코드는 Java에서도 원활하게 사용할 수 있습니다. 이 섹션에서는 Kotlin에서 Java 코드 호출에 대한 세부 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b1117330525358e715dea7a8875981cd28a616bf" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with &lt;code&gt;kotlin.js&lt;/code&gt; standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. Also it is available on NPM as &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt; package&lt;/a&gt;</source>
          <target state="translated">Kotlin은 &lt;code&gt;kotlin.js&lt;/code&gt; 표준 라이브러리와 함께 단일 파일로 배포되며 ,이 파일은 자체적으로 UMD 모듈로 컴파일되므로 위에서 설명한 모든 모듈 시스템과 함께 사용할 수 있습니다. 또한 NPM에서 &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt; 패키지 로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a18e9cef9fc2a234c1d159c10281aea5af17fa" translate="yes" xml:space="preserve">
          <source>Kotlin is distributed with the Kotlin/JS standard library as a single file, which is itself compiled as an UMD module, so you can use it with any module system described above. While for most use cases of Kotlin/JS, it is recommended to use a Gradle dependency on &lt;code&gt;kotlin-stdlib-js&lt;/code&gt;, it is also available on NPM as the &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt;&lt;code&gt;kotlin&lt;/code&gt;&lt;/a&gt; package.</source>
          <target state="translated">Kotlin은 Kotlin / JS 표준 라이브러리와 함께 단일 파일로 배포되며, 자체적으로 UMD 모듈로 컴파일되므로 위에서 설명한 모든 모듈 시스템에서 사용할 수 있습니다. 대부분의 Kotlin / JS 사용 사례에서는 &lt;code&gt;kotlin-stdlib-js&lt;/code&gt; 에 Gradle 종속성을 사용하는 것이 좋지만 NPM에서도 &lt;a href=&quot;https://www.npmjs.com/package/kotlin&quot;&gt; &lt;code&gt;kotlin&lt;/code&gt; &lt;/a&gt; 패키지 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bb12b617173b78ae2213fea703120a48dac83b8" translate="yes" xml:space="preserve">
          <source>Kotlin is inspired by existing languages such as Java, C#, JavaScript, Scala and Groovy. We've tried to ensure that Kotlin is easy to learn, so that people can easily jump on board, reading and writing Kotlin in a matter of days. Learning idiomatic Kotlin and using some more of its advanced features can take a little longer, but overall it is not a complicated language.</source>
          <target state="translated">Kotlin은 Java, C #, JavaScript, Scala 및 Groovy와 같은 기존 언어에서 영감을 얻었습니다. 우리는 Kotlin이 배우기 쉽도록 노력하여 사람들이 며칠 만에 Kotlin을 쉽게 읽고 쓸 수 있도록했습니다. 관용적 코 틀린을 배우고 더 많은 고급 기능을 사용하는 데 시간이 조금 더 걸릴 수 있지만 전반적으로 복잡한 언어는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="62c8094d2f49ea185993571453009f8f90b8b387" translate="yes" xml:space="preserve">
          <source>Kotlin is more concise. Rough estimates indicate approximately a 40% cut in the number of lines of code. It&amp;rsquo;s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE&amp;rsquo;s. Other features including smart casting, higher-order functions, extension functions and lambdas with receivers provide the ability to write expressive code as well as facilitating creation of DSL.</source>
          <target state="translated">코 틀린이 더 간결합니다. 대략적인 추정치에 따르면 코드 줄 수가 약 40 % 줄었습니다. 또한 형식이 더 안전합니다. 예를 들어 널 입력 불가능 유형을 지원하면 응용 프로그램이 NPE에 덜 취약합니다. 스마트 캐스팅, 고차 함수, 확장 기능 및 수신기가있는 람다를 포함한 다른 기능은 표현 코드를 작성하는 기능을 제공 할뿐만 아니라 DSL 작성을 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="57ebc857aaa4fe4ee76557729aedd97eb250b716" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 100+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin은 주로 JetBrains의 엔지니어 팀이 개발합니다 (현재 팀 규모는 100 명 이상). 수석 언어 디자이너는 &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt; 입니다. 핵심 팀 외에도 GitHub에는 250 명 이상의 외부 기여자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a6891160d562ed8798489fdde041cf7382a9267" translate="yes" xml:space="preserve">
          <source>Kotlin is primarily developed by a team of engineers at JetBrains (current team size is 50+). The lead language designer is &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt;. In addition to the core team, there are also over 250 external contributors on GitHub.</source>
          <target state="translated">Kotlin은 주로 JetBrains의 엔지니어 팀 (현재 팀 규모는 50+ 이상)에 의해 개발되었습니다. 주요 언어 디자이너는 &lt;a href=&quot;https://twitter.com/abreslav&quot;&gt;Andrey Breslav&lt;/a&gt; 입니다. 핵심 팀 외에도 GitHub에는 250 명 이상의 외부 기고자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e252e4cd43e2222ef996694efabbf2a368b1568c" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;../tutorials/getting-started&quot;&gt;IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;../tutorials/kotlin-android&quot;&gt;Android Studio&lt;/a&gt; , &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; 및 &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans를&lt;/a&gt; 포함한 모든 주요 Java IDE에서 지원됩니다 . 또한 &lt;a href=&quot;../tutorials/command-line&quot;&gt;명령 줄 컴파일러&lt;/a&gt; 를 사용할 수 있으며 응용 프로그램을 컴파일하고 실행하기위한 간단한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b9c46bf1ad2fe2fbc414ecfb85cf4b65bec1ff6" translate="yes" xml:space="preserve">
          <source>Kotlin is supported by all major Java IDEs including &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt;, &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; and &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans&lt;/a&gt;. In addition, a &lt;a href=&quot;../tutorials/command-line&quot;&gt;command line compiler&lt;/a&gt; is available and provides straightforward support for compiling and running applications.</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;../tutorials/jvm-get-started&quot;&gt;IntelliJ IDEA&lt;/a&gt; , &lt;a href=&quot;https://developer.android.com/kotlin/get-started&quot;&gt;Android Studio&lt;/a&gt; , &lt;a href=&quot;../tutorials/getting-started-eclipse&quot;&gt;Eclipse&lt;/a&gt; 및 &lt;a href=&quot;http://plugins.netbeans.org/plugin/68590/kotlin&quot;&gt;NetBeans를&lt;/a&gt; 포함한 모든 주요 Java IDE에서 지원됩니다 . 또한 &lt;a href=&quot;../tutorials/command-line&quot;&gt;명령 줄 컴파일러&lt;/a&gt; 를 사용할 수 있으며 응용 프로그램 컴파일 및 실행에 대한 직접적인 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38b8eb152c426ee3fe939706153705b8354595aa" translate="yes" xml:space="preserve">
          <source>Kotlin is well covered in online courses, check out recommended courses here:</source>
          <target state="translated">Kotlin은 온라인 과정을 잘 다루고 있습니다. 여기에서 권장 과정을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f6275eeb32172070d309b650be85e7156b1c7dc9" translate="yes" xml:space="preserve">
          <source>Kotlin lets you choose the version of JVM for execution. By default, the Kotlin/JVM compiler produces Java 6 compatible bytecode. If you want to make use of optimizations available in newer versions of Java, you can explicitly specify the target Java version from 8 to 13. Note that in this case the resulting bytecode might not run on lower versions.</source>
          <target state="translated">Kotlin을 사용하면 실행할 JVM 버전을 선택할 수 있습니다. 기본적으로 Kotlin / JVM 컴파일러는 자바 6 호환 바이트 코드를 생성합니다. 최신 버전의 Java에서 사용 가능한 최적화를 사용하려면 8에서 13까지의 대상 Java 버전을 명시 적으로 지정할 수 있습니다.이 경우 결과 바이트 코드가 하위 버전에서 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b75c21f1512e55023917a6b77552862460e120" translate="yes" xml:space="preserve">
          <source>Kotlin lets you easily create ranges of values using the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt;&lt;code&gt;rangeTo()&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;kotlin.ranges&lt;/code&gt; package and its operator form &lt;code&gt;..&lt;/code&gt;. Usually, &lt;code&gt;rangeTo()&lt;/code&gt; is complemented by &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;!in&lt;/code&gt; functions.</source>
          <target state="translated">코 틀린은 쉽게 사용 값 범위 만들 수 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/range-to&quot;&gt; &lt;code&gt;rangeTo()&lt;/code&gt; &lt;/a&gt; 로부터 기능 &lt;code&gt;kotlin.ranges&lt;/code&gt; 의 패키지와 연산자 형태 &lt;code&gt;..&lt;/code&gt; . 일반적으로 &lt;code&gt;rangeTo()&lt;/code&gt; 는 &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;!in&lt;/code&gt; 함수로 보완됩니다 .</target>
        </trans-unit>
        <trans-unit id="ceee386e40b3b46c69160d750c22ce62d0c3f184" translate="yes" xml:space="preserve">
          <source>Kotlin lets you manipulate collections independently of the exact type of objects stored in them. In other words, you add a &lt;code&gt;String&lt;/code&gt; to a list of &lt;code&gt;String&lt;/code&gt;s the same way as you would do with &lt;code&gt;Int&lt;/code&gt;s or a user-defined class. So, the Kotlin Standard Library offers generic interfaces, classes, and functions for creating, populating, and managing collections of any type.</source>
          <target state="translated">Kotlin을 사용하면 컬렉션에 저장된 정확한 유형의 개체와 독립적으로 컬렉션을 조작 할 수 있습니다. 즉, 당신은 추가 &lt;code&gt;String&lt;/code&gt; 의 목록에 &lt;code&gt;String&lt;/code&gt; 당신이 할 것 같은의 같은 방식으로 &lt;code&gt;Int&lt;/code&gt; 의 또는 사용자 정의 클래스입니다. 따라서 Kotlin 표준 라이브러리는 모든 유형의 콜렉션을 작성, 채우기 및 관리하기위한 일반 인터페이스, 클래스 및 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8bb9f52709d9b5cdac5f51755d862ecbca9c415c" translate="yes" xml:space="preserve">
          <source>Kotlin metadata</source>
          <target state="translated">코 틀린 메타 데이터</target>
        </trans-unit>
        <trans-unit id="0e7ef1544d45f6a307acf242d3ddb29c611697ae" translate="yes" xml:space="preserve">
          <source>Kotlin modules can be used in Swift/Objective-C code if compiled into a framework (see &quot;Targets and output kinds&quot; section in &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle plugin documentation&lt;/a&gt;). See &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;calculator sample&lt;/a&gt; for an example.</source>
          <target state="translated">Kotlin 모듈은 프레임 워크로 컴파일 된 경우 Swift / Objective-C 코드에서 사용될 수 있습니다 ( &lt;a href=&quot;gradle_plugin#targets-and-output-kinds&quot;&gt;Gradle 플러그인 설명서의&lt;/a&gt; &quot;대상 및 출력 종류&quot;섹션 참조 ). &lt;a href=&quot;https://github.com/JetBrains/kotlin-native/tree/master/samples/calculator&quot;&gt;예제&lt;/a&gt; 는 계산기 샘플 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0c9d0d836710fc155aae7ff2099c119f8b8ff3b" translate="yes" xml:space="preserve">
          <source>Kotlin now integrates with the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223). The API allows to evaluate snippets of code at runtime:</source>
          <target state="translated">Kotlin은 이제 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html&quot;&gt;javax.script API&lt;/a&gt; (JSR-223) 와 통합됩니다 . API를 사용하면 런타임시 코드 스 니펫을 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5917b5d1de587466aad2c24c7e35497e2343f72e" translate="yes" xml:space="preserve">
          <source>Kotlin now supports storing parameter names in the bytecode. This can be enabled using the &lt;code&gt;-java-parameters&lt;/code&gt; command line option.</source>
          <target state="translated">Kotlin은 이제 바이트 코드에 매개 변수 이름 저장을 지원합니다. &lt;code&gt;-java-parameters&lt;/code&gt; 명령 행 옵션을 사용하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="900f5e70ca199686eb62d660ad48f2ce1610ab30" translate="yes" xml:space="preserve">
          <source>Kotlin numeric types, except for &lt;code&gt;kotlin.Long&lt;/code&gt; are mapped to JavaScript Number.</source>
          <target state="translated">&lt;code&gt;kotlin.Long&lt;/code&gt; 을 제외한 Kotlin 숫자 유형 은 JavaScript Number에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="fa0f528e5b1ad066646e40d867c682edc345e3d1" translate="yes" xml:space="preserve">
          <source>Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example</source>
          <target state="translated">Kotlin 객체는 고정 될 수 있습니다. 즉 메모리에서 해당 위치는 고정 해제 될 때까지 안정적으로 유지되며 이러한 객체 내부 데이터에 대한 포인터는 C 함수로 전달 될 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="23971a8580dfc32441ac3140ce5ff12ac8ef11bf" translate="yes" xml:space="preserve">
          <source>Kotlin plugin 1.3.21 or higher should be installed in the IDE. This can be verified via &lt;em&gt;Language &amp;amp; Frameworks | Kotlin Updates&lt;/em&gt; section in the &lt;em&gt;Settings&lt;/em&gt; (or &lt;em&gt;Preferences&lt;/em&gt;) of the IDE.</source>
          <target state="translated">Kotlin 플러그인 1.3.21 이상이 IDE에 설치되어 있어야합니다. &lt;em&gt;언어 및 프레임 워크&lt;/em&gt; 를 통해 확인할 수 있습니다. &lt;em&gt;| &lt;/em&gt;IDE 의 &lt;em&gt;설정&lt;/em&gt; (또는 &lt;em&gt;환경 설정&lt;/em&gt; )의 &lt;em&gt;Kotlin 업데이트&lt;/em&gt; 섹션</target>
        </trans-unit>
        <trans-unit id="446a5a46278f3d1273d1c8d81bcdc944823353d2" translate="yes" xml:space="preserve">
          <source>Kotlin plugin for IntelliJ IDEA supports &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;scratches&lt;/a&gt;. Scratches let you create code drafts in the same IDE window with your project and run them on the fly. Scratches are not tied to projects; you can access and run all your scratches from any IntelliJ IDEA window on your OS.</source>
          <target state="translated">IntelliJ IDEA 용 Kotlin 플러그인은 &lt;a href=&quot;https://www.jetbrains.com/help/idea/scratches.html&quot;&gt;스크래치를&lt;/a&gt; 지원합니다 . 스크래치를 사용하면 프로젝트와 동일한 IDE 창에서 코드 드래프트를 작성하여 즉시 실행할 수 있습니다. 흠집은 프로젝트와 관련이 없습니다. OS의 IntelliJ IDEA 창에서 모든 스크래치에 액세스하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf764bc84647534de5f2a7804f4aa2d9d548f9f9" translate="yes" xml:space="preserve">
          <source>Kotlin preserves lazy object initialization in JavaScript.</source>
          <target state="translated">Kotlin은 JavaScript에서 게으른 객체 초기화를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="69aede4d1ffe657e5907011bd8394bcc0601690e" translate="yes" xml:space="preserve">
          <source>Kotlin preserves overflow semantics for &lt;code&gt;kotlin.Int&lt;/code&gt;, &lt;code&gt;kotlin.Byte&lt;/code&gt;, &lt;code&gt;kotlin.Short&lt;/code&gt;, &lt;code&gt;kotlin.Char&lt;/code&gt; and &lt;code&gt;kotlin.Long&lt;/code&gt;.</source>
          <target state="translated">Kotlin은 &lt;code&gt;kotlin.Int&lt;/code&gt; , &lt;code&gt;kotlin.Byte&lt;/code&gt; , &lt;code&gt;kotlin.Short&lt;/code&gt; , &lt;code&gt;kotlin.Char&lt;/code&gt; 및 &lt;code&gt;kotlin.Long&lt;/code&gt; 에 대한 오버 플로우 의미를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="2849a08507ed289fb75d76677103722db661daba" translate="yes" xml:space="preserve">
          <source>Kotlin primitive type boxes are mapped to special Swift/Objective-C classes. For example, &lt;code&gt;kotlin.Int&lt;/code&gt; box is represented as &lt;code&gt;KotlinInt&lt;/code&gt; class instance in Swift (or &lt;code&gt;${prefix}Int&lt;/code&gt; instance in Objective-C, where &lt;code&gt;prefix&lt;/code&gt; is the framework names prefix). These classes are derived from &lt;code&gt;NSNumber&lt;/code&gt;, so the instances are proper &lt;code&gt;NSNumber&lt;/code&gt;s supporting all corresponding operations.</source>
          <target state="translated">Kotlin 기본 유형 상자는 특수 Swift / Objective-C 클래스에 매핑됩니다. 예를 들어, &lt;code&gt;kotlin.Int&lt;/code&gt; 상자는 Swift에서 &lt;code&gt;KotlinInt&lt;/code&gt; 클래스 인스턴스 (또는 Objective-C의 &lt;code&gt;${prefix}Int&lt;/code&gt; 인스턴스 (여기서 &lt;code&gt;prefix&lt;/code&gt; 는 프레임 워크 이름 접두어 임))로 표시됩니다. 이러한 클래스는 &lt;code&gt;NSNumber&lt;/code&gt; 에서 파생 되므로 인스턴스는 모든 해당 작업을 지원하는 적절한 &lt;code&gt;NSNumber&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a7ceca5755070f2e75db1f8f41e2c1a411bf045a" translate="yes" xml:space="preserve">
          <source>Kotlin primitive types</source>
          <target state="translated">Kotlin 기본 유형</target>
        </trans-unit>
        <trans-unit id="56d4abf280a1b7394ae7fdfbb57bfe9eaca646d5" translate="yes" xml:space="preserve">
          <source>Kotlin properties declared in a named object or a companion object will have static backing fields either in that named object or in the class containing the companion object.</source>
          <target state="translated">명명 된 객체 또는 컴패니언 객체에 선언 된 Kotlin 속성에는 해당 명명 된 객체 또는 컴패니언 객체를 포함하는 클래스에 정적 백업 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf2e0c6a8a702a4b4cb47d5f81663fe43b024e43" translate="yes" xml:space="preserve">
          <source>Kotlin provides a series of compiler options that are accessible in IntelliJ IDEA also. In addition to the one we've just seen for generating source maps, we also have the ability to set</source>
          <target state="translated">Kotlin은 IntelliJ IDEA에서도 액세스 할 수있는 일련의 컴파일러 옵션을 제공합니다. 방금 소스 맵을 생성하기 위해 본 것 외에도 설정할 수있는 기능이 있습니다</target>
        </trans-unit>
        <trans-unit id="e2142c523bbfdb03dd37f333a0ce0922e05e00a3" translate="yes" xml:space="preserve">
          <source>Kotlin provides a set of built-in types that represent numbers.</source>
          <target state="translated">Kotlin은 숫자를 나타내는 기본 제공 유형 집합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0a113f99eec74b4131a54c5b784be8df823aef27" translate="yes" xml:space="preserve">
          <source>Kotlin provides a variety of functions to execute a block of code in the context of a given object: &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt;, and &lt;code&gt;also&lt;/code&gt;. For the guidance on choosing the right scope function for your case, refer to &lt;a href=&quot;scope-functions&quot;&gt;Scope Functions&lt;/a&gt;.</source>
          <target state="translated">: 코 틀린는 주어진 객체의 컨텍스트에서 코드 블록을 실행하는 다양한 기능을 제공 &lt;code&gt;let&lt;/code&gt; , &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; , &lt;code&gt;apply&lt;/code&gt; , 및 &lt;code&gt;also&lt;/code&gt; . 귀하의 경우에 적합한 범위의 기능을 선택에 대한 지침을 참조 &lt;a href=&quot;scope-functions&quot;&gt;스코프 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bdbfc816d9da34f310288932621f6005bd4a635" translate="yes" xml:space="preserve">
          <source>Kotlin provides so called &lt;strong&gt;star-projection&lt;/strong&gt; syntax for this:</source>
          <target state="translated">Kotlin 은이를 위해 소위 &lt;strong&gt;스타-투영&lt;/strong&gt; 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a7357de7d14d7d6aa1f1f673c4bd660028007794" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to extend a class with new functionality without having to inherit from the class or use design patterns such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. For example, you can write new functions for a class from a third-party library that you can't modify. Such functions are available for calling in the usual way as if they were methods of the original class. This mechanism is called &lt;em&gt;extension functions&lt;/em&gt;. There are also &lt;em&gt;extension properties&lt;/em&gt; that let you define new properties for existing classes.</source>
          <target state="translated">Kotlin은 클래스에서 상속하거나 Decorator와 같은 디자인 패턴을 사용하지 않고도 새로운 기능으로 클래스를 확장 할 수있는 기능을 제공합니다. 이것은 &lt;em&gt;extensions&lt;/em&gt; 라는 특별한 선언을 통해 이루어집니다 . 예를 들어 수정할 수없는 타사 라이브러리의 클래스에 대한 새 함수를 작성할 수 있습니다. 이러한 함수는 원래 클래스의 메서드 인 것처럼 일반적인 방식으로 호출 할 수 있습니다. 이 메커니즘을 &lt;em&gt;확장 함수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 기존 클래스에 대한 새 속성을 정의 할 수있는 &lt;em&gt;확장 속성&lt;/em&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="45eae3e9e04c057fe2a9ce2b00c2b1626952c923" translate="yes" xml:space="preserve">
          <source>Kotlin provides the ability to target JavaScript. It does so by transpiling Kotlin to JavaScript. The current implementation targets ECMAScript 5.1 but there are plans to eventually target ECMAScript 2015 as well.</source>
          <target state="translated">Kotlin은 JavaScript를 대상으로하는 기능을 제공합니다. Kotlin을 JavaScript로 변환하여 그렇게합니다. 현재 구현은 ECMAScript 5.1을 대상으로하지만 결국 ECMAScript 2015를 대상으로 할 계획도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d361e832e7fbd8cbfa474feeaaf4e3060965e0c" translate="yes" xml:space="preserve">
          <source>Kotlin provides the following built-in types representing numbers (this is close to Java):</source>
          <target state="translated">Kotlin은 숫자를 나타내는 다음과 같은 내장 유형을 제공합니다 (이것은 Java에 가깝습니다).</target>
        </trans-unit>
        <trans-unit id="bcb1ec23fd44ea30c0c43e5be53b38271d9f8878" translate="yes" xml:space="preserve">
          <source>Kotlin provides three tasks for Ant:</source>
          <target state="translated">Kotlin은 Ant에 대한 세 가지 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d32683bae75ae112d7b7ae383176964359ce8293" translate="yes" xml:space="preserve">
          <source>Kotlin requires that every member property is initialized during instance construction. Sometimes, a class is intended to be used in such a way that the constructor doesn't have enough information to initialize all properties (such as when making a builder class or when using property-based dependency injection). In order to not have to make those properties nullable, you can use a &lt;em&gt;late-initialized property&lt;/em&gt;:</source>
          <target state="translated">Kotlin은 인스턴스 생성 중에 모든 멤버 속성을 초기화해야합니다. 때로는 클래스가 생성자에 모든 속성을 초기화하기위한 정보가 충분하지 않은 방식으로 사용되기도합니다 (빌더 클래스를 만들 때 또는 속성 기반 종속성 주입을 사용할 때). 이러한 속성을 nullable로 만들지 않으려면 &lt;em&gt;초기화&lt;/em&gt; 가 &lt;em&gt;늦은 속성을&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c82522c1d0ee2c933047e31fffeca6f833ef7e" translate="yes" xml:space="preserve">
          <source>Kotlin scripts in &lt;code&gt;build.gradle.kts&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;build.gradle.kts&lt;/code&gt; 파일의 Kotlin 스크립트</target>
        </trans-unit>
        <trans-unit id="120e9cfe3ecde2244c4b2038cf0d5e11c76827a7" translate="yes" xml:space="preserve">
          <source>Kotlin singleton (made with an &lt;code&gt;object&lt;/code&gt; declaration, including &lt;code&gt;companion object&lt;/code&gt;) is imported to Swift/Objective-C as a class with a single instance. The instance is available through the factory method, i.e. as &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; in Objective-C and &lt;code&gt;MySingleton()&lt;/code&gt; in Swift.</source>
          <target state="translated">(AN로 만든 코 틀린 싱글 &lt;code&gt;object&lt;/code&gt; 를 포함 선언, &lt;code&gt;companion object&lt;/code&gt; ) 단일 인스턴스와 클래스로 스위프트 / 오브젝티브 C로 가져옵니다. 인스턴스는 팩토리 메소드를 통해 사용할 수 있습니다 (예 : Objective-C의 &lt;code&gt;[MySingleton mySingleton]&lt;/code&gt; 및 Swift의 &lt;code&gt;MySingleton()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea729ea75b1b1e606f056a5012e91fb52a83a74" translate="yes" xml:space="preserve">
          <source>Kotlin singletons</source>
          <target state="translated">코 틀린 싱글 톤</target>
        </trans-unit>
        <trans-unit id="a2394b4a95a3420db31c70572b58364d6b98a0c6" translate="yes" xml:space="preserve">
          <source>Kotlin source file or directory to compile</source>
          <target state="translated">Kotlin 소스 파일 또는 컴파일 할 디렉토리</target>
        </trans-unit>
        <trans-unit id="e2f631b0ebe5da9da1b87daae220f0696369b117" translate="yes" xml:space="preserve">
          <source>Kotlin source sets may be connected with the &lt;em&gt;'depends on'&lt;/em&gt; relation, so that if a source set &lt;code&gt;foo&lt;/code&gt; depends on a source set &lt;code&gt;bar&lt;/code&gt; then:</source>
          <target state="translated">Kotlin 소스 세트는 &lt;em&gt;'depends on'&lt;/em&gt; 관계 와 연결될 수 있으므로 소스 세트 &lt;code&gt;foo&lt;/code&gt; 가 소스 세트 &lt;code&gt;bar&lt;/code&gt; 에 의존 하는 경우 :</target>
        </trans-unit>
        <trans-unit id="3806de1d34a4bca588a5784ceb856faa4c1b15c6" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin 소스는 동일한 폴더 또는 다른 폴더에서 Java 소스와 혼합 될 수 있습니다. 기본 규칙은 다른 폴더를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8dda6be52af63434ddc539d85c3f07ae2c8c8de5" translate="yes" xml:space="preserve">
          <source>Kotlin sources can be stored with Java sources in the same folder, or placed to different folders. The default convention is using different folders:</source>
          <target state="translated">Kotlin 소스는 자바 소스와 함께 동일한 폴더에 저장되거나 다른 폴더에 배치 될 수 있습니다. 기본 규칙은 다른 폴더를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="742632ac6e0e85caf1c4f062cccebafab2dafb01" translate="yes" xml:space="preserve">
          <source>Kotlin standard library artifacts and split packages</source>
          <target state="translated">Kotlin 표준 라이브러리 아티팩트 및 분할 패키지</target>
        </trans-unit>
        <trans-unit id="77cb00a3ce7a3cdab1c1c157be47f7632c70f806" translate="yes" xml:space="preserve">
          <source>Kotlin subclasses of Objective-C classes</source>
          <target state="translated">Objective-C 클래스의 Kotlin 하위 클래스</target>
        </trans-unit>
        <trans-unit id="2607bec52d42f747a5225384e349fc0ccef2ced7" translate="yes" xml:space="preserve">
          <source>Kotlin supports SAM conversions for both Java and &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin interfaces&lt;/a&gt;. This support for Java means that Kotlin function literals can be automatically converted into implementations of Java interfaces with a single non-default method, as long as the parameter types of the interface method match the parameter types of the Kotlin function.</source>
          <target state="translated">Kotlin은 자바 및 &lt;a href=&quot;fun-interfaces&quot;&gt;Kotlin 인터페이스&lt;/a&gt; 모두에 대해 SAM 변환을 지원합니다 . 이 자바 지원은 인터페이스 메소드의 매개 변수 유형이 Kotlin 함수의 매개 변수 유형과 일치하는 한 Kotlin 함수 리터럴을 기본이 아닌 단일 메소드를 사용하여 Java 인터페이스 구현으로 자동 변환 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e4a28ec1a46419f171d723ee46383588cd9c1cbc" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimises out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;테일 재귀&lt;/a&gt; 라고하는 기능 프로그래밍 스타일을 지원합니다 . 이것은 일반적으로 루프를 사용하여 작성되는 일부 알고리즘은 재귀 함수를 사용하여 작성되지만 스택 오버플로의 위험이 없습니다. 함수가 &lt;code&gt;tailrec&lt;/code&gt; 수정 자로 표시되고 필요한 양식을 충족하면 컴파일러는 재귀를 최적화하여 대신 빠르고 효율적인 루프 기반 버전을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="a2baed6c5430ce0572e2f1a5bae6b4631f0f1c73" translate="yes" xml:space="preserve">
          <source>Kotlin supports a style of functional programming known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail recursion&lt;/a&gt;. This allows some algorithms that would normally be written using loops to instead be written using a recursive function, but without the risk of stack overflow. When a function is marked with the &lt;code&gt;tailrec&lt;/code&gt; modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop based version instead:</source>
          <target state="translated">Kotlin은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;꼬리 재귀&lt;/a&gt; 로 알려진 함수형 프로그래밍 스타일을 지원합니다 . 이렇게하면 일반적으로 루프를 사용하여 작성되는 일부 알고리즘이 대신 재귀 함수를 사용하여 작성되지만 스택 오버플로 위험이 없습니다. 함수가 &lt;code&gt;tailrec&lt;/code&gt; 수정 자로 표시되고 필요한 형식을 충족하면 컴파일러가 재귀를 최적화하여 대신 빠르고 효율적인 루프 기반 버전을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="f764f32b8a5f60d7b0c651002320db85fd7d539f" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the &lt;em&gt;Kotlin annotation processing tool&lt;/em&gt;(&lt;code&gt;kapt&lt;/code&gt;). Usage of kapt with Gradle is described on the &lt;a href=&quot;kapt&quot;&gt;kapt page&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 &lt;em&gt;Kotlin 주석 처리 도구&lt;/em&gt; ( &lt;code&gt;kapt&lt;/code&gt; ) 를 통한 음음 처리를 지원합니다 . Gradle과의 kapt 사용법은 kapt &lt;a href=&quot;kapt&quot;&gt;페이지&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f5d747f019181c1a771753e56710d47a2bbad6" translate="yes" xml:space="preserve">
          <source>Kotlin supports annonation processing via the Kotlin annotation processing tool &lt;a href=&quot;kapt&quot;&gt;&lt;code&gt;kapt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 Kotlin 주석 처리 도구 &lt;a href=&quot;kapt&quot;&gt; &lt;code&gt;kapt&lt;/code&gt; &lt;/a&gt; 를 통한 주석 처리를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="92bcfac7403d3cddfb4464119a784d92d81f9f9d" translate="yes" xml:space="preserve">
          <source>Kotlin supports local functions, i.e. a function inside another function:</source>
          <target state="translated">Kotlin은 로컬 함수, 즉 다른 함수 내부의 함수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="282b26637b1a5ff71051d95d88177e34b6cefc30" translate="yes" xml:space="preserve">
          <source>Kotlin supports single-parent class inheritance - so each class (except the root class &lt;code&gt;Any&lt;/code&gt;) has got exactly one parent class, called a &lt;em&gt;superclass&lt;/em&gt;. Kotlin wants you to think through your class design to make sure that it's actually safe to &lt;em&gt;subclass&lt;/em&gt; it, so classes are &lt;em&gt;closed&lt;/em&gt; by default and can't be inherited from unless you explicitly declare the class to be &lt;em&gt;open&lt;/em&gt; or &lt;em&gt;abstract&lt;/em&gt;. You can then subclass from that class by declaring a new class which mentions its parent class after a colon:</source>
          <target state="translated">Kotlin은 단일 부모 클래스 상속을 지원하므로 각 클래스 (루트 클래스 &lt;code&gt;Any&lt;/code&gt; 제외 )에는 &lt;em&gt;수퍼 클래스&lt;/em&gt; 라고하는 하나의 부모 클래스가 있습니다. Kotlin은 클래스 디자인을 통해 실제로 &lt;em&gt;서브 클래 싱&lt;/em&gt; 하는 것이 안전한지 확인 하기를 원하므로 클래스가 기본적으로 &lt;em&gt;닫히고&lt;/em&gt; 클래스를 &lt;em&gt;open&lt;/em&gt; 또는 &lt;em&gt;abstract&lt;/em&gt; 라고 명시 적으로 선언하지 않는 한 클래스를 상속받을 수 없습니다 . 그런 다음 콜론 뒤에 부모 클래스를 언급하는 새 클래스를 선언하여 해당 클래스에서 서브 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c701dab67e42733a07778c8e90d14a14d6115e0e" translate="yes" xml:space="preserve">
          <source>Kotlin supports the following operators and special symbols:</source>
          <target state="translated">Kotlin은 다음 연산자와 특수 기호를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b9f65c39eaf4fcfb17c2f522f10687c0e4404fdb" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers (&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt;), which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 적절한 클래스의 멤버로 선언 된 숫자 ( &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; )에 대한 표준 산술 연산 집합을 지원합니다 (하지만 컴파일러는 해당 명령어에 따라 호출을 최적화합니다). &lt;a href=&quot;operator-overloading&quot;&gt;연산자 오버로딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4887c0a9ca610838532432bde155538452979c8b" translate="yes" xml:space="preserve">
          <source>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions). See &lt;a href=&quot;operator-overloading&quot;&gt;Operator overloading&lt;/a&gt;.</source>
          <target state="translated">Kotlin은 적절한 클래스의 멤버로 선언 된 숫자에 대한 표준 산술 연산 세트를 지원합니다 (하지만 컴파일러는 해당 명령어에 대한 호출을 최적화합니다). &lt;a href=&quot;operator-overloading&quot;&gt;연산자 과부하를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8bfc686b943f3ad415464d9f2987e93b995ca8c" translate="yes" xml:space="preserve">
          <source>Kotlin supports traditional &lt;em&gt;break&lt;/em&gt; and &lt;em&gt;continue&lt;/em&gt; operators in loops. See &lt;a href=&quot;returns&quot;&gt;Returns and jumps&lt;/a&gt;.</source>
          <target state="translated">코 틀린은 기존의 지원 &lt;em&gt;중단을&lt;/em&gt; 하고 &lt;em&gt;계속&lt;/em&gt; 루프 연산자를. &lt;a href=&quot;returns&quot;&gt;리턴 및 점프를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d07ef64d55abdae6d6a123db33be555df8316b4" translate="yes" xml:space="preserve">
          <source>Kotlin supports trailing commas in the following cases:</source>
          <target state="translated">Kotlin은 다음과 같은 경우 후행 쉼표를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d836a05da6a45d7708b37e3a93892db605af05e1" translate="yes" xml:space="preserve">
          <source>Kotlin targets a wide range of the Java versions, including Java 6 and Java 7, where default methods in the interfaces are not allowed. For your convenience, the Kotlin compiler works around that limitation, but this workaround isn't compatible with the &lt;code&gt;default&lt;/code&gt; methods, introduced in Java 8.</source>
          <target state="translated">Kotlin은 인터페이스의 기본 메소드가 허용되지 않는 Java 6 및 Java 7을 포함한 광범위한 Java 버전을 대상으로합니다. 편의상 Kotlin 컴파일러는 이러한 제한을 해결하지만이 해결 방법은 Java 8에 도입 된 &lt;code&gt;default&lt;/code&gt; 방법 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7a3c3013cf9e37dd556eb25470f92f220350c10a" translate="yes" xml:space="preserve">
          <source>Kotlin to JavaScript</source>
          <target state="translated">코 틀린에서 JavaScript로</target>
        </trans-unit>
        <trans-unit id="09a30aded79f08fdd22e3766d5057679b6cb51d6" translate="yes" xml:space="preserve">
          <source>Kotlin treats some Java types specially. Such types are not loaded from Java &quot;as is&quot;, but are &lt;em&gt;mapped&lt;/em&gt; to corresponding Kotlin types. The mapping only matters at compile time, the runtime representation remains unchanged. Java's primitive types are mapped to corresponding Kotlin types (keeping &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; in mind):</source>
          <target state="translated">Kotlin은 일부 Java 유형을 특별히 처리합니다. 이러한 유형은 Java에서 &quot;있는 그대로&quot;로드되지 않지만 해당 Kotlin 유형에 &lt;em&gt;매핑&lt;/em&gt; 됩니다. 매핑은 컴파일 타임에만 중요하며 런타임 표현은 변경되지 않습니다. Java의 기본 유형은 해당 Kotlin 유형에 매핑됩니다 ( &lt;a href=&quot;#null-safety-and-platform-types&quot;&gt;플랫폼 유형&lt;/a&gt; 을 염두에 두십시오).</target>
        </trans-unit>
        <trans-unit id="768f1e9cdea1a9d60e4596098790dc6c5c883f4f" translate="yes" xml:space="preserve">
          <source>Kotlin turns the function pointer return type into a nullable &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; object. There is the need to explicitly check for &lt;code&gt;null&lt;/code&gt; first. We use &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis operator&lt;/a&gt; for that. The &lt;code&gt;cinterop&lt;/code&gt; tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.</source>
          <target state="translated">Kotlin은 함수 포인터 리턴 유형을 널 입력 가능 &lt;code&gt;CPointer&amp;lt;CFunction&amp;lt;..&amp;gt;&lt;/code&gt; 오브젝트로 변환합니다. &lt;code&gt;null&lt;/code&gt; 을 명시 적으로 먼저 확인해야합니다 . 우리는이를 위해 &lt;a href=&quot;../../reference/null-safety&quot;&gt;elvis 연산자&lt;/a&gt; 를 사용합니다. &lt;code&gt;cinterop&lt;/code&gt; 의 도구는 우리가 코 틀린에 개체를 호출하기 쉬운로 C 함수 포인터를 설정하는 데 도움이됩니다. 이것이 우리가 마지막 줄에서 한 일입니다.</target>
        </trans-unit>
        <trans-unit id="db8f21bde482b5a130cf00596109ec23d3d336d2" translate="yes" xml:space="preserve">
          <source>Kotlin uses a family of function types like &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; for declarations that deal with functions: &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt;.</source>
          <target state="translated">코 틀린 같은 기능 유형의 가족 사용 &lt;code&gt;(Int) -&amp;gt; String&lt;/code&gt; 선언에 대한 그 기능 거래 : &lt;code&gt;val onClick: () -&amp;gt; Unit = ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb4aa710f2c72b83ee921d5d3e539487fd005073" translate="yes" xml:space="preserve">
          <source>Kotlin uses the &lt;code&gt;libnative_&lt;/code&gt; prefix for all declarations in the created &lt;code&gt;libnative_api.h&lt;/code&gt; file. Let's present the mapping of the types in a more readable way:</source>
          <target state="translated">Kotlin은 작성된 &lt;code&gt;libnative_api.h&lt;/code&gt; 파일 의 모든 선언에 &lt;code&gt;libnative_&lt;/code&gt; 접두사를 사용 합니다. 보다 읽기 쉬운 방식으로 타입의 매핑을 제시해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="b58121b32bf1a1498b7715228a497191716fd48d" translate="yes" xml:space="preserve">
          <source>Kotlin was designed for easy interoperation with Java platform. It sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes. However, JavaScript is a dynamically-typed language, which means it does not check types in compile-time. You can freely talk to JavaScript from Kotlin via &lt;a href=&quot;dynamic-type&quot;&gt;dynamic&lt;/a&gt; types, but if you want the full power of Kotlin type system, you can create Kotlin headers for JavaScript libraries.</source>
          <target state="translated">Kotlin은 Java 플랫폼과 쉽게 상호 운용되도록 설계되었습니다. Java 클래스는 Kotlin 클래스로, Java는 Kotlin 클래스를 Java 클래스로 간주합니다. 그러나 JavaScript는 동적 형식 언어이므로 컴파일 타임에 형식을 확인하지 않습니다. &lt;a href=&quot;dynamic-type&quot;&gt;동적&lt;/a&gt; 유형을 통해 Kotlin에서 JavaScript와 자유롭게 대화 할 수 있지만 Kotlin 유형 시스템의 모든 기능을 원한다면 JavaScript 라이브러리 용 Kotlin 헤더를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4c0f3a3782b90edcee0e70de97ebb0b28520a70" translate="yes" xml:space="preserve">
          <source>Kotlin was first designed for easy interoperation with the Java platform: it sees Java classes as Kotlin classes, and Java sees Kotlin classes as Java classes.</source>
          <target state="translated">Kotlin은 Java 플랫폼과의 쉬운 상호 운용을 위해 처음 설계되었습니다. Java 클래스는 Kotlin 클래스로, Java는 Kotlin 클래스를 Java 클래스로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="487d5ff42a3055fc2a4cb28f3d53d445d59f1865" translate="yes" xml:space="preserve">
          <source>Kotlin will allow you to declare this property without initializing it, and you can set the property value at some point after construction (either directly or via a function). It is the responsibility of the class itself as well as its users to take care not to read the property before it has been set, and Kotlin allows you to write code that reads &lt;code&gt;name&lt;/code&gt; as if it were an ordinary, non-nullable property. However, the compiler is unable to enforce correct usage, so if the property is read before it has been set, an &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; will be thrown at runtime.</source>
          <target state="translated">Kotlin은이 속성을 초기화하지 않고 선언 할 수 있으며 생성 후 어느 시점에서 (직접 또는 함수를 통해) 속성 값을 설정할 수 있습니다. 클래스 자체와 속성을 설정하기 전에 속성을 읽지 않도록주의하는 것은 클래스 자체의 책임이며 Kotlin에서는 &lt;code&gt;name&lt;/code&gt; 을 일반 null이 아닌 속성처럼 읽는 코드를 작성할 수 있습니다 . 그러나 컴파일러에서 올바른 사용법을 적용 할 수 없으므로 속성을 설정하기 전에 읽은 경우 런타임에 &lt;code&gt;UninitializedPropertyAccessException&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b3a556e28261e02ebafecde169f3b3513ca13075" translate="yes" xml:space="preserve">
          <source>Kotlin works quite smoothly with Spring Boot and many of the steps found on the &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; for creating a RESTful service can be followed verbatim for Kotlin. There are some minor differences however when it comes to defining the Gradle configuration and the project layout structure, as well as the initialization code.</source>
          <target state="translated">Kotlin은 Spring Boot와 매우 원활하게 작동 하며 RESTful 서비스를 만들기위한 &lt;a href=&quot;https://spring.io/guides&quot;&gt;Spring Guides&lt;/a&gt; 에있는 많은 단계 를 Kotlin에 대해 그대로 사용할 수 있습니다. 그러나 Gradle 구성과 프로젝트 레이아웃 구조 및 초기화 코드를 정의 할 때 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ea688f8664ba8f8dabcebd91046161c6146f3c" translate="yes" xml:space="preserve">
          <source>Kotlin works with different &lt;a href=&quot;build-tools&quot;&gt;build tools&lt;/a&gt;, so if we're using a standard tool such as Ant, Maven or Gradle, the process for setting up a Kotlin project is no different to any other language or library that integrates with these tools. Where there are some minor requirements and differences is when using JBS, which is the internal build system that IntelliJ IDEA uses, which is also supported on TeamCity.</source>
          <target state="translated">Kotlin은 다른 &lt;a href=&quot;build-tools&quot;&gt;빌드 도구&lt;/a&gt; 와 함께 작동 하므로 Ant, Maven 또는 Gradle과 같은 표준 도구를 사용하는 경우 Kotlin 프로젝트를 설정하는 프로세스는 이러한 도구와 통합되는 다른 언어 나 라이브러리와 다르지 않습니다. 사소한 요구 사항과 차이점이있는 경우 JBS (IntelliJ IDEA에서 사용하는 내부 빌드 시스템)를 사용할 때 TeamCity에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="457e307b979be376836ec99d4487123ba8ace79f" translate="yes" xml:space="preserve">
          <source>Kotlin's approach to working with asynchronous code is using coroutines, which is the idea of suspendable computations, i.e. the idea that a function can suspend its execution at some point and resume later on.</source>
          <target state="translated">Kotlin의 비동기 코드 작업 방식은 코 루틴을 사용하는 것으로, 이는 일시 중단 가능한 계산, 즉 함수가 특정 시점에서 실행을 일시 중단하고 나중에 다시 시작할 수 있다는 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="b5ab858d5d3418daf57f2ff97756dc06bfcd23b9" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation generation tool is called &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;. See the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; for usage instructions.</source>
          <target state="translated">Kotlin의 문서 생성 도구를 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt; 라고 합니다. 사용법에 대해서는 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3af1e3ba09d170fd30c3af38c47add3814785926" translate="yes" xml:space="preserve">
          <source>Kotlin's documentation syntax is called &lt;em&gt;KDoc&lt;/em&gt;. A KDoc block is placed above the construct it describes, and begins with &lt;code&gt;/**&lt;/code&gt; and ends with &lt;code&gt;*/&lt;/code&gt; (possibly on one line; if not, each intermediate lines should start with an aligned asterisk). The first block of text is the summary; then, you can use &lt;em&gt;block tags&lt;/em&gt; to provide information about specific parts of the construct. Some block tags are &lt;code&gt;@param&lt;/code&gt; for function parameters and generic type parameters, and &lt;code&gt;@return&lt;/code&gt; for the return value. You can link to identifiers inside brackets. All the text outside of links and block tag names is in Markdown format.</source>
          <target state="translated">Kotlin의 문서 구문을 &lt;em&gt;KDoc&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . KDoc 블록은 설명하는 구문 위에 위치하며 &lt;code&gt;/**&lt;/code&gt; 로 시작하고 &lt;code&gt;*/&lt;/code&gt; 로 끝납니다 (한 줄에있을 수 있습니다. 그렇지 않은 경우 각 중간 줄은 정렬 된 별표로 시작해야합니다). 첫 번째 텍스트 블록은 요약입니다. 그런 다음 &lt;em&gt;블록 태그&lt;/em&gt; 를 사용 하여 구성의 특정 부분에 대한 정보를 제공 할 수 있습니다 . 일부 블록 태그는 함수 매개 변수 및 일반 형식 매개 변수의 경우 &lt;code&gt;@param&lt;/code&gt; 이고 &lt;code&gt;@return&lt;/code&gt; 경우 @return 입니다. 괄호 안의 식별자에 연결할 수 있습니다. 링크 및 블록 태그 이름 외부의 모든 텍스트는 마크 다운 형식입니다.</target>
        </trans-unit>
        <trans-unit id="053760c0ead482ee5ae43f8e0bead527a31d7dd2" translate="yes" xml:space="preserve">
          <source>Kotlin's generics are a little different from Java's (see &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt;). When importing Java types to Kotlin we perform some conversions:</source>
          <target state="translated">Kotlin의 제네릭은 Java와 약간 다릅니다 ( &lt;a href=&quot;generics&quot;&gt;Generics&lt;/a&gt; 참조 ). Java 유형을 Kotlin으로 가져올 때 몇 가지 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9ce324f37629b9d5fdf6ee64821674d4e61b9c46" translate="yes" xml:space="preserve">
          <source>Kotlin's loops are similar to Python's. &lt;code&gt;for&lt;/code&gt; iterates over anything that is &lt;em&gt;iterable&lt;/em&gt; (anything that has an &lt;code&gt;iterator()&lt;/code&gt; function that provides an &lt;code&gt;Iterator&lt;/code&gt; object), or anything that is itself an iterator:</source>
          <target state="translated">Kotlin의 루프는 Python과 유사합니다. &lt;code&gt;for&lt;/code&gt; 무엇이든을 반복하다 &lt;em&gt;반복자&lt;/em&gt; (AN이 아무것도 &lt;code&gt;iterator()&lt;/code&gt; 제공 기능 &lt;code&gt;Iterator&lt;/code&gt; 자체의 반복자, 또는 어떤 개체) :</target>
        </trans-unit>
        <trans-unit id="ba05695800cb8016bdf03b211c131a78afee8e93" translate="yes" xml:space="preserve">
          <source>Kotlin's object model is substantially different from Python's. Most importantly, classes are &lt;em&gt;not&lt;/em&gt; dynamically modifiable at runtime! (There are some limited exceptions to this, but you generally shouldn't do it. However, it &lt;em&gt;is&lt;/em&gt; possible to dynamically &lt;em&gt;inspect&lt;/em&gt; classes and objects at runtime with a feature called &lt;em&gt;reflection&lt;/em&gt; - this can be useful, but should be judiciously used.) All properties (attributes) and functions that might ever be needed on a class must be declared either directly in the class body or as &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;extension functions&lt;/em&gt;&lt;/a&gt;, so you should think carefully through your class design.</source>
          <target state="translated">코 틀린의 객체 모델은 파이썬과 실질적으로 다릅니다. 가장 중요한 점 은 런타임에 클래스를 동적으로 수정할 수 &lt;em&gt;없다는 것입니다&lt;/em&gt; ! (이이 일부 제한 예외,하지만 당신은 일반적으로 그것을하지 말아야하지만,. &lt;em&gt;입니다&lt;/em&gt; 동적으로 할 수 &lt;em&gt;검사&lt;/em&gt; 클래스와 기능이라고하여 런타임에 객체 &lt;em&gt;반사&lt;/em&gt; -.이 유용 할 수 있지만 신중하게 사용되어야한다) 모든 클래스에서 필요할 수있는 속성 (속성) 및 함수는 클래스 본문에서 직접 또는 &lt;a href=&quot;extension-functionsproperties&quot;&gt;&lt;em&gt;확장 함수&lt;/em&gt;&lt;/a&gt; 로 선언해야 하므로 클래스 디자인을 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2a59f6487d643d44ccac72e26090969f3853d89" translate="yes" xml:space="preserve">
          <source>Kotlin's standard library has a &lt;code&gt;TODO()&lt;/code&gt; function that will always throw a &lt;code&gt;NotImplementedError&lt;/code&gt;. Its return type is &lt;code&gt;Nothing&lt;/code&gt; so it can be used regardless of expected type. There's also an overload that accepts a reason parameter:</source>
          <target state="translated">Kotlin의 표준 라이브러리에는 항상 &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생 시키는 &lt;code&gt;TODO()&lt;/code&gt; 함수가 있습니다. 반환 유형은 &lt;code&gt;Nothing&lt;/code&gt; 이므로 예상 유형에 관계없이 사용할 수 있습니다. 이유 매개 변수를 허용하는 과부하도 있습니다.</target>
        </trans-unit>
        <trans-unit id="970540431e074be00582837c3e83cd1ca1a5ee04" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 형식 시스템은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 라고도하는 코드에서 null 참조의 위험을 제거하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8b3b3c2fce26ced6c3f89e4969b12ebc4e57fb47" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed at eliminating the danger of null references from code, also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 유형 시스템은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions&quot;&gt;The Billion Dollar Mistake&lt;/a&gt; 로 알려진 코드에서 null 참조의 위험을 제거하는 데 목적 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ae5912eae484ffd44f09a774b363dbba8158106" translate="yes" xml:space="preserve">
          <source>Kotlin's type system is aimed to eliminate &lt;code&gt;NullPointerException&lt;/code&gt;'s from our code. The only possible causes of NPE's may be:</source>
          <target state="translated">Kotlin의 형식 시스템은 코드에서 &lt;code&gt;NullPointerException&lt;/code&gt; 을 제거하는 것을 목표로 합니다. NPE의 유일한 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b21dfbe494a9eaaf724f5a9592dd235fdd14650" translate="yes" xml:space="preserve">
          <source>Kotlin, as a language, provides only minimal low-level APIs in its standard library to enable various other libraries to utilize coroutines. Unlike many other languages with similar capabilities, &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; are not keywords in Kotlin and are not even part of its standard library. Moreover, Kotlin's concept of &lt;em&gt;suspending function&lt;/em&gt; provides a safer and less error-prone abstraction for asynchronous operations than futures and promises.</source>
          <target state="translated">Kotlin은 언어로서 표준 라이브러리에서 최소한의 저수준 API 만 제공하여 다양한 다른 라이브러리가 코 루틴을 활용할 수 있도록합니다. 비슷한 기능을 가진 다른 많은 언어와 달리 &lt;code&gt;async&lt;/code&gt; 및 &lt;code&gt;await&lt;/code&gt; 는 Kotlin의 키워드가 아니며 표준 라이브러리의 일부도 아닙니다. 또한 Kotlin의 &lt;em&gt;일시 중단 기능&lt;/em&gt; 개념은 미래와 약속보다 비동기 작업에 대해 안전하고 오류가 발생하기 쉬운 추상화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1aefdadaf18a27e16e25f47128252ff2aeb47fe6" translate="yes" xml:space="preserve">
          <source>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator. This is done via special declarations called &lt;em&gt;extensions&lt;/em&gt;. Kotlin supports &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;.</source>
          <target state="translated">C # 및 Gosu와 유사한 Kotlin은 클래스에서 상속하거나 Decorator와 같은 모든 유형의 디자인 패턴을 사용하지 않고도 새로운 기능으로 클래스를 확장 할 수 있습니다. 이는 &lt;em&gt;extensions&lt;/em&gt; 라는 특수 선언을 통해 수행됩니다 . Kotlin은 &lt;em&gt;확장 기능&lt;/em&gt; 및 &lt;em&gt;확장 속성을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="66f1754b6d5c7a12dce00bd5e634c25ddb75bf52" translate="yes" xml:space="preserve">
          <source>Kotlin/JS</source>
          <target state="translated">Kotlin/JS</target>
        </trans-unit>
        <trans-unit id="b4529ea374c3a4cde07a41aa987a9b048c623d50" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (Classic back-end)</source>
          <target state="translated">Kotlin / JS (기본 백엔드)</target>
        </trans-unit>
        <trans-unit id="4c111df440b988d7ac0f881b0ae8eeed10bb5e43" translate="yes" xml:space="preserve">
          <source>Kotlin/JS (IR-based)</source>
          <target state="translated">Kotlin / JS (IR 기반)</target>
        </trans-unit>
        <trans-unit id="3409f54fa5231194c2d7cb0f9009c3222e1a2109" translate="yes" xml:space="preserve">
          <source>Kotlin/JS Overview</source>
          <target state="translated">Kotlin / JS 개요</target>
        </trans-unit>
        <trans-unit id="5579b6ef038f8f8ca2fe985b676250979f056cbe" translate="yes" xml:space="preserve">
          <source>Kotlin/JS allows you to &lt;strong&gt;leverage powerful browser and web APIs&lt;/strong&gt; in a type-safe fashion. Create, modify and interact with elements in the Document Object Model (DOM), use Kotlin code to control the rendering of &lt;code&gt;canvas&lt;/code&gt; or WebGL components, and enjoy access to many more of the features supported in modern browsers.</source>
          <target state="translated">Kotlin / JS를 사용하면 유형이 안전한 방식으로 &lt;strong&gt;강력한 브라우저 및 웹 API&lt;/strong&gt; 를 &lt;strong&gt;활용할&lt;/strong&gt; 수 있습니다 . DOM (문서 개체 모델)의 요소를 생성, 수정 및 상호 작용하고 Kotlin 코드를 사용하여 &lt;code&gt;canvas&lt;/code&gt; 또는 WebGL 구성 요소 의 렌더링을 제어하고 최신 브라우저에서 지원되는 더 많은 기능에 액세스 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
