<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="49301d7c0ca361c41d110b3bca3a6ef2c53c1486" translate="yes" xml:space="preserve">
          <source>They also can be used in return statements of functions returning the context object.</source>
          <target state="translated">컨텍스트 객체를 반환하는 함수의 return 문에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e6ad519d848a011249fae6e51a09e8caed4ec20" translate="yes" xml:space="preserve">
          <source>They can't be passed as reified type arguments.</source>
          <target state="translated">그것들은 refined type 인수로 전달 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f968b20031a0c4e81acc38a3f23bdedaba5b962" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (i.e. &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="translated">클래스 리터럴 표현식 (예 : &lt;code&gt;I::class&lt;/code&gt; ) 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="31bcc86b1bb409efa1776fef24979f29b2bad523" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (such as &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="translated">클래스 리터럴 표현식 (예 : &lt;code&gt;I::class&lt;/code&gt; ) 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2f0701452411de1234771e67765d254ade0b6df7" translate="yes" xml:space="preserve">
          <source>They can't be used on the right hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="translated">이들은 오른쪽에 이용 될 수는 &lt;code&gt;is&lt;/code&gt; 검사한다.</target>
        </trans-unit>
        <trans-unit id="a244b209eab02673f1fb27177884b364b4d4031d" translate="yes" xml:space="preserve">
          <source>They can't be used on the right-hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="translated">그들은 오른쪽에 이용 될 수 &lt;code&gt;is&lt;/code&gt; 검사한다.</target>
        </trans-unit>
        <trans-unit id="f1d1a7c20f6efa1c87f68abf4cdd98085a534c8a" translate="yes" xml:space="preserve">
          <source>They include sample projects, which can serve as jumping-off points for your own projects, and contain useful snippets and patterns.</source>
          <target state="translated">여기에는 자체 프로젝트의 시작 지점 역할을 할 수있는 샘플 프로젝트가 포함되며 유용한 스 니펫 및 패턴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="398723a13324bec77451c1ae01057e1ef7af3705" translate="yes" xml:space="preserve">
          <source>They must be member functions or &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;;</source>
          <target state="translated">멤버 함수 또는 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d532a698fc6a89ca0085db59fd5aa194790955a6" translate="yes" xml:space="preserve">
          <source>They must have a single parameter;</source>
          <target state="translated">그것들은 단일 파라미터를 가져야합니다;</target>
        </trans-unit>
        <trans-unit id="91414177a4c44f1c365d06f986fa21be74b2196d" translate="yes" xml:space="preserve">
          <source>They will be compiled accordingly:</source>
          <target state="translated">그에 따라 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="4df440c5a2dac5df94e2c6decf7738ac3f8470ab" translate="yes" xml:space="preserve">
          <source>Third value.</source>
          <target state="translated">세번째 가치.</target>
        </trans-unit>
        <trans-unit id="65054a6c60d19f99f3ba82de08ae0a53fc9c01d3" translate="yes" xml:space="preserve">
          <source>This API can be used to group a collection by key and fold each group simultaneously. For example, it can be used to count the number of words starting with each letter:</source>
          <target state="translated">이 API를 사용하여 키별로 모음을 그룹화하고 각 그룹을 동시에 접을 수 있습니다. 예를 들어, 각 문자로 시작하는 단어 수를 계산하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e92a8ba9a486d6b6f5f3bfcee1ee9e16e21ffe" translate="yes" xml:space="preserve">
          <source>This Expression</source>
          <target state="translated">이 표현</target>
        </trans-unit>
        <trans-unit id="39d8e7ef05f8d1193ddfe60ed385361228082346" translate="yes" xml:space="preserve">
          <source>This allows the Java Persistence API (JPA) to instantiate a class although it doesn't have the zero-parameter constructor from Kotlin or Java point of view (see the description of &lt;code&gt;kotlin-jpa&lt;/code&gt; plugin &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;below&lt;/a&gt;).</source>
          <target state="translated">이것은 Java Persistence API (JPA)가 Kotlin 또는 Java 관점에서 0 매개 변수 생성자를 갖지 않지만 클래스를 인스턴스화 할 수있게합니다 ( &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;아래&lt;/a&gt; 의 &lt;code&gt;kotlin-jpa&lt;/code&gt; 플러그인 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="262a7c17763f126ac70f16b74664e0c2732654ca" translate="yes" xml:space="preserve">
          <source>This allows the user code to not pass an extra &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; parameter in basic coroutine builders like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt;, but still provide easy access to coroutine context.</source>
          <target state="translated">이를 통해 사용자 코드 는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt; 와 같은 기본 코 루틴 빌더에서 추가 &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; 매개 변수를 전달하지 않아도 코 루틴 컨텍스트에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb2da247bb9f320229aba7d44d4da4813d52b5e8" translate="yes" xml:space="preserve">
          <source>This allows us to write:</source>
          <target state="translated">이를 통해 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2943eee5e149bda0a3b90788c4e427a3f77fb555" translate="yes" xml:space="preserve">
          <source>This also a reason why, in these examples, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">이 예제에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; 가 항상 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 작성된 코 루틴에 설치 되는 이유이기도 합니다. 메인 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 범위에서 실행되는 코 루틴에 예외 핸들러를 설치하는 것은 의미가 없습니다 . 메인 핸들러는 설치된 핸들러에도 불구하고 자식이 예외로 완료되면 항상 취소되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="369f2b1361dad7365016272a8691f3b6c2f5f7b0" translate="yes" xml:space="preserve">
          <source>This also works in &lt;a href=&quot;multi-declarations&quot;&gt;destructuring declarations&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;multi-declarations&quot;&gt;선언&lt;/a&gt; 을 파괴하는 데 에도 효과적입니다 .</target>
        </trans-unit>
        <trans-unit id="7624b3ac5961056978ec90a7581d578f33bbbb61" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a JVM method.</source>
          <target state="translated">이 주석은 JVM 메소드로 컴파일 될 때 함수가 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cbf5d9ab056e2f21c12f9f19d919382afdc1ec0d" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method in Kotlin/JVM and Kotlin/Native.</source>
          <target state="translated">이 주석은 Kotlin / JVM 및 Kotlin / Native에서 플랫폼 메소드로 컴파일 할 때 함수에서 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b67d7593eb58defe040aee620d9f9dc5b7b870b" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method.</source>
          <target state="translated">이 주석은 플랫폼 메소드로 컴파일 될 때 함수가 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="53852272acd887d2ace151213b2a79c6186dd5ad" translate="yes" xml:space="preserve">
          <source>This annotation is intended for &lt;em&gt;rare cases&lt;/em&gt; when API designer needs to hide Kotlin-specific target from Java API while keeping it a part of Kotlin API so the resulting API is idiomatic for both languages.</source>
          <target state="translated">이 주석은위한 것입니다 &lt;em&gt;드문 경우&lt;/em&gt; 결과 API는 두 언어에 대한 관용적 그래서 자바 API에서 숨기기 코 틀린 특정 대상에 대한 API 디자이너의 요구가 코 틀린의 API의 일부를 유지하면서 때.</target>
        </trans-unit>
        <trans-unit id="f7ff9954f76ed995dd9da4bc5f1699538f3cd9e5" translate="yes" xml:space="preserve">
          <source>This annotation is only applicable to &lt;code&gt;expect&lt;/code&gt; annotation classes in multi-platform projects and marks that class as &quot;optional&quot;. Optional expected class is allowed to have no corresponding actual class on the platform. Optional annotations can only be used to annotate something, not as types in signatures. If an optional annotation has no corresponding actual class on a platform, the annotation entries where it's used are simply erased when compiling code on that platform.</source>
          <target state="translated">이 주석은 다중 플랫폼 프로젝트에서 주석 클래스 를 &lt;code&gt;expect&lt;/code&gt; 할 때만 해당 클래스를 &quot;선택&quot;으로 표시합니다. 선택적 예상 클래스는 플랫폼에서 해당하는 실제 클래스를 가질 수 없습니다. 선택적 주석은 서명의 유형이 아닌 무언가에 주석을 달기 위해서만 사용할 수 있습니다. 선택적 주석에 플랫폼에서 해당하는 실제 클래스가없는 경우 해당 플랫폼에서 코드를 컴파일 할 때 주석이 사용 된 주석 항목이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="c1b9122ad4cc089c09a766a63290941217a27add" translate="yes" xml:space="preserve">
          <source>This annotation is present on any class file produced by the Kotlin compiler and is read by the compiler and reflection. Parameters have very short JVM names on purpose: these names appear in all generated class files, and we'd like to reduce their size.</source>
          <target state="translated">이 주석은 Kotlin 컴파일러가 생성 한 클래스 파일에 있으며 컴파일러와 리플렉션에서 읽습니다. 매개 변수는 의도적으로 매우 짧은 JVM 이름을 갖습니다.이 이름은 생성 된 모든 클래스 파일에 나타나며 크기를 줄이려고합니다.</target>
        </trans-unit>
        <trans-unit id="10a19875cc351d84fe5e296411c863dd2553261e" translate="yes" xml:space="preserve">
          <source>This annotation marks the experimental preview of the standard library API for measuring time and working with durations.</source>
          <target state="translated">이 주석은 시간 측정 및 기간 작업을위한 표준 라이브러리 API의 실험적 미리보기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="08e24e4cbc4d173492beb5ffd4d4ddb94a113383" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">이 주석은 실험적인 것으로 간주되는 표준 라이브러리 API를 표시하며 표준 라이브러리에 대해 제공되는 &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;일반적인 호환성 보증&lt;/a&gt; 대상이 아닙니다 . 이러한 API의 동작이 변경되거나 추가 릴리스에서 API가 완전히 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="400bdfa2156af296817e663103c3f69c483eb8d7" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">이 주석은 실험적인 것으로 간주되는 표준 라이브러리 API를 표시하며 표준 라이브러리에 대해 제공되는 &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;일반적인 호환성 보증&lt;/a&gt; 대상이 아닙니다 . 이러한 API의 동작이 변경되거나 추가 릴리스에서 API가 완전히 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a3b2ae9c5594175372b79e16080724e6e8baa3b" translate="yes" xml:space="preserve">
          <source>This approach requires a series of changes in how we program, in particular</source>
          <target state="translated">이 접근법은 특히 프로그래밍 방식에 대한 일련의 변경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="caabd1756e7a5fe69a248020021b58534dfbff4d" translate="yes" xml:space="preserve">
          <source>This behavior is correct but it can be very inconvenient for some libraries. So it is possible to specify in the &lt;code&gt;.def&lt;/code&gt; file which of the included headers are to be imported. The separate declarations from other headers can also be imported in case of direct dependencies.</source>
          <target state="translated">이 동작은 정확하지만 일부 라이브러리에서는 매우 불편할 수 있습니다. 따라서 포함 된 헤더 중 가져올 헤더를 &lt;code&gt;.def&lt;/code&gt; 파일 에 지정할 수 있습니다. 직접 종속성의 경우 다른 헤더에서 별도의 선언을 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b0989aa993ac0e544c959f288dcd6e31817be1" translate="yes" xml:space="preserve">
          <source>This behavior is similar to &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;, which also allow you to access the members of the receiver object inside the body of the function.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 와 유사하며 함수 본문 내에서 수신자 오브젝트의 멤버에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e20a24097999574b06c858b7503368f6bbdeb55a" translate="yes" xml:space="preserve">
          <source>This callback method should call one of these two methods:</source>
          <target state="translated">이 콜백 메소드는 다음 두 메소드 중 하나를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="216d2a3ecca96db5ee19a6d39eef11e98c9f0bf5" translate="yes" xml:space="preserve">
          <source>This can be effectively combined with other idioms, leading to shorter code. E.g. with the &lt;em&gt;when&lt;/em&gt;-expression:</source>
          <target state="translated">이것은 다른 관용구와 효과적으로 결합되어 코드가 더 짧아집니다. 예를 들어 &lt;em&gt;when&lt;/em&gt; -expression 과 함께 :</target>
        </trans-unit>
        <trans-unit id="a3b4ad6a40906907f86d5ceb0160f0fc35e4272e" translate="yes" xml:space="preserve">
          <source>This can be useful for creating &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; literals with less noise, for example:</source>
          <target state="translated">노이즈가 적은 &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;맵&lt;/a&gt; 리터럴 을 만드는 데 유용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e1ff87841658b954b989c8097e33f6cc0f4c4fa" translate="yes" xml:space="preserve">
          <source>This check is only available for the properties that are lexically accessible, i.e. declared in the same type or in one of the outer types, or at top level in the same file.</source>
          <target state="translated">이 검사는 사 전적으로 액세스 가능한 속성, 즉 동일한 유형 또는 외부 유형 중 하나 또는 동일한 파일에서 최상위 수준으로 선언 된 속성에 대해서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e6d8ea08a6d2f26902035e61567b7b01f67c89" translate="yes" xml:space="preserve">
          <source>This class cannot be either co- or contravariant in &lt;code&gt;T&lt;/code&gt;. And this imposes certain inflexibilities. Consider the following function:</source>
          <target state="translated">이 클래스는 &lt;code&gt;T&lt;/code&gt; 의 공변량 또는 반 변형 일 수 없습니다 . 그리고 이것은 특정 융통성을 부과합니다. 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5e57ca69fb23b5a69bf1e170dc12314fcab3e46e" translate="yes" xml:space="preserve">
          <source>This class is deprecated in favor of a more general approach provided by &lt;a href=&quot;../-requires-opt-in/index&quot;&gt;RequiresOptIn&lt;/a&gt;/&lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt;.</source>
          <target state="translated">이 클래스가 제공하는보다 일반적인 접근 방식에 찬성되지 않습니다 &lt;a href=&quot;../-requires-opt-in/index&quot;&gt;RequiresOptIn&lt;/a&gt; / &lt;a href=&quot;../-opt-in/index&quot;&gt;옵트 인&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfa1db139b7b160a14b6c47d1a1495d378da6d44" translate="yes" xml:space="preserve">
          <source>This class is experimental itself and can only be used with the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 실험적이며 컴파일러 인수 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 과 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5fdf32c20c754f3849efeb2ffb6fd9fe85ddd31" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.</source>
          <target state="translated">이 클래스는 읽기 전용 목록을 구현하는 데 도움을주기 위해 동시 수정 추적을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3649d86d1c264225e25ee01e6d003c299727a7d0" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.</source>
          <target state="translated">이 클래스는 읽기 전용 세트를 구현하는 데 도움을주기 위해 동시 수정 추적을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d10d84799d8bbf78fb0535ad9184c4c6ada6aa07" translate="yes" xml:space="preserve">
          <source>This class is intended to implement different file traversal methods. It allows to iterate through all files inside a given directory.</source>
          <target state="translated">이 클래스는 다른 파일 순회 메소드를 구현하기위한 것입니다. 주어진 디렉토리 내의 모든 파일을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322e62ea251e48658a034c9b427e81ba230bb5e9" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36e06591e999a4c0d4c4171fd2c0675fb1b16fc" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ba51153ea7889b4c1f1704d375fc98842fa90a" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de458f3166219b6408ccb11d5d011e7dedd5974" translate="yes" xml:space="preserve">
          <source>This code calculates the fixpoint of cosine, which is a mathematical constant. It simply calls Math.cos repeatedly starting at 1.0 until the result doesn't change any more, yielding a result of 0.7390851332151611 for the specified &lt;code&gt;eps&lt;/code&gt; precision. The resulting code is equivalent to this more traditional style:</source>
          <target state="translated">이 코드는 수학 상수 인 코사인의 고정 점을 계산합니다. 결과가 더 이상 변경되지 않을 때까지 1.0부터 반복적으로 Math.cos를 호출하여 지정된 &lt;code&gt;eps&lt;/code&gt; 정밀도에 대해 0.7390851332151611의 결과를 생성합니다 . 결과 코드는 이보다 전통적인 스타일과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a6ca25f95d0c9b2687336e1d3e2569e0a9d58bd7" translate="yes" xml:space="preserve">
          <source>This code prints &quot;&lt;em&gt;Class method&lt;/em&gt;&quot;.</source>
          <target state="translated">이 코드는 &quot; &lt;em&gt;Class method&lt;/em&gt; &quot;를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="1c9fb24eb61454c344b8e7f5093f2e83751a14fd" translate="yes" xml:space="preserve">
          <source>This code specifies an action to be performed on the &quot;hello&quot; button click. Note that with lambdas this code looks rather concise written directly in Kotlin:</source>
          <target state="translated">이 코드는 &quot;hello&quot;버튼 클릭시 수행 할 동작을 지정합니다. 람다의 경우이 코드는 Kotlin에서 직접 작성된 다소 간결하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="655348672aba46b323a130d4745ad11efc796bd4" translate="yes" xml:space="preserve">
          <source>This code will be compiled &quot;as is&quot;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in Kotlin becomes &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in the generated JavaScript code.</source>
          <target state="translated">이 코드는 &quot;있는 그대로&quot;컴파일됩니다 &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 코 틀린에이된다 &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 생성 된 자바 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="f097f6de0cc3b7d0fc741d38a1eac67ae2fca6f2" translate="yes" xml:space="preserve">
          <source>This code will launch a long-running operation without blocking the main thread. The &lt;code&gt;preparePost&lt;/code&gt; is what's called a &lt;code&gt;suspendable function&lt;/code&gt;, thus the keyword &lt;code&gt;suspend&lt;/code&gt; prefixing it. What this means as stated above, is that the function will execute, pause execution and resume at some point in time.</source>
          <target state="translated">이 코드는 메인 스레드를 차단하지 않고 장기 실행 작업을 시작합니다. &lt;code&gt;preparePost&lt;/code&gt; 는 불리는 무슨이다 &lt;code&gt;suspendable function&lt;/code&gt; 따라서 키워드가 &lt;code&gt;suspend&lt;/code&gt; 붙임. 위에서 언급 한 바와 같이이 기능은 특정 시점에서 함수가 실행, 실행 일시 중지 및 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="940a39107db356b9719bbf9342038d41ba48b8c2" translate="yes" xml:space="preserve">
          <source>This code works slower, but we still don't get &quot;Counter = 100000&quot; at the end, because volatile variables guarantee linearizable (this is a technical term for &quot;atomic&quot;) reads and writes to the corresponding variable, but do not provide atomicity of larger actions (increment in our case).</source>
          <target state="translated">이 코드는 느리게 작동하지만 휘발성 변수는 선형화 가능 ( &quot;원자&quot;의 기술적 용어 임) 읽기와 쓰기를 보장하지만 원 자성을 제공하지 않기 때문에 끝에 &quot;카운터 = 100000&quot;을 얻지 못합니다. 더 큰 행동 (우리의 경우 증가).</target>
        </trans-unit>
        <trans-unit id="19e35196b450d82e8abc869e0b8d2aedd7f24d49" translate="yes" xml:space="preserve">
          <source>This code works very slowly, because it does &lt;em&gt;fine-grained&lt;/em&gt; thread-confinement. Each individual increment switches from multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context to the single-threaded context using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext(counterContext)&lt;/a&gt; block.</source>
          <target state="translated">이 코드는 &lt;em&gt;세분화 된&lt;/em&gt; 스레드 조합을 수행하기 때문에 매우 느리게 작동합니다 . 각 개별 증분은 다중 스레드 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;디스패처&lt;/a&gt; 에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext (counterContext)&lt;/a&gt; 블록을 사용하여 기본 스레드를 단일 스레드 컨텍스트로 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="d15be2d04edeeec0e153a44e5ef98d0f0d439b37" translate="yes" xml:space="preserve">
          <source>This collection has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">이 컬렉션의 크기는 &lt;code&gt;groupCount + 1&lt;/code&gt; 여기서 &lt;code&gt;groupCount&lt;/code&gt; 는 정규식의 그룹 수입니다. 그룹은 1에서 &lt;code&gt;groupCount&lt;/code&gt; 로 색인화되며 색인이 0 인 그룹은 전체 일치 항목에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c28fcaf55859958d617c24c43acf5fe9a19ed1ae" translate="yes" xml:space="preserve">
          <source>This command will produce a &lt;code&gt;png.klib&lt;/code&gt; compiled library and &lt;code&gt;png-build/kotlin&lt;/code&gt; directory containing Kotlin source code for the library.</source>
          <target state="translated">이 명령은 &lt;code&gt;png.klib&lt;/code&gt; 컴파일 라이브러리와 라이브러리의 Kotlin 소스 코드를 포함하는 &lt;code&gt;png-build/kotlin&lt;/code&gt; 디렉토리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="31a6ce4f29e9c4d59e89de3b53b3a11728189b63" translate="yes" xml:space="preserve">
          <source>This contract specifies that:</source>
          <target state="translated">이 계약은 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d6dc362cdb3af439d7414c31776e978f9f9881cd" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="translated">이 규칙은 &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;괄호 외부에 람다 식&lt;/a&gt; 을 전달하는 것과 함께 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ 스타일&lt;/a&gt; 코드를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="615ee8a7977549b4df34e13628dfcadf465d6b63" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb308959(v=msdn.10)&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="translated">이 규칙은 &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;괄호 외부에 람다 식&lt;/a&gt; 을 전달하는 것과 함께 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb308959(v=msdn.10)&quot;&gt;LINQ 스타일&lt;/a&gt; 코드를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="78e5afd48b07123042fcce6bdde782478e4769ee" translate="yes" xml:space="preserve">
          <source>This could be an issue for Java-interoperability, so Kotlin 1.3 introduces the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation. Methods, annotated with this annotation will be generated as &lt;code&gt;default&lt;/code&gt; methods for JVM:</source>
          <target state="translated">이것은 Java 상호 운용성에 문제가 될 수 있으므로 Kotlin 1.3에는 &lt;code&gt;@JvmDefault&lt;/code&gt; 주석이 도입되었습니다 . 이 주석으로 주석이 달린 메소드는 JVM의 &lt;code&gt;default&lt;/code&gt; 메소드 로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b179e178b1137230407a1019e7d8b4984a1d071b" translate="yes" xml:space="preserve">
          <source>This creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level. You can then access it in the build script for:</source>
          <target state="translated">이것은 최상위 레벨에서 &lt;code&gt;kotlin&lt;/code&gt; 확장을 만듭니다 . 그런 다음 빌드 스크립트에서 다음에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91b0596f729477e16cacda10e4665e91b4d05e3b" translate="yes" xml:space="preserve">
          <source>This document covers some details of Kotlin/Native interoperability with Swift/Objective-C.</source>
          <target state="translated">이 문서는 Swift / Objective-C와의 Kotlin / Native 상호 운용성에 대한 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="50a7c9e10c5c72d9392130bc3068411c0b41a1c1" translate="yes" xml:space="preserve">
          <source>This document explains the structure of &lt;a href=&quot;multiplatform&quot;&gt;Kotlin multiplatform projects&lt;/a&gt; and describes how those are configured and built using Gradle.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;multiplatform&quot;&gt;Kotlin 멀티 플랫폼 프로젝트&lt;/a&gt; 의 구조 와 Gradle을 사용하여 구성 및 빌드되는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="21394d0363d5df965c799770727e7adbc3c6c279" translate="yes" xml:space="preserve">
          <source>This effect is specified in the &lt;code&gt;contract { }&lt;/code&gt; block by attaching a boolean expression to another &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect&lt;/a&gt; effect with the function &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt;.</source>
          <target state="translated">이 효과는에 지정된 &lt;code&gt;contract { }&lt;/code&gt; 다른 부울 표현식을 부착하여 블록 &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect의&lt;/a&gt; 기능과 효과 &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5b2df09cf2fcb8077c0a923825c3e12c005d89" translate="yes" xml:space="preserve">
          <source>This example always prints zero. Resources do not leak.</source>
          <target state="translated">이 예제는 항상 0을 인쇄합니다. 자원이 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e955cd6c26356181a1bb5fce56a8a7425848e09" translate="yes" xml:space="preserve">
          <source>This example can be also rewritten in a more idiomatic way, using &lt;code&gt;runBlocking&lt;/code&gt; to wrap the execution of the main function:</source>
          <target state="translated">이 예제는 &lt;code&gt;runBlocking&lt;/code&gt; 을 사용 하여 주 함수의 실행을 래핑 하여보다 관용적 인 방식으로 다시 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea137e1d1b8bae0357ac3e28f43d2dbd0615f21" translate="yes" xml:space="preserve">
          <source>This example completes in less than a second for me, but it prints some arbitrary number, because some coroutines don't finish before &lt;code&gt;main()&lt;/code&gt; prints the result. Let's fix that.</source>
          <target state="translated">이 예제는 1 초 안에 완료되지만 &lt;code&gt;main()&lt;/code&gt; 이 결과를 인쇄 하기 전에 일부 코 루틴이 끝나지 않기 때문에 임의의 숫자를 인쇄합니다. 고쳐 봅시다.</target>
        </trans-unit>
        <trans-unit id="a01abea8c251a15b2fecf1b509dc49ecf9457794" translate="yes" xml:space="preserve">
          <source>This example prints &quot;&lt;em&gt;Shape&lt;/em&gt;&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;s&lt;/code&gt;, which is the &lt;code&gt;Shape&lt;/code&gt; class.</source>
          <target state="translated">이 예제 인쇄 &quot; &lt;em&gt;모양&lt;/em&gt; 확장 함수가 호출되고 있기는&quot;만 매개 변수의 선언 된 유형에 따라 다릅니다 &lt;code&gt;s&lt;/code&gt; 는 IS, &lt;code&gt;Shape&lt;/code&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3176985b1c6580c82570c99ec00af4e47e3fca5d" translate="yes" xml:space="preserve">
          <source>This example uses the utility function &lt;code&gt;startActivity&lt;/code&gt; creating an intent with no data and starting a new activity, which comes from the &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; library. To pass some data, you can say &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;startActivity&lt;/code&gt; 유틸리티 함수를 사용하여 데이터가없는 인 텐트를 작성하고 &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; 라이브러리 에서 제공되는 새 활동을 시작합니다 . 일부 데이터를 전달하기 위해 &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt; 라고 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6017ffad0436bb8b6025573c2ab986b658552870" translate="yes" xml:space="preserve">
          <source>This example will print &quot;c&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;c&lt;/code&gt;, which is the &lt;code&gt;C&lt;/code&gt; class.</source>
          <target state="translated">호출되는 확장 기능은 매개 변수의 선언 형에 의존하기 때문에이 예제는 &quot;C&quot;를 출력합니다 &lt;code&gt;c&lt;/code&gt; 는 IS, &lt;code&gt;C&lt;/code&gt; 의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="133008c5d984069ce6a34613c275871c4f01bd7c" translate="yes" xml:space="preserve">
          <source>This extension allows to use instances of Lazy for property delegation: &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</source>
          <target state="translated">이 확장을 사용하면 속성 위임에 Lazy 인스턴스를 사용할 수 있습니다. &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d46e174deee6bd3f88e10604b91fb9b63428622" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="translated">이 확장은 이전 이름의 매개 변수를 사용한 호출에만 선택됩니다. 매개 변수 이름을 &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt; 와 동일하게 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="14d1030709354dc027ae0189ce6ddad41a98c081" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence(kotlin.Int,%20kotlin.Int)&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="translated">이 확장은 이전 이름의 매개 변수를 사용한 호출에만 선택됩니다. 매개 변수 이름을 &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence(kotlin.Int,%20kotlin.Int)&quot;&gt;CharSequence.subSequence&lt;/a&gt; 와 동일한 이름으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="04d1f02c756f7e0904c6b3ffc69c7b6618cd5516" translate="yes" xml:space="preserve">
          <source>This extension on &lt;code&gt;Map&lt;/code&gt; returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found. If the map was produced with &lt;code&gt;withDefault&lt;/code&gt;, this function will return the default value instead of throwing an exception.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 의이 확장 은 주어진 키에 해당하는 기존 값을 반환하거나 찾을 수없는 키를 언급하여 예외를 발생시킵니다. &lt;code&gt;withDefault&lt;/code&gt; 로 맵을 생성 한 경우이 함수는 예외를 발생시키는 대신 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="179023ec810ea92c988e87fc2b985af8aad37762" translate="yes" xml:space="preserve">
          <source>This feature is available since Kotlin 1.3.40.</source>
          <target state="translated">이 기능은 Kotlin 1.3.40부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="291f1aee064b4993bae1bca7498ed1b391616e9f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82fc3a4111cee52b0765cac3deb75eac875358c3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 0에 가까운 &lt;a href=&quot;expm1#kotlin.math%24expm1(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; 에 대해보다 정확한 결과를 생성하도록 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b2cb2dc1fab6dcfdc4a04073763dbc01b226107" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ea77ed3f5037a0baac9478b8da01da4e51178e3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8188da7cb3be6634067162b37cc97e8bc1ff03f4" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 0에 가까운 &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; 에 대해보다 정확한 결과를 생성하도록 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efadae38b073a74442295c102230ba4f30a5571f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Float)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 0에 가까운 &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Float)/x&quot;&gt;x&lt;/a&gt; 에 대해보다 정확한 결과를 생성하도록 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c898be592d8e9ec3ec1e1197444847361f309383" translate="yes" xml:space="preserve">
          <source>This function catches any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;map-catching#kotlin%24mapCatching(kotlin.Result((kotlin.mapCatching.T)),%20kotlin.Function1((kotlin.mapCatching.T,%20kotlin.mapCatching.R)))/transform&quot;&gt;transform&lt;/a&gt; function and encapsulates it as a failure. See &lt;a href=&quot;../kotlin.collections/map&quot;&gt;map&lt;/a&gt; for an alternative that rethrows exceptions from &lt;code&gt;transform&lt;/code&gt; function.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;map-catching#kotlin%24mapCatching(kotlin.Result((kotlin.mapCatching.T)),%20kotlin.Function1((kotlin.mapCatching.T,%20kotlin.mapCatching.R)))/transform&quot;&gt;변형&lt;/a&gt; 함수에 의해 throw되는 모든 &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외를 포착 하고이를 실패로 캡슐화합니다. &lt;code&gt;transform&lt;/code&gt; 함수 에서 예외를 다시 발생시키는 대안 은 &lt;a href=&quot;../kotlin.collections/map&quot;&gt;map&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cef13bf6e73de23f49c16a3bab2d588fbcbf2988" translate="yes" xml:space="preserve">
          <source>This function catches any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;recover-catching#kotlin%24recoverCatching(kotlin.Result((kotlin.recoverCatching.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recoverCatching.R)))/transform&quot;&gt;transform&lt;/a&gt; function and encapsulates it as a failure. See &lt;a href=&quot;recover&quot;&gt;recover&lt;/a&gt; for an alternative that rethrows exceptions.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;recover-catching#kotlin%24recoverCatching(kotlin.Result((kotlin.recoverCatching.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recoverCatching.R)))/transform&quot;&gt;변형&lt;/a&gt; 함수에 의해 throw되는 모든 &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외를 포착 하고이를 실패로 캡슐화합니다. 예외를 다시 발생시키는 대안 은 &lt;a href=&quot;recover&quot;&gt;복구&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c484bb37db8fbf2af8bdf87b8645f693e45336d" translate="yes" xml:space="preserve">
          <source>This function compares this string and the specified &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt; in a synchronized block that acquires that &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;'s monitor.</source>
          <target state="translated">이 함수는이 문자열과 해당 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt; 의 모니터 를 획득하는 동기화 된 블록 의 지정된 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt; 를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="15d8b3c4e3fae3fdf6c4d98c18ebe217e09dc09b" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">이 함수는 동결 시도 중에 이러한 객체를 볼 경우 동결이 실패하고 &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; 이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b1cc74a9da98228f1c9d06844410d709b18bb49c" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">이 함수는 동결 시도 중에 이러한 객체를 볼 경우 동결이 실패하고 &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; 이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a5393499e5b4f857a3be1966cc5a5ee2263343b0" translate="yes" xml:space="preserve">
          <source>This function has two notable differences from the method Pattern.split:</source>
          <target state="translated">이 함수는 Pattern.split 메서드와 두 가지 눈에 띄는 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8266b16f93bf335043fb8a8f2352b33ede13a56f" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unchecked&lt;/em&gt;. Repeated invocation of any resume function on the resulting continuation corrupts the state machine of the coroutine and may result in arbitrary behaviour or exception.</source>
          <target state="translated">이 기능은 &lt;em&gt;선택되어&lt;/em&gt; 있지 않습니다 . 결과 연속에서 재개 기능을 반복적으로 호출하면 코 루틴의 상태 시스템이 손상되어 임의의 동작이나 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="080e9b8336d9b1bd6ef82f0d25962f50f8a0565d" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 함수에 대한 속기 &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (참조 : &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;배&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d500cf4330e5af6f7d32531bc1c10b5b5cb22a39" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 함수에 대한 속기 &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1206d6e25fa2947fa30b44bb46d8a067f16e4bc2" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;getOrElse { null }&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt; 참조 ) 또는 &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (참조&lt;a href=&quot;../../kotlin.collections/fold&quot;&gt; fold&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ceaf91c907592aafc9f5d591d5965851baf420" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ff5ce4b141292d06ec70d6eb85ccd3070084028" translate="yes" xml:space="preserve">
          <source>This function is deprecated. See &lt;a href=&quot;as-c-pointer&quot;&gt;Worker.asCPointer&lt;/a&gt; for more details.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. &lt;a href=&quot;as-c-pointer&quot;&gt;Worker.asCPointer를&lt;/a&gt; 참조하십시오 . 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1082b4365fe4440feb5a4149d9805ba0ee95963d" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;kotlinx.cinterop.StableRef.create(worker).asCPointer()&lt;/code&gt; instead. The result can be unwrapped with &lt;code&gt;pointer.asStableRef&amp;lt;Worker&amp;gt;().get()&lt;/code&gt;. &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/index&quot;&gt;StableRef&lt;/a&gt; should be eventually disposed manually with &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/dispose&quot;&gt;StableRef.dispose&lt;/a&gt;.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 &lt;code&gt;kotlinx.cinterop.StableRef.create(worker).asCPointer()&lt;/code&gt; 사용하십시오. 결과는 &lt;code&gt;pointer.asStableRef&amp;lt;Worker&amp;gt;().get()&lt;/code&gt; 으로 풀 수 있습니다 . &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/index&quot;&gt;StableRef은&lt;/a&gt; 결국 수동으로 배치해야한다 &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/dispose&quot;&gt;StableRef.dispose&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="655c266532fc9da4c9f83fafc0352f21cfdf4913" translate="yes" xml:space="preserve">
          <source>This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; to resume the execution of the suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 내부에서 사용하여 일시 중단 함수에 대한 참조를 사용하여 일시 중단 된 코 루틴 실행을 재개 하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a73c80e70840d67f98f7e02bc949060c1aff0a7a" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (참조 : &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;배&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6bebf395da4954e0241f8b8cedacdd2c2c071a5d" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="036653325111157e1e020b5f2e95ce39aee0befd" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;getOrElse { null }&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt; 참조 ) 또는 &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt; 참조 )의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="0cd6600313d79bdb9ccb1177f047f415c30785ec" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2764ff2fd2235b064886b62fb3ea52722744061e" translate="yes" xml:space="preserve">
          <source>This function is supposed to copy items from one array to another. Let's try to apply it in practice:</source>
          <target state="translated">이 함수는 한 배열에서 다른 배열로 항목을 복사합니다. 실제로 적용 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="e946cda58e67ec0857646809f4c7cd966c6aa3b4" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="translated">이 함수는 이 특정 연속을 가로 채지 않으려는 경우 원래 &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;연속을&lt;/a&gt; 단순히 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11e7f8ea6989ea16c6c6f19e0683df8d87331f23" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="translated">이 함수는 이 특정 연속을 가로 채지 않으려면 단순히 원래 &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;연속을&lt;/a&gt; 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e37e9fc156176e563d05b6de34d613400e3a03e7" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 인터셉트되지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c7cfd05c8eea06ab4db27704a1d5249d155e3e" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 인터셉트되지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e77211107874c1aa9b698abd78683ca24a554806" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 가로 채지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되었는지 확인하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23439beed8599daea974279d78d13303435cfab9" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 가로 채지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되었는지 확인하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c273643758adbf26e0358f1c22929439c83656d2" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="translated">이 기능의 즉각적인 결과를 사용한다 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; 또는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 경우에 그 수표, &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 계속 년대 &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;상황&lt;/a&gt; , 호출 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt; , 캐시를하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e65f4539a9086004cb5d3a889baf0f098ccd5d4a" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="translated">이 기능의 즉각적인 결과를 사용한다 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; 또는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 경우에 그 수표, &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 계속 년대 &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;상황&lt;/a&gt; , 호출 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt; , 캐시를하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b0e3ac4cd4df41a67feb4ab61ba294bec022bac" translate="yes" xml:space="preserve">
          <source>This function takes one parameter named &lt;code&gt;init&lt;/code&gt;, which is itself a function. The type of the function is &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt;, which is a &lt;em&gt;function type with receiver&lt;/em&gt;. This means that we need to pass an instance of type &lt;code&gt;HTML&lt;/code&gt; (a &lt;em&gt;receiver&lt;/em&gt;) to the function, and we can call members of that instance inside the function. The receiver can be accessed through the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">이 함수는 &lt;code&gt;init&lt;/code&gt; 라는 하나의 매개 변수를 가져옵니다 . 함수의 유형은 &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt; 이며, 이는 &lt;em&gt;수신기&lt;/em&gt; 가있는 &lt;em&gt;함수 유형입니다&lt;/em&gt; . 즉, &lt;code&gt;HTML&lt;/code&gt; 유형 의 &lt;em&gt;수신자&lt;/em&gt; ( &lt;em&gt;수신자&lt;/em&gt; )를 함수 에 전달해야 하며 함수 내에서 해당 인스턴스의 멤버를 호출 할 수 있습니다. 수신자는 &lt;em&gt;다음&lt;/em&gt; 키워드를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="675aeac2a918c6d6c8b4beafdddac2cf6431511b" translate="yes" xml:space="preserve">
          <source>This illustrates several important points:</source>
          <target state="translated">이것은 몇 가지 중요한 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="42ded97c96158badfa6b51ddc24bd9a63c6cca70" translate="yes" xml:space="preserve">
          <source>This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself. There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the capacity and &quot;growth increment&quot; concepts.</source>
          <target state="translated">이 구현은 백업 JS 배열 자체의 크기를 조정할 수 있으므로 용량을 관리하는 방법을 제공하지 않습니다. JavaScript에서 배열 크기를 사전 할당하는 것에는 속도 이점이 없으므로이 구현에는 용량 및 &quot;증가 증분&quot;개념이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="691ede82b3af6046b7651a9c02f4605eaa3ba130" translate="yes" xml:space="preserve">
          <source>This implementation makes no guarantees regarding the order of enumeration of &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;keys&lt;/a&gt;, &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;values&lt;/a&gt; and &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;entries&lt;/a&gt; collections.</source>
          <target state="translated">이 구현은 , &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;키&lt;/a&gt; 의 열거 순서 , &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;값&lt;/a&gt; 및 &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;엔트리&lt;/a&gt; 컬렉션에 대해서는 보증하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8ddc3e7d274cee12068e4ad892df6635b0d1615a" translate="yes" xml:space="preserve">
          <source>This implementation preserves the insertion order of elements during the iteration.</source>
          <target state="translated">이 구현은 반복 동안 요소의 삽입 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1edd274f6c90be7cfea12d2c044bc4232b280a23" translate="yes" xml:space="preserve">
          <source>This implicit default value is used when the original map doesn't contain a value for the key specified and a value is obtained with &lt;a href=&quot;get-value&quot;&gt;Map.getValue&lt;/a&gt; function, for example when properties are delegated to the map.</source>
          <target state="translated">이 암시 적 기본값은 원래 맵에 지정된 키 값이 &lt;a href=&quot;get-value&quot;&gt;없고 Map.getValue&lt;/a&gt; 함수 를 사용하여 값을 가져 오는 경우 (예 : 속성이 맵에 위임 될 때) 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="410788a84e729541585bfe744595e36fe672b2b8" translate="yes" xml:space="preserve">
          <source>This implies a different way to approach problems and quite a significant shift from what we're using to when writing synchronous code. One benefit as opposed to Futures is that given its ported to so many platforms, generally we can find a consistent API experience no matter what we use it, be it C#, Java, JavaScript, or any other language where Rx is available.</source>
          <target state="translated">이것은 문제에 접근하는 다른 방법과 동기 코드를 작성할 때 우리가 사용하는 것에서 상당한 변화를 의미합니다. 선물과 반대되는 이점 중 하나는 많은 플랫폼으로 포팅되어 있기 때문에 일반적으로 C #, Java, JavaScript 또는 Rx를 사용할 수있는 다른 언어에 관계없이 일관된 API 경험을 찾을 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b300e1ecd05ef9cda9c0ccf69cc9b5755628a6bd" translate="yes" xml:space="preserve">
          <source>This imposes certain risks of binary incompatibility caused by changes in the module that declares an inline function in case the calling module is not re-compiled after the change.</source>
          <target state="translated">이는 변경 후 호출 모듈이 재 컴파일되지 않은 경우 인라인 함수를 선언하는 모듈의 변경으로 인한 이진 비 호환성 위험을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="1c39f73f8778c781fa84c78bdda94d474dac7b9e" translate="yes" xml:space="preserve">
          <source>This in principle feels like a much more elegant solution, but once again has several issues:</source>
          <target state="translated">이것은 원칙적으로 훨씬 더 우아한 솔루션처럼 느껴지지만 다시 한 번 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dca6747771b3b10d5fd08415bf950f46bdea92f" translate="yes" xml:space="preserve">
          <source>This interface is implemented by floating point ranges returned by &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; and &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; operators to achieve IEEE-754 comparison order instead of total order of floating point numbers.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; 및 &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; 연산자가 반환 한 부동 소수점 범위에 의해 구현되어 총 부동 소수점 수 대신 IEEE-754 비교 순서를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="b9b5668de562d41a3eb7fb59a1bae495ad743bbf" translate="yes" xml:space="preserve">
          <source>This interface is likely to be handled by compiler magic and shouldn't be subtyped by arbitrary classes.</source>
          <target state="translated">이 인터페이스는 컴파일러 매직에 의해 처리 될 수 있으며 임의의 클래스에 의해 서브 타입 화되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="60e87d87b4ef52673d6b6accbe785d16a04f37c9" translate="yes" xml:space="preserve">
          <source>This is a guide on core features of &lt;code&gt;kotlinx.coroutines&lt;/code&gt; with a series of examples, divided up into different topics.</source>
          <target state="translated">이 안내서는 여러 주제로 나뉘어 진 일련의 예제가있는 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 의 핵심 기능에 대한 안내서입니다 .</target>
        </trans-unit>
        <trans-unit id="c933ba19b81dc6ad55a2c69193b755c303d2100a" translate="yes" xml:space="preserve">
          <source>This is a little better, but we have no or little help from the powerful code completion of the IDE. It would be so much better if we could say:</source>
          <target state="translated">이것은 조금 나아지지만 IDE의 강력한 코드 완성에서 도움이 거의 또는 전혀 없습니다. 우리가 말할 수 있다면 훨씬 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="da401b98d9be6d7ebaac9172cbd4241fbf6ba27c" translate="yes" xml:space="preserve">
          <source>This is also a way to write unit tests for suspending functions:</source>
          <target state="translated">이것은 또한 일시 중단 함수에 대한 단위 테스트를 작성하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="64ed768079e9d5cbdb933e9c19824b5132acfb30" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="109dcae61144497c38fcb7128f4fde954a0b0dab" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1275ac7243b73ff90c0cce870f1cace4805d6b9b" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bbf054c69a799b1f208427023936248eccf48ba6" translate="yes" xml:space="preserve">
          <source>This is because we are not inside any coroutine. We can use delay if we wrap it into &lt;code&gt;runBlocking {}&lt;/code&gt; that starts a coroutine and waits until it's done:</source>
          <target state="translated">우리는 코 루틴 안에 있지 않기 때문입니다. 코 루틴을 시작하고 완료 될 때까지 기다리는 &lt;code&gt;runBlocking {}&lt;/code&gt; 에 지연을 감쌀 경우 지연을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89a3c5e95e199bf51561c58886a8d92c513c9cea" translate="yes" xml:space="preserve">
          <source>This is called an &lt;em&gt;object declaration&lt;/em&gt;, and it always has a name following the &lt;em&gt;object&lt;/em&gt; keyword. Just like a variable declaration, an object declaration is not an expression, and cannot be used on the right hand side of an assignment statement.</source>
          <target state="translated">이를 &lt;em&gt;객체 선언&lt;/em&gt; 이라고하며 항상 &lt;em&gt;객체&lt;/em&gt; 키워드 뒤에 이름이 있습니다. 변수 선언과 마찬가지로 객체 선언은 표현식이 아니며 대입 문의 오른쪽에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f25f0b9ab280fe3c292330ad8e1771dad21395c" translate="yes" xml:space="preserve">
          <source>This is completely legitimate Kotlin code. You can play with this code online (modify it and run in the browser) &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이것은 완전히 합법적 인 Kotlin 코드입니다. 당신은 (그것을 수정하고 브라우저에서 실행) 온라인이 코드를 재생할 수 있습니다 &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;여기에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ddd6e3de1f5a28a90747db03b48c3a1e5c746b0" translate="yes" xml:space="preserve">
          <source>This is different from adjusting &lt;code&gt;webpackTask.output.libraryTarget&lt;/code&gt;. The library target changes the output &lt;em&gt;generated by webpack&lt;/em&gt; (after your code has already been compiled). &lt;code&gt;kotlinOptions.moduleKind&lt;/code&gt; changes the output generated &lt;em&gt;by the Kotlin compiler&lt;/em&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;webpackTask.output.libraryTarget&lt;/code&gt; 조정과 다릅니다 . 라이브러리 타겟 &lt;em&gt;은 웹팩에 의해 생성 된&lt;/em&gt; 출력을 변경합니다 (코드가 이미 컴파일 된 후). &lt;code&gt;kotlinOptions.moduleKind&lt;/code&gt; &lt;em&gt;는 Kotlin 컴파일러가&lt;/em&gt; 생성 &lt;em&gt;한&lt;/em&gt; 출력을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="cafbcd266b45a7c72452995f54470aa36c3c74c4" translate="yes" xml:space="preserve">
          <source>This is how Kotlin Multiplatform works.</source>
          <target state="translated">이것이 Kotlin Multiplatform이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="f1b5d12f5c0ad6b8f02b5702175b995f5f4555de" translate="yes" xml:space="preserve">
          <source>This is how the package &lt;code&gt;com.example.html&lt;/code&gt; is defined (only the elements used in the example above). It builds an HTML tree. It makes heavy use of &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt; and &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;lambdas with receiver&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;com.example.html&lt;/code&gt; 패키지 가 정의 된 방식입니다 (위 예에서 사용 된 요소 만). HTML 트리를 빌드합니다. &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;리시버와 함께 &lt;/a&gt;&lt;a href=&quot;extensions&quot;&gt;확장 기능&lt;/a&gt; 과 람다를 많이 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="eb4b287b1edf1ba23dd84510aa2e475b62f2bf92" translate="yes" xml:space="preserve">
          <source>This is how the same function looks without the standard library functions:</source>
          <target state="translated">표준 라이브러리 함수없이 동일한 함수가 보이는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="be45b011252e2fb8cf7402a94a29a95e7994751a" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript module (see &lt;a href=&quot;js-modules&quot;&gt;JavaScript Modules&lt;/a&gt; for more information on this). In this case there won't be a wrapper object, instead, declarations will be exposed as a JavaScript module of a corresponding kind. For example, in case of CommonJS you should write:</source>
          <target state="translated">Kotlin 모듈을 JavaScript 모듈로 컴파일 할 때는 적용 할 수 없습니다 ( 자세한 내용 은 &lt;a href=&quot;js-modules&quot;&gt;JavaScript 모듈&lt;/a&gt; 참조 ). 이 경우 래퍼 객체가 없으므로 선언이 해당 종류의 JavaScript 모듈로 노출됩니다. 예를 들어, CommonJS의 경우 다음을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ac1b203334ec097b223fccc93d140d76e0239d4" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript modules like UMD (which is the default setting for both &lt;code&gt;browser&lt;/code&gt; and &lt;code&gt;nodejs&lt;/code&gt; targets), CommonJS or AMD. In this case, your declarations will be exposed in the format specified by your chosen JavaScript module system. When using UMD or CommonJS, for example, your call site could look like this:</source>
          <target state="translated">Kotlin 모듈을 UMD와 같은 자바 스크립트 모듈로 컴파일 할 때는 적용되지 않습니다 ( &lt;code&gt;browser&lt;/code&gt; 및 &lt;code&gt;nodejs&lt;/code&gt; 모두의 기본 설정) 대상 ), CommonJS 또는 AMD . 이 경우 선언은 선택한 JavaScript 모듈 시스템에서 지정한 형식으로 노출됩니다. 예를 들어 UMD 또는 CommonJS를 사용하는 경우 호출 사이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16ae8412e011bd154f0f6ed0d14afcc433a50b3b" translate="yes" xml:space="preserve">
          <source>This is not required when using Kotlin Gradle plugin 1.1.1 and above with the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;, and with &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle 플러그인 DSL&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt; 과 함께 Kotlin Gradle 플러그인 1.1.1 이상을 사용할 때는 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="04267f944435e1968a98920e69ed6ee93ce59d4b" translate="yes" xml:space="preserve">
          <source>This is one expression in all three languages:</source>
          <target state="translated">이것은 세 언어 모두에서 하나의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="6b9969b7447679a0aefde827887c1e2aff85957c" translate="yes" xml:space="preserve">
          <source>This is one expression in both Kotlin (because the first line doesn't parse on its own) and JavaScript, and doesn't parse in Python:</source>
          <target state="translated">이것은 Kotlin (첫 번째 줄은 자체적으로 구문 분석하지 않기 때문에)과 JavaScript 모두에서 하나의 표현이며 Python에서는 구문 분석하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e08018d2743eaf233d0fdb2fc751af52fc3dee8" translate="yes" xml:space="preserve">
          <source>This is only the beginning and a small example of Kotlin code sharing between iOS and Android (and other platforms) with Kotlin, Kotlin/Native and Kotlin multiplatform projects. The same approach works for real applications, independent of their size or complexity.</source>
          <target state="translated">이것은 Kotlin, Kotlin / Native 및 Kotlin 멀티 플랫폼 프로젝트에서 iOS와 Android (및 기타 플랫폼)간에 Kotlin 코드 공유의 시작이자 작은 예일뿐입니다. 크기 나 복잡성에 관계없이 동일한 응용 프로그램이 실제 응용 프로그램에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="556b42ba8780522a3f90da067d375baba3a8ad1d" translate="yes" xml:space="preserve">
          <source>This is particularly important for Android developers, since the compiler can now correctly analyze generic &lt;code&gt;findViewById&lt;/code&gt; calls in Android API level 26:</source>
          <target state="translated">컴파일러는 이제 Android API 레벨 26에서 일반 &lt;code&gt;findViewById&lt;/code&gt; 호출을 올바르게 분석 할 수 있으므로 이는 Android 개발자에게 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="995a44882385c48d93df496a6a80eaaa6c26f44a" translate="yes" xml:space="preserve">
          <source>This is provided only for convenience; you don't have to extend this interface as long as your property delegate has methods with the same signatures.</source>
          <target state="translated">이것은 편의상 제공됩니다. 속성 대리자가 동일한 서명을 가진 메서드를 가지고 있다면이 인터페이스를 확장 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64b2fb3aa48fe9872cab0264ea29aacf2838772b" translate="yes" xml:space="preserve">
          <source>This is the JS code generated for the Kotlin code above (the &lt;code&gt;main&lt;/code&gt; function). Let's have a closer look at it.</source>
          <target state="translated">위의 Kotlin 코드에 대해 생성 된 JS 코드입니다 ( &lt;code&gt;main&lt;/code&gt; 기능). 자세히 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="61af108c05fdc7b4a1413c5ee9cd9367a036a611" translate="yes" xml:space="preserve">
          <source>This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.</source>
          <target state="translated">이것이이 특정 문제에 대한 가장 빠른 해결책입니다. 일반 카운터, 수집, 대기열 및 기타 표준 데이터 구조 및 기본 작업에 사용됩니다. 그러나 즉시 사용 가능한 스레드 안전 구현이없는 복잡한 상태 또는 복잡한 작업으로 쉽게 확장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa369ec473906917e945918ae4ca55d8b5858ee4" translate="yes" xml:space="preserve">
          <source>This is the last tutorial in the series. The first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 마지막 튜토리얼입니다. 이 시리즈의 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. 도 있습니다 &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;C에서 매핑 구조체 및 연합 유형&lt;/a&gt; 및 &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C의에서 매핑 함수 포인터&lt;/a&gt; 자습서.</target>
        </trans-unit>
        <trans-unit id="db342e5eb9179bc09fc429165b10a1574cb68d62" translate="yes" xml:space="preserve">
          <source>This is the main feature of inline classes, which inspired the name &quot;inline&quot;: data of the class is &quot;inlined&quot; into its usages (similar to how content of &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt; is inlined to call sites).</source>
          <target state="translated">이것은 인라인 클래스의 주요 기능으로, &quot;인라인&quot;이라는 이름에서 영감을 얻었습니다. 클래스의 데이터는 사용법에 &quot;인라인&quot;되어 있습니다 ( &lt;a href=&quot;inline-functions&quot;&gt;인라인 함수의&lt;/a&gt; 내용이 인라인 사이트를 호출 하는 방식과 유사 ).</target>
        </trans-unit>
        <trans-unit id="e191f2b52800fbe76b7db487772b3a907bdf44b0" translate="yes" xml:space="preserve">
          <source>This is the second post in the series. The very first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also the &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 두 번째 게시물입니다. 이 시리즈의 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C&lt;/a&gt; 의 Mapping Function Pointer 와 &lt;a href=&quot;mapping-strings-from-c&quot;&gt;C&lt;/a&gt; 자습서의 Mapping Strings도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d714ceb3667c2a2d840d8a543c7e66ce3d058a3" translate="yes" xml:space="preserve">
          <source>This is the third post in the series. The very first tutorial is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 세 번째 게시물입니다. 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. 도 있습니다 &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;C에서 매핑 구조체 및 연합 유형&lt;/a&gt; 및 &lt;a href=&quot;mapping-strings-from-c&quot;&gt;C의에서 매핑 문자열&lt;/a&gt; 자습서.</target>
        </trans-unit>
        <trans-unit id="4b1e08d2ab9bc443d4e794dd876f58764cb1b59a" translate="yes" xml:space="preserve">
          <source>This is true for a division between any two integer types.</source>
          <target state="translated">이는 두 정수 유형을 나누는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="1cdf86b607345251afe79fd6fc9f04693b54a221" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because the two coroutines execute concurrently. Note that concurrency with coroutines is always explicit.</source>
          <target state="translated">두 코 루틴이 동시에 실행되기 때문에 이는 두 배 빠릅니다. 코 루틴과의 동시성은 항상 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="f2ad8f555f0fd0b81fe583ef82f57587da754391" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because we have concurrent execution of two coroutines. Note that concurrency with coroutines is always explicit.</source>
          <target state="translated">우리는 두 개의 코 루틴을 동시에 실행하기 때문에 두 배 빠릅니다. 코 루틴과의 동시성은 항상 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="71c1af27d3f71a4b285ff3d26289c1fc97691cf8" translate="yes" xml:space="preserve">
          <source>This is useful for configuring properties that aren't present in the object constructor.</source>
          <target state="translated">이는 개체 생성자에없는 속성을 구성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="92b4fd5ae8a5154b1a5e18bb911000880c41554c" translate="yes" xml:space="preserve">
          <source>This lets Android Studio know that the kotlin directory is a source root, so when the project model is loaded into the IDE it will be properly recognized. Alternatively, you can put Kotlin classes in the Java source directory, typically located in &lt;code&gt;src/main/java&lt;/code&gt;.</source>
          <target state="translated">이를 통해 Android Studio는 kotlin 디렉토리가 소스 루트임을 알 수 있으므로 프로젝트 모델이 IDE에로드 될 때 올바르게 인식됩니다. 또는 Kotlin 클래스를 Java 소스 디렉토리 (일반적으로 &lt;code&gt;src/main/java&lt;/code&gt; 에 있음)에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="736ca34cfc08c91c8fd20715eb24479a73c79bdf" translate="yes" xml:space="preserve">
          <source>This library is published to Bintray JCenter repository, so let us add it:</source>
          <target state="translated">이 라이브러리는 Bintray JCenter 리포지토리에 게시되므로 다음과 같이 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="898c5a35f84b96626909c79797c0f501c038d6e4" translate="yes" xml:space="preserve">
          <source>This list has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">이 목록의 크기는 &lt;code&gt;groupCount + 1&lt;/code&gt; 여기서 &lt;code&gt;groupCount&lt;/code&gt; 는 정규식의 그룹 수입니다. 그룹은 1에서 &lt;code&gt;groupCount&lt;/code&gt; 로 색인화되며 색인이 0 인 그룹은 전체 일치 항목에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4bdb3ec74f6932b33fd8d2d9d59b4f6dd5cdc88a" translate="yes" xml:space="preserve">
          <source>This marker distinguishes the experimental contract declaration API and is used to opt-in for that feature when declaring contracts of user functions.</source>
          <target state="translated">이 마커는 실험 계약 선언 API를 구별하며 사용자 기능 계약을 선언 할 때 해당 기능을 옵트 인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="180f1cb299276ef1bdc5f464e18d2794e7d742af" translate="yes" xml:space="preserve">
          <source>This may be useful in the following cases:</source>
          <target state="translated">다음과 같은 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe068972b66d6d75ef4966c9005153d1f9eaed4c" translate="yes" xml:space="preserve">
          <source>This may be useful, for example, when you want to rename a property in a backward-compatible way: you introduce a new property, annotate the old one with the &lt;code&gt;@Deprecated&lt;/code&gt; annotation, and delegate its implementation.</source>
          <target state="translated">예를 들어 이전 버전과 호환되는 방식으로 속성의 이름을 바꾸려는 경우 유용 할 수 있습니다. 새 속성을 도입하고 이전 속성에 &lt;code&gt;@Deprecated&lt;/code&gt; 로 주석을 추가합니다. 주석으로 구현을 위임합니다.</target>
        </trans-unit>
        <trans-unit id="13bd4b9a1ff3829dff4d0473f506ce883108b5a3" translate="yes" xml:space="preserve">
          <source>This means that there's a library in the classpath which does not depend on the Kotlin standard library as a Gradle/Maven dependency, but is distributed in the same artifact with it (i.e. has it &lt;em&gt;bundled&lt;/em&gt;). Such a library may cause issues because standard build tools do not consider it an instance of the Kotlin standard library, thus it's not subject to the dependency version resolution mechanisms, and you can end up with several versions of the same library in the classpath. Consider contacting the authors of such a library and suggesting to use the Gradle/Maven dependency instead.</source>
          <target state="translated">이것은 클래스 경로에 Grat / Maven 의존성으로 Kotlin 표준 라이브러리에 의존하지 않지만 같은 아티팩트로 배포되는 라이브러리가 있음을 의미합니다 (즉, &lt;em&gt;번들로 묶음&lt;/em&gt; ). 이러한 라이브러리는 표준 빌드 도구가 Kotlin 표준 라이브러리의 인스턴스로 간주하지 않기 때문에 문제를 일으킬 수 있으므로 종속성 버전 확인 메커니즘이 적용되지 않으므로 클래스 경로에서 동일한 라이브러리의 여러 버전으로 끝날 수 있습니다. 이러한 라이브러리의 작성자에게 연락하여 Gradle / Maven 종속성을 대신 사용하도록 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="6cde525aeab8f8f490a4ed99ff83215b05165a70" translate="yes" xml:space="preserve">
          <source>This means that you have a dependency on libraries of different versions, for example the 1.1 standard library and the 1.0 reflection library. To prevent subtle errors at runtime, we recommend you to use the same version of all Kotlin libraries. In this case, consider adding an explicit dependency on the 1.1 reflection library.</source>
          <target state="translated">즉, 1.1 표준 라이브러리 및 1.0 리플렉션 라이브러리와 같이 다른 버전의 라이브러리에 종속됩니다. 런타임시 미묘한 오류를 방지하려면 동일한 버전의 모든 Kotlin 라이브러리를 사용하는 것이 좋습니다. 이 경우 1.1 리플렉션 라이브러리에 명시 적 종속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="17a60d9a927ab40397189c8d1b96e5f7c53d044e" translate="yes" xml:space="preserve">
          <source>This means that you're using the Kotlin compiler 1.1 against the standard or reflection library of version 1.0. This can be handled in different ways:</source>
          <target state="translated">이것은 버전 1.0의 표준 또는 리플렉션 라이브러리에 대해 Kotlin 컴파일러 1.1을 사용하고 있음을 의미합니다. 다른 방법으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="77369f21aef42d741a8e7d6c6dac5c006f439aba" translate="yes" xml:space="preserve">
          <source>This means you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments (their default values are calculated by some JavaScript code).</source>
          <target state="translated">즉 , 하나의 필수 인수와 두 개의 선택적 인수를 사용하여 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 를 호출 할 수 있습니다 (기본값은 일부 JavaScript 코드로 계산 됨).</target>
        </trans-unit>
        <trans-unit id="448a85fa82c5ef71170374be3303b1bc78bb209c" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is a part of public API and therefore should be included in the generated documentation for the element to which the annotation is applied.</source>
          <target state="translated">이 메타 주석은 주석이 퍼블릭 API의 일부임을 결정하므로 주석이 적용되는 요소에 대해 생성 된 문서에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c594f1e41ee531a1ebc1db1a8ef8742f5fcd14a" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is applicable twice or more on a single code element</source>
          <target state="translated">이 메타 주석은 단일 코드 요소에 주석이 두 번 이상 적용될 수 있음을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="71d0203916dcd2ae084a69342802dae5c434f881" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines whether an annotation is stored in binary output and visible for reflection. By default, both are true.</source>
          <target state="translated">이 메타 주석은 주석이 이진 출력으로 저장되고 반영 될 수 있는지 여부를 결정합니다. 기본적으로 둘 다 true입니다.</target>
        </trans-unit>
        <trans-unit id="a36fadd37607b67a90a001f3c5a13ec3d8698650" translate="yes" xml:space="preserve">
          <source>This meta-annotation indicates the kinds of code elements which are possible targets of an annotation.</source>
          <target state="translated">이 메타 주석은 주석의 대상이 될 수있는 코드 요소의 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5733089c709664ede5e39a2892f4d97391a8d9f0" translate="yes" xml:space="preserve">
          <source>This method accepts values of &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; type in range &lt;code&gt;0x00..0xff&lt;/code&gt;, other values are prohibited.</source>
          <target state="translated">이 방법은 &lt;code&gt;0x00..0xff&lt;/code&gt; 범위 의 &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; 유형 값을 허용 하며 다른 값은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="a75948e2d8c32738a31fd96217f7586ee79f04f4" translate="yes" xml:space="preserve">
          <source>This method allows to use destructuring declarations when working with maps, for example:</source>
          <target state="translated">이 방법을 사용하면 맵 작업시 다음과 같은 구조적 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a64298e1d3ab705d641d81b81fea403c6aa3318" translate="yes" xml:space="preserve">
          <source>This method allows to use the &lt;code&gt;x in map&lt;/code&gt; syntax for checking whether an object is contained in the map.</source>
          <target state="translated">이 방법을 사용하면 객체가지도에 포함되어 있는지 확인하기 위해 &lt;code&gt;x in map&lt;/code&gt; 구문 에서 x 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f4999c28f30d3489635a82f469652d71846c62" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="translated">이 메소드는 키가 이미있는 경우 값을 맵에 넣지 않도록하지만 키가 이미 맵에 있어도 &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; 함수가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047deaa17bbcb4b085ecd0f5b31fe3d84a681f3f" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut(java.util.concurrent.ConcurrentMap((kotlin.collections.getOrPut.K,%20kotlin.collections.getOrPut.V)),%20kotlin.collections.getOrPut.K,%20kotlin.Function0((kotlin.collections.getOrPut.V)))/defaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="translated">이 메소드는 키가 이미있는 경우 값을 맵에 넣지 않도록 보장하지만 키가 이미 맵에있는 경우에도 &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut(java.util.concurrent.ConcurrentMap((kotlin.collections.getOrPut.K,%20kotlin.collections.getOrPut.V)),%20kotlin.collections.getOrPut.K,%20kotlin.Function0((kotlin.collections.getOrPut.V)))/defaultValue&quot;&gt;defaultValue&lt;/a&gt; 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="083648bbf3b66e12f1c5e5fd3afa3ff2914dd084" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecd5e6ce22de7239fac178cb06d85481149c22bf" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB byte array size.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다. 내부 제한은 2GB 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ecfd9cc7f27ed3b4efbb7dd03aebaf75912a636e" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB file size.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다. 파일 크기는 2GB로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="43901fb40d645ef2b68c677a55d2f926ea8ed530" translate="yes" xml:space="preserve">
          <source>This method is redeclared as abstract, because it's not implemented in the base class, so it must be always overridden in the concrete mutable collection implementation.</source>
          <target state="translated">이 메소드는 기본 클래스에서 구현되지 않기 때문에 추상으로 다시 선언되므로, 구체적으로 변경 가능한 콜렉션 구현에서 항상 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f25f95428ac465fef329ee7b3944fdbec35af43f" translate="yes" xml:space="preserve">
          <source>This mode should not be used unless the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance is guaranteed never to be initialized from more than one thread.</source>
          <target state="translated">&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스가 둘 이상의 스레드에서 초기화되지 않도록 보장되지 않는 한이 모드를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="6446cf4cb49ffcb2caf4afcf619d26541516a151" translate="yes" xml:space="preserve">
          <source>This name can be used to access the binary:</source>
          <target state="translated">이 이름은 바이너리에 액세스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb387fd4daeff721899d12634f06c3c11719a1e" translate="yes" xml:space="preserve">
          <source>This now works much faster and produces correct result.</source>
          <target state="translated">이제 훨씬 빠르게 작동하고 올바른 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="08d7f6ce5ec74ffd1dae5f3e2a4e554fa93562ae" translate="yes" xml:space="preserve">
          <source>This page contains the current coding style for the Kotlin language.</source>
          <target state="translated">이 페이지에는 코 틀린 언어의 현재 코딩 스타일이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d592b749bb8c59614b5bce1df54bbaa180a699f7" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended that you keep Kotlin and Java files separately (in case the project contains Java files). If you don't store them separately , specify the source folder in the &lt;code&gt;sourceSets&lt;/code&gt; block:</source>
          <target state="translated">이 플러그인은 Kotlin 파일에서만 작동하므로 Kotlin 및 자바 파일을 별도로 보관하는 것이 좋습니다 (프로젝트에 자바 파일이 포함 된 경우). 별도로 저장하지 않는 경우 &lt;code&gt;sourceSets&lt;/code&gt; 블록 에 소스 폴더를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b0d3b6a365feefc5bf2639481a27bf15df77f32" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended to keep Kotlin and Java files separate (in case if the same project contains Java files). As with targeting the JVM, if not using the default convention, you should specify the source folder using &lt;em&gt;sourceSets&lt;/em&gt;:</source>
          <target state="translated">이 플러그인은 Kotlin 파일에서만 작동하므로 Kotlin과 Java 파일을 동일한 프로젝트에 Java 파일이 포함 된 경우 별도로 보관하는 것이 좋습니다. JVM을 대상으로하는 것처럼 기본 규칙을 사용하지 않는 경우 &lt;em&gt;sourceSets를&lt;/em&gt; 사용하여 소스 폴더를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d1dbfb5aeb4d13de4e43c69f4da833e8295308f" translate="yes" xml:space="preserve">
          <source>This podspec file can be referenced from a &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; of an Xcode project. After that the framework built from the Kotlin/Native module can be used from this Xcode project. If necessary, this framework is automatically rebuilt during Xcode build process.</source>
          <target state="translated">이 podspec 파일은 Xcode 프로젝트 의 &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; 에서 참조 할 수 있습니다 . 그 후 Kotlin / Native 모듈로 빌드 된 프레임 워크를이 Xcode 프로젝트에서 사용할 수 있습니다. 필요한 경우이 프레임 워크는 Xcode 빌드 프로세스 중에 자동으로 다시 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">이것은 인쇄</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="ebe525fb027f139b406ffe6decdd11bbf6d8b5bb" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons explained below.</source>
          <target state="translated">비동기 함수를 사용하는이 프로그래밍 스타일은 다른 프로그래밍 언어에서 널리 사용되는 스타일이므로 여기에서는 설명 용으로 만 제공됩니다. 이 스타일을 Kotlin 코 루틴과 함께 사용 &lt;strong&gt;하는 것은 권장하지 않습니다.&lt;/strong&gt; 아래에 설명 된 이유 때문에 .</target>
        </trans-unit>
        <trans-unit id="cda4b457c77664242055b4741cc46d64c55f08a1" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons that are explained below.</source>
          <target state="translated">비동기 함수가있는이 프로그래밍 스타일은 다른 프로그래밍 언어에서 널리 사용되는 스타일이기 때문에 여기에서는 설명을 위해서만 제공됩니다. Kotlin 코 루틴과 함께이 스타일을 사용 &lt;strong&gt;하는 것은&lt;/strong&gt; 아래 설명 된 이유로 &lt;strong&gt;권장하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="77b890076daadde689d1ec3897dcc482dac8e326" translate="yes" xml:space="preserve">
          <source>This property can be used in two cases:</source>
          <target state="translated">이 속성은 두 가지 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff03394cef9f3232cd16286e35c99b97f61a20fd" translate="yes" xml:space="preserve">
          <source>This property can't be used from normal code.</source>
          <target state="translated">이 속성은 일반 코드에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7c3d50d77ba7c2fef150fd01d7bd663fd6396e5" translate="yes" xml:space="preserve">
          <source>This property is currently not supported in Kotlin/JS.</source>
          <target state="translated">이 속성은 현재 Kotlin / JS에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec1ca1351fa183afc05654031c5fff3d664e375" translate="yes" xml:space="preserve">
          <source>This protocol is designed for comfortable updates as no project can be blocked from updating its dependencies even if it's using a slightly outdated compiler.</source>
          <target state="translated">이 프로토콜은 프로젝트가 약간 오래된 컴파일러를 사용하더라도 종속성 업데이트를 차단할 수 없으므로 편리한 업데이트를 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="98a9e8bab8deee99e0e21fcb3247e8a1511740b5" translate="yes" xml:space="preserve">
          <source>This publication does not include any artifacts and only references the other publications as its variants. However, it may need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts by using &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt;&lt;code&gt;artifact(...)&lt;/code&gt;&lt;/a&gt; in the publication's scope, which is accessed as shown above.</source>
          <target state="translated">이 발행물에는 아티팩트가 포함되어 있지 않으며 다른 발행물을 해당 변형으로 만 참조합니다. 그러나 저장소에 필요한 경우 소스 및 문서 아티팩트가 필요할 수 있습니다. 이 경우 게시 범위에서 &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt; &lt;code&gt;artifact(...)&lt;/code&gt; &lt;/a&gt; 를 사용하여 위의 아티팩트를 추가하십시오 . 위의 그림과 같이 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="e2515924de7501ee2f4c68fc0b725aaaf061557d" translate="yes" xml:space="preserve">
          <source>This quickly gets unwieldy, so you will typically &lt;em&gt;import&lt;/em&gt; the symbols you need. You can import a specific symbol:</source>
          <target state="translated">이것은 다루기 어려워 지므로 일반적으로 필요한 기호를 &lt;em&gt;가져옵니다&lt;/em&gt; . 특정 심볼을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4727911dc96369eca10addebc256163a4abb387" translate="yes" xml:space="preserve">
          <source>This requires that the consumer's Gradle build can read Gradle module metadata, either using Gradle 5.3+ or explicitly enabling it by &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; in &lt;code&gt;settings.gradle&lt;/code&gt;.</source>
          <target state="translated">이렇게하여 수 있도록 명시 적으로 Gradle을을 사용하여 5.3+ 또는 중, 소비자의 Gradle을 빌드 Gradle을 모듈 메타 데이터를 읽을 수 있어야 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 에 &lt;code&gt;settings.gradle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3811c08a3b736bc78dff85189aa76ac7adf599c" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;b.length&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is not null, and &lt;em&gt;null&lt;/em&gt; otherwise. The type of this expression is &lt;code&gt;Int?&lt;/code&gt;.</source>
          <target state="translated">이 반환 &lt;code&gt;b.length&lt;/code&gt; 경우 &lt;code&gt;b&lt;/code&gt; 는 null이되지 않고 &lt;em&gt;널 (null)&lt;/em&gt; 이 없습니다. 이 표현의 타입은 &lt;code&gt;Int?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="752e46575723521dd2b0e2f3643820dd84459a5c" translate="yes" xml:space="preserve">
          <source>This runs a 1'000'000 threads each of which adds to a common counter. My patience runs out before this program completes on my machine (definitely over a minute).</source>
          <target state="translated">이것은 공통 카운터에 추가되는 1'000'000 스레드를 실행합니다. 이 프로그램이 컴퓨터에서 완료되기 전에 인내심이 없어집니다 (분당).</target>
        </trans-unit>
        <trans-unit id="86208ae33ef90a5dcb8c41ac6a075a89ce88f8d7" translate="yes" xml:space="preserve">
          <source>This section covers basic coroutine concepts.</source>
          <target state="translated">이 섹션은 기본적인 코 루틴 개념을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="75d5f867c8b73c01b71e379315dc5e2a4c6f94a7" translate="yes" xml:space="preserve">
          <source>This section covers coroutine cancellation and timeouts.</source>
          <target state="translated">이 섹션에서는 코 루틴 취소 및 타임 아웃에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1de34a1a4060ac4a9343482aadfbf40dd5028f41" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that a cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by the coroutines' machinery. Here we look at what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception.</source>
          <target state="translated">이 섹션에서는 예외 처리 및 예외에 대한 취소를 다룹니다. 취소 된 코 루틴 이 중단 지점에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; 을 발생시키고 코 루틴의 기계에 의해 무시된다는 것을 이미 알고 있습니다. 여기에서는 취소 중에 예외가 발생하거나 동일한 코 루틴의 여러 자식이 예외를 발생시키는 경우 어떻게되는지 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="7fd839d8f63682d12541a453824eb6d8c7ab4f81" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by coroutines machinery. But what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception?</source>
          <target state="translated">이 섹션에서는 예외 처리 및 예외 취소에 대해 설명합니다. 우리는 이미 취소 된 코 루틴 이 서스펜션 포인트에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; 을 던지고 코 루틴 기계에 의해 무시된다는 것을 이미 알고 있습니다. 그러나 취소 중에 예외가 발생하거나 동일한 코 루틴의 여러 자녀가 ​​예외를 throw하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="dd1323da1dc057b96f757b1081629bfe17cfb809" translate="yes" xml:space="preserve">
          <source>This section covers various approaches to composition of suspending functions.</source>
          <target state="translated">이 섹션은 서 스펜 딩 기능의 구성에 대한 다양한 접근법을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c0b801aac5ae1a9b9aa65ed84d940a1ebfabf5c1" translate="yes" xml:space="preserve">
          <source>This self-contained jar file can be passed directly to a JRE to run your application:</source>
          <target state="translated">이 자체 포함 된 jar 파일은 JRE로 직접 전달되어 애플리케이션을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eff95c0ad7329dd98bdd50eb833ef0910fc787b" translate="yes" xml:space="preserve">
          <source>This simplified example ensures that the JVM, JS, and Kotlin metadata publications are only uploaded when &lt;code&gt;-PisLinux=true&lt;/code&gt; is passed to the build in the command line:</source>
          <target state="translated">이 간단한 예제는 JVM, JS 및 Kotlin 메타 데이터 게시가 명령 행에서 &lt;code&gt;-PisLinux=true&lt;/code&gt; 가 빌드로 전달 될 때만 업로드 되도록합니다.</target>
        </trans-unit>
        <trans-unit id="41a51abdee059894e1c3bfb1c72642c3da8b751d" translate="yes" xml:space="preserve">
          <source>This starts a new coroutine. By default, coroutines are run on a shared pool of threads. Threads still exist in a program based on coroutines, but one thread can run many coroutines, so there's no need for too many threads.</source>
          <target state="translated">새로운 코 루틴이 시작됩니다. 기본적으로 코 루틴은 공유 스레드 풀에서 실행됩니다. 스레드는 여전히 코 루틴 기반 프로그램에 존재하지만 하나의 스레드는 많은 코 루틴을 실행할 수 있으므로 너무 많은 스레드가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08ae2339793360b19c579572a5e9dcd8e02beebb" translate="yes" xml:space="preserve">
          <source>This step helps synchronize your Xcode project with Kotlin Pod dependencies by calling &lt;code&gt;pod install&lt;/code&gt; for your &lt;code&gt;Podfile&lt;/code&gt;.</source>
          <target state="translated">이 단계는 &lt;code&gt;Podfile&lt;/code&gt; 에 대한 &lt;code&gt;pod install&lt;/code&gt; 을 호출하여 Xcode 프로젝트를 Kotlin Pod 종속성과 동기화하는 데 도움이됩니다. .</target>
        </trans-unit>
        <trans-unit id="76c41d50702d4202e91d08f7ef8c0739fa6d0823" translate="yes" xml:space="preserve">
          <source>This syntax is called a &lt;em&gt;destructuring declaration&lt;/em&gt;. A destructuring declaration creates multiple variables at once. We have declared two new variables: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;, and can use them independently:</source>
          <target state="translated">이 구문을 &lt;em&gt;파괴 선언&lt;/em&gt; 이라고합니다 . 파괴 선언은 한 번에 여러 변수를 만듭니다. 우리는 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 라는 두 가지 새로운 변수를 선언 했고 , 그것들을 독립적으로 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="530a8c17c6739ef629eabdb94246db16d43922c7" translate="yes" xml:space="preserve">
          <source>This table says that when the compiler processes, for example, an expression &lt;code&gt;+a&lt;/code&gt;, it performs the following steps:</source>
          <target state="translated">이 테이블은 컴파일러가 예를 들어 &lt;code&gt;+a&lt;/code&gt; 식을 처리 할 때 다음 단계를 수행 한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="cca6caa135016bb5fe36c582797dd2583e1f3082" translate="yes" xml:space="preserve">
          <source>This takes about 10 seconds on my machine, so yes, coroutines do run in parallel.</source>
          <target state="translated">내 컴퓨터에서 약 10 초가 걸리므로 코 루틴이 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="215ff0a6c5e99998fdfa92a79eaf70ff28fc615e" translate="yes" xml:space="preserve">
          <source>This task copies both dependencies runtime files and the compilation output to the &lt;code&gt;web&lt;/code&gt; directory.</source>
          <target state="translated">이 태스크는 종속성 런타임 파일과 컴파일 결과를 &lt;code&gt;web&lt;/code&gt; 디렉토리에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="1a26679828d6c6d2c31183443afd2cce0f1abe38" translate="yes" xml:space="preserve">
          <source>This test will be automatically executed on the JVM target in addition to the common part.</source>
          <target state="translated">이 테스트는 공통 부분 외에 JVM 대상에서 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="422dc05df4ea784a9b658e3b358ccefed13a0844" translate="yes" xml:space="preserve">
          <source>This time we take a returned &lt;code&gt;char *&lt;/code&gt; from the &lt;code&gt;return_string&lt;/code&gt; function and turn it into a Kotlin string. For that we do the following in Kotlin:</source>
          <target state="translated">이번에 는 &lt;code&gt;return_string&lt;/code&gt; 함수 에서 반환 된 &lt;code&gt;char *&lt;/code&gt; 를 가져와 Kotlin 문자열로 바꿉니다. 이를 위해 Kotlin에서 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1bc095b457022b841cd86dbdae9f7dd06a0233ca" translate="yes" xml:space="preserve">
          <source>This time we will ask a C function to write us a C string to a given buffer. The function is called &lt;code&gt;copy_string&lt;/code&gt;. It takes a pointer to the location writing characters and the allowed buffer size. The function returns something to indicate if it has succeeded or failed. Let's assume &lt;code&gt;0&lt;/code&gt; means it succeeded, and the supplied buffer was big enough:</source>
          <target state="translated">이번에는 C 함수에게 주어진 버퍼에 C 문자열을 쓰도록 요청할 것입니다. 이 함수를 &lt;code&gt;copy_string&lt;/code&gt; 이라고 합니다 . 문자를 쓰는 위치와 허용되는 버퍼 크기에 대한 포인터가 필요합니다. 이 함수는 성공 또는 실패 여부를 나타내는 것을 반환합니다. &lt;code&gt;0&lt;/code&gt; 이 성공을 의미하고 제공된 버퍼가 충분히 크다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="95eb5f454522f97d35d22eb89071211f56ea5b5c" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use Kotlin Android Extensions to improve support for Android development.</source>
          <target state="translated">이 학습서는 Kotlin Android 확장을 사용하여 Android 개발 지원을 개선하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="54b32f69d1a441fb0920f9a2c8eb9ed0a6588065" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use in Kotlin popular Android frameworks and libraries that rely on annotation processing.</source>
          <target state="translated">이 튜토리얼에서는 주석 처리에 의존하는 Kotlin의 인기있는 Android 프레임 워크 및 라이브러리에서 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="98dac163941bb963709918b2eba82c9b82af15ef" translate="yes" xml:space="preserve">
          <source>This tutorial explains the basic usage of Kotlin for competitive programming.</source>
          <target state="translated">이 튜토리얼은 경쟁력있는 프로그래밍을위한 Kotlin의 기본 사용법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d0f7acc9fd5623b0666fe34b54ba37696a87ee9a" translate="yes" xml:space="preserve">
          <source>This tutorial explains the different approaches to asynchronous programming</source>
          <target state="translated">이 튜토리얼은 비동기 프로그래밍에 대한 다양한 접근 방식을 설명합니다</target>
        </trans-unit>
        <trans-unit id="b37aa099eaa69fb3a0a9c2ea81dc57defd40be24" translate="yes" xml:space="preserve">
          <source>This tutorial is designed both for competitive programmers that did not use Kotlin before and for Kotlin developers that did not participate in any competitive programming events before. It assumes the corresponding programming skills.</source>
          <target state="translated">이 튜토리얼은 이전에 Kotlin을 사용하지 않은 경쟁 프로그래머와 이전에 경쟁 프로그래밍 이벤트에 참여하지 않은 Kotlin 개발자를 위해 설계되었습니다. 해당 프로그래밍 기술을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6ab5e488d7caf8012aa22bda0a09bdd7f98d9861" translate="yes" xml:space="preserve">
          <source>This tutorial shows how to debug a Kotlin/JS project build by Gradle. If you are using Maven or IDEA, the recipes would be similar.</source>
          <target state="translated">이 튜토리얼은 Gradle의 Kotlin / JS 프로젝트 빌드를 디버깅하는 방법을 보여줍니다. Maven 또는 IDEA를 사용하는 경우 레시피는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="f9acc149373601d8ab69e64887e6e309b360247b" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to run Kotlin code snippets in a lightweight manner without creating or modifying the whole project.</source>
          <target state="translated">이 튜토리얼은 전체 프로젝트를 만들거나 수정하지 않고 간단한 방식으로 Kotlin 코드 스 니펫을 실행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="946efbdf49896b1eceb2a440b208d6a7b7c887c4" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to write and run Kotlin code snippets in a lightweight manner without creating entire applications.</source>
          <target state="translated">이 가이드에서는 전체 애플리케이션을 만들지 않고 가벼운 방식으로 Kotlin 코드 스 니펫을 작성하고 실행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b741e974e2ef9e2aadef771ec4ed4af6da26b1ed" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Hello World application using the command line compiler.</source>
          <target state="translated">이 튜토리얼은 명령 행 컴파일러를 사용하여 Hello World 애플리케이션을 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="9ef69a04e24828e3b4f1be864d64b99505227e64" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Kotlin JavaScript library using the command line compiler.</source>
          <target state="translated">이 튜토리얼은 명령 행 컴파일러를 사용하여 Kotlin JavaScript 라이브러리를 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7cbf690e869df1155e9df8254a2e24065f3c7742" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a simple Kotlin application for Android.</source>
          <target state="translated">이 튜토리얼은 Android 용 간단한 Kotlin 응용 프로그램을 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="262f778d62fb1c6728a7e17683a48adb22e2c354" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through setting up a project using coroutines, and writing code that uses them.</source>
          <target state="translated">이 튜토리얼은 코 루틴을 사용하여 프로젝트를 설정하고이를 사용하는 코드를 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="b761f80d7daf0f57c426b6c2c8f5551348835c06" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple REST controller with Spring Boot</source>
          <target state="translated">이 튜토리얼은 Spring Boot로 간단한 REST 컨트롤러를 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="d3c06d78974760f747dc344799aadb31e636411d" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple controller using HttpServlet to display Hello World.</source>
          <target state="translated">이 튜토리얼은 HttpServlet을 사용하여 Hello World를 표시하는 간단한 컨트롤러를 만드는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="917a46d0d52ec8a68291cefda5c1868408d5366b" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of using Java and Kotlin in a single IntelliJ IDEA project.</source>
          <target state="translated">이 튜토리얼에서는 단일 IntelliJ IDEA 프로젝트에서 Java 및 Kotlin을 사용하는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="5c37cdc48efb7900f24478fb914764b4ad25e974" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through a series of exercises to get familiar with Kotlin.</source>
          <target state="translated">이 튜토리얼은 Kotlin에 익숙해 지도록 일련의 연습을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="fed85180abcbc65ba4b2af3d5f5d2d524508a6b7" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through creating a simple Hello World application using IntelliJ IDEA.</source>
          <target state="translated">이 자습서는 IntelliJ IDEA를 사용하여 간단한 Hello World 응용 프로그램을 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="3a3a5550c3979eb75d3c935292c9198b690dcdbe" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through the interactive learning with a set of Kotlin programming tasks.</source>
          <target state="translated">이 튜토리얼은 일련의 Kotlin 프로그래밍 작업을 통해 대화식 학습을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="1922851cbe5cc3d86c3c73d15c6f4bdffb8c9675" translate="yes" xml:space="preserve">
          <source>This tutorial will walk you through creating a simple Kotlin course with a set of programming tasks and integrated tests.</source>
          <target state="translated">이 튜토리얼은 일련의 프로그래밍 작업과 통합 테스트로 간단한 Kotlin 코스를 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="c6030bef069b6977eab83078442b66dedd7712ad" translate="yes" xml:space="preserve">
          <source>This tutorials walks us through creating a simple Hello World application using Eclipse IDE</source>
          <target state="translated">이 튜토리얼은 Eclipse IDE를 사용하여 간단한 Hello World 애플리케이션을 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="1cba3a52b4e9e49248914c3506dd87812401b394" translate="yes" xml:space="preserve">
          <source>This type is used as a receiver type of the lambda function passed to the &lt;a href=&quot;../contract&quot;&gt;contract&lt;/a&gt; function.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;../contract&quot;&gt;계약&lt;/a&gt; 함수에 전달 된 람다 함수의 수신자 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d42addf558756322234c05ff9ff53ebc28a290b0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">이 값은 &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 인수 의 반환 값으로 사용되어 실행이 일시 중단되었으며 결과를 즉시 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f268b965a48f4655e5367448b4016e6f76edf6f0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">이 값은 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 인수 의 반환 값으로 사용되어 실행이 일시 중단되었으며 결과를 즉시 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6e8f43b127da8dc0c4ddf32ba0afa9420b6890c9" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="translated">이 값은 &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;해당&lt;/a&gt; 값 보다 작아야 합니다 . 그렇지 않으면 반환 된 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d268ef4eff4a4c02ff30a25a66e6ca340c2e614" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo(kotlin.ranges.rangeTo.T,%20kotlin.ranges.rangeTo.T)/that&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="translated">이 값은 &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo(kotlin.ranges.rangeTo.T,%20kotlin.ranges.rangeTo.T)/that&quot;&gt;해당&lt;/a&gt; 값 보다 작아야 합니다 . 그렇지 않으면 반환 된 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4e95d6779047f36ef44cebc8fe10ec0e5dbd2f" translate="yes" xml:space="preserve">
          <source>This way any value of type &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; can be passed as an argument of &lt;code&gt;const char*&lt;/code&gt; type. If a Kotlin string should be passed, code like this could be used:</source>
          <target state="translated">이런 식으로 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; 유형의 값 을 &lt;code&gt;const char*&lt;/code&gt; 유형 의 인수로 전달할 수 있습니다 . Kotlin 문자열을 전달해야하는 경우 다음과 같은 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a5e105dc56eeee056d102244e8a0f5fed4f0c6" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope are cancelled.</source>
          <target state="translated">이런 식으로, &lt;code&gt;concurrentSum&lt;/code&gt; 함수 의 코드 내에서 문제 가 발생하여 예외가 발생하면 해당 범위에서 시작된 모든 코 루틴이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="751432b1fc412bf87d1b4554a9034d2372594768" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of the &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope will be cancelled.</source>
          <target state="translated">이렇게하면 &lt;code&gt;concurrentSum&lt;/code&gt; 함수 의 코드에서 문제 가 발생하여 예외가 발생하면 해당 범위에서 시작된 모든 코 루틴이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="f17f9d1f7410fbad939ec9e37eb14f1a6139cb16" translate="yes" xml:space="preserve">
          <source>This will apply the Gradle &lt;code&gt;java&lt;/code&gt; plugin and configure the target to cooperate with it. Note that just applying the Java plugin without specifying &lt;code&gt;withJava()&lt;/code&gt; in a JVM target will have no effect on the target.</source>
          <target state="translated">Gradle &lt;code&gt;java&lt;/code&gt; 플러그인 을 적용하고 대상과 협력하도록 구성합니다. JVM 대상에서 &lt;code&gt;withJava()&lt;/code&gt; 를 지정하지 않고 Java 플러그인을 적용해도 대상에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e9c760291236659fa80c3cad20690354472cf0c" translate="yes" xml:space="preserve">
          <source>This will assign &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is non-null, but if it is null, the entire function that contains this expression will stop and return &lt;code&gt;y&lt;/code&gt; (this works because &lt;code&gt;return&lt;/code&gt; is also an expression, and if it is evaluated, it evaluates its argument and then makes the containing function return the result).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 널이 아닌 경우 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;z&lt;/code&gt; 를 할당 하지만, 널이 아닌 경우이 표현식을 포함하는 전체 함수는 중지하고 &lt;code&gt;y&lt;/code&gt; 를 리턴합니다 ( &lt;code&gt;return&lt;/code&gt; 도 표현식 이기 때문에 작동 하며, 평가되는 경우에는이를 평가합니다). 인수를 포함하고 포함 함수가 결과를 리턴하게합니다.</target>
        </trans-unit>
        <trans-unit id="e3c6e68d7f248b58990253f88430e5ca4c4c8e2b" translate="yes" xml:space="preserve">
          <source>This will automatically implement all the interface members of &lt;code&gt;PowerSource&lt;/code&gt; in &lt;code&gt;MotorVehicle&lt;/code&gt; by invoking the same member on &lt;code&gt;engine&lt;/code&gt;. This only works for properties that are declared in the constructor.</source>
          <target state="translated">&lt;code&gt;engine&lt;/code&gt; 에서 동일한 멤버를 호출하여 &lt;code&gt;MotorVehicle&lt;/code&gt; 에서 &lt;code&gt;PowerSource&lt;/code&gt; 의 모든 인터페이스 멤버를 자동으로 구현합니다 . 생성자에서 선언 된 속성에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4c10956ebfa0383ee2f1e029c8feb69cf8fc5ac" translate="yes" xml:space="preserve">
          <source>This will raise a &lt;code&gt;ClassCastException&lt;/code&gt; if the object is not actually an instance of &lt;code&gt;Person&lt;/code&gt; or any of its subclasses. If you're not sure what &lt;code&gt;x&lt;/code&gt; is, but you're happy to get null if it's not a &lt;code&gt;Person&lt;/code&gt;, you can use &lt;code&gt;as?&lt;/code&gt;, which will return null if the cast fails. Note that the resulting type is &lt;code&gt;Person?&lt;/code&gt;:</source>
          <target state="translated">이것은 올릴 것이다 &lt;code&gt;ClassCastException&lt;/code&gt; 이 객체가 실제의 인스턴스가 아닌 경우 &lt;code&gt;Person&lt;/code&gt; 또는 그 서브 클래스의. &lt;code&gt;x&lt;/code&gt; 가 무엇인지 확실 하지 않지만 &lt;code&gt;Person&lt;/code&gt; 이 아닌 경우 null을 얻는 것이 행복하다면 다음 &lt;code&gt;as?&lt;/code&gt; 사용할 수 있습니까? 캐스트에 실패하면 null을 반환합니다. 결과 유형은 &lt;code&gt;Person?&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa6b2b95ad5f670c5af166fa09cb0ec4fc6be37b" translate="yes" xml:space="preserve">
          <source>This works also for &lt;em&gt;var&lt;/em&gt;&amp;rsquo;s properties if you use a &lt;code&gt;MutableMap&lt;/code&gt; instead of read-only &lt;code&gt;Map&lt;/code&gt;:</source>
          <target state="translated">읽기 전용 &lt;code&gt;Map&lt;/code&gt; 대신 &lt;code&gt;MutableMap&lt;/code&gt; 을 사용하는 경우 &lt;em&gt;var&lt;/em&gt; 의 속성 에도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="dfbae76eefb17a295e772659a5df1b063a9b20dc" translate="yes" xml:space="preserve">
          <source>Those class names are always getting in the way. We can use static imports and get this:</source>
          <target state="translated">그 클래스 이름은 항상 방해가되고 있습니다. 정적 가져 오기를 사용하여 다음을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="840686b21fe85a3d03fcebd9f6fe5d67ee5b8f5f" translate="yes" xml:space="preserve">
          <source>Though reflection may not be needed in many cases, we can still use it with a reified type parameter:</source>
          <target state="translated">대부분의 경우 리플렉션이 필요하지 않을 수도 있지만, reified type 매개 변수와 함께 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9c8e28b5db7e794581721a97a55d403ef96db4" translate="yes" xml:space="preserve">
          <source>Thread confinement coarse-grained</source>
          <target state="translated">스레드 감금 거친</target>
        </trans-unit>
        <trans-unit id="58c8dc7270e76e9fe5dcba1621b0a309ea2a0ff5" translate="yes" xml:space="preserve">
          <source>Thread confinement fine-grained</source>
          <target state="translated">세밀한 스레드 감금</target>
        </trans-unit>
        <trans-unit id="07c0a8bbcccb40629ed6cd8852b0c2af35dea6b2" translate="yes" xml:space="preserve">
          <source>Thread-local data</source>
          <target state="translated">스레드 로컬 데이터</target>
        </trans-unit>
        <trans-unit id="b51d97d48189b14ee90ab80ab5f1002db2ed52a4" translate="yes" xml:space="preserve">
          <source>Thread-safe data structures</source>
          <target state="translated">스레드 안전 데이터 구조</target>
        </trans-unit>
        <trans-unit id="8a77bfd3db44e0aeb0a80c2f055eea2ff97f89d4" translate="yes" xml:space="preserve">
          <source>ThreadLocal</source>
          <target state="translated">ThreadLocal</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="54fc24f5a7668604be098318c177c182e63b5fa7" translate="yes" xml:space="preserve">
          <source>Threads are by far probably the most well-known approach to avoid applications from blocking.</source>
          <target state="translated">스레드는 아마도 응용 프로그램의 차단을 피하는 가장 잘 알려진 방법 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8cb6272d819adb1d7ec29aee37d20ed2b2cd093" translate="yes" xml:space="preserve">
          <source>Threads aren't always available. Some platforms, such as JavaScript do not even support threads</source>
          <target state="translated">스레드를 항상 사용할 수있는 것은 아닙니다. JavaScript와 같은 일부 플랫폼은 스레드를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="100ffacab3bbb22c877b7db046d6811ab68a4092" translate="yes" xml:space="preserve">
          <source>Threads aren't cheap. Threads require context switches which are costly.</source>
          <target state="translated">실은 싸지 않습니다. 스레드에는 비용이 많이 드는 컨텍스트 스위치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed5d4b963a60e738f823f980aab2e771fb9e0b19" translate="yes" xml:space="preserve">
          <source>Threads aren't easy. Debugging threads, avoiding race conditions are common problems we suffer in multi-threaded programming.</source>
          <target state="translated">스레드는 쉽지 않습니다. 경쟁 조건을 피하면서 스레드 디버깅은 멀티 스레드 프로그래밍에서 흔히 발생하는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="dada4feb2387f68301b5e37c631ce74cff4d977a" translate="yes" xml:space="preserve">
          <source>Threads aren't infinite. The number of threads that can be launched is limited by the underlying operating system. In server-side applications, this could cause a major bottleneck.</source>
          <target state="translated">스레드는 무한하지 않습니다. 시작할 수있는 스레드 수는 기본 운영 체제에 따라 제한됩니다. 서버 측 응용 프로그램에서는 이로 인해 심각한 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea7ecc8ef4eb25f7a1da622aee2bb4b90728e800" translate="yes" xml:space="preserve">
          <source>Through these platforms you can access the &lt;strong&gt;platform native code&lt;/strong&gt; (JVM, JS, and Native) and leverage all native capabilities.</source>
          <target state="translated">이러한 플랫폼을 통해 &lt;strong&gt;플랫폼 네이티브 코드&lt;/strong&gt; (JVM, JS 및 네이티브)에 액세스하고 모든 네이티브 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8abf11297f412ee4fff55514bb434f634e293565" translate="yes" xml:space="preserve">
          <source>Throwable</source>
          <target state="translated">Throwable</target>
        </trans-unit>
        <trans-unit id="eac1fd32ab840fc388b25886124b82f77d7d2760" translate="yes" xml:space="preserve">
          <source>Throwing and catching</source>
          <target state="translated">던지고 잡기</target>
        </trans-unit>
        <trans-unit id="866ed5ebf5c2f2a9c6597aa6906378e31d48e178" translate="yes" xml:space="preserve">
          <source>Thrown by cancellable suspending functions if the coroutine is cancelled while it is suspended. It indicates &lt;em&gt;normal&lt;/em&gt; cancellation of a coroutine.</source>
          <target state="translated">코 루틴이 일시 중단 된 동안 취소되면 취소 가능한 일시 중단 함수에 의해 throw됩니다. &lt;em&gt;정상을&lt;/em&gt; 나타냅니다.&lt;em&gt;&lt;/em&gt;코 루틴의 취소를 .</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="b1b2da4ce29be6e42fd3a3a1d87f8fd7bd99c3f3" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="21712a0494f28f6a46c5535db142ea2522d8b30e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="b88e532ebba6a290db595d7e93591bf93e58ec5d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="a834d850910b82b32184bf20e615c66a32c33ffc" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="b187627b0474be6a63105d8fbe200f08b14f46f0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="d8d5a9cbb5d90075a851ac67a508560060d907ea" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="877c528f0857e16d746ea6daff3b5297368a55b2" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="cb0860bdd589a1bb034f027aa22414ee9971d985" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea를&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="6495db8a536c8d755d3c31cd2f1405c6a5089dde" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;, IllegalArgumentException를&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="a435a6330bdfb93f8f0baf2519c326f8c8a67d8c" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;, IllegalArgumentException를&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean)/value&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="452d882ee13cc2478203bd62e2127715d9c6ce3d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;값&lt;/a&gt; 이 null 인 경우 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException을&lt;/a&gt; throw합니다 . 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dbf5201e6e48ab5572c5ef4e7b99a7cfc2a7333" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?)/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;, IllegalArgumentException를&lt;/a&gt; 경우 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?)/value&quot;&gt;값이&lt;/a&gt; null입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d30f2afa782c5c47e8fd1fd37da6b472b4245324" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="6af1ad354715d427817f522962505b9c2ca46b8d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="e3e3dc9398319dc7d021d329ec499047c0ffa229" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 널 (null)입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1585605996fe54d528d4847469a1c01a292a3702" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">값이 다음 과 같은 경우 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; 호출 결과와 함께 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; 이 발생 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;합니다.&lt;/a&gt; 널 (null)입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cde80ff370e1f63acd5ebfbb8e922a017c83fe9e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="ef2f3f8adf5e012243cd34b2702b7a2ac8adf662" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 는 IF &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean)/value&quot;&gt;값&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="402cd2d9df6a156fba6fc0cc6697b5d76b649c05" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;값이&lt;/a&gt; null입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dda2799a06b523e6b176c9ee67f6d63f48ada3d8" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?)/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?)/value&quot;&gt;값이&lt;/a&gt; null입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f113c02962407d7507fe9485b4da7237a47f7c4" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;message&lt;/a&gt;.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 주어진와 &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;메시지를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5181608eaea2225525164d5696d71e611d6d7bd0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error(kotlin.Any)/message&quot;&gt;message&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;error#kotlin%24error(kotlin.Any)/message&quot;&gt;메시지&lt;/a&gt; 와 함께 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 을 던집니다 .</target>
        </trans-unit>
        <trans-unit id="a87a5cbfe4f8dd0bce93da8e99fc5031d54a4b66" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="f984d420014f0ad6416ec5b1ab125dd6010c5b27" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="a52512f1adf6d29a59645748fabb172d879e3685" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 생성 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 널 (null)이다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="493d7b4fc94a4de0e97d67db438c813b7833a321" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 생성 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 널 (null)이다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4dd5a74a27ccc78ea75829f90e11af066deef725" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 1.</source>
          <target state="translated">이 목록의 크기가 1보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="b0dfa8cfada0f87002fce9e2dcf29d69386eb81f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 2.</source>
          <target state="translated">이 목록의 크기가 2보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="bc0636ec717eef51c36cc08b0d19404e2a1e901f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 3.</source>
          <target state="translated">이 목록의 크기가 3 미만인 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="e916ab2f35fc79abd1560b46cce8cf83ff72163a" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 4.</source>
          <target state="translated">이 목록의 크기가 4보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="17cfbe66f161c701133c0656f5b1abbe3644c69f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 5.</source>
          <target state="translated">이 목록의 크기가 5보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; throw합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb093191144e508e969bd08f6b07ef13c7da6e0" translate="yes" xml:space="preserve">
          <source>Throws an exception if the sequence is constrained to be iterated once and &lt;code&gt;iterator&lt;/code&gt; is invoked the second time.</source>
          <target state="translated">시퀀스가 한 번 반복되도록 제한되고 두 번째로 &lt;code&gt;iterator&lt;/code&gt; 가 호출 되면 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fd78909be435341dfba595389f3fa1467854f4e" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8285a899ac5a29cc7129aa4da6958e875202fb46" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3e1ce4459287d83d21368b2dc4cdc52b9cd0160c" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f4b2f84f4e57b04b9edd9c87d2979e39d26f5771" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b185c5f4e93631e2a060ab41fb4eb57e4de681a" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ef32dfbd1a922263c5c164f620e7b2908d21430d" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e93b6c2ea0c9c6c6ad13686a90f2bf85ab5f5baf" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4fd3822175bffcfa7e80b1f53ede5ab3ae2bc086" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eacd93615a6dd16e6f9a9d63ee869eefaa897d95" translate="yes" xml:space="preserve">
          <source>Throws an exception if this collection is empty. If the collection can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 컬렉션이 비어 있으면 예외를 throw합니다. 컬렉션이 예상대로 비어있는 경우 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7624ee5a82ead06e5c18d4b5b2178b988495c62d" translate="yes" xml:space="preserve">
          <source>Throws an exception if this collection is empty. If the collection can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 컬렉션이 비어 있으면 예외를 throw합니다. 컬렉션이 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f601e98edd4457fbbb656d028259bf3599380762" translate="yes" xml:space="preserve">
          <source>Throws an exception if this list is empty. If the list can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 목록이 비어 있으면 예외가 발생합니다. 목록이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a6b616691ee940145aebe0fc262a2f6d65461cd7" translate="yes" xml:space="preserve">
          <source>Throws an exception if this list is empty. If the list can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 목록이 비어 있으면 예외가 발생합니다. 목록이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4581922a0ef91d93af0368bead5bd7539b44ea3" translate="yes" xml:space="preserve">
          <source>Throws an exception if this sequence is empty. If the sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 시퀀스가 ​​비어 있으면 예외가 발생합니다. 시퀀스가 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9ce91e94c848fefcebcae40244d52f7890553ddb" translate="yes" xml:space="preserve">
          <source>Throws an exception if this sequence is empty. If the sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 시퀀스가 ​​비어 있으면 예외가 발생합니다. 시퀀스가 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="802eb217aa06b1ddcf50385d8b88823ead2d004a" translate="yes" xml:space="preserve">
          <source>Throws an exception since enum constants cannot be cloned. This method prevents enum classes from inheriting from &lt;code&gt;Cloneable&lt;/code&gt;.</source>
          <target state="translated">열거 형 상수를 복제 할 수 없으므로 예외가 발생합니다. 이 메서드는 열거 형 클래스가 &lt;code&gt;Cloneable&lt;/code&gt; 로부터 상속되지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="abf5b40e0b4f0a5382568a99833124d4e1e46035" translate="yes" xml:space="preserve">
          <source>Thus, if the layout filename is &lt;code&gt;activity_main.xml&lt;/code&gt;, we'd import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt;.</source>
          <target state="translated">따라서 레이아웃 파일 이름이 &lt;code&gt;activity_main.xml&lt;/code&gt; 인 경우 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="97edcc8b1307ff786c44c31ec2579356e7a22d17" translate="yes" xml:space="preserve">
          <source>Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.</source>
          <target state="translated">따라서 NPE를 원할 경우 NPE를 가질 수는 있지만 명시 적으로 요청해야하며 파란색으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd3fb291d3a706316d022aff145e9de544011b65" translate="yes" xml:space="preserve">
          <source>Thus, single quotes can not be used to form string literals.</source>
          <target state="translated">따라서 작은 따옴표를 사용하여 문자열 리터럴을 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b9124e1ec7c5edcf4abab648d63459254b7d7ee" translate="yes" xml:space="preserve">
          <source>Thus, the &lt;code&gt;last&lt;/code&gt; element is not always the same as the specified end value.</source>
          <target state="translated">따라서 &lt;code&gt;last&lt;/code&gt; 요소가 지정된 끝 값과 항상 같지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3018655a2f36aad6ef9ad9471b91d569410cec76" translate="yes" xml:space="preserve">
          <source>Thus, you can create something resource manager-like by creating a class that implements &lt;code&gt;Closeable&lt;/code&gt;, does its setup work in &lt;code&gt;init&lt;/code&gt;, and does its cleanup work in &lt;code&gt;close()&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;Closeable&lt;/code&gt; 을 구현 하고 설정이 &lt;code&gt;init&lt;/code&gt; 에서 작동하며 정리가 &lt;code&gt;close()&lt;/code&gt; 에서 작동 하는 클래스를 작성하여 자원 관리자와 같은 것을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f717771b6bc333649ebdd74853decf5175f1649" translate="yes" xml:space="preserve">
          <source>Ticker channel is a special rendezvous channel that produces &lt;code&gt;Unit&lt;/code&gt; every time given delay passes since last consumption from this channel. Though it may seem to be useless standalone, it is a useful building block to create complex time-based &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; pipelines and operators that do windowing and other time-dependent processing. Ticker channel can be used in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; to perform &quot;on tick&quot; action.</source>
          <target state="translated">티커 채널은 이 채널에서 마지막으로 소비 된 이후 지연 시간이 주어질 때마다 &lt;code&gt;Unit&lt;/code&gt; 를 생성하는 특수한 랑데부 채널입니다 . 쓸모없는 독립형처럼 보일 수도 있지만, 윈도 잉 및 기타 시간 종속 처리를 수행 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;하는&lt;/a&gt; 복잡한 시간 기반 생산 파이프 라인 및 운영자 를 생성하는 데 유용한 빌딩 블록 입니다. 티커 채널은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;선택시&lt;/a&gt; &quot;틱시&quot;작업을 수행 하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="709221186863e6ea184e824b11c1140ada1e2ad5" translate="yes" xml:space="preserve">
          <source>Ticker channels</source>
          <target state="translated">티커 채널</target>
        </trans-unit>
        <trans-unit id="10572d800e81a954a70d12fcb00a40ac135136f2" translate="yes" xml:space="preserve">
          <source>TimeMark</source>
          <target state="translated">TimeMark</target>
        </trans-unit>
        <trans-unit id="6e9104aba3fe18e4dd8562ba5f52cb92ded067dc" translate="yes" xml:space="preserve">
          <source>TimeRanges</source>
          <target state="translated">TimeRanges</target>
        </trans-unit>
        <trans-unit id="c90348d5ff080b78282efd07b8b0ed4226890eee" translate="yes" xml:space="preserve">
          <source>TimeSource</source>
          <target state="translated">TimeSource</target>
        </trans-unit>
        <trans-unit id="eca969ef85583fca89468fa678b49acb2534e5b8" translate="yes" xml:space="preserve">
          <source>TimedValue</source>
          <target state="translated">TimedValue</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="799c2191675c2bb6c5c783e298421617f1390ce2" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;prepare for Java 9 support&lt;/a&gt;, the extension functions and properties in the &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; library have been moved to the package &lt;code&gt;kotlin.reflect.full&lt;/code&gt;. The names in the old package (&lt;code&gt;kotlin.reflect&lt;/code&gt;) are deprecated and will be removed in Kotlin 1.2. Note that the core reflection interfaces (such as &lt;code&gt;KClass&lt;/code&gt;) are part of the Kotlin standard library, not &lt;code&gt;kotlin-reflect&lt;/code&gt;, and are not affected by the move.</source>
          <target state="translated">하기 위해 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;자바 (9) 지원을위한 준비&lt;/a&gt; 의의 확장 기능 및 특성 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 라이브러리는 패키지로 이동되었습니다 &lt;code&gt;kotlin.reflect.full&lt;/code&gt; . 이전 패키지 ( &lt;code&gt;kotlin.reflect&lt;/code&gt; ) 의 이름 은 더 이상 사용되지 않으며 Kotlin 1.2에서 제거됩니다. 핵심 반사 인터페이스 (예 : &lt;code&gt;KClass&lt;/code&gt; )는 &lt;code&gt;kotlin-reflect&lt;/code&gt; 가 아닌 Kotlin 표준 라이브러리의 일부이며 이동의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05823a5d5a74d4953764cdf3ac4c6b3fb68f1e64" translate="yes" xml:space="preserve">
          <source>To Use</source>
          <target state="translated">쓰다</target>
        </trans-unit>
        <trans-unit id="9d9e0e01bc3681e891f7f867582c90865280f877" translate="yes" xml:space="preserve">
          <source>To accept and propagate the experimental status to your whole module, compile the module with the argument &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. In this case, &lt;em&gt;every declaration&lt;/em&gt; in the module becomes experimental. The use of the module requires the acceptance of its experimental status as well.</source>
          <target state="translated">실험 상태를 수락하여 전체 모듈에 전파하려면 인수 &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; 로 모듈을 컴파일하십시오 . 이 경우 모듈의 &lt;em&gt;모든 선언&lt;/em&gt; 은 실험적입니다. 모듈을 사용하려면 실험 상태도 수용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0b5cb313d227acb944e950971366b62de8d6de6" translate="yes" xml:space="preserve">
          <source>To accept the experimental status without propagation, compile the module with the argument &lt;code&gt;-Xuse-experimental&lt;/code&gt;, specifying the fully qualified name of the experimental API marker you use: &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt;.</source>
          <target state="translated">전파하지 않고 실험 상태를 승인하려면 사용하는 실험 API 마커의 완전한 이름을 지정하여 &lt;code&gt;-Xuse-experimental&lt;/code&gt; 인수로 모듈을 컴파일하십시오 . &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; . 이 인수로 컴파일하면 모듈의 모든 선언에 &lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt; 주석이있는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9903a558b00c4bc82f88c2dfad1d5c92c9e2ae3f" translate="yes" xml:space="preserve">
          <source>To accept the usage of multiple experimental APIs on the module level, add one of the described arguments for each experimental API marker used in your module.</source>
          <target state="translated">모듈 레벨에서 여러 실험 API의 사용을 승인하려면 모듈에 사용 된 각 실험 API 마커에 대해 설명 된 인수 중 하나를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d162c0174f5af87401e6b5d45d66155192832d80" translate="yes" xml:space="preserve">
          <source>To access &lt;em&gt;this&lt;/em&gt; from an outer scope (a &lt;a href=&quot;classes&quot;&gt;class&lt;/a&gt;, or &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;, or labeled &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;) we write &lt;code&gt;this@label&lt;/code&gt; where &lt;code&gt;@label&lt;/code&gt; is a &lt;a href=&quot;returns&quot;&gt;label&lt;/a&gt; on the scope &lt;em&gt;this&lt;/em&gt; is meant to be from:</source>
          <target state="translated">액세스하려면 &lt;em&gt;이&lt;/em&gt; 외부 범위 (A에서 &lt;a href=&quot;classes&quot;&gt;클래스&lt;/a&gt; , 또는 &lt;a href=&quot;extensions&quot;&gt;확장 기능&lt;/a&gt; , 또는 표시된 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기 기능 리터럴은&lt;/a&gt; ) 우리는 기록 &lt;code&gt;this@label&lt;/code&gt; &lt;code&gt;@label&lt;/code&gt; 는 A는 &lt;a href=&quot;returns&quot;&gt;라벨&lt;/a&gt; 범위에 대한 &lt;em&gt;이가&lt;/em&gt; 보낸 것으로 의미를 :</target>
        </trans-unit>
        <trans-unit id="5db6557812d02b15eefb7397c674770717b897fd" translate="yes" xml:space="preserve">
          <source>To access a property that is a member of a class, we qualify it:</source>
          <target state="translated">클래스 멤버 인 속성에 액세스하려면 다음과 같이 자격을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="81410d36157afd9871ba5225faca2642fb141190" translate="yes" xml:space="preserve">
          <source>To access properties as first-class objects in Kotlin, we can also use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">Kotlin에서 일류 객체로 속성에 액세스하기 위해 &lt;code&gt;::&lt;/code&gt; 연산자를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58a760c627562db97cdca1a84e7db3c27c2f629c" translate="yes" xml:space="preserve">
          <source>To access static members of a Java type that is &lt;a href=&quot;#mapped-types&quot;&gt;mapped&lt;/a&gt; to a Kotlin type, use the full qualified name of the Java type: &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt;.</source>
          <target state="translated">Kotlin 유형에 &lt;a href=&quot;#mapped-types&quot;&gt;맵핑&lt;/a&gt; 된 Java 유형의 정적 멤버에 액세스하려면 Java 유형 의 완전한 이름 인 &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7529d2d95d23cbd6b23debe45e1e3095efe982cc" translate="yes" xml:space="preserve">
          <source>To achieve &lt;code&gt;mutable XOR global&lt;/code&gt; invariant, all globally visible state (currently, &lt;code&gt;object&lt;/code&gt; singletons and enums) are automatically frozen. If object freezing is not desired, a &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; annotation can be used, which will make the object state thread local, and so, mutable (but the changed state is not visible to other threads).</source>
          <target state="translated">&lt;code&gt;mutable XOR global&lt;/code&gt; 불변 값 을 달성하기 위해 모든 전역 적으로 볼 수있는 상태 (현재 &lt;code&gt;object&lt;/code&gt; 싱글 톤 및 열거 형)가 자동으로 고정됩니다. 객체 동결이 필요하지 않은 경우, &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; 주석을 사용하여 객체 상태 스레드를 로컬로 만들 수 있으므로 변경할 수 있습니다 (그러나 변경된 상태는 다른 스레드에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="1019a589281c0c646b20946b4cd19b5c15e8fdaa" translate="yes" xml:space="preserve">
          <source>To activate DCE tool, add the following line to &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">DCE 도구를 활성화하려면 &lt;code&gt;build.gradle&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="518dd8e0c3f079203e35eb4b3c3a2d8d28ec483f" translate="yes" xml:space="preserve">
          <source>To add a dependency on a library, set the dependency of the required &lt;a href=&quot;#dependency-types&quot;&gt;type&lt;/a&gt; (for example, &lt;code&gt;implementation&lt;/code&gt;) in the &lt;code&gt;dependencies&lt;/code&gt; block of the source sets DSL.</source>
          <target state="translated">라이브러리에 대한 종속성을 추가하려면 소스 세트 DSL 의 &lt;code&gt;dependencies&lt;/code&gt; 블록 에서 필요한 &lt;a href=&quot;#dependency-types&quot;&gt;유형&lt;/a&gt; (예 : &lt;code&gt;implementation&lt;/code&gt; )의 종속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a7881622441c034d7bab9ec188cf250853bf301a" translate="yes" xml:space="preserve">
          <source>To add a dependency to a source set, use a &lt;code&gt;dependencies { ... }&lt;/code&gt; block of the source sets DSL. Four kinds of dependencies are supported:</source>
          <target state="translated">소스 세트에 종속성을 추가하려면 소스 세트 DSL의 &lt;code&gt;dependencies { ... }&lt;/code&gt; 블록을 사용하십시오. 네 가지 종류의 종속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1a499912e7035afeaf92f7261767aa556ac8c3f9" translate="yes" xml:space="preserve">
          <source>To add a new key-value pair to a mutable map, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt;. When a new entry is put into a &lt;code&gt;LinkedHashMap&lt;/code&gt; (the default map implementation), it is added so that it comes last when iterating the map. In sorted maps, the positions of new elements are defined by the order of their keys.</source>
          <target state="translated">변경 가능한 맵에 새 키-값 쌍을 추가하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; . 새 항목을 &lt;code&gt;LinkedHashMap&lt;/code&gt; (기본 맵 구현)에 넣으면 맵을 반복 할 때 마지막에 오도록 추가됩니다. 정렬 된 맵에서 새 요소의 위치는 키 순서에 따라 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f2454f68b2510146a6d3830da5c71ddda2db8b87" translate="yes" xml:space="preserve">
          <source>To add a single element to a list or a set, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; function. The specified object is appended to the end of the collection.</source>
          <target state="translated">단일 요소를 목록 또는 세트에 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 하려면 add () 함수를 사용하십시오 . 지정된 개체가 컬렉션 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc1110c5b9a5333f0f0fec5eb2e00b218df46d2" translate="yes" xml:space="preserve">
          <source>To add elements to a specific position in a list, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt;&lt;code&gt;addAll()&lt;/code&gt;&lt;/a&gt; providing the position for element insertion as an additional argument. All elements that come after the position shift to the right.</source>
          <target state="translated">목록의 특정 위치에 요소를 추가하려면 add &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt; &lt;code&gt;addAll()&lt;/code&gt; &lt;/a&gt; 을 사용하여 요소 삽입 위치를 추가 인수로 제공하십시오. 위치 뒤에 오는 모든 요소는 오른쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8035a3b6b37b3480851f2821e2b47d2393940de4" translate="yes" xml:space="preserve">
          <source>To add multiple entries at a time, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt;&lt;code&gt;putAll()&lt;/code&gt;&lt;/a&gt;. Its argument can be a &lt;code&gt;Map&lt;/code&gt; or a group of &lt;code&gt;Pair&lt;/code&gt;s: &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Sequence&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">한 번에 여러 항목을 추가하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt; &lt;code&gt;putAll()&lt;/code&gt; &lt;/a&gt; . 인수는 &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;Pair&lt;/code&gt; 의 그룹 ( &lt;code&gt;Iterable&lt;/code&gt; , &lt;code&gt;Sequence&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; )일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aac6c02c5c8182c376328758ec65c08ad1e19d6" translate="yes" xml:space="preserve">
          <source>To add the Kotlin support to your Eclipse IDE, install the &lt;em&gt;Kotlin Plugin for Eclipse&lt;/em&gt;. We recommend installing the Kotlin plugin from &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt;. One option is to drag this button into a running Eclipse window:</source>
          <target state="translated">Kotlin 지원을 Eclipse IDE에 추가하려면 &lt;em&gt;Kotlin Plugin for Eclipse를&lt;/em&gt; 설치하십시오 . &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt; 에서 Kotlin 플러그인을 설치하는 것이 좋습니다 . 한 가지 옵션은이 버튼을 실행중인 Eclipse 창으로 끌어 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="11458a551629eb8e637b1b4f455d800a9c36a1f1" translate="yes" xml:space="preserve">
          <source>To address this problem, in Kotlin 1.1 a special mechanism to control receiver scope was introduced.</source>
          <target state="translated">이 문제를 해결하기 위해 Kotlin 1.1에서는 수신기 범위를 제어하는 ​​특수 메커니즘이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="93364070d4707402d500a207978499a9a901b72c" translate="yes" xml:space="preserve">
          <source>To allow nulls, we can declare a variable as nullable string, written &lt;code&gt;String?&lt;/code&gt;:</source>
          <target state="translated">null을 허용하기 위해 변수를 nullable 문자열로 선언하면 &lt;code&gt;String?&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2b28f33c9dfafdc6b47099300c488e134702926" translate="yes" xml:space="preserve">
          <source>To annotate the receiver parameter of an extension function, use the following syntax:</source>
          <target state="translated">확장 함수의 수신자 매개 변수에 주석을 달려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27d0b2adae39bd08addf9e085ed30cd88ae2eee6" translate="yes" xml:space="preserve">
          <source>To apply a function to elements in the reverse order, use functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt;&lt;code&gt;reduceRight()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt;&lt;code&gt;foldRight()&lt;/code&gt;&lt;/a&gt;. They work in a way similar to &lt;code&gt;fold()&lt;/code&gt; and &lt;code&gt;reduce()&lt;/code&gt; but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</source>
          <target state="translated">요소에 역순으로 함수를 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt; &lt;code&gt;reduceRight()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt; &lt;code&gt;foldRight()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 그것들은 &lt;code&gt;fold()&lt;/code&gt; 및 &lt;code&gt;reduce()&lt;/code&gt; 와 비슷한 방식으로 작동 하지만 마지막 요소에서 시작하여 이전으로 계속합니다. 오른쪽으로 접거나 줄이면 연산 인수가 순서를 변경합니다. 먼저 요소로 이동 한 다음 누적 값으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2a59cafd76f62ee4d0be26a47e36b2b9add63e94" translate="yes" xml:space="preserve">
          <source>To apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin, just add the following snippet into your build script:</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 을 적용하려면 빌드 스크립트에 다음 스 니펫을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="93d5ab42155015ed266c58696481bdeab9ce4844" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="91b39bd7e91bbd35306d062a5989d8160e42b8de" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d0112a7d95b0f1e5eac2132ba1ef497e36b55c4f" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="313c30481943d6f382ca1f81ef0079a1e108b27b" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4027c8136b6286dfe349c3bde29fd950bfe158c1" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="511a802d66276d56dea9179b2c2f2932520462fa" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="31bfe127214639414101a9ca7c2a589e0f9d8655" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="98541eec86ea0f0ca7790dd22601b3805220f6d7" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6276ae19b8071911e89a3dcb94d020bccd844c9c" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="translated">&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 피하기 위해이 방법은이 문자열의 처음부터 끝까지 진행되며 각 위치 에서 해당 위치의이 인스턴스에서 구분 기호와 동일한 &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="8d7e3e92f18e00c4c45e963dd6305eb6cda4267d" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="translated">&lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 방지하기 위해이 메서드는이 문자열의 처음부터 끝까지 진행 하고 해당 위치에서이 인스턴스의 구분 기호와 동일한 &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소를 각 위치에서 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="35cbc5daa3fa4744579892d02b514b4f1f8fe190" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 피하기 위해이 방법은이 문자열의 처음부터 끝까지 진행하며 각 위치 에서 해당 위치에서이 문자열과 일치 하는 &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="3b1eaf906ec2e97627b57ad449d3e9fea0f52ed9" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 방지하기 위해이 메서드는이 문자열의 처음부터 끝까지 진행 하고 해당 위치에서이 문자열과 일치 하는 &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소를 각 위치에서 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4098083aa9fa1edbe4454946791bd3716c2341fe" translate="yes" xml:space="preserve">
          <source>To avoid an exception being thrown, one can use a &lt;em&gt;safe&lt;/em&gt; cast operator &lt;em&gt;as?&lt;/em&gt; that returns &lt;em&gt;null&lt;/em&gt; on failure:</source>
          <target state="translated">예외가 발생하지 않도록 &lt;em&gt;안전한&lt;/em&gt; 캐스트 연산자를 다음 &lt;em&gt;과 같이&lt;/em&gt; 사용할 수 &lt;em&gt;있습니까? &lt;/em&gt;실패시 &lt;em&gt;null&lt;/em&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ff225a55ea176600b1d470fbc58e6bb3a657f71a" translate="yes" xml:space="preserve">
          <source>To avoid breaking the compatibility with such clients, compile your Kotlin code in the &lt;em&gt;compatibility mode&lt;/em&gt; by specifying the &lt;code&gt;-Xjvm-default=all-compatibility&lt;/code&gt; compiler option. In this case, all the code that uses the previous version will work fine with the new one. However, the compatibility mode adds some overhead to the resulting bytecode size.</source>
          <target state="translated">이러한 클라이언트와의 호환성이 깨지지 않도록하려면 &lt;code&gt;-Xjvm-default=all-compatibility&lt;/code&gt; 컴파일러 옵션 을 지정하여 &lt;em&gt;호환성 모드&lt;/em&gt; 에서 Kotlin 코드를 컴파일하세요 . 이 경우 이전 버전을 사용하는 모든 코드가 새 버전에서 잘 작동합니다. 그러나 호환성 모드는 결과 바이트 코드 크기에 약간의 오버 헤드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e17e4153a46063a7e951557055076fb55b29173" translate="yes" xml:space="preserve">
          <source>To avoid exceptions when retrieving element with non-existing positions, use safe variations of &lt;code&gt;elementAt()&lt;/code&gt;:</source>
          <target state="translated">존재하지 않는 위치를 가진 요소를 검색 할 때 예외를 피하려면 &lt;code&gt;elementAt()&lt;/code&gt; 의 안전한 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7274268313d792eeb0ea9bf91f3d9337f0c66bb3" translate="yes" xml:space="preserve">
          <source>To avoid unchecked casts, you can redesign the program structure: in the example above, there could be interfaces &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; with type-safe implementations for different types. You can introduce reasonable abstractions to move unchecked casts from calling code to the implementation details. Proper use of &lt;a href=&quot;generics#variance&quot;&gt;generic variance&lt;/a&gt; can also help.</source>
          <target state="translated">확인되지 않은 캐스트를 피하기 위해 프로그램 구조를 다시 디자인 할 수 있습니다. 위의 예에서, 다양한 유형에 대해 유형 안전 구현을 가진 &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; 인터페이스가있을 수 있습니다 . 확인되지 않은 캐스트를 호출 코드에서 구현 세부 사항으로 이동하기 위해 합리적인 추상화를 도입 할 수 있습니다. &lt;a href=&quot;generics#variance&quot;&gt;일반 분산을&lt;/a&gt; 올바르게 사용하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fda07e220a1d9d0906bbd1a8bf6f784d8a05be" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently tail recursion is only supported in the JVM backend.</source>
          <target state="translated">&lt;code&gt;tailrec&lt;/code&gt; 수정자를 사용할 수 있으려면 함수가 마지막으로 수행 할 때 자신을 호출해야합니다. 재귀 호출 후 더 많은 코드가 있으면 테일 재귀를 사용할 수 없으며 try / catch / finally 블록 내에서 사용할 수 없습니다. 현재 테일 재귀는 JVM 백엔드에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="26086ae134fdfd5e001fb5980e8bca3370532b03" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently, tail recursion is supported by Kotlin for JVM and Kotlin/Native.</source>
          <target state="translated">&lt;code&gt;tailrec&lt;/code&gt; 수정자를 사용할 수 있으려면 함수가 수행하는 마지막 작업으로 자신을 호출해야합니다. 재귀 호출 후 더 많은 코드가 있으면 꼬리 재귀를 사용할 수 없으며 try / catch / finally 블록 내에서 사용할 수 없습니다. 현재 테일 재귀는 JVM 및 Kotlin / Native 용 Kotlin에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e77c612cc0ad3329a96be3d4bc330a4270facd79" translate="yes" xml:space="preserve">
          <source>To be fair, you'd get the same output in Python, but the mechanism would be different: both instances would start out without any attributes of their own (&lt;code&gt;age&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; would be attributes on the class), and the first printing would access the class attribute; only the assignment would cause an &lt;code&gt;age&lt;/code&gt; attribute to appear on &lt;code&gt;a&lt;/code&gt;. In Kotlin, there are no class properties in this example, and each instance starts out with both properties. If you need a class-level property, see the section on &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt;.</source>
          <target state="translated">공평하게 말하면 파이썬에서 동일한 결과를 얻을 수 있지만 메커니즘은 다릅니다. 두 인스턴스는 자체 속성 ( &lt;code&gt;age&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 이 클래스 의 속성이 됨)없이 시작되고 첫 번째 인쇄에 액세스합니다 클래스 속성; 할당 만 &lt;code&gt;age&lt;/code&gt; 속성이에 표시되도록 &lt;code&gt;a&lt;/code&gt; . Kotlin에는이 예제에 클래스 속성이 없으며 각 인스턴스는 두 속성으로 시작합니다. 클래스 수준 속성이 필요한 경우 &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;컴패니언 객체&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5cad0364e908d8aa1ff84ca1d9136f4ad0e8a7e" translate="yes" xml:space="preserve">
          <source>To break a collection onto parts of a given size, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt;&lt;code&gt;chunked()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;chunked()&lt;/code&gt; takes a single argument &amp;ndash; the size of the chunk &amp;ndash; and returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;s of the given size. The first chunk starts from the first element and contains the &lt;code&gt;size&lt;/code&gt; elements, the second chunk holds the next &lt;code&gt;size&lt;/code&gt; elements, and so on. The last chunk may have a smaller size.</source>
          <target state="translated">주어진 크기의 부분으로 모음을 나누려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt; &lt;code&gt;chunked()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;chunked()&lt;/code&gt; 는 하나의 인수 (청크 크기)를 사용하여 주어진 크기 의 &lt;code&gt;List&lt;/code&gt; &lt;code&gt;List&lt;/code&gt; 을 반환합니다 . 첫 번째 청크는 첫 번째 요소에서 시작하여 &lt;code&gt;size&lt;/code&gt; 요소를 포함하고 두 번째 청크는 다음 &lt;code&gt;size&lt;/code&gt; 요소를 보유합니다 . 마지막 청크는 더 작은 크기를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c901a4737d7c3f04fc344e06625faf76eec8e9d6" translate="yes" xml:space="preserve">
          <source>To build a custom string representation, you can specify its parameters in function arguments &lt;code&gt;separator&lt;/code&gt;, &lt;code&gt;prefix&lt;/code&gt;, and &lt;code&gt;postfix&lt;/code&gt;. The resulting string will start with the &lt;code&gt;prefix&lt;/code&gt; and end with the &lt;code&gt;postfix&lt;/code&gt;. The &lt;code&gt;separator&lt;/code&gt; will come after each element except the last.</source>
          <target state="translated">사용자 정의 문자열 표현을 작성하려면 함수 인수 &lt;code&gt;separator&lt;/code&gt; , &lt;code&gt;prefix&lt;/code&gt; 및 &lt;code&gt;postfix&lt;/code&gt; 에서 해당 매개 변수를 지정할 수 있습니다 . 결과 문자열은 &lt;code&gt;prefix&lt;/code&gt; 시작 하고 &lt;code&gt;postfix&lt;/code&gt; 로 끝납니다 . &lt;code&gt;separator&lt;/code&gt; 마지막 제외한 각 요소에 들어오는 것이다.</target>
        </trans-unit>
        <trans-unit id="2719279869fab416ee4cd752ab3460ef98055407" translate="yes" xml:space="preserve">
          <source>To build and run your application on an emulator:</source>
          <target state="translated">에뮬레이터에서 응용 프로그램을 빌드하고 실행하려면</target>
        </trans-unit>
        <trans-unit id="7150222f1a1fb391342d63f455f2076e7800770e" translate="yes" xml:space="preserve">
          <source>To build two-element windows, there is a separate function - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt;&lt;code&gt;zipWithNext()&lt;/code&gt;&lt;/a&gt;. It creates pairs of adjacent elements of the receiver collection. Note that &lt;code&gt;zipWithNext()&lt;/code&gt; doesn't break the collection into pairs; it creates a &lt;code&gt;Pair&lt;/code&gt; for &lt;em&gt;each&lt;/em&gt; element except the last one, so its result on &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; is &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt;, not &lt;code&gt;[[1, 2&lt;/code&gt;], &lt;code&gt;[3, 4]]&lt;/code&gt;. &lt;code&gt;zipWithNext()&lt;/code&gt; can be called with a transformation function as well; it should take two elements of the receiver collection as arguments.</source>
          <target state="translated">요소가 두 개인 창을 만들려면 별도의 함수 인 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt; &lt;code&gt;zipWithNext()&lt;/code&gt; &lt;/a&gt; 있습니다. 수신자 콜렉션의 인접한 요소 쌍을 작성합니다. 참고 &lt;code&gt;zipWithNext()&lt;/code&gt; 쌍으로 수집을 중단하지 않는다; 이것은 생성 &lt;code&gt;Pair&lt;/code&gt; 위한 &lt;em&gt;각각&lt;/em&gt; 의 그 결과, 그래서 최종 제외한 요소 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 이다 &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt; 이 아닌 &lt;code&gt;[[1, 2&lt;/code&gt; ], &lt;code&gt;[3, 4]]&lt;/code&gt; . &lt;code&gt;zipWithNext()&lt;/code&gt; 는 변환 함수로도 호출 할 수 있습니다. 수신자 콜렉션의 두 요소를 인수로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c83a6b42d390ab9398eaec7a8e407e01581218b" translate="yes" xml:space="preserve">
          <source>To call &lt;code&gt;fold&lt;/code&gt;, we need to pass it an &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;instance of the function type&lt;/a&gt; as an argument, and lambda expressions (&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;described in more detail below&lt;/a&gt;) are widely used for this purpose at higher-order function call sites:</source>
          <target state="translated">&lt;code&gt;fold&lt;/code&gt; 를 호출하려면 &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;함수 유형&lt;/a&gt; 의 인스턴스를 인수 로 전달해야 하며 람다 표현식 ( &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;아래에 자세히 설명 됨&lt;/a&gt; )은이 목적을 위해 고차 함수 호출 사이트에서 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6580f39324c16c3fdd14fd9204c4e7b2dbc24353" translate="yes" xml:space="preserve">
          <source>To call a generic function, specify the type arguments at the call site &lt;strong&gt;after&lt;/strong&gt; the name of the function:</source>
          <target state="translated">일반 함수를 호출하려면 함수 이름 &lt;strong&gt;뒤에&lt;/strong&gt; 호출 사이트에서 유형 인수를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="567fc2cf862c0915604df53cff04863a317488f7" translate="yes" xml:space="preserve">
          <source>To catch an exception, use the &lt;em&gt;try&lt;/em&gt;-expression:</source>
          <target state="translated">예외를 포착하려면 &lt;em&gt;try&lt;/em&gt; -expression을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8d7572362421bb5d6d9129ee1f644a5743bf60f" translate="yes" xml:space="preserve">
          <source>To change the names of generated accessor methods for properties without explicitly implemented getters and setters, you can use &lt;code&gt;@get:JvmName&lt;/code&gt; and &lt;code&gt;@set:JvmName&lt;/code&gt;:</source>
          <target state="translated">명시 적으로 구현 된 getter 및 setter없이 속성에 대해 생성 된 접근 자 메서드의 이름을 변경하려면 &lt;code&gt;@get:JvmName&lt;/code&gt; 및 &lt;code&gt;@set:JvmName&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fbf41ce5d5e2bab70a3b18ea06244281f42ad35" translate="yes" xml:space="preserve">
          <source>To check that your code passes your own test click the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If your code and test are correct, you will see the &lt;strong&gt;&quot;Congratulations!&quot;&lt;/strong&gt; text:</source>
          <target state="translated">코드가 자체 테스트를 통과했는지 확인하려면 &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 상단의 &lt;strong&gt;확인&lt;/strong&gt; 아이콘을 클릭하십시오 . 코드와 테스트가 정확하면 &lt;strong&gt;&quot;축하합니다!&quot; &lt;/strong&gt;본문:&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="beef2a5f5b84a735eaf6763f186616f2da608682" translate="yes" xml:space="preserve">
          <source>To check the presence of an element in a collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt;&lt;code&gt;contains()&lt;/code&gt;&lt;/a&gt; function. It returns &lt;code&gt;true&lt;/code&gt; if there is a collection element that &lt;code&gt;equals()&lt;/code&gt; the function argument. You can call &lt;code&gt;contains()&lt;/code&gt; in the operator form with the &lt;code&gt;in&lt;/code&gt; keyword.</source>
          <target state="translated">컬렉션에 요소가 있는지 확인하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt; &lt;code&gt;contains()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 함수 인수 &lt;code&gt;equals()&lt;/code&gt; 컬렉션 요소가 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;in&lt;/code&gt; 키워드를 사용하여 연산자 형식으로 &lt;code&gt;contains()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bacf79d368ab6b699d2fdae207996c835a00695c" translate="yes" xml:space="preserve">
          <source>To check the presence of multiple instances together at once, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt;&lt;code&gt;containsAll()&lt;/code&gt;&lt;/a&gt; with a collection of these instances as an argument.</source>
          <target state="translated">한 번에 여러 인스턴스가 있는지 확인하려면 이러한 인스턴스 컬렉션을 인수로하여 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt; &lt;code&gt;containsAll()&lt;/code&gt; &lt;/a&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf01294073385c1601c163965354f1918a41a878" translate="yes" xml:space="preserve">
          <source>To check the stability status of different components of Kotlin (Kotlin/JVM, JS, Native, various libraries, etc), please consult &lt;a href=&quot;components-stability&quot;&gt;this link&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 다른 구성 요소 (Kotlin / JVM, JS, Native, 다양한 라이브러리 등)의 안정성 상태를 확인하려면 &lt;a href=&quot;components-stability&quot;&gt;이 링크&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff347228167cf9fc3db7b8ec20d8d867ef76b338" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;lateinit var&lt;/code&gt; has already been initialized, use &lt;code&gt;.isInitialized&lt;/code&gt; on the &lt;a href=&quot;reflection#property-references&quot;&gt;reference to that property&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;lateinit var&lt;/code&gt; 가 이미 초기화 되었는지 확인하려면 &lt;a href=&quot;reflection#property-references&quot;&gt;해당 속성&lt;/a&gt; 에 대한 참조에서 &lt;code&gt;.isInitialized&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06e9d17e9ea9b86a000058cf4db743b9a4f8896c" translate="yes" xml:space="preserve">
          <source>To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:</source>
          <target state="translated">클래스 헤더가 길 때 클래스 헤더와 본문을 명확하게 분리하려면 클래스 헤더 다음에 빈 줄을 추가하거나 (위의 예와 같이) 여는 중괄호를 별도의 줄에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="3e043d9080f48d9f8a9db312581f08dbc6b9e5fd" translate="yes" xml:space="preserve">
          <source>To collect all source sets participating in a compilation, including those added via the depends-on relation, one can use the property &lt;code&gt;allKotlinSourceSets&lt;/code&gt;.</source>
          <target state="translated">의존 관계를 통해 추가 된 것을 포함하여 컴파일에 참여하는 모든 소스 세트를 수집하기 위해 &lt;code&gt;allKotlinSourceSets&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="803e7c1c7144d14a645ff4c12ca8fcfcbdd5adbe" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means kotlin-maven-plugin should be run before maven-compiler-plugin using the following method, making sure that the kotlin plugin is above the maven-compiler-plugin in your pom.xml file:</source>
          <target state="translated">혼합 코드 애플리케이션을 컴파일하려면 Java 컴파일러 전에 Kotlin 컴파일러를 호출해야합니다. 즉, kotlin 플러그인이 pom.xml 파일의 maven-compiler-plugin 위에 있는지 확인하여 다음 방법을 사용하여 kotlin-maven-plugin을 maven-compiler-plugin보다 먼저 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="db544e0e7056b8ab96d6dfe0f4c1cf8c1335597b" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means that &lt;code&gt;kotlin-maven-plugin&lt;/code&gt; should run before &lt;code&gt;maven-compiler-plugin&lt;/code&gt; using the following method. Make sure that the &lt;code&gt;kotlin&lt;/code&gt; plugin comes before the &lt;code&gt;maven-compiler-plugin&lt;/code&gt; in your &lt;code&gt;pom.xml&lt;/code&gt; file:</source>
          <target state="translated">혼합 코드 애플리케이션을 컴파일하려면 자바 컴파일러보다 먼저 Kotlin 컴파일러를 호출해야합니다. Maven 용어에서 이는 &lt;code&gt;kotlin-maven-plugin&lt;/code&gt; 이 다음 방법을 사용하여 &lt;code&gt;maven-compiler-plugin&lt;/code&gt; 보다 먼저 실행되어야 함을 의미합니다 . &lt;code&gt;kotlin&lt;/code&gt; 플러그인이 &lt;code&gt;pom.xml&lt;/code&gt; 파일 에서 &lt;code&gt;maven-compiler-plugin&lt;/code&gt; 앞에 오는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="72988880fd1eb858d05ee3ce13bbc13e7e1bb020" translate="yes" xml:space="preserve">
          <source>To compile source code, specify the source directories in the</source>
          <target state="translated">소스 코드를 컴파일하려면</target>
        </trans-unit>
        <trans-unit id="37fdd621985c6aff13221b4e4aea16cc07ab8ee0" translate="yes" xml:space="preserve">
          <source>To configure DCE on the main source set, you can use the &lt;code&gt;runDceKotlinJs&lt;/code&gt; task (and corresponding &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; for other source sets).</source>
          <target state="translated">기본 소스 세트에서 DCE를 구성하기 위해 &lt;code&gt;runDceKotlinJs&lt;/code&gt; 태스크 (및 다른 소스 세트에 해당하는 &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbb0879e62b32ffc14d1dc5aabab44fdf51b7ee" translate="yes" xml:space="preserve">
          <source>To configure a single task, use its name. Examples:</source>
          <target state="translated">단일 작업을 구성하려면 해당 이름을 사용하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="75b4ad80b6e5b98a0167e62ef51d7159288b8634" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to &lt;strong&gt;Settings | Editor | Code Style | Kotlin&lt;/strong&gt;, click &lt;strong&gt;Set from&amp;hellip;&lt;/strong&gt; link in the upper right corner, and select &lt;strong&gt;Kotlin style guide&lt;/strong&gt; from the menu.</source>
          <target state="translated">이 스타일 가이드에 따라 IntelliJ 포맷터를 구성하려면 Kotlin 플러그인 버전 1.2.20 이상을 설치하고 &lt;strong&gt;설정 | 편집자 | 코드 스타일 | Kotlin&lt;/strong&gt; 에서 오른쪽 상단 모서리에있는 &lt;strong&gt;설정&amp;hellip;&lt;/strong&gt; 링크를 클릭 하고 메뉴에서 &lt;strong&gt;Kotlin 스타일 가이드&lt;/strong&gt; 를 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="68df6e8c753963392486043995598199a7116aa3" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to Settings | Editor | Code Style | Kotlin, click on &quot;Set from&amp;hellip;&quot; link in the upper right corner, and select &quot;Predefined style / Kotlin style guide&quot; from the menu.</source>
          <target state="translated">이 스타일 가이드에 따라 IntelliJ 포맷터를 구성하려면 Kotlin 플러그인 버전 1.2.20 이상을 설치하고 설정 | 편집자 | 코드 스타일 | Kotlin의 오른쪽 상단 모서리에있는 &quot;Set from&amp;hellip;&quot;링크를 클릭하고 메뉴에서 &quot;Predefined style / Kotlin style guide&quot;를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a84aa42a71bde94030fd28b49274ed212410ae73" translate="yes" xml:space="preserve">
          <source>To convert a Kotlin function to a pointer to a C function, &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; can be used. It is also able to provide the lambda instead of a function reference. The function or lambda must not capture any values.</source>
          <target state="translated">Kotlin 함수를 C 함수의 포인터로 변환하기 위해 &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; 사용할 수 있습니다. 함수 참조 대신 람다를 제공 할 수도 있습니다. 함수 또는 람다는 어떤 값도 캡처하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3c44f554793ee378fe115edb9d2b77ef0a09d12f" translate="yes" xml:space="preserve">
          <source>To convert a file we simply provide the input file, and optionally an output directory. The command below will convert the file &lt;code&gt;jquery.d.ts&lt;/code&gt; in the current folder, which we've previously downloaded from the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed repository&lt;/a&gt; to the output folder &lt;code&gt;headers&lt;/code&gt;:</source>
          <target state="translated">파일을 변환하기 위해 단순히 입력 파일과 선택적으로 출력 디렉토리를 제공합니다. 아래 명령 은 이전에 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed 리포지토리&lt;/a&gt; 에서 다운로드 한 현재 폴더의 &lt;code&gt;jquery.d.ts&lt;/code&gt; 파일 을 출력 폴더 &lt;code&gt;headers&lt;/code&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="53082c51d066700fb796c416707ace90c10e7442" translate="yes" xml:space="preserve">
          <source>To convert numeric values to different types, use &lt;a href=&quot;#explicit-conversions&quot;&gt;Explicit conversions&lt;/a&gt;.</source>
          <target state="translated">숫자 값을 다른 유형으로 &lt;a href=&quot;#explicit-conversions&quot;&gt;변환&lt;/a&gt; 하려면 명시 적 변환을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="09283e6df610a2666a552ab05ba081120d5fb799" translate="yes" xml:space="preserve">
          <source>To correctly import the dependencies into the Kotlin/Native module, the &lt;code&gt;Podfile&lt;/code&gt; must contain either &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_modular_headers_bang&quot;&gt;&lt;code&gt;use_modular_headers!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_frameworks_bang&quot;&gt;&lt;code&gt;use_frameworks!&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">올바르게 코 틀린 / 기본 모듈에 의존성을 가져 오려면는 &lt;code&gt;Podfile&lt;/code&gt; 는 하나의 메시지 있어야합니다 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_modular_headers_bang&quot;&gt; &lt;code&gt;use_modular_headers!&lt;/code&gt; &lt;/a&gt;또는 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_frameworks_bang&quot;&gt; &lt;code&gt;use_frameworks!&lt;/code&gt; &lt;/a&gt;지령.</target>
        </trans-unit>
        <trans-unit id="033c0e927137582a697794f54285b85aeb454fd5" translate="yes" xml:space="preserve">
          <source>To cover these (and other) cases, Kotlin supports &lt;em&gt;delegated properties&lt;/em&gt;:</source>
          <target state="translated">이러한 (및 기타) 사례를 다루기 위해 Kotlin은 &lt;em&gt;위임 속성을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9d0229fd8c1088f563b4cf4e10d12c4379d2f726" translate="yes" xml:space="preserve">
          <source>To create a Kotlin scratch, click &lt;strong&gt;File | New | Scratch file&lt;/strong&gt; and select the &lt;strong&gt;Kotlin&lt;/strong&gt; type.</source>
          <target state="translated">Kotlin 스크래치를 작성하려면 &lt;strong&gt;파일 | 새로운 | 파일을 스크래치&lt;/strong&gt; 하고 &lt;strong&gt;Kotlin&lt;/strong&gt; 유형을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2345a81dc6db58bf05fd03f469161c13a230da9" translate="yes" xml:space="preserve">
          <source>To create a Kotlin worksheet in a project directory, right-click the directory in the project tree and select &lt;strong&gt;New | Kotlin Worksheet&lt;/strong&gt;.</source>
          <target state="translated">프로젝트 디렉토리에 Kotlin 워크 시트를 만들려면 프로젝트 트리에서 디렉토리를 마우스 오른쪽 버튼으로 클릭하고 &lt;strong&gt;New | Kotlin 워크 시트&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6469e95270452943ecc23557177165ada17e0d19" translate="yes" xml:space="preserve">
          <source>To create a collection with the same elements as an existing collection, you can use copying operations. Collection copying operations from the standard library create &lt;em&gt;shallow&lt;/em&gt; copy collections with references to the same elements. Thus, a change made to a collection element reflects in all its copies.</source>
          <target state="translated">기존 컬렉션과 동일한 요소로 컬렉션을 만들려면 복사 작업을 사용할 수 있습니다. 표준 라이브러리에서 수집 복사 작업 을 수행하면 동일한 요소에 대한 참조가있는 &lt;em&gt;단순&lt;/em&gt; 복사 수집이 생성 됩니다. 따라서 컬렉션 요소에 대한 변경 사항은 모든 복사본에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="c93eeedd365f43d9e2553f0db590167b463ec502" translate="yes" xml:space="preserve">
          <source>To create a concrete type collection, such as an &lt;code&gt;ArrayList&lt;/code&gt; or &lt;code&gt;LinkedList&lt;/code&gt;, you can use the available constructors for these types. Similar constructors are available for implementations of &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 또는 &lt;code&gt;LinkedList&lt;/code&gt; 와 같은 구체적인 유형 컬렉션을 만들려면 이러한 유형에 사용 가능한 생성자를 사용할 수 있습니다. &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Map&lt;/code&gt; 구현에 유사한 생성자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10c83d8ce189917b93f0dd12f924ce0343c0f0cd" translate="yes" xml:space="preserve">
          <source>To create a course, go to &lt;strong&gt;Create New Course&lt;/strong&gt; from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;, fill in the title, author and description:</source>
          <target state="translated">과정을 만들려면 갈 &lt;strong&gt;새로운 코스를 만들기&lt;/strong&gt; 로부터 &lt;strong&gt;시작 화면&lt;/strong&gt; 또는에서 &lt;strong&gt;파일 메뉴&lt;/strong&gt; , 제목, 저자 및 설명에 채우기 :</target>
        </trans-unit>
        <trans-unit id="b19b96489e64fb428b07b0d9e5f6b20ffaee0c76" translate="yes" xml:space="preserve">
          <source>To create a finite sequence with &lt;code&gt;generateSequence()&lt;/code&gt;, provide a function that returns &lt;code&gt;null&lt;/code&gt; after the last element you need.</source>
          <target state="translated">&lt;code&gt;generateSequence()&lt;/code&gt; 를 사용하여 유한 시퀀스를 작성하려면 필요한 마지막 요소 다음에 &lt;code&gt;null&lt;/code&gt; 을 리턴하는 함수를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="47b61d43a27903512a35c90e596534948c2b1dbf" translate="yes" xml:space="preserve">
          <source>To create a progression for iterating in reverse order, use &lt;code&gt;downTo&lt;/code&gt; instead of &lt;code&gt;..&lt;/code&gt; when defining the range for it.</source>
          <target state="translated">역순으로 반복 진행을 만들려면 범위를 정의 할 때 &lt;code&gt;..&lt;/code&gt; 대신 &lt;code&gt;downTo&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="b47410847599f97a1134fa9ef445378b7a480550" translate="yes" xml:space="preserve">
          <source>To create a range for your class, call the &lt;code&gt;rangeTo()&lt;/code&gt; function on the range start value and provide the end value as an argument. &lt;code&gt;rangeTo()&lt;/code&gt; is often called in its operator form &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">클래스의 범위를 만들려면 범위 시작 값 에서 &lt;code&gt;rangeTo()&lt;/code&gt; 함수를 호출 하고 끝 값을 인수로 제공하십시오. &lt;code&gt;rangeTo()&lt;/code&gt; 종종 운영자 형태라고 &lt;code&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef350d13303167462d244e7352097ce6871c0d66" translate="yes" xml:space="preserve">
          <source>To create a self-contained Jar file containing the code from your module along with dependencies, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">종속성과 함께 모듈의 코드를 포함하는 자체 포함 된 Jar 파일을 작성하려면 Maven pom.xml 파일의 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 아래에 다음을 포함 하십시오. 여기서 &lt;code&gt;main.class&lt;/code&gt; 는 특성으로 정의되며 기본 Kotlin 또는 자바 클래스 :</target>
        </trans-unit>
        <trans-unit id="250688e8e0fbdc724cfa4d689a087f5e676490f2" translate="yes" xml:space="preserve">
          <source>To create a sequence, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt;&lt;code&gt;sequenceOf()&lt;/code&gt;&lt;/a&gt; function listing the elements as its arguments.</source>
          <target state="translated">시퀀스를 만들려면 요소를 인수로 나열하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt; &lt;code&gt;sequenceOf()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab5e0caabe6ba677095c9c30bc71be0a60a8ea76" translate="yes" xml:space="preserve">
          <source>To create a small Jar file containing just the code from your module, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">모듈의 코드 만 포함하는 작은 Jar 파일을 만들려면 Maven pom.xml 파일의 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 아래에 다음을 포함 하십시오. 여기서 &lt;code&gt;main.class&lt;/code&gt; 는 속성으로 정의되며 기본 Kotlin 또는 Java 클래스를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="e35af751d291871272ac5bf8d4ceb5925a4c895b" translate="yes" xml:space="preserve">
          <source>To create a target, use one of the preset functions, which are named according to the target platforms and optionally accept the target name and a configuring code block:</source>
          <target state="translated">대상을 작성하려면 대상 플랫폼에 따라 이름이 지정된 사전 설정 기능 중 하나를 사용하고 선택적으로 대상 이름과 구성 코드 블록을 승인하십시오.</target>
        </trans-unit>
        <trans-unit id="59c179a1054538f29e6f5790e866a02248610385" translate="yes" xml:space="preserve">
          <source>To create an array, we can use a library function &lt;code&gt;arrayOf()&lt;/code&gt; and pass the item values to it, so that &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; creates an array &lt;code&gt;[1, 2, 3]&lt;/code&gt;. Alternatively, the &lt;code&gt;arrayOfNulls()&lt;/code&gt; library function can be used to create an array of a given size filled with null elements.</source>
          <target state="translated">배열을 만들려면 &lt;code&gt;arrayOf()&lt;/code&gt; 라이브러리 함수를 사용 하고 항목 값을 전달하여 &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; 이 배열 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 있습니다. 또는 &lt;code&gt;arrayOfNulls()&lt;/code&gt; 라이브러리 함수를 사용하여 널 요소로 채워진 주어진 크기의 배열을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cc39e6db177eed985da184429e7d653e4d3e03b" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 만들려면 &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9b7dfa76d5d4f8a207e73e37c8aed978cc5e50d" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy(kotlin.Function0((kotlin.lazy.T)))&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 생성하려면 &lt;a href=&quot;../lazy#kotlin%24lazy(kotlin.Function0((kotlin.lazy.T)))&quot;&gt;lazy&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="392ca62c20eb8ea21287252327b80e948e15e7f9" translate="yes" xml:space="preserve">
          <source>To create an instance of a class, we call the constructor as if it were a regular function:</source>
          <target state="translated">클래스의 인스턴스를 만들려면 생성자를 일반 함수 인 것처럼 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5ececdd9ea1ec767cefb32bd8a4972a7f3db2e63" translate="yes" xml:space="preserve">
          <source>To create an object of an anonymous class that inherits from some type (or types), we write:</source>
          <target state="translated">어떤 유형에서 상속되는 익명 클래스의 객체를 만들려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="66ccf1c80c7d0872003cb95567afdbb598a15cac" translate="yes" xml:space="preserve">
          <source>To create bindings for a new library, start by creating a &lt;code&gt;.def&lt;/code&gt; file. Structurally it's a simple property file, which looks like this:</source>
          <target state="translated">새 라이브러리에 대한 바인딩을 작성하려면 먼저 &lt;code&gt;.def&lt;/code&gt; 파일 을 작성 하십시오. 구조적으로 이것은 다음과 같은 간단한 속성 파일입니다.</target>
        </trans-unit>
        <trans-unit id="53cb83a01be7750f4f13800e35fa2fb65a7ce331" translate="yes" xml:space="preserve">
          <source>To create or access several targets from multiple presets dynamically, you can use the &lt;code&gt;targetFromPreset&lt;/code&gt; function which accepts a preset (those are contained in the &lt;code&gt;kotlin.presets&lt;/code&gt; domain object collection) and, optionally, a target name and a configuration code block.</source>
          <target state="translated">여러 사전 설정에서 여러 대상을 동적으로 작성하거나 액세스하려면 사전 설정 ( &lt;code&gt;kotlin.presets&lt;/code&gt; 도메인 오브젝트 콜렉션에 포함됨 ) 및 선택적으로 대상 이름 및 구성 코드 블록 을 허용하는 &lt;code&gt;targetFromPreset&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84204f67cf463ce0040ab94f394e112f27f7a64e" translate="yes" xml:space="preserve">
          <source>To create such channel use a factory method &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt;. To indicate that no further elements are needed use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; method on it.</source>
          <target state="translated">이러한 채널을 만들려면 팩토리 메소드 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;시세를 사용하십시오&lt;/a&gt; . 추가 요소가 필요하지 않음을 나타내려면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f270c63c035ac76bc90800e7489ec199d1188bb4" translate="yes" xml:space="preserve">
          <source>To create the new file, the &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;prefix&lt;/a&gt; and the &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;suffix&lt;/a&gt; may first be adjusted to fit the limitations of the underlying platform.</source>
          <target state="translated">새 파일을 만들려면 먼저 기본 플랫폼의 제한 사항에 맞게 &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;접두사&lt;/a&gt; 와 &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;접미사를&lt;/a&gt; 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed397e5c4869250a6fe4256b7633ea9b132cd1a7" translate="yes" xml:space="preserve">
          <source>To create the new file, the &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;prefix&lt;/a&gt; and the &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;suffix&lt;/a&gt; may first be adjusted to fit the limitations of the underlying platform.</source>
          <target state="translated">새 파일을 만들려면 먼저 기본 플랫폼의 제한 사항에 맞게 &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;접두사&lt;/a&gt; 와 &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;접미사를&lt;/a&gt; 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e26d13b3d6d463e1b2fd03afc335d058a5d4673" translate="yes" xml:space="preserve">
          <source>To debug Kotlin in Google Chrome, you should use DevTools. Please, read the &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;official documentation&lt;/a&gt; to learn how to open and use DevTools.</source>
          <target state="translated">Chrome에서 Kotlin을 디버깅하려면 DevTools를 사용해야합니다. DevTools를 열고 사용하는 방법을 배우 려면 &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;공식 문서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e817cf98143421063f9dd49cbdf248b7b2518117" translate="yes" xml:space="preserve">
          <source>To debug Kotlin sources in the browser, you should tell the compiler to generate source map file. Add following lines to the Gradle configuration:</source>
          <target state="translated">브라우저에서 Kotlin 소스를 디버그하려면 소스 맵 파일을 생성하도록 컴파일러에 지시해야합니다. Gradle 구성에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c61d767cd604eae6780df09aa030d9d280b98c" translate="yes" xml:space="preserve">
          <source>To declare a function that is implemented in native (C or C++) code, you need to mark it with the &lt;code&gt;external&lt;/code&gt; modifier:</source>
          <target state="translated">네이티브 (C 또는 C ++) 코드로 구현 된 함수를 선언하려면 &lt;code&gt;external&lt;/code&gt; 수정 자로 이를 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="17984c774c9009532146abdfe4c1f92691dab870" translate="yes" xml:space="preserve">
          <source>To declare a sealed class, you put the &lt;code&gt;sealed&lt;/code&gt; modifier before the name of the class. A sealed class can have subclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1, the rules were even more strict: classes had to be nested inside the declaration of the sealed class).</source>
          <target state="translated">봉인 된 클래스를 선언하려면 클래스 이름 앞에 &lt;code&gt;sealed&lt;/code&gt; 수정자를 넣습니다 . 봉인 된 클래스에는 서브 클래스가있을 수 있지만 모두 봉인 된 클래스 자체와 동일한 파일에 선언되어야합니다. (Kotlin 1.1 이전에는 규칙이 더욱 엄격했습니다. 클래스는 봉인 된 클래스의 선언 안에 중첩되어야했습니다).</target>
        </trans-unit>
        <trans-unit id="10a7f058c3df1eb894a755ea535860aa75893fea" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, place the type after a colon in the class header:</source>
          <target state="translated">명시 적 상위 유형을 선언하려면 클래스 헤더의 콜론 뒤에 유형을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="c97ee402b691c80817117f378bd0349e4a8da26c" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, we place the type after a colon in the class header:</source>
          <target state="translated">명시적인 슈퍼 타입을 선언하기 위해 클래스 헤더에서 콜론 뒤에 타입을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="48ff93d55fe3658449347e35151be6b572c8736d" translate="yes" xml:space="preserve">
          <source>To declare an extension function, we need to prefix its name with a &lt;em&gt;receiver type&lt;/em&gt;, i.e. the type being extended. The following adds a &lt;code&gt;swap&lt;/code&gt; function to &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">확장 함수를 선언하려면 이름 앞에 &lt;em&gt;리시버 유형&lt;/em&gt; , 즉 확장되는 &lt;em&gt;유형&lt;/em&gt; 을 접두어로 붙여야합니다 . 다음 은 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; &lt;code&gt;swap&lt;/code&gt; 함수를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f1b32c095491287535a8ffbd23d718a4ec1e28de" translate="yes" xml:space="preserve">
          <source>To define a custom order for the collection sorting, you can provide your own &lt;code&gt;Comparator&lt;/code&gt;. To do this, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt;&lt;code&gt;sortedWith()&lt;/code&gt;&lt;/a&gt; function passing in your &lt;code&gt;Comparator&lt;/code&gt;. With this function, sorting strings by their length looks like this:</source>
          <target state="translated">콜렉션 정렬에 대한 사용자 정의 순서를 정의하기 위해 고유 한 &lt;code&gt;Comparator&lt;/code&gt; 를 제공 할 수 있습니다 . 이렇게하려면 &lt;code&gt;Comparator&lt;/code&gt; 에 전달 된 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt; &lt;code&gt;sortedWith()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . 이 함수를 사용하면 문자열을 길이별로 정렬하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76c4ad66d01d81d2c13dd0f6fd9cbde76bdd69dd" translate="yes" xml:space="preserve">
          <source>To define a custom progression step, use the &lt;code&gt;step&lt;/code&gt; function on a range.</source>
          <target state="translated">사용자 정의 진행 단계를 정의하려면 범위 에서 &lt;code&gt;step&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3c595e055a9ae116f425f8291258d8dc6632df5" translate="yes" xml:space="preserve">
          <source>To define a natural order for a user-defined type, make the type an inheritor of &lt;code&gt;Comparable&lt;/code&gt;. This requires implementing the &lt;code&gt;compareTo()&lt;/code&gt; function. &lt;code&gt;compareTo()&lt;/code&gt; must take another object of the same type as an argument and return an integer value showing which object is greater:</source>
          <target state="translated">사용자 정의 형식의 자연스러운 순서를 정의하려면 형식을 &lt;code&gt;Comparable&lt;/code&gt; 의 상속자로 만드십시오 . &lt;code&gt;compareTo()&lt;/code&gt; 함수를 구현해야 합니다. &lt;code&gt;compareTo()&lt;/code&gt; 는 인수와 동일한 유형의 다른 객체를 가져 와서 더 큰 객체를 나타내는 정수 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="15f6c4e9b412ce540337bf0f4670d3a11f889be0" translate="yes" xml:space="preserve">
          <source>To delegate a property to another property, use the proper &lt;code&gt;::&lt;/code&gt; qualifier in the delegate name, for example, &lt;code&gt;this::delegate&lt;/code&gt; or &lt;code&gt;MyClass::delegate&lt;/code&gt;.</source>
          <target state="translated">속성을 다른 속성에 위임하려면 위임 이름에 적절한 &lt;code&gt;::&lt;/code&gt; 한정자를 사용합니다 ( 예 : &lt;code&gt;this::delegate&lt;/code&gt; 또는 &lt;code&gt;MyClass::delegate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9143cabd73a5291d802c769a81ee627bbb5733e" translate="yes" xml:space="preserve">
          <source>To denote the current &lt;em&gt;receiver&lt;/em&gt;, we use &lt;em&gt;this&lt;/em&gt; expressions:</source>
          <target state="translated">현재 &lt;em&gt;수신자&lt;/em&gt; 를 나타 내기 위해 &lt;em&gt;다음&lt;/em&gt; 표현식 을 사용 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="370aeed576ab8358f729a92b8f556723486b4edb" translate="yes" xml:space="preserve">
          <source>To deploy Kotlin applications on &lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt;, you can follow the &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;official Heroku tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt; 에 Kotlin 응용 프로그램을 배포하려면 &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;공식 Heroku 튜토리얼을&lt;/a&gt; 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="9515ab87992626329f3209451ad10d94d57d9d91" translate="yes" xml:space="preserve">
          <source>To disable</source>
          <target state="translated">비활성화하려면</target>
        </trans-unit>
        <trans-unit id="771653f64e2b72ee994da136292e2bfcc37a8770" translate="yes" xml:space="preserve">
          <source>To disable the caching for all Kotlin tasks, set the system property flag &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; (run the build with the argument &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt;).</source>
          <target state="translated">모든 Kotlin 태스크에 대한 캐싱을 사용하지 않으려면 시스템 특성 플래그 &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 (인수 &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt; 로 빌드를 실행하십시오 ).</target>
        </trans-unit>
        <trans-unit id="5fb61a8c9c6d11d2594861df1a6ec31dd25d8561" translate="yes" xml:space="preserve">
          <source>To eliminate the risk of such incompatibility being introduced by a change in &lt;strong&gt;non&lt;/strong&gt;-public API of a module, the public API inline functions are not allowed to use non-public-API declarations, i.e. &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt; declarations and their parts, in their bodies.</source>
          <target state="translated">이러한 호환성이의 변화에 의해 도입되는 위험 제거하기 위해 &lt;strong&gt;비&lt;/strong&gt; 모듈의 -public API를 공개 API의 인라인 함수는 비공개-API 선언, 즉 사용 할 수 없습니다 &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;internal&lt;/code&gt; 몸에, 선언과 그 부품 .</target>
        </trans-unit>
        <trans-unit id="2defcf6d3a2e2a6242b791d65c0bc5e944e6db59" translate="yes" xml:space="preserve">
          <source>To enable Kotlin OSGi support you need to include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; instead of regular Kotlin libraries. It is recommended to remove &lt;code&gt;kotlin-runtime&lt;/code&gt;, &lt;code&gt;kotlin-stdlib&lt;/code&gt; and &lt;code&gt;kotlin-reflect&lt;/code&gt; dependencies as &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; already contains all of them. You also should pay attention in case when external Kotlin libraries are included. Most regular Kotlin dependencies are not OSGi-ready, so you shouldn't use them and should remove them from your project.</source>
          <target state="translated">Kotlin OSGi 지원을 활성화하려면 일반 Kotlin 라이브러리 대신 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 을 포함해야합니다 . &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 에 이미 모든 것이 포함되어 있으므로 &lt;code&gt;kotlin-runtime&lt;/code&gt; , &lt;code&gt;kotlin-stdlib&lt;/code&gt; 및 &lt;code&gt;kotlin-reflect&lt;/code&gt; 종속성 을 제거하는 것이 좋습니다 . 외부 Kotlin 라이브러리가 포함 된 경우에도주의해야합니다. 대부분의 일반적인 Kotlin 종속성은 OSGi를 지원하지 않으므로이를 사용해서는 안되며 프로젝트에서 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="6eb3341f99fe9ebb8d9323c290933247870fe5f7" translate="yes" xml:space="preserve">
          <source>To enable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">증분 주석 처리를 사용하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="6dbd033e65a082aad28e5c2fcd37b8daf6829885" translate="yes" xml:space="preserve">
          <source>To enable this behavior you need to have &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; in your dependencies.</source>
          <target state="translated">이 동작을 사용하려면 종속성에 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="1b92d03d7ab798afc0052aefc2671aaf31759d48" translate="yes" xml:space="preserve">
          <source>To enable this, inline functions support &lt;em&gt;reified type parameters&lt;/em&gt;, so we can write something like this:</source>
          <target state="translated">이를 가능하게하기 위해 인라인 함수는 &lt;em&gt;reified type parameters를&lt;/em&gt; 지원 하므로 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c78de63fcfaed2f5ca9f53b2c3f6f324dab90107" translate="yes" xml:space="preserve">
          <source>To enable trailing commas in the IntelliJ IDEA formatter, go to &lt;strong&gt;Settings | Editor | Code Style | Kotlin&lt;/strong&gt;, open the &lt;strong&gt;Other&lt;/strong&gt; tab and select the &lt;strong&gt;Use trailing comma&lt;/strong&gt; option.</source>
          <target state="translated">IntelliJ IDEA 포맷터에서 후행 쉼표를 사용하려면 &lt;strong&gt;설정 | 편집자 | 코드 스타일 | Kotlin&lt;/strong&gt; 에서 &lt;strong&gt;기타&lt;/strong&gt; 탭을 열고 &lt;strong&gt;후행 쉼표 사용&lt;/strong&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="eda2f16c079bedddcf43889e299a4aeef442f108" translate="yes" xml:space="preserve">
          <source>To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements:</source>
          <target state="translated">생성 된 코드의 일관성과 의미있는 동작을 보장하기 위해 데이터 클래스는 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7d11890fbe59d29f5f955e489a75b4c6f2d6120" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch or a worksheet, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The code will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run sequentially, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="translated">스크래치 또는 워크 시트에서 각 특정 식을 평가 &lt;strong&gt;하려면 REPL 사용을&lt;/strong&gt; 선택 하여 실행합니다 . 코드는 &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt; 에서와 같은 방식으로 실행됩니다. 코드 라인은 순차적으로 실행되어 각 호출의 결과를 제공합니다. 나중에 해당 행에 표시된 이름 &lt;code&gt;res*&lt;/code&gt; 결과를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1915a0468ec60c04f19505bbcc82c60fb33083b3" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The scratch will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run subsequently, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="translated">스크래치로 각 특정 표현식을 평가하려면 &lt;strong&gt;Use REPL을&lt;/strong&gt; 선택한 상태 에서 실행 &lt;strong&gt;하십시오&lt;/strong&gt; . 스크래치는 &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt; 과 같은 방식으로 실행됩니다. 코드 라인은 이후에 실행되어 각 호출의 결과를 제공합니다. 나중에 해당 줄에 표시된 &lt;code&gt;res*&lt;/code&gt; 라는 이름으로 결과를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94918723afeacff1efa16ca8ab355a3ef8c400e9" translate="yes" xml:space="preserve">
          <source>To exclude default Kotlin libraries that comes as transitive dependencies you can use the following approach:</source>
          <target state="translated">전이 의존성으로 제공되는 기본 Kotlin 라이브러리를 제외하려면 다음 접근법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfe13659cc9bfcece191e4b8535987313b947937" translate="yes" xml:space="preserve">
          <source>To exclude the standard library from external libraries (notice that &quot;star exclusion&quot; works in Maven 3 only):</source>
          <target state="translated">외부 라이브러리에서 표준 라이브러리를 제외하려면 ( &quot;스타 제외&quot;는 Maven 3에서만 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="07af8a09aee36adfe68b2b0a1b6017022afe11a3" translate="yes" xml:space="preserve">
          <source>To facilitate this, Kotlin, as a statically typed programming language, uses a family of &lt;a href=&quot;#function-types&quot;&gt;function types&lt;/a&gt; to represent functions and provides a set of specialized language constructs, such as &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">이를 용이하게하기 위해 Kotlin은 정적으로 유형이 지정된 프로그래밍 언어로서 &lt;a href=&quot;#function-types&quot;&gt;함수 유형&lt;/a&gt; 을 사용하여 함수 를 나타내고 &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;람다 식과&lt;/a&gt; 같은 특수 언어 구조 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6f3dc2eba2ee9bd47ab354f073c6c2fcb6b42573" translate="yes" xml:space="preserve">
          <source>To filter collections by negative conditions, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt;&lt;code&gt;filterNot()&lt;/code&gt;&lt;/a&gt;. It returns a list of elements for which the predicate yields &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">부정적인 조건으로 콜렉션을 필터링하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt; &lt;code&gt;filterNot()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 술어가 &lt;code&gt;false&lt;/code&gt; 를 산출하는 요소의리스트를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="70215058b180f374e26cdfcf334f5153e68b392f" translate="yes" xml:space="preserve">
          <source>To find an intersection between two collections (elements present in both of them), use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt;&lt;code&gt;intersect()&lt;/code&gt;&lt;/a&gt;. To find collection elements not present in another collection, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt;&lt;code&gt;subtract()&lt;/code&gt;&lt;/a&gt;. Both these functions can be called in the infix form as well, for example, &lt;code&gt;a intersect b&lt;/code&gt;.</source>
          <target state="translated">두 컬렉션 (둘 다에있는 요소) 사이의 교차점을 찾으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt; &lt;code&gt;intersect()&lt;/code&gt; &lt;/a&gt; . 다른 컬렉션에없는 컬렉션 요소를 찾으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt; &lt;code&gt;subtract()&lt;/code&gt; &lt;/a&gt; . 이 두 함수는 모두 예를 들어 &lt;code&gt;a intersect b&lt;/code&gt; 와 같이 삽입 형식으로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c38d615ff41226343f4fd39898bb931c04a0136" translate="yes" xml:space="preserve">
          <source>To find out how to start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">JavaScript에 Kotlin을 사용하는 방법을 알아 보려면 &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;학습서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1b3025669d14b930eb88a22f129712b45d175de" translate="yes" xml:space="preserve">
          <source>To fix this, we have to declare objects of type &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 유형의 객체를 선언해야합니다 . 우리는 이전과 같은 변수에 대해 동일한 메소드를 모두 호출 할 수 있으므로 더 복잡한 유형에 의해 추가 된 값이 없기 때문에 의미가없는 Object&amp;gt;를 확장 합니다. 그러나 컴파일러는 그것을 모른다.</target>
        </trans-unit>
        <trans-unit id="1c3ed2671d90a6fccce18fdda0d98b5b6f90b98a" translate="yes" xml:space="preserve">
          <source>To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">Kotlin 프로젝트에 대한 문서를 생성하려면 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka를&lt;/a&gt; 사용하십시오 . 구성 지침 은 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 . Dokka는 혼합 언어 프로젝트를 지원하며 표준 JavaDoc을 포함하여 여러 형식으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da5847f3384d7a88c1adee061594df4e30b80fc" translate="yes" xml:space="preserve">
          <source>To get a seeded instance of random generator use &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; function.</source>
          <target state="translated">랜덤 생성기의 시드 인스턴스를 얻으려면 &lt;a href=&quot;index&quot;&gt;랜덤&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="90b0958330415ed4272efd87321aab58607e2589" translate="yes" xml:space="preserve">
          <source>To get a set containing all elements that are contained at least in one of these collections use &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;.</source>
          <target state="translated">이러한 컬렉션 중 하나 이상에 포함 된 모든 요소를 ​​포함하는 집합을 얻으려면 &lt;a href=&quot;union&quot;&gt;union을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7140ce3a3c50fbb1558d05a01072f6583b3697ee" translate="yes" xml:space="preserve">
          <source>To get a set containing all elements that are contained in both collections use &lt;a href=&quot;intersect&quot;&gt;intersect&lt;/a&gt;.</source>
          <target state="translated">두 컬렉션에 포함 된 모든 요소를 ​​포함하는 집합을 얻으려면 &lt;a href=&quot;intersect&quot;&gt;intersect를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="004366928e90c7cdc731785eae1ab45f89c2dc1a" translate="yes" xml:space="preserve">
          <source>To get started, install a recent version of IntelliJ IDEA. Kotlin is bundled with IntelliJ IDEA starting from version 15. You can download the free &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; from &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;.</source>
          <target state="translated">시작하려면 최신 버전의 IntelliJ IDEA를 설치하십시오. Kotlin은 버전 15부터 IntelliJ IDEA와 번들로 제공됩니다 . &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt; 에서 무료 &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; 을 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94da0b750a9691183cd3aef14a71ddcee794f57c" translate="yes" xml:space="preserve">
          <source>To get the Kotlin class corresponding to a Java class, use the &lt;code&gt;.kotlin&lt;/code&gt; extension property:</source>
          <target state="translated">Java 클래스에 해당하는 Kotlin 클래스를 가져 오려면 &lt;code&gt;.kotlin&lt;/code&gt; 확장 등록 정보를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="03f3657fbd7420151d7cbee074c2f638231666dd" translate="yes" xml:space="preserve">
          <source>To get the pointer, &lt;code&gt;.cstr&lt;/code&gt; should be allocated in native memory, e.g.</source>
          <target state="translated">포인터를 얻으려면 &lt;code&gt;.cstr&lt;/code&gt; 을 기본 메모리에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="99f419fbdc788d8ad3548e218e2e9d1a31e1f757" translate="yes" xml:space="preserve">
          <source>To get the specified number of elements starting from the first, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt;&lt;code&gt;take()&lt;/code&gt;&lt;/a&gt; function. For getting the last elements, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt;&lt;code&gt;takeLast()&lt;/code&gt;&lt;/a&gt;. When called with a number larger than the collection size, both functions return the whole collection.</source>
          <target state="translated">처음부터 지정된 수의 요소를 가져 오려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt; &lt;code&gt;take()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 마지막 요소를 얻으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt; &lt;code&gt;takeLast()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 컬렉션 크기보다 큰 숫자로 호출하면 두 함수가 전체 컬렉션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c882c6a497d3655af358c59177443fd4abbe265" translate="yes" xml:space="preserve">
          <source>To handle this case, you can mark the property with the &lt;code&gt;lateinit&lt;/code&gt; modifier:</source>
          <target state="translated">이 경우를 처리하기 위해 &lt;code&gt;lateinit&lt;/code&gt; 수정자를 사용 하여 특성을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f184ea8aba5991e48a265c7b37cae24a3a756b30" translate="yes" xml:space="preserve">
          <source>To have a dependency-injected implementation generated for the type, annotate it with &lt;code&gt;@Component&lt;/code&gt;. The generated class will have the name of this type prepended with Dagger, like &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; below:</source>
          <target state="translated">유형에 대해 의존성 주입 구현을 생성하려면 &lt;code&gt;@Component&lt;/code&gt; 로 주석을 답니다 . 생성 된 클래스의 이름은 아래 &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; 과 같이 Dagger가 앞에 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="6137f5bb9dbee2ae27bbe242d627fd31058aa51b" translate="yes" xml:space="preserve">
          <source>To have the framework header written without generics, add the flag to the compiler config:</source>
          <target state="translated">제네릭없이 프레임 워크 헤더를 작성하려면 컴파일러 구성에 플래그를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3ecd027b7452270691e59717236b30ee0ecf96d4" translate="yes" xml:space="preserve">
          <source>To help removing deprecated API gradually, the property &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;level&lt;/a&gt; could be used. Usually a gradual phase-out goes through the &quot;warning&quot;, then &quot;error&quot;, then &quot;hidden&quot; or &quot;removed&quot; stages:</source>
          <target state="translated">더 이상 사용되지 않는 API를 점진적으로 제거하기 위해 특성 &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;레벨&lt;/a&gt; 을 사용할 수 있습니다. 일반적으로 점진적인 단계적 종료는 &quot;경고&quot;, &quot;오류&quot;, &quot;숨김&quot;또는 &quot;제거&quot;단계를 거칩니다.</target>
        </trans-unit>
        <trans-unit id="bc69b946016a4baffee197957d550f5dda1d3fad" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your case, we'll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style.</source>
          <target state="translated">귀하의 사례에 적합한 스코프 기능을 선택하는 데 도움을 드리기 위해 해당 기능을 자세히 설명하고 사용 권장 사항을 제공합니다. 기술적으로 함수는 여러 경우에 상호 교환이 가능하므로 예제는 일반적인 사용 스타일을 정의하는 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2dc9569e913e0a78f05976a0042b79260268c830" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your purpose, we provide the table of key differences between them.</source>
          <target state="translated">목적에 맞는 올바른 스코프 기능을 선택할 수 있도록 주요 차이점 표를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3bc65688182a6a956a218fa3a16959313490f82c" translate="yes" xml:space="preserve">
          <source>To import a Kotlin/Native module in an existing Xcode project:</source>
          <target state="translated">기존 Xcode 프로젝트에서 Kotlin / Native 모듈을 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="2c68721c967bf9f85180daa4363543c530c2e36a" translate="yes" xml:space="preserve">
          <source>To import this module in Kotlin, you have to write two Kotlin source files:</source>
          <target state="translated">Kotlin에서이 모듈을 가져 오려면 두 개의 Kotlin 소스 파일을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c82d374c6d84bb2e142c6de52f1cf3dcc0306ae" translate="yes" xml:space="preserve">
          <source>To improve the behavior in such cases, Kotlin 1.3 introduces experimental mechanism called &lt;em&gt;contracts&lt;/em&gt;.</source>
          <target state="translated">이러한 경우 동작을 개선하기 위해 Kotlin 1.3에는 &lt;em&gt;계약&lt;/em&gt; 이라는 실험 메커니즘이 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2d833a47bb81067eedcf42dfefd225e6c4221741" translate="yes" xml:space="preserve">
          <source>To improve the speed of builds that use kapt, you can enable the &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; for kapt tasks. Using the worker API lets Gradle run independent annotation processing tasks from a single project in parallel, which in some cases significantly decreases the execution time. However, running kapt with Gradle worker API enabled can result in increased memory consumption due to parallel execution.</source>
          <target state="translated">kapt를 사용하는 빌드 속도를 향상시키기 위해 &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; 를 kapt 작업에 사용할 수 있습니다. 작업자 API를 사용하면 Gradle이 단일 프로젝트에서 독립적 인 주석 처리 작업을 병렬로 실행할 수 있으므로 경우에 따라 실행 시간이 크게 단축됩니다. 그러나 Gradle worker API가 활성화 된 상태에서 kapt를 실행하면 병렬 실행으로 인해 메모리 소비가 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="068fdab62a2284b03b98013c61f3a69a95e920c0" translate="yes" xml:space="preserve">
          <source>To improve the times of incremental builds with kapt, it can use the Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;compile avoidance&lt;/a&gt;. With compile avoidance enabled, Gradle can skip annotation processing when rebuilding a project. Particularly, annotation processing is skipped when:</source>
          <target state="translated">kapt를 사용한 증분 빌드 시간을 향상시키기 위해 Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;컴파일 방지를&lt;/a&gt; 사용할 수 있습니다 . 컴파일 회피를 사용하면 Gradle은 프로젝트를 다시 빌드 할 때 주석 처리를 건너 뛸 수 있습니다. 특히 다음과 같은 경우 주석 처리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ccaf04d3ae02444add2457f45cff16183d2e8aae" translate="yes" xml:space="preserve">
          <source>To include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; to a gradle project:</source>
          <target state="translated">&lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 을 gradle 프로젝트에 포함 시키 려면 :</target>
        </trans-unit>
        <trans-unit id="9a00cb17d9820854213a41158d7418355d4b5911" translate="yes" xml:space="preserve">
          <source>To include Java sources in the compilations of a JVM target, or to apply a Gradle plugin that requires the &lt;code&gt;java&lt;/code&gt; plugin to work, you need to explicitly enable Java support for the target:</source>
          <target state="translated">JVM 대상 컴파일에 Java 소스를 포함 시키거나 &lt;code&gt;java&lt;/code&gt; 플러그인이 작동해야하는 Gradle 플러그인을 적용하려면 대상에 대한 Java 지원을 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="7860a6aaa1b42e9447caa0f0a8321e9d88a64124" translate="yes" xml:space="preserve">
          <source>To include the Kotlin OSGi bundle to a Maven project:</source>
          <target state="translated">Kotlin OSGi 번들을 Maven 프로젝트에 포함 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="077956d227f2aa6078ddf39bc8e4e3d8b94732b8" translate="yes" xml:space="preserve">
          <source>To inspect the bookkeeping details of the library</source>
          <target state="translated">라이브러리의 부기 세부 정보를 검사하려면</target>
        </trans-unit>
        <trans-unit id="8c24292aeea43558882c36e9ecc631d06e7467b2" translate="yes" xml:space="preserve">
          <source>To install the library to the default location use</source>
          <target state="translated">라이브러리를 기본 위치에 설치하려면</target>
        </trans-unit>
        <trans-unit id="7ee91ac3540f1dbe83a27b16835cca72eb9b4a6e" translate="yes" xml:space="preserve">
          <source>To interop with platforms, use platform-specific versions of Kotlin. &lt;strong&gt;Platform-specific versions of Kotlin&lt;/strong&gt; (Kotlin/JVM, Kotlin/JS, Kotlin/Native) include extensions to the Kotlin language, and platform-specific libraries and tools.</source>
          <target state="translated">플랫폼과 상호 운용하려면 플랫폼 별 Kotlin 버전을 사용하세요. &lt;strong&gt;Kotlin의 플랫폼 별 버전&lt;/strong&gt; (Kotlin / JVM, Kotlin / JS, Kotlin / Native)에는 Kotlin 언어에 대한 확장과 플랫폼 별 라이브러리 및 도구가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="24f6533d6772f8462ed0f43822595fdca8aa6a25" translate="yes" xml:space="preserve">
          <source>To iterate a number range which does not include its end element, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt;&lt;code&gt;until&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">끝 요소를 포함하지 않는 숫자 범위를 반복하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt; &lt;code&gt;until&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b66d0a5358d7d3838074096ed7a34f595b79a041" translate="yes" xml:space="preserve">
          <source>To iterate numbers in reverse order, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt;&lt;code&gt;downTo&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">숫자를 역순으로 반복하려면 &lt;code&gt;..&lt;/code&gt; 대신 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt; &lt;code&gt;downTo&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de33c40021cd7f879768e42f24ff227ac1b5363" translate="yes" xml:space="preserve">
          <source>To iterate over a range of numbers, use a &lt;a href=&quot;ranges&quot;&gt;range expression&lt;/a&gt;:</source>
          <target state="translated">숫자 범위를 반복하려면 &lt;a href=&quot;ranges&quot;&gt;범위 표현식을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d257341caadaa79961255fe9fe80098ff7724e64" translate="yes" xml:space="preserve">
          <source>To keep certain declarations from elimination, add the &lt;code&gt;dceTask&lt;/code&gt; block to your Gradle build script and list the declarations as arguments of the &lt;code&gt;keep&lt;/code&gt; function. An argument must be the declaration's fully qualified name with the module name as a prefix: &lt;code&gt;moduleName.dot.separated.package.name.declarationName&lt;/code&gt;</source>
          <target state="translated">특정 선언이 제거되지 않도록하려면 Gradle 빌드 스크립트에 &lt;code&gt;dceTask&lt;/code&gt; 블록을 추가 하고 선언을 &lt;code&gt;keep&lt;/code&gt; 함수의 인수로 나열합니다 . 인수는 모듈 이름을 접두사로 사용하는 선언의 정규화 된 이름이어야합니다. &lt;code&gt;moduleName.dot.separated.package.name.declarationName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab2aa40b87301860aff15bd0eb5882ddd4d76c11" translate="yes" xml:space="preserve">
          <source>To learn more about the available features in the new Kotlin/JS IR compiler and how to try it for your project, visit the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">새로운 Kotlin / JS IR 컴파일러에서 사용 가능한 기능과 프로젝트에서 사용하는 방법에 대해 자세히 알아 보려면 &lt;a href=&quot;js-ir-compiler&quot;&gt;문서를&lt;/a&gt; 방문하세요 .</target>
        </trans-unit>
        <trans-unit id="85b39f1ed38fbcb7ba7bf0ac158a30f9c142955c" translate="yes" xml:space="preserve">
          <source>To link to a library use the &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; flag. For example:</source>
          <target state="translated">라이브러리에 링크하려면 &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; 플래그를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d43d923015e08ab71364c00b4d2a9fc351e1604" translate="yes" xml:space="preserve">
          <source>To link to another element (class, method, property or parameter), simply put its name in square brackets:</source>
          <target state="translated">다른 요소 (클래스, 메서드, 속성 또는 매개 변수)에 연결하려면 해당 이름을 대괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="04523bc3328b0c5397fbfdee046da0685d0fae03" translate="yes" xml:space="preserve">
          <source>To list library contents:</source>
          <target state="translated">라이브러리 내용을 나열하려면</target>
        </trans-unit>
        <trans-unit id="94d09a96d064da30ca57cf8cdc79fa8ea3d9ad9e" translate="yes" xml:space="preserve">
          <source>To maintain indentation in multiline strings, use &lt;code&gt;trimIndent&lt;/code&gt; when the resulting string does not require any internal indentation, or &lt;code&gt;trimMargin&lt;/code&gt; when internal indentation is required:</source>
          <target state="translated">여러 줄 문자열에서 들여 쓰기를 사용 유지하기 위해 &lt;code&gt;trimIndent&lt;/code&gt; 을 결과 문자열은 내부 들여 쓰기를 요구하거나하지 않는 경우 &lt;code&gt;trimMargin&lt;/code&gt; 를 내부 들여 쓰기가 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="e12b1be94182f1503207932a398c53d947b434c0" translate="yes" xml:space="preserve">
          <source>To make Kotlin APIs work in Java we generate &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; as &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; for covariantly defined &lt;code&gt;Box&lt;/code&gt; (or &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; for contravariantly defined &lt;code&gt;Foo&lt;/code&gt;) when it appears &lt;em&gt;as a parameter&lt;/em&gt;. When it's a return value, we don't generate wildcards, because otherwise Java clients will have to deal with them (and it's against the common Java coding style). Therefore, the functions from our example are actually translated as follows:</source>
          <target state="translated">Kotlin API를 Java에서 작동하게하려면 &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; covariantly 정의에 대한 &lt;code&gt;Box&lt;/code&gt; (또는 &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; contravariantly 정의에 대한 &lt;code&gt;Foo&lt;/code&gt; )가 나타날 때 &lt;em&gt;매개 변수로&lt;/em&gt; . 반환 값일 때는 와일드 카드를 생성하지 않습니다. 그렇지 않으면 Java 클라이언트가 처리해야합니다 (그리고 일반적인 Java 코딩 스타일에 위배됩니다). 따라서이 예제의 함수는 실제로 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa213848d1f87a73fda0915bb91fbde0ccc8072" translate="yes" xml:space="preserve">
          <source>To make reading the input in competitive programming tasks like this more concise, you can have the following list of helper input-reading functions:</source>
          <target state="translated">이와 같이 경쟁력있는 프로그래밍 작업에서 입력을보다 간결하게 작성하려면 다음과 같은 도우미 입력 판독 기능 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9375e20c00ff62d1ddedd02075c0f25b2cc018c0" translate="yes" xml:space="preserve">
          <source>To make the compiler do this, we need to mark the &lt;code&gt;lock()&lt;/code&gt; function with the &lt;code&gt;inline&lt;/code&gt; modifier:</source>
          <target state="translated">컴파일러에서이를 수행하려면 &lt;code&gt;lock()&lt;/code&gt; 함수를 &lt;code&gt;inline&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27c1b74df654000c9e62d4a18ccabc7efde139c9" translate="yes" xml:space="preserve">
          <source>To make the compiler start controlling scopes we only have to annotate the types of all receivers used in the DSL with the same marker annotation. For instance, for HTML Builders we declare an annotation &lt;code&gt;@HTMLTagMarker&lt;/code&gt;:</source>
          <target state="translated">컴파일러가 범위 제어를 시작하게하려면 DSL에 사용 된 모든 수신기 유형에 동일한 표식 주석을 달기 만하면됩니다. 예를 들어 HTML 빌더의 경우 &lt;code&gt;@HTMLTagMarker&lt;/code&gt; 주석을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="28e2c451a4401d778b575e3ce27ab0a72af2a6e7" translate="yes" xml:space="preserve">
          <source>To make the library complete we should write some tests, but we have three independent implementations and it is a waste of time to write duplicate tests for each one. The good thing about common code is that it can be covered with common tests, which later are compiled and executed on &lt;em&gt;every&lt;/em&gt; platform. All the bits for testing are already generated by the project Wizard.</source>
          <target state="translated">라이브러리를 완성하려면 몇 가지 테스트를 작성해야하지만 3 개의 독립적 인 구현이 있으며 각 테스트마다 중복 테스트를 작성하는 것은 시간 낭비입니다. 공통 코드에 대한 좋은 점은 공통 테스트로 다룰 수 있다는 것입니다.이 테스트는 나중에 &lt;em&gt;모든&lt;/em&gt; 플랫폼 에서 컴파일되고 실행됩니다 . 테스트를위한 모든 비트는 이미 프로젝트 마법사에 의해 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="942a849d5ea3976160d1c1dbff01132e386b6a13" translate="yes" xml:space="preserve">
          <source>To make this work, we should</source>
          <target state="translated">이 작업을 수행하려면</target>
        </trans-unit>
        <trans-unit id="c619d626cb3800fca0e85916c367e7240cf3f525" translate="yes" xml:space="preserve">
          <source>To make unsigned integers easier to use, Kotlin provides an ability to tag an integer literal with a suffix indicating a specific unsigned type (similarly to Float/Long):</source>
          <target state="translated">부호없는 정수를보다 쉽게 ​​사용할 수 있도록 Kotlin은 부호없는 특정 유형 (Float / Long과 유사)을 나타내는 접미어로 정수 리터럴에 태그를 지정하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c98bfc3140cd7bdf91e45deb511c924efadd9a92" translate="yes" xml:space="preserve">
          <source>To make your builds faster, you can enable incremental compilation for Maven (supported since Kotlin 1.1.2). In order to do that, define the &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; property:</source>
          <target state="translated">보다 빠른 빌드를 위해 Maven에 대한 증분 컴파일을 활성화 할 수 있습니다 (Kotlin 1.1.2부터 지원). 그렇게하려면 &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; 속성을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2895b62f37c528355f502b2144c9b302d5145a42" translate="yes" xml:space="preserve">
          <source>To manually compile the application call the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;downloaded&lt;/a&gt; compiler and generate a &lt;code&gt;hello.kexe&lt;/code&gt; (Linux and macOS) or &lt;code&gt;hello.exe&lt;/code&gt; (Windows) binary file:</source>
          <target state="translated">애플리케이션을 수동으로 컴파일하려면 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;다운로드 한&lt;/a&gt; 컴파일러를 호출하고 &lt;code&gt;hello.kexe&lt;/code&gt; (Linux 및 macOS) 또는 &lt;code&gt;hello.exe&lt;/code&gt; (Windows) 이진 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b4f6cb9f672ef57783a6ef29cd59db4418575608" translate="yes" xml:space="preserve">
          <source>To mark an API element as experimental, annotate its declaration with your experimental marker annotation:</source>
          <target state="translated">API 요소를 실험으로 표시하려면 실험 마커 주석으로 선언에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="cb122bda7a14229a5d1edd9ff546275f891b9d77" translate="yes" xml:space="preserve">
          <source>To merge two collections into one, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt;&lt;code&gt;union()&lt;/code&gt;&lt;/a&gt; function. It can be used in the infix form &lt;code&gt;a union b&lt;/code&gt;. Note that for ordered collections the order of the operands is important: in the resulting collection, the elements of the first operand go before the elements of the second.</source>
          <target state="translated">두 컬렉션을 하나로 병합하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt; &lt;code&gt;union()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 접두사 형태 &lt;code&gt;a union b&lt;/code&gt; 로 사용될 수 있습니다 . 정렬 된 컬렉션의 경우 피연산자의 순서가 중요합니다. 결과 컬렉션에서는 첫 번째 피연산자의 요소가 두 번째 피연산자의 요소보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="44d5c2b36c84b91934a121e2f5ace6e150a12f1e" translate="yes" xml:space="preserve">
          <source>To mitigate such issues, functions using inline classes are &lt;em&gt;mangled&lt;/em&gt; by adding some stable hashcode to the function name. Therefore, &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; will be represented as &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt;, which solves the clash problem.</source>
          <target state="translated">이러한 문제를 완화하기 위해 인라인 클래스를 사용 하는 함수는 함수 이름에 안정적인 해시 코드를 추가하여 &lt;em&gt;엉망&lt;/em&gt; 입니다. 따라서 &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; 는 &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt; 로 표시되어 충돌 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="214eeb66f4dd4d1fbd2d9b25b399283f63731ef6" translate="yes" xml:space="preserve">
          <source>To mitigate this problem for the users of such bytecode processing tools, we&amp;rsquo;ve added a command-line option (&lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt;) that tells the compiler to generate more Java-like bytecode for such constructs. Here &lt;code&gt;MODE&lt;/code&gt; is one of:</source>
          <target state="translated">이러한 바이트 코드 처리 도구 사용자에게이 문제를 완화하기 위해 컴파일러에 이러한 구문에 대해 더 많은 Java와 유사한 바이트 코드를 생성하도록 지시 하는 명령 행 옵션 ( &lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt; )을 추가했습니다. 여기서 &lt;code&gt;MODE&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d6aa0bdd277639961899c3f20d2977a244b12631" translate="yes" xml:space="preserve">
          <source>To mitigate this, when defining your generic classes, if the generic type should &lt;em&gt;never&lt;/em&gt; be null, provide a non-null type constraint:</source>
          <target state="translated">이를 완화하려면 일반 클래스를 정의 할 때 일반 유형이 널 이 &lt;em&gt;아니&lt;/em&gt; 어야하는 경우 널이 아닌 유형 제한 조건을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="c1476847da392c83fd72508f4713555cdba4a150" translate="yes" xml:space="preserve">
          <source>To open the list of available courses, go to &lt;strong&gt;Browse Courses&lt;/strong&gt; on the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;. You can start with the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;, a series of exercises created to get you familiar with the Kotlin Syntax:</source>
          <target state="translated">가능한 과목의 목록을 열려면 이동 &lt;strong&gt;과정 검색&lt;/strong&gt; 켜기 &lt;strong&gt;시작 화면&lt;/strong&gt; 또는에서 &lt;strong&gt;파일 메뉴&lt;/strong&gt; . Kotlin 구문에 익숙해 지도록 작성된 일련의 연습 인 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans로&lt;/a&gt; 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f5b1117471b5f9bbedb587fe4ad37368bca070e" translate="yes" xml:space="preserve">
          <source>To opt-in without propagating, either annotate declarations with &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; or pass &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; to the compiler.</source>
          <target state="translated">에 수신 거부에 전파하지 않고,과하거나 주석을 선언 &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; 또는 통과 &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; 컴파일러에.</target>
        </trans-unit>
        <trans-unit id="5c9c6ae81e15d7660d42f1ec133505c23d5897c2" translate="yes" xml:space="preserve">
          <source>To overcome this restriction an &lt;code&gt;internal&lt;/code&gt; declaration can be annotated with the &lt;code&gt;@PublishedApi&lt;/code&gt; annotation:</source>
          <target state="translated">이 제한을 극복하기 위해 &lt;code&gt;@PublishedApi&lt;/code&gt; 주석으로 &lt;code&gt;internal&lt;/code&gt; 선언에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a53373994c3982c9e9e8b4ff82c6886cee600271" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;clone()&lt;/code&gt;, your class needs to extend &lt;code&gt;kotlin.Cloneable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;clone()&lt;/code&gt; 을 재정의하려면 클래스가 &lt;code&gt;kotlin.Cloneable&lt;/code&gt; 을 확장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5ef664ee32f352aa2bb27af09f15aaa52406f6" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;finalize()&lt;/code&gt;, all you need to do is simply declare it, without using the &lt;em&gt;override&lt;/em&gt; keyword:</source>
          <target state="translated">무시하려면 &lt;code&gt;finalize()&lt;/code&gt; 사용하지 않고, 당신이 할 필요가 단순히 선언되는 &lt;em&gt;재정의&lt;/em&gt; 키워드 :</target>
        </trans-unit>
        <trans-unit id="8b0eb1602de9391e417352c211eac3143269f17a" translate="yes" xml:space="preserve">
          <source>To override different methods with clashing Kotlin signatures, you can add a &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; annotation to the class.</source>
          <target state="translated">Kotlin 서명 충돌로 다른 메소드를 대체 하기 위해 클래스에 &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; 주석을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91bf99aec76b5996287fb77c5aef5099beb9bbf4" translate="yes" xml:space="preserve">
          <source>To pass an array of primitive values you can do the following in Kotlin:</source>
          <target state="translated">기본 값의 배열을 전달하려면 Kotlin에서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e5025ef1a23d09437b26030660587370537de7f" translate="yes" xml:space="preserve">
          <source>To pass custom raw compiler arguments, you can use &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; elements with either &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;line&lt;/code&gt; attributes. This can be done within the &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; task elements, as follows:</source>
          <target state="translated">사용자 정의 원시 컴파일러 인수를 전달하기 위해 &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; 요소를 &lt;code&gt;value&lt;/code&gt; 또는 &lt;code&gt;line&lt;/code&gt; 속성 과 함께 사용할 수 있습니다 . &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; 태스크 요소 내에서 다음과 같이 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a66e06df579b1b23b91b1d16d9167a525f0b07ab" translate="yes" xml:space="preserve">
          <source>To perform a certain operation only for non-null values, you can use the safe call operator together with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">null이 아닌 값에 대해서만 특정 작업을 수행하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 과 함께 safe call 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad4b6b2d80d98efbdc1e78464bd70bae937149d2" translate="yes" xml:space="preserve">
          <source>To perform operations on all keys or all values of a map, you can retrieve them from the properties &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; accordingly. &lt;code&gt;keys&lt;/code&gt; is a set of all map keys and &lt;code&gt;values&lt;/code&gt; is a collection of all map values.</source>
          <target state="translated">맵의 모든 키 또는 모든 값에 대해 작업을 수행하려면 그에 따라 속성 &lt;code&gt;keys&lt;/code&gt; 와 &lt;code&gt;values&lt;/code&gt; 에서 검색 할 수 있습니다 . &lt;code&gt;keys&lt;/code&gt; 는 모든 맵 키 세트이며 &lt;code&gt;values&lt;/code&gt; 은 모든 맵 값의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="f51b0c422406c4232c8e54b63e979d8283484a9e" translate="yes" xml:space="preserve">
          <source>To prevent spoiling the global object, Kotlin creates an object that contains all Kotlin declarations from the current module. So if you name your module as &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">전역 객체의 손상을 막기 위해 Kotlin은 현재 모듈의 모든 Kotlin 선언을 포함하는 객체를 만듭니다. 따라서 모듈 이름을 &lt;code&gt;myModule&lt;/code&gt; 로 지정 하면 모든 선언을 &lt;code&gt;myModule&lt;/code&gt; 객체 를 통해 JavaScript에 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf0b70dea8387f3ebfae5a605f2eb84fae8ef787" translate="yes" xml:space="preserve">
          <source>To produce a library with the Kotlin/Native compiler use the &lt;code&gt;-produce library&lt;/code&gt; or &lt;code&gt;-p library&lt;/code&gt; flag. For example:</source>
          <target state="translated">Kotlin / Native 컴파일러로 라이브러리를 생성하려면 &lt;code&gt;-produce library&lt;/code&gt; 또는 &lt;code&gt;-p library&lt;/code&gt; 플래그를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffef4a8cd2a1229b2f11fc8babdeb98ccaf8e0db" translate="yes" xml:space="preserve">
          <source>To produce binaries with the Kotlin/Native compiler it's sufficient to use the &lt;code&gt;-g&lt;/code&gt; option on the command line.</source>
          <target state="translated">Kotlin / Native 컴파일러로 바이너리를 생성하려면 명령 행 에서 &lt;code&gt;-g&lt;/code&gt; 옵션 을 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="bf705fafa9b67e24b379be9a50584f74e0e18d03" translate="yes" xml:space="preserve">
          <source>To propagate the opt-in requirement, annotate declarations that use unsigned integers with &lt;code&gt;@ExperimentalUnsignedTypes&lt;/code&gt;.</source>
          <target state="translated">옵트 인 요구 사항을 전파하려면 &lt;code&gt;@ExperimentalUnsignedTypes&lt;/code&gt; 와 함께 부호없는 정수를 사용하는 선언에 주석을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="1d3463a205e94a6afcbfd6330cbb565e26b9762f" translate="yes" xml:space="preserve">
          <source>To provide a custom equals check implementation, override the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt; function. Functions with the same name and other signatures, like &lt;code&gt;equals(other: Foo)&lt;/code&gt;, don't affect equality checks with the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">커스텀 equals check 구현을 제공하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt; 함수를 재정의하십시오 . &lt;code&gt;equals(other: Foo)&lt;/code&gt; 와 같은 이름과 다른 서명을 가진 함수는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자를 사용한 동등성 검사에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e836b4f2fc16da476cc12a9d2050e81e112acff" translate="yes" xml:space="preserve">
          <source>To provide access to user's native operating system services, &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution includes a set of prebuilt libraries specific to each target. We call them &lt;strong&gt;Platform Libraries&lt;/strong&gt;.</source>
          <target state="translated">사용자의 기본 운영 체제 서비스에 대한 액세스를 제공하기 위해 &lt;code&gt;Kotlin/Native&lt;/code&gt; 배포에는 각 대상에 고유 한 사전 빌드 된 라이브러리 세트가 포함됩니다. 우리는 그들을 &lt;strong&gt;플랫폼 라이브러리&lt;/strong&gt; 라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="31bd1e7079e9e4ecee7632836be44ddf7d329d26" translate="yes" xml:space="preserve">
          <source>To publish an Android library as a part of a multiplatform library, one needs to &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;setup publishing for the library&lt;/a&gt; and provide additional configuration for the Android library target.</source>
          <target state="translated">멀티 플랫폼 라이브러리의 일부로 Android 라이브러리를 공개하려면 라이브러리에 대한 &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;공개&lt;/a&gt; 를 설정 하고 Android 라이브러리 대상에 대한 추가 구성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d256a0c22e6d267c506acee2d9aeb1788f5b9b28" translate="yes" xml:space="preserve">
          <source>To refer to the object, we use its name directly:</source>
          <target state="translated">객체를 참조하기 위해 이름을 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6b8089bed090bdadd847bf36cd42b8f6183969d2" translate="yes" xml:space="preserve">
          <source>To remove an element at a specific position from a list, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt;&lt;code&gt;removeAt()&lt;/code&gt;&lt;/a&gt; function providing the position as an argument. All indices of elements that come after the element being removed will decrease by one.</source>
          <target state="translated">목록에서 특정 위치의 요소를 제거하려면 위치를 인수로 제공하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt; &lt;code&gt;removeAt()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 요소를 제거한 후 나오는 요소의 모든 인덱스는 1 씩 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="521b7c2bcc6979fed176a9238d544430e53c8f9c" translate="yes" xml:space="preserve">
          <source>To remove an element from a mutable collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;remove()&lt;/code&gt; accepts the element value and removes one occurrence of this value.</source>
          <target state="translated">변경 가능한 컬렉션에서 요소를 제거하려면 remove &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;remove()&lt;/code&gt; 는 요소 값을 승인하고이 값의 한 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a5e20b686847f8b478f6ecb4aea9aa4a6082939" translate="yes" xml:space="preserve">
          <source>To remove an entry from a mutable map, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. When calling &lt;code&gt;remove()&lt;/code&gt;, you can pass either a key or a whole key-value-pair. If you specify both the key and value, the element with this key will be removed only if its value matches the second argument.</source>
          <target state="translated">변경 가능한 맵에서 항목을 제거하려면 remove &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;remove()&lt;/code&gt; 호출 할 때 키 또는 전체 키-값 쌍을 전달할 수 있습니다. 키와 값을 모두 지정하면이 키가있는 요소는 해당 값이 두 번째 인수와 일치하는 경우에만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0521fbcd6fb6f9d94e609424eadc7933044f924e" translate="yes" xml:space="preserve">
          <source>To remove the library from the default repository use</source>
          <target state="translated">기본 저장소에서 라이브러리를 제거하려면</target>
        </trans-unit>
        <trans-unit id="31c3d88842fee1685ad0d679c0db8a0fc174ec11" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of experimental features by passing the argument &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; to &lt;code&gt;kotlinc&lt;/code&gt;.</source>
          <target state="translated">인수 전달하여 당신이 실험 기능을 사용하도록 선택해야하는 경고를 제거하려면 &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; 에 &lt;code&gt;kotlinc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e630e1d578ed6510bfa59a81e36360f93345c8c" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of this feature by passing the compiler argument &lt;code&gt;-Xinline-classes&lt;/code&gt;.</source>
          <target state="translated">To remove the warning you have to opt in to the usage of this feature by passing the compiler argument &lt;code&gt;-Xinline-classes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3f08203a0ddf6e6bc4f31d19032cdb3e04aee85" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">경고를 제거하려면 컴파일러 인수 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d469d435bb3a113c1dd1088e7025b64a6a0198e5" translate="yes" xml:space="preserve">
          <source>To represent body of an external function. In most cases Kotlin does not require to provide bodies of external functions and properties, but if for some reason you want to (for example, due to limitation of your coding style guides), you should use &lt;code&gt;definedExternally&lt;/code&gt;.</source>
          <target state="translated">외부 함수의 본문을 나타냅니다. 대부분의 경우 Kotlin은 외부 함수 및 속성 본문을 제공 할 필요는 없지만 어떤 이유로 코딩 스타일 가이드의 제한으로 인해 원하는 경우 &lt;code&gt;definedExternally&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="19ce750db4ac36bdd72cdcddab7ef744528c90ce" translate="yes" xml:space="preserve">
          <source>To represent value of default argument.</source>
          <target state="translated">기본 인수의 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="54a0a9d97090503eaabc29843393d48b0c0faafe" translate="yes" xml:space="preserve">
          <source>To resolve ambiguities in exports (like overloads for functions with the same name), you can use the &lt;code&gt;@JsExport&lt;/code&gt; annotation together with &lt;code&gt;@JsName&lt;/code&gt; to specify the names for the generated and exported functions.</source>
          <target state="translated">To resolve ambiguities in exports (like overloads for functions with the same name), you can use the &lt;code&gt;@JsExport&lt;/code&gt; annotation together with &lt;code&gt;@JsName&lt;/code&gt; to specify the names for the generated and exported functions.</target>
        </trans-unit>
        <trans-unit id="69457a99de832ac1adcb88dba9125bcc6ced4562" translate="yes" xml:space="preserve">
          <source>To retrieve the Java class of an object, use the &lt;code&gt;java&lt;/code&gt; extension property on a &lt;a href=&quot;reflection#class-references&quot;&gt;class reference&lt;/a&gt;:</source>
          <target state="translated">객체의 Java 클래스를 검색하려면 &lt;a href=&quot;reflection#class-references&quot;&gt;클래스 참조&lt;/a&gt; 에서 &lt;code&gt;java&lt;/code&gt; 확장 등록 정보를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9630cc244843d39b109cb4a4e7a2a47687f686a" translate="yes" xml:space="preserve">
          <source>To return a floating-point type, explicitly convert one of the arguments to a floating-point type.</source>
          <target state="translated">To return a floating-point type, explicitly convert one of the arguments to a floating-point type.</target>
        </trans-unit>
        <trans-unit id="cab4ab009a9095119ec865716a0422fa20f520ff" translate="yes" xml:space="preserve">
          <source>To return to the pre-1.2 behavior, pass the flag &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; to the compiler.</source>
          <target state="translated">1.2 이전 동작으로 돌아가려면 &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; 플래그 를 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5e0d2974dcfaa7063fb542a18d0b57f9a9db0a83" translate="yes" xml:space="preserve">
          <source>To run REPL in IntelliJ IDEA, open &lt;strong&gt;Tools | Kotlin | Kotlin REPL&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA에서 REPL을 실행하려면 &lt;strong&gt;도구 | 코 틀린 | 코 틀린 REPL&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c80c0585cded44d08003b71c290d1079d4069543" translate="yes" xml:space="preserve">
          <source>To run REPL in the OS command line, open &lt;strong&gt;/bin/kotlinc-jvm&lt;/strong&gt; from the directory of standalone Kotlin compiler.</source>
          <target state="translated">OS 명령 행에서 REPL을 실행하려면 독립형 Kotlin 컴파일러 디렉토리에서 &lt;strong&gt;/ bin / kotlinc-jvm을여십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7fd27594c6ae21992652c27028d51d29604dfae3" translate="yes" xml:space="preserve">
          <source>To run a script, we just pass the &lt;code&gt;-script&lt;/code&gt; option to the compiler with the corresponding script file.</source>
          <target state="translated">스크립트를 실행하려면 해당 스크립트 파일과 함께 &lt;code&gt;-script&lt;/code&gt; 옵션을 컴파일러에 전달하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="e2cae558670745cc7ac9e88ece3ef0ebf63a7483" translate="yes" xml:space="preserve">
          <source>To run kapt with compile avoidance:</source>
          <target state="translated">컴파일 방지로 kapt를 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="58d7a0df7bd3a304f110999cd04f5328dff8bc19" translate="yes" xml:space="preserve">
          <source>To run the application, right-click somewhere in the main file and select &lt;strong&gt;Run As | Kotlin Application&lt;/strong&gt;.</source>
          <target state="translated">응용 프로그램을 실행하려면 기본 파일에서 마우스 오른쪽 버튼을 클릭하고 &lt;strong&gt;Run As | 코 틀린 응용 프로그램&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4d15311fa7cd994c8e9ce22c145ce856d694db" translate="yes" xml:space="preserve">
          <source>To save your course as a zip file, go to &lt;strong&gt;Course Creator -&amp;gt; Generate Course Archive&lt;/strong&gt; action. The generated archive can be opened via the &lt;strong&gt;Browse Courses&lt;/strong&gt; available from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; and in the &lt;strong&gt;File Menu&lt;/strong&gt; with the &lt;strong&gt;Import Course&lt;/strong&gt; icon:</source>
          <target state="translated">코스를 zip 파일로 저장하려면 &lt;strong&gt;코스 생성기-&amp;gt; 코스 아카이브 생성&lt;/strong&gt; 액션으로 이동하십시오. 생성 된 아카이브는을 통해 열 수 있습니다 &lt;strong&gt;찾아보기 코스&lt;/strong&gt; 로부터 가능한 &lt;strong&gt;시작 화면&lt;/strong&gt; 과의 &lt;strong&gt;파일 메뉴&lt;/strong&gt; 로 &lt;strong&gt;가져 오기 과정&lt;/strong&gt; 아이콘 :</target>
        </trans-unit>
        <trans-unit id="36a621d8894a43c60f62b88c51e7aa345450af8d" translate="yes" xml:space="preserve">
          <source>To search an element in a sorted list, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt;&lt;code&gt;binarySearch()&lt;/code&gt;&lt;/a&gt; function passing the value as an argument. If such an element exists, the function returns its index; otherwise, it returns &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; where &lt;code&gt;insertionPoint&lt;/code&gt; is the index where this element should be inserted so that the list remains sorted. If there is more than one element with the given value, the search can return any of their indices.</source>
          <target state="translated">정렬 된 목록에서 요소를 검색하려면 값을 인수로 전달하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/binary-search&quot;&gt; &lt;code&gt;binarySearch()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . 이러한 요소가 존재하면 함수는 해당 인덱스를 리턴합니다. 그렇지 않으면 &lt;code&gt;(-insertionPoint - 1)&lt;/code&gt; 리턴합니다. 여기서 &lt;code&gt;insertionPoint&lt;/code&gt; 는 목록이 정렬 된 상태로 유지되도록이 요소를 삽입해야하는 색인입니다. 주어진 값을 가진 요소가 두 개 이상인 경우 검색은 색인을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680ca05ae718e68cfb1629f08e49b399fcda4d93" translate="yes" xml:space="preserve">
          <source>To see the full Gradle script check out the source of the project on GitHub.</source>
          <target state="translated">전체 Gradle 스크립트를 보려면 GitHub에서 프로젝트 소스를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6bc22d1c45afda0ba0e9856d43874792a674530d" translate="yes" xml:space="preserve">
          <source>To select module kind, set the &lt;code&gt;moduleKind&lt;/code&gt; compiler option in the Gradle build script.</source>
          <target state="translated">To select module kind, set the &lt;code&gt;moduleKind&lt;/code&gt; compiler option in the Gradle build script.</target>
        </trans-unit>
        <trans-unit id="06d76d8df652a0954c4314eb6cd119fb4f22f648" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Gradle, you should set &lt;code&gt;moduleKind&lt;/code&gt; property, i.e.</source>
          <target state="translated">Gradle을 통해 컴파일 할 때 모듈 시스템을 선택하려면 &lt;code&gt;moduleKind&lt;/code&gt; 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="16681c84550456d5ff8bc73b03434df79d115f43" translate="yes" xml:space="preserve">
          <source>To select module system when compiling via Maven, you should set &lt;code&gt;moduleKind&lt;/code&gt; configuration property, i.e. your &lt;code&gt;pom.xml&lt;/code&gt; should look like this:</source>
          <target state="translated">Maven을 통해 컴파일 할 때 모듈 시스템을 선택하려면 &lt;code&gt;moduleKind&lt;/code&gt; 구성 속성을 설정해야 합니다. 즉, &lt;code&gt;pom.xml&lt;/code&gt; 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="5dfb90c4357595726b2e826922df2d26c2c78269" translate="yes" xml:space="preserve">
          <source>To setup a multiplatform project from scratch in a Gradle project, first apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin to the project by adding the following to the beginning of the &lt;code&gt;build.gradle&lt;/code&gt; file:</source>
          <target state="translated">Gradle 프로젝트에서 멀티 플랫폼 프로젝트를 처음부터 새로 설정하려면 먼저 &lt;code&gt;build.gradle&lt;/code&gt; 파일 의 시작 부분에 다음을 추가하여 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인을 프로젝트에 적용 하십시오.</target>
        </trans-unit>
        <trans-unit id="c7e47d17458659905c4f2f62bdab7488ae50c7a1" translate="yes" xml:space="preserve">
          <source>To skip automatic conversion and ensure raw pointers are used in the bindings, a &lt;code&gt;noStringConversion&lt;/code&gt; statement in the &lt;code&gt;.def&lt;/code&gt; file could be used, i.e.</source>
          <target state="translated">자동 변환을 건너 뛰고 바인딩에 원시 포인터가 사용되도록 하려면 &lt;code&gt;.def&lt;/code&gt; 파일 의 &lt;code&gt;noStringConversion&lt;/code&gt; 문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db6bb94ddd68466610ca12cc204d3d3c6bd7dd12" translate="yes" xml:space="preserve">
          <source>To solve such issues, Kotlin introduces a special kind of class called an &lt;code&gt;inline class&lt;/code&gt;, which is declared by placing an &lt;code&gt;inline&lt;/code&gt; modifier before the name of the class:</source>
          <target state="translated">이러한 문제를 해결하기 위해 Kotlin은 &lt;code&gt;inline class&lt;/code&gt; 라는 특수한 클래스를 도입했습니다 . 클래스는 클래스 이름 앞에 &lt;code&gt;inline&lt;/code&gt; 수정자를 배치하여 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6edca763e12c6292a414b20b65eaba5f53f467b" translate="yes" xml:space="preserve">
          <source>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an explicit &lt;em&gt;constructor&lt;/em&gt; keyword):</source>
          <target state="translated">클래스의 기본 생성자의 가시성을 지정하려면 다음 구문을 사용하십시오 (명시 적 &lt;em&gt;생성자&lt;/em&gt; 키워드 를 추가해야 함 ).</target>
        </trans-unit>
        <trans-unit id="419bcc45449c9e2a7d1fb4c22599e33f123b758a" translate="yes" xml:space="preserve">
          <source>To specify additional compilation options, use the &lt;code&gt;kotlinOptions&lt;/code&gt; property of a Kotlin compilation task.</source>
          <target state="translated">추가 컴파일 옵션을 지정하려면 Kotlin 컴파일 작업 의 &lt;code&gt;kotlinOptions&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ac203e68342bc2b26ca6bd486204285a11e36be" translate="yes" xml:space="preserve">
          <source>To specify that a function type is &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;nullable&lt;/a&gt;, use parentheses: &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt;.</source>
          <target state="translated">함수 유형이 &lt;a href=&quot;null-safety#nullable-types-and-non-null-types&quot;&gt;널 입력 가능&lt;/a&gt; 하도록 지정하려면 괄호를 사용하십시오. &lt;code&gt;((Int, Int) -&amp;gt; Int)?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa582abf300c214133b85270789a22565f82393f" translate="yes" xml:space="preserve">
          <source>To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</source>
          <target state="translated">To start coroutine debugging, you just need to set breakpoints and run the application in debug mode.</target>
        </trans-unit>
        <trans-unit id="e57f72b9d262e6ee5d6ce2e784cc4119575a7e41" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다. 결과 연속에서 재개 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="29211ac1a181cd4bb3901bb410d7de3d38f88156" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.createCoroutine.T%29%29%2C+kotlin.coroutines.createCoroutine.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속 호출된다. 결과 연속에서 재개 함수를 계속 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="93a4c159e45ae9b13567d12cfe549a89c643e81c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="03689575e5ce0d05cb5875c63b25386ef2dc70ce" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines%24createCoroutine(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.createCoroutine.T)),%20kotlin.coroutines.createCoroutine.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.createCoroutine.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when the coroutine completes with a result or an exception. Subsequent invocation of any resume function on the resulting continuation will produce an &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b715c677cb96aa31e520707c8bf7a084527dde6c" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다. 결과 연속에서 재개 함수를 반복적으로 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="7ae9d4ba7899cbe4180b0d690d30390847f2291f" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; instance. The &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception. Repeated invocation of any resume function on the resulting continuation produces &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt;.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 &lt;a href=&quot;-continuation/index&quot;&gt;Continuation&lt;/a&gt; 인스턴스 에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오 . &lt;a href=&quot;create-coroutine#kotlin.coroutines.experimental%24createCoroutine%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.createCoroutine.T%29%29%2C+kotlin.coroutines.experimental.createCoroutine.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.createCoroutine.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다. 결과 연속에서 재개 함수를 반복적으로 호출하면 &lt;a href=&quot;../kotlin/-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="dfc6df82451691b1971099e0817380884cac3aec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="e102b42121057a6878b15b2e0b7a9abdd7059c88" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unchecked#kotlin.coroutines.experimental.intrinsics%24createCoroutineUnchecked%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%2C+kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.R%2C+kotlin.coroutines.experimental.Continuation%28%28kotlin.coroutines.experimental.intrinsics.createCoroutineUnchecked.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="a74d51560d5c774d1a56f8d84a208e43206f3604" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="aa80d28b000c404e7e7471739dc834ced4e443ec" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">생성 된 코 루틴을 실행하려면 반환 된 Continuation 인스턴스에서 &lt;code&gt;resume(Unit)&lt;/code&gt; 을 호출 하십시오. &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완료&lt;/a&gt; 코 루틴은 결과 또는 예외로 완료 될 때 연속이 호출된다.</target>
        </trans-unit>
        <trans-unit id="107268b53cdccea4df633455aa08e9eb59213796" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</target>
        </trans-unit>
        <trans-unit id="15c18083bec73d38fe935b18a61bfb26719f41fa" translate="yes" xml:space="preserve">
          <source>To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</source>
          <target state="translated">To start executing the created coroutine, invoke &lt;code&gt;resume(Unit)&lt;/code&gt; on the returned Continuation instance. The &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; continuation is invoked when coroutine completes with result or exception.</target>
        </trans-unit>
        <trans-unit id="e2482fe90c75c3748aeac1be942111f81e932b33" translate="yes" xml:space="preserve">
          <source>To start the course, go to &lt;strong&gt;View -&amp;gt; Tool Windows -&amp;gt; Project&lt;/strong&gt;. You will find a course plan, the list of lessons. Every lesson has a set of tasks and code exercises you need to solve. Start with the very first one:</source>
          <target state="translated">과정을 시작하려면 &lt;strong&gt;보기-&amp;gt; 도구 창-&amp;gt; 프로젝트로 이동하십시오&lt;/strong&gt; . 코스 계획, 수업 목록을 찾을 수 있습니다. 모든 수업에는 해결해야 할 일련의 작업과 코드 연습이 있습니다. 첫 번째로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="af4a3359bcc2d8aaecee721a7eaa5358429907bb" translate="yes" xml:space="preserve">
          <source>To start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;js-project-setup&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;, or pick a hands-on lab from the next section to work through.</source>
          <target state="translated">To start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;js-project-setup&quot;&gt;Setting up a Kotlin/JS project&lt;/a&gt;, or pick a hands-on lab from the next section to work through.</target>
        </trans-unit>
        <trans-unit id="5f3ceec14c1433cf322f7865c09a18312ccb1945" translate="yes" xml:space="preserve">
          <source>To start with, we'll need a Microsoft Visual C++ compiler installed that supports a x64_64 target. The easiest way to do this is to have a version of Microsoft Visual Studio installed on a Windows machine.</source>
          <target state="translated">우선 x64_64 대상을 지원하는 Microsoft Visual C ++ 컴파일러가 설치되어 있어야합니다. 가장 쉬운 방법은 Windows 컴퓨터에 Microsoft Visual Studio 버전을 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="66185b084e5432ac45a03abd883161f880e5f11e" translate="yes" xml:space="preserve">
          <source>To switch to the old behavior, pass the fallback flag &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; to the compiler.</source>
          <target state="translated">이전 동작으로 전환하려면 폴백 플래그 &lt;code&gt;-Xno-receiver-assertions&lt;/code&gt; 를 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="cc3b8fe9e3a75acdfca2d542f5fc3f0b9c8e0c32" translate="yes" xml:space="preserve">
          <source>To switch to the old smart casts behavior, pass the fallback flag &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; as the compiler argument. It will become deprecated in Kotlin 1.3.</source>
          <target state="translated">이전 스마트 캐스트 동작으로 전환하려면 폴백 플래그 &lt;code&gt;-Xlegacy-smart-cast-after-try&lt;/code&gt; 를 컴파일러 인수로 전달하십시오. Kotlin 1.3에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ee56f12e381a099c59880a6823066a60e9d50df" translate="yes" xml:space="preserve">
          <source>To take all the elements except a given number of first or last elements, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt;&lt;code&gt;drop()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt;&lt;code&gt;dropLast()&lt;/code&gt;&lt;/a&gt; functions respectively.</source>
          <target state="translated">지정된 수의 첫 번째 또는 마지막 요소를 제외한 모든 요소를 ​​가져 오려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop&quot;&gt; &lt;code&gt;drop()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/drop-last&quot;&gt; &lt;code&gt;dropLast()&lt;/code&gt; &lt;/a&gt; 함수를 각각 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="27b36af5861b299fc805f783568e62a3fc319e12" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin.</source>
          <target state="translated">To target the JVM, apply the Kotlin JVM plugin.</target>
        </trans-unit>
        <trans-unit id="ca844ba87cff8c023079c9be62782b3a3fde8a97" translate="yes" xml:space="preserve">
          <source>To target the JVM, apply the Kotlin JVM plugin. Starting with Kotlin 1.1.1, the plugin can be applied using the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;:</source>
          <target state="translated">JVM을 대상으로하려면 Kotlin JVM 플러그인을 적용하십시오. Kotlin 1.1.1부터 &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle 플러그인 DSL을&lt;/a&gt; 사용하여 플러그인을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="089288f0ea4e442474ea533e687f95ceb53b919e" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided by the developer, and therefore does not try to generate any JavaScript code from the declaration. This means that you should omit bodies of &lt;code&gt;external&lt;/code&gt; declarations. For example:</source>
          <target state="translated">Kotlin에게 특정 선언이 순수 JavaScript로 작성되었음을 알리려면 &lt;code&gt;external&lt;/code&gt; 수정 자로 표시해야합니다 . 컴파일러는 이러한 선언을 볼 때 해당 클래스, 함수 또는 속성에 대한 구현이 개발자가 제공한다고 가정하므로 선언에서 JavaScript 코드를 생성하려고 시도하지 않습니다. 이것은 &lt;code&gt;external&lt;/code&gt; 선언의 본문을 생략해야 함을 의미합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c054ec329a7a56272832fde51ee7e82f8f4336b8" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with the &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided externally (by the developer or via an &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm dependency&lt;/a&gt;), and therefore does not try to generate any JavaScript code from the declaration. This is also why &lt;code&gt;external&lt;/code&gt; declarations can't have a body. For example:</source>
          <target state="translated">To tell Kotlin that a certain declaration is written in pure JavaScript, you should mark it with the &lt;code&gt;external&lt;/code&gt; modifier. When the compiler sees such a declaration, it assumes that the implementation for the corresponding class, function or property is provided externally (by the developer or via an &lt;a href=&quot;js-project-setup#npm-dependencies&quot;&gt;npm dependency&lt;/a&gt;), and therefore does not try to generate any JavaScript code from the declaration. This is also why &lt;code&gt;external&lt;/code&gt; declarations can't have a body. For example:</target>
        </trans-unit>
        <trans-unit id="13b684242eb1261a088744c1edd0d98430ef5246" translate="yes" xml:space="preserve">
          <source>To tell Kotlin that an &lt;code&gt;external&lt;/code&gt; class, package, function or property is a JavaScript module, you can use &lt;code&gt;@JsModule&lt;/code&gt; annotation. Consider you have the following CommonJS module called &quot;hello&quot;:</source>
          <target state="translated">Kotlin에 &lt;code&gt;external&lt;/code&gt; 클래스, 패키지, 함수 또는 속성이 JavaScript 모듈 &lt;code&gt;@JsModule&lt;/code&gt; 위해 @JsModule 주석을 사용할 수 있습니다 . &quot;hello&quot;라는 다음 CommonJS 모듈이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9709dd3d7713138256dbb958ab241135af68f988" translate="yes" xml:space="preserve">
          <source>To test it, we'll use a simple async function that resolves to a specified string after a specified time:</source>
          <target state="translated">이를 테스트하기 위해 지정된 시간 후에 지정된 문자열로 해석되는 간단한 비동기 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1b99a15ae02c59db4c41dbf465be5149eb5f7541" translate="yes" xml:space="preserve">
          <source>To throw an exception object, use the &lt;em&gt;throw&lt;/em&gt;-expression:</source>
          <target state="translated">예외 객체를 던질하기 위해 사용 &lt;em&gt;던져&lt;/em&gt; -expression를 :</target>
        </trans-unit>
        <trans-unit id="c7a0e8b8a829212ce4bf38fa9f7e144c221c0093" translate="yes" xml:space="preserve">
          <source>To turn off DCE completely, use the &lt;code&gt;devMode&lt;/code&gt; option in the &lt;code&gt;dceTask&lt;/code&gt;:</source>
          <target state="translated">To turn off DCE completely, use the &lt;code&gt;devMode&lt;/code&gt; option in the &lt;code&gt;dceTask&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="374704e123399146f9a10acdf418e1645171dca5" translate="yes" xml:space="preserve">
          <source>To unwrap the reference:</source>
          <target state="translated">참조를 풀려면</target>
        </trans-unit>
        <trans-unit id="a91c18bfe059c0da75a37ebc4ffaf3efe0d2e769" translate="yes" xml:space="preserve">
          <source>To unzip a list of pairs, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt;&lt;code&gt;unzip()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쌍의 목록을 압축 해제하려면 unzip &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/unzip&quot;&gt; &lt;code&gt;unzip()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a0e0cb040b2c181af6e3ea61de668187d10e532" translate="yes" xml:space="preserve">
          <source>To use a property, simply refer to it by name:</source>
          <target state="translated">To use a property, simply refer to it by name:</target>
        </trans-unit>
        <trans-unit id="d8bf5ffe82f149520490d0887cef3348767dda39" translate="yes" xml:space="preserve">
          <source>To use a property, we simply refer to it by name, as if it were a field in Java:</source>
          <target state="translated">속성을 사용하려면 Java의 필드 인 것처럼 이름으로 간단히 참조하면됩니다.</target>
        </trans-unit>
        <trans-unit id="213ffc2b7aa1496be9528a577f9f8df930989d35" translate="yes" xml:space="preserve">
          <source>To use an EAP build instead, we need to specify its version in &lt;code&gt;ext.kotlin_version&lt;/code&gt; and add the corresponding repository to the &lt;code&gt;buildscript&lt;/code&gt; section (usually EAP builds are located on &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt;)</source>
          <target state="translated">대신 EAP 빌드를 사용하려면, 우리는 그것의 버전을 지정해야 &lt;code&gt;ext.kotlin_version&lt;/code&gt; 과에 해당 저장소를 추가 &lt;code&gt;buildscript&lt;/code&gt; 의 부분 (일반적으로 EAP가에있는 빌드 &lt;a href=&quot;https://bintray.com/kotlin&quot;&gt;Bintray&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="95905a2dc80cd98916ed0f8c91572f9ae392d28e" translate="yes" xml:space="preserve">
          <source>To use an experimental API in all functions and classes in a file, add the file-level annotation &lt;code&gt;@file:UseExperimental&lt;/code&gt; to the top of the file before the package specification and imports.</source>
          <target state="translated">파일의 모든 함수와 클래스에서 실험용 API를 사용하려면 파일 사양 주석 &lt;code&gt;@file:UseExperimental&lt;/code&gt; 을 패키지 사양 및 가져 오기 전에 파일 맨 위에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7911ada2a93fd834ce5409496ee220d5914c628" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in a scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list.</source>
          <target state="translated">To use classes or functions from a project in a scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list.</target>
        </trans-unit>
        <trans-unit id="905c85d4c4dbeeb5849e639296b6ff9051d12bf0" translate="yes" xml:space="preserve">
          <source>To use classes or functions from a project in the scratch, import them into the scratch file as usual with the &lt;code&gt;import&lt;/code&gt; statement. Then write your code and run it with the appropriate module selected in &lt;strong&gt;Use classpath of module&lt;/strong&gt; list. To rebuild the module automatically before running the scratch, select &lt;strong&gt;Make before Run&lt;/strong&gt;.</source>
          <target state="translated">스크래치에서 프로젝트의 클래스 또는 함수를 사용하려면 &lt;code&gt;import&lt;/code&gt; 문을 사용하여 평소와 같이 스크래치 파일로 가져 오십시오 . 그런 다음 코드를 작성하고 &lt;strong&gt;모듈&lt;/strong&gt; 목록의 &lt;strong&gt;클래스 경로 사용&lt;/strong&gt; 에서 선택한 적절한 모듈로 실행 하십시오. 스크래치를 실행하기 전에 모듈을 자동으로 다시 빌드하려면 실행 전에 작성을 선택 &lt;strong&gt;하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7e6f898d3fd804cbaaa8f5e41eecb4b87b3f095b" translate="yes" xml:space="preserve">
          <source>To use it with Kotlin configure annotation processing dependency using &lt;code&gt;kapt&lt;/code&gt;:</source>
          <target state="translated">Kotlin과 함께 사용하려면 &lt;code&gt;kapt&lt;/code&gt; 를 사용하여 주석 처리 종속성을 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b18f46b3a0f449d7eb395f93e2e99d2ceb07f22" translate="yes" xml:space="preserve">
          <source>To use reflection in a Gradle or Maven project, add the dependency on &lt;code&gt;kotlin-reflect&lt;/code&gt;:</source>
          <target state="translated">To use reflection in a Gradle or Maven project, add the dependency on &lt;code&gt;kotlin-reflect&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a24de3bc480fd74ef920d5e8c2200b8ea53a9381" translate="yes" xml:space="preserve">
          <source>To use such an extension outside its declaring package, we need to import it at the call site:</source>
          <target state="translated">이러한 확장을 선언 패키지 외부에서 사용하려면 호출 사이트에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="f45da6c5e75b429df6c944cb1a348aa71eac1487" translate="yes" xml:space="preserve">
          <source>To use the Gradle worker API for parallel execution of kapt tasks, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">kapt 작업의 병렬 실행에 Gradle worker API를 사용하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b36ae1fba60b209f3facc66006c1d59e359e4b" translate="yes" xml:space="preserve">
          <source>To use the library just</source>
          <target state="translated">라이브러리를 사용하려면</target>
        </trans-unit>
        <trans-unit id="f8b6262cd9dc8c43d7c667ac936a5f2566f2a0e4" translate="yes" xml:space="preserve">
          <source>To use these dependencies from a Kotlin code, import a package &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;. In the example above, it's &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt;.</source>
          <target state="translated">Kotlin 코드에서 이러한 종속성을 사용하려면 &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; 패키지를 가져 오십시오 . 위의 예에서 &lt;code&gt;cocoapods.AFNetworking&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fc228ddfd7202033ce71a7fc317732c5e0b0cb8d" translate="yes" xml:space="preserve">
          <source>To use these dependencies from the Kotlin code, import the packages &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">To use these dependencies from the Kotlin code, import the packages &lt;code&gt;cocoapods.&amp;lt;library-name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f56a6a1ece973c1e685039b7b24f3bed65f0bb" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to &lt;strong&gt;Settings | Editor | Inspections&lt;/strong&gt; and enable the &lt;strong&gt;Kotlin | Style issues | File is not formatted according to project settings&lt;/strong&gt; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">To verify that your code is formatted according to the style guide, go to &lt;strong&gt;Settings | Editor | Inspections&lt;/strong&gt; and enable the &lt;strong&gt;Kotlin | Style issues | File is not formatted according to project settings&lt;/strong&gt; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</target>
        </trans-unit>
        <trans-unit id="29ce373f521a913b58c57c24b3da2c509d708a6c" translate="yes" xml:space="preserve">
          <source>To verify that your code is formatted according to the style guide, go to the inspection settings and enable the &quot;Kotlin | Style issues | File is not formatted according to project settings&quot; inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.</source>
          <target state="translated">스타일 가이드에 따라 코드 형식이 지정되었는지 확인하려면 검사 설정으로 이동하여 &quot;Kotlin | 스타일 문제 | 파일이 프로젝트 설정에 따라 형식이 지정되지 않았습니다&quot;검사를 활성화하십시오. 스타일 가이드에 설명 된 다른 문제 (예 : 명명 규칙)를 확인하는 추가 검사는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4960c3af648de37ee9fc988a1b8a755e743e505" translate="yes" xml:space="preserve">
          <source>To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the &lt;code&gt;withTimeout&lt;/code&gt; block.</source>
          <target state="translated">To workaround this problem you can store a reference to the resource in the variable as opposed to returning it from the &lt;code&gt;withTimeout&lt;/code&gt; block.</target>
        </trans-unit>
        <trans-unit id="b6747c485a8043bd5cfaa965ac1719dda893a066" translate="yes" xml:space="preserve">
          <source>To wrap the reference:</source>
          <target state="translated">참조를 래핑하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4fc60ef5d69079c451ea67854c51808d9ec41c01" translate="yes" xml:space="preserve">
          <source>Tooling</source>
          <target state="translated">Tooling</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="a2b342afe760f02175e18eb57be53d77e5b4d945" translate="yes" xml:space="preserve">
          <source>Tools for Android Development</source>
          <target state="translated">안드로이드 개발 도구</target>
        </trans-unit>
        <trans-unit id="933c173dc4997663d3dd2b639f726f17d399abb1" translate="yes" xml:space="preserve">
          <source>Top level/global variables of non-primitive types are by default accessible in the main thread (i.e., the thread which initialized &lt;em&gt;Kotlin/Native&lt;/em&gt; runtime first) only. Access from another thread will lead to an &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; being thrown. To make such variables accessible in other threads, you can use either the &lt;code&gt;@ThreadLocal&lt;/code&gt; annotation, and mark the value thread local or &lt;code&gt;@SharedImmutable&lt;/code&gt;, which will make the value frozen and accessible from other threads.</source>
          <target state="translated">기본이 아닌 유형의 최상위 레벨 / 글로벌 변수는 기본적으로 메인 스레드 (즉, &lt;em&gt;Kotlin / Native&lt;/em&gt; 런타임을 먼저 초기화 한 스레드 )에서만 액세스 할 수 있습니다 . 다른 스레드에서 액세스하면 &lt;code&gt;IncorrectDereferenceException&lt;/code&gt; 이 발생합니다. 이러한 변수를 다른 스레드에서 액세스 할 수 있도록하려면 &lt;code&gt;@ThreadLocal&lt;/code&gt; 주석을 사용 하고 값 스레드를 로컬 또는 &lt;code&gt;@SharedImmutable&lt;/code&gt; 로 표시하면 다른 스레드에서 값을 고정하고 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10164060fa5359f1cc0440621a4aa0561a65a4b" translate="yes" xml:space="preserve">
          <source>Top-level Kotlin functions and properties are accessible as members of special classes. Each Kotlin file is translated into such a class. E.g.</source>
          <target state="translated">최상위 클래스 Kotlin 함수 및 속성은 특수 클래스의 멤버로 액세스 할 수 있습니다. 각 Kotlin 파일은 이러한 클래스로 변환됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="2b1be77aa458090db17874852b17692b274f4c30" translate="yes" xml:space="preserve">
          <source>Top-level functions and properties</source>
          <target state="translated">최상위 기능 및 속성</target>
        </trans-unit>
        <trans-unit id="73a9d7257a50c4b586e17a750a9b120479406586" translate="yes" xml:space="preserve">
          <source>Top-level variables:</source>
          <target state="translated">최상위 변수 :</target>
        </trans-unit>
        <trans-unit id="093982a5b38ce32bb690b5df5afe9cfb58db39b3" translate="yes" xml:space="preserve">
          <source>Top-level, or member of an &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;object&lt;/em&gt; declaration&lt;/a&gt; or &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;a &lt;em&gt;companion object&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">의 최상위 또는 멤버 &lt;a href=&quot;object-declarations#object-declarations&quot;&gt;&lt;em&gt;객체&lt;/em&gt; 선언&lt;/a&gt; 또는 &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;em&gt;동반자 객체&lt;/em&gt;&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3f139abb7a549a1210b36f7dbf89215ad6c9902" translate="yes" xml:space="preserve">
          <source>Touch</source>
          <target state="translated">Touch</target>
        </trans-unit>
        <trans-unit id="1efa29eabe3ababde0e86df3b6d2edc46db3122e" translate="yes" xml:space="preserve">
          <source>TouchList</source>
          <target state="translated">TouchList</target>
        </trans-unit>
        <trans-unit id="86c192cdf813e67ab4284db18cce6c47a873de77" translate="yes" xml:space="preserve">
          <source>TrackEventInit</source>
          <target state="translated">TrackEventInit</target>
        </trans-unit>
        <trans-unit id="7b5b3a2e5f602edd973d6bc7c27d9b7106a52ef4" translate="yes" xml:space="preserve">
          <source>Trailing commas</source>
          <target state="translated">후행 쉼표</target>
        </trans-unit>
        <trans-unit id="10b9c6cd7256580987215cb5bd31fae33f7491a8" translate="yes" xml:space="preserve">
          <source>Trailing commas are entirely optional &amp;ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</source>
          <target state="translated">Trailing commas are entirely optional &amp;ndash; your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.</target>
        </trans-unit>
        <trans-unit id="24c733cfc9ff52310bfeff0739e9d84bd974f090" translate="yes" xml:space="preserve">
          <source>Training Partners</source>
          <target state="translated">교육 파트너</target>
        </trans-unit>
        <trans-unit id="62000f6d60c7b6da6e48acb50b9e4d2454c263e3" translate="yes" xml:space="preserve">
          <source>TransferMode</source>
          <target state="translated">TransferMode</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="45d5bc5a6500f8488347501d41f5194f063eae68" translate="yes" xml:space="preserve">
          <source>Transient</source>
          <target state="translated">Transient</target>
        </trans-unit>
        <trans-unit id="ba8d3f89d630067e3ad00c3e459e314bd98fb9a0" translate="yes" xml:space="preserve">
          <source>Transitive: for any non-null values &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, if &lt;code&gt;x.equals(y)&lt;/code&gt; returns true and &lt;code&gt;y.equals(z)&lt;/code&gt; returns true, then &lt;code&gt;x.equals(z)&lt;/code&gt; should return true.</source>
          <target state="translated">전이 : 널이 아닌 값 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 경우 &lt;code&gt;x.equals(y)&lt;/code&gt; 가 true를 리턴하고 &lt;code&gt;y.equals(z)&lt;/code&gt; 가 true를 리턴하면 &lt;code&gt;x.equals(z)&lt;/code&gt; 는 true를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b98ac58ac04384390fe968f8d17e1762075dcc" translate="yes" xml:space="preserve">
          <source>Translate primitive arrays to JS typed arrays</source>
          <target state="translated">기본 배열을 JS 유형 배열로 변환</target>
        </trans-unit>
        <trans-unit id="a1e378439cd6792c22e6754f9de426ee92e8887a" translate="yes" xml:space="preserve">
          <source>Translated to</source>
          <target state="translated">로 번역</target>
        </trans-unit>
        <trans-unit id="bd2fa02487c23403447e0670b33275ea05db6a74" translate="yes" xml:space="preserve">
          <source>Translation Rules</source>
          <target state="translated">번역 규칙</target>
        </trans-unit>
        <trans-unit id="ab6dfa598f3ee1889c506fcb09d74fa1777c572b" translate="yes" xml:space="preserve">
          <source>Translation of type &lt;code&gt;Nothing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Nothing&lt;/code&gt; 의 번역</target>
        </trans-unit>
        <trans-unit id="6aceb57c8bb80570e896470165c635c1ee57a688" translate="yes" xml:space="preserve">
          <source>Translation rules</source>
          <target state="translated">Translation rules</target>
        </trans-unit>
        <trans-unit id="a15aca388afb19d901171e68fd72afd431d071e5" translate="yes" xml:space="preserve">
          <source>Traversing a map/list of pairs</source>
          <target state="translated">지도 / 쌍 목록 탐색</target>
        </trans-unit>
        <trans-unit id="c5549ac8b888e22b01fa637b7351d8e5201d7fba" translate="yes" xml:space="preserve">
          <source>TreeWalker</source>
          <target state="translated">TreeWalker</target>
        </trans-unit>
        <trans-unit id="bf7930508d19dc53b19991f963b30e949ffffae4" translate="yes" xml:space="preserve">
          <source>Trigonometric: &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt; and inverse of them: &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;;</source>
          <target state="translated">삼각법 : &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; 및 그 반대로 : &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;atan2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="b9283be1760ffff3d2b71a4bf3400fc0c777b4fb" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">소스 문자열의 모든 행에서 선행 공백 문자 다음에 &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; 를 자르고 공백 이있는 경우 첫 번째와 마지막 행을 제거합니다 (공백 차이와 비어 있음).</target>
        </trans-unit>
        <trans-unit id="5480c14a1f35b84e453f6cd73b5a2004a2f5d464" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">Trims leading whitespace characters followed by &lt;a href=&quot;../../kotlin.text/trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</target>
        </trans-unit>
        <trans-unit id="c35e61d912f4e00490fababb98d899c86bab87f9" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">소스 문자열의 모든 행에서 선행 공백 문자 다음에 &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin%28kotlin.String%2C+kotlin.String%29%2FmarginPrefix&quot;&gt;marginPrefix&lt;/a&gt; 를 자르고 공백 이있는 경우 첫 번째와 마지막 행을 제거합니다 (공백 차이와 비어 있음).</target>
        </trans-unit>
        <trans-unit id="84a97aca5ec5480f19364dafde3094ff54f3e81a" translate="yes" xml:space="preserve">
          <source>Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</source>
          <target state="translated">Trims leading whitespace characters followed by &lt;a href=&quot;trim-margin#kotlin.text%24trimMargin(kotlin.String,%20kotlin.String)/marginPrefix&quot;&gt;marginPrefix&lt;/a&gt; from every line of a source string and removes the first and the last lines if they are blank (notice difference blank vs empty).</target>
        </trans-unit>
        <trans-unit id="ae1a12e0ad64ac32c1b6bcc5a4f65c861d2ccdb6" translate="yes" xml:space="preserve">
          <source>Triple</source>
          <target state="translated">Triple</target>
        </trans-unit>
        <trans-unit id="dd25f60abb02d8a8fead2fd0c632ac71f7dc7572" translate="yes" xml:space="preserve">
          <source>True if this BitSet contains no bits set to true.</source>
          <target state="translated">이 BitSet에 비트가 true로 설정되어 있지 않으면 True입니다.</target>
        </trans-unit>
        <trans-unit id="ebadece2244cd8c3930af24f6efed50ba5303aeb" translate="yes" xml:space="preserve">
          <source>Try is an expression</source>
          <target state="translated">시도는 표현이다</target>
        </trans-unit>
        <trans-unit id="ab16b9ed40416d31269e0f90879c02e2beaffb5d" translate="yes" xml:space="preserve">
          <source>Try the following example:</source>
          <target state="translated">다음 예제를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="6e8975e856a765f6b65172a38acea83accc861c3" translate="yes" xml:space="preserve">
          <source>Tuning the Gradle Build Script</source>
          <target state="translated">Gradle 빌드 스크립트 튜닝</target>
        </trans-unit>
        <trans-unit id="486df8c49f3484e79ec93676a1d2d32e3c21544f" translate="yes" xml:space="preserve">
          <source>Turn off the discovery of annotation processors in the compile classpath by adding this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가하여 컴파일 클래스 경로에서 주석 프로세서 감지를 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a8a70d82aa05be09e708b91e7f3e4c134d89ffcd" translate="yes" xml:space="preserve">
          <source>Two characters are considered the same ignoring case if at least one of the following is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">다음 중 적어도 하나 인 경우 두 문자는 같은 무시하는 경우 간주됩니다 &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab472c51dfbccf051740af19176dfafb00b61af8" translate="yes" xml:space="preserve">
          <source>Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.</source>
          <target state="translated">동일한 시드를 가진 두 개의 생성기는 동일한 버전의 Kotlin 런타임 내에서 동일한 순서의 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d137720f3328e5a478b178126ce3903c8817736d" translate="yes" xml:space="preserve">
          <source>Two maps containing the equal pairs are equal regardless of the pair order.</source>
          <target state="translated">동일한 쌍을 포함하는 두 맵은 쌍 순서에 관계없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="5f6616a8e5da9fee3d521ed755f2bea54b08215a" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: &amp;#x27;is&amp;#x27; and &amp;#x27;as&amp;#x27;</source>
          <target state="translated">유형 검사 및 캐스트 : 'is'및 'as'</target>
        </trans-unit>
        <trans-unit id="d6cc07866d5f06f3719a56316deb52a9dd1a6362" translate="yes" xml:space="preserve">
          <source>Type Checks and Casts: 'is' and 'as'</source>
          <target state="translated">유형 검사 및 캐스트 : 'is'및 'as'</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">유형 별명</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">타입 별칭</target>
        </trans-unit>
        <trans-unit id="69c8e849ce31321a314a70ac8ad4ed39beff1378" translate="yes" xml:space="preserve">
          <source>Type aliases do not introduce new types. They are equivalent to the corresponding underlying types. When you add &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; and use &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; in your code, the Kotlin compiler always expands it to &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt;. Thus you can pass a variable of your type whenever a general function type is required and vice versa:</source>
          <target state="translated">타입 별칭은 새로운 타입을 도입하지 않습니다. 해당하는 기본 유형과 같습니다. 코드에서 &lt;code&gt;typealias Predicate&amp;lt;T&amp;gt;&lt;/code&gt; 를 추가 하고 &lt;code&gt;Predicate&amp;lt;Int&amp;gt;&lt;/code&gt; 를 사용 하면 Kotlin 컴파일러는 항상 &lt;code&gt;(Int) -&amp;gt; Boolean&lt;/code&gt; 확장합니다 . 따라서 일반 함수 유형이 필요할 때마다 유형의 변수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63f9c00fb5f4cc41a0eed5075c935b736c6b9723" translate="yes" xml:space="preserve">
          <source>Type aliases provide alternative names for existing types. If the type name is too long you can introduce a different shorter name and use the new one instead.</source>
          <target state="translated">유형 별명은 기존 유형의 대체 이름을 제공합니다. 유형 이름이 너무 길면 더 짧은 다른 이름을 도입하고 대신 새 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e35e3a28b52f56ce98adcccb56e038088090c61a" translate="yes" xml:space="preserve">
          <source>Type arguments</source>
          <target state="translated">Type arguments</target>
        </trans-unit>
        <trans-unit id="f97f977bc0dba85c3cc52fd08f6033a3696be06a" translate="yes" xml:space="preserve">
          <source>Type arguments can be omitted if they can be inferred from the context, so the following example works as well:</source>
          <target state="translated">컨텍스트에서 유추 할 수있는 유형 인수는 생략 할 수 있으므로 다음 예제도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c98c974ad55a448f7905288ae79a3c29e3dafc00" translate="yes" xml:space="preserve">
          <source>Type arguments passed for the parameters of the classifier in this type. For example, in the type &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; the only type argument is &lt;code&gt;out Number&lt;/code&gt;.</source>
          <target state="translated">이 유형의 분류 자 ​​매개 변수에 전달 된 유형 인수. 예를 들어, &lt;code&gt;Array&amp;lt;out Number&amp;gt;&lt;/code&gt; 유형에서 유일한 유형 인수는 &lt;code&gt;out Number&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17f4a34465afc16c831c4800dd92a48a4229a238" translate="yes" xml:space="preserve">
          <source>Type casts to generic types with concrete type arguments, e.g. &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt;, cannot be checked at runtime.</source>
          <target state="translated">구체적인 유형 인수 (예 : &lt;code&gt;foo as List&amp;lt;String&amp;gt;&lt;/code&gt; ) 가있는 일반 유형으로 유형 캐스트 는 런타임시 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="73156460a89d705ba62bd534bd81f39c8db2596a" translate="yes" xml:space="preserve">
          <source>Type checks and automatic casts</source>
          <target state="translated">Type checks and automatic casts</target>
        </trans-unit>
        <trans-unit id="793f10e89d89960ec6635302ed647f148619a822" translate="yes" xml:space="preserve">
          <source>Type erasure</source>
          <target state="translated">유형 삭제</target>
        </trans-unit>
        <trans-unit id="40dc0a7305bb05f3cc921959233fc31aff814e2e" translate="yes" xml:space="preserve">
          <source>Type erasure and generic type checks</source>
          <target state="translated">유형 삭제 및 일반 유형 검사</target>
        </trans-unit>
        <trans-unit id="3a57e7033772e15f6c935d00cab613d6b63a13b4" translate="yes" xml:space="preserve">
          <source>Type inference for variable and property types</source>
          <target state="translated">변수 및 속성 유형에 대한 유형 유추</target>
        </trans-unit>
        <trans-unit id="6468c2c68f3a4de506104359dc49acb341f7ce4b" translate="yes" xml:space="preserve">
          <source>Type of this parameter. For a &lt;code&gt;vararg&lt;/code&gt; parameter, this is the type of the corresponding array, not the individual element.</source>
          <target state="translated">이 매개 변수의 유형입니다. A의 &lt;code&gt;vararg&lt;/code&gt; 파라미터, 이는 해당 어레이가 아닌 개별 요소의 유형이다.</target>
        </trans-unit>
        <trans-unit id="c9a3646a7ac556f56d25e93e18f2d2b1583d0264" translate="yes" xml:space="preserve">
          <source>Type parameters</source>
          <target state="translated">유형 매개 변수</target>
        </trans-unit>
        <trans-unit id="67db91aa392a58df5790c33c41ae1990e5a33a95" translate="yes" xml:space="preserve">
          <source>Type projection is either the star projection, or an entity consisting of a specific type plus optional variance.</source>
          <target state="translated">유형 투영은 별 투영 또는 특정 유형과 선택적 분산으로 구성된 엔터티입니다.</target>
        </trans-unit>
        <trans-unit id="a1c1994c749574f626726569018d7132330feb4f" translate="yes" xml:space="preserve">
          <source>Type projections</source>
          <target state="translated">타입 투영</target>
        </trans-unit>
        <trans-unit id="390df132c9a4d4db52e48418904c22311abcfb25" translate="yes" xml:space="preserve">
          <source>Type projections (use-site covariance and contravariance)</source>
          <target state="translated">유형 예측 (사용 사이트 공분산 및 공분산)</target>
        </trans-unit>
        <trans-unit id="abe0a5c2d281fcb1877a803065e24a61b33d5485" translate="yes" xml:space="preserve">
          <source>Type qualifier defaults (since 1.1.50)</source>
          <target state="translated">한정자 기본값 (1.1.50부터)</target>
        </trans-unit>
        <trans-unit id="7774fb35aa4a81a2d582ed079ba64fde2c6c6958" translate="yes" xml:space="preserve">
          <source>Type qualifier nicknames (since 1.1.50)</source>
          <target state="translated">한정자 닉네임 (1.1.50부터)</target>
        </trans-unit>
        <trans-unit id="40de16300b7ec7ebb7fd5b46ebfe06fa7442e5d2" translate="yes" xml:space="preserve">
          <source>Type usage</source>
          <target state="translated">유형 사용법</target>
        </trans-unit>
        <trans-unit id="302ec0e139d68906dc0b295bb935fe896afa1e82" translate="yes" xml:space="preserve">
          <source>Type-Safe Builders</source>
          <target state="translated">유형 안전 빌더</target>
        </trans-unit>
        <trans-unit id="1c6379917dd2967a0cd2179d5b9d494b8ce1b4e8" translate="yes" xml:space="preserve">
          <source>Type-safe builders allow creating Kotlin-based domain-specific languages (DSLs) suitable for building complex hierarchical data structures in a semi-declarative way. Some of the example use cases for the builders are:</source>
          <target state="translated">유형 안전 빌더를 사용하면 복잡한 계층 적 데이터 구조를 반 선언적 방식으로 구축하는 데 적합한 Kotlin 기반 DSL (Domain-Specific Language)을 만들 수 있습니다. 빌더의 일부 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c15b26d8e7df3e3ffb8c17df0302ea2aa484921" translate="yes" xml:space="preserve">
          <source>TypeCastException</source>
          <target state="translated">TypeCastException</target>
        </trans-unit>
        <trans-unit id="5f0d1a781a66df1f72742486a55df1e5b04f2308" translate="yes" xml:space="preserve">
          <source>Typealias describing custom exception reporting hook.</source>
          <target state="translated">사용자 정의 예외보고 후크를 설명하는 유형별</target>
        </trans-unit>
        <trans-unit id="f3f4c434904369ad0a9f93c33f4c9768b4547a37" translate="yes" xml:space="preserve">
          <source>TypedArrays support enabled by default</source>
          <target state="translated">기본적으로 TypedArrays 지원 활성화</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="5ee39ed12bcc53f39d2691296714b602c56e8452" translate="yes" xml:space="preserve">
          <source>Types in C Language</source>
          <target state="translated">C 언어의 유형</target>
        </trans-unit>
        <trans-unit id="9082e24429af3d96afc6c792bd53d243c13fe913" translate="yes" xml:space="preserve">
          <source>Types in Kotlin are optional in many places due to pervasive use of type-inference, but every declaration still has a well-defined static type that is known at compilation.</source>
          <target state="translated">Kotlin의 형식은 형식 유추를 광범위하게 사용하기 때문에 여러 곳에서 선택 사항이지만 모든 선언에는 여전히 컴파일시 알려진 잘 정의 된 정적 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="629a9e78a0114f36f48645e6ead99e73e5226592" translate="yes" xml:space="preserve">
          <source>Types mapping between C and Kotlin/Native</source>
          <target state="translated">C와 Kotlin / Native 사이의 유형 매핑</target>
        </trans-unit>
        <trans-unit id="f4beb9af58f792082d8857ce30b4be1bdbe9b57a" translate="yes" xml:space="preserve">
          <source>Typography</source>
          <target state="translated">Typography</target>
        </trans-unit>
        <trans-unit id="4ae5c7578750deca68bcc325a7a71916e13eb9f0" translate="yes" xml:space="preserve">
          <source>UArraysKt</source>
          <target state="translated">UArraysKt</target>
        </trans-unit>
        <trans-unit id="bf674fff56341390c001cb60679614bd8b320e06" translate="yes" xml:space="preserve">
          <source>UByte</source>
          <target state="translated">UByte</target>
        </trans-unit>
        <trans-unit id="ffb6040505a41eac67ecae4d97b182ca73c78ec7" translate="yes" xml:space="preserve">
          <source>UByteArray</source>
          <target state="translated">UByteArray</target>
        </trans-unit>
        <trans-unit id="d70700d1cf06666209f322639803c081fb20d34b" translate="yes" xml:space="preserve">
          <source>UByteIterator</source>
          <target state="translated">UByteIterator</target>
        </trans-unit>
        <trans-unit id="5c472b4b939131094e43f08559b073c75fc2a028" translate="yes" xml:space="preserve">
          <source>UByteVar</source>
          <target state="translated">UByteVar</target>
        </trans-unit>
        <trans-unit id="f25071b42b8c8e395a2b2b3981b7f23745b87556" translate="yes" xml:space="preserve">
          <source>UByteVarOf</source>
          <target state="translated">UByteVarOf</target>
        </trans-unit>
        <trans-unit id="7df33eb953a0db74ecea7bf713e814fb3abc743c" translate="yes" xml:space="preserve">
          <source>UIEventInit</source>
          <target state="translated">UIEventInit</target>
        </trans-unit>
        <trans-unit id="9b81a5f58a08d125439c4fe920735e6f93f6c26f" translate="yes" xml:space="preserve">
          <source>UInt</source>
          <target state="translated">UInt</target>
        </trans-unit>
        <trans-unit id="e8203a992b0218cb4341f1de99192c75977adf66" translate="yes" xml:space="preserve">
          <source>UIntArray</source>
          <target state="translated">UIntArray</target>
        </trans-unit>
        <trans-unit id="107a5f6058e02cbfca8e781b5a2a6f523ad395cb" translate="yes" xml:space="preserve">
          <source>UIntIterator</source>
          <target state="translated">UIntIterator</target>
        </trans-unit>
        <trans-unit id="b426f73d819457b44ee2c1f6127ae0354bab9219" translate="yes" xml:space="preserve">
          <source>UIntProgression</source>
          <target state="translated">UIntProgression</target>
        </trans-unit>
        <trans-unit id="733f5415b770d705f77b9612bf3ea932f2bce7d0" translate="yes" xml:space="preserve">
          <source>UIntRange</source>
          <target state="translated">UIntRange</target>
        </trans-unit>
        <trans-unit id="c9533b600e74bcc2cae112123bf64c63ddcac0d1" translate="yes" xml:space="preserve">
          <source>UIntVar</source>
          <target state="translated">UIntVar</target>
        </trans-unit>
        <trans-unit id="77c6c1f150c9389635fa7924b4f92a8549cf352c" translate="yes" xml:space="preserve">
          <source>UIntVarOf</source>
          <target state="translated">UIntVarOf</target>
        </trans-unit>
        <trans-unit id="89e5acbaebf4cf3fe914f8e97ce3365330718921" translate="yes" xml:space="preserve">
          <source>ULong</source>
          <target state="translated">ULong</target>
        </trans-unit>
        <trans-unit id="0aede794cd54bbb254cbbba847a9015fdedd384b" translate="yes" xml:space="preserve">
          <source>ULongArray</source>
          <target state="translated">ULongArray</target>
        </trans-unit>
        <trans-unit id="f83610c14f64002be2365b4b214aea8d4eb7c555" translate="yes" xml:space="preserve">
          <source>ULongIterator</source>
          <target state="translated">ULongIterator</target>
        </trans-unit>
        <trans-unit id="7f4860e3cc03b10b3ed8b10361499545cea0082e" translate="yes" xml:space="preserve">
          <source>ULongProgression</source>
          <target state="translated">ULongProgression</target>
        </trans-unit>
        <trans-unit id="904eba861b0907dd0e83aefaefd037f230269422" translate="yes" xml:space="preserve">
          <source>ULongRange</source>
          <target state="translated">ULongRange</target>
        </trans-unit>
        <trans-unit id="c10238514adfeb120f1beff5e873dea7b5ed95a8" translate="yes" xml:space="preserve">
          <source>ULongVar</source>
          <target state="translated">ULongVar</target>
        </trans-unit>
        <trans-unit id="f9dbd48fa2388e1f99c73bab257c97f132eb1089" translate="yes" xml:space="preserve">
          <source>ULongVarOf</source>
          <target state="translated">ULongVarOf</target>
        </trans-unit>
        <trans-unit id="b9a5671fcf84e88d78fc3704de6f9b452eff55a8" translate="yes" xml:space="preserve">
          <source>UNASSIGNED</source>
          <target state="translated">UNASSIGNED</target>
        </trans-unit>
        <trans-unit id="67a492265c45012bb305d1d916be6fecf6ea8e3e" translate="yes" xml:space="preserve">
          <source>UNDEFINED</source>
          <target state="translated">UNDEFINED</target>
        </trans-unit>
        <trans-unit id="a7864204909e345af29e9c794841c9fe894997a9" translate="yes" xml:space="preserve">
          <source>UNIX_LINES</source>
          <target state="translated">UNIX_LINES</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="c12e2347be0a8619c1d9ecacaec292e6f681ff3c" translate="yes" xml:space="preserve">
          <source>UNSAFE</source>
          <target state="translated">UNSAFE</target>
        </trans-unit>
        <trans-unit id="260ff90ffb9b1a7afc1635ad4eeec327ff83ec80" translate="yes" xml:space="preserve">
          <source>UPPERCASE_LETTER</source>
          <target state="translated">UPPERCASE_LETTER</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="b19e8d66e7f004e226c44a75766dadab7d09911a" translate="yes" xml:space="preserve">
          <source>URLSearchParams</source>
          <target state="translated">URLSearchParams</target>
        </trans-unit>
        <trans-unit id="91e7bf3c4d0ab9784e0c43761883c8268e94bc3e" translate="yes" xml:space="preserve">
          <source>US_ASCII</source>
          <target state="translated">US_ASCII</target>
        </trans-unit>
        <trans-unit id="3f4264aca0374d417f001d13663bbf89f0617103" translate="yes" xml:space="preserve">
          <source>UShort</source>
          <target state="translated">UShort</target>
        </trans-unit>
        <trans-unit id="c9c0b8b91e36fe7c1c4c0418920e6f5691e8c55a" translate="yes" xml:space="preserve">
          <source>UShortArray</source>
          <target state="translated">UShortArray</target>
        </trans-unit>
        <trans-unit id="6c3a83167054246ea25835255ce7b0e018316b2a" translate="yes" xml:space="preserve">
          <source>UShortIterator</source>
          <target state="translated">UShortIterator</target>
        </trans-unit>
        <trans-unit id="a33eeb13596790b08a6df8799ea234e412c8c47b" translate="yes" xml:space="preserve">
          <source>UShortVar</source>
          <target state="translated">UShortVar</target>
        </trans-unit>
        <trans-unit id="282cb40f96ea3b82ef408a23ef69ab3812e1c45c" translate="yes" xml:space="preserve">
          <source>UShortVarOf</source>
          <target state="translated">UShortVarOf</target>
        </trans-unit>
        <trans-unit id="bdfd4d8d6952777c39403b2d2e2f8a2a52bf255f" translate="yes" xml:space="preserve">
          <source>UTC</source>
          <target state="translated">UTC</target>
        </trans-unit>
        <trans-unit id="f0217f65f3e1f538b0d8cda26e80a2285c43df22" translate="yes" xml:space="preserve">
          <source>UTF-16 code unit (see the section on &lt;a href=&quot;strings&quot;&gt;strings&lt;/a&gt; - in most cases, this is one Unicode character, but it might be just one half of a Unicode character)</source>
          <target state="translated">UTF-16 코드 단위 ( &lt;a href=&quot;strings&quot;&gt;문자열&lt;/a&gt; 섹션 참조 -대부분의 경우 이것은 유니 코드 문자이지만 유니 코드 문자의 절반 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="3133dd8458a32c8b5ce4a722caa62b68748d9288" translate="yes" xml:space="preserve">
          <source>UTF_16</source>
          <target state="translated">UTF_16</target>
        </trans-unit>
        <trans-unit id="6ca2e2b19e1ecda564482fabe6d3670b269a5872" translate="yes" xml:space="preserve">
          <source>UTF_16BE</source>
          <target state="translated">UTF_16BE</target>
        </trans-unit>
        <trans-unit id="9754e677d06d03c4582e2dcf98147ca46f84d72e" translate="yes" xml:space="preserve">
          <source>UTF_16LE</source>
          <target state="translated">UTF_16LE</target>
        </trans-unit>
        <trans-unit id="447ed343c0ab25980389215d35f14db291c88450" translate="yes" xml:space="preserve">
          <source>UTF_32</source>
          <target state="translated">UTF_32</target>
        </trans-unit>
        <trans-unit id="92586032892e03cbec5d2f808289d67c3e5fe454" translate="yes" xml:space="preserve">
          <source>UTF_32BE</source>
          <target state="translated">UTF_32BE</target>
        </trans-unit>
        <trans-unit id="cbf0128f0e447f51c74b68507c6628894645216c" translate="yes" xml:space="preserve">
          <source>UTF_32LE</source>
          <target state="translated">UTF_32LE</target>
        </trans-unit>
        <trans-unit id="444b32f7d1774bb52a894fb896e3e3f1afe43c1f" translate="yes" xml:space="preserve">
          <source>UTF_8</source>
          <target state="translated">UTF_8</target>
        </trans-unit>
        <trans-unit id="ee17a2d4842b1562f38fb267817829d58a3dedfb" translate="yes" xml:space="preserve">
          <source>Uint16Array</source>
          <target state="translated">Uint16Array</target>
        </trans-unit>
        <trans-unit id="633c2aa79d88322b5d53222bfe0bb765531ece57" translate="yes" xml:space="preserve">
          <source>Uint32Array</source>
          <target state="translated">Uint32Array</target>
        </trans-unit>
        <trans-unit id="9dafd0a91ea1eadf5a4b323d71716a37f430543c" translate="yes" xml:space="preserve">
          <source>Uint8Array</source>
          <target state="translated">Uint8Array</target>
        </trans-unit>
        <trans-unit id="80d3d1902630c787d741b39af0ddaba8dab6c5b7" translate="yes" xml:space="preserve">
          <source>Uint8ClampedArray</source>
          <target state="translated">Uint8ClampedArray</target>
        </trans-unit>
        <trans-unit id="dbab18f3ded2bfe1f1beae0998ec97e669719cb0" translate="yes" xml:space="preserve">
          <source>Unary operations</source>
          <target state="translated">단항 연산</target>
        </trans-unit>
        <trans-unit id="700a41ed5d6a21b389d3a06a552007f7d4970e83" translate="yes" xml:space="preserve">
          <source>Unary operators &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, and a function &lt;code&gt;inv&lt;/code&gt;.</source>
          <target state="translated">단항 연산자 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;--&lt;/code&gt; 및 함수 &lt;code&gt;inv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7af4b44086924bef8511e74a06dc5652e98b37f" translate="yes" xml:space="preserve">
          <source>Unary prefix operators</source>
          <target state="translated">단항 접두사 연산자</target>
        </trans-unit>
        <trans-unit id="71f09f8fe1dde2289c868a03cb103ae030625690" translate="yes" xml:space="preserve">
          <source>Unchecked casts</source>
          <target state="translated">확인되지 않은 캐스트</target>
        </trans-unit>
        <trans-unit id="b8d5b81db1752990f9a00626b0f1fe949182953e" translate="yes" xml:space="preserve">
          <source>Unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. Unconfined dispatcher should not be used in general code.</source>
          <target state="translated">제한되지 않은 디스패처는 나중에 실행하기 위해 코 루틴을 디스패치 할 필요가 없거나 바람직하지 않은 부작용을 일으키는 특정 경우에 도움이 될 수있는 고급 메커니즘입니다. 코 루틴의 일부 작업은 즉시 수행해야하기 때문입니다. 제한되지 않은 디스패처는 일반 코드에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="1ad54c8520658fa2b0366caffc5901ab7a388736" translate="yes" xml:space="preserve">
          <source>Unconfined vs confined dispatcher</source>
          <target state="translated">제한되지 않은 발송자 및 한정된 발송자</target>
        </trans-unit>
        <trans-unit id="a2570f4d995169cd25ade0e53aebb8dd50e4a603" translate="yes" xml:space="preserve">
          <source>Undefined bidirectional character type. Undefined &lt;code&gt;char&lt;/code&gt; values have undefined directionality in the Unicode specification.</source>
          <target state="translated">정의되지 않은 양방향 문자 유형. 정의되지 않은 &lt;code&gt;char&lt;/code&gt; 값은 유니 코드 사양에서 정의되지 않은 방향성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="36bdd28a04792d2d0be5dfb8e33b3534b2fbd55b" translate="yes" xml:space="preserve">
          <source>Under the hood for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">모든 위임 된 속성에 대해 Kotlin 컴파일러는 보조 속성을 생성하고 위임합니다. 예를 들어 속성 &lt;code&gt;prop&lt;/code&gt; 의 경우 숨겨진 속성 &lt;code&gt;prop$delegate&lt;/code&gt; 가 생성되며 접근 자의 코드는 단순히이 추가 속성에 위임합니다.</target>
        </trans-unit>
        <trans-unit id="dd8b30eeb866c4439bd48cb8b3176d8c5f111d35" translate="yes" xml:space="preserve">
          <source>Under the hood, for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</source>
          <target state="translated">Under the hood, for every delegated property the Kotlin compiler generates an auxiliary property and delegates to it. For instance, for the property &lt;code&gt;prop&lt;/code&gt; the hidden property &lt;code&gt;prop$delegate&lt;/code&gt; is generated, and the code of the accessors simply delegates to this additional property:</target>
        </trans-unit>
        <trans-unit id="3488dca90e45f8e2402977d7d251d68f390541e0" translate="yes" xml:space="preserve">
          <source>Underscore for unused variables (since 1.1)</source>
          <target state="translated">사용되지 않은 변수의 밑줄 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="fb79a41a5516422da2e439b9cf71e40fb6fb14d4" translate="yes" xml:space="preserve">
          <source>Underscores for unused parameters</source>
          <target state="translated">사용하지 않는 매개 변수의 밑줄</target>
        </trans-unit>
        <trans-unit id="c1313f733bf8697e7ec5cdf78f97cfd84d52c63d" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals</source>
          <target state="translated">숫자 리터럴의 밑줄</target>
        </trans-unit>
        <trans-unit id="a32a8ccb60d72fd24a8aa497590c0bf8ba9cd8dc" translate="yes" xml:space="preserve">
          <source>Underscores in numeric literals (since 1.1)</source>
          <target state="translated">숫자 리터럴의 밑줄 (1.1 이후)</target>
        </trans-unit>
        <trans-unit id="1d199ddedf7802afc54d34deabe810e8a6bf5c4f" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you want an empty collection, you need to either declare the resulting collection type explicitly, or supply the element type(s) to the function that constructs the collection:</source>
          <target state="translated">불행히도 빈 컬렉션을 원하면 결과 컬렉션 유형을 명시 적으로 선언하거나 컬렉션을 구성하는 함수에 요소 유형을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e40bf9bbf42c1f6fc0258d8c13f458aad30b49f2" translate="yes" xml:space="preserve">
          <source>Unfortunately, the code formatter built into IntelliJ IDEA had to work long before this document was released and now has a default setup that produces different formatting from what is now recommended.</source>
          <target state="translated">불행히도 IntelliJ IDEA에 내장 된 코드 포맷터는이 문서가 릴리스되기 오래 전에 작동해야했으며 이제는 현재 권장되는 것과 다른 형식을 생성하는 기본 설정을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="12945de7af176c634a0d8ce8b70c82d42353176c" translate="yes" xml:space="preserve">
          <source>Unfortunately, using this would require us to type &lt;code&gt;p.name.value&lt;/code&gt; every time we wanted to use the property. We could do the following, but that's also not great since it introduces an extra property:</source>
          <target state="translated">불행히도 이것을 사용하려면 속성을 사용하려고 할 때마다 &lt;code&gt;p.name.value&lt;/code&gt; 를 입력해야 합니다. 우리는 다음을 수행 할 수 있지만 추가 속성을 도입하기 때문에 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8837f610cd63014d412facb51aa6f98460391f9a" translate="yes" xml:space="preserve">
          <source>Unicode correctness can be onerous in Python 2, since the &quot;default&quot; string type &lt;code&gt;str&lt;/code&gt; is really just a byte array, while &lt;code&gt;unicode&lt;/code&gt; is actually a sequence of &lt;em&gt;code units&lt;/em&gt; (see below) - and whether the code units are 16 or 32 bits wide depends on how your Python distribution was built. In Kotlin, there's no such confusion: &lt;code&gt;String&lt;/code&gt;, which is what you get when you make a string literal (which you can only do with double quotes), is an immutable sequence of UTF-16 code units. &lt;code&gt;ByteArray&lt;/code&gt; is a fixed-size (but otherwise mutable) byte array (and &lt;code&gt;String&lt;/code&gt; can specifically &lt;em&gt;not&lt;/em&gt; be used as a byte array).</source>
          <target state="translated">&quot;default&quot;문자열 타입 &lt;code&gt;str&lt;/code&gt; 은 실제로는 바이트 배열이고, &lt;code&gt;unicode&lt;/code&gt; 는 실제로 &lt;em&gt;코드 단위&lt;/em&gt; 의 시퀀스이므로 (아래 참조) 유니 코드의 정확성은 번거로울 수 있습니다. 파이썬 배포판이 어떻게 만들어 졌는지에 대해 Kotlin에는 혼동이 없습니다. &lt;code&gt;String&lt;/code&gt; 은 문자열 리터럴 (큰 따옴표로만 할 수 있음)을 만들 때 얻을 수있는 UTF-16 코드 단위의 불변 시퀀스입니다. &lt;code&gt;ByteArray&lt;/code&gt; 는 고정 크기 (그렇지만 변경 가능) 바이트 배열입니다 (그리고 &lt;code&gt;String&lt;/code&gt; 은 바이트 배열로 구체적 으로 사용할 수 &lt;em&gt;없습니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="505d5c38054a74d4b2175415322819ae4849fcad" translate="yes" xml:space="preserve">
          <source>Unified Module Definitions (UMD), which is compatible with both &lt;em&gt;AMD&lt;/em&gt; and &lt;em&gt;CommonJS&lt;/em&gt;, and works as &quot;plain&quot; when neither &lt;em&gt;AMD&lt;/em&gt; nor &lt;em&gt;CommonJS&lt;/em&gt; is available at runtime.</source>
          <target state="translated">&lt;em&gt;AMD&lt;/em&gt; 및 &lt;em&gt;CommonJS&lt;/em&gt; 와 호환 되며 런타임에 &lt;em&gt;AMD&lt;/em&gt; 또는 &lt;em&gt;CommonJS&lt;/em&gt; 를 사용할 수 없는 경우 &quot;일반&quot;으로 작동 하는 UMD (Unified Module Definitions) .</target>
        </trans-unit>
        <trans-unit id="4b0e76a89bd66d41a17ed421fa008af6ae14f66f" translate="yes" xml:space="preserve">
          <source>Unified standard library</source>
          <target state="translated">통합 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="c4f58ff59e65d2d98ffef40514cadc0e589f2165" translate="yes" xml:space="preserve">
          <source>Unify split by an empty match regex result across the platforms</source>
          <target state="translated">플랫폼에서 빈 일치 정규식 결과로 분할을 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="370ce5f1a9eb1b7143f06590af17c7841cb70b8d" translate="yes" xml:space="preserve">
          <source>UninitializedPropertyAccessException</source>
          <target state="translated">UninitializedPropertyAccessException</target>
        </trans-unit>
        <trans-unit id="a91e29c6a18b3d46ad21babc72fbe12a2806e9d6" translate="yes" xml:space="preserve">
          <source>UnionAudioTrackOrTextTrackOrVideoTrack</source>
          <target state="translated">UnionAudioTrackOrTextTrackOrVideoTrack</target>
        </trans-unit>
        <trans-unit id="b427069e00bef5cd6617471fa2f1c76d7e94c1b0" translate="yes" xml:space="preserve">
          <source>UnionClientOrMessagePortOrServiceWorker</source>
          <target state="translated">UnionClientOrMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="10052a20073fd80351eaa98a0618cc05908c3fe2" translate="yes" xml:space="preserve">
          <source>UnionElementOrHTMLCollection</source>
          <target state="translated">UnionElementOrHTMLCollection</target>
        </trans-unit>
        <trans-unit id="64df693fc6248e2d4b802ced57f664db2486df1a" translate="yes" xml:space="preserve">
          <source>UnionElementOrMouseEvent</source>
          <target state="translated">UnionElementOrMouseEvent</target>
        </trans-unit>
        <trans-unit id="5d95156c593ab4f5a1d6aa9b7adaaae5b5072eee" translate="yes" xml:space="preserve">
          <source>UnionElementOrProcessingInstruction</source>
          <target state="translated">UnionElementOrProcessingInstruction</target>
        </trans-unit>
        <trans-unit id="cb794bdbfe712bfdef6a341eb0ffeda3e61df94b" translate="yes" xml:space="preserve">
          <source>UnionElementOrRadioNodeList</source>
          <target state="translated">UnionElementOrRadioNodeList</target>
        </trans-unit>
        <trans-unit id="55e9b0c8b2893c068d7bad4f687cd74e04c97fae" translate="yes" xml:space="preserve">
          <source>UnionHTMLOptGroupElementOrHTMLOptionElement</source>
          <target state="translated">UnionHTMLOptGroupElementOrHTMLOptionElement</target>
        </trans-unit>
        <trans-unit id="9914d6bd1e51362b2ae64dd4e4f0c81df753f3a5" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrServiceWorker</source>
          <target state="translated">UnionMessagePortOrServiceWorker</target>
        </trans-unit>
        <trans-unit id="9f29b0aeda2c26ba869f1da1baf112b08de48285" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindow</source>
          <target state="translated">UnionMessagePortOrWindow</target>
        </trans-unit>
        <trans-unit id="0bdbd6bc95c6e23b6042a486f6d277c7a15fc86a" translate="yes" xml:space="preserve">
          <source>UnionMessagePortOrWindowProxy</source>
          <target state="translated">UnionMessagePortOrWindowProxy</target>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="0cc244abccf5ca3308a1494c12878b0d0e26feea" translate="yes" xml:space="preserve">
          <source>Unit-returning functions</source>
          <target state="translated">단위 반환 기능</target>
        </trans-unit>
        <trans-unit id="4e0950ee26dcc7da4ca806b4b340177a815e5066" translate="yes" xml:space="preserve">
          <source>Unless specified otherwise, the names of functions and modules can be &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;mangled&lt;/a&gt; in the generated JavaScript code. To keep such functions from elimination, use the mangled names in the &lt;code&gt;keep&lt;/code&gt; arguments as they appear in the generated JavaScript code.</source>
          <target state="translated">Unless specified otherwise, the names of functions and modules can be &lt;a href=&quot;js-to-kotlin-interop#jsname-annotation&quot;&gt;mangled&lt;/a&gt; in the generated JavaScript code. To keep such functions from elimination, use the mangled names in the &lt;code&gt;keep&lt;/code&gt; arguments as they appear in the generated JavaScript code.</target>
        </trans-unit>
        <trans-unit id="e885d6886100fb26b71f7747ee932dbb05e71ce7" translate="yes" xml:space="preserve">
          <source>Unless you're working on a library, omit redundant modifiers (e.g. &lt;code&gt;public&lt;/code&gt;).</source>
          <target state="translated">라이브러리에서 작업하지 않는 한 중복 수정자를 생략하십시오 (예 : &lt;code&gt;public&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8feafcdb2005e6ef556074da45e878f1b7bc1d3a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; it does not intercept continuation.</source>
          <target state="translated">&lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt; 과 달리 연속을 가로 채지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5baaedd3e64f7be16b02c01618d1a48a2f53082" translate="yes" xml:space="preserve">
          <source>Unlike Java, Kotlin does not have a separate &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&quot;import static&quot;&lt;/a&gt; syntax; all of these declarations are imported using the regular &lt;code&gt;import&lt;/code&gt; keyword.</source>
          <target state="translated">Java와 달리 Kotlin에는 별도의 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/language/static-import.html&quot;&gt;&quot;import static&quot;&lt;/a&gt; 구문이 없습니다. 이러한 모든 선언은 일반 &lt;code&gt;import&lt;/code&gt; 키워드를 사용하여 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7e26e1701ff3fbdbd8ab214ddee2ab24ae9fb3e0" translate="yes" xml:space="preserve">
          <source>Unlike Java, block comments in Kotlin can be nested.</source>
          <target state="translated">Java와 달리 Kotlin의 블록 주석은 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d71d4e303da5f24db04f06a7b993b10b6d2cf202" translate="yes" xml:space="preserve">
          <source>Unlike Python, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; is an expression: the last expression of the &lt;code&gt;try&lt;/code&gt; block (if it succeeds) or the chosen &lt;code&gt;catch&lt;/code&gt; block becomes the result value (&lt;code&gt;finally&lt;/code&gt; doesn't affect the result), so we can refactor the function body above to:</source>
          <target state="translated">파이썬과는 달리, &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 의 마지막 표현 : 표현이다 &lt;code&gt;try&lt;/code&gt; 블록 (성공할 경우) 또는 선택한 &lt;code&gt;catch&lt;/code&gt; 블록은 결과 값은 (된다 &lt;code&gt;finally&lt;/code&gt; 우리는 위의 함수 본문을 리팩토링 할 수 있도록 결과에 영향을주지 않습니다) :</target>
        </trans-unit>
        <trans-unit id="9ffcb8e6d8c0e1886c9139362bf8a80448f390b9" translate="yes" xml:space="preserve">
          <source>Unlike a queue, a channel can be closed to indicate that no more elements are coming. On the receiver side it is convenient to use a regular &lt;code&gt;for&lt;/code&gt; loop to receive elements from the channel.</source>
          <target state="translated">대기열과 달리 채널을 닫아 더 이상 요소가 없음을 나타냅니다. 수신기 측에서는 정기적 인 &lt;code&gt;for&lt;/code&gt; 루프를 사용 하여 채널에서 요소를 수신 하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="79736268c87ef812b5a0caf77be57b249d138010" translate="yes" xml:space="preserve">
          <source>Unlike docstrings, KDoc blocks are not available to the program at runtime.</source>
          <target state="translated">docstring과 달리 KDoc 블록은 런타임에 프로그램에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e77ba9444bad622fec50b4242ad0088f476d99f" translate="yes" xml:space="preserve">
          <source>Unlike other pointers, the parameters of type &lt;code&gt;const char*&lt;/code&gt; are represented as a Kotlin &lt;code&gt;String&lt;/code&gt;. So it is possible to pass any Kotlin string to a binding expecting a C string.</source>
          <target state="translated">다른 포인터와 달리 &lt;code&gt;const char*&lt;/code&gt; 유형의 매개 변수 는 Kotlin &lt;code&gt;String&lt;/code&gt; 으로 표시됩니다 . 따라서 모든 Kotlin 문자열을 C 문자열을 기대하는 바인딩에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3405f910e07d811413c0ab883fbacf2fe2d5fb" translate="yes" xml:space="preserve">
          <source>Unlike sources that can be fixed by hand in the worst case, binaries are a lot harder to migrate, and this makes backwards compatibility very important in the case of binaries. Incompatible changes to binaries can make updates very uncomfortable and thus should be introduced with even more care than those in the source language syntax.</source>
          <target state="translated">최악의 경우 손으로 수정할 수있는 소스와 달리 이진은 마이그레이션하기가 훨씬 어렵 기 때문에 이진의 경우 하위 호환성이 매우 중요합니다. 바이너리에 대한 호환되지 않는 변경은 업데이트를 매우 불편하게 만들 수 있으므로 소스 언어 구문의 것보다 더 조심스럽게 도입해야합니다.</target>
        </trans-unit>
        <trans-unit id="71ea4413722e85a3b020d9ed01e939aac7d2c7c0" translate="yes" xml:space="preserve">
          <source>Unlike the overload that accepts an argument of type &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, this function does not compare this string and the specified &lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt; in a synchronized block.</source>
          <target state="translated">Unlike the overload that accepts an argument of type &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;, this function does not compare this string and the specified &lt;a href=&quot;../kotlin/-char-sequence/index#kotlin.CharSequence&quot;&gt;CharSequence&lt;/a&gt; in a synchronized block.</target>
        </trans-unit>
        <trans-unit id="418fd8181d764c26cb6aebed80be5ec76fed83e8" translate="yes" xml:space="preserve">
          <source>Unsafe mode is intended for most performance critical operations, where object graph ownership is expected to be correct (such as application debugged earlier in &lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt; mode), just transfers ownership without further checks.</source>
          <target state="translated">안전하지 않은 모드는 객체 그래프 소유권이 정확할 것으로 예상되는 (예 : &lt;a href=&quot;-s-a-f-e&quot;&gt;SAFE&lt;/a&gt; 모드 에서 이전에 디버깅 된 응용 프로그램) 대부분의 성능이 중요한 작업을 위해 고안되었으며 추가 검사없이 소유권을 이전합니다.</target>
        </trans-unit>
        <trans-unit id="eb25c274c554703f1d6ac7eff8cabedc73b12953" translate="yes" xml:space="preserve">
          <source>UnsafeVariance</source>
          <target state="translated">UnsafeVariance</target>
        </trans-unit>
        <trans-unit id="cfba46d6859cfbbcea2df0d333b94927ce585d13" translate="yes" xml:space="preserve">
          <source>Unsigned arithmetics</source>
          <target state="translated">부호없는 산술</target>
        </trans-unit>
        <trans-unit id="5c5289ec1ae0731b7a3321d477acd024a60473b2" translate="yes" xml:space="preserve">
          <source>Unsigned integers</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="5b676d18e8ccf61f5e227df4adab6b4ac25f32fd" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details in the &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">부호없는 정수는 Kotlin 1.3부터 ​​사용 가능하며 현재 &lt;em&gt;실험 중&lt;/em&gt; 입니다. 에서 자세한 내용을 참조하십시오 &lt;a href=&quot;basic-types#experimental-status-of-unsigned-integers&quot;&gt;참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f300d5a964ee1dfe6f01eeb8815de2c1adedd0" translate="yes" xml:space="preserve">
          <source>Unsigned integers are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details in the &lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</source>
          <target state="translated">Unsigned integers are available only since Kotlin 1.3 and currently are in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details in the &lt;a href=&quot;basic-types#beta-status-of-unsigned-integers&quot;&gt;reference&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b747e738f03e7ea5b53d3e97fc3d06bb2fdd5460" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently are &lt;em&gt;experimental&lt;/em&gt;. See details &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">부호없는 유형은 Kotlin 1.3 이후에만 사용할 수 있으며 현재 &lt;em&gt;실험적&lt;/em&gt; 입니다. 세부 사항을 참조하십시오 &lt;a href=&quot;#experimental-status-of-unsigned-integers&quot;&gt;아래를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d65bd8aeb4b2e88a04a2f25ed0b812fa94ab0cb" translate="yes" xml:space="preserve">
          <source>Unsigned types are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details &lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">Unsigned types are available only since Kotlin 1.3 and currently in &lt;a href=&quot;evolution/components-stability&quot;&gt;Beta&lt;/a&gt;. See details &lt;a href=&quot;#beta-status-of-unsigned-integers&quot;&gt;below&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c69f19b70030748472412cf013c7f8262fa5cc73" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another experimental feature, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">부호없는 유형은 다른 실험 기능, 즉 &lt;a href=&quot;inline-classes&quot;&gt;인라인 클래스를&lt;/a&gt; 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="963c1b3d4bd7cb3c897cb1ca5167eb9af57242de" translate="yes" xml:space="preserve">
          <source>Unsigned types are implemented using another feature that's not yet stable, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</source>
          <target state="translated">Unsigned types are implemented using another feature that's not yet stable, namely &lt;a href=&quot;inline-classes&quot;&gt;inline classes&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="22647f2117d5ec2026da9b7edc1161d8603f0593" translate="yes" xml:space="preserve">
          <source>Unsigned types support most of the operations of their signed counterparts.</source>
          <target state="translated">서명되지 않은 유형은 서명 된 상대방의 대부분의 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a84f8397c523a0f7323640840daf25c5d28f242d" translate="yes" xml:space="preserve">
          <source>Unsound smartcasts on enum members</source>
          <target state="translated">열거 형 멤버의 들리지 않는 스마트 캐스트</target>
        </trans-unit>
        <trans-unit id="fb52c13a5d3c511932c9721a05a0f30bebc8f773" translate="yes" xml:space="preserve">
          <source>Unsupported</source>
          <target state="translated">Unsupported</target>
        </trans-unit>
        <trans-unit id="d6b9cc70af4626956ac004db8653f110603b7231" translate="yes" xml:space="preserve">
          <source>UnsupportedOperationException</source>
          <target state="translated">UnsupportedOperationException</target>
        </trans-unit>
        <trans-unit id="2ce01f081a0318f94ee11d34764838aaa22a8009" translate="yes" xml:space="preserve">
          <source>Unused declarations can appear in cases like:</source>
          <target state="translated">Unused declarations can appear in cases like:</target>
        </trans-unit>
        <trans-unit id="7d866719de20162a43b046be2b1dd937f0e0c8b0" translate="yes" xml:space="preserve">
          <source>Unzip the standalone compiler into a directory and optionally add the &lt;code&gt;bin&lt;/code&gt; directory to the system path. The &lt;code&gt;bin&lt;/code&gt; directory contains the scripts needed to compile and run Kotlin on Windows, OS X and Linux.</source>
          <target state="translated">독립형 컴파일러를 디렉토리에 압축 해제하고 선택적으로 &lt;code&gt;bin&lt;/code&gt; 디렉토리를 시스템 경로에 추가하십시오 . &lt;code&gt;bin&lt;/code&gt; 디렉토리는 컴파일 및 Windows, OS X 및 Linux에서 코 틀린를 실행하는 데 필요한 스크립트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="756c6de970516b187b891362c635541de1071978" translate="yes" xml:space="preserve">
          <source>Update to version A (where the change is announced)</source>
          <target state="translated">버전 A로 업데이트 (변경 사항이 발표 된 곳)</target>
        </trans-unit>
        <trans-unit id="a8909313fb96928caf2b3605836e51265cd9382c" translate="yes" xml:space="preserve">
          <source>Update to version B (where the change happens)</source>
          <target state="translated">버전 B로 업데이트 (변경이 발생한 위치)</target>
        </trans-unit>
        <trans-unit id="bc69b0f01bd4bf2a5762f9802698425322ca8ecc" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">의 지정된지도 &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;에서&lt;/a&gt; 키 / 값 쌍으로이지도를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="bb9919809e0edbf2ce222896374072b2a1f62288" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">Updates this map with key/value pairs from the specified map &lt;a href=&quot;../-mutable-map/put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9592e59ae4a1ea78ffeef819217ff2d297efc8bf" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">의 지정된지도 &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll%28kotlin.collections.Map%28%28kotlin.collections.MutableMap.K%2C+kotlin.collections.MutableMap.V%29%29%29%2Ffrom&quot;&gt;에서&lt;/a&gt; 키 / 값 쌍으로이지도를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="2ea39222df240b93c342df8ff54a9cb5e6582800" translate="yes" xml:space="preserve">
          <source>Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</source>
          <target state="translated">Updates this map with key/value pairs from the specified map &lt;a href=&quot;put-all#kotlin.collections.MutableMap%24putAll(kotlin.collections.Map((kotlin.collections.MutableMap.K,%20kotlin.collections.MutableMap.V)))/from&quot;&gt;from&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ec6952e09b9cc6aee90f3110c55ff105e4facbf9" translate="yes" xml:space="preserve">
          <source>Updating</source>
          <target state="translated">Updating</target>
        </trans-unit>
        <trans-unit id="d63c48198d515b24d1b1b235598c3c48c2a4be5a" translate="yes" xml:space="preserve">
          <source>Updating Gradle Scripts</source>
          <target state="translated">Gradle 스크립트 업데이트</target>
        </trans-unit>
        <trans-unit id="408c0db23a4308cddf6a6e9ce2a0a6679db93544" translate="yes" xml:space="preserve">
          <source>Updating elements</source>
          <target state="translated">요소 업데이트</target>
        </trans-unit>
        <trans-unit id="5db2b695ba29ebd7f0ca8dec803b6b54c73ec2a6" translate="yes" xml:space="preserve">
          <source>Upper bounds</source>
          <target state="translated">상한</target>
        </trans-unit>
        <trans-unit id="6fe7e1ccf58a63e3bc126e60c26bcc1a9fac8e17" translate="yes" xml:space="preserve">
          <source>Upper bounds, or generic constraints imposed on this type parameter. See the &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin language documentation&lt;/a&gt; for more information.</source>
          <target state="translated">이 유형 매개 변수에 부과 된 상한 또는 일반 제한 조건. 자세한 내용은 &lt;a href=&quot;../../../../../../docs/reference/generics#upper-bounds&quot;&gt;Kotlin 언어 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="034e0e826c171bc69a42734bf5f512ba3665a32d" translate="yes" xml:space="preserve">
          <source>Usage of the &lt;code&gt;!!&lt;/code&gt; operator that is described below;</source>
          <target state="translated">의 사용법 &lt;code&gt;!!&lt;/code&gt; 아래에 설명 된 연산자;</target>
        </trans-unit>
        <trans-unit id="e1820bd9f032e11eff310c40682c9835a9eb3203" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as a warning.</source>
          <target state="translated">더 이상 사용되지 않는 요소의 사용은 경고로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6da2a0224bff4d0cdbf931eb3f79ea3c663d17" translate="yes" xml:space="preserve">
          <source>Usage of the deprecated element will be reported as an error.</source>
          <target state="translated">더 이상 사용되지 않는 요소의 사용은 오류로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2278b9118c021e0836f33b45c4b344bc07faf3" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt; annotation, e.g. &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; , or with the &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</target>
        </trans-unit>
        <trans-unit id="5b2bd12dd174680813870a73e531a53b2704ad9f" translate="yes" xml:space="preserve">
          <source>Usages of such API will be reported as warnings unless an explicit opt-in with the &lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; annotation, e.g. &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt;, or with the &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; compiler option is given.</source>
          <target state="translated">&lt;a href=&quot;../-use-experimental/index&quot;&gt;UseExperimental&lt;/a&gt; 어노테이션 (예 : &lt;code&gt;@UseExperimental(ExperimentalUnsignedTypes::class)&lt;/code&gt; ) 또는 &lt;code&gt;-Xuse-experimental=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; 컴파일러 옵션이 명시 적으로 옵트 인되지 않는 한 이러한 API의 사용법은 경고로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="5461bf95a53302a7c5df48274f6a4f3517903597" translate="yes" xml:space="preserve">
          <source>Usages of this annotation require an explicit compilation argument to be specified: either &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; or &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt;.</source>
          <target state="translated">이 어노테이션을 사용하려면 명시적인 컴파일 인수를 지정해야합니다 ( &lt;code&gt;-Xjvm-default=enable&lt;/code&gt; 또는 &lt;code&gt;-Xjvm-default=compatibility&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="070afea0c959ac4ab2122b78be879a1236b7d5f2" translate="yes" xml:space="preserve">
          <source>Use 4 spaces for indentation. Do not use tabs.</source>
          <target state="translated">들여 쓰기를 위해 4 개의 공백을 사용하십시오. 탭을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="505b02e2c68810a100167ed2394b7b09d07536b9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Kotlin from Swift&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#calling-kotlin-code-from-swift&quot;&gt;Swift에서 Kotlin&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="259f61d0fe4d9980f69dcb9a143f67a783be3566" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; function to describe a conditional effect that happens in such case.</source>
          <target state="translated">이러한 경우에 발생하는 조건부 효과를 설명 하려면 &lt;a href=&quot;../-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b3d7f2e06019f3ce17f9b7609b4e12a0a852225" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt;, &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; or &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp&lt;/a&gt; extension functions to instantiate a &lt;code&gt;FileTreeWalk&lt;/code&gt; instance.</source>
          <target state="translated">사용 &lt;a href=&quot;../java.io.-file/walk&quot;&gt;File.walk&lt;/a&gt; , &lt;a href=&quot;../java.io.-file/walk-top-down&quot;&gt;File.walkTopDown&lt;/a&gt; 또는 &lt;a href=&quot;../java.io.-file/walk-bottom-up&quot;&gt;File.walkBottomUp의&lt;/a&gt; 확장 기능은 인스턴스화하는 &lt;code&gt;FileTreeWalk&lt;/code&gt; 의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="855c22b8caa56aad8a88d87618784ee61265712d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;apply&lt;/code&gt; for code blocks that don't return a value and mainly operate on the members of the receiver object. The common case for &lt;code&gt;apply&lt;/code&gt; is the object configuration. Such calls can be read as &amp;ldquo;&lt;em&gt;apply the following assignments to the object.&lt;/em&gt;&amp;rdquo;</source>
          <target state="translated">값을 반환하지 않고 주로 수신자 객체의 멤버에서 작동하는 코드 블록에 &lt;code&gt;apply&lt;/code&gt; 을 사용하십시오 . 일반적인 &lt;code&gt;apply&lt;/code&gt; 사례 는 객체 구성입니다. 이러한 호출은 &quot; &lt;em&gt;다음 과제를 객체에 적용&lt;/em&gt; &quot;으로 읽을 수 있습니다 &lt;em&gt;. &lt;/em&gt;&quot;</target>
        </trans-unit>
        <trans-unit id="6ba975b0b8793e55988fa1e5cd1c3f8baae89326" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;arguments {}&lt;/code&gt; block to pass arguments to annotation processors:</source>
          <target state="translated">&lt;code&gt;arguments {}&lt;/code&gt; 블록을 사용 하여 인수를 주석 프로세서에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="9068946a50ad967859350bf76f77d127a3ad6ba3" translate="yes" xml:space="preserve">
          <source>Use C function pointer from Kotlin</source>
          <target state="translated">Kotlin의 C 함수 포인터 사용</target>
        </trans-unit>
        <trans-unit id="7f14c4d527695edd872c7fe2172a6db2f31e9728" translate="yes" xml:space="preserve">
          <source>Use Kotlin from node.js with CommonJS</source>
          <target state="translated">CommonJS와 함께 node.js의 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="7955d34ca487ac99a425deedc1ddb62d16416242" translate="yes" xml:space="preserve">
          <source>Use Kotlin in the browser with AMD</source>
          <target state="translated">AMD 브라우저에서 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="567ed77b3fedba236234b46ed9dd13b2639d5a1d" translate="yes" xml:space="preserve">
          <source>Use a Kotlin Gradle project as a CocoaPods dependency</source>
          <target state="translated">Use a Kotlin Gradle project as a CocoaPods dependency</target>
        </trans-unit>
        <trans-unit id="5dafba398135044480a3e13e8cf827e6d5239bcb" translate="yes" xml:space="preserve">
          <source>Use a function returning nullable value:</source>
          <target state="translated">널 입력 가능 값을 리턴하는 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6761a777f295b6258dc7a19c0a25a2a4cc06a051" translate="yes" xml:space="preserve">
          <source>Use any members that don't mention the star-projected type parameter(s) at all</source>
          <target state="translated">별 투영 된 유형 매개 변수를 전혀 언급하지 않은 멤버를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="02c711d6a5cfe540ce71589b8b208d49d3883457" translate="yes" xml:space="preserve">
          <source>Use any members that return the star-projected type parameter(s), but the return type will appear to be &lt;code&gt;Any?&lt;/code&gt; (unless the type parameter is constrained, in which case you'll get the type mentioned in the constraint)</source>
          <target state="translated">별 투영 된 유형 매개 변수를 리턴하는 멤버를 사용하지만 리턴 유형은 &lt;code&gt;Any?&lt;/code&gt; (type 매개 변수가 제한되어 있지 않으면 제약 조건에 언급 된 유형이 표시됩니다)</target>
        </trans-unit>
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">사용 사례</target>
        </trans-unit>
        <trans-unit id="6914afc57d4eceefab3ce74c4e34c13830de00b1" translate="yes" xml:space="preserve">
          <source>Use dynamic to interact with libraries</source>
          <target state="translated">동적을 사용하여 라이브러리와 상호 작용</target>
        </trans-unit>
        <trans-unit id="a696c211088879b039bc564a3a89ee0e5d5cf819" translate="yes" xml:space="preserve">
          <source>Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.</source>
          <target state="translated">확장 기능을 자유롭게 사용하십시오. 객체에서 주로 작동하는 함수가있을 때마다 해당 객체를 수신자로 받아들이는 확장 함수로 만드는 것이 좋습니다. API 오염을 최소화하려면 확장 기능의 가시성을 적절하게 제한하십시오. 필요에 따라 로컬 확장 기능, 멤버 확장 기능 또는 개인용 가시성이있는 최상위 확장 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d507109a798498dbaa1e633727d124b6d6bc26b0" translate="yes" xml:space="preserve">
          <source>Use for APIs which have a third-party implementation available at runtime.</source>
          <target state="translated">Use for APIs which have a third-party implementation available at runtime.</target>
        </trans-unit>
        <trans-unit id="3f1d8d5003fdff477f08dfe445e9b40450048a1d" translate="yes" xml:space="preserve">
          <source>Use for dependencies needed for the internal logic of a module.</source>
          <target state="translated">Use for dependencies needed for the internal logic of a module.</target>
        </trans-unit>
        <trans-unit id="f46a150eeba438f84a49eada07a259f489c6609a" translate="yes" xml:space="preserve">
          <source>Use four spaces for indentation. Do not use tabs.</source>
          <target state="translated">Use four spaces for indentation. Do not use tabs.</target>
        </trans-unit>
        <trans-unit id="ce69d8e8477848e488f670533689cb83c9f8c099" translate="yes" xml:space="preserve">
          <source>Use it &lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;from Android app&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#using-sharedcode-from-android&quot;&gt;안드로이드 앱에서&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="62f9973d0d21db3635e8a7ac730a624b82c527d3" translate="yes" xml:space="preserve">
          <source>Use kotlinx.html to generate HTML</source>
          <target state="translated">kotlinx.html을 사용하여 HTML 생성</target>
        </trans-unit>
        <trans-unit id="7f896877d7535f3235fee51d8eb8bb2fc4692498" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for constructor parameters.</source>
          <target state="translated">생성자 매개 변수에는 일반 들여 쓰기 (4 칸)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8e22c1db7346b432b927919ebe9e716628c63ef8" translate="yes" xml:space="preserve">
          <source>Use regular indent (4 spaces) for function parameters.</source>
          <target state="translated">함수 매개 변수에는 규칙적인 들여 쓰기 (4 칸)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b28f6c3f00f4a4b985821c624ebe6f5d2ab53f74" translate="yes" xml:space="preserve">
          <source>Use regular indent (four spaces) for constructor parameters.</source>
          <target state="translated">Use regular indent (four spaces) for constructor parameters.</target>
        </trans-unit>
        <trans-unit id="2153a3c57b5ac237e2457368e65faee188870aa7" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;until&lt;/code&gt; function to loop over an open range:</source>
          <target state="translated">개방 범위를 반복 하려면 &lt;code&gt;until&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bd4c99e44de0d3ffdb3c45eb15b74d7b4c2b386" translate="yes" xml:space="preserve">
          <source>Use the IR backend</source>
          <target state="translated">Use the IR backend</target>
        </trans-unit>
        <trans-unit id="9e774b3c689a7ceab89fb14ac0440aed57436890" translate="yes" xml:space="preserve">
          <source>Use the Kotlin dynamic library from C</source>
          <target state="translated">C의 Kotlin 동적 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="fca17390ef51588303bcc0395c954faa0b511dcd" translate="yes" xml:space="preserve">
          <source>Use the intention from the IDE to include the missing import line:</source>
          <target state="translated">누락 된 가져 오기 행을 포함 시키려면 IDE의 의도를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c9fe0e8ecff640eabedf59913fdfab4613b76bf4" translate="yes" xml:space="preserve">
          <source>Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of &lt;code&gt;Boolean&lt;/code&gt; type, unless the meaning of all parameters is absolutely clear from context.</source>
          <target state="translated">메소드가 동일한 기본 유형의 여러 매개 변수를 가져 오거나 &lt;code&gt;Boolean&lt;/code&gt; 유형의 매개 변수에 대해 컨텍스트에서 모든 매개 변수의 의미가 완전히 명확하지 않은 한 명명 된 인수 구문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="09617aa736694d6bc881574c01e808ebeb4fb7c7" translate="yes" xml:space="preserve">
          <source>Use the path to the Java runtime version 1.8 or 11 for the &lt;em&gt;Gradle JVM&lt;/em&gt; field. Check out the &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; or &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt; for the best JRE, OpenJDK, or JDK distribution.</source>
          <target state="translated">&lt;em&gt;Gradle JVM&lt;/em&gt; 필드에 Java 런타임 버전 1.8 또는 11의 경로를 사용하십시오 . 최상의 JRE, OpenJDK 또는 JDK 배포에 대해서는 &lt;a href=&quot;https://jdk.java.net/11/&quot;&gt;https://jdk.java.net/11&lt;/a&gt; 또는 &lt;a href=&quot;https://adoptopenjdk.net/&quot;&gt;https://adoptopenjdk.net/&lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="efe23756e108375f4f234fa62c62b1a3192f2334" translate="yes" xml:space="preserve">
          <source>Use the shared Kotlin library &lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;from iOS app&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#setting-up-framework-dependency-in-xcode&quot;&gt;iOS 앱에서&lt;/a&gt; 공유 Kotlin 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="f9852a84398c6954bfc8ee0f3c95a700b78ffafb" translate="yes" xml:space="preserve">
          <source>Use the types &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; and &lt;code&gt;KotlinCompileCommon&lt;/code&gt; for the JS and Common targets, accordingly.</source>
          <target state="translated">JS 및 공통 대상에 &lt;code&gt;Kotlin2JsCompile&lt;/code&gt; 및 &lt;code&gt;KotlinCompileCommon&lt;/code&gt; 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e03be997274e2b63af86d76fc7bf98a2088dbc4" translate="yes" xml:space="preserve">
          <source>Use ts2kt to interact with libraries</source>
          <target state="translated">ts2kt를 사용하여 라이브러리와 상호 작용</target>
        </trans-unit>
        <trans-unit id="106c8f3de5148d18865fbc697fa5d5cdeecc28c4" translate="yes" xml:space="preserve">
          <source>Use-site variance: Type projections</source>
          <target state="translated">사용 사이트 차이 : 유형 투영</target>
        </trans-unit>
        <trans-unit id="e2476b5675d923b0014d65b682cc8d7c7848dd3a" translate="yes" xml:space="preserve">
          <source>UseExperimental</source>
          <target state="translated">UseExperimental</target>
        </trans-unit>
        <trans-unit id="5948d8b97ec29bff3672a84e9d432b919624dc55" translate="yes" xml:space="preserve">
          <source>Used both during compilation and at runtime and is exported to library consumers.</source>
          <target state="translated">Used both during compilation and at runtime and is exported to library consumers.</target>
        </trans-unit>
        <trans-unit id="8ac3c810c772a41c5e178656755fecd6523a14fa" translate="yes" xml:space="preserve">
          <source>Used during compilation and at runtime for the current module, but is not exposed for compilation of other modules depending on the one with the `implementation` dependency.</source>
          <target state="translated">Used during compilation and at runtime for the current module, but is not exposed for compilation of other modules depending on the one with the `implementation` dependency.</target>
        </trans-unit>
        <trans-unit id="73310b7839f171659371cc3680a3ce118bf8dc6d" translate="yes" xml:space="preserve">
          <source>Used for compilation of the current module and is not available at runtime nor during compilation of other modules.</source>
          <target state="translated">Used for compilation of the current module and is not available at runtime nor during compilation of other modules.</target>
        </trans-unit>
        <trans-unit id="f27716b3301b8979f846685e09578fc4d968ef31" translate="yes" xml:space="preserve">
          <source>User-defined contracts</source>
          <target state="translated">User-defined contracts</target>
        </trans-unit>
        <trans-unit id="2546ff21c7035e67f381dd0185abecc195a459e2" translate="yes" xml:space="preserve">
          <source>Users of Kotlin on the Server Side</source>
          <target state="translated">서버 측 Kotlin 사용자</target>
        </trans-unit>
        <trans-unit id="47181373df2bd78be6294c0add1dbe6339b4681b" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 지정된 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3391e8d9489d92fff425335dfe200993b486d0ea" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 기본 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="704ebbde6e2b32eeb1c2f67d4e693a35f67af0fd" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</target>
        </trans-unit>
        <trans-unit id="aac052dc5a6c0e7fbd28f5bc3a043e4ecb32e5f5" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="0dd3b1deb8f1d7bfb8c12c5a14f2ab32a21d65af" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</target>
        </trans-unit>
        <trans-unit id="7a75a8ac839c741b8d08dc9c1deee0d88e4f979c" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+java.util.Locale%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 지정된 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9d3ac3ea11a7f22b1d758a682e71f98cc029fa36" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">제공된 &lt;a href=&quot;format#kotlin.text%24format%28kotlin.String.Companion%2C+kotlin.String%2C+kotlin.Array%28%28kotlin.Any%29%29%29%2Fformat&quot;&gt;형식&lt;/a&gt; 을 형식 문자열로 사용하고 기본 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="10dc34a2059cb8159f0a883b5dd86e0bc6137e07" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</target>
        </trans-unit>
        <trans-unit id="f82d324c322c9f91adb6f0983572279a3329ac89" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20java.util.Locale?,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="65bfa57761f82862cfd81ebd5b8013f5e01aaad7" translate="yes" xml:space="preserve">
          <source>Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">Uses the provided &lt;a href=&quot;format#kotlin.text%24format(kotlin.String.Companion,%20kotlin.String,%20kotlin.Array((kotlin.Any?)))/format&quot;&gt;format&lt;/a&gt; as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</target>
        </trans-unit>
        <trans-unit id="42fcdb82df9fab88befa785457e65d1af96aa239" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the default locale.</source>
          <target state="translated">이 문자열을 형식 문자열로 사용하고 기본 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3f6866db3da817af6ed67e3dae70c3ec02de81e2" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale.</source>
          <target state="translated">이 문자열을 형식 문자열로 사용하고 지정된 로케일을 사용하여 지정된 인수를 대체하여 얻은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6484cdf608c52e6f223f86ea931137798547136f" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;../../kotlin.text/format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="a6a6e896b98588b46d5642885789c195ba9adc2a" translate="yes" xml:space="preserve">
          <source>Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</source>
          <target state="translated">Uses this string as a format string and returns a string obtained by substituting the specified arguments, using the specified locale. If &lt;a href=&quot;format#kotlin.text%24format(kotlin.String,%20java.util.Locale?,%20kotlin.Array((kotlin.Any?)))/locale&quot;&gt;locale&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt; then no localization is applied.</target>
        </trans-unit>
        <trans-unit id="4e62e86755452347944ce24bc99c8763bab8c2b5" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;receive&lt;/a&gt; suspending function we can receive &lt;em&gt;either&lt;/em&gt; from one channel or the other. But &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; expression allows us to receive from &lt;em&gt;both&lt;/em&gt; simultaneously using its &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; clauses:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/receive.html&quot;&gt;수신&lt;/a&gt; 일시 중단 기능을 사용하면 한 채널에서 수신 &lt;em&gt;하거나&lt;/em&gt; 다른 채널에서 수신 할 수 &lt;em&gt;있습니다&lt;/em&gt; . 그러나 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; 표현식을 사용하면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/on-receive.html&quot;&gt;onReceive&lt;/a&gt; 절을 사용하여 &lt;em&gt;두 가지를&lt;/em&gt; 동시에 받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08f3f41e2b1efe6c5dce0e5fec64099ed03bdf2b" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;lambdas&quot;&gt;higher-order functions&lt;/a&gt; imposes certain runtime penalties: each function is an object, and it captures a closure, i.e. those variables that are accessed in the body of the function. Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.</source>
          <target state="translated">&lt;a href=&quot;lambdas&quot;&gt;고차 함수를&lt;/a&gt; 사용하면 특정 런타임 처벌이 적용됩니다. 각 함수는 객체이며 클로저, 즉 함수 본문에서 액세스되는 변수를 캡처합니다. 메모리 할당 (함수 객체 및 클래스 모두) 및 가상 호출은 런타임 오버 헤드를 유발합니다.</target>
        </trans-unit>
        <trans-unit id="491e6c994c3baf4cc8af39219068162e74e38931" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;::Foo&lt;/code&gt;, the zero-argument constructor of the class Foo, we can simply call it like this:</source>
          <target state="translated">&lt;code&gt;::Foo&lt;/code&gt; 클래스의 제로 인수 생성자 :: Foo를 사용하면 다음과 같이 간단히 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1288042cdb0bedb4cedef04fffbbc6421151560c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;when&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; expression 사용</target>
        </trans-unit>
        <trans-unit id="b4d45feb4cce668fd7098830e83bf2557a415c16" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;if&lt;/em&gt; as an expression:</source>
          <target state="translated">사용 &lt;em&gt;하는 경우&lt;/em&gt; 표현으로 :</target>
        </trans-unit>
        <trans-unit id="7956ce97b97e87d0f55a6ea0cc6e4e05373fcf15" translate="yes" xml:space="preserve">
          <source>Using AMD</source>
          <target state="translated">AMD 사용</target>
        </trans-unit>
        <trans-unit id="aae897c446cafc25370dcce91792d5e6dfa9a087" translate="yes" xml:space="preserve">
          <source>Using Ant</source>
          <target state="translated">개미 사용하기</target>
        </trans-unit>
        <trans-unit id="44ab2ab05f55d2266ffc569dcf7fc124a65679b4" translate="yes" xml:space="preserve">
          <source>Using C Interop and libcurl for an App</source>
          <target state="translated">앱에 C Interop 및 libcurl 사용</target>
        </trans-unit>
        <trans-unit id="a59cc5aadf82954e8f0283bd3dfcaae639efbadd" translate="yes" xml:space="preserve">
          <source>Using C library from Kotlin/Native</source>
          <target state="translated">Kotlin / Native의 C 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="d678710e9135632a43d33f3d5da6bf72dddacbe5" translate="yes" xml:space="preserve">
          <source>Using CommonJS</source>
          <target state="translated">CommonJS 사용</target>
        </trans-unit>
        <trans-unit id="e42f7c8cd0e8730768cbb184338fabc772fadfd5" translate="yes" xml:space="preserve">
          <source>Using Dynamic</source>
          <target state="translated">동적 사용</target>
        </trans-unit>
        <trans-unit id="cbe69bb9e7692bc07945db15e10c51c3ee312db2" translate="yes" xml:space="preserve">
          <source>Using Generated Headers from C</source>
          <target state="translated">C에서 생성 된 헤더 사용</target>
        </trans-unit>
        <trans-unit id="27c679a18ee1d9ed93d7a66b728665e446e0b013" translate="yes" xml:space="preserve">
          <source>Using Gradle</source>
          <target state="translated">Gradle 사용</target>
        </trans-unit>
        <trans-unit id="17fbd0b7659b724c4b82377e5e5b6176a4a4d7c0" translate="yes" xml:space="preserve">
          <source>Using Gradle Kotlin DSL</source>
          <target state="translated">Gradle Kotlin DSL 사용</target>
        </trans-unit>
        <trans-unit id="71d5b086b763a415271837d49bf05b383ed34176" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA Build System</source>
          <target state="translated">IntelliJ IDEA 빌드 시스템 사용</target>
        </trans-unit>
        <trans-unit id="81cb9f3916c8314e916dfe4f86e42b9f41066648" translate="yes" xml:space="preserve">
          <source>Using IntelliJ IDEA we can easily run and debug the application in any of the possible application servers defined such as Tomcat, Glassfish or WildFly. In this case we're going to use Tomcat which has previously &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;been defined as an application server in IntelliJ IDEA&lt;/a&gt;. Note that application server support is only available in IntelliJ IDEA Ultimate.</source>
          <target state="translated">IntelliJ IDEA를 사용하면 Tomcat, Glassfish 또는 WildFly와 같이 정의 된 가능한 모든 응용 프로그램 서버에서 응용 프로그램을 쉽게 실행하고 디버깅 할 수 있습니다. 이 경우 이전 &lt;a href=&quot;http://www.jetbrains.com/idea/webhelp/defining-application-servers-in-intellij-idea.html&quot;&gt;에 IntelliJ IDEA에서 애플리케이션 서버로 정의 된&lt;/a&gt; Tomcat을 사용 합니다 . 응용 프로그램 서버 지원은 IntelliJ IDEA Ultimate에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4709ae28ff320dfabd65f0869103704aedfcf674" translate="yes" xml:space="preserve">
          <source>Using JNI with Kotlin</source>
          <target state="translated">Kotlin과 함께 JNI 사용</target>
        </trans-unit>
        <trans-unit id="2bbc39d0664d569562a91137d4d90178cf23c617" translate="yes" xml:space="preserve">
          <source>Using Kotlin Android Extensions</source>
          <target state="translated">Kotlin Android 확장 사용</target>
        </trans-unit>
        <trans-unit id="b022874247f51c944909afa759f623b6478ca32e" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android Development</source>
          <target state="translated">안드로이드 개발에 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="60a1392d0c8d40966f3ba2738ae5f701e549f245" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Android development, you can benefit from:</source>
          <target state="translated">Using Kotlin for Android development, you can benefit from:</target>
        </trans-unit>
        <trans-unit id="aaf246aafd7124667a554d398075e5452aa83ed4" translate="yes" xml:space="preserve">
          <source>Using Kotlin for Server-side Development</source>
          <target state="translated">서버 측 개발에 Kotlin 사용</target>
        </trans-unit>
        <trans-unit id="2b0fb5591f02bcbebcc2bd375ac8a71d601338b0" translate="yes" xml:space="preserve">
          <source>Using Kotlin/Native Targets</source>
          <target state="translated">코 틀린 / 네이티브 대상 사용</target>
        </trans-unit>
        <trans-unit id="936b968752b32f197dc84832341b3f607b83a027" translate="yes" xml:space="preserve">
          <source>Using Maven</source>
          <target state="translated">메이븐 사용하기</target>
        </trans-unit>
        <trans-unit id="ef7af2346af2c37f7e6ee428aab1c98075a789a9" translate="yes" xml:space="preserve">
          <source>Using SharedCode from Android</source>
          <target state="translated">Android에서 SharedCode 사용</target>
        </trans-unit>
        <trans-unit id="603ab8042b5d1c17d5b50d529fa9db7d658d860a" translate="yes" xml:space="preserve">
          <source>Using Struct and Union Types from Kotlin</source>
          <target state="translated">Kotlin의 구조 및 공용체 유형 사용</target>
        </trans-unit>
        <trans-unit id="6e4c13998b5f91e0846d37840959ab407900c453" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프 사용하기</target>
        </trans-unit>
        <trans-unit id="4fe7e2f58454fbb71457b9ce1e7ce104ef338243" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">사용 &lt;code&gt;while&lt;/code&gt; 루프를</target>
        </trans-unit>
        <trans-unit id="29dae43467cc406389583f725ed8cb7bcc1c247d" translate="yes" xml:space="preserve">
          <source>Using a Kotlin/JavaScript library.</source>
          <target state="translated">Kotlin / JavaScript 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="d3383ee07c516c1fa1802c63fcedaaefadd8e48c" translate="yes" xml:space="preserve">
          <source>Using a callable reference to an existing declaration:</source>
          <target state="translated">기존 선언에 대한 호출 가능한 참조 사용</target>
        </trans-unit>
        <trans-unit id="197fb49229d662d3379f8cffecb5a8e470235340" translate="yes" xml:space="preserve">
          <source>Using a code block within a function literal, in one of the forms:</source>
          <target state="translated">함수 리터럴 내에서 다음 형식 중 하나로 코드 블록 사용</target>
        </trans-unit>
        <trans-unit id="a7c34a78b0f5530284b929714a111e0120a19cb8" translate="yes" xml:space="preserve">
          <source>Using a standard build tool</source>
          <target state="translated">표준 빌드 도구 사용</target>
        </trans-unit>
        <trans-unit id="5a3edbb4ebc2b355b2a8f195be33f5a03ead3d30" translate="yes" xml:space="preserve">
          <source>Using bindings</source>
          <target state="translated">바인딩 사용</target>
        </trans-unit>
        <trans-unit id="92c77c8ea60a2ffe09d3b8484f979577fe3fe402" translate="yes" xml:space="preserve">
          <source>Using cinterop</source>
          <target state="translated">cinterop 사용</target>
        </trans-unit>
        <trans-unit id="6f335b7fd336f32636cf82fea33e6e5a118b4de7" translate="yes" xml:space="preserve">
          <source>Using collections</source>
          <target state="translated">컬렉션 사용</target>
        </trans-unit>
        <trans-unit id="ce4da38f792e511ab4d77c2e6a228d9a0f717f17" translate="yes" xml:space="preserve">
          <source>Using conditional expressions</source>
          <target state="translated">조건식 사용</target>
        </trans-unit>
        <trans-unit id="918641690842037efdc3f921e9d2a03a1b94d884" translate="yes" xml:space="preserve">
          <source>Using conditional statements</source>
          <target state="translated">조건문 사용</target>
        </trans-unit>
        <trans-unit id="3fc2b300fe4dab146a33f883986c605263212bcf" translate="yes" xml:space="preserve">
          <source>Using experimental APIs</source>
          <target state="translated">실험용 API 사용</target>
        </trans-unit>
        <trans-unit id="ebd9b5845829e10c5bf4bfdb285f0143f1b0cc17" translate="yes" xml:space="preserve">
          <source>Using extension functions</source>
          <target state="translated">확장 기능 사용</target>
        </trans-unit>
        <trans-unit id="b252910d4e8badbe4bca9df0c30fd5478c5c630b" translate="yes" xml:space="preserve">
          <source>Using in CLI</source>
          <target state="translated">CLI에서 사용</target>
        </trans-unit>
        <trans-unit id="30f417bc0504e6fe1552d975f144e48529a622bd" translate="yes" xml:space="preserve">
          <source>Using in Gradle</source>
          <target state="translated">Gradle에서 사용</target>
        </trans-unit>
        <trans-unit id="987fbf118a45b1d5fc70735f1b4a9cb07d729a9e" translate="yes" xml:space="preserve">
          <source>Using in Maven</source>
          <target state="translated">Maven에서 사용</target>
        </trans-unit>
        <trans-unit id="b58b6328c1df079d0d8cccee5234ec40deb70287" translate="yes" xml:space="preserve">
          <source>Using infix functions</source>
          <target state="translated">삽입 기능 사용</target>
        </trans-unit>
        <trans-unit id="a915c033f5e92eb86f6eb764c7d3fbfec97399c7" translate="yes" xml:space="preserve">
          <source>Using instances of a custom class that implements a function type as an interface:</source>
          <target state="translated">함수 유형을 인터페이스로 구현하는 사용자 정의 클래스 인스턴스 사용 :</target>
        </trans-unit>
        <trans-unit id="b7d1f08b0755e4efecc6155b06410d6d8f47dd0c" translate="yes" xml:space="preserve">
          <source>Using kotlinx.html</source>
          <target state="translated">kotlinx.html 사용</target>
        </trans-unit>
        <trans-unit id="e33a647f9d820f02525a9e589cf38c7cb15aa9e1" translate="yes" xml:space="preserve">
          <source>Using lambda expressions to filter and map collections:</source>
          <target state="translated">람다 식을 사용하여 컬렉션 필터링 및 매핑 :</target>
        </trans-unit>
        <trans-unit id="85b9a9b134d068b76d1d9da5eba9082360a75376" translate="yes" xml:space="preserve">
          <source>Using loops</source>
          <target state="translated">루프 사용</target>
        </trans-unit>
        <trans-unit id="e702f70d153e5bb48504257ee3c4806c305f3fd0" translate="yes" xml:space="preserve">
          <source>Using modules</source>
          <target state="translated">모듈 사용</target>
        </trans-unit>
        <trans-unit id="9af9fabd79c052500b25a5c07039f994d4da9bd7" translate="yes" xml:space="preserve">
          <source>Using nullable &lt;code&gt;Boolean&lt;/code&gt; values in conditions</source>
          <target state="translated">조건에서 널 입력 가능 &lt;code&gt;Boolean&lt;/code&gt; 값 사용</target>
        </trans-unit>
        <trans-unit id="d6a1a404256e60f476abcfdb633a3c534e236959" translate="yes" xml:space="preserve">
          <source>Using nullable values and checking for &lt;em&gt;null&lt;/em&gt;</source>
          <target state="translated">널 (NULL) 값을 사용하고 확인 &lt;em&gt;널 (null)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="872ffc0740cd8cd114c0bd134533ae0bef8b975c" translate="yes" xml:space="preserve">
          <source>Using our favorite editor, we create a new file called &lt;em&gt;library.kt&lt;/em&gt;:</source>
          <target state="translated">자주 사용하는 편집기를 사용하여 &lt;em&gt;library.kt&lt;/em&gt; 라는 새 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="550a8f8d20b2e8584106d065339f4d4da1689dfc" translate="yes" xml:space="preserve">
          <source>Using ranges</source>
          <target state="translated">범위 사용</target>
        </trans-unit>
        <trans-unit id="51f179a48f07181aae2f460999afe3b38f8238e7" translate="yes" xml:space="preserve">
          <source>Using scope functions apply/with/run/also/let</source>
          <target state="translated">범위 기능 사용 적용 / 사용 / 실행 / 또한 / let</target>
        </trans-unit>
        <trans-unit id="3ec4dda09fda63d9abb963027b78f1d3b6ffe21e" translate="yes" xml:space="preserve">
          <source>Using string templates</source>
          <target state="translated">문자열 템플릿 사용</target>
        </trans-unit>
        <trans-unit id="4e76a46a35a0080ea05cb7befbedfc77e476e034" translate="yes" xml:space="preserve">
          <source>Using strings</source>
          <target state="translated">문자열 사용</target>
        </trans-unit>
        <trans-unit id="18148327a2ccfbb8e71316dac9304b16aaccd2b3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin for building &lt;a href=&quot;multiplatform&quot;&gt;multiplatform projects&lt;/a&gt; is described in &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;Building Multiplatform Projects with Gradle&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;multiplatform&quot;&gt;멀티 플랫폼 프로젝트&lt;/a&gt; 를 빌드하기 위해 &lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 사용은 Gradle을 사용하여 멀티 플랫폼 프로젝트 &lt;a href=&quot;building-mpp-with-gradle&quot;&gt;빌드에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="662526f9ec265672a8f5eadc1e458fce90d93089" translate="yes" xml:space="preserve">
          <source>Using the C Function Pointer from Kotlin</source>
          <target state="translated">Kotlin의 C 함수 포인터 사용</target>
        </trans-unit>
        <trans-unit id="3b3c88f2622b6c11af48eeafb534d5bf373c1268" translate="yes" xml:space="preserve">
          <source>Using the Code from Objective-C</source>
          <target state="translated">Objective-C의 코드 사용</target>
        </trans-unit>
        <trans-unit id="2751cf504326591f0615360e90b35bf6098ad931" translate="yes" xml:space="preserve">
          <source>Using the Code from Swift</source>
          <target state="translated">Swift에서 코드 사용하기</target>
        </trans-unit>
        <trans-unit id="51e131a08f907def09c45df11a971dfb390d42ac" translate="yes" xml:space="preserve">
          <source>Using the command line to run scripts</source>
          <target state="translated">명령 행을 사용하여 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="0dde1829bc0d42dfa9d3d99dc69c6583462ddf28" translate="yes" xml:space="preserve">
          <source>Using the tool &lt;code&gt;ts2kt&lt;/code&gt; (TypeScript to Kotlin) we can convert any &lt;code&gt;d.ts&lt;/code&gt; files to Kotlin. To install the tool we can use &lt;code&gt;npm&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ts2kt&lt;/code&gt; 도구 (TypeScript에서 Kotlin로)를 사용하여 &lt;code&gt;d.ts&lt;/code&gt; 파일을 Kotlin으로 변환 할 수 있습니다 . 도구를 설치하려면 &lt;code&gt;npm&lt;/code&gt; 을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a89a0f28e4e5bf44543e1c9581c55c0e6aecc40d" translate="yes" xml:space="preserve">
          <source>Using trailing commas has several benefits:</source>
          <target state="translated">Using trailing commas has several benefits:</target>
        </trans-unit>
        <trans-unit id="4ebccac5de220cac33103fa30ac3780779ac2fcd" translate="yes" xml:space="preserve">
          <source>Using ts2kt to generate header files for Kotlin</source>
          <target state="translated">ts2kt를 사용하여 Kotlin의 헤더 파일 생성</target>
        </trans-unit>
        <trans-unit id="e0fbba9738442b4c0647e5831e5969871c4f6a2a" translate="yes" xml:space="preserve">
          <source>Using type checks and automatic casts</source>
          <target state="translated">유형 검사 및 자동 캐스트 사용</target>
        </trans-unit>
        <trans-unit id="d8d81e999a726d52e9414f74a35f368a368d19de" translate="yes" xml:space="preserve">
          <source>Usually these fields are private but they can be exposed in one of the following ways:</source>
          <target state="translated">일반적으로 이러한 필드는 비공개이지만 다음 방법 중 하나로 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1278d398657af96687576590c71d68b9a3f58aa" translate="yes" xml:space="preserve">
          <source>Usually, a native binary can be compiled as &lt;em&gt;debug&lt;/em&gt; with more debug information and fewer optimizations, and &lt;em&gt;release&lt;/em&gt; where optimizations are enabled and there is no (or at least less) debug information available.</source>
          <target state="translated">일반적으로 기본 바이너리는 더 많은 디버그 정보와 더 적은 최적화 로 &lt;em&gt;디버그&lt;/em&gt; 로 컴파일 할 수 있으며 최적화가 활성화되고 사용 가능한 디버그 정보가없는 &lt;em&gt;릴리스를 릴리스&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="12caefb8a5010ce40aa23c1ea29352f8837f75ed" translate="yes" xml:space="preserve">
          <source>Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it &lt;em&gt;unsafe&lt;/em&gt;. The unsafe cast in Kotlin is done by the infix operator &lt;em&gt;as&lt;/em&gt; (see &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;operator precedence&lt;/a&gt;):</source>
          <target state="translated">일반적으로 캐스트가 불가능한 경우 캐스트 연산자는 예외를 발생시킵니다. 따라서 우리는 이것을 &lt;em&gt;안전하지 않은 것으로&lt;/em&gt; 부릅니다 . Kotlin의 안전하지 않은 캐스트는 다음 &lt;em&gt;과 같이&lt;/em&gt; 중위 연산자에 의해 수행됩니다 ( &lt;a href=&quot;https://kotlinlang.org/docs/reference/grammar.html#expressions&quot;&gt;연산자 우선 순위&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="078efedb0f7a9297e4a66c7bf48c73578606e64d" translate="yes" xml:space="preserve">
          <source>Utility functions for concurrent programming.</source>
          <target state="translated">동시 프로그래밍을위한 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="54a27f71a3926c933fffb4cc8fcd736d36aae00b" translate="yes" xml:space="preserve">
          <source>Utility functions for working with Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;streams&lt;/a&gt;.</source>
          <target state="translated">Java 8 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html&quot;&gt;스트림&lt;/a&gt; 작업을위한 유틸리티 기능 .</target>
        </trans-unit>
        <trans-unit id="70a0023fe530c9e1dc6b5efd1156df2342cee154" translate="yes" xml:space="preserve">
          <source>Utility functions for working with the browser DOM.</source>
          <target state="translated">브라우저 DOM 작업을위한 유틸리티 기능.</target>
        </trans-unit>
        <trans-unit id="7dc10180b878fd7bd185c2d6a23c0519a292a3a0" translate="yes" xml:space="preserve">
          <source>VALUE</source>
          <target state="translated">VALUE</target>
        </trans-unit>
        <trans-unit id="b48498a5cff3c4e7ce37b18fdd81413319dd4656" translate="yes" xml:space="preserve">
          <source>VALUE_PARAMETER</source>
          <target state="translated">VALUE_PARAMETER</target>
        </trans-unit>
        <trans-unit id="242cc9162b91c0b54499ac05fdd663dcea97e3ff" translate="yes" xml:space="preserve">
          <source>ValidityState</source>
          <target state="translated">ValidityState</target>
        </trans-unit>
        <trans-unit id="4ca51107e6a14998cd7631ba2234ead0b2f51037" translate="yes" xml:space="preserve">
          <source>Value arguments</source>
          <target state="translated">Value arguments</target>
        </trans-unit>
        <trans-unit id="bc813f9a338f88bada03e57203025b97e72de98e" translate="yes" xml:space="preserve">
          <source>Value parameter of a function or a constructor</source>
          <target state="translated">함수 또는 생성자의 값 매개 변수</target>
        </trans-unit>
        <trans-unit id="ae7d4e58b65d5a70d4dfae24ee97f38d7c1a9ff0" translate="yes" xml:space="preserve">
          <source>Values can be updated. In turn, keys never change: once you add an entry, its key is constant.</source>
          <target state="translated">값을 업데이트 할 수 있습니다. 차례로 키는 변경되지 않습니다. 항목을 추가하면 해당 키는 일정합니다.</target>
        </trans-unit>
        <trans-unit id="83ce8efcd219286f9e80c1c630307f7c0a05ac1f" translate="yes" xml:space="preserve">
          <source>Values of an annotation instance are exposed as properties to Kotlin code:</source>
          <target state="translated">주석 인스턴스의 값은 Kotlin 코드에 속성으로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="e2e1116424b8a24a96cede1b506dcc3d11485f0b" translate="yes" xml:space="preserve">
          <source>VarType</source>
          <target state="translated">VarType</target>
        </trans-unit>
        <trans-unit id="42ec9490f36e6cae9913c4374b09e32237c707ad" translate="yes" xml:space="preserve">
          <source>Varargs and optional/named parameters</source>
          <target state="translated">Varargs 및 선택적 / 명명 된 매개 변수</target>
        </trans-unit>
        <trans-unit id="10eea16b487acafb1da690a6fa932f924aadcf7a" translate="yes" xml:space="preserve">
          <source>Variable inspection</source>
          <target state="translated">변수 검사</target>
        </trans-unit>
        <trans-unit id="342ee951b83918c9c708f1243be034edc6ba7220" translate="yes" xml:space="preserve">
          <source>Variable inspections for var variables works out of the box for primitive types. For non-primitive types there are custom pretty printers for lldb in &lt;code&gt;konan_lldb.py&lt;/code&gt;:</source>
          <target state="translated">var 변수에 대한 변수 검사는 기본 유형에 대해 즉시 작동합니다. 기본이 아닌 유형의 경우 &lt;code&gt;konan_lldb.py&lt;/code&gt; 에 lldb 용 사용자 정의 프린터가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a018b33a39aac69fe200a8b99412d4c30ecc8054" translate="yes" xml:space="preserve">
          <source>Variable names should use &lt;code&gt;lowerCamelCase&lt;/code&gt; instead of &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">변수 이름은 &lt;code&gt;snake_case&lt;/code&gt; 대신 &lt;code&gt;lowerCamelCase&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="43edb35cae8befc5879d0b7aa2cd22c92255e5d7" translate="yes" xml:space="preserve">
          <source>Variable number of arguments (Varargs)</source>
          <target state="translated">가변 개수의 인수 (Varargs)</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="eaac90ed072370b9f57426b726154a33050c4fed" translate="yes" xml:space="preserve">
          <source>Variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; get the values returned by &lt;code&gt;component1()&lt;/code&gt; and &lt;code&gt;component2()&lt;/code&gt; called on elements of the collection.</source>
          <target state="translated">변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 컬렉션의 요소에서 호출 된 &lt;code&gt;component1()&lt;/code&gt; 및 &lt;code&gt;component2()&lt;/code&gt; 의해 반환 된 값을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="808412b58bbf8525d5dac7961edbdfc05c3db76a" translate="yes" xml:space="preserve">
          <source>Variables that can be reassigned use the &lt;code&gt;var&lt;/code&gt; keyword:</source>
          <target state="translated">재 할당 할 수있는 변수는 &lt;code&gt;var&lt;/code&gt; 키워드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="eb39bbf6ccbbc8fdb77438c3cd6155bb1b7ec6b8" translate="yes" xml:space="preserve">
          <source>Variance</source>
          <target state="translated">Variance</target>
        </trans-unit>
        <trans-unit id="1a91ea423a97d4a87943d588b081e7e38282531c" translate="yes" xml:space="preserve">
          <source>Variance directions</source>
          <target state="translated">차이 방향</target>
        </trans-unit>
        <trans-unit id="5c16bf6df0ccb8c8f8d9897278f38f99a8d180ae" translate="yes" xml:space="preserve">
          <source>Variant generics</source>
          <target state="translated">변형 제네릭</target>
        </trans-unit>
        <trans-unit id="7ed714f305f37a57ecb8473b7415dfab9db01f6a" translate="yes" xml:space="preserve">
          <source>Various utilities for working with strings and char sequences.</source>
          <target state="translated">문자열 및 문자 시퀀스 작업을위한 다양한 유틸리티.</target>
        </trans-unit>
        <trans-unit id="280853b24c26b2f29a476f73ab7f87fbd08c6186" translate="yes" xml:space="preserve">
          <source>Vector128</source>
          <target state="translated">Vector128</target>
        </trans-unit>
        <trans-unit id="6c08e229ae1df722641eb28302211d6c86591e45" translate="yes" xml:space="preserve">
          <source>Vector128Var</source>
          <target state="translated">Vector128Var</target>
        </trans-unit>
        <trans-unit id="9ffb8650f3fdd46d87c18838f3017eda5ad872f4" translate="yes" xml:space="preserve">
          <source>Vector128VarOf</source>
          <target state="translated">Vector128VarOf</target>
        </trans-unit>
        <trans-unit id="288ce52d20fd503b110a72d86e9675e1c95e19eb" translate="yes" xml:space="preserve">
          <source>Verify the emulator configuration and click &lt;strong&gt;Finish&lt;/strong&gt;.</source>
          <target state="translated">에뮬레이터 구성을 확인하고 &lt;strong&gt;완료를&lt;/strong&gt; 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="de621f8c2654b2397c981cb428da06adf04bb6fe" translate="yes" xml:space="preserve">
          <source>Versioned separately from the language</source>
          <target state="translated">Versioned separately from the language</target>
        </trans-unit>
        <trans-unit id="84bee7b1488f1e88fea6081e11b80da21edf9ec4" translate="yes" xml:space="preserve">
          <source>VideoFacingModeEnum</source>
          <target state="translated">VideoFacingModeEnum</target>
        </trans-unit>
        <trans-unit id="fa871b63d316a5ccaf06d516a54da0961996827d" translate="yes" xml:space="preserve">
          <source>VideoResizeModeEnum</source>
          <target state="translated">VideoResizeModeEnum</target>
        </trans-unit>
        <trans-unit id="64fea40a0473c85795b9336e14b2b716b018b418" translate="yes" xml:space="preserve">
          <source>VideoTrack</source>
          <target state="translated">VideoTrack</target>
        </trans-unit>
        <trans-unit id="c02eab00438fffc417a6ac0aa9bb22fc06605beb" translate="yes" xml:space="preserve">
          <source>View binding</source>
          <target state="translated">뷰 바인딩</target>
        </trans-unit>
        <trans-unit id="db9fea7c8a56a15e997acc428b673797be1af865" translate="yes" xml:space="preserve">
          <source>View caching</source>
          <target state="translated">캐싱보기</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="0d73e14a3fcddf8956a7da60bbcb1e077c95f7a0" translate="yes" xml:space="preserve">
          <source>Visibility Modifiers</source>
          <target state="translated">가시성 수정 자</target>
        </trans-unit>
        <trans-unit id="28ffb1b2d0c701707ce3c73f2c7cf4a513706777" translate="yes" xml:space="preserve">
          <source>Visibility is an aspect of a Kotlin declaration regulating where that declaration is accessible in the source code. Visibility can be changed with one of the following modifiers: &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, &lt;code&gt;internal&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt;.</source>
          <target state="translated">가시성은 소스 코드에서 해당 선언에 액세스 할 수있는 위치를 규제하는 Kotlin 선언의 한 측면입니다. &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; , &lt;code&gt;internal&lt;/code&gt; , &lt;code&gt;private&lt;/code&gt; 수정 자 중 하나를 사용하여 가시성을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="849b37d75d9e78cb34f760a7b86638406d0e4272" translate="yes" xml:space="preserve">
          <source>Visibility modifiers</source>
          <target state="translated">가시성 수정 자</target>
        </trans-unit>
        <trans-unit id="8ccb166e167967c0af7bc8270ccff3bc3f332444" translate="yes" xml:space="preserve">
          <source>Visibility modifiers can't be placed on local variables, since their visibility is always limited to the containing block.</source>
          <target state="translated">가시성은 항상 포함 블록으로 제한되므로 가시성 수정자는 로컬 변수에 배치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6cd8f7e2419769693129b0c2082de4e40a0da3a3" translate="yes" xml:space="preserve">
          <source>Visibility of Top-level Declarations</source>
          <target state="translated">최상위 선언의 가시성</target>
        </trans-unit>
        <trans-unit id="b794e604145c856d9c96b2bfb79a673421c9cf64" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;internal&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;internal&lt;/code&gt; 수정 자로 표시된 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="63bf3a48e0f5fd4c5b7c9576056b33b03784b05d" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;private&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 수정 자로 표시된 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="d02ce232d311d05d3099c6a996cbef8c4dd286f9" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;protected&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 수정 자로 표시된 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="dd1c739248ca96578cca7f9bfb547899b54a876f" translate="yes" xml:space="preserve">
          <source>Visibility of declarations marked with the &lt;code&gt;public&lt;/code&gt; modifier, or with no modifier at all.</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 수정 자로 표시 되거나 수정자가없는 선언의 가시성 .</target>
        </trans-unit>
        <trans-unit id="de706486df3bb39a3413cb5cbbb1d996126bda21" translate="yes" xml:space="preserve">
          <source>Visibility of this callable, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">이 콜 러블 의 가시성. Kotlin에서 가시성을 표현할 수없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dac6119f07007062b4875b1638bac8a721585f4a" translate="yes" xml:space="preserve">
          <source>Visibility of this class, or &lt;code&gt;null&lt;/code&gt; if its visibility cannot be represented in Kotlin.</source>
          <target state="translated">이 클래스 의 가시성. Kotlin에서 가시성을 표현할 수없는 경우는 &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aabca03bdef260f1cffd784ffe10c2b762503211" translate="yes" xml:space="preserve">
          <source>Visibility rules regarding complex class hierarchies with companion objects</source>
          <target state="translated">컴패니언 객체가있는 복잡한 클래스 계층 구조에 대한 가시성 규칙</target>
        </trans-unit>
        <trans-unit id="ac3022e113442db8619d262ae03fa9c0097a6e0d" translate="yes" xml:space="preserve">
          <source>Volatile</source>
          <target state="translated">Volatile</target>
        </trans-unit>
        <trans-unit id="74365b04f91d0aa9f5cfe78a2b9d8c743270db07" translate="yes" xml:space="preserve">
          <source>Volatiles are of no help</source>
          <target state="translated">휘발성 물질은 도움이되지 않습니다</target>
        </trans-unit>
        <trans-unit id="fd3edc641024a335a508fdacefb5f51ded5905cc" translate="yes" xml:space="preserve">
          <source>WARNING</source>
          <target state="translated">WARNING</target>
        </trans-unit>
        <trans-unit id="4e946026a7ff331eb2b9dc124f891817863bd199" translate="yes" xml:space="preserve">
          <source>WASM</source>
          <target state="translated">WASM</target>
        </trans-unit>
        <trans-unit id="25ca2ee13f635d58b0c2cff69efbc6a4f1b88f58" translate="yes" xml:space="preserve">
          <source>WASM32</source>
          <target state="translated">WASM32</target>
        </trans-unit>
        <trans-unit id="406538ae6cd24bca924c59857d3c75a306aa56eb" translate="yes" xml:space="preserve">
          <source>WATCHOS</source>
          <target state="translated">WATCHOS</target>
        </trans-unit>
        <trans-unit id="b9fac4aec6291b1c5ab0f9569e59e39d2636356c" translate="yes" xml:space="preserve">
          <source>WCString</source>
          <target state="translated">WCString</target>
        </trans-unit>
        <trans-unit id="c1cd547450ddf19820dbba6198904ce66087e598" translate="yes" xml:space="preserve">
          <source>WHITESPACE</source>
          <target state="translated">WHITESPACE</target>
        </trans-unit>
        <trans-unit id="2e31950e28a56c4fe6e7025b187b2fd4fefe4871" translate="yes" xml:space="preserve">
          <source>WINDOWS</source>
          <target state="translated">WINDOWS</target>
        </trans-unit>
        <trans-unit id="d9fff1c0dfb1298ad2bb377a3be85896a8fef6d6" translate="yes" xml:space="preserve">
          <source>Waiting for a job</source>
          <target state="translated">일자리를 기다리는 중</target>
        </trans-unit>
        <trans-unit id="43754c49f6c1a5cc1ea3d54dbf166c296a415ea2" translate="yes" xml:space="preserve">
          <source>Warning! Annotating your API with &lt;code&gt;@JvmDefault&lt;/code&gt; has serious implications on binary compatibility. Make sure to carefully read the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;reference page&lt;/a&gt; before using &lt;code&gt;@JvmDefault&lt;/code&gt; in production.</source>
          <target state="translated">경고! &lt;code&gt;@JvmDefault&lt;/code&gt; 로 API에 주석을 달면 이진 호환성에 심각한 영향을 미칩니다. 프로덕션에서 &lt;code&gt;@JvmDefault&lt;/code&gt; 를 사용하기 전에 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index&quot;&gt;참조 페이지&lt;/a&gt; 를주의해서 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7d38e4cd7c43347e6b57a76218aeff28900c3be2" translate="yes" xml:space="preserve">
          <source>Warning: using reflection is usually the wrong way to solve problems in Kotlin! In particular, if you have several classes that all have some common properties/functions and you want to write a function that can take an instance of any of those classes and use those properties, the correct approach is to define an interface with the common properties/functions and make all the relevant classes implement it; the function can then take that interface as a parameter. If you don't control those classes, you can use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;Adapter pattern&lt;/a&gt; and write wrapper classes that implement the interface - this is very easy thanks to Kotlin's &lt;a href=&quot;inheritance#delegation&quot;&gt;delegation feature&lt;/a&gt;. You can also get a lot of leverage out of using generics in clever ways.</source>
          <target state="translated">경고 : 리플렉션 사용은 일반적으로 Kotlin의 문제를 해결하는 잘못된 방법입니다! 특히, 일부 공통 속성 / 함수를 가진 여러 클래스가 있고 해당 클래스의 인스턴스를 가져 와서 해당 속성을 사용할 수있는 함수를 작성하려는 경우 올바른 접근 방식은 공통 속성으로 인터페이스를 정의하는 것입니다. / functions 및 모든 관련 클래스가이를 구현하도록합니다. 그러면 함수는 해당 인터페이스를 매개 변수로 사용할 수 있습니다. 이러한 클래스를 제어하지 않으면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Adapter_pattern&quot;&gt;어댑터 패턴을&lt;/a&gt; 사용 하고 인터페이스를 구현하는 랩퍼 클래스를 작성할 수 있습니다. 이는 Kotlin의 &lt;a href=&quot;inheritance#delegation&quot;&gt;위임 기능&lt;/a&gt; 덕분에 매우 쉽습니다 . 또한 제네릭을 영리하게 사용하면 많은 활용 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5869fc3835710be9dffa94b09164944fe6c00863" translate="yes" xml:space="preserve">
          <source>Warnings as errors</source>
          <target state="translated">오류로서의 경고</target>
        </trans-unit>
        <trans-unit id="7d7a6c37ae0a89dc47c6393b7b23a560c9ff63a7" translate="yes" xml:space="preserve">
          <source>Watch for deprecation warnings in advance for the best update experience.</source>
          <target state="translated">Watch for deprecation warnings in advance for the best update experience.</target>
        </trans-unit>
        <trans-unit id="621508220c73315e0bfc68d68f589c562907f45d" translate="yes" xml:space="preserve">
          <source>We add the &lt;code&gt;SharedCode&lt;/code&gt; framework to the Xcode project. For that let's click on the root node of the &lt;em&gt;project navigator&lt;/em&gt; and select the &lt;em&gt;target&lt;/em&gt; settings. Next, we click on the &lt;code&gt;+&lt;/code&gt; in the &lt;em&gt;Embedded Binaries&lt;/em&gt; section, click &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; button in the dialog to choose the framework from the disk. We can point to the following folder:</source>
          <target state="translated">Xcode 프로젝트에 &lt;code&gt;SharedCode&lt;/code&gt; 프레임 워크를 추가합니다 . 이를 위해 &lt;em&gt;프로젝트 탐색기&lt;/em&gt; 의 루트 노드를 클릭 하고 &lt;em&gt;대상&lt;/em&gt; 설정을 선택하십시오 . 그런 다음 &lt;em&gt;Embedded Binaries&lt;/em&gt; 섹션 에서 &lt;code&gt;+&lt;/code&gt; 를 클릭 하고 대화 상자에서 &lt;em&gt;Add Other&amp;hellip;&lt;/em&gt; 버튼을 클릭 하여 디스크에서 프레임 워크를 선택합니다. 다음 폴더를 가리킬 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a9f25c8723418966c0e0b17f9549ea1ce5a5f99" translate="yes" xml:space="preserve">
          <source>We also need to use the &lt;em&gt;war&lt;/em&gt; plugin that helps us generate the corresponding WAR artifacts for running/deploying</source>
          <target state="translated">또한 실행 / 배포를위한 해당 WAR 아티팩트를 생성하는 데 도움이 되는 &lt;em&gt;war&lt;/em&gt; 플러그인 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f769d9a3ee354265c33ea15ceda2db82197765c" translate="yes" xml:space="preserve">
          <source>We are just trying out an idea and want some users to play with it and give feedback. If it doesn't work out, we may drop it any minute.</source>
          <target state="translated">We are just trying out an idea and want some users to play with it and give feedback. If it doesn't work out, we may drop it any minute.</target>
        </trans-unit>
        <trans-unit id="05a06031f1e06a7952c57e44121ca5e185850421" translate="yes" xml:space="preserve">
          <source>We are now ready to start coding the iOS application and to use the Kotlin code from it</source>
          <target state="translated">이제 iOS 애플리케이션 코딩을 시작하고 Kotlin 코드를 사용할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="cff8cb63586d851860fe613c1e521ee0461e4b2e" translate="yes" xml:space="preserve">
          <source>We are ready to use the &lt;code&gt;SharedCode&lt;/code&gt; library from our Android and iOS applications.</source>
          <target state="translated">Android 및 iOS 애플리케이션에서 &lt;code&gt;SharedCode&lt;/code&gt; 라이브러리 를 사용할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="14edea8060ff3b0350a868b06c73ba61ae235890" translate="yes" xml:space="preserve">
          <source>We are starting with an implementation for the JVM. Let's create a file &lt;code&gt;Base64.kt&lt;/code&gt; in &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; folder and provide a simple implementation, which delegates to &lt;code&gt;java.util.Base64&lt;/code&gt;:</source>
          <target state="translated">우리는 JVM 구현으로 시작합니다. 하자는 파일 생성 &lt;code&gt;Base64.kt&lt;/code&gt; 에서 &lt;code&gt;jvmMain/kotlin/jetbrains/base64&lt;/code&gt; 폴더를하고있는 대표 간단한 구현, 제공 &lt;code&gt;java.util.Base64&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="b38f2316b8757428d73f475d7c1fadf769b873b4" translate="yes" xml:space="preserve">
          <source>We are using &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;IntelliJ IDEA&lt;/a&gt; for this tutorial. Both the &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;free and open source&lt;/a&gt; IntelliJ IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;Community Edition&lt;/a&gt; and IntelliJ IDEA Ultimate Edition work for this tutorial. We can download and install both of them from &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; if necessary. The Kotlin plugin is included with IntelliJ IDEA by default, but still, we need to make sure the Kotlin plugin version is 1.3.41 (or newer) in the &lt;em&gt;Settings&lt;/em&gt; or &lt;em&gt;Preferences&lt;/em&gt; dialog, under the Language &amp;amp; Frameworks | Kotlin section.</source>
          <target state="translated">우리는 사용 &lt;a href=&quot;https://jetbrains.com/idea&quot;&gt;하게 IntelliJ IDEA를&lt;/a&gt; 이 튜토리얼. 둘 다 &lt;a href=&quot;https://www.jetbrains.com/idea/features/editions_comparison_matrix.html&quot;&gt;무료 및 오픈 소스&lt;/a&gt; 인 IntelliJ의 IDEA &lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;커뮤니티 에디션&lt;/a&gt; 과이 튜토리얼하게 IntelliJ IDEA 얼티미트 에디션 작동합니다. 필요한 경우 &lt;a href=&quot;https://jetbrains.com/idea/download&quot;&gt;https://jetbrains.com/idea/download&lt;/a&gt; 에서 두 가지를 모두 다운로드하여 설치할 수 있습니다 . Kotlin 플러그인은 기본적으로 IntelliJ IDEA에 포함되어 있지만 여전히 언어 또는 프레임 워크 | &lt;em&gt;설정&lt;/em&gt; 또는 &lt;em&gt;환경 설정&lt;/em&gt; 대화 상자 에서 Kotlin 플러그인 버전이 1.3.41 이상인지 확인해야합니다. 코 틀린 섹션.</target>
        </trans-unit>
        <trans-unit id="55cc632a1ea27e5e64ad2495a5384f62f48dbc86" translate="yes" xml:space="preserve">
          <source>We are using the &lt;code&gt;delay()&lt;/code&gt; function that's like &lt;code&gt;Thread.sleep()&lt;/code&gt;, but better: it &lt;em&gt;doesn't block a thread&lt;/em&gt;, but only suspends the coroutine itself. The thread is returned to the pool while the coroutine is waiting, and when the waiting is done, the coroutine resumes on a free thread in the pool.</source>
          <target state="translated">우리는 &lt;code&gt;Thread.sleep()&lt;/code&gt; 과 같은 &lt;code&gt;delay()&lt;/code&gt; 함수를 사용하고 있지만 더 좋습니다 : &lt;em&gt;thread를 차단하지는 않지만&lt;/em&gt; 코 루틴 자체를 일시 중단합니다. 코 루틴이 대기하는 동안 스레드가 풀로 리턴되고 대기가 완료되면 코 루틴이 풀의 사용 가능한 스레드에서 재개됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da1efc61212d59164e482ecaadd2d5e755cb8ec9" translate="yes" xml:space="preserve">
          <source>We believe that a lot of users could use a much faster cycle, where critical compiler bug fixes arrive immediately, making the code more safe and correct. So, Kotlin 1.3 introduces &lt;em&gt;progressive&lt;/em&gt; compiler mode, which can be enabled by passing the argument &lt;code&gt;-progressive&lt;/code&gt; to the compiler.</source>
          <target state="translated">우리는 많은 사용자들이 훨씬 빠른 사이클을 사용할 수 있다고 생각합니다. 중요한 컴파일러 버그 수정이 즉시 도착하여 코드가 더 안전하고 정확합니다. 따라서 Kotlin 1.3에는 &lt;em&gt;점진적&lt;/em&gt; 컴파일러 모드가 도입되었습니다.이 모드는 &lt;code&gt;-progressive&lt;/code&gt; 인수 를 컴파일러 에 전달하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e996e5615a264af995c203eaebe6185c018bf0a" translate="yes" xml:space="preserve">
          <source>We believe that the words &lt;strong&gt;in&lt;/strong&gt; and &lt;strong&gt;out&lt;/strong&gt; are self-explaining (as they were successfully used in C# for quite some time already), thus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:</source>
          <target state="translated">우리는 단어 믿고 &lt;strong&gt;에서&lt;/strong&gt; 와 &lt;strong&gt;밖으로&lt;/strong&gt; 따라서 위에서 언급 한 니모닉이 정말 필요하지, 자기 설명 (성공적 이미 꽤 많은 시간 동안 C #으로 사용했다), 그리고 하나는 높은 목적을 위해 그것을 바꿔 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a4b5a076e237cd86b9569bc0bd72070895b09bdf" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;lib.exe&lt;/code&gt; from the toolchain to generate the static library wrapper &lt;code&gt;libnative.lib&lt;/code&gt; that automates the DLL usage from the code:</source>
          <target state="translated">코드에서 DLL 사용을 자동화하는 정적 라이브러리 래퍼 &lt;code&gt;libnative.lib&lt;/code&gt; 를 생성하기 위해 툴체인에서 &lt;code&gt;lib.exe&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b380a7bf1b634600b0c261666fb452d97fe21714" translate="yes" xml:space="preserve">
          <source>We call Kotlin classes directly from Objective-C code. A Kotlin &lt;code&gt;object&lt;/code&gt; has the class method function &lt;code&gt;object&lt;/code&gt;, which allows us to get the only instance of the object and to call &lt;code&gt;Object&lt;/code&gt; methods on it. The widespread pattern is used to create an instance of the &lt;code&gt;Clazz&lt;/code&gt; class. We call the &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; on Objective-C. We may also use &lt;code&gt;[DemoClazz new]&lt;/code&gt; for constructors without parameters. Global declarations from the Kotlin sources are scoped under the &lt;code&gt;DemoLibKt&lt;/code&gt; class in Objective-C. All methods are turned into class methods of that class. The &lt;code&gt;strings&lt;/code&gt; function is turned into &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; function in Objective-C, we can pass &lt;code&gt;NSString&lt;/code&gt; directly to it. The return is visible as &lt;code&gt;NSString&lt;/code&gt; too.</source>
          <target state="translated">Objective-C 코드에서 Kotlin 클래스를 직접 호출합니다. Kotlin &lt;code&gt;object&lt;/code&gt; 에는 클래스 메소드 함수 &lt;code&gt;object&lt;/code&gt; 가 있습니다 .이를 통해 객체 의 유일한 인스턴스를 가져 와서 &lt;code&gt;Object&lt;/code&gt; 메소드 를 호출 할 수 있습니다. 널리 퍼진 패턴은 &lt;code&gt;Clazz&lt;/code&gt; 클래스 의 인스턴스를 작성하는 데 사용됩니다 . Objective-C 에서 &lt;code&gt;[[ DemoClazz alloc] init]&lt;/code&gt; 를 호출합니다 . 파라미터가없는 생성자에 &lt;code&gt;[DemoClazz new]&lt;/code&gt; 를 사용할 수도 있습니다 . Kotlin 소스의 글로벌 선언은 Objective-C 의 &lt;code&gt;DemoLibKt&lt;/code&gt; 클래스 아래에 있습니다. 모든 메소드는 해당 클래스의 클래스 메소드로 바뀝니다. &lt;code&gt;strings&lt;/code&gt; 함수로 설정되어 &lt;code&gt;DemoLibKt.stringsStr&lt;/code&gt; Objective-C에서 함수 를 사용하면 &lt;code&gt;NSString&lt;/code&gt; 을 직접 전달할 수 있습니다 . 리턴은 &lt;code&gt;NSString&lt;/code&gt; 으로 도 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6efbfc50d097338c67f6c25e5a2530e00802bbf1" translate="yes" xml:space="preserve">
          <source>We can also check a value for being &lt;em&gt;in&lt;/em&gt; or &lt;em&gt;!in&lt;/em&gt; a &lt;a href=&quot;ranges&quot;&gt;range&lt;/a&gt; or a collection:</source>
          <target state="translated">또한 &lt;a href=&quot;ranges&quot;&gt;범위&lt;/a&gt; 또는 컬렉션 &lt;em&gt;에&lt;/em&gt; 있거나 &lt;em&gt;!에&lt;/em&gt; 있는 값을 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d48b261007df82564fff9e248b32f0b0877a7db" translate="yes" xml:space="preserve">
          <source>We can also run the project from the command line, without using IntelliJ IDEA Ultimate, if we apply the gretty plugin. In order to do this, we need to make the following changes to build.gradle:</source>
          <target state="translated">We can also run the project from the command line, without using IntelliJ IDEA Ultimate, if we apply the gretty plugin. In order to do this, we need to make the following changes to build.gradle:</target>
        </trans-unit>
        <trans-unit id="be71c4616ae57b989081464748078b992e6a499b" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; option.</source>
          <target state="translated">또한 &lt;code&gt;sourceMap&lt;/code&gt; 옵션을 통해이를 표시하여 컴파일러가 소스 맵을 생성하도록할지 여부를 정의 할 수있는 방법도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db36be1716cde1f09b5bb491a1d29f546a1af582" translate="yes" xml:space="preserve">
          <source>We can also see how we can define whether we want the compiler to generate sourcemaps for us by indicating this via the &lt;code&gt;sourceMap&lt;/code&gt; parameter.</source>
          <target state="translated">또한 &lt;code&gt;sourceMap&lt;/code&gt; 매개 변수 를 통해이를 표시하여 컴파일러가 소스 맵을 생성하도록할지 여부를 정의 할 수있는 방법도 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5bd60fd46fe6ea1c5b448761b2e310af9a2b34e" translate="yes" xml:space="preserve">
          <source>We can check whether an object conforms to a given type at runtime by using the &lt;code&gt;is&lt;/code&gt; operator or its negated form &lt;code&gt;!is&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 연산자 또는 부정 형식 인 &lt;code&gt;!is&lt;/code&gt; 를 사용하여 런타임에 객체가 주어진 유형을 따르는 지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80fca726c567776685be62a6f296ba802e4a0c48" translate="yes" xml:space="preserve">
          <source>We can choose to let &lt;code&gt;MotorVehicle&lt;/code&gt; implement that interface, since it's got the required members - but now we need to mark those members with &lt;code&gt;override&lt;/code&gt;, and we can remove &lt;code&gt;open&lt;/code&gt; since an overridden function is implicitly open:</source>
          <target state="translated">필요한 멤버가 있으므로 &lt;code&gt;MotorVehicle&lt;/code&gt; 이 해당 인터페이스를 구현 하도록 선택할 수 있습니다. 그러나 이제 해당 멤버를 &lt;code&gt;override&lt;/code&gt; 로 표시해야 하며 재정의 된 함수가 암시 적으로 열려 있으므로 &lt;code&gt;open&lt;/code&gt; 을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ab28e12a4329ff5188bb6bb1c34f1f3bf4ce258" translate="yes" xml:space="preserve">
          <source>We can configure the Kotlin compiler option to use any of these. The last option (UMD) will generate UMD and fallback to the other options if one is not available. Currently Kotlin compiler options are per IntelliJ IDEA project as opposed to a Kotlin module.</source>
          <target state="translated">Kotlin 컴파일러 옵션을 구성하여 이들 중 하나를 사용할 수 있습니다. 마지막 옵션 (UMD)은 UMD를 생성하고 사용할 수없는 경우 다른 옵션으로 대체합니다. 현재 Kotlin 컴파일러 옵션은 Kotlin 모듈과 달리 IntelliJ IDEA 프로젝트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5b4c1b5549ed7b71f56b6d1ba48bd66bf46537dc" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with &quot;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">호출하는 비동기 스타일 함수를 정의 할 수 있습니다 &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; 명시 적 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 참조 가있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 코 루틴 빌더를 사용하여 doSomethingUsefulOne 및 &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; 를&lt;em&gt;비동기 적으로&lt;/em&gt; . 이러한 함수의 이름을 &quot;Async&quot;접미사로 지정하면 비동기 계산 만 시작하고 결과를 얻기 위해 결과 지연된 값을 사용해야한다는 사실을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="452dc3c84f7cabd350d9558a57e866a1cf25ff79" translate="yes" xml:space="preserve">
          <source>We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt;&lt;em&gt;asynchronously&lt;/em&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with the &quot;&amp;hellip;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</source>
          <target state="translated">We can define async-style functions that invoke &lt;code&gt;doSomethingUsefulOne&lt;/code&gt; and &lt;code&gt;doSomethingUsefulTwo&lt;/code&gt; &lt;em&gt;asynchronously&lt;/em&gt; using the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; coroutine builder with an explicit &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; reference. We name such functions with the &quot;&amp;hellip;Async&quot; suffix to highlight the fact that they only start asynchronous computation and one needs to use the resulting deferred value to get the result.</target>
        </trans-unit>
        <trans-unit id="4ecb356b303055242a64963a7b2a1f314c6be1d3" translate="yes" xml:space="preserve">
          <source>We can define custom accessors for a property. If we define a custom getter, it will be called every time we access the property (this allows us to implement a computed property). Here's an example of a custom getter:</source>
          <target state="translated">속성에 대한 사용자 지정 접근자를 정의 할 수 있습니다. 커스텀 게터를 정의하면 속성에 액세스 할 때마다 호출됩니다 (계산 된 속성을 구현할 수 있습니다). 맞춤 게터의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b31aa9761950ea554c775fecf5e0c018baf882fd" translate="yes" xml:space="preserve">
          <source>We can easily call it directly (&lt;code&gt;isOdd(5)&lt;/code&gt;), but we can also use it as a function type value, e.g. pass it to another function. To do this, we use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">쉽게 직접 호출 할 수 있지만 ( &lt;code&gt;isOdd(5)&lt;/code&gt; ), 함수 유형 값으로 사용할 수도 있습니다 (예 : 다른 함수에 전달). 이를 위해 &lt;code&gt;::&lt;/code&gt; 연산자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ae17c1ca56657ad30866237b96021ef47b3cda29" translate="yes" xml:space="preserve">
          <source>We can explicitly convert a character to an &lt;code&gt;Int&lt;/code&gt; number:</source>
          <target state="translated">문자를 &lt;code&gt;Int&lt;/code&gt; 숫자 로 명시 적으로 변환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d31ec9f07f4bc208cadad8ae2ec0b5f65d7cdf75" translate="yes" xml:space="preserve">
          <source>We can explicitly return a value from the lambda using the &lt;a href=&quot;returns#return-at-labels&quot;&gt;qualified return&lt;/a&gt; syntax. Otherwise, the value of the last expression is implicitly returned.</source>
          <target state="translated">&lt;a href=&quot;returns#return-at-labels&quot;&gt;정규화 된 반환&lt;/a&gt; 구문을 사용하여 람다에서 값을 명시 적으로 반환 할 수 있습니다 . 그렇지 않으면 마지막 표현식의 값이 내재적으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5af6b3dce006afd131588be4e84caa508a65cc20" translate="yes" xml:space="preserve">
          <source>We can import either a single name, e.g.</source>
          <target state="translated">단일 이름을 가져올 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8a9f3b72eb46629a298e0a057eccfdabab01c204" translate="yes" xml:space="preserve">
          <source>We can install &lt;code&gt;kotlinizer&lt;/code&gt; to the default repository:</source>
          <target state="translated">설치할 수있다 &lt;code&gt;kotlinizer&lt;/code&gt; 를 기본 저장소에 :</target>
        </trans-unit>
        <trans-unit id="6d3bad56e3c4235f442b8c993bfc65c9b26cdc43" translate="yes" xml:space="preserve">
          <source>We can now add our first Kotlin source code file and IntelliJ IDEA will prompt us to configure the project for Kotlin. On doing so, we should select as target JavaScript</source>
          <target state="translated">이제 첫 번째 Kotlin 소스 코드 파일을 추가 할 수 있으며 IntelliJ IDEA는 Kotlin에 대한 프로젝트를 구성하라는 메시지를 표시합니다. 이를 위해 대상 JavaScript로 선택해야합니다</target>
        </trans-unit>
        <trans-unit id="dc96081c653c84bb3dd3b5b83bfc524f3cd03b65" translate="yes" xml:space="preserve">
          <source>We can now do this (but it's still possible to call the function the normal way):</source>
          <target state="translated">우리는 이제 이것을 할 수 있습니다 (그러나 정상적인 방법으로 함수를 호출하는 것은 여전히 ​​가능합니다) :</target>
        </trans-unit>
        <trans-unit id="bb97bda68a25be3b25091829fa426075294c2d71" translate="yes" xml:space="preserve">
          <source>We can now use any of the standard Gradle tasks for Spring Boot to run the application. As such, running</source>
          <target state="translated">Spring Boot에 대한 표준 Gradle 작업을 사용하여 응용 프로그램을 실행할 수 있습니다. 따라서, 달리기</target>
        </trans-unit>
        <trans-unit id="c6898463443208b858c46602bd14f4fe18a2e216" translate="yes" xml:space="preserve">
          <source>We can override a non-abstract open member with an abstract one</source>
          <target state="translated">추상적 인 멤버로 비 개방형 멤버를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec8ade084fb51f7b34b89fae3c572fe0de063884" translate="yes" xml:space="preserve">
          <source>We can run the compiler without parameters to have an interactive shell. We can type any valid Kotlin code and see the results.</source>
          <target state="translated">매개 변수없이 컴파일러를 실행하여 대화식 쉘을 가질 수 있습니다. 유효한 Kotlin 코드를 입력하고 결과를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29622b395465874ab1409644634bdf5bd547c3e" translate="yes" xml:space="preserve">
          <source>We can see how the API is created. To start with, we need to initialize the &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; structure. Let's take a look at the latest part of the &lt;code&gt;libnative_api.h&lt;/code&gt; for this:</source>
          <target state="translated">API가 어떻게 생성되는지 확인할 수 있습니다. 우선 &lt;code&gt;libnative_ExportedSymbols&lt;/code&gt; 구조 를 초기화해야합니다 . &lt;code&gt;libnative_api.h&lt;/code&gt; 의 최신 부분을 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="d27d56a268fbe45c1d0688c4606abf60011997ba" translate="yes" xml:space="preserve">
          <source>We can simply refer to any class or member function inside our node.js code by simply importing the module using &lt;code&gt;require&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 를 사용하여 간단히 모듈을 가져 와서 node.js 코드 내에서 클래스 또는 멤버 함수를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="831ccd2e7105b549d27fa757caf8f798b465ce95" translate="yes" xml:space="preserve">
          <source>We can simulate custom infix operations by using &lt;a href=&quot;functions#infix-notation&quot;&gt;infix function calls&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#infix-notation&quot;&gt;infix 함수 호출&lt;/a&gt; 을 사용하여 사용자 정의 infix 작업을 시뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="509f912bd5b5b6af65e5240f9ef362cc1a5f0b3f" translate="yes" xml:space="preserve">
          <source>We can start by creating a library file in Kotlin and save it as &lt;code&gt;hello.kt&lt;/code&gt;:</source>
          <target state="translated">Kotlin에서 라이브러리 파일을 &lt;code&gt;hello.kt&lt;/code&gt; 로 저장할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="89f8fe8ceb180f0a0bdf079538aa483abb6121b4" translate="yes" xml:space="preserve">
          <source>We can then do this:</source>
          <target state="translated">그런 다음이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67a4cc600951e3a005f1c78d3f5d6ddad7aa6cbe" translate="yes" xml:space="preserve">
          <source>We can use arbitrary expressions (not only constants) as branch conditions</source>
          <target state="translated">상수 조건뿐만 아니라 임의의 표현식을 분기 조건으로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1d0515ada05fe82e395d7a6707b6351170a6e35a" translate="yes" xml:space="preserve">
          <source>We can use classes or functions from a Kotlin project, in our scratches and worksheets.</source>
          <target state="translated">We can use classes or functions from a Kotlin project, in our scratches and worksheets.</target>
        </trans-unit>
        <trans-unit id="8b191724788dd23ede6b8c2149628b7a54092d58" translate="yes" xml:space="preserve">
          <source>We can use explicit conversions to widen numbers</source>
          <target state="translated">숫자를 넓히기 위해 명시적인 변환을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="dfb0038c9e10b5e80574a36666be3c3e86aa4353" translate="yes" xml:space="preserve">
          <source>We collectively refer to &lt;em&gt;Experimental&lt;/em&gt;, &lt;em&gt;Alpha&lt;/em&gt; and &lt;em&gt;Beta&lt;/em&gt; as &lt;strong&gt;pre-stable&lt;/strong&gt; levels.</source>
          <target state="translated">We collectively refer to &lt;em&gt;Experimental&lt;/em&gt;, &lt;em&gt;Alpha&lt;/em&gt; and &lt;em&gt;Beta&lt;/em&gt; as &lt;strong&gt;pre-stable&lt;/strong&gt; levels.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
