<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="kotlin">
    <body>
      <group id="kotlin">
        <trans-unit id="8e5f25cf2555e851681e56711455629d8b96cc85" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; code is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 코드는이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c93c7f205f664c42eb53e198c38febdd8681e8c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Char&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toChar()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Char&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toChar()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0bee6e823fc7a039aaeeb4e2cf6ccadd56cad2" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec044076f69f3a9e4c8c326707b213be48dbdf4c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Float&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Float&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="413cc395d49c3c9b688aa7288d432c1583480097" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e04c116c448cef44fd49f1d1da49c8be72cf833e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="624ad9cad2fadf7c5df7034160380cba9b36827a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e233d00009204b3d8e16f6c4faaeb29b610dd152" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="be9fd1536c9016ec165d93e9e044c6403df23d59" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Double&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Double&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ae244f9a05312104462c229a2e3a4a4de64be4e1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f8088fd36ea4c2c1efeb80cfa5d2e317eb476320" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f353ad75e4345f7f3c16a80f19361bddd53a4f67" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="abac5ba157cb93c8f101ff3e6ab497cfac17749a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Float&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Float&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9d03c1143daecc3b8a141860933f0a92adb18b37" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="6ff94aee825d38ae08d93f2ca58819f2a03d9747" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a5d4e0dea3c1513f10c80d1128e159e3a009787" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Int&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 . 결과적인 &lt;code&gt;Int&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="134cc45d29d5c0611e6038571857feed8853b0ee" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a8d60bc3ef88b39460060b7f8165763da80802bc" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="12aaa5ec83610d73b4b2fc195902417a297ddd61" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b30712342fda907bc49df4d10c136bbeeaaf708b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Int&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Int&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="25bcbeae5576ececd431ec0f451a2c7cf6bf73b4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value has the same binary representation as this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="e6a0efc4ac5c4b05735980342faa240209bf9353" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a30381cf3452bf71d4466b6a6a9c5a35e959654a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7692c28294ebe4518a8808f192338ab899b5aeec" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Short&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="60b7e7e3ba10c2b92827e84db685cc040e179ed1" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a95d7e6a557f4530d701aed1a8410d9b6e793205" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e900373f53d6267fd01ecf92bb2c5cb1fed9a7b7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Long&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Long&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3866529acc183dc8b682af92a84909ec65bd5749" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value has the same binary representation as this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="5ccfa5aff935ee9326f2b407c585467d126768e7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is equal to &lt;code&gt;this.toInt().toShort()&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은 &lt;code&gt;this.toInt().toShort()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb338e05b22f496cc978d6bf212ddabde5dd17a4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="27367d77acd56c6a1050bc0a49a57fcf2061de96" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bc0fbdc70644d6d748c478656fa78e912cc16e6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 . 결과 &lt;code&gt;Short&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9494a50b8985a2d74ddd24ec83038bdcd4606a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value. Note that the resulting &lt;code&gt;Short&lt;/code&gt; value may be negative.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 . 결과 &lt;code&gt;Short&lt;/code&gt; 값은 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbe35f845af4aa0feff1d9060ab35a7c6fe3476" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;Byte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="62163dcead131c0bf0933b1342f420db3bc4bb8d" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;Short&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;Short&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26c6a5634d9e1d8b962bb6788ae67bc866b78e45" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Byte&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Byte&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="11d5b691a4a978c7af952b604f7d065d5eac1305" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="5226c83d79204652c28eff49e7528cb1e99fe2d6" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="726d8e3bdd3b093a08a44094c2cae4da994770da" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dfb49e88d21be6bcb0f49bf822a5aaa6937a983" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2686cc59be2588fb1dc986c8db1acdab514c552c" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5d21503bfa5cb9b99c854c368f0b66239678aba" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UByte&lt;/code&gt; value is represented by the least significant 8 bits of this &lt;code&gt;UShort&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UByte&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 값 의 최하위 8 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f3fe5211f1aea05bea1a841d6d73788aeeb2998" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="66a1e76fd131680ad5406468e22ad3973f35ff4e" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc935cba2a00e8cc63899ff18d12438a89739380" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value is represented by the least significant 32 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 32 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d9ba2608012da37a52b5b9b7da96f6d67796334" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9ab12c98c1ea5502db93ef496727f7d48f4edc12" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UInt&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UInt&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e00a9f9829597db51c5f5f105c5c613e61839318" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a5fe358a0a132b3d4ac886ee0067825836c972c3" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1e225f6484184e1fd9b9a789c6be2168c16944f8" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UInt&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="951d01157187c8755e4bb93be0ec662d70035ced" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;ULong&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UShort&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;ULong&lt;/code&gt; 값은이 &lt;code&gt;UShort&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="76c0754fefaa89b43d0e48e2d3b2efa1a3c37cac" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value has the same binary representation as this &lt;code&gt;Short&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Short&lt;/code&gt; 값 과 동일한 이진 표현을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ed25489ad27c7ad2fa4a9e9ed8a17e177ed921a7" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Int&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Int&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f42954d6785f3d5db6ef1809c504748ad3c8598b" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;Long&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;Long&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="1457c7b3fcc5ff173b3ad803474b4e660273fb3a" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;UInt&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;UInt&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4cfae00353cb363d45d034bd2773a412889ab06" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value is represented by the least significant 16 bits of this &lt;code&gt;ULong&lt;/code&gt; value.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;ULong&lt;/code&gt; 값 의 최하위 16 비트로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd44eb3bc0245bda18586fe624c6aa7f2130c655" translate="yes" xml:space="preserve">
          <source>The resulting &lt;code&gt;UShort&lt;/code&gt; value represents the same numerical value as this &lt;code&gt;UByte&lt;/code&gt;.</source>
          <target state="translated">결과 &lt;code&gt;UShort&lt;/code&gt; 값은이 &lt;code&gt;UByte&lt;/code&gt; 와 동일한 숫자 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26ad7d1c46a7946f361222464d3fd9f54190f2e7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Long&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Double&lt;/code&gt; 입니다. 이 &lt;code&gt;Long&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Double&lt;/code&gt; 사이에 있는 경우 최소 유효 비트 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="492c13f0924f52f27eadd038e36be9a70c7d0f23" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Double&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Double&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;ULong&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Double&lt;/code&gt; 입니다. 이 &lt;code&gt;ULong&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Double&lt;/code&gt; 사이에 있는 경우, 적어도 유의 한 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="fc0e588cba1b5e32b36bbd725d91a005e8eca137" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Double&lt;/code&gt; value. In case when this &lt;code&gt;Double&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Double&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Double&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="1a94a9e0d2914f4ed72b19cd967f6325996af0de" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Int&lt;/code&gt; value. In case when this &lt;code&gt;Int&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Int&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Int&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="4c34f885e332b614efeb077bdc9dc7f566d719ac" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;Long&lt;/code&gt; value. In case when this &lt;code&gt;Long&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;Long&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;Long&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="56778d0fa4ef4bd39c3c6c8e27df252ff267b86a" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;UInt&lt;/code&gt; value. In case when this &lt;code&gt;UInt&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;UInt&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;UInt&lt;/code&gt; 값이 정확히 두 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="498957909e2b3c5b2a70150c6779dc9db0eb20c7" translate="yes" xml:space="preserve">
          <source>The resulting value is the closest &lt;code&gt;Float&lt;/code&gt; to this &lt;code&gt;ULong&lt;/code&gt; value. In case when this &lt;code&gt;ULong&lt;/code&gt; value is exactly between two &lt;code&gt;Float&lt;/code&gt;s, the one with zero at least significant bit of mantissa is selected.</source>
          <target state="translated">결과 값은 이 &lt;code&gt;ULong&lt;/code&gt; 값에 가장 가까운 &lt;code&gt;Float&lt;/code&gt; 입니다. 이 &lt;code&gt;ULong&lt;/code&gt; 값이 정확히 2 개의 &lt;code&gt;Float&lt;/code&gt; 사이 인 경우, 적어도 유의 한 가수 비트가 0 인 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="65d14c2cdb6c9b143338a902f9c4de4c9b45f92f" translate="yes" xml:space="preserve">
          <source>The return type inference for anonymous functions works just like for normal functions: the return type is inferred automatically for anonymous functions with an expression body and has to be specified explicitly (or is assumed to be &lt;code&gt;Unit&lt;/code&gt;) for anonymous functions with a block body.</source>
          <target state="translated">익명 함수에 대한 리턴 유형 유추는 일반 함수와 동일하게 작동합니다. 리턴 유형은 표현식 본문이있는 익명 함수에 대해 자동으로 추론 되며 블록 본문이있는 익명 함수에 대해 명시 적으로 지정되거나 &lt;code&gt;Unit&lt;/code&gt; 으로 간주되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dbab78ef44eaefb4e469bd1e51f4e8661d634cea" translate="yes" xml:space="preserve">
          <source>The return type of a function-typed return type (the user expects the returned function to return &lt;code&gt;Fruit&lt;/code&gt;, so it's okay if it really returns &lt;code&gt;Apple&lt;/code&gt;)</source>
          <target state="translated">함수 타입 리턴 타입의 리턴 타입 (사용자는 리턴 된 함수가 &lt;code&gt;Fruit&lt;/code&gt; 을 리턴 할 것으로 예상 하므로 실제로 &lt;code&gt;Apple&lt;/code&gt; 을 리턴해도 괜찮습니다 )</target>
        </trans-unit>
        <trans-unit id="d8362d946ac99a87abd0521089565682c0510f07" translate="yes" xml:space="preserve">
          <source>The return type of a lambda expression is inferred from the type of the last expression inside it (or from the function type of the variable/parameter that the lambda expression is assigned to). If a lambda expression is passed as a function parameter (which is the ordinary use) or assigned to a variable with a declared type, Kotlin can infer the parameter types too, and you only need to specify their names:</source>
          <target state="translated">람다 식의 반환 형식은 그 안에있는 마지막 식의 형식 (또는 람다식이 할당 된 변수 / 매개 변수의 함수 형식)에서 유추됩니다. 람다식이 함수 매개 변수 (일반적인 용도)로 전달되거나 선언 된 유형의 변수에 지정된 경우 Kotlin은 매개 변수 유형도 유추 할 수 있으며 해당 이름 만 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d7c260eb93497371636dc4de8fdb8ef84ac32045" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;apply&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt; is the context object itself. Hence, they can be included into call chains as &lt;em&gt;side steps&lt;/em&gt;: you can continue chaining function calls on the same object after them.</source>
          <target state="translated">의 반환 값 &lt;code&gt;apply&lt;/code&gt; 하고 &lt;code&gt;also&lt;/code&gt; 상황에 맞는 객체 자체입니다. 따라서 이러한 &lt;em&gt;단계는&lt;/em&gt; 호출 &lt;em&gt;단계에 부가 단계&lt;/em&gt; 로 포함될 수 있습니다 . 함수 호출은 이후에 동일한 객체에서 함수 호출을 계속 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="02d73a0e151892c1ff98e7a6888b38592bdd4e2a" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../-time-mark/index&quot;&gt;TimeMark&lt;/a&gt; instance encapsulates the captured time point and allows querying the duration of time interval &lt;a href=&quot;../-time-mark/elapsed-now&quot;&gt;elapsed&lt;/a&gt; from that point.</source>
          <target state="translated">반환 된 &lt;a href=&quot;../-time-mark/index&quot;&gt;TimeMark&lt;/a&gt; 인스턴스는 캡처 된 시점을 캡슐화하고 해당 시점에서 &lt;a href=&quot;../-time-mark/elapsed-now&quot;&gt;경과 된&lt;/a&gt; 시간 간격의 기간을 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="046b6584c1bbd3a7a64857edece72cc830dec917" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">리턴 된 인스턴스는 지정된 &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;잠금&lt;/a&gt; 오브젝트를 사용하여 동기화합니다. 하면 &lt;a href=&quot;lazy#kotlin%24lazy%28kotlin.Any%2C+kotlin.Function0%28%28kotlin.lazy.T%29%29%29%2Flock&quot;&gt;잠금이&lt;/a&gt; 이 경우 자체에 동기화 할 수있는 인스턴스 용도를 지정하지 않은 것이 실수로 교착 상태가 발생할 수 있으므로 반환 된 인스턴스의 외부 코드에서 동기화하지 않습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b93655dba3d2a18324e24a42bc0aa37bcaff559" translate="yes" xml:space="preserve">
          <source>The returned instance uses the specified &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; object to synchronize on. When the &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;lock&lt;/a&gt; is not specified the instance uses itself to synchronize on, in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.</source>
          <target state="translated">반환 된 인스턴스는 지정된 &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;잠금&lt;/a&gt; 개체를 사용하여 동기화합니다. 하면 &lt;a href=&quot;lazy#kotlin%24lazy(kotlin.Any?,%20kotlin.Function0((kotlin.lazy.T)))/lock&quot;&gt;잠금이&lt;/a&gt; 이 경우 자체에 동기화 할 수있는 인스턴스 용도를 지정하지 않은 것이 실수로 교착 상태가 발생할 수 있으므로 반환 된 인스턴스의 외부 코드에서 동기화하지 않습니다. 또한이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97bfc2ca377533226a66b10393317b0a2f994fba" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this char sequence contains less than two characters.</source>
          <target state="translated">이 문자 순서에 2 자 미만이 포함되어 있으면 리턴 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d158c2273db93047119908af61efbbba35bd76f3" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this collection contains less than two elements.</source>
          <target state="translated">이 컬렉션에 요소가 2 개 미만인 경우 반환 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="29bbad5c305945f97c70cd75ffccab450111f2ea" translate="yes" xml:space="preserve">
          <source>The returned map is serializable (JVM).</source>
          <target state="translated">리턴 된 맵은 직렬화 가능 (JVM)입니다.</target>
        </trans-unit>
        <trans-unit id="ec4d25dd41a10ce08bae955efed7031764938b43" translate="yes" xml:space="preserve">
          <source>The returned map is serializable.</source>
          <target state="translated">반환 된 맵은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6f1137c5bd275e0d050f73fe1ffb45e6bc0fef52" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original array.</source>
          <target state="translated">반환 된 맵은 원래 배열에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="aab8c4af63582433af11da060d436e3782362d9a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original char sequence.</source>
          <target state="translated">리턴 된 맵은 원래 문자 시퀀스에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="16f1a5aa5ffd50a8f9547783402bf7757df5025f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original collection.</source>
          <target state="translated">리턴 된 맵은 원래 콜렉션에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="19c068ac54b988c0d6076dddd8c2dbf4092708f6" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the keys produced from the original sequence.</source>
          <target state="translated">반환 된 맵은 원래 시퀀스에서 생성 된 키의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f54f229a0ee8d8720d828fe3e27b2d2a6ca940bc" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array.</source>
          <target state="translated">반환 된 맵은 원래 배열의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="918c726186d31885a03be5dd5847d194f356551f" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original array. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">반환 된 맵은 원래 배열의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1331dc1f7dcbe48a5148654c3f9a9dd17b60c885" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original char sequence.</source>
          <target state="translated">리턴 된 맵은 원래 문자 시퀀스의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="566ed3a9dcb7ca74d4f2c70c6fdf84ac896debb5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection.</source>
          <target state="translated">반환 된 맵은 원본 컬렉션의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2e469a2caf818c0835cee9e0a1babf1e2e3c07a5" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original collection. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">반환 된 맵은 원본 컬렉션의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4c19d30d5fb69c54a255c5b1e548f2fa56d3aefb" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f87204408405ad88a40594eff8f4867029a89b59" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fpair&quot;&gt;쌍&lt;/a&gt; 은 고유 키가있는 경우 결국 반복된다.</target>
        </trans-unit>
        <trans-unit id="2699ea2c18d183922dd8db09dd9a3f0e18a1eb1d" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. The &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;pair&lt;/a&gt; is iterated in the end if it has a unique key.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/pair&quot;&gt;쌍&lt;/a&gt; 은 고유 키가있는 경우 결국 반복된다.</target>
        </trans-unit>
        <trans-unit id="8ff3f66b8173f81182161d671f67a90a7b9f8d74" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키를 가진 해당 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.Array%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 배열 순서로 결국 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c15bc5f538aa94ff9d36f2c463553e37bffffa8" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 그 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 고유 키와 함께의 순서로 결국 반복되는 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Iterable%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="41524b28b32f1890886788ed586175d793500478" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 그 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍&lt;/a&gt; 고유 키와 함께의 순서로 결국 반복되는 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.sequences.Sequence%28%28kotlin.Pair%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%29%29%2Fpairs&quot;&gt;쌍의&lt;/a&gt; 순서.</target>
        </trans-unit>
        <trans-unit id="f1a276280301194297ba4dd69f82e32624b066f0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; array.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키가있는 이러한 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.Array((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 배열 의 순서로 마지막에 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="60a4b6ca8bf806aec99d136cb53e3d0881c0b238" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키가있는 이러한 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Iterable((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 수집 순서대로 마지막에 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1d13bbc3f9bab24f8a9c962714d64145931ced0" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; with unique keys are iterated in the end in the order of &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;pairs&lt;/a&gt; sequence.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 고유 키가있는 이러한 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 은 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.sequences.Sequence((kotlin.Pair((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))))/pairs&quot;&gt;쌍&lt;/a&gt; 순서 대로 끝에서 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="af1ab049b7a80d37b426b5189d29b3d33630f886" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 이 맵에서 누락 된 다른 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;맵의&lt;/a&gt; 항목은 해당 &lt;a href=&quot;plus#kotlin.collections%24plus%28kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%2C+kotlin.collections.Map%28%28kotlin.collections.plus.K%2C+kotlin.collections.plus.V%29%29%29%2Fmap&quot;&gt;맵&lt;/a&gt; 순서대로 끝까지 반복 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b1dd6b497b334d1c744c85f81ba4c2ff9742b26" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original map. Those entries of another &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt; that are missing in this map are iterated in the end in the order of that &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;map&lt;/a&gt;.</source>
          <target state="translated">반환 된 맵은 원래 맵의 항목 반복 순서를 유지합니다. 이 맵에서 누락 된 다른 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;맵의&lt;/a&gt; 항목은 해당 &lt;a href=&quot;plus#kotlin.collections%24plus(kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)),%20kotlin.collections.Map((kotlin.collections.plus.K,%20kotlin.collections.plus.V)))/map&quot;&gt;맵&lt;/a&gt; 의 순서대로 마지막에 반복 됩니다 .</target>
        </trans-unit>
        <trans-unit id="048dcd341f30e50bd04dda11327a4ef88e0d2612" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence.</source>
          <target state="translated">리턴 된 맵은 원래 순서의 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="bba2889b44a4cec09a40249a683767a797d71e14" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order of the original sequence. If any of two pairs would have the same key the last one gets added to the map.</source>
          <target state="translated">리턴 된 맵은 원래 순서의 항목 반복 순서를 유지합니다. 두 쌍 중 하나가 동일한 키를 가지면 마지막 키가 맵에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b48dc5da4ba5d84bf8f51570f1be30c9067ca36a" translate="yes" xml:space="preserve">
          <source>The returned map preserves the entry iteration order.</source>
          <target state="translated">리턴 된 맵은 항목 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d70c61d5fb5764eefc41a239b3b607225317f588" translate="yes" xml:space="preserve">
          <source>The returned sequence is constrained to be iterated only once.</source>
          <target state="translated">반환 된 시퀀스는 한 번만 반복되도록 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="a79b9e6a21565ad6033f2ab5027e737873a51569" translate="yes" xml:space="preserve">
          <source>The returned sequence is empty if this sequence contains less than two elements.</source>
          <target state="translated">이 시퀀스에 요소가 2 개 미만인 경우 반환 된 시퀀스가 ​​비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7927ae1e5106eaeb7bb0b0dc1138826c33d1919c" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="8e820b287237249236a403161f0b70ed17d391a2" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.Array%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="3daac3d7a93bd39f019e22a0fe48ced02c6896f9" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original array. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원래 배열의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.Array((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b2b309c05bb0df5183017b60bb11949ef16cec12" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original char sequence.</source>
          <target state="translated">리턴 된 세트는 원래 문자 순서의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="77b699621c7e191100bcd082c9accf071cd60f08" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection.</source>
          <target state="translated">반환 된 집합은 원본 컬렉션의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ed96aca660cbd3c3aee98cb1f013ac3448395f47" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원본 컬렉션의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union%28kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%2C+kotlin.collections.Iterable%28%28kotlin.collections.union.T%29%29%29%2Fother&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="c4910c50663c8a64b733d52ca426f65568fa0287" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original collection. Those elements of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection that are unique are iterated in the end in the order of the &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;other&lt;/a&gt; collection.</source>
          <target state="translated">반환 된 집합은 원래 컬렉션의 요소 반복 순서를 유지합니다. 의 그 요소 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 고유 한 컬렉션의 순서로 결국 반복되는 &lt;a href=&quot;union#kotlin.collections%24union(kotlin.collections.Iterable((kotlin.collections.union.T)),%20kotlin.collections.Iterable((kotlin.collections.union.T)))/other&quot;&gt;다른&lt;/a&gt; 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b556a6977dd4e71f20e303d7d9385040d75f0ac7" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original sequence.</source>
          <target state="translated">리턴 된 세트는 원래 순서의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="eddbfc5096c56b9aafbe04f2e54352a74a62ad62" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order of the original set.</source>
          <target state="translated">리턴 된 세트는 원래 세트의 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4e9b4d20ac671bfe117e4f28b0081ad091c327b5" translate="yes" xml:space="preserve">
          <source>The returned set preserves the element iteration order.</source>
          <target state="translated">리턴 된 세트는 요소 반복 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="3396cb9052521da9189bb354afe95f34735769fc" translate="yes" xml:space="preserve">
          <source>The returned time mark is more &lt;em&gt;early&lt;/em&gt; when the &lt;a href=&quot;minus#kotlin.time.TimeMark%24minus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is positive, and more &lt;em&gt;late&lt;/em&gt; when the &lt;a href=&quot;minus#kotlin.time.TimeMark%24minus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is negative.</source>
          <target state="translated">반환 시간 표시가 더 &lt;em&gt;일찍&lt;/em&gt; 때 &lt;a href=&quot;minus#kotlin.time.TimeMark%24minus(kotlin.time.Duration)/duration&quot;&gt;시간이&lt;/a&gt; 더 긍정적이고, &lt;em&gt;늦게&lt;/em&gt; 때 &lt;a href=&quot;minus#kotlin.time.TimeMark%24minus(kotlin.time.Duration)/duration&quot;&gt;기간은&lt;/a&gt; 부정적이다.</target>
        </trans-unit>
        <trans-unit id="b678653886184f25ddce12e87e8c3d50b1e6262c" translate="yes" xml:space="preserve">
          <source>The returned time mark is more &lt;em&gt;late&lt;/em&gt; when the &lt;a href=&quot;plus#kotlin.time.TimeMark%24plus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is positive, and more &lt;em&gt;early&lt;/em&gt; when the &lt;a href=&quot;plus#kotlin.time.TimeMark%24plus(kotlin.time.Duration)/duration&quot;&gt;duration&lt;/a&gt; is negative.</source>
          <target state="translated">반환 시간 표시가 더 &lt;em&gt;늦게&lt;/em&gt; 때 &lt;a href=&quot;plus#kotlin.time.TimeMark%24plus(kotlin.time.Duration)/duration&quot;&gt;시간이&lt;/a&gt; 더 긍정적이며, &lt;em&gt;초기&lt;/em&gt; 때 &lt;a href=&quot;plus#kotlin.time.TimeMark%24plus(kotlin.time.Duration)/duration&quot;&gt;기간은&lt;/a&gt; 부정적이다.</target>
        </trans-unit>
        <trans-unit id="7c0e13333db8789388b9d52adff49d100d5cf6ca" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;sinh(y) == x&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;y&lt;/code&gt; 되도록 &lt;code&gt;sinh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0a819fc71728e449a1fa0a52b2d805fcb67dfe6" translate="yes" xml:space="preserve">
          <source>The returned value is &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;tanh(y) == x&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;y&lt;/code&gt; 되도록 &lt;code&gt;tanh(y) == x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38db1bb7310932e868d4c70216856f90e11179f2" translate="yes" xml:space="preserve">
          <source>The returned value is positive &lt;code&gt;y&lt;/code&gt; such that &lt;code&gt;cosh(y) == x&lt;/code&gt;.</source>
          <target state="translated">반환 값은 양수 &lt;code&gt;y&lt;/code&gt; 이므로 &lt;code&gt;cosh(y) == x&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09ad6f6bfed71caa855b5d5a6e4efd57371809c7" translate="yes" xml:space="preserve">
          <source>The returned value is presented in the format &lt;code&gt;PThHmMs.fS&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; are the integer components of this duration (see &lt;a href=&quot;to-components&quot;&gt;toComponents&lt;/a&gt;) and &lt;code&gt;f&lt;/code&gt; is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either 0, 3, 6, or 9 decimal digits.</source>
          <target state="translated">반환 된 값은 &lt;code&gt;PThHmMs.fS&lt;/code&gt; 형식으로 표시됩니다. 여기서 &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; 는이 기간의 정수 구성 요소 ( &lt;a href=&quot;to-components&quot;&gt;toComponents&lt;/a&gt; 참조 )이고 &lt;code&gt;f&lt;/code&gt; 는 초의 소수 부분입니다. 값의 둥근 정도에 따라 소수 부분은 0, 3, 6 또는 9 개의 십진수로 형식화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92462ffebca930d13f4cb4aaee4b7842f4ea14de" translate="yes" xml:space="preserve">
          <source>The returned value of a &lt;em&gt;try&lt;/em&gt;-expression is either the last expression in the &lt;em&gt;try&lt;/em&gt; block or the last expression in the &lt;em&gt;catch&lt;/em&gt; block (or blocks). Contents of the &lt;em&gt;finally&lt;/em&gt; block do not affect the result of the expression.</source>
          <target state="translated">&lt;em&gt;try&lt;/em&gt; -expression 의 리턴 값은 &lt;em&gt;try&lt;/em&gt; 블록의 마지막 표현식 이거나 &lt;em&gt;catch&lt;/em&gt; 블록 (또는 블록) 의 마지막 표현식입니다 . &lt;em&gt;finally&lt;/em&gt; 블록의 내용은 표현식 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="261319d8fec52739ec6c832665ae3f7dbd0e5025" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin 클래스 계층의 루트 모든 Kotlin 클래스에는 &lt;a href=&quot;-any/index#kotlin.Any&quot;&gt;Any&lt;/a&gt; 가 수퍼 클래스로 있습니다.</target>
        </trans-unit>
        <trans-unit id="a55ae833319a2f8e509e5aee918452e19eb747a8" translate="yes" xml:space="preserve">
          <source>The root of the Kotlin class hierarchy. Every Kotlin class has &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; as a superclass.</source>
          <target state="translated">Kotlin 클래스 계층의 루트 모든 Kotlin 클래스에는 &lt;a href=&quot;index#kotlin.Any&quot;&gt;Any&lt;/a&gt; 가 수퍼 클래스로 있습니다.</target>
        </trans-unit>
        <trans-unit id="98512a74a1640b8252b93eb9be999aab21267c59" translate="yes" xml:space="preserve">
          <source>The runner will set the value for the property system.path.macro.KOTLIN.BUNDLED to the correct one based on the path settings from the IntelliJ IDEA project. However this value needs to be defined in TeamCity (and can be set to any value). Therefore we need to define it as a system variable.</source>
          <target state="translated">러너는 system.path.macro.KOTLIN.BUNDLED 속성의 값을 IntelliJ IDEA 프로젝트의 경로 설정에 따라 올바른 값으로 설정합니다. 그러나이 값은 TeamCity에서 정의해야하며 임의의 값으로 설정할 수 있습니다. 따라서 시스템 변수로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="578262526068b614504d1b18d76cf8dea19e1504" translate="yes" xml:space="preserve">
          <source>The same is available for maps with the functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt;&lt;code&gt;mapOf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt;&lt;code&gt;mutableMapOf()&lt;/code&gt;&lt;/a&gt;. The map's keys and values are passed as &lt;code&gt;Pair&lt;/code&gt; objects (usually created with &lt;code&gt;to&lt;/code&gt; infix function).</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/map-of&quot;&gt; &lt;code&gt;mapOf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/mutable-map-of&quot;&gt; &lt;code&gt;mutableMapOf()&lt;/code&gt; &lt;/a&gt; 함수가있는 맵에서도 동일하게 사용할 수 있습니다 . 지도의 키와 값은 &lt;code&gt;Pair&lt;/code&gt; 객체 로 전달됩니다 (보통 함수를 사용 &lt;code&gt;to&lt;/code&gt; 생성 ).</target>
        </trans-unit>
        <trans-unit id="25f5c97c541192ff226fb77118f20b9141f29a81" translate="yes" xml:space="preserve">
          <source>The same rules are used by the Kotlin/Native compiler to generate the &lt;code&gt;.h&lt;/code&gt; file for all platforms.</source>
          <target state="translated">Kotlin / Native 컴파일러 는 모든 플랫폼에 대해 &lt;code&gt;.h&lt;/code&gt; 파일 을 생성하기 위해 동일한 규칙을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="dac2ac98305c82e23b60095cae0d9b066592bfa3" translate="yes" xml:space="preserve">
          <source>The same set of functions (but without constants) is also available for &lt;code&gt;Float&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;Float&lt;/code&gt; 인수 에도 동일한 함수 세트 (상수는 없음)를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd6887219148439be70535c83e0ab200b27625e" translate="yes" xml:space="preserve">
          <source>The same syntax can be used to annotate the entire file. To do this, put an annotation with the target &lt;code&gt;file&lt;/code&gt; at the top level of a file, before the package directive or before all imports if the file is in the default package:</source>
          <target state="translated">동일한 구문을 사용하여 전체 파일에 주석을 달 수 있습니다. 이렇게하려면 , 파일이 기본 패키지에있는 경우, 파일의 최상위 레벨, 패키지 지시문 앞 또는 모든 가져 오기 전에 대상 &lt;code&gt;file&lt;/code&gt; 에 주석을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ae227fcecaec9d7de3afec1996267608672f87b" translate="yes" xml:space="preserve">
          <source>The same syntax with omitted type arguments can be used for casts that do not take type arguments into account: &lt;code&gt;list as ArrayList&lt;/code&gt;.</source>
          <target state="translated">형식 인수를 고려하지 않은 캐스트에 대해서는 형식 인수가 생략 된 동일한 구문을 사용할 수 있습니다. &lt;code&gt;list as ArrayList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="998fefac425fa7727b709de3b80c938ce507ca90" translate="yes" xml:space="preserve">
          <source>The same trick applies when we need to have a property &lt;code&gt;x&lt;/code&gt; alongside with a function &lt;code&gt;getX()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;getX()&lt;/code&gt; 함수와 함께 &lt;code&gt;x&lt;/code&gt; 속성이 필요한 경우에도 동일한 트릭이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7028478d43f0e9046e167eadedccdd38efaac612" translate="yes" xml:space="preserve">
          <source>The same type parameter can be used in both covariant and contravariant projections (because it's the generic classes that are being projected, not the type parameter):</source>
          <target state="translated">공변량 및 반 변량 예측에 동일한 유형 매개 변수를 사용할 수 있습니다 (유형 매개 변수가 아닌 투영되는 일반 클래스이므로).</target>
        </trans-unit>
        <trans-unit id="e34374077b9198e942d005d02c16935775597fa6" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">결과의 스케일의 스케일과 동일하다 &lt;code&gt;this&lt;/code&gt; (divident) 및 라운딩 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; 라운딩 모드를 사용한다.</target>
        </trans-unit>
        <trans-unit id="862c489ca779c92aa7c1ebb24e7220c5850ae722" translate="yes" xml:space="preserve">
          <source>The scale of the result is the same as the scale of &lt;code&gt;this&lt;/code&gt; (divident), and for rounding the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; rounding mode is used.</source>
          <target state="translated">결과의 스케일은 &lt;code&gt;this&lt;/code&gt; (나누기) 스케일과 동일 하며 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/math/RoundingMode.html#HALF_EVEN&quot;&gt;RoundingMode.HALF_EVEN&lt;/a&gt; 반올림 모드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f22bffdb314393bc05bae9820f09e84c2f28f7a7" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4a3f3df589995633decc0a7530a1bb032d855ae5" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="a36f2feb54110b2ee9d15c70833427be6cae37ba" translate="yes" xml:space="preserve">
          <source>The scope for yielding values of a &lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; or an &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator&lt;/a&gt;, provides &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; and &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; suspension functions.</source>
          <target state="translated">&lt;a href=&quot;../../kotlin.sequences/-sequence/index&quot;&gt;Sequence&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin.collections/-iterator/index#kotlin.collections.Iterator&quot;&gt;Iterator의&lt;/a&gt; 값을 산출하는 범위 는 &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield&quot;&gt;yield&lt;/a&gt; 및 &lt;a href=&quot;../../kotlin.sequences/-sequence-scope/yield-all&quot;&gt;yieldAll&lt;/a&gt; 서스펜션 함수를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f47c36946d42e828300cda7cb035fe509918aa59" translate="yes" xml:space="preserve">
          <source>The scope functions differ by the result they return:</source>
          <target state="translated">범위 함수는 반환 결과에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8f4977d6e6dad61eba46e51272eff7452a6f78a7" translate="yes" xml:space="preserve">
          <source>The scope functions do not introduce any new technical capabilities, but they can make your code more concise and readable.</source>
          <target state="translated">스코프 함수는 새로운 기술 기능을 도입하지 않지만 코드를보다 간결하고 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84a98a8ab59f4886f0e69aee2d9364d4d099205" translate="yes" xml:space="preserve">
          <source>The second coroutine has computed its value and disappeared.</source>
          <target state="translated">두 번째 코 루틴은 그 값을 계산하고 사라졌습니다.</target>
        </trans-unit>
        <trans-unit id="76e57d4d84961d41b1ec0ed92b3d75452ff7d775" translate="yes" xml:space="preserve">
          <source>The second coroutine is calculating the &lt;code&gt;a&lt;/code&gt; value &amp;ndash; it has the &lt;strong&gt;RUNNING&lt;/strong&gt; status.</source>
          <target state="translated">두 번째 코 루틴은 &lt;code&gt;a&lt;/code&gt; 값을 계산하고 있으며 &lt;strong&gt;RUNNING&lt;/strong&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="5f41bf24b11179244ce6543e55a837627d8700cb" translate="yes" xml:space="preserve">
          <source>The second line is the &lt;code&gt;headerFilter&lt;/code&gt;. This is used to denote what exactly we want included. In C, when one file references another file with the &lt;code&gt;#include&lt;/code&gt; directive, all the headers are also included. Sometimes this may not be needed, and we can use this parameter, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;using glob patterns&lt;/a&gt;, to fine tune things. Note, that &lt;code&gt;headerFilter&lt;/code&gt; is an optional argument and mostly only used when the library we're using is being installed as a system library, and we do not want to fetch external dependencies (such as system &lt;code&gt;stdint.h&lt;/code&gt; header) into our interop library. It may be important for both optimizing the library size and fixing potential conflicts between the system and the Kotlin/Native provided compilation environment.</source>
          <target state="translated">두 번째 줄은 &lt;code&gt;headerFilter&lt;/code&gt; 입니다. 이것은 정확히 우리가 포함하고 싶은 것을 나타내는 데 사용됩니다. C에서 한 파일이 &lt;code&gt;#include&lt;/code&gt; 지시문으로 다른 파일을 참조 하면 모든 헤더도 포함됩니다. 때때로 이것은 필요하지 않을 수 있으며, &lt;a href=&quot;https://en.wikipedia.org/wiki/Glob_(programming)&quot;&gt;glob 패턴을&lt;/a&gt; 사용하여이 매개 변수를 사용하여 사물을 미세 조정할 수 있습니다. 참고 것을 &lt;code&gt;headerFilter&lt;/code&gt; 는 선택적 인수이며, 대부분은 단지 우리가 사용하고있는 라이브러리가 시스템 라이브러리로 설치하는 경우에 사용, 우리는 (예 : 시스템과 같은 외부 종속성을 가져하지 않으 &lt;code&gt;stdint.h&lt;/code&gt; 의 우리의 상호 운용성 라이브러리에 헤더를). 라이브러리 크기를 최적화하고 시스템과 Kotlin / Native 제공 컴파일 환경 간의 잠재적 충돌을 수정하는 것이 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="840619ade32a5f33b95550212b369e6072d8ca9d" translate="yes" xml:space="preserve">
          <source>The second list contains the second elements.</source>
          <target state="translated">두 번째 목록에는 두 번째 요소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="61c6cf9e9e7f1d565d89fe5986da63f4fbcd432b" translate="yes" xml:space="preserve">
          <source>The second observation, is that &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; gets immediately selected when the channel is already closed.</source>
          <target state="translated">두 번째 관찰 은 채널이 이미 닫혀 있으면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/on-receive-or-null.html&quot;&gt;onReceiveOrNull&lt;/a&gt; 이 즉시 선택 된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="90bb330cf5e09011380c337ab5bbdf9ebc55c7f5" translate="yes" xml:space="preserve">
          <source>The second step is to configure the framework search path of the produced binary. It is also known as &lt;code&gt;rpath&lt;/code&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;run-time search path&lt;/a&gt;. The binary uses the path to look for the required frameworks. We do not recommend installing additional frameworks to the OS if it is not needed. We should understand the layout of our future application, for example, we may have the &lt;code&gt;Frameworks&lt;/code&gt; folder under the application bundle with all the frameworks we use. The &lt;code&gt;@rpath&lt;/code&gt; parameter can be configured in Xcode. We need to open the &lt;em&gt;project&lt;/em&gt; configuration and find the &lt;code&gt;Runpath Search Paths&lt;/code&gt; section. Here we specify the relative path to the compiled framework.</source>
          <target state="translated">두 번째 단계는 생성 된 바이너리의 프레임 워크 검색 경로를 구성하는 것입니다. &lt;code&gt;rpath&lt;/code&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rpath&quot;&gt;런타임 검색 경로&lt;/a&gt; 라고도 합니다 . 바이너리는 경로를 사용하여 필요한 프레임 워크를 찾습니다. 필요하지 않은 경우 추가 프레임 워크를 OS에 설치하지 않는 것이 좋습니다. 예를 들어, 향후 응용 프로그램의 레이아웃을 이해해야합니다. 예를 들어, 사용하는 모든 프레임 워크와 함께 응용 프로그램 번들 아래에 &lt;code&gt;Frameworks&lt;/code&gt; 폴더 가있을 수 있습니다. &lt;code&gt;@rpath&lt;/code&gt; 의 파라미터 엑스 코드로 구성 될 수있다. &lt;em&gt;프로젝트&lt;/em&gt; 구성 을 열고 &lt;code&gt;Runpath Search Paths&lt;/code&gt; 섹션을 찾아야합니다 . 여기서는 컴파일 된 프레임 워크의 상대 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="654406bf07807fb9a1c468fda5253d223f604a77" translate="yes" xml:space="preserve">
          <source>The second step is to then include the framework path into the &lt;code&gt;Framework Search Paths&lt;/code&gt; block of the &lt;code&gt;Build Settings&lt;/code&gt; section of the &lt;em&gt;target&lt;/em&gt; configuration page. It is possible to use &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; macro to simplify the setup.</source>
          <target state="translated">두 번째 단계는 &lt;em&gt;대상&lt;/em&gt; 구성 페이지 의 &lt;code&gt;Build Settings&lt;/code&gt; 섹션에있는 &lt;code&gt;Framework Search Paths&lt;/code&gt; 블록에 프레임 워크 경로를 포함시키는 것 입니다. 사용할 수 있습니다 &lt;code&gt;$(PROJECT_DIR)&lt;/code&gt; 설정을 단순화하기 위해 매크로를.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e3a3f25c81d64436deec2668dbca688024cd76" translate="yes" xml:space="preserve">
          <source>The second way is using typed getters. These getters allow one to access a binary of a certain type by its name prefix and build type.</source>
          <target state="translated">두 번째 방법은 형식화 된 게터를 사용하는 것입니다. 이 게터를 사용하면 이름 접두사 및 빌드 유형으로 특정 유형의 이진 파일에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="827737115fbde8c1114cdac2570a8c2c25e8999d" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">순서는 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed로&lt;/a&gt; 시작할 때마다 여러 번 반복 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc73d4e6f9fffbb0e65e07b8a9240c6689985bdd" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times, each time starting with &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt;.</source>
          <target state="translated">시퀀스는 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed로&lt;/a&gt; 시작할 때마다 여러 번 반복 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0eda5b13d201be08982eef0e6ce47fb43644a540" translate="yes" xml:space="preserve">
          <source>The sequence can be iterated multiple times.</source>
          <target state="translated">시퀀스는 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a85208253c6224f238363151292bff48ddafdf4" translate="yes" xml:space="preserve">
          <source>The sequence can be potentially infinite.</source>
          <target state="translated">순서는 잠재적으로 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5675a51efa9f06e75cacd0d5cc4fa5944cc8f4" translate="yes" xml:space="preserve">
          <source>The sequence of values returned by the given iterator can be potentially infinite.</source>
          <target state="translated">주어진 반복자가 반환 한 값의 시퀀스는 잠재적으로 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d79c1f34f116fdb6c923fac302558f761c71524" translate="yes" xml:space="preserve">
          <source>The sequence operations can be classified into the following groups regarding their state requirements:</source>
          <target state="translated">시퀀스 작업은 상태 요구 사항과 관련하여 다음 그룹으로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30c4d2821891f6cd1d6f9f4ff92091f8670df4f6" translate="yes" xml:space="preserve">
          <source>The sequence processing goes like this:</source>
          <target state="translated">시퀀스 처리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="037cfea620d6aaba99a768d063c28b857dfd0b60" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값 이 발생할 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.Function0%28%28kotlin.sequences.generateSequence.T%29%29%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2FseedFunction&quot;&gt;seedFunction의&lt;/a&gt; 반환 &lt;code&gt;null&lt;/code&gt; , 빈 시퀀스를 생성한다.</target>
        </trans-unit>
        <trans-unit id="6f1a48a2bbbc690466820f3b0f0b43bc4de3e6e5" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값 이 발생할 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence%28kotlin.sequences.generateSequence.T%2C+kotlin.Function1%28%28kotlin.sequences.generateSequence.T%2C+kotlin.sequences.generateSequence.T%29%29%29%2Fseed&quot;&gt;씨앗&lt;/a&gt; 이다 &lt;code&gt;null&lt;/code&gt; 빈 시퀀스가 생성된다.</target>
        </trans-unit>
        <trans-unit id="7f85b3586f825638607e86e68f4e2c3390aaa658" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction&lt;/a&gt; returns &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값을 만날 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.Function0((kotlin.sequences.generateSequence.T?)),%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seedFunction&quot;&gt;seedFunction의&lt;/a&gt; 반환 &lt;code&gt;null&lt;/code&gt; , 빈 시퀀스를 생성한다.</target>
        </trans-unit>
        <trans-unit id="2bd1e283bb0d03da60d7adf31bcae11b19146a2e" translate="yes" xml:space="preserve">
          <source>The sequence produces values until it encounters first &lt;code&gt;null&lt;/code&gt; value. If &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;seed&lt;/a&gt; is &lt;code&gt;null&lt;/code&gt;, an empty sequence is produced.</source>
          <target state="translated">시퀀스는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값을 만날 때까지 값을 생성합니다 . 경우 &lt;a href=&quot;generate-sequence#kotlin.sequences%24generateSequence(kotlin.sequences.generateSequence.T?,%20kotlin.Function1((kotlin.sequences.generateSequence.T,%20kotlin.sequences.generateSequence.T?)))/seed&quot;&gt;씨앗&lt;/a&gt; 이다 &lt;code&gt;null&lt;/code&gt; 빈 시퀀스가 생성된다.</target>
        </trans-unit>
        <trans-unit id="f129e3ce5b36d66a5d5fd7f643fe14c7cd5cdbca" translate="yes" xml:space="preserve">
          <source>The sequential nature of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html&quot;&gt;flatMapConcat&lt;/a&gt; is clearly seen in the output:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html&quot;&gt;flatMapConcat&lt;/a&gt; 의 순차적 특성은 출력에서 명확하게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a3082b192dc0701c42da2f86e13f788df24a0f1" translate="yes" xml:space="preserve">
          <source>The set of all possible types that can be substituted for a given type parameter may be restricted by &lt;strong&gt;generic constraints&lt;/strong&gt;.</source>
          <target state="translated">주어진 형식 매개 변수로 대체 할 수있는 모든 가능한 형식 집합은 &lt;strong&gt;일반 제약 조건에&lt;/strong&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf0dd762f332fcd86a0727fbb8e23b4a1bb32f29" translate="yes" xml:space="preserve">
          <source>The set of options that were used to create this regular expression.</source>
          <target state="translated">이 정규 표현식을 작성하는 데 사용 된 옵션 세트.</target>
        </trans-unit>
        <trans-unit id="459759855b3639a06e88e0e2596d7493a847d411" translate="yes" xml:space="preserve">
          <source>The set of target platforms is defined by a multiplatform library author, and they should provide all of the platform-specific implementations for the library. Adding new targets for a multiplatform library at the consumer's side is not supported.</source>
          <target state="translated">대상 플랫폼 세트는 다중 플랫폼 라이브러리 작성자가 정의하며 라이브러리에 대한 모든 플랫폼 별 구현을 제공해야합니다. 소비자 측에서 멀티 플랫폼 라이브러리에 대한 새 대상 추가는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6c20544cd51f23d74f3a9b338c20b248ca719a1" translate="yes" xml:space="preserve">
          <source>The set passed as a receiver to the &lt;a href=&quot;build-set#kotlin.collections%24buildSet(kotlin.Function1((kotlin.collections.MutableSet((kotlin.collections.buildSet.E)),%20kotlin.Unit)))/builderAction&quot;&gt;builderAction&lt;/a&gt; is valid only inside that function. Using it outside of the function produces an unspecified behavior.</source>
          <target state="translated">&lt;a href=&quot;build-set#kotlin.collections%24buildSet(kotlin.Function1((kotlin.collections.MutableSet((kotlin.collections.buildSet.E)),%20kotlin.Unit)))/builderAction&quot;&gt;builderAction에&lt;/a&gt; 수신자로 전달 된 세트는 해당 함수 내에서만 유효합니다. 함수 외부에서 사용하면 지정되지 않은 동작이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cfae932c206b2b202a3e4b7250821be416b0151c" translate="yes" xml:space="preserve">
          <source>The set passed as a receiver to the &lt;a href=&quot;build-set#kotlin.collections%24buildSet(kotlin.Int,%20kotlin.Function1((kotlin.collections.MutableSet((kotlin.collections.buildSet.E)),%20kotlin.Unit)))/builderAction&quot;&gt;builderAction&lt;/a&gt; is valid only inside that function. Using it outside of the function produces an unspecified behavior.</source>
          <target state="translated">&lt;a href=&quot;build-set#kotlin.collections%24buildSet(kotlin.Int,%20kotlin.Function1((kotlin.collections.MutableSet((kotlin.collections.buildSet.E)),%20kotlin.Unit)))/builderAction&quot;&gt;builderAction에&lt;/a&gt; 수신자로 전달 된 세트는 해당 함수 내에서만 유효합니다. 함수 외부에서 사용하면 지정되지 않은 동작이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="488655893b603c994560325ea4e7b1458229763b" translate="yes" xml:space="preserve">
          <source>The setter of this mutable property, used to change the value of the property.</source>
          <target state="translated">속성 값을 변경하는 데 사용되는이 가변 속성의 setter입니다.</target>
        </trans-unit>
        <trans-unit id="67fe2f456972c4ac12399f4f27262af0c978820f" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;greet()&lt;/code&gt; is &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; because it's a function on &lt;code&gt;Person&lt;/code&gt; that takes a &lt;code&gt;String&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">의 서명 &lt;code&gt;greet()&lt;/code&gt; 입니다 &lt;code&gt;KFunction2&amp;lt;Person, String, String&amp;gt;&lt;/code&gt; 이 켜져 함수이기 때문에 &lt;code&gt;Person&lt;/code&gt; 소요 &lt;code&gt;String&lt;/code&gt; 과 리턴 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e351be319f91b0a3ca4911e8fb9da8a9528097a" translate="yes" xml:space="preserve">
          <source>The signature of a member function or an &lt;a href=&quot;extension-functionsproperties&quot;&gt;extension function&lt;/a&gt; begins with a &lt;em&gt;receiver&lt;/em&gt;: the type upon which the function can be invoked. For example, the signature of &lt;code&gt;toString()&lt;/code&gt; is &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; - it can be called on any non-null object (the receiver), it takes no parameters, and it returns a &lt;code&gt;String&lt;/code&gt;. It is possible to write a lambda function with such a signature - this is called a &lt;em&gt;function literal with receiver&lt;/em&gt;, and is extremely useful for building DSLs.</source>
          <target state="translated">멤버 함수 또는 &lt;a href=&quot;extension-functionsproperties&quot;&gt;확장 함수&lt;/a&gt; 의 서명은 &lt;em&gt;수신자 (&lt;/em&gt; 함수를 호출 할 수있는 유형)로 시작합니다 . 예를 들어 &lt;code&gt;toString()&lt;/code&gt; 의 서명 은 &lt;code&gt;Any.() -&amp;gt; String&lt;/code&gt; -null이 아닌 객체 (수신자)에서 호출 할 수 있으며 매개 변수를 사용하지 않고 &lt;code&gt;String&lt;/code&gt; 을 반환합니다 . 이러한 서명으로 람다 함수를 작성할 수 있습니다.이를 &lt;em&gt;수신자와 함께 함수 리터럴&lt;/em&gt; 이라고하며 DSL을 작성하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="aadf52185468aa82855f792813cb9471782e9fa0" translate="yes" xml:space="preserve">
          <source>The signature of the overriding function must exactly match the overridden one, except that the return type in the overriding function may be a subtype of the return type of the overridden function.</source>
          <target state="translated">재정의 함수의 반환 유형이 재정의 된 함수의 반환 유형의 하위 유형일 수 있다는 점을 제외하고 재정의 함수의 서명은 재정의 된 서명과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb5cfcfa1d9e07364a5b05687e8945f6f792b6b5" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is a class of an anonymous object).</source>
          <target state="translated">소스 코드에 선언 된 클래스의 단순 이름 또는 클래스에 이름이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다 (예 : 익명 객체의 클래스 인 경우).</target>
        </trans-unit>
        <trans-unit id="0290c571ea3c6c1d4ef5f1279658ebad7901a082" translate="yes" xml:space="preserve">
          <source>The simple name of the class as it was declared in the source code, or &lt;code&gt;null&lt;/code&gt; if the class has no name (if, for example, it is an anonymous object literal).</source>
          <target state="translated">소스 코드에서 선언 된 클래스의 단순 이름이거나 클래스에 이름이없는 경우 &lt;code&gt;null&lt;/code&gt; 입니다 (예 : 익명의 객체 리터럴 인 경우).</target>
        </trans-unit>
        <trans-unit id="4a78d65e883965ba15ad1eec8e7ccc645ad6c9f8" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there a two build types available: &lt;code&gt;DEBUG&lt;/code&gt; (produces a not optimized binary with a debug information) and &lt;code&gt;RELEASE&lt;/code&gt; (produces an optimized binary without debug information). Consequently the following snippet creates two executable binaries: debug and release.</source>
          <target state="translated">가장 간단한 버전은 추가 매개 변수가 필요하지 않으며 각 빌드 유형마다 하나의 바이너리를 만듭니다. 현재 두 가지 빌드 유형이 있습니다. &lt;code&gt;DEBUG&lt;/code&gt; (디버그 정보가있는 최적화되지 않은 이진 파일을 생성 함 ) 및 &lt;code&gt;RELEASE&lt;/code&gt; (디버그 정보가없는 최적화 된 이진 파일을 생성 함). 결과적으로 다음 스 니펫은 디버그 및 릴리스라는 두 개의 실행 가능 바이너리를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4d355ad220db74fe2658767f0c23a71e3df3dd7a" translate="yes" xml:space="preserve">
          <source>The simplest version doesn't require any additional parameters and creates one binary for each build type. Currently there two build types available:</source>
          <target state="translated">가장 간단한 버전은 추가 매개 변수가 필요하지 않으며 각 빌드 유형에 대해 하나의 바이너리를 생성합니다. 현재 두 가지 빌드 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e7b9b0dd8fa90a8e9f2b4ea99f92d60e815b8b9" translate="yes" xml:space="preserve">
          <source>The single immutable C value. It is self-contained and doesn't depend on native memory.</source>
          <target state="translated">불변의 단일 C 값 자체 포함되어 있으며 기본 메모리에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8e685c40e1d41520bbfb52a9a2cf6ce5cf4d2b1" translate="yes" xml:space="preserve">
          <source>The single-parent rule often becomes too limiting, as you'll often find commonalities between classes in different branches of a class hierarchy. These commonalities can be expressed in &lt;em&gt;interfaces&lt;/em&gt;.</source>
          <target state="translated">단일 부모 규칙은 클래스 계층 구조의 서로 다른 브랜치에서 클래스 사이에 공통점이 있기 때문에 종종 너무 제한됩니다. 이러한 공통성은 &lt;em&gt;인터페이스&lt;/em&gt; 로 표현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27135a00f55fa78c13aaad4e34fb656e821fa145" translate="yes" xml:space="preserve">
          <source>The smallest time unit is &lt;a href=&quot;-n-a-n-o-s-e-c-o-n-d-s#kotlin.time.DurationUnit.NANOSECONDS&quot;&gt;NANOSECONDS&lt;/a&gt; and the largest is &lt;a href=&quot;-d-a-y-s#kotlin.time.DurationUnit.DAYS&quot;&gt;DAYS&lt;/a&gt;, which corresponds to exactly 24 &lt;a href=&quot;-h-o-u-r-s#kotlin.time.DurationUnit.HOURS&quot;&gt;HOURS&lt;/a&gt;.</source>
          <target state="translated">가장 작은 시간 단위는 &lt;a href=&quot;-n-a-n-o-s-e-c-o-n-d-s#kotlin.time.DurationUnit.NANOSECONDS&quot;&gt;NANOSECONDS&lt;/a&gt; 이고 가장 큰 단위는 &lt;a href=&quot;-d-a-y-s#kotlin.time.DurationUnit.DAYS&quot;&gt;DAYS&lt;/a&gt; 로 정확히 24 &lt;a href=&quot;-h-o-u-r-s#kotlin.time.DurationUnit.HOURS&quot;&gt;시간에&lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ad2d029e0bf9000bbb670b32b9cfbfdfb5c64ee2" translate="yes" xml:space="preserve">
          <source>The solution is a &lt;em&gt;delegated property&lt;/em&gt;, which allows you to specify the behavior of getting and setting a property (somewhat similar to implementing &lt;code&gt;__getattribute__()&lt;/code&gt; and &lt;code&gt;__setattribute__()&lt;/code&gt; in Python, but for one property at a time).</source>
          <target state="translated">해결책은 &lt;em&gt;위임 된 속성으로&lt;/em&gt; , &lt;em&gt;속성&lt;/em&gt; 을 가져오고 설정하는 동작을 지정할 수 있습니다 &lt;code&gt;__setattribute__()&lt;/code&gt; 파이썬에서 &lt;code&gt;__getattribute__()&lt;/code&gt; 및 __setattribute __ () 구현과 비슷 하지만 한 번에 하나의 속성).</target>
        </trans-unit>
        <trans-unit id="02ba30e8a0350e3498389f6bdcc51b4d923322f5" translate="yes" xml:space="preserve">
          <source>The solution is to mark the targets with a custom attribute, which is taken into account by Gradle during dependency resolution. This, however, must be done on both the library author and the consumer sides, and it's the library author's responsibility to communicate the attribute and its possible values to the consumers.</source>
          <target state="translated">해결책은 대상을 사용자 지정 특성으로 표시하는 것입니다.이 특성은 종속성 해결 중에 Gradle에서 고려됩니다. 그러나 이것은 라이브러리 작성자와 소비자 측 모두에서 수행되어야하며 속성과 가능한 값을 소비자에게 전달하는 것은 라이브러리 작성자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="4ce364ecc8aca93a0b9f937690067d3d1f6fcb4e" translate="yes" xml:space="preserve">
          <source>The sort is &lt;em&gt;stable&lt;/em&gt;. It means that equal elements preserve their order relative to each other after sorting.</source>
          <target state="translated">정렬이 &lt;em&gt;안정적&lt;/em&gt; 입니다. 즉, 동일한 요소가 정렬 후 서로에 대한 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="563e0866ee26fde4dae779a523cc71b4cbb6977d" translate="yes" xml:space="preserve">
          <source>The source set names are case-sensitive. When referring to a default source set by its name, make sure the name prefix matches a target's name, for example, a source set &lt;code&gt;iosX64Main&lt;/code&gt; for a target &lt;code&gt;iosX64&lt;/code&gt;.</source>
          <target state="translated">소스 세트 이름은 대소 문자를 구분합니다. 이름으로 기본 소스 세트를 참조 할 때 이름 &lt;code&gt;iosX64Main&lt;/code&gt; 두부가 대상의 이름과 일치하는지 확인하십시오 (예 : 대상 &lt;code&gt;iosX64&lt;/code&gt; 의 소스 세트 iosX64Main) .</target>
        </trans-unit>
        <trans-unit id="11b3468dd6e9b05386099434c4ca46b0c2547522" translate="yes" xml:space="preserve">
          <source>The source sets DSL can be used to define these connections between the source sets:</source>
          <target state="translated">소스 세트 DSL을 사용하여 소스 세트 간의 이러한 연결을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee1552c884a6b1c888ad99542230488f493bca7" translate="yes" xml:space="preserve">
          <source>The source sets are configured within a &lt;code&gt;sourceSets { ... }&lt;/code&gt; block of the &lt;code&gt;kotlin { ... }&lt;/code&gt; extension:</source>
          <target state="translated">소스 세트는 &lt;code&gt;kotlin { ... }&lt;/code&gt; 확장자 의 &lt;code&gt;sourceSets { ... }&lt;/code&gt; 블록 내에 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4cf592997fcfc68c560b9248ead3349afe2d7c1" translate="yes" xml:space="preserve">
          <source>The specification of the requirements to the delegated object can be found &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">위임 된 객체에 대한 요구 사항의 사양은 &lt;a href=&quot;delegated-properties#property-delegate-requirements&quot;&gt;아래에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d73e9a80f0bf586c373c77dd33cae5cc1f592da3" translate="yes" xml:space="preserve">
          <source>The specified arrays are also considered deeply equal if both are &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">지정된 배열도 둘 다 &lt;code&gt;null&lt;/code&gt; 인 경우 완전히 동일한 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="63949c8dfec16ede4c20d9d3cd58cdaf9f88fafe" translate="yes" xml:space="preserve">
          <source>The standard JavaDoc generation plugin (&lt;code&gt;maven-javadoc-plugin&lt;/code&gt;) does not support Kotlin code. To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">표준 JavaDoc 생성 플러그인 ( &lt;code&gt;maven-javadoc-plugin&lt;/code&gt; )은 Kotlin 코드를 지원하지 않습니다. Kotlin 프로젝트에 대한 문서를 생성하려면 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka를&lt;/a&gt; 사용하십시오 . 구성 지침 은 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-maven-plugin&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 . Dokka는 혼합 언어 프로젝트를 지원하며 표준 JavaDoc을 포함하여 여러 형식으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8d32cf58d6a52257e9ed55a0d5c90647cf240f" translate="yes" xml:space="preserve">
          <source>The standard library contains a group of extension functions that let you filter collections in a single call. These functions leave the original collection unchanged, so they are available for both &lt;a href=&quot;collections-overview#collection-types&quot;&gt;mutable and read-only&lt;/a&gt; collections. To operate the filtering result, you should assign it to a variable or chain the functions after filtering.</source>
          <target state="translated">표준 라이브러리에는 단일 호출에서 모음을 필터링 할 수있는 확장 기능 그룹이 포함되어 있습니다. 이러한 함수는 원본 컬렉션을 변경하지 않고 &lt;a href=&quot;collections-overview#collection-types&quot;&gt;변경 가능하고 읽기 전용&lt;/a&gt; 컬렉션 에 모두 사용할 수 있습니다 . 필터링 결과를 조작하려면 필터링 후 결과를 변수에 지정하거나 함수를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="64cd7cca211b28854215461360962734eb107f4c" translate="yes" xml:space="preserve">
          <source>The standard library defines a function named &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt;&lt;code&gt;asDynamic()&lt;/code&gt;&lt;/a&gt; which casts a value to the dynamic type. Given our previous example where we used jQuery to work with DOM elements, we can now combine this with &lt;code&gt;asDynamic()&lt;/code&gt; to then invoke &lt;code&gt;dataTable()&lt;/code&gt; on the result:</source>
          <target state="translated">표준 라이브러리는 값을 동적 유형으로 캐스팅하는 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.js/as-dynamic&quot;&gt; &lt;code&gt;asDynamic()&lt;/code&gt; &lt;/a&gt; 이라는 함수를 정의합니다 . jQuery를 사용하여 DOM 요소로 작업 한 이전 예를 &lt;code&gt;asDynamic()&lt;/code&gt; 이제이를 asDynamic () 과 결합 하여 결과에서 &lt;code&gt;dataTable()&lt;/code&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f57c9d3cc14b958c346235550397a3ba0b18486" translate="yes" xml:space="preserve">
          <source>The standard library in 1.4.0 includes a number of improvements in the API for string manipulation:</source>
          <target state="translated">1.4.0의 표준 라이브러리에는 문자열 조작을위한 API의 여러 개선 사항이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f92a5708c1e21664731222bd701621446c56d87" translate="yes" xml:space="preserve">
          <source>The standard library now provides a set of functions for element-by-element operations on arrays: comparison (&lt;code&gt;contentEquals&lt;/code&gt; and &lt;code&gt;contentDeepEquals&lt;/code&gt;), hash code calculation (&lt;code&gt;contentHashCode&lt;/code&gt; and &lt;code&gt;contentDeepHashCode&lt;/code&gt;), and conversion to a string (&lt;code&gt;contentToString&lt;/code&gt; and &lt;code&gt;contentDeepToString&lt;/code&gt;). They're supported both for the JVM (where they act as aliases for the corresponding functions in &lt;code&gt;java.util.Arrays&lt;/code&gt;) and for JS (where the implementation is provided in the Kotlin standard library).</source>
          <target state="translated">표준 라이브러리는 이제 비교 ( &lt;code&gt;contentEquals&lt;/code&gt; 및 &lt;code&gt;contentDeepEquals&lt;/code&gt; ), 해시 코드 계산 ( &lt;code&gt;contentHashCode&lt;/code&gt; 및 &lt;code&gt;contentDeepHashCode&lt;/code&gt; ) 및 문자열로 변환 ( &lt;code&gt;contentToString&lt;/code&gt; 및 &lt;code&gt;contentDeepToString&lt;/code&gt; )에 대한 요소 별 조작을위한 함수 세트를 제공합니다 . JVM ( &lt;code&gt;java.util.Arrays&lt;/code&gt; 의 해당 함수에 대한 별명으로 작동 ) 및 JS (구현이 Kotlin 표준 라이브러리에서 제공되는 경우) 모두에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4cd1337efd07a01ae50fb56677c92729c05a2ca9" translate="yes" xml:space="preserve">
          <source>The standard library provides &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt;. In most cases, though, named data classes are a better design choice, because they make the code more readable by providing meaningful names for properties.</source>
          <target state="translated">표준 라이브러리는 &lt;code&gt;Pair&lt;/code&gt; and &lt;code&gt;Triple&lt;/code&gt; 을 제공합니다 . 그러나 대부분의 경우 명명 된 데이터 클래스는 속성에 의미있는 이름을 제공하여 코드를 더 읽기 쉽게하기 때문에 더 나은 디자인 선택입니다.</target>
        </trans-unit>
        <trans-unit id="0fa7bf33e28a4e2133f3eb85b822f13a5861e747" translate="yes" xml:space="preserve">
          <source>The standard library provides us with a series of wrappers around DOM as well as functions to work with JavaScript, using static typing. What happens however when we want to use a library such as jQuery? Kotlin does not have its own &quot;header&quot; files for all the different libraries available on the JavaScript ecosystem however, TypeScript does. The &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;Definitely Typed repository&lt;/a&gt; provides us with a very large selection of header files.</source>
          <target state="translated">표준 라이브러리는 정적 타이핑을 사용하여 JavaScript를 다루는 함수뿐만 아니라 DOM에 대한 일련의 래퍼를 제공합니다. 그러나 jQuery와 같은 라이브러리를 사용하려면 어떻게됩니까? Kotlin에는 JavaScript 생태계에서 사용 가능한 모든 다른 라이브러리에 대한 자체 &quot;헤더&quot;파일이 없지만 TypeScript에는 있습니다. &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/&quot;&gt;확실히 입력 된 저장소는&lt;/a&gt; 헤더 파일의 매우 큰 선택을 우리에게 제공한다.</target>
        </trans-unit>
        <trans-unit id="5b02aa301d08018505c67b11eafce33e20430963" translate="yes" xml:space="preserve">
          <source>The standard library uses coroutines to support &lt;em&gt;lazily generated sequences&lt;/em&gt; with &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;yieldAll&lt;/code&gt; functions. In such a sequence, the block of code that returns sequence elements is suspended after each element has been retrieved, and resumed when the next element is requested. Here's an example:</source>
          <target state="translated">표준 라이브러리는 코 루틴을 사용 하여 &lt;code&gt;yield&lt;/code&gt; 및 &lt;code&gt;yieldAll&lt;/code&gt; 함수로 &lt;em&gt;느리게 생성 된 시퀀스&lt;/em&gt; 를 지원 합니다. 이러한 시퀀스에서 시퀀스 요소를 반환하는 코드 블록은 각 요소가 검색된 후 일시 중단되고 다음 요소가 요청되면 다시 시작됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd81d65292e2ed27e6a7bd7b3f70e04e3c6f5969" translate="yes" xml:space="preserve">
          <source>The status value in &lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; specifies how the compiler treats inappropriate usages of the annotated types in Kotlin (e.g. using a &lt;code&gt;@MyNullable&lt;/code&gt;-annotated type value as non-null):</source>
          <target state="translated">&lt;code&gt;@UnderMigration(status = ...)&lt;/code&gt; 의 상태 값 은 컴파일러가 Kotlin에서 어노테이션이있는 유형의 부적절한 사용법을 처리하는 방법을 지정합니다 (예 : &lt;code&gt;@MyNullable&lt;/code&gt; -어노테이션이있는 유형 값을 널이 아닌 것으로 사용).</target>
        </trans-unit>
        <trans-unit id="4dfa4a2af58e962d2e78195bb041069a8bfddba3" translate="yes" xml:space="preserve">
          <source>The step of the progression.</source>
          <target state="translated">진행의 단계.</target>
        </trans-unit>
        <trans-unit id="e2561323722fd466eed7e84734bba0e2d9a0a20e" translate="yes" xml:space="preserve">
          <source>The step value must be positive. If you need to count downwards, use the inclusive &lt;code&gt;downTo&lt;/code&gt;:</source>
          <target state="translated">단계 값은 양수 여야합니다. 아래로 계산해야하는 경우 포괄적 인 &lt;code&gt;downTo&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba5dcc36cf4e926283f2cf38c8b5b4a8a22b74ac" translate="yes" xml:space="preserve">
          <source>The subclass &lt;em&gt;inherits&lt;/em&gt; all members that exist in its superclass - both those that are directly defined in the superclass and the ones that the superclass itself has inherited. In this example, &lt;code&gt;Car&lt;/code&gt; contains the following members:</source>
          <target state="translated">서브 클래스 &lt;em&gt;는&lt;/em&gt; 수퍼 클래스에 존재하는 모든 멤버 (수퍼 클래스에 직접 정의 된 멤버와 수퍼 클래스 자체가 상속 한 멤버)를 모두 상속합니다. 이 예에서 &lt;code&gt;Car&lt;/code&gt; 는 다음 멤버를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9587208b56b71c873bb976ba7dd19e63565c1783" translate="yes" xml:space="preserve">
          <source>The substring from the input string captured by this match.</source>
          <target state="translated">이 일치에 의해 캡처 된 입력 문자열의 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ef9d4de4ce3f425feef1d92bfbe702742ff76fe2" translate="yes" xml:space="preserve">
          <source>The syntax is: &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt;. The expression after &lt;em&gt;by&lt;/em&gt; is the &lt;em&gt;delegate&lt;/em&gt;, because &lt;code&gt;get()&lt;/code&gt; (and &lt;code&gt;set()&lt;/code&gt;) corresponding to the property will be delegated to its &lt;code&gt;getValue()&lt;/code&gt; and &lt;code&gt;setValue()&lt;/code&gt; methods. Property delegates don&amp;rsquo;t have to implement any interface, but they have to provide a &lt;code&gt;getValue()&lt;/code&gt; function (and &lt;code&gt;setValue()&lt;/code&gt; &amp;mdash; for &lt;em&gt;var&lt;/em&gt;s). For example:</source>
          <target state="translated">구문은 &lt;code&gt;val/var &amp;lt;property name&amp;gt;: &amp;lt;Type&amp;gt; by &amp;lt;expression&amp;gt;&lt;/code&gt; 입니다. 속성에 해당하는 &lt;code&gt;get()&lt;/code&gt; (및 &lt;code&gt;set()&lt;/code&gt; )이 &lt;code&gt;getValue()&lt;/code&gt; 및 &lt;code&gt;setValue()&lt;/code&gt; 메소드에 &lt;em&gt;위임&lt;/em&gt; 되기 때문에 &lt;em&gt;by by&lt;/em&gt; 뒤의 표현식 은 &lt;em&gt;delegate&lt;/em&gt; 입니다. 부동산 대표는 인터페이스를 구현할 필요는 없지만, 그들은 제공해야 &lt;code&gt;getValue()&lt;/code&gt; 함수를 (와 &lt;code&gt;setValue()&lt;/code&gt; - 대한 &lt;em&gt;VAR&lt;/em&gt; 들). 예를 들면 다음과 같습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f8b0e5f27ed7447035e9e8912fa4868135e5b36" translate="yes" xml:space="preserve">
          <source>The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa.</source>
          <target state="translated">아래 표는 Kotlin 개념이 Swift / Objective-C에 매핑되고 그 반대의 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3a0f8ac6bab0154ecc68aecfaae3d29f58f2856b" translate="yes" xml:space="preserve">
          <source>The target's JAR task instead of &lt;code&gt;jar&lt;/code&gt; (for example, &lt;code&gt;jvmJar&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;jar&lt;/code&gt; 대신 대상의 JAR 작업 (예 : &lt;code&gt;jvmJar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="124f0b13dfdd24294f1739df4ba61c7845dc9b4c" translate="yes" xml:space="preserve">
          <source>The target's test task instead of &lt;code&gt;test&lt;/code&gt; (for example, &lt;code&gt;jvmTest&lt;/code&gt;).</source>
          <target state="translated">대신 대상의 테스트 작업 &lt;code&gt;test&lt;/code&gt; (예를 들어, &lt;code&gt;jvmTest&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="27aee67b81ecee081c926fb6403fc250a2669b58" translate="yes" xml:space="preserve">
          <source>The targets created from presets are added to the &lt;code&gt;kotlin.targets&lt;/code&gt; domain object collection, which can be used to access them by their names or configure all targets:</source>
          <target state="translated">사전 설정에서 생성 된 대상이 &lt;code&gt;kotlin.targets&lt;/code&gt; 도메인 객체 컬렉션에 추가되어 이름으로 액세스하거나 모든 대상을 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fee7dff3e4d6eadb637b39f376e9227a5981c25c" translate="yes" xml:space="preserve">
          <source>The targets of a multiplatform project are described in the corresponding blocks inside &lt;code&gt;kotlin&lt;/code&gt;, for example, &lt;code&gt;jvm&lt;/code&gt;, &lt;code&gt;android&lt;/code&gt;, &lt;code&gt;iosArm64&lt;/code&gt;. The complete list of available targets is the following:</source>
          <target state="translated">멀티 플랫폼 프로젝트의 대상은 &lt;code&gt;kotlin&lt;/code&gt; 내부의 해당 블록 ( 예 : &lt;code&gt;jvm&lt;/code&gt; , &lt;code&gt;android&lt;/code&gt; , &lt;code&gt;iosArm64&lt;/code&gt; )에 설명되어 있습니다. 사용 가능한 대상의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea834ff7223c20a4c037e26a9eaa3ee2e490ee75" translate="yes" xml:space="preserve">
          <source>The terminology is that &lt;code&gt;var&lt;/code&gt; declares a &lt;em&gt;mutable&lt;/em&gt; variable, and that &lt;code&gt;val&lt;/code&gt; declares a &lt;em&gt;read-only&lt;/em&gt; or &lt;em&gt;assign-once&lt;/em&gt; variable - so both kinds are called &lt;em&gt;variables&lt;/em&gt;.</source>
          <target state="translated">용어는 &lt;code&gt;var&lt;/code&gt; 가 &lt;em&gt;가변&lt;/em&gt; 변수를 선언하고 &lt;code&gt;val&lt;/code&gt; 이 &lt;em&gt;읽기 전용&lt;/em&gt; 또는 &lt;em&gt;한 번만 할당&lt;/em&gt; 변수를 선언 하므로 두 종류를 모두 &lt;em&gt;변수&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c1a93ffe9401881d7e0f5a7066475d9434f33d" translate="yes" xml:space="preserve">
          <source>The the &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;example project&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;https://github.com/ilmat192/kotlin-native-serialization-sample&quot;&gt;예제 프로젝트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8693d679cd999a259c3aef897e70bd0e78837fd" translate="yes" xml:space="preserve">
          <source>The third coroutine has the &lt;strong&gt;CREATED&lt;/strong&gt; status and isn&amp;rsquo;t calculating the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">세 번째 코 루틴은 &lt;strong&gt;CREATED&lt;/strong&gt; 상태이며 &lt;code&gt;b&lt;/code&gt; 값을 계산하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3144e358140798c41ce3b59dc5b4d63d3fba3f7" translate="yes" xml:space="preserve">
          <source>The third coroutine is calculating the value of &lt;code&gt;b&lt;/code&gt; &amp;ndash; it has the &lt;strong&gt;RUNNING&lt;/strong&gt; status.</source>
          <target state="translated">세 번째 코 루틴은 &lt;code&gt;b&lt;/code&gt; 의 값을 계산하고 있으며 &lt;strong&gt;RUNNING&lt;/strong&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="db0d4a97f9fddd6cc7f4a4e559ab92c9b243b3dc" translate="yes" xml:space="preserve">
          <source>The third option is for NPE-lovers: the not-null assertion operator (&lt;code&gt;!!&lt;/code&gt;) converts any value to a non-null type and throws an exception if the value is null. We can write &lt;code&gt;b!!&lt;/code&gt;, and this will return a non-null value of &lt;code&gt;b&lt;/code&gt; (e.g., a &lt;code&gt;String&lt;/code&gt; in our example) or throw an NPE if &lt;code&gt;b&lt;/code&gt; is null:</source>
          <target state="translated">세 번째 옵션은 NPE 애호가를위한 것입니다. Null이 아닌 어설 션 연산자 ( &lt;code&gt;!!&lt;/code&gt; )는 모든 값을 Null이 아닌 유형으로 변환하고 값이 null 인 경우 예외를 throw합니다. 우리는 &lt;code&gt;b!!&lt;/code&gt; 를 쓸 수있다 !! 이 경우 null이 아닌 값 &lt;code&gt;b&lt;/code&gt; (예 : &lt;code&gt;String&lt;/code&gt; 가 반환 되거나 &lt;code&gt;b&lt;/code&gt; 가 null 인 경우 NPE가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="328eee564065ef14869693e4097fdfb0bb1e1ca4" translate="yes" xml:space="preserve">
          <source>The three targets are created with the preset functions &lt;code&gt;jvm()&lt;/code&gt;, &lt;code&gt;js()&lt;/code&gt;, and &lt;code&gt;mingwX64()&lt;/code&gt; that provide some &lt;a href=&quot;#default-project-layout&quot;&gt;default configuration&lt;/a&gt;. There are presets for each of the &lt;a href=&quot;#supported-platforms&quot;&gt;supported platforms&lt;/a&gt;.</source>
          <target state="translated">세 가지 대상은 &lt;a href=&quot;#default-project-layout&quot;&gt;기본 구성&lt;/a&gt; 을 제공 하는 사전 설정 함수 &lt;code&gt;jvm()&lt;/code&gt; , &lt;code&gt;js()&lt;/code&gt; 및 &lt;code&gt;mingwX64()&lt;/code&gt; 됩니다. &lt;a href=&quot;#supported-platforms&quot;&gt;지원되는&lt;/a&gt; 각 플랫폼에 대한 사전 설정이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="865a447cbe3c80dc40999ce2ca6d480bd87143d3" translate="yes" xml:space="preserve">
          <source>The timeout event in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; is asynchronous with respect to the code running in its block and may happen at any time, even right before the return from inside of the timeout block. Keep this in mind if you open or acquire some resource inside the block that needs closing or release outside of the block.</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html&quot;&gt;withTimeout&lt;/a&gt; 의 시간 초과 이벤트는 해당 블록에서 실행중인 코드와 관련하여 비동기 적이며 시간 초과 블록 내부에서 반환되기 직전에 언제든지 발생할 수 있습니다. 블록 외부에서 닫거나 해제해야하는 블록 내부의 일부 리소스를 열거 나 획득하는 경우이를 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="04def297d18523cf309971345c57324bf9993c18" translate="yes" xml:space="preserve">
          <source>The title case of a character is usually the same as its upper case with several exceptions. The particular list of characters with the special title case form depends on the underlying platform.</source>
          <target state="translated">문자의 제목은 일반적으로 몇 가지 예외를 제외하고 대문자와 동일합니다. 특수 제목 케이스 형식의 특정 문자 목록은 기본 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="95397456cc9c821cee4e5e9e86873ae3bfa64d7a" translate="yes" xml:space="preserve">
          <source>The tutorial assumes you have prior knowledge of the &lt;a href=&quot;../../reference/coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; and &lt;a href=&quot;../../reference/coroutines/flow#flows&quot;&gt;Kotlin Flow&lt;/a&gt; concepts.</source>
          <target state="translated">이 가이드에서는 &lt;a href=&quot;../../reference/coroutines/flow#flows&quot;&gt;코 &lt;/a&gt;&lt;a href=&quot;../../reference/coroutines/coroutines-guide&quot;&gt;루틴&lt;/a&gt; 및 Kotlin Flow 개념에 대한 사전 지식이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="fb864cb1ef23ff32107953e1fa4c437c5106429f" translate="yes" xml:space="preserve">
          <source>The tutorial assumes you have prior knowledge of the &lt;a href=&quot;../../reference/coroutines/coroutines-guide&quot;&gt;coroutines&lt;/a&gt; concept.</source>
          <target state="translated">이 튜토리얼은 &lt;a href=&quot;../../reference/coroutines/coroutines-guide&quot;&gt;코 루틴&lt;/a&gt; 개념에 대한 사전 지식이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="3871e9aa2f804023caa55782736ddd2a4dee3be1" translate="yes" xml:space="preserve">
          <source>The two characters are the same (as compared by the == operator)</source>
          <target state="translated">두 문자는 동일합니다 (== 연산자와 비교하여)</target>
        </trans-unit>
        <trans-unit id="43727256131e4c09e21487921129d951e5403bce" translate="yes" xml:space="preserve">
          <source>The type &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt; is special, because it has no natural counterpart in Java. Indeed, every Java reference type, including &lt;code&gt;java.lang.Void&lt;/code&gt;, accepts &lt;code&gt;null&lt;/code&gt; as a value, and &lt;code&gt;Nothing&lt;/code&gt; doesn't accept even that. So, this type cannot be accurately represented in the Java world. This is why Kotlin generates a raw type where an argument of type &lt;code&gt;Nothing&lt;/code&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;exceptions#the-nothing-type&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt; 유형 은 Java에서 자연스럽게 대응되지 않기 때문에 특별합니다. 실제로 &lt;code&gt;java.lang.Void&lt;/code&gt; 를 포함한 모든 Java 참조 유형 은 &lt;code&gt;null&lt;/code&gt; 을 값으로 허용 하며 &lt;code&gt;Nothing&lt;/code&gt; 조차도 허용하지 않습니다. 따라서이 유형은 Java 세계에서 정확하게 표현 될 수 없습니다. 이것이 Kotlin이 &lt;code&gt;Nothing&lt;/code&gt; 유형의 인수 가 사용되는 원시 유형을 생성하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="5840d7b86dbf1ab10e5032023a9859ef434e1278" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Boolean&lt;/code&gt; represents booleans, and has two values: &lt;em&gt;true&lt;/em&gt; and &lt;em&gt;false&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 유형은 부울을 나타내며 &lt;em&gt;true&lt;/em&gt; 및 &lt;em&gt;false의&lt;/em&gt; 두 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdef02e2cbe116b674c3a5cab83d13e4789bcc49" translate="yes" xml:space="preserve">
          <source>The type argument &lt;code&gt;T&lt;/code&gt; of &lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; must be one of the &quot;lvalue&quot; types described above, e.g., the C type &lt;code&gt;struct S*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt;, &lt;code&gt;int8_t*&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt;, and &lt;code&gt;char**&lt;/code&gt; is mapped to &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CPointer&amp;lt;T&amp;gt;&lt;/code&gt; 의 type 인수 &lt;code&gt;T&lt;/code&gt; 는 위에서 설명한 &quot;lvalue&quot;유형 중 하나 여야합니다. 예를 들어 C type &lt;code&gt;struct S*&lt;/code&gt; 는 &lt;code&gt;CPointer&amp;lt;S&amp;gt;&lt;/code&gt; 에 매핑되고 &lt;code&gt;CPointer&amp;lt;int_8tVar&amp;gt;&lt;/code&gt; &lt;code&gt;int8_t*&lt;/code&gt; 는 CPointer &amp;lt;int_8tVar&amp;gt;에 매핑 되고 &lt;code&gt;char**&lt;/code&gt; 는 &lt;code&gt;CPointer&amp;lt;CPointerVar&amp;lt;ByteVar&amp;gt;&amp;gt;&lt;/code&gt; 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="304e12f8621867e9197c2891cfb5db65d05e542f" translate="yes" xml:space="preserve">
          <source>The type arguments of generic function calls are also only checked at compile time. Inside the function bodies, the type parameters cannot be used for type checks, and type casts to type parameters (&lt;code&gt;foo as T&lt;/code&gt;) are unchecked. However, &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;reified type parameters&lt;/a&gt; of inline functions are substituted by the actual type arguments in the inlined function body at the call sites and thus can be used for type checks and casts, with the same restrictions for instances of generic types as described above.</source>
          <target state="translated">일반 함수 호출의 유형 인수는 컴파일시에만 확인됩니다. 함수 본문 내에서 형식 매개 변수는 형식 검사에 사용할 수 없으며 형식 매개 변수에 대한 형식 캐스트 ( &lt;code&gt;foo as T&lt;/code&gt; )는 선택되지 않습니다. 그러나 인라인 함수의 &lt;a href=&quot;inline-functions#reified-type-parameters&quot;&gt;구체화 된 유형 매개 변수&lt;/a&gt; 는 호출 사이트에서 인라인 된 함수 본문의 실제 유형 인수로 대체되므로 위에서 설명한 일반 유형의 인스턴스에 대한 동일한 제한 사항으로 유형 검사 및 캐스트에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d035411fbfdc1232561efb8b45fef51b9b3f1fe" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;safeDivide&lt;/code&gt; is &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt;. Note that unlike function type declarations, the parameter list of a lambda expression must not be enclosed in parentheses.</source>
          <target state="translated">&lt;code&gt;safeDivide&lt;/code&gt; 의 유형 은 &lt;code&gt;(Int, Int) -&amp;gt; Double&lt;/code&gt; 입니다. 함수 유형 선언과 달리 람다 식의 매개 변수 목록은 괄호로 묶어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e87e3495180710587f4d34c13b7d672cd8d74623" translate="yes" xml:space="preserve">
          <source>The type of a delegated property wasn&amp;rsquo;t taken into account while analyzing the delegate expression which follows the &lt;code&gt;by&lt;/code&gt; keyword. For instance, the following code didn&amp;rsquo;t compile before, but now the compiler correctly infers the types of the &lt;code&gt;old&lt;/code&gt; and &lt;code&gt;new&lt;/code&gt; parameters as &lt;code&gt;String?&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;by&lt;/code&gt; 키워드 뒤에 오는 대리자 표현식을 분석하는 동안 위임 된 속성의 유형은 고려되지 않았습니다 . 예를 들어, 다음 코드는 이전에 컴파일되지 않았지만 이제 컴파일러는 &lt;code&gt;old&lt;/code&gt; 및 &lt;code&gt;new&lt;/code&gt; 매개 변수 의 유형을 &lt;code&gt;String?&lt;/code&gt; 올바르게 추론 합니까? :</target>
        </trans-unit>
        <trans-unit id="c50d2b6bc67063abeddc4b2628733da7784a58f0" translate="yes" xml:space="preserve">
          <source>The type of a property, and the types that are used for the parameters and the return type of a function, must be &quot;at least as visible&quot; as the property/function itself. For example, a public function can't take a private type as a parameter.</source>
          <target state="translated">속성의 유형과 매개 변수에 사용되는 유형 및 함수의 반환 유형은 속성 / 함수 자체만큼 &quot;적어도 가시적&quot;이어야합니다. 예를 들어, 공용 함수는 전용 유형을 매개 변수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8de1071b6667ea170a2315b344096736147854e4" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;throw&lt;/code&gt; expression is the special type &lt;code&gt;Nothing&lt;/code&gt;. The type has no values and is used to mark code locations that can never be reached. In your own code, you can use &lt;code&gt;Nothing&lt;/code&gt; to mark a function that never returns:</source>
          <target state="translated">&lt;code&gt;throw&lt;/code&gt; 표현식 의 유형은 특수 유형 &lt;code&gt;Nothing&lt;/code&gt; 입니다. 이 유형에는 값이 없으며 도달 할 수없는 코드 위치를 표시하는 데 사용됩니다. 자체 코드에서 &lt;code&gt;Nothing&lt;/code&gt; 을 사용 하여 절대 반환하지 않는 함수를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23c18621bf7101376cb4104c69faad184a7d75d0" translate="yes" xml:space="preserve">
          <source>The type of these expressions is the &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing type&lt;/a&gt;.</source>
          <target state="translated">이러한 표현식의 유형은 &lt;a href=&quot;exceptions#the-nothing-type&quot;&gt;Nothing 유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28dfc8e3403b9f6de19da78b037825e3337aa674" translate="yes" xml:space="preserve">
          <source>The type of values returned by this callable.</source>
          <target state="translated">이 호출 가능 객체가 반환 한 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="724404b217f8e33affca4710ff6d760dfbd8b8e9" translate="yes" xml:space="preserve">
          <source>The type safety checks that Kotlin performs for generic declaration usages are only done at compile time. At runtime, the instances of generic types do not hold any information about their actual type arguments. The type information is said to be &lt;em&gt;erased&lt;/em&gt;. For example, the instances of &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; and &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; are erased to just &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Kotlin이 일반 선언 사용에 대해 수행하는 형식 안전 검사는 컴파일 타임에만 수행됩니다. 런타임시 일반 유형의 인스턴스는 실제 유형 인수에 대한 정보를 보유하지 않습니다. 유형 정보가 &lt;em&gt;지워&lt;/em&gt; 졌다고합니다 . 예를 들어 &lt;code&gt;Foo&amp;lt;Bar&amp;gt;&lt;/code&gt; 및 &lt;code&gt;Foo&amp;lt;Baz?&amp;gt;&lt;/code&gt; 인스턴스는 &lt;code&gt;Foo&amp;lt;*&amp;gt;&lt;/code&gt; 로 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="bd9368e467f6513ce687f28529e6a3ccfb31bd57" translate="yes" xml:space="preserve">
          <source>The type specified after a colon is the &lt;strong&gt;upper bound&lt;/strong&gt;: only a subtype of &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; may be substituted for &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">콜론 이후 지정된 유형 인 &lt;strong&gt;상한&lt;/strong&gt; 의 서브 타입 : &lt;code&gt;Comparable&amp;lt;T&amp;gt;&lt;/code&gt; 치환 될 수 &lt;code&gt;T&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195a81820ffdceacb4b4779278f03f44e25e239e" translate="yes" xml:space="preserve">
          <source>The type specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">투영에 지정된 유형이거나 별 투영 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e184ade95bbad48da746688d8668a604f12d3467" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object.</source>
          <target state="translated">단 하나의 값을 가진 유형 : &lt;code&gt;Unit&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="19328e2c828d83e68c896264bdfa85a39aa786f7" translate="yes" xml:space="preserve">
          <source>The type with only one value: the &lt;code&gt;Unit&lt;/code&gt; object. This type corresponds to the &lt;code&gt;void&lt;/code&gt; type in Java.</source>
          <target state="translated">단 하나의 값을 가진 유형 : &lt;code&gt;Unit&lt;/code&gt; 객체. 이 유형 은 Java 의 &lt;code&gt;void&lt;/code&gt; 유형에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="7008246671a61ed2da63a9b1d753eac75888ec6a" translate="yes" xml:space="preserve">
          <source>The types inside the angle brackets are called &lt;em&gt;generic type parameters&lt;/em&gt;, which we will cover later. In short, it's a useful technique to make a class that is tied to another class (such as a container class, which is tied to its element class) applicable to many different classes.</source>
          <target state="translated">꺾쇠 괄호 안의 &lt;em&gt;유형을 일반 유형 매개 변수&lt;/em&gt; 라고하며 , 나중에 다루겠습니다. 즉, 다른 클래스 (예 : 요소 클래스에 연결된 컨테이너 클래스)에 연결된 클래스를 여러 클래스에 적용 할 수있는 유용한 기술입니다.</target>
        </trans-unit>
        <trans-unit id="608adb2d4b11107c32aaf63109063a2afc4cba2c" translate="yes" xml:space="preserve">
          <source>The unconfined dispatcher is an advanced mechanism that can be helpful in certain corner cases where dispatching of a coroutine for its execution later is not needed or produces undesirable side-effects, because some operation in a coroutine must be performed right away. The unconfined dispatcher should not be used in general code.</source>
          <target state="translated">제한되지 않은 디스패처는 코 루틴의 일부 작업을 즉시 수행해야하므로 나중에 실행하기 위해 코 루틴을 디스패치하지 않아도되거나 바람직하지 않은 부작용이 발생하는 특정 코너 경우에 도움이 될 수있는 고급 메커니즘입니다. 제한되지 않은 디스패처는 일반 코드에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6fa7d43068ef0a257b1107aef91aad1237cf845b" translate="yes" xml:space="preserve">
          <source>The unit in which this time source's readings are expressed.</source>
          <target state="translated">이 시간 소스의 판독 값이 표현되는 단위입니다.</target>
        </trans-unit>
        <trans-unit id="3b16b6543fccfa319ed1bb173131c9217c5b8ccc" translate="yes" xml:space="preserve">
          <source>The usage from C is straightforward and uncomplicated. We create a &lt;code&gt;main.c&lt;/code&gt; file with the following code:</source>
          <target state="translated">C의 사용법은 간단하고 복잡하지 않습니다. 다음 코드를 사용하여 &lt;code&gt;main.c&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="eda63df3b0cc777042c5e16e6a7e9e820a7f02bd" translate="yes" xml:space="preserve">
          <source>The usage is pretty similar to all-open.</source>
          <target state="translated">사용법은 모두 열기와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d4460c6a02beaa088565d93296bf84c132fa91dd" translate="yes" xml:space="preserve">
          <source>The usage is the same to all-open and no-arg, except the fact that sam-with-receiver does not have any built-in presets, and you need to specify your own list of special-treated annotations.</source>
          <target state="translated">sam-with-receiver에 내장 된 사전 설정이없고 고유 한 특수 처리 된 주석 목록을 지정해야한다는 점을 제외하면 사용법은 모두 열기 및 인수 없음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="79d6496f32a4f62877c61deb0bd17640fe23059a" translate="yes" xml:space="preserve">
          <source>The use cases of different functions overlap, so that you can choose the functions based on the specific conventions used in your project or team.</source>
          <target state="translated">서로 다른 기능의 사용 사례가 겹치므로 프로젝트 또는 팀에서 사용되는 특정 규칙에 따라 기능을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="882548c8ded53fae119e86e0601fc1f2361824a2" translate="yes" xml:space="preserve">
          <source>The use-site variance specified in the projection, or &lt;code&gt;null&lt;/code&gt; if this is a star projection.</source>
          <target state="translated">투영에 지정된 사용 사이트 차이 또는 별 투영 인 경우 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6253f8d51fcab2be72d37974c28482731bda531" translate="yes" xml:space="preserve">
          <source>The value being held by this class.</source>
          <target state="translated">이 클래스가 보유하고있는 가치.</target>
        </trans-unit>
        <trans-unit id="577bdaa0d4f29e2066a35e4f4e04798f20702fe4" translate="yes" xml:space="preserve">
          <source>The value is coerced to the range of &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; type, if it doesn't fit in that range, see the conversion &lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong&lt;/a&gt; for details.</source>
          <target state="translated">값은 &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 유형 의 범위로 강제 변환됩니다. 해당 범위에 맞지 않는 경우 자세한 내용은 &lt;a href=&quot;../../kotlin/-double/to-long#kotlin.Double%24toLong()&quot;&gt;Double.toLong 변환&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6df952c69c83c655c026cd3cab96c052641127" translate="yes" xml:space="preserve">
          <source>The value must be positive and &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; is used to specify an unlimited depth.</source>
          <target state="translated">값은 양수 여야하며 &lt;a href=&quot;../../kotlin/-int/-m-a-x_-v-a-l-u-e#kotlin.Int.Companion%24MAX_VALUE&quot;&gt;Int.MAX_VALUE&lt;/a&gt; 를 사용하여 무제한 깊이를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="97892b5c37923194772dbef7a77eefc1ede87692" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;-o&lt;/code&gt; option specifies the name of the output file, so this call should generate a &lt;code&gt;hello.kexe&lt;/code&gt; (Linux and macOS) or &lt;code&gt;hello.exe&lt;/code&gt; (Windows) binary file. For the full list of available compiler options, see the &lt;a href=&quot;../../reference/compiler-reference&quot;&gt;compiler options reference&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-o&lt;/code&gt; 옵션 의 값은 출력 파일의 이름을 지정 &lt;code&gt;hello.kexe&lt;/code&gt; 호출은 hello.kexe (Linux 및 macOS) 또는 &lt;code&gt;hello.exe&lt;/code&gt; (Windows) 바이너리 파일을 생성해야 합니다. 사용 가능한 컴파일러 옵션의 전체 목록은 &lt;a href=&quot;../../reference/compiler-reference&quot;&gt;컴파일러 옵션 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="239f4ace7ed276249b435b6f6174eb7de8fef7a5" translate="yes" xml:space="preserve">
          <source>The value of captured group.</source>
          <target state="translated">캡처 한 그룹의 가치.</target>
        </trans-unit>
        <trans-unit id="ce44ab0aef2ba6fca007243084494724190d0750" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of days.</source>
          <target state="translated">이 기간의 값은 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of days 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddf648b4a0329becbc5477b60555b12220f10b40" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of hours.</source>
          <target state="translated">이 기간의 값은 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;두 배&lt;/a&gt; 의 시간으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="011bd5d3e1ddd02dcec9b1f85243ece2a4ace656" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of microseconds.</source>
          <target state="translated">이 기간의 값은 마이크로 초의 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;두 배로&lt;/a&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="30b8a003aa5b8584408499ff82622a0e706a84fc" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of milliseconds.</source>
          <target state="translated">이 기간의 값은 밀리 초의 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;두 배로&lt;/a&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c99149817b525fbcf413d6772866b32a2c01ada" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of minutes.</source>
          <target state="translated">이 기간의 값은 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;두 배&lt;/a&gt; 의 분으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e38ca805c23940cba81f9df025502e9ca46a64b0" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of nanoseconds.</source>
          <target state="translated">이 기간의 값은 나노초 의 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;두 배로&lt;/a&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="21ec4e0972a7296f1c104ec03a824f9de0f72383" translate="yes" xml:space="preserve">
          <source>The value of this duration expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number of seconds.</source>
          <target state="translated">이 기간의 값은 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;두 배 (&lt;/a&gt; 초) 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="af704602dd7474776e5b688f4b067018b5e41c89" translate="yes" xml:space="preserve">
          <source>The value of this variable.</source>
          <target state="translated">이 변수의 값.</target>
        </trans-unit>
        <trans-unit id="3aabcc212c1608210121013dee11f396d22f4fca" translate="yes" xml:space="preserve">
          <source>The variable containing a &lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;-c-opaque-pointer&quot;&gt;COpaquePointer를&lt;/a&gt; 포함하는 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="e9b853cf2301d69ed0ca13dfc9180094e7f3e288" translate="yes" xml:space="preserve">
          <source>The version of the bytecode interface (naming conventions, signatures) of the class file annotated with this annotation.</source>
          <target state="translated">이 주석으로 주석이 달린 클래스 파일의 바이트 코드 인터페이스 버전 (이름 지정 규칙, 서명).</target>
        </trans-unit>
        <trans-unit id="1abfb175c8f11a4b2665f4fbd6b2ed384b7a75ef" translate="yes" xml:space="preserve">
          <source>The version of the metadata provided in the arguments of this annotation.</source>
          <target state="translated">이 주석의 인수에 제공된 메타 데이터의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="b210bbe6f64c596cb275d652b699dc315a1fc8bc" translate="yes" xml:space="preserve">
          <source>The very first part contains the standard C/C++ header and footer:</source>
          <target state="translated">첫 번째 부분에는 표준 C / C ++ 헤더 및 바닥 글이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="13204b21b51f8144497368ed89b8d47c465b75a3" translate="yes" xml:space="preserve">
          <source>The visibility level only affects the &lt;em&gt;lexical visibility&lt;/em&gt; of the &lt;em&gt;symbol&lt;/em&gt; - i.e., where the compiler allows you to type out the symbol. It does not affect where &lt;em&gt;instances&lt;/em&gt; are used: for example, a public top-level function may well return an instance of a private class, as long as the return type doesn't mention the private class name but is instead a public base class of the private class (possibly &lt;code&gt;Any&lt;/code&gt;) or a public interface that the private class implements. When you &lt;a href=&quot;inheritance#subclassing&quot;&gt;subclass&lt;/a&gt; a class, its private members are also inherited by the subclass, but are not directly accessible there - however, if you call an inherited public function that happens to access a private member, that's fine.</source>
          <target state="translated">가시성 수준 은 &lt;em&gt;기호&lt;/em&gt; 의 &lt;em&gt;어휘 적 가시성&lt;/em&gt; 에만 영향을 미칩니다. 즉, 컴파일러에서 기호를 입력 할 수 있습니다. &lt;em&gt;인스턴스&lt;/em&gt; 가 사용되는 위치에는 영향을 미치지 않습니다 . 예를 들어, 공개 최상위 함수는 반환 유형이 개인 클래스 이름을 언급하지 않고 대신에 공개 기본 클래스 인 경우 개인 클래스의 인스턴스를 반환 할 수 있습니다. 개인 클래스 (아마도 &lt;code&gt;Any&lt;/code&gt; ) 또는 개인 클래스가 구현하는 공용 인터페이스 &lt;a href=&quot;inheritance#subclassing&quot;&gt;클래스&lt;/a&gt; 를 서브 클래 싱 할 때 , 그 프라이빗 멤버도 서브 클래스에 의해 상속되지만 직접 액세스 할 수는 없습니다. 그러나 프라이빗 멤버에 접근하는 상속 된 퍼블릭 함수를 호출하면 좋습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be08405fa49b795ce8dcbbade59f22553916f972" translate="yes" xml:space="preserve">
          <source>The way in which we'd use this from JavaScript would be to call &lt;code&gt;dataTable()&lt;/code&gt; on the corresponding &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element</source>
          <target state="translated">JavaScript에서 이것을 사용하는 방법 은 해당 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 요소 에서 &lt;code&gt;dataTable()&lt;/code&gt; 을 호출 하는 것입니다</target>
        </trans-unit>
        <trans-unit id="df6c92cd4ac7021995eb7f605c7d7406310257be" translate="yes" xml:space="preserve">
          <source>The way to refer to the context object</source>
          <target state="translated">컨텍스트 객체를 참조하는 방법</target>
        </trans-unit>
        <trans-unit id="db21ceeaa7842bb619c97af30e1e09b94faa6e61" translate="yes" xml:space="preserve">
          <source>The web site has a bunch of &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;online resources&lt;/a&gt;, including &lt;a href=&quot;https://kotlin.link&quot;&gt;Kotlin Digests&lt;/a&gt; by community members, a &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;newsletter&lt;/a&gt;, a &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;podcast&lt;/a&gt; and more.</source>
          <target state="translated">이 웹 사이트에는 커뮤니티 구성원의 &lt;a href=&quot;https://kotlin.link&quot;&gt;코 틀린 다이제스트&lt;/a&gt; , &lt;a href=&quot;http://www.kotlinweekly.net&quot;&gt;뉴스 레터&lt;/a&gt; , &lt;a href=&quot;https://talkingkotlin.com&quot;&gt;팟 캐스트&lt;/a&gt; 등을 포함한 다양한 &lt;a href=&quot;https://kotlinlang.org/community/&quot;&gt;온라인 리소스가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffaad4042bec05249e2007ea2e2a7c01e5b1b264" translate="yes" xml:space="preserve">
          <source>Then add the respective dependencies using the &lt;code&gt;kapt&lt;/code&gt; configuration in your &lt;code&gt;dependencies&lt;/code&gt; block:</source>
          <target state="translated">그런 다음 &lt;code&gt;dependencies&lt;/code&gt; 블록 에서 &lt;code&gt;kapt&lt;/code&gt; 구성을 사용하여 해당 종속성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d3dd4715a6e839facb3a4bc6c2872f8802ec4b8" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;build.gradle&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-gradle&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">그런 다음 마법사 단계를 따르십시오. 당신은해야합니다 &lt;code&gt;build.gradle&lt;/code&gt; 의 코 틀린로 만든 파일에 따라 구성 &lt;a href=&quot;../../reference/using-gradle&quot;&gt;이 문서&lt;/a&gt; . Kotlin 1.3 이상으로 구성되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9ed3e436c4ee364169e1bdacb724480b6ae120b2" translate="yes" xml:space="preserve">
          <source>Then follow the wizard steps. You'll have a &lt;code&gt;pom.xml&lt;/code&gt; file created with Kotlin configured according to &lt;a href=&quot;../../reference/using-maven&quot;&gt;this document&lt;/a&gt;. Make sure it's configured for Kotlin 1.3 or higher.</source>
          <target state="translated">그런 다음 마법사 단계를 따르십시오. 당신은해야합니다 &lt;code&gt;pom.xml&lt;/code&gt; 코 틀린로 만든 파일에 따라 구성 &lt;a href=&quot;../../reference/using-maven&quot;&gt;이 문서&lt;/a&gt; . Kotlin 1.3 이상으로 구성되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="10cfe3c1803900b3459055c1fdedb21ced35e4cd" translate="yes" xml:space="preserve">
          <source>Then run the &lt;code&gt;cinterop&lt;/code&gt; tool with something like this (note that for host libraries that are not included in the sysroot search paths, headers may be needed):</source>
          <target state="translated">그런 다음 다음 과 같이 &lt;code&gt;cinterop&lt;/code&gt; 도구를 실행하십시오 (sysroot 검색 경로에 포함되지 않은 호스트 라이브러리의 경우 헤더가 필요할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5581239ffa3d854f1837127435e240d49f122ba5" translate="yes" xml:space="preserve">
          <source>Then specify the list of SAM-with-receiver annotations:</source>
          <target state="translated">그런 다음 수신자가있는 SAM 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9b78fa9ef8a36ffde61cb8bc4f298109afadcbee" translate="yes" xml:space="preserve">
          <source>Then specify the list of annotations that will make classes open:</source>
          <target state="translated">그런 다음 클래스를 여는 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fd73374c27e0a874f2f41c35f033bfc599a82d6b" translate="yes" xml:space="preserve">
          <source>Then specify the list of no-arg annotations:</source>
          <target state="translated">그런 다음 인수없는 주석 목록을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ef92249fe5f505a551a8b463644321da779af43" translate="yes" xml:space="preserve">
          <source>Then we can have several processor coroutines. In this example, they just print their id and received number:</source>
          <target state="translated">그런 다음 여러 프로세서 코 루틴을 가질 수 있습니다. 이 예에서는 ID와 수신 번호 만 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="490b87ea6044ef60c21b2e7783571a7d77df8b12" translate="yes" xml:space="preserve">
          <source>Then we define a function that launches an actor using an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;액터&lt;/a&gt; 코 루틴 빌더를 사용하여 액터 를 시작하는 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d20d8e9783f5f7554d56032158624be9ade29c33" translate="yes" xml:space="preserve">
          <source>Then we end up with a flow of flows (&lt;code&gt;Flow&amp;lt;Flow&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt;) that needs to be &lt;em&gt;flattened&lt;/em&gt; into a single flow for further processing. Collections and sequences have &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/flatten&quot;&gt;flatten&lt;/a&gt; and &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/flat-map&quot;&gt;flatMap&lt;/a&gt; operators for this. However, due to the asynchronous nature of flows they call for different &lt;em&gt;modes&lt;/em&gt; of flattening, as such, there is a family of flattening operators on flows.</source>
          <target state="translated">그런 다음 추가 처리를 위해 단일 흐름 으로 &lt;em&gt;평면화&lt;/em&gt; 해야하는 &lt;code&gt;Flow&amp;lt;Flow&amp;lt;String&amp;gt;&amp;gt;&lt;/code&gt; 흐름 ( Flow &amp;lt;Flow &amp;lt;String &amp;gt;&amp;gt; )으로 끝납니다 . 컬렉션과 시퀀스에는이를 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/flatten&quot;&gt;위해 flatten&lt;/a&gt; 및 &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.sequences/flat-map&quot;&gt;flatMap&lt;/a&gt; 연산자가 있습니다. 그러나 흐름의 비동기 특성으로 인해 서로 다른 평면화 &lt;em&gt;모드&lt;/em&gt; 가 필요하므로 흐름에 평면화 연산자 제품군이 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ca671870f1fadd5567721f74e5bc28177111ecb" translate="yes" xml:space="preserve">
          <source>Then you can finish creating your project or, optionally, &lt;em&gt;configure the project&lt;/em&gt; on the next screen:</source>
          <target state="translated">그런 다음 프로젝트 생성을 완료하거나 선택적으로 다음 화면 &lt;em&gt;에서 프로젝트&lt;/em&gt; 를 &lt;em&gt;구성 할 수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="843feae1b1434f20428d159db5d3289af1525e9c" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled by the variants, a Kotlin source set is created under that source set name prepended by the target name, like Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants compilations accordingly.</source>
          <target state="translated">그런 다음 변형에 의해 컴파일 된 각 &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android 소스 세트&lt;/a&gt; 에 대해 Kotlin 소스 세트는 Android 소스 세트 &lt;code&gt;debug&lt;/code&gt; Kotlin 소스 세트 &lt;code&gt;androidDebug&lt;/code&gt; 및 &lt;code&gt;android&lt;/code&gt; 라는 Kotlin 타겟과 같이 대상 이름이 앞에 붙은 해당 소스 세트 이름 아래에 작성됩니다 . 이러한 Kotlin 소스 세트는 그에 따라 변형 컴파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8f493cee5294668e61abac2182624f37839c6424" translate="yes" xml:space="preserve">
          <source>Then, for each &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android source set&lt;/a&gt; compiled for each of the variants, a Kotlin source set is created under that source set name prepended by the target name, like the Kotlin source set &lt;code&gt;androidDebug&lt;/code&gt; for an Android source set &lt;code&gt;debug&lt;/code&gt; and the Kotlin target named &lt;code&gt;android&lt;/code&gt;. These Kotlin source sets are added to the variants&amp;rsquo; compilations accordingly.</source>
          <target state="translated">그런 다음 각 변형에 대해 컴파일 된 각 &lt;a href=&quot;https://developer.android.com/studio/build/build-variants#sourcesets&quot;&gt;Android 소스 세트&lt;/a&gt; 에 대해 Kotlin 소스 세트가 Android 소스 세트 &lt;code&gt;debug&lt;/code&gt; 용 Kotlin 소스 세트 &lt;code&gt;androidDebug&lt;/code&gt; 및 &lt;code&gt;android&lt;/code&gt; 라는 Kotlin 타겟과 같이 대상 이름 앞에 추가 된 해당 소스 세트 이름 아래에 생성됩니다 . 이러한 Kotlin 소스 세트는 그에 따라 변형의 컴파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="68562aa9b0f180cb0bf47fd690042cd2286c6294" translate="yes" xml:space="preserve">
          <source>Then, it would be perfectly safe to store a reference to an instance of &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; in a variable of type &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; &amp;ndash; there are no consumer-methods to call. But Java does not know this, and still prohibits it:</source>
          <target state="translated">그런 다음 &lt;code&gt;Source&amp;lt;Object&amp;gt;&lt;/code&gt; 유형의 변수에 &lt;code&gt;Source&amp;lt;String&amp;gt;&lt;/code&gt; 인스턴스에 대한 참조를 저장하는 것이 안전합니다 . 호출 할 소비자 메소드는 없습니다. 그러나 Java는 이것을 알지 못하고 여전히 금지합니다.</target>
        </trans-unit>
        <trans-unit id="d673d7a939528ccf7977db751d0c7bd0f923bb89" translate="yes" xml:space="preserve">
          <source>Then, once a target is added, default compilations are created for it:</source>
          <target state="translated">그런 다음 대상이 추가되면 기본 컴파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b51b664e8983298e6dc346e7c7dc0b18863813" translate="yes" xml:space="preserve">
          <source>Then, some time later the deprecation level is raised to &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt;, so that no new Kotlin code can be compiled using the deprecated API.</source>
          <target state="translated">그런 다음 얼마 후 사용 중단 레벨이 &lt;a href=&quot;../-deprecation-level/-e-r-r-o-r#kotlin.DeprecationLevel.ERROR&quot;&gt;DeprecationLevel.ERROR&lt;/a&gt; 로 높아져 사용 중단 된 API를 사용하여 새로운 Kotlin 코드를 컴파일 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6377e7d0f06e408f80f03d549dd08ce8d9b969c" translate="yes" xml:space="preserve">
          <source>Then, the only thing we want to ensure is that &lt;code&gt;copy()&lt;/code&gt; does not do any bad things. We want to prohibit it from &lt;strong&gt;writing&lt;/strong&gt; to &lt;code&gt;from&lt;/code&gt;, and we can:</source>
          <target state="translated">그렇다면 우리가 원하는 유일한 것은 &lt;code&gt;copy()&lt;/code&gt; 가 나쁜 일을하지 않는다는 것입니다. 우리는에서 그것을 금지 할 &lt;strong&gt;쓰기&lt;/strong&gt; 로 &lt;code&gt;from&lt;/code&gt; , 우리는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2e04f4cdf39ff6bfe2fd15e1cdcb551eff15e642" translate="yes" xml:space="preserve">
          <source>There are a few courses available for Kotlin, including a &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;Pluralsight Kotlin Course&lt;/a&gt; by Kevin Jones, an &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O&amp;rsquo;Reilly Course&lt;/a&gt; by Hadi Hariri and an &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin Course&lt;/a&gt; by Peter Sommerhoff.</source>
          <target state="translated">Kevin Jones 의 &lt;a href=&quot;https://www.pluralsight.com/courses/kotlin-getting-started&quot;&gt;복수형 Kotlin 코스&lt;/a&gt; , Hadi Hariri 의 &lt;a href=&quot;http://shop.oreilly.com/product/0636920052982.do&quot;&gt;O'Reilly 코스&lt;/a&gt; 및 Peter Sommerhoff 의 &lt;a href=&quot;http://petersommerhoff.com/dev/kotlin/kotlin-beginner-tutorial/&quot;&gt;Udemy Kotlin 코스&lt;/a&gt; 를 포함하여 Kotlin에 사용할 수있는 몇 가지 코스가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aeb1151dcad680105c7a075482911c8fc7a00f6" translate="yes" xml:space="preserve">
          <source>There are a lot of built-in extension functions/properties in Kotlin - for example, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, and the rest of the framework for processing collections in a functional manner is built using extension functions.</source>
          <target state="translated">Kotlin에는 내장 확장 기능 / 속성이 많이 &lt;code&gt;map()&lt;/code&gt; 예 : map () , &lt;code&gt;filter()&lt;/code&gt; . 기능 방식으로 컬렉션을 처리하기위한 나머지 프레임 워크는 확장 기능을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="24f819fcebc7b01f0f49b06a15eca941aac602cd" translate="yes" xml:space="preserve">
          <source>There are already &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;a number of books&lt;/a&gt; available for Kotlin, including &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;Kotlin in Action&lt;/a&gt; which is by Kotlin team members Dmitry Jemerov and Svetlana Isakova, &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Kotlin for Android Developers&lt;/a&gt; targeted at Android developers.</source>
          <target state="translated">Kotlin 팀원 인 Dmitry Jemerov와 &lt;a href=&quot;https://leanpub.com/kotlin-for-android-developers&quot;&gt;Android 개발자를&lt;/a&gt; 대상으로 하는 Android 개발자를위한 Kotlin Svetlana Isakova가 제공하는 Kotlin &lt;a href=&quot;https://www.manning.com/books/kotlin-in-action&quot;&gt;in Action&lt;/a&gt; 을 포함하여 Kotlin에 사용할 수 &lt;a href=&quot;https://kotlinlang.org/docs/books.html&quot;&gt;있는 많은 책&lt;/a&gt; 이 이미 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fc2f752c1f987f34408faba377f5009dac3834a" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;minOfWith()&lt;/code&gt; and &lt;code&gt;maxOfWith()&lt;/code&gt;, which take a &lt;code&gt;Comparator&lt;/code&gt; as an argument, and &lt;code&gt;*OrNull()&lt;/code&gt; versions of all four functions that return &lt;code&gt;null&lt;/code&gt; on empty collections.</source>
          <target state="translated">도 있습니다 &lt;code&gt;minOfWith()&lt;/code&gt; 및 &lt;code&gt;maxOfWith()&lt;/code&gt; , 테이크 &lt;code&gt;Comparator&lt;/code&gt; 인수로, 그리고 &lt;code&gt;*OrNull()&lt;/code&gt; 네 가지 기능의 버전은 반환이 &lt;code&gt;null&lt;/code&gt; 빈 컬렉션에.</target>
        </trans-unit>
        <trans-unit id="9bb89fb652d44ab10911a269bc7625b66f46b917" translate="yes" xml:space="preserve">
          <source>There are also community-maintained libraries that support more serialization formats, such as &lt;a href=&quot;https://yaml.org/&quot;&gt;YAML&lt;/a&gt; or &lt;a href=&quot;https://avro.apache.org/&quot;&gt;Apache Avro&lt;/a&gt;. For detailed information about available serialization formats, see the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/formats/README.md&quot;&gt;&lt;code&gt;kotlinx.serialization&lt;/code&gt; documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://yaml.org/&quot;&gt;YAML&lt;/a&gt; 또는 &lt;a href=&quot;https://avro.apache.org/&quot;&gt;Apache Avro&lt;/a&gt; 와 같은 더 많은 직렬화 형식을 지원하는 커뮤니티 유지 라이브러리도 있습니다 . 사용 가능한 직렬화 형식에 대한 자세한 정보는 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.serialization/blob/master/formats/README.md&quot;&gt; &lt;code&gt;kotlinx.serialization&lt;/code&gt; 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cafdda410a7a8fb3e86649e5eeda1f41cb52882f" translate="yes" xml:space="preserve">
          <source>There are also functions for creating collections without any elements: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt;&lt;code&gt;emptyList()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt;&lt;code&gt;emptySet()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt;&lt;code&gt;emptyMap()&lt;/code&gt;&lt;/a&gt;. When creating empty collections, you should specify the type of elements that the collection will hold.</source>
          <target state="translated">&lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-list&quot;&gt; &lt;code&gt;emptyList()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-set&quot;&gt; &lt;code&gt;emptySet()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/empty-map&quot;&gt; &lt;code&gt;emptyMap()&lt;/code&gt; &lt;/a&gt; 요소없이 컬렉션을 생성하는 함수도 있습니다 . 빈 모음을 만들 때는 모음에 보유 할 요소 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="843241bb0f5eb80f440f0b1b3622ce9c95598c3b" translate="yes" xml:space="preserve">
          <source>There are also functions for retrieving the smallest and the largest elements by certain selector function or custom &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt;&lt;code&gt;Comparator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">특정 선택기 기능 또는 사용자 지정 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-comparator/index&quot;&gt; &lt;code&gt;Comparator&lt;/code&gt; &lt;/a&gt; 가장 작은 요소와 가장 큰 요소를 검색하는 기능도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4888d99de496e5f2812e2d42599de7f621ae0a73" translate="yes" xml:space="preserve">
          <source>There are also functions that narrow the element type by filtering elements of a given type:</source>
          <target state="translated">주어진 유형의 요소를 필터링하여 요소 유형을 좁히는 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22fc645d90366ef3cbd36340e10852155ba93121" translate="yes" xml:space="preserve">
          <source>There are also many recordings of &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin talks&lt;/a&gt; available on YouTube and Vimeo.</source>
          <target state="translated">YouTube와 Vimeo에서 사용 가능한 &lt;a href=&quot;http://kotlinlang.org/community/talks.html&quot;&gt;Kotlin 대화&lt;/a&gt; 에 대한 많은 녹음 자료도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4606566df8d7d15d5ed6bd46e8178f7ee899fb7" translate="yes" xml:space="preserve">
          <source>There are also more specific types:</source>
          <target state="translated">더 구체적인 유형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06489c1e98a1df08c22af1c2c8a1f880cc0522a9" translate="yes" xml:space="preserve">
          <source>There are also some tools available to convert between Kotlin and C strings manually:</source>
          <target state="translated">Kotlin과 C 문자열을 수동으로 변환하는 데 사용할 수있는 몇 가지 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5da1b83a877bec99a63204ac23c3a863bcc7d2fe" translate="yes" xml:space="preserve">
          <source>There are also the following type qualifiers in the C language: &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, &lt;code&gt;restruct&lt;/code&gt;, &lt;code&gt;atomic&lt;/code&gt;.</source>
          <target state="translated">C 언어에는 &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; , &lt;code&gt;restruct&lt;/code&gt; , &lt;code&gt;atomic&lt;/code&gt; 유형 한정자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1856539b37f6f362e28eec082e8282bf62fdd7b" translate="yes" xml:space="preserve">
          <source>There are also two specific ways for filtering maps: by keys and by values. For each way, there is a function: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt;&lt;code&gt;filterKeys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt;&lt;code&gt;filterValues()&lt;/code&gt;&lt;/a&gt;. Both return a new map of entries which match the given predicate. The predicate for &lt;code&gt;filterKeys()&lt;/code&gt; checks only the element keys, the one for &lt;code&gt;filterValues()&lt;/code&gt; checks only values.</source>
          <target state="translated">키를 필터링하고 값을 기준으로 맵을 필터링하는 두 가지 방법이 있습니다. 각 방법에는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-keys&quot;&gt; &lt;code&gt;filterKeys()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-values&quot;&gt; &lt;code&gt;filterValues()&lt;/code&gt; &lt;/a&gt; 함수가 있습니다. 둘 다 주어진 술어와 일치하는 새로운 항목 맵을 리턴합니다. 의 술어 &lt;code&gt;filterKeys()&lt;/code&gt; 검사 만 요소 키에 대한 하나 &lt;code&gt;filterValues()&lt;/code&gt; 를 체크 값만.</target>
        </trans-unit>
        <trans-unit id="250044abbac1d0cc39bffb2b00e37419c1aa5fa8" translate="yes" xml:space="preserve">
          <source>There are also useful aliases for retrieving the first and the last element of the collection: &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt;&lt;code&gt;first()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt;&lt;code&gt;last()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컬렉션의 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/first&quot;&gt; &lt;code&gt;first()&lt;/code&gt; &lt;/a&gt; 요소와 마지막 요소 인 first () 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/last&quot;&gt; &lt;code&gt;last()&lt;/code&gt; &lt;/a&gt; 를 검색하는 데 유용한 별칭도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f989069ff2a0fc8bbd7269050d48a2e9c89946af" translate="yes" xml:space="preserve">
          <source>There are certain common kinds of properties, that, though we can implement them manually every time we need them, would be very nice to implement once and for all, and put into a library. Examples include:</source>
          <target state="translated">일반적인 종류의 속성이 있지만 필요할 때마다 수동으로 구현할 수 있지만 한 번에 구현하고 라이브러리에 넣는 것이 매우 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9d07a2b7a0e6a37bb57f8fc3823505798a41626" translate="yes" xml:space="preserve">
          <source>There are certain rules that define write operations on maps:</source>
          <target state="translated">맵에서 쓰기 조작을 정의하는 특정 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3a36051a175f99aacc43b0a72a065674774e2a" translate="yes" xml:space="preserve">
          <source>There are couple of observations to make out of it.</source>
          <target state="translated">그것을 확인하기 위해 몇 가지 관찰이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd050ce9dc8260feb80b7e8ad7e70f3ec42e69f1" translate="yes" xml:space="preserve">
          <source>There are exactly four instances of this class, named &lt;code&gt;ContentKind.TOPIC&lt;/code&gt;, and so on. Instances of this class can be compared to each other with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;, and you can get all the allowable values with &lt;code&gt;ContentKind.values()&lt;/code&gt;. You can also tack on more information to each instance if you need:</source>
          <target state="translated">이 클래스에는 정확히 &lt;code&gt;ContentKind.TOPIC&lt;/code&gt; 등 네 개의 인스턴스가 있습니다. 이 클래스의 인스턴스는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 로 서로 비교할 수 있으며 &lt;code&gt;ContentKind.values()&lt;/code&gt; 사용하여 허용 가능한 모든 값을 얻을 수 있습니다 . 필요한 경우 각 인스턴스에 대한 자세한 정보를 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="11ad196ede0a4f63cd51413d0ab908cfc6383f63" translate="yes" xml:space="preserve">
          <source>There are four types of dependencies:</source>
          <target state="translated">네 가지 유형의 종속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99e47ebabd055fced8bd65467671cf5429616422" translate="yes" xml:space="preserve">
          <source>There are lots of ways to compose multiple flows.</source>
          <target state="translated">여러 흐름을 구성하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f927ac2e11471dbf3b5e6b2ee718ccfcd881bb02" translate="yes" xml:space="preserve">
          <source>There are many approaches to this problem, and in Kotlin we take a very flexible one by providing &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; support at the language level and delegating most of the functionality to libraries, much in line with Kotlin's philosophy.</source>
          <target state="translated">이 문제에 대한 많은 접근 방식이 있으며 Kotlin 에서는 언어 수준에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt; 지원을 제공 하고 대부분의 기능을 Kotlin의 철학에 따라 라이브러리에 위임 함으로써 매우 유연한 방법 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a0366ee935c5394b522c3fe877f29b4f014a964b" translate="yes" xml:space="preserve">
          <source>There are many more platform libraries available for host and cross-compilation targets. &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution provides access to &lt;code&gt;OpenGL&lt;/code&gt;, &lt;code&gt;zlib&lt;/code&gt; and other popular native libraries on applicable platforms.</source>
          <target state="translated">호스트 및 크로스 컴파일 대상에 사용할 수있는 더 많은 플랫폼 라이브러리가 있습니다. &lt;code&gt;Kotlin/Native&lt;/code&gt; 배포는 해당 플랫폼 에서 &lt;code&gt;OpenGL&lt;/code&gt; , &lt;code&gt;zlib&lt;/code&gt; 및 기타 인기있는 기본 라이브러리에 대한 액세스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ef27dee02c48c1f5d014bbb6297ef36468bd6491" translate="yes" xml:space="preserve">
          <source>There are multiple ways to compile Kotlin to JavaScript. The recommended approach is to use Gradle; if desired, you can also build JavaScript projects directly from IntelliJ IDEA, use Maven, or compile the code manually from the command line. To learn more about how to compile to JavaScript please see the corresponding tutorials:</source>
          <target state="translated">Kotlin을 JavaScript로 컴파일하는 방법에는 여러 가지가 있습니다. 권장되는 접근 방식은 Gradle을 사용하는 것입니다. 원하는 경우 IntelliJ IDEA에서 직접 JavaScript 프로젝트를 빌드하거나 Maven을 사용하거나 명령 줄에서 코드를 수동으로 컴파일 할 수도 있습니다. JavaScript로 컴파일하는 방법에 대한 자세한 내용은 해당 자습서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2dc32ef7bc8bd0e0afcc7aa9afb4f5081190370a" translate="yes" xml:space="preserve">
          <source>There are new &lt;code&gt;compile&amp;lt;SourceSet&amp;gt;KotlinMetadata&lt;/code&gt; tasks for all published intermediate source-sets</source>
          <target state="translated">게시 된 모든 중간 소스 세트에 대한 새로운 &lt;code&gt;compile&amp;lt;SourceSet&amp;gt;KotlinMetadata&lt;/code&gt; 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="655afcf98b929642faf68faf52cca26e671f04f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;code&gt;**kwargs&lt;/code&gt; in Kotlin, but you can define optional parameters with default values, and you may choose to name some or all of the parameters when you call the function (whether they've got default values or not). A parameter with a default value must still specify its type explicitly. Like in Python, the named arguments can be reordered at will at the call site:</source>
          <target state="translated">Kotlin 에는 &lt;code&gt;**kwargs&lt;/code&gt; 가 없지만 기본값을 사용하여 선택적 매개 변수를 정의 할 수 있으며 함수를 호출 할 때 매개 변수의 일부 또는 전체 이름을 지정할 수 있습니다 (기본값이 있는지 여부). 기본값을 가진 매개 변수는 여전히 유형을 명시 적으로 지정해야합니다. 파이썬에서와 같이 명명 된 인수는 호출 사이트에서 마음대로 재정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="577ed2c21e3c8a21c4f57421503fea8126403589" translate="yes" xml:space="preserve">
          <source>There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. Most collection types have an &lt;code&gt;isEmpty()&lt;/code&gt; and an &lt;code&gt;isNotEmpty()&lt;/code&gt; function.</source>
          <target state="translated">부울로 자동 변환되지 않으므로 진리와 거짓 개념이 없습니다. 0, 비어 있거나 널에 대한 검사는 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 명시 적으로 수행해야합니다 . 대부분의 컬렉션 유형에는 &lt;code&gt;isEmpty()&lt;/code&gt; 및 &lt;code&gt;isNotEmpty()&lt;/code&gt; 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0173c0164165dfc2326b31145c73366a6b9e4caf" translate="yes" xml:space="preserve">
          <source>There are now separate versions of the standard library supporting the new JDK APIs added in Java 7 and 8. If you need access to the new APIs, use &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; and &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven artifacts instead of the standard &lt;code&gt;kotlin-stdlib&lt;/code&gt;. These artifacts are tiny extensions on top of &lt;code&gt;kotlin-stdlib&lt;/code&gt; and they bring it to your project as a transitive dependency.</source>
          <target state="translated">이제 Java 7 및 8에 추가 된 새로운 JDK API를 지원하는 별도의 표준 라이브러리 버전이 있습니다. 새 API에 액세스해야하는 경우 표준 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 대신 &lt;code&gt;kotlin-stdlib-jre7&lt;/code&gt; 및 &lt;code&gt;kotlin-stdlib-jre8&lt;/code&gt; maven 아티팩트를 사용하십시오. stdlib . 이 아티팩트는 &lt;code&gt;kotlin-stdlib&lt;/code&gt; 의 작은 확장 이며 프로젝트에 전 이적 종속성으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="eb7a82db5fbadd7939003437756e36c07405db69" translate="yes" xml:space="preserve">
          <source>There are numerous ways that Kotlin/JS can be used. To provide you some inspiration, here's a non-exhaustive list of scenarios in which you can use Kotlin/JS.</source>
          <target state="translated">Kotlin / JS를 사용할 수있는 방법에는 여러 가지가 있습니다. 영감을주기 위해 Kotlin / JS를 사용할 수있는 시나리오 목록이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f69b73bfcd710307d7869f79c049d0bc960833d" translate="yes" xml:space="preserve">
          <source>There are several ways to obtain an instance of a function type:</source>
          <target state="translated">함수 유형의 인스턴스를 얻는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb4470f4c8ab69e441c59ca19feae2c36a172f6" translate="yes" xml:space="preserve">
          <source>There are several ways to override the default setting:</source>
          <target state="translated">기본 설정을 재정의하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf800a950521aa58b97d350b92bc387bac6d9bab" translate="yes" xml:space="preserve">
          <source>There are several ways to set the compiler options and their values (&lt;em&gt;compiler arguments&lt;/em&gt;):</source>
          <target state="translated">컴파일러 옵션 및 해당 값 ( &lt;em&gt;컴파일러 인수&lt;/em&gt; ) 을 설정하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ea08a710ccd5abee84ca77d28377d406d442756" translate="yes" xml:space="preserve">
          <source>There are some limitations:</source>
          <target state="translated">몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="060bb5e1464bf104cc44e53612c8d8eb0e6d472c" translate="yes" xml:space="preserve">
          <source>There are target presets that one can apply using the preset functions, as shown above, for the following target platforms:</source>
          <target state="translated">다음과 같은 대상 플랫폼에 대해 사전 설정 기능을 사용하여 적용 할 수있는 대상 사전 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="928b53f844ebe12f1ce8f740249971af80b86900" translate="yes" xml:space="preserve">
          <source>There are the following kinds of binaries:</source>
          <target state="translated">다음과 같은 종류의 바이너리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7df642de78432a3520c5b5afd68e2c605c1c315a" translate="yes" xml:space="preserve">
          <source>There are the following kinds of literal constants for integral values:</source>
          <target state="translated">정수 값에는 다음과 같은 종류의 리터럴 상수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4373b7b309c5120a0c7bdb4b6efb5a4594f35b5" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; one, and two coroutines computing deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">코 루틴은 세 가지가 있습니다. 주 코 루틴 (# 1) &amp;ndash; &lt;code&gt;runBlocking&lt;/code&gt; 1 및 두 코 루틴 계산 지연 값 &lt;code&gt;a&lt;/code&gt; (# 2) 및 &lt;code&gt;b&lt;/code&gt; (# 3). 이들은 모두 &lt;code&gt;runBlocking&lt;/code&gt; 컨텍스트에서 실행되며 기본 스레드로 제한됩니다. 이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b170e6fd924b27994900ac3fea0116365dd9d5a3" translate="yes" xml:space="preserve">
          <source>There are three coroutines. The main coroutine (#1) inside &lt;code&gt;runBlocking&lt;/code&gt; and two coroutines computing the deferred values &lt;code&gt;a&lt;/code&gt; (#2) and &lt;code&gt;b&lt;/code&gt; (#3). They are all executing in the context of &lt;code&gt;runBlocking&lt;/code&gt; and are confined to the main thread. The output of this code is:</source>
          <target state="translated">세 개의 코 루틴이 있습니다. &lt;code&gt;runBlocking&lt;/code&gt; 내부의 메인 코 루틴 (# 1) 과 지연된 값 &lt;code&gt;a&lt;/code&gt; (# 2)와 &lt;code&gt;b&lt;/code&gt; (# 3)를 계산하는 두 개의 코 루틴 . 이들은 모두 &lt;code&gt;runBlocking&lt;/code&gt; 컨텍스트에서 실행되며 주 스레드에 국한됩니다. 이 코드의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f684c90b5c1cc2b45ec708952abe326e96395793" translate="yes" xml:space="preserve">
          <source>There are too many companies using Kotlin to list, but some more visible companies that have publicly declared usage of Kotlin, be this via blog posts, GitHub repositories or talks include &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt;, &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; or &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda&lt;/a&gt;.</source>
          <target state="translated">Kotlin을 사용하여 상장하기에는 너무 많은 회사가 있지만 공개적으로 Kotlin의 사용을 선언 한 더 눈에 띄는 회사는 블로그 게시물, GitHub 리포지토리 또는 대화를 통해 &lt;a href=&quot;https://medium.com/square-corner-blog/square-open-source-loves-kotlin-c57c21710a17&quot;&gt;Square&lt;/a&gt; , &lt;a href=&quot;https://www.youtube.com/watch?v=mDpnc45WwlI&quot;&gt;Pinterest&lt;/a&gt; , &lt;a href=&quot;https://m.signalvnoise.com/how-we-made-basecamp-3s-android-app-100-kotlin-35e4e1c0ef12&quot;&gt;Basecamp&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.corda.net/releases/release-M9.2/further-notes-on-kotlin.html&quot;&gt;Corda를 포함&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="26ea8b64f47f54b93f794f79bdbd7ea265251dad" translate="yes" xml:space="preserve">
          <source>There are two approaches to making computation code cancellable. The first one is to periodically invoke a suspending function that checks for cancellation. There is a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;yield&lt;/a&gt; function that is a good choice for that purpose. The other one is to explicitly check the cancellation status. Let us try the latter approach.</source>
          <target state="translated">계산 코드를 취소 할 수있는 방법에는 두 가지가 있습니다. 첫 번째는 취소를 확인하는 일시 중단 기능을 주기적으로 호출하는 것입니다. 이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html&quot;&gt;항복&lt;/a&gt; 목적을위한 좋은 선택이다 기능. 다른 하나는 취소 상태를 명시 적으로 확인하는 것입니다. 후자의 접근법을 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="cdb0e62ebdac6496d2a6cecaea4c9ddd6a113e2b" translate="yes" xml:space="preserve">
          <source>There are two functions for which the compiler gives same name in JavaScript, you can mark one with &lt;code&gt;@JsName(...)&lt;/code&gt; to prevent the compiler from reporting error.</source>
          <target state="translated">컴파일러에서 JavaScript로 동일한 이름을 제공하는 두 가지 함수 가 있습니다. 컴파일러에서 오류를보고하지 않도록 &lt;code&gt;@JsName(...)&lt;/code&gt; 으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="538a207adbe54f7fe71914302d366f642c584d32" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with marking your API as experimental too, or without doing that.</source>
          <target state="translated">서명되지 않은 유형을 선택하는 두 가지 방법이 있습니다. API를 실험용으로 표시하거나 수행하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8fb334f842c55f58127659b8b13256439fde4f09" translate="yes" xml:space="preserve">
          <source>There are two possible ways to opt-in for unsigned types: with requiring an opt-in for your API, or without doing that.</source>
          <target state="translated">서명되지 않은 유형에 대해 옵트 인하는 방법에는 두 가지가 있습니다. API에 대한 옵트 인을 요구하거나 그렇게하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="33427a641bab71be82e1a6d8c670d7484fef5041" translate="yes" xml:space="preserve">
          <source>There are two ways you can create the hierarchical structure:</source>
          <target state="translated">다음 두 가지 방법으로 계층 구조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b3923915c4ddd4dd399b02f1d436b8dc853f8d" translate="yes" xml:space="preserve">
          <source>There can be different modes of stability depending of how quickly a component is evolving:</source>
          <target state="translated">구성 요소가 얼마나 빠르게 발전하고 있는지에 따라 다양한 안정성 모드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b3f1a4d9ad65e8f5f359abf2fed82920c3beef2" translate="yes" xml:space="preserve">
          <source>There have been many approaches to solving this problem, including:</source>
          <target state="translated">이 문제를 해결하기위한 많은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4dc29b34f77a8368125ef8d384ca8b6bfbe8472" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; field that represents the &lt;code&gt;Clazz&lt;/code&gt; from Kotlin. The &lt;code&gt;Clazz#memberFunction&lt;/code&gt; is accessible with the &lt;code&gt;memberFunction&lt;/code&gt; field. The only difference is that the &lt;code&gt;memberFunction&lt;/code&gt; accepts a &lt;code&gt;this&lt;/code&gt; reference as the first parameter. The C language does not support objects, and this is the reason to pass a &lt;code&gt;this&lt;/code&gt; pointer explicitly.</source>
          <target state="translated">있다 &lt;code&gt;kotlin.root.example.Clazz&lt;/code&gt; 의 나타내는 필드 &lt;code&gt;Clazz&lt;/code&gt; 코 틀린에서가. &lt;code&gt;Clazz#memberFunction&lt;/code&gt; 에 액세스 할 수 &lt;code&gt;memberFunction&lt;/code&gt; 의 필드. 유일한 차이점은 &lt;code&gt;memberFunction&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 참조를 첫 번째 매개 변수로 승인 한다는 것 입니다. C 언어는 개체를 지원하지 않으며, 이것은 전달하는 이유는 &lt;code&gt;this&lt;/code&gt; 명시 적으로 포인터를.</target>
        </trans-unit>
        <trans-unit id="725365acc046d2774e785fd58198ecf73c6aec56" translate="yes" xml:space="preserve">
          <source>There is a better solution. We can use structured concurrency in our code. Instead of launching coroutines in the &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;, just like we usually do with threads (threads are always global), we can launch coroutines in the specific scope of the operation we are performing.</source>
          <target state="translated">더 나은 해결책이 있습니다. 코드에서 구조적 동시성을 사용할 수 있습니다. &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 코 루틴을 시작하는 대신 , 일반적으로 스레드를 사용하는 것처럼 (스레드는 항상 글로벌 임) 수행중인 특정 작업 범위에서 코 루틴을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b1300b6ec8e15e33a7b0dfe89c4e2e11e628f0" translate="yes" xml:space="preserve">
          <source>There is a bunch of new extensions on the String class to convert it to a number without throwing an exception on invalid number: &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt;, &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; etc.</source>
          <target state="translated">String 클래스에는 유효하지 않은 숫자에 대한 예외를 발생시키지 않고 숫자로 변환하는 새로운 확장 기능이 많이 있습니다. &lt;code&gt;String.toIntOrNull(): Int?&lt;/code&gt; , &lt;code&gt;String.toDoubleOrNull(): Double?&lt;/code&gt; 기타</target>
        </trans-unit>
        <trans-unit id="2d16488afd500f574acdf4a610fe81c8b613729f" translate="yes" xml:space="preserve">
          <source>There is a common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">변수를 &lt;code&gt;volatile&lt;/code&gt; 만들면 동시성 문제가 해결 된다는 일반적인 오해가 있습니다. 시도해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7e33e2bb2c0c45c94e894d38130281f13150c4a3" translate="yes" xml:space="preserve">
          <source>There is a constructor in the &lt;code&gt;Clazz&lt;/code&gt; field (aka &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt;), which is the constructor function to create an instance of the &lt;code&gt;Clazz&lt;/code&gt;.</source>
          <target state="translated">에서 생성자가 &lt;code&gt;Clazz&lt;/code&gt; 필드 (일명 &lt;code&gt;kotlin.root.example.Clazz.Clazz&lt;/code&gt; 의 인스턴스를 생성하는 생성자 함수이다) &lt;code&gt;Clazz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8e6c9d338e18c01513c4cf42dbec9a1ab61f7aa" translate="yes" xml:space="preserve">
          <source>There is a convenient coroutine builder named &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; that makes it easy to do it right on producer side, and an extension function &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt;, that replaces a &lt;code&gt;for&lt;/code&gt; loop on the consumer side:</source>
          <target state="translated">편리한 코 루틴 빌더의 이름이 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;생산&lt;/a&gt; 쉽게 바로 생산자 측에서 그것을 할 수 있습니다, 그리고 확장 기능 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/consume-each.html&quot;&gt;consumeEach&lt;/a&gt; A와 교체, &lt;code&gt;for&lt;/code&gt; 소비자 측 루프 :</target>
        </trans-unit>
        <trans-unit id="2dc05473a597a891dd992cdcf3cb31ec48971266" translate="yes" xml:space="preserve">
          <source>There is a laziness option to &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; using an optional &lt;code&gt;start&lt;/code&gt; parameter with a value of &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt;. It starts coroutine only when its result is needed by some &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;await&lt;/a&gt; or if a &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;start&lt;/a&gt; function is invoked. Run the following example:</source>
          <target state="translated">&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y.html&quot;&gt;CoroutineStart.LAZY&lt;/a&gt; 값을 갖는 선택적 &lt;code&gt;start&lt;/code&gt; 매개 변수를 사용하여 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;비동기&lt;/a&gt; 하는 게으름 옵션이 있습니다 . 일부 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html&quot;&gt;대기자&lt;/a&gt; 가 결과를 필요로 하거나 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/start.html&quot;&gt;시작&lt;/a&gt; 함수가 호출 된 경우 에만 코 루틴을 시작 합니다. 다음 예제를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="64fbf3e4d33c3845151425fcbae0bd95c1ac7ffc" translate="yes" xml:space="preserve">
          <source>There is a nice piece of syntactic sugar that lets you do this: &lt;em&gt;extension functions&lt;/em&gt; and &lt;em&gt;extension properties&lt;/em&gt;. They look like regular member functions/properties, but they are defined outside of any class - yet they reference the class name and can use &lt;code&gt;this&lt;/code&gt;. However, they can only use visible members of the class (typically just the public ones). Behind the scenes, they get compiled down to regular functions that take the target instance as a parameter.</source>
          <target state="translated">이를 수행 할 수있는 멋진 구문 설탕 조각이 있습니다 : &lt;em&gt;확장 함수&lt;/em&gt; 및 &lt;em&gt;확장 속성&lt;/em&gt; . 일반 멤버 함수 / 속성처럼 보이지만 클래스 외부에서 정의되어 있지만 클래스 이름을 참조하여 &lt;code&gt;this&lt;/code&gt; 사용할 수 있습니다 . 그러나 클래스의 보이는 멤버 만 (일반적으로 공개 멤버 만) 사용할 수 있습니다. 배후에서 대상 인스턴스를 매개 변수로 사용하는 일반 함수로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="56a1a93e9823bbcbe462dd3f2561922740df0cc6" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; extension function that conveniently represents &lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; pattern:</source>
          <target state="translated">&lt;code&gt;mutex.lock(); try { ... } finally { mutex.unlock() }&lt;/code&gt; 을 편리하게 나타내는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/with-lock.html&quot;&gt;withLock&lt;/a&gt; 확장 함수 도 있습니다 . {...} 마지막으로 {mutex.unlock ()} 패턴을 시도하십시오 .</target>
        </trans-unit>
        <trans-unit id="5482d8805716b35d94ddb1402c557dc6720d3835" translate="yes" xml:space="preserve">
          <source>There is also a pair of functions that take a predicate and search for elements matching it:</source>
          <target state="translated">술어를 가져 와서 일치하는 요소를 검색하는 함수 쌍도 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c042439b9082c369e4da946808b3cddd767bd9" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; coroutine builder that conveniently combines actor's mailbox channel into its scope to receive messages from and combines the send channel into the resulting job object, so that a single reference to the actor can be carried around as its handle.</source>
          <target state="translated">액터의 우편함 채널을 범위로 편리하게 결합하여 송신 채널을 결과 작업 오브젝트로부터 수신하고 결합하여 액터에 대한 단일 참조를 처리 할 수 있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;액터&lt;/a&gt; 코 루틴 빌더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44464d4de5fbd249cc21009c9fb2f52893bbcce" translate="yes" xml:space="preserve">
          <source>There is an optimization that removes redundant arrays creation in such cases, which prevents performance degradation. The single-argument form produces warnings in Kotlin 1.2 and is to be dropped in Kotlin 1.3.</source>
          <target state="translated">이러한 경우 중복 어레이 생성을 제거하여 성능 저하를 방지하는 최적화가 있습니다. 단일 인수 형식은 Kotlin 1.2에서 경고를 생성하며 Kotlin 1.3에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4b4c7df274b19d3bf5dccee93fd3962d578245" translate="yes" xml:space="preserve">
          <source>There is an option to publish variants grouped by the product flavor, so that the outputs of the different build types are placed in a single module, with the build type becoming a classifier for the artifacts (the release build type is still published with no classifier). This mode is disabled by default and can be enabled as follows:</source>
          <target state="translated">제품 플레이버별로 그룹화 된 변형을 게시 할 수있는 옵션이 있으므로 빌드 유형이 아티팩트의 분류자가되는 빌드 유형이 서로 다른 빌드 유형의 출력이 단일 모듈에 배치됩니다 (릴리스 빌드 유형은 분류자가없는 상태로 여전히 공개됨) ). 이 모드는 기본적으로 비활성화되어 있으며 다음과 같이 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a3b908fffabfbd0bb64797382bd07626137ec3f" translate="yes" xml:space="preserve">
          <source>There is common misconception that making a variable &lt;code&gt;volatile&lt;/code&gt; solves concurrency problem. Let us try it:</source>
          <target state="translated">변수를 &lt;code&gt;volatile&lt;/code&gt; 만드는 것이 동시성 문제를 해결 한다는 일반적인 오해가 있습니다. 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="5eb09ee69535cf6dda53683554e0ee16259161ba" translate="yes" xml:space="preserve">
          <source>There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given &lt;code&gt;char *&lt;/code&gt; means a C string in the context. Strings in the C language are null-terminated, a trailing zero character &lt;code&gt;\0&lt;/code&gt; is added at the end of a bytes sequence to mark a string termination. Usually, &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8 encoded strings&lt;/a&gt; are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;. Kotlin/Native uses UTF-8 character encoding by default.</source>
          <target state="translated">문자열에 대한 C 언어에는 전용 유형이 없습니다. 개발자는 주어진 &lt;code&gt;char *&lt;/code&gt; 가 컨텍스트에서 C 문자열을 의미 하는지 여부를 메소드 서명 또는 문서에서 알고 있습니다 . C 언어의 문자열은 null로 끝나고 문자열 시퀀스를 표시하기 위해 바이트 시퀀스의 끝에 후행 0 문자 &lt;code&gt;\0&lt;/code&gt; 이 추가됩니다. 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8로 인코딩 된 문자열&lt;/a&gt; 이 사용됩니다. UTF-8 인코딩은 가변 너비 문자를 사용하며 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; 와 역 호환됩니다 . Kotlin / Native는 기본적으로 UTF-8 문자 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="50408f344ff56fd13407ed98b66fe0baaa2ef0c5" translate="yes" xml:space="preserve">
          <source>There is no longer an exception when running this code:</source>
          <target state="translated">이 코드를 실행할 때 더 이상 예외가 없습니다.</target>
        </trans-unit>
        <trans-unit id="edef4e6315a2b596a0ca3836f2b3be1feee84974" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.</source>
          <target state="translated">이 클래스의 값에 첨부 된 의미는 없으며 어떤 목적으로도 사용할 수 있습니다. 쌍은 값 의미를 나타냅니다. 즉 두 구성 요소가 모두 같으면 두 쌍이 같습니다.</target>
        </trans-unit>
        <trans-unit id="0049a565ebb0e6780625b95d2507e4c5901c80a7" translate="yes" xml:space="preserve">
          <source>There is no meaning attached to values in this class, it can be used for any purpose. Triple exhibits value semantics, i.e. two triples are equal if all three components are equal. An example of decomposing it into values:</source>
          <target state="translated">이 클래스의 값에 첨부 된 의미는 없으며 어떤 목적으로도 사용할 수 있습니다. 트리플은 가치 의미론을 나타냅니다. 즉, 세 구성 요소가 모두 같으면 두 트리플이 같습니다. 값으로 분해하는 예 :</target>
        </trans-unit>
        <trans-unit id="1dd7b0fcce3d3026dd4903ea1dcae2ace7aba63b" translate="yes" xml:space="preserve">
          <source>There is no namespaces support in C, so the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.</source>
          <target state="translated">C에서는 네임 스페이스가 지원되지 않으므로 Kotlin / Native 컴파일러는 기존 기본 프로젝트의 다른 기호와 충돌을 피하기 위해 긴 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9fc7acf9c721c77f449446dbc8b3636586ef2efc" translate="yes" xml:space="preserve">
          <source>There is no need to consider compatibility for new interfaces, as no clients have used them before. You can minimize the compatibility overhead by excluding these interfaces from the compatibility mode. To do this, annotate them with the &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; annotation. Such interfaces compile the same way as with &lt;code&gt;-Xjvm-default=all&lt;/code&gt;.</source>
          <target state="translated">새로운 인터페이스에 대한 호환성을 고려할 필요가 없습니다. 이전에 사용한 적이없는 클라이언트가 있기 때문입니다. 호환성 모드에서 이러한 인터페이스를 제외하여 호환성 오버 헤드를 최소화 할 수 있습니다. 이렇게하려면 &lt;code&gt;@JvmDefaultWithoutCompatibility&lt;/code&gt; 어노테이션으로 어노테이션을 작성하십시오. 이러한 인터페이스는 &lt;code&gt;-Xjvm-default=all&lt;/code&gt; 과 같은 방식으로 컴파일 됩니다 .</target>
        </trans-unit>
        <trans-unit id="8859e68bee06f71aa7ff22831dc050e526d2f13b" translate="yes" xml:space="preserve">
          <source>There is no need to handle the case of misformatted input in competitive programming. In competitive programming, an input format is always precisely specified and the actual input cannot deviate from the input specification in the problem statement. That's what the null-assertion operator &lt;code&gt;!!&lt;/code&gt; essentially does &amp;mdash; it asserts that the input string is present and throws an exception otherwise. Likewise, the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt()&lt;/a&gt; function throws an exception if the input string is not an integer.</source>
          <target state="translated">경쟁 프로그래밍에서 형식이 잘못된 입력의 경우를 처리 할 필요가 없습니다. 경쟁 프로그래밍에서 입력 형식은 항상 정확하게 지정되며 실제 입력은 문제 설명의 입력 사양에서 벗어날 수 없습니다. 이것이 널 어설 션 연산자입니다 &lt;code&gt;!!&lt;/code&gt; 본질적으로-입력 문자열이 존재한다고 주장하고 그렇지 않으면 예외가 발생합니다. 마찬가지로 입력 문자열이 정수가 아닌 경우 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.text/to-int&quot;&gt;String.toInt ()&lt;/a&gt; 함수는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c6d0ebaf0b7e6376420eb9484810949b156e1e12" translate="yes" xml:space="preserve">
          <source>There is no such syntax in Kotlin. However, in Kotlin we have &lt;a href=&quot;object-declarations#companion-objects&quot;&gt;&lt;code&gt;companion&lt;/code&gt;&lt;/a&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; classes in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. &lt;code&gt;MyClass&lt;/code&gt; from the example above can be described as follows:</source>
          <target state="translated">Kotlin에는 이러한 구문이 없습니다. 그러나 Kotlin에는 &lt;a href=&quot;object-declarations#companion-objects&quot;&gt; &lt;code&gt;companion&lt;/code&gt; &lt;/a&gt; 객체가 있습니다. Kotlin은 &lt;code&gt;external&lt;/code&gt; 클래스 의 컴패니언 개체를 특별한 방식으로 처리합니다. 개체를 기대하는 대신 컴패니언 개체의 멤버를 클래스 자체의 멤버로 가정합니다. 위 예제의 &lt;code&gt;MyClass&lt;/code&gt; 는 다음과 같이 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e914e64115449100ebfd64599edfd2968cff02a7" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">현재 지원되는 플랫폼마다 다양한 &lt;a href=&quot;building-mpp-with-gradle#supported-platforms&quot;&gt;사전 설정 플랫폼 구성&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c9261e9c8424c9800b6b0327e8368a8f20c36c1" translate="yes" xml:space="preserve">
          <source>There is now a large number of &lt;a href=&quot;mpp-supported-platforms&quot;&gt;preset platform configurations&lt;/a&gt; for different supported platforms.</source>
          <target state="translated">이제 지원되는 다양한 &lt;a href=&quot;mpp-supported-platforms&quot;&gt;플랫폼에&lt;/a&gt; 대해 많은 사전 설정된 플랫폼 구성 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b648b3a77b4b2e5fa4527e728e2d5fe0ae2a410" translate="yes" xml:space="preserve">
          <source>There is one important semantic difference between object expressions and object declarations:</source>
          <target state="translated">객체 표현과 객체 선언 사이에는 중요한 의미 론적 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd6b73de53838cea1717936197f551e12e9d247" translate="yes" xml:space="preserve">
          <source>There is one more way to search elements in lists &amp;ndash; &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt;. It works significantly faster than other built-in search functions but &lt;em&gt;requires the list to be &lt;a href=&quot;collection-ordering&quot;&gt;sorted&lt;/a&gt;&lt;/em&gt; in ascending order according to a certain ordering: natural or another one provided in the function parameter. Otherwise, the result is undefined.</source>
          <target state="translated">목록에서 요소를 검색하는 또 다른 방법 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;이진 검색이&lt;/a&gt; 있습니다. 다른 내장 검색 기능보다 훨씬 빠르지 만 특정 순서에 따라 &lt;em&gt;목록을&lt;a href=&quot;collection-ordering&quot;&gt;&lt;/a&gt;&lt;/em&gt; 오름차순으로 &lt;em&gt;정렬&lt;/em&gt;&lt;em&gt; 해야합니다 (&lt;/em&gt; 자연 또는 함수 매개 변수에 제공된 다른 순서). 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4497244354ad07743aea06bad3f15a18c72b5c2" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">코 루틴의 실제 사용을 위해 여전히 바람직한 것이 있습니다. &lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 사용하면 최상위 코 루틴을 만듭니다. 가볍지 만 실행하는 동안 여전히 일부 메모리 리소스를 사용합니다. 새로 출시 된 코 루틴에 대한 참조를 유지하지 않으면 여전히 실행됩니다. 코 루틴의 코드가 멈 추면 (예를 들어, 너무 오래 지연되는 경우) 코 루틴을 너무 많이 시작하고 메모리가 부족하면 어떻게합니까? 실행 된 모든 코 루틴에 대한 참조를 수동으로 유지하고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;결합&lt;/a&gt; 해야하는 것은 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c2958b4b7d6ee3fe23d0044dbf293010b99dd8e5" translate="yes" xml:space="preserve">
          <source>There is still something to be desired for practical usage of coroutines. When we use &lt;code&gt;GlobalScope.launch&lt;/code&gt;, we create a top-level coroutine. Even though it is light-weight, it still consumes some memory resources while it runs. If we forget to keep a reference to the newly launched coroutine, it still runs. What if the code in the coroutine hangs (for example, we erroneously delay for too long), what if we launched too many coroutines and ran out of memory? Having to manually keep references to all the launched coroutines and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;join&lt;/a&gt; them is error-prone.</source>
          <target state="translated">코 루틴의 실제 사용을 위해 여전히 원하는 것이 있습니다. &lt;code&gt;GlobalScope.launch&lt;/code&gt; 를 사용할 때 최상위 코 루틴을 만듭니다. 가볍지 만 실행하는 동안 여전히 일부 메모리 리소스를 소비합니다. 새로 시작된 코 루틴에 대한 참조를 유지하는 것을 잊더라도 여전히 실행됩니다. 코 루틴의 코드가 멈춘다면 (예를 들어, 너무 오래 지연되는 경우), 너무 많은 코 루틴을 시작하고 메모리가 부족하면 어떻게 될까요? 실행 된 모든 코 루틴에 대한 참조를 수동으로 유지하고 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/join.html&quot;&gt;조인&lt;/a&gt; 해야하는 것은 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="01079d64cb67e3f5b3eb1ab0a3228010e68dcdd0" translate="yes" xml:space="preserve">
          <source>There may be times when you need to quickly write and execute code outside of a project or application. This may be useful, for example, when learning Kotlin or evaluating expressions. Let's have a look at three handy ways we can use to run Kotlin code quickly:</source>
          <target state="translated">프로젝트 또는 애플리케이션 외부에서 코드를 빠르게 작성하고 실행해야하는 경우가 있습니다. 예를 들어 Kotlin을 배우거나 표현식을 평가할 때 유용 할 수 있습니다. Kotlin 코드를 빠르게 실행하는 데 사용할 수있는 세 가지 편리한 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="98631247ce5d35bfa57c2de9453651ac4adc252b" translate="yes" xml:space="preserve">
          <source>There may be zero or more &lt;em&gt;catch&lt;/em&gt; blocks. &lt;em&gt;finally&lt;/em&gt; block may be omitted. However at least one &lt;em&gt;catch&lt;/em&gt; or &lt;em&gt;finally&lt;/em&gt; block should be present.</source>
          <target state="translated">&lt;em&gt;캐치&lt;/em&gt; 블록 이 0 개 이상있을 수 있습니다 . &lt;em&gt;마지막으로&lt;/em&gt; 블록은 생략 될 수 있습니다. 그러나 적어도 하나의 &lt;em&gt;catch&lt;/em&gt; 또는 &lt;em&gt;finally&lt;/em&gt; 블록이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f116d6d19440fd947335171cc03cdab27f6adc4e" translate="yes" xml:space="preserve">
          <source>There will be a property named &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 라는 속성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="def4b70b1b61bdf7178a471139f991f3029fb44c" translate="yes" xml:space="preserve">
          <source>There will only ever be one instance of this class, and the instance (which is created the first time it is accessed, in a thread-safe manner) has got the same name as the class:</source>
          <target state="translated">이 클래스의 인스턴스는 하나 뿐이며 인스턴스 (스레드에 안전한 방식으로 처음 액세스 할 때 생성됨)는 클래스와 동일한 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6f9f7587a2e090ad5e29fbff32347947646d8531" translate="yes" xml:space="preserve">
          <source>There's a little bit of runtime overhead associated with lambda functions: they are really objects, so they must be instantiated, and (like other functions) calling them takes a little bit of time too. If we use the &lt;code&gt;inline&lt;/code&gt; keyword on a function, we tell the compiler to &lt;em&gt;inline&lt;/em&gt; both the function and its lambda parameters (if any) - that is, the compiler will copy the code of the function (and its lambda parameters) into &lt;em&gt;every&lt;/em&gt; callsite, thus eliminating the overhead of both the lambda instantiation and the calling of the function and the lambdas. This will happen unconditionally, unlike in C and C++, where &lt;code&gt;inline&lt;/code&gt; is more of a hint to the compiler. This will cause the size of the compiled code to grow, but it may be worth it for certain small but frequently-called functions.</source>
          <target state="translated">람다 함수와 관련된 런타임 오버 헤드가 약간 있습니다. 실제로는 객체이므로 인스턴스화해야하며 (다른 함수와 마찬가지로) 호출하는 데 약간의 시간이 걸립니다. 함수에 &lt;code&gt;inline&lt;/code&gt; 키워드를 사용하면 컴파일러에 함수와 해당 람다 매개 변수 (있는 경우)를 모두 &lt;em&gt;인라인&lt;/em&gt; 하도록 지시 합니다. 즉, 컴파일러는 함수 코드 (및 람다 매개 변수)를 &lt;em&gt;모든&lt;/em&gt; 호출 사이트에 복사합니다. 따라서 람다 인스턴스화와 함수 호출 및 람다 모두의 오버 헤드를 제거합니다. &lt;code&gt;inline&lt;/code&gt; C 및 C ++과 달리 무조건적으로 발생합니다.컴파일러에 대한 힌트입니다. 이로 인해 컴파일 된 코드의 크기가 커지지 만 작지만 자주 호출되는 특정 기능에는 유용 ​​할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db5770d8b83e30706aed362d9428bb0d8466fab" translate="yes" xml:space="preserve">
          <source>There's a vast collection of functional programming-style operations available in the &lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt;&lt;code&gt;kotlin.collections&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../api/latest/jvm/stdlib/kotlin.collections/index&quot;&gt; &lt;code&gt;kotlin.collections&lt;/code&gt; 패키지&lt;/a&gt; 에는 다양한 기능적 프로그래밍 스타일 작업 모음이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="202786b020b9056a1534a505736791f80248ba7e" translate="yes" xml:space="preserve">
          <source>There's no 64 bit integer number in JavaScript, so &lt;code&gt;kotlin.Long&lt;/code&gt; is not mapped to any JavaScript object, it's emulated by a Kotlin class.</source>
          <target state="translated">JavaScript에는 64 비트 정수 가 없으므로 &lt;code&gt;kotlin.Long&lt;/code&gt; 은 JavaScript 객체에 매핑되지 않으며 Kotlin 클래스에 의해 에뮬레이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9178e1d163a2f07f63e80e90e8b72e40666cb6be" translate="yes" xml:space="preserve">
          <source>There's no such syntax in Kotlin. However, in Kotlin we have &lt;code&gt;companion&lt;/code&gt; objects. Kotlin treats companion objects of &lt;code&gt;external&lt;/code&gt; class in a special way: instead of expecting an object, it assumes members of companion objects to be members of the class itself. To describe &lt;code&gt;MyClass&lt;/code&gt; from the example above, you can write:</source>
          <target state="translated">코 틀린에는 그러한 구문이 없습니다. 그러나 Kotlin에는 &lt;code&gt;companion&lt;/code&gt; 개체가 있습니다. Kotlin은 &lt;code&gt;external&lt;/code&gt; 클래스 의 컴패니언 객체를 특별한 방식으로 처리합니다. 객체를 기대하는 대신 컴패니언 객체의 멤버를 클래스 자체의 멤버로 가정합니다. 위 예제에서 &lt;code&gt;MyClass&lt;/code&gt; 를 설명하기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918d499d192390404b8163b61ae9ad18a046a4a8" translate="yes" xml:space="preserve">
          <source>There's two forms of using &lt;code&gt;definedExternally&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;definedExternally&lt;/code&gt; 를 사용하는 데는 두 가지 형태가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d27760789bc7d15f7cae3944fffbd1ed1e60b2e" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">따라서 일부 조건을 확인하여 쓰기 잠금 내부 의 &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;작업을&lt;/a&gt; 시작한 경우 가능한 경쟁을 피하기 위해 &lt;a href=&quot;write#kotlin.concurrent%24write%28java.util.concurrent.locks.ReentrantReadWriteLock%2C+kotlin.Function0%28%28kotlin.concurrent.write.T%29%29%29%2Faction&quot;&gt;작업&lt;/a&gt; 내에서 조건을 다시 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e58964a321357f25142def10569f3d0cf1f1691d" translate="yes" xml:space="preserve">
          <source>Therefore if the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; inside write lock has been initiated by checking some condition, the condition must be rechecked inside the &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;action&lt;/a&gt; to avoid possible races.</source>
          <target state="translated">따라서 쓰기 잠금 내부 &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;작업&lt;/a&gt; 이 일부 조건을 확인하여 시작된 경우 가능한 경합을 피하기 위해 &lt;a href=&quot;write#kotlin.concurrent%24write(java.util.concurrent.locks.ReentrantReadWriteLock,%20kotlin.Function0((kotlin.concurrent.write.T)))/action&quot;&gt;작업&lt;/a&gt; 내부에서 조건을 다시 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f17bb5adc41c5c7eefa8d167c2c05552954588a" translate="yes" xml:space="preserve">
          <source>Therefore, the two following snippets are equivalent:</source>
          <target state="translated">따라서 다음 두 스 니펫은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b2fcfe97b28b6d55545bf13f39eacf58d2cbb997" translate="yes" xml:space="preserve">
          <source>Therefore, there is no general way to check whether an instance of a generic type was created with certain type arguments at runtime, and the compiler &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;prohibits such &lt;em&gt;is&lt;/em&gt;-checks&lt;/a&gt;.</source>
          <target state="translated">따라서 런타임에 제네릭 형식의 인스턴스가 특정 형식 인수를 사용하여 만들어 졌는지 여부를 확인하는 일반적인 방법은 없으며 컴파일러 &lt;a href=&quot;typecasts#type-erasure-and-generic-type-checks&quot;&gt;&lt;em&gt;는&lt;/em&gt;&lt;/a&gt; -checks를 금지&lt;em&gt;&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ba4578c0908f499a877e6e75a3e1e8fb6ca14fec" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;unchecked casts&lt;/a&gt; can be used when type safety is implied by the high-level program logic but cannot be inferred directly by the compiler. The compiler issues a warning on unchecked casts, and at runtime, only the non-generic part is checked (equivalent to &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">이러한 &lt;a href=&quot;typecasts#unchecked-casts&quot;&gt;검사되지 않은 캐스트&lt;/a&gt; 는 유형 안전이 고급 프로그램 논리에 의해 암시되지만 컴파일러가 직접 유추 할 수없는 경우에 사용할 수 있습니다. 컴파일러는 검사되지 않은 캐스트에 대해 경고를 발행하고 런타임에 제네릭이 아닌 부분 만 검사합니다 ( &lt;code&gt;foo as List&amp;lt;*&amp;gt;&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="dd3d3ea77431105543bdd1015eeb929086add1c8" translate="yes" xml:space="preserve">
          <source>These abstract classes can be used as base classes when implementing Kotlin collection classes. For implementing read-only collections there are &lt;code&gt;AbstractCollection&lt;/code&gt;, &lt;code&gt;AbstractList&lt;/code&gt;, &lt;code&gt;AbstractSet&lt;/code&gt; and &lt;code&gt;AbstractMap&lt;/code&gt;, and for mutable collections there are &lt;code&gt;AbstractMutableCollection&lt;/code&gt;, &lt;code&gt;AbstractMutableList&lt;/code&gt;, &lt;code&gt;AbstractMutableSet&lt;/code&gt; and &lt;code&gt;AbstractMutableMap&lt;/code&gt;. On JVM these abstract mutable collections inherit most of their functionality from JDK's abstract collections.</source>
          <target state="translated">Kotlin 컬렉션 클래스를 구현할 때 이러한 추상 클래스를 기본 클래스로 사용할 수 있습니다. 읽기 전용 컬렉션을 구현하기 위해 &lt;code&gt;AbstractCollection&lt;/code&gt; , &lt;code&gt;AbstractList&lt;/code&gt; , &lt;code&gt;AbstractSet&lt;/code&gt; 및 &lt;code&gt;AbstractMap&lt;/code&gt; 이 있으며 변경 가능한 컬렉션에는 &lt;code&gt;AbstractMutableCollection&lt;/code&gt; , &lt;code&gt;AbstractMutableList&lt;/code&gt; , &lt;code&gt;AbstractMutableSet&lt;/code&gt; 및 &lt;code&gt;AbstractMutableMap&lt;/code&gt; 이 있습니다. JVM에서 이러한 추상 가변 콜렉션은 JDK의 추상 콜렉션에서 대부분의 기능을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="aae55c4083a74f1ac27e26d5124083a7a6b3b4cb" translate="yes" xml:space="preserve">
          <source>These are the &lt;a href=&quot;#default-project-layout&quot;&gt;default source set names&lt;/a&gt; for the production and test sources for the targets configured above. The source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are included into production and test compilations, respectively, of all targets. Note that the dependencies for common source sets &lt;code&gt;commonMain&lt;/code&gt; and &lt;code&gt;commonTest&lt;/code&gt; are the common artifacts, and the platform libraries go to the source sets of the specific targets.</source>
          <target state="translated">이들은입니다 &lt;a href=&quot;#default-project-layout&quot;&gt;기본 소스 세트 이름&lt;/a&gt; 위의 구성 대상에 대한 생산 및 테스트 소스. &lt;code&gt;commonMain&lt;/code&gt; 및 &lt;code&gt;commonTest&lt;/code&gt; 소스 세트 는 모든 대상의 프로덕션 및 테스트 컴파일에 각각 포함됩니다. 공통 소스 세트 &lt;code&gt;commonMain&lt;/code&gt; 및 &lt;code&gt;commonTest&lt;/code&gt; 에 대한 종속성 은 공통 아티팩트이며 플랫폼 라이브러리는 특정 대상의 소스 세트로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6c67dd2d501b6f7860e7b47d523d2ae61bab43e4" translate="yes" xml:space="preserve">
          <source>These are three general-purpose extension functions applicable to any receiver.</source>
          <target state="translated">이는 모든 수신기에 적용 가능한 3 가지 범용 확장 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a31b00eaf51e9ded931a5bcf77718ad763afbdf7" translate="yes" xml:space="preserve">
          <source>These changes are relevant only for projects with the hierarchical project structure.</source>
          <target state="translated">이러한 변경 사항은 계층 적 프로젝트 구조를 가진 프로젝트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b13209452f2b9faee7dc51d424f004345829a7e" translate="yes" xml:space="preserve">
          <source>These compilers are used by the IDE when you click the &lt;strong&gt;Compile&lt;/strong&gt; or &lt;strong&gt;Run&lt;/strong&gt; button for your Kotlin project.</source>
          <target state="translated">이러한 컴파일러는 Kotlin 프로젝트 의 &lt;strong&gt;컴파일&lt;/strong&gt; 또는 &lt;strong&gt;실행&lt;/strong&gt; 버튼을 클릭 할 때 IDE에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a99a063b2c797ffc59fde5538599b9e6760c083" translate="yes" xml:space="preserve">
          <source>These considerations lead to the following rules. A covariant type parameter &lt;code&gt;T&lt;/code&gt; (which the user of an object might think is &lt;code&gt;Fruit&lt;/code&gt;, while the object in reality is tied to &lt;code&gt;Apple&lt;/code&gt;) may be used as:</source>
          <target state="translated">이러한 고려 사항은 다음 규칙으로 이어집니다. 공변량 유형 매개 변수 &lt;code&gt;T&lt;/code&gt; (객체의 사용자가 &lt;code&gt;Fruit&lt;/code&gt; 라고 생각할 수 있지만 실제로는 객체가 &lt;code&gt;Apple&lt;/code&gt; 에 연결되어 있다고 생각할 수 있음)는 다음과 같이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a12f370f83960d4f7413fab1b904c1e1f23ab2" translate="yes" xml:space="preserve">
          <source>These declarations look clear. All &lt;code&gt;char *&lt;/code&gt; pointers are turned into &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; for parameters and to &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; in return types. Kotlin turns &lt;code&gt;char&lt;/code&gt; type into &lt;code&gt;kotlin.Byte&lt;/code&gt; type, as it is usually an 8-bit signed value.</source>
          <target state="translated">이 선언은 분명해 보인다. 모든 &lt;code&gt;char *&lt;/code&gt; 포인터는 &lt;code&gt;str: CValuesRef&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 매개 변수 및 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;?&lt;/code&gt; 반환 형식으로. Kotlin은 &lt;code&gt;char&lt;/code&gt; 유형을 &lt;code&gt;kotlin.Byte&lt;/code&gt; 유형으로 변환 합니다. 일반적으로 8 비트 부호있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="53e4257de1ac9420719572d5eaf311fafd22b5c2" translate="yes" xml:space="preserve">
          <source>These features are not considered production ready yet, so you need to turn on the &lt;em&gt;experimental mode&lt;/em&gt; in &lt;code&gt;build.gradle&lt;/code&gt; in order to use them:</source>
          <target state="translated">이러한 기능은 아직 프로덕션 준비 상태로 간주되지 않으므로 &lt;code&gt;build.gradle&lt;/code&gt; 에서 &lt;em&gt;실험 모드&lt;/em&gt; 를 켜야 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6b05d8f5b89932c0c2ddc8328889d3567a05266" translate="yes" xml:space="preserve">
          <source>These functions can also be used for converting collections to other types, for example, build a set from a list or vice versa.</source>
          <target state="translated">이 함수는 컬렉션을 다른 형식으로 변환하는데도 사용할 수 있습니다 (예 : 목록에서 집합을 빌드하거나 그 반대로).</target>
        </trans-unit>
        <trans-unit id="d5e9c8cae28543e16ef49eb2054cfc4937ef3fcf" translate="yes" xml:space="preserve">
          <source>These functions can be used for easy copying of maps:</source>
          <target state="translated">이 기능을 사용하면 맵을 쉽게 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7f12885b59bbc14ccabadd6389a34cf6ff8eb2" translate="yes" xml:space="preserve">
          <source>These functions can be used to find the lowest and greatest of two or three given values, where values are primitive numbers or &lt;code&gt;Comparable&lt;/code&gt; objects. There is also an overload of each function that take an additional &lt;code&gt;Comparator&lt;/code&gt; instance, if you want to compare objects that are not comparable themselves.</source>
          <target state="translated">이 함수는 두 개 또는 세 개의 주어진 값 중 가장 작은 값과 가장 큰 값을 찾는 데 사용할 수 있습니다. 여기서 값은 기본 숫자 또는 &lt;code&gt;Comparable&lt;/code&gt; 객체입니다. 자체 비교할 수없는 객체를 비교하려는 경우 추가 &lt;code&gt;Comparator&lt;/code&gt; 인스턴스 를 사용하는 각 함수의 오버로드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7f5c9e85694705edbe3da3b621cafe8f2795f3" translate="yes" xml:space="preserve">
          <source>These functions deal with Kotlin/Native objects. Call the &lt;code&gt;DisposeStablePointer&lt;/code&gt; to release a Kotlin object and &lt;code&gt;DisposeString&lt;/code&gt; to release a Kotlin String, which has the &lt;code&gt;char*&lt;/code&gt; type in C. It is possible to use the &lt;code&gt;IsInstance&lt;/code&gt; function to check if a Kotlin type or a &lt;code&gt;libnative_KNativePtr&lt;/code&gt; is an instance of another type. The actual set of operations generated depends on the actual usages.</source>
          <target state="translated">이 함수는 Kotlin / Native 객체를 처리합니다. 통화 &lt;code&gt;DisposeStablePointer&lt;/code&gt; 코 틀린 객체와 해제 &lt;code&gt;DisposeString&lt;/code&gt; 가 갖는 코 틀린 문자열 해제 &lt;code&gt;char*&lt;/code&gt; 사용하는 것이 가능하다 C.에 입력 &lt;code&gt;IsInstance&lt;/code&gt; 의 코 틀린 종류 나 있는지 확인하는 기능을 &lt;code&gt;libnative_KNativePtr&lt;/code&gt; 는 다른 유형의 인스턴스이다. 생성되는 실제 작업 세트는 실제 사용법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ebcfd0ed6c7e90830065d9ee1e014161378d5e50" translate="yes" xml:space="preserve">
          <source>These include &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;bound callable references&lt;/a&gt; that point to a member of a particular instance: &lt;code&gt;foo::toString&lt;/code&gt;.</source>
          <target state="translated">여기에는 특정 인스턴스의 멤버를 가리키는 &lt;a href=&quot;reflection#bound-function-and-property-references-since-11&quot;&gt;바인딩 된 호출 가능 참조&lt;/a&gt; 가 포함됩니다 ( &lt;code&gt;foo::toString&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="341a2ef673574a4668acee83662de92778d835b1" translate="yes" xml:space="preserve">
          <source>These operators only work with the function &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt;, which can be overridden to provide custom equality check implementation. Any other function with the same name (like &lt;code&gt;equals(other: Foo)&lt;/code&gt;) will not be called.</source>
          <target state="translated">이 연산자는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt; 함수에서만 작동하며, 사용자 정의 동등 검사 구현을 제공하기 위해 재정의 할 수 있습니다. &lt;code&gt;equals(other: Foo)&lt;/code&gt; 같은 이름을 가진 다른 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04c64c9fdc4ddbb026d14664db7dfcf575773eab" translate="yes" xml:space="preserve">
          <source>These options have nearly the same effect as clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt;/&lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; and swiftc's &lt;code&gt;-embed-bitcode&lt;/code&gt;/&lt;code&gt;-embed-bitcode-marker&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션은 clang의 &lt;code&gt;-fembed-bitcode&lt;/code&gt; / &lt;code&gt;-fembed-bitcode-marker&lt;/code&gt; 및 swiftc의 &lt;code&gt;-embed-bitcode&lt;/code&gt; / &lt;code&gt;-embed-bitcode-marker&lt;/code&gt; 와 거의 동일한 효과를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="42a0b78cb4e25be9e1f6ef7cf3d39eb3e781050e" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">이러한 작업은 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.3.41&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant 버전 1.8.2+ 의 &lt;em&gt;lib&lt;/em&gt; 폴더 에있는 &lt;em&gt;kotlin-ant.jar&lt;/em&gt; 라이브러리에 정의되어 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35fb8f738b23790388f177e5975164208ed39249" translate="yes" xml:space="preserve">
          <source>These tasks are defined in the &lt;em&gt;kotlin-ant.jar&lt;/em&gt; library which is located in the &lt;em&gt;lib&lt;/em&gt; folder for the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant version 1.8.2+ is required.</source>
          <target state="translated">이러한 작업은 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;Kotlin Compiler&lt;/a&gt; Ant 버전 1.8.2+ 의 &lt;em&gt;lib&lt;/em&gt; 폴더 에있는 &lt;em&gt;kotlin-ant.jar&lt;/em&gt; 라이브러리에 정의되어 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d0ae43a71338a23e33d7f8aec6b35c87860e63a" translate="yes" xml:space="preserve">
          <source>These transformations can also be applied to &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt;, which is similar to Python's generators and allows for lazy evaluation. If you have a huge list and you want to process it lazily, you can call &lt;code&gt;asSequence()&lt;/code&gt; on it.</source>
          <target state="translated">이러한 변환은 &lt;code&gt;Sequence&amp;lt;T&amp;gt;&lt;/code&gt; 에도 적용 할 수 있으며 , 이는 Python의 생성기와 유사하며 지연 평가를 허용합니다. 거대한 목록이 있고 지연 처리하려면 &lt;code&gt;asSequence()&lt;/code&gt; 를 호출 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="03f364964cb20dc479a4f5003a2a44d235abdb7a" translate="yes" xml:space="preserve">
          <source>These two functions can not be defined side-by-side, because their JVM signatures are the same: &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt;. If we really want them to have the same name in Kotlin, we can annotate one (or both) of them with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt;&lt;code&gt;@JvmName&lt;/code&gt;&lt;/a&gt; and specify a different name as an argument:</source>
          <target state="translated">이 두 함수는 JVM 서명이 동일하므로 나란히 정의 할 수 없습니다. &lt;code&gt;filterValid(Ljava/util/List;)Ljava/util/List;&lt;/code&gt; . Kotlin에서 실제로 동일한 이름을 갖기를 원한다면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index&quot;&gt; &lt;code&gt;@JvmName&lt;/code&gt; &lt;/a&gt; 으로 그들 중 하나 (또는 ​​둘 다)에 주석을 달고 다른 이름을 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="921fb3d0fcc9e0673ab266d259447beb1dbfed2e" translate="yes" xml:space="preserve">
          <source>These two options let you choose the proper function depending on what you do next in your code.</source>
          <target state="translated">이 두 가지 옵션을 사용하면 코드에서 다음에 수행 할 작업에 따라 적절한 기능을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbdf5173288dba5a705ae6e593e7cbdf4691ea2" translate="yes" xml:space="preserve">
          <source>These types are used to map boxed Kotlin number types into Objective-C and Swift. In Swift, we may simply call the constructor to create an instance, e.g. &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt;.</source>
          <target state="translated">이 유형은 박스형 Kotlin 숫자 유형을 Objective-C 및 Swift에 맵핑하는 데 사용됩니다. Swift에서 생성자를 호출하여 인스턴스를 생성 할 수 있습니다 &lt;code&gt;KotlinLong(value: 42)&lt;/code&gt; 예 : KotlinLong (value : 42)) .</target>
        </trans-unit>
        <trans-unit id="c780ae4d91e6b3d59d657bd21738eface7e6d706" translate="yes" xml:space="preserve">
          <source>These types have a special notation that corresponds to the signatures of the functions, i.e. their parameters and return values:</source>
          <target state="translated">이 유형에는 함수의 시그니처, 즉 매개 변수 및 리턴 값에 해당하는 특수 표기법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="49301d7c0ca361c41d110b3bca3a6ef2c53c1486" translate="yes" xml:space="preserve">
          <source>They also can be used in return statements of functions returning the context object.</source>
          <target state="translated">컨텍스트 객체를 반환하는 함수의 return 문에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e6ad519d848a011249fae6e51a09e8caed4ec20" translate="yes" xml:space="preserve">
          <source>They can't be passed as reified type arguments.</source>
          <target state="translated">그것들은 refined type 인수로 전달 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9f968b20031a0c4e81acc38a3f23bdedaba5b962" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (i.e. &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="translated">클래스 리터럴 표현식 (예 : &lt;code&gt;I::class&lt;/code&gt; ) 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="31bcc86b1bb409efa1776fef24979f29b2bad523" translate="yes" xml:space="preserve">
          <source>They can't be used in class literal expressions (such as &lt;code&gt;I::class&lt;/code&gt;).</source>
          <target state="translated">클래스 리터럴 표현식 (예 : &lt;code&gt;I::class&lt;/code&gt; ) 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2f0701452411de1234771e67765d254ade0b6df7" translate="yes" xml:space="preserve">
          <source>They can't be used on the right hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="translated">이들은 오른쪽에 이용 될 수는 &lt;code&gt;is&lt;/code&gt; 검사한다.</target>
        </trans-unit>
        <trans-unit id="a244b209eab02673f1fb27177884b364b4d4031d" translate="yes" xml:space="preserve">
          <source>They can't be used on the right-hand side of &lt;code&gt;is&lt;/code&gt; checks.</source>
          <target state="translated">그들은 오른쪽에 이용 될 수 &lt;code&gt;is&lt;/code&gt; 검사한다.</target>
        </trans-unit>
        <trans-unit id="f1d1a7c20f6efa1c87f68abf4cdd98085a534c8a" translate="yes" xml:space="preserve">
          <source>They include sample projects, which can serve as jumping-off points for your own projects, and contain useful snippets and patterns.</source>
          <target state="translated">여기에는 자체 프로젝트의 시작 지점 역할을 할 수있는 샘플 프로젝트가 포함되며 유용한 스 니펫 및 패턴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="398723a13324bec77451c1ae01057e1ef7af3705" translate="yes" xml:space="preserve">
          <source>They must be member functions or &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;;</source>
          <target state="translated">멤버 함수 또는 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d532a698fc6a89ca0085db59fd5aa194790955a6" translate="yes" xml:space="preserve">
          <source>They must have a single parameter;</source>
          <target state="translated">그것들은 단일 파라미터를 가져야합니다;</target>
        </trans-unit>
        <trans-unit id="91414177a4c44f1c365d06f986fa21be74b2196d" translate="yes" xml:space="preserve">
          <source>They will be compiled accordingly:</source>
          <target state="translated">그에 따라 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="4df440c5a2dac5df94e2c6decf7738ac3f8470ab" translate="yes" xml:space="preserve">
          <source>Third value.</source>
          <target state="translated">세번째 가치.</target>
        </trans-unit>
        <trans-unit id="568f46dc17a32c789437c86db2458bc1fe5ce90c" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;kotlinMultiplatform&lt;/code&gt; publication does not include any artifacts and only references the other publications as its variants. However, it may need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts by using &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt;&lt;code&gt;artifact(...)&lt;/code&gt;&lt;/a&gt; in the publication's scope.</source>
          <target state="translated">이 &lt;code&gt;kotlinMultiplatform&lt;/code&gt; 출판물은 아티팩트를 포함하지 않으며 다른 출판물을 변형으로 만 참조합니다. 그러나 저장소에 필요한 경우 소스 및 문서 아티팩트가 필요할 수 있습니다. 이 경우 게시 범위에서 &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt; &lt;code&gt;artifact(...)&lt;/code&gt; &lt;/a&gt; 를 사용하여 해당 아티팩트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="65054a6c60d19f99f3ba82de08ae0a53fc9c01d3" translate="yes" xml:space="preserve">
          <source>This API can be used to group a collection by key and fold each group simultaneously. For example, it can be used to count the number of words starting with each letter:</source>
          <target state="translated">이 API를 사용하여 키별로 모음을 그룹화하고 각 그룹을 동시에 접을 수 있습니다. 예를 들어, 각 문자로 시작하는 단어 수를 계산하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5e92a8ba9a486d6b6f5f3bfcee1ee9e16e21ffe" translate="yes" xml:space="preserve">
          <source>This Expression</source>
          <target state="translated">이 표현</target>
        </trans-unit>
        <trans-unit id="400a9b5cc1bda6f3a7e49accaa11c2410d235898" translate="yes" xml:space="preserve">
          <source>This JavaScript function can now be used just like a regular Kotlin function. Because we provided type information in the header file (as opposed to simply defining parameter and return type to be &lt;code&gt;dynamic&lt;/code&gt;), proper compiler support and type-checking is also available.</source>
          <target state="translated">이제이 자바 스크립트 함수를 일반 Kotlin 함수처럼 사용할 수 있습니다. 헤더 파일에 유형 정보를 제공했기 때문에 (단순히 매개 변수를 정의하고 유형을 &lt;code&gt;dynamic&lt;/code&gt; 반환하는 대신 ) 적절한 컴파일러 지원 및 유형 검사도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39d8e7ef05f8d1193ddfe60ed385361228082346" translate="yes" xml:space="preserve">
          <source>This allows the Java Persistence API (JPA) to instantiate a class although it doesn't have the zero-parameter constructor from Kotlin or Java point of view (see the description of &lt;code&gt;kotlin-jpa&lt;/code&gt; plugin &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;below&lt;/a&gt;).</source>
          <target state="translated">이것은 Java Persistence API (JPA)가 Kotlin 또는 Java 관점에서 0 매개 변수 생성자를 갖지 않지만 클래스를 인스턴스화 할 수있게합니다 ( &lt;a href=&quot;compiler-plugins#jpa-support&quot;&gt;아래&lt;/a&gt; 의 &lt;code&gt;kotlin-jpa&lt;/code&gt; 플러그인 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="262a7c17763f126ac70f16b74664e0c2732654ca" translate="yes" xml:space="preserve">
          <source>This allows the user code to not pass an extra &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; parameter in basic coroutine builders like &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; and &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt;, but still provide easy access to coroutine context.</source>
          <target state="translated">이를 통해 사용자 코드 는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/launch.html&quot;&gt;launch&lt;/a&gt; 및 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html&quot;&gt;async&lt;/a&gt; 와 같은 기본 코 루틴 빌더에서 추가 &lt;a href=&quot;-coroutine-context/index&quot;&gt;CoroutineContext&lt;/a&gt; 매개 변수를 전달하지 않아도 코 루틴 컨텍스트에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb2da247bb9f320229aba7d44d4da4813d52b5e8" translate="yes" xml:space="preserve">
          <source>This allows us to write:</source>
          <target state="translated">이를 통해 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2943eee5e149bda0a3b90788c4e427a3f77fb555" translate="yes" xml:space="preserve">
          <source>This also a reason why, in these examples, &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; is always installed to a coroutine that is created in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt;. It does not make sense to install an exception handler to a coroutine that is launched in the scope of the main &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt;, since the main coroutine is going to be always cancelled when its child completes with exception despite the installed handler.</source>
          <target state="translated">이 예제에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html&quot;&gt;CoroutineExceptionHandler&lt;/a&gt; 가 항상 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/index.html&quot;&gt;GlobalScope&lt;/a&gt; 에서 작성된 코 루틴에 설치 되는 이유이기도 합니다. 메인 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html&quot;&gt;runBlocking&lt;/a&gt; 범위에서 실행되는 코 루틴에 예외 핸들러를 설치하는 것은 의미가 없습니다 . 메인 핸들러는 설치된 핸들러에도 불구하고 자식이 예외로 완료되면 항상 취소되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="369f2b1361dad7365016272a8691f3b6c2f5f7b0" translate="yes" xml:space="preserve">
          <source>This also works in &lt;a href=&quot;multi-declarations&quot;&gt;destructuring declarations&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;multi-declarations&quot;&gt;선언&lt;/a&gt; 을 파괴하는 데 에도 효과적입니다 .</target>
        </trans-unit>
        <trans-unit id="d8207f40b4373f5ed1c6abf3087010e599937228" translate="yes" xml:space="preserve">
          <source>This annotation can be applied to either files or top-level declarations.</source>
          <target state="translated">이 주석은 파일 또는 최상위 선언에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7624b3ac5961056978ec90a7581d578f33bbbb61" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a JVM method.</source>
          <target state="translated">이 주석은 JVM 메소드로 컴파일 될 때 함수가 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cbf5d9ab056e2f21c12f9f19d919382afdc1ec0d" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method in Kotlin/JVM and Kotlin/Native.</source>
          <target state="translated">이 주석은 Kotlin / JVM 및 Kotlin / Native에서 플랫폼 메소드로 컴파일 할 때 함수에서 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b67d7593eb58defe040aee620d9f9dc5b7b870b" translate="yes" xml:space="preserve">
          <source>This annotation indicates what exceptions should be declared by a function when compiled to a platform method.</source>
          <target state="translated">이 주석은 플랫폼 메소드로 컴파일 될 때 함수가 선언해야하는 예외를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="938e58ea6fe6a8518c5ab92c2083223c5182968a" translate="yes" xml:space="preserve">
          <source>This annotation is also used to discriminate the annotated overloads in case if overload selection still cannot choose one of them even taking in account the result of lambda parameter analysis. In that case a warning is reported.</source>
          <target state="translated">이 주석은 또한 람다 매개 변수 분석의 결과를 고려하더라도 과부하 선택이 여전히 그중 하나를 선택할 수없는 경우 주석이 달린 과부하를 구별하는 데 사용됩니다. 이 경우 경고가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="9cda87fc9471c788eb58ec6f2e67bdf425f08550" translate="yes" xml:space="preserve">
          <source>This annotation is experimental, meaning that restrictions mentioned above are subject to change.</source>
          <target state="translated">이 주석은 실험적이므로 위에서 언급 한 제한 사항이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53852272acd887d2ace151213b2a79c6186dd5ad" translate="yes" xml:space="preserve">
          <source>This annotation is intended for &lt;em&gt;rare cases&lt;/em&gt; when API designer needs to hide Kotlin-specific target from Java API while keeping it a part of Kotlin API so the resulting API is idiomatic for both languages.</source>
          <target state="translated">이 주석은위한 것입니다 &lt;em&gt;드문 경우&lt;/em&gt; 결과 API는 두 언어에 대한 관용적 그래서 자바 API에서 숨기기 코 틀린 특정 대상에 대한 API 디자이너의 요구가 코 틀린의 API의 일부를 유지하면서 때.</target>
        </trans-unit>
        <trans-unit id="f7ff9954f76ed995dd9da4bc5f1699538f3cd9e5" translate="yes" xml:space="preserve">
          <source>This annotation is only applicable to &lt;code&gt;expect&lt;/code&gt; annotation classes in multi-platform projects and marks that class as &quot;optional&quot;. Optional expected class is allowed to have no corresponding actual class on the platform. Optional annotations can only be used to annotate something, not as types in signatures. If an optional annotation has no corresponding actual class on a platform, the annotation entries where it's used are simply erased when compiling code on that platform.</source>
          <target state="translated">이 주석은 다중 플랫폼 프로젝트에서 주석 클래스 를 &lt;code&gt;expect&lt;/code&gt; 할 때만 해당 클래스를 &quot;선택&quot;으로 표시합니다. 선택적 예상 클래스는 플랫폼에서 해당하는 실제 클래스를 가질 수 없습니다. 선택적 주석은 서명의 유형이 아닌 무언가에 주석을 달기 위해서만 사용할 수 있습니다. 선택적 주석에 플랫폼에서 해당하는 실제 클래스가없는 경우 해당 플랫폼에서 코드를 컴파일 할 때 주석이 사용 된 주석 항목이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="c1b9122ad4cc089c09a766a63290941217a27add" translate="yes" xml:space="preserve">
          <source>This annotation is present on any class file produced by the Kotlin compiler and is read by the compiler and reflection. Parameters have very short JVM names on purpose: these names appear in all generated class files, and we'd like to reduce their size.</source>
          <target state="translated">이 주석은 Kotlin 컴파일러가 생성 한 클래스 파일에 있으며 컴파일러와 리플렉션에서 읽습니다. 매개 변수는 의도적으로 매우 짧은 JVM 이름을 갖습니다.이 이름은 생성 된 모든 클래스 파일에 나타나며 크기를 줄이려고합니다.</target>
        </trans-unit>
        <trans-unit id="10a19875cc351d84fe5e296411c863dd2553261e" translate="yes" xml:space="preserve">
          <source>This annotation marks the experimental preview of the standard library API for measuring time and working with durations.</source>
          <target state="translated">이 주석은 시간 측정 및 기간 작업을위한 표준 라이브러리 API의 실험적 미리보기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="08e24e4cbc4d173492beb5ffd4d4ddb94a113383" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">이 주석은 실험적인 것으로 간주되는 표준 라이브러리 API를 표시하며 표준 라이브러리에 대해 제공되는 &lt;a href=&quot;../../../../../../docs/reference/evolution/components-stability&quot;&gt;일반적인 호환성 보증&lt;/a&gt; 대상이 아닙니다 . 이러한 API의 동작이 변경되거나 추가 릴리스에서 API가 완전히 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="400bdfa2156af296817e663103c3f69c483eb8d7" translate="yes" xml:space="preserve">
          <source>This annotation marks the standard library API that is considered experimental and is not subject to the &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;general compatibility guarantees&lt;/a&gt; given for the standard library: the behavior of such API may be changed or the API may be removed completely in any further release.</source>
          <target state="translated">이 주석은 실험적인 것으로 간주되는 표준 라이브러리 API를 표시하며 표준 라이브러리에 대해 제공되는 &lt;a href=&quot;../../../../../docs/reference/evolution/components-stability&quot;&gt;일반적인 호환성 보증&lt;/a&gt; 대상이 아닙니다 . 이러한 API의 동작이 변경되거나 추가 릴리스에서 API가 완전히 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5109889d5440b373d8a734354ff5ededaa5413bf" translate="yes" xml:space="preserve">
          <source>This applies the Gradle &lt;code&gt;java&lt;/code&gt; plugin and configures the target to cooperate with it.</source>
          <target state="translated">이렇게하면 Gradle &lt;code&gt;java&lt;/code&gt; 플러그인 이 적용되고 대상이 이와 협력하도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4a3b2ae9c5594175372b79e16080724e6e8baa3b" translate="yes" xml:space="preserve">
          <source>This approach requires a series of changes in how we program, in particular</source>
          <target state="translated">이 접근법은 특히 프로그래밍 방식에 대한 일련의 변경이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="726ac695c3ca14123e929478de2ca04ef1ac0eb0" translate="yes" xml:space="preserve">
          <source>This approach works only for a native source set that is shared among platform-specific source sets. It doesn&amp;rsquo;t work for native source sets shared at higher levels of the source set hierarchy.</source>
          <target state="translated">이 접근 방식은 플랫폼 별 소스 세트간에 공유되는 기본 소스 세트에 대해서만 작동합니다. 소스 세트 계층의 상위 레벨에서 공유되는 기본 소스 세트에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="caabd1756e7a5fe69a248020021b58534dfbff4d" translate="yes" xml:space="preserve">
          <source>This behavior is correct but it can be very inconvenient for some libraries. So it is possible to specify in the &lt;code&gt;.def&lt;/code&gt; file which of the included headers are to be imported. The separate declarations from other headers can also be imported in case of direct dependencies.</source>
          <target state="translated">이 동작은 정확하지만 일부 라이브러리에서는 매우 불편할 수 있습니다. 따라서 포함 된 헤더 중 가져올 헤더를 &lt;code&gt;.def&lt;/code&gt; 파일 에 지정할 수 있습니다. 직접 종속성의 경우 다른 헤더에서 별도의 선언을 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b0989aa993ac0e544c959f288dcd6e31817be1" translate="yes" xml:space="preserve">
          <source>This behavior is similar to &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt;, which also allow you to access the members of the receiver object inside the body of the function.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;extensions&quot;&gt;확장 함수&lt;/a&gt; 와 유사하며 함수 본문 내에서 수신자 오브젝트의 멤버에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e20a24097999574b06c858b7503368f6bbdeb55a" translate="yes" xml:space="preserve">
          <source>This callback method should call one of these two methods:</source>
          <target state="translated">이 콜백 메소드는 다음 두 메소드 중 하나를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="216d2a3ecca96db5ee19a6d39eef11e98c9f0bf5" translate="yes" xml:space="preserve">
          <source>This can be effectively combined with other idioms, leading to shorter code. E.g. with the &lt;em&gt;when&lt;/em&gt;-expression:</source>
          <target state="translated">이것은 다른 관용구와 효과적으로 결합되어 코드가 더 짧아집니다. 예를 들어 &lt;em&gt;when&lt;/em&gt; -expression 과 함께 :</target>
        </trans-unit>
        <trans-unit id="a3b4ad6a40906907f86d5ceb0160f0fc35e4272e" translate="yes" xml:space="preserve">
          <source>This can be useful for creating &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;Map&lt;/a&gt; literals with less noise, for example:</source>
          <target state="translated">노이즈가 적은 &lt;a href=&quot;../kotlin.collections/-map/index#kotlin.collections.Map&quot;&gt;맵&lt;/a&gt; 리터럴 을 만드는 데 유용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30bbb3ee5d18507d31640cacf4f0eef06845cc34" translate="yes" xml:space="preserve">
          <source>This change increases the number of possible null check optimizations that can be performed either by the Kotlin compiler or by various kinds of bytecode processing tools, such as the Android &lt;a href=&quot;https://developer.android.com/studio/build/shrink-code&quot;&gt;R8 optimizer&lt;/a&gt;.</source>
          <target state="translated">이 변경 사항은 Kotlin 컴파일러 또는 Android &lt;a href=&quot;https://developer.android.com/studio/build/shrink-code&quot;&gt;R8 최적화 프로그램&lt;/a&gt; 과 같은 다양한 종류의 바이트 코드 처리 도구에서 수행 할 수있는 가능한 null 검사 최적화의 수를 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="7e1ff87841658b954b989c8097e33f6cc0f4c4fa" translate="yes" xml:space="preserve">
          <source>This check is only available for the properties that are lexically accessible, i.e. declared in the same type or in one of the outer types, or at top level in the same file.</source>
          <target state="translated">이 검사는 사 전적으로 액세스 가능한 속성, 즉 동일한 유형 또는 외부 유형 중 하나 또는 동일한 파일에서 최상위 수준으로 선언 된 속성에 대해서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e6d8ea08a6d2f26902035e61567b7b01f67c89" translate="yes" xml:space="preserve">
          <source>This class cannot be either co- or contravariant in &lt;code&gt;T&lt;/code&gt;. And this imposes certain inflexibilities. Consider the following function:</source>
          <target state="translated">이 클래스는 &lt;code&gt;T&lt;/code&gt; 의 공변량 또는 반 변형 일 수 없습니다 . 그리고 이것은 특정 융통성을 부과합니다. 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5e57ca69fb23b5a69bf1e170dc12314fcab3e46e" translate="yes" xml:space="preserve">
          <source>This class is deprecated in favor of a more general approach provided by &lt;a href=&quot;../-requires-opt-in/index&quot;&gt;RequiresOptIn&lt;/a&gt;/&lt;a href=&quot;../-opt-in/index&quot;&gt;OptIn&lt;/a&gt;.</source>
          <target state="translated">이 클래스가 제공하는보다 일반적인 접근 방식에 찬성되지 않습니다 &lt;a href=&quot;../-requires-opt-in/index&quot;&gt;RequiresOptIn&lt;/a&gt; / &lt;a href=&quot;../-opt-in/index&quot;&gt;옵트 인&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfa1db139b7b160a14b6c47d1a1495d378da6d44" translate="yes" xml:space="preserve">
          <source>This class is experimental itself and can only be used with the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 실험적이며 컴파일러 인수 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 과 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5fdf32c20c754f3849efeb2ffb6fd9fe85ddd31" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.</source>
          <target state="translated">이 클래스는 읽기 전용 목록을 구현하는 데 도움을주기 위해 동시 수정 추적을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3649d86d1c264225e25ee01e6d003c299727a7d0" translate="yes" xml:space="preserve">
          <source>This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.</source>
          <target state="translated">이 클래스는 읽기 전용 세트를 구현하는 데 도움을주기 위해 동시 수정 추적을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d10d84799d8bbf78fb0535ad9184c4c6ada6aa07" translate="yes" xml:space="preserve">
          <source>This class is intended to implement different file traversal methods. It allows to iterate through all files inside a given directory.</source>
          <target state="translated">이 클래스는 다른 파일 순회 메소드를 구현하기위한 것입니다. 주어진 디렉토리 내의 모든 파일을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322e62ea251e48658a034c9b427e81ba230bb5e9" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;-stable-ref/as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36e06591e999a4c0d4c4171fd2c0675fb1b16fc" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9ba51153ea7889b4c1f1704d375fc98842fa90a" translate="yes" xml:space="preserve">
          <source>This class provides a way to create a stable handle to any Kotlin object. After &lt;a href=&quot;as-c-pointer&quot;&gt;converting to CPointer&lt;/a&gt; it can be safely passed to native code e.g. to be received in a Kotlin callback.</source>
          <target state="translated">이 클래스는 Kotlin 객체에 대한 안정적인 핸들을 만드는 방법을 제공합니다. &lt;a href=&quot;as-c-pointer&quot;&gt;CPointer로 변환&lt;/a&gt; 한 후에 는 코 틀린 콜백에서 수신하기 위해 네이티브 코드로 안전하게 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcb7002c65d065a83f8e4df531f7471f6f059189" translate="yes" xml:space="preserve">
          <source>This class requires opt-in itself and can only be used with the compiler argument &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 옵트 인 자체가 필요하며 컴파일러 인수 &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt; 과 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3de458f3166219b6408ccb11d5d011e7dedd5974" translate="yes" xml:space="preserve">
          <source>This code calculates the fixpoint of cosine, which is a mathematical constant. It simply calls Math.cos repeatedly starting at 1.0 until the result doesn't change any more, yielding a result of 0.7390851332151611 for the specified &lt;code&gt;eps&lt;/code&gt; precision. The resulting code is equivalent to this more traditional style:</source>
          <target state="translated">이 코드는 수학 상수 인 코사인의 고정 점을 계산합니다. 결과가 더 이상 변경되지 않을 때까지 1.0부터 반복적으로 Math.cos를 호출하여 지정된 &lt;code&gt;eps&lt;/code&gt; 정밀도에 대해 0.7390851332151611의 결과를 생성합니다 . 결과 코드는 이보다 전통적인 스타일과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0859f73fe17538052c3240dd97a19efeb37af3a3" translate="yes" xml:space="preserve">
          <source>This code outputs the same numbers, but it waits 100ms before printing each one.</source>
          <target state="translated">이 코드는 동일한 숫자를 출력하지만 각 숫자를 인쇄하기 전에 100ms를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="311dcc9bdc9a71974877af55a1f22b85798cc90e" translate="yes" xml:space="preserve">
          <source>This code outputs:</source>
          <target state="translated">이 코드는 다음을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="a6ca25f95d0c9b2687336e1d3e2569e0a9d58bd7" translate="yes" xml:space="preserve">
          <source>This code prints &quot;&lt;em&gt;Class method&lt;/em&gt;&quot;.</source>
          <target state="translated">이 코드는 &quot; &lt;em&gt;Class method&lt;/em&gt; &quot;를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="8620e5b24bc2854857bfffdb08cfa789461eb543" translate="yes" xml:space="preserve">
          <source>This code prints the numbers after waiting for a second.</source>
          <target state="translated">이 코드는 잠시 기다린 후 숫자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3d9da40aacdb3e7a501485fd289174c0f7bd3ce2" translate="yes" xml:space="preserve">
          <source>This code prints three numbers produced by the &lt;code&gt;simple&lt;/code&gt; flow followed by a &quot;Done&quot; string:</source>
          <target state="translated">이 코드 는 &quot;Done&quot;문자열이 뒤 따르는 &lt;code&gt;simple&lt;/code&gt; 흐름에 의해 생성 된 세 개의 숫자를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="fed0b2a7bdca562e95956df46281418063a044e3" translate="yes" xml:space="preserve">
          <source>This code produces the following exception:</source>
          <target state="translated">이 코드는 다음 예외를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1c9fb24eb61454c344b8e7f5093f2e83751a14fd" translate="yes" xml:space="preserve">
          <source>This code specifies an action to be performed on the &quot;hello&quot; button click. Note that with lambdas this code looks rather concise written directly in Kotlin:</source>
          <target state="translated">이 코드는 &quot;hello&quot;버튼 클릭시 수행 할 동작을 지정합니다. 람다의 경우이 코드는 Kotlin에서 직접 작성된 다소 간결하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="5ce07b0d1b723a22c052939194fdf2108e0fc9dc" translate="yes" xml:space="preserve">
          <source>This code successfully catches an exception in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; terminal operator and, as we see, no more values are emitted after that:</source>
          <target state="translated">이 코드는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html&quot;&gt;collect&lt;/a&gt; 터미널 연산자 에서 예외를 성공적으로 포착하며 그 이후에는 더 이상 값이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a399037775e6ca51f06689e0a34eb873db7e0ee6" translate="yes" xml:space="preserve">
          <source>This code waits 100ms before printing each number without blocking the main thread. This is verified by printing &quot;I'm not blocked&quot; every 100ms from a separate coroutine that is running in the main thread:</source>
          <target state="translated">이 코드는 주 스레드를 차단하지 않고 각 번호를 인쇄하기 전에 100ms를 기다립니다. 이것은 메인 스레드에서 실행되는 별도의 코 루틴에서 100ms마다 &quot;I 'm not blocked&quot;를 인쇄하여 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="655348672aba46b323a130d4745ad11efc796bd4" translate="yes" xml:space="preserve">
          <source>This code will be compiled &quot;as is&quot;: &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in Kotlin becomes &lt;code&gt;dyn.whatever(1)&lt;/code&gt; in the generated JavaScript code.</source>
          <target state="translated">이 코드는 &quot;있는 그대로&quot;컴파일됩니다 &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 코 틀린에이된다 &lt;code&gt;dyn.whatever(1)&lt;/code&gt; 생성 된 자바 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="f097f6de0cc3b7d0fc741d38a1eac67ae2fca6f2" translate="yes" xml:space="preserve">
          <source>This code will launch a long-running operation without blocking the main thread. The &lt;code&gt;preparePost&lt;/code&gt; is what's called a &lt;code&gt;suspendable function&lt;/code&gt;, thus the keyword &lt;code&gt;suspend&lt;/code&gt; prefixing it. What this means as stated above, is that the function will execute, pause execution and resume at some point in time.</source>
          <target state="translated">이 코드는 메인 스레드를 차단하지 않고 장기 실행 작업을 시작합니다. &lt;code&gt;preparePost&lt;/code&gt; 는 불리는 무슨이다 &lt;code&gt;suspendable function&lt;/code&gt; 따라서 키워드가 &lt;code&gt;suspend&lt;/code&gt; 붙임. 위에서 언급 한 바와 같이이 기능은 특정 시점에서 함수가 실행, 실행 일시 중지 및 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="940a39107db356b9719bbf9342038d41ba48b8c2" translate="yes" xml:space="preserve">
          <source>This code works slower, but we still don't get &quot;Counter = 100000&quot; at the end, because volatile variables guarantee linearizable (this is a technical term for &quot;atomic&quot;) reads and writes to the corresponding variable, but do not provide atomicity of larger actions (increment in our case).</source>
          <target state="translated">이 코드는 느리게 작동하지만 휘발성 변수는 선형화 가능 ( &quot;원자&quot;의 기술적 용어 임) 읽기와 쓰기를 보장하지만 원 자성을 제공하지 않기 때문에 끝에 &quot;카운터 = 100000&quot;을 얻지 못합니다. 더 큰 행동 (우리의 경우 증가).</target>
        </trans-unit>
        <trans-unit id="19e35196b450d82e8abc869e0b8d2aedd7f24d49" translate="yes" xml:space="preserve">
          <source>This code works very slowly, because it does &lt;em&gt;fine-grained&lt;/em&gt; thread-confinement. Each individual increment switches from multi-threaded &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt; context to the single-threaded context using &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext(counterContext)&lt;/a&gt; block.</source>
          <target state="translated">이 코드는 &lt;em&gt;세분화 된&lt;/em&gt; 스레드 조합을 수행하기 때문에 매우 느리게 작동합니다 . 각 개별 증분은 다중 스레드 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html&quot;&gt;디스패처&lt;/a&gt; 에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html&quot;&gt;withContext (counterContext)&lt;/a&gt; 블록을 사용하여 기본 스레드를 단일 스레드 컨텍스트로 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="d15be2d04edeeec0e153a44e5ef98d0f0d439b37" translate="yes" xml:space="preserve">
          <source>This collection has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">이 컬렉션의 크기는 &lt;code&gt;groupCount + 1&lt;/code&gt; 여기서 &lt;code&gt;groupCount&lt;/code&gt; 는 정규식의 그룹 수입니다. 그룹은 1에서 &lt;code&gt;groupCount&lt;/code&gt; 로 색인화되며 색인이 0 인 그룹은 전체 일치 항목에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3f0910a281cb430f7b55e3a35ed5817aefc3f7c5" translate="yes" xml:space="preserve">
          <source>This command should output crash report that is additionally processed and includes inlined stack trace elements.</source>
          <target state="translated">이 명령은 추가로 처리되고 인라인 스택 추적 요소를 포함하는 충돌 보고서를 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="c28fcaf55859958d617c24c43acf5fe9a19ed1ae" translate="yes" xml:space="preserve">
          <source>This command will produce a &lt;code&gt;png.klib&lt;/code&gt; compiled library and &lt;code&gt;png-build/kotlin&lt;/code&gt; directory containing Kotlin source code for the library.</source>
          <target state="translated">이 명령은 &lt;code&gt;png.klib&lt;/code&gt; 컴파일 라이브러리와 라이브러리의 Kotlin 소스 코드를 포함하는 &lt;code&gt;png-build/kotlin&lt;/code&gt; 디렉토리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="31a6ce4f29e9c4d59e89de3b53b3a11728189b63" translate="yes" xml:space="preserve">
          <source>This contract specifies that:</source>
          <target state="translated">이 계약은 다음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d6dc362cdb3af439d7414c31776e978f9f9881cd" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="translated">이 규칙은 &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;괄호 외부에 람다 식&lt;/a&gt; 을 전달하는 것과 함께 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb308959.aspx&quot;&gt;LINQ 스타일&lt;/a&gt; 코드를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="615ee8a7977549b4df34e13628dfcadf465d6b63" translate="yes" xml:space="preserve">
          <source>This convention, along with &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;passing a lambda expression outside parentheses&lt;/a&gt;, allows for &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb308959(v=msdn.10)&quot;&gt;LINQ-style&lt;/a&gt; code:</source>
          <target state="translated">이 규칙은 &lt;a href=&quot;#passing-a-lambda-to-the-last-parameter&quot;&gt;괄호 외부에 람다 식&lt;/a&gt; 을 전달하는 것과 함께 &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/bb308959(v=msdn.10)&quot;&gt;LINQ 스타일&lt;/a&gt; 코드를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="78e5afd48b07123042fcce6bdde782478e4769ee" translate="yes" xml:space="preserve">
          <source>This could be an issue for Java-interoperability, so Kotlin 1.3 introduces the &lt;code&gt;@JvmDefault&lt;/code&gt; annotation. Methods, annotated with this annotation will be generated as &lt;code&gt;default&lt;/code&gt; methods for JVM:</source>
          <target state="translated">이것은 Java 상호 운용성에 문제가 될 수 있으므로 Kotlin 1.3에는 &lt;code&gt;@JvmDefault&lt;/code&gt; 주석이 도입되었습니다 . 이 주석으로 주석이 달린 메소드는 JVM의 &lt;code&gt;default&lt;/code&gt; 메소드 로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b179e178b1137230407a1019e7d8b4984a1d071b" translate="yes" xml:space="preserve">
          <source>This creates the &lt;code&gt;kotlin&lt;/code&gt; extension at the top level. You can then access it in the build script for:</source>
          <target state="translated">이것은 최상위 레벨에서 &lt;code&gt;kotlin&lt;/code&gt; 확장을 만듭니다 . 그런 다음 빌드 스크립트에서 다음에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91b0596f729477e16cacda10e4665e91b4d05e3b" translate="yes" xml:space="preserve">
          <source>This document covers some details of Kotlin/Native interoperability with Swift/Objective-C.</source>
          <target state="translated">이 문서는 Swift / Objective-C와의 Kotlin / Native 상호 운용성에 대한 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="50a7c9e10c5c72d9392130bc3068411c0b41a1c1" translate="yes" xml:space="preserve">
          <source>This document explains the structure of &lt;a href=&quot;multiplatform&quot;&gt;Kotlin multiplatform projects&lt;/a&gt; and describes how those are configured and built using Gradle.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;multiplatform&quot;&gt;Kotlin 멀티 플랫폼 프로젝트&lt;/a&gt; 의 구조 와 Gradle을 사용하여 구성 및 빌드되는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="21394d0363d5df965c799770727e7adbc3c6c279" translate="yes" xml:space="preserve">
          <source>This effect is specified in the &lt;code&gt;contract { }&lt;/code&gt; block by attaching a boolean expression to another &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect&lt;/a&gt; effect with the function &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt;.</source>
          <target state="translated">이 효과는에 지정된 &lt;code&gt;contract { }&lt;/code&gt; 다른 부울 표현식을 부착하여 블록 &lt;a href=&quot;-simple-effect/index&quot;&gt;SimpleEffect의&lt;/a&gt; 기능과 효과 &lt;a href=&quot;-simple-effect/implies&quot;&gt;SimpleEffect.implies&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb5b2df09cf2fcb8077c0a923825c3e12c005d89" translate="yes" xml:space="preserve">
          <source>This example always prints zero. Resources do not leak.</source>
          <target state="translated">이 예제는 항상 0을 인쇄합니다. 자원이 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e955cd6c26356181a1bb5fce56a8a7425848e09" translate="yes" xml:space="preserve">
          <source>This example can be also rewritten in a more idiomatic way, using &lt;code&gt;runBlocking&lt;/code&gt; to wrap the execution of the main function:</source>
          <target state="translated">이 예제는 &lt;code&gt;runBlocking&lt;/code&gt; 을 사용 하여 주 함수의 실행을 래핑 하여보다 관용적 인 방식으로 다시 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea137e1d1b8bae0357ac3e28f43d2dbd0615f21" translate="yes" xml:space="preserve">
          <source>This example completes in less than a second for me, but it prints some arbitrary number, because some coroutines don't finish before &lt;code&gt;main()&lt;/code&gt; prints the result. Let's fix that.</source>
          <target state="translated">이 예제는 1 초 안에 완료되지만 &lt;code&gt;main()&lt;/code&gt; 이 결과를 인쇄 하기 전에 일부 코 루틴이 끝나지 않기 때문에 임의의 숫자를 인쇄합니다. 고쳐 봅시다.</target>
        </trans-unit>
        <trans-unit id="a01abea8c251a15b2fecf1b509dc49ecf9457794" translate="yes" xml:space="preserve">
          <source>This example prints &quot;&lt;em&gt;Shape&lt;/em&gt;&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;s&lt;/code&gt;, which is the &lt;code&gt;Shape&lt;/code&gt; class.</source>
          <target state="translated">이 예제 인쇄 &quot; &lt;em&gt;모양&lt;/em&gt; 확장 함수가 호출되고 있기는&quot;만 매개 변수의 선언 된 유형에 따라 다릅니다 &lt;code&gt;s&lt;/code&gt; 는 IS, &lt;code&gt;Shape&lt;/code&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9e728cbcad0747512419b85edec7c03f8dbc8800" translate="yes" xml:space="preserve">
          <source>This example prints:</source>
          <target state="translated">이 예제는 다음을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3176985b1c6580c82570c99ec00af4e47e3fca5d" translate="yes" xml:space="preserve">
          <source>This example uses the utility function &lt;code&gt;startActivity&lt;/code&gt; creating an intent with no data and starting a new activity, which comes from the &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; library. To pass some data, you can say &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;startActivity&lt;/code&gt; 유틸리티 함수를 사용하여 데이터가없는 인 텐트를 작성하고 &lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt; 라이브러리 에서 제공되는 새 활동을 시작합니다 . 일부 데이터를 전달하기 위해 &lt;code&gt;startActivity&amp;lt;OtherActivity&amp;gt;(&quot;KEY&quot; to &quot;VALUE&quot;)&lt;/code&gt; 라고 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6017ffad0436bb8b6025573c2ab986b658552870" translate="yes" xml:space="preserve">
          <source>This example will print &quot;c&quot;, because the extension function being called depends only on the declared type of the parameter &lt;code&gt;c&lt;/code&gt;, which is the &lt;code&gt;C&lt;/code&gt; class.</source>
          <target state="translated">호출되는 확장 기능은 매개 변수의 선언 형에 의존하기 때문에이 예제는 &quot;C&quot;를 출력합니다 &lt;code&gt;c&lt;/code&gt; 는 IS, &lt;code&gt;C&lt;/code&gt; 의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a5a9e0df4941c06894731d36487fbab59c324ecd" translate="yes" xml:space="preserve">
          <source>This exception is still caught and collection is stopped:</source>
          <target state="translated">이 예외는 여전히 포착되고 수집이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="133008c5d984069ce6a34613c275871c4f01bd7c" translate="yes" xml:space="preserve">
          <source>This extension allows to use instances of Lazy for property delegation: &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</source>
          <target state="translated">이 확장을 사용하면 속성 위임에 Lazy 인스턴스를 사용할 수 있습니다. &lt;code&gt;val property: String by lazy { initializer }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d46e174deee6bd3f88e10604b91fb9b63428622" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="translated">이 확장은 이전 이름의 매개 변수를 사용한 호출에만 선택됩니다. 매개 변수 이름을 &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence%28kotlin.Int%2C+kotlin.Int%29&quot;&gt;CharSequence.subSequence&lt;/a&gt; 와 동일하게 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="14d1030709354dc027ae0189ce6ddad41a98c081" translate="yes" xml:space="preserve">
          <source>This extension is chosen only for invocation with old-named parameters. Replace parameter names with the same as those of &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence(kotlin.Int,%20kotlin.Int)&quot;&gt;CharSequence.subSequence&lt;/a&gt;.</source>
          <target state="translated">이 확장은 이전 이름의 매개 변수를 사용한 호출에만 선택됩니다. 매개 변수 이름을 &lt;a href=&quot;../kotlin/-char-sequence/sub-sequence#kotlin.CharSequence%24subSequence(kotlin.Int,%20kotlin.Int)&quot;&gt;CharSequence.subSequence&lt;/a&gt; 와 동일한 이름으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="04d1f02c756f7e0904c6b3ffc69c7b6618cd5516" translate="yes" xml:space="preserve">
          <source>This extension on &lt;code&gt;Map&lt;/code&gt; returns an existing value corresponding to the given key or throws an exception, mentioning which key was not found. If the map was produced with &lt;code&gt;withDefault&lt;/code&gt;, this function will return the default value instead of throwing an exception.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 의이 확장 은 주어진 키에 해당하는 기존 값을 반환하거나 찾을 수없는 키를 언급하여 예외를 발생시킵니다. &lt;code&gt;withDefault&lt;/code&gt; 로 맵을 생성 한 경우이 함수는 예외를 발생시키는 대신 기본값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="179023ec810ea92c988e87fc2b985af8aad37762" translate="yes" xml:space="preserve">
          <source>This feature is available since Kotlin 1.3.40.</source>
          <target state="translated">이 기능은 Kotlin 1.3.40부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="291f1aee064b4993bae1bca7498ed1b391616e9f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;expm1#kotlin.math%24expm1%28kotlin.Double%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82fc3a4111cee52b0765cac3deb75eac875358c3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;expm1#kotlin.math%24expm1(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 0에 가까운 &lt;a href=&quot;expm1#kotlin.math%24expm1(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; 에 대해보다 정확한 결과를 생성하도록 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b2cb2dc1fab6dcfdc4a04073763dbc01b226107" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Double%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ea77ed3f5037a0baac9478b8da01da4e51178e3" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;ln1p#kotlin.math%24ln1p%28kotlin.Float%29%2Fx&quot;&gt;x가&lt;/a&gt; 0에 가까울수록 더 정확한 결과를 생성하도록 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8188da7cb3be6634067162b37cc97e8bc1ff03f4" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 0에 가까운 &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Double)/x&quot;&gt;x&lt;/a&gt; 에 대해보다 정확한 결과를 생성하도록 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efadae38b073a74442295c102230ba4f30a5571f" translate="yes" xml:space="preserve">
          <source>This function can be implemented to produce more precise result for &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Float)/x&quot;&gt;x&lt;/a&gt; near zero.</source>
          <target state="translated">이 함수는 0에 가까운 &lt;a href=&quot;ln1p#kotlin.math%24ln1p(kotlin.Float)/x&quot;&gt;x&lt;/a&gt; 에 대해보다 정확한 결과를 생성하도록 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4311a401a48c7764543d1126d79598187555315" translate="yes" xml:space="preserve">
          <source>This function can be used to extend the logic of creating the object (e.g. perform validation checks) to which the property implementation is delegated.</source>
          <target state="translated">이 함수는 속성 구현이 위임되는 객체 생성 로직 (예 : 유효성 검사 수행)을 확장하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c898be592d8e9ec3ec1e1197444847361f309383" translate="yes" xml:space="preserve">
          <source>This function catches any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;map-catching#kotlin%24mapCatching(kotlin.Result((kotlin.mapCatching.T)),%20kotlin.Function1((kotlin.mapCatching.T,%20kotlin.mapCatching.R)))/transform&quot;&gt;transform&lt;/a&gt; function and encapsulates it as a failure. See &lt;a href=&quot;../kotlin.collections/map&quot;&gt;map&lt;/a&gt; for an alternative that rethrows exceptions from &lt;code&gt;transform&lt;/code&gt; function.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;map-catching#kotlin%24mapCatching(kotlin.Result((kotlin.mapCatching.T)),%20kotlin.Function1((kotlin.mapCatching.T,%20kotlin.mapCatching.R)))/transform&quot;&gt;변형&lt;/a&gt; 함수에 의해 throw되는 모든 &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외를 포착 하고이를 실패로 캡슐화합니다. &lt;code&gt;transform&lt;/code&gt; 함수 에서 예외를 다시 발생시키는 대안 은 &lt;a href=&quot;../kotlin.collections/map&quot;&gt;map&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cef13bf6e73de23f49c16a3bab2d588fbcbf2988" translate="yes" xml:space="preserve">
          <source>This function catches any &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; exception thrown by &lt;a href=&quot;recover-catching#kotlin%24recoverCatching(kotlin.Result((kotlin.recoverCatching.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recoverCatching.R)))/transform&quot;&gt;transform&lt;/a&gt; function and encapsulates it as a failure. See &lt;a href=&quot;recover&quot;&gt;recover&lt;/a&gt; for an alternative that rethrows exceptions.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;recover-catching#kotlin%24recoverCatching(kotlin.Result((kotlin.recoverCatching.T)),%20kotlin.Function1((kotlin.Throwable,%20kotlin.recoverCatching.R)))/transform&quot;&gt;변형&lt;/a&gt; 함수에 의해 throw되는 모든 &lt;a href=&quot;-throwable/index#kotlin.Throwable&quot;&gt;Throwable&lt;/a&gt; 예외를 포착 하고이를 실패로 캡슐화합니다. 예외를 다시 발생시키는 대안 은 &lt;a href=&quot;recover&quot;&gt;복구&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c484bb37db8fbf2af8bdf87b8645f693e45336d" translate="yes" xml:space="preserve">
          <source>This function compares this string and the specified &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt; in a synchronized block that acquires that &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt;'s monitor.</source>
          <target state="translated">이 함수는이 문자열과 해당 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt; 의 모니터 를 획득하는 동기화 된 블록 의 지정된 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html&quot;&gt;StringBuffer&lt;/a&gt; 를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="15d8b3c4e3fae3fdf6c4d98c18ebe217e09dc09b" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">이 함수는 동결 시도 중에 이러한 객체를 볼 경우 동결이 실패하고 &lt;a href=&quot;-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; 이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b1cc74a9da98228f1c9d06844410d709b18bb49c" translate="yes" xml:space="preserve">
          <source>This function ensures that if we see such an object during freezing attempt - freeze fails and &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; is thrown.</source>
          <target state="translated">이 함수는 동결 시도 중에 이러한 객체를 볼 경우 동결이 실패하고 &lt;a href=&quot;../../kotlin.native.concurrent/-freezing-exception/index&quot;&gt;FreezingException&lt;/a&gt; 이 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a5393499e5b4f857a3be1966cc5a5ee2263343b0" translate="yes" xml:space="preserve">
          <source>This function has two notable differences from the method Pattern.split:</source>
          <target state="translated">이 함수는 Pattern.split 메서드와 두 가지 눈에 띄는 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8266b16f93bf335043fb8a8f2352b33ede13a56f" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;unchecked&lt;/em&gt;. Repeated invocation of any resume function on the resulting continuation corrupts the state machine of the coroutine and may result in arbitrary behaviour or exception.</source>
          <target state="translated">이 기능은 &lt;em&gt;선택되어&lt;/em&gt; 있지 않습니다 . 결과 연속에서 재개 기능을 반복적으로 호출하면 코 루틴의 상태 시스템이 손상되어 임의의 동작이나 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="080e9b8336d9b1bd6ef82f0d25962f50f8a0565d" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 함수에 대한 속기 &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (참조 : &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;배&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d500cf4330e5af6f7d32531bc1c10b5b5cb22a39" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 함수에 대한 속기 &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1206d6e25fa2947fa30b44bb46d8a067f16e4bc2" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;getOrElse { null }&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt; 참조 ) 또는 &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (참조&lt;a href=&quot;../../kotlin.collections/fold&quot;&gt; fold&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3ceaf91c907592aafc9f5d591d5965851baf420" translate="yes" xml:space="preserve">
          <source>This function is a shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ff5ce4b141292d06ec70d6eb85ccd3070084028" translate="yes" xml:space="preserve">
          <source>This function is deprecated. See &lt;a href=&quot;as-c-pointer&quot;&gt;Worker.asCPointer&lt;/a&gt; for more details.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. &lt;a href=&quot;as-c-pointer&quot;&gt;Worker.asCPointer를&lt;/a&gt; 참조하십시오 . 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1082b4365fe4440feb5a4149d9805ba0ee95963d" translate="yes" xml:space="preserve">
          <source>This function is deprecated. Use &lt;code&gt;kotlinx.cinterop.StableRef.create(worker).asCPointer()&lt;/code&gt; instead. The result can be unwrapped with &lt;code&gt;pointer.asStableRef&amp;lt;Worker&amp;gt;().get()&lt;/code&gt;. &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/index&quot;&gt;StableRef&lt;/a&gt; should be eventually disposed manually with &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/dispose&quot;&gt;StableRef.dispose&lt;/a&gt;.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 &lt;code&gt;kotlinx.cinterop.StableRef.create(worker).asCPointer()&lt;/code&gt; 사용하십시오. 결과는 &lt;code&gt;pointer.asStableRef&amp;lt;Worker&amp;gt;().get()&lt;/code&gt; 으로 풀 수 있습니다 . &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/index&quot;&gt;StableRef은&lt;/a&gt; 결국 수동으로 배치해야한다 &lt;a href=&quot;../../kotlinx.cinterop/-stable-ref/dispose&quot;&gt;StableRef.dispose&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="655c266532fc9da4c9f83fafc0352f21cfdf4913" translate="yes" xml:space="preserve">
          <source>This function is designed to be used from inside of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; to resume the execution of the suspended coroutine using a reference to the suspending function.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 내부에서 사용하여 일시 중단 함수에 대한 참조를 사용하여 일시 중단 된 코 루틴 실행을 재개 하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4f965c0d50c6551000096efd613ba42b0075743e" translate="yes" xml:space="preserve">
          <source>This function is experimental because not all the features are supported yet, and behavior might change in corner cases. In particular, the following is not supported correctly or at all:</source>
          <target state="translated">이 기능은 아직 일부 기능이 지원되지 않기 때문에 실험적이며, 코너 케이스에서 동작이 변경 될 수 있습니다. 특히 다음은 올바르게 또는 전혀 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a73c80e70840d67f98f7e02bc949060c1aff0a7a" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;fold(onSuccess = { null }, onFailure = { it })&lt;/code&gt; (참조 : &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;배&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6bebf395da4954e0241f8b8cedacdd2c2c071a5d" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { defaultValue }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="036653325111157e1e020b5f2e95ce39aee0befd" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { null }&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;) or &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; (see &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;code&gt;getOrElse { null }&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt; 참조 ) 또는 &lt;code&gt;fold(onSuccess = { it }, onFailure = { null })&lt;/code&gt; ( &lt;a href=&quot;../../kotlin.collections/fold&quot;&gt;fold&lt;/a&gt; 참조 )의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="0cd6600313d79bdb9ccb1177f047f415c30785ec" translate="yes" xml:space="preserve">
          <source>This function is shorthand for &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (see &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse&lt;/a&gt;).</source>
          <target state="translated">이 기능에 대한 속기 &lt;code&gt;getOrElse { throw it }&lt;/code&gt; (참조 &lt;a href=&quot;../kotlin.collections/get-or-else&quot;&gt;getOrElse을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2764ff2fd2235b064886b62fb3ea52722744061e" translate="yes" xml:space="preserve">
          <source>This function is supposed to copy items from one array to another. Let's try to apply it in practice:</source>
          <target state="translated">이 함수는 한 배열에서 다른 배열로 항목을 복사합니다. 실제로 적용 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="e946cda58e67ec0857646809f4c7cd966c6aa3b4" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="translated">이 함수는 이 특정 연속을 가로 채지 않으려는 경우 원래 &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation%28kotlin.coroutines.Continuation%28%28kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T%29%29%29%2Fcontinuation&quot;&gt;연속을&lt;/a&gt; 단순히 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11e7f8ea6989ea16c6c6f19e0683df8d87331f23" translate="yes" xml:space="preserve">
          <source>This function may simply return original &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;continuation&lt;/a&gt; if it does not want to intercept this particular continuation.</source>
          <target state="translated">이 함수는 이 특정 연속을 가로 채지 않으려면 단순히 원래 &lt;a href=&quot;intercept-continuation#kotlin.coroutines.ContinuationInterceptor%24interceptContinuation(kotlin.coroutines.Continuation((kotlin.coroutines.ContinuationInterceptor.interceptContinuation.T)))/continuation&quot;&gt;연속을&lt;/a&gt; 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e37e9fc156176e563d05b6de34d613400e3a03e7" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 인터셉트되지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c7cfd05c8eea06ab4db27704a1d5249d155e3e" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 인터셉트되지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되도록하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction1%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29%2Fcompletion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e77211107874c1aa9b698abd78683ca24a554806" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 가로 채지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되었는지 확인하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23439beed8599daea974279d78d13303435cfab9" translate="yes" xml:space="preserve">
          <source>This function returns unintercepted continuation. Invocation of &lt;code&gt;resume(Unit)&lt;/code&gt; starts coroutine immediately in the invoker's call stack without going through the ContinuationInterceptor that might be present in the completion's CoroutineContext. It is the invoker's responsibility to ensure that a proper invocation context is established. Note that &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;completion&lt;/a&gt; of this function may get invoked in an arbitrary context.</source>
          <target state="translated">이 함수는 가로 채지 않은 연속을 반환합니다. 의 호출 &lt;code&gt;resume(Unit)&lt;/code&gt; 시작은 완성의 CoroutineContext에있을 수있는 ContinuationInterceptor 거치지 않고 호출자의 호출 스택에서 바로 코 루틴. 적절한 호출 컨텍스트가 설정되었는지 확인하는 것은 호출자의 책임입니다. 참고 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction1((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.intrinsics.createCoroutineUnintercepted.R,%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))/completion&quot;&gt;완성&lt;/a&gt; 이 기능은 임의의 컨텍스트에서 호출받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c273643758adbf26e0358f1c22929439c83656d2" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="translated">이 기능의 즉각적인 결과를 사용한다 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted%28kotlin.coroutines.SuspendFunction0%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%2C+kotlin.coroutines.Continuation%28%28kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T%29%29%29&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; 또는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 경우에 그 수표, &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 계속 년대 &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;상황&lt;/a&gt; , 호출 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt; , 캐시를하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e65f4539a9086004cb5d3a889baf0f098ccd5d4a" translate="yes" xml:space="preserve">
          <source>This function shall be used on the immediate result of &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; or &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;, in which case it checks for &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; in the continuation's &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;context&lt;/a&gt;, invokes &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt;, caches and returns the result.</source>
          <target state="translated">이 기능의 즉각적인 결과를 사용한다 &lt;a href=&quot;create-coroutine-unintercepted#kotlin.coroutines.intrinsics%24createCoroutineUnintercepted(kotlin.coroutines.SuspendFunction0((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)),%20kotlin.coroutines.Continuation((kotlin.coroutines.intrinsics.createCoroutineUnintercepted.T)))&quot;&gt;createCoroutineUnintercepted&lt;/a&gt; 또는 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt; 경우에 그 수표, &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/index&quot;&gt;ContinuationInterceptor&lt;/a&gt; 계속 년대 &lt;a href=&quot;../kotlin.coroutines/-continuation/context&quot;&gt;상황&lt;/a&gt; , 호출 &lt;a href=&quot;../kotlin.coroutines/-continuation-interceptor/intercept-continuation&quot;&gt;ContinuationInterceptor.interceptContinuation&lt;/a&gt; , 캐시를하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b0e3ac4cd4df41a67feb4ab61ba294bec022bac" translate="yes" xml:space="preserve">
          <source>This function takes one parameter named &lt;code&gt;init&lt;/code&gt;, which is itself a function. The type of the function is &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt;, which is a &lt;em&gt;function type with receiver&lt;/em&gt;. This means that we need to pass an instance of type &lt;code&gt;HTML&lt;/code&gt; (a &lt;em&gt;receiver&lt;/em&gt;) to the function, and we can call members of that instance inside the function. The receiver can be accessed through the &lt;em&gt;this&lt;/em&gt; keyword:</source>
          <target state="translated">이 함수는 &lt;code&gt;init&lt;/code&gt; 라는 하나의 매개 변수를 가져옵니다 . 함수의 유형은 &lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt; 이며, 이는 &lt;em&gt;수신기&lt;/em&gt; 가있는 &lt;em&gt;함수 유형입니다&lt;/em&gt; . 즉, &lt;code&gt;HTML&lt;/code&gt; 유형 의 &lt;em&gt;수신자&lt;/em&gt; ( &lt;em&gt;수신자&lt;/em&gt; )를 함수 에 전달해야 하며 함수 내에서 해당 인스턴스의 멤버를 호출 할 수 있습니다. 수신자는 &lt;em&gt;다음&lt;/em&gt; 키워드를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="675aeac2a918c6d6c8b4beafdddac2cf6431511b" translate="yes" xml:space="preserve">
          <source>This illustrates several important points:</source>
          <target state="translated">이것은 몇 가지 중요한 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="42ded97c96158badfa6b51ddc24bd9a63c6cca70" translate="yes" xml:space="preserve">
          <source>This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself. There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the capacity and &quot;growth increment&quot; concepts.</source>
          <target state="translated">이 구현은 백업 JS 배열 자체의 크기를 조정할 수 있으므로 용량을 관리하는 방법을 제공하지 않습니다. JavaScript에서 배열 크기를 사전 할당하는 것에는 속도 이점이 없으므로이 구현에는 용량 및 &quot;증가 증분&quot;개념이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="691ede82b3af6046b7651a9c02f4605eaa3ba130" translate="yes" xml:space="preserve">
          <source>This implementation makes no guarantees regarding the order of enumeration of &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;keys&lt;/a&gt;, &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;values&lt;/a&gt; and &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;entries&lt;/a&gt; collections.</source>
          <target state="translated">이 구현은 , &lt;a href=&quot;../-abstract-mutable-map/keys#kotlin.collections.AbstractMutableMap%24keys&quot;&gt;키&lt;/a&gt; 의 열거 순서 , &lt;a href=&quot;../-abstract-mutable-map/values#kotlin.collections.AbstractMutableMap%24values&quot;&gt;값&lt;/a&gt; 및 &lt;a href=&quot;entries#kotlin.collections.HashMap%24entries&quot;&gt;엔트리&lt;/a&gt; 컬렉션에 대해서는 보증하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8ddc3e7d274cee12068e4ad892df6635b0d1615a" translate="yes" xml:space="preserve">
          <source>This implementation preserves the insertion order of elements during the iteration.</source>
          <target state="translated">이 구현은 반복 동안 요소의 삽입 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1edd274f6c90be7cfea12d2c044bc4232b280a23" translate="yes" xml:space="preserve">
          <source>This implicit default value is used when the original map doesn't contain a value for the key specified and a value is obtained with &lt;a href=&quot;get-value&quot;&gt;Map.getValue&lt;/a&gt; function, for example when properties are delegated to the map.</source>
          <target state="translated">이 암시 적 기본값은 원래 맵에 지정된 키 값이 &lt;a href=&quot;get-value&quot;&gt;없고 Map.getValue&lt;/a&gt; 함수 를 사용하여 값을 가져 오는 경우 (예 : 속성이 맵에 위임 될 때) 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="410788a84e729541585bfe744595e36fe672b2b8" translate="yes" xml:space="preserve">
          <source>This implies a different way to approach problems and quite a significant shift from what we're using to when writing synchronous code. One benefit as opposed to Futures is that given its ported to so many platforms, generally we can find a consistent API experience no matter what we use it, be it C#, Java, JavaScript, or any other language where Rx is available.</source>
          <target state="translated">이것은 문제에 접근하는 다른 방법과 동기 코드를 작성할 때 우리가 사용하는 것에서 상당한 변화를 의미합니다. 선물과 반대되는 이점 중 하나는 많은 플랫폼으로 포팅되어 있기 때문에 일반적으로 C #, Java, JavaScript 또는 Rx를 사용할 수있는 다른 언어에 관계없이 일관된 API 경험을 찾을 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b300e1ecd05ef9cda9c0ccf69cc9b5755628a6bd" translate="yes" xml:space="preserve">
          <source>This imposes certain risks of binary incompatibility caused by changes in the module that declares an inline function in case the calling module is not re-compiled after the change.</source>
          <target state="translated">이는 변경 후 호출 모듈이 재 컴파일되지 않은 경우 인라인 함수를 선언하는 모듈의 변경으로 인한 이진 비 호환성 위험을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="1c39f73f8778c781fa84c78bdda94d474dac7b9e" translate="yes" xml:space="preserve">
          <source>This in principle feels like a much more elegant solution, but once again has several issues:</source>
          <target state="translated">이것은 원칙적으로 훨씬 더 우아한 솔루션처럼 느껴지지만 다시 한 번 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dca6747771b3b10d5fd08415bf950f46bdea92f" translate="yes" xml:space="preserve">
          <source>This interface is implemented by floating point ranges returned by &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; and &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; operators to achieve IEEE-754 comparison order instead of total order of floating point numbers.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;../range-to&quot;&gt;Float.rangeTo&lt;/a&gt; 및 &lt;a href=&quot;../range-to&quot;&gt;Double.rangeTo&lt;/a&gt; 연산자가 반환 한 부동 소수점 범위에 의해 구현되어 총 부동 소수점 수 대신 IEEE-754 비교 순서를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="b9b5668de562d41a3eb7fb59a1bae495ad743bbf" translate="yes" xml:space="preserve">
          <source>This interface is likely to be handled by compiler magic and shouldn't be subtyped by arbitrary classes.</source>
          <target state="translated">이 인터페이스는 컴파일러 매직에 의해 처리 될 수 있으며 임의의 클래스에 의해 서브 타입 화되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="60e87d87b4ef52673d6b6accbe785d16a04f37c9" translate="yes" xml:space="preserve">
          <source>This is a guide on core features of &lt;code&gt;kotlinx.coroutines&lt;/code&gt; with a series of examples, divided up into different topics.</source>
          <target state="translated">이 안내서는 여러 주제로 나뉘어 진 일련의 예제가있는 &lt;code&gt;kotlinx.coroutines&lt;/code&gt; 의 핵심 기능에 대한 안내서입니다 .</target>
        </trans-unit>
        <trans-unit id="df1cdfbf36992d0e353e65acc97d1211d338f55d" translate="yes" xml:space="preserve">
          <source>This is a key reason the &lt;code&gt;simple&lt;/code&gt; function (which returns a flow) is not marked with &lt;code&gt;suspend&lt;/code&gt; modifier. By itself, &lt;code&gt;simple()&lt;/code&gt; call returns quickly and does not wait for anything. The flow starts every time it is collected, that is why we see &quot;Flow started&quot; when we call &lt;code&gt;collect&lt;/code&gt; again.</source>
          <target state="translated">이것이 흐름을 반환하는 &lt;code&gt;simple&lt;/code&gt; 함수에 &lt;code&gt;suspend&lt;/code&gt; 수정자가 표시되지 않은 주요 이유 입니다. 그 자체로 &lt;code&gt;simple()&lt;/code&gt; 호출은 빠르게 반환되고 아무것도 기다리지 않습니다. 흐름은 수집 될 때마다 시작되므로 &lt;code&gt;collect&lt;/code&gt; 를 다시 호출 할 때 &quot;Flow started&quot;가 표시됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="c933ba19b81dc6ad55a2c69193b755c303d2100a" translate="yes" xml:space="preserve">
          <source>This is a little better, but we have no or little help from the powerful code completion of the IDE. It would be so much better if we could say:</source>
          <target state="translated">이것은 조금 나아지지만 IDE의 강력한 코드 완성에서 도움이 거의 또는 전혀 없습니다. 우리가 말할 수 있다면 훨씬 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="da401b98d9be6d7ebaac9172cbd4241fbf6ba27c" translate="yes" xml:space="preserve">
          <source>This is also a way to write unit tests for suspending functions:</source>
          <target state="translated">이것은 또한 일시 중단 함수에 대한 단위 테스트를 작성하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="64ed768079e9d5cbdb933e9c19824b5132acfb30" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;../-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="109dcae61144497c38fcb7128f4fde954a0b0dab" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;../kotlin.reflect/-k-function/index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1275ac7243b73ff90c0cce870f1cace4805d6b9b" translate="yes" xml:space="preserve">
          <source>This is an experimental API. Given a class for a compiled Kotlin lambda or a function expression, returns a &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; instance providing introspection capabilities for that lambda or function expression and its parameters. Not all features are currently supported, in particular KCallable.call and KCallable.callBy will fail at the moment.</source>
          <target state="translated">이것은 실험적인 API입니다. 컴파일 된 Kotlin 람다 또는 함수 표현식에 대한 클래스가 주어지면 해당 람다 또는 함수 표현식 및 해당 매개 변수에 대한 내성 기능을 제공 하는 &lt;a href=&quot;index#kotlin.reflect.KFunction&quot;&gt;KFunction&lt;/a&gt; 인스턴스를 리턴합니다 . 현재 모든 기능이 지원되는 것은 아니며, 특히 KCallable.call 및 KCallable.callBy는 현재 실패합니다.</target>
        </trans-unit>
        <trans-unit id="56ff2e2058e67cead5d0e1ef36c3683a6dd863f0" translate="yes" xml:space="preserve">
          <source>This is an experimental function that behaves as a similar function from kotlin.reflect.full on JVM.</source>
          <target state="translated">이것은 JVM의 kotlin.reflect.full과 유사한 기능으로 작동하는 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="bbf054c69a799b1f208427023936248eccf48ba6" translate="yes" xml:space="preserve">
          <source>This is because we are not inside any coroutine. We can use delay if we wrap it into &lt;code&gt;runBlocking {}&lt;/code&gt; that starts a coroutine and waits until it's done:</source>
          <target state="translated">우리는 코 루틴 안에 있지 않기 때문입니다. 코 루틴을 시작하고 완료 될 때까지 기다리는 &lt;code&gt;runBlocking {}&lt;/code&gt; 에 지연을 감쌀 경우 지연을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89a3c5e95e199bf51561c58886a8d92c513c9cea" translate="yes" xml:space="preserve">
          <source>This is called an &lt;em&gt;object declaration&lt;/em&gt;, and it always has a name following the &lt;em&gt;object&lt;/em&gt; keyword. Just like a variable declaration, an object declaration is not an expression, and cannot be used on the right hand side of an assignment statement.</source>
          <target state="translated">이를 &lt;em&gt;객체 선언&lt;/em&gt; 이라고하며 항상 &lt;em&gt;객체&lt;/em&gt; 키워드 뒤에 이름이 있습니다. 변수 선언과 마찬가지로 객체 선언은 표현식이 아니며 대입 문의 오른쪽에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f25f0b9ab280fe3c292330ad8e1771dad21395c" translate="yes" xml:space="preserve">
          <source>This is completely legitimate Kotlin code. You can play with this code online (modify it and run in the browser) &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이것은 완전히 합법적 인 Kotlin 코드입니다. 당신은 (그것을 수정하고 브라우저에서 실행) 온라인이 코드를 재생할 수 있습니다 &lt;a href=&quot;https://play.kotlinlang.org/byExample/09_Kotlin_JS/06_HtmlBuilder&quot;&gt;여기에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ddd6e3de1f5a28a90747db03b48c3a1e5c746b0" translate="yes" xml:space="preserve">
          <source>This is different from adjusting &lt;code&gt;webpackTask.output.libraryTarget&lt;/code&gt;. The library target changes the output &lt;em&gt;generated by webpack&lt;/em&gt; (after your code has already been compiled). &lt;code&gt;kotlinOptions.moduleKind&lt;/code&gt; changes the output generated &lt;em&gt;by the Kotlin compiler&lt;/em&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;webpackTask.output.libraryTarget&lt;/code&gt; 조정과 다릅니다 . 라이브러리 타겟 &lt;em&gt;은 웹팩에 의해 생성 된&lt;/em&gt; 출력을 변경합니다 (코드가 이미 컴파일 된 후). &lt;code&gt;kotlinOptions.moduleKind&lt;/code&gt; &lt;em&gt;는 Kotlin 컴파일러가&lt;/em&gt; 생성 &lt;em&gt;한&lt;/em&gt; 출력을 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="0e75165bd6c0c435e57a13f622ac0560e9f8aea5" translate="yes" xml:space="preserve">
          <source>This is equivalent to</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="9f70cf8ecc85c3e0ff05ae57878985a9c7914959" translate="yes" xml:space="preserve">
          <source>This is especially helpful if you use multi-line syntax for parameters or values. After adding a trailing comma, you can then easily swap lines with parameters or values.</source>
          <target state="translated">이는 매개 변수 또는 값에 여러 줄 구문을 사용하는 경우 특히 유용합니다. 후행 쉼표를 추가 한 후 매개 변수 또는 값으로 행을 쉽게 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cafbcd266b45a7c72452995f54470aa36c3c74c4" translate="yes" xml:space="preserve">
          <source>This is how Kotlin Multiplatform works.</source>
          <target state="translated">이것이 Kotlin Multiplatform이 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="f1b5d12f5c0ad6b8f02b5702175b995f5f4555de" translate="yes" xml:space="preserve">
          <source>This is how the package &lt;code&gt;com.example.html&lt;/code&gt; is defined (only the elements used in the example above). It builds an HTML tree. It makes heavy use of &lt;a href=&quot;extensions&quot;&gt;extension functions&lt;/a&gt; and &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;lambdas with receiver&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;com.example.html&lt;/code&gt; 패키지 가 정의 된 방식입니다 (위 예에서 사용 된 요소 만). HTML 트리를 빌드합니다. &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;리시버와 함께 &lt;/a&gt;&lt;a href=&quot;extensions&quot;&gt;확장 기능&lt;/a&gt; 과 람다를 많이 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="eb4b287b1edf1ba23dd84510aa2e475b62f2bf92" translate="yes" xml:space="preserve">
          <source>This is how the same function looks without the standard library functions:</source>
          <target state="translated">표준 라이브러리 함수없이 동일한 함수가 보이는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="be45b011252e2fb8cf7402a94a29a95e7994751a" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript module (see &lt;a href=&quot;js-modules&quot;&gt;JavaScript Modules&lt;/a&gt; for more information on this). In this case there won't be a wrapper object, instead, declarations will be exposed as a JavaScript module of a corresponding kind. For example, in case of CommonJS you should write:</source>
          <target state="translated">Kotlin 모듈을 JavaScript 모듈로 컴파일 할 때는 적용 할 수 없습니다 ( 자세한 내용 은 &lt;a href=&quot;js-modules&quot;&gt;JavaScript 모듈&lt;/a&gt; 참조 ). 이 경우 래퍼 객체가 없으므로 선언이 해당 종류의 JavaScript 모듈로 노출됩니다. 예를 들어, CommonJS의 경우 다음을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ac1b203334ec097b223fccc93d140d76e0239d4" translate="yes" xml:space="preserve">
          <source>This is not applicable when you compile your Kotlin module to JavaScript modules like UMD (which is the default setting for both &lt;code&gt;browser&lt;/code&gt; and &lt;code&gt;nodejs&lt;/code&gt; targets), CommonJS or AMD. In this case, your declarations will be exposed in the format specified by your chosen JavaScript module system. When using UMD or CommonJS, for example, your call site could look like this:</source>
          <target state="translated">Kotlin 모듈을 UMD와 같은 자바 스크립트 모듈로 컴파일 할 때는 적용되지 않습니다 ( &lt;code&gt;browser&lt;/code&gt; 및 &lt;code&gt;nodejs&lt;/code&gt; 모두의 기본 설정) 대상 ), CommonJS 또는 AMD . 이 경우 선언은 선택한 JavaScript 모듈 시스템에서 지정한 형식으로 노출됩니다. 예를 들어 UMD 또는 CommonJS를 사용하는 경우 호출 사이트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16ae8412e011bd154f0f6ed0d14afcc433a50b3b" translate="yes" xml:space="preserve">
          <source>This is not required when using Kotlin Gradle plugin 1.1.1 and above with the &lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle plugins DSL&lt;/a&gt;, and with &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.gradle.org/current/userguide/plugins.html#sec:plugins_block&quot;&gt;Gradle 플러그인 DSL&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/gradle/kotlin-dsl&quot;&gt;Gradle Kotlin DSL&lt;/a&gt; 과 함께 Kotlin Gradle 플러그인 1.1.1 이상을 사용할 때는 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="04267f944435e1968a98920e69ed6ee93ce59d4b" translate="yes" xml:space="preserve">
          <source>This is one expression in all three languages:</source>
          <target state="translated">이것은 세 언어 모두에서 하나의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="6b9969b7447679a0aefde827887c1e2aff85957c" translate="yes" xml:space="preserve">
          <source>This is one expression in both Kotlin (because the first line doesn't parse on its own) and JavaScript, and doesn't parse in Python:</source>
          <target state="translated">이것은 Kotlin (첫 번째 줄은 자체적으로 구문 분석하지 않기 때문에)과 JavaScript 모두에서 하나의 표현이며 Python에서는 구문 분석하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e08018d2743eaf233d0fdb2fc751af52fc3dee8" translate="yes" xml:space="preserve">
          <source>This is only the beginning and a small example of Kotlin code sharing between iOS and Android (and other platforms) with Kotlin, Kotlin/Native and Kotlin multiplatform projects. The same approach works for real applications, independent of their size or complexity.</source>
          <target state="translated">이것은 Kotlin, Kotlin / Native 및 Kotlin 멀티 플랫폼 프로젝트에서 iOS와 Android (및 기타 플랫폼)간에 Kotlin 코드 공유의 시작이자 작은 예일뿐입니다. 크기 나 복잡성에 관계없이 동일한 응용 프로그램이 실제 응용 프로그램에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="556b42ba8780522a3f90da067d375baba3a8ad1d" translate="yes" xml:space="preserve">
          <source>This is particularly important for Android developers, since the compiler can now correctly analyze generic &lt;code&gt;findViewById&lt;/code&gt; calls in Android API level 26:</source>
          <target state="translated">컴파일러는 이제 Android API 레벨 26에서 일반 &lt;code&gt;findViewById&lt;/code&gt; 호출을 올바르게 분석 할 수 있으므로 이는 Android 개발자에게 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="e920053f53e4a61b09848006ad0bfc26918d5a11" translate="yes" xml:space="preserve">
          <source>This is provided only for convenience; you don't have to extend this interface as long as your delegate provider has a method with the same signature.</source>
          <target state="translated">이는 편의를 위해서만 제공됩니다. 위임 공급자가 동일한 서명을 가진 메서드를 가지고있는 한이 인터페이스를 확장 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="995a44882385c48d93df496a6a80eaaa6c26f44a" translate="yes" xml:space="preserve">
          <source>This is provided only for convenience; you don't have to extend this interface as long as your property delegate has methods with the same signatures.</source>
          <target state="translated">이것은 편의상 제공됩니다. 속성 대리자가 동일한 서명을 가진 메서드를 가지고 있다면이 인터페이스를 확장 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="64b2fb3aa48fe9872cab0264ea29aacf2838772b" translate="yes" xml:space="preserve">
          <source>This is the JS code generated for the Kotlin code above (the &lt;code&gt;main&lt;/code&gt; function). Let's have a closer look at it.</source>
          <target state="translated">위의 Kotlin 코드에 대해 생성 된 JS 코드입니다 ( &lt;code&gt;main&lt;/code&gt; 기능). 자세히 살펴 봅시다.</target>
        </trans-unit>
        <trans-unit id="61af108c05fdc7b4a1413c5ee9cd9367a036a611" translate="yes" xml:space="preserve">
          <source>This is the fastest solution for this particular problem. It works for plain counters, collections, queues and other standard data structures and basic operations on them. However, it does not easily scale to complex state or to complex operations that do not have ready-to-use thread-safe implementations.</source>
          <target state="translated">이것이이 특정 문제에 대한 가장 빠른 해결책입니다. 일반 카운터, 수집, 대기열 및 기타 표준 데이터 구조 및 기본 작업에 사용됩니다. 그러나 즉시 사용 가능한 스레드 안전 구현이없는 복잡한 상태 또는 복잡한 작업으로 쉽게 확장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa369ec473906917e945918ae4ca55d8b5858ee4" translate="yes" xml:space="preserve">
          <source>This is the last tutorial in the series. The first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 마지막 튜토리얼입니다. 이 시리즈의 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. 도 있습니다 &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;C에서 매핑 구조체 및 연합 유형&lt;/a&gt; 및 &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C의에서 매핑 함수 포인터&lt;/a&gt; 자습서.</target>
        </trans-unit>
        <trans-unit id="db342e5eb9179bc09fc429165b10a1574cb68d62" translate="yes" xml:space="preserve">
          <source>This is the main feature of inline classes, which inspired the name &quot;inline&quot;: data of the class is &quot;inlined&quot; into its usages (similar to how content of &lt;a href=&quot;inline-functions&quot;&gt;inline functions&lt;/a&gt; is inlined to call sites).</source>
          <target state="translated">이것은 인라인 클래스의 주요 기능으로, &quot;인라인&quot;이라는 이름에서 영감을 얻었습니다. 클래스의 데이터는 사용법에 &quot;인라인&quot;되어 있습니다 ( &lt;a href=&quot;inline-functions&quot;&gt;인라인 함수의&lt;/a&gt; 내용이 인라인 사이트를 호출 하는 방식과 유사 ).</target>
        </trans-unit>
        <trans-unit id="e191f2b52800fbe76b7db487772b3a907bdf44b0" translate="yes" xml:space="preserve">
          <source>This is the second post in the series. The very first tutorial of the series is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also the &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;Mapping Function Pointers from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 두 번째 게시물입니다. 이 시리즈의 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. &lt;a href=&quot;mapping-function-pointers-from-c&quot;&gt;C&lt;/a&gt; 의 Mapping Function Pointer 와 &lt;a href=&quot;mapping-strings-from-c&quot;&gt;C&lt;/a&gt; 자습서의 Mapping Strings도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d714ceb3667c2a2d840d8a543c7e66ce3d058a3" translate="yes" xml:space="preserve">
          <source>This is the third post in the series. The very first tutorial is &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;Mapping Primitive Data Types from C&lt;/a&gt;. There are also &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;Mapping Struct and Union Types from C&lt;/a&gt; and &lt;a href=&quot;mapping-strings-from-c&quot;&gt;Mapping Strings from C&lt;/a&gt; tutorials.</source>
          <target state="translated">이 시리즈의 세 번째 게시물입니다. 첫 번째 튜토리얼은 &lt;a href=&quot;mapping-primitive-data-types-from-c&quot;&gt;C의 기본 데이터 유형 매핑&lt;/a&gt; 입니다. 도 있습니다 &lt;a href=&quot;mapping-struct-union-types-from-c&quot;&gt;C에서 매핑 구조체 및 연합 유형&lt;/a&gt; 및 &lt;a href=&quot;mapping-strings-from-c&quot;&gt;C의에서 매핑 문자열&lt;/a&gt; 자습서.</target>
        </trans-unit>
        <trans-unit id="4b1e08d2ab9bc443d4e794dd876f58764cb1b59a" translate="yes" xml:space="preserve">
          <source>This is true for a division between any two integer types.</source>
          <target state="translated">이는 두 정수 유형을 나누는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="1cdf86b607345251afe79fd6fc9f04693b54a221" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because the two coroutines execute concurrently. Note that concurrency with coroutines is always explicit.</source>
          <target state="translated">두 코 루틴이 동시에 실행되기 때문에 이는 두 배 빠릅니다. 코 루틴과의 동시성은 항상 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="f2ad8f555f0fd0b81fe583ef82f57587da754391" translate="yes" xml:space="preserve">
          <source>This is twice as fast, because we have concurrent execution of two coroutines. Note that concurrency with coroutines is always explicit.</source>
          <target state="translated">우리는 두 개의 코 루틴을 동시에 실행하기 때문에 두 배 빠릅니다. 코 루틴과의 동시성은 항상 명시 적입니다.</target>
        </trans-unit>
        <trans-unit id="71c1af27d3f71a4b285ff3d26289c1fc97691cf8" translate="yes" xml:space="preserve">
          <source>This is useful for configuring properties that aren't present in the object constructor.</source>
          <target state="translated">이는 개체 생성자에없는 속성을 구성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="92b4fd5ae8a5154b1a5e18bb911000880c41554c" translate="yes" xml:space="preserve">
          <source>This lets Android Studio know that the kotlin directory is a source root, so when the project model is loaded into the IDE it will be properly recognized. Alternatively, you can put Kotlin classes in the Java source directory, typically located in &lt;code&gt;src/main/java&lt;/code&gt;.</source>
          <target state="translated">이를 통해 Android Studio는 kotlin 디렉토리가 소스 루트임을 알 수 있으므로 프로젝트 모델이 IDE에로드 될 때 올바르게 인식됩니다. 또는 Kotlin 클래스를 Java 소스 디렉토리 (일반적으로 &lt;code&gt;src/main/java&lt;/code&gt; 에 있음)에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="736ca34cfc08c91c8fd20715eb24479a73c79bdf" translate="yes" xml:space="preserve">
          <source>This library is published to Bintray JCenter repository, so let us add it:</source>
          <target state="translated">이 라이브러리는 Bintray JCenter 리포지토리에 게시되므로 다음과 같이 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="898c5a35f84b96626909c79797c0f501c038d6e4" translate="yes" xml:space="preserve">
          <source>This list has size of &lt;code&gt;groupCount + 1&lt;/code&gt; where &lt;code&gt;groupCount&lt;/code&gt; is the count of groups in the regular expression. Groups are indexed from 1 to &lt;code&gt;groupCount&lt;/code&gt; and group with the index 0 corresponds to the entire match.</source>
          <target state="translated">이 목록의 크기는 &lt;code&gt;groupCount + 1&lt;/code&gt; 여기서 &lt;code&gt;groupCount&lt;/code&gt; 는 정규식의 그룹 수입니다. 그룹은 1에서 &lt;code&gt;groupCount&lt;/code&gt; 로 색인화되며 색인이 0 인 그룹은 전체 일치 항목에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d9cbb7f39883f90a51ea7e495265c7bc108e6a66" translate="yes" xml:space="preserve">
          <source>This made it easy to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-all-platforms&quot;&gt;share code on all platforms&lt;/a&gt;, but it was not so easy to &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;share between only some of the targets&lt;/a&gt;, especially similar ones that could potentially reuse a lot of the common logic and third-party APIs.</source>
          <target state="translated">이로 인해 &lt;a href=&quot;mpp-share-on-platforms#share-code-on-all-platforms&quot;&gt;모든 플랫폼&lt;/a&gt; 에서 코드를 쉽게 공유 할 수 있었지만 &lt;a href=&quot;mpp-share-on-platforms#share-code-on-similar-platforms&quot;&gt;일부 대상&lt;/a&gt; , 특히 많은 공통 논리 및 타사 API를 잠재적으로 재사용 할 수있는 유사한 대상간에 만 공유하는 것은 그렇게 쉽지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="4bdb3ec74f6932b33fd8d2d9d59b4f6dd5cdc88a" translate="yes" xml:space="preserve">
          <source>This marker distinguishes the experimental contract declaration API and is used to opt-in for that feature when declaring contracts of user functions.</source>
          <target state="translated">이 마커는 실험 계약 선언 API를 구별하며 사용자 기능 계약을 선언 할 때 해당 기능을 옵트 인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="180f1cb299276ef1bdc5f464e18d2794e7d742af" translate="yes" xml:space="preserve">
          <source>This may be useful in the following cases:</source>
          <target state="translated">다음과 같은 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe068972b66d6d75ef4966c9005153d1f9eaed4c" translate="yes" xml:space="preserve">
          <source>This may be useful, for example, when you want to rename a property in a backward-compatible way: you introduce a new property, annotate the old one with the &lt;code&gt;@Deprecated&lt;/code&gt; annotation, and delegate its implementation.</source>
          <target state="translated">예를 들어 이전 버전과 호환되는 방식으로 속성의 이름을 바꾸려는 경우 유용 할 수 있습니다. 새 속성을 도입하고 이전 속성에 &lt;code&gt;@Deprecated&lt;/code&gt; 로 주석을 추가합니다. 주석으로 구현을 위임합니다.</target>
        </trans-unit>
        <trans-unit id="13bd4b9a1ff3829dff4d0473f506ce883108b5a3" translate="yes" xml:space="preserve">
          <source>This means that there's a library in the classpath which does not depend on the Kotlin standard library as a Gradle/Maven dependency, but is distributed in the same artifact with it (i.e. has it &lt;em&gt;bundled&lt;/em&gt;). Such a library may cause issues because standard build tools do not consider it an instance of the Kotlin standard library, thus it's not subject to the dependency version resolution mechanisms, and you can end up with several versions of the same library in the classpath. Consider contacting the authors of such a library and suggesting to use the Gradle/Maven dependency instead.</source>
          <target state="translated">이것은 클래스 경로에 Grat / Maven 의존성으로 Kotlin 표준 라이브러리에 의존하지 않지만 같은 아티팩트로 배포되는 라이브러리가 있음을 의미합니다 (즉, &lt;em&gt;번들로 묶음&lt;/em&gt; ). 이러한 라이브러리는 표준 빌드 도구가 Kotlin 표준 라이브러리의 인스턴스로 간주하지 않기 때문에 문제를 일으킬 수 있으므로 종속성 버전 확인 메커니즘이 적용되지 않으므로 클래스 경로에서 동일한 라이브러리의 여러 버전으로 끝날 수 있습니다. 이러한 라이브러리의 작성자에게 연락하여 Gradle / Maven 종속성을 대신 사용하도록 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="6cde525aeab8f8f490a4ed99ff83215b05165a70" translate="yes" xml:space="preserve">
          <source>This means that you have a dependency on libraries of different versions, for example the 1.1 standard library and the 1.0 reflection library. To prevent subtle errors at runtime, we recommend you to use the same version of all Kotlin libraries. In this case, consider adding an explicit dependency on the 1.1 reflection library.</source>
          <target state="translated">즉, 1.1 표준 라이브러리 및 1.0 리플렉션 라이브러리와 같이 다른 버전의 라이브러리에 종속됩니다. 런타임시 미묘한 오류를 방지하려면 동일한 버전의 모든 Kotlin 라이브러리를 사용하는 것이 좋습니다. 이 경우 1.1 리플렉션 라이브러리에 명시 적 종속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="17a60d9a927ab40397189c8d1b96e5f7c53d044e" translate="yes" xml:space="preserve">
          <source>This means that you're using the Kotlin compiler 1.1 against the standard or reflection library of version 1.0. This can be handled in different ways:</source>
          <target state="translated">이것은 버전 1.0의 표준 또는 리플렉션 라이브러리에 대해 Kotlin 컴파일러 1.1을 사용하고 있음을 의미합니다. 다른 방법으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="77369f21aef42d741a8e7d6c6dac5c006f439aba" translate="yes" xml:space="preserve">
          <source>This means you can call &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; with one required argument and two optional arguments (their default values are calculated by some JavaScript code).</source>
          <target state="translated">즉 , 하나의 필수 인수와 두 개의 선택적 인수를 사용하여 &lt;code&gt;myFunWithOptionalArgs&lt;/code&gt; 를 호출 할 수 있습니다 (기본값은 일부 JavaScript 코드로 계산 됨).</target>
        </trans-unit>
        <trans-unit id="448a85fa82c5ef71170374be3303b1bc78bb209c" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is a part of public API and therefore should be included in the generated documentation for the element to which the annotation is applied.</source>
          <target state="translated">이 메타 주석은 주석이 퍼블릭 API의 일부임을 결정하므로 주석이 적용되는 요소에 대해 생성 된 문서에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c594f1e41ee531a1ebc1db1a8ef8742f5fcd14a" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines that an annotation is applicable twice or more on a single code element</source>
          <target state="translated">이 메타 주석은 단일 코드 요소에 주석이 두 번 이상 적용될 수 있음을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="71d0203916dcd2ae084a69342802dae5c434f881" translate="yes" xml:space="preserve">
          <source>This meta-annotation determines whether an annotation is stored in binary output and visible for reflection. By default, both are true.</source>
          <target state="translated">이 메타 주석은 주석이 이진 출력으로 저장되고 반영 될 수 있는지 여부를 결정합니다. 기본적으로 둘 다 true입니다.</target>
        </trans-unit>
        <trans-unit id="a36fadd37607b67a90a001f3c5a13ec3d8698650" translate="yes" xml:space="preserve">
          <source>This meta-annotation indicates the kinds of code elements which are possible targets of an annotation.</source>
          <target state="translated">이 메타 주석은 주석의 대상이 될 수있는 코드 요소의 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5733089c709664ede5e39a2892f4d97391a8d9f0" translate="yes" xml:space="preserve">
          <source>This method accepts values of &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; type in range &lt;code&gt;0x00..0xff&lt;/code&gt;, other values are prohibited.</source>
          <target state="translated">이 방법은 &lt;code&gt;0x00..0xff&lt;/code&gt; 범위 의 &lt;a href=&quot;../kotlin/-short/index#kotlin.Short&quot;&gt;Short&lt;/a&gt; 유형 값을 허용 하며 다른 값은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="a75948e2d8c32738a31fd96217f7586ee79f04f4" translate="yes" xml:space="preserve">
          <source>This method allows to use destructuring declarations when working with maps, for example:</source>
          <target state="translated">이 방법을 사용하면 맵 작업시 다음과 같은 구조적 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a64298e1d3ab705d641d81b81fea403c6aa3318" translate="yes" xml:space="preserve">
          <source>This method allows to use the &lt;code&gt;x in map&lt;/code&gt; syntax for checking whether an object is contained in the map.</source>
          <target state="translated">이 방법을 사용하면 객체가지도에 포함되어 있는지 확인하기 위해 &lt;code&gt;x in map&lt;/code&gt; 구문 에서 x 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f4999c28f30d3489635a82f469652d71846c62" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="translated">이 메소드는 키가 이미있는 경우 값을 맵에 넣지 않도록하지만 키가 이미 맵에 있어도 &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut%28java.util.concurrent.ConcurrentMap%28%28kotlin.collections.getOrPut.K%2C+kotlin.collections.getOrPut.V%29%29%2C+kotlin.collections.getOrPut.K%2C+kotlin.Function0%28%28kotlin.collections.getOrPut.V%29%29%29%2FdefaultValue&quot;&gt;defaultValue&lt;/a&gt; 함수가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047deaa17bbcb4b085ecd0f5b31fe3d84a681f3f" translate="yes" xml:space="preserve">
          <source>This method guarantees not to put the value into the map if the key is already there, but the &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut(java.util.concurrent.ConcurrentMap((kotlin.collections.getOrPut.K,%20kotlin.collections.getOrPut.V)),%20kotlin.collections.getOrPut.K,%20kotlin.Function0((kotlin.collections.getOrPut.V)))/defaultValue&quot;&gt;defaultValue&lt;/a&gt; function may be invoked even if the key is already in the map.</source>
          <target state="translated">이 메소드는 키가 이미있는 경우 값을 맵에 넣지 않도록 보장하지만 키가 이미 맵에있는 경우에도 &lt;a href=&quot;get-or-put#kotlin.collections%24getOrPut(java.util.concurrent.ConcurrentMap((kotlin.collections.getOrPut.K,%20kotlin.collections.getOrPut.V)),%20kotlin.collections.getOrPut.K,%20kotlin.Function0((kotlin.collections.getOrPut.V)))/defaultValue&quot;&gt;defaultValue&lt;/a&gt; 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="083648bbf3b66e12f1c5e5fd3afa3ff2914dd084" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecd5e6ce22de7239fac178cb06d85481149c22bf" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB byte array size.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다. 내부 제한은 2GB 바이트 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ecfd9cc7f27ed3b4efbb7dd03aebaf75912a636e" translate="yes" xml:space="preserve">
          <source>This method is not recommended on huge files. It has an internal limitation of 2 GB file size.</source>
          <target state="translated">이 방법은 대용량 파일에는 권장되지 않습니다. 파일 크기는 2GB로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="43901fb40d645ef2b68c677a55d2f926ea8ed530" translate="yes" xml:space="preserve">
          <source>This method is redeclared as abstract, because it's not implemented in the base class, so it must be always overridden in the concrete mutable collection implementation.</source>
          <target state="translated">이 메소드는 기본 클래스에서 구현되지 않기 때문에 추상으로 다시 선언되므로, 구체적으로 변경 가능한 콜렉션 구현에서 항상 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f25f95428ac465fef329ee7b3944fdbec35af43f" translate="yes" xml:space="preserve">
          <source>This mode should not be used unless the &lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; instance is guaranteed never to be initialized from more than one thread.</source>
          <target state="translated">&lt;a href=&quot;../-lazy/index&quot;&gt;Lazy&lt;/a&gt; 인스턴스가 둘 이상의 스레드에서 초기화되지 않도록 보장되지 않는 한이 모드를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="6446cf4cb49ffcb2caf4afcf619d26541516a151" translate="yes" xml:space="preserve">
          <source>This name can be used to access the binary:</source>
          <target state="translated">이 이름은 바이너리에 액세스하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb387fd4daeff721899d12634f06c3c11719a1e" translate="yes" xml:space="preserve">
          <source>This now works much faster and produces correct result.</source>
          <target state="translated">이제 훨씬 빠르게 작동하고 올바른 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="da4dbc68402bb11c32b149d461913452ae42bef5" translate="yes" xml:space="preserve">
          <source>This operator should not be used from inside of &lt;a href=&quot;-deep-recursive-scope/index&quot;&gt;DeepRecursiveScope&lt;/a&gt; as it uses the call stack slot for initial recursive invocation. From inside of &lt;a href=&quot;-deep-recursive-scope/index&quot;&gt;DeepRecursiveScope&lt;/a&gt; use &lt;a href=&quot;-deep-recursive-scope/call-recursive&quot;&gt;callRecursive&lt;/a&gt;.</source>
          <target state="translated">이 연산자는 초기 재귀 호출에 호출 스택 슬롯을 사용하므로 &lt;a href=&quot;-deep-recursive-scope/index&quot;&gt;DeepRecursiveScope&lt;/a&gt; 내부에서 사용해서는 안됩니다 . &lt;a href=&quot;-deep-recursive-scope/index&quot;&gt;DeepRecursiveScope&lt;/a&gt; 내부에서 callRecursive를 사용 &lt;a href=&quot;-deep-recursive-scope/call-recursive&quot;&gt;합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08d7f6ce5ec74ffd1dae5f3e2a4e554fa93562ae" translate="yes" xml:space="preserve">
          <source>This page contains the current coding style for the Kotlin language.</source>
          <target state="translated">이 페이지에는 코 틀린 언어의 현재 코딩 스타일이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d592b749bb8c59614b5bce1df54bbaa180a699f7" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended that you keep Kotlin and Java files separately (in case the project contains Java files). If you don't store them separately , specify the source folder in the &lt;code&gt;sourceSets&lt;/code&gt; block:</source>
          <target state="translated">이 플러그인은 Kotlin 파일에서만 작동하므로 Kotlin 및 자바 파일을 별도로 보관하는 것이 좋습니다 (프로젝트에 자바 파일이 포함 된 경우). 별도로 저장하지 않는 경우 &lt;code&gt;sourceSets&lt;/code&gt; 블록 에 소스 폴더를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b0d3b6a365feefc5bf2639481a27bf15df77f32" translate="yes" xml:space="preserve">
          <source>This plugin only works for Kotlin files so it is recommended to keep Kotlin and Java files separate (in case if the same project contains Java files). As with targeting the JVM, if not using the default convention, you should specify the source folder using &lt;em&gt;sourceSets&lt;/em&gt;:</source>
          <target state="translated">이 플러그인은 Kotlin 파일에서만 작동하므로 Kotlin과 Java 파일을 동일한 프로젝트에 Java 파일이 포함 된 경우 별도로 보관하는 것이 좋습니다. JVM을 대상으로하는 것처럼 기본 규칙을 사용하지 않는 경우 &lt;em&gt;sourceSets를&lt;/em&gt; 사용하여 소스 폴더를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d1dbfb5aeb4d13de4e43c69f4da833e8295308f" translate="yes" xml:space="preserve">
          <source>This podspec file can be referenced from a &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; of an Xcode project. After that the framework built from the Kotlin/Native module can be used from this Xcode project. If necessary, this framework is automatically rebuilt during Xcode build process.</source>
          <target state="translated">이 podspec 파일은 Xcode 프로젝트 의 &lt;a href=&quot;https://guides.cocoapods.org/using/the-podfile.html&quot;&gt;Podfile&lt;/a&gt; 에서 참조 할 수 있습니다 . 그 후 Kotlin / Native 모듈로 빌드 된 프레임 워크를이 Xcode 프로젝트에서 사용할 수 있습니다. 필요한 경우이 프레임 워크는 Xcode 빌드 프로세스 중에 자동으로 다시 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">이것은 인쇄</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">인쇄합니다 :</target>
        </trans-unit>
        <trans-unit id="ebe525fb027f139b406ffe6decdd11bbf6d8b5bb" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons explained below.</source>
          <target state="translated">비동기 함수를 사용하는이 프로그래밍 스타일은 다른 프로그래밍 언어에서 널리 사용되는 스타일이므로 여기에서는 설명 용으로 만 제공됩니다. 이 스타일을 Kotlin 코 루틴과 함께 사용 &lt;strong&gt;하는 것은 권장하지 않습니다.&lt;/strong&gt; 아래에 설명 된 이유 때문에 .</target>
        </trans-unit>
        <trans-unit id="cda4b457c77664242055b4741cc46d64c55f08a1" translate="yes" xml:space="preserve">
          <source>This programming style with async functions is provided here only for illustration, because it is a popular style in other programming languages. Using this style with Kotlin coroutines is &lt;strong&gt;strongly discouraged&lt;/strong&gt; for the reasons that are explained below.</source>
          <target state="translated">비동기 함수가있는이 프로그래밍 스타일은 다른 프로그래밍 언어에서 널리 사용되는 스타일이기 때문에 여기에서는 설명을 위해서만 제공됩니다. Kotlin 코 루틴과 함께이 스타일을 사용 &lt;strong&gt;하는 것은&lt;/strong&gt; 아래 설명 된 이유로 &lt;strong&gt;권장하지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="77b890076daadde689d1ec3897dcc482dac8e326" translate="yes" xml:space="preserve">
          <source>This property can be used in two cases:</source>
          <target state="translated">이 속성은 두 가지 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff03394cef9f3232cd16286e35c99b97f61a20fd" translate="yes" xml:space="preserve">
          <source>This property can't be used from normal code.</source>
          <target state="translated">이 속성은 일반 코드에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7c3d50d77ba7c2fef150fd01d7bd663fd6396e5" translate="yes" xml:space="preserve">
          <source>This property is currently not supported in Kotlin/JS.</source>
          <target state="translated">이 속성은 현재 Kotlin / JS에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2196c6e17a412a106531ad1fc581b412f9389ab" translate="yes" xml:space="preserve">
          <source>This property of a flow is called &lt;em&gt;context preservation&lt;/em&gt;.</source>
          <target state="translated">흐름의이 속성을 &lt;em&gt;컨텍스트 보존&lt;/em&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="c5517f3de5c3954c1997a06c521c60c838cdab23" translate="yes" xml:space="preserve">
          <source>This protected method should be overridden to return the current reading of the time source expressed as a &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; number in the unit specified by the &lt;a href=&quot;unit&quot;&gt;unit&lt;/a&gt; property.</source>
          <target state="translated">이 보호 된 메서드는 &lt;a href=&quot;unit&quot;&gt;unit&lt;/a&gt; 속성에 지정된 단위 로 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; 숫자 로 표현 된 시간 원본의 현재 판독 값을 반환하도록 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="28f6dba9afcf9e41a248ed22e9825e004644bd01" translate="yes" xml:space="preserve">
          <source>This protected method should be overridden to return the current reading of the time source expressed as a &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number in the unit specified by the &lt;a href=&quot;../-abstract-long-time-source/unit&quot;&gt;unit&lt;/a&gt; property.</source>
          <target state="translated">이 보호 된 메서드는 &lt;a href=&quot;../-abstract-long-time-source/unit&quot;&gt;unit&lt;/a&gt; 속성에 지정된 단위 로 &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 숫자 로 표현 된 시간 원본의 현재 판독 값을 반환하도록 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8a502fcd862a7a6134a3c1a231924a5e92f7555" translate="yes" xml:space="preserve">
          <source>This protected method should be overridden to return the current reading of the time source expressed as a &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; number in the unit specified by the &lt;a href=&quot;unit&quot;&gt;unit&lt;/a&gt; property.</source>
          <target state="translated">이 보호 된 메서드는 &lt;a href=&quot;unit&quot;&gt;unit&lt;/a&gt; 속성에 지정된 단위 로 &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 숫자 로 표현 된 시간 원본의 현재 판독 값을 반환하도록 재정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aec1ca1351fa183afc05654031c5fff3d664e375" translate="yes" xml:space="preserve">
          <source>This protocol is designed for comfortable updates as no project can be blocked from updating its dependencies even if it's using a slightly outdated compiler.</source>
          <target state="translated">이 프로토콜은 프로젝트가 약간 오래된 컴파일러를 사용하더라도 종속성 업데이트를 차단할 수 없으므로 편리한 업데이트를 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="98a9e8bab8deee99e0e21fcb3247e8a1511740b5" translate="yes" xml:space="preserve">
          <source>This publication does not include any artifacts and only references the other publications as its variants. However, it may need the sources and documentation artifacts if that is required by the repository. In that case, add those artifacts by using &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt;&lt;code&gt;artifact(...)&lt;/code&gt;&lt;/a&gt; in the publication's scope, which is accessed as shown above.</source>
          <target state="translated">이 발행물에는 아티팩트가 포함되어 있지 않으며 다른 발행물을 해당 변형으로 만 참조합니다. 그러나 저장소에 필요한 경우 소스 및 문서 아티팩트가 필요할 수 있습니다. 이 경우 게시 범위에서 &lt;a href=&quot;https://docs.gradle.org/current/javadoc/org/gradle/api/publish/maven/MavenPublication.html#artifact-java.lang.Object-&quot;&gt; &lt;code&gt;artifact(...)&lt;/code&gt; &lt;/a&gt; 를 사용하여 위의 아티팩트를 추가하십시오 . 위의 그림과 같이 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="e2515924de7501ee2f4c68fc0b725aaaf061557d" translate="yes" xml:space="preserve">
          <source>This quickly gets unwieldy, so you will typically &lt;em&gt;import&lt;/em&gt; the symbols you need. You can import a specific symbol:</source>
          <target state="translated">이것은 다루기 어려워 지므로 일반적으로 필요한 기호를 &lt;em&gt;가져옵니다&lt;/em&gt; . 특정 심볼을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4727911dc96369eca10addebc256163a4abb387" translate="yes" xml:space="preserve">
          <source>This requires that the consumer's Gradle build can read Gradle module metadata, either using Gradle 5.3+ or explicitly enabling it by &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; in &lt;code&gt;settings.gradle&lt;/code&gt;.</source>
          <target state="translated">이렇게하여 수 있도록 명시 적으로 Gradle을을 사용하여 5.3+ 또는 중, 소비자의 Gradle을 빌드 Gradle을 모듈 메타 데이터를 읽을 수 있어야 &lt;code&gt;enableFeaturePreview(&quot;GRADLE_METADATA&quot;)&lt;/code&gt; 에 &lt;code&gt;settings.gradle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3811c08a3b736bc78dff85189aa76ac7adf599c" translate="yes" xml:space="preserve">
          <source>This returns &lt;code&gt;b.length&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is not null, and &lt;em&gt;null&lt;/em&gt; otherwise. The type of this expression is &lt;code&gt;Int?&lt;/code&gt;.</source>
          <target state="translated">이 반환 &lt;code&gt;b.length&lt;/code&gt; 경우 &lt;code&gt;b&lt;/code&gt; 는 null이되지 않고 &lt;em&gt;널 (null)&lt;/em&gt; 이 없습니다. 이 표현의 타입은 &lt;code&gt;Int?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="752e46575723521dd2b0e2f3643820dd84459a5c" translate="yes" xml:space="preserve">
          <source>This runs a 1'000'000 threads each of which adds to a common counter. My patience runs out before this program completes on my machine (definitely over a minute).</source>
          <target state="translated">이것은 공통 카운터에 추가되는 1'000'000 스레드를 실행합니다. 이 프로그램이 컴퓨터에서 완료되기 전에 인내심이 없어집니다 (분당).</target>
        </trans-unit>
        <trans-unit id="86208ae33ef90a5dcb8c41ac6a075a89ce88f8d7" translate="yes" xml:space="preserve">
          <source>This section covers basic coroutine concepts.</source>
          <target state="translated">이 섹션은 기본적인 코 루틴 개념을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="75d5f867c8b73c01b71e379315dc5e2a4c6f94a7" translate="yes" xml:space="preserve">
          <source>This section covers coroutine cancellation and timeouts.</source>
          <target state="translated">이 섹션에서는 코 루틴 취소 및 타임 아웃에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1de34a1a4060ac4a9343482aadfbf40dd5028f41" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that a cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by the coroutines' machinery. Here we look at what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception.</source>
          <target state="translated">이 섹션에서는 예외 처리 및 예외에 대한 취소를 다룹니다. 취소 된 코 루틴 이 중단 지점에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; 을 발생시키고 코 루틴의 기계에 의해 무시된다는 것을 이미 알고 있습니다. 여기에서는 취소 중에 예외가 발생하거나 동일한 코 루틴의 여러 자식이 예외를 발생시키는 경우 어떻게되는지 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="7fd839d8f63682d12541a453824eb6d8c7ab4f81" translate="yes" xml:space="preserve">
          <source>This section covers exception handling and cancellation on exceptions. We already know that cancelled coroutine throws &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; in suspension points and that it is ignored by coroutines machinery. But what happens if an exception is thrown during cancellation or multiple children of the same coroutine throw an exception?</source>
          <target state="translated">이 섹션에서는 예외 처리 및 예외 취소에 대해 설명합니다. 우리는 이미 취소 된 코 루틴 이 서스펜션 포인트에서 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html&quot;&gt;CancellationException&lt;/a&gt; 을 던지고 코 루틴 기계에 의해 무시된다는 것을 이미 알고 있습니다. 그러나 취소 중에 예외가 발생하거나 동일한 코 루틴의 여러 자녀가 ​​예외를 throw하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="dd1323da1dc057b96f757b1081629bfe17cfb809" translate="yes" xml:space="preserve">
          <source>This section covers various approaches to composition of suspending functions.</source>
          <target state="translated">이 섹션은 서 스펜 딩 기능의 구성에 대한 다양한 접근법을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="a95364236d062d020a78b5720e48ac1fd0f74e43" translate="yes" xml:space="preserve">
          <source>This section provides steps for creating a multiplatform library. You can also complete the &lt;a href=&quot;../tutorials/mpp/multiplatform-library&quot;&gt;tutorial&lt;/a&gt; where you will create a multiplatform library, test it, and publish it to Maven.</source>
          <target state="translated">이 섹션에서는 다중 플랫폼 라이브러리를 만드는 단계를 제공합니다. 멀티 플랫폼 라이브러리를 만들고 테스트 한 다음 Maven에 게시 하는 &lt;a href=&quot;../tutorials/mpp/multiplatform-library&quot;&gt;자습서를&lt;/a&gt; 완료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0b801aac5ae1a9b9aa65ed84d940a1ebfabf5c1" translate="yes" xml:space="preserve">
          <source>This self-contained jar file can be passed directly to a JRE to run your application:</source>
          <target state="translated">이 자체 포함 된 jar 파일은 JRE로 직접 전달되어 애플리케이션을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="223d9ca7ba6df0b968b70ef4903c89512ab178b6" translate="yes" xml:space="preserve">
          <source>This should create a folder &lt;code&gt;build/native/bin&lt;/code&gt; with two subfolders &lt;code&gt;debugExecutable&lt;/code&gt; and &lt;code&gt;releaseExecutable&lt;/code&gt; with the corresponding binary. By default, the binary is named the same as the project folder.</source>
          <target state="translated">그러면 해당 바이너리가있는 &lt;code&gt;debugExecutable&lt;/code&gt; 및 &lt;code&gt;releaseExecutable&lt;/code&gt; 하위 폴더가 두 개있는 &lt;code&gt;build/native/bin&lt;/code&gt; 폴더가 생성 됩니다. 기본적으로 바이너리의 이름은 프로젝트 폴더와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="07b72134ade9a0b803e3da70c408db30a1a38134" translate="yes" xml:space="preserve">
          <source>This simplified example ensures that publications are only uploaded when &lt;code&gt;isMainHost=true&lt;/code&gt; is passed. This means that a publication that can be published from multiple platforms will be published only once &amp;ndash; from the main host.</source>
          <target state="translated">이 단순화 된 예제는 &lt;code&gt;isMainHost=true&lt;/code&gt; 가 전달 된 경우에만 발행물이 업로드되도록합니다 . 즉, 여러 플랫폼에서 게시 할 수있는 게시는 주 호스트에서 한 번만 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="3eff95c0ad7329dd98bdd50eb833ef0910fc787b" translate="yes" xml:space="preserve">
          <source>This simplified example ensures that the JVM, JS, and Kotlin metadata publications are only uploaded when &lt;code&gt;-PisLinux=true&lt;/code&gt; is passed to the build in the command line:</source>
          <target state="translated">이 간단한 예제는 JVM, JS 및 Kotlin 메타 데이터 게시가 명령 행에서 &lt;code&gt;-PisLinux=true&lt;/code&gt; 가 빌드로 전달 될 때만 업로드 되도록합니다.</target>
        </trans-unit>
        <trans-unit id="41a51abdee059894e1c3bfb1c72642c3da8b751d" translate="yes" xml:space="preserve">
          <source>This starts a new coroutine. By default, coroutines are run on a shared pool of threads. Threads still exist in a program based on coroutines, but one thread can run many coroutines, so there's no need for too many threads.</source>
          <target state="translated">새로운 코 루틴이 시작됩니다. 기본적으로 코 루틴은 공유 스레드 풀에서 실행됩니다. 스레드는 여전히 코 루틴 기반 프로그램에 존재하지만 하나의 스레드는 많은 코 루틴을 실행할 수 있으므로 너무 많은 스레드가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08ae2339793360b19c579572a5e9dcd8e02beebb" translate="yes" xml:space="preserve">
          <source>This step helps synchronize your Xcode project with Kotlin Pod dependencies by calling &lt;code&gt;pod install&lt;/code&gt; for your &lt;code&gt;Podfile&lt;/code&gt;.</source>
          <target state="translated">이 단계는 &lt;code&gt;Podfile&lt;/code&gt; 에 대한 &lt;code&gt;pod install&lt;/code&gt; 을 호출하여 Xcode 프로젝트를 Kotlin Pod 종속성과 동기화하는 데 도움이됩니다. .</target>
        </trans-unit>
        <trans-unit id="76c41d50702d4202e91d08f7ef8c0739fa6d0823" translate="yes" xml:space="preserve">
          <source>This syntax is called a &lt;em&gt;destructuring declaration&lt;/em&gt;. A destructuring declaration creates multiple variables at once. We have declared two new variables: &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt;, and can use them independently:</source>
          <target state="translated">이 구문을 &lt;em&gt;파괴 선언&lt;/em&gt; 이라고합니다 . 파괴 선언은 한 번에 여러 변수를 만듭니다. 우리는 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 라는 두 가지 새로운 변수를 선언 했고 , 그것들을 독립적으로 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="530a8c17c6739ef629eabdb94246db16d43922c7" translate="yes" xml:space="preserve">
          <source>This table says that when the compiler processes, for example, an expression &lt;code&gt;+a&lt;/code&gt;, it performs the following steps:</source>
          <target state="translated">이 테이블은 컴파일러가 예를 들어 &lt;code&gt;+a&lt;/code&gt; 식을 처리 할 때 다음 단계를 수행 한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="cca6caa135016bb5fe36c582797dd2583e1f3082" translate="yes" xml:space="preserve">
          <source>This takes about 10 seconds on my machine, so yes, coroutines do run in parallel.</source>
          <target state="translated">내 컴퓨터에서 약 10 초가 걸리므로 코 루틴이 병렬로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="215ff0a6c5e99998fdfa92a79eaf70ff28fc615e" translate="yes" xml:space="preserve">
          <source>This task copies both dependencies runtime files and the compilation output to the &lt;code&gt;web&lt;/code&gt; directory.</source>
          <target state="translated">이 태스크는 종속성 런타임 파일과 컴파일 결과를 &lt;code&gt;web&lt;/code&gt; 디렉토리에 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="1a26679828d6c6d2c31183443afd2cce0f1abe38" translate="yes" xml:space="preserve">
          <source>This test will be automatically executed on the JVM target in addition to the common part.</source>
          <target state="translated">이 테스트는 공통 부분 외에 JVM 대상에서 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="66487ce50428c7f10ee64de3817e29a9dd09d391" translate="yes" xml:space="preserve">
          <source>This time source returns its readings from a source of monotonic time when it is available in a target platform, and resorts to a non-monotonic time source otherwise.</source>
          <target state="translated">이 시간 원본은 대상 플랫폼에서 사용할 수있는 경우 단조로운 시간 원본에서 판독 값을 반환하고 그렇지 않으면 비단 조적인 시간 원본에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="422dc05df4ea784a9b658e3b358ccefed13a0844" translate="yes" xml:space="preserve">
          <source>This time we take a returned &lt;code&gt;char *&lt;/code&gt; from the &lt;code&gt;return_string&lt;/code&gt; function and turn it into a Kotlin string. For that we do the following in Kotlin:</source>
          <target state="translated">이번에 는 &lt;code&gt;return_string&lt;/code&gt; 함수 에서 반환 된 &lt;code&gt;char *&lt;/code&gt; 를 가져와 Kotlin 문자열로 바꿉니다. 이를 위해 Kotlin에서 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1bc095b457022b841cd86dbdae9f7dd06a0233ca" translate="yes" xml:space="preserve">
          <source>This time we will ask a C function to write us a C string to a given buffer. The function is called &lt;code&gt;copy_string&lt;/code&gt;. It takes a pointer to the location writing characters and the allowed buffer size. The function returns something to indicate if it has succeeded or failed. Let's assume &lt;code&gt;0&lt;/code&gt; means it succeeded, and the supplied buffer was big enough:</source>
          <target state="translated">이번에는 C 함수에게 주어진 버퍼에 C 문자열을 쓰도록 요청할 것입니다. 이 함수를 &lt;code&gt;copy_string&lt;/code&gt; 이라고 합니다 . 문자를 쓰는 위치와 허용되는 버퍼 크기에 대한 포인터가 필요합니다. 이 함수는 성공 또는 실패 여부를 나타내는 것을 반환합니다. &lt;code&gt;0&lt;/code&gt; 이 성공을 의미하고 제공된 버퍼가 충분히 크다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="82c6c3bd1da0d55221efcca2072d5e9cdb826610" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to create Kotlin Flow and debug it using IntelliJ IDEA.</source>
          <target state="translated">이 가이드에서는 Kotlin Flow를 만들고 IntelliJ IDEA를 사용하여 디버깅하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c68ca0982e68f9e22974e99e2e822ed4b0d343c0" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to create Kotlin coroutines and debug them using IntelliJ IDEA.</source>
          <target state="translated">이 가이드에서는 Kotlin 코 루틴을 만들고 IntelliJ IDEA를 사용하여 디버깅하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f9387511094971af8445fb83c09dde400b482b22" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to use IntelliJ IDEA for creating a Kotlin/Native application.</source>
          <target state="translated">이 가이드에서는 Kotlin / Native 애플리케이션을 만들기 위해 IntelliJ IDEA를 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ebf218f1387966b47fc351969c1b8ff8c0f7190c" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to use IntelliJ IDEA for creating a console application.</source>
          <target state="translated">이 자습서에서는 IntelliJ IDEA를 사용하여 콘솔 애플리케이션을 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fe4c518bfe506edc227e9d14e1ef41199e094bec" translate="yes" xml:space="preserve">
          <source>This tutorial demonstrates how to use IntelliJ IDEA for creating a frontend application with Kotlin/JS for React.</source>
          <target state="translated">이 가이드에서는 IntelliJ IDEA를 사용하여 React 용 Kotlin / JS로 프런트 엔드 애플리케이션을 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="95eb5f454522f97d35d22eb89071211f56ea5b5c" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use Kotlin Android Extensions to improve support for Android development.</source>
          <target state="translated">이 학습서는 Kotlin Android 확장을 사용하여 Android 개발 지원을 개선하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="54b32f69d1a441fb0920f9a2c8eb9ed0a6588065" translate="yes" xml:space="preserve">
          <source>This tutorial describes how to use in Kotlin popular Android frameworks and libraries that rely on annotation processing.</source>
          <target state="translated">이 튜토리얼에서는 주석 처리에 의존하는 Kotlin의 인기있는 Android 프레임 워크 및 라이브러리에서 사용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="98dac163941bb963709918b2eba82c9b82af15ef" translate="yes" xml:space="preserve">
          <source>This tutorial explains the basic usage of Kotlin for competitive programming.</source>
          <target state="translated">이 튜토리얼은 경쟁력있는 프로그래밍을위한 Kotlin의 기본 사용법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d0f7acc9fd5623b0666fe34b54ba37696a87ee9a" translate="yes" xml:space="preserve">
          <source>This tutorial explains the different approaches to asynchronous programming</source>
          <target state="translated">이 튜토리얼은 비동기 프로그래밍에 대한 다양한 접근 방식을 설명합니다</target>
        </trans-unit>
        <trans-unit id="b37aa099eaa69fb3a0a9c2ea81dc57defd40be24" translate="yes" xml:space="preserve">
          <source>This tutorial is designed both for competitive programmers that did not use Kotlin before and for Kotlin developers that did not participate in any competitive programming events before. It assumes the corresponding programming skills.</source>
          <target state="translated">이 튜토리얼은 이전에 Kotlin을 사용하지 않은 경쟁 프로그래머와 이전에 경쟁 프로그래밍 이벤트에 참여하지 않은 Kotlin 개발자를 위해 설계되었습니다. 해당 프로그래밍 기술을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6ab5e488d7caf8012aa22bda0a09bdd7f98d9861" translate="yes" xml:space="preserve">
          <source>This tutorial shows how to debug a Kotlin/JS project build by Gradle. If you are using Maven or IDEA, the recipes would be similar.</source>
          <target state="translated">이 튜토리얼은 Gradle의 Kotlin / JS 프로젝트 빌드를 디버깅하는 방법을 보여줍니다. Maven 또는 IDEA를 사용하는 경우 레시피는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="f9acc149373601d8ab69e64887e6e309b360247b" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to run Kotlin code snippets in a lightweight manner without creating or modifying the whole project.</source>
          <target state="translated">이 튜토리얼은 전체 프로젝트를 만들거나 수정하지 않고 간단한 방식으로 Kotlin 코드 스 니펫을 실행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="946efbdf49896b1eceb2a440b208d6a7b7c887c4" translate="yes" xml:space="preserve">
          <source>This tutorial shows the ways to write and run Kotlin code snippets in a lightweight manner without creating entire applications.</source>
          <target state="translated">이 가이드에서는 전체 애플리케이션을 만들지 않고 가벼운 방식으로 Kotlin 코드 스 니펫을 작성하고 실행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b741e974e2ef9e2aadef771ec4ed4af6da26b1ed" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Hello World application using the command line compiler.</source>
          <target state="translated">이 튜토리얼은 명령 행 컴파일러를 사용하여 Hello World 애플리케이션을 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="9ef69a04e24828e3b4f1be864d64b99505227e64" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a Kotlin JavaScript library using the command line compiler.</source>
          <target state="translated">이 튜토리얼은 명령 행 컴파일러를 사용하여 Kotlin JavaScript 라이브러리를 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7cbf690e869df1155e9df8254a2e24065f3c7742" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through creating a simple Kotlin application for Android.</source>
          <target state="translated">이 튜토리얼은 Android 용 간단한 Kotlin 응용 프로그램을 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="262f778d62fb1c6728a7e17683a48adb22e2c354" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through setting up a project using coroutines, and writing code that uses them.</source>
          <target state="translated">이 튜토리얼은 코 루틴을 사용하여 프로젝트를 설정하고이를 사용하는 코드를 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="b761f80d7daf0f57c426b6c2c8f5551348835c06" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple REST controller with Spring Boot</source>
          <target state="translated">이 튜토리얼은 Spring Boot로 간단한 REST 컨트롤러를 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="d3c06d78974760f747dc344799aadb31e636411d" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of creating a simple controller using HttpServlet to display Hello World.</source>
          <target state="translated">이 튜토리얼은 HttpServlet을 사용하여 Hello World를 표시하는 간단한 컨트롤러를 만드는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="917a46d0d52ec8a68291cefda5c1868408d5366b" translate="yes" xml:space="preserve">
          <source>This tutorial walks us through the process of using Java and Kotlin in a single IntelliJ IDEA project.</source>
          <target state="translated">이 튜토리얼에서는 단일 IntelliJ IDEA 프로젝트에서 Java 및 Kotlin을 사용하는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="5c37cdc48efb7900f24478fb914764b4ad25e974" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through a series of exercises to get familiar with Kotlin.</source>
          <target state="translated">이 튜토리얼은 Kotlin에 익숙해 지도록 일련의 연습을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="fed85180abcbc65ba4b2af3d5f5d2d524508a6b7" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through creating a simple Hello World application using IntelliJ IDEA.</source>
          <target state="translated">이 자습서는 IntelliJ IDEA를 사용하여 간단한 Hello World 응용 프로그램을 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="3a3a5550c3979eb75d3c935292c9198b690dcdbe" translate="yes" xml:space="preserve">
          <source>This tutorial walks you through the interactive learning with a set of Kotlin programming tasks.</source>
          <target state="translated">이 튜토리얼은 일련의 Kotlin 프로그래밍 작업을 통해 대화식 학습을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="1922851cbe5cc3d86c3c73d15c6f4bdffb8c9675" translate="yes" xml:space="preserve">
          <source>This tutorial will walk you through creating a simple Kotlin course with a set of programming tasks and integrated tests.</source>
          <target state="translated">이 튜토리얼은 일련의 프로그래밍 작업과 통합 테스트로 간단한 Kotlin 코스를 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="c6030bef069b6977eab83078442b66dedd7712ad" translate="yes" xml:space="preserve">
          <source>This tutorials walks us through creating a simple Hello World application using Eclipse IDE</source>
          <target state="translated">이 튜토리얼은 Eclipse IDE를 사용하여 간단한 Hello World 애플리케이션을 작성하는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="1cba3a52b4e9e49248914c3506dd87812401b394" translate="yes" xml:space="preserve">
          <source>This type is used as a receiver type of the lambda function passed to the &lt;a href=&quot;../contract&quot;&gt;contract&lt;/a&gt; function.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;../contract&quot;&gt;계약&lt;/a&gt; 함수에 전달 된 람다 함수의 수신자 유형으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d42addf558756322234c05ff9ff53ebc28a290b0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">이 값은 &lt;a href=&quot;suspend-coroutine-or-return&quot;&gt;suspendCoroutineOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 인수 의 반환 값으로 사용되어 실행이 일시 중단되었으며 결과를 즉시 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f268b965a48f4655e5367448b4016e6f76edf6f0" translate="yes" xml:space="preserve">
          <source>This value is used as a return value of &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn&lt;/a&gt;&lt;code&gt;block&lt;/code&gt; argument to state that the execution was suspended and will not return any result immediately.</source>
          <target state="translated">이 값은 &lt;a href=&quot;suspend-coroutine-unintercepted-or-return&quot;&gt;suspendCoroutineUninterceptedOrReturn &lt;/a&gt; &lt;code&gt;block&lt;/code&gt; 인수 의 반환 값으로 사용되어 실행이 일시 중단되었으며 결과를 즉시 반환하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6e8f43b127da8dc0c4ddf32ba0afa9420b6890c9" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="translated">이 값은 &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo%28kotlin.ranges.rangeTo.T%2C+kotlin.ranges.rangeTo.T%29%2Fthat&quot;&gt;해당&lt;/a&gt; 값 보다 작아야 합니다 . 그렇지 않으면 반환 된 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d268ef4eff4a4c02ff30a25a66e6ca340c2e614" translate="yes" xml:space="preserve">
          <source>This value needs to be smaller than &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo(kotlin.ranges.rangeTo.T,%20kotlin.ranges.rangeTo.T)/that&quot;&gt;that&lt;/a&gt; value, otherwise the returned range will be empty.</source>
          <target state="translated">이 값은 &lt;a href=&quot;range-to#kotlin.ranges%24rangeTo(kotlin.ranges.rangeTo.T,%20kotlin.ranges.rangeTo.T)/that&quot;&gt;해당&lt;/a&gt; 값 보다 작아야 합니다 . 그렇지 않으면 반환 된 범위가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4e95d6779047f36ef44cebc8fe10ec0e5dbd2f" translate="yes" xml:space="preserve">
          <source>This way any value of type &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; can be passed as an argument of &lt;code&gt;const char*&lt;/code&gt; type. If a Kotlin string should be passed, code like this could be used:</source>
          <target state="translated">이런 식으로 &lt;code&gt;CPointer&amp;lt;ByteVar&amp;gt;&lt;/code&gt; 유형의 값 을 &lt;code&gt;const char*&lt;/code&gt; 유형 의 인수로 전달할 수 있습니다 . Kotlin 문자열을 전달해야하는 경우 다음과 같은 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a5e105dc56eeee056d102244e8a0f5fed4f0c6" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope are cancelled.</source>
          <target state="translated">이런 식으로, &lt;code&gt;concurrentSum&lt;/code&gt; 함수 의 코드 내에서 문제 가 발생하여 예외가 발생하면 해당 범위에서 시작된 모든 코 루틴이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="751432b1fc412bf87d1b4554a9034d2372594768" translate="yes" xml:space="preserve">
          <source>This way, if something goes wrong inside the code of the &lt;code&gt;concurrentSum&lt;/code&gt; function and it throws an exception, all the coroutines that were launched in its scope will be cancelled.</source>
          <target state="translated">이렇게하면 &lt;code&gt;concurrentSum&lt;/code&gt; 함수 의 코드에서 문제 가 발생하여 예외가 발생하면 해당 범위에서 시작된 모든 코 루틴이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="f17f9d1f7410fbad939ec9e37eb14f1a6139cb16" translate="yes" xml:space="preserve">
          <source>This will apply the Gradle &lt;code&gt;java&lt;/code&gt; plugin and configure the target to cooperate with it. Note that just applying the Java plugin without specifying &lt;code&gt;withJava()&lt;/code&gt; in a JVM target will have no effect on the target.</source>
          <target state="translated">Gradle &lt;code&gt;java&lt;/code&gt; 플러그인 을 적용하고 대상과 협력하도록 구성합니다. JVM 대상에서 &lt;code&gt;withJava()&lt;/code&gt; 를 지정하지 않고 Java 플러그인을 적용해도 대상에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e9c760291236659fa80c3cad20690354472cf0c" translate="yes" xml:space="preserve">
          <source>This will assign &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is non-null, but if it is null, the entire function that contains this expression will stop and return &lt;code&gt;y&lt;/code&gt; (this works because &lt;code&gt;return&lt;/code&gt; is also an expression, and if it is evaluated, it evaluates its argument and then makes the containing function return the result).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 널이 아닌 경우 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;z&lt;/code&gt; 를 할당 하지만, 널이 아닌 경우이 표현식을 포함하는 전체 함수는 중지하고 &lt;code&gt;y&lt;/code&gt; 를 리턴합니다 ( &lt;code&gt;return&lt;/code&gt; 도 표현식 이기 때문에 작동 하며, 평가되는 경우에는이를 평가합니다). 인수를 포함하고 포함 함수가 결과를 리턴하게합니다.</target>
        </trans-unit>
        <trans-unit id="e3c6e68d7f248b58990253f88430e5ca4c4c8e2b" translate="yes" xml:space="preserve">
          <source>This will automatically implement all the interface members of &lt;code&gt;PowerSource&lt;/code&gt; in &lt;code&gt;MotorVehicle&lt;/code&gt; by invoking the same member on &lt;code&gt;engine&lt;/code&gt;. This only works for properties that are declared in the constructor.</source>
          <target state="translated">&lt;code&gt;engine&lt;/code&gt; 에서 동일한 멤버를 호출하여 &lt;code&gt;MotorVehicle&lt;/code&gt; 에서 &lt;code&gt;PowerSource&lt;/code&gt; 의 모든 인터페이스 멤버를 자동으로 구현합니다 . 생성자에서 선언 된 속성에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4c10956ebfa0383ee2f1e029c8feb69cf8fc5ac" translate="yes" xml:space="preserve">
          <source>This will raise a &lt;code&gt;ClassCastException&lt;/code&gt; if the object is not actually an instance of &lt;code&gt;Person&lt;/code&gt; or any of its subclasses. If you're not sure what &lt;code&gt;x&lt;/code&gt; is, but you're happy to get null if it's not a &lt;code&gt;Person&lt;/code&gt;, you can use &lt;code&gt;as?&lt;/code&gt;, which will return null if the cast fails. Note that the resulting type is &lt;code&gt;Person?&lt;/code&gt;:</source>
          <target state="translated">이것은 올릴 것이다 &lt;code&gt;ClassCastException&lt;/code&gt; 이 객체가 실제의 인스턴스가 아닌 경우 &lt;code&gt;Person&lt;/code&gt; 또는 그 서브 클래스의. &lt;code&gt;x&lt;/code&gt; 가 무엇인지 확실 하지 않지만 &lt;code&gt;Person&lt;/code&gt; 이 아닌 경우 null을 얻는 것이 행복하다면 다음 &lt;code&gt;as?&lt;/code&gt; 사용할 수 있습니까? 캐스트에 실패하면 null을 반환합니다. 결과 유형은 &lt;code&gt;Person?&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fa6b2b95ad5f670c5af166fa09cb0ec4fc6be37b" translate="yes" xml:space="preserve">
          <source>This works also for &lt;em&gt;var&lt;/em&gt;&amp;rsquo;s properties if you use a &lt;code&gt;MutableMap&lt;/code&gt; instead of read-only &lt;code&gt;Map&lt;/code&gt;:</source>
          <target state="translated">읽기 전용 &lt;code&gt;Map&lt;/code&gt; 대신 &lt;code&gt;MutableMap&lt;/code&gt; 을 사용하는 경우 &lt;em&gt;var&lt;/em&gt; 의 속성 에도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="dfbae76eefb17a295e772659a5df1b063a9b20dc" translate="yes" xml:space="preserve">
          <source>Those class names are always getting in the way. We can use static imports and get this:</source>
          <target state="translated">그 클래스 이름은 항상 방해가되고 있습니다. 정적 가져 오기를 사용하여 다음을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="840686b21fe85a3d03fcebd9f6fe5d67ee5b8f5f" translate="yes" xml:space="preserve">
          <source>Though reflection may not be needed in many cases, we can still use it with a reified type parameter:</source>
          <target state="translated">대부분의 경우 리플렉션이 필요하지 않을 수도 있지만, reified type 매개 변수와 함께 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9c8e28b5db7e794581721a97a55d403ef96db4" translate="yes" xml:space="preserve">
          <source>Thread confinement coarse-grained</source>
          <target state="translated">스레드 감금 거친</target>
        </trans-unit>
        <trans-unit id="58c8dc7270e76e9fe5dcba1621b0a309ea2a0ff5" translate="yes" xml:space="preserve">
          <source>Thread confinement fine-grained</source>
          <target state="translated">세밀한 스레드 감금</target>
        </trans-unit>
        <trans-unit id="07c0a8bbcccb40629ed6cd8852b0c2af35dea6b2" translate="yes" xml:space="preserve">
          <source>Thread-local data</source>
          <target state="translated">스레드 로컬 데이터</target>
        </trans-unit>
        <trans-unit id="b51d97d48189b14ee90ab80ab5f1002db2ed52a4" translate="yes" xml:space="preserve">
          <source>Thread-safe data structures</source>
          <target state="translated">스레드 안전 데이터 구조</target>
        </trans-unit>
        <trans-unit id="8a77bfd3db44e0aeb0a80c2f055eea2ff97f89d4" translate="yes" xml:space="preserve">
          <source>ThreadLocal</source>
          <target state="translated">ThreadLocal</target>
        </trans-unit>
        <trans-unit id="5541d0b76d127f6a3c54bbc247ffcc1b6c2bbc25" translate="yes" xml:space="preserve">
          <source>Threading</source>
          <target state="translated">Threading</target>
        </trans-unit>
        <trans-unit id="54fc24f5a7668604be098318c177c182e63b5fa7" translate="yes" xml:space="preserve">
          <source>Threads are by far probably the most well-known approach to avoid applications from blocking.</source>
          <target state="translated">스레드는 아마도 응용 프로그램의 차단을 피하는 가장 잘 알려진 방법 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8cb6272d819adb1d7ec29aee37d20ed2b2cd093" translate="yes" xml:space="preserve">
          <source>Threads aren't always available. Some platforms, such as JavaScript do not even support threads</source>
          <target state="translated">스레드를 항상 사용할 수있는 것은 아닙니다. JavaScript와 같은 일부 플랫폼은 스레드를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="100ffacab3bbb22c877b7db046d6811ab68a4092" translate="yes" xml:space="preserve">
          <source>Threads aren't cheap. Threads require context switches which are costly.</source>
          <target state="translated">실은 싸지 않습니다. 스레드에는 비용이 많이 드는 컨텍스트 스위치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ed5d4b963a60e738f823f980aab2e771fb9e0b19" translate="yes" xml:space="preserve">
          <source>Threads aren't easy. Debugging threads, avoiding race conditions are common problems we suffer in multi-threaded programming.</source>
          <target state="translated">스레드는 쉽지 않습니다. 경쟁 조건을 피하면서 스레드 디버깅은 멀티 스레드 프로그래밍에서 흔히 발생하는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="dada4feb2387f68301b5e37c631ce74cff4d977a" translate="yes" xml:space="preserve">
          <source>Threads aren't infinite. The number of threads that can be launched is limited by the underlying operating system. In server-side applications, this could cause a major bottleneck.</source>
          <target state="translated">스레드는 무한하지 않습니다. 시작할 수있는 스레드 수는 기본 운영 체제에 따라 제한됩니다. 서버 측 응용 프로그램에서는 이로 인해 심각한 병목 현상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea7ecc8ef4eb25f7a1da622aee2bb4b90728e800" translate="yes" xml:space="preserve">
          <source>Through these platforms you can access the &lt;strong&gt;platform native code&lt;/strong&gt; (JVM, JS, and Native) and leverage all native capabilities.</source>
          <target state="translated">이러한 플랫폼을 통해 &lt;strong&gt;플랫폼 네이티브 코드&lt;/strong&gt; (JVM, JS 및 네이티브)에 액세스하고 모든 네이티브 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8abf11297f412ee4fff55514bb434f634e293565" translate="yes" xml:space="preserve">
          <source>Throwable</source>
          <target state="translated">Throwable</target>
        </trans-unit>
        <trans-unit id="eac1fd32ab840fc388b25886124b82f77d7d2760" translate="yes" xml:space="preserve">
          <source>Throwing and catching</source>
          <target state="translated">던지고 잡기</target>
        </trans-unit>
        <trans-unit id="866ed5ebf5c2f2a9c6597aa6906378e31d48e178" translate="yes" xml:space="preserve">
          <source>Thrown by cancellable suspending functions if the coroutine is cancelled while it is suspended. It indicates &lt;em&gt;normal&lt;/em&gt; cancellation of a coroutine.</source>
          <target state="translated">코 루틴이 일시 중단 된 동안 취소되면 취소 가능한 일시 중단 함수에 의해 throw됩니다. &lt;em&gt;정상을&lt;/em&gt; 나타냅니다.&lt;em&gt;&lt;/em&gt;코 루틴의 취소를 .</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="b1b2da4ce29be6e42fd3a3a1d87f8fd7bd99c3f3" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="21712a0494f28f6a46c5535db142ea2522d8b30e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="b88e532ebba6a290db595d7e93591bf93e58ec5d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="a834d850910b82b32184bf20e615c66a32c33ffc" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; calculated by &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError를&lt;/a&gt; 하여 계산 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="b187627b0474be6a63105d8fbe200f08b14f46f0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="d8d5a9cbb5d90075a851ac67a508560060d907ea" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert%28kotlin.Boolean%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓이며, 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="877c528f0857e16d746ea6daff3b5297368a55b2" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled during compilation.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 컴파일시 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="cb0860bdd589a1bb034f027aa22414ee9971d985" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;AssertionError&lt;/a&gt; if the &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false and runtime assertions have been enabled on the JVM using the &lt;em&gt;-ea&lt;/em&gt; JVM option.</source>
          <target state="translated">예외 &lt;a href=&quot;-assertion-error/index#kotlin.AssertionError&quot;&gt;않고 AssertionError를&lt;/a&gt; 경우 &lt;a href=&quot;assert#kotlin%24assert(kotlin.Boolean)/value&quot;&gt;값은&lt;/a&gt; false입니다 및 런타임 주장이 사용하는 JVM에서 활성화 된 &lt;em&gt;-ea를&lt;/em&gt; JVM 옵션을.</target>
        </trans-unit>
        <trans-unit id="6495db8a536c8d755d3c31cd2f1405c6a5089dde" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;, IllegalArgumentException를&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="a435a6330bdfb93f8f0baf2519c326f8c8a67d8c" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;, IllegalArgumentException를&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean)/value&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="452d882ee13cc2478203bd62e2127715d9c6ce3d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">&lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%29%2Fvalue&quot;&gt;값&lt;/a&gt; 이 null 인 경우 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException을&lt;/a&gt; throw합니다 . 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0dbf5201e6e48ab5572c5ef4e7b99a7cfc2a7333" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?)/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;, IllegalArgumentException를&lt;/a&gt; 경우 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?)/value&quot;&gt;값이&lt;/a&gt; null입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d30f2afa782c5c47e8fd1fd37da6b472b4245324" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="6af1ad354715d427817f522962505b9c2ca46b8d" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require#kotlin%24require(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="e3e3dc9398319dc7d021d329ec499047c0ffa229" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;는 IllegalArgumentException&lt;/a&gt; 호출의 결과 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull%28kotlin.requireNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 널 (null)입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1585605996fe54d528d4847469a1c01a292a3702" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; with the result of calling &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">값이 다음 과 같은 경우 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; 호출 결과와 함께 &lt;a href=&quot;-illegal-argument-exception/index#kotlin.IllegalArgumentException&quot;&gt;IllegalArgumentException&lt;/a&gt; 이 발생 &lt;a href=&quot;require-not-null#kotlin%24requireNotNull(kotlin.requireNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;합니다.&lt;/a&gt; 널 (null)입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cde80ff370e1f63acd5ebfbb8e922a017c83fe9e" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%29%2Fvalue&quot;&gt;값은&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="ef2f3f8adf5e012243cd34b2702b7a2ac8adf662" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean)/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 는 IF &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean)/value&quot;&gt;값&lt;/a&gt; false입니다.</target>
        </trans-unit>
        <trans-unit id="402cd2d9df6a156fba6fc0cc6697b5d76b649c05" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%29%2Fvalue&quot;&gt;값이&lt;/a&gt; null입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dda2799a06b523e6b176c9ee67f6d63f48ada3d8" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?)/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이를&lt;/a&gt; 경우 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?)/value&quot;&gt;값이&lt;/a&gt; null입니다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f113c02962407d7507fe9485b4da7237a47f7c4" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;message&lt;/a&gt;.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 주어진와 &lt;a href=&quot;error#kotlin%24error%28kotlin.Any%29%2Fmessage&quot;&gt;메시지를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5181608eaea2225525164d5696d71e611d6d7bd0" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the given &lt;a href=&quot;error#kotlin%24error(kotlin.Any)/message&quot;&gt;message&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;error#kotlin%24error(kotlin.Any)/message&quot;&gt;메시지&lt;/a&gt; 와 함께 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; 을 던집니다 .</target>
        </trans-unit>
        <trans-unit id="a87a5cbfe4f8dd0bce93da8e99fc5031d54a4b66" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check%28kotlin.Boolean%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="f984d420014f0ad6416ec5b1ab125dd6010c5b27" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is false.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 &lt;a href=&quot;check#kotlin%24check(kotlin.Boolean,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="a52512f1adf6d29a59645748fabb172d879e3685" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2FlazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 생성 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull%28kotlin.checkNotNull.T%2C+kotlin.Function0%28%28kotlin.Any%29%29%29%2Fvalue&quot;&gt;값이&lt;/a&gt; 널 (null)이다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="493d7b4fc94a4de0e97d67db438c813b7833a321" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException&lt;/a&gt; with the result of calling &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage&lt;/a&gt; if the &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;value&lt;/a&gt; is null. Otherwise returns the not null value.</source>
          <target state="translated">예외 &lt;a href=&quot;-illegal-state-exception/index#kotlin.IllegalStateException&quot;&gt;IllegalStateException이&lt;/a&gt; 호출의 결과 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/lazyMessage&quot;&gt;lazyMessage을&lt;/a&gt; 경우 생성 &lt;a href=&quot;check-not-null#kotlin%24checkNotNull(kotlin.checkNotNull.T?,%20kotlin.Function0((kotlin.Any)))/value&quot;&gt;값이&lt;/a&gt; 널 (null)이다. 그렇지 않으면 null이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4dd5a74a27ccc78ea75829f90e11af066deef725" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 1.</source>
          <target state="translated">이 목록의 크기가 1보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="b0dfa8cfada0f87002fce9e2dcf29d69386eb81f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 2.</source>
          <target state="translated">이 목록의 크기가 2보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="bc0636ec717eef51c36cc08b0d19404e2a1e901f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 3.</source>
          <target state="translated">이 목록의 크기가 3 미만인 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="e916ab2f35fc79abd1560b46cce8cf83ff72163a" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 4.</source>
          <target state="translated">이 목록의 크기가 4보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던집니다 .</target>
        </trans-unit>
        <trans-unit id="17cfbe66f161c701133c0656f5b1abbe3644c69f" translate="yes" xml:space="preserve">
          <source>Throws an &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; if the size of this list is less than 5.</source>
          <target state="translated">이 목록의 크기가 5보다 작은 경우 &lt;a href=&quot;../kotlin/-index-out-of-bounds-exception/index#kotlin.IndexOutOfBoundsException&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; throw합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb093191144e508e969bd08f6b07ef13c7da6e0" translate="yes" xml:space="preserve">
          <source>Throws an exception if the sequence is constrained to be iterated once and &lt;code&gt;iterator&lt;/code&gt; is invoked the second time.</source>
          <target state="translated">시퀀스가 한 번 반복되도록 제한되고 두 번째로 &lt;code&gt;iterator&lt;/code&gt; 가 호출 되면 예외 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fd78909be435341dfba595389f3fa1467854f4e" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8285a899ac5a29cc7129aa4da6958e875202fb46" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3e1ce4459287d83d21368b2dc4cdc52b9cd0160c" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f4b2f84f4e57b04b9edd9c87d2979e39d26f5771" translate="yes" xml:space="preserve">
          <source>Throws an exception if this array is empty. If the array can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 배열이 비어 있으면 예외가 발생합니다. 배열이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b185c5f4e93631e2a060ab41fb4eb57e4de681a" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ef32dfbd1a922263c5c164f620e7b2908d21430d" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e93b6c2ea0c9c6c6ad13686a90f2bf85ab5f5baf" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4fd3822175bffcfa7e80b1f53ede5ab3ae2bc086" translate="yes" xml:space="preserve">
          <source>Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 문자 시퀀스가 ​​비어있는 경우 예외를 throw합니다. 문자 시퀀스가 ​​예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eacd93615a6dd16e6f9a9d63ee869eefaa897d95" translate="yes" xml:space="preserve">
          <source>Throws an exception if this collection is empty. If the collection can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 컬렉션이 비어 있으면 예외를 throw합니다. 컬렉션이 예상대로 비어있는 경우 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7624ee5a82ead06e5c18d4b5b2178b988495c62d" translate="yes" xml:space="preserve">
          <source>Throws an exception if this collection is empty. If the collection can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 컬렉션이 비어 있으면 예외를 throw합니다. 컬렉션이 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f601e98edd4457fbbb656d028259bf3599380762" translate="yes" xml:space="preserve">
          <source>Throws an exception if this list is empty. If the list can be empty in an expected way, please use &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 목록이 비어 있으면 예외가 발생합니다. 목록이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-indexed-or-null&quot;&gt;reduceRightIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a6b616691ee940145aebe0fc262a2f6d65461cd7" translate="yes" xml:space="preserve">
          <source>Throws an exception if this list is empty. If the list can be empty in an expected way, please use &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 목록이 비어 있으면 예외가 발생합니다. 목록이 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-right-or-null&quot;&gt;reduceRightOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4581922a0ef91d93af0368bead5bd7539b44ea3" translate="yes" xml:space="preserve">
          <source>Throws an exception if this sequence is empty. If the sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 시퀀스가 ​​비어 있으면 예외가 발생합니다. 시퀀스가 예상대로 비어있을 수있는 경우 대신 &lt;a href=&quot;reduce-indexed-or-null&quot;&gt;reduceIndexedOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9ce91e94c848fefcebcae40244d52f7890553ddb" translate="yes" xml:space="preserve">
          <source>Throws an exception if this sequence is empty. If the sequence can be empty in an expected way, please use &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull&lt;/a&gt; instead. It returns &lt;code&gt;null&lt;/code&gt; when its receiver is empty.</source>
          <target state="translated">이 시퀀스가 ​​비어 있으면 예외가 발생합니다. 시퀀스가 예상대로 비어있을 수 있으면 대신 &lt;a href=&quot;reduce-or-null&quot;&gt;reduceOrNull을&lt;/a&gt; 사용하십시오. 수신자가 비어 있으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="802eb217aa06b1ddcf50385d8b88823ead2d004a" translate="yes" xml:space="preserve">
          <source>Throws an exception since enum constants cannot be cloned. This method prevents enum classes from inheriting from &lt;code&gt;Cloneable&lt;/code&gt;.</source>
          <target state="translated">열거 형 상수를 복제 할 수 없으므로 예외가 발생합니다. 이 메서드는 열거 형 클래스가 &lt;code&gt;Cloneable&lt;/code&gt; 로부터 상속되지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="abf5b40e0b4f0a5382568a99833124d4e1e46035" translate="yes" xml:space="preserve">
          <source>Thus, if the layout filename is &lt;code&gt;activity_main.xml&lt;/code&gt;, we'd import &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt;.</source>
          <target state="translated">따라서 레이아웃 파일 이름이 &lt;code&gt;activity_main.xml&lt;/code&gt; 인 경우 &lt;code&gt;kotlinx.android.synthetic.main.activity_main.*&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="97edcc8b1307ff786c44c31ec2579356e7a22d17" translate="yes" xml:space="preserve">
          <source>Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.</source>
          <target state="translated">따라서 NPE를 원할 경우 NPE를 가질 수는 있지만 명시 적으로 요청해야하며 파란색으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd3fb291d3a706316d022aff145e9de544011b65" translate="yes" xml:space="preserve">
          <source>Thus, single quotes can not be used to form string literals.</source>
          <target state="translated">따라서 작은 따옴표를 사용하여 문자열 리터럴을 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b9124e1ec7c5edcf4abab648d63459254b7d7ee" translate="yes" xml:space="preserve">
          <source>Thus, the &lt;code&gt;last&lt;/code&gt; element is not always the same as the specified end value.</source>
          <target state="translated">따라서 &lt;code&gt;last&lt;/code&gt; 요소가 지정된 끝 값과 항상 같지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3018655a2f36aad6ef9ad9471b91d569410cec76" translate="yes" xml:space="preserve">
          <source>Thus, you can create something resource manager-like by creating a class that implements &lt;code&gt;Closeable&lt;/code&gt;, does its setup work in &lt;code&gt;init&lt;/code&gt;, and does its cleanup work in &lt;code&gt;close()&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;Closeable&lt;/code&gt; 을 구현 하고 설정이 &lt;code&gt;init&lt;/code&gt; 에서 작동하며 정리가 &lt;code&gt;close()&lt;/code&gt; 에서 작동 하는 클래스를 작성하여 자원 관리자와 같은 것을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f717771b6bc333649ebdd74853decf5175f1649" translate="yes" xml:space="preserve">
          <source>Ticker channel is a special rendezvous channel that produces &lt;code&gt;Unit&lt;/code&gt; every time given delay passes since last consumption from this channel. Though it may seem to be useless standalone, it is a useful building block to create complex time-based &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;produce&lt;/a&gt; pipelines and operators that do windowing and other time-dependent processing. Ticker channel can be used in &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;select&lt;/a&gt; to perform &quot;on tick&quot; action.</source>
          <target state="translated">티커 채널은 이 채널에서 마지막으로 소비 된 이후 지연 시간이 주어질 때마다 &lt;code&gt;Unit&lt;/code&gt; 를 생성하는 특수한 랑데부 채널입니다 . 쓸모없는 독립형처럼 보일 수도 있지만, 윈도 잉 및 기타 시간 종속 처리를 수행 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/produce.html&quot;&gt;하는&lt;/a&gt; 복잡한 시간 기반 생산 파이프 라인 및 운영자 를 생성하는 데 유용한 빌딩 블록 입니다. 티커 채널은 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.selects/select.html&quot;&gt;선택시&lt;/a&gt; &quot;틱시&quot;작업을 수행 하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="709221186863e6ea184e824b11c1140ada1e2ad5" translate="yes" xml:space="preserve">
          <source>Ticker channels</source>
          <target state="translated">티커 채널</target>
        </trans-unit>
        <trans-unit id="63320b186f0d534224159af37ea2139273bd1f6c" translate="yes" xml:space="preserve">
          <source>Time unit representing one day, which is always equal to 24 hours.</source>
          <target state="translated">하루를 나타내는 시간 단위로 항상 24 시간과 같습니다.</target>
        </trans-unit>
        <trans-unit id="877ba4bc277c902e0734e2ffcb282d31130b4f5b" translate="yes" xml:space="preserve">
          <source>Time unit representing one hour.</source>
          <target state="translated">1 시간을 나타내는 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="e13f33001c6412bef1563d532ed0814ae7fe14e4" translate="yes" xml:space="preserve">
          <source>Time unit representing one microsecond, which is 1/1000 of a millisecond.</source>
          <target state="translated">1/1000 밀리 초인 1 마이크로 초를 나타내는 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="69bd96548a564e999c99e810765a0e91f82651be" translate="yes" xml:space="preserve">
          <source>Time unit representing one millisecond, which is 1/1000 of a second.</source>
          <target state="translated">1/1000 초인 1 밀리 초를 나타내는 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="596db628883d083bd5767a0e071af81c363164e2" translate="yes" xml:space="preserve">
          <source>Time unit representing one minute.</source>
          <target state="translated">1 분을 나타내는 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="c55ed39b5dc095ccfcfc2f009b87f746b868a8d9" translate="yes" xml:space="preserve">
          <source>Time unit representing one nanosecond, which is 1/1000 of a microsecond.</source>
          <target state="translated">마이크로 초의 1/1000 인 1 나노초를 나타내는 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="c9dbcaa261c78b418e4aebabb43ab10eb5d2c894" translate="yes" xml:space="preserve">
          <source>Time unit representing one second.</source>
          <target state="translated">1 초를 나타내는 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="10572d800e81a954a70d12fcb00a40ac135136f2" translate="yes" xml:space="preserve">
          <source>TimeMark</source>
          <target state="translated">TimeMark</target>
        </trans-unit>
        <trans-unit id="6e9104aba3fe18e4dd8562ba5f52cb92ded067dc" translate="yes" xml:space="preserve">
          <source>TimeRanges</source>
          <target state="translated">TimeRanges</target>
        </trans-unit>
        <trans-unit id="c90348d5ff080b78282efd07b8b0ed4226890eee" translate="yes" xml:space="preserve">
          <source>TimeSource</source>
          <target state="translated">TimeSource</target>
        </trans-unit>
        <trans-unit id="eca969ef85583fca89468fa678b49acb2534e5b8" translate="yes" xml:space="preserve">
          <source>TimedValue</source>
          <target state="translated">TimedValue</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="799c2191675c2bb6c5c783e298421617f1390ce2" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;prepare for Java 9 support&lt;/a&gt;, the extension functions and properties in the &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; library have been moved to the package &lt;code&gt;kotlin.reflect.full&lt;/code&gt;. The names in the old package (&lt;code&gt;kotlin.reflect&lt;/code&gt;) are deprecated and will be removed in Kotlin 1.2. Note that the core reflection interfaces (such as &lt;code&gt;KClass&lt;/code&gt;) are part of the Kotlin standard library, not &lt;code&gt;kotlin-reflect&lt;/code&gt;, and are not affected by the move.</source>
          <target state="translated">하기 위해 &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/&quot;&gt;자바 (9) 지원을위한 준비&lt;/a&gt; 의의 확장 기능 및 특성 &lt;code&gt;kotlin-reflect.jar&lt;/code&gt; 라이브러리는 패키지로 이동되었습니다 &lt;code&gt;kotlin.reflect.full&lt;/code&gt; . 이전 패키지 ( &lt;code&gt;kotlin.reflect&lt;/code&gt; ) 의 이름 은 더 이상 사용되지 않으며 Kotlin 1.2에서 제거됩니다. 핵심 반사 인터페이스 (예 : &lt;code&gt;KClass&lt;/code&gt; )는 &lt;code&gt;kotlin-reflect&lt;/code&gt; 가 아닌 Kotlin 표준 라이브러리의 일부이며 이동의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05823a5d5a74d4953764cdf3ac4c6b3fb68f1e64" translate="yes" xml:space="preserve">
          <source>To Use</source>
          <target state="translated">쓰다</target>
        </trans-unit>
        <trans-unit id="9d9e0e01bc3681e891f7f867582c90865280f877" translate="yes" xml:space="preserve">
          <source>To accept and propagate the experimental status to your whole module, compile the module with the argument &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. In this case, &lt;em&gt;every declaration&lt;/em&gt; in the module becomes experimental. The use of the module requires the acceptance of its experimental status as well.</source>
          <target state="translated">실험 상태를 수락하여 전체 모듈에 전파하려면 인수 &lt;code&gt;-Xexperimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; 로 모듈을 컴파일하십시오 . 이 경우 모듈의 &lt;em&gt;모든 선언&lt;/em&gt; 은 실험적입니다. 모듈을 사용하려면 실험 상태도 수용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0b5cb313d227acb944e950971366b62de8d6de6" translate="yes" xml:space="preserve">
          <source>To accept the experimental status without propagation, compile the module with the argument &lt;code&gt;-Xuse-experimental&lt;/code&gt;, specifying the fully qualified name of the experimental API marker you use: &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt;. Compiling with this argument has the same effect as if every declaration in the module had the annotation&lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt;.</source>
          <target state="translated">전파하지 않고 실험 상태를 승인하려면 사용하는 실험 API 마커의 완전한 이름을 지정하여 &lt;code&gt;-Xuse-experimental&lt;/code&gt; 인수로 모듈을 컴파일하십시오 . &lt;code&gt;-Xuse-experimental=org.mylibrary.ExperimentalMarker&lt;/code&gt; . 이 인수로 컴파일하면 모듈의 모든 선언에 &lt;code&gt;@UseExperimental(ExperimentalMarker::class)&lt;/code&gt; 주석이있는 것과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9903a558b00c4bc82f88c2dfad1d5c92c9e2ae3f" translate="yes" xml:space="preserve">
          <source>To accept the usage of multiple experimental APIs on the module level, add one of the described arguments for each experimental API marker used in your module.</source>
          <target state="translated">모듈 레벨에서 여러 실험 API의 사용을 승인하려면 모듈에 사용 된 각 실험 API 마커에 대해 설명 된 인수 중 하나를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d162c0174f5af87401e6b5d45d66155192832d80" translate="yes" xml:space="preserve">
          <source>To access &lt;em&gt;this&lt;/em&gt; from an outer scope (a &lt;a href=&quot;classes&quot;&gt;class&lt;/a&gt;, or &lt;a href=&quot;extensions&quot;&gt;extension function&lt;/a&gt;, or labeled &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;function literal with receiver&lt;/a&gt;) we write &lt;code&gt;this@label&lt;/code&gt; where &lt;code&gt;@label&lt;/code&gt; is a &lt;a href=&quot;returns&quot;&gt;label&lt;/a&gt; on the scope &lt;em&gt;this&lt;/em&gt; is meant to be from:</source>
          <target state="translated">액세스하려면 &lt;em&gt;이&lt;/em&gt; 외부 범위 (A에서 &lt;a href=&quot;classes&quot;&gt;클래스&lt;/a&gt; , 또는 &lt;a href=&quot;extensions&quot;&gt;확장 기능&lt;/a&gt; , 또는 표시된 &lt;a href=&quot;lambdas#function-literals-with-receiver&quot;&gt;수신기 기능 리터럴은&lt;/a&gt; ) 우리는 기록 &lt;code&gt;this@label&lt;/code&gt; &lt;code&gt;@label&lt;/code&gt; 는 A는 &lt;a href=&quot;returns&quot;&gt;라벨&lt;/a&gt; 범위에 대한 &lt;em&gt;이가&lt;/em&gt; 보낸 것으로 의미를 :</target>
        </trans-unit>
        <trans-unit id="5db6557812d02b15eefb7397c674770717b897fd" translate="yes" xml:space="preserve">
          <source>To access a property that is a member of a class, we qualify it:</source>
          <target state="translated">클래스 멤버 인 속성에 액세스하려면 다음과 같이 자격을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="81410d36157afd9871ba5225faca2642fb141190" translate="yes" xml:space="preserve">
          <source>To access properties as first-class objects in Kotlin, we can also use the &lt;code&gt;::&lt;/code&gt; operator:</source>
          <target state="translated">Kotlin에서 일류 객체로 속성에 액세스하기 위해 &lt;code&gt;::&lt;/code&gt; 연산자를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58a760c627562db97cdca1a84e7db3c27c2f629c" translate="yes" xml:space="preserve">
          <source>To access static members of a Java type that is &lt;a href=&quot;#mapped-types&quot;&gt;mapped&lt;/a&gt; to a Kotlin type, use the full qualified name of the Java type: &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt;.</source>
          <target state="translated">Kotlin 유형에 &lt;a href=&quot;#mapped-types&quot;&gt;맵핑&lt;/a&gt; 된 Java 유형의 정적 멤버에 액세스하려면 Java 유형 의 완전한 이름 인 &lt;code&gt;java.lang.Integer.bitCount(foo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7529d2d95d23cbd6b23debe45e1e3095efe982cc" translate="yes" xml:space="preserve">
          <source>To achieve &lt;code&gt;mutable XOR global&lt;/code&gt; invariant, all globally visible state (currently, &lt;code&gt;object&lt;/code&gt; singletons and enums) are automatically frozen. If object freezing is not desired, a &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; annotation can be used, which will make the object state thread local, and so, mutable (but the changed state is not visible to other threads).</source>
          <target state="translated">&lt;code&gt;mutable XOR global&lt;/code&gt; 불변 값 을 달성하기 위해 모든 전역 적으로 볼 수있는 상태 (현재 &lt;code&gt;object&lt;/code&gt; 싱글 톤 및 열거 형)가 자동으로 고정됩니다. 객체 동결이 필요하지 않은 경우, &lt;code&gt;kotlin.native.ThreadLocal&lt;/code&gt; 주석을 사용하여 객체 상태 스레드를 로컬로 만들 수 있으므로 변경할 수 있습니다 (그러나 변경된 상태는 다른 스레드에 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="1019a589281c0c646b20946b4cd19b5c15e8fdaa" translate="yes" xml:space="preserve">
          <source>To activate DCE tool, add the following line to &lt;code&gt;build.gradle&lt;/code&gt;:</source>
          <target state="translated">DCE 도구를 활성화하려면 &lt;code&gt;build.gradle&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="518dd8e0c3f079203e35eb4b3c3a2d8d28ec483f" translate="yes" xml:space="preserve">
          <source>To add a dependency on a library, set the dependency of the required &lt;a href=&quot;#dependency-types&quot;&gt;type&lt;/a&gt; (for example, &lt;code&gt;implementation&lt;/code&gt;) in the &lt;code&gt;dependencies&lt;/code&gt; block of the source sets DSL.</source>
          <target state="translated">라이브러리에 대한 종속성을 추가하려면 소스 세트 DSL 의 &lt;code&gt;dependencies&lt;/code&gt; 블록 에서 필요한 &lt;a href=&quot;#dependency-types&quot;&gt;유형&lt;/a&gt; (예 : &lt;code&gt;implementation&lt;/code&gt; )의 종속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8c4bb60ccc35accc967ef970dec8a3a413d9d346" translate="yes" xml:space="preserve">
          <source>To add a dependency on a library, set the dependency of the required &lt;a href=&quot;using-gradle#dependency-types&quot;&gt;type&lt;/a&gt; (for example, &lt;code&gt;implementation&lt;/code&gt;) in the &lt;code&gt;dependencies&lt;/code&gt; block of the source sets DSL.</source>
          <target state="translated">라이브러리에 대한 종속성을 추가하려면 소스 세트 DSL 의 &lt;code&gt;dependencies&lt;/code&gt; 블록 에서 필요한 &lt;a href=&quot;using-gradle#dependency-types&quot;&gt;유형&lt;/a&gt; (예 : &lt;code&gt;implementation&lt;/code&gt; )의 종속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a7881622441c034d7bab9ec188cf250853bf301a" translate="yes" xml:space="preserve">
          <source>To add a dependency to a source set, use a &lt;code&gt;dependencies { ... }&lt;/code&gt; block of the source sets DSL. Four kinds of dependencies are supported:</source>
          <target state="translated">소스 세트에 종속성을 추가하려면 소스 세트 DSL의 &lt;code&gt;dependencies { ... }&lt;/code&gt; 블록을 사용하십시오. 네 가지 종류의 종속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1a499912e7035afeaf92f7261767aa556ac8c3f9" translate="yes" xml:space="preserve">
          <source>To add a new key-value pair to a mutable map, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt;. When a new entry is put into a &lt;code&gt;LinkedHashMap&lt;/code&gt; (the default map implementation), it is added so that it comes last when iterating the map. In sorted maps, the positions of new elements are defined by the order of their keys.</source>
          <target state="translated">변경 가능한 맵에 새 키-값 쌍을 추가하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; . 새 항목을 &lt;code&gt;LinkedHashMap&lt;/code&gt; (기본 맵 구현)에 넣으면 맵을 반복 할 때 마지막에 오도록 추가됩니다. 정렬 된 맵에서 새 요소의 위치는 키 순서에 따라 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f2454f68b2510146a6d3830da5c71ddda2db8b87" translate="yes" xml:space="preserve">
          <source>To add a single element to a list or a set, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; function. The specified object is appended to the end of the collection.</source>
          <target state="translated">단일 요소를 목록 또는 세트에 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 하려면 add () 함수를 사용하십시오 . 지정된 개체가 컬렉션 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc1110c5b9a5333f0f0fec5eb2e00b218df46d2" translate="yes" xml:space="preserve">
          <source>To add elements to a specific position in a list, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt;&lt;code&gt;addAll()&lt;/code&gt;&lt;/a&gt; providing the position for element insertion as an additional argument. All elements that come after the position shift to the right.</source>
          <target state="translated">목록의 특정 위치에 요소를 추가하려면 add &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/add-all&quot;&gt; &lt;code&gt;addAll()&lt;/code&gt; &lt;/a&gt; 을 사용하여 요소 삽입 위치를 추가 인수로 제공하십시오. 위치 뒤에 오는 모든 요소는 오른쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8035a3b6b37b3480851f2821e2b47d2393940de4" translate="yes" xml:space="preserve">
          <source>To add multiple entries at a time, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt;&lt;code&gt;putAll()&lt;/code&gt;&lt;/a&gt;. Its argument can be a &lt;code&gt;Map&lt;/code&gt; or a group of &lt;code&gt;Pair&lt;/code&gt;s: &lt;code&gt;Iterable&lt;/code&gt;, &lt;code&gt;Sequence&lt;/code&gt;, or &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">한 번에 여러 항목을 추가하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/put-all&quot;&gt; &lt;code&gt;putAll()&lt;/code&gt; &lt;/a&gt; . 인수는 &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;Pair&lt;/code&gt; 의 그룹 ( &lt;code&gt;Iterable&lt;/code&gt; , &lt;code&gt;Sequence&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; )일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aac6c02c5c8182c376328758ec65c08ad1e19d6" translate="yes" xml:space="preserve">
          <source>To add the Kotlin support to your Eclipse IDE, install the &lt;em&gt;Kotlin Plugin for Eclipse&lt;/em&gt;. We recommend installing the Kotlin plugin from &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt;. One option is to drag this button into a running Eclipse window:</source>
          <target state="translated">Kotlin 지원을 Eclipse IDE에 추가하려면 &lt;em&gt;Kotlin Plugin for Eclipse를&lt;/em&gt; 설치하십시오 . &lt;a href=&quot;http://marketplace.eclipse.org/content/kotlin-plugin-eclipse&quot;&gt;Eclipse Marketplace&lt;/a&gt; 에서 Kotlin 플러그인을 설치하는 것이 좋습니다 . 한 가지 옵션은이 버튼을 실행중인 Eclipse 창으로 끌어 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="11458a551629eb8e637b1b4f455d800a9c36a1f1" translate="yes" xml:space="preserve">
          <source>To address this problem, in Kotlin 1.1 a special mechanism to control receiver scope was introduced.</source>
          <target state="translated">이 문제를 해결하기 위해 Kotlin 1.1에서는 수신기 범위를 제어하는 ​​특수 메커니즘이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa01e838f66ea96e149d6c1d033b2d0ba7c11c23" translate="yes" xml:space="preserve">
          <source>To adjust the name for the JavaScript &lt;em&gt;module&lt;/em&gt; (which is generated in &lt;code&gt;build/js/packages/myModuleName&lt;/code&gt;), including the corresponding &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt; files, use the &lt;code&gt;moduleName&lt;/code&gt; option:</source>
          <target state="translated">해당 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 포함 하여 JavaScript &lt;em&gt;모듈&lt;/em&gt; ( &lt;code&gt;build/js/packages/myModuleName&lt;/code&gt; 에서 생성됨 ) 의 이름을 조정하려면 &lt;code&gt;moduleName&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="93364070d4707402d500a207978499a9a901b72c" translate="yes" xml:space="preserve">
          <source>To allow nulls, we can declare a variable as nullable string, written &lt;code&gt;String?&lt;/code&gt;:</source>
          <target state="translated">null을 허용하기 위해 변수를 nullable 문자열로 선언하면 &lt;code&gt;String?&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2b28f33c9dfafdc6b47099300c488e134702926" translate="yes" xml:space="preserve">
          <source>To annotate the receiver parameter of an extension function, use the following syntax:</source>
          <target state="translated">확장 함수의 수신자 매개 변수에 주석을 달려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27d0b2adae39bd08addf9e085ed30cd88ae2eee6" translate="yes" xml:space="preserve">
          <source>To apply a function to elements in the reverse order, use functions &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt;&lt;code&gt;reduceRight()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt;&lt;code&gt;foldRight()&lt;/code&gt;&lt;/a&gt;. They work in a way similar to &lt;code&gt;fold()&lt;/code&gt; and &lt;code&gt;reduce()&lt;/code&gt; but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</source>
          <target state="translated">요소에 역순으로 함수를 적용하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/reduce-right&quot;&gt; &lt;code&gt;reduceRight()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/fold-right&quot;&gt; &lt;code&gt;foldRight()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 그것들은 &lt;code&gt;fold()&lt;/code&gt; 및 &lt;code&gt;reduce()&lt;/code&gt; 와 비슷한 방식으로 작동 하지만 마지막 요소에서 시작하여 이전으로 계속합니다. 오른쪽으로 접거나 줄이면 연산 인수가 순서를 변경합니다. 먼저 요소로 이동 한 다음 누적 값으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2a59cafd76f62ee4d0be26a47e36b2b9add63e94" translate="yes" xml:space="preserve">
          <source>To apply the &lt;code&gt;kotlin-multiplatform&lt;/code&gt; plugin, just add the following snippet into your build script:</source>
          <target state="translated">&lt;code&gt;kotlin-multiplatform&lt;/code&gt; 플러그인 을 적용하려면 빌드 스크립트에 다음 스 니펫을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3ca39dc59e8cc90057c5b6aa659388256e0056c5" translate="yes" xml:space="preserve">
          <source>To automatically trigger a re-build of your application after making changes to the source files, use the Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/command_line_interface.html#sec:continuous_build&quot;&gt;continuous build&lt;/a&gt; feature:</source>
          <target state="translated">소스 파일을 변경 한 후 애플리케이션 재 빌드를 자동으로 트리거하려면 Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/command_line_interface.html#sec:continuous_build&quot;&gt;연속 빌드&lt;/a&gt; 기능을 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="93d5ab42155015ed266c58696481bdeab9ce4844" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="91b39bd7e91bbd35306d062a5989d8160e42b8de" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;find-any-of#kotlin.text%24findAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d0112a7d95b0f1e5eac2132ba1ef497e36b55c4f" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="313c30481943d6f382ca1f81ef0079a1e108b27b" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;find-last-any-of#kotlin.text%24findLastAnyOf(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4027c8136b6286dfe349c3bde29fd950bfe158c1" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="511a802d66276d56dea9179b2c2f2932520462fa" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 처음부터 끝까지 진행하고, 발견 &lt;a href=&quot;index-of-any#kotlin.text%24indexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="31bfe127214639414101a9ca7c2a589e0f9d8655" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny%28kotlin.CharSequence%2C+kotlin.collections.Collection%28%28kotlin.String%29%29%2C+kotlin.Int%2C+kotlin.Boolean%29%2Fstrings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="98541eec86ea0f0ca7790dd22601b3805220f6d7" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; have characters in common, this method proceeds from the end toward the beginning of this string, and finds at each position the first element in &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;strings&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">문자열 때 모호한 결과를 방지하기 위해 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열이&lt;/a&gt; 공통의 문자를 가지고,이 방법은 각 위치에서의 첫 번째 요소 문자열의 시작을 향한 끝에서 진행하고, 발견 &lt;a href=&quot;last-index-of-any#kotlin.text%24lastIndexOfAny(kotlin.CharSequence,%20kotlin.collections.Collection((kotlin.String)),%20kotlin.Int,%20kotlin.Boolean)/strings&quot;&gt;문자열&lt;/a&gt; 그 위치에서이 문자열을 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6276ae19b8071911e89a3dcb94d020bccd844c9c" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="translated">&lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 피하기 위해이 방법은이 문자열의 처음부터 끝까지 진행되며 각 위치 에서 해당 위치의이 인스턴스에서 구분 기호와 동일한 &lt;a href=&quot;split#kotlin.text%24split%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="8d7e3e92f18e00c4c45e963dd6305eb6cda4267d" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and matches at each position the first element in &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; that is equal to a delimiter in this instance at that position.</source>
          <target state="translated">&lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 방지하기 위해이 메서드는이 문자열의 처음부터 끝까지 진행 하고 해당 위치에서이 인스턴스의 구분 기호와 동일한 &lt;a href=&quot;split#kotlin.text%24split(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소를 각 위치에서 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="35cbc5daa3fa4744579892d02b514b4f1f8fe190" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 피하기 위해이 방법은이 문자열의 처음부터 끝까지 진행하며 각 위치 에서 해당 위치에서이 문자열과 일치 하는 &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence%28kotlin.CharSequence%2C+kotlin.Array%28%28kotlin.String%29%29%2C+kotlin.Boolean%2C+kotlin.Int%29%2Fdelimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="3b1eaf906ec2e97627b57ad449d3e9fea0f52ed9" translate="yes" xml:space="preserve">
          <source>To avoid ambiguous results when strings in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; have characters in common, this method proceeds from the beginning to the end of this string, and finds at each position the first element in &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;delimiters&lt;/a&gt; that matches this string at that position.</source>
          <target state="translated">&lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호의&lt;/a&gt; 문자열에 공통 문자 가 있을 때 모호한 결과를 방지하기 위해이 메서드는이 문자열의 처음부터 끝까지 진행 하고 해당 위치에서이 문자열과 일치 하는 &lt;a href=&quot;split-to-sequence#kotlin.text%24splitToSequence(kotlin.CharSequence,%20kotlin.Array((kotlin.String)),%20kotlin.Boolean,%20kotlin.Int)/delimiters&quot;&gt;구분 기호&lt;/a&gt; 의 첫 번째 요소를 각 위치에서 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4098083aa9fa1edbe4454946791bd3716c2341fe" translate="yes" xml:space="preserve">
          <source>To avoid an exception being thrown, one can use a &lt;em&gt;safe&lt;/em&gt; cast operator &lt;em&gt;as?&lt;/em&gt; that returns &lt;em&gt;null&lt;/em&gt; on failure:</source>
          <target state="translated">예외가 발생하지 않도록 &lt;em&gt;안전한&lt;/em&gt; 캐스트 연산자를 다음 &lt;em&gt;과 같이&lt;/em&gt; 사용할 수 &lt;em&gt;있습니까? &lt;/em&gt;실패시 &lt;em&gt;null&lt;/em&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ff225a55ea176600b1d470fbc58e6bb3a657f71a" translate="yes" xml:space="preserve">
          <source>To avoid breaking the compatibility with such clients, compile your Kotlin code in the &lt;em&gt;compatibility mode&lt;/em&gt; by specifying the &lt;code&gt;-Xjvm-default=all-compatibility&lt;/code&gt; compiler option. In this case, all the code that uses the previous version will work fine with the new one. However, the compatibility mode adds some overhead to the resulting bytecode size.</source>
          <target state="translated">이러한 클라이언트와의 호환성이 깨지지 않도록하려면 &lt;code&gt;-Xjvm-default=all-compatibility&lt;/code&gt; 컴파일러 옵션 을 지정하여 &lt;em&gt;호환성 모드&lt;/em&gt; 에서 Kotlin 코드를 컴파일하세요 . 이 경우 이전 버전을 사용하는 모든 코드가 새 버전에서 잘 작동합니다. 그러나 호환성 모드는 결과 바이트 코드 크기에 약간의 오버 헤드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ba3e151dfa9ea7385c197541ad779f6d353044b8" translate="yes" xml:space="preserve">
          <source>To avoid duplicate publications of modules that can be built on several platforms (like JVM, JS, Kotlin metadata), configure the publishing tasks for these modules to run conditionally.</source>
          <target state="translated">여러 플랫폼 (예 : JVM, JS, Kotlin 메타 데이터)에서 빌드 할 수있는 모듈의 중복 게시를 방지하려면 이러한 모듈이 조건부로 실행되도록 게시 작업을 구성하세요.</target>
        </trans-unit>
        <trans-unit id="9e17e4153a46063a7e951557055076fb55b29173" translate="yes" xml:space="preserve">
          <source>To avoid exceptions when retrieving element with non-existing positions, use safe variations of &lt;code&gt;elementAt()&lt;/code&gt;:</source>
          <target state="translated">존재하지 않는 위치를 가진 요소를 검색 할 때 예외를 피하려면 &lt;code&gt;elementAt()&lt;/code&gt; 의 안전한 변형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7274268313d792eeb0ea9bf91f3d9337f0c66bb3" translate="yes" xml:space="preserve">
          <source>To avoid unchecked casts, you can redesign the program structure: in the example above, there could be interfaces &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; with type-safe implementations for different types. You can introduce reasonable abstractions to move unchecked casts from calling code to the implementation details. Proper use of &lt;a href=&quot;generics#variance&quot;&gt;generic variance&lt;/a&gt; can also help.</source>
          <target state="translated">확인되지 않은 캐스트를 피하기 위해 프로그램 구조를 다시 디자인 할 수 있습니다. 위의 예에서, 다양한 유형에 대해 유형 안전 구현을 가진 &lt;code&gt;DictionaryReader&amp;lt;T&amp;gt;&lt;/code&gt; 및 &lt;code&gt;DictionaryWriter&amp;lt;T&amp;gt;&lt;/code&gt; 인터페이스가있을 수 있습니다 . 확인되지 않은 캐스트를 호출 코드에서 구현 세부 사항으로 이동하기 위해 합리적인 추상화를 도입 할 수 있습니다. &lt;a href=&quot;generics#variance&quot;&gt;일반 분산을&lt;/a&gt; 올바르게 사용하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fda07e220a1d9d0906bbd1a8bf6f784d8a05be" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently tail recursion is only supported in the JVM backend.</source>
          <target state="translated">&lt;code&gt;tailrec&lt;/code&gt; 수정자를 사용할 수 있으려면 함수가 마지막으로 수행 할 때 자신을 호출해야합니다. 재귀 호출 후 더 많은 코드가 있으면 테일 재귀를 사용할 수 없으며 try / catch / finally 블록 내에서 사용할 수 없습니다. 현재 테일 재귀는 JVM 백엔드에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="26086ae134fdfd5e001fb5980e8bca3370532b03" translate="yes" xml:space="preserve">
          <source>To be eligible for the &lt;code&gt;tailrec&lt;/code&gt; modifier, a function must call itself as the last operation it performs. You cannot use tail recursion when there is more code after the recursive call, and you cannot use it within try/catch/finally blocks. Currently, tail recursion is supported by Kotlin for JVM and Kotlin/Native.</source>
          <target state="translated">&lt;code&gt;tailrec&lt;/code&gt; 수정자를 사용할 수 있으려면 함수가 수행하는 마지막 작업으로 자신을 호출해야합니다. 재귀 호출 후 더 많은 코드가 있으면 꼬리 재귀를 사용할 수 없으며 try / catch / finally 블록 내에서 사용할 수 없습니다. 현재 테일 재귀는 JVM 및 Kotlin / Native 용 Kotlin에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e77c612cc0ad3329a96be3d4bc330a4270facd79" translate="yes" xml:space="preserve">
          <source>To be fair, you'd get the same output in Python, but the mechanism would be different: both instances would start out without any attributes of their own (&lt;code&gt;age&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; would be attributes on the class), and the first printing would access the class attribute; only the assignment would cause an &lt;code&gt;age&lt;/code&gt; attribute to appear on &lt;code&gt;a&lt;/code&gt;. In Kotlin, there are no class properties in this example, and each instance starts out with both properties. If you need a class-level property, see the section on &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;companion objects&lt;/a&gt;.</source>
          <target state="translated">공평하게 말하면 파이썬에서 동일한 결과를 얻을 수 있지만 메커니즘은 다릅니다. 두 인스턴스는 자체 속성 ( &lt;code&gt;age&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 이 클래스 의 속성이 됨)없이 시작되고 첫 번째 인쇄에 액세스합니다 클래스 속성; 할당 만 &lt;code&gt;age&lt;/code&gt; 속성이에 표시되도록 &lt;code&gt;a&lt;/code&gt; . Kotlin에는이 예제에 클래스 속성이 없으며 각 인스턴스는 두 속성으로 시작합니다. 클래스 수준 속성이 필요한 경우 &lt;a href=&quot;objects-and-companion-objects#companion-objects&quot;&gt;컴패니언 객체&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d58ecb9e55a69412f4f07d4a983e7c9fa7ff4a8" translate="yes" xml:space="preserve">
          <source>To begin debugging, let's navigate to the page and launch the developer tools of our browser (for example by right-clicking and selecting the &lt;em&gt;Inspect&lt;/em&gt; action). If our program is logging information to the console, we can navigate to the &lt;em&gt;Console&lt;/em&gt; tab to see this output. Depending on our browser and its developer tools, these logs will also reference the Kotlin source files they originate from:</source>
          <target state="translated">디버깅을 시작하기 위해 페이지로 이동하여 브라우저의 개발자 도구를 시작합니다 (예 : 마우스 오른쪽 버튼을 클릭하고 &lt;em&gt;Inspect&lt;/em&gt; 작업 선택 ). 프로그램이 정보를 콘솔에 기록하는 경우 &lt;em&gt;콘솔&lt;/em&gt; 탭으로 이동 하여이 출력을 볼 수 있습니다 . 브라우저 및 개발자 도구에 따라 이러한 로그는 원본이 생성 된 Kotlin 소스 파일도 참조합니다.</target>
        </trans-unit>
        <trans-unit id="d5cad0364e908d8aa1ff84ca1d9136f4ad0e8a7e" translate="yes" xml:space="preserve">
          <source>To break a collection onto parts of a given size, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt;&lt;code&gt;chunked()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;chunked()&lt;/code&gt; takes a single argument &amp;ndash; the size of the chunk &amp;ndash; and returns a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;List&lt;/code&gt;s of the given size. The first chunk starts from the first element and contains the &lt;code&gt;size&lt;/code&gt; elements, the second chunk holds the next &lt;code&gt;size&lt;/code&gt; elements, and so on. The last chunk may have a smaller size.</source>
          <target state="translated">주어진 크기의 부분으로 모음을 나누려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/chunked&quot;&gt; &lt;code&gt;chunked()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;chunked()&lt;/code&gt; 는 하나의 인수 (청크 크기)를 사용하여 주어진 크기 의 &lt;code&gt;List&lt;/code&gt; &lt;code&gt;List&lt;/code&gt; 을 반환합니다 . 첫 번째 청크는 첫 번째 요소에서 시작하여 &lt;code&gt;size&lt;/code&gt; 요소를 포함하고 두 번째 청크는 다음 &lt;code&gt;size&lt;/code&gt; 요소를 보유합니다 . 마지막 청크는 더 작은 크기를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c901a4737d7c3f04fc344e06625faf76eec8e9d6" translate="yes" xml:space="preserve">
          <source>To build a custom string representation, you can specify its parameters in function arguments &lt;code&gt;separator&lt;/code&gt;, &lt;code&gt;prefix&lt;/code&gt;, and &lt;code&gt;postfix&lt;/code&gt;. The resulting string will start with the &lt;code&gt;prefix&lt;/code&gt; and end with the &lt;code&gt;postfix&lt;/code&gt;. The &lt;code&gt;separator&lt;/code&gt; will come after each element except the last.</source>
          <target state="translated">사용자 정의 문자열 표현을 작성하려면 함수 인수 &lt;code&gt;separator&lt;/code&gt; , &lt;code&gt;prefix&lt;/code&gt; 및 &lt;code&gt;postfix&lt;/code&gt; 에서 해당 매개 변수를 지정할 수 있습니다 . 결과 문자열은 &lt;code&gt;prefix&lt;/code&gt; 시작 하고 &lt;code&gt;postfix&lt;/code&gt; 로 끝납니다 . &lt;code&gt;separator&lt;/code&gt; 마지막 제외한 각 요소에 들어오는 것이다.</target>
        </trans-unit>
        <trans-unit id="2719279869fab416ee4cd752ab3460ef98055407" translate="yes" xml:space="preserve">
          <source>To build and run your application on an emulator:</source>
          <target state="translated">에뮬레이터에서 응용 프로그램을 빌드하고 실행하려면</target>
        </trans-unit>
        <trans-unit id="7150222f1a1fb391342d63f455f2076e7800770e" translate="yes" xml:space="preserve">
          <source>To build two-element windows, there is a separate function - &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt;&lt;code&gt;zipWithNext()&lt;/code&gt;&lt;/a&gt;. It creates pairs of adjacent elements of the receiver collection. Note that &lt;code&gt;zipWithNext()&lt;/code&gt; doesn't break the collection into pairs; it creates a &lt;code&gt;Pair&lt;/code&gt; for &lt;em&gt;each&lt;/em&gt; element except the last one, so its result on &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; is &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt;, not &lt;code&gt;[[1, 2&lt;/code&gt;], &lt;code&gt;[3, 4]]&lt;/code&gt;. &lt;code&gt;zipWithNext()&lt;/code&gt; can be called with a transformation function as well; it should take two elements of the receiver collection as arguments.</source>
          <target state="translated">요소가 두 개인 창을 만들려면 별도의 함수 인 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/zip-with-next&quot;&gt; &lt;code&gt;zipWithNext()&lt;/code&gt; &lt;/a&gt; 있습니다. 수신자 콜렉션의 인접한 요소 쌍을 작성합니다. 참고 &lt;code&gt;zipWithNext()&lt;/code&gt; 쌍으로 수집을 중단하지 않는다; 이것은 생성 &lt;code&gt;Pair&lt;/code&gt; 위한 &lt;em&gt;각각&lt;/em&gt; 의 그 결과, 그래서 최종 제외한 요소 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 이다 &lt;code&gt;[[1, 2], [2, 3], [3, 4]]&lt;/code&gt; 이 아닌 &lt;code&gt;[[1, 2&lt;/code&gt; ], &lt;code&gt;[3, 4]]&lt;/code&gt; . &lt;code&gt;zipWithNext()&lt;/code&gt; 는 변환 함수로도 호출 할 수 있습니다. 수신자 콜렉션의 두 요소를 인수로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c83a6b42d390ab9398eaec7a8e407e01581218b" translate="yes" xml:space="preserve">
          <source>To call &lt;code&gt;fold&lt;/code&gt;, we need to pass it an &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;instance of the function type&lt;/a&gt; as an argument, and lambda expressions (&lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;described in more detail below&lt;/a&gt;) are widely used for this purpose at higher-order function call sites:</source>
          <target state="translated">&lt;code&gt;fold&lt;/code&gt; 를 호출하려면 &lt;a href=&quot;#instantiating-a-function-type&quot;&gt;함수 유형&lt;/a&gt; 의 인스턴스를 인수 로 전달해야 하며 람다 표현식 ( &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;아래에 자세히 설명 됨&lt;/a&gt; )은이 목적을 위해 고차 함수 호출 사이트에서 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6580f39324c16c3fdd14fd9204c4e7b2dbc24353" translate="yes" xml:space="preserve">
          <source>To call a generic function, specify the type arguments at the call site &lt;strong&gt;after&lt;/strong&gt; the name of the function:</source>
          <target state="translated">일반 함수를 호출하려면 함수 이름 &lt;strong&gt;뒤에&lt;/strong&gt; 호출 사이트에서 유형 인수를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="567fc2cf862c0915604df53cff04863a317488f7" translate="yes" xml:space="preserve">
          <source>To catch an exception, use the &lt;em&gt;try&lt;/em&gt;-expression:</source>
          <target state="translated">예외를 포착하려면 &lt;em&gt;try&lt;/em&gt; -expression을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8d7572362421bb5d6d9129ee1f644a5743bf60f" translate="yes" xml:space="preserve">
          <source>To change the names of generated accessor methods for properties without explicitly implemented getters and setters, you can use &lt;code&gt;@get:JvmName&lt;/code&gt; and &lt;code&gt;@set:JvmName&lt;/code&gt;:</source>
          <target state="translated">명시 적으로 구현 된 getter 및 setter없이 속성에 대해 생성 된 접근 자 메서드의 이름을 변경하려면 &lt;code&gt;@get:JvmName&lt;/code&gt; 및 &lt;code&gt;@set:JvmName&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56c5976217a59b38e176bfb7f018f237783d8246" translate="yes" xml:space="preserve">
          <source>To check that tests are executed properly, we can add a file &lt;code&gt;src/test/kotlin/AppTest.kt&lt;/code&gt; and fill it with this content:</source>
          <target state="translated">테스트가 제대로 실행되었는지 확인하기 위해 &lt;code&gt;src/test/kotlin/AppTest.kt&lt;/code&gt; 파일을 추가하고 다음 내용으로 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fbf41ce5d5e2bab70a3b18ea06244281f42ad35" translate="yes" xml:space="preserve">
          <source>To check that your code passes your own test click the &lt;strong&gt;Check&lt;/strong&gt; icon at the top of &lt;strong&gt;Task Description&lt;/strong&gt; panel. If your code and test are correct, you will see the &lt;strong&gt;&quot;Congratulations!&quot;&lt;/strong&gt; text:</source>
          <target state="translated">코드가 자체 테스트를 통과했는지 확인하려면 &lt;strong&gt;작업 설명&lt;/strong&gt; 패널 상단의 &lt;strong&gt;확인&lt;/strong&gt; 아이콘을 클릭하십시오 . 코드와 테스트가 정확하면 &lt;strong&gt;&quot;축하합니다!&quot; &lt;/strong&gt;본문:&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="beef2a5f5b84a735eaf6763f186616f2da608682" translate="yes" xml:space="preserve">
          <source>To check the presence of an element in a collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt;&lt;code&gt;contains()&lt;/code&gt;&lt;/a&gt; function. It returns &lt;code&gt;true&lt;/code&gt; if there is a collection element that &lt;code&gt;equals()&lt;/code&gt; the function argument. You can call &lt;code&gt;contains()&lt;/code&gt; in the operator form with the &lt;code&gt;in&lt;/code&gt; keyword.</source>
          <target state="translated">컬렉션에 요소가 있는지 확인하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains&quot;&gt; &lt;code&gt;contains()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 함수 인수 &lt;code&gt;equals()&lt;/code&gt; 컬렉션 요소가 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;in&lt;/code&gt; 키워드를 사용하여 연산자 형식으로 &lt;code&gt;contains()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bacf79d368ab6b699d2fdae207996c835a00695c" translate="yes" xml:space="preserve">
          <source>To check the presence of multiple instances together at once, call &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt;&lt;code&gt;containsAll()&lt;/code&gt;&lt;/a&gt; with a collection of these instances as an argument.</source>
          <target state="translated">한 번에 여러 인스턴스가 있는지 확인하려면 이러한 인스턴스 컬렉션을 인수로하여 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/contains-all&quot;&gt; &lt;code&gt;containsAll()&lt;/code&gt; &lt;/a&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf01294073385c1601c163965354f1918a41a878" translate="yes" xml:space="preserve">
          <source>To check the stability status of different components of Kotlin (Kotlin/JVM, JS, Native, various libraries, etc), please consult &lt;a href=&quot;components-stability&quot;&gt;this link&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 다른 구성 요소 (Kotlin / JVM, JS, Native, 다양한 라이브러리 등)의 안정성 상태를 확인하려면 &lt;a href=&quot;components-stability&quot;&gt;이 링크&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff347228167cf9fc3db7b8ec20d8d867ef76b338" translate="yes" xml:space="preserve">
          <source>To check whether a &lt;code&gt;lateinit var&lt;/code&gt; has already been initialized, use &lt;code&gt;.isInitialized&lt;/code&gt; on the &lt;a href=&quot;reflection#property-references&quot;&gt;reference to that property&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;lateinit var&lt;/code&gt; 가 이미 초기화 되었는지 확인하려면 &lt;a href=&quot;reflection#property-references&quot;&gt;해당 속성&lt;/a&gt; 에 대한 참조에서 &lt;code&gt;.isInitialized&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a142fb50381952ec419c46ff01c1249b5d802db1" translate="yes" xml:space="preserve">
          <source>To choose between the different Kotlin/JS compiler options, set the key &lt;code&gt;kotlin.js.compiler&lt;/code&gt; in your &lt;code&gt;gradle.properties&lt;/code&gt; to &lt;code&gt;legacy&lt;/code&gt;, &lt;code&gt;ir&lt;/code&gt;, or &lt;code&gt;both&lt;/code&gt;. Alternatively, pass &lt;code&gt;LEGACY&lt;/code&gt;, &lt;code&gt;IR&lt;/code&gt;, or &lt;code&gt;BOTH&lt;/code&gt; to the &lt;code&gt;js&lt;/code&gt; function in your &lt;code&gt;build.gradle(.kts)&lt;/code&gt;.</source>
          <target state="translated">다양한 Kotlin / JS 컴파일러 옵션 중에서 선택하려면 &lt;code&gt;kotlin.js.compiler&lt;/code&gt; 의 &lt;code&gt;gradle.properties&lt;/code&gt; 키 를 &lt;code&gt;legacy&lt;/code&gt; , &lt;code&gt;ir&lt;/code&gt; 또는 &lt;code&gt;both&lt;/code&gt; 합니다. 또는 &lt;code&gt;LEGACY&lt;/code&gt; , &lt;code&gt;IR&lt;/code&gt; 또는 &lt;code&gt;BOTH&lt;/code&gt; 를 &lt;code&gt;build.gradle(.kts)&lt;/code&gt; 의 &lt;code&gt;js&lt;/code&gt; 함수에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="06e9d17e9ea9b86a000058cf4db743b9a4f8896c" translate="yes" xml:space="preserve">
          <source>To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:</source>
          <target state="translated">클래스 헤더가 길 때 클래스 헤더와 본문을 명확하게 분리하려면 클래스 헤더 다음에 빈 줄을 추가하거나 (위의 예와 같이) 여는 중괄호를 별도의 줄에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="3e043d9080f48d9f8a9db312581f08dbc6b9e5fd" translate="yes" xml:space="preserve">
          <source>To collect all source sets participating in a compilation, including those added via the depends-on relation, one can use the property &lt;code&gt;allKotlinSourceSets&lt;/code&gt;.</source>
          <target state="translated">의존 관계를 통해 추가 된 것을 포함하여 컴파일에 참여하는 모든 소스 세트를 수집하기 위해 &lt;code&gt;allKotlinSourceSets&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="803e7c1c7144d14a645ff4c12ca8fcfcbdd5adbe" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means kotlin-maven-plugin should be run before maven-compiler-plugin using the following method, making sure that the kotlin plugin is above the maven-compiler-plugin in your pom.xml file:</source>
          <target state="translated">혼합 코드 애플리케이션을 컴파일하려면 Java 컴파일러 전에 Kotlin 컴파일러를 호출해야합니다. 즉, kotlin 플러그인이 pom.xml 파일의 maven-compiler-plugin 위에 있는지 확인하여 다음 방법을 사용하여 kotlin-maven-plugin을 maven-compiler-plugin보다 먼저 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="db544e0e7056b8ab96d6dfe0f4c1cf8c1335597b" translate="yes" xml:space="preserve">
          <source>To compile mixed code applications Kotlin compiler should be invoked before Java compiler. In maven terms that means that &lt;code&gt;kotlin-maven-plugin&lt;/code&gt; should run before &lt;code&gt;maven-compiler-plugin&lt;/code&gt; using the following method. Make sure that the &lt;code&gt;kotlin&lt;/code&gt; plugin comes before the &lt;code&gt;maven-compiler-plugin&lt;/code&gt; in your &lt;code&gt;pom.xml&lt;/code&gt; file:</source>
          <target state="translated">혼합 코드 애플리케이션을 컴파일하려면 자바 컴파일러보다 먼저 Kotlin 컴파일러를 호출해야합니다. Maven 용어에서 이는 &lt;code&gt;kotlin-maven-plugin&lt;/code&gt; 이 다음 방법을 사용하여 &lt;code&gt;maven-compiler-plugin&lt;/code&gt; 보다 먼저 실행되어야 함을 의미합니다 . &lt;code&gt;kotlin&lt;/code&gt; 플러그인이 &lt;code&gt;pom.xml&lt;/code&gt; 파일 에서 &lt;code&gt;maven-compiler-plugin&lt;/code&gt; 앞에 오는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="72988880fd1eb858d05ee3ce13bbc13e7e1bb020" translate="yes" xml:space="preserve">
          <source>To compile source code, specify the source directories in the</source>
          <target state="translated">소스 코드를 컴파일하려면</target>
        </trans-unit>
        <trans-unit id="05e8b41e40400d680ccd1fc7712decc5274ce096" translate="yes" xml:space="preserve">
          <source>To compile the application use the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;downloaded&lt;/a&gt; compiler to execute the following command:</source>
          <target state="translated">애플리케이션을 컴파일하려면 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases/tag/v1.4.10&quot;&gt;다운로드 한&lt;/a&gt; 컴파일러를 사용 하여 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b4127356a573ae0646e7fc7abacf9ec61a4c1bfd" translate="yes" xml:space="preserve">
          <source>To compile your module in the explicit API mode, add the following lines to your Gradle build script:</source>
          <target state="translated">명시 적 API 모드에서 모듈을 컴파일하려면 Gradle 빌드 스크립트에 다음 줄을 추가하세요.</target>
        </trans-unit>
        <trans-unit id="37fdd621985c6aff13221b4e4aea16cc07ab8ee0" translate="yes" xml:space="preserve">
          <source>To configure DCE on the main source set, you can use the &lt;code&gt;runDceKotlinJs&lt;/code&gt; task (and corresponding &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; for other source sets).</source>
          <target state="translated">기본 소스 세트에서 DCE를 구성하기 위해 &lt;code&gt;runDceKotlinJs&lt;/code&gt; 태스크 (및 다른 소스 세트에 해당하는 &lt;code&gt;runDce&amp;lt;sourceSetName&amp;gt;KotlinJs&lt;/code&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fbb0879e62b32ffc14d1dc5aabab44fdf51b7ee" translate="yes" xml:space="preserve">
          <source>To configure a single task, use its name. Examples:</source>
          <target state="translated">단일 작업을 구성하려면 해당 이름을 사용하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="31f760752d420596279600b4f50a8da617cd79a7" translate="yes" xml:space="preserve">
          <source>To configure additional Yarn features, place a &lt;code&gt;.yarnrc&lt;/code&gt; file in the root of your project. At build time, it gets picked up automatically.</source>
          <target state="translated">추가 Yarn 기능을 구성하려면 프로젝트의 루트에 &lt;code&gt;.yarnrc&lt;/code&gt; 파일을 배치 하십시오. 빌드시 자동으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="75b4ad80b6e5b98a0167e62ef51d7159288b8634" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to &lt;strong&gt;Settings | Editor | Code Style | Kotlin&lt;/strong&gt;, click &lt;strong&gt;Set from&amp;hellip;&lt;/strong&gt; link in the upper right corner, and select &lt;strong&gt;Kotlin style guide&lt;/strong&gt; from the menu.</source>
          <target state="translated">이 스타일 가이드에 따라 IntelliJ 포맷터를 구성하려면 Kotlin 플러그인 버전 1.2.20 이상을 설치하고 &lt;strong&gt;설정 | 편집자 | 코드 스타일 | Kotlin&lt;/strong&gt; 에서 오른쪽 상단 모서리에있는 &lt;strong&gt;설정&amp;hellip;&lt;/strong&gt; 링크를 클릭 하고 메뉴에서 &lt;strong&gt;Kotlin 스타일 가이드&lt;/strong&gt; 를 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="68df6e8c753963392486043995598199a7116aa3" translate="yes" xml:space="preserve">
          <source>To configure the IntelliJ formatter according to this style guide, please install Kotlin plugin version 1.2.20 or newer, go to Settings | Editor | Code Style | Kotlin, click on &quot;Set from&amp;hellip;&quot; link in the upper right corner, and select &quot;Predefined style / Kotlin style guide&quot; from the menu.</source>
          <target state="translated">이 스타일 가이드에 따라 IntelliJ 포맷터를 구성하려면 Kotlin 플러그인 버전 1.2.20 이상을 설치하고 설정 | 편집자 | 코드 스타일 | Kotlin의 오른쪽 상단 모서리에있는 &quot;Set from&amp;hellip;&quot;링크를 클릭하고 메뉴에서 &quot;Predefined style / Kotlin style guide&quot;를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="2c9d3b301661c08e8259cc3ab20ba4dbad19be49" translate="yes" xml:space="preserve">
          <source>To construct a duration use either the extension function &lt;a href=&quot;../to-duration&quot;&gt;toDuration&lt;/a&gt;, or the extension properties &lt;a href=&quot;../hours&quot;&gt;hours&lt;/a&gt;, &lt;a href=&quot;../minutes&quot;&gt;minutes&lt;/a&gt;, &lt;a href=&quot;../seconds&quot;&gt;seconds&lt;/a&gt;, and so on, available on &lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt;, &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt;, and &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; numeric types.</source>
          <target state="translated">기간을 구성하려면 확장 함수 &lt;a href=&quot;../to-duration&quot;&gt;toDuration&lt;/a&gt; 또는 &lt;a href=&quot;../../kotlin/-int/index#kotlin.Int&quot;&gt;Int&lt;/a&gt; , &lt;a href=&quot;../../kotlin/-long/index#kotlin.Long&quot;&gt;Long&lt;/a&gt; 및 &lt;a href=&quot;../../kotlin/-double/index#kotlin.Double&quot;&gt;Double&lt;/a&gt; 숫자 유형 에서 사용할 수 있는 확장 속성 &lt;a href=&quot;../hours&quot;&gt;hours&lt;/a&gt; , &lt;a href=&quot;../minutes&quot;&gt;minutes&lt;/a&gt; , &lt;a href=&quot;../seconds&quot;&gt;seconds&lt;/a&gt; 등을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a84aa42a71bde94030fd28b49274ed212410ae73" translate="yes" xml:space="preserve">
          <source>To convert a Kotlin function to a pointer to a C function, &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; can be used. It is also able to provide the lambda instead of a function reference. The function or lambda must not capture any values.</source>
          <target state="translated">Kotlin 함수를 C 함수의 포인터로 변환하기 위해 &lt;code&gt;staticCFunction(::kotlinFunction)&lt;/code&gt; 사용할 수 있습니다. 함수 참조 대신 람다를 제공 할 수도 있습니다. 함수 또는 람다는 어떤 값도 캡처하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3c44f554793ee378fe115edb9d2b77ef0a09d12f" translate="yes" xml:space="preserve">
          <source>To convert a file we simply provide the input file, and optionally an output directory. The command below will convert the file &lt;code&gt;jquery.d.ts&lt;/code&gt; in the current folder, which we've previously downloaded from the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed repository&lt;/a&gt; to the output folder &lt;code&gt;headers&lt;/code&gt;:</source>
          <target state="translated">파일을 변환하기 위해 단순히 입력 파일과 선택적으로 출력 디렉토리를 제공합니다. 아래 명령 은 이전에 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/types/jquery/jquery.d.ts&quot;&gt;Definitely Typed 리포지토리&lt;/a&gt; 에서 다운로드 한 현재 폴더의 &lt;code&gt;jquery.d.ts&lt;/code&gt; 파일 을 출력 폴더 &lt;code&gt;headers&lt;/code&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="969568decea2cdc2afa64668f60c6158428db0dd" translate="yes" xml:space="preserve">
          <source>To convert floating-point numbers to &lt;code&gt;Byte&lt;/code&gt; or &lt;code&gt;Short&lt;/code&gt;, use the two-step conversion: first, convert them to &lt;code&gt;Int&lt;/code&gt;, and then convert them again to the target type.</source>
          <target state="translated">부동 소수점 숫자를 &lt;code&gt;Byte&lt;/code&gt; 또는 &lt;code&gt;Short&lt;/code&gt; 로 변환하려면 먼저 두 단계 변환을 사용하십시오. 먼저 &lt;code&gt;Int&lt;/code&gt; 로 변환 한 다음 다시 대상 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="53082c51d066700fb796c416707ace90c10e7442" translate="yes" xml:space="preserve">
          <source>To convert numeric values to different types, use &lt;a href=&quot;#explicit-conversions&quot;&gt;Explicit conversions&lt;/a&gt;.</source>
          <target state="translated">숫자 값을 다른 유형으로 &lt;a href=&quot;#explicit-conversions&quot;&gt;변환&lt;/a&gt; 하려면 명시 적 변환을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="09283e6df610a2666a552ab05ba081120d5fb799" translate="yes" xml:space="preserve">
          <source>To correctly import the dependencies into the Kotlin/Native module, the &lt;code&gt;Podfile&lt;/code&gt; must contain either &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_modular_headers_bang&quot;&gt;&lt;code&gt;use_modular_headers!&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_frameworks_bang&quot;&gt;&lt;code&gt;use_frameworks!&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">올바르게 코 틀린 / 기본 모듈에 의존성을 가져 오려면는 &lt;code&gt;Podfile&lt;/code&gt; 는 하나의 메시지 있어야합니다 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_modular_headers_bang&quot;&gt; &lt;code&gt;use_modular_headers!&lt;/code&gt; &lt;/a&gt;또는 &lt;a href=&quot;https://guides.cocoapods.org/syntax/podfile.html#use_frameworks_bang&quot;&gt; &lt;code&gt;use_frameworks!&lt;/code&gt; &lt;/a&gt;지령.</target>
        </trans-unit>
        <trans-unit id="033c0e927137582a697794f54285b85aeb454fd5" translate="yes" xml:space="preserve">
          <source>To cover these (and other) cases, Kotlin supports &lt;em&gt;delegated properties&lt;/em&gt;:</source>
          <target state="translated">이러한 (및 기타) 사례를 다루기 위해 Kotlin은 &lt;em&gt;위임 속성을&lt;/em&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9d0229fd8c1088f563b4cf4e10d12c4379d2f726" translate="yes" xml:space="preserve">
          <source>To create a Kotlin scratch, click &lt;strong&gt;File | New | Scratch file&lt;/strong&gt; and select the &lt;strong&gt;Kotlin&lt;/strong&gt; type.</source>
          <target state="translated">Kotlin 스크래치를 작성하려면 &lt;strong&gt;파일 | 새로운 | 파일을 스크래치&lt;/strong&gt; 하고 &lt;strong&gt;Kotlin&lt;/strong&gt; 유형을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2345a81dc6db58bf05fd03f469161c13a230da9" translate="yes" xml:space="preserve">
          <source>To create a Kotlin worksheet in a project directory, right-click the directory in the project tree and select &lt;strong&gt;New | Kotlin Worksheet&lt;/strong&gt;.</source>
          <target state="translated">프로젝트 디렉토리에 Kotlin 워크 시트를 만들려면 프로젝트 트리에서 디렉토리를 마우스 오른쪽 버튼으로 클릭하고 &lt;strong&gt;New | Kotlin 워크 시트&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="80ff78a98293894db61ee5daa488d414337b0f86" translate="yes" xml:space="preserve">
          <source>To create a Kotlin/JS project in IntelliJ IDEA, go to &lt;strong&gt;File | New | Project&lt;/strong&gt; and select &lt;strong&gt;Gradle | Kotlin/JS for browser&lt;/strong&gt; or &lt;strong&gt;Kotlin/JS for Node.js&lt;/strong&gt;. Be sure to clear the &lt;strong&gt;Java&lt;/strong&gt; checkbox. If you want to use the Kotlin DSL for Gradle, make sure to check the &lt;strong&gt;Kotlin DSL build script&lt;/strong&gt; option.</source>
          <target state="translated">IntelliJ IDEA에서 Kotlin / JS 프로젝트를 만들려면 &lt;strong&gt;파일 | 새로운 | 프로젝트&lt;/strong&gt; 를 선택하고 &lt;strong&gt;Gradle | 브라우저 용 Kotlin / JS&lt;/strong&gt; 또는 &lt;strong&gt;Node.js 용 Kotlin / JS&lt;/strong&gt; . &lt;strong&gt;Java&lt;/strong&gt; 확인란 을 선택 취소해야합니다 . Gradle 용 Kotlin DSL을 사용하려면 &lt;strong&gt;Kotlin DSL 빌드 스크립트&lt;/strong&gt; 옵션 을 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6469e95270452943ecc23557177165ada17e0d19" translate="yes" xml:space="preserve">
          <source>To create a collection with the same elements as an existing collection, you can use copying operations. Collection copying operations from the standard library create &lt;em&gt;shallow&lt;/em&gt; copy collections with references to the same elements. Thus, a change made to a collection element reflects in all its copies.</source>
          <target state="translated">기존 컬렉션과 동일한 요소로 컬렉션을 만들려면 복사 작업을 사용할 수 있습니다. 표준 라이브러리에서 수집 복사 작업 을 수행하면 동일한 요소에 대한 참조가있는 &lt;em&gt;단순&lt;/em&gt; 복사 수집이 생성 됩니다. 따라서 컬렉션 요소에 대한 변경 사항은 모든 복사본에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="c93eeedd365f43d9e2553f0db590167b463ec502" translate="yes" xml:space="preserve">
          <source>To create a concrete type collection, such as an &lt;code&gt;ArrayList&lt;/code&gt; or &lt;code&gt;LinkedList&lt;/code&gt;, you can use the available constructors for these types. Similar constructors are available for implementations of &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArrayList&lt;/code&gt; 또는 &lt;code&gt;LinkedList&lt;/code&gt; 와 같은 구체적인 유형 컬렉션을 만들려면 이러한 유형에 사용 가능한 생성자를 사용할 수 있습니다. &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Map&lt;/code&gt; 구현에 유사한 생성자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10c83d8ce189917b93f0dd12f924ce0343c0f0cd" translate="yes" xml:space="preserve">
          <source>To create a course, go to &lt;strong&gt;Create New Course&lt;/strong&gt; from the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;, fill in the title, author and description:</source>
          <target state="translated">과정을 만들려면 갈 &lt;strong&gt;새로운 코스를 만들기&lt;/strong&gt; 로부터 &lt;strong&gt;시작 화면&lt;/strong&gt; 또는에서 &lt;strong&gt;파일 메뉴&lt;/strong&gt; , 제목, 저자 및 설명에 채우기 :</target>
        </trans-unit>
        <trans-unit id="b19b96489e64fb428b07b0d9e5f6b20ffaee0c76" translate="yes" xml:space="preserve">
          <source>To create a finite sequence with &lt;code&gt;generateSequence()&lt;/code&gt;, provide a function that returns &lt;code&gt;null&lt;/code&gt; after the last element you need.</source>
          <target state="translated">&lt;code&gt;generateSequence()&lt;/code&gt; 를 사용하여 유한 시퀀스를 작성하려면 필요한 마지막 요소 다음에 &lt;code&gt;null&lt;/code&gt; 을 리턴하는 함수를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="47b61d43a27903512a35c90e596534948c2b1dbf" translate="yes" xml:space="preserve">
          <source>To create a progression for iterating in reverse order, use &lt;code&gt;downTo&lt;/code&gt; instead of &lt;code&gt;..&lt;/code&gt; when defining the range for it.</source>
          <target state="translated">역순으로 반복 진행을 만들려면 범위를 정의 할 때 &lt;code&gt;..&lt;/code&gt; 대신 &lt;code&gt;downTo&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="b47410847599f97a1134fa9ef445378b7a480550" translate="yes" xml:space="preserve">
          <source>To create a range for your class, call the &lt;code&gt;rangeTo()&lt;/code&gt; function on the range start value and provide the end value as an argument. &lt;code&gt;rangeTo()&lt;/code&gt; is often called in its operator form &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">클래스의 범위를 만들려면 범위 시작 값 에서 &lt;code&gt;rangeTo()&lt;/code&gt; 함수를 호출 하고 끝 값을 인수로 제공하십시오. &lt;code&gt;rangeTo()&lt;/code&gt; 종종 운영자 형태라고 &lt;code&gt;..&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef350d13303167462d244e7352097ce6871c0d66" translate="yes" xml:space="preserve">
          <source>To create a self-contained Jar file containing the code from your module along with dependencies, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">종속성과 함께 모듈의 코드를 포함하는 자체 포함 된 Jar 파일을 작성하려면 Maven pom.xml 파일의 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 아래에 다음을 포함 하십시오. 여기서 &lt;code&gt;main.class&lt;/code&gt; 는 특성으로 정의되며 기본 Kotlin 또는 자바 클래스 :</target>
        </trans-unit>
        <trans-unit id="250688e8e0fbdc724cfa4d689a087f5e676490f2" translate="yes" xml:space="preserve">
          <source>To create a sequence, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt;&lt;code&gt;sequenceOf()&lt;/code&gt;&lt;/a&gt; function listing the elements as its arguments.</source>
          <target state="translated">시퀀스를 만들려면 요소를 인수로 나열하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.sequences/sequence-of&quot;&gt; &lt;code&gt;sequenceOf()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab5e0caabe6ba677095c9c30bc71be0a60a8ea76" translate="yes" xml:space="preserve">
          <source>To create a small Jar file containing just the code from your module, include the following under &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; in your Maven pom.xml file, where &lt;code&gt;main.class&lt;/code&gt; is defined as a property and points to the main Kotlin or Java class:</source>
          <target state="translated">모듈의 코드 만 포함하는 작은 Jar 파일을 만들려면 Maven pom.xml 파일의 &lt;code&gt;build-&amp;gt;plugins&lt;/code&gt; 아래에 다음을 포함 하십시오. 여기서 &lt;code&gt;main.class&lt;/code&gt; 는 속성으로 정의되며 기본 Kotlin 또는 Java 클래스를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="e35af751d291871272ac5bf8d4ceb5925a4c895b" translate="yes" xml:space="preserve">
          <source>To create a target, use one of the preset functions, which are named according to the target platforms and optionally accept the target name and a configuring code block:</source>
          <target state="translated">대상을 작성하려면 대상 플랫폼에 따라 이름이 지정된 사전 설정 기능 중 하나를 사용하고 선택적으로 대상 이름과 구성 코드 블록을 승인하십시오.</target>
        </trans-unit>
        <trans-unit id="59c179a1054538f29e6f5790e866a02248610385" translate="yes" xml:space="preserve">
          <source>To create an array, we can use a library function &lt;code&gt;arrayOf()&lt;/code&gt; and pass the item values to it, so that &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; creates an array &lt;code&gt;[1, 2, 3]&lt;/code&gt;. Alternatively, the &lt;code&gt;arrayOfNulls()&lt;/code&gt; library function can be used to create an array of a given size filled with null elements.</source>
          <target state="translated">배열을 만들려면 &lt;code&gt;arrayOf()&lt;/code&gt; 라이브러리 함수를 사용 하고 항목 값을 전달하여 &lt;code&gt;arrayOf(1, 2, 3)&lt;/code&gt; 이 배열 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 있습니다. 또는 &lt;code&gt;arrayOfNulls()&lt;/code&gt; 라이브러리 함수를 사용하여 널 요소로 채워진 주어진 크기의 배열을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cc39e6db177eed985da184429e7d653e4d3e03b" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 만들려면 &lt;a href=&quot;../lazy#kotlin%24lazy%28kotlin.Function0%28%28kotlin.lazy.T%29%29%29&quot;&gt;lazy&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9b7dfa76d5d4f8a207e73e37c8aed978cc5e50d" translate="yes" xml:space="preserve">
          <source>To create an instance of &lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; use the &lt;a href=&quot;../lazy#kotlin%24lazy(kotlin.Function0((kotlin.lazy.T)))&quot;&gt;lazy&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;Lazy&lt;/a&gt; 인스턴스를 생성하려면 &lt;a href=&quot;../lazy#kotlin%24lazy(kotlin.Function0((kotlin.lazy.T)))&quot;&gt;lazy&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="392ca62c20eb8ea21287252327b80e948e15e7f9" translate="yes" xml:space="preserve">
          <source>To create an instance of a class, we call the constructor as if it were a regular function:</source>
          <target state="translated">클래스의 인스턴스를 만들려면 생성자를 일반 함수 인 것처럼 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5ececdd9ea1ec767cefb32bd8a4972a7f3db2e63" translate="yes" xml:space="preserve">
          <source>To create an object of an anonymous class that inherits from some type (or types), we write:</source>
          <target state="translated">어떤 유형에서 상속되는 익명 클래스의 객체를 만들려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="66ccf1c80c7d0872003cb95567afdbb598a15cac" translate="yes" xml:space="preserve">
          <source>To create bindings for a new library, start by creating a &lt;code&gt;.def&lt;/code&gt; file. Structurally it's a simple property file, which looks like this:</source>
          <target state="translated">새 라이브러리에 대한 바인딩을 작성하려면 먼저 &lt;code&gt;.def&lt;/code&gt; 파일 을 작성 하십시오. 구조적으로 이것은 다음과 같은 간단한 속성 파일입니다.</target>
        </trans-unit>
        <trans-unit id="53cb83a01be7750f4f13800e35fa2fb65a7ce331" translate="yes" xml:space="preserve">
          <source>To create or access several targets from multiple presets dynamically, you can use the &lt;code&gt;targetFromPreset&lt;/code&gt; function which accepts a preset (those are contained in the &lt;code&gt;kotlin.presets&lt;/code&gt; domain object collection) and, optionally, a target name and a configuration code block.</source>
          <target state="translated">여러 사전 설정에서 여러 대상을 동적으로 작성하거나 액세스하려면 사전 설정 ( &lt;code&gt;kotlin.presets&lt;/code&gt; 도메인 오브젝트 콜렉션에 포함됨 ) 및 선택적으로 대상 이름 및 구성 코드 블록 을 허용하는 &lt;code&gt;targetFromPreset&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84204f67cf463ce0040ab94f394e112f27f7a64e" translate="yes" xml:space="preserve">
          <source>To create such channel use a factory method &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;ticker&lt;/a&gt;. To indicate that no further elements are needed use &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; method on it.</source>
          <target state="translated">이러한 채널을 만들려면 팩토리 메소드 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/ticker.html&quot;&gt;시세를 사용하십시오&lt;/a&gt; . 추가 요소가 필요하지 않음을 나타내려면 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/cancel.html&quot;&gt;ReceiveChannel.cancel&lt;/a&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7ca6e4021fa1f14db902d32b5e28e873b56dfed4" translate="yes" xml:space="preserve">
          <source>To create the hierarchical structure manually, introduce an intermediate source set that holds the shared code for several targets and create a structure of the source sets including the intermediate one.</source>
          <target state="translated">계층 구조를 수동으로 생성하려면 여러 타겟에 대한 공유 코드를 보유하는 중간 소스 세트를 도입하고 중간 소스 세트를 포함하여 소스 세트의 구조를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f270c63c035ac76bc90800e7489ec199d1188bb4" translate="yes" xml:space="preserve">
          <source>To create the new file, the &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;prefix&lt;/a&gt; and the &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;suffix&lt;/a&gt; may first be adjusted to fit the limitations of the underlying platform.</source>
          <target state="translated">새 파일을 만들려면 먼저 기본 플랫폼의 제한 사항에 맞게 &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;접두사&lt;/a&gt; 와 &lt;a href=&quot;create-temp-dir#kotlin.io%24createTempDir(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;접미사를&lt;/a&gt; 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed397e5c4869250a6fe4256b7633ea9b132cd1a7" translate="yes" xml:space="preserve">
          <source>To create the new file, the &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;prefix&lt;/a&gt; and the &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;suffix&lt;/a&gt; may first be adjusted to fit the limitations of the underlying platform.</source>
          <target state="translated">새 파일을 만들려면 먼저 기본 플랫폼의 제한 사항에 맞게 &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/prefix&quot;&gt;접두사&lt;/a&gt; 와 &lt;a href=&quot;create-temp-file#kotlin.io%24createTempFile(kotlin.String,%20kotlin.String?,%20java.io.File?)/suffix&quot;&gt;접미사를&lt;/a&gt; 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e26d13b3d6d463e1b2fd03afc335d058a5d4673" translate="yes" xml:space="preserve">
          <source>To debug Kotlin in Google Chrome, you should use DevTools. Please, read the &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;official documentation&lt;/a&gt; to learn how to open and use DevTools.</source>
          <target state="translated">Chrome에서 Kotlin을 디버깅하려면 DevTools를 사용해야합니다. DevTools를 열고 사용하는 방법을 배우 려면 &lt;a href=&quot;https://developer.chrome.com/devtools&quot;&gt;공식 문서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e817cf98143421063f9dd49cbdf248b7b2518117" translate="yes" xml:space="preserve">
          <source>To debug Kotlin sources in the browser, you should tell the compiler to generate source map file. Add following lines to the Gradle configuration:</source>
          <target state="translated">브라우저에서 Kotlin 소스를 디버그하려면 소스 맵 파일을 생성하도록 컴파일러에 지시해야합니다. Gradle 구성에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c61d767cd604eae6780df09aa030d9d280b98c" translate="yes" xml:space="preserve">
          <source>To declare a function that is implemented in native (C or C++) code, you need to mark it with the &lt;code&gt;external&lt;/code&gt; modifier:</source>
          <target state="translated">네이티브 (C 또는 C ++) 코드로 구현 된 함수를 선언하려면 &lt;code&gt;external&lt;/code&gt; 수정 자로 이를 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="79e836524d01f43d3f368b1ec21e6a64cf0c9af7" translate="yes" xml:space="preserve">
          <source>To declare a functional interface in Kotlin, use the &lt;code&gt;fun&lt;/code&gt; modifier.</source>
          <target state="translated">Kotlin에서 기능 인터페이스를 선언하려면 &lt;code&gt;fun&lt;/code&gt; 한정자를 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="17984c774c9009532146abdfe4c1f92691dab870" translate="yes" xml:space="preserve">
          <source>To declare a sealed class, you put the &lt;code&gt;sealed&lt;/code&gt; modifier before the name of the class. A sealed class can have subclasses, but all of them must be declared in the same file as the sealed class itself. (Before Kotlin 1.1, the rules were even more strict: classes had to be nested inside the declaration of the sealed class).</source>
          <target state="translated">봉인 된 클래스를 선언하려면 클래스 이름 앞에 &lt;code&gt;sealed&lt;/code&gt; 수정자를 넣습니다 . 봉인 된 클래스에는 서브 클래스가있을 수 있지만 모두 봉인 된 클래스 자체와 동일한 파일에 선언되어야합니다. (Kotlin 1.1 이전에는 규칙이 더욱 엄격했습니다. 클래스는 봉인 된 클래스의 선언 안에 중첩되어야했습니다).</target>
        </trans-unit>
        <trans-unit id="10a7f058c3df1eb894a755ea535860aa75893fea" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, place the type after a colon in the class header:</source>
          <target state="translated">명시 적 상위 유형을 선언하려면 클래스 헤더의 콜론 뒤에 유형을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="c97ee402b691c80817117f378bd0349e4a8da26c" translate="yes" xml:space="preserve">
          <source>To declare an explicit supertype, we place the type after a colon in the class header:</source>
          <target state="translated">명시적인 슈퍼 타입을 선언하기 위해 클래스 헤더에서 콜론 뒤에 타입을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="48ff93d55fe3658449347e35151be6b572c8736d" translate="yes" xml:space="preserve">
          <source>To declare an extension function, we need to prefix its name with a &lt;em&gt;receiver type&lt;/em&gt;, i.e. the type being extended. The following adds a &lt;code&gt;swap&lt;/code&gt; function to &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">확장 함수를 선언하려면 이름 앞에 &lt;em&gt;리시버 유형&lt;/em&gt; , 즉 확장되는 &lt;em&gt;유형&lt;/em&gt; 을 접두어로 붙여야합니다 . 다음 은 &lt;code&gt;MutableList&amp;lt;Int&amp;gt;&lt;/code&gt; &lt;code&gt;swap&lt;/code&gt; 함수를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="a2675b642241372403d53ead59c356a1d8d22f48" translate="yes" xml:space="preserve">
          <source>To declare an npm dependency, pass its name and version to the &lt;code&gt;npm()&lt;/code&gt; function inside a dependency declaration. You can also specify one or multiple version range based on &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm's semver syntax&lt;/a&gt;.</source>
          <target state="translated">npm 종속성을 선언하려면 종속성 선언 내의 &lt;code&gt;npm()&lt;/code&gt; 함수에 이름과 버전을 전달하십시오 . &lt;a href=&quot;https://docs.npmjs.com/misc/semver#versions&quot;&gt;npm의 semver 구문을&lt;/a&gt; 기반으로 하나 또는 여러 버전 범위를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e983a5d628747c6e88e300a187da5fef2223334" translate="yes" xml:space="preserve">
          <source>To declare final native binaries such as executables or shared libraries, use the &lt;code&gt;binaries&lt;/code&gt; property of a native target. This property represents a collection of native binaries built for this target in addition to the default &lt;code&gt;*.klib&lt;/code&gt; artifact and provides a set of methods for declaring and configuring them.</source>
          <target state="translated">실행 파일 또는 공유 라이브러리와 같은 최종 네이티브 바이너리를 선언하려면 네이티브 대상 의 &lt;code&gt;binaries&lt;/code&gt; 속성을 사용하세요 . 이 속성은 기본 &lt;code&gt;*.klib&lt;/code&gt; 아티팩트 외에이 대상에 대해 빌드 된 네이티브 바이너리 컬렉션을 나타내며 이를 선언 및 구성하기위한 메서드 집합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f1b32c095491287535a8ffbd23d718a4ec1e28de" translate="yes" xml:space="preserve">
          <source>To define a custom order for the collection sorting, you can provide your own &lt;code&gt;Comparator&lt;/code&gt;. To do this, call the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt;&lt;code&gt;sortedWith()&lt;/code&gt;&lt;/a&gt; function passing in your &lt;code&gt;Comparator&lt;/code&gt;. With this function, sorting strings by their length looks like this:</source>
          <target state="translated">콜렉션 정렬에 대한 사용자 정의 순서를 정의하기 위해 고유 한 &lt;code&gt;Comparator&lt;/code&gt; 를 제공 할 수 있습니다 . 이렇게하려면 &lt;code&gt;Comparator&lt;/code&gt; 에 전달 된 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/sorted-with&quot;&gt; &lt;code&gt;sortedWith()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 . 이 함수를 사용하면 문자열을 길이별로 정렬하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76c4ad66d01d81d2c13dd0f6fd9cbde76bdd69dd" translate="yes" xml:space="preserve">
          <source>To define a custom progression step, use the &lt;code&gt;step&lt;/code&gt; function on a range.</source>
          <target state="translated">사용자 정의 진행 단계를 정의하려면 범위 에서 &lt;code&gt;step&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3c595e055a9ae116f425f8291258d8dc6632df5" translate="yes" xml:space="preserve">
          <source>To define a natural order for a user-defined type, make the type an inheritor of &lt;code&gt;Comparable&lt;/code&gt;. This requires implementing the &lt;code&gt;compareTo()&lt;/code&gt; function. &lt;code&gt;compareTo()&lt;/code&gt; must take another object of the same type as an argument and return an integer value showing which object is greater:</source>
          <target state="translated">사용자 정의 형식의 자연스러운 순서를 정의하려면 형식을 &lt;code&gt;Comparable&lt;/code&gt; 의 상속자로 만드십시오 . &lt;code&gt;compareTo()&lt;/code&gt; 함수를 구현해야 합니다. &lt;code&gt;compareTo()&lt;/code&gt; 는 인수와 동일한 유형의 다른 객체를 가져 와서 더 큰 객체를 나타내는 정수 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="97b3e94e6c163378ef995af60afef80476f27107" translate="yes" xml:space="preserve">
          <source>To define the target execution environment for a Kotlin/JS project, add the &lt;code&gt;js&lt;/code&gt; section with &lt;code&gt;browser {}&lt;/code&gt; or &lt;code&gt;nodejs {}&lt;/code&gt; inside.</source>
          <target state="translated">Kotlin / JS 프로젝트의 대상 실행 환경을 정의하려면 &lt;code&gt;browser {}&lt;/code&gt; 또는 &lt;code&gt;nodejs {}&lt;/code&gt; 가 포함 된 &lt;code&gt;js&lt;/code&gt; 섹션을 내부에 추가하세요.</target>
        </trans-unit>
        <trans-unit id="15f6c4e9b412ce540337bf0f4670d3a11f889be0" translate="yes" xml:space="preserve">
          <source>To delegate a property to another property, use the proper &lt;code&gt;::&lt;/code&gt; qualifier in the delegate name, for example, &lt;code&gt;this::delegate&lt;/code&gt; or &lt;code&gt;MyClass::delegate&lt;/code&gt;.</source>
          <target state="translated">속성을 다른 속성에 위임하려면 위임 이름에 적절한 &lt;code&gt;::&lt;/code&gt; 한정자를 사용합니다 ( 예 : &lt;code&gt;this::delegate&lt;/code&gt; 또는 &lt;code&gt;MyClass::delegate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9143cabd73a5291d802c769a81ee627bbb5733e" translate="yes" xml:space="preserve">
          <source>To denote the current &lt;em&gt;receiver&lt;/em&gt;, we use &lt;em&gt;this&lt;/em&gt; expressions:</source>
          <target state="translated">현재 &lt;em&gt;수신자&lt;/em&gt; 를 나타 내기 위해 &lt;em&gt;다음&lt;/em&gt; 표현식 을 사용 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="370aeed576ab8358f729a92b8f556723486b4edb" translate="yes" xml:space="preserve">
          <source>To deploy Kotlin applications on &lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt;, you can follow the &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;official Heroku tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.heroku.com&quot;&gt;Heroku&lt;/a&gt; 에 Kotlin 응용 프로그램을 배포하려면 &lt;a href=&quot;https://devcenter.heroku.com/articles/getting-started-with-kotlin&quot;&gt;공식 Heroku 튜토리얼을&lt;/a&gt; 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="df65bd88e8b911bd297cf79b50116d47f9582b7f" translate="yes" xml:space="preserve">
          <source>To deserialize an object from JSON, use the &lt;code&gt;decodeFromString()&lt;/code&gt; function:</source>
          <target state="translated">JSON에서 객체를 역 직렬화하려면 &lt;code&gt;decodeFromString()&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9515ab87992626329f3209451ad10d94d57d9d91" translate="yes" xml:space="preserve">
          <source>To disable</source>
          <target state="translated">비활성화하려면</target>
        </trans-unit>
        <trans-unit id="771653f64e2b72ee994da136292e2bfcc37a8770" translate="yes" xml:space="preserve">
          <source>To disable the caching for all Kotlin tasks, set the system property flag &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; (run the build with the argument &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt;).</source>
          <target state="translated">모든 Kotlin 태스크에 대한 캐싱을 사용하지 않으려면 시스템 특성 플래그 &lt;code&gt;kotlin.caching.enabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 (인수 &lt;code&gt;-Dkotlin.caching.enabled=false&lt;/code&gt; 로 빌드를 실행하십시오 ).</target>
        </trans-unit>
        <trans-unit id="c87cd2c2540cd75daead1d75a0422fd2e77c8c87" translate="yes" xml:space="preserve">
          <source>To download and install your declared dependencies during build time, the plugin manages its own installation of the &lt;a href=&quot;https://yarnpkg.com/lang/en/&quot;&gt;Yarn&lt;/a&gt; package manager.</source>
          <target state="translated">빌드시 선언 된 종속성을 다운로드하고 설치하기 위해 플러그인은 자체 &lt;a href=&quot;https://yarnpkg.com/lang/en/&quot;&gt;Yarn&lt;/a&gt; 패키지 관리자 설치를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="5fb61a8c9c6d11d2594861df1a6ec31dd25d8561" translate="yes" xml:space="preserve">
          <source>To eliminate the risk of such incompatibility being introduced by a change in &lt;strong&gt;non&lt;/strong&gt;-public API of a module, the public API inline functions are not allowed to use non-public-API declarations, i.e. &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;internal&lt;/code&gt; declarations and their parts, in their bodies.</source>
          <target state="translated">이러한 호환성이의 변화에 의해 도입되는 위험 제거하기 위해 &lt;strong&gt;비&lt;/strong&gt; 모듈의 -public API를 공개 API의 인라인 함수는 비공개-API 선언, 즉 사용 할 수 없습니다 &lt;code&gt;private&lt;/code&gt; 및 &lt;code&gt;internal&lt;/code&gt; 몸에, 선언과 그 부품 .</target>
        </trans-unit>
        <trans-unit id="2defcf6d3a2e2a6242b791d65c0bc5e944e6db59" translate="yes" xml:space="preserve">
          <source>To enable Kotlin OSGi support you need to include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; instead of regular Kotlin libraries. It is recommended to remove &lt;code&gt;kotlin-runtime&lt;/code&gt;, &lt;code&gt;kotlin-stdlib&lt;/code&gt; and &lt;code&gt;kotlin-reflect&lt;/code&gt; dependencies as &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; already contains all of them. You also should pay attention in case when external Kotlin libraries are included. Most regular Kotlin dependencies are not OSGi-ready, so you shouldn't use them and should remove them from your project.</source>
          <target state="translated">Kotlin OSGi 지원을 활성화하려면 일반 Kotlin 라이브러리 대신 &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 을 포함해야합니다 . &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 에 이미 모든 것이 포함되어 있으므로 &lt;code&gt;kotlin-runtime&lt;/code&gt; , &lt;code&gt;kotlin-stdlib&lt;/code&gt; 및 &lt;code&gt;kotlin-reflect&lt;/code&gt; 종속성 을 제거하는 것이 좋습니다 . 외부 Kotlin 라이브러리가 포함 된 경우에도주의해야합니다. 대부분의 일반적인 Kotlin 종속성은 OSGi를 지원하지 않으므로이를 사용해서는 안되며 프로젝트에서 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="cfb7bf1512d4d94303eeac356cb8f8007e5c3e6b" translate="yes" xml:space="preserve">
          <source>To enable hierarchical project structure support, add the following to your &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="translated">계층 적 프로젝트 구조 지원을 활성화하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eb3341f99fe9ebb8d9323c290933247870fe5f7" translate="yes" xml:space="preserve">
          <source>To enable incremental annotation processing, add this line to your &lt;code&gt;gradle.properties&lt;/code&gt; file:</source>
          <target state="translated">증분 주석 처리를 사용하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 파일에 다음 행을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="884726c9e2c8978bb4071d284e17e9fc6968d458" translate="yes" xml:space="preserve">
          <source>To enable the Kotlin/JS IR backend, set the key &lt;code&gt;kotlin.js.compiler=ir&lt;/code&gt; in your &lt;code&gt;gradle.properties&lt;/code&gt;, or pass the &lt;code&gt;IR&lt;/code&gt; compiler type to the &lt;code&gt;js&lt;/code&gt; function of your Gradle build script:</source>
          <target state="translated">코 틀린 / JS IR 백엔드를 사용하려면 키 설정 &lt;code&gt;kotlin.js.compiler=ir&lt;/code&gt; 당신에 &lt;code&gt;gradle.properties&lt;/code&gt; , 또는 통과 &lt;code&gt;IR&lt;/code&gt; 받는 컴파일러 유형을 &lt;code&gt;js&lt;/code&gt; 당신의 Gradle을 빌드 스크립트의 기능 :</target>
        </trans-unit>
        <trans-unit id="fcb5bed9cc9f628e32c3756f1cd602e0e77263b5" translate="yes" xml:space="preserve">
          <source>To enable the hierarchical project structure along with the use of platform-dependent libraries in shared source sets, just add the following to your &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="translated">공유 소스 세트에서 플랫폼 종속 라이브러리를 사용하는 것과 함께 계층 적 프로젝트 구조를 활성화하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 에 다음을 추가하기 만하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b57d628cf85360ad8bd4a7930a8905edba4ddfa" translate="yes" xml:space="preserve">
          <source>To enable the hierarchy structure support, add the following flag to your &lt;code&gt;gradle.properties&lt;/code&gt;.</source>
          <target state="translated">계층 구조 지원을 활성화하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 에 다음 플래그를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b35444a84ab9bdbb135466d1f0e26e106a076ce9" translate="yes" xml:space="preserve">
          <source>To enable the new JVM IR backend, specify an additional compiler option in your Gradle build script:</source>
          <target state="translated">새 JVM IR 백엔드를 활성화하려면 Gradle 빌드 스크립트에 추가 컴파일러 옵션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6dbd033e65a082aad28e5c2fcd37b8daf6829885" translate="yes" xml:space="preserve">
          <source>To enable this behavior you need to have &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; in your dependencies.</source>
          <target state="translated">이 동작을 사용하려면 종속성에 &lt;code&gt;kotlin-stdlib-jdk7&lt;/code&gt; 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="1b92d03d7ab798afc0052aefc2671aaf31759d48" translate="yes" xml:space="preserve">
          <source>To enable this, inline functions support &lt;em&gt;reified type parameters&lt;/em&gt;, so we can write something like this:</source>
          <target state="translated">이를 가능하게하기 위해 인라인 함수는 &lt;em&gt;reified type parameters를&lt;/em&gt; 지원 하므로 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c78de63fcfaed2f5ca9f53b2c3f6f324dab90107" translate="yes" xml:space="preserve">
          <source>To enable trailing commas in the IntelliJ IDEA formatter, go to &lt;strong&gt;Settings | Editor | Code Style | Kotlin&lt;/strong&gt;, open the &lt;strong&gt;Other&lt;/strong&gt; tab and select the &lt;strong&gt;Use trailing comma&lt;/strong&gt; option.</source>
          <target state="translated">IntelliJ IDEA 포맷터에서 후행 쉼표를 사용하려면 &lt;strong&gt;설정 | 편집자 | 코드 스타일 | Kotlin&lt;/strong&gt; 에서 &lt;strong&gt;기타&lt;/strong&gt; 탭을 열고 &lt;strong&gt;후행 쉼표 사용&lt;/strong&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="46b021f78d5fbc98904919e312b9537ed7727e54" translate="yes" xml:space="preserve">
          <source>To enable usage of platform-dependent libraries in shared source sets, add the following to your &lt;code&gt;gradle.properties&lt;/code&gt;:</source>
          <target state="translated">공유 소스 세트에서 플랫폼 종속 라이브러리를 사용하려면 &lt;code&gt;gradle.properties&lt;/code&gt; 에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="492e1dcfc287eacc3fa568b6d7af38123a5111c3" translate="yes" xml:space="preserve">
          <source>To enjoy the new features in your Kotlin projects, update Gradle to the &lt;a href=&quot;https://gradle.org/releases/&quot;&gt;latest version&lt;/a&gt;. Multiplatform projects require Gradle 6.0 or later, while other Kotlin projects work with Gradle 5.4 or later.</source>
          <target state="translated">Kotlin 프로젝트의 새로운 기능을 활용하려면 Gradle을 &lt;a href=&quot;https://gradle.org/releases/&quot;&gt;최신 버전으로&lt;/a&gt; 업데이트하세요 . 멀티 플랫폼 프로젝트에는 Gradle 6.0 이상이 필요하지만 다른 Kotlin 프로젝트는 Gradle 5.4 이상에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eda2f16c079bedddcf43889e299a4aeef442f108" translate="yes" xml:space="preserve">
          <source>To ensure consistency and meaningful behavior of the generated code, data classes have to fulfill the following requirements:</source>
          <target state="translated">생성 된 코드의 일관성과 의미있는 동작을 보장하기 위해 데이터 클래스는 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7d11890fbe59d29f5f955e489a75b4c6f2d6120" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch or a worksheet, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The code will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run sequentially, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="translated">스크래치 또는 워크 시트에서 각 특정 식을 평가 &lt;strong&gt;하려면 REPL 사용을&lt;/strong&gt; 선택 하여 실행합니다 . 코드는 &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt; 에서와 같은 방식으로 실행됩니다. 코드 라인은 순차적으로 실행되어 각 호출의 결과를 제공합니다. 나중에 해당 행에 표시된 이름 &lt;code&gt;res*&lt;/code&gt; 결과를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1915a0468ec60c04f19505bbcc82c60fb33083b3" translate="yes" xml:space="preserve">
          <source>To evaluate each particular expression in a scratch, run it with &lt;strong&gt;Use REPL&lt;/strong&gt; selected. The scratch will be executed the same way as in &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt;: the code lines will run subsequently, providing results of each call. You can later refer to the results by the names &lt;code&gt;res*&lt;/code&gt; shown in the corresponding lines.</source>
          <target state="translated">스크래치로 각 특정 표현식을 평가하려면 &lt;strong&gt;Use REPL을&lt;/strong&gt; 선택한 상태 에서 실행 &lt;strong&gt;하십시오&lt;/strong&gt; . 스크래치는 &lt;a href=&quot;#repl&quot;&gt;REPL&lt;/a&gt; 과 같은 방식으로 실행됩니다. 코드 라인은 이후에 실행되어 각 호출의 결과를 제공합니다. 나중에 해당 줄에 표시된 &lt;code&gt;res*&lt;/code&gt; 라는 이름으로 결과를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94918723afeacff1efa16ca8ab355a3ef8c400e9" translate="yes" xml:space="preserve">
          <source>To exclude default Kotlin libraries that comes as transitive dependencies you can use the following approach:</source>
          <target state="translated">전이 의존성으로 제공되는 기본 Kotlin 라이브러리를 제외하려면 다음 접근법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfe13659cc9bfcece191e4b8535987313b947937" translate="yes" xml:space="preserve">
          <source>To exclude the standard library from external libraries (notice that &quot;star exclusion&quot; works in Maven 3 only):</source>
          <target state="translated">외부 라이브러리에서 표준 라이브러리를 제외하려면 ( &quot;스타 제외&quot;는 Maven 3에서만 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="07af8a09aee36adfe68b2b0a1b6017022afe11a3" translate="yes" xml:space="preserve">
          <source>To facilitate this, Kotlin, as a statically typed programming language, uses a family of &lt;a href=&quot;#function-types&quot;&gt;function types&lt;/a&gt; to represent functions and provides a set of specialized language constructs, such as &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;lambda expressions&lt;/a&gt;.</source>
          <target state="translated">이를 용이하게하기 위해 Kotlin은 정적으로 유형이 지정된 프로그래밍 언어로서 &lt;a href=&quot;#function-types&quot;&gt;함수 유형&lt;/a&gt; 을 사용하여 함수 를 나타내고 &lt;a href=&quot;#lambda-expressions-and-anonymous-functions&quot;&gt;람다 식과&lt;/a&gt; 같은 특수 언어 구조 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6f3dc2eba2ee9bd47ab354f073c6c2fcb6b42573" translate="yes" xml:space="preserve">
          <source>To filter collections by negative conditions, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt;&lt;code&gt;filterNot()&lt;/code&gt;&lt;/a&gt;. It returns a list of elements for which the predicate yields &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">부정적인 조건으로 콜렉션을 필터링하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/filter-not&quot;&gt; &lt;code&gt;filterNot()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 술어가 &lt;code&gt;false&lt;/code&gt; 를 산출하는 요소의리스트를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="70215058b180f374e26cdfcf334f5153e68b392f" translate="yes" xml:space="preserve">
          <source>To find an intersection between two collections (elements present in both of them), use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt;&lt;code&gt;intersect()&lt;/code&gt;&lt;/a&gt;. To find collection elements not present in another collection, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt;&lt;code&gt;subtract()&lt;/code&gt;&lt;/a&gt;. Both these functions can be called in the infix form as well, for example, &lt;code&gt;a intersect b&lt;/code&gt;.</source>
          <target state="translated">두 컬렉션 (둘 다에있는 요소) 사이의 교차점을 찾으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/intersect&quot;&gt; &lt;code&gt;intersect()&lt;/code&gt; &lt;/a&gt; . 다른 컬렉션에없는 컬렉션 요소를 찾으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/subtract&quot;&gt; &lt;code&gt;subtract()&lt;/code&gt; &lt;/a&gt; . 이 두 함수는 모두 예를 들어 &lt;code&gt;a intersect b&lt;/code&gt; 와 같이 삽입 형식으로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c38d615ff41226343f4fd39898bb931c04a0136" translate="yes" xml:space="preserve">
          <source>To find out how to start using Kotlin for JavaScript, please refer to the &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;tutorials&lt;/a&gt;.</source>
          <target state="translated">JavaScript에 Kotlin을 사용하는 방법을 알아 보려면 &lt;a href=&quot;../tutorials/javascript/kotlin-to-javascript/kotlin-to-javascript&quot;&gt;학습서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1b3025669d14b930eb88a22f129712b45d175de" translate="yes" xml:space="preserve">
          <source>To fix this, we have to declare objects of type &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt;, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there's no value added by the more complex type. But the compiler does not know that.</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;Source&amp;lt;? extends Object&amp;gt;&lt;/code&gt; 유형의 객체를 선언해야합니다 . 우리는 이전과 같은 변수에 대해 동일한 메소드를 모두 호출 할 수 있으므로 더 복잡한 유형에 의해 추가 된 값이 없기 때문에 의미가없는 Object&amp;gt;를 확장 합니다. 그러나 컴파일러는 그것을 모른다.</target>
        </trans-unit>
        <trans-unit id="1c3ed2671d90a6fccce18fdda0d98b5b6f90b98a" translate="yes" xml:space="preserve">
          <source>To generate documentation for Kotlin projects, use &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka&lt;/a&gt;; please refer to the &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; for configuration instructions. Dokka supports mixed-language projects and can generate output in multiple formats, including standard JavaDoc.</source>
          <target state="translated">Kotlin 프로젝트에 대한 문서를 생성하려면 &lt;a href=&quot;https://github.com/Kotlin/dokka&quot;&gt;Dokka를&lt;/a&gt; 사용하십시오 . 구성 지침 은 &lt;a href=&quot;https://github.com/Kotlin/dokka/blob/master/README.md#using-the-gradle-plugin&quot;&gt;Dokka README&lt;/a&gt; 를 참조하십시오 . Dokka는 혼합 언어 프로젝트를 지원하며 표준 JavaDoc을 포함하여 여러 형식으로 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da5847f3384d7a88c1adee061594df4e30b80fc" translate="yes" xml:space="preserve">
          <source>To get a seeded instance of random generator use &lt;a href=&quot;index&quot;&gt;Random&lt;/a&gt; function.</source>
          <target state="translated">랜덤 생성기의 시드 인스턴스를 얻으려면 &lt;a href=&quot;index&quot;&gt;랜덤&lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="90b0958330415ed4272efd87321aab58607e2589" translate="yes" xml:space="preserve">
          <source>To get a set containing all elements that are contained at least in one of these collections use &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;.</source>
          <target state="translated">이러한 컬렉션 중 하나 이상에 포함 된 모든 요소를 ​​포함하는 집합을 얻으려면 &lt;a href=&quot;union&quot;&gt;union을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7140ce3a3c50fbb1558d05a01072f6583b3697ee" translate="yes" xml:space="preserve">
          <source>To get a set containing all elements that are contained in both collections use &lt;a href=&quot;intersect&quot;&gt;intersect&lt;/a&gt;.</source>
          <target state="translated">두 컬렉션에 포함 된 모든 요소를 ​​포함하는 집합을 얻으려면 &lt;a href=&quot;intersect&quot;&gt;intersect를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ebdc0fb5ea1aabe15241a38dfb2375efd0bbb23" translate="yes" xml:space="preserve">
          <source>To get started, first download and install the latest version of &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">시작하려면 먼저 최신 버전의 &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA를&lt;/a&gt; 다운로드하여 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="004366928e90c7cdc731785eae1ab45f89c2dc1a" translate="yes" xml:space="preserve">
          <source>To get started, install a recent version of IntelliJ IDEA. Kotlin is bundled with IntelliJ IDEA starting from version 15. You can download the free &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; from &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt;.</source>
          <target state="translated">시작하려면 최신 버전의 IntelliJ IDEA를 설치하십시오. Kotlin은 버전 15부터 IntelliJ IDEA와 번들로 제공됩니다 . &lt;a href=&quot;http://www.jetbrains.com&quot;&gt;JetBrains&lt;/a&gt; 에서 무료 &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;Community Edition&lt;/a&gt; 을 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19a5979eba55c06eb5e8ffc62a4e177ce4f4ab4b" translate="yes" xml:space="preserve">
          <source>To get started, install the latest version of &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA&lt;/a&gt;.</source>
          <target state="translated">시작하려면 최신 버전의 &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA를&lt;/a&gt; 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="07b8c3b410c109db3527c629a1fbed9127661a08" translate="yes" xml:space="preserve">
          <source>To get started, install the latest version of &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA&lt;/a&gt;. The tutorial is applicable to both IntelliJ IDEA Community Edition and the Ultimate Edition.</source>
          <target state="translated">시작하려면 최신 버전의 &lt;a href=&quot;http://www.jetbrains.com/idea/download/index.html&quot;&gt;IntelliJ IDEA를&lt;/a&gt; 설치하십시오 . 이 튜토리얼은 IntelliJ IDEA Community Edition과 Ultimate Edition 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="94da0b750a9691183cd3aef14a71ddcee794f57c" translate="yes" xml:space="preserve">
          <source>To get the Kotlin class corresponding to a Java class, use the &lt;code&gt;.kotlin&lt;/code&gt; extension property:</source>
          <target state="translated">Java 클래스에 해당하는 Kotlin 클래스를 가져 오려면 &lt;code&gt;.kotlin&lt;/code&gt; 확장 등록 정보를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="03f3657fbd7420151d7cbee074c2f638231666dd" translate="yes" xml:space="preserve">
          <source>To get the pointer, &lt;code&gt;.cstr&lt;/code&gt; should be allocated in native memory, e.g.</source>
          <target state="translated">포인터를 얻으려면 &lt;code&gt;.cstr&lt;/code&gt; 을 기본 메모리에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="99f419fbdc788d8ad3548e218e2e9d1a31e1f757" translate="yes" xml:space="preserve">
          <source>To get the specified number of elements starting from the first, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt;&lt;code&gt;take()&lt;/code&gt;&lt;/a&gt; function. For getting the last elements, use &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt;&lt;code&gt;takeLast()&lt;/code&gt;&lt;/a&gt;. When called with a number larger than the collection size, both functions return the whole collection.</source>
          <target state="translated">처음부터 지정된 수의 요소를 가져 오려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take&quot;&gt; &lt;code&gt;take()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 마지막 요소를 얻으려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/take-last&quot;&gt; &lt;code&gt;takeLast()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 . 컬렉션 크기보다 큰 숫자로 호출하면 두 함수가 전체 컬렉션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="60dea6b3d906532fe9c4d5b9272538f57b1ae918" translate="yes" xml:space="preserve">
          <source>To get the value of this duration expressed in a particular &lt;a href=&quot;../-duration-unit/index#kotlin.time.DurationUnit&quot;&gt;duration units&lt;/a&gt; use the functions &lt;a href=&quot;to-int&quot;&gt;toInt&lt;/a&gt;, &lt;a href=&quot;to-long&quot;&gt;toLong&lt;/a&gt;, and &lt;a href=&quot;to-double&quot;&gt;toDouble&lt;/a&gt; or the properties &lt;a href=&quot;in-hours&quot;&gt;inHours&lt;/a&gt;, &lt;a href=&quot;in-minutes&quot;&gt;inMinutes&lt;/a&gt;, &lt;a href=&quot;in-seconds&quot;&gt;inSeconds&lt;/a&gt;, &lt;a href=&quot;in-nanoseconds&quot;&gt;inNanoseconds&lt;/a&gt;, and so on.</source>
          <target state="translated">특정 &lt;a href=&quot;../-duration-unit/index#kotlin.time.DurationUnit&quot;&gt;기간 단위로&lt;/a&gt; 표현 된이 기간의 값을 가져 오려면 &lt;a href=&quot;to-int&quot;&gt;toInt&lt;/a&gt; , &lt;a href=&quot;to-long&quot;&gt;toLong&lt;/a&gt; 및 &lt;a href=&quot;to-double&quot;&gt;toDouble&lt;/a&gt; 함수 또는 &lt;a href=&quot;in-hours&quot;&gt;inHours&lt;/a&gt; , &lt;a href=&quot;in-minutes&quot;&gt;inMinutes&lt;/a&gt; , &lt;a href=&quot;in-seconds&quot;&gt;inSeconds&lt;/a&gt; , &lt;a href=&quot;in-nanoseconds&quot;&gt;inNanoseconds&lt;/a&gt; 등 의 속성 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7c882c6a497d3655af358c59177443fd4abbe265" translate="yes" xml:space="preserve">
          <source>To handle this case, you can mark the property with the &lt;code&gt;lateinit&lt;/code&gt; modifier:</source>
          <target state="translated">이 경우를 처리하기 위해 &lt;code&gt;lateinit&lt;/code&gt; 수정자를 사용 하여 특성을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f184ea8aba5991e48a265c7b37cae24a3a756b30" translate="yes" xml:space="preserve">
          <source>To have a dependency-injected implementation generated for the type, annotate it with &lt;code&gt;@Component&lt;/code&gt;. The generated class will have the name of this type prepended with Dagger, like &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; below:</source>
          <target state="translated">유형에 대해 의존성 주입 구현을 생성하려면 &lt;code&gt;@Component&lt;/code&gt; 로 주석을 답니다 . 생성 된 클래스의 이름은 아래 &lt;code&gt;DaggerCoffeeShop&lt;/code&gt; 과 같이 Dagger가 앞에 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="6137f5bb9dbee2ae27bbe242d627fd31058aa51b" translate="yes" xml:space="preserve">
          <source>To have the framework header written without generics, add the flag to the compiler config:</source>
          <target state="translated">제네릭없이 프레임 워크 헤더를 작성하려면 컴파일러 구성에 플래그를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3ecd027b7452270691e59717236b30ee0ecf96d4" translate="yes" xml:space="preserve">
          <source>To help removing deprecated API gradually, the property &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;level&lt;/a&gt; could be used. Usually a gradual phase-out goes through the &quot;warning&quot;, then &quot;error&quot;, then &quot;hidden&quot; or &quot;removed&quot; stages:</source>
          <target state="translated">더 이상 사용되지 않는 API를 점진적으로 제거하기 위해 특성 &lt;a href=&quot;level#kotlin.Deprecated%24level&quot;&gt;레벨&lt;/a&gt; 을 사용할 수 있습니다. 일반적으로 점진적인 단계적 종료는 &quot;경고&quot;, &quot;오류&quot;, &quot;숨김&quot;또는 &quot;제거&quot;단계를 거칩니다.</target>
        </trans-unit>
        <trans-unit id="8ad141ec6c84758415e74b2e6cc38c9b0d8e26a6" translate="yes" xml:space="preserve">
          <source>To help you become more familiar with scripting in Kotlin, we&amp;rsquo;ve prepared a &lt;a href=&quot;https://github.com/Kotlin/kotlin-script-examples&quot;&gt;project with examples&lt;/a&gt;. It contains examples of the standard scripts (&lt;code&gt;*.main.kts&lt;/code&gt;) and examples of uses of the Kotlin Scripting API and custom script definitions. Please give it a try and share your feedback using our &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;issue tracker&lt;/a&gt;.</source>
          <target state="translated">Kotlin의 스크립팅에 더 익숙해 질 수 있도록 &lt;a href=&quot;https://github.com/Kotlin/kotlin-script-examples&quot;&gt;예제가 포함&lt;/a&gt; 된 프로젝트를 준비했습니다 . 여기에는 표준 스크립트 ( &lt;code&gt;*.main.kts&lt;/code&gt; )의 예와 Kotlin Scripting API 및 커스텀 스크립트 정의의 사용 예가 포함되어 있습니다 . 한 번 사용해보고 &lt;a href=&quot;https://youtrack.jetbrains.com/issues/KT&quot;&gt;문제 추적기를&lt;/a&gt; 사용하여 피드백을 공유하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc69b946016a4baffee197957d550f5dda1d3fad" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your case, we'll describe them in detail and provide usage recommendations. Technically, functions are interchangeable in many cases, so the examples show the conventions that define the common usage style.</source>
          <target state="translated">귀하의 사례에 적합한 스코프 기능을 선택하는 데 도움을 드리기 위해 해당 기능을 자세히 설명하고 사용 권장 사항을 제공합니다. 기술적으로 함수는 여러 경우에 상호 교환이 가능하므로 예제는 일반적인 사용 스타일을 정의하는 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2dc9569e913e0a78f05976a0042b79260268c830" translate="yes" xml:space="preserve">
          <source>To help you choose the right scope function for your purpose, we provide the table of key differences between them.</source>
          <target state="translated">목적에 맞는 올바른 스코프 기능을 선택할 수 있도록 주요 차이점 표를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f98ff3616d6d9c52fa18df7c42e1d78d8ba28ec6" translate="yes" xml:space="preserve">
          <source>To help you start using the new features of &lt;a href=&quot;#kotlin-multiplatform&quot;&gt;Kotlin multiplatform&lt;/a&gt; in existing projects, we publish the &lt;a href=&quot;migrating-multiplatform-project-to-14&quot;&gt;migration guide for multiplatform projects&lt;/a&gt;.</source>
          <target state="translated">기존 프로젝트에서 &lt;a href=&quot;#kotlin-multiplatform&quot;&gt;Kotlin 멀티 플랫폼&lt;/a&gt; 의 새로운 기능을 사용할 수 있도록 &lt;a href=&quot;migrating-multiplatform-project-to-14&quot;&gt;멀티 플랫폼 프로젝트 용 마이그레이션 가이드를&lt;/a&gt; 게시합니다 .</target>
        </trans-unit>
        <trans-unit id="3bc65688182a6a956a218fa3a16959313490f82c" translate="yes" xml:space="preserve">
          <source>To import a Kotlin/Native module in an existing Xcode project:</source>
          <target state="translated">기존 Xcode 프로젝트에서 Kotlin / Native 모듈을 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="2c68721c967bf9f85180daa4363543c530c2e36a" translate="yes" xml:space="preserve">
          <source>To import this module in Kotlin, you have to write two Kotlin source files:</source>
          <target state="translated">Kotlin에서이 모듈을 가져 오려면 두 개의 Kotlin 소스 파일을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c82d374c6d84bb2e142c6de52f1cf3dcc0306ae" translate="yes" xml:space="preserve">
          <source>To improve the behavior in such cases, Kotlin 1.3 introduces experimental mechanism called &lt;em&gt;contracts&lt;/em&gt;.</source>
          <target state="translated">이러한 경우 동작을 개선하기 위해 Kotlin 1.3에는 &lt;em&gt;계약&lt;/em&gt; 이라는 실험 메커니즘이 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2d833a47bb81067eedcf42dfefd225e6c4221741" translate="yes" xml:space="preserve">
          <source>To improve the speed of builds that use kapt, you can enable the &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; for kapt tasks. Using the worker API lets Gradle run independent annotation processing tasks from a single project in parallel, which in some cases significantly decreases the execution time. However, running kapt with Gradle worker API enabled can result in increased memory consumption due to parallel execution.</source>
          <target state="translated">kapt를 사용하는 빌드 속도를 향상시키기 위해 &lt;a href=&quot;https://guides.gradle.org/using-the-worker-api/&quot;&gt;Gradle worker API&lt;/a&gt; 를 kapt 작업에 사용할 수 있습니다. 작업자 API를 사용하면 Gradle이 단일 프로젝트에서 독립적 인 주석 처리 작업을 병렬로 실행할 수 있으므로 경우에 따라 실행 시간이 크게 단축됩니다. 그러나 Gradle worker API가 활성화 된 상태에서 kapt를 실행하면 병렬 실행으로 인해 메모리 소비가 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcf0aa09f38966cb24f42a40a86491a1cfa33e5" translate="yes" xml:space="preserve">
          <source>To improve the speed of object allocation, we now offer the &lt;a href=&quot;https://github.com/microsoft/mimalloc&quot;&gt;mimalloc&lt;/a&gt; memory allocator as an alternative to the system allocator. mimalloc works up to two times faster on some benchmarks. Currently, the usage of mimalloc in Kotlin/Native is experimental; you can switch to it using the &lt;code&gt;-Xallocator=mimalloc&lt;/code&gt; compiler option.</source>
          <target state="translated">객체 할당 속도를 개선하기 위해 이제 시스템 할당 자 대신 &lt;a href=&quot;https://github.com/microsoft/mimalloc&quot;&gt;mimalloc&lt;/a&gt; 메모리 할당자를 제공합니다 . mimalloc은 일부 벤치 마크에서 최대 2 배 더 빠르게 작동합니다. 현재 Kotlin / Native에서 mimalloc 사용은 실험적입니다. &lt;code&gt;-Xallocator=mimalloc&lt;/code&gt; 컴파일러 옵션을 사용하여 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="068fdab62a2284b03b98013c61f3a69a95e920c0" translate="yes" xml:space="preserve">
          <source>To improve the times of incremental builds with kapt, it can use the Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;compile avoidance&lt;/a&gt;. With compile avoidance enabled, Gradle can skip annotation processing when rebuilding a project. Particularly, annotation processing is skipped when:</source>
          <target state="translated">kapt를 사용한 증분 빌드 시간을 향상시키기 위해 Gradle &lt;a href=&quot;https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance&quot;&gt;컴파일 방지를&lt;/a&gt; 사용할 수 있습니다 . 컴파일 회피를 사용하면 Gradle은 프로젝트를 다시 빌드 할 때 주석 처리를 건너 뛸 수 있습니다. 특히 다음과 같은 경우 주석 처리를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ccaf04d3ae02444add2457f45cff16183d2e8aae" translate="yes" xml:space="preserve">
          <source>To include &lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; to a gradle project:</source>
          <target state="translated">&lt;code&gt;kotlin-osgi-bundle&lt;/code&gt; 을 gradle 프로젝트에 포함 시키 려면 :</target>
        </trans-unit>
        <trans-unit id="9a00cb17d9820854213a41158d7418355d4b5911" translate="yes" xml:space="preserve">
          <source>To include Java sources in the compilations of a JVM target, or to apply a Gradle plugin that requires the &lt;code&gt;java&lt;/code&gt; plugin to work, you need to explicitly enable Java support for the target:</source>
          <target state="translated">JVM 대상 컴파일에 Java 소스를 포함 시키거나 &lt;code&gt;java&lt;/code&gt; 플러그인이 작동해야하는 Gradle 플러그인을 적용하려면 대상에 대한 Java 지원을 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1dd53e422fa19594e216fec42e7a9db9831a316" translate="yes" xml:space="preserve">
          <source>To include Java sources in the compilations of the JVM target, explicitly enable the Java language support for the target:</source>
          <target state="translated">JVM 대상의 컴파일에 Java 소스를 포함하려면 대상에 대한 Java 언어 지원을 명시 적으로 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7860a6aaa1b42e9447caa0f0a8321e9d88a64124" translate="yes" xml:space="preserve">
          <source>To include the Kotlin OSGi bundle to a Maven project:</source>
          <target state="translated">Kotlin OSGi 번들을 Maven 프로젝트에 포함 시키려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="077956d227f2aa6078ddf39bc8e4e3d8b94732b8" translate="yes" xml:space="preserve">
          <source>To inspect the bookkeeping details of the library</source>
          <target state="translated">라이브러리의 부기 세부 정보를 검사하려면</target>
        </trans-unit>
        <trans-unit id="8c24292aeea43558882c36e9ecc631d06e7467b2" translate="yes" xml:space="preserve">
          <source>To install the library to the default location use</source>
          <target state="translated">라이브러리를 기본 위치에 설치하려면</target>
        </trans-unit>
        <trans-unit id="7ee91ac3540f1dbe83a27b16835cca72eb9b4a6e" translate="yes" xml:space="preserve">
          <source>To interop with platforms, use platform-specific versions of Kotlin. &lt;strong&gt;Platform-specific versions of Kotlin&lt;/strong&gt; (Kotlin/JVM, Kotlin/JS, Kotlin/Native) include extensions to the Kotlin language, and platform-specific libraries and tools.</source>
          <target state="translated">플랫폼과 상호 운용하려면 플랫폼 별 Kotlin 버전을 사용하세요. &lt;strong&gt;Kotlin의 플랫폼 별 버전&lt;/strong&gt; (Kotlin / JVM, Kotlin / JS, Kotlin / Native)에는 Kotlin 언어에 대한 확장과 플랫폼 별 라이브러리 및 도구가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="24f6533d6772f8462ed0f43822595fdca8aa6a25" translate="yes" xml:space="preserve">
          <source>To iterate a number range which does not include its end element, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt;&lt;code&gt;until&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">끝 요소를 포함하지 않는 숫자 범위를 반복하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/until&quot;&gt; &lt;code&gt;until&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b66d0a5358d7d3838074096ed7a34f595b79a041" translate="yes" xml:space="preserve">
          <source>To iterate numbers in reverse order, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt;&lt;code&gt;downTo&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;..&lt;/code&gt;.</source>
          <target state="translated">숫자를 역순으로 반복하려면 &lt;code&gt;..&lt;/code&gt; 대신 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.ranges/down-to&quot;&gt; &lt;code&gt;downTo&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de33c40021cd7f879768e42f24ff227ac1b5363" translate="yes" xml:space="preserve">
          <source>To iterate over a range of numbers, use a &lt;a href=&quot;ranges&quot;&gt;range expression&lt;/a&gt;:</source>
          <target state="translated">숫자 범위를 반복하려면 &lt;a href=&quot;ranges&quot;&gt;범위 표현식을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d257341caadaa79961255fe9fe80098ff7724e64" translate="yes" xml:space="preserve">
          <source>To keep certain declarations from elimination, add the &lt;code&gt;dceTask&lt;/code&gt; block to your Gradle build script and list the declarations as arguments of the &lt;code&gt;keep&lt;/code&gt; function. An argument must be the declaration's fully qualified name with the module name as a prefix: &lt;code&gt;moduleName.dot.separated.package.name.declarationName&lt;/code&gt;</source>
          <target state="translated">특정 선언이 제거되지 않도록하려면 Gradle 빌드 스크립트에 &lt;code&gt;dceTask&lt;/code&gt; 블록을 추가 하고 선언을 &lt;code&gt;keep&lt;/code&gt; 함수의 인수로 나열합니다 . 인수는 모듈 이름을 접두사로 사용하는 선언의 정규화 된 이름이어야합니다. &lt;code&gt;moduleName.dot.separated.package.name.declarationName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa43f6beeaee705b410de36d25fd9dd87b9df82" translate="yes" xml:space="preserve">
          <source>To learn more about &lt;code&gt;.yarnrc&lt;/code&gt;, please visit the &lt;a href=&quot;https://classic.yarnpkg.com/en/docs/yarnrc/&quot;&gt;official Yarn documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.yarnrc&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;https://classic.yarnpkg.com/en/docs/yarnrc/&quot;&gt;공식 Yarn 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d62030b7e0428ad66c98aff7d08903586325814" translate="yes" xml:space="preserve">
          <source>To learn more about how to write declarations, please refer to the &lt;a href=&quot;../../reference/js-interop&quot;&gt;&quot;Calling JavaScript from Kotlin&quot;&lt;/a&gt; section of the Kotlin documentation.</source>
          <target state="translated">선언 작성 방법에 대한 자세한 내용은 Kotlin 문서의 &lt;a href=&quot;../../reference/js-interop&quot;&gt;'Kotlin에서 자바 스크립트 호출'&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="3fab971a68e73bd96c01ec9495b8f9cd81816592" translate="yes" xml:space="preserve">
          <source>To learn more about the &lt;code&gt;kotlinx.html&lt;/code&gt; library, check out the &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Getting-started&quot;&gt;GitHub Wiki&lt;/a&gt;, where you can find more information about how to &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/DOM-trees&quot;&gt;create elements&lt;/a&gt; without adding them to the DOM, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Events&quot;&gt;binding to events&lt;/a&gt; like &lt;code&gt;onClick&lt;/code&gt;, and examples on how to &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Elements-CSS-classes&quot;&gt;apply CSS classes&lt;/a&gt; to your HTML elements, to name just a few.</source>
          <target state="translated">&lt;code&gt;kotlinx.html&lt;/code&gt; 라이브러리 에 대해 자세히 알아 보려면 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Getting-started&quot;&gt;GitHub Wiki를&lt;/a&gt; 확인하세요. 여기서 DOM에 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/DOM-trees&quot;&gt;요소&lt;/a&gt; 를 추가하지 않고 요소 를 만드는 방법 , &lt;code&gt;onClick&lt;/code&gt; 과 같은 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Events&quot;&gt;이벤트에 바인딩&lt;/a&gt; 하는 방법, &lt;a href=&quot;https://github.com/Kotlin/kotlinx.html/wiki/Elements-CSS-classes&quot;&gt;CSS 클래스&lt;/a&gt; 를 적용 하는 방법에 대한 예에 대한 자세한 정보를 찾을 수 있습니다. 몇 가지 예를 들면 HTML 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ab2aa40b87301860aff15bd0eb5882ddd4d76c11" translate="yes" xml:space="preserve">
          <source>To learn more about the available features in the new Kotlin/JS IR compiler and how to try it for your project, visit the &lt;a href=&quot;js-ir-compiler&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">새로운 Kotlin / JS IR 컴파일러에서 사용 가능한 기능과 프로젝트에서 사용하는 방법에 대해 자세히 알아 보려면 &lt;a href=&quot;js-ir-compiler&quot;&gt;문서를&lt;/a&gt; 방문하세요 .</target>
        </trans-unit>
        <trans-unit id="04b14d4042668c912610980566cf53b4151424a6" translate="yes" xml:space="preserve">
          <source>To learn more about the different kinds of JS module and the distinctions between them, see &lt;a href=&quot;https://www.davidbcalhoun.com/2014/what-is-amd-commonjs-and-umd/&quot;&gt;this&lt;/a&gt; article.</source>
          <target state="translated">다양한 종류의 JS 모듈과 그 차이점에 대해 자세히 알아 보려면 &lt;a href=&quot;https://www.davidbcalhoun.com/2014/what-is-amd-commonjs-and-umd/&quot;&gt;이&lt;/a&gt; 기사를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5e2d5b6189babe68891c536472cd400762b1bb85" translate="yes" xml:space="preserve">
          <source>To let the API users update their modules accordingly (remove the annotations from their code and recompile), mark the annotations as &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-deprecated/index&quot;&gt;&lt;code&gt;@Deprecated&lt;/code&gt;&lt;/a&gt; and provide the explanation in the deprecation message.</source>
          <target state="translated">API 사용자가 그에 따라 모듈을 업데이트 할 수 있도록하려면 (코드에서 주석을 제거하고 다시 컴파일) 주석을 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-deprecated/index&quot;&gt; &lt;code&gt;@Deprecated&lt;/code&gt; &lt;/a&gt; 로 표시 하고 지원 중단 메시지에 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="85b39f1ed38fbcb7ba7bf0ac158a30f9c142955c" translate="yes" xml:space="preserve">
          <source>To link to a library use the &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; flag. For example:</source>
          <target state="translated">라이브러리에 링크하려면 &lt;code&gt;-library &amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;-l &amp;lt;name&amp;gt;&lt;/code&gt; 플래그를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d43d923015e08ab71364c00b4d2a9fc351e1604" translate="yes" xml:space="preserve">
          <source>To link to another element (class, method, property or parameter), simply put its name in square brackets:</source>
          <target state="translated">다른 요소 (클래스, 메서드, 속성 또는 매개 변수)에 연결하려면 해당 이름을 대괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="04523bc3328b0c5397fbfdee046da0685d0fae03" translate="yes" xml:space="preserve">
          <source>To list library contents:</source>
          <target state="translated">라이브러리 내용을 나열하려면</target>
        </trans-unit>
        <trans-unit id="94d09a96d064da30ca57cf8cdc79fa8ea3d9ad9e" translate="yes" xml:space="preserve">
          <source>To maintain indentation in multiline strings, use &lt;code&gt;trimIndent&lt;/code&gt; when the resulting string does not require any internal indentation, or &lt;code&gt;trimMargin&lt;/code&gt; when internal indentation is required:</source>
          <target state="translated">여러 줄 문자열에서 들여 쓰기를 사용 유지하기 위해 &lt;code&gt;trimIndent&lt;/code&gt; 을 결과 문자열은 내부 들여 쓰기를 요구하거나하지 않는 경우 &lt;code&gt;trimMargin&lt;/code&gt; 를 내부 들여 쓰기가 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="e12b1be94182f1503207932a398c53d947b434c0" translate="yes" xml:space="preserve">
          <source>To make Kotlin APIs work in Java we generate &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; as &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; for covariantly defined &lt;code&gt;Box&lt;/code&gt; (or &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; for contravariantly defined &lt;code&gt;Foo&lt;/code&gt;) when it appears &lt;em&gt;as a parameter&lt;/em&gt;. When it's a return value, we don't generate wildcards, because otherwise Java clients will have to deal with them (and it's against the common Java coding style). Therefore, the functions from our example are actually translated as follows:</source>
          <target state="translated">Kotlin API를 Java에서 작동하게하려면 &lt;code&gt;Box&amp;lt;Super&amp;gt;&lt;/code&gt; 를 &lt;code&gt;Box&amp;lt;? extends Super&amp;gt;&lt;/code&gt; covariantly 정의에 대한 &lt;code&gt;Box&lt;/code&gt; (또는 &lt;code&gt;Foo&amp;lt;? super Bar&amp;gt;&lt;/code&gt; contravariantly 정의에 대한 &lt;code&gt;Foo&lt;/code&gt; )가 나타날 때 &lt;em&gt;매개 변수로&lt;/em&gt; . 반환 값일 때는 와일드 카드를 생성하지 않습니다. 그렇지 않으면 Java 클라이언트가 처리해야합니다 (그리고 일반적인 Java 코딩 스타일에 위배됩니다). 따라서이 예제의 함수는 실제로 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1aa213848d1f87a73fda0915bb91fbde0ccc8072" translate="yes" xml:space="preserve">
          <source>To make reading the input in competitive programming tasks like this more concise, you can have the following list of helper input-reading functions:</source>
          <target state="translated">이와 같이 경쟁력있는 프로그래밍 작업에서 입력을보다 간결하게 작성하려면 다음과 같은 도우미 입력 판독 기능 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9375e20c00ff62d1ddedd02075c0f25b2cc018c0" translate="yes" xml:space="preserve">
          <source>To make the compiler do this, we need to mark the &lt;code&gt;lock()&lt;/code&gt; function with the &lt;code&gt;inline&lt;/code&gt; modifier:</source>
          <target state="translated">컴파일러에서이를 수행하려면 &lt;code&gt;lock()&lt;/code&gt; 함수를 &lt;code&gt;inline&lt;/code&gt; 수정 자로 표시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27c1b74df654000c9e62d4a18ccabc7efde139c9" translate="yes" xml:space="preserve">
          <source>To make the compiler start controlling scopes we only have to annotate the types of all receivers used in the DSL with the same marker annotation. For instance, for HTML Builders we declare an annotation &lt;code&gt;@HTMLTagMarker&lt;/code&gt;:</source>
          <target state="translated">컴파일러가 범위 제어를 시작하게하려면 DSL에 사용 된 모든 수신기 유형에 동일한 표식 주석을 달기 만하면됩니다. 예를 들어 HTML 빌더의 경우 &lt;code&gt;@HTMLTagMarker&lt;/code&gt; 주석을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="e99e5ceb142555c1890edb23ec1da5ac2677e92d" translate="yes" xml:space="preserve">
          <source>To make the library complete we should write some tests, but we have three independent implementations and it is a waste of time to write duplicate tests for each one.</source>
          <target state="translated">라이브러리를 완성하려면 몇 가지 테스트를 작성해야하지만 세 개의 독립적 인 구현이 있으며 각각에 대해 중복 테스트를 작성하는 것은 시간 낭비입니다.</target>
        </trans-unit>
        <trans-unit id="28e2c451a4401d778b575e3ce27ab0a72af2a6e7" translate="yes" xml:space="preserve">
          <source>To make the library complete we should write some tests, but we have three independent implementations and it is a waste of time to write duplicate tests for each one. The good thing about common code is that it can be covered with common tests, which later are compiled and executed on &lt;em&gt;every&lt;/em&gt; platform. All the bits for testing are already generated by the project Wizard.</source>
          <target state="translated">라이브러리를 완성하려면 몇 가지 테스트를 작성해야하지만 3 개의 독립적 인 구현이 있으며 각 테스트마다 중복 테스트를 작성하는 것은 시간 낭비입니다. 공통 코드에 대한 좋은 점은 공통 테스트로 다룰 수 있다는 것입니다.이 테스트는 나중에 &lt;em&gt;모든&lt;/em&gt; 플랫폼 에서 컴파일되고 실행됩니다 . 테스트를위한 모든 비트는 이미 프로젝트 마법사에 의해 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="1949bde1af891823df088c0dd9e543cd71be0c91" translate="yes" xml:space="preserve">
          <source>To make the users of annotations &lt;code&gt;@OptIn&lt;/code&gt; and &lt;code&gt;@RequiresOptIn&lt;/code&gt; aware of their experimental status, the compiler raises warnings when compiling the code with these annotations:</source>
          <target state="translated">&lt;code&gt;@OptIn&lt;/code&gt; 및 &lt;code&gt;@RequiresOptIn&lt;/code&gt; 주석 사용자가 실험 상태를 인식 하도록하기 위해 컴파일러는 다음 주석으로 코드를 컴파일 할 때 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="942a849d5ea3976160d1c1dbff01132e386b6a13" translate="yes" xml:space="preserve">
          <source>To make this work, we should</source>
          <target state="translated">이 작업을 수행하려면</target>
        </trans-unit>
        <trans-unit id="c619d626cb3800fca0e85916c367e7240cf3f525" translate="yes" xml:space="preserve">
          <source>To make unsigned integers easier to use, Kotlin provides an ability to tag an integer literal with a suffix indicating a specific unsigned type (similarly to Float/Long):</source>
          <target state="translated">부호없는 정수를보다 쉽게 ​​사용할 수 있도록 Kotlin은 부호없는 특정 유형 (Float / Long과 유사)을 나타내는 접미어로 정수 리터럴에 태그를 지정하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c98bfc3140cd7bdf91e45deb511c924efadd9a92" translate="yes" xml:space="preserve">
          <source>To make your builds faster, you can enable incremental compilation for Maven (supported since Kotlin 1.1.2). In order to do that, define the &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; property:</source>
          <target state="translated">보다 빠른 빌드를 위해 Maven에 대한 증분 컴파일을 활성화 할 수 있습니다 (Kotlin 1.1.2부터 지원). 그렇게하려면 &lt;code&gt;kotlin.compiler.incremental&lt;/code&gt; 속성을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2895b62f37c528355f502b2144c9b302d5145a42" translate="yes" xml:space="preserve">
          <source>To manually compile the application call the &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;downloaded&lt;/a&gt; compiler and generate a &lt;code&gt;hello.kexe&lt;/code&gt; (Linux and macOS) or &lt;code&gt;hello.exe&lt;/code&gt; (Windows) binary file:</source>
          <target state="translated">애플리케이션을 수동으로 컴파일하려면 &lt;a href=&quot;https://github.com/JetBrains/kotlin/releases&quot;&gt;다운로드 한&lt;/a&gt; 컴파일러를 호출하고 &lt;code&gt;hello.kexe&lt;/code&gt; (Linux 및 macOS) 또는 &lt;code&gt;hello.exe&lt;/code&gt; (Windows) 이진 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="b4f6cb9f672ef57783a6ef29cd59db4418575608" translate="yes" xml:space="preserve">
          <source>To mark an API element as experimental, annotate its declaration with your experimental marker annotation:</source>
          <target state="translated">API 요소를 실험으로 표시하려면 실험 마커 주석으로 선언에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="cb122bda7a14229a5d1edd9ff546275f891b9d77" translate="yes" xml:space="preserve">
          <source>To merge two collections into one, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt;&lt;code&gt;union()&lt;/code&gt;&lt;/a&gt; function. It can be used in the infix form &lt;code&gt;a union b&lt;/code&gt;. Note that for ordered collections the order of the operands is important: in the resulting collection, the elements of the first operand go before the elements of the second.</source>
          <target state="translated">두 컬렉션을 하나로 병합하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/union&quot;&gt; &lt;code&gt;union()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 접두사 형태 &lt;code&gt;a union b&lt;/code&gt; 로 사용될 수 있습니다 . 정렬 된 컬렉션의 경우 피연산자의 순서가 중요합니다. 결과 컬렉션에서는 첫 번째 피연산자의 요소가 두 번째 피연산자의 요소보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="44d5c2b36c84b91934a121e2f5ace6e150a12f1e" translate="yes" xml:space="preserve">
          <source>To mitigate such issues, functions using inline classes are &lt;em&gt;mangled&lt;/em&gt; by adding some stable hashcode to the function name. Therefore, &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; will be represented as &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt;, which solves the clash problem.</source>
          <target state="translated">이러한 문제를 완화하기 위해 인라인 클래스를 사용 하는 함수는 함수 이름에 안정적인 해시 코드를 추가하여 &lt;em&gt;엉망&lt;/em&gt; 입니다. 따라서 &lt;code&gt;fun compute(x: UInt)&lt;/code&gt; 는 &lt;code&gt;public final void compute-&amp;lt;hashcode&amp;gt;(int x)&lt;/code&gt; 로 표시되어 충돌 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="214eeb66f4dd4d1fbd2d9b25b399283f63731ef6" translate="yes" xml:space="preserve">
          <source>To mitigate this problem for the users of such bytecode processing tools, we&amp;rsquo;ve added a command-line option (&lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt;) that tells the compiler to generate more Java-like bytecode for such constructs. Here &lt;code&gt;MODE&lt;/code&gt; is one of:</source>
          <target state="translated">이러한 바이트 코드 처리 도구 사용자에게이 문제를 완화하기 위해 컴파일러에 이러한 구문에 대해 더 많은 Java와 유사한 바이트 코드를 생성하도록 지시 하는 명령 행 옵션 ( &lt;code&gt;-Xnormalize-constructor-calls=MODE&lt;/code&gt; )을 추가했습니다. 여기서 &lt;code&gt;MODE&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d6aa0bdd277639961899c3f20d2977a244b12631" translate="yes" xml:space="preserve">
          <source>To mitigate this, when defining your generic classes, if the generic type should &lt;em&gt;never&lt;/em&gt; be null, provide a non-null type constraint:</source>
          <target state="translated">이를 완화하려면 일반 클래스를 정의 할 때 일반 유형이 널 이 &lt;em&gt;아니&lt;/em&gt; 어야하는 경우 널이 아닌 유형 제한 조건을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="c1476847da392c83fd72508f4713555cdba4a150" translate="yes" xml:space="preserve">
          <source>To open the list of available courses, go to &lt;strong&gt;Browse Courses&lt;/strong&gt; on the &lt;strong&gt;Welcome Screen&lt;/strong&gt; or in the &lt;strong&gt;File Menu&lt;/strong&gt;. You can start with the &lt;a href=&quot;koans&quot;&gt;Kotlin Koans&lt;/a&gt;, a series of exercises created to get you familiar with the Kotlin Syntax:</source>
          <target state="translated">가능한 과목의 목록을 열려면 이동 &lt;strong&gt;과정 검색&lt;/strong&gt; 켜기 &lt;strong&gt;시작 화면&lt;/strong&gt; 또는에서 &lt;strong&gt;파일 메뉴&lt;/strong&gt; . Kotlin 구문에 익숙해 지도록 작성된 일련의 연습 인 &lt;a href=&quot;koans&quot;&gt;Kotlin Koans로&lt;/a&gt; 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10ddd6b6d4ee0835e4f821b2d4cf707d94c091da" translate="yes" xml:space="preserve">
          <source>To opt in to multiple APIs on the module level, add one of the described arguments for each opt-in requirement marker used in your module.</source>
          <target state="translated">모듈 수준에서 여러 API를 옵트 인하려면 모듈에서 사용되는 각 옵트 인 요구 사항 마커에 대해 설명 된 인수 중 하나를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8f5b1117471b5f9bbedb587fe4ad37368bca070e" translate="yes" xml:space="preserve">
          <source>To opt-in without propagating, either annotate declarations with &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; or pass &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; to the compiler.</source>
          <target state="translated">에 수신 거부에 전파하지 않고,과하거나 주석을 선언 &lt;code&gt;@OptIn(ExperimentalUnsignedTypes::class)&lt;/code&gt; 또는 통과 &lt;code&gt;-Xopt-in=kotlin.ExperimentalUnsignedTypes&lt;/code&gt; 컴파일러에.</target>
        </trans-unit>
        <trans-unit id="5c9c6ae81e15d7660d42f1ec133505c23d5897c2" translate="yes" xml:space="preserve">
          <source>To overcome this restriction an &lt;code&gt;internal&lt;/code&gt; declaration can be annotated with the &lt;code&gt;@PublishedApi&lt;/code&gt; annotation:</source>
          <target state="translated">이 제한을 극복하기 위해 &lt;code&gt;@PublishedApi&lt;/code&gt; 주석으로 &lt;code&gt;internal&lt;/code&gt; 선언에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a53373994c3982c9e9e8b4ff82c6886cee600271" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;clone()&lt;/code&gt;, your class needs to extend &lt;code&gt;kotlin.Cloneable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;clone()&lt;/code&gt; 을 재정의하려면 클래스가 &lt;code&gt;kotlin.Cloneable&lt;/code&gt; 을 확장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e5ef664ee32f352aa2bb27af09f15aaa52406f6" translate="yes" xml:space="preserve">
          <source>To override &lt;code&gt;finalize()&lt;/code&gt;, all you need to do is simply declare it, without using the &lt;em&gt;override&lt;/em&gt; keyword:</source>
          <target state="translated">무시하려면 &lt;code&gt;finalize()&lt;/code&gt; 사용하지 않고, 당신이 할 필요가 단순히 선언되는 &lt;em&gt;재정의&lt;/em&gt; 키워드 :</target>
        </trans-unit>
        <trans-unit id="8b0eb1602de9391e417352c211eac3143269f17a" translate="yes" xml:space="preserve">
          <source>To override different methods with clashing Kotlin signatures, you can add a &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; annotation to the class.</source>
          <target state="translated">Kotlin 서명 충돌로 다른 메소드를 대체 하기 위해 클래스에 &lt;code&gt;@Suppress(&quot;CONFLICTING_OVERLOADS&quot;)&lt;/code&gt; 주석을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91bf99aec76b5996287fb77c5aef5099beb9bbf4" translate="yes" xml:space="preserve">
          <source>To pass an array of primitive values you can do the following in Kotlin:</source>
          <target state="translated">기본 값의 배열을 전달하려면 Kotlin에서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e5025ef1a23d09437b26030660587370537de7f" translate="yes" xml:space="preserve">
          <source>To pass custom raw compiler arguments, you can use &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; elements with either &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;line&lt;/code&gt; attributes. This can be done within the &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; task elements, as follows:</source>
          <target state="translated">사용자 정의 원시 컴파일러 인수를 전달하기 위해 &lt;code&gt;&amp;lt;compilerarg&amp;gt;&lt;/code&gt; 요소를 &lt;code&gt;value&lt;/code&gt; 또는 &lt;code&gt;line&lt;/code&gt; 속성 과 함께 사용할 수 있습니다 . &lt;code&gt;&amp;lt;kotlinc&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;kotlin2js&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;withKotlin&amp;gt;&lt;/code&gt; 태스크 요소 내에서 다음과 같이 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc5a689b36d99998646f8c6f6cfcbfb516f9dfc2" translate="yes" xml:space="preserve">
          <source>To pass values that contain whitespaces, surround them with single (&lt;strong&gt;'&lt;/strong&gt;) or double (&lt;strong&gt;&quot;&lt;/strong&gt;) quotes. If a value contains quotation marks in it, escape them with a backslash (&lt;strong&gt;\&lt;/strong&gt;).</source>
          <target state="translated">공백이 포함 된 값을 전달하려면 작은 따옴표 ( &lt;strong&gt;'&lt;/strong&gt; ) 또는 큰 따옴표 ( &lt;strong&gt;&quot;&lt;/strong&gt; )로 묶으십시오. 값에 따옴표가 포함 된 경우 백 슬래시 ( &lt;strong&gt;\&lt;/strong&gt; )로 이스케이프하십시오 .</target>
        </trans-unit>
        <trans-unit id="a66e06df579b1b23b91b1d16d9167a525f0b07ab" translate="yes" xml:space="preserve">
          <source>To perform a certain operation only for non-null values, you can use the safe call operator together with &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">null이 아닌 값에 대해서만 특정 작업을 수행하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/let&quot;&gt; &lt;code&gt;let&lt;/code&gt; &lt;/a&gt; 과 함께 safe call 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad4b6b2d80d98efbdc1e78464bd70bae937149d2" translate="yes" xml:space="preserve">
          <source>To perform operations on all keys or all values of a map, you can retrieve them from the properties &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; accordingly. &lt;code&gt;keys&lt;/code&gt; is a set of all map keys and &lt;code&gt;values&lt;/code&gt; is a collection of all map values.</source>
          <target state="translated">맵의 모든 키 또는 모든 값에 대해 작업을 수행하려면 그에 따라 속성 &lt;code&gt;keys&lt;/code&gt; 와 &lt;code&gt;values&lt;/code&gt; 에서 검색 할 수 있습니다 . &lt;code&gt;keys&lt;/code&gt; 는 모든 맵 키 세트이며 &lt;code&gt;values&lt;/code&gt; 은 모든 맵 값의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b92bc0346854a9fa46aa79641f72238048fe6403" translate="yes" xml:space="preserve">
          <source>To prevent potential issues, the compiler warns users of such APIs about these conditions and requires them to opt in before using the API.</source>
          <target state="translated">잠재적 인 문제를 방지하기 위해 컴파일러는 이러한 조건에 대해 이러한 API 사용자에게 경고하고 API를 사용하기 전에 옵트 인하도록 요구합니다.</target>
        </trans-unit>
        <trans-unit id="f51b0c422406c4232c8e54b63e979d8283484a9e" translate="yes" xml:space="preserve">
          <source>To prevent spoiling the global object, Kotlin creates an object that contains all Kotlin declarations from the current module. So if you name your module as &lt;code&gt;myModule&lt;/code&gt;, all declarations are available to JavaScript via &lt;code&gt;myModule&lt;/code&gt; object. For example:</source>
          <target state="translated">전역 객체의 손상을 막기 위해 Kotlin은 현재 모듈의 모든 Kotlin 선언을 포함하는 객체를 만듭니다. 따라서 모듈 이름을 &lt;code&gt;myModule&lt;/code&gt; 로 지정 하면 모든 선언을 &lt;code&gt;myModule&lt;/code&gt; 객체 를 통해 JavaScript에 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf0b70dea8387f3ebfae5a605f2eb84fae8ef787" translate="yes" xml:space="preserve">
          <source>To produce a library with the Kotlin/Native compiler use the &lt;code&gt;-produce library&lt;/code&gt; or &lt;code&gt;-p library&lt;/code&gt; flag. For example:</source>
          <target state="translated">Kotlin / Native 컴파일러로 라이브러리를 생성하려면 &lt;code&gt;-produce library&lt;/code&gt; 또는 &lt;code&gt;-p library&lt;/code&gt; 플래그를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ffef4a8cd2a1229b2f11fc8babdeb98ccaf8e0db" translate="yes" xml:space="preserve">
          <source>To produce binaries with the Kotlin/Native compiler it's sufficient to use the &lt;code&gt;-g&lt;/code&gt; option on the command line.</source>
          <target state="translated">Kotlin / Native 컴파일러로 바이너리를 생성하려면 명령 행 에서 &lt;code&gt;-g&lt;/code&gt; 옵션 을 사용하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="bf705fafa9b67e24b379be9a50584f74e0e18d03" translate="yes" xml:space="preserve">
          <source>To propagate the opt-in requirement, annotate declarations that use unsigned integers with &lt;code&gt;@ExperimentalUnsignedTypes&lt;/code&gt;.</source>
          <target state="translated">옵트 인 요구 사항을 전파하려면 &lt;code&gt;@ExperimentalUnsignedTypes&lt;/code&gt; 와 함께 부호없는 정수를 사용하는 선언에 주석을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="bb410b553ff107b4b517f8f7d71063276da071a9" translate="yes" xml:space="preserve">
          <source>To provide a consistent experience when working with different container types, we&amp;rsquo;ve also added new functions for &lt;strong&gt;arrays&lt;/strong&gt;:</source>
          <target state="translated">다양한 컨테이너 유형으로 작업 할 때 일관된 경험을 제공하기 위해 &lt;strong&gt;배열에&lt;/strong&gt; 대한 새로운 함수도 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="1d3463a205e94a6afcbfd6330cbb565e26b9762f" translate="yes" xml:space="preserve">
          <source>To provide a custom equals check implementation, override the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt;&lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt;&lt;/a&gt; function. Functions with the same name and other signatures, like &lt;code&gt;equals(other: Foo)&lt;/code&gt;, don't affect equality checks with the operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;.</source>
          <target state="translated">커스텀 equals check 구현을 제공하려면 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin/-any/equals&quot;&gt; &lt;code&gt;equals(other: Any?): Boolean&lt;/code&gt; &lt;/a&gt; 함수를 재정의하십시오 . &lt;code&gt;equals(other: Foo)&lt;/code&gt; 와 같은 이름과 다른 서명을 가진 함수는 &lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 연산자를 사용한 동등성 검사에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e836b4f2fc16da476cc12a9d2050e81e112acff" translate="yes" xml:space="preserve">
          <source>To provide access to user's native operating system services, &lt;code&gt;Kotlin/Native&lt;/code&gt; distribution includes a set of prebuilt libraries specific to each target. We call them &lt;strong&gt;Platform Libraries&lt;/strong&gt;.</source>
          <target state="translated">사용자의 기본 운영 체제 서비스에 대한 액세스를 제공하기 위해 &lt;code&gt;Kotlin/Native&lt;/code&gt; 배포에는 각 대상에 고유 한 사전 빌드 된 라이브러리 세트가 포함됩니다. 우리는 그들을 &lt;strong&gt;플랫폼 라이브러리&lt;/strong&gt; 라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="31bd1e7079e9e4ecee7632836be44ddf7d329d26" translate="yes" xml:space="preserve">
          <source>To publish an Android library as a part of a multiplatform library, one needs to &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;setup publishing for the library&lt;/a&gt; and provide additional configuration for the Android library target.</source>
          <target state="translated">멀티 플랫폼 라이브러리의 일부로 Android 라이브러리를 공개하려면 라이브러리에 대한 &lt;a href=&quot;#publishing-a-multiplatform-library&quot;&gt;공개&lt;/a&gt; 를 설정 하고 Android 라이브러리 대상에 대한 추가 구성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea7d8288d45b7d92cbec680fddd4a73d1135d188" translate="yes" xml:space="preserve">
          <source>To publish an Android library, you need to provide additional configuration.</source>
          <target state="translated">Android 라이브러리를 게시하려면 추가 구성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ba7323e97d7a64aa36c1fb8b1ca290f8aaf3112" translate="yes" xml:space="preserve">
          <source>To refer to all or some particular compilations of a target, use the &lt;code&gt;compilations&lt;/code&gt; object collection. From &lt;code&gt;compilations&lt;/code&gt;, you can refer to a compilation by its name.</source>
          <target state="translated">대상의 전체 또는 일부 특정 컴파일을 참조하려면 &lt;code&gt;compilations&lt;/code&gt; 개체 컬렉션을 사용하십시오 . 에서 &lt;code&gt;compilations&lt;/code&gt; , 당신은 이름으로 편집을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d256a0c22e6d267c506acee2d9aeb1788f5b9b28" translate="yes" xml:space="preserve">
          <source>To refer to the object, we use its name directly:</source>
          <target state="translated">객체를 참조하기 위해 이름을 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6b8089bed090bdadd847bf36cd42b8f6183969d2" translate="yes" xml:space="preserve">
          <source>To remove an element at a specific position from a list, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt;&lt;code&gt;removeAt()&lt;/code&gt;&lt;/a&gt; function providing the position as an argument. All indices of elements that come after the element being removed will decrease by one.</source>
          <target state="translated">목록에서 특정 위치의 요소를 제거하려면 위치를 인수로 제공하는 &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-list/remove-at&quot;&gt; &lt;code&gt;removeAt()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 요소를 제거한 후 나오는 요소의 모든 인덱스는 1 씩 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="521b7c2bcc6979fed176a9238d544430e53c8f9c" translate="yes" xml:space="preserve">
          <source>To remove an element from a mutable collection, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;remove()&lt;/code&gt; accepts the element value and removes one occurrence of this value.</source>
          <target state="translated">변경 가능한 컬렉션에서 요소를 제거하려면 remove &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;remove()&lt;/code&gt; 는 요소 값을 승인하고이 값의 한 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a5e20b686847f8b478f6ecb4aea9aa4a6082939" translate="yes" xml:space="preserve">
          <source>To remove an entry from a mutable map, use the &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; function. When calling &lt;code&gt;remove()&lt;/code&gt;, you can pass either a key or a whole key-value-pair. If you specify both the key and value, the element with this key will be removed only if its value matches the second argument.</source>
          <target state="translated">변경 가능한 맵에서 항목을 제거하려면 remove &lt;a href=&quot;../../api/latest/jvm/stdlib/kotlin.collections/-mutable-map/remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . &lt;code&gt;remove()&lt;/code&gt; 호출 할 때 키 또는 전체 키-값 쌍을 전달할 수 있습니다. 키와 값을 모두 지정하면이 키가있는 요소는 해당 값이 두 번째 인수와 일치하는 경우에만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0521fbcd6fb6f9d94e609424eadc7933044f924e" translate="yes" xml:space="preserve">
          <source>To remove the library from the default repository use</source>
          <target state="translated">기본 저장소에서 라이브러리를 제거하려면</target>
        </trans-unit>
        <trans-unit id="31c3d88842fee1685ad0d679c0db8a0fc174ec11" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of experimental features by passing the argument &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; to &lt;code&gt;kotlinc&lt;/code&gt;.</source>
          <target state="translated">인수 전달하여 당신이 실험 기능을 사용하도록 선택해야하는 경고를 제거하려면 &lt;code&gt;-XXLanguage:+InlineClasses&lt;/code&gt; 에 &lt;code&gt;kotlinc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e630e1d578ed6510bfa59a81e36360f93345c8c" translate="yes" xml:space="preserve">
          <source>To remove the warning you have to opt in to the usage of this feature by passing the compiler argument &lt;code&gt;-Xinline-classes&lt;/code&gt;.</source>
          <target state="translated">To remove the warning you have to opt in to the usage of this feature by passing the compiler argument &lt;code&gt;-Xinline-classes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28a952e26ac563cedfa7c9f543249e0cc2d66483" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt;.</source>
          <target state="translated">경고를 제거하려면 컴파일러 인수 &lt;code&gt;-Xopt-in=kotlin.RequiresOptIn&lt;/code&gt; 을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3f08203a0ddf6e6bc4f31d19032cdb3e04aee85" translate="yes" xml:space="preserve">
          <source>To remove the warnings, add the compiler argument &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt;.</source>
          <target state="translated">경고를 제거하려면 컴파일러 인수 &lt;code&gt;-Xuse-experimental=kotlin.Experimental&lt;/code&gt; 을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d469d435bb3a113c1dd1088e7025b64a6a0198e5" translate="yes" xml:space="preserve">
          <source>To represent body of an external function. In most cases Kotlin does not require to provide bodies of external functions and properties, but if for some reason you want to (for example, due to limitation of your coding style guides), you should use &lt;code&gt;definedExternally&lt;/code&gt;.</source>
          <target state="translated">외부 함수의 본문을 나타냅니다. 대부분의 경우 Kotlin은 외부 함수 및 속성 본문을 제공 할 필요는 없지만 어떤 이유로 코딩 스타일 가이드의 제한으로 인해 원하는 경우 &lt;code&gt;definedExternally&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="19ce750db4ac36bdd72cdcddab7ef744528c90ce" translate="yes" xml:space="preserve">
          <source>To represent value of default argument.</source>
          <target state="translated">기본 인수의 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="14a14bea6684b1e554722af225128be0f57d25cd" translate="yes" xml:space="preserve">
          <source>To require an opt-in to using an API element, annotate its declaration with an opt-in requirement annotation:</source>
          <target state="translated">API 요소 사용에 대한 옵트 인을 요구하려면 옵트 인 요구 사항 주석으로 선언에 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="54a0a9d97090503eaabc29843393d48b0c0faafe" translate="yes" xml:space="preserve">
          <source>To resolve ambiguities in exports (like overloads for functions with the same name), you can use the &lt;code&gt;@JsExport&lt;/code&gt; annotation together with &lt;code&gt;@JsName&lt;/code&gt; to specify the names for the generated and exported functions.</source>
          <target state="translated">To resolve ambiguities in exports (like overloads for functions with the same name), you can use the &lt;code&gt;@JsExport&lt;/code&gt; annotation together with &lt;code&gt;@JsName&lt;/code&gt; to specify the names for the generated and exported functions.</target>
        </trans-unit>
        <trans-unit id="69457a99de832ac1adcb88dba9125bcc6ced4562" translate="yes" xml:space="preserve">
          <source>To retrieve the Java class of an object, use the &lt;code&gt;java&lt;/code&gt; extension property on a &lt;a href=&quot;reflection#class-references&quot;&gt;class reference&lt;/a&gt;:</source>
          <target state="translated">객체의 Java 클래스를 검색하려면 &lt;a href=&quot;reflection#class-references&quot;&gt;클래스 참조&lt;/a&gt; 에서 &lt;code&gt;java&lt;/code&gt; 확장 등록 정보를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9630cc244843d39b109cb4a4e7a2a47687f686a" translate="yes" xml:space="preserve">
          <source>To return a floating-point type, explicitly convert one of the arguments to a floating-point type.</source>
          <target state="translated">To return a floating-point type, explicitly convert one of the arguments to a floating-point type.</target>
        </trans-unit>
        <trans-unit id="cab4ab009a9095119ec865716a0422fa20f520ff" translate="yes" xml:space="preserve">
          <source>To return to the pre-1.2 behavior, pass the flag &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; to the compiler.</source>
          <target state="translated">1.2 이전 동작으로 돌아가려면 &lt;code&gt;-Xno-exception-on-explicit-equals-for-boxed-null&lt;/code&gt; 플래그 를 컴파일러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5e0d2974dcfaa7063fb542a18d0b57f9a9db0a83" translate="yes" xml:space="preserve">
          <source>To run REPL in IntelliJ IDEA, open &lt;strong&gt;Tools | Kotlin | Kotlin REPL&lt;/strong&gt;.</source>
          <target state="translated">IntelliJ IDEA에서 REPL을 실행하려면 &lt;strong&gt;도구 | 코 틀린 | 코 틀린 REPL&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c80c0585cded44d08003b71c290d1079d4069543" translate="yes" xml:space="preserve">
          <source>To run REPL in the OS command line, open &lt;strong&gt;/bin/kotlinc-jvm&lt;/strong&gt; from the directory of standalone Kotlin compiler.</source>
          <target state="translated">OS 명령 행에서 REPL을 실행하려면 독립형 Kotlin 컴파일러 디렉토리에서 &lt;strong&gt;/ bin / kotlinc-jvm을여십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3cc3c110a513b90b220f8954bf1227697a6710b3" translate="yes" xml:space="preserve">
          <source>To run a project, execute the standard lifecycle &lt;code&gt;run&lt;/code&gt; task, or the alias to which it corresponds:</source>
          <target state="translated">프로젝트를 실행하려면 표준 수명주기 &lt;code&gt;run&lt;/code&gt; 작업 또는 해당하는 별칭을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="7fd27594c6ae21992652c27028d51d29604dfae3" translate="yes" xml:space="preserve">
          <source>To run a script, we just pass the &lt;code&gt;-script&lt;/code&gt; option to the compiler with the corresponding script file.</source>
          <target state="translated">스크립트를 실행하려면 해당 스크립트 파일과 함께 &lt;code&gt;-script&lt;/code&gt; 옵션을 컴파일러에 전달하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="e2cae558670745cc7ac9e88ece3ef0ebf63a7483" translate="yes" xml:space="preserve">
          <source>To run kapt with compile avoidance:</source>
          <target state="translated">컴파일 방지로 kapt를 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="7bfb5403dc626e7b616c00072ab7971dc81d2cec" translate="yes" xml:space="preserve">
          <source>To run tests for a particular target suitable for testing, run a test task &lt;code&gt;&amp;lt;targetName&amp;gt;Test&lt;/code&gt;.</source>
          <target state="translated">테스트에 적합한 특정 대상에 대한 테스트를 실행하려면 테스트 작업 &lt;code&gt;&amp;lt;targetName&amp;gt;Test&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="65dc2975423668b7d149d3345dc1e61eeea66998" translate="yes" xml:space="preserve">
          <source>To run tests for all targets, run the &lt;code&gt;check&lt;/code&gt; task.</source>
          <target state="translated">모든 대상에 대해 테스트를 실행하려면 &lt;code&gt;check&lt;/code&gt; 태스크를 실행하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
