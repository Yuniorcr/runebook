<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_fortran">
    <body>
      <group id="gnu_fortran">
        <trans-unit id="eb53e961d2bb5f1b5ee80557c9816e0f3fdd477c" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of kind &lt;var&gt;KIND&lt;/var&gt;. If &lt;var&gt;KIND&lt;/var&gt; is absent, the return value is of default integer kind.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 &lt;var&gt;KIND&lt;/var&gt; 유형 입니다. 경우 &lt;var&gt;KIND&lt;/var&gt; 결석, 반환 값은 기본 정수 종류이다.</target>
        </trans-unit>
        <trans-unit id="0bdf5ddfa5925754973e731c8e1d96133f640c61" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of kind &lt;var&gt;KIND&lt;/var&gt;. If &lt;var&gt;KIND&lt;/var&gt; is absent, the return value is of default integer kind. If &lt;var&gt;DIM&lt;/var&gt; is absent, the result is an array of the lower bounds of &lt;var&gt;ARRAY&lt;/var&gt;. If &lt;var&gt;DIM&lt;/var&gt; is present, the result is a scalar corresponding to the lower bound of the array along that dimension. If &lt;var&gt;ARRAY&lt;/var&gt; is an expression rather than a whole array or array structure component, or if it has a zero extent along the relevant dimension, the lower bound is taken to be 1.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 &lt;var&gt;KIND&lt;/var&gt; 유형 입니다. 경우 &lt;var&gt;KIND&lt;/var&gt; 결석, 반환 값은 기본 정수 종류이다. 경우 &lt;var&gt;DIM&lt;/var&gt; 은 존재하지 않고, 그 결과의 하한의 배열 &lt;var&gt;ARRAY&lt;/var&gt; . 경우 &lt;var&gt;DIM&lt;/var&gt; 이 존재하는 결과는 그 사이즈에 따라 배열의 결합, 하부에 대응하는 스칼라이다. 경우 &lt;var&gt;ARRAY&lt;/var&gt; 식보다는 전체 어레이 또는 어레이 구조 구성 요소, 또는 그 관련 차원에 따른 제로 범위를 갖는 경우, 하한은 1로 취해진 다.</target>
        </trans-unit>
        <trans-unit id="83a9edd7ddbef7e8f627c3a7780c3eabdb730e23" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of kind &lt;var&gt;KIND&lt;/var&gt;. If &lt;var&gt;KIND&lt;/var&gt; is absent, the return value is of default integer kind. If &lt;var&gt;DIM&lt;/var&gt; is absent, the result is an array of the lower cobounds of &lt;var&gt;COARRAY&lt;/var&gt;. If &lt;var&gt;DIM&lt;/var&gt; is present, the result is a scalar corresponding to the lower cobound of the array along that codimension.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 &lt;var&gt;KIND&lt;/var&gt; 유형 입니다. 경우 &lt;var&gt;KIND&lt;/var&gt; 결석, 반환 값은 기본 정수 종류이다. 경우 &lt;var&gt;DIM&lt;/var&gt; 은 존재하지 않고, 그 결과 하부 cobounds 배열이다 &lt;var&gt;COARRAY&lt;/var&gt; . 경우 &lt;var&gt;DIM&lt;/var&gt; 이 존재하는 결과는 함께여 차원 어레이의 하부 cobound에 대응하는 스칼라이다.</target>
        </trans-unit>
        <trans-unit id="a62ee54968351482d9fafb6b9f2f76c0ec81a458" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of kind &lt;var&gt;KIND&lt;/var&gt;. If &lt;var&gt;KIND&lt;/var&gt; is absent, the return value is of default integer kind. If &lt;var&gt;DIM&lt;/var&gt; is absent, the result is an array of the upper bounds of &lt;var&gt;ARRAY&lt;/var&gt;. If &lt;var&gt;DIM&lt;/var&gt; is present, the result is a scalar corresponding to the upper bound of the array along that dimension. If &lt;var&gt;ARRAY&lt;/var&gt; is an expression rather than a whole array or array structure component, or if it has a zero extent along the relevant dimension, the upper bound is taken to be the number of elements along the relevant dimension.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 &lt;var&gt;KIND&lt;/var&gt; 유형 입니다. 경우 &lt;var&gt;KIND&lt;/var&gt; 결석, 반환 값은 기본 정수 종류이다. 경우 &lt;var&gt;DIM&lt;/var&gt; 은 존재하지 않고, 그 결과의 상한의 배열 &lt;var&gt;ARRAY&lt;/var&gt; . 경우 &lt;var&gt;DIM&lt;/var&gt; 이 존재하는 결과는 그 상부 차원에 따른 어레이의 행에 대응하는 스칼라이다. 경우 &lt;var&gt;ARRAY&lt;/var&gt; 식보다는 전체 어레이 또는 어레이 구조 구성 요소, 또는 그 관련 차원에 따른 제로 범위를 갖는 경우, 상한은 적절한 치수를 따라 소자의 수를 보낸다.</target>
        </trans-unit>
        <trans-unit id="598dee67912bfb6dc4099ccea478e8d202fdc5e7" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of kind &lt;var&gt;KIND&lt;/var&gt;. If &lt;var&gt;KIND&lt;/var&gt; is absent, the return value is of default integer kind. If &lt;var&gt;DIM&lt;/var&gt; is present, the result is an array with a rank one less than the rank of &lt;var&gt;ARRAY&lt;/var&gt;, and a size corresponding to the shape of &lt;var&gt;ARRAY&lt;/var&gt; with the &lt;var&gt;DIM&lt;/var&gt; dimension removed.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 &lt;var&gt;KIND&lt;/var&gt; 유형 입니다. 경우 &lt;var&gt;KIND&lt;/var&gt; 결석, 반환 값은 기본 정수 종류이다. &lt;var&gt;DIM&lt;/var&gt; 이있는 경우 결과는 &lt;var&gt;ARRAY&lt;/var&gt; 순위보다 1이 작은 순위 와 &lt;var&gt;DIM&lt;/var&gt; 차원이 제거 된 &lt;var&gt;ARRAY&lt;/var&gt; 의 모양에 해당하는 크기의 배열 입니다 .</target>
        </trans-unit>
        <trans-unit id="d4eb954ceec6871a8aff825eb0013483cc733be0" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of the default integer kind.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 기본 정수 종류입니다.</target>
        </trans-unit>
        <trans-unit id="c6a1743976d9027bc9f3577d9c87408e3c4f6365" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of the default integer kind. For arrays, their rank is returned; for scalars zero is returned.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 기본 정수 종류입니다. 배열의 경우 순위가 반환됩니다. 스칼라의 경우 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2e905ca40ccd62ec252076e443b49b1de863c018" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; and of the same kind as &lt;var&gt;I&lt;/var&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며 &lt;var&gt;I&lt;/var&gt; 와 동일한 종류 입니다.</target>
        </trans-unit>
        <trans-unit id="b6116519989c78aedef730f398f73e179cfb24d3" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; or &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 또는 &lt;code&gt;REAL&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="eb509545a2eeeaf252e2869237f497564ddb7a7f" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt; or &lt;code&gt;REAL&lt;/code&gt;. (As a GNU extension, kind is the largest kind of the actual arguments.)</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 또는 &lt;code&gt;REAL&lt;/code&gt; 유형 입니다. (GNU 확장으로서 kind는 실제 인수 중 가장 큰 종류입니다.)</target>
        </trans-unit>
        <trans-unit id="eee9ab99f3e5a3ae690c8716e8b14d5ce06f2f46" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt;, with a &lt;code&gt;KIND&lt;/code&gt; corresponding to the size (in bytes) of a memory address on the target machine.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 이며, &lt;code&gt;KIND&lt;/code&gt; 는 대상 시스템에서 메모리 주소의 크기 (바이트)에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="249be10cc932f7ed0c8b836fb4fc9c745c4b5df5" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="fbddfbc0a85071342fdff8fc3bb9f25f454fc734" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;INTEGER&lt;/code&gt;. If &lt;var&gt;KIND&lt;/var&gt; is present, it specifies the kind value of the return type; otherwise, it is of the default integer kind.</source>
          <target state="translated">리턴 값은 &lt;code&gt;INTEGER&lt;/code&gt; 유형 입니다. 경우 &lt;var&gt;KIND&lt;/var&gt; 존재하고, 상기 리턴 형의 종류를 지정 값; 그렇지 않으면 기본 정수 종류입니다.</target>
        </trans-unit>
        <trans-unit id="5de0e4f80a9b872da4f5e336c0113b9974a1094d" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;LOGICAL&lt;/code&gt;</source>
          <target state="translated">리턴 값은 &lt;code&gt;LOGICAL&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="48c5fc8912623f8a9a113f6506c7b0e23b5c0c13" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;LOGICAL&lt;/code&gt; and of the default kind.</source>
          <target state="translated">리턴 값은 &lt;code&gt;LOGICAL&lt;/code&gt; 유형 이며 기본 유형입니다.</target>
        </trans-unit>
        <trans-unit id="370753e248a8b09156d7e597be39f3a1d02cfe65" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;LOGICAL&lt;/code&gt;; it is &lt;code&gt;.false.&lt;/code&gt; if either &lt;var&gt;c_ptr_1&lt;/var&gt; is a C NULL pointer or if &lt;var&gt;c_ptr1&lt;/var&gt; and &lt;var&gt;c_ptr_2&lt;/var&gt; point to different addresses.</source>
          <target state="translated">리턴 값은 &lt;code&gt;LOGICAL&lt;/code&gt; 유형입니다 . 그것은이다 &lt;code&gt;.false.&lt;/code&gt; 두 경우 &lt;var&gt;c_ptr_1&lt;/var&gt; 이 는 C NULL 포인터 또는 경우입니다 &lt;var&gt;c_ptr1&lt;/var&gt; 및 &lt;var&gt;c_ptr_2&lt;/var&gt; 의 포인트 서로 다른 주소에.</target>
        </trans-unit>
        <trans-unit id="aa23bca46de4600f9ff3218ab9518e4d08e2c3a3" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL(8)&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;REAL(8)&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="efb37cd7ab3769e55ed29b5e0743bab1572519ec" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; and lies in the range &lt;em&gt;- 0.4027... \leq Bessel (0,x) \leq 1&lt;/em&gt;. It has the same kind as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;REAL&lt;/code&gt; 유형 이며 &lt;em&gt;-0.4027 ... \ leq Bessel (0, x) \ leq 1 범위에&lt;/em&gt; 있습니다. &lt;var&gt;X&lt;/var&gt; 와 같은 종류 입니다.</target>
        </trans-unit>
        <trans-unit id="a7f8a8b7baaa4eba4b1ab3ef3e72e6a0ab31cf47" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; and lies in the range &lt;em&gt;- 0.5818... \leq Bessel (0,x) \leq 0.5818 &lt;/em&gt;. It has the same kind as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">반환 값은 &lt;code&gt;REAL&lt;/code&gt; 유형 이며 &lt;em&gt;-0.5818 ... \ leq Bessel (0, x) \ leq 0.5818 범위에&lt;/em&gt; 있습니다. &lt;var&gt;X&lt;/var&gt; 와 같은 종류 입니다.</target>
        </trans-unit>
        <trans-unit id="6e609ed1651145c9e468a4004da8ba43e0a852b9" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; and of the same kind as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;REAL&lt;/code&gt; 유형 이며 &lt;var&gt;X&lt;/var&gt; 와 동일한 종류 입니다.</target>
        </trans-unit>
        <trans-unit id="c7c92ce3fa938c9048704a3fa45833e2bbda77aa" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; and of the same kind as &lt;var&gt;X&lt;/var&gt;. It lies in the range &lt;em&gt;0 \leq erfc (x) \leq 2 &lt;/em&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;REAL&lt;/code&gt; 유형 이며 &lt;var&gt;X&lt;/var&gt; 와 동일한 종류 입니다. 이 범위에 놓여 &lt;em&gt;0 \ 당량 ERFC (X) \ 2 당량&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9b3ba37ae4292a3d6aace960f8ba7c22914180e3" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; of the same kind as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">리턴 값은 &lt;var&gt;X&lt;/var&gt; 와 동일한 종류의 &lt;code&gt;REAL&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c4d7bc9244655beb96b55b76d32c755d70f08bb9" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; or &lt;code&gt;COMPLEX&lt;/code&gt;. The kind type parameter is the same as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 유형 입니다. 종류 유형 매개 변수는 &lt;var&gt;X&lt;/var&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="52f2f43018f4f86c1e559faa9e18b3978a8a9f65" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; or &lt;code&gt;COMPLEX&lt;/code&gt;. The kind type parameter is the same as &lt;var&gt;X&lt;/var&gt;. If &lt;var&gt;X&lt;/var&gt; is &lt;code&gt;COMPLEX&lt;/code&gt;, the imaginary part &lt;em&gt;\omega&lt;/em&gt; is in the range &lt;em&gt;-\pi &amp;lt; \omega \leq \pi&lt;/em&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 유형 입니다. 종류 유형 매개 변수는 &lt;var&gt;X&lt;/var&gt; 와 동일합니다 . 경우 &lt;var&gt;X&lt;/var&gt; 는 이다 &lt;code&gt;COMPLEX&lt;/code&gt; , 허부 &lt;em&gt;\ 오메가&lt;/em&gt; 범위이다 &lt;em&gt;- \ &amp;lt;\ 오메가 \ 당량 \ PI PI&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="271633e463525471e3aaf3bfaf331cbeb0bdc05a" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; with the kind type parameter of the argument if the optional &lt;var&gt;KIND&lt;/var&gt; is absent; otherwise, the kind type parameter will be given by &lt;var&gt;KIND&lt;/var&gt;. If the magnitude of &lt;var&gt;X&lt;/var&gt; is less than one, &lt;code&gt;AINT(X)&lt;/code&gt; returns zero. If the magnitude is equal to or greater than one then it returns the largest whole number that does not exceed its magnitude. The sign is the same as the sign of &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">선택적 &lt;var&gt;KIND&lt;/var&gt; 가 없으면 인수의 kind type 매개 변수와 함께 리턴 값은 &lt;code&gt;REAL&lt;/code&gt; 유형입니다 . 그렇지 않은 경우 종류 유형 매개 변수는 &lt;var&gt;KIND&lt;/var&gt; 에 의해 제공됩니다 . &lt;var&gt;X&lt;/var&gt; 의 크기 가 1보다 작 으면 &lt;code&gt;AINT(X)&lt;/code&gt; 는 0을 반환합니다. 크기가 1 이상이면 크기를 초과하지 않는 가장 큰 정수를 반환합니다. 부호는 &lt;var&gt;X&lt;/var&gt; 부호와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f7f36e7fcea48ef96a95edfab1de67a3cc236316" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt; with the kind type parameter of the argument.</source>
          <target state="translated">리턴 값은 인수의 kind 유형 매개 변수와 함께 &lt;code&gt;REAL&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c45065812d5139a1b1942d2709f16b6269e10256" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt;, of the same kind as &lt;var&gt;X&lt;/var&gt; and lies in the range &lt;em&gt;-1 \leq erf (x) \leq 1 &lt;/em&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;REAL&lt;/code&gt; 유형 이며 &lt;var&gt;X&lt;/var&gt; 와 같은 종류 이며 &lt;em&gt;-1 \ leq erf (x) \ leq 1 범위에&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="3593be30e354a4944f584f85ca4db6a0e05b4320" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;code&gt;REAL&lt;/code&gt;. It has the same kind as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;REAL&lt;/code&gt; 유형 입니다. &lt;var&gt;X&lt;/var&gt; 와 같은 종류 입니다.</target>
        </trans-unit>
        <trans-unit id="984b03c6b9e16b2e0f22e91b0e736ec9951bccee" translate="yes" xml:space="preserve">
          <source>The return value is of type default &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 기본 &lt;code&gt;INTEGER&lt;/code&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="0f315eca9ae0c32f83b2fd4691a70cd03d6e071b" translate="yes" xml:space="preserve">
          <source>The return value is of type double precision real.</source>
          <target state="translated">리턴 값은 배정 밀도 실수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="582cd1df820740d9a93f7e6f89fdb131e2276d78" translate="yes" xml:space="preserve">
          <source>The return value is of type integer and of the system-dependent kind &lt;code&gt;C_SIZE_T&lt;/code&gt; (from the &lt;code&gt;ISO_C_BINDING&lt;/code&gt; module). Its value is the number of bytes occupied by the argument. If the argument has the &lt;code&gt;POINTER&lt;/code&gt; attribute, the number of bytes of the storage area pointed to is returned. If the argument is of a derived type with &lt;code&gt;POINTER&lt;/code&gt; or &lt;code&gt;ALLOCATABLE&lt;/code&gt; components, the return value does not account for the sizes of the data pointed to by these components.</source>
          <target state="translated">리턴 값은 정수 유형이고 시스템 종속 종류 &lt;code&gt;C_SIZE_T&lt;/code&gt; ( &lt;code&gt;ISO_C_BINDING&lt;/code&gt; 모듈에서)입니다. 그 값은 인수가 차지하는 바이트 수입니다. 인수에 &lt;code&gt;POINTER&lt;/code&gt; 속성 이 있으면, 지정된 스토리지 영역의 바이트 수가 리턴됩니다. 인수가 &lt;code&gt;POINTER&lt;/code&gt; 또는 &lt;code&gt;ALLOCATABLE&lt;/code&gt; 구성 요소 가있는 파생 유형 인 경우 리턴 값은 해당 구성 요소가 가리키는 데이터의 크기를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6eec0376a05371f7d168dbbc7f9d15cbde400f9a" translate="yes" xml:space="preserve">
          <source>The return value is of type integer and of the system-dependent kind &lt;var&gt;C_SIZE_T&lt;/var&gt; (from the &lt;var&gt;ISO_C_BINDING&lt;/var&gt; module). Its value is the number of bytes occupied by the argument. If the argument has the &lt;code&gt;POINTER&lt;/code&gt; attribute, the number of bytes of the storage area pointed to is returned. If the argument is of a derived type with &lt;code&gt;POINTER&lt;/code&gt; or &lt;code&gt;ALLOCATABLE&lt;/code&gt; components, the return value does not account for the sizes of the data pointed to by these components. If the argument is polymorphic, the size according to the dynamic type is returned. The argument may not be a procedure or procedure pointer. Note that the code assumes for arrays that those are contiguous; for contiguous arrays, it returns the storage or an array element multiplied by the size of the array.</source>
          <target state="translated">리턴 값은 정수 유형이고 시스템 종속 종류 &lt;var&gt;C_SIZE_T&lt;/var&gt; ( &lt;var&gt;ISO_C_BINDING&lt;/var&gt; 모듈에서)입니다. 그 값은 인수가 차지하는 바이트 수입니다. 인수에 &lt;code&gt;POINTER&lt;/code&gt; 속성 이 있으면, 지정된 스토리지 영역의 바이트 수가 리턴됩니다. 인수가 &lt;code&gt;POINTER&lt;/code&gt; 또는 &lt;code&gt;ALLOCATABLE&lt;/code&gt; 을 사용하여 파생 된 유형 인 경우반환 값은 이러한 구성 요소가 가리키는 데이터 크기를 고려하지 않습니다. 인수가 다형성 인 경우 동적 유형에 따른 크기가 리턴됩니다. 인수가 프로 시저 또는 프로 시저 포인터가 아닐 수 있습니다. 이 코드는 배열이 연속적이라고 가정합니다. 연속 배열의 경우 스토리지 또는 배열 요소에 배열 크기를 곱한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4e4e26872c5fa9c8fdafe9bf5459f08da237b356" translate="yes" xml:space="preserve">
          <source>The return value is of type real with the kind type parameter of the argument if the optional &lt;var&gt;KIND&lt;/var&gt; is absent; otherwise, the kind type parameter will be given by &lt;var&gt;KIND&lt;/var&gt;. If &lt;var&gt;A&lt;/var&gt; is greater than zero, &lt;code&gt;ANINT(A)&lt;/code&gt; returns &lt;code&gt;AINT(X+0.5)&lt;/code&gt;. If &lt;var&gt;A&lt;/var&gt; is less than or equal to zero then it returns &lt;code&gt;AINT(X-0.5)&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;var&gt;KIND&lt;/var&gt; 가 없으면 인수의 kind type 매개 변수와 함께 리턴 값은 real 유형입니다 . 그렇지 않은 경우 종류 유형 매개 변수는 &lt;var&gt;KIND&lt;/var&gt; 로 제공됩니다 . 경우 &lt;var&gt;A&lt;/var&gt; 는 0보다 큰, &lt;code&gt;ANINT(A)&lt;/code&gt; 리턴 &lt;code&gt;AINT(X+0.5)&lt;/code&gt; . &lt;var&gt;A&lt;/var&gt; 가 0보다 작거나 같은 경우 &lt;code&gt;AINT(X-0.5)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="959f4c5d3ac7748c28361f6f293891c14b6170fa" translate="yes" xml:space="preserve">
          <source>The return value is the result of &lt;code&gt;A - (INT(A/P) * P)&lt;/code&gt;. The type and kind of the return value is the same as that of the arguments. The returned value has the same sign as A and a magnitude less than the magnitude of P.</source>
          <target state="translated">반환 값은 &lt;code&gt;A - (INT(A/P) * P)&lt;/code&gt; 입니다. 반환 값의 유형과 종류는 인수의 유형과 종류와 같습니다. 반환 된 값은 A와 부호가 같고 P의 크기보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="13755d147827e4166e8b56ffa0ab71a42622c2f5" translate="yes" xml:space="preserve">
          <source>The return value is the result of &lt;code&gt;A - (INT(A/P) * P)&lt;/code&gt;. The type and kind of the return value is the same as that of the arguments. The returned value has the same sign as A and a magnitude less than the magnitude of P. (As a GNU extension, kind is the largest kind of the actual arguments.)</source>
          <target state="translated">반환 값은 &lt;code&gt;A - (INT(A/P) * P)&lt;/code&gt; 입니다. 반환 값의 유형과 종류는 인수와 동일합니다. 반환 된 값은 A와 같은 부호와 P의 크기보다 작은 크기를 갖습니다. (GNU 확장으로서 종류는 실제 인수의 가장 큰 종류입니다.)</target>
        </trans-unit>
        <trans-unit id="fc1a7134b3700811e1b902a25e654b06aaf1aead" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;GETGID&lt;/code&gt; is an &lt;code&gt;INTEGER&lt;/code&gt; of the default kind.</source>
          <target state="translated">&lt;code&gt;GETGID&lt;/code&gt; 의 반환 값은 기본 종류 의 &lt;code&gt;INTEGER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b162949d538a88dc141803e7b2a4ecb8ca274cf0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;GETPID&lt;/code&gt; is an &lt;code&gt;INTEGER&lt;/code&gt; of the default kind.</source>
          <target state="translated">&lt;code&gt;GETPID&lt;/code&gt; 의 반환 값은 기본 종류 의 &lt;code&gt;INTEGER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4028dd5f729d49755b5e378fb57c9b2e9288e821" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;GETUID&lt;/code&gt; is an &lt;code&gt;INTEGER&lt;/code&gt; of the default kind.</source>
          <target state="translated">&lt;code&gt;GETUID&lt;/code&gt; 의 반환 값은 기본 종류 의 &lt;code&gt;INTEGER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3d715262b947ce1f385c5394b09cac4bfaba7ec8" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as P and a magnitude less than the magnitude of P.</source>
          <target state="translated">반환 된 값은 P와 부호가 같고 P의 크기보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="5b7f540253a5a8f1d16e9afd7bde9fc797a18ad7" translate="yes" xml:space="preserve">
          <source>The runtime-library implements the xorshift1024* random number generator (RNG). This generator has a period of &lt;em&gt;2^{1024} - 1&lt;/em&gt;, and when using multiple threads up to &lt;em&gt;2^{512}&lt;/em&gt; threads can each generate &lt;em&gt;2^{512}&lt;/em&gt; random numbers before any aliasing occurs.</source>
          <target state="translated">런타임 라이브러리는 xorshift1024 * 임의 번호 생성기 (RNG)를 구현합니다. 이 생성기는 기간이 &lt;em&gt;2 ^ {1024}-1&lt;/em&gt; 이고 여러 스레드를 사용하는 경우 최대 &lt;em&gt;2 ^ {512}&lt;/em&gt; 스레드는 앨리어싱이 발생하기 전에 각각 &lt;em&gt;2 ^ {512}의&lt;/em&gt; 난수를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd62adf3c80e0178e752054222417f6259e8f5be" translate="yes" xml:space="preserve">
          <source>The runtime-library implements the xoshiro256** pseudorandom number generator (PRNG). This generator has a period of &lt;em&gt;2^{256} - 1&lt;/em&gt;, and when using multiple threads up to &lt;em&gt;2^{128}&lt;/em&gt; threads can each generate &lt;em&gt;2^{128}&lt;/em&gt; random numbers before any aliasing occurs.</source>
          <target state="translated">런타임 라이브러리는 xoshiro256 ** 의사 난수 생성기 (PRNG)를 구현합니다. 이 생성기의 기간은 &lt;em&gt;2 ^ {256}-1&lt;/em&gt; 이며, 여러 스레드를 사용할 때 최대 &lt;em&gt;2 ^ {128} 개의&lt;/em&gt; 스레드는 별칭이 발생하기 전에 각각 &lt;em&gt;2 ^ {128} 개의&lt;/em&gt; 난수를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42e4d0f915730a2252b564d93ed3dce9a87c6599" translate="yes" xml:space="preserve">
          <source>The seconds of the minute</source>
          <target state="translated">분의 초</target>
        </trans-unit>
        <trans-unit id="24e7b16ff59f49171cc78027e1794f8f1b1d7d6d" translate="yes" xml:space="preserve">
          <source>The size in bits of the numeric storage unit.</source>
          <target state="translated">숫자 저장 단위의 비트 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b7ee76dd2d9d1f495ebca5858975eaff9d4583d5" translate="yes" xml:space="preserve">
          <source>The start of the GNU Fortran 95 project was announced on the GCC homepage in March 18, 2000 (even though Andy had already been working on it for a while, of course).</source>
          <target state="translated">GNU Fortran 95 프로젝트의 시작은 2000 년 3 월 18 일 GCC 홈페이지에서 발표되었습니다 (Andy는 이미 한동안 프로젝트를 진행하고 있었음에도 불구하고).</target>
        </trans-unit>
        <trans-unit id="38ed06fe770c5d35789774258b2b51a19de5472c" translate="yes" xml:space="preserve">
          <source>The statement is an image-control statement but does not imply sync memory. Still, all preceeding push communications of this image to the specified remote image have to be completed before &lt;code&gt;event_wait&lt;/code&gt; on the remote image returns.</source>
          <target state="translated">명령문은 이미지 제어 명령문이지만 메모리 동기화를 의미하지는 않습니다. 여전히 원격 이미지의 &lt;code&gt;event_wait&lt;/code&gt; 가 리턴 되기 전에이 이미지의 지정된 원격 이미지에 대한 모든 선행 푸시 통신을 완료해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9616ab988b77a036324fbde31f5b9db4dfa45ebc" translate="yes" xml:space="preserve">
          <source>The structure used for implementing arbitrary reference chains. A &lt;code&gt;CAF_REFERENCE_T&lt;/code&gt; allows to specify a component reference or any kind of array reference of any rank supported by gfortran. For array references all kinds as known by the compiler/Fortran standard are supported indicated by a &lt;code&gt;MODE&lt;/code&gt;.</source>
          <target state="translated">임의의 참조 체인을 구현하는 데 사용되는 구조입니다. &lt;code&gt;CAF_REFERENCE_T&lt;/code&gt; 는 컴포넌트 참조 또는 gfortran 지원하는 모든 순위의 레퍼런스 어레이의 종류를 지정할 수있다. 배열 참조은 컴파일러 / 포트란 표준으로 알려진 모든 종류는로 표시된 지원 &lt;code&gt;MODE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7999118032b291f8794b503745efd367d18a17c0" translate="yes" xml:space="preserve">
          <source>The syntax for the initializers is as for the &lt;code&gt;DATA&lt;/code&gt; statement, but unlike in a &lt;code&gt;DATA&lt;/code&gt; statement, an initializer only applies to the variable immediately preceding the initialization. In other words, something like &lt;code&gt;INTEGER I,J/2,3/&lt;/code&gt; is not valid. This style of initialization is only allowed in declarations without double colons (&lt;code&gt;::&lt;/code&gt;); the double colons were introduced in Fortran 90, which also introduced a standard syntax for initializing variables in type declarations.</source>
          <target state="translated">초기화 자에 대한 구문은 대한과 같다 &lt;code&gt;DATA&lt;/code&gt; 의 문하지만 달리 &lt;code&gt;DATA&lt;/code&gt; 문, 이니셜 라이저는 즉시 초기화 앞의 변수에 적용됩니다. 즉, &lt;code&gt;INTEGER I,J/2,3/&lt;/code&gt; 과 같은 것은 유효하지 않습니다. 이 스타일의 초기화는 이중 콜론 ( &lt;code&gt;::&lt;/code&gt; :)이없는 선언에서만 허용됩니다 . 이중 콜론은 Fortran 90에 도입되었으며 형식 선언에서 변수를 초기화하기위한 표준 구문도 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="28a61d29fef76ee86cf7c31200823d33363cf00f" translate="yes" xml:space="preserve">
          <source>The syntax of the directive is</source>
          <target state="translated">지시문의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3764ebf0328558fd1dd7adacb7fedba955fffe52" translate="yes" xml:space="preserve">
          <source>The the present status for optional arguments with value attribute, which are internally passed by value</source>
          <target state="translated">내부적으로 value에 의해 전달되는 value 속성을 가진 선택적 인수의 현재 상태</target>
        </trans-unit>
        <trans-unit id="bf8c7dff005259cfa5a4d11f5128b5cc039c6c96" translate="yes" xml:space="preserve">
          <source>The three last arguments allow the user to get status information. After synchronous execution, &lt;code&gt;EXITSTAT&lt;/code&gt; contains the integer exit code of the command, as returned by &lt;code&gt;system&lt;/code&gt;. &lt;code&gt;CMDSTAT&lt;/code&gt; is set to zero if the command line was executed (whatever its exit status was). &lt;code&gt;CMDMSG&lt;/code&gt; is assigned an error message if an error has occurred.</source>
          <target state="translated">마지막 3 개의 인수를 통해 사용자는 상태 정보를 얻을 수 있습니다. 동기 실행 후 &lt;code&gt;EXITSTAT&lt;/code&gt; 에는 &lt;code&gt;system&lt;/code&gt; 에서 리턴 한대로 명령의 정수 종료 코드가 포함 됩니다 . 명령 행이 실행 된 경우 (종료 상태가 무엇이든) &lt;code&gt;CMDSTAT&lt;/code&gt; 는 0으로 설정됩니다. 오류가 발생하면 &lt;code&gt;CMDMSG&lt;/code&gt; 에 오류 메시지가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="76b048dbc2a9186b5f83e47a87d8985393f66ae2" translate="yes" xml:space="preserve">
          <source>The transformational function uses a recurrence algorithm which might, for some values of &lt;var&gt;X&lt;/var&gt;, lead to different results than calls to the elemental function.</source>
          <target state="translated">변환 함수는 &lt;var&gt;X&lt;/var&gt; 의 일부 값에 대해 요소 함수 호출과 다른 결과를 초래할 수있는 반복 알고리즘을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="e948b80cb7634d9e146c3c4cd97e720da8293b87" translate="yes" xml:space="preserve">
          <source>The two maps share memory, and the size of the union is ultimately six bytes:</source>
          <target state="translated">두 맵은 메모리를 공유하며 공용체의 크기는 궁극적으로 6 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="262c2c26c9d4d716ef902e5e289d6414c127cfc0" translate="yes" xml:space="preserve">
          <source>The two sections below detail the extensions to standard Fortran that are implemented in GNU Fortran, as well as some of the popular or historically important extensions that are not (or not yet) implemented. For the latter case, we explain the alternatives available to GNU Fortran users, including replacement by standard-conforming code or GNU extensions.</source>
          <target state="translated">아래의 두 섹션은 GNU Fortran에서 구현 된 표준 Fortran 확장과 아직 구현되지 않았거나 아직 구현되지 않은 역사적으로 중요한 확장 중 일부에 대해 자세히 설명합니다. 후자의 경우 표준 준수 코드 또는 GNU 확장으로 대체하는 것을 포함하여 GNU Fortran 사용자가 사용할 수있는 대안을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bcfae381a0eef2dc76bc9418159791a9ca625429" translate="yes" xml:space="preserve">
          <source>The type and kind of the result are those of the arguments.</source>
          <target state="translated">결과의 유형과 종류는 논쟁의 유형과 종류입니다.</target>
        </trans-unit>
        <trans-unit id="dd135a1aca29e33ba458b4303e44879b82e09f3f" translate="yes" xml:space="preserve">
          <source>The type and kind of the result are those of the arguments. (As a GNU extension, kind is the largest kind of the actual arguments.)</source>
          <target state="translated">결과의 유형과 종류는 인수의 것입니다. (GNU 확장으로서 kind는 실제 인수 중 가장 큰 종류입니다.)</target>
        </trans-unit>
        <trans-unit id="b60d7601344c5a76fe23d562a35e95b6cd3dea0d" translate="yes" xml:space="preserve">
          <source>The type and kind type parameter shall be the same as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">유형 및 종류 유형 매개 변수는 &lt;var&gt;X&lt;/var&gt; 와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="82b301b08e2a4fecedb703e179985e48328b7a90" translate="yes" xml:space="preserve">
          <source>The type and kind type parameter shall be the same as &lt;var&gt;Y&lt;/var&gt;. If &lt;var&gt;Y&lt;/var&gt; is zero, then &lt;var&gt;X&lt;/var&gt; must be nonzero.</source>
          <target state="translated">유형 및 종류 유형 매개 변수는 &lt;var&gt;Y&lt;/var&gt; 와 동일해야합니다 . 경우 &lt;var&gt;Y&lt;/var&gt; 가 제로이며, 다음 &lt;var&gt;X&lt;/var&gt; 는 제로해야합니다.</target>
        </trans-unit>
        <trans-unit id="751d8f91b294511309a460716d26411b1fe93de1" translate="yes" xml:space="preserve">
          <source>The type may be &lt;code&gt;INTEGER&lt;/code&gt; or &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; 또는 &lt;code&gt;REAL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8f2ea0d4d6ab9dc7bd366ab4f0dd6a79aa826cb" translate="yes" xml:space="preserve">
          <source>The type may be &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, or &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72337e0bbf2eed4e1d2af8058240e838f1642aef" translate="yes" xml:space="preserve">
          <source>The type name may be ommitted, in which case the structure type itself is anonymous, and other structures of the same type cannot be instantiated. The following shows some examples:</source>
          <target state="translated">유형 이름은 생략 될 수 있으며,이 경우 구조 유형 자체는 익명이며 동일한 유형의 다른 구조는 인스턴스화 할 수 없습니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="d93c0e4e182c185d842cdedd7b10bce1e0b09ec2" translate="yes" xml:space="preserve">
          <source>The type of a function result is declared more than once with the same type. If</source>
          <target state="translated">함수 결과의 유형은 동일한 유형으로 두 번 이상 선언됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="8cc354975027bfd2028d021bf406aae4e3c2d38f" translate="yes" xml:space="preserve">
          <source>The type of the argument shall be &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">인수의 유형은 &lt;code&gt;COMPLEX&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="93d3d86c4793cd0d4401ee7d242dfcc9aa3063bc" translate="yes" xml:space="preserve">
          <source>The type of the argument shall be &lt;code&gt;LOGICAL&lt;/code&gt; and it shall not be scalar.</source>
          <target state="translated">인수의 유형은 &lt;code&gt;LOGICAL&lt;/code&gt; 형 이어야하며 스칼라가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="a1874399dd8debb219c5166e114bcbc5bf94b1dd" translate="yes" xml:space="preserve">
          <source>The type of the argument shall be &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">인수의 유형은 &lt;code&gt;REAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ceb8e964c7fd1ebadc2b5eede315eb190e2024b" translate="yes" xml:space="preserve">
          <source>The type of the argument shall be a &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">인수의 유형은 &lt;code&gt;INTEGER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="06e32e8771daa785aeef2c61d1c640563e957265" translate="yes" xml:space="preserve">
          <source>The type of the argument shall be a &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">인수의 유형은 &lt;code&gt;REAL&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac8d7b662297ea3c01d30c6ccc66589e2943b18a" translate="yes" xml:space="preserve">
          <source>The type of the argument shall be a scalar &lt;code&gt;INTEGER&lt;/code&gt;. It is &lt;code&gt;INTENT(IN)&lt;/code&gt;.</source>
          <target state="translated">인수의 유형은 스칼라 &lt;code&gt;INTEGER&lt;/code&gt; 입니다. 그것은이다 &lt;code&gt;INTENT(IN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc735b17b3e1f45f00cd00ddaaaff079cc26f77b" translate="yes" xml:space="preserve">
          <source>The type of the argument shall be an &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, or &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">인수의 유형은 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6a26da1da7695d65728a115e85aba923eff3ae08" translate="yes" xml:space="preserve">
          <source>The type of the return value is the default &lt;code&gt;INTEGER&lt;/code&gt;. If all the bits of &lt;code&gt;I&lt;/code&gt; are zero, the result value is &lt;code&gt;BIT_SIZE(I)&lt;/code&gt;.</source>
          <target state="translated">리턴 값의 유형은 기본 &lt;code&gt;INTEGER&lt;/code&gt; 입니다. &lt;code&gt;I&lt;/code&gt; 의 모든 비트 가 0이면 결과 값은 &lt;code&gt;BIT_SIZE(I)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fbe3f02380e2b541d6e5457e7fd0a69d68d25ff" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;CHARACTER&lt;/code&gt; and of default kind.</source>
          <target state="translated">유형은 &lt;code&gt;CHARACTER&lt;/code&gt; 이고 기본 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ac9263fbe3acf460bfb8625ad993bbd135775a9" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;CHARACTER&lt;/code&gt; of default kind and shall specify a valid path within the file system.</source>
          <target state="translated">유형 은 기본 종류의 &lt;code&gt;CHARACTER&lt;/code&gt; 여야하며 파일 시스템 내에서 유효한 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d5803c299829066d26b7e0ce007201e4f888669" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;CHARACTER&lt;/code&gt; of the default kind, a valid path within the file system.</source>
          <target state="translated">유형 은 파일 시스템 내에서 유효한 경로 인 기본 종류의 &lt;code&gt;CHARACTER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1191d123664006490d5882a44e897251d5c2caab" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;CHARACTER&lt;/code&gt;, of the default kind and a valid path within the file system.</source>
          <target state="translated">유형 은 기본 종류의 &lt;code&gt;CHARACTER&lt;/code&gt; 이며 파일 시스템 내의 유효한 경로입니다.</target>
        </trans-unit>
        <trans-unit id="f3c4911b8a9b58407af0c2fbaba9514d93d71561" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;CHARACTER&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;CHARACTER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb22e9421ec5f9f0d104cf9bb996a9f8d7dee861" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;COMPLEX(8)&lt;/code&gt;.</source>
          <target state="translated">형식은 &lt;code&gt;COMPLEX(8)&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="06b67a221511c0e137257882d1e9e59a3a6a906a" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">형식은 &lt;code&gt;COMPLEX&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa76ae774f29008bb21faf05fe5ccb873dccc65b" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER(4), DIMENSION(13)&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER(4), DIMENSION(13)&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="49195e157b64b566b580d8516dbc048e0859f5ec" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER, DIMENSION(3)&lt;/code&gt; and the kind shall be the default integer kind.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER, DIMENSION(3)&lt;/code&gt; 이고 종류는 기본 정수 종류입니다.</target>
        </trans-unit>
        <trans-unit id="91ac4567f922029acc27911837202a12cd629a6c" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt; or &lt;code&gt;REAL&lt;/code&gt;</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; 또는 &lt;code&gt;REAL&lt;/code&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6d2189a5d0c4283c4e9be116f62bac9339b0eae3" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt; or &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; 또는 &lt;code&gt;REAL&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e640f8d3716ba6d12a4818ad86507a012d12c244" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt; or a boz-literal-constant.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; 또는 boz-literal-constant입니다.</target>
        </trans-unit>
        <trans-unit id="b7033141ab7807510ed446e758a073d59e78db46" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt; with the same kind type parameter as &lt;var&gt;I&lt;/var&gt; or a boz-literal-constant. &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt; shall not both be boz-literal-constants.</source>
          <target state="translated">유형 은 &lt;var&gt;I&lt;/var&gt; 또는 boz-literal-constant 와 동일한 유형 매개 변수를 갖는 &lt;code&gt;INTEGER&lt;/code&gt; 여야합니다 . &lt;var&gt;I&lt;/var&gt; 와 &lt;var&gt;J&lt;/var&gt; 는 모두 boz-literal-constants가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2398afaa22acebf6c886fed2e5dc8c055949c3e0" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, or &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="423f64bb13fd0d42f68ddc7daa7ff17b2469804e" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt;, of the same kind as &lt;var&gt;FROM&lt;/var&gt;.</source>
          <target state="translated">형식 은 &lt;var&gt;FROM&lt;/var&gt; 과 같은 종류의 &lt;code&gt;INTEGER&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="cd7da9b9811c2580ca363bb937e63ef59f2802c6" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt;, of the same kind as &lt;var&gt;I&lt;/var&gt;. (As a GNU extension, different kinds are also permitted.)</source>
          <target state="translated">유형 은 &lt;var&gt;I&lt;/var&gt; 와 같은 종류의 &lt;code&gt;INTEGER&lt;/code&gt; 입니다. (GNU 확장으로서 다른 종류도 허용됩니다.)</target>
        </trans-unit>
        <trans-unit id="9ada3b2664ea127dd02d2db4489e10c7cbecc094" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc3226094e6148191cbe212a1c5e1db104d20630" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;INTEGER&lt;/code&gt;. It represents the location of the memory that should be de-allocated.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; 입니다. 할당 해제해야 할 메모리의 위치를 ​​나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d658f58c3260d8a5faf85a1dcf5910d294af1e67" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;LOGICAL&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;LOGICAL&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1f6885c8dbbf74fea9a2c2207ed5c178cfd8486c" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;REAL(4), DIMENSION(2)&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;REAL(4), DIMENSION(2)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="98eecf6903ab82ddba4992ccecbade0f5e4dc553" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;REAL(4)&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;REAL(4)&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="53e0fc940e7cbebaeb46dba0fae40184676739e7" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;REAL&lt;/code&gt; or &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7c7235d467d216904c788cbcc38511c2e9b34bd" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;REAL&lt;/code&gt; or &lt;code&gt;COMPLEX&lt;/code&gt;; if &lt;var&gt;Y&lt;/var&gt; is present, &lt;var&gt;X&lt;/var&gt; shall be REAL.</source>
          <target state="translated">유형은 &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 입니다 . 만약 &lt;var&gt;Y&lt;/var&gt; 가 존재하고, &lt;var&gt;X&lt;/var&gt; 는 REAL한다.</target>
        </trans-unit>
        <trans-unit id="9db9c2eb618b2ddd88b7468a00b9cefb69525c6a" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;REAL&lt;/code&gt; with &lt;code&gt;INTENT(OUT)&lt;/code&gt;.</source>
          <target state="translated">유형 은 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 과 &lt;code&gt;REAL&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a1d18069968fd48b59b8a6d6c93958c7b56552e" translate="yes" xml:space="preserve">
          <source>The type shall be &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;REAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8845fd97fc1463c357a0d65af6946451066b800c" translate="yes" xml:space="preserve">
          <source>The type shall be either &lt;code&gt;REAL&lt;/code&gt; and a magnitude that is less than or equal to one - or be &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;REAL&lt;/code&gt; 이고 1보다 작거나 같은 크기이거나 &lt;code&gt;COMPLEX&lt;/code&gt; 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="e5a30dd13926b2e12959183c6903362c0105b0fd" translate="yes" xml:space="preserve">
          <source>The type shall be either a scalar &lt;code&gt;INTEGER&lt;/code&gt; type or a scalar &lt;code&gt;LOGICAL&lt;/code&gt; type or a boz-literal-constant.</source>
          <target state="translated">유형은 스칼라 &lt;code&gt;INTEGER&lt;/code&gt; 유형 또는 스칼라 &lt;code&gt;LOGICAL&lt;/code&gt; 유형 또는 boz-literal-constant입니다.</target>
        </trans-unit>
        <trans-unit id="94fbd5f24d0acbd8e22e93455330e0fd225c853c" translate="yes" xml:space="preserve">
          <source>The type shall be either a scalar &lt;code&gt;INTEGER&lt;/code&gt; type or a scalar &lt;code&gt;LOGICAL&lt;/code&gt; type.</source>
          <target state="translated">유형은 스칼라 &lt;code&gt;INTEGER&lt;/code&gt; 유형이거나 스칼라 &lt;code&gt;LOGICAL&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec7ca22141e4b9a06e5dda596780008cef2fb919" translate="yes" xml:space="preserve">
          <source>The type shall be numeric if &lt;var&gt;VECTOR_A&lt;/var&gt; is of numeric type or &lt;code&gt;LOGICAL&lt;/code&gt; if &lt;var&gt;VECTOR_A&lt;/var&gt; is of type &lt;code&gt;LOGICAL&lt;/code&gt;. &lt;var&gt;VECTOR_B&lt;/var&gt; shall be a rank-one array.</source>
          <target state="translated">만약 타입은 숫자한다 &lt;var&gt;VECTOR_A&lt;/var&gt; 는 숫자 나 타입이다 &lt;code&gt;LOGICAL&lt;/code&gt; 경우 &lt;var&gt;VECTOR_A&lt;/var&gt; 가 형이고 &lt;code&gt;LOGICAL&lt;/code&gt; . &lt;var&gt;VECTOR_B&lt;/var&gt; 는 1 순위 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4a6bd7e1bb25961611a360c9aea3894916ae7a04" translate="yes" xml:space="preserve">
          <source>The type shall be numeric or &lt;code&gt;LOGICAL&lt;/code&gt;, rank 1.</source>
          <target state="translated">유형은 숫자 또는 &lt;code&gt;LOGICAL&lt;/code&gt; , 순위 1 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f72f1156bbda3a66bb289860d34381f4dab86e4f" translate="yes" xml:space="preserve">
          <source>The type shall be of default &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">유형은 기본 &lt;code&gt;INTEGER&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d5327a23ce03329961ba946fd7f5361a11ebb85" translate="yes" xml:space="preserve">
          <source>The type shall be of type &lt;code&gt;CHARACTER&lt;/code&gt; and of default kind. It is an &lt;code&gt;INTENT(OUT)&lt;/code&gt; argument. If the length of this variable is too short for the time and date string to fit completely, it will be blank on procedure return.</source>
          <target state="translated">유형은 &lt;code&gt;CHARACTER&lt;/code&gt; 유형 이며 기본 유형이어야합니다 . 그것은이다 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 인수. 이 변수의 길이가 시간 및 날짜 문자열이 완전히 맞지 않을 정도로 짧으면 프로 시저 리턴시 공백입니다.</target>
        </trans-unit>
        <trans-unit id="d3bc2bd1c32b2500e670a40e260b765d1daa5ffd" translate="yes" xml:space="preserve">
          <source>The type shall be of type &lt;code&gt;CHARACTER&lt;/code&gt; of the default kind. It is an &lt;code&gt;INTENT(OUT)&lt;/code&gt; argument. If the length of this variable is too short for the date and time string to fit completely, it will be blank on procedure return.</source>
          <target state="translated">유형 은 기본 종류의 &lt;code&gt;CHARACTER&lt;/code&gt; 유형이어야합니다 . 그것은이다 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 인수. 이 변수의 길이가 날짜 및 시간 문자열이 완전히 맞지 않을 정도로 짧으면 프로 시저 리턴시 공백입니다.</target>
        </trans-unit>
        <trans-unit id="5f826de915dcf6de08abe91e02c9b917f35ea9d8" translate="yes" xml:space="preserve">
          <source>The type shall be of type &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;code&gt;INTEGER&lt;/code&gt; 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0455977db0b358c9c374904b286d9d5e35bd7233" translate="yes" xml:space="preserve">
          <source>The type shall be the same as the type of &lt;var&gt;I&lt;/var&gt; or a boz-literal-constant. &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt; shall not both be boz-literal-constants. If either &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt; is a boz-literal-constant, then the other argument must be a scalar &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;var&gt;I&lt;/var&gt; 또는 boz-literal-constant 의 유형과 동일해야합니다 . &lt;var&gt;I&lt;/var&gt; 와 &lt;var&gt;J&lt;/var&gt; 는 모두 boz-literal-constants가 아닙니다. 어느 경우 &lt;var&gt;I&lt;/var&gt; 와 &lt;var&gt;J&lt;/var&gt; 는 보즈 - 문자 상수이며, 다음 다른 인수는 스칼라해야 &lt;code&gt;INTEGER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52f6b28315bae2355372b670b1e0b04942b6ec56" translate="yes" xml:space="preserve">
          <source>The type shall be the same as the type of &lt;var&gt;I&lt;/var&gt; or a boz-literal-constant. &lt;var&gt;I&lt;/var&gt; and &lt;var&gt;J&lt;/var&gt; shall not both be boz-literal-constants. If either &lt;var&gt;I&lt;/var&gt; or &lt;var&gt;J&lt;/var&gt; is a boz-literal-constant, then the other argument must be a scalar &lt;code&gt;INTEGER&lt;/code&gt;.</source>
          <target state="translated">유형은 &lt;var&gt;I&lt;/var&gt; 또는 boz-literal-constant 의 유형과 동일해야합니다 . &lt;var&gt;I&lt;/var&gt; 와 &lt;var&gt;J&lt;/var&gt; 는 모두 boz-literal-constants가 아닙니다. 어느 경우 &lt;var&gt;I&lt;/var&gt; 또는 &lt;var&gt;J&lt;/var&gt; 가 보즈 - 문자 상수이며, 다음 다른 인수는 스칼라해야 &lt;code&gt;INTEGER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fab4c8cedc4a7416040514c677a6e882f57b066" translate="yes" xml:space="preserve">
          <source>The type shall be the same as the type of &lt;var&gt;I&lt;/var&gt;.</source>
          <target state="translated">타입은 &lt;var&gt;I&lt;/var&gt; 타입과 동일해야한다 .</target>
        </trans-unit>
        <trans-unit id="26736d9505849944df4354034817057ec4ee69a6" translate="yes" xml:space="preserve">
          <source>The type shall be the same as the type of &lt;var&gt;J&lt;/var&gt;.</source>
          <target state="translated">타입은 &lt;var&gt;J&lt;/var&gt; 타입과 동일해야한다 .</target>
        </trans-unit>
        <trans-unit id="a40fb18a4c682357ac4bf46cfe1b7ca7c8f3ffbb" translate="yes" xml:space="preserve">
          <source>The type shall be the same type and kind as &lt;var&gt;X&lt;/var&gt;.</source>
          <target state="translated">유형은 &lt;var&gt;X&lt;/var&gt; 와 유형 및 종류가 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b55cb762dcab77e36401e60098066687e4343226" translate="yes" xml:space="preserve">
          <source>The type shall be the same type and kind as &lt;var&gt;X&lt;/var&gt;. (As a GNU extension, arguments of different kinds are permitted.)</source>
          <target state="translated">유형은 &lt;var&gt;X&lt;/var&gt; 와 동일한 유형 및 종류 여야합니다 . (GNU 확장으로서 다른 종류의 인수가 허용됩니다.)</target>
        </trans-unit>
        <trans-unit id="d8835b12c862d6d220d2c23db41fba6f0af76889" translate="yes" xml:space="preserve">
          <source>The type shall either be &lt;code&gt;REAL&lt;/code&gt; with a magnitude that is less than or equal to one - or the type shall be &lt;code&gt;COMPLEX&lt;/code&gt;.</source>
          <target state="translated">유형 은 1보다 작거나 같은 크기의 &lt;code&gt;REAL&lt;/code&gt; 이거나 유형이 &lt;code&gt;COMPLEX&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2a61b360fc68557bef0129d9bac7f2f1c8be4d5c" translate="yes" xml:space="preserve">
          <source>The typical use is to check the local event variable to only call &lt;code&gt;event_wait&lt;/code&gt; when the data is available. However, a coindexed variable is permitted; there is no ordering or synchronization implied. It acts like an atomic fetch of the value of the event variable.</source>
          <target state="translated">일반적으로 데이터를 사용할 수있을 때 &lt;code&gt;event_wait&lt;/code&gt; 만 호출하도록 로컬 이벤트 변수를 확인합니다 . 그러나 공동 색인화 된 변수는 허용됩니다. 주문 또는 동기화가 암시되지 않습니다. 이벤트 변수 값의 원자 적 페치처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b26c90a9256d5a439ecc493931c274578b970f64" translate="yes" xml:space="preserve">
          <source>The use of strings is now further illustrated using the C library function &lt;code&gt;strncpy&lt;/code&gt;, whose prototype is</source>
          <target state="translated">문자열의 사용은 이제 상기 C 라이브러리 함수를 이용하여 도시되어 &lt;code&gt;strncpy&lt;/code&gt; 에서 누구의 프로토 타입을</target>
        </trans-unit>
        <trans-unit id="fb593af2f8485dd7a7d7b8f147a99dc20d1b9c75" translate="yes" xml:space="preserve">
          <source>The use of the</source>
          <target state="translated">의 사용</target>
        </trans-unit>
        <trans-unit id="d5f9011906ddcee052fe235787a5b3d54198f0cb" translate="yes" xml:space="preserve">
          <source>The value assigned to the variable passed to the &lt;code&gt;IOSTAT=&lt;/code&gt; specifier of an input/output statement if an end-of-file condition occurred.</source>
          <target state="translated">파일 끝 조건이 발생한 경우 변수에 지정된 값 이 입 / 출력 명령문 의 &lt;code&gt;IOSTAT=&lt;/code&gt; 지정자로 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4719f11c07d3f3c8ce4ac8fd00cd9775f6091e99" translate="yes" xml:space="preserve">
          <source>The value assigned to the variable passed to the &lt;code&gt;IOSTAT=&lt;/code&gt; specifier of an input/output statement if an end-of-record condition occurred.</source>
          <target state="translated">레코드 끝 조건이 발생한 경우 변수에 지정된 값 이 입력 / 출력 명령문 의 &lt;code&gt;IOSTAT=&lt;/code&gt; 지정자로 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3e536cd1dcbd59b580aa893db3378560129f426d" translate="yes" xml:space="preserve">
          <source>The value of the conversion can be queried by using &lt;code&gt;INQUIRE(CONVERT=ch)&lt;/code&gt;. The values returned are &lt;code&gt;'BIG_ENDIAN'&lt;/code&gt; and &lt;code&gt;'LITTLE_ENDIAN'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;INQUIRE(CONVERT=ch)&lt;/code&gt; 사용하여 변환 값을 조회 할 수 있습니다 . 리턴 된 값은 &lt;code&gt;'BIG_ENDIAN'&lt;/code&gt; 및 &lt;code&gt;'LITTLE_ENDIAN'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3096c64b44533dfc371fdf31cd22b8c410e097ac" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; and &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY&lt;/code&gt; are for allocatable components in derived type coarrays only. The first one sets up the token without allocating memory for allocatable component. The latter one only allocates the memory for an allocatable component in a derived type coarray. The token needs to be setup previously by the REGISTER_ONLY. This allows to have allocatable components un-allocated on some images. The status whether an allocatable component is allocated on a remote image can be queried by &lt;code&gt;_caf_is_present&lt;/code&gt; which used internally by the &lt;code&gt;ALLOCATED&lt;/code&gt; intrinsic.</source>
          <target state="translated">&lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; 및 &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY&lt;/code&gt; 값 은 파생 된 유형의 배열에서 할당 가능한 구성 요소에만 해당됩니다. 첫 번째는 할당 가능한 구성 요소에 메모리를 할당하지 않고 토큰을 설정합니다. 후자는 파생 된 유형의 배열에서 할당 가능한 구성 요소에 대한 메모리 만 할당합니다. 토큰은 REGISTER_ONLY에서 미리 설정해야합니다. 이를 통해 일부 이미지에서 할당 가능한 구성 요소를 할당 해제 할 수 있습니다. 할당 가능한 컴포넌트가 원격 이미지에 할당되는지 여부는 &lt;code&gt;ALLOCATED&lt;/code&gt; 내장 함수에 의해 내부적으로 사용 되는 &lt;code&gt;_caf_is_present&lt;/code&gt; 로 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e62877336f5ec6496c8f902184b7517e2b17ee0" translate="yes" xml:space="preserve">
          <source>The variable consists of an optional default mode, followed by a list of optional exceptions, which are separated by semicolons from the preceding default and each other. Each exception consists of a format and a comma-separated list of units. Valid values for the modes are the same as for the &lt;code&gt;CONVERT&lt;/code&gt; specifier:</source>
          <target state="translated">변수는 선택적 기본 모드와 선택적 예외 목록으로 구성되며, 앞의 기본값과 서로 세미콜론으로 구분됩니다. 각 예외는 형식과 쉼표로 구분 된 단위 목록으로 구성됩니다. 모드의 유효한 값은 &lt;code&gt;CONVERT&lt;/code&gt; 지정자 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="109448d45cda92cd38e03fa0cd8353b386cdad87" translate="yes" xml:space="preserve">
          <source>The year</source>
          <target state="translated">그 해</target>
        </trans-unit>
        <trans-unit id="3b63780e5af2f3c57683186b887d40e59e0c09a1" translate="yes" xml:space="preserve">
          <source>There are a number of restrictions on the attributes that can be applied to Cray pointers and pointees. Pointees may not have the &lt;code&gt;ALLOCATABLE&lt;/code&gt;, &lt;code&gt;INTENT&lt;/code&gt;, &lt;code&gt;OPTIONAL&lt;/code&gt;, &lt;code&gt;DUMMY&lt;/code&gt;, &lt;code&gt;TARGET&lt;/code&gt;, &lt;code&gt;INTRINSIC&lt;/code&gt;, or &lt;code&gt;POINTER&lt;/code&gt; attributes. Pointers may not have the &lt;code&gt;DIMENSION&lt;/code&gt;, &lt;code&gt;POINTER&lt;/code&gt;, &lt;code&gt;TARGET&lt;/code&gt;, &lt;code&gt;ALLOCATABLE&lt;/code&gt;, &lt;code&gt;EXTERNAL&lt;/code&gt;, or &lt;code&gt;INTRINSIC&lt;/code&gt; attributes, nor may they be function results. Pointees may not occur in more than one pointer statement. A pointee cannot be a pointer. Pointees cannot occur in equivalence, common, or data statements.</source>
          <target state="translated">Cray 포인터 및 포인트에 적용 할 수있는 속성에는 여러 가지 제한이 있습니다. Pointees은 없을 수 있습니다 &lt;code&gt;ALLOCATABLE&lt;/code&gt; , &lt;code&gt;INTENT&lt;/code&gt; , &lt;code&gt;OPTIONAL&lt;/code&gt; , &lt;code&gt;DUMMY&lt;/code&gt; , &lt;code&gt;TARGET&lt;/code&gt; , &lt;code&gt;INTRINSIC&lt;/code&gt; , 또는 &lt;code&gt;POINTER&lt;/code&gt; 특성을. 포인터에는 &lt;code&gt;DIMENSION&lt;/code&gt; , &lt;code&gt;POINTER&lt;/code&gt; , &lt;code&gt;TARGET&lt;/code&gt; , &lt;code&gt;ALLOCATABLE&lt;/code&gt; , &lt;code&gt;EXTERNAL&lt;/code&gt; 또는 &lt;code&gt;INTRINSIC&lt;/code&gt; 속성이 없거나 함수 결과가 될 수 없습니다. Pointee는 둘 이상의 포인터 문에서 발생할 수 없습니다. 포인트는 포인터가 될 수 없습니다. 포인트는 동등성, 공통 또는 데이터 진술에서 발생할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4b5193ed4beb969198ed57f8498f98bf39a4c7d" translate="yes" xml:space="preserve">
          <source>Therefore, if your &lt;code&gt;PROGRAM&lt;/code&gt; is not compiled with GNU Fortran and the GNU Fortran compiled procedures require intrinsics relying on the library initialization, you need to initialize the library yourself. Using the default options, gfortran calls &lt;code&gt;_gfortran_set_args&lt;/code&gt; and &lt;code&gt;_gfortran_set_options&lt;/code&gt;. The initialization of the former is needed if the called procedures access the command line (and for backtracing); the latter sets some flags based on the standard chosen or to enable backtracing. In typical programs, it is not necessary to call any initialization function.</source>
          <target state="translated">따라서 &lt;code&gt;PROGRAM&lt;/code&gt; 이 GNU Fortran으로 컴파일되지 않고 GNU Fortran 컴파일 절차에서 라이브러리 초기화에 의존하는 내장 함수가 필요한 경우 라이브러리를 직접 초기화해야합니다. 기본 옵션을 사용하여 gfortran은 &lt;code&gt;_gfortran_set_args&lt;/code&gt; 및 &lt;code&gt;_gfortran_set_options&lt;/code&gt; 를 호출합니다 . 호출 된 프로 시저가 명령 행에 액세스하고 역 추적을 수행하는 경우 전자의 초기화가 필요합니다. 후자는 선택한 표준에 따라 또는 역 추적을 활성화하기 위해 일부 플래그를 설정합니다. 일반적인 프로그램에서는 초기화 함수를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="77e19f5b5e0547ddf8dbdd2c925284ab5527bc06" translate="yes" xml:space="preserve">
          <source>These affect interpretation of the &lt;code&gt;INCLUDE&lt;/code&gt; directive (as well as of the &lt;code&gt;#include&lt;/code&gt; directive of the &lt;code&gt;cpp&lt;/code&gt; preprocessor).</source>
          <target state="translated">이는 &lt;code&gt;INCLUDE&lt;/code&gt; 지시문 ( &lt;code&gt;cpp&lt;/code&gt; 전 처리기 의 &lt;code&gt;#include&lt;/code&gt; 지시문)의 해석에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="ef3bfde35380344720b3705131f2b7157e7c6c81" translate="yes" xml:space="preserve">
          <source>These functions return a &lt;code&gt;INTEGER&lt;/code&gt; variable or array under the following rules:</source>
          <target state="translated">이 함수 는 다음 규칙에 따라 &lt;code&gt;INTEGER&lt;/code&gt; 변수 또는 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c64413df2ece9f7b1f68f08d4c3768a8444b0404" translate="yes" xml:space="preserve">
          <source>These functions return a &lt;code&gt;REAL&lt;/code&gt; variable or array under the following rules:</source>
          <target state="translated">이 함수 는 다음 규칙에 따라 &lt;code&gt;REAL&lt;/code&gt; 변수 또는 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9b9701e15c9d94aa04294acbc1a1a03ddc6872e2" translate="yes" xml:space="preserve">
          <source>These machine-independent options control the interface conventions used in code generation.</source>
          <target state="translated">이러한 머신 독립적 옵션은 코드 생성에 사용되는 인터페이스 규칙을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a0382784bb77d0eef10d617838d494ddb43f0ff9" translate="yes" xml:space="preserve">
          <source>These options affect how GNU Fortran searches for files specified by the &lt;code&gt;INCLUDE&lt;/code&gt; directive and where it searches for previously compiled modules.</source>
          <target state="translated">이 옵션은 GNU Fortran이 &lt;code&gt;INCLUDE&lt;/code&gt; 지시문으로 지정된 파일을 검색하는 방법 과 이전에 컴파일 된 모듈을 검색하는 위치에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="9212e0d4ae1040d9de601a8656e96605a53c3da8" translate="yes" xml:space="preserve">
          <source>These options affect the runtime behavior of programs compiled with GNU Fortran.</source>
          <target state="translated">이 옵션은 GNU Fortran으로 컴파일 된 프로그램의 런타임 동작에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="024672ba12f6533c6267ee5ffbe7b18b0036fae5" translate="yes" xml:space="preserve">
          <source>These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.</source>
          <target state="translated">이 옵션은 컴파일러가 객체 파일을 실행 가능한 출력 파일에 연결할 때 사용됩니다. 컴파일러가 링크 단계를 수행하지 않으면 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="66481454213e08f056758bde6c4884e98bafbb08" translate="yes" xml:space="preserve">
          <source>These options control the amount and kinds of errors and warnings produced by GNU Fortran:</source>
          <target state="translated">이 옵션은 GNU Fortran이 생성하는 오류 및 경고의 양과 종류를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="4a18eb980bce33438d417cf38b9a8bbb9aa71b69" translate="yes" xml:space="preserve">
          <source>These options do not initialize</source>
          <target state="translated">이 옵션은 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9de3c712a06a63e8325149190f38205617b3b74b" translate="yes" xml:space="preserve">
          <source>This acts like an atomic add of one to the remote image&amp;rsquo;s event variable. The statement is an image-control statement but does not imply sync memory. Still, all preceeding push communications of this image to the specified remote image have to be completed before &lt;code&gt;event_wait&lt;/code&gt; on the remote image returns.</source>
          <target state="translated">이것은 원격 이미지의 이벤트 변수에 하나를 추가하는 것처럼 작동합니다. 명령문은 이미지 제어 명령문이지만 메모리 동기화를 의미하지는 않습니다. 여전히 원격 이미지의 &lt;code&gt;event_wait&lt;/code&gt; 가 리턴 되기 전에이 이미지의 지정된 원격 이미지에 대한 모든 선행 푸시 통신을 완료해야 합니다.</target>
        </trans-unit>
        <trans-unit id="22feb0461e5b7f6c0ba7f52a4663dfe24d62502d" translate="yes" xml:space="preserve">
          <source>This chapter describes certain characteristics of the GNU Fortran compiler, that are not specified by the Fortran standard, but which might in some way or another become visible to the programmer.</source>
          <target state="translated">이 장에서는 Fortran 표준에 의해 지정되지 않았지만 어떤 방식 으로든 프로그래머가 볼 수있는 GNU Fortran 컴파일러의 특정 특성에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2a4a43a7feae452bf5173b8a111e0a8262d577cf" translate="yes" xml:space="preserve">
          <source>This chapter is about mixed-language interoperability, but also applies if one links Fortran code compiled by different compilers. In most cases, use of the C Binding features of the Fortran 2003 standard is sufficient, and their use is highly recommended.</source>
          <target state="translated">이 장은 혼합 언어 상호 운용성에 관한 것이지만 다른 컴파일러가 컴파일 한 Fortran 코드를 링크 한 경우에도 적용됩니다. 대부분의 경우 Fortran 2003 표준의 C 바인딩 기능을 사용하는 것으로 충분하며 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f1e702b7214a6f7ca59d3d47c387289ebf5b4067" translate="yes" xml:space="preserve">
          <source>This code can easily be rewritten in the Fortran 90 syntax as following:</source>
          <target state="translated">이 코드는 다음과 같이 Fortran 90 구문으로 쉽게 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8656ad7821fd04eca3a624a8da4662c1420c6fe" translate="yes" xml:space="preserve">
          <source>This currently produces a warning under the following circumstances:</source>
          <target state="translated">현재 다음 상황에서 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="197a9a23ea62f4dbfbe96edba0cf2526747fb0b2" translate="yes" xml:space="preserve">
          <source>This directive is intended for annotation of existing code. For new code it is recommended to consider OpenMP SIMD directives as potential alternative.</source>
          <target state="translated">이 지시문은 기존 코드의 주석을위한 것입니다. 새 코드의 경우 OpenMP SIMD 지시문을 잠재적 인 대안으로 고려하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8ecad4e9d8fa92bb361e1868fdc79df79afe2276" translate="yes" xml:space="preserve">
          <source>This directive tells the compiler to ignore vector dependencies in the following loop. It must be placed immediately before a &lt;code&gt;DO&lt;/code&gt; loop and applies only to the loop that follows.</source>
          <target state="translated">이 지시문은 컴파일러가 다음 루프에서 벡터 종속성을 무시하도록 지시합니다. &lt;code&gt;DO&lt;/code&gt; 루프 바로 앞에 위치해야하며 다음 루프에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8fdec12332cdc958871af4cc82a52d567201791" translate="yes" xml:space="preserve">
          <source>This directive tells the compiler to not vectorize the following loop. It must be placed immediately before a &lt;code&gt;DO&lt;/code&gt; loop and applies only to the loop that follows.</source>
          <target state="translated">이 지시문은 컴파일러에게 다음 루프를 벡터화하지 않도록 지시합니다. &lt;code&gt;DO&lt;/code&gt; 루프 바로 앞에 위치해야하며 다음 루프에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="795f35f6b1b2bf87ba510c9877fa8ff5ca2f961d" translate="yes" xml:space="preserve">
          <source>This directive tells the compiler to vectorize the following loop. It must be placed immediately before a &lt;code&gt;DO&lt;/code&gt; loop and applies only to the loop that follows.</source>
          <target state="translated">이 지시문은 컴파일러에게 다음 루프를 벡터화하도록 지시합니다. &lt;code&gt;DO&lt;/code&gt; 루프 바로 앞에 위치해야하며 다음 루프에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a600f5bae88b8af4f41aa1dcd6b00bb0403b9073" translate="yes" xml:space="preserve">
          <source>This does not affect the generation of code that interfaces with the &lt;code&gt;libgfortran&lt;/code&gt; library.</source>
          <target state="translated">이것은 &lt;code&gt;libgfortran&lt;/code&gt; 라이브러리 와 인터페이스하는 코드 생성에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="28f0968dc8b67521c596f25f3a75db83bc49a3f8" translate="yes" xml:space="preserve">
          <source>This environment variable can be used to select the unit number preconnected to standard error. This must be a positive integer. The default value is 0.</source>
          <target state="translated">이 환경 변수를 사용하여 표준 오류에 사전 연결된 장치 번호를 선택할 수 있습니다. 양의 정수 여야합니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="cd6caa3d92713d5d3fd8a16b4a767da8d7286bed" translate="yes" xml:space="preserve">
          <source>This environment variable can be used to select the unit number preconnected to standard input. This must be a positive integer. The default value is 5.</source>
          <target state="translated">이 환경 변수를 사용하여 표준 입력에 사전 연결된 장치 번호를 선택할 수 있습니다. 양의 정수 여야합니다. 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="55be1592809c0c8fd62642ebfe31c0c986768a4b" translate="yes" xml:space="preserve">
          <source>This environment variable can be used to select the unit number preconnected to standard output. This must be a positive integer. The default value is 6.</source>
          <target state="translated">이 환경 변수를 사용하여 표준 출력에 사전 연결된 장치 번호를 선택할 수 있습니다. 양의 정수 여야합니다. 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="9edad1663ac8df062018ea2991b5d54b2936b869" translate="yes" xml:space="preserve">
          <source>This environment variable controls whether all I/O is unbuffered. If the first letter is &amp;lsquo;</source>
          <target state="translated">이 환경 변수는 모든 I / O의 버퍼링 해제 여부를 제어합니다. 첫 글자가 '</target>
        </trans-unit>
        <trans-unit id="ff0027efe7de9254829de09fdcc76e5978299729" translate="yes" xml:space="preserve">
          <source>This environment variable specifies the default record length, in bytes, for files which are opened without a &lt;code&gt;RECL&lt;/code&gt; tag in the &lt;code&gt;OPEN&lt;/code&gt; statement. This must be a positive integer. The default value is 1073741824 bytes (1 GB).</source>
          <target state="translated">이 환경 변수 는 &lt;code&gt;OPEN&lt;/code&gt; 문 에서 &lt;code&gt;RECL&lt;/code&gt; 태그 없이 열린 파일의 기본 레코드 길이 (바이트)를 지정합니다 . 양의 정수 여야합니다. 기본값은 1073741824 바이트 (1GB)입니다.</target>
        </trans-unit>
        <trans-unit id="8ea7fe46fc8c55d61a3db5fc15d498d1f4180d49" translate="yes" xml:space="preserve">
          <source>This environment variable specifies the separator when writing list-directed output. It may contain any number of spaces and at most one comma. If you specify this on the command line, be sure to quote spaces, as in</source>
          <target state="translated">이 환경 변수는 목록 지정 출력을 쓸 때 구분 기호를 지정합니다. 공백과 쉼표를 하나만 포함 할 수 있습니다. 명령 행에서이를 지정하면 다음과 같이 공백을 인용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c021d72749991c23356ffabd6dfbc56508b828a" translate="yes" xml:space="preserve">
          <source>This function follows TS18508.</source>
          <target state="translated">이 기능은 TS18508을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5c92002fa62b66e4c064f8a830ba00c4e17f2880" translate="yes" xml:space="preserve">
          <source>This function follows TS18508. Because team-functionality is not yet implemented a null-pointer is passed for the &lt;var&gt;team&lt;/var&gt; argument at the moment.</source>
          <target state="translated">이 기능은 TS18508을 따릅니다. 팀 기능이 아직 구현되지 않았으므로 현재 &lt;var&gt;team&lt;/var&gt; 인수에 대해 널 포인터가 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="281161dd77013053891d99d6b24620dd744c6d98" translate="yes" xml:space="preserve">
          <source>This function follows TS18508. If the num_image intrinsic has no arguments, then the compiler passes &lt;code&gt;distance=0&lt;/code&gt; and &lt;code&gt;failed=-1&lt;/code&gt; to the function.</source>
          <target state="translated">이 기능은 TS18508을 따릅니다. num_image 내장 함수에 인수가없는 경우 컴파일러는 &lt;code&gt;distance=0&lt;/code&gt; 및 &lt;code&gt;failed=-1&lt;/code&gt; 을 함수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="36843c9a9d81510495a2de5041a8f388c0b515d9" translate="yes" xml:space="preserve">
          <source>This function has been superseded by the &lt;code&gt;ISHFT&lt;/code&gt; intrinsic, which is standard in Fortran 95 and later, and the &lt;code&gt;SHIFTL&lt;/code&gt; intrinsic, which is standard in Fortran 2008 and later.</source>
          <target state="translated">이 기능은 Fortran 95 이상에서 표준 인 &lt;code&gt;ISHFT&lt;/code&gt; 내장 함수와 Fortran 2008 이상에서 표준 인 &lt;code&gt;SHIFTL&lt;/code&gt; 내장 함수로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8d5185981845465d6f936768cfaf1c8479d1f960" translate="yes" xml:space="preserve">
          <source>This function has been superseded by the &lt;code&gt;SHIFTA&lt;/code&gt; intrinsic, which is standard in Fortran 2008 and later.</source>
          <target state="translated">이 기능은 Fortran 2008 이상에서 표준 인 &lt;code&gt;SHIFTA&lt;/code&gt; 내장 함수로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7883b9835b542c667123819e0017b2ed606c2e97" translate="yes" xml:space="preserve">
          <source>This function is also called for critical block; for those, the array index is always zero and the image index is one. Libraries are permitted to use other images for critical-block locking variables.</source>
          <target state="translated">이 기능은 크리티컬 블록에도 필요합니다. 이를 위해 배열 인덱스는 항상 0이고 이미지 인덱스는 1입니다. 라이브러리는 임계 블록 잠금 변수에 다른 이미지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4e94494ad79c851ab73148a3f8bfbbeeeb9909" translate="yes" xml:space="preserve">
          <source>This function is also called for critical blocks; for those, the array index is always zero and the image index is one. Libraries are permitted to use other images for critical-block locking variables.</source>
          <target state="translated">이 기능은 임계 블록에도 필요합니다. 이를 위해 배열 인덱스는 항상 0이고 이미지 인덱스는 1입니다. 라이브러리는 임계 블록 잠금 변수에 다른 이미지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39f3abb212933541d2d1b3129f0bc0b04deb34de" translate="yes" xml:space="preserve">
          <source>This function is called at startup of the program before the Fortran main program, if the latter has been compiled with</source>
          <target state="translated">이 함수는 Fortran 메인 프로그램 이전에 프로그램을 시작할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="966affa2d8ec1c35095281de0ab1620333c77c35" translate="yes" xml:space="preserve">
          <source>This function is called at the end of the Fortran main program, if it has been compiled with the</source>
          <target state="translated">이 함수는 Fortran 메인 프로그램의 끝에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7c33170ca1e280e7028e9de505f203126b99ce8a" translate="yes" xml:space="preserve">
          <source>This function is for compatibility only and should be avoided in favor of standard constructs wherever possible.</source>
          <target state="translated">이 기능은 호환성을 위해서만 사용되며 가능한 경우 표준 구성을 위해 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="f40c18ee3caf97ebb024c915f4966940a7077192" translate="yes" xml:space="preserve">
          <source>This function only operates on a local coarray. It acts like a loop checking atomically the value of the event variable, breaking if the value is greater or equal the requested number of counts. Before the function returns, the event variable has to be decremented by the requested &lt;var&gt;until_count&lt;/var&gt; value. A possible implementation would be a busy loop for a certain number of spins (possibly depending on the number of threads relative to the number of available cores) followed by another waiting strategy such as a sleeping wait (possibly with an increasing number of sleep time) or, if possible, a futex wait.</source>
          <target state="translated">이 기능은 로컬 거친에서만 작동합니다. 그것은 이벤트 변수의 값을 원자 적으로 검사하는 루프처럼 작동하여 값이 요청 된 카운트 수보다 크거나 같은 경우 깨집니다. 함수가 리턴되기 전에 이벤트 변수는 요청 된 &lt;var&gt;until_count&lt;/var&gt; 값 만큼 감소 해야 합니다. 가능한 구현은 특정 수의 스핀 (사용 가능한 코어 수에 대한 스레드 수에 따라 다름)에 이어 사용하지 않는 수면 대기와 같은 다른 대기 전략 (수면 시간이 늘어날 수 있음)에 대한 사용 중 루프입니다. 또는 가능하면 futex 대기.</target>
        </trans-unit>
        <trans-unit id="8e82c777fee24347fe2a752fe09317af253677a8" translate="yes" xml:space="preserve">
          <source>This function returns information about a file. No permissions are required on the file itself, but execute (search) permission is required on all of the directories in path that lead to the file.</source>
          <target state="translated">이 함수는 파일에 대한 정보를 반환합니다. 파일 자체에는 권한이 필요하지 않지만 파일로 연결되는 경로의 모든 디렉토리에는 실행 (검색) 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2913c4adfe5d7ae124ee72c05cb92ad9d07380eb" translate="yes" xml:space="preserve">
          <source>This function returns the current image number, which is a positive number.</source>
          <target state="translated">이 함수는 현재 이미지 번호를 양수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b0050502c27f414b284c68b355fb97fbc36d5be3" translate="yes" xml:space="preserve">
          <source>This function returns the number of images in the current team, if &lt;var&gt;distance&lt;/var&gt; is 0 or the number of images in the parent team at the specified distance. If failed is -1, the function returns the number of all images at the specified distance; if it is 0, the function returns the number of nonfailed images, and if it is 1, it returns the number of failed images.</source>
          <target state="translated">이 함수는 &lt;var&gt;distance&lt;/var&gt; 가 0이거나 지정된 거리에서 상위 팀의 이미지 수인 경우 현재 팀의 이미지 수를 반환합니다 . 실패가 -1이면 함수는 지정된 거리에있는 모든 이미지의 수를 반환합니다. 0이면 실패하지 않은 이미지 수를 반환하고 1이면 실패한 이미지 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f859e604f7d0cc6144d2103a4a535c2a8a84248" translate="yes" xml:space="preserve">
          <source>This intrinsic is not fully portable, such as to systems with 32-bit &lt;code&gt;INTEGER&lt;/code&gt; types but supporting times wider than 32 bits. Therefore, the values returned by this intrinsic might be, or become, negative, or numerically less than previous values, during a single run of the compiled program.</source>
          <target state="translated">이 내장 함수는 32 비트 &lt;code&gt;INTEGER&lt;/code&gt; 유형의 시스템과 같이 완전히 이식 가능하지 않지만 32 비트보다 넓은 시간을 지원합니다. 따라서이 내장 함수에서 반환 된 값은 컴파일 된 프로그램을 한 번 실행하는 동안 음수이거나 이전 값보다 숫자가 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ee5be7e9d104fb85189d68c349b1f07bdcc025" translate="yes" xml:space="preserve">
          <source>This intrinsic is provided in both subroutine and function forms; however, only one form can be used in any given program unit.</source>
          <target state="translated">이 내장 함수는 서브 루틴 및 기능 형태로 제공됩니다. 그러나 특정 프로그램 단위에는 하나의 양식 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b7f87b22e060341f281484f211efd48d33be44" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is not fully backwards compatible with &lt;code&gt;g77&lt;/code&gt;. In &lt;code&gt;g77&lt;/code&gt;, the &lt;code&gt;FSEEK&lt;/code&gt; takes a statement label instead of a &lt;var&gt;STATUS&lt;/var&gt; variable. If FSEEK is used in old code, change</source>
          <target state="translated">이 내장 루틴은 &lt;code&gt;g77&lt;/code&gt; 과 완전히 호환되지 않습니다 . 에서 &lt;code&gt;g77&lt;/code&gt; 의 &lt;code&gt;FSEEK&lt;/code&gt; 성명 라벨 대신합니다 &lt;var&gt;STATUS&lt;/var&gt; 변수를. 이전 코드에서 FSEEK를 사용하는 경우 변경</target>
        </trans-unit>
        <trans-unit id="3c54a719431e9fc3537265ce2e390f6baa049068" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. For integer arguments, programmers should consider the use of the &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; intrinsic defined by the Fortran standard.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다. 정수 인수의 경우 프로그래머는 Fortran 표준에 의해 정의 된 &lt;a href=&quot;iand#IAND&quot;&gt;IAND&lt;/a&gt; 내장 기능 의 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="44801e63896540caa2832d84542a86121fdefa3e" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. For integer arguments, programmers should consider the use of the &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; intrinsic and for logical arguments the &lt;code&gt;.NEQV.&lt;/code&gt; operator, which are both defined by the Fortran standard.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다. 정수 인수의 경우 프로그래머는 &lt;a href=&quot;ieor#IEOR&quot;&gt;IEOR&lt;/a&gt; 내장 함수와 논리 인수 인 .NEQV 의 사용을 고려해야합니다 &lt;code&gt;.NEQV.&lt;/code&gt; 연산자는 모두 포트란 표준에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="384676885402adf7056d33be128dffc3896cabcc" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. For integer arguments, programmers should consider the use of the &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; intrinsic defined by the Fortran standard.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다. 정수 인수의 경우 프로그래머는 Fortran 표준에 의해 정의 된 &lt;a href=&quot;ior#IOR&quot;&gt;IOR&lt;/a&gt; 내장 기능 의 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e0c30a4df04adf858f82efcd71fa903821aa148" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. In new code, programmers should consider the use of the &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt; intrinsic defined by the Fortran 2003 standard.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다. 새 코드에서 프로그래머는 Fortran 2003 표준에 정의 된 &lt;a href=&quot;command_005fargument_005fcount#COMMAND_005fARGUMENT_005fCOUNT&quot;&gt;COMMAND_ARGUMENT_COUNT&lt;/a&gt; 내장 함수 의 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="032801d3fd91afdf588dd9891d97526b21fba234" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. In new code, programmers should consider the use of the &lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; intrinsic defined by the Fortran 95 standard.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다. 새 코드에서 프로그래머는 Fortran 95 표준에 의해 정의 된 &lt;a href=&quot;date_005fand_005ftime#DATE_005fAND_005fTIME&quot;&gt;DATE_AND_TIME&lt;/a&gt; 내장 함수 의 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1792c97c2e33afc51300c7a79b0243e98eb49abf" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. In new code, programmers should consider the use of the &lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt; intrinsic defined by the Fortran 2003 standard.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다. 새 코드에서 프로그래머는 Fortran 2003 표준에서 정의한 내장 &lt;a href=&quot;get_005fcommand_005fargument#GET_005fCOMMAND_005fARGUMENT&quot;&gt;GET_COMMAND_ARGUMENT&lt;/a&gt; 의 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8ae6719e90c20d36962ce023f82322bd6e242d70" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. In new code, programmers should consider the use of the &lt;a href=&quot;get_005fenvironment_005fvariable#GET_005fENVIRONMENT_005fVARIABLE&quot;&gt;GET_ENVIRONMENT_VARIABLE&lt;/a&gt; intrinsic defined by the Fortran 2003 standard.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다. 새 코드에서 프로그래머는 Fortran 2003 표준에 의해 정의 된 &lt;a href=&quot;get_005fenvironment_005fvariable#GET_005fENVIRONMENT_005fVARIABLE&quot;&gt;GET_ENVIRONMENT_VARIABLE&lt;/a&gt; 내장 기능 의 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="158f40f2fb86f2bf4a0090b473106d93ef551f36" translate="yes" xml:space="preserve">
          <source>This intrinsic routine is provided for backwards compatibility with GNU Fortran 77. It implements a simple modulo generator as provided by &lt;code&gt;g77&lt;/code&gt;. For new code, one should consider the use of &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt; as it implements a superior algorithm.</source>
          <target state="translated">이 내장 루틴은 GNU Fortran 77과의 하위 호환성을 위해 제공됩니다 . &lt;code&gt;g77&lt;/code&gt; 에서 제공하는 간단한 모듈로 생성기를 구현합니다 . 새 코드의 경우 우수한 알고리즘을 구현하므로 &lt;a href=&quot;random_005fnumber#RANDOM_005fNUMBER&quot;&gt;RANDOM_NUMBER&lt;/a&gt; 의 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="84f88a6daf986c4c9df5236405833583354c355a" translate="yes" xml:space="preserve">
          <source>This is approximately equivalent to the C concept of &lt;em&gt;casting&lt;/em&gt; one type to another.</source>
          <target state="translated">이것은 한 유형을 다른 유형으로 &lt;em&gt;캐스트&lt;/em&gt; 하는 C 개념과 거의 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6673b3fe5ac6180ff2788c69a30622746a7d9f64" translate="yes" xml:space="preserve">
          <source>This is primarily meant for legacy code to ensure that existing C bindings match what &lt;code&gt;gfortran&lt;/code&gt; emits. The generated C prototypes should be correct for the current version of the compiler, but may not match what other compilers or earlier versions of &lt;code&gt;gfortran&lt;/code&gt; need. For new developments, use of the &lt;code&gt;BIND(C)&lt;/code&gt; features is recommended.</source>
          <target state="translated">이것은 주로 기존 C 바인딩이 &lt;code&gt;gfortran&lt;/code&gt; 이 내 보낸 것과 일치하는지 확인하기위한 레거시 코드를위한 것입니다 . 생성 된 C 프로토 타입은 현재 버전의 컴파일러에 맞아야하지만 다른 컴파일러 또는 이전 버전의 &lt;code&gt;gfortran&lt;/code&gt; 에 필요한 것과 일치하지 않을 수 있습니다 . 새로운 개발의 경우 &lt;code&gt;BIND(C)&lt;/code&gt; 기능을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4f78ddbd198ef016de9d8500e32ce704f98a0b6b" translate="yes" xml:space="preserve">
          <source>This manual documents the use of &lt;code&gt;gfortran&lt;/code&gt;, the GNU Fortran compiler. You can find in this manual how to invoke &lt;code&gt;gfortran&lt;/code&gt;, as well as its features and incompatibilities.</source>
          <target state="translated">이 매뉴얼 은 GNU Fortran 컴파일러 인 &lt;code&gt;gfortran&lt;/code&gt; 의 사용에 대해 설명합니다 . 이 매뉴얼에서 &lt;code&gt;gfortran&lt;/code&gt; 호출 방법 과 기능 및 비 호환성을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd00d3b339354c60934121feacbd122117058b19" translate="yes" xml:space="preserve">
          <source>This manual specifically documents the Fortran front end, which handles the programming language&amp;rsquo;s syntax and semantics. The aspects of GCC which relate to the optimization passes and the back-end code generation are documented in the GCC manual; see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in Using the GNU Compiler Collection (GCC). The two manuals together provide a complete reference for the GNU Fortran compiler.</source>
          <target state="translated">이 매뉴얼은 특히 프로그래밍 언어의 구문과 의미를 다루는 Fortran 프론트 엔드를 문서화합니다. 최적화 패스 및 백엔드 코드 생성과 관련된 GCC의 측면은 GCC 매뉴얼에 문서화되어 있습니다. GNU 컴파일러 모음 (GCC) 사용의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/index.html#Top&quot;&gt;소개&lt;/a&gt; 를 참조하십시오 . 이 두 설명서는 GNU Fortran 컴파일러에 대한 완전한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da761f38b79fd038dcaec436084fc120f672c166" translate="yes" xml:space="preserve">
          <source>This option can be used to increase the upper limit permitted in array constructors. The code below requires this option to expand the array at compile time.</source>
          <target state="translated">이 옵션을 사용하면 배열 생성자에 허용 된 상한을 늘릴 수 있습니다. 아래 코드는 컴파일시 배열을 확장하기 위해이 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fee5c9abfd0e1aa5822834c6eeb723d8669d34d4" translate="yes" xml:space="preserve">
          <source>This option causes all intrinsic procedures (including the GNU-specific extensions) to be accepted. This can be useful with</source>
          <target state="translated">이 옵션을 사용하면 모든 내장 프로 시저 (GNU 관련 확장명 포함)가 승인됩니다. 이것은 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6d0348a7094c3bb65db79638454b061059b7c330" translate="yes" xml:space="preserve">
          <source>This option currently only affects local arrays declared with constant bounds, and may not apply to all character variables. Future versions of GNU Fortran may improve this behavior.</source>
          <target state="translated">이 옵션은 현재 상수 범위로 선언 된 로컬 배열에만 영향을 미치며 모든 문자 변수에 적용되지 않을 수 있습니다. GNU Fortran의 이후 버전에서는이 동작이 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e34b9ddb5ac2a20b41fb080bdfe00e59908b6305" translate="yes" xml:space="preserve">
          <source>This option has no effect if</source>
          <target state="translated">이 옵션은 다음과 같은 경우에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="223090f1188ac1bc38c64fe292f4f4b2503fac75" translate="yes" xml:space="preserve">
          <source>This option is implied by</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="705dd214fcbbda555d2c25430996631d43106884" translate="yes" xml:space="preserve">
          <source>This option is like the</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="6dcc834a238a6d226feb006834bccbf03e189785" translate="yes" xml:space="preserve">
          <source>This option is provided for interoperability with C code that was compiled with the</source>
          <target state="translated">이 옵션은 다음과 같이 컴파일 된 C 코드와의 상호 운용성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="917b232fb77d73cb0ec8cab985a319ee6cf9d3dd" translate="yes" xml:space="preserve">
          <source>This option performs front-end optimization, based on manipulating parts the Fortran parse tree. Enabled by default by any</source>
          <target state="translated">이 옵션은 포트란 구문 분석 트리를 조작하는 파트를 기반으로 프론트 엔드 최적화를 수행합니다. 기본적으로 사용</target>
        </trans-unit>
        <trans-unit id="ca34be3ac1c0cfbcac13e98adbbf3aaf42480458" translate="yes" xml:space="preserve">
          <source>This option specifies the location of pre-compiled intrinsic modules, if they are not in the default location expected by the compiler.</source>
          <target state="translated">이 옵션은 사전 컴파일 된 내장 모듈의 위치 (컴파일러가 예상하는 기본 위치가 아닌 경우)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="489d2d3dc4ad612404439f06784d2cccd2575735" translate="yes" xml:space="preserve">
          <source>This option specifies the size in bytes of the largest array that will be put on the stack; if the size is exceeded static memory is used (except in procedures marked as RECURSIVE). Use the option</source>
          <target state="translated">이 옵션은 스택에 넣을 가장 큰 배열의 크기를 바이트 단위로 지정합니다. 크기가 초과되면 정적 메모리가 사용됩니다 (RECURSIVE로 표시된 절차는 제외). 옵션을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="11be81f519864dfc1a1dc18a3dd7b92d323a6f47" translate="yes" xml:space="preserve">
          <source>This option specifies where to put</source>
          <target state="translated">이 옵션은 넣을 위치를 지정합니다</target>
        </trans-unit>
        <trans-unit id="a2292812ac2de4bbcf125e97db150b88d1ff19e4" translate="yes" xml:space="preserve">
          <source>This option tells GNU Fortran to pack derived type members as closely as possible. Code compiled with this option is likely to be incompatible with code compiled without this option, and may execute slower.</source>
          <target state="translated">이 옵션은 GNU Fortran이 파생 형식 멤버를 가능한 한 가깝게 압축하도록합니다. 이 옵션으로 컴파일 된 코드는이 옵션없이 컴파일 된 코드와 호환되지 않을 수 있으며 느리게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7164ae1aacba18245cfcc434f9b65dac4ecc25c4" translate="yes" xml:space="preserve">
          <source>This option will generate C prototypes from &lt;code&gt;BIND(C)&lt;/code&gt; variable declarations, types and procedure interfaces and writes them to standard output. &lt;code&gt;ENUM&lt;/code&gt; is not yet supported.</source>
          <target state="translated">이 옵션은 &lt;code&gt;BIND(C)&lt;/code&gt; 변수 선언, 유형 및 프로 시저 인터페이스 에서 C 프로토 타입을 생성 하고이를 표준 출력에 기록합니다. &lt;code&gt;ENUM&lt;/code&gt; 은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dadda4652a5366d77172435b6ab8c58d2728b1ac" translate="yes" xml:space="preserve">
          <source>This option will generate C prototypes from external functions and subroutines and write them to standard output. This may be useful for making sure that C bindings to Fortran code are correct. This option does not generate prototypes for &lt;code&gt;BIND(C)&lt;/code&gt; procedures, use</source>
          <target state="translated">이 옵션은 외부 함수와 서브 루틴에서 C 프로토 타입을 생성하고 표준 출력에 기록합니다. Fortran 코드에 대한 C 바인딩이 올바른지 확인하는 데 유용 할 수 있습니다. 이 옵션은 &lt;code&gt;BIND(C)&lt;/code&gt; 프로 시저에 대한 프로토 타입을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12532c5ae0779044956d4d2a254f6c248c99f323" translate="yes" xml:space="preserve">
          <source>This option will make &lt;code&gt;gfortran&lt;/code&gt; generate calls to BLAS functions for some matrix operations like &lt;code&gt;MATMUL&lt;/code&gt;, instead of using our own algorithms, if the size of the matrices involved is larger than a given limit (see</source>
          <target state="translated">이 옵션 을 사용하면 관련된 행렬의 크기가 주어진 한계보다 큰 경우 자체 알고리즘을 사용하는 대신 &lt;code&gt;MATMUL&lt;/code&gt; 과 같은 일부 행렬 연산에 대해 &lt;code&gt;gfortran&lt;/code&gt; 에서 BLAS 함수에 대한 호출을 생성합니다 (참조</target>
        </trans-unit>
        <trans-unit id="899ab6a4f582ee97e38d7181c40ae4cb35d7e064" translate="yes" xml:space="preserve">
          <source>This path is also used to search for</source>
          <target state="translated">이 경로는 검색에도 사용됩니다</target>
        </trans-unit>
        <trans-unit id="d56cad3d74290385e337db23139ff0aedc0acdde" translate="yes" xml:space="preserve">
          <source>This section contains a brief overview of data and metadata consistency and durability issues when doing I/O.</source>
          <target state="translated">이 섹션에는 I / O 수행시 데이터 및 메타 데이터 일관성 및 내구성 문제에 대한 간략한 개요가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6957d6ca0910154380babb76e8d3e085f1e68957" translate="yes" xml:space="preserve">
          <source>This section documents the behavior of GNU Fortran for file operations on symbolic links, on systems that support them.</source>
          <target state="translated">이 섹션에서는 심볼릭 링크와이를 지원하는 시스템에서의 파일 작업에 대한 GNU Fortran의 동작에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="38dea81c180f672b0c441b27663adef76042f832" translate="yes" xml:space="preserve">
          <source>This section gives an overview about the naming convention of procedures and global variables and about the argument passing conventions used by GNU Fortran. If a C binding has been specified, the naming convention and some of the argument-passing conventions change. If possible, mixed-language and mixed-compiler projects should use the better defined C binding for interoperability. See see &lt;a href=&quot;interoperability-with-c#Interoperability-with-C&quot;&gt;Interoperability with C&lt;/a&gt;.</source>
          <target state="translated">이 절에서는 절차와 전역 변수의 명명 규칙과 GNU Fortran에서 사용하는 인수 전달 규칙에 대해 개괄적으로 설명합니다. C 바인딩이 지정된 경우 이름 지정 규칙 및 일부 인수 전달 규칙이 변경됩니다. 가능하면 혼합 언어 및 혼합 컴파일러 프로젝트는 상호 운용성을 위해보다 잘 정의 된 C 바인딩을 사용해야합니다. &lt;a href=&quot;interoperability-with-c#Interoperability-with-C&quot;&gt;C와의 상호 운용성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d40aa1a9ac50cb6cb64b6b5960e75cdc841b86bf" translate="yes" xml:space="preserve">
          <source>This should be used in conjunction with</source>
          <target state="translated">이것은 함께 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="d261c166654b6be1ca7aff01a1aa0b9021ccf34f" translate="yes" xml:space="preserve">
          <source>This should result in faster accesses to the array. However it can introduce significant overhead to the function call, especially when the passed data is noncontiguous.</source>
          <target state="translated">그러면 어레이에 더 빠르게 액세스 할 수 있습니다. 그러나 특히 전달 된 데이터가 인접하지 않은 경우 함수 호출에 상당한 오버 헤드가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba1f840584de56db6b801fec0e6ee266bab8c03f" translate="yes" xml:space="preserve">
          <source>This will cause the external routine &lt;var&gt;handler_print&lt;/var&gt; to be called after 3 seconds.</source>
          <target state="translated">3 초 후에 외부 루틴 &lt;var&gt;handler_print&lt;/var&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d36424075df8e6139c5277cabf5beae54f23f070" translate="yes" xml:space="preserve">
          <source>Time difference with UTC in minutes</source>
          <target state="translated">UTC와의 시차 (분)</target>
        </trans-unit>
        <trans-unit id="c9e15e81d54c8d889d77808a2a80a45f461c3998" translate="yes" xml:space="preserve">
          <source>Time function</source>
          <target state="translated">시간 기능</target>
        </trans-unit>
        <trans-unit id="789434162ce4077a1ca99d458662cad7a7c91e5f" translate="yes" xml:space="preserve">
          <source>Time function (64-bit)</source>
          <target state="translated">시간 함수 (64 비트)</target>
        </trans-unit>
        <trans-unit id="b3f3742e1f14daffeeba7a726599fb169259df16" translate="yes" xml:space="preserve">
          <source>To aid this dialog, when input is from stdin, errors send their messages to stderr and execution continues, even if &lt;code&gt;IOSTAT&lt;/code&gt; is set.</source>
          <target state="translated">이 대화 상자를 지원하기 위해 stdin에서 입력을 받으면 &lt;code&gt;IOSTAT&lt;/code&gt; 가 설정되어 있어도 오류가 stderr로 메시지를 전송하고 실행이 계속 됩니다.</target>
        </trans-unit>
        <trans-unit id="747d887a590c006b3f8b814203bc58099792b3a7" translate="yes" xml:space="preserve">
          <source>To disable preprocessing of files with any of the above listed extensions, use the negative form:</source>
          <target state="translated">위에 나열된 확장자를 가진 파일의 전처리를 비활성화하려면 음수 형식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="106845682d1e1eedc961b9b2b1a996284635faff" translate="yes" xml:space="preserve">
          <source>To enable the processing of the OpenACC directive &lt;code&gt;!$acc&lt;/code&gt; in free-form source code; the &lt;code&gt;c$acc&lt;/code&gt;, &lt;code&gt;*$acc&lt;/code&gt; and &lt;code&gt;!$acc&lt;/code&gt; directives in fixed form; the &lt;code&gt;!$&lt;/code&gt; conditional compilation sentinels in free form; and the &lt;code&gt;c$&lt;/code&gt;, &lt;code&gt;*$&lt;/code&gt; and &lt;code&gt;!$&lt;/code&gt; sentinels in fixed form, &lt;code&gt;gfortran&lt;/code&gt; needs to be invoked with the</source>
          <target state="translated">자유 형식의 소스 코드에서 OpenACC 지시문 &lt;code&gt;!$acc&lt;/code&gt; 를 처리 할 수 ​​있도록합니다 . 고정 된 형태 의 &lt;code&gt;c$acc&lt;/code&gt; , &lt;code&gt;*$acc&lt;/code&gt; 및 &lt;code&gt;!$acc&lt;/code&gt; 지시어; 자유 형식 의 &lt;code&gt;!$&lt;/code&gt; 조건부 컴파일 센티넬; 고정 형식 의 &lt;code&gt;c$&lt;/code&gt; , &lt;code&gt;*$&lt;/code&gt; 및 &lt;code&gt;!$&lt;/code&gt; 센티넬은 &lt;code&gt;gfortran&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="771a514eda173adc5e3191103ddb927fd8f9ab25" translate="yes" xml:space="preserve">
          <source>To enable the processing of the OpenMP directive &lt;code&gt;!$omp&lt;/code&gt; in free-form source code; the &lt;code&gt;c$omp&lt;/code&gt;, &lt;code&gt;*$omp&lt;/code&gt; and &lt;code&gt;!$omp&lt;/code&gt; directives in fixed form; the &lt;code&gt;!$&lt;/code&gt; conditional compilation sentinels in free form; and the &lt;code&gt;c$&lt;/code&gt;, &lt;code&gt;*$&lt;/code&gt; and &lt;code&gt;!$&lt;/code&gt; sentinels in fixed form, &lt;code&gt;gfortran&lt;/code&gt; needs to be invoked with the</source>
          <target state="translated">자유 형식의 소스 코드에서 OpenMP 지시어 &lt;code&gt;!$omp&lt;/code&gt; 를 처리 할 수 ​​있도록합니다 . 고정 형식 의 &lt;code&gt;c$omp&lt;/code&gt; , &lt;code&gt;*$omp&lt;/code&gt; 및 &lt;code&gt;!$omp&lt;/code&gt; 지시문; 자유 형식 의 &lt;code&gt;!$&lt;/code&gt; 조건부 컴파일 센티넬; 고정 형식 의 &lt;code&gt;c$&lt;/code&gt; , &lt;code&gt;*$&lt;/code&gt; 및 &lt;code&gt;!$&lt;/code&gt; 센티넬은 &lt;code&gt;gfortran&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="4d2732defdbbc505a06dbf529811a90f7a471e2b" translate="yes" xml:space="preserve">
          <source>To get the address of elements, this extension provides an intrinsic function &lt;code&gt;LOC()&lt;/code&gt;. The &lt;code&gt;LOC()&lt;/code&gt; function is equivalent to the &lt;code&gt;&amp;amp;&lt;/code&gt; operator in C, except the address is cast to an integer type:</source>
          <target state="translated">요소의 주소를 얻기 위해이 확장은 고유 함수 &lt;code&gt;LOC()&lt;/code&gt; 제공합니다 . &lt;code&gt;LOC()&lt;/code&gt; 함수에 해당 &lt;code&gt;&amp;amp;&lt;/code&gt; 어드레스가 정수형로 캐스팅 제외 C 연산자 :</target>
        </trans-unit>
        <trans-unit id="6e2d882aa0b48c86a658f6347fc786377914ea4c" translate="yes" xml:space="preserve">
          <source>To pass a variable by value, use the &lt;code&gt;VALUE&lt;/code&gt; attribute. Thus, the following C prototype</source>
          <target state="translated">값으로 변수를 전달하려면 &lt;code&gt;VALUE&lt;/code&gt; 속성을 사용하십시오 . 따라서 다음 C 프로토 타입</target>
        </trans-unit>
        <trans-unit id="700a2463d3f19e5a55c7c576d786360cc36572b2" translate="yes" xml:space="preserve">
          <source>To provide a workaround for existing binary packages, this option disables tail call optimization for gfortran procedures with character arguments. With</source>
          <target state="translated">기존 바이너리 패키지에 대한 해결 방법을 제공하기 위해이 옵션은 문자 인수가있는 gfortran 프로 시저에 대한 마무리 호출 최적화를 비활성화합니다. 와</target>
        </trans-unit>
        <trans-unit id="9282e2bdcf4231e51bbc3fa2981e1fe29516f8f8" translate="yes" xml:space="preserve">
          <source>To stat a link: &lt;a href=&quot;lstat#LSTAT&quot;&gt;LSTAT&lt;/a&gt; To stat a file: &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</source>
          <target state="translated">링크 를 통계하려면 : &lt;a href=&quot;lstat#LSTAT&quot;&gt;LSTAT&lt;/a&gt; 파일을 통계하려면 : &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21bf865177a622b9b1d5706746a33709f5af3eac" translate="yes" xml:space="preserve">
          <source>To stat a link: &lt;a href=&quot;lstat#LSTAT&quot;&gt;LSTAT&lt;/a&gt;, to stat a file: &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</source>
          <target state="translated">링크를 통계하려면 : &lt;a href=&quot;lstat#LSTAT&quot;&gt;LSTAT&lt;/a&gt; , 파일을 통계 하려면 : &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1266b5a0f7ad3fb906f188e853a7b736fd26145e" translate="yes" xml:space="preserve">
          <source>To stat an open file: &lt;a href=&quot;fstat#FSTAT&quot;&gt;FSTAT&lt;/a&gt; To stat a file: &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</source>
          <target state="translated">열린 파일 을 stat하려면 : &lt;a href=&quot;fstat#FSTAT&quot;&gt;FSTAT&lt;/a&gt; 파일 을 stat하려면 : &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="71c8db7b766cf8cb469c0e5bb3240fd944a223a1" translate="yes" xml:space="preserve">
          <source>To stat an open file: &lt;a href=&quot;fstat#FSTAT&quot;&gt;FSTAT&lt;/a&gt; To stat a link: &lt;a href=&quot;lstat#LSTAT&quot;&gt;LSTAT&lt;/a&gt;</source>
          <target state="translated">열려있는 파일을 찍으려면 : &lt;a href=&quot;fstat#FSTAT&quot;&gt;fstat를&lt;/a&gt; 하는 방법은 링크를 찍으 : &lt;a href=&quot;lstat#LSTAT&quot;&gt;lstat는을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60682cbc389a7f0f541210a8589d63dafde4129f" translate="yes" xml:space="preserve">
          <source>To stat an open file: &lt;a href=&quot;fstat#FSTAT&quot;&gt;FSTAT&lt;/a&gt;, to stat a file: &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</source>
          <target state="translated">열린 파일을 통계하려면 : &lt;a href=&quot;fstat#FSTAT&quot;&gt;FSTAT&lt;/a&gt; , 파일을 통계하려면 : &lt;a href=&quot;stat#STAT&quot;&gt;STAT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97207c3da28dd1f216297ba21e80496ef7309eac" translate="yes" xml:space="preserve">
          <source>To stat an open file: &lt;a href=&quot;fstat#FSTAT&quot;&gt;FSTAT&lt;/a&gt;, to stat a link: &lt;a href=&quot;lstat#LSTAT&quot;&gt;LSTAT&lt;/a&gt;</source>
          <target state="translated">열린 파일을 통계하려면 : &lt;a href=&quot;fstat#FSTAT&quot;&gt;FSTAT&lt;/a&gt; , 링크를 통계 하려면 : &lt;a href=&quot;lstat#LSTAT&quot;&gt;LSTAT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee60ad344c778dbb162e77975b44b1ab1581540d" translate="yes" xml:space="preserve">
          <source>To support legacy codes, GNU Fortran allows missing periods in format specifications if and only if</source>
          <target state="translated">레거시 코드를 지원하기 위해 GNU Fortran은 다음과 같은 경우에만 형식 스펙에서 누락 된 기간을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="aeff8a003878724bccac02bb31b67dbb969733c7" translate="yes" xml:space="preserve">
          <source>To support legacy codes, GNU Fortran allows the comma separator to be omitted immediately before and after character string edit descriptors in &lt;code&gt;FORMAT&lt;/code&gt; statements.</source>
          <target state="translated">레거시 코드를 지원하기 위해 GNU Fortran을 사용하면 &lt;code&gt;FORMAT&lt;/code&gt; 문 에서 문자열 편집 디스크립터 바로 전후에 쉼표 구분 기호를 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e84af684dc5daeae32e10f526c51cbb39c823bf" translate="yes" xml:space="preserve">
          <source>To support legacy codes, GNU Fortran allows the comma separator to be omitted immediately before and after character string edit descriptors in &lt;code&gt;FORMAT&lt;/code&gt; statements. A comma with no following format decriptor is permited if the</source>
          <target state="translated">레거시 코드를 지원하기 위해 GNU Fortran에서는 &lt;code&gt;FORMAT&lt;/code&gt; 문 에서 문자열 편집 설명자 바로 앞뒤에 쉼표 구분 기호를 생략 할 수 있습니다 . 다음 형식 설명자가없는 쉼표는 다음과 같은 경우 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e034d558672f1bb2625e58e4102dfa15d7fec77" translate="yes" xml:space="preserve">
          <source>To support legacy codes, GNU Fortran allows the input item list of the &lt;code&gt;READ&lt;/code&gt; statement, and the output item lists of the &lt;code&gt;WRITE&lt;/code&gt; and &lt;code&gt;PRINT&lt;/code&gt; statements, to start with a comma.</source>
          <target state="translated">레거시 코드를 지원하기 위해 GNU Fortran은 &lt;code&gt;READ&lt;/code&gt; 문의 입력 항목 목록 과 &lt;code&gt;WRITE&lt;/code&gt; 및 &lt;code&gt;PRINT&lt;/code&gt; 문의 출력 항목 목록을 쉼표로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e00d99a569b4269ee4bd52962b512317475de80" translate="yes" xml:space="preserve">
          <source>To support legacy codes, GNU Fortran allows width to be omitted from format specifications if and only if</source>
          <target state="translated">레거시 코드를 지원하기 위해 GNU Fortran은 다음과 같은 경우에만 형식 사양에서 너비를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fa264a42cc80e6c180dee472f9205b2ee99b9c2" translate="yes" xml:space="preserve">
          <source>To support legacy codes, GNU Fortran permits the count field of the &lt;code&gt;X&lt;/code&gt; edit descriptor in &lt;code&gt;FORMAT&lt;/code&gt; statements to be omitted. When omitted, the count is implicitly assumed to be one.</source>
          <target state="translated">레거시 코드를 지원하기 위해 GNU Fortran 은 &lt;code&gt;FORMAT&lt;/code&gt; 문의 &lt;code&gt;X&lt;/code&gt; 편집 설명 자의 count 필드를 생략 할 수 있습니다. 생략하면 카운트는 암시 적으로 1로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0397b205290cd3284fcb87047fd515ce71bc79b3" translate="yes" xml:space="preserve">
          <source>Transfer bit patterns</source>
          <target state="translated">전송 비트 패턴</target>
        </trans-unit>
        <trans-unit id="581923b0ba5bd2d15abc29d6e5e8ce7ea6dc2af6" translate="yes" xml:space="preserve">
          <source>Transferring of allocations via &lt;code&gt;MOVE_ALLOC&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MOVE_ALLOC&lt;/code&gt; 을 통한 할당 전송 .</target>
        </trans-unit>
        <trans-unit id="5f200117904c989c5b71c10e2df8802de5fcf81c" translate="yes" xml:space="preserve">
          <source>Transformational function</source>
          <target state="translated">변형 기능</target>
        </trans-unit>
        <trans-unit id="e70128a916c6f33d343fed9e075e6779cd01028c" translate="yes" xml:space="preserve">
          <source>Translate the user&amp;rsquo;s program into instructions a computer can carry out more quickly than it takes to translate the instructions in the first place. The result after compilation of a program is &lt;em&gt;machine code&lt;/em&gt;, code designed to be efficiently translated and processed by a machine such as your computer. Humans usually are not as good writing machine code as they are at writing Fortran (or C++, Ada, or Java), because it is easy to make tiny mistakes writing machine code.</source>
          <target state="translated">사용자의 프로그램을 컴퓨터가 명령을 먼저 번역하는 것보다 더 빨리 수행 할 수있는 명령으로 변환합니다. 프로그램 컴파일 후의 결과 는 컴퓨터와 같은 기계에 의해 효율적으로 번역되고 처리되도록 설계된 &lt;em&gt;기계 코드&lt;/em&gt; 입니다. 인간은 일반적으로 기계 코드를 작성하는 데 작은 실수를하기가 쉽기 때문에 포트란 (또는 C ++, Ada 또는 Java)을 작성할 때처럼 기계 코드를 잘 작성하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="618e311e13c4b76d3cf2bebe91792696125b79f3" translate="yes" xml:space="preserve">
          <source>Transpose an array of rank two</source>
          <target state="translated">랭크 2의 배열을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="fa5b118cd82926c8ba60fc5b4e9f4facc9ec3577" translate="yes" xml:space="preserve">
          <source>Transpose an array of rank two. Element (i, j) of the result has the value &lt;code&gt;MATRIX(j, i)&lt;/code&gt;, for all i, j.</source>
          <target state="translated">랭크 2의 배열을 바꿉니다. 결과의 요소 (i, j)는 모든 i, j에 대해 &lt;code&gt;MATRIX(j, i)&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="87b07ff0b8c55dbd66f463e70061f285ff8e7f1d" translate="yes" xml:space="preserve">
          <source>Treat each program unit (except those marked as RECURSIVE) as if the &lt;code&gt;SAVE&lt;/code&gt; statement were specified for every local variable and array referenced in it. Does not affect common blocks. (Some Fortran compilers provide this option under the name</source>
          <target state="translated">&lt;code&gt;SAVE&lt;/code&gt; 문이 참조 된 모든 로컬 변수 및 배열에 대해 지정된 것처럼 각 프로그램 단위 (RECURSIVE로 표시된 것 제외) 를 처리하십시오. 공통 블록에는 영향을 미치지 않습니다. (일부 포트란 컴파일러는 이름으로이 옵션을 제공합니다</target>
        </trans-unit>
        <trans-unit id="2e664ee052bbf2019c132b1385ce2ac062702f98" translate="yes" xml:space="preserve">
          <source>Truncate to a whole number</source>
          <target state="translated">정수로 자르기</target>
        </trans-unit>
        <trans-unit id="04079637719a844631dc4811a152bce800d6eb55" translate="yes" xml:space="preserve">
          <source>Turns all warnings into errors.</source>
          <target state="translated">모든 경고를 오류로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="1811066da67e504477d75dad839d3b284b5d6851" translate="yes" xml:space="preserve">
          <source>Two line feeds and carriage return</source>
          <target state="translated">두 개의 줄 바꿈 및 캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="a3dc6c906e98f1e5ba74f445e96c86ba8ba7fbb6" translate="yes" xml:space="preserve">
          <source>Typedef of type &lt;code&gt;void *&lt;/code&gt; on the compiler side. Can be any data type on the library side.</source>
          <target state="translated">컴파일러 측의 &lt;code&gt;void *&lt;/code&gt; 유형의 Typedef 라이브러리 측의 모든 데이터 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7e51a4459148e181b9af3ce817118a68e10cf35" translate="yes" xml:space="preserve">
          <source>UNPACK</source>
          <target state="translated">UNPACK</target>
        </trans-unit>
        <trans-unit id="9531ac1c772b98a514787df9460ed3aef76b01b3" translate="yes" xml:space="preserve">
          <source>Unformatted sequential files are stored as logical records using record markers. Each logical record consists of one of more subrecords.</source>
          <target state="translated">형식화되지 않은 순차 파일은 레코드 마커를 사용하여 논리 레코드로 저장됩니다. 각 논리 레코드는 하나 이상의 서브 레코드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6dc403952d1c8a45e0169421b64bf31ee41166" translate="yes" xml:space="preserve">
          <source>Unions are an old vendor extension which were commonly used with the non-standard &lt;a href=&quot;structure-and-record#STRUCTURE-and-RECORD&quot;&gt;STRUCTURE and RECORD&lt;/a&gt; extensions. Use of &lt;code&gt;UNION&lt;/code&gt; and &lt;code&gt;MAP&lt;/code&gt; is automatically enabled with</source>
          <target state="translated">연합은 비표준 &lt;a href=&quot;structure-and-record#STRUCTURE-and-RECORD&quot;&gt;STRUCTURE 및 RECORD&lt;/a&gt; 확장에 일반적으로 사용되는 오래된 공급 업체 확장입니다 . 의 사용 &lt;code&gt;UNION&lt;/code&gt; 및 &lt;code&gt;MAP&lt;/code&gt; 가 자동으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="db7a84404f8bec00fa2f135c6d8a6f6a613666fe" translate="yes" xml:space="preserve">
          <source>Unit number for standard error</source>
          <target state="translated">표준 오차의 단위 번호</target>
        </trans-unit>
        <trans-unit id="280f3d077d29a2f474bd7a75efbfa76f173f2a77" translate="yes" xml:space="preserve">
          <source>Unit number for standard input</source>
          <target state="translated">표준 입력 장치 번호</target>
        </trans-unit>
        <trans-unit id="61acf618a725b32bf12841f02d25e1776f39d8e3" translate="yes" xml:space="preserve">
          <source>Unit number for standard output</source>
          <target state="translated">표준 출력의 장치 번호</target>
        </trans-unit>
        <trans-unit id="019d93f6fdc1b764eb07d4db6e13bc6056e02f95" translate="yes" xml:space="preserve">
          <source>Unlinks the file &lt;var&gt;PATH&lt;/var&gt;. A null character (&lt;code&gt;CHAR(0)&lt;/code&gt;) can be used to mark the end of the name in &lt;var&gt;PATH&lt;/var&gt;; otherwise, trailing blanks in the file name are ignored. If the &lt;var&gt;STATUS&lt;/var&gt; argument is supplied, it contains 0 on success or a nonzero error code upon return; see &lt;code&gt;unlink(2)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;PATH&lt;/var&gt; 파일을 연결 해제합니다 . 널 문자 ( &lt;code&gt;CHAR(0)&lt;/code&gt; )를 사용하여 &lt;var&gt;PATH&lt;/var&gt; 에서 이름의 끝을 표시 할 수 있습니다 . 그렇지 않으면 파일 이름의 후미 공백이 무시됩니다. 는 IF &lt;var&gt;STATUS&lt;/var&gt; 인수가 제공되고, 그것은 성공 또는 반환시 제로가 아닌 에러 코드에 0이 포함되어; &lt;code&gt;unlink(2)&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a9f17adaf9079b58a1a3d4f20af95a3dca6f657" translate="yes" xml:space="preserve">
          <source>Unlocking a lock variable</source>
          <target state="translated">잠금 변수 잠금 해제</target>
        </trans-unit>
        <trans-unit id="12eb5b406f16b604cf34ad2388c34903d500a97d" translate="yes" xml:space="preserve">
          <source>Unpack an array of rank one into an array</source>
          <target state="translated">순위 1의 배열을 배열로 압축 해제</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="c4664e1c6e1eed64913fcd62c9c184079c4df3ca" translate="yes" xml:space="preserve">
          <source>Up to Fortran 95, BOZ literal constants were only allowed to initialize integer variables in DATA statements. Since Fortran 2003 BOZ literal constants are also allowed as actual arguments to the &lt;code&gt;REAL&lt;/code&gt;, &lt;code&gt;DBLE&lt;/code&gt;, &lt;code&gt;INT&lt;/code&gt; and &lt;code&gt;CMPLX&lt;/code&gt; intrinsic functions. The BOZ literal constant is simply a string of bits, which is padded or truncated as needed, during conversion to a numeric type. The Fortran standard states that the treatment of the sign bit is processor dependent. Gfortran interprets the sign bit as a user would expect.</source>
          <target state="translated">Fortran 95까지 BOZ 리터럴 상수는 DATA 문에서 정수 변수 만 초기화 할 수있었습니다. Fortran 2003 BOZ 리터럴 상수는 &lt;code&gt;REAL&lt;/code&gt; , &lt;code&gt;DBLE&lt;/code&gt; , &lt;code&gt;INT&lt;/code&gt; 및 &lt;code&gt;CMPLX&lt;/code&gt; 내장 함수 에 대한 실제 인수로도 허용됩니다 . BOZ 리터럴 상수는 단순히 숫자 유형으로 변환하는 동안 필요에 따라 채워지거나 잘리는 비트 문자열입니다. Fortran 표준에 따르면 부호 비트 처리는 프로세서에 따라 다릅니다. Gfortran은 사용자가 예상하는대로 부호 비트를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="43973ff76352a5affc21c21f4a8d3d0508028492" translate="yes" xml:space="preserve">
          <source>Up to Fortran 95, BOZ literals were only allowed to initialize integer variables in DATA statements. Since Fortran 2003 BOZ literals are also allowed as argument of &lt;code&gt;REAL&lt;/code&gt;, &lt;code&gt;DBLE&lt;/code&gt;, &lt;code&gt;INT&lt;/code&gt; and &lt;code&gt;CMPLX&lt;/code&gt;; the result is the same as if the integer BOZ literal had been converted by &lt;code&gt;TRANSFER&lt;/code&gt; to, respectively, &lt;code&gt;real&lt;/code&gt;, &lt;code&gt;double precision&lt;/code&gt;, &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;complex&lt;/code&gt;. As GNU Fortran extension the intrinsic procedures &lt;code&gt;FLOAT&lt;/code&gt;, &lt;code&gt;DFLOAT&lt;/code&gt;, &lt;code&gt;COMPLEX&lt;/code&gt; and &lt;code&gt;DCMPLX&lt;/code&gt; are treated alike.</source>
          <target state="translated">Fortran 95까지 BOZ 리터럴은 DATA 문에서 정수 변수 만 초기화 할 수있었습니다. Fortran 2003부터 BOZ 리터럴은 &lt;code&gt;REAL&lt;/code&gt; , &lt;code&gt;DBLE&lt;/code&gt; , &lt;code&gt;INT&lt;/code&gt; 및 &lt;code&gt;CMPLX&lt;/code&gt; 의 인수로 허용됩니다 . 결과는 정수 BOZ 리터럴이 &lt;code&gt;TRANSFER&lt;/code&gt; 에 의해 각각 &lt;code&gt;real&lt;/code&gt; , &lt;code&gt;double precision&lt;/code&gt; , &lt;code&gt;integer&lt;/code&gt; 또는 &lt;code&gt;complex&lt;/code&gt; 로 변환 된 것과 같습니다 . GNU Fortran 확장으로서 고유 프로 시저 &lt;code&gt;FLOAT&lt;/code&gt; , &lt;code&gt;DFLOAT&lt;/code&gt; , &lt;code&gt;COMPLEX&lt;/code&gt; 및 &lt;code&gt;DCMPLX&lt;/code&gt; 는 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="3984c15373a989fe27ef4b1eeb3b706a5a45538d" translate="yes" xml:space="preserve">
          <source>Upper codimension bounds of an array</source>
          <target state="translated">배열의 상한 치수</target>
        </trans-unit>
        <trans-unit id="147d16aacd6cba56d9ff8f3f120167efb5adc5f2" translate="yes" xml:space="preserve">
          <source>Upper dimension bounds of an array</source>
          <target state="translated">배열의 상한치</target>
        </trans-unit>
        <trans-unit id="eb4639975214bd02baed9aee7811250d9713b6c2" translate="yes" xml:space="preserve">
          <source>Use &lt;var&gt;dir&lt;/var&gt; as a subdirectory of the directory containing target-specific C++ headers.</source>
          <target state="translated">대상별 C ++ 헤더를 포함하는 디렉토리의 서브 &lt;var&gt;dir&lt;/var&gt; 로 dir 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="496c59f6a9d32b643cd08c29e9aafbff1438a9fb" translate="yes" xml:space="preserve">
          <source>Use of</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="6c08132280908eb00731c64ad8528e58b9a6bef0" translate="yes" xml:space="preserve">
          <source>Used to query the coarray library whether an allocatable component in a derived type coarray is allocated on a remote image.</source>
          <target state="translated">파생 된 유형 coarray의 할당 가능한 구성 요소가 원격 이미지에 할당되는지 여부를 coarray 라이브러리를 조회하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="228565cbb2b7d39564fb37b4722a8bb876904f67" translate="yes" xml:space="preserve">
          <source>User ID function</source>
          <target state="translated">사용자 ID 기능</target>
        </trans-unit>
        <trans-unit id="8b8d229c12343fe081586cfe087fea3a8ed6c959" translate="yes" xml:space="preserve">
          <source>User time in seconds.</source>
          <target state="translated">사용자 시간 (초)</target>
        </trans-unit>
        <trans-unit id="a663e15f507d37b3a8ee28f0c34a9256987cb042" translate="yes" xml:space="preserve">
          <source>User-visible implementation details.</source>
          <target state="translated">사용자가 볼 수있는 구현 세부 사항.</target>
        </trans-unit>
        <trans-unit id="6935b3ffa77b90caf0faa1e8c8b856ce5c34b528" translate="yes" xml:space="preserve">
          <source>Using anything but the native representation for unformatted data carries a significant speed overhead. If speed in this area matters to you, it is best if you use this only for data that needs to be portable.</source>
          <target state="translated">형식화되지 않은 데이터에 기본 표현 이외의 다른 것을 사용하면 상당한 속도 오버 헤드가 발생합니다. 이 영역의 속도가 중요한 경우 이식성이 필요한 데이터에만 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="89e3bf68c4405c5a4aa33fded084807b149d7ac2" translate="yes" xml:space="preserve">
          <source>Using assumed-shape, assumed-rank and deferred-shape arrays in &lt;code&gt;BIND(C)&lt;/code&gt; procedures is not fully supported. In particular, C interoperable strings of other length than one are not supported as this requires the new array descriptor.</source>
          <target state="translated">&lt;code&gt;BIND(C)&lt;/code&gt; 프로 시저 에서 가정 모양, 가정 순위 및 지연 모양 배열을 사용하는 것은 완전히 지원되지 않습니다. 특히, 길이가 아닌 C 상호 운용 가능한 문자열은 새로운 배열 설명자가 필요하므로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ef2bf79fd4bd83959b5f9a04b3c5898c048623e" translate="yes" xml:space="preserve">
          <source>Using complex arguments with &lt;code&gt;TAN&lt;/code&gt;, &lt;code&gt;SINH&lt;/code&gt;, &lt;code&gt;COSH&lt;/code&gt;, &lt;code&gt;TANH&lt;/code&gt;, &lt;code&gt;ASIN&lt;/code&gt;, &lt;code&gt;ACOS&lt;/code&gt;, and &lt;code&gt;ATAN&lt;/code&gt; is now possible; &lt;code&gt;ATAN&lt;/code&gt;(&lt;var&gt;Y&lt;/var&gt;,&lt;var&gt;X&lt;/var&gt;) is now an alias for &lt;code&gt;ATAN2&lt;/code&gt;(&lt;var&gt;Y&lt;/var&gt;,&lt;var&gt;X&lt;/var&gt;).</source>
          <target state="translated">&lt;code&gt;TAN&lt;/code&gt; , &lt;code&gt;SINH&lt;/code&gt; , &lt;code&gt;COSH&lt;/code&gt; , &lt;code&gt;TANH&lt;/code&gt; , &lt;code&gt;ASIN&lt;/code&gt; , &lt;code&gt;ACOS&lt;/code&gt; 및 &lt;code&gt;ATAN&lt;/code&gt; 과 함께 복잡한 인수를 사용할 수 있습니다. &lt;code&gt;ATAN&lt;/code&gt; ( &lt;var&gt;Y&lt;/var&gt; , &lt;var&gt;X&lt;/var&gt; )는 이제 &lt;code&gt;ATAN2&lt;/code&gt; ( &lt;var&gt;Y&lt;/var&gt; , &lt;var&gt;X&lt;/var&gt; ) 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="0fece744bc9977f23cdac28c3daa8c2367a856f3" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;OPEN&lt;/code&gt; statement with a &lt;code&gt;STATUS=&quot;NEW&quot;&lt;/code&gt; specifier on a symbolic link will result in an error condition, whether the symbolic link points to an existing target or is dangling.</source>
          <target state="translated">기호 링크에서 &lt;code&gt;STATUS=&quot;NEW&quot;&lt;/code&gt; 지정자 와 함께 &lt;code&gt;OPEN&lt;/code&gt; 문을 사용하면 기호 링크가 기존 대상을 가리 키거나 매달려 있는지 여부에 관계없이 오류 조건이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93d3730838597eeb50b33dec00642cbfcc38d35b" translate="yes" xml:space="preserve">
          <source>Using the option could look like this:</source>
          <target state="translated">옵션을 사용하면 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="765c9e1c01049eff74e4f8406ca71be449872e2b" translate="yes" xml:space="preserve">
          <source>Using this option can lead to problems including crashes due to insufficient stack space.</source>
          <target state="translated">이 옵션을 사용하면 스택 공간 부족으로 인한 충돌을 비롯한 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cae86d6fdec2cd3dc1278e7b6832cae32df94ce6" translate="yes" xml:space="preserve">
          <source>Using this option is &lt;em&gt;strongly&lt;/em&gt; discouraged. It is possible to provide standard-conforming code which allows different types of arguments by using an explicit interface and &lt;code&gt;TYPE(*)&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하는 것이된다 &lt;em&gt;강하게&lt;/em&gt; 낙담. 명시 적 인터페이스 및 &lt;code&gt;TYPE(*)&lt;/code&gt; 을 사용하여 다양한 유형의 인수를 허용하는 표준 준수 코드를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25a92b1376d7512d8c7f7c39f7d1ff452ae99c9f" translate="yes" xml:space="preserve">
          <source>Valid Fortran 95 programs should compile properly with or without this option. However, without this option, certain GNU extensions and traditional Fortran features are supported as well. With this option, many of them are rejected.</source>
          <target state="translated">이 옵션을 사용하거나 사용하지 않고 유효한 Fortran 95 프로그램을 올바르게 컴파일해야합니다. 그러나이 옵션이 없으면 특정 GNU 확장 및 기존 포트란 기능도 지원됩니다. 이 옵션을 사용하면 많은 항목이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="407568ddcfbd4b707cbc30d20bbc2a3cdc6e850e" translate="yes" xml:space="preserve">
          <source>Valid Fortran programs should compile properly with or without this option. However, without this option, certain GNU extensions and traditional Fortran features are supported as well. With this option, many of them are rejected.</source>
          <target state="translated">유효한 Fortran 프로그램은이 옵션을 사용하거나 사용하지 않고 올바르게 컴파일해야합니다. 그러나이 옵션이 없으면 특정 GNU 확장 및 기존 Fortran 기능도 지원됩니다. 이 옵션을 사용하면 많은 항목이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="81a4ce5218bef8986dca03cf2247e3656031274f" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;CONVERT&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;CONVERT&lt;/code&gt; 에 유효한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="86c32875bdd6c77926003edf1c3b3e4acfee35de" translate="yes" xml:space="preserve">
          <source>Variable of any type.</source>
          <target state="translated">모든 유형의 변수.</target>
        </trans-unit>
        <trans-unit id="3fa8f639194f927a05e6ee8c3f56f9cf59112e12" translate="yes" xml:space="preserve">
          <source>Variable of the type &lt;code&gt;REAL&lt;/code&gt;.</source>
          <target state="translated">유형의 변수 &lt;code&gt;REAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f50cd138831971a4cd8cb6d265ba3e133d980fe" translate="yes" xml:space="preserve">
          <source>Variables can be made accessible from C using the C binding attribute, optionally together with specifying a binding name. Those variables have to be declared in the declaration part of a &lt;code&gt;MODULE&lt;/code&gt;, be of interoperable type, and have neither the &lt;code&gt;pointer&lt;/code&gt; nor the &lt;code&gt;allocatable&lt;/code&gt; attribute.</source>
          <target state="translated">C 바인딩 속성을 사용하여 선택적으로 바인딩 이름 지정과 함께 C에서 변수에 액세스 할 수 있습니다. 이러한 변수는 &lt;code&gt;MODULE&lt;/code&gt; 의 선언 부분에서 선언되고 상호 운용 가능한 유형이어야하며 &lt;code&gt;pointer&lt;/code&gt; 나 &lt;code&gt;allocatable&lt;/code&gt; 속성 이 없어야 합니다.</target>
        </trans-unit>
        <trans-unit id="e29dc413f150614968f1b014cc388ae4bbbb66a1" translate="yes" xml:space="preserve">
          <source>Variables with &lt;code&gt;NO_ARG_CHECK&lt;/code&gt; attribute shall be of assumed-type (&lt;code&gt;TYPE(*)&lt;/code&gt;; recommended) or of type &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;LOGICAL&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt; or &lt;code&gt;COMPLEX&lt;/code&gt;. They shall not have the &lt;code&gt;ALLOCATE&lt;/code&gt;, &lt;code&gt;CODIMENSION&lt;/code&gt;, &lt;code&gt;INTENT(OUT)&lt;/code&gt;, &lt;code&gt;POINTER&lt;/code&gt; or &lt;code&gt;VALUE&lt;/code&gt; attribute; furthermore, they shall be either scalar or of assumed-size (&lt;code&gt;dimension(*)&lt;/code&gt;). As &lt;code&gt;TYPE(*)&lt;/code&gt;, the &lt;code&gt;NO_ARG_CHECK&lt;/code&gt; attribute requires an explicit interface.</source>
          <target state="translated">&lt;code&gt;NO_ARG_CHECK&lt;/code&gt; 속성을 갖는 변수 는 가정 유형 ( &lt;code&gt;TYPE(*)&lt;/code&gt; ; 권장) 또는 유형 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;LOGICAL&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 또는 &lt;code&gt;COMPLEX&lt;/code&gt; 이어야합니다 . 그들은이 안된다 &lt;code&gt;ALLOCATE&lt;/code&gt; , &lt;code&gt;CODIMENSION&lt;/code&gt; , &lt;code&gt;INTENT(OUT)&lt;/code&gt; , &lt;code&gt;POINTER&lt;/code&gt; 또는 &lt;code&gt;VALUE&lt;/code&gt; 의 특성; 또한 스칼라이거나 가정 된 크기 ( &lt;code&gt;dimension(*)&lt;/code&gt; ) 여야합니다 . 마찬가지로 &lt;code&gt;TYPE(*)&lt;/code&gt; 는 &lt;code&gt;NO_ARG_CHECK&lt;/code&gt; 의 특성이 명시 적 인터페이스를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="bfe3182f539bb0934f3b078b390e76b150e1ffae" translate="yes" xml:space="preserve">
          <source>Verifies that all the characters in &lt;var&gt;STRING&lt;/var&gt; belong to the set of characters in &lt;var&gt;SET&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;STRING&lt;/var&gt; 의 모든 문자가 &lt;var&gt;SET&lt;/var&gt; 의 문자 세트에 속하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="4bd7e52ecd27919a5500b769c17d879c88191ef8" translate="yes" xml:space="preserve">
          <source>Wait for completion of segment-memory operations</source>
          <target state="translated">세그먼트 메모리 작업 완료를 기다립니다</target>
        </trans-unit>
        <trans-unit id="82441dcba5985ea7f14bcce3582fcb6daa3ff460" translate="yes" xml:space="preserve">
          <source>Wait that an event occurred</source>
          <target state="translated">이벤트가 발생하기를 기다립니다</target>
        </trans-unit>
        <trans-unit id="09800eef55377fcedfe7531a852761aa69452162" translate="yes" xml:space="preserve">
          <source>Wait until the event count has reached at least the specified &lt;var&gt;until_count&lt;/var&gt;; if so, atomically decrement the event variable by this amount and return.</source>
          <target state="translated">이벤트 카운트가 적어도 지정된 &lt;var&gt;until_count&lt;/var&gt; 에 도달 할 때까지 기다 립니다 . 그렇다면 이벤트 변수를이 양만큼 원자 적으로 감소시키고 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b224c52d9abbb5a7474efb2d65072b2e44bb2089" translate="yes" xml:space="preserve">
          <source>Warn about array temporaries generated by the compiler. The information generated by this warning is sometimes useful in optimization, in order to avoid such temporaries.</source>
          <target state="translated">컴파일러가 생성 한 배열 임시에 대해 경고합니다. 이 경고에 의해 생성 된 정보는 때때로 그러한 일시적인 상황을 피하기 위해 최적화에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4084725652784f9979ae67cc2bc37cba76815b06" translate="yes" xml:space="preserve">
          <source>Warn about implicit conversions between different types and kinds. This option does &lt;em&gt;not&lt;/em&gt; imply</source>
          <target state="translated">다른 유형과 종류 간의 암시 적 변환에 대해 경고합니다. 이 옵션은 암시 하지 &lt;em&gt;않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5951ad61852d6e3a277ac4de207b01682a21781d" translate="yes" xml:space="preserve">
          <source>Warn about implicit conversions that are likely to change the value of the expression after conversion. Implied by</source>
          <target state="translated">변환 후 표현식의 값이 변경 될 수있는 암시 적 변환에 대해 경고하십시오. 에 의해 암시</target>
        </trans-unit>
        <trans-unit id="522d88aac9acdbc550cd79b62acd8f2814978281" translate="yes" xml:space="preserve">
          <source>Warn about missing ampersand in continued character constants. The warning is given with</source>
          <target state="translated">연속적인 문자 상수에서 앰퍼샌드 누락에 대해 경고합니다. 경고는</target>
        </trans-unit>
        <trans-unit id="bd7ac747461bfb19988cc8539e1c9e64fa811341" translate="yes" xml:space="preserve">
          <source>Warn about possible aliasing of dummy arguments. Specifically, it warns if the same actual argument is associated with a dummy argument with &lt;code&gt;INTENT(IN)&lt;/code&gt; and a dummy argument with &lt;code&gt;INTENT(OUT)&lt;/code&gt; in a call with an explicit interface.</source>
          <target state="translated">더미 인수의 가능한 앨리어싱에 대해 경고합니다. 특히, 동일한 실제 인수가 명시 적 인터페이스 호출에서 &lt;code&gt;INTENT(IN)&lt;/code&gt; 의 더미 인수와 &lt;code&gt;INTENT(OUT)&lt;/code&gt; 의 더미 인수와 연관되어 있는지 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="8276d05128a23bdc66caf69856565cd3ac49b11d" translate="yes" xml:space="preserve">
          <source>Warn about type, rank, and other mismatches between formal parameters and actual arguments to functions and subroutines. These warnings are recommended and thus enabled by default.</source>
          <target state="translated">형식 매개 변수와 함수 및 서브 루틴에 대한 실제 인수 사이의 유형, 순위 및 기타 불일치에 대해 경고합니다. 이 경고는 권장되므로 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1912b824d5122aa2b3135ac8571577fd7b48e4ab" translate="yes" xml:space="preserve">
          <source>Warn about unused dummy arguments. This option is implied by</source>
          <target state="translated">사용되지 않는 더미 인수에 대해 경고하십시오. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="466fbabbce62f74944696cd15456fb2d7fcaeb87" translate="yes" xml:space="preserve">
          <source>Warn if &lt;code&gt;gfortran&lt;/code&gt; finds a procedure named like an intrinsic not available in the currently selected standard (with</source>
          <target state="translated">&lt;code&gt;gfortran&lt;/code&gt; 이 현재 선택된 표준에서 사용할 수없는 내장 함수와 같은 프로 시저를 찾으면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="6161693bd356986be63048763cd39c9baa6b5c07" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;DO&lt;/code&gt; loop is known to execute zero times at compile time. This option is implied by</source>
          <target state="translated">컴파일시 &lt;code&gt;DO&lt;/code&gt; 루프가 0 번 실행되는 것으로 경고합니다 . 이 옵션은</target>
        </trans-unit>
        <trans-unit id="661e7d1989726a5b031f8b8e009ebf9f30bc1812" translate="yes" xml:space="preserve">
          <source>Warn if a &lt;code&gt;USE&lt;/code&gt; statement has no &lt;code&gt;ONLY&lt;/code&gt; qualifier and thus implicitly imports all public entities of the used module.</source>
          <target state="translated">&lt;code&gt;USE&lt;/code&gt; 문에 한정자 &lt;code&gt;ONLY&lt;/code&gt; 없고 사용 된 모듈의 모든 공용 엔터티를 암시 적으로 가져 오는 경우 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="3689fd7d0ff1922bbed4f343e2ef4cb9af2ab93c" translate="yes" xml:space="preserve">
          <source>Warn if a DO loop with step either 1 or -1 yields an underflow or an overflow during iteration of an induction variable of the loop. This option is implied by</source>
          <target state="translated">1 또는 -1 단계의 DO 루프가 루프의 유도 변수를 반복하는 동안 언더 플로우 또는 오버 플로우가 발생하면 경고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="854d2f746792cf8db804c37e064b21ce9301b18d" translate="yes" xml:space="preserve">
          <source>Warn if a constant integer division truncates it result. As an example, 3/5 evaluates to 0.</source>
          <target state="translated">상수 정수 나누기가 결과를 자르면 경고합니다. 예를 들어, 3/5는 0으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="9b2066d9dfd9a4c837bc20bf0aa183d1120fdb7a" translate="yes" xml:space="preserve">
          <source>Warn if a constant integer division truncates its result. As an example, 3/5 evaluates to 0.</source>
          <target state="translated">상수 정수 나눗셈이 결과를 자르면 경고합니다. 예를 들어, 3/5는 0으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="588972d1cbb7265eaf8fc906a30d164447a14d0f" translate="yes" xml:space="preserve">
          <source>Warn if a procedure is called that has neither an explicit interface nor has been declared as &lt;code&gt;EXTERNAL&lt;/code&gt;.</source>
          <target state="translated">명시 적 인터페이스가 없거나 &lt;code&gt;EXTERNAL&lt;/code&gt; 로 선언되지 않은 프로 시저가 호출되면 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="ea0bee44772f0985b4e6b09fe2b0a698f6dea611" translate="yes" xml:space="preserve">
          <source>Warn if a procedure is called without an explicit interface. Note this only checks that an explicit interface is present. It does not check that the declared interfaces are consistent across program units.</source>
          <target state="translated">명시 적 인터페이스없이 프로 시저가 호출되면 경고합니다. 이는 명시 적 인터페이스가 존재하는지 확인합니다. 선언 된 인터페이스가 프로그램 단위에서 일관성이 있는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="572b81076d92d77297bcbc29d67f13fbb01a1c1d" translate="yes" xml:space="preserve">
          <source>Warn if a user-defined procedure or module procedure has the same name as an intrinsic; in this case, an explicit interface or &lt;code&gt;EXTERNAL&lt;/code&gt; or &lt;code&gt;INTRINSIC&lt;/code&gt; declaration might be needed to get calls later resolved to the desired intrinsic/procedure. This option is implied by</source>
          <target state="translated">사용자 정의 프로 시저 또는 모듈 프로 시저가 내장 함수와 이름이 같은 경우 경고합니다. 이 경우 나중에 호출을 원하는 내장 / 프로 시저로 해석하기 위해 명시 적 인터페이스 또는 &lt;code&gt;EXTERNAL&lt;/code&gt; 또는 &lt;code&gt;INTRINSIC&lt;/code&gt; 선언이 필요할 수 있습니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="c6313468c7f20703362c8280354927535f8c4817" translate="yes" xml:space="preserve">
          <source>Warn if an array subscript inside a DO loop could lead to an out-of-bounds access even if the compiler cannot prove that the statement is actually executed, in cases like</source>
          <target state="translated">다음과 같은 경우 컴파일러가 명령문이 실제로 실행되었음을 증명할 수없는 경우에도 DO 루프 내부의 배열 첨자가 범위를 벗어난 액세스로 이어질 수있는 경우 경고합니다.</target>
        </trans-unit>
        <trans-unit id="1bbfd5c0b30e3d9b0cc4d30b7e0b3b1ab599cea5" translate="yes" xml:space="preserve">
          <source>Warn if any calls to functions are eliminated by the optimizations enabled by the</source>
          <target state="translated">함수에 대한 호출이</target>
        </trans-unit>
        <trans-unit id="78622fc9eb587b89d6e067b9c66adbfba344d1bf" translate="yes" xml:space="preserve">
          <source>Warn if any calls to impure functions are eliminated by the optimizations enabled by the</source>
          <target state="translated">불순한 함수에 대한 호출이에 의해 활성화 된 최적화에 의해 제거되면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="28fa1b23765d5b95be89cb337809efc686e5e2fa" translate="yes" xml:space="preserve">
          <source>Warn if the a variable might not be C interoperable. In particular, warn if the variable has been declared using an intrinsic type with default kind instead of using a kind parameter defined for C interoperability in the intrinsic &lt;code&gt;ISO_C_Binding&lt;/code&gt; module. This option is implied by</source>
          <target state="translated">변수가 C 상호 운용 가능하지 않을 경우 경고합니다. 특히, 고유 &lt;code&gt;ISO_C_Binding&lt;/code&gt; 모듈 에서 C 상호 운용성에 대해 정의 된 종류 매개 변수를 사용하는 대신 기본 종류를 가진 내장 유형을 사용하여 변수가 선언되었는지 경고합니다 . 이 옵션은</target>
        </trans-unit>
        <trans-unit id="ef8af028d4983d98362486a17cbfc0701f0c1daf" translate="yes" xml:space="preserve">
          <source>Warn if the pointer in a pointer assignment might be longer than the its target. This option is implied by</source>
          <target state="translated">포인터 할당의 포인터가 목표보다 길면 경고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="1e1c6cf6b2f16673310dca3f81d3413d3db94acf" translate="yes" xml:space="preserve">
          <source>Warn when a character assignment will truncate the assigned string.</source>
          <target state="translated">문자 할당이 할당 된 문자열을자를 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="33974696d324503f9f5592f482c2b2bed794f6dc" translate="yes" xml:space="preserve">
          <source>Warn when a source code line will be truncated. This option is implied by</source>
          <target state="translated">소스 코드 행이 잘릴 때 경고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="ef60364667482ef9180c9682128a09332dcdd4fd" translate="yes" xml:space="preserve">
          <source>Warn when comparing real or complex types for equality or inequality. This option is implied by</source>
          <target state="translated">평등 또는 불평등에 대해 실제 또는 복합 유형을 비교할 때 경고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="1bae9b5e7bb97c9d9f44c62b324978d3ef2cfb85" translate="yes" xml:space="preserve">
          <source>Warn when the compiler inserts code to for allocation or reallocation of an allocatable variable; this includes scalars and derived types.</source>
          <target state="translated">할당 가능한 변수의 할당 또는 재 할당을 위해 컴파일러가 코드를 삽입 할 때 경고합니다. 여기에는 스칼라 및 파생 형식이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3e7c470d64906667f279242b7e6866ca62a8625a" translate="yes" xml:space="preserve">
          <source>Warn when the compiler might insert code to for allocation or reallocation of an allocatable array variable of intrinsic type in intrinsic assignments. In hot loops, the Fortran 2003 reallocation feature may reduce the performance. If the array is already allocated with the correct shape, consider using a whole-array array-spec (e.g. &lt;code&gt;(:,:,:)&lt;/code&gt;) for the variable on the left-hand side to prevent the reallocation check. Note that in some cases the warning is shown, even if the compiler will optimize reallocation checks away. For instance, when the right-hand side contains the same variable multiplied by a scalar. See also</source>
          <target state="translated">컴파일러가 내장형 할당에 내장형의 할당 가능한 배열 변수를 할당하거나 재 할당하기 위해 코드를 삽입 할 때 경고합니다. 핫 루프에서 Fortran 2003 재 할당 기능은 성능을 저하시킬 수 있습니다. 배열이 이미 올바른 모양으로 할당 된 경우 재 할당 검사를 방지하기 위해 왼쪽의 변수에 대해 전체 배열 배열 사양 (예 : &lt;code&gt;(:,:,:)&lt;/code&gt; )을 사용하는 것이 좋습니다. 컴파일러가 재 할당 검사를 최적화하더라도 경고가 표시되는 경우가 있습니다. 예를 들어, 오른쪽에 동일한 변수에 스칼라를 곱한 값이 포함 된 경우. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="aba0f8527f0ae28cb3764542d56ab9c6554a3372" translate="yes" xml:space="preserve">
          <source>Warn when using</source>
          <target state="translated">사용할 때 경고</target>
        </trans-unit>
        <trans-unit id="dd2caf461146fc0c27dbc71c71c4f7aa3908451d" translate="yes" xml:space="preserve">
          <source>Warning: this currently handles C- and C++-Style comments only. The preprocessor does not yet recognize Fortran-style comments.</source>
          <target state="translated">경고 : 현재 C- 및 C ++ 스타일 주석 만 처리합니다. 전처리 기는 아직 포트란 스타일 주석을 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="94ffd48f2b4d962c99d9db25ca293419aa163ad8" translate="yes" xml:space="preserve">
          <source>Warning: this currently handles C-Style comments only. The preprocessor does not yet recognize Fortran-style comments.</source>
          <target state="translated">경고 : 현재 C 스타일 주석 만 처리합니다. 전처리 기는 아직 포트란 스타일 주석을 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="a2c9d16128d0b0e986193867a02e538ba9edc111" translate="yes" xml:space="preserve">
          <source>Warnings are diagnostic messages that report constructions which are not inherently erroneous but which are risky or suggest there is likely to be a bug in the program. Unless</source>
          <target state="translated">경고는 본질적으로 잘못된 것은 아니지만 위험하거나 프로그램에 버그가있을 가능성이있는 구성을보고하는 진단 메시지입니다. 그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="108fa40e56841a965aacfcbfefc2ec6faafaf150" translate="yes" xml:space="preserve">
          <source>Warns at run time when for passing an actual argument a temporary array had to be generated. The information generated by this warning is sometimes useful in optimization, in order to avoid such temporaries.</source>
          <target state="translated">실제 인수를 전달할 때 임시 배열을 생성해야 할 때 런타임에 경고합니다. 이 경고에 의해 생성 된 정보는 때때로 그러한 일시적인 상황을 피하기 위해 최적화에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5f670340f4086217d636b58b4a8baf518283a90e" translate="yes" xml:space="preserve">
          <source>What you should know about the GNU Fortran compiler.</source>
          <target state="translated">GNU Fortran 컴파일러에 대해 알아야 할 사항</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="ae8f2c847e82eacb3330824431ecb6760c9c80c7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; is used, then only a token for an allocatable or pointer component is created. The &lt;code&gt;SIZE&lt;/code&gt; parameter is not used then. On the contrary when &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY&lt;/code&gt; is specified, then the &lt;var&gt;token&lt;/var&gt; needs to be registered by a previous call with regtype &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; and either the memory specified in the &lt;var&gt;DESC&lt;/var&gt;&amp;rsquo;s data-ptr is registered or allocate when the data-ptr is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; 이 사용되고, 다음 할당 가능한 구성 요소 또는 포인터 만 토큰이 생성된다. 이때 &lt;code&gt;SIZE&lt;/code&gt; 매개 변수는 사용되지 않습니다. 반대로 &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY&lt;/code&gt; 가 지정된 경우 에는 regtype &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; 를 사용하여 이전 호출에 의해 &lt;var&gt;token&lt;/var&gt; 을 등록해야 하며 &lt;var&gt;DESC&lt;/var&gt; 의 data-ptr에 지정된 메모리 가 등록되거나 data-ptr이 &lt;code&gt;NULL&lt;/code&gt; 인 경우 할당해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="67560420e909b1895814947ddf8f0aa9a465f756" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; is used, then only a token for an allocatable or pointer component is created. The &lt;code&gt;SIZE&lt;/code&gt; parameter is not used then. On the contrary when &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY&lt;/code&gt; is specified, then the &lt;var&gt;token&lt;/var&gt; needs to be registered by a previous call with regtype &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; and either the memory specified in the &lt;var&gt;desc&lt;/var&gt;&amp;rsquo;s data-ptr is registered or allocate when the data-ptr is NULL.</source>
          <target state="translated">&lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; 가 사용 되면 할당 가능 또는 포인터 구성 요소에 대한 토큰 만 작성됩니다. 그런 다음 &lt;code&gt;SIZE&lt;/code&gt; 매개 변수가 사용되지 않습니다. 반대로 &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY&lt;/code&gt; 가 지정, 다음 &lt;var&gt;token&lt;/var&gt; 요구는 regtype와 이전 호출에 의해 등록 할 &lt;code&gt;CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY&lt;/code&gt; 에 지정된 및 중 메모리 &lt;var&gt;desc&lt;/var&gt; 의 등록 또는 데이터 PTR이 NULL 인 경우 할당되는 데이터-PTR.</target>
        </trans-unit>
        <trans-unit id="88bded3e15ff0baa725022f73c001015ef1a3188" translate="yes" xml:space="preserve">
          <source>When a serious runtime error is encountered or a deadly signal is emitted (segmentation fault, illegal instruction, bus error, floating-point exception, and the other POSIX signals that have the action &amp;lsquo;</source>
          <target state="translated">심각한 런타임 오류가 발생하거나 치명적인 신호가 발생하는 경우 (세그먼트 오류, 잘못된 명령어, 버스 오류, 부동 소수점 예외 및 작업이있는 기타 POSIX 신호 '</target>
        </trans-unit>
        <trans-unit id="d187440d3289a9e0210d93ea0fd013f9512aa25b" translate="yes" xml:space="preserve">
          <source>When converting C to Fortran arrays, the one-dimensional &lt;code&gt;SHAPE&lt;/code&gt; argument has to be passed.</source>
          <target state="translated">C를 포트란 배열로 변환 할 때는 1 차원 &lt;code&gt;SHAPE&lt;/code&gt; 인수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7c4c91617326eaca277c24e11db7d05cc0cbfa1" translate="yes" xml:space="preserve">
          <source>When enabled, floating point numbers of value zero with the sign bit set are written as negative number in formatted output and treated as negative in the &lt;code&gt;SIGN&lt;/code&gt; intrinsic.</source>
          <target state="translated">활성화되면 부호 비트가 설정된 값 0의 부동 소수점 숫자가 형식화 된 출력에서 ​​음수로 기록되고 &lt;code&gt;SIGN&lt;/code&gt; 내장 함수 에서 음수로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="eeca1f337fb739872b54dee328f73f93a9e40dfd" translate="yes" xml:space="preserve">
          <source>When front-end optimiztion is active, some calls to the &lt;code&gt;MATMUL&lt;/code&gt; intrinsic function will be inlined. This may result in code size increase if the size of the matrix cannot be determined at compile time, as code for both cases is generated. Setting &lt;code&gt;-finline-matmul-limit=0&lt;/code&gt; will disable inlining in all cases. Setting this option with a value of &lt;var&gt;n&lt;/var&gt; will produce inline code for matrices with size up to &lt;var&gt;n&lt;/var&gt;. If the matrices involved are not square, the size comparison is performed using the geometric mean of the dimensions of the argument and result matrices.</source>
          <target state="translated">프론트 엔드 최적화가 활성화되면 &lt;code&gt;MATMUL&lt;/code&gt; 내장 함수 에 대한 일부 호출 이 인라인됩니다. 두 경우 모두 코드가 생성 될 때 컴파일 타임에 행렬의 크기를 결정할 수없는 경우 코드 크기가 증가 할 수 있습니다. 설정 &lt;code&gt;-finline-matmul-limit=0&lt;/code&gt; 모든 경우에 인라인이 비활성화됩니다. 이 옵션을 &lt;var&gt;n&lt;/var&gt; 값으로 설정하면 크기가 최대 &lt;var&gt;n&lt;/var&gt; 인 행렬에 대한 인라인 코드가 생성됩니다 . 관련된 행렬이 정사각형이 아닌 경우 인수와 결과 행렬의 차원에 대한 기하 평균을 사용하여 크기 비교가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2766d2d7801570fd9ec5320c58ddadc1590a00ab" translate="yes" xml:space="preserve">
          <source>When opening a file with &lt;code&gt;STATUS='SCRATCH'&lt;/code&gt;, GNU Fortran tries to create the file in one of the potential directories by testing each directory in the order below.</source>
          <target state="translated">&lt;code&gt;STATUS='SCRATCH'&lt;/code&gt; 로 파일을 열면 GNU Fortran은 아래 순서대로 각 디렉토리를 테스트하여 잠재적 디렉토리 중 하나에 파일을 작성하려고합니다.</target>
        </trans-unit>
        <trans-unit id="11e80ace0193957c244a758d9c902ca08eba49a2" translate="yes" xml:space="preserve">
          <source>When passing an assumed-shape argument of a procedure as actual argument to an assumed-size or explicit size or as argument to a procedure that does not have an explicit interface, the argument may have to be packed, that is put into contiguous memory. An example is the call to &lt;code&gt;foo&lt;/code&gt; in</source>
          <target state="translated">프로 시저의 가정 된 모양 인수를 가정 된 크기 또는 명시 적 크기에 대한 실제 인수로 전달하거나 명시 적 인터페이스가없는 프로 시저에 대한 인수로 전달하는 경우 인수가 압축되어 연속 메모리에 저장됩니다. 예를 들어 &lt;code&gt;foo&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="a35971e670e07866ae8840e316c8e7d29e3fe47c" translate="yes" xml:space="preserve">
          <source>When running on a platform using the GNU C library (glibc) version 2.16 or older, or a derivative thereof, the high resolution monotonic clock is available only when linking with the &lt;var&gt;rt&lt;/var&gt; library. This can be done explicitly by adding the &lt;code&gt;-lrt&lt;/code&gt; flag when linking the application, but is also done implicitly when using OpenMP.</source>
          <target state="translated">GNU C 라이브러리 (glibc) 버전 2.16 이상 또는 그 파생어를 사용하는 플랫폼에서 실행하는 경우 고해상도 단조로운 시계는 &lt;var&gt;rt&lt;/var&gt; 라이브러리 와 링크 할 때만 사용할 수 있습니다. 응용 프로그램을 연결할 때 &lt;code&gt;-lrt&lt;/code&gt; 플래그 를 추가하여 명시 적으로 수행 할 수 있지만 OpenMP를 사용하면 암시 적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e675ba4e2a9fc9ca692908904940d08356ceb15f" translate="yes" xml:space="preserve">
          <source>When the resulting bit representation does not correspond to a valid representation of a variable of the same type as &lt;var&gt;MOLD&lt;/var&gt;, the results are undefined, and subsequent operations on the result cannot be guaranteed to produce sensible behavior. For example, it is possible to create &lt;code&gt;LOGICAL&lt;/code&gt; variables for which &lt;code&gt;&lt;var&gt;VAR&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;.NOT.&lt;var&gt;VAR&lt;/var&gt;&lt;/code&gt; both appear to be true.</source>
          <target state="translated">결과 비트 표현이 &lt;var&gt;MOLD&lt;/var&gt; 와 동일한 유형의 변수의 유효한 표현에 해당하지 않는 경우 결과가 정의되지 않으며 결과에 대한 후속 조작으로 합리적인 동작을 보장 할 수 없습니다. 예를 들어, &lt;code&gt;&lt;var&gt;VAR&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;.NOT.&lt;var&gt;VAR&lt;/var&gt;&lt;/code&gt; 대한 &lt;code&gt;LOGICAL&lt;/code&gt; 변수 를 작성할 수 있습니다 . &lt;var&gt;VAR&lt;/var&gt; 은 모두 사실 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3f056e8af3b672d61e0cf862b2ce71a359bc2ac" translate="yes" xml:space="preserve">
          <source>When writing a namelist, if no &lt;code&gt;DELIM=&lt;/code&gt; is specified, by default a double quote is used to delimit character strings. If -std=F95, F2003, or F2008, etc, the delim status is set to &amp;rsquo;none&amp;rsquo;. Defaulting to quotes ensures that namelists with character strings can be subsequently read back in accurately.</source>
          <target state="translated">이름 목록을 작성할 때 &lt;code&gt;DELIM=&lt;/code&gt; 을 지정 하지 않으면 기본적으로 큰 따옴표가 문자열을 구분하는 데 사용됩니다. -std = F95, F2003 또는 F2008 등인 경우 탈회 상태는 '없음'으로 설정됩니다. 따옴표로 기본 설정하면 문자열이 포함 된 이름 목록을 나중에 정확하게 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba58728ec5ca054abee939a9a3fb572c1d4641e6" translate="yes" xml:space="preserve">
          <source>When you compile a &lt;code&gt;PROGRAM&lt;/code&gt; with GNU Fortran, a function with the name &lt;code&gt;main&lt;/code&gt; (in the symbol table of the object file) is generated, which initializes the libgfortran library and then calls the actual program which uses the name &lt;code&gt;MAIN__&lt;/code&gt;, for historic reasons. If you link GNU Fortran compiled procedures to, e.g., a C or C++ program or to a Fortran program compiled by a different compiler, the libgfortran library is not initialized and thus a few intrinsic procedures do not work properly, e.g. those for obtaining the command-line arguments.</source>
          <target state="translated">GNU Fortran 을 사용하여 &lt;code&gt;PROGRAM&lt;/code&gt; 을 컴파일 할 때 이름이 &lt;code&gt;main&lt;/code&gt; (오브젝트 파일의 기호 테이블에 있음) 인 함수 가 생성되어 libgfortran 라이브러리를 초기화 한 다음 역사적인 이유로 이름 &lt;code&gt;MAIN__&lt;/code&gt; 을 사용하는 실제 프로그램을 호출합니다 . GNU Fortran 컴파일 프로 시저를 예를 들어 C 또는 C ++ 프로그램 또는 다른 컴파일러가 컴파일 한 Fortran 프로그램에 링크하면 libgfortran 라이브러리가 초기화되지 않으므로 몇 가지 고유 프로 시저 (예 : 명령을 얻는 프로 시저)가 제대로 작동하지 않습니다. 라인 인수.</target>
        </trans-unit>
        <trans-unit id="f2750398741b2f11290cbd685e177851d8fb5c1c" translate="yes" xml:space="preserve">
          <source>Where &lt;em&gt;cc&lt;/em&gt; is a character expression that evaluates to one of the following values:</source>
          <target state="translated">여기서 &lt;em&gt;cc&lt;/em&gt; 는 다음 값 중 하나로 평가되는 문자 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="6c7de8024b3cfabcef4a35c5b7edc7a021aa8dea" translate="yes" xml:space="preserve">
          <source>Where &lt;em&gt;sh&lt;/em&gt; in the first form is a character expression that evaluates to a value as seen in the table below. The latter two forms are aliases for particular values of &lt;em&gt;sh&lt;/em&gt;:</source>
          <target state="translated">여기서 &lt;em&gt;SH&lt;/em&gt; 첫번째 형태는 평가 값은 아래의 표와 같이하는 문자 표현이다. 후자의 두 형식은 특정 &lt;em&gt;sh&lt;/em&gt; 값에 대한 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="4791bac408596c8470b374c7662725fdf31ff5e8" translate="yes" xml:space="preserve">
          <source>Where to find module files</source>
          <target state="translated">모듈 파일을 찾을 수있는 곳</target>
        </trans-unit>
        <trans-unit id="8485a0cf529dc17b7cfbe99570f8d806cd3e66d5" translate="yes" xml:space="preserve">
          <source>Whether a unit is a terminal device</source>
          <target state="translated">장치가 터미널 장치인지 여부</target>
        </trans-unit>
        <trans-unit id="35defbb7af16014ebb90d057f80d80681233aa89" translate="yes" xml:space="preserve">
          <source>While CPP is the de-facto standard for preprocessing Fortran code, Part 3 of the Fortran 95 standard (ISO/IEC 1539-3:1998) defines Conditional Compilation, which is not widely used and not directly supported by the GNU Fortran compiler. You can use the program coco to preprocess such files (&lt;a href=&quot;http://www.daniellnagle.com/coco.html&quot;&gt;http://www.daniellnagle.com/coco.html&lt;/a&gt;).</source>
          <target state="translated">CPP는 Fortran 코드 전처리를위한 사실상의 표준이지만 Fortran 95 표준 (ISO / IEC 1539-3 : 1998)의 Part 3은 GNU Fortran 컴파일러에서 널리 사용되지 않고 직접 지원되지 않는 조건부 컴파일을 정의합니다. coco 프로그램을 사용하여 이러한 파일을 사전 처리 할 수 ​​있습니다 ( &lt;a href=&quot;http://www.daniellnagle.com/coco.html&quot;&gt;http://www.daniellnagle.com/coco.html&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="44465ca1745e5c89ef858bdcaf96f5ad6660cc0e" translate="yes" xml:space="preserve">
          <source>While the rules permit in principle an intrinsic function, none of the intrinsics in the standard fulfill the criteria of having a specific function, which takes two arguments of the same type and returning that type as result.</source>
          <target state="translated">규칙은 원칙적으로 내장 함수를 허용하지만 표준의 내장 함수 중 어느 것도 특정 함수를 갖는 기준을 충족하지 못합니다. 동일한 함수의 두 인수를 취하여 결과로 해당 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9b230703e30bf49ec651c144023967c8c1427a1" translate="yes" xml:space="preserve">
          <source>Why we chose to start from scratch.</source>
          <target state="translated">처음부터 시작하기로 선택한 이유</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="97578212676930534c49ede2c08cfc8bb97a541e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;CARRIAGECONTROL='FORTRAN'&lt;/code&gt;, when a record is written, the first character of the input record is not written, and instead determines the output record separator as follows:</source>
          <target state="translated">함께 &lt;code&gt;CARRIAGECONTROL='FORTRAN'&lt;/code&gt; 레코드가 작성되고, 입력 레코드의 첫 번째 문자를 기입하고, 대신 다음과 같이 출력 레코드 분리 결정되지 않는다 :</target>
        </trans-unit>
        <trans-unit id="0dabf0d0b5e9adcedd79c3fc95b6d7f5d6bae542" translate="yes" xml:space="preserve">
          <source>With respect to consistency, for regular files GNU Fortran uses buffered I/O in order to improve performance. This buffer is flushed automatically when full and in some other situations, e.g. when closing a unit. It can also be explicitly flushed with the &lt;code&gt;FLUSH&lt;/code&gt; statement. Also, the buffering can be turned off with the &lt;code&gt;GFORTRAN_UNBUFFERED_ALL&lt;/code&gt; and &lt;code&gt;GFORTRAN_UNBUFFERED_PRECONNECTED&lt;/code&gt; environment variables. Special files, such as terminals and pipes, are always unbuffered. Sometimes, however, further things may need to be done in order to allow other processes to see data that GNU Fortran has written, as follows.</source>
          <target state="translated">일관성과 관련하여 일반 파일의 경우 GNU Fortran은 성능을 향상시키기 위해 버퍼 된 I / O를 사용합니다. 이 버퍼는 가득 차거나 다른 상황 (예 : 장치를 닫을 때)에 자동으로 플러시됩니다. &lt;code&gt;FLUSH&lt;/code&gt; 문을 사용하여 명시 적으로 플러시 할 수도 있습니다 . 또한 &lt;code&gt;GFORTRAN_UNBUFFERED_ALL&lt;/code&gt; 및 &lt;code&gt;GFORTRAN_UNBUFFERED_PRECONNECTED&lt;/code&gt; 환경 변수를 사용 하여 버퍼링을 해제 할 수 있습니다 . 터미널 및 파이프와 같은 특수 파일은 항상 버퍼링되지 않습니다. 그러나 때때로 다른 프로세스가 다음과 같이 GNU Fortran이 작성한 데이터를 볼 수 있도록하기 위해 추가 작업이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecf2fd597a2a6a9d6edc2945801575d8aeebc586" translate="yes" xml:space="preserve">
          <source>With respect to durability, GNU Fortran makes no effort to ensure that data is committed to stable storage. If this is required, the GNU Fortran programmer can use the intrinsic &lt;code&gt;FNUM&lt;/code&gt; to retrieve the low level file descriptor corresponding to an open Fortran unit. Then, using e.g. the &lt;code&gt;ISO_C_BINDING&lt;/code&gt; feature, one can call the underlying system call to flush dirty data to stable storage, such as &lt;code&gt;fsync&lt;/code&gt; on POSIX, &lt;code&gt;_commit&lt;/code&gt; on MingW, or &lt;code&gt;fcntl(fd,
F_FULLSYNC, 0)&lt;/code&gt; on Mac OS X. The following example shows how to call fsync:</source>
          <target state="translated">내구성과 관련하여 GNU Fortran은 데이터가 안정적인 스토리지에 투입되도록 노력하지 않습니다. 이것이 필요한 경우 GNU Fortran 프로그래머는 내장 &lt;code&gt;FNUM&lt;/code&gt; 을 사용하여 열린 포트란 장치에 해당하는 하위 수준 파일 설명자를 검색 할 수 있습니다 . 그런 다음 &lt;code&gt;ISO_C_BINDING&lt;/code&gt; 기능을 사용 하여 기본 시스템 호출을 호출하여 POSIX의 &lt;code&gt;fsync&lt;/code&gt; , MingW의 &lt;code&gt;_commit&lt;/code&gt; 또는 Mac OS X의 &lt;code&gt;fcntl(fd, F_FULLSYNC, 0)&lt;/code&gt; 과 같이 더티 데이터를 안정적인 스토리지로 플러시 할 수 있습니다 . 다음 예 fsync를 호출하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d4565f8f86a38c3e14bd51ab8867add7e5bdca13" translate="yes" xml:space="preserve">
          <source>Write a single character in stream mode</source>
          <target state="translated">스트림 모드에서 단일 문자 쓰기</target>
        </trans-unit>
        <trans-unit id="0c7aacd737c85b4482ea60464b1e5483a7f859f6" translate="yes" xml:space="preserve">
          <source>Write a single character in stream mode by bypassing normal formatted output. Stream I/O should not be mixed with normal record-oriented (formatted or unformatted) I/O on the same unit; the results are unpredictable.</source>
          <target state="translated">일반 형식의 출력을 무시하여 스트림 모드에서 단일 문자를 작성하십시오. 스트림 I / O는 동일한 장치에서 일반 레코드 지향 (포맷되거나 형식화되지 않은) I / O와 혼합되어서는 안됩니다. 결과는 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ae30dab9123b514da2987353a722881cdcb9b99" translate="yes" xml:space="preserve">
          <source>Write a single character in stream mode to stdout</source>
          <target state="translated">스트림 모드에서 단일 문자를 stdout에 작성</target>
        </trans-unit>
        <trans-unit id="ae7b54f04eb7530a2b1812a63e469e3d486eba7f" translate="yes" xml:space="preserve">
          <source>Write a single character in stream mode to stdout by bypassing normal formatted output. Stream I/O should not be mixed with normal record-oriented (formatted or unformatted) I/O on the same unit; the results are unpredictable.</source>
          <target state="translated">일반 형식의 출력을 무시하여 스트림 모드에서 단일 문자를 stdout에 씁니다. 스트림 I / O는 동일한 장치에서 일반 레코드 지향 (포맷되거나 형식화되지 않은) I / O와 혼합되어서는 안됩니다. 결과는 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="6c48174bf9be34e46b8e987347f290f90c99d38c" translate="yes" xml:space="preserve">
          <source>Years since 1900</source>
          <target state="translated">1900 년 이후</target>
        </trans-unit>
        <trans-unit id="111fe75a8c4e18020ec4499e010fa687af13b495" translate="yes" xml:space="preserve">
          <source>You can compile Fortran, C, or other programs.</source>
          <target state="translated">Fortran, C 또는 기타 프로그램을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dd4909e8fc25b70ebd4942296a6f09a42e2b499" translate="yes" xml:space="preserve">
          <source>You can request many specific warnings with options beginning</source>
          <target state="translated">옵션을 시작하여 많은 특정 경고를 요청할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3e9f14dd6998edf466db38fdc1b1ab851d13c7e5" translate="yes" xml:space="preserve">
          <source>You can use this directive to control how many times a loop should be unrolled. It must be placed immediately before a &lt;code&gt;DO&lt;/code&gt; loop and applies only to the loop that follows. N is an integer constant specifying the unrolling factor. The values of 0 and 1 block any unrolling of the loop.</source>
          <target state="translated">이 지시문을 사용하여 루프를 언 롤링해야하는 횟수를 제어 할 수 있습니다. &lt;code&gt;DO&lt;/code&gt; 루프 바로 앞에 위치해야하며 다음 루프에만 적용됩니다. N은 언 롤링 계수를 지정하는 정수 상수입니다. 0과 1의 값은 루프의 모든 풀림을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="f747c1351f871bcd60a180b905c92b44750331fe" translate="yes" xml:space="preserve">
          <source>You can use this directive to define which middle-end built-ins provide vector implementations. &lt;code&gt;B&lt;/code&gt; is name of the middle-end built-in. &lt;code&gt;FLAGS&lt;/code&gt; are optional and must be either &quot;(inbranch)&quot; or &quot;(notinbranch)&quot;. &lt;code&gt;IF&lt;/code&gt; statement is optional and is used to filter multilib ABIs for the built-in that should be vectorized. Example usage:</source>
          <target state="translated">이 지시문을 사용하여 벡터 구현을 제공하는 중급 내장 기능을 정의 할 수 있습니다. &lt;code&gt;B&lt;/code&gt; 는 내장형 중급의 이름입니다. &lt;code&gt;FLAGS&lt;/code&gt; 는 선택 사항이며 &quot;(inbranch)&quot;또는 &quot;(notinbranch)&quot;중 하나 여야합니다. &lt;code&gt;IF&lt;/code&gt; 문은 선택 사항이며 벡터화해야하는 내장에 대한 multilib ABI를 필터링하는 데 사용됩니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="5a83a0c884ced5b1afbf8e0b73de9c85e4e8c7bb" translate="yes" xml:space="preserve">
          <source>You should be prepared for side effects when using</source>
          <target state="translated">사용할 때 부작용에 대비해야합니다</target>
        </trans-unit>
        <trans-unit id="b09ae3d62baa1b83765b926b94bd6ef475f9f741" translate="yes" xml:space="preserve">
          <source>[Function] The kind type parameter is that of &lt;code&gt;pid&lt;/code&gt;. Returns 0 on success; otherwise a system-specific error code is returned.</source>
          <target state="translated">[함수] 종류 유형 매개 변수는 &lt;code&gt;pid&lt;/code&gt; 의 매개 변수입니다 . 성공하면 0을 반환합니다. 그렇지 않으면 시스템 특정 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d3a12c2833904d981c45e7a3ab4d30ccefa492e9" translate="yes" xml:space="preserve">
          <source>[Subroutine](Optional) Shall be a scalar &lt;code&gt;INTEGER&lt;/code&gt;. Returns 0 on success; otherwise a system-specific error code is returned.</source>
          <target state="translated">[서브 루틴] (선택 사항) 스칼라 &lt;code&gt;INTEGER&lt;/code&gt; 가 됩니다. 성공하면 0을 반환합니다. 그렇지 않으면 시스템 특정 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="80bcc8b02cd875c9c7b9dc9e6159a6cd886a4b36" translate="yes" xml:space="preserve">
          <source>\e</source>
          <target state="translated">\e</target>
        </trans-unit>
        <trans-unit id="c0f3cda9e4344c2a7bab365b583714e3ced4d0ef" translate="yes" xml:space="preserve">
          <source>a scalar integer expression. It shall have the same the same value on all images and refer to an image of the current team.</source>
          <target state="translated">스칼라 정수 표현식 모든 이미지에서 동일한 값을 가지며 현재 팀의 이미지를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f1dba76b561684930a25a984046b3b4149785ca" translate="yes" xml:space="preserve">
          <source>alert</source>
          <target state="translated">alert</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="e77bd9716ede992358114f3a902f3355d112cb37" translate="yes" xml:space="preserve">
          <source>allocatable arrays</source>
          <target state="translated">할당 가능한 배열</target>
        </trans-unit>
        <trans-unit id="62633185507778aceb37987eb1cc91a21a879a8f" translate="yes" xml:space="preserve">
          <source>allows both without warning. The special compile flag</source>
          <target state="translated">경고없이 둘 다 허용합니다. 특수 컴파일 플래그</target>
        </trans-unit>
        <trans-unit id="1f5b3f613766aaf918a69780de4c9798b47580fe" translate="yes" xml:space="preserve">
          <source>allows direct specification of user-defined names while debugging and when interfacing GNU Fortran code with other languages.</source>
          <target state="translated">GNU Fortran 코드를 디버깅하고 다른 언어와 인터페이스 할 때 사용자 정의 이름을 직접 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b094bd4b93be6eefd9deabac603a3ffc8863916f" translate="yes" xml:space="preserve">
          <source>allows the compiler to accept both types of extensions, but to warn about the use of the latter. Specifying either</source>
          <target state="translated">컴파일러가 두 가지 유형의 확장을 모두 허용하지만 후자의 사용에 대해 경고 할 수 있습니다. 다음 중 하나를 지정</target>
        </trans-unit>
        <trans-unit id="307d1e360bd70b68e619ab4409229ef6381f25fd" translate="yes" xml:space="preserve">
          <source>allows the compiler to reorder &lt;code&gt;REAL&lt;/code&gt; and &lt;code&gt;COMPLEX&lt;/code&gt; expressions to produce faster code. Note that for the re-association optimization</source>
          <target state="translated">컴파일러가 &lt;code&gt;REAL&lt;/code&gt; 및 &lt;code&gt;COMPLEX&lt;/code&gt; 표현식 을 재정렬 하여 더 빠른 코드를 생성 할 수 있습니다. 재 연관 최적화를 위해</target>
        </trans-unit>
        <trans-unit id="40bc64f32f3759cd80b03c592116e7e3e45028dc" translate="yes" xml:space="preserve">
          <source>also applies to C-language constructs where they occur in GNU Fortran source files, such as use of &amp;lsquo;</source>
          <target state="translated">GNU Fortran 소스 파일에서 발생하는 C 언어 구성에도 적용됩니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="f34eaf4f6ae89eb9588e134559245afad4e138e4" translate="yes" xml:space="preserve">
          <source>also sets</source>
          <target state="translated">또한 세트</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="462e6102c017b6efc429cc5adc75f57c58251ea7" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;INCLUDE&lt;/code&gt; is pretty much the same as of</source>
          <target state="translated">및 &lt;code&gt;INCLUDE&lt;/code&gt; 는 거의의과 동일</target>
        </trans-unit>
        <trans-unit id="292980597e557a10217b5691febcadb9d213adb8" translate="yes" xml:space="preserve">
          <source>and before the standard system directories. If &lt;var&gt;dir&lt;/var&gt; begins with &lt;code&gt;=&lt;/code&gt;, then the &lt;code&gt;=&lt;/code&gt; will be replaced by the sysroot prefix; see</source>
          <target state="translated">그리고 표준 시스템 디렉토리 이전. 경우 &lt;var&gt;dir&lt;/var&gt; 시작 &lt;code&gt;=&lt;/code&gt; 다음 &lt;code&gt;=&lt;/code&gt; 는 SYSROOT 프리픽스로 대체한다; 보다</target>
        </trans-unit>
        <trans-unit id="fe615c5a045e9786f613b25d6db6e8a3a153cd9f" translate="yes" xml:space="preserve">
          <source>and the standard system directories have been exhausted. &lt;var&gt;dir&lt;/var&gt; is treated as a system include directory. If dir begins with &lt;code&gt;=&lt;/code&gt;, then the &lt;code&gt;=&lt;/code&gt; will be replaced by the sysroot prefix; see</source>
          <target state="translated">표준 시스템 디렉토리가 소진되었습니다. &lt;var&gt;dir&lt;/var&gt; 은 시스템 포함 디렉토리로 취급됩니다. dir이 &lt;code&gt;=&lt;/code&gt; 로 시작 하면 &lt;code&gt;=&lt;/code&gt; 는 sysroot 접두사로 대체됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="279e1d014cf4abebcae795334732a0d437d5eaee" translate="yes" xml:space="preserve">
          <source>are fulfillable</source>
          <target state="translated">이행 가능하다</target>
        </trans-unit>
        <trans-unit id="c162e6f931b76a039cade52319fa62f5f59d5ac4" translate="yes" xml:space="preserve">
          <source>are unset, then</source>
          <target state="translated">설정되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="f90b354e1ad05f2cbdb06191a417c252a8ef06d9" translate="yes" xml:space="preserve">
          <source>array-temps</source>
          <target state="translated">array-temps</target>
        </trans-unit>
        <trans-unit id="701c2ff3eb348e7426c8e05b63b0c9f609bb4ed2" translate="yes" xml:space="preserve">
          <source>as a shared and a static library, this option forces the use of the static version. If no shared version of</source>
          <target state="translated">공유 및 정적 라이브러리 인 경우이 옵션은 정적 버전을 강제로 사용합니다. 공유 버전이없는 경우</target>
        </trans-unit>
        <trans-unit id="4930eb3f60df3a6a61e8d44178feb2b8f820a153" translate="yes" xml:space="preserve">
          <source>backspace</source>
          <target state="translated">backspace</target>
        </trans-unit>
        <trans-unit id="38e4f23119f7668c81c56c877acdc10f397299d2" translate="yes" xml:space="preserve">
          <source>big-endian</source>
          <target state="translated">big-endian</target>
        </trans-unit>
        <trans-unit id="0569ae912e387dbc988dee842bf17cdd4e437f63" translate="yes" xml:space="preserve">
          <source>bits</source>
          <target state="translated">bits</target>
        </trans-unit>
        <trans-unit id="94ae97ff8e7caaef3f4646cca3cdf56f523b799b" translate="yes" xml:space="preserve">
          <source>bounds</source>
          <target state="translated">bounds</target>
        </trans-unit>
        <trans-unit id="188ee8a2f10ca3a55acd9ea49e80b28725f4f691" translate="yes" xml:space="preserve">
          <source>but before the standard system directories. Mark it as a system directory, so that it gets the same special treatment as is applied to the standard system directories. If &lt;var&gt;dir&lt;/var&gt; begins with &lt;code&gt;=&lt;/code&gt;, then the &lt;code&gt;=&lt;/code&gt; will be replaced by the sysroot prefix; see</source>
          <target state="translated">그러나 표준 시스템 디렉토리 앞에 있습니다. 표준 시스템 디렉토리에 적용되는 것과 동일한 특수 처리를 받도록 시스템 디렉토리로 표시하십시오. 경우 &lt;var&gt;dir&lt;/var&gt; 시작 &lt;code&gt;=&lt;/code&gt; 다음 &lt;code&gt;=&lt;/code&gt; 는 SYSROOT 프리픽스로 대체한다; 보다</target>
        </trans-unit>
        <trans-unit id="ebb9c7c867d883ff5141789956a5ef40c338d9bf" translate="yes" xml:space="preserve">
          <source>calling conventions as, calling &lt;code&gt;COMPLEX&lt;/code&gt; or default &lt;code&gt;REAL&lt;/code&gt; functions between program parts which were compiled with different calling conventions will break at execution time.</source>
          <target state="translated">전화, 같은 규칙 호출 &lt;code&gt;COMPLEX&lt;/code&gt; 또는 기본 &lt;code&gt;REAL&lt;/code&gt; 의 실행 시간에 휴식 것입니다 서로 다른 호출 규칙 컴파일 된 프로그램 부분 사이의 기능을.</target>
        </trans-unit>
        <trans-unit id="155492bae6631e20781be78071bc152b6d8f9cf8" translate="yes" xml:space="preserve">
          <source>calling conventions.</source>
          <target state="translated">전화 컨벤션.</target>
        </trans-unit>
        <trans-unit id="0ba7cfd7085a8bbf209947aafdb4a7809cf36c85" translate="yes" xml:space="preserve">
          <source>can be of any type</source>
          <target state="translated">어떤 유형이든 가능</target>
        </trans-unit>
        <trans-unit id="53beda948658ffb5ab31db86eab25bf5510c8780" translate="yes" xml:space="preserve">
          <source>can be used to disable automatic alignment. The same form of this option should be used for all files that share a &lt;code&gt;COMMON&lt;/code&gt; block. To avoid potential alignment issues in &lt;code&gt;COMMON&lt;/code&gt; blocks, it is recommended to order objects from largest to smallest.</source>
          <target state="translated">자동 정렬을 비활성화하는 데 사용할 수 있습니다. &lt;code&gt;COMMON&lt;/code&gt; 블록 을 공유하는 모든 파일에 동일한 형식의이 옵션을 사용해야합니다 . &lt;code&gt;COMMON&lt;/code&gt; 블록 에서 잠재적 인 정렬 문제를 피하려면 개체를 최대에서 최소로 주문하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ccf724a55479e15f28ad8abcfb71e0079d794123" translate="yes" xml:space="preserve">
          <source>can be used to never trigger this behavior and always link to the intrinsic regardless of the selected standard.</source>
          <target state="translated">이 동작을 트리거하지 않고 선택한 표준에 관계없이 항상 내장 함수에 연결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45d7ff0a6ad7e73b5bef8ff8fc4ce39dd5dd1f46" translate="yes" xml:space="preserve">
          <source>can be used to prevent this. The kind of real constants like &lt;code&gt;1.d0&lt;/code&gt; will not be changed by</source>
          <target state="translated">이를 방지하는 데 사용할 수 있습니다. &lt;code&gt;1.d0&lt;/code&gt; 과 같은 실제 상수의 종류는 다음과 같이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e9f192b79a14968d26f70ab1aa8e21b65e3df64" translate="yes" xml:space="preserve">
          <source>carriage return</source>
          <target state="translated">캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="80b50fe0872299d1f4bb06454839f9fee15d937e" translate="yes" xml:space="preserve">
          <source>compile flag. If you have a choice, you should instead use Fortran 90&amp;rsquo;s &amp;ldquo;derived types&amp;rdquo;, which have a different syntax.</source>
          <target state="translated">컴파일 플래그. 당신이 선택할 수 있다면, 대신에 다른 구문을 가진 Fortran 90의&amp;ldquo;유도 된 유형&amp;rdquo;을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="11e041a9bab9c284eb7a06bcf02197a4245d640d" translate="yes" xml:space="preserve">
          <source>compile option was used.</source>
          <target state="translated">컴파일 옵션이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="725ff60a58db4873feed67e0e19b5f49ef4d936b" translate="yes" xml:space="preserve">
          <source>compile options.</source>
          <target state="translated">컴파일 옵션.</target>
        </trans-unit>
        <trans-unit id="6d5c9dab960e525ed112945029e61215d50dbc52" translate="yes" xml:space="preserve">
          <source>complement</source>
          <target state="translated">complement</target>
        </trans-unit>
        <trans-unit id="a145496a160f0c990a2ba77072b2813a8d1d3095" translate="yes" xml:space="preserve">
          <source>complement of exclusive or</source>
          <target state="translated">독점 또는</target>
        </trans-unit>
        <trans-unit id="94a0426e8d3203da5468ccf0c624f93cb37601e2" translate="yes" xml:space="preserve">
          <source>core</source>
          <target state="translated">core</target>
        </trans-unit>
        <trans-unit id="08702c35c20b1e6b02956f50b2b6be9b1f59559b" translate="yes" xml:space="preserve">
          <source>dD</source>
          <target state="translated">dD</target>
        </trans-unit>
        <trans-unit id="09f4b2adfa8ab11737d7e6446fe87db9cdad1ed9" translate="yes" xml:space="preserve">
          <source>default integer rank-1 array of a size equal to the corank of &lt;var&gt;COARRAY&lt;/var&gt;.</source>
          <target state="translated">COARRAY의 &lt;var&gt;COARRAY&lt;/var&gt; 동일한 크기의 기본 정수 rank-1 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="8910a4fc750141e3933a3e7d21cbc111c5a9aa05" translate="yes" xml:space="preserve">
          <source>default integer scalar (optional). If present, &lt;var&gt;DIM&lt;/var&gt; shall be between one and the corank of &lt;var&gt;COARRAY&lt;/var&gt;.</source>
          <target state="translated">기본 정수 스칼라 (선택 사항). 존재하는 경우, &lt;var&gt;DIM&lt;/var&gt; 은 COARRAY의 하나와 코크 랭크 사이에 &lt;var&gt;COARRAY&lt;/var&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5610fa253c9ebb20d865092429beef7dcace7f0b" translate="yes" xml:space="preserve">
          <source>define the corresponding C prototype as follows:</source>
          <target state="translated">다음과 같이 해당 C 프로토 타입을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="0fcd775c9c66c394d7cc47116dfc0df06082e8f9" translate="yes" xml:space="preserve">
          <source>denormal</source>
          <target state="translated">denormal</target>
        </trans-unit>
        <trans-unit id="384cccd1da3089fa8cc9d67e9123633665ca5e87" translate="yes" xml:space="preserve">
          <source>disables both types of extensions, and</source>
          <target state="translated">두 가지 유형의 확장을 모두 사용 중지하고</target>
        </trans-unit>
        <trans-unit id="b7aa8f1c66cb1264d85616aec76821fc3ff00e0b" translate="yes" xml:space="preserve">
          <source>disables it if it was activated by a previous specification.</source>
          <target state="translated">이전 사양으로 활성화 된 경우 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="309ebc44023886ea3f59fbc3403a90cbc6a0c62f" translate="yes" xml:space="preserve">
          <source>does not affect it.</source>
          <target state="translated">영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d3e15e2be429ba7d9009b3b7776254e4b47a296" translate="yes" xml:space="preserve">
          <source>does not print the negative sign of zero values (or values rounded to zero for I/O) and regards zero as positive number in the &lt;code&gt;SIGN&lt;/code&gt; intrinsic for compatibility with Fortran 77. The default is</source>
          <target state="translated">0 값의 음수 부호 (또는 I / O의 경우 0으로 반올림 된 값)를 인쇄하지 않으며 Fortran 77과의 호환성을 위해 본질적으로 &lt;code&gt;SIGN&lt;/code&gt; 에서 0을 양수로 간주합니다 . 기본값은</target>
        </trans-unit>
        <trans-unit id="66e88d0cc4f406250069737b8bc68e800a009817" translate="yes" xml:space="preserve">
          <source>during the linking step.</source>
          <target state="translated">연결 단계 중에.</target>
        </trans-unit>
        <trans-unit id="016da978ce5f23a177543b5e3d96bbc5b9004fcb" translate="yes" xml:space="preserve">
          <source>elimination of identical function calls within expressions,</source>
          <target state="translated">표현식 내에서 동일한 함수 호출 제거,</target>
        </trans-unit>
        <trans-unit id="61c4d33bfa297438229056e5bc5fd2d834fdc945" translate="yes" xml:space="preserve">
          <source>enables additional compatibility extensions along with those enabled by</source>
          <target state="translated">추가 호환성 확장 기능과</target>
        </trans-unit>
        <trans-unit id="30e425d1c4938905cafa6a9ccc95d9145b90381d" translate="yes" xml:space="preserve">
          <source>enables the &lt;a href=&quot;cotan#COTAN&quot;&gt;COTAN&lt;/a&gt; intrinsic, and trigonometric intrinsics which accept or produce values in degrees instead of radians. Here is a summary of the new intrinsics:</source>
          <target state="translated">라디안 대신 각도로 값을 수락하거나 생성 하는 &lt;a href=&quot;cotan#COTAN&quot;&gt;COTAN&lt;/a&gt; 내장 및 삼각 내장 함수를 활성화합니다 . 다음은 새로운 내장 함수의 요약입니다.</target>
        </trans-unit>
        <trans-unit id="cd86d7d19b20b55735eac175826a31a3ec2f4e06" translate="yes" xml:space="preserve">
          <source>except in two respects: it does not include the predefined macros, and it outputs both the &lt;code&gt;#define&lt;/code&gt; directives and the result of preprocessing. Both kinds of output go to the standard output file.</source>
          <target state="translated">사전 정의 된 매크로를 포함하지 않으며 &lt;code&gt;#define&lt;/code&gt; 지시문과 사전 처리 결과를 모두 출력합니다 . 두 종류의 출력 모두 표준 출력 파일로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e70fcdf9170ecc89eefcbc7fa642a563ae39722e" translate="yes" xml:space="preserve">
          <source>except that only macros that are expanded, or whose definedness is tested in preprocessor directives, are output; the output is delayed until the use or test of the macro; and &lt;code&gt;'#undef'&lt;/code&gt; directives are also output for macros tested but undefined at the time.</source>
          <target state="translated">전 처리기 지시문에서 확장되거나 정의가 테스트 된 매크로 만 출력됩니다. 매크로를 사용하거나 테스트 할 때까지 출력이 지연됩니다. 그리고 &lt;code&gt;'#undef'&lt;/code&gt; 지시문은 테스트되었지만 매크로는 당시에 정의되지 않은 매크로에 대해서도 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="2935217b8f0d832c64304c27e48cf1504494e46e" translate="yes" xml:space="preserve">
          <source>exclusive or</source>
          <target state="translated">독점 또는</target>
        </trans-unit>
        <trans-unit id="7532ab0484812d9733fa29e0282123a8e828146f" translate="yes" xml:space="preserve">
          <source>extension are also run through preprocessing.</source>
          <target state="translated">확장은 전처리를 통해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe3532a6dc9049685bd1aa545e3adedf8f01067" translate="yes" xml:space="preserve">
          <source>extensions are treated as fixed form. Source files with</source>
          <target state="translated">확장은 고정 형식으로 처리됩니다. 소스 파일</target>
        </trans-unit>
        <trans-unit id="1221fc936dfb7f80572f110e231a5f4fdcbabb06" translate="yes" xml:space="preserve">
          <source>extensions are treated as free form. The capitalized versions of either form are run through preprocessing. Source files with the lower case</source>
          <target state="translated">확장은 자유 형식으로 취급됩니다. 두 형식의 대문자 버전은 사전 처리를 통해 실행됩니다. 소문자가있는 소스 파일</target>
        </trans-unit>
        <trans-unit id="3b6dbce3c28e8958016b1367d18e1b647fc90c18" translate="yes" xml:space="preserve">
          <source>extensions as Fortran source code, and compile it accordingly. A &lt;code&gt;gfortran&lt;/code&gt; driver program is also provided, which is identical to &lt;code&gt;gcc&lt;/code&gt; except that it automatically links the Fortran runtime libraries into the compiled program.</source>
          <target state="translated">Fortran 소스 코드로 확장하고 적절하게 컴파일하십시오. &lt;code&gt;gfortran&lt;/code&gt; 드라이버 프로그램은 동일있는 구비 &lt;code&gt;gcc&lt;/code&gt; 를 자동으로 컴파일 된 프로그램에 포트란 런타임 라이브러리를 연결하는 것을 제외.</target>
        </trans-unit>
        <trans-unit id="f860431e8f0c3d87c15448f01b23bae1fd07eeae" translate="yes" xml:space="preserve">
          <source>f2003</source>
          <target state="translated">f2003</target>
        </trans-unit>
        <trans-unit id="7c5cdf6f9cb2427be7c07c63dfe25e61f4f80ae7" translate="yes" xml:space="preserve">
          <source>f2008</source>
          <target state="translated">f2008</target>
        </trans-unit>
        <trans-unit id="4a7d0cf549ae5bbfe745d9d0aa6b41e4b556a3d7" translate="yes" xml:space="preserve">
          <source>f2018</source>
          <target state="translated">f2018</target>
        </trans-unit>
        <trans-unit id="26275c768e377b0d50c55c5828e7fd8bf70c44ca" translate="yes" xml:space="preserve">
          <source>f77, gnu</source>
          <target state="translated">f77, 누</target>
        </trans-unit>
        <trans-unit id="a5576455cb5f0024ec37f8307e138df17eecc413" translate="yes" xml:space="preserve">
          <source>f95</source>
          <target state="translated">f95</target>
        </trans-unit>
        <trans-unit id="42c37e11cecc411fd563a9b8bd87322962f195a3" translate="yes" xml:space="preserve">
          <source>f95, gnu</source>
          <target state="translated">f95, 누</target>
        </trans-unit>
        <trans-unit id="a4d41b154a214defec5ed9b013895d21989d8cf2" translate="yes" xml:space="preserve">
          <source>files and other such things.</source>
          <target state="translated">파일과 다른 것들.</target>
        </trans-unit>
        <trans-unit id="e677ffdbb391e44728ea8e698e026741ec3283c1" translate="yes" xml:space="preserve">
          <source>files for compiled modules. It is also added to the list of directories to searched by an &lt;code&gt;USE&lt;/code&gt; statement.</source>
          <target state="translated">컴파일 된 모듈 용 파일. 또한 &lt;code&gt;USE&lt;/code&gt; 문 으로 검색 할 디렉토리 목록에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="80090814aeb95110019f1c0b128d2837019fefb0" translate="yes" xml:space="preserve">
          <source>files when previously compiled modules are required by a &lt;code&gt;USE&lt;/code&gt; statement.</source>
          <target state="translated">이전에 컴파일 된 모듈이 &lt;code&gt;USE&lt;/code&gt; 문에 필요한 경우 파일</target>
        </trans-unit>
        <trans-unit id="c8091331f7fa59c4253e1f30ce7b111c70e8ce6d" translate="yes" xml:space="preserve">
          <source>flag and experimental support for multiple images with the</source>
          <target state="translated">여러 이미지에 대한 플래그 및 실험적 지원</target>
        </trans-unit>
        <trans-unit id="a77d55c00e1bb084c2e9eb99f2d962433de325e7" translate="yes" xml:space="preserve">
          <source>flag is present in the command line, this option has no effect, since no &lt;code&gt;#line&lt;/code&gt; directives are emitted whatsoever.</source>
          <target state="translated">플래그는 명령 행에 존재하며, &lt;code&gt;#line&lt;/code&gt; 지시문이 전혀 생성 되지 않으므로이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="834427f82fddf40fa83fb85bab98bdc1e308071c" translate="yes" xml:space="preserve">
          <source>flag will be treated as described above with</source>
          <target state="translated">플래그는 위에서 설명한대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="964992a57d111bb0865d708e942f8599f79c480d" translate="yes" xml:space="preserve">
          <source>flag.</source>
          <target state="translated">flag.</target>
        </trans-unit>
        <trans-unit id="d6032db772960f71d51d4e8867565ae351e5755c" translate="yes" xml:space="preserve">
          <source>foo.f90</source>
          <target state="translated">foo.f90</target>
        </trans-unit>
        <trans-unit id="0fe82926165e5182b9b802441f71648ba07fbc6c" translate="yes" xml:space="preserve">
          <source>for a description of the exceptions.)</source>
          <target state="translated">예외에 대한 설명은.)</target>
        </trans-unit>
        <trans-unit id="686fada21819d2c685a6f60218198bc8a61e59f2" translate="yes" xml:space="preserve">
          <source>for compatability with legacy code. These intrinsics are described fully in &lt;a href=&quot;intrinsic-procedures#Intrinsic-Procedures&quot;&gt;Intrinsic Procedures&lt;/a&gt; where it is noted that they are extensions and should be avoided whenever possible.</source>
          <target state="translated">레거시 코드와의 호환성. 이러한 내장 기능은 &lt;a href=&quot;intrinsic-procedures#Intrinsic-Procedures&quot;&gt;내장 프로 시저에&lt;/a&gt; 자세히 설명되어 있으며 확장 기능이므로 가능할 때마다 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b65456fcee33f621726a32682c9f5a43fcf563c" translate="yes" xml:space="preserve">
          <source>for performing loop interchanges.</source>
          <target state="translated">루프 교환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c5b3ddef2954620839314bb4513103ce8cff3be3" translate="yes" xml:space="preserve">
          <source>for that.</source>
          <target state="translated">그에 대한.</target>
        </trans-unit>
        <trans-unit id="c0389b13c0c0bc3d4c76f0cdcfbaf94048d4f9f2" translate="yes" xml:space="preserve">
          <source>for the affected local variables.</source>
          <target state="translated">영향을받는 지역 변수</target>
        </trans-unit>
        <trans-unit id="cacfbd40505fff5a97d7effce15468bbc881b94d" translate="yes" xml:space="preserve">
          <source>form feed</source>
          <target state="translated">사료 공급</target>
        </trans-unit>
        <trans-unit id="336da558f64105368889cd9dc8c1bedbc9b157d2" translate="yes" xml:space="preserve">
          <source>gnu</source>
          <target state="translated">gnu</target>
        </trans-unit>
        <trans-unit id="14734451d7bae207d688228f94079ef3922bc4f5" translate="yes" xml:space="preserve">
          <source>header.gcc</source>
          <target state="translated">header.gcc</target>
        </trans-unit>
        <trans-unit id="840335b8f41f2168b82077c6520c948eb5434936" translate="yes" xml:space="preserve">
          <source>horizontal tab</source>
          <target state="translated">가로 탭</target>
        </trans-unit>
        <trans-unit id="99a98a2beae0cd812850d3aafc1f5072a3698eb9" translate="yes" xml:space="preserve">
          <source>i386 and x86_64 processors</source>
          <target state="translated">i386 및 x86_64 프로세서</target>
        </trans-unit>
        <trans-unit id="c38e1a7be464ab7163038c4c36228ad752b9e97b" translate="yes" xml:space="preserve">
          <source>if &lt;var&gt;TARGET&lt;/var&gt; is associated with &lt;var&gt;POINTER&lt;/var&gt;, the target associated with &lt;var&gt;TARGET&lt;/var&gt; are not zero-sized storage sequences and occupy the same storage units. The result is false, if either &lt;var&gt;TARGET&lt;/var&gt; or &lt;var&gt;POINTER&lt;/var&gt; is disassociated.</source>
          <target state="translated">만약 &lt;var&gt;TARGET&lt;/var&gt; 과 연관된 &lt;var&gt;POINTER&lt;/var&gt; 와 연관된 타겟 &lt;var&gt;TARGET&lt;/var&gt; 은 크기가 0 인 시퀀스 저장되지 않고 동일한 저장 유닛을 점유한다. &lt;var&gt;TARGET&lt;/var&gt; 또는 &lt;var&gt;POINTER&lt;/var&gt; 가 연결 해제 된 경우 결과는 false 입니다.</target>
        </trans-unit>
        <trans-unit id="6c9b2714a61483876d23ff7c8a64d7bd23a0e3a4" translate="yes" xml:space="preserve">
          <source>if also</source>
          <target state="translated">만약에</target>
        </trans-unit>
        <trans-unit id="470cec587602b47395a317eb72d14272f9628412" translate="yes" xml:space="preserve">
          <source>implies</source>
          <target state="translated">implies</target>
        </trans-unit>
        <trans-unit id="9c5bf8d9bc8e210238a8fe2e5d72c0d3cd933402" translate="yes" xml:space="preserve">
          <source>in effect, GNU Fortran appends one underscore to external names with no underscores. This is done to ensure compatibility with code produced by many UNIX Fortran compilers.</source>
          <target state="translated">사실상 GNU Fortran은 밑줄없이 외부 이름에 하나의 밑줄을 추가합니다. 이것은 많은 UNIX Fortran 컴파일러가 생성 한 코드와의 호환성을 보장하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="199b8c6b0e05b2ae2850d87fb479d7514ae3a298" translate="yes" xml:space="preserve">
          <source>inexact</source>
          <target state="translated">inexact</target>
        </trans-unit>
        <trans-unit id="3975926a2eab8c1f39a81423a9191838bedd5ce0" translate="yes" xml:space="preserve">
          <source>inlining calls to &lt;code&gt;MATMUL&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;MATMUL&lt;/code&gt; 에 대한 인라인 호출 ,</target>
        </trans-unit>
        <trans-unit id="f288a9885275d88fa51cca7f94d4afe580da627d" translate="yes" xml:space="preserve">
          <source>intent(in) An array with the images provided by the user. If &lt;var&gt;count&lt;/var&gt; is zero, a NULL pointer is passed.</source>
          <target state="translated">intent (in) 사용자가 제공 한 이미지가있는 배열입니다. 경우 &lt;var&gt;count&lt;/var&gt; 제로, NULL 포인터가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0d64470f06caa30284d32cc6160676923b4aef37" translate="yes" xml:space="preserve">
          <source>intent(in) An opaque pointer identifying the coarray.</source>
          <target state="translated">intent (in) 굵은 선을 식별하는 불투명 포인터.</target>
        </trans-unit>
        <trans-unit id="76d06192264773444e86ae90f3b2d4858da682a7" translate="yes" xml:space="preserve">
          <source>intent(in) An opaque pointer identifying the destination coarray.</source>
          <target state="translated">intent (in) 대상 coarray를 식별하는 불투명 포인터.</target>
        </trans-unit>
        <trans-unit id="5a519cdcdc1f69485de1ce896d1cbabdc62b2317" translate="yes" xml:space="preserve">
          <source>intent(in) An opaque pointer identifying the source coarray.</source>
          <target state="translated">intent (in) 소스 coarray를 식별하는 불투명 포인터.</target>
        </trans-unit>
        <trans-unit id="0d89f0a22dc211bfe990fa5c7112a73605f1d37e" translate="yes" xml:space="preserve">
          <source>intent(in) Array descriptor for the destination remote image for the bounds and the size. The &lt;code&gt;base_addr&lt;/code&gt; shall not be accessed.</source>
          <target state="translated">intent (in) 경계 및 크기의 대상 원격 이미지에 대한 배열 설명자입니다. &lt;code&gt;base_addr&lt;/code&gt; 에는 접근 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="d8e381ccf9b08b8bb80b79ca9d9afc63960bc670" translate="yes" xml:space="preserve">
          <source>intent(in) Array descriptor for the remote image for the bounds and the size. The &lt;code&gt;base_addr&lt;/code&gt; shall not be accessed.</source>
          <target state="translated">intent (in) 경계 및 크기에 대한 원격 이미지의 배열 설명자입니다. &lt;code&gt;base_addr&lt;/code&gt; 에는 접근 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="21b36193b1986e46831d2d36d9f55427bd188643" translate="yes" xml:space="preserve">
          <source>intent(in) Array descriptor of the local array to be transferred to the remote image</source>
          <target state="translated">intent (in) 원격 이미지로 전송 될 로컬 배열의 배열 설명자</target>
        </trans-unit>
        <trans-unit id="94d835761d04046e12ac086173de735e16582194" translate="yes" xml:space="preserve">
          <source>intent(in) Array descriptor of the local array to be transferred to the remote image.</source>
          <target state="translated">intent (in) 원격 이미지로 전송할 로컬 배열의 배열 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="0b137a9a57ef4f28ad011e2688d0324f73eaeef5" translate="yes" xml:space="preserve">
          <source>intent(in) Array descriptor of the local array to store the data transferred from the remote image. May be reallocated where needed and when &lt;var&gt;DST_REALLOCATABLE&lt;/var&gt; allows it.</source>
          <target state="translated">intent (in) 원격 이미지에서 전송 된 데이터를 저장하는 로컬 배열의 배열 설명자입니다. 필요한 곳과 &lt;var&gt;DST_REALLOCATABLE&lt;/var&gt; 이 허용하는 경우 재 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="715d21a9ec79deea7ff428d1e569238505e5ccf2" translate="yes" xml:space="preserve">
          <source>intent(in) Array index; first array index is 0. For scalars, it is always 0.</source>
          <target state="translated">의도 (in) 배열 인덱스; 첫 번째 배열 인덱스는 0입니다. 스칼라의 경우 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="ff507e34c8a45057567cc7f417a397b02a1068fd" translate="yes" xml:space="preserve">
          <source>intent(in) By which amount of bytes the actual data is shifted compared to the base address of the coarray.</source>
          <target state="translated">intent (in) 실제 데이터가 코어 레이의 기본 주소와 비교되는 바이트 양으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5827bcb1977aba2b510ad01fde06be16a4301a86" translate="yes" xml:space="preserve">
          <source>intent(in) By which amount of bytes the actual data is shifted compared to the base address of the destination coarray.</source>
          <target state="translated">intent (in) 실제 데이터가 대상 coarray의 기본 주소와 비교되는 바이트 양으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="36fd39d0a6f6c42be47d9de7d1437673d7949fbb" translate="yes" xml:space="preserve">
          <source>intent(in) By which amount of bytes the actual data is shifted compared to the base address of the source coarray.</source>
          <target state="translated">intent (in) 실제 데이터가 소스 coarray의 기본 주소와 비교되는 바이트 양으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="4da886a16175f0a7b81dfb6c2e0c47f35e40e618" translate="yes" xml:space="preserve">
          <source>intent(in) Flags regarding the reduction function</source>
          <target state="translated">intent (in) 감소 함수에 관한 플래그</target>
        </trans-unit>
        <trans-unit id="a6190352aaf55ad6622c0af3d93413a4480ed70c" translate="yes" xml:space="preserve">
          <source>intent(in) Function pointer to the reduction function</source>
          <target state="translated">intent (in) 감소 함수를 가리키는 함수 포인터</target>
        </trans-unit>
        <trans-unit id="a02d70d8f2943db449fcc8123140cb5fb7336dc3" translate="yes" xml:space="preserve">
          <source>intent(in) Give the type of the destination. When the destination is not an array, than the precise type, e.g. of a component in a derived type, is not known, but provided here.</source>
          <target state="translated">intent (in) 목적지의 유형을 제공합니다. 대상이 배열이 아닌 경우 정확한 유형 (예 : 파생 유형의 구성 요소)은 알 수 없지만 여기에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="94b8b32e6aad49601b5ba54e2c449fa6566b2f8b" translate="yes" xml:space="preserve">
          <source>intent(in) Give the type of the source. When the source is not an array, than the precise type, e.g. of a component in a derived type, is not known, but provided here.</source>
          <target state="translated">intent (in) 소스의 유형을 제공합니다. 소스가 배열이 아닌 경우 정확한 유형 (예 : 파생 유형의 구성 요소)보다 정확한 유형은 알 수 없지만 여기에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="099a17fba874ac35f6d7cf534e76942244c794bf" translate="yes" xml:space="preserve">
          <source>intent(in) If not NULL, it contains the vector subscript of the destination array; the values are relative to the dimension triplet of the dest argument.</source>
          <target state="translated">intent (in) NULL이 아닌 경우 대상 배열의 벡터 첨자를 포함합니다. 값은 대상 인수의 차원 삼중 항을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="ef8b16d7a048c23ba0824f7f2f4bfb6363160aae" translate="yes" xml:space="preserve">
          <source>intent(in) If not NULL, it contains the vector subscript of the source array; the values are relative to the dimension triplet of the &lt;var&gt;src&lt;/var&gt; argument.</source>
          <target state="translated">intent (in) NULL이 아닌 경우 소스 배열의 벡터 첨자를 포함합니다. 값은 &lt;var&gt;src&lt;/var&gt; 인수 의 차원 삼중 항을 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="6a0bfaf3a867d4013c44ac4e4703e60f31f2ee27" translate="yes" xml:space="preserve">
          <source>intent(in) Kind of the destination argument</source>
          <target state="translated">의도 (in) 목적지 인수의 종류</target>
        </trans-unit>
        <trans-unit id="be96b2d6d8760aa7f00af41e9cc13426e60ba4d2" translate="yes" xml:space="preserve">
          <source>intent(in) Kind of the source argument</source>
          <target state="translated">의도 (in) 소스 인수의 종류</target>
        </trans-unit>
        <trans-unit id="ac127585157acceadcf25227de2729aeb1d0024d" translate="yes" xml:space="preserve">
          <source>intent(in) Set when &lt;var&gt;DST&lt;/var&gt; is of allocatable or pointer type and its refs allow reallocation, i.e., the full array or a component is referenced.</source>
          <target state="translated">intent (in) &lt;var&gt;DST&lt;/var&gt; 가 할당 가능하거나 포인터 유형이고 참조가 재 할당을 허용하는 경우 설정됩니다 . 즉, 전체 배열 또는 구성 요소가 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="9f64b05bd8e771d00afab090b88b25239dc8c88e" translate="yes" xml:space="preserve">
          <source>intent(in) Set when the destination is of allocatable or pointer type and the refs will allow reallocation, i.e., the ref is a full array or component ref.</source>
          <target state="translated">intent (in) 대상이 할당 가능하거나 포인터 유형이고 참조가 재 할당을 허용 할 때 설정됩니다. 즉, 참조가 전체 배열 또는 구성 요소 참조입니다.</target>
        </trans-unit>
        <trans-unit id="707edae82ce5d7667a384fa041f087c32e6e0207" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the destination remote image; must be a positive number.</source>
          <target state="translated">intent (in) 대상 원격 이미지의 ID입니다. 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d13067c812dd2136e27be3b4e43b1002f75687ec" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the image from which the data should be broadcasted.</source>
          <target state="translated">intent (in) 데이터가 브로드 캐스트되어야하는 이미지의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="fe3c7bbfa06c3e100efc7391462de42ea1ca1928" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the image to which the reduced value should be copied to; if zero, it has to be copied to all images.</source>
          <target state="translated">intent (in) 감소 된 값을 복사 할 이미지의 ID입니다. 0이면 모든 이미지에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="614aa95da334df7441884dcfef7b16977cd669e6" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the remote image; must be a positive number.</source>
          <target state="translated">intent (in) 원격 이미지의 ID. 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="593f98f053fd1048d7e959bd12fb2a4533078aee" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the remote image; must be a positive number; zero indicates the current image when accessed noncoindexed.</source>
          <target state="translated">intent (in) 원격 이미지의 ID. 양수 여야합니다. 0은 색인화되지 않은 상태로 액세스 할 때 현재 이미지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2746bd8754c2c29907d7c1474f9bdd0c919b1479" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the remote image; must be a positive number; zero indicates the current image when used noncoindexed.</source>
          <target state="translated">intent (in) 원격 이미지의 ID. 양수 여야합니다. 0은 색인화되지 않은 상태로 사용될 때 현재 이미지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bee143538f01659107759ee190edb66748b742d9" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the remote image; must be a positive number; zero indicates the current image, when accessed noncoindexed.</source>
          <target state="translated">intent (in) 원격 이미지의 ID. 양수 여야합니다. 0은 색인화되지 않은 상태로 액세스 할 때 현재 이미지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="19cc660c7fa6722f307efcfd657f55037a63a836" translate="yes" xml:space="preserve">
          <source>intent(in) The ID of the source remote image; must be a positive number.</source>
          <target state="translated">intent (in) 소스 원격 이미지의 ID입니다. 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8cab2a8aaf16a06b15938951d4164a5698cf708c" translate="yes" xml:space="preserve">
          <source>intent(in) The data type, i.e. &lt;code&gt;BT_INTEGER&lt;/code&gt; (1) or &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2).</source>
          <target state="translated">intent (in) 데이터 유형, 즉 &lt;code&gt;BT_INTEGER&lt;/code&gt; (1) 또는 &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2).</target>
        </trans-unit>
        <trans-unit id="26d46f5d8fc76e851c39a2ab69e77b469f89fecf" translate="yes" xml:space="preserve">
          <source>intent(in) The exit status to be used.</source>
          <target state="translated">intent (in) 사용될 종료 상태.</target>
        </trans-unit>
        <trans-unit id="81be2bf3ece9e0451e872d67bae1b61ea82f5c85" translate="yes" xml:space="preserve">
          <source>intent(in) The kind value (only 4; always &lt;code&gt;int&lt;/code&gt;)</source>
          <target state="translated">intent (in) 종류 값 (단 4; 항상 &lt;code&gt;int&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8e67d808ca7c4c1adf44b87b05fec3ee5dce6fda" translate="yes" xml:space="preserve">
          <source>intent(in) The new value for the atomic variable, assigned to the atomic variable, if &lt;code&gt;compare&lt;/code&gt; equals the value of the atomic variable.</source>
          <target state="translated">intent (in) &lt;code&gt;compare&lt;/code&gt; 가 원자 변수의 값 과 같은 경우 원자 변수에 할당 된 원자 변수의 새 값입니다 .</target>
        </trans-unit>
        <trans-unit id="632f1c1dd95212054e5a6a41d7d28e207ea8e344" translate="yes" xml:space="preserve">
          <source>intent(in) The number of events which have to be available before the function returns.</source>
          <target state="translated">intent (in) 함수가 반환되기 전에 사용할 수있는 이벤트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a0dda66dcc75e30df5dfb47d443b5ee4eccd3de8" translate="yes" xml:space="preserve">
          <source>intent(in) The number of images which are provided in the next argument. For a zero-sized array, the value is zero. For &lt;code&gt;sync images (*)&lt;/code&gt;, the value is &lt;em&gt;-1&lt;/em&gt;.</source>
          <target state="translated">intent (in) 다음 인수에서 제공되는 이미지 수입니다. 크기가 0 인 배열의 경우 값은 0입니다. 들면 &lt;code&gt;sync images (*)&lt;/code&gt; 의 값은 &lt;em&gt;-1&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b95cccac8dff5eeb8d8d037c1032117c395be679" translate="yes" xml:space="preserve">
          <source>intent(in) The references on the remote array to store the data given by src. Guaranteed to have at least one entry.</source>
          <target state="translated">intent (in) src에 의해 주어진 데이터를 저장하기위한 원격 배열의 참조. 최소한 하나의 항목이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6c623d7793e522d3f1bd14e50d5a27ec6a4aafb7" translate="yes" xml:space="preserve">
          <source>intent(in) The references on the remote array to store the data given by the source. Guaranteed to have at least one entry.</source>
          <target state="translated">intent (in) 소스가 제공 한 데이터를 저장하기위한 원격 배열의 참조입니다. 최소한 하나의 항목이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e344f1531d4a9859696eb12549ffe2d312c23227" translate="yes" xml:space="preserve">
          <source>intent(in) The references to apply to the remote structure to get the data.</source>
          <target state="translated">intent (in) 데이터를 얻기 위해 원격 구조에 적용 할 참조입니다.</target>
        </trans-unit>
        <trans-unit id="364809cebf2b546a1a2419774fc89aab03edbd59" translate="yes" xml:space="preserve">
          <source>intent(in) The value used for comparision.</source>
          <target state="translated">intent (in) 비교에 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="f8a5ce8e22eeec22028c3a25534b9f0a8f00bfe9" translate="yes" xml:space="preserve">
          <source>intent(in) The variable is &lt;code&gt;false&lt;/code&gt; when it is known at compile time that the &lt;var&gt;dest&lt;/var&gt; and &lt;var&gt;src&lt;/var&gt; either cannot overlap or overlap (fully or partially) such that walking &lt;var&gt;src&lt;/var&gt; and &lt;var&gt;dest&lt;/var&gt; in element wise element order (honoring the stride value) will not lead to wrong results. Otherwise, the value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">intent (in) 변수는 컴파일 타임에 &lt;var&gt;dest&lt;/var&gt; 와 &lt;var&gt;src&lt;/var&gt; 가 겹치거나 겹칠 수 없거나 (전부 또는 부분적으로) 요소 별 요소 순서 (보폭 값을 존중하는)에서 &lt;var&gt;src&lt;/var&gt; 와 &lt;var&gt;dest&lt;/var&gt; 를 걸어 갈 수없는 것으로 알려진 경우 &lt;code&gt;false&lt;/code&gt; 입니다. 잘못된 결과. 그렇지 않으면 값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="14696eb7013c871f6ac8b0e40360e0aba7f91b96" translate="yes" xml:space="preserve">
          <source>intent(in) the buffer size of errmsg</source>
          <target state="translated">errmsg의 버퍼 크기 의도 (intent (in))</target>
        </trans-unit>
        <trans-unit id="487364230ad74ee8ff94a2c56002bbba442e162f" translate="yes" xml:space="preserve">
          <source>intent(in) the buffer size of errmsg.</source>
          <target state="translated">errmsg의 버퍼 크기를 의도합니다 (in).</target>
        </trans-unit>
        <trans-unit id="6930506ddb242563b5df2d1b100d308c41f04c72" translate="yes" xml:space="preserve">
          <source>intent(in) the data type, i.e. &lt;code&gt;BT_INTEGER&lt;/code&gt; (1) or &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2)</source>
          <target state="translated">데이터 유형의 의도, 즉 &lt;code&gt;BT_INTEGER&lt;/code&gt; (1) 또는 &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2)</target>
        </trans-unit>
        <trans-unit id="267e2cfef03902802c5bb271f9a6a5b9eaef7486" translate="yes" xml:space="preserve">
          <source>intent(in) the data type, i.e. &lt;code&gt;BT_INTEGER&lt;/code&gt; (1) or &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2).</source>
          <target state="translated">&lt;code&gt;BT_INTEGER&lt;/code&gt; (1) 또는 &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2) 와 같은 데이터 유형을 의도 합니다.</target>
        </trans-unit>
        <trans-unit id="b45b63c027a940467363f23d448c2e80775628ef" translate="yes" xml:space="preserve">
          <source>intent(in) the error message (not zero terminated)</source>
          <target state="translated">오류 메시지의 의도 (in) (0으로 끝나지 않음)</target>
        </trans-unit>
        <trans-unit id="e941f7b7ab614dced2a98601335bc887a0fb90e2" translate="yes" xml:space="preserve">
          <source>intent(in) the kind value (only 4; always &lt;code&gt;int&lt;/code&gt;)</source>
          <target state="translated">종류 값의 의도 (in) (단 4; 항상 &lt;code&gt;int&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="161b92ce03cf05a924e603651ee8720b17f85c90" translate="yes" xml:space="preserve">
          <source>intent(in) the length of the string</source>
          <target state="translated">문자열 길이 의도 (in)</target>
        </trans-unit>
        <trans-unit id="801a43379f5383a484c1d7fcd49339ffa7c177e1" translate="yes" xml:space="preserve">
          <source>intent(in) the operation to be performed; possible values &lt;code&gt;GFC_CAF_ATOMIC_ADD&lt;/code&gt; (1), &lt;code&gt;GFC_CAF_ATOMIC_AND&lt;/code&gt; (2), &lt;code&gt;GFC_CAF_ATOMIC_OR&lt;/code&gt; (3), &lt;code&gt;GFC_CAF_ATOMIC_XOR&lt;/code&gt; (4).</source>
          <target state="translated">수행 할 작업 의도 (in); 가능한 값 &lt;code&gt;GFC_CAF_ATOMIC_ADD&lt;/code&gt; (1), &lt;code&gt;GFC_CAF_ATOMIC_AND&lt;/code&gt; (2), &lt;code&gt;GFC_CAF_ATOMIC_OR&lt;/code&gt; (3), &lt;code&gt;GFC_CAF_ATOMIC_XOR&lt;/code&gt; (4).</target>
        </trans-unit>
        <trans-unit id="cbd4fc3531fc5aaece553a14856fb436b6cec67d" translate="yes" xml:space="preserve">
          <source>intent(in) the string length of argument &lt;var&gt;a&lt;/var&gt;</source>
          <target state="translated">인수 &lt;var&gt;a&lt;/var&gt; 의 문자열 길이 의도 (in)</target>
        </trans-unit>
        <trans-unit id="55829fdaad223f02bc1b593a6c576e3a98d38032" translate="yes" xml:space="preserve">
          <source>intent(in) the value to be assigned, passed by reference</source>
          <target state="translated">할당 할 값을 intent (in), 참조로 전달</target>
        </trans-unit>
        <trans-unit id="ca2950f4e0981e66b5092046e61ae50fe611a127" translate="yes" xml:space="preserve">
          <source>intent(inout) A pointer to an array of strings with the command-line arguments or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">intent (inout) 명령 줄 인수가있는 문자열 배열에 대한 포인터 또는 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bc4fc492c137a2aac25ed0170b410c18ef467370" translate="yes" xml:space="preserve">
          <source>intent(inout) An array descriptor for the data to be processed. On the destination image(s) the result overwrites the old content.</source>
          <target state="translated">intent (inout) 처리 할 데이터의 배열 설명자입니다. 대상 이미지에서 결과가 이전 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="bf144a4f344e14f25a36df8b8073a68a514976c0" translate="yes" xml:space="preserve">
          <source>intent(inout) An array descriptor with the data to be broadcasted (on &lt;var&gt;source_image&lt;/var&gt;) or to be received (other images).</source>
          <target state="translated">intent (inout) 브로드 캐스트 ( &lt;var&gt;source_image&lt;/var&gt; ) 또는 수신 할 데이터 (기타 이미지)가 있는 배열 설명자입니다 .</target>
        </trans-unit>
        <trans-unit id="66d3c2612d7bc69005f1150de25d473ca9ae6cc5" translate="yes" xml:space="preserve">
          <source>intent(inout) An array descriptor with the data to be processed. On the destination image(s) the result overwrites the old content.</source>
          <target state="translated">intent (inout) 처리 할 데이터가있는 배열 설명자입니다. 대상 이미지에서 결과가 이전 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="15db2faef357bb642fdf7ad82237c3ab5f2aa45b" translate="yes" xml:space="preserve">
          <source>intent(inout) An integer pointer with the number of arguments passed to the program or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">intent (inout) 프로그램에 전달 된 인수 수를 가진 정수 포인터 또는 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17af252aee68c0a180ad426063d7fd6f33756878" translate="yes" xml:space="preserve">
          <source>intent(inout) The (pseudo) array descriptor.</source>
          <target state="translated">intent (inout) (의사) 배열 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="a9aea7e4d8827fc261f8a44e5dac43b414a0de40" translate="yes" xml:space="preserve">
          <source>intent(int) If not NULL, it contains the vector subscript of the destination array; the values are relative to the dimension triplet of the &lt;var&gt;dest&lt;/var&gt; argument.</source>
          <target state="translated">intent (int) NULL이 아닌 경우 대상 배열의 벡터 첨자를 포함합니다. 값은 &lt;var&gt;dest&lt;/var&gt; 인수 의 차원 삼중 항을 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="73693a50ec07021820249ec97ab3f4a3857520ad" translate="yes" xml:space="preserve">
          <source>intent(out) An opaque pointer identifying the coarray.</source>
          <target state="translated">intent (out) 굵은 선을 식별하는 불투명 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="e921c52080158ef4b2d7956cab258208bd2b5162" translate="yes" xml:space="preserve">
          <source>intent(out) Array descriptor of the local array to store the data retrieved from the remote image</source>
          <target state="translated">intent (out) 원격 이미지에서 검색된 데이터를 저장하기위한 로컬 배열의 배열 설명자</target>
        </trans-unit>
        <trans-unit id="f04319656bf0d2e6dd6f69e5a5ebb3a6473ed9a7" translate="yes" xml:space="preserve">
          <source>intent(out) For allocatable coarrays, stores the STAT=; may be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">intent (out) 할당 가능한 coarray의 경우 STAT =; &lt;code&gt;NULL&lt;/code&gt; 일 수 있음</target>
        </trans-unit>
        <trans-unit id="d65f0a6beb9d913a66c822d2c5d3190a6cf67b5e" translate="yes" xml:space="preserve">
          <source>intent(out) For allocatable coarrays, stores the STAT=; may be NULL</source>
          <target state="translated">intent (out) 할당 할 수있는 성긴 배열의 경우 STAT =; NULL 일 수있다</target>
        </trans-unit>
        <trans-unit id="d0037247da208404b3a842a5e9cfe758abeb866e" translate="yes" xml:space="preserve">
          <source>intent(out) For allocatable coarrays, stores the STAT=; may be NULL.</source>
          <target state="translated">intent (out) 할당 할 수있는 성긴 배열의 경우 STAT =; NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d74a331233b4f4e33077ab905a4a92be98a2b0" translate="yes" xml:space="preserve">
          <source>intent(out) If not NULL, it returns whether lock could be obtained.</source>
          <target state="translated">intent (out) NULL이 아니면 잠금을 얻을 수 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1003c2c632053ef5ecb8fcb61f066d500a185edb" translate="yes" xml:space="preserve">
          <source>intent(out) Stores the STAT=; may be NULL</source>
          <target state="translated">intent (out) STAT =를 저장합니다. NULL 일 수있다</target>
        </trans-unit>
        <trans-unit id="8b105c6684afeb53d9958a6bbbbc96e3a8e1d80e" translate="yes" xml:space="preserve">
          <source>intent(out) Stores the STAT=; may be NULL.</source>
          <target state="translated">intent (out) STAT =를 저장합니다. NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8c5e64d7a23388138d38004f467f462432d82d" translate="yes" xml:space="preserve">
          <source>intent(out) Stores the status STAT= and may be NULL.</source>
          <target state="translated">intent (out) 상태 STAT =를 저장하며 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22aa95cc1b4c96223ae30d6859771efc98ea6d55" translate="yes" xml:space="preserve">
          <source>intent(out) The number of events currently posted to the event variable.</source>
          <target state="translated">intent (out) 현재 이벤트 변수에 게시 된 이벤트 수입니다.</target>
        </trans-unit>
        <trans-unit id="50abafcc6e831cd3614d9d2457378295c9110a1e" translate="yes" xml:space="preserve">
          <source>intent(out) The value which the atomic variable had just before the atomic operation.</source>
          <target state="translated">intent (out) 원자 연산 직전에 원자 변수가 가진 값.</target>
        </trans-unit>
        <trans-unit id="df5b1fedaa41491bd8f2afed52ad873636b5ce93" translate="yes" xml:space="preserve">
          <source>intent(out) The value which the atomic variable had just before the cas operation.</source>
          <target state="translated">intent (out) 원자 변수가 cas 연산 직전에 가진 값.</target>
        </trans-unit>
        <trans-unit id="035558d623a032f3ec28a40dede97bfa7bec65d0" translate="yes" xml:space="preserve">
          <source>intent(out) The variable assigned the atomically referenced variable.</source>
          <target state="translated">intent (out) 원자 참조 변수가 할당 된 변수입니다.</target>
        </trans-unit>
        <trans-unit id="037f9e80fca605767df17477ee17f05ac728bff4" translate="yes" xml:space="preserve">
          <source>intent(out) When an error occurs, this will be set to an error message; may be &lt;code&gt;NULL&lt;/code&gt;</source>
          <target state="translated">intent (out) 오류가 발생하면 오류 메시지로 설정됩니다. &lt;code&gt;NULL&lt;/code&gt; 일 수 있음</target>
        </trans-unit>
        <trans-unit id="2225374520d16971d111cf41e4784e1901ae311d" translate="yes" xml:space="preserve">
          <source>intent(out) When an error occurs, this will be set to an error message; may be NULL</source>
          <target state="translated">intent (out) 오류가 발생하면 오류 메시지로 설정됩니다. NULL 일 수있다</target>
        </trans-unit>
        <trans-unit id="ce26b108a707115bd5f4aef03c042398dd221791" translate="yes" xml:space="preserve">
          <source>intent(out) When an error occurs, this will be set to an error message; may be NULL.</source>
          <target state="translated">intent (out) 오류가 발생하면 오류 메시지로 설정됩니다. NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dedba824d83bedf8875dc183379515a617109434" translate="yes" xml:space="preserve">
          <source>intent(out) When non-&lt;code&gt;NULL&lt;/code&gt; give the result of the get-operation, i.e., zero on success and non-zero on error. When &lt;code&gt;NULL&lt;/code&gt; and an error occurs, then an error message is printed and the program is terminated.</source>
          <target state="translated">intent (out) &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 get-operation의 결과 (예 : 성공시 0, 오류시 0이 아님)를 제공합니다. 경우 &lt;code&gt;NULL&lt;/code&gt; 에러가 발생하고 에러 메시지가 출력되고, 프로그램은 종료된다.</target>
        </trans-unit>
        <trans-unit id="f86c202555db33039a8ef7c3450ea3126f57bf3b" translate="yes" xml:space="preserve">
          <source>intent(out) When non-&lt;code&gt;NULL&lt;/code&gt; give the result of the operation, i.e., zero on success and non-zero on error. When &lt;code&gt;NULL&lt;/code&gt; and an error occurs, then an error message is printed and the program is terminated.</source>
          <target state="translated">intent (out) &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 작업 결과를 제공합니다 (예 : 성공시 0, 오류시 0이 아님). 경우 &lt;code&gt;NULL&lt;/code&gt; 에러가 발생하고 에러 메시지가 출력되고, 프로그램은 종료된다.</target>
        </trans-unit>
        <trans-unit id="bbc5b3e98e236b00632ca29ed3051aaf8a6c9b55" translate="yes" xml:space="preserve">
          <source>intent(out) When non-NULL give the result of the operation, i.e., zero on success and non-zero on error. When NULL and an error occurs, then an error message is printed and the program is terminated.</source>
          <target state="translated">intent (out) NULL이 아닌 경우 작업 결과를 제공합니다 (예 : 성공시 0, 오류시 0이 아님). NULL이고 오류가 발생하면 오류 메시지가 인쇄되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="83f9a047e55e2f65c0bf4d6d3570cf32a45ee927" translate="yes" xml:space="preserve">
          <source>intent(out) when non-&lt;code&gt;NULL&lt;/code&gt; give the result of the send-operation, i.e., zero on success and non-zero on error. When &lt;code&gt;NULL&lt;/code&gt; and an error occurs, then an error message is printed and the program is terminated.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 intent (out) 는 전송 작업의 결과를 제공합니다 (예 : 성공시 0, 오류시 0이 아님). 경우 &lt;code&gt;NULL&lt;/code&gt; 에러가 발생하고 에러 메시지가 출력되고, 프로그램은 종료된다.</target>
        </trans-unit>
        <trans-unit id="cfc152cf3a76c667ea7be9868520c394342defa4" translate="yes" xml:space="preserve">
          <source>intent(out) when non-NULL give the result of the operation, i.e., zero on success and non-zero on error. When NULL and an error occurs, then an error message is printed and the program is terminated.</source>
          <target state="translated">NULL이 아닌 경우 intent (out)는 작업 결과를 제공합니다 (예 : 성공시 0, 오류시 0이 아님). NULL이고 오류가 발생하면 오류 메시지가 인쇄되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4b6914c620d2daa62ebe5994f36f361b3a759bf8" translate="yes" xml:space="preserve">
          <source>intersection</source>
          <target state="translated">intersection</target>
        </trans-unit>
        <trans-unit id="81f344a7686a80b4c5293e8fdc0b0160c82c06a8" translate="yes" xml:space="preserve">
          <source>invalid</source>
          <target state="translated">invalid</target>
        </trans-unit>
        <trans-unit id="023e03b99b011f685d4d366b227ca74853a31772" translate="yes" xml:space="preserve">
          <source>is active for</source>
          <target state="translated">활성화되어있다</target>
        </trans-unit>
        <trans-unit id="a3399e99e36d13c096ddbe66f96097e5ea9fa4d6" translate="yes" xml:space="preserve">
          <source>is an &lt;code&gt;INTENT(INOUT)&lt;/code&gt; argument and shall be nonpolymorphic. If it is allocatable, it shall be allocated; if it is a pointer, it shall be associated. &lt;var&gt;A&lt;/var&gt; shall have the same type and type parameters on all images of the team; if it is an array, it shall have the same shape on all images.</source>
          <target state="translated">이다 &lt;code&gt;INTENT(INOUT)&lt;/code&gt; 인수 및 nonpolymorphic한다. 할당 할 수있는 경우 할당된다. 포인터 인 경우 연관되어야합니다. &lt;var&gt;A&lt;/var&gt; 는 팀의 모든 이미지에서 동일한 유형 및 유형 매개 변수를 가져야한다. 그것이 배열이라면, 모든 이미지에서 같은 모양이어야한다.</target>
        </trans-unit>
        <trans-unit id="d5e077e3588ef2b8e6993d19f94c41071bc6f708" translate="yes" xml:space="preserve">
          <source>is explicitly requested.</source>
          <target state="translated">명시 적으로 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="8a98a007e26664e6e90b50caf1a9921d33b04c72" translate="yes" xml:space="preserve">
          <source>is given on the command line. Default widths will be used. This is considered non-conforming code and is discouraged.</source>
          <target state="translated">명령 줄에 제공됩니다. 기본 너비가 사용됩니다. 이는 부적합 코드로 간주되며 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26e79733e06b2f4ea2fe9f20c47dd94601696725" translate="yes" xml:space="preserve">
          <source>is given on the command line. This is considered non-conforming code and is discouraged.</source>
          <target state="translated">명령 행에 제공됩니다. 이것은 부적합 코드로 간주되며 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5dbae8240e6694e97ce09b3556bdb8f793596ca" translate="yes" xml:space="preserve">
          <source>is given, &lt;code&gt;DOUBLE PRECISION&lt;/code&gt; would instead be promoted to 16 bytes if possible, and</source>
          <target state="translated">주어, &lt;code&gt;DOUBLE PRECISION&lt;/code&gt; 은 대신 가능하면 16 바이트로 승진 될 것이다</target>
        </trans-unit>
        <trans-unit id="b8f2654b110054bce27d4604268533e4097dc61a" translate="yes" xml:space="preserve">
          <source>is given.</source>
          <target state="translated">주어진다.</target>
        </trans-unit>
        <trans-unit id="fa1a1e11beb3fa8f41d6859fdb96ba4f0fde5df7" translate="yes" xml:space="preserve">
          <source>is given. See also</source>
          <target state="translated">주어진다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="92aa0aaeaa698b1852033bd37c58c53ce7482b9e" translate="yes" xml:space="preserve">
          <source>is given. This attribute overrides</source>
          <target state="translated">주어진다. 이 속성은</target>
        </trans-unit>
        <trans-unit id="d511ff3c4c76fb95257fb99a792937799e6a1fca" translate="yes" xml:space="preserve">
          <source>is implemented as something akin to:</source>
          <target state="translated">다음과 비슷한 것으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f815a1bc4e8a059d90fcdeaf55f25f08112f57b7" translate="yes" xml:space="preserve">
          <source>is implied by</source>
          <target state="translated">에 의해 암시</target>
        </trans-unit>
        <trans-unit id="cf3593f4d582b9feb29ac97d0837991402cbf637" translate="yes" xml:space="preserve">
          <source>is implied by any of the</source>
          <target state="translated">다음 중 하나에 의해 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="822a1460ab8db4ab8c430537f71607d13c088241" translate="yes" xml:space="preserve">
          <source>is in effect, this packing will be performed by inline code. This allows for more optimization while increasing code size.</source>
          <target state="translated">실제로이 패킹은 인라인 코드로 수행됩니다. 이를 통해 코드 크기를 늘리는 동시에 더 많은 최적화가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f71aadf50c18579748c6456b5e95ba08181d232a" translate="yes" xml:space="preserve">
          <source>is in effect.</source>
          <target state="translated">효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b81137a94ebbde76653e3f712e080132ad80d01" translate="yes" xml:space="preserve">
          <source>is in effect. It is implied by the</source>
          <target state="translated">효과가 있습니다. 그것은에 의해 암시</target>
        </trans-unit>
        <trans-unit id="664179b7d883d2fcc4f164fbe02f49a06fb16b23" translate="yes" xml:space="preserve">
          <source>is in effect. Matrix multiplication of matrices with size larger than (or equal to) &lt;var&gt;n&lt;/var&gt; will be performed by calls to BLAS functions, while others will be handled by &lt;code&gt;gfortran&lt;/code&gt; internal algorithms. If the matrices involved are not square, the size comparison is performed using the geometric mean of the dimensions of the argument and result matrices.</source>
          <target state="translated">효과가 있습니다. 크기가 &lt;var&gt;n&lt;/var&gt; 보다 크거나 같은 행렬의 행렬 곱셈은 BLAS 함수 호출에 의해 수행되는 반면, 다른 행렬 은 &lt;code&gt;gfortran&lt;/code&gt; 내부 알고리즘에 의해 처리됩니다 . 관련된 행렬이 정사각형이 아닌 경우 인수와 결과 행렬의 차원에 대한 기하 평균을 사용하여 크기 비교가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1e3edce66572775c2ea107b61d39776d81b7bd51" translate="yes" xml:space="preserve">
          <source>is not recommended unless you are experimenting with issues such as integration of GNU Fortran into existing system environments (vis-&amp;agrave;-vis existing libraries, tools, and so on).</source>
          <target state="translated">기존 시스템 환경 (기존 라이브러리, 도구 등)에 GNU Fortran 통합과 같은 문제를 실험하지 않는 한 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3de06cc6f860f8a9fc1d0678674470739770e52a" translate="yes" xml:space="preserve">
          <source>is set for the compilation of the main program.</source>
          <target state="translated">메인 프로그램의 컴파일을 위해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ea83b96a85bb598b022550183e045e1662e26def" translate="yes" xml:space="preserve">
          <source>is specified, they do not prevent compilation of the program.</source>
          <target state="translated">지정하면 프로그램 컴파일을 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df7614250cf825ce49ccd1794afad60108faf9d9" translate="yes" xml:space="preserve">
          <source>is specified.</source>
          <target state="translated">지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a587815b962b44059592c40869eeea56aa9fb9d" translate="yes" xml:space="preserve">
          <source>is used  *** unless</source>
          <target state="translated">사용하지 않는 한 ***</target>
        </trans-unit>
        <trans-unit id="f136f5c17366f25e870e746058a467ee09b3377a" translate="yes" xml:space="preserve">
          <source>is used (see &lt;a href=&quot;fortran-dialect-options#Fortran-Dialect-Options&quot;&gt;Fortran Dialect Options&lt;/a&gt;)</source>
          <target state="translated">사용됨 ( &lt;a href=&quot;fortran-dialect-options#Fortran-Dialect-Options&quot;&gt;Fortran Dialect 옵션&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="25f648ba07c318fb10c2ec4f60a42f5fb257af03" translate="yes" xml:space="preserve">
          <source>is used with</source>
          <target state="translated">와 함께 사용</target>
        </trans-unit>
        <trans-unit id="a6839d76bbb7783af5dc7927fd3ea8c02821e91c" translate="yes" xml:space="preserve">
          <source>is used.</source>
          <target state="translated">사용.</target>
        </trans-unit>
        <trans-unit id="66e43fcd5f31ca6c3f01f8743ada40c1cd9bf77d" translate="yes" xml:space="preserve">
          <source>is used. In the following example, the first element of the array will be given the value 0.00 and the two succeeding elements will be given the values 1.00 and 2.00.</source>
          <target state="translated">사용. 다음 예제에서 배열의 첫 번째 요소에는 0.00 값이 주어지고 두 개의 후속 요소에는 1.00 및 2.00 값이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="9b33046ed39d182e3adafa9045ad6787d4bbc321" translate="yes" xml:space="preserve">
          <source>legacy</source>
          <target state="translated">legacy</target>
        </trans-unit>
        <trans-unit id="9d062bafff17ba8b9a1215c4c51485134d509d91" translate="yes" xml:space="preserve">
          <source>lib</source>
          <target state="translated">lib</target>
        </trans-unit>
        <trans-unit id="80218e6fcc0c072989e1a142de7299e32a6e5226" translate="yes" xml:space="preserve">
          <source>libgfortran</source>
          <target state="translated">libgfortran</target>
        </trans-unit>
        <trans-unit id="aadf46ad52b563db141c6a8b633250cb09e7740c" translate="yes" xml:space="preserve">
          <source>little-endian</source>
          <target state="translated">little-endian</target>
        </trans-unit>
        <trans-unit id="3f9a1c07b593dfba479aaa63292e71d7545fc898" translate="yes" xml:space="preserve">
          <source>matches the Fortran declaration</source>
          <target state="translated">포트란 선언과 일치</target>
        </trans-unit>
        <trans-unit id="73b77927d84a6401987ab70daf9a82a6ee5e4f4e" translate="yes" xml:space="preserve">
          <source>matches the following &lt;code&gt;struct&lt;/code&gt; declaration in C</source>
          <target state="translated">C에서 다음 &lt;code&gt;struct&lt;/code&gt; 선언 과 일치</target>
        </trans-unit>
        <trans-unit id="7fe27285fff392016bb8c583c67246eb6704f6e8" translate="yes" xml:space="preserve">
          <source>matrix multiplication</source>
          <target state="translated">행렬 곱셈</target>
        </trans-unit>
        <trans-unit id="19bbd4269ffa388d514e6c395af8f09261c1a711" translate="yes" xml:space="preserve">
          <source>means the same thing as</source>
          <target state="translated">와 같은 것을 의미</target>
        </trans-unit>
        <trans-unit id="eccc4fdd5c655985a966fcd5519cee11d576e209" translate="yes" xml:space="preserve">
          <source>mem</source>
          <target state="translated">mem</target>
        </trans-unit>
        <trans-unit id="d1854cae891ec7b29161ccaf79a24b00c274bdaa" translate="yes" xml:space="preserve">
          <source>n</source>
          <target state="translated">n</target>
        </trans-unit>
        <trans-unit id="6f5b01580ce43822444ae4c79edcd0dc789028f1" translate="yes" xml:space="preserve">
          <source>native</source>
          <target state="translated">native</target>
        </trans-unit>
        <trans-unit id="52c56ebf038fb7625cfef22840e3ab11b2246ecb" translate="yes" xml:space="preserve">
          <source>need to be in effect. The parentheses protection is enabled by default, unless</source>
          <target state="translated">효력이 있어야합니다. 괄호 보호는 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e453d1d3e45b46f4624613d0ed41283e8121317d" translate="yes" xml:space="preserve">
          <source>new line</source>
          <target state="translated">새로운 줄</target>
        </trans-unit>
        <trans-unit id="6912021f8da67a66e21e98578b71290c2142f9a3" translate="yes" xml:space="preserve">
          <source>no underscore is appended while &lt;code&gt;-fsecond-underscore&lt;/code&gt; appends two underscores. Depending on the target system and the calling convention, the procedure might be additionally dressed; for instance, on 32bit Windows with &lt;code&gt;stdcall&lt;/code&gt;, an at-sign &lt;code&gt;@&lt;/code&gt; followed by an integer number is appended. For the changing the calling convention, see see &lt;a href=&quot;gnu-fortran-compiler-directives#GNU-Fortran-Compiler-Directives&quot;&gt;GNU Fortran Compiler Directives&lt;/a&gt;.</source>
          <target state="translated">밑줄은 추가되지 &lt;code&gt;-fsecond-underscore&lt;/code&gt; 는 두 개의 밑줄을 추가합니다. 대상 시스템 및 호출 규칙에 따라 절차가 추가로 옷을 입을 수 있습니다. 예를 들어, &lt;code&gt;stdcall&lt;/code&gt; 이있는 32 비트 Windows 에서는 at-sign &lt;code&gt;@&lt;/code&gt; 다음에 정수가 추가됩니다. 호출 규칙을 변경하려면 &lt;a href=&quot;gnu-fortran-compiler-directives#GNU-Fortran-Compiler-Directives&quot;&gt;GNU Fortran 컴파일러 지시문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84e9d0dbac2449a2a96508e04c0accf17a79c336" translate="yes" xml:space="preserve">
          <source>no-</source>
          <target state="translated">no-</target>
        </trans-unit>
        <trans-unit id="71f8e7976e4cbc4561c9d62fb283e7f788202acb" translate="yes" xml:space="preserve">
          <source>none</source>
          <target state="translated">none</target>
        </trans-unit>
        <trans-unit id="82a52a64d1c2d49d8fe29b8a8671eba7fdbb2c8d" translate="yes" xml:space="preserve">
          <source>null character</source>
          <target state="translated">널 문자</target>
        </trans-unit>
        <trans-unit id="150d7bb6bbb7c572c7453262785b65f5c1ada1e5" translate="yes" xml:space="preserve">
          <source>number of command line argument strings</source>
          <target state="translated">명령 행 인수 문자열 수</target>
        </trans-unit>
        <trans-unit id="11fbbaaf0a67aea0d85fd3edb52178ee2c95cf54" translate="yes" xml:space="preserve">
          <source>number of options passed</source>
          <target state="translated">전달 된 옵션 수</target>
        </trans-unit>
        <trans-unit id="6e972ef42bd6df42920670270b4f66874641ff72" translate="yes" xml:space="preserve">
          <source>objects with the POINTER attribute</source>
          <target state="translated">POINTER 속성을 가진 객체</target>
        </trans-unit>
        <trans-unit id="937fc102cb0f766f49b950a02e67b46c044617c6" translate="yes" xml:space="preserve">
          <source>omp_lib.h</source>
          <target state="translated">omp_lib.h</target>
        </trans-unit>
        <trans-unit id="110ac099a63aaaf008854653e573454a1ebc64ad" translate="yes" xml:space="preserve">
          <source>one of the caf_register_t types.</source>
          <target state="translated">caf_register_t 유형 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0808d0355362fb07d30f078c078ddacfa434ffa1" translate="yes" xml:space="preserve">
          <source>only in gfortran procedures with character arguments that call implicitly prototyped procedures.</source>
          <target state="translated">암시 적으로 프로토 타입 된 프로 시저를 호출하는 문자 인수가있는 gfortran 프로 시저에서만.</target>
        </trans-unit>
        <trans-unit id="a6f32744141032da5bff0021214a9f0a8f72e942" translate="yes" xml:space="preserve">
          <source>openacc_lib.h</source>
          <target state="translated">openacc_lib.h</target>
        </trans-unit>
        <trans-unit id="21a94b187356f6639de170787b8b0236b1d55489" translate="yes" xml:space="preserve">
          <source>option (which exists for backwards compability only) is in effect.</source>
          <target state="translated">옵션 (역방향 호환성을 위해서만 존재 함)이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7cd170a8ec5cf578e8a1b74718a186076244d2a7" translate="yes" xml:space="preserve">
          <source>option and support for the file extensions</source>
          <target state="translated">파일 확장자에 대한 옵션 및 지원</target>
        </trans-unit>
        <trans-unit id="46dddf0d2774765cfbd4425ea3472294efd49c5c" translate="yes" xml:space="preserve">
          <source>option can be used to generate prototypes which conform to gfortran&amp;rsquo;s ABI, for inclusion in the source code.</source>
          <target state="translated">옵션은 소스 코드에 포함하기 위해 gfortran의 ABI를 준수하는 프로토 타입을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d2a8c3d168f9f29ea8a3e3a3b55392ccc7d5b17" translate="yes" xml:space="preserve">
          <source>option causes all C++-style comments inside a macro to be converted to C-style comments. This is to prevent later use of that macro from inadvertently commenting out the remainder of the source line. The</source>
          <target state="translated">옵션을 사용하면 매크로 내의 모든 C ++ 스타일 주석이 C 스타일 주석으로 변환됩니다. 이는 나중에 해당 매크로를 사용하여 소스 라인의 나머지 부분을 실수로 주석 처리하는 것을 방지합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="5f7873321f26f0d990c13e9a403ffb186d691b13" translate="yes" xml:space="preserve">
          <source>option except</source>
          <target state="translated">옵션 제외</target>
        </trans-unit>
        <trans-unit id="b30bad31c44d5554857ee51285785dbaa4e87bd2" translate="yes" xml:space="preserve">
          <source>option extends support of Hollerith constants to comparisons:</source>
          <target state="translated">옵션은 Hollerith 상수 지원을 비교로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="3e715e6cf813b3fb8e875cb1b4d893d15277d8f9" translate="yes" xml:space="preserve">
          <source>option flag list:</source>
          <target state="translated">옵션 플래그 목록 :</target>
        </trans-unit>
        <trans-unit id="f8a59604aa1481079b7689e1b94785aeca741601" translate="yes" xml:space="preserve">
          <source>option for more information.</source>
          <target state="translated">자세한 내용은 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3556e958b8c1ce0c992c816b18693450704dfd5a" translate="yes" xml:space="preserve">
          <source>option if you want object files compiled with GNU Fortran to be compatible with object code created with these tools.</source>
          <target state="translated">GNU Fortran으로 컴파일 된 오브젝트 파일이이 도구로 작성된 오브젝트 코드와 호환되도록하려면 옵션을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="faf18f537fa40899cc1130e12579a59c575a8cd5" translate="yes" xml:space="preserve">
          <source>option initializes &lt;code&gt;REAL&lt;/code&gt; and &lt;code&gt;COMPLEX&lt;/code&gt; variables with a quiet NaN. For a signalling NaN use</source>
          <target state="translated">옵션 은 조용한 NaN으로 &lt;code&gt;REAL&lt;/code&gt; 및 &lt;code&gt;COMPLEX&lt;/code&gt; 변수를 초기화 합니다. 신호 NaN 사용</target>
        </trans-unit>
        <trans-unit id="2d1351c892abbbed783a3034224515fbc9786eec" translate="yes" xml:space="preserve">
          <source>option instructs the compiler to initialize local &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, and &lt;code&gt;COMPLEX&lt;/code&gt; variables to zero, &lt;code&gt;LOGICAL&lt;/code&gt; variables to false, and &lt;code&gt;CHARACTER&lt;/code&gt; variables to a string of null bytes. Finer-grained initialization options are provided by the</source>
          <target state="translated">옵션은 컴파일러에게 로컬 &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 및 &lt;code&gt;COMPLEX&lt;/code&gt; 변수를 0으로, &lt;code&gt;LOGICAL&lt;/code&gt; 변수를 false로, &lt;code&gt;CHARACTER&lt;/code&gt; 변수를 널 바이트 문자열 로 초기화하도록 지시합니다 . 보다 세밀한 초기화 옵션은</target>
        </trans-unit>
        <trans-unit id="138b0af3ea6a0946f118342990e798f7bd579fd2" translate="yes" xml:space="preserve">
          <source>option is added.</source>
          <target state="translated">옵션이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7091ba3109db02534597ef8e378b2538efffa4f" translate="yes" xml:space="preserve">
          <source>option is generally used to support lint comments.</source>
          <target state="translated">옵션은 일반적으로 보푸라기 주석을 지원하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b24d04c41729d60f21d32bbbdb1a63f474f66a5a" translate="yes" xml:space="preserve">
          <source>option is given they are treated as if the first column contained a blank. If the</source>
          <target state="translated">옵션은 첫 번째 열에 공백이있는 것처럼 취급됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="287e7f63ad39154ebe8fecc7c99d0f618b1a471f" translate="yes" xml:space="preserve">
          <source>option is given, they are treated as comment lines.</source>
          <target state="translated">옵션이 주어지면 주석 행으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="90976eedeea57409cf17e2da87a1ee0ee77b5ef4" translate="yes" xml:space="preserve">
          <source>option is used. With any of those options continued character constants never have implicit spaces appended to them to fill out the line.</source>
          <target state="translated">옵션이 사용됩니다. 이러한 옵션 중 하나를 사용하면 연속 문자 상수에는 줄을 채우기 위해 암시 적 공백이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4e83634651ab2e2fcb8d2a3eca160fe7a66d634" translate="yes" xml:space="preserve">
          <source>option will parse the value into an integer of type &lt;code&gt;INTEGER(kind=C_LONG)&lt;/code&gt; on the host. Said value is then assigned to the integer variables in the Fortran code, which might result in wraparound if the value is too large for the kind.</source>
          <target state="translated">옵션은 값을 호스트에서 &lt;code&gt;INTEGER(kind=C_LONG)&lt;/code&gt; 유형의 정수로 구문 분석합니다 . 그런 다음 해당 값이 Fortran 코드의 정수 변수에 할당되며, 값이 종류에 비해 너무 크면 줄 바꿈이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25417ae0a78b0af13771ed7615f72787bf0a4d94" translate="yes" xml:space="preserve">
          <source>option, altough this is rarely useful. If the length of a logical record exceeds this limit, the data is distributed among several subrecords.</source>
          <target state="translated">옵션이지만 이것은 거의 유용하지 않습니다. 논리 레코드의 길이가이 한계를 초과하면 데이터가 여러 서브 레코드에 분배됩니다.</target>
        </trans-unit>
        <trans-unit id="a34f2f3d76e4e1b302822281837cf4eec6b279a0" translate="yes" xml:space="preserve">
          <source>option, and so all intrinsic procedures described here are accepted. There is one caveat. For a select group of intrinsic procedures, &lt;code&gt;g77&lt;/code&gt; implemented both a function and a subroutine. Both classes have been implemented in &lt;code&gt;gfortran&lt;/code&gt; for backwards compatibility with &lt;code&gt;g77&lt;/code&gt;. It is noted here that these functions and subroutines cannot be intermixed in a given subprogram. In the descriptions that follow, the applicable standard for each intrinsic procedure is noted.</source>
          <target state="translated">옵션이므로 여기에 설명 된 모든 본질적 절차가 허용됩니다. 하나의 경고가 있습니다. 선택된 내장 프로 시저 그룹에 대해 &lt;code&gt;g77&lt;/code&gt; 은 기능과 서브 루틴을 모두 구현했습니다. &lt;code&gt;g77&lt;/code&gt; 과의 하위 호환성을 위해 두 클래스 모두 &lt;code&gt;gfortran&lt;/code&gt; 으로 구현되었습니다 . 이 기능들과 서브 루틴들은 주어진 서브 프로그램에서 혼합 될 수 없다는 점에 유의하십시오. 이하의 설명에서, 각각의 고유 절차에 적용 가능한 표준이 언급되어있다.</target>
        </trans-unit>
        <trans-unit id="b9f390858f176c761bd4d024b001313103e7ff4b" translate="yes" xml:space="preserve">
          <source>option, but applies only to header files. See the</source>
          <target state="translated">옵션이지만 헤더 파일에만 적용됩니다. 참조</target>
        </trans-unit>
        <trans-unit id="ca06f45b34999ef78d83680cc23aee4feb47bec5" translate="yes" xml:space="preserve">
          <source>option, the</source>
          <target state="translated">옵션,</target>
        </trans-unit>
        <trans-unit id="b9e36dadee662e7af188ab666bac755b65329f40" translate="yes" xml:space="preserve">
          <source>option, the &lt;a href=&quot;convert-specifier#CONVERT-specifier&quot;&gt;CONVERT specifier&lt;/a&gt; in an open statement or the &lt;a href=&quot;gfortran_005fconvert_005funit#GFORTRAN_005fCONVERT_005fUNIT&quot;&gt;GFORTRAN_CONVERT_UNIT&lt;/a&gt; environment variable.</source>
          <target state="translated">옵션, open 문의 &lt;a href=&quot;convert-specifier#CONVERT-specifier&quot;&gt;CONVERT 지정자&lt;/a&gt; 또는 &lt;a href=&quot;gfortran_005fconvert_005funit#GFORTRAN_005fCONVERT_005fUNIT&quot;&gt;GFORTRAN_CONVERT_UNIT&lt;/a&gt; 환경 변수.</target>
        </trans-unit>
        <trans-unit id="6ae8466701cc7877c4bddede4c4fb980f9a951c6" translate="yes" xml:space="preserve">
          <source>option, the argument passing is modified and no longer completely matches the platform ABI. Some other Fortran compilers use &lt;code&gt;f2c&lt;/code&gt; semantic by default; this might cause problems with interoperablility.</source>
          <target state="translated">옵션으로 인수 전달이 수정되어 더 이상 플랫폼 ABI와 완전히 일치하지 않습니다. 일부 다른 포트란 컴파일러 는 기본적으로 &lt;code&gt;f2c&lt;/code&gt; 의미를 사용합니다 . 이로 인해 상호 운용성에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7327a6f71275be751e16853302d6797cd34f889" translate="yes" xml:space="preserve">
          <source>option, unless</source>
          <target state="translated">옵션이 아닌 한</target>
        </trans-unit>
        <trans-unit id="12cb917fa6b139c69bd08293a23c4256c452e570" translate="yes" xml:space="preserve">
          <source>option.</source>
          <target state="translated">option.</target>
        </trans-unit>
        <trans-unit id="423425bb1735fe8335c27b50a1b492c0164e3f59" translate="yes" xml:space="preserve">
          <source>option. At the moment, this option only affects &lt;code&gt;FORALL&lt;/code&gt; and &lt;code&gt;DO CONCURRENT&lt;/code&gt; statements with several forall triplets.</source>
          <target state="translated">선택권. 현재이 옵션 은 여러 개의 forall 트리플렛이있는 &lt;code&gt;FORALL&lt;/code&gt; 및 &lt;code&gt;DO CONCURRENT&lt;/code&gt; 문 에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="24fe3d79734f45c3cb85b43fb6884e4a13dbbb29" translate="yes" xml:space="preserve">
          <source>option. It will make GNU Fortran choose the smallest &lt;code&gt;INTEGER&lt;/code&gt; kind a given enumerator set will fit in, and give all its enumerators this kind.</source>
          <target state="translated">선택권. GNU Fortran 은 주어진 열거 자 집합에 맞는 가장 작은 &lt;code&gt;INTEGER&lt;/code&gt; 종류를 선택하고 모든 열거 자에게 이러한 종류를 부여합니다.</target>
        </trans-unit>
        <trans-unit id="0617d98ebd8478371e5e0679fa2d7af359a09fd0" translate="yes" xml:space="preserve">
          <source>option. Optimizations enabled by this option include inlining calls to &lt;code&gt;MATMUL&lt;/code&gt;, elimination of identical function calls within expressions, removing unnecessary calls to &lt;code&gt;TRIM&lt;/code&gt; in comparisons and assignments and replacing &lt;code&gt;TRIM(a)&lt;/code&gt; with &lt;code&gt;a(1:LEN_TRIM(a))&lt;/code&gt;. It can be deselected by specifying</source>
          <target state="translated">선택권. 이 옵션을 통해 최적화 된 기능에는 &lt;code&gt;MATMUL&lt;/code&gt; 호출 인라인 , 표현식 내에서 동일한 함수 호출 제거, 비교 및 할당에서 &lt;code&gt;TRIM&lt;/code&gt; 에 대한 불필요한 호출 제거 및 &lt;code&gt;TRIM(a)&lt;/code&gt; 를 &lt;code&gt;a(1:LEN_TRIM(a))&lt;/code&gt; 됩니다. 지정하여 선택을 해제 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1853c2f7202c9954976851c97d33b2b4a06e6b87" translate="yes" xml:space="preserve">
          <source>option. This option is implied by</source>
          <target state="translated">선택권. 이 옵션은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cb8daff2914505b56aa7be7e3b603f292e7e4638" translate="yes" xml:space="preserve">
          <source>optional; team on the which the inquiry is to be performed.</source>
          <target state="translated">선택 과목; 문의를 수행 할 팀.</target>
        </trans-unit>
        <trans-unit id="b186fbd0500f9fe44f2380f8246be6d9890766d9" translate="yes" xml:space="preserve">
          <source>optional; the kind of the resulting integer array.</source>
          <target state="translated">선택 과목; 결과 정수 배열의 종류</target>
        </trans-unit>
        <trans-unit id="2eaa6d5ac1dfa500abd78c17f69dab63fb485980" translate="yes" xml:space="preserve">
          <source>options (and the directory of the current file, if appropriate) are searched.</source>
          <target state="translated">옵션 (및 해당되는 경우 현재 파일의 디렉토리)이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="aad1cb0d40ee3402c17e9ce478fccd81f8043e35" translate="yes" xml:space="preserve">
          <source>options are processed in the order they are given on the command line. All -imacros file and -include file options are processed after all -D and -U options.</source>
          <target state="translated">옵션은 명령 행에 주어진 순서대로 처리됩니다. 모든 -imacros 파일 및 -include 파일 옵션은 모든 -D 및 -U 옵션 뒤에 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="461a1f48c7d01c8208afeba6b7008faaa6051aae" translate="yes" xml:space="preserve">
          <source>options except when optimizing for size via</source>
          <target state="translated">옵션을 통해 크기를 최적화하는 경우 제외</target>
        </trans-unit>
        <trans-unit id="0ce552b484c6baf569abee1187485cadddefa843" translate="yes" xml:space="preserve">
          <source>options will silence warnings that would have been emitted by</source>
          <target state="translated">옵션은 다음과 같은 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eeec37a7c5de5e558698507dd9b10d6069b93b4e" translate="yes" xml:space="preserve">
          <source>options, which can be used to restrict the set of intrinsic procedures to a given standard. By default, &lt;code&gt;gfortran&lt;/code&gt; sets the</source>
          <target state="translated">내장 프로 시저 세트를 주어진 표준으로 제한하는 데 사용할 수있는 옵션. 기본적으로 &lt;code&gt;gfortran&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="835470bacb439d9d9ed5b0fb6adc0d05997c0a0e" translate="yes" xml:space="preserve">
          <source>options.</source>
          <target state="translated">options.</target>
        </trans-unit>
        <trans-unit id="503a31a0aef5a90f801a2df18be9d8e43e463a55" translate="yes" xml:space="preserve">
          <source>options. If the &lt;var&gt;prefix&lt;/var&gt; represents a directory, you should include the final &lt;code&gt;'/'&lt;/code&gt;.</source>
          <target state="translated">옵션. &lt;var&gt;prefix&lt;/var&gt; 가 디렉토리를 나타내는 경우 최종 &lt;code&gt;'/'&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="15207e97dc285c469651810c46695ae88381311c" translate="yes" xml:space="preserve">
          <source>or adding it.</source>
          <target state="translated">또는 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1ac31865bdacb9fa6c7dbeeb75ff28738cae398a" translate="yes" xml:space="preserve">
          <source>or equivalent</source>
          <target state="translated">또는 동등한</target>
        </trans-unit>
        <trans-unit id="f3c446f5c600ee0723a591482edd6f3fc16d1ec1" translate="yes" xml:space="preserve">
          <source>or if</source>
          <target state="translated">아니면</target>
        </trans-unit>
        <trans-unit id="7575aa67b045f229769b11d1626612197866d7c5" translate="yes" xml:space="preserve">
          <source>or standard-conforming mode is enabled, this is an error.</source>
          <target state="translated">또는 표준 준수 모드를 사용하는 경우 오류입니다.</target>
        </trans-unit>
        <trans-unit id="7cb1b49562016ba76c59c7ec044adaf8cc02dc6c" translate="yes" xml:space="preserve">
          <source>or with:</source>
          <target state="translated">또는 함께 :</target>
        </trans-unit>
        <trans-unit id="6ae2dc2ac7dc5d47b8c060f0e22c38089a3bea86" translate="yes" xml:space="preserve">
          <source>or,</source>
          <target state="translated">or,</target>
        </trans-unit>
        <trans-unit id="10e80591d92f76de99d040a135745da09e965721" translate="yes" xml:space="preserve">
          <source>overflow</source>
          <target state="translated">overflow</target>
        </trans-unit>
        <trans-unit id="4149a32b415d88839c45c3b1f1c432b9aea20387" translate="yes" xml:space="preserve">
          <source>platforms which use the GNU C Library (glibc)</source>
          <target state="translated">GNU C 라이브러리 (glibc)를 사용하는 플랫폼</target>
        </trans-unit>
        <trans-unit id="aebf9343fb5e97ec99071763d5134ef00c0c95b7" translate="yes" xml:space="preserve">
          <source>platforms with support for SysV/386 routines for floating point interface (including Solaris and BSDs)</source>
          <target state="translated">부동 소수점 인터페이스 (Solaris 및 BSD 포함)를위한 SysV / 386 루틴을 지원하는 플랫폼</target>
        </trans-unit>
        <trans-unit id="dc8880b02ba33882587808f96c9cce75017781ce" translate="yes" xml:space="preserve">
          <source>platforms with the AIX OS</source>
          <target state="translated">AIX OS가있는 플랫폼</target>
        </trans-unit>
        <trans-unit id="b35bb38df9605e4c5858316b7853a16e42ea6997" translate="yes" xml:space="preserve">
          <source>pointer</source>
          <target state="translated">pointer</target>
        </trans-unit>
        <trans-unit id="d1f4ebfda5b47a773e00bd291970f315bc667b29" translate="yes" xml:space="preserve">
          <source>pointer interoperable with &lt;var&gt;cptr&lt;/var&gt;. It is &lt;code&gt;INTENT(OUT)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;cptr&lt;/var&gt; 과 상호 운용 가능한 포인터 . 그것은 인 &lt;code&gt;INTENT(OUT)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31d0b624910a4b7c8e86205cd558df13bb986d6f" translate="yes" xml:space="preserve">
          <source>precision greater than or equal to &lt;code&gt;P&lt;/code&gt;, but the &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;RADIX&lt;/code&gt; requirements can be fulfilled</source>
          <target state="translated">&lt;code&gt;P&lt;/code&gt; 이상의 정밀도 이지만 &lt;code&gt;R&lt;/code&gt; 및 &lt;code&gt;RADIX&lt;/code&gt; 요구 사항을 충족 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a609d8b6eabd5abd1462e4b709db12a4397fc81" translate="yes" xml:space="preserve">
          <source>prefix quote digits quote</source>
          <target state="translated">접두사 따옴표 자리 따옴표</target>
        </trans-unit>
        <trans-unit id="ebc67bc60f36362ea4b9599cdd2a8b18adda1a4b" translate="yes" xml:space="preserve">
          <source>procedure pointer interoperable with &lt;var&gt;cptr&lt;/var&gt;. It is &lt;code&gt;INTENT(OUT)&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;cptr&lt;/var&gt; 과 상호 운용 가능한 프로 시저 포인터 . 그것은 인 &lt;code&gt;INTENT(OUT)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81503dacd5c0d1686795eef17cfffc587b8f8036" translate="yes" xml:space="preserve">
          <source>pure function with two scalar nonallocatable arguments, which shall be nonpolymorphic and have the same type and type parameters as &lt;var&gt;A&lt;/var&gt;. The function shall return a nonallocatable scalar of the same type and type parameters as &lt;var&gt;A&lt;/var&gt;. The function shall be the same on all images and with regards to the arguments mathematically commutative and associative. Note that &lt;var&gt;OPERATOR&lt;/var&gt; may not be an elemental function, unless it is an intrisic function.</source>
          <target state="translated">두 개의 스칼라 비 할당 가능 인수를 갖는 순수 함수. 비다 형성이어야하며 &lt;var&gt;A&lt;/var&gt; 와 동일한 유형 및 유형 매개 변수를 갖습니다 . 이 함수는 &lt;var&gt;A&lt;/var&gt; 와 동일한 유형 및 유형 매개 변수의 비 할당 가능한 스칼라를 리턴해야 합니다. 이 기능은 모든 이미지에서 수학적으로 정형적이고 연관성있는 인수와 관련하여 동일해야합니다. 참고 &lt;var&gt;OPERATOR&lt;/var&gt; 는 그것이 intrisic 기능하지 않는 한, 원소 기능하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67c20a4b9186099107113a1238627a8f556312fb" translate="yes" xml:space="preserve">
          <source>range greater than or equal to &lt;code&gt;R&lt;/code&gt;, but &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;RADIX&lt;/code&gt; are fulfillable</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 이상의 범위 이지만 &lt;code&gt;P&lt;/code&gt; 및 &lt;code&gt;RADIX&lt;/code&gt; 는 충족 가능</target>
        </trans-unit>
        <trans-unit id="1ec362cb7d87fee296be85bb7958cd5060dcaacb" translate="yes" xml:space="preserve">
          <source>recursion</source>
          <target state="translated">recursion</target>
        </trans-unit>
        <trans-unit id="e78f6ff8fbc54ae9f6cfee89ff8b3e4d5badc065" translate="yes" xml:space="preserve">
          <source>removing unnecessary calls to &lt;code&gt;TRIM&lt;/code&gt; in comparisons and assignments,</source>
          <target state="translated">비교 및 할당에서 &lt;code&gt;TRIM&lt;/code&gt; 에 대한 불필요한 호출 제거 ,</target>
        </trans-unit>
        <trans-unit id="46ff44d1ca669fafcb26a0787762a184f26821da" translate="yes" xml:space="preserve">
          <source>replacing &lt;code&gt;TRIM(a)&lt;/code&gt; with &lt;code&gt;a(1:LEN_TRIM(a))&lt;/code&gt; and</source>
          <target state="translated">대체 &lt;code&gt;TRIM(a)&lt;/code&gt; 와 &lt;code&gt;a(1:LEN_TRIM(a))&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="819058b65252d029de261449f9498a5e4222043a" translate="yes" xml:space="preserve">
          <source>scalar of the type &lt;code&gt;C_FUNPTR&lt;/code&gt;. It is &lt;code&gt;INTENT(IN)&lt;/code&gt;.</source>
          <target state="translated">유형의 스칼라 &lt;code&gt;C_FUNPTR&lt;/code&gt; . 그것은이다 &lt;code&gt;INTENT(IN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9619df87ad5b8d0cffb524d9db5432d401495cb7" translate="yes" xml:space="preserve">
          <source>scalar of the type &lt;code&gt;C_PTR&lt;/code&gt;. It is &lt;code&gt;INTENT(IN)&lt;/code&gt;.</source>
          <target state="translated">유형의 스칼라 &lt;code&gt;C_PTR&lt;/code&gt; . 그것은이다 &lt;code&gt;INTENT(IN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c100f5177622824e526bd2cff4fe2591455f888" translate="yes" xml:space="preserve">
          <source>shall be -1, 0, or 1</source>
          <target state="translated">-1, 0 또는 1이어야합니다</target>
        </trans-unit>
        <trans-unit id="e11bc8db23be401b73ea4ba436e695069a4319e8" translate="yes" xml:space="preserve">
          <source>shall be an integer, real or character variable, which has the same type and type parameters on all images of the team.</source>
          <target state="translated">정수, 실수 또는 문자 변수 여야하며 팀의 모든 이미지에서 동일한 유형 및 유형 매개 변수를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="876f21c9041df223eb7d36b233a1216a066a05bb" translate="yes" xml:space="preserve">
          <source>shall be an integer, real or complex variable, which has the same type and type parameters on all images of the team.</source>
          <target state="translated">팀의 모든 이미지에서 동일한 유형 및 유형 매개 변수를 갖는 정수, 실수 또는 복합 변수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="754e6a0f423fa609374c119a06dd1be2850f58b5" translate="yes" xml:space="preserve">
          <source>short-circuiting of logical operators (&lt;code&gt;.AND.&lt;/code&gt; and &lt;code&gt;.OR.&lt;/code&gt;).</source>
          <target state="translated">논리 연산자의 단락 ( &lt;code&gt;.AND.&lt;/code&gt; 및 &lt;code&gt;.OR.&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce0b1612aa711b78a720295d271a33894e2b72bf" translate="yes" xml:space="preserve">
          <source>single</source>
          <target state="translated">single</target>
        </trans-unit>
        <trans-unit id="0a6e2d7628cf0474c6c912a6bba3b83770aa6e9e" translate="yes" xml:space="preserve">
          <source>subroutine</source>
          <target state="translated">subroutine</target>
        </trans-unit>
        <trans-unit id="a0a26055aa647c7655ff344172186c18c0368f94" translate="yes" xml:space="preserve">
          <source>such that truncations are reported as error.</source>
          <target state="translated">잘림이 오류로보고되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ade3217578be1546a1b2a6827e4b13aa6d48d141" translate="yes" xml:space="preserve">
          <source>swap</source>
          <target state="translated">swap</target>
        </trans-unit>
        <trans-unit id="8c16ef009120e8094f13233a82aa09319ebbe601" translate="yes" xml:space="preserve">
          <source>tail call optimization is disabled in all gfortran procedures with character arguments, with</source>
          <target state="translated">꼬리 호출 최적화는 문자 인수가있는 모든 gfortran 프로 시저에서 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="8afd4b5d93b2a139a83662e7e0b82aa8491d287d" translate="yes" xml:space="preserve">
          <source>target associated with &lt;var&gt;POINTER&lt;/var&gt; and the target associated with &lt;var&gt;TARGET&lt;/var&gt; have the same shape, are not zero-sized arrays, are arrays whose elements are not zero-sized storage sequences, and &lt;var&gt;TARGET&lt;/var&gt; and &lt;var&gt;POINTER&lt;/var&gt; occupy the same storage units in array element order. The result is false, if either &lt;var&gt;TARGET&lt;/var&gt; or &lt;var&gt;POINTER&lt;/var&gt; is disassociated.</source>
          <target state="translated">와 연관된으로 타겟팅 &lt;var&gt;POINTER&lt;/var&gt; 과와 연관된 타겟 &lt;var&gt;TARGET&lt;/var&gt; 은 동일한 형상을 갖고, 크기 0의 배열되지 않으며, 해당 요소를 크기 0의 저장 순서없는 배열하고, &lt;var&gt;TARGET&lt;/var&gt; 및 &lt;var&gt;POINTER&lt;/var&gt; 배열 요소의 순서로 같은 저장 유닛을 점유한다. &lt;var&gt;TARGET&lt;/var&gt; 또는 &lt;var&gt;POINTER&lt;/var&gt; 가 연결 해제 된 경우 결과는 false 입니다.</target>
        </trans-unit>
        <trans-unit id="a04d7e97691cac9fa21cc2c1727b513d58907ee0" translate="yes" xml:space="preserve">
          <source>the buffer size of errmsg.</source>
          <target state="translated">errmsg의 버퍼 사이즈</target>
        </trans-unit>
        <trans-unit id="3407790e76ade08f5621b00541c84788000db589" translate="yes" xml:space="preserve">
          <source>the command-line argument strings; argv[0] is the pathname of the executable itself.</source>
          <target state="translated">명령 행 인수 문자열; argv [0]은 실행 파일 자체의 경로 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f7316138e93b6f1077a4e8c0c10a40a6aabb0213" translate="yes" xml:space="preserve">
          <source>the data type, i.e. &lt;code&gt;BT_INTEGER&lt;/code&gt; (1) or &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2).</source>
          <target state="translated">데이터 유형, 즉 &lt;code&gt;BT_INTEGER&lt;/code&gt; (1) 또는 &lt;code&gt;BT_LOGICAL&lt;/code&gt; (2).</target>
        </trans-unit>
        <trans-unit id="d0a58458c0c7eeebc72672ded1b3cadf21e05a5c" translate="yes" xml:space="preserve">
          <source>the distance from this image to the ancestor. Shall be positive.</source>
          <target state="translated">이 이미지로부터 조상까지의 거리 긍정적이다.</target>
        </trans-unit>
        <trans-unit id="cf81f6aaca3c9b58b11682a24caa3eeba563266d" translate="yes" xml:space="preserve">
          <source>the maximum length for a subrecord; the maximum permitted value is 2147483639, which is also the default.</source>
          <target state="translated">서브 레코드의 최대 길이; 허용되는 최대 값은 2147483639이며 기본값이기도합니다.</target>
        </trans-unit>
        <trans-unit id="930a883f5491fe120e904a7088ece0ae97f6f47e" translate="yes" xml:space="preserve">
          <source>the positive scalar id of the image in the current TEAM.</source>
          <target state="translated">현재 TEAM에서 이미지의 양의 스칼라 ID</target>
        </trans-unit>
        <trans-unit id="d68abd242c6370cf39d9f99e6286ef1833e644c1" translate="yes" xml:space="preserve">
          <source>the token to free.</source>
          <target state="translated">무료 토큰.</target>
        </trans-unit>
        <trans-unit id="7faa6a77513725b31df0b7cc8968bc2d3ebe484f" translate="yes" xml:space="preserve">
          <source>the type of action to take for the coarray. A &lt;code&gt;CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY&lt;/code&gt; is allowed only for allocatable or pointer components of derived type coarrays. The action only deallocates the local memory without deleting the token.</source>
          <target state="translated">대충에 대해 취할 조치 유형. &lt;code&gt;CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY&lt;/code&gt; 은 오직 파생 형 coarrays의 할당 가능한 또는 포인터 구성 요소 허용됩니다. 이 작업은 토큰을 삭제하지 않고 로컬 메모리 만 할당 해제합니다.</target>
        </trans-unit>
        <trans-unit id="5b5dd8c9ff824ec9ed1299ba9e3f206e549366f7" translate="yes" xml:space="preserve">
          <source>the value will &amp;ldquo;wrap around&amp;rdquo; and &lt;code&gt;i&lt;/code&gt; will be initialized to &lt;em&gt;-1&lt;/em&gt; instead.</source>
          <target state="translated">값은 &quot;랩 어라운드&quot;하고 &lt;code&gt;i&lt;/code&gt; 초기화됩니다 &lt;em&gt;-1&lt;/em&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e3bd2ac3c4ecbd8d070128bab4585b0f261719c7" translate="yes" xml:space="preserve">
          <source>there will only be a single call to &lt;code&gt;f&lt;/code&gt;. This option only works if</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 는 한 번만 호출됩니다 . 이 옵션은 다음과 같은 경우에만 작동합니다</target>
        </trans-unit>
        <trans-unit id="ce0b84d0dd06526675c367a9b37baa8d05636232" translate="yes" xml:space="preserve">
          <source>though, so also</source>
          <target state="translated">그래도</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="58290606c3460d65f954245fc13085dc9fb00b03" translate="yes" xml:space="preserve">
          <source>to allow for recursive procedures which do not have a RECURSIVE attribute or for parallel programs. Use</source>
          <target state="translated">RECURSIVE 속성이없는 재귀 프로 시저 또는 병렬 프로그램을 허용합니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="175241870abde22a0be0b3aac8163545ef8c3eb8" translate="yes" xml:space="preserve">
          <source>to check programs for conformance. They soon find that it does not do quite what they want&amp;mdash;it finds some nonstandard practices, but not all. However, improvements to GNU Fortran in this area are welcome.</source>
          <target state="translated">프로그램의 적합성을 확인합니다. 그들은 곧 자신이 원하는 것을 제대로 수행하지 못한다는 것을 알게되었습니다. 비표준 관행을 찾아 냈지만 전부는 아닙니다. 그러나이 영역에서 GNU Fortran의 개선을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="c76aacb822227bb99791ba9c41442a01f2a7f418" translate="yes" xml:space="preserve">
          <source>to enable the extension.</source>
          <target state="translated">확장을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3b9acd43263622cec1b2ad4f0e876aff9b871918" translate="yes" xml:space="preserve">
          <source>to force standard-compliance but get access to the full range of intrinsics available with &lt;code&gt;gfortran&lt;/code&gt;. As a consequence,</source>
          <target state="translated">표준 준수를 강요하지만 &lt;code&gt;gfortran&lt;/code&gt; 으로 사용 가능한 모든 범위의 내장 함수에 액세스 할 수 있습니다 . 결과로서,</target>
        </trans-unit>
        <trans-unit id="12b49323bb42ef72b6d00da7d458b41262f07945" translate="yes" xml:space="preserve">
          <source>to never use the stack.</source>
          <target state="translated">스택을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a487cdc42f348f32bb8abc739adc4b9c8e68d91f" translate="yes" xml:space="preserve">
          <source>to print &amp;ldquo;Hello World&amp;rdquo; from Fortran, one can call it using</source>
          <target state="translated">Fortran에서 &quot;Hello World&quot;를 인쇄하려면</target>
        </trans-unit>
        <trans-unit id="c229f515f93d84975158baab99770dc72d593ef2" translate="yes" xml:space="preserve">
          <source>to request warnings on implicit declarations. Each of these specific warning options also has a negative form beginning</source>
          <target state="translated">암시 적 선언에 대한 경고를 요청합니다. 이러한 특정 경고 옵션은 각각 부정적인 형식으로 시작합니다</target>
        </trans-unit>
        <trans-unit id="2cf73b040d3ebb1a557b25499750c11e6de3ec66" translate="yes" xml:space="preserve">
          <source>to turn off warnings; for example,</source>
          <target state="translated">경고를 끄는 것; 예를 들어</target>
        </trans-unit>
        <trans-unit id="19015b8c94f51ee823f61956ac164471d73f4dd5" translate="yes" xml:space="preserve">
          <source>to use no static memory.</source>
          <target state="translated">정적 메모리를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36e14f2c6b35cc9a0321a033c591b6ea1d4e4a21" translate="yes" xml:space="preserve">
          <source>underflow</source>
          <target state="translated">underflow</target>
        </trans-unit>
        <trans-unit id="67ad5a07a2b999e38f2228365318c33459ab727a" translate="yes" xml:space="preserve">
          <source>union</source>
          <target state="translated">union</target>
        </trans-unit>
        <trans-unit id="42e184930956d048c819e40f18f94f0094d47bc6" translate="yes" xml:space="preserve">
          <source>unless</source>
          <target state="translated">unless</target>
        </trans-unit>
        <trans-unit id="679625c058dc3d2ec7b3e088cae949818bb4ef55" translate="yes" xml:space="preserve">
          <source>variables that appear in an &lt;code&gt;EQUIVALENCE&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;EQUIVALENCE&lt;/code&gt; 문에 나타나는 변수</target>
        </trans-unit>
        <trans-unit id="8e20de8c86b03fce756f44020e334524e1e43cf0" translate="yes" xml:space="preserve">
          <source>vertical tab</source>
          <target state="translated">수직 탭</target>
        </trans-unit>
        <trans-unit id="e6e6862204ddc536a1d78809a8a7a3e4e4f4e18d" translate="yes" xml:space="preserve">
          <source>was built when the compiler was configured, this option has no effect.</source>
          <target state="translated">컴파일러가 구성 될 때 빌드되었으므로이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21eb15aba4be708707af156d3f8a747af52717e8" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;a.out&lt;/code&gt; is the compiled Fortran program that you want to run. Default is a single space.</source>
          <target state="translated">때 &lt;code&gt;a.out&lt;/code&gt; 실행할 것을 컴파일 된 포트란 프로그램입니다. 기본은 단일 공간입니다.</target>
        </trans-unit>
        <trans-unit id="f138e9d634fdf24c393cc63f5b7d7f32db5395c0" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;TYPESPEC&lt;/code&gt; is a basic type (&lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;REAL&lt;/code&gt;, etc.), and where &lt;code&gt;size&lt;/code&gt; is a byte count corresponding to the storage size of a valid kind for that type. (For &lt;code&gt;COMPLEX&lt;/code&gt; variables, &lt;code&gt;size&lt;/code&gt; is the total size of the real and imaginary parts.) The statement then declares &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; to be of type &lt;code&gt;TYPESPEC&lt;/code&gt; with the appropriate kind. This is equivalent to the standard-conforming declaration</source>
          <target state="translated">여기서 &lt;code&gt;TYPESPEC&lt;/code&gt; 은 기본 유형 ( &lt;code&gt;INTEGER&lt;/code&gt; , &lt;code&gt;REAL&lt;/code&gt; 등)이고 &lt;code&gt;size&lt;/code&gt; 는 해당 유형에 유효한 종류의 스토리지 크기에 해당하는 바이트 수입니다. (내용 &lt;code&gt;COMPLEX&lt;/code&gt; 변수 &lt;code&gt;size&lt;/code&gt; 실수 및 허수 부분들의 총 크기이다.)에 대한 설명은 다음 선언 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 형으로 &lt;code&gt;TYPESPEC&lt;/code&gt; 적절한 종류. 이는 표준 준수 선언과 같습니다.</target>
        </trans-unit>
        <trans-unit id="106f049255c1037131151279d9bf42f29a26e2ce" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;k&lt;/code&gt; is the kind parameter suitable for the intended precision. As kind parameters are implementation-dependent, use the &lt;code&gt;KIND&lt;/code&gt;, &lt;code&gt;SELECTED_INT_KIND&lt;/code&gt; and &lt;code&gt;SELECTED_REAL_KIND&lt;/code&gt; intrinsics to retrieve the correct value, for instance &lt;code&gt;REAL*8 x&lt;/code&gt; can be replaced by:</source>
          <target state="translated">여기서 &lt;code&gt;k&lt;/code&gt; 는 의도 한 정밀도에 적합한 종류 매개 변수입니다. 종류 매개 변수는 구현에 따라 &lt;code&gt;KIND&lt;/code&gt; 므로 KIND , &lt;code&gt;SELECTED_INT_KIND&lt;/code&gt; 및 &lt;code&gt;SELECTED_REAL_KIND&lt;/code&gt; 내장 함수를 사용하여 올바른 값을 검색하십시오. 예를 들어 &lt;code&gt;REAL*8 x&lt;/code&gt; 는 다음으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72fe5a3c57c54d3e2df5873ea9ccfd1fc3a8e0c9" translate="yes" xml:space="preserve">
          <source>where in free-form source code only whitespace is allowed before &lt;code&gt;!GCC$&lt;/code&gt; and in fixed-form source code &lt;code&gt;!GCC$&lt;/code&gt;, &lt;code&gt;cGCC$&lt;/code&gt; or &lt;code&gt;*GCC$&lt;/code&gt; shall start in the first column.</source>
          <target state="translated">자유 형식 소스 코드에서는 &lt;code&gt;!GCC$&lt;/code&gt; 전에 공백 만 허용 되고 고정 형식 소스 코드 &lt;code&gt;!GCC$&lt;/code&gt; 에서는 &lt;code&gt;cGCC$&lt;/code&gt; 또는 &lt;code&gt;*GCC$&lt;/code&gt; 가 첫 번째 열에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="976b09a5872dfbfbe83998f6bc24c8c24ead00cf" translate="yes" xml:space="preserve">
          <source>where the C code intended for interoperating with the Fortran code then uses &lt;code&gt;#include &quot;foo.h&quot;&lt;/code&gt;.</source>
          <target state="translated">Fortran 코드와 상호 운용하기위한 C 코드는 &lt;code&gt;#include &quot;foo.h&quot;&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ba5f4a488a95f68e495af46779a064e4a2d6d895" translate="yes" xml:space="preserve">
          <source>will be ignored and no user-defined procedure with the same name as any intrinsic will be called except when it is explicitly declared &lt;code&gt;EXTERNAL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EXTERNAL&lt;/code&gt; 을 명시 적으로 선언 한 경우를 제외하고는 내장 함수와 동일한 이름의 사용자 정의 프로 시저가 무시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="98a9b25f5321a98f1dce9cf581bf7cb1bd4139f7" translate="yes" xml:space="preserve">
          <source>will cause a warning to be issued if a tab is encountered. Note,</source>
          <target state="translated">탭이 발견되면 경고가 발행됩니다. 노트,</target>
        </trans-unit>
        <trans-unit id="abd1c0581f4e0c24d7b8edaf4b7bbe5f6c665192" translate="yes" xml:space="preserve">
          <source>will compile the file with all checks enabled as specified above except warnings for generated array temporaries.</source>
          <target state="translated">생성 된 배열 임시에 대한 경고를 제외하고 위에서 지정한대로 모든 검사가 활성화 된 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="8cd24269c88b630d3e1526473ce0dc27e5552e94" translate="yes" xml:space="preserve">
          <source>will show all the predefined macros.</source>
          <target state="translated">미리 정의 된 모든 매크로가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9f286f890efae667cf8be4c3e3f0f9db0bad42" translate="yes" xml:space="preserve">
          <source>with &lt;code&gt;#include&lt;/code&gt; in the &lt;code&gt;cpp&lt;/code&gt; preprocessor, with regard to looking for</source>
          <target state="translated">와 &lt;code&gt;#include&lt;/code&gt; 에서 &lt;code&gt;cpp&lt;/code&gt; 찾고 관련하여 전처리,</target>
        </trans-unit>
        <trans-unit id="380dd5456f2c95e0b9a35505ef92da839c0c01fb" translate="yes" xml:space="preserve">
          <source>with code compiled with the default</source>
          <target state="translated">기본값으로 컴파일 된 코드</target>
        </trans-unit>
        <trans-unit id="671e80331550079d85338e454d62ec7cf1db23b8" translate="yes" xml:space="preserve">
          <source>with the following:</source>
          <target state="translated">다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="0b290e6292697adca00d7d3d5662240ab8fc30bb" translate="yes" xml:space="preserve">
          <source>would be</source>
          <target state="translated">될 것이다</target>
        </trans-unit>
        <trans-unit id="95cb0bfd2977c761298d9624e4b4d4c72a39974a" translate="yes" xml:space="preserve">
          <source>y</source>
          <target state="translated">y</target>
        </trans-unit>
        <trans-unit id="aa8c41330509455ee5679d04ed41535d280d9a89" translate="yes" xml:space="preserve">
          <source>zero</source>
          <target state="translated">zero</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
