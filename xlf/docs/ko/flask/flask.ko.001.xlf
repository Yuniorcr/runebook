<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="flask">
    <body>
      <group id="flask">
        <trans-unit id="d518ee4676b80ad78627e3058478d5d42201367e" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2007&amp;ndash;2020 Pallets</source>
          <target state="translated">&amp;copy; 2007&amp;ndash;2020 팔레트</target>
        </trans-unit>
        <trans-unit id="0dea52dadc89b7a6bcb166da37a5fa2683706699" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Hello Flaskext!&amp;rdquo;</source>
          <target state="translated">&quot;안녕하세요 Flaskext!&quot;</target>
        </trans-unit>
        <trans-unit id="b9b929fe54087453b5f1d596ec5eb8001da93dd8" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Micro&amp;rdquo; does not mean that your whole web application has to fit into a single Python file (although it certainly can), nor does it mean that Flask is lacking in functionality. The &amp;ldquo;micro&amp;rdquo; in microframework means Flask aims to keep the core simple but extensible. Flask won&amp;rsquo;t make many decisions for you, such as what database to use. Those decisions that it does make, such as what templating engine to use, are easy to change. Everything else is up to you, so that Flask can be everything you need and nothing you don&amp;rsquo;t.</source>
          <target state="translated">&quot;마이크로&quot;는 전체 웹 애플리케이션이 단일 Python 파일에 맞아야 함을 의미하지 않으며 (확실히 가능하지만) Flask에 기능이 없다는 의미도 아닙니다. 마이크로 프레임 워크의 &quot;마이크로&quot;는 Flask가 핵심을 단순하면서도 확장 가능하게 유지하는 것을 목표로한다는 것을 의미합니다. Flask는 사용할 데이터베이스와 같은 많은 결정을 내리지 않습니다. 사용할 템플릿 엔진과 같은 결정을 내리는 것은 변경하기 쉽습니다. 다른 모든 것은 당신에게 달려 있으므로 Flask는 당신이 필요로하는 모든 것이 될 수 있고 당신이 필요로하지 않는 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed4056fbc79159bda157747a2241de3ef3b7ce60" translate="yes" xml:space="preserve">
          <source>(On Windows you need to use &lt;code&gt;set&lt;/code&gt; instead of &lt;code&gt;export&lt;/code&gt;.)</source>
          <target state="translated">(Windows 에서는 &lt;code&gt;export&lt;/code&gt; 대신 &lt;code&gt;set&lt;/code&gt; 을 사용해야 합니다 .)</target>
        </trans-unit>
        <trans-unit id="531ce4e3f3b615cc5f55e3d17a55c173b8a0544a" translate="yes" xml:space="preserve">
          <source>(On Windows, use &lt;code&gt;set&lt;/code&gt; instead of &lt;code&gt;export&lt;/code&gt;.)</source>
          <target state="translated">(Windows에서는 &lt;code&gt;export&lt;/code&gt; 대신 &lt;code&gt;set&lt;/code&gt; 을 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="5a3f3fb8509928682231ec3231a525028a615239" translate="yes" xml:space="preserve">
          <source>(Want to just log errors and stack traces? See &lt;a href=&quot;../errorhandling/index#application-errors&quot;&gt;Application Errors&lt;/a&gt;)</source>
          <target state="translated">(오류 및 스택 추적 만 기록하고 싶으신가요? &lt;a href=&quot;../errorhandling/index#application-errors&quot;&gt;애플리케이션 오류&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="d89981778b9525952a642f77e691311c6dd293e1" translate="yes" xml:space="preserve">
          <source>(default) accepts any text without a slash</source>
          <target state="translated">(기본값) 슬래시가없는 모든 텍스트를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9ec858ed054f38cb94e160f72774fc041e6ff478" translate="yes" xml:space="preserve">
          <source>(nothing)</source>
          <target state="translated">(nothing)</target>
        </trans-unit>
        <trans-unit id="9130cb8188f0785b281988616eeb6d809089da04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#flask.Markup.unescape&quot;&gt;&lt;code&gt;unescape()&lt;/code&gt;&lt;/a&gt; the markup, remove tags, and normalize whitespace to single spaces.</source>
          <target state="translated">&lt;a href=&quot;#flask.Markup.unescape&quot;&gt; &lt;code&gt;unescape()&lt;/code&gt; &lt;/a&gt;마크 업을 unescape () 하고, 태그를 제거하고, 공백을 단일 공백으로 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="65805e6061a49425d7365ddd0434d4e5a2f82569" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#flask.sessions.SessionInterface.make_null_session&quot;&gt;&lt;code&gt;make_null_session()&lt;/code&gt;&lt;/a&gt; will look here for the class that should be created when a null session is requested. Likewise the &lt;a href=&quot;#flask.sessions.SessionInterface.is_null_session&quot;&gt;&lt;code&gt;is_null_session()&lt;/code&gt;&lt;/a&gt; method will perform a typecheck against this type.</source>
          <target state="translated">&lt;a href=&quot;#flask.sessions.SessionInterface.make_null_session&quot;&gt; &lt;code&gt;make_null_session()&lt;/code&gt; &lt;/a&gt; 은 null 세션이 요청 될 때 생성되어야하는 클래스를 여기에서 찾습니다. 마찬가지로&lt;a href=&quot;#flask.sessions.SessionInterface.is_null_session&quot;&gt; &lt;code&gt;is_null_session()&lt;/code&gt; &lt;/a&gt; 메서드는이 유형에 대해 유형 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="94945113cc5354d56fa9306672a00c6ae72ad7fc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/index#flask.got_request_exception&quot;&gt;&lt;code&gt;got_request_exception&lt;/code&gt;&lt;/a&gt; is sent when an exception begins to be handled, but before an &lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; is looked up or called.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.got_request_exception&quot;&gt; &lt;code&gt;got_request_exception&lt;/code&gt; &lt;/a&gt; 은 예외 처리가 시작될 때 전송되지만&lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt; 가 조회되거나 호출되기 전에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c90890ea5636a5ad9069bb81946d398bbda8ae4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/index#flask.request_finished&quot;&gt;&lt;code&gt;request_finished&lt;/code&gt;&lt;/a&gt; is sent after the &lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt;&lt;code&gt;after_request()&lt;/code&gt;&lt;/a&gt; functions are called.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.request_finished&quot;&gt; &lt;code&gt;request_finished&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;../api/index#flask.Flask.after_request&quot;&gt; &lt;code&gt;after_request()&lt;/code&gt; &lt;/a&gt; 함수가 호출 된후에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="19964118cb5b2e5624f5823a111f7dc156d2f2bc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/index#flask.request_started&quot;&gt;&lt;code&gt;request_started&lt;/code&gt;&lt;/a&gt; is sent before the &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; functions are called.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.request_started&quot;&gt; &lt;code&gt;request_started&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt; 함수가 호출되기 전에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f6b1a894ddd6e86e9da54f95316a4cbddd7249b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/index#flask.request_tearing_down&quot;&gt;&lt;code&gt;request_tearing_down&lt;/code&gt;&lt;/a&gt; is sent after the &lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt; functions are called.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.request_tearing_down&quot;&gt; &lt;code&gt;request_tearing_down&lt;/code&gt; &lt;/a&gt; 은&lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt; 함수가 호출 된후에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e6242b0037b13d337d6bf273aa5b9e086b9e054e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.gevent.org/&quot;&gt;Gevent&lt;/a&gt; is a coroutine-based Python networking library that uses &lt;a href=&quot;https://greenlet.readthedocs.io/en/latest/&quot;&gt;greenlet&lt;/a&gt; to provide a high-level synchronous API on top of &lt;a href=&quot;http://software.schmorp.de/pkg/libev.html&quot;&gt;libev&lt;/a&gt; event loop:</source>
          <target state="translated">&lt;a href=&quot;http://www.gevent.org/&quot;&gt;Gevent는&lt;/a&gt; 용도가있는 코 루틴 기반의 파이썬 네트워킹 라이브러리입니다 &lt;a href=&quot;https://greenlet.readthedocs.io/en/latest/&quot;&gt;greenlet&lt;/a&gt; 위에 높은 수준의 동기 API를 제공하는 &lt;a href=&quot;http://software.schmorp.de/pkg/libev.html&quot;&gt;libev의&lt;/a&gt; 이벤트 루프 :</target>
        </trans-unit>
        <trans-unit id="5a7895fa80d2b1575519c0724ceefb133c4410b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;strong&gt;KeyError&lt;/strong&gt;&lt;/a&gt; &amp;ndash; if the tag key is already registered and &lt;code&gt;force&lt;/code&gt; is not true.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;strong&gt;KeyError&lt;/strong&gt;&lt;/a&gt; &amp;ndash; 태그 키가 이미 등록되어 있고 &lt;code&gt;force&lt;/code&gt; 가 참이 아닌 경우입니다.</target>
        </trans-unit>
        <trans-unit id="2a6d17432cfe78a83c46a8088ca15fbe3d7e13ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.sentry.io/platforms/python/guides/flask/&quot;&gt;Flask-specific documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.sentry.io/platforms/python/guides/flask/&quot;&gt;Flask 관련 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d565dd25cb8083f2f33a41f77fb0e5addce2af31" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;python-dotenv&lt;/a&gt; enables support for &lt;a href=&quot;../cli/index#dotenv&quot;&gt;Environment Variables From dotenv&lt;/a&gt; when running &lt;code&gt;flask&lt;/code&gt; commands.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;python-dotenv&lt;/a&gt; 는 &lt;code&gt;flask&lt;/code&gt; 명령을 실행할 때 &lt;a href=&quot;../cli/index#dotenv&quot;&gt;dotenv의 환경 변수를&lt;/a&gt; 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="d8bbab9e7bb34c6875207a31abfa28df9bf24b5d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://gunicorn.org/&quot;&gt;Gunicorn&lt;/a&gt; &amp;lsquo;Green Unicorn&amp;rsquo; is a WSGI HTTP Server for UNIX. It&amp;rsquo;s a pre-fork worker model ported from Ruby&amp;rsquo;s Unicorn project. It supports both &lt;a href=&quot;https://eventlet.net/&quot;&gt;eventlet&lt;/a&gt; and &lt;a href=&quot;https://greenlet.readthedocs.io/en/latest/&quot;&gt;greenlet&lt;/a&gt;. Running a Flask application on this server is quite simple:</source>
          <target state="translated">&lt;a href=&quot;https://gunicorn.org/&quot;&gt;Gunicorn&lt;/a&gt; 'Green Unicorn'은 UNIX 용 WSGI HTTP 서버입니다. Ruby의 Unicorn 프로젝트에서 이식 된 pre-fork 작업자 모델입니다. &lt;a href=&quot;https://eventlet.net/&quot;&gt;eventlet&lt;/a&gt; 과 &lt;a href=&quot;https://greenlet.readthedocs.io/en/latest/&quot;&gt;greenlet을&lt;/a&gt; 모두 지원합니다 . 이 서버에서 Flask 애플리케이션을 실행하는 것은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="472600c67ce8d07f654d3fb06359c8114c527085" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://gunicorn.org/&quot;&gt;Gunicorn&lt;/a&gt; provides many command-line options &amp;ndash; see &lt;code&gt;gunicorn -h&lt;/code&gt;. For example, to run a Flask application with 4 worker processes (&lt;code&gt;-w
4&lt;/code&gt;) binding to localhost port 4000 (&lt;code&gt;-b 127.0.0.1:4000&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;https://gunicorn.org/&quot;&gt;Gunicorn&lt;/a&gt; 은 많은 명령 줄 옵션을 제공합니다 . &lt;code&gt;gunicorn -h&lt;/code&gt; 를 참조 하세요 . 예를 들어 4 개의 작업자 프로세스 ( &lt;code&gt;-w 4&lt;/code&gt; )가 localhost 포트 4000 ( &lt;code&gt;-b 127.0.0.1:4000&lt;/code&gt; )에 바인딩 된 Flask 애플리케이션을 실행하려면 다음을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="4f0956922c2e45871115bbce8982b5af8743e042" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; is a small JavaScript library commonly used to simplify working with the DOM and JavaScript in general. It is the perfect tool to make web applications more dynamic by exchanging JSON between server and client.</source>
          <target state="translated">&lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 는 일반적으로 DOM 및 JavaScript 작업을 단순화하는 데 일반적으로 사용되는 작은 JavaScript 라이브러리입니다. 서버와 클라이언트간에 JSON을 교환하여 웹 애플리케이션을보다 동적으로 만드는 완벽한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="a4c27b2ebf441268b2d950ac6acef9ceff1aa4c7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://palletsprojects.com/p/click/&quot;&gt;Click&lt;/a&gt; is a framework for writing command line applications. It provides the &lt;code&gt;flask&lt;/code&gt; command and allows adding custom management commands.</source>
          <target state="translated">&lt;a href=&quot;https://palletsprojects.com/p/click/&quot;&gt;Click&lt;/a&gt; 은 명령 줄 애플리케이션을 작성하기위한 프레임 워크입니다. &lt;code&gt;flask&lt;/code&gt; 명령을 제공하고 사용자 지정 관리 명령을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d564eb9e722c60bb1317c271f9893fd46bcbb52" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://palletsprojects.com/p/itsdangerous/&quot;&gt;ItsDangerous&lt;/a&gt; securely signs data to ensure its integrity. This is used to protect Flask&amp;rsquo;s session cookie.</source>
          <target state="translated">&lt;a href=&quot;https://palletsprojects.com/p/itsdangerous/&quot;&gt;ItsDangerous&lt;/a&gt; 는 무결성을 보장하기 위해 데이터에 안전하게 서명합니다. 이것은 Flask의 세션 쿠키를 보호하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11c160160d6e753a46072bceeac58d51f286b821" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://palletsprojects.com/p/jinja/&quot;&gt;Jinja&lt;/a&gt; is a template language that renders the pages your application serves.</source>
          <target state="translated">&lt;a href=&quot;https://palletsprojects.com/p/jinja/&quot;&gt;Jinja&lt;/a&gt; 는 애플리케이션이 제공하는 페이지를 렌더링하는 템플릿 언어입니다.</target>
        </trans-unit>
        <trans-unit id="85e6cf18ea4adc5a960ddbdaff872146f4b90d84" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://palletsprojects.com/p/markupsafe/&quot;&gt;MarkupSafe&lt;/a&gt; comes with Jinja. It escapes untrusted input when rendering templates to avoid injection attacks.</source>
          <target state="translated">&lt;a href=&quot;https://palletsprojects.com/p/markupsafe/&quot;&gt;MarkupSafe&lt;/a&gt; 는 Jinja와 함께 제공됩니다. 주입 공격을 피하기 위해 템플릿을 렌더링 할 때 신뢰할 수없는 입력을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="73c1564f44b95eaef06f6953c30e436ecdd78f8f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://palletsprojects.com/p/werkzeug/&quot;&gt;Werkzeug&lt;/a&gt; implements WSGI, the standard Python interface between applications and servers.</source>
          <target state="translated">&lt;a href=&quot;https://palletsprojects.com/p/werkzeug/&quot;&gt;Werkzeug&lt;/a&gt; 는 애플리케이션과 서버 간의 표준 Python 인터페이스 인 WSGI를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="cd6aa582b05147a13aef5aef69f0ddd14281f7a3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://pypi.org/project/setuptools/&quot;&gt;Setuptools&lt;/a&gt;, is an extension library that is commonly used to distribute Python libraries and extensions. It extends distutils, a basic module installation system shipped with Python to also support various more complex constructs that make larger applications easier to distribute:</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/setuptools/&quot;&gt;Setuptools&lt;/a&gt; 는 Python 라이브러리 및 확장을 배포하는 데 일반적으로 사용되는 확장 라이브러리입니다. Python과 함께 제공되는 기본 모듈 설치 시스템 인 distutils를 확장하여 더 큰 응용 프로그램을 더 쉽게 배포 할 수있는 다양하고 복잡한 구조도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="70b8c0ff8ede71cb50dd0fde2a4413379c21a3d1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://pythonhosted.org/blinker/&quot;&gt;Blinker&lt;/a&gt; provides support for &lt;a href=&quot;../signals/index#signals&quot;&gt;Signals&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://pythonhosted.org/blinker/&quot;&gt;Blinker&lt;/a&gt; 는 &lt;a href=&quot;../signals/index#signals&quot;&gt;신호&lt;/a&gt; 지원을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5d23b01202033165611d8a0b5009d5738978cdcb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://pythonhosted.org/watchdog/&quot;&gt;Watchdog&lt;/a&gt; provides a faster, more efficient reloader for the development server.</source>
          <target state="translated">&lt;a href=&quot;https://pythonhosted.org/watchdog/&quot;&gt;Watchdog&lt;/a&gt; 은 개발 서버에 더 빠르고 효율적인 리 로더를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6681a129cdef8c8594d303500b6f2798522c70b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://simplejson.readthedocs.io/&quot;&gt;SimpleJSON&lt;/a&gt; is a fast JSON implementation that is compatible with Python&amp;rsquo;s &lt;code&gt;json&lt;/code&gt; module. It is preferred for JSON operations if it is installed.</source>
          <target state="translated">&lt;a href=&quot;https://simplejson.readthedocs.io/&quot;&gt;SimpleJSON&lt;/a&gt; 은 Python의 &lt;code&gt;json&lt;/code&gt; 모듈 과 호환되는 빠른 JSON 구현입니다 . 설치된 경우 JSON 작업에 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="6e2e6ebfc4c24cd599c23777dfc091c4fe61a008" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twistedmatrix.com/trac/wiki/TwistedWeb&quot;&gt;Twisted Web&lt;/a&gt; is the web server shipped with &lt;a href=&quot;https://twistedmatrix.com/trac/&quot;&gt;Twisted&lt;/a&gt;, a mature, non-blocking event-driven networking library. Twisted Web comes with a standard WSGI container which can be controlled from the command line using the &lt;code&gt;twistd&lt;/code&gt; utility:</source>
          <target state="translated">&lt;a href=&quot;https://twistedmatrix.com/trac/wiki/TwistedWeb&quot;&gt;Twisted Web&lt;/a&gt; 은 성숙한 비 차단 이벤트 기반 네트워킹 라이브러리 인 &lt;a href=&quot;https://twistedmatrix.com/trac/&quot;&gt;Twisted&lt;/a&gt; 와 함께 제공되는 웹 서버 입니다. Twisted Web은 &lt;code&gt;twistd&lt;/code&gt; 유틸리티를 사용하여 명령 줄에서 제어 할 수있는 표준 WSGI 컨테이너와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="91d0073f5771c7940421d0a465d32609ca7e7490" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://uwsgi-docs.readthedocs.io/en/latest/&quot;&gt;uWSGI&lt;/a&gt; is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn.</source>
          <target state="translated">&lt;a href=&quot;https://uwsgi-docs.readthedocs.io/en/latest/&quot;&gt;uWSGI&lt;/a&gt; 는 C로 작성된 빠른 애플리케이션 서버입니다. 구성이 매우 가능하여 gunicorn보다 설정이 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="8a702a0a0f8f564f77025fc649a80ff83ed90efb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict&quot;&gt;&lt;code&gt;MultiDict&lt;/code&gt;&lt;/a&gt; object containing all uploaded files. Each key in &lt;a href=&quot;#flask.Request.files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt; is the name from the &lt;code&gt;&amp;lt;input type=&quot;file&quot; name=&quot;&quot;&amp;gt;&lt;/code&gt;. Each value in &lt;a href=&quot;#flask.Request.files&quot;&gt;&lt;code&gt;files&lt;/code&gt;&lt;/a&gt; is a Werkzeug &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage&quot;&gt;&lt;code&gt;FileStorage&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.MultiDict&quot;&gt; &lt;code&gt;MultiDict&lt;/code&gt; &lt;/a&gt;업로드 된 모든 파일을 포함하는 MultiDict 개체입니다. &lt;a href=&quot;#flask.Request.files&quot;&gt; &lt;code&gt;files&lt;/code&gt; &lt;/a&gt; 각 키는 &lt;code&gt;&amp;lt;input type=&quot;file&quot; name=&quot;&quot;&amp;gt;&lt;/code&gt; 입니다. &lt;a href=&quot;#flask.Request.files&quot;&gt; &lt;code&gt;files&lt;/code&gt; &lt;/a&gt; 각 값은 Werkzeug&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage&quot;&gt; &lt;code&gt;FileStorage&lt;/code&gt; &lt;/a&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="a982f899a12f0c75094410af44e9c79a9d352e30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt;&lt;code&gt;werkzeug.exceptions.HTTPException&lt;/code&gt;&lt;/a&gt; subclasses like &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.BadRequest&quot;&gt;&lt;code&gt;BadRequest&lt;/code&gt;&lt;/a&gt; and their HTTP codes are interchangeable when registering handlers. (&lt;code&gt;BadRequest.code == 400&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt; &lt;code&gt;werkzeug.exceptions.HTTPException&lt;/code&gt; &lt;/a&gt;처리기를 등록 할 때&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.BadRequest&quot;&gt; &lt;code&gt;BadRequest&lt;/code&gt; &lt;/a&gt; 및 해당 HTTP 코드와같은 werkzeug.exceptions.HTTPException 하위 클래스는 상호 교환 할 수 있습니다. ( &lt;code&gt;BadRequest.code == 400&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9edf23e4ac711ff478615faff3de2d150f268030" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.NotFound&quot;&gt;&lt;code&gt;NotFound&lt;/code&gt;&lt;/a&gt; if one or more passed paths fall out of its boundaries.</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.NotFound&quot;&gt; &lt;code&gt;NotFound&lt;/code&gt; &lt;/a&gt; 하나 이상의 전달 경로는 경계 밖으로 떨어질 경우.</target>
        </trans-unit>
        <trans-unit id="b85fcdb38da1ffb85aba4adb03f47b27e54851cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.fabfile.org/&quot;&gt;Fabric&lt;/a&gt; is a tool for Python similar to Makefiles but with the ability to execute commands on a remote server. In combination with a properly set up Python package (&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Larger Applications&lt;/a&gt;) and a good concept for configurations (&lt;a href=&quot;../../config/index#config&quot;&gt;Configuration Handling&lt;/a&gt;) it is very easy to deploy Flask applications to external servers.</source>
          <target state="translated">&lt;a href=&quot;https://www.fabfile.org/&quot;&gt;Fabric&lt;/a&gt; 은 Makefile과 유사한 Python 용 도구이지만 원격 서버에서 명령을 실행할 수있는 기능이 있습니다. 적절하게 설정된 Python 패키지 ( &lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Larger Applications&lt;/a&gt; ) 및 구성에 대한 좋은 개념 ( &lt;a href=&quot;../../config/index#config&quot;&gt;Configuration Handling&lt;/a&gt; ) 과 함께 Flask 애플리케이션을 외부 서버에 배포하는 것은 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="db3235b3038a6abb8495dbefb504d8e344e9f7fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$('selector')&lt;/code&gt; selects an element and lets you operate on it.</source>
          <target state="translated">&lt;code&gt;$('selector')&lt;/code&gt; 는 요소를 선택하고 이에 대해 작업 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="b0396579b5b9d74c0379afb7dfa00a26771cad0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$(function() { ... })&lt;/code&gt; specifies code that should run once the browser is done loading the basic parts of the page.</source>
          <target state="translated">&lt;code&gt;$(function() { ... })&lt;/code&gt; 은 브라우저가 페이지의 기본 부분을로드 한 후 실행해야하는 코드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a0fb748788b036951546b9f24a0392746d039718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$.getJSON(url, data, func)&lt;/code&gt; sends a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;url&lt;/code&gt; and will send the contents of the &lt;code&gt;data&lt;/code&gt; object as query parameters. Once the data arrived, it will call the given function with the return value as argument. Note that we can use the &lt;code&gt;$SCRIPT_ROOT&lt;/code&gt; variable here that we set earlier.</source>
          <target state="translated">&lt;code&gt;$.getJSON(url, data, func)&lt;/code&gt; 는 &lt;code&gt;url&lt;/code&gt; 에 &lt;code&gt;GET&lt;/code&gt; 요청을 보내고 &lt;code&gt;data&lt;/code&gt; 개체 의 내용을 쿼리 매개 변수로 보냅니다 . 데이터가 도착하면 반환 값을 인수로 사용하여 주어진 함수를 호출합니다. 앞서 설정 한 &lt;code&gt;$SCRIPT_ROOT&lt;/code&gt; 변수를 여기서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18d0a75842f807413113f3534b792c8caf492559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$PREFIX&lt;/code&gt; is the prefix of your Python installation. This can be &lt;code&gt;/usr&lt;/code&gt; or the path to your virtualenv. You can print the value of &lt;code&gt;sys.prefix&lt;/code&gt; to see what the prefix is set to.</source>
          <target state="translated">&lt;code&gt;$PREFIX&lt;/code&gt; 는 Python 설치의 접두사입니다. 이 될 수 &lt;code&gt;/usr&lt;/code&gt; 또는 VIRTUALENV의 경로입니다. &lt;code&gt;sys.prefix&lt;/code&gt; 의 값을 인쇄하여 접두사가 무엇으로 설정되어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c86879e512bd6eb10dbfe3000ee0814d16515dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; tag</source>
          <target state="translated">&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 태그</target>
        </trans-unit>
        <trans-unit id="c3c2d8fb0dfe9b8b241a7130b266b01781e9efa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; supported</source>
          <target state="translated">&lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; 지원됨</target>
        </trans-unit>
        <trans-unit id="98a447de4f3427fcef5d5b065b660c9bb6102327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;script/&amp;gt;&lt;/code&gt; supported</source>
          <target state="translated">&lt;code&gt;&amp;lt;script/&amp;gt;&lt;/code&gt; 지원됨</target>
        </trans-unit>
        <trans-unit id="a31e55b12e715283a365d31dee75a3daf0749d76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;tag/value/&lt;/code&gt; == &lt;code&gt;&amp;lt;tag&amp;gt;value&amp;lt;/tag&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;tag/value/&lt;/code&gt; == &lt;code&gt;&amp;lt;tag&amp;gt;value&amp;lt;/tag&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="746c7a855378092ae9fe449170ed2492ffcd04a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; tag</source>
          <target state="translated">&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 태그</target>
        </trans-unit>
        <trans-unit id="975bbe635b6c36e7eaccc2480d58b079cc36907a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FLASK_APP&lt;/code&gt; has three parts: an optional path that sets the current working directory, a Python file or dotted import path, and an optional variable name of the instance or factory. If the name is a factory, it can optionally be followed by arguments in parentheses. The following values demonstrate these parts:</source>
          <target state="translated">&lt;code&gt;FLASK_APP&lt;/code&gt; 에는 현재 작업 디렉토리를 설정하는 선택적 경로, Python 파일 또는 점으로 구분 된 가져 오기 경로, 인스턴스 또는 팩토리의 선택적 변수 이름의 세 부분이 있습니다. 이름이 팩토리 인 경우 선택적으로 괄호 안에 인수가 올 수 있습니다. 다음 값은 이러한 부분을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a0fb11ea62bed1e4c80043b75cbe031ec488e5db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HttpOnly&lt;/code&gt; protects the contents of cookies from being read with JavaScript.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; 는 쿠키의 내용이 JavaScript로 읽히지 않도록 보호합니다.</target>
        </trans-unit>
        <trans-unit id="4ea84cea1412aa766be7124a8878cf5c9a8b9c5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SameSite&lt;/code&gt; restricts how cookies are sent with requests from external sites. Can be set to &lt;code&gt;'Lax'&lt;/code&gt; (recommended) or &lt;code&gt;'Strict'&lt;/code&gt;. &lt;code&gt;Lax&lt;/code&gt; prevents sending cookies with CSRF-prone requests from external sites, such as submitting a form. &lt;code&gt;Strict&lt;/code&gt; prevents sending cookies with all external requests, including following regular links.</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; 는 외부 사이트의 요청과 함께 쿠키를 보내는 방법을 제한합니다. &lt;code&gt;'Lax'&lt;/code&gt; (권장) 또는 &lt;code&gt;'Strict'&lt;/code&gt; 로 설정할 수 있습니다 . &lt;code&gt;Lax&lt;/code&gt; 는 양식 제출과 같이 외부 사이트에서 CSRF가 발생하기 쉬운 요청으로 쿠키를 보내는 것을 방지합니다. &lt;code&gt;Strict&lt;/code&gt; 는 다음 일반 링크를 포함하여 모든 외부 요청과 함께 쿠키를 보내는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d3236772a445c1872e5d1843904ac9000ff16548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Secure&lt;/code&gt; limits cookies to HTTPS traffic only.</source>
          <target state="translated">&lt;code&gt;Secure&lt;/code&gt; 은 쿠키를 HTTPS 트래픽으로 만 제한합니다.</target>
        </trans-unit>
        <trans-unit id="4e1f8c213629c6461c191d797f7b4c19c6c3b878" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if a file was loaded.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 파일이로드 된 경우 True 입니다.</target>
        </trans-unit>
        <trans-unit id="b1d31e569e2c6d2e7618b9d203b25d3d0acda5cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if the request is secure.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 요청이 안전한 경우 True 입니다.</target>
        </trans-unit>
        <trans-unit id="0ff433bc4ab49a9115a31137f879171a86eb554c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if the session is new, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 세션이 새 세션이면 True , &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다.</target>
        </trans-unit>
        <trans-unit id="91c1a517800b5131a9b335f5f0290beee96ddcf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to &lt;code&gt;True&lt;/code&gt; yourself. Here an example:</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 세션 개체가 수정을 감지 한 경우 참 입니다. 변경 가능한 구조에 대한 수정은 자동으로 선택되지 않습니다.이 경우 속성을 직접 &lt;code&gt;True&lt;/code&gt; 로 명시 적으로 설정해야합니다 . 다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ea87cc1d34278b8dddd0b42aefa3a09099b80ce8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;True&lt;/code&gt; if the signaling system is available. This is the case when &lt;a href=&quot;https://pypi.org/project/blinker/&quot;&gt;blinker&lt;/a&gt; is installed.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 신호 시스템을 사용할 수 있으면 참 입니다. 때의 경우입니다 &lt;a href=&quot;https://pypi.org/project/blinker/&quot;&gt;점멸등이&lt;/a&gt; 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8169c6a80ada381e17d402e3903aa1da3d7c2cbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__name__&lt;/code&gt;: The name of a function is by default used as endpoint. If endpoint is provided explicitly this value is used. Additionally this will be prefixed with the name of the blueprint by default which cannot be customized from the function itself.</source>
          <target state="translated">&lt;code&gt;__name__&lt;/code&gt; : 함수의 이름은 기본적으로 끝점으로 사용됩니다. 엔드 포인트가 명시 적으로 제공되면이 값이 사용됩니다. 또한 기본적으로 함수 자체에서 사용자 정의 할 수없는 블루 프린트의 이름이 접두어로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="0a9df685baccd0775f17b1304c28201b1d6e8545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;category_filter&lt;/code&gt; filters the messages down to only those matching the provided categories.</source>
          <target state="translated">&lt;code&gt;category_filter&lt;/code&gt; 는 제공된 카테고리와 일치하는 메시지로만 메시지를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="5f0ef33d69eaa4bfd51edf2610a408d765bb20c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datetime&lt;/code&gt; objects are serialized as &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; strings.</source>
          <target state="translated">&lt;code&gt;datetime&lt;/code&gt; 객체는 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; 문자열 로 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="a1a8aec0fdea472b68178d0dc8c2e2ac58562f1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;datetime&lt;/code&gt; objects are serialized as RFC 822 datetime strings. This is the same as the HTTP date format.</source>
          <target state="translated">&lt;code&gt;datetime&lt;/code&gt; 객체는 RFC 822 datetime 문자열로 직렬화됩니다. 이것은 HTTP 날짜 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9630cfa9de15eee59ff35d285a289f503044a527" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;element.bind('event', func)&lt;/code&gt; specifies a function that should run when the user clicked on the element. If that function returns &lt;code&gt;false&lt;/code&gt;, the default behavior will not kick in (in this case, navigate to the &lt;code&gt;#&lt;/code&gt; URL).</source>
          <target state="translated">&lt;code&gt;element.bind('event', func)&lt;/code&gt; 는 사용자가 요소를 클릭했을 때 실행되어야하는 함수를 지정합니다. 해당 함수가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 기본 동작이 시작되지 않습니다 (이 경우 &lt;code&gt;#&lt;/code&gt; URL로 이동 ).</target>
        </trans-unit>
        <trans-unit id="6d3176be119a504dd754ba55119d4713b43fef8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_X()&lt;/code&gt; creates resource &lt;code&gt;X&lt;/code&gt; if it does not exist, caching it as &lt;code&gt;g.X&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_X()&lt;/code&gt; 는 존재하지 않는 경우 리소스 &lt;code&gt;X&lt;/code&gt; 를 생성 하여 &lt;code&gt;g.X&lt;/code&gt; 로 캐싱합니다 .</target>
        </trans-unit>
        <trans-unit id="fb2784ba71d886313c08c5ab558d667082003f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;jsonify&lt;/code&gt; responses will be output with newlines, spaces, and indentation for easier reading by humans. Always enabled in debug mode.</source>
          <target state="translated">&lt;code&gt;jsonify&lt;/code&gt; 응답은 사람이 쉽게 읽을 수 있도록 줄 바꿈, 공백 및 들여 쓰기로 출력됩니다. 디버그 모드에서 항상 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9ad39dd664f6fb2f43a5f7941004b4d82a447efb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;methods&lt;/code&gt;: If methods are not provided when the URL rule is added, Flask will look on the view function object itself if a &lt;code&gt;methods&lt;/code&gt; attribute exists. If it does, it will pull the information for the methods from there.</source>
          <target state="translated">&lt;code&gt;methods&lt;/code&gt; : URL 규칙이 추가 될 때 메서드가 제공되지 않은 경우, Flask는 &lt;code&gt;methods&lt;/code&gt; 속성이 존재 하는 경우보기 함수 개체 자체를 찾습니다 . 그렇다면 거기에서 메소드에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9a75c957764dd0ac561e48d56f98547b45faa26e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;provide_automatic_options&lt;/code&gt;: if this attribute is set Flask will either force enable or disable the automatic implementation of the HTTP &lt;code&gt;OPTIONS&lt;/code&gt; response. This can be useful when working with decorators that want to customize the &lt;code&gt;OPTIONS&lt;/code&gt; response on a per-view basis.</source>
          <target state="translated">&lt;code&gt;provide_automatic_options&lt;/code&gt; :이 속성이 설정되면 Flask는 HTTP &lt;code&gt;OPTIONS&lt;/code&gt; 응답 의 자동 구현을 강제로 활성화하거나 비활성화합니다 . 이것은 뷰별로 &lt;code&gt;OPTIONS&lt;/code&gt; 응답 을 사용자 정의하려는 데코레이터와 함께 작업 할 때 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10238de8f6fb16fd7d039ea5f0fce896ec3a6166" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;required_methods&lt;/code&gt;: if this attribute is set, Flask will always add these methods when registering a URL rule even if the methods were explicitly overridden in the &lt;code&gt;route()&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;required_methods&lt;/code&gt; :이 속성이 설정되면, Flask는 &lt;code&gt;route()&lt;/code&gt; 호출 에서 메서드가 명시 적으로 재정의 된 경우에도 URL 규칙을 등록 할 때 항상 이러한 메서드를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="80a99a26d0ab1e08d56705aadc5ee2c98392c2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;teardown_X()&lt;/code&gt; closes or otherwise deallocates the resource if it exists. It is registered as a &lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt;&lt;code&gt;teardown_appcontext()&lt;/code&gt;&lt;/a&gt; handler.</source>
          <target state="translated">&lt;code&gt;teardown_X()&lt;/code&gt; 는 리소스가있는 경우 리소스를 닫거나 할당을 취소합니다. &lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt; &lt;code&gt;teardown_appcontext()&lt;/code&gt; &lt;/a&gt; 핸들러 로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b5e60d40133ee70f88cc349bff1434e01260c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uwsgi&lt;/code&gt; is designed to operate on WSGI callables found in python modules.</source>
          <target state="translated">&lt;code&gt;uwsgi&lt;/code&gt; 는 파이썬 모듈에있는 WSGI 콜 러블 에서 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="57785c0779e7b30a41daa7c4f39e79f60ee523a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;with_categories&lt;/code&gt; controls whether categories are returned with message text (&lt;code&gt;True&lt;/code&gt; gives a tuple, where &lt;code&gt;False&lt;/code&gt; gives just the message text).</source>
          <target state="translated">&lt;code&gt;with_categories&lt;/code&gt; 는 카테고리가 메시지 텍스트와 함께 반환되는지 여부를 제어합니다 ( &lt;code&gt;True&lt;/code&gt; 는 튜플을 제공하고 &lt;code&gt;False&lt;/code&gt; 는 메시지 텍스트 만 제공함).</target>
        </trans-unit>
        <trans-unit id="264a75f15e8768017378ff5aa7ec6d13020c47cd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;403 Forbidden&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;403 금지&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="586a59e4b962c9b6789d54ab5c4fb70be8626ea2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;404 Not Found&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;404 찾을 수 없음&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a215ef6f36d7a15c9c4e28eadd90357881ee027" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;410 Gone&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;410 사라&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0089fa189954cfa234c9261f4e32598b6ca9227" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;500 Internal Server Error&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;500 내부 서버 오류&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c698feb1063fdd23757189804be5c20be3b972f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt;: a module:</source>
          <target state="translated">&lt;strong&gt;사례 1&lt;/strong&gt; : 모듈 :</target>
        </trans-unit>
        <trans-unit id="1ac7263ae26f8375bd73f43953ba8509bbf8115d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 2&lt;/strong&gt;: a package:</source>
          <target state="translated">&lt;strong&gt;사례 2&lt;/strong&gt; : 패키지 :</target>
        </trans-unit>
        <trans-unit id="cc7899d748508c3f6d0376c833ed567b49ea1fb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not enable debug mode when deploying in production.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로덕션에 배포 할 때는 디버그 모드를 활성화하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90464e2eb7a44300862e3bebd7dd58113e248b3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not enable development when deploying in production.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로덕션에 배포 할 때는 개발을 활성화하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6095f8a459900b1bce961926ffcfed268a91f8e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Do not reveal the secret key when posting questions or committing code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;질문을 게시하거나 코드를 커밋 할 때 비밀 키를 공개하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dd6c015e544bb312da362ed087656a8ef19ebeb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem:&lt;/strong&gt; accessing resources gives IO errors</source>
          <target state="translated">&lt;strong&gt;문제 :&lt;/strong&gt; 리소스에 액세스하면 IO 오류가 발생 함</target>
        </trans-unit>
        <trans-unit id="e1d6e604546a2b5cc0e12efc04254d0aa00007d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem:&lt;/strong&gt; application dies with an error on print</source>
          <target state="translated">&lt;strong&gt;문제 :&lt;/strong&gt; 인쇄 오류와 함께 응용 프로그램이 죽습니다.</target>
        </trans-unit>
        <trans-unit id="a7a3ecffdf761b753484f47d246a38db274b4435" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem:&lt;/strong&gt; application does not run, errorlog shows SystemExit ignored</source>
          <target state="translated">&lt;strong&gt;문제 :&lt;/strong&gt; 응용 프로그램이 실행되지 않고 오류 로그에 SystemExit 무시 됨이 표시됨</target>
        </trans-unit>
        <trans-unit id="8cdaac50d9d45221b946902f26cbb6369824df2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problem:&lt;/strong&gt; application gives permission errors</source>
          <target state="translated">&lt;strong&gt;문제 :&lt;/strong&gt; 응용 프로그램에서 권한 오류가 발생 함</target>
        </trans-unit>
        <trans-unit id="eb1917bcc07f14ce4521e82f28a99518998547b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Response&lt;/strong&gt; (&lt;em&gt;class&lt;/em&gt;) &amp;ndash; a Response class to use when instantiating a response. The default is &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Response&quot;&gt;&lt;code&gt;werkzeug.wrappers.Response&lt;/code&gt;&lt;/a&gt; if unspecified.</source>
          <target state="translated">&lt;strong&gt;Response&lt;/strong&gt; ( &lt;em&gt;class&lt;/em&gt; ) &amp;ndash; 응답을 인스턴스화 할 때 사용할 Response 클래스입니다. 기본값은 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.Response&quot;&gt; &lt;code&gt;werkzeug.wrappers.Response&lt;/code&gt; (&lt;/a&gt; 지정되지 않은 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="411b67c4fe1edc58c5eeee09275031bb5e53c7df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Something that is untested is broken.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;테스트되지 않은 것이 손상되었습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fc787f3e120c04b789d27fb663be30560c7e223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;_anchor&lt;/strong&gt; &amp;ndash; if provided this is added as anchor to the URL.</source>
          <target state="translated">&lt;strong&gt;_anchor&lt;/strong&gt; &amp;ndash; 제공되는 경우 URL에 앵커로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f85b763a336db9c59a15b107acaccdc40fa95860" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;_external&lt;/strong&gt; &amp;ndash; if set to &lt;code&gt;True&lt;/code&gt;, an absolute URL is generated. Server address can be changed via &lt;code&gt;SERVER_NAME&lt;/code&gt; configuration variable which falls back to the &lt;code&gt;Host&lt;/code&gt; header, then to the IP and port of the request.</source>
          <target state="translated">&lt;strong&gt;_external&lt;/strong&gt; &amp;ndash; &lt;code&gt;True&lt;/code&gt; 로 설정 하면 절대 URL이 생성됩니다. 서버 주소는 &lt;code&gt;Host&lt;/code&gt; 헤더 로 &lt;code&gt;SERVER_NAME&lt;/code&gt; 되는 SERVER_NAME 구성 변수를 통해 변경된 다음 요청의 IP 및 포트 로 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1595e778c5a5688e14777098e30e5dd6b68c6cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;_method&lt;/strong&gt; &amp;ndash; if provided this explicitly specifies an HTTP method.</source>
          <target state="translated">&lt;strong&gt;_method&lt;/strong&gt; &amp;ndash; 제공되는 경우 HTTP 메서드를 명시 적으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1447d3c985bc8df0dc058749bbebded427234294" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;_scheme&lt;/strong&gt; &amp;ndash; a string specifying the desired URL scheme. The &lt;code&gt;_external&lt;/code&gt; parameter must be set to &lt;code&gt;True&lt;/code&gt; or a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. The default behavior uses the same scheme as the current request, or &lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt; from the &lt;a href=&quot;../config/index#config&quot;&gt;app configuration&lt;/a&gt; if no request context is available. As of Werkzeug 0.10, this also can be set to an empty string to build protocol-relative URLs.</source>
          <target state="translated">&lt;strong&gt;_scheme&lt;/strong&gt; &amp;ndash; 원하는 URL 체계를 지정하는 문자열. &lt;code&gt;_external&lt;/code&gt; 매개 변수로 설정해야합니다 &lt;code&gt;True&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. 기본 동작은 현재 요청과 동일한 체계를 사용하거나 요청 컨텍스트를 사용할 수없는 경우 &lt;a href=&quot;../config/index#config&quot;&gt;앱 구성의 &lt;/a&gt; &lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt; 를 사용합니다. Werkzeug 0.10부터는 프로토콜 기준 URL을 빌드하기 위해 빈 문자열로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c3e6a3ad0cd6fc2919296a83cdca75e56f4949" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;add_default_commands&lt;/strong&gt; &amp;ndash; if this is True then the default run and shell commands will be added.</source>
          <target state="translated">&lt;strong&gt;add_default_commands&lt;/strong&gt; &amp;ndash; 이것이 True이면 기본 실행 및 셸 명령이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9f23232a065d560810e918918df8dac4f8e60009" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;add_etags&lt;/strong&gt; &amp;ndash; set to &lt;code&gt;False&lt;/code&gt; to disable attaching of etags.</source>
          <target state="translated">&lt;strong&gt;add_etags&lt;/strong&gt; &amp;ndash; &lt;strong&gt;etag의&lt;/strong&gt; 첨부를 비활성화 하려면 &lt;code&gt;False&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="608c490a3b7a7a5b5c6b7ddeecb0d80ef460a0fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;add_version_option&lt;/strong&gt; &amp;ndash; adds the &lt;code&gt;--version&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;add_version_option&lt;/strong&gt; &amp;ndash; &lt;code&gt;--version&lt;/code&gt; 옵션을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e03bf5e3c42d15f81d4f67e808b36124061a65d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt; &amp;ndash; App instance to use to configure the JSON decoder. Uses &lt;code&gt;current_app&lt;/code&gt; if not given, and falls back to the default encoder when not in an app context.</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt; &amp;ndash; JSON 디코더를 구성하는 데 사용할 앱 인스턴스입니다. 지정되지 않은 경우 &lt;code&gt;current_app&lt;/code&gt; 을 사용 하고 앱 컨텍스트에없는 경우 기본 인코더로 폴백합니다.</target>
        </trans-unit>
        <trans-unit id="3b37a14f60ddc45460ae1a1c3cf7bb804d61f206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt; &amp;ndash; App instance to use to configure the JSON encoder. Uses &lt;code&gt;current_app&lt;/code&gt; if not given, and falls back to the default encoder when not in an app context.</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt; &amp;ndash; JSON 인코더를 구성하는 데 사용할 앱 인스턴스입니다. 지정되지 않은 경우 &lt;code&gt;current_app&lt;/code&gt; 을 사용 하고 앱 컨텍스트에없는 경우 기본 인코더로 폴백합니다.</target>
        </trans-unit>
        <trans-unit id="dbf07ad6e8163af838c4a4bce1c3a7ac4b0d6c5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;app&lt;/strong&gt; &amp;ndash; The application this blueprint is being registered with.</source>
          <target state="translated">&lt;strong&gt;app&lt;/strong&gt; &amp;ndash;이 Blueprint가 등록되는 애플리케이션입니다.</target>
        </trans-unit>
        <trans-unit id="37787e35d235832a5664b3d22f58d07ad3f70942" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;args&lt;/strong&gt; &amp;ndash; List of strings to invoke the command with.</source>
          <target state="translated">&lt;strong&gt;args&lt;/strong&gt; &amp;ndash; 명령을 호출하는 데 사용할 문자열 목록입니다.</target>
        </trans-unit>
        <trans-unit id="88cf87f171ef909b0a6ab39071d438ab199406f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;args&lt;/strong&gt; &amp;ndash; other positional arguments passed to &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt;&lt;code&gt;EnvironBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;args&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt; &lt;code&gt;EnvironBuilder&lt;/code&gt; 에&lt;/a&gt; 전달 된 기타 위치 인수 .</target>
        </trans-unit>
        <trans-unit id="d1bcb8aa084a30c31f73af5047e40564f8bb22f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;args&lt;/strong&gt; &amp;ndash; the arguments that should be used for parsing. If not provided, &lt;code&gt;sys.argv[1:]&lt;/code&gt; is used.</source>
          <target state="translated">&lt;strong&gt;args&lt;/strong&gt; &amp;ndash; 구문 분석에 사용해야하는 인수입니다. 제공되지 않으면 &lt;code&gt;sys.argv[1:]&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a75994deebcb825c5077bcdeef7da54e5c68375" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;as_attachment&lt;/strong&gt; &amp;ndash; set to &lt;code&gt;True&lt;/code&gt; if you want to send this file with a &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; header.</source>
          <target state="translated">&lt;strong&gt;as_attachment&lt;/strong&gt; &amp;ndash; &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 헤더 와 함께이 파일을 보내려면 &lt;code&gt;True&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="cebce9f13b390132727c9d5b7e56de78fe0916f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;as_tuple&lt;/strong&gt; &amp;ndash; Returns a tuple in the form &lt;code&gt;(environ, result)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;as_tuple&lt;/strong&gt; &amp;ndash; 형식 &lt;code&gt;(environ, result)&lt;/code&gt; 의 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="23582261dff607d4d3e44b536500330ef7bdb924" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;attachment_filename&lt;/strong&gt; &amp;ndash; the filename for the attachment if it differs from the file&amp;rsquo;s filename.</source>
          <target state="translated">&lt;strong&gt;attachment_filename&lt;/strong&gt; &amp;ndash; 파일의 파일 이름과 다른 경우 첨부 파일의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2b6a8d9ecfbee14997e91e976ecbd1c424b8c4f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;attribute&lt;/strong&gt; &amp;ndash; the name of the variable of macro to access</source>
          <target state="translated">&lt;strong&gt;attribute&lt;/strong&gt; &amp;ndash; 액세스 할 매크로 변수의 이름</target>
        </trans-unit>
        <trans-unit id="a228e2c624c314757358b46ea25ef7facc6dc542" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;base_url&lt;/strong&gt; &amp;ndash; Base URL where the app is being served, which &lt;code&gt;path&lt;/code&gt; is relative to. If not given, built from &lt;a href=&quot;../config/index#PREFERRED_URL_SCHEME&quot;&gt;&lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;subdomain&lt;/code&gt;, &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../config/index#APPLICATION_ROOT&quot;&gt;&lt;code&gt;APPLICATION_ROOT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;base_url&lt;/strong&gt; &amp;ndash; 앱이 제공되는 기본 URL 이며 상대 &lt;code&gt;path&lt;/code&gt; 입니다. 지정하지 않으면 &lt;a href=&quot;../config/index#PREFERRED_URL_SCHEME&quot;&gt; &lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;subdomain&lt;/code&gt; , &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt; &lt;code&gt;SERVER_NAME&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../config/index#APPLICATION_ROOT&quot;&gt; &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; &lt;/a&gt; 에서 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="e08852aa3e0cd48c5aed0e4b5f80a597e45b1b97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;blueprint&lt;/strong&gt; &amp;ndash; The blueprint to register.</source>
          <target state="translated">&lt;strong&gt;청사진&lt;/strong&gt; &amp;ndash; 등록 할 청사진입니다.</target>
        </trans-unit>
        <trans-unit id="60f5182daf9b0ea6fb9f318ff89d978dfc6d8de2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;buffered&lt;/strong&gt; &amp;ndash; Set this to True to buffer the application run. This will automatically close the application for you as well.</source>
          <target state="translated">&lt;strong&gt;buffered&lt;/strong&gt; &amp;ndash; 응용 프로그램 실행을 버퍼링하려면 True로 설정합니다. 그러면 자동으로 응용 프로그램도 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="5facf81498e0079ef55bd5885dca94b969d9d0d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cache&lt;/strong&gt; &amp;ndash; Store the parsed JSON to return for subsequent calls.</source>
          <target state="translated">&lt;strong&gt;cache&lt;/strong&gt; &amp;ndash; 후속 호출을 위해 반환 할 구문 분석 된 JSON을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2ac78ada69a3b300cd9537ca5ddd12a0fd5fc107" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cache_timeout&lt;/strong&gt; &amp;ndash; the timeout in seconds for the headers. When &lt;code&gt;None&lt;/code&gt; (default), this value is set by &lt;a href=&quot;#flask.Flask.get_send_file_max_age&quot;&gt;&lt;code&gt;get_send_file_max_age()&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;cache_timeout&lt;/strong&gt; &amp;ndash; 헤더의 제한 시간 (초). 때 &lt;code&gt;None&lt;/code&gt; (기본값),이 값은 설정되지 않습니다 &lt;a href=&quot;#flask.Flask.get_send_file_max_age&quot;&gt; &lt;code&gt;get_send_file_max_age()&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b95bf3677403aad595b54105245fad6970996e9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;category&lt;/strong&gt; &amp;ndash; the category for the message. The following values are recommended: &lt;code&gt;'message'&lt;/code&gt; for any kind of message, &lt;code&gt;'error'&lt;/code&gt; for errors, &lt;code&gt;'info'&lt;/code&gt; for information messages and &lt;code&gt;'warning'&lt;/code&gt; for warnings. However any kind of string can be used as category.</source>
          <target state="translated">&lt;strong&gt;category&lt;/strong&gt; &amp;ndash; 메시지의 카테고리. 다음 값이 권장됩니다. 모든 종류의 메시지에 대한 &lt;code&gt;'message'&lt;/code&gt; , &lt;code&gt;'error'&lt;/code&gt; 대한 'error' , 정보 메시지에 대한 &lt;code&gt;'info'&lt;/code&gt; 및 &lt;code&gt;'warning'&lt;/code&gt; 대한 'warning' . 그러나 모든 종류의 문자열을 범주로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82e097c0d2eec0c45ac59180d1b717bb03240315" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;category_filter&lt;/strong&gt; &amp;ndash; whitelist of categories to limit return values</source>
          <target state="translated">&lt;strong&gt;category_filter&lt;/strong&gt; &amp;ndash; 반환 값을 제한하는 카테고리 허용 목록</target>
        </trans-unit>
        <trans-unit id="c985221253ea980e81e81f3f2a2fcf4887d98cd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;cli&lt;/strong&gt; &amp;ndash; Command object to invoke. Default is the app&amp;rsquo;s &lt;code&gt;cli&lt;/code&gt; group.</source>
          <target state="translated">&lt;strong&gt;cli&lt;/strong&gt; &amp;ndash; 호출 할 명령 개체입니다. 기본값은 앱의 &lt;code&gt;cli&lt;/code&gt; 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="cfca5efe6070315aabe88f6e28752f88293b5ba8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;code&lt;/strong&gt; &amp;ndash; the redirect status code. defaults to 302.</source>
          <target state="translated">&lt;strong&gt;code&lt;/strong&gt; &amp;ndash; 리디렉션 상태 코드입니다. 기본값은 302입니다.</target>
        </trans-unit>
        <trans-unit id="0cf85909f70be6f596494909631b27ba9f83ba88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;code_or_exception&lt;/strong&gt; &amp;ndash; the code as integer for the handler, or an arbitrary exception</source>
          <target state="translated">&lt;strong&gt;code_or_exception&lt;/strong&gt; &amp;ndash; 핸들러의 정수 코드 또는 임의의 예외</target>
        </trans-unit>
        <trans-unit id="cb0a12c6366f65d82e0b4aef42334074aa309e23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;complete_var&lt;/strong&gt; &amp;ndash; the environment variable that controls the bash completion support. The default is &lt;code&gt;&quot;_&amp;lt;prog_name&amp;gt;_COMPLETE&quot;&lt;/code&gt; with prog_name in uppercase.</source>
          <target state="translated">&lt;strong&gt;complete_var&lt;/strong&gt; &amp;ndash; bash 완료 지원을 제어하는 ​​환경 변수입니다. 기본값은 &lt;code&gt;&quot;_&amp;lt;prog_name&amp;gt;_COMPLETE&quot;&lt;/code&gt; 이며 prog_name은 대문자입니다.</target>
        </trans-unit>
        <trans-unit id="9accb05414012ef286c63ec9b579daea95d27af6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;conditional&lt;/strong&gt; &amp;ndash; set to &lt;code&gt;True&lt;/code&gt; to enable conditional responses.</source>
          <target state="translated">&lt;strong&gt;조건부&lt;/strong&gt; &amp;ndash; 조건부 응답을 사용 하려면 &lt;code&gt;True&lt;/code&gt; 로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="436acc8b138a85e3690042f03a0e9f2f14edd79f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context&lt;/strong&gt; &amp;ndash; the context as a dictionary that is updated in place to add extra variables.</source>
          <target state="translated">&lt;strong&gt;context&lt;/strong&gt; &amp;ndash; 추가 변수를 추가하기 위해 업데이트되는 사전으로서의 컨텍스트.</target>
        </trans-unit>
        <trans-unit id="bd01e1e0132c6d08fb0ecf0023b73a015ef8554c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;context&lt;/strong&gt; &amp;ndash; the variables that should be available in the context of the template.</source>
          <target state="translated">&lt;strong&gt;context&lt;/strong&gt; &amp;ndash; 템플릿 컨텍스트에서 사용할 수 있어야하는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="567ed41b221e0ca33f73ac9f8c40aff5a35564b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;create_app&lt;/strong&gt; &amp;ndash; an optional callback that is passed the script info and returns the loaded app.</source>
          <target state="translated">&lt;strong&gt;create_app&lt;/strong&gt; &amp;ndash; 스크립트 정보를 전달하고로드 된 앱을 반환하는 선택적 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="6ff12fd0afca22f74b91d9848d29f3f36010bcd5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; The request body, either as a string or a dict of form keys and values.</source>
          <target state="translated">&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; 요청 본문 (문자열 또는 양식 키 및 값의 사전).</target>
        </trans-unit>
        <trans-unit id="7563b4004e7b60a5c2bbaf7ee1b0854a837d3a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;debug&lt;/strong&gt; &amp;ndash; if given, enable or disable debug mode. See &lt;a href=&quot;#flask.Flask.debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;debug&lt;/strong&gt; &amp;ndash; 제공된 경우 디버그 모드를 활성화 또는 비활성화합니다. &lt;a href=&quot;#flask.Flask.debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba6db865977753c19ecb2e202717006b6d05e0de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default&lt;/strong&gt; &amp;ndash; Value to return if the attribute is not present, instead of raise a &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;default&lt;/strong&gt; &amp;ndash; &lt;code&gt;KeyError&lt;/code&gt; 를 발생 시키는 대신 속성이없는 경우 반환 할 값 입니다.</target>
        </trans-unit>
        <trans-unit id="8b4572637e651e0f86ec9a59440ad45428ed70ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;default&lt;/strong&gt; &amp;ndash; Value to return if the attribute is not present.</source>
          <target state="translated">&lt;strong&gt;default&lt;/strong&gt; &amp;ndash; 속성이없는 경우 반환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="b527da7cfddf0d56f7594c808e2531d58ce6ddea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;defaults&lt;/strong&gt; &amp;ndash; an optional dictionary of default values</source>
          <target state="translated">&lt;strong&gt;defaults&lt;/strong&gt; &amp;ndash; &lt;strong&gt;기본값&lt;/strong&gt; 의 선택적 사전</target>
        </trans-unit>
        <trans-unit id="966c23751131e64ded89a8b47948169db277bcc8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;directory&lt;/strong&gt; &amp;ndash; the directory where all the files are stored.</source>
          <target state="translated">&lt;strong&gt;directory&lt;/strong&gt; &amp;ndash; 모든 파일이 저장되는 디렉토리.</target>
        </trans-unit>
        <trans-unit id="b5b20d4a849059ef8928b86c8dac536a1639b541" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;directory&lt;/strong&gt; &amp;ndash; the trusted base directory.</source>
          <target state="translated">&lt;strong&gt;directory&lt;/strong&gt; &amp;ndash; 신뢰할 수있는 기본 디렉터리입니다.</target>
        </trans-unit>
        <trans-unit id="bad95a09a377f167eef559ed125ab766f0f6c846" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;domain&lt;/strong&gt; &amp;ndash; if you want to set a cross-domain cookie. For example, &lt;code&gt;domain=&quot;.example.com&quot;&lt;/code&gt; will set a cookie that is readable by the domain &lt;code&gt;www.example.com&lt;/code&gt;, &lt;code&gt;foo.example.com&lt;/code&gt; etc. Otherwise, a cookie will only be readable by the domain that set it.</source>
          <target state="translated">&lt;strong&gt;도메인&lt;/strong&gt; &amp;ndash; 교차 도메인 쿠키를 설정하려는 경우. 예를 들어 &lt;code&gt;domain=&quot;.example.com&quot;&lt;/code&gt; 은 도메인 &lt;code&gt;www.example.com&lt;/code&gt; , &lt;code&gt;foo.example.com&lt;/code&gt; 등에서 읽을 수있는 쿠키를 설정합니다 . 그렇지 않으면 쿠키를 설정 한 도메인에서만 쿠키를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee5560037f44164bef111fd58579a2a6e0b969be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;endpoint&lt;/strong&gt; &amp;ndash; the endpoint for the registered URL rule. Flask itself assumes the name of the view function as endpoint</source>
          <target state="translated">&lt;strong&gt;끝점&lt;/strong&gt; &amp;ndash; 등록 된 URL 규칙의 끝점입니다. Flask 자체는 뷰 함수의 이름을 끝점으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b2eb3921e28e6378054eae42bee38e98f883a6c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;endpoint&lt;/strong&gt; &amp;ndash; the endpoint of the URL (name of the function)</source>
          <target state="translated">&lt;strong&gt;endpoint&lt;/strong&gt; &amp;ndash; URL의 끝점 (함수 이름)</target>
        </trans-unit>
        <trans-unit id="715d8c6a09bc16ccd980823bef52a18df5d84795" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;endpoint&lt;/strong&gt; &amp;ndash; the name of the endpoint</source>
          <target state="translated">&lt;strong&gt;끝점&lt;/strong&gt; &amp;ndash; &lt;strong&gt;끝점&lt;/strong&gt; 의 이름</target>
        </trans-unit>
        <trans-unit id="5f892f1f744bf320a73a941e61f6e5b07ad9995f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;environ&lt;/strong&gt; &amp;ndash; A WSGI environment.</source>
          <target state="translated">&lt;strong&gt;environ&lt;/strong&gt; &amp;ndash; WSGI 환경.</target>
        </trans-unit>
        <trans-unit id="f1bcd7588bf2c2054cd86d8184e59ed8b857dd81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;environ&lt;/strong&gt; &amp;ndash; a WSGI environment</source>
          <target state="translated">&lt;strong&gt;environ&lt;/strong&gt; &amp;ndash; WSGI 환경</target>
        </trans-unit>
        <trans-unit id="2c7f830e0dc9310dd0dcda54773ee2d85fbce1a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;exc&lt;/strong&gt; &amp;ndash; An unhandled exception raised while dispatching the request. Detected from the current exception information if not passed. Passed to each teardown function.</source>
          <target state="translated">&lt;strong&gt;exc&lt;/strong&gt; &amp;ndash; 요청을 디스패치하는 동안 발생한 처리되지 않은 예외. 전달되지 않은 경우 현재 예외 정보에서 감지되었습니다. 각 분해 기능에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="71b5b11a26fc0578539c3ab4992d1a00c8775177" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;expires&lt;/strong&gt; &amp;ndash; should be a &lt;code&gt;datetime&lt;/code&gt; object or UNIX timestamp.</source>
          <target state="translated">&lt;strong&gt;expires&lt;/strong&gt; &amp;ndash; &lt;code&gt;datetime&lt;/code&gt; 객체 또는 UNIX 타임 스탬프 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b14aac71e1eb0514b3b289e23e64c0f25473f3c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;extra&lt;/strong&gt; &amp;ndash; extra keyword arguments are forwarded to the context constructor. See &lt;code&gt;Context&lt;/code&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;extra&lt;/strong&gt; &amp;ndash; 추가 키워드 인수가 컨텍스트 생성자에 전달됩니다. 자세한 내용은 &lt;code&gt;Context&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5dca546864148d56bd3f25e8e7150140e9292f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;f&lt;/strong&gt; &amp;ndash; the WSGI callable to decorate</source>
          <target state="translated">&lt;strong&gt;f&lt;/strong&gt; &amp;ndash; 꾸미기위한 WSGI 콜 러블</target>
        </trans-unit>
        <trans-unit id="1cb1c39ea52dc019fd095830470039c3288662ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filename&lt;/strong&gt; &amp;ndash; the filename of the JSON file. This can either be an absolute filename or a filename relative to the root path.</source>
          <target state="translated">&lt;strong&gt;filename&lt;/strong&gt; &amp;ndash; JSON 파일의 파일 이름입니다. 이것은 절대 파일 이름이거나 루트 경로에 상대적인 파일 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ab7156117ed679a38cc0008eae23a622f8c40a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filename&lt;/strong&gt; &amp;ndash; the filename of the config. This can either be an absolute filename or a filename relative to the root path.</source>
          <target state="translated">&lt;strong&gt;filename&lt;/strong&gt; &amp;ndash; 구성의 파일 이름입니다. 이것은 절대 파일 이름이거나 루트 경로에 상대적인 파일 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a5de9b615bfa684c62e5597d91b4a1055a872ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filename&lt;/strong&gt; &amp;ndash; the filename relative to that directory to download.</source>
          <target state="translated">&lt;strong&gt;filename&lt;/strong&gt; &amp;ndash; 다운로드 할 해당 디렉토리에 상대적인 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6d322a6c67a48ebae00b57a4e147abbef3ca17a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filename_or_fp&lt;/strong&gt; &amp;ndash; the filename of the file to send. This is relative to the &lt;a href=&quot;#flask.Flask.root_path&quot;&gt;&lt;code&gt;root_path&lt;/code&gt;&lt;/a&gt; if a relative path is specified. Alternatively a file object might be provided in which case &lt;code&gt;X-Sendfile&lt;/code&gt; might not work and fall back to the traditional method. Make sure that the file pointer is positioned at the start of data to send before calling &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;filename_or_fp&lt;/strong&gt; &amp;ndash; 보낼 파일의 파일 이름입니다. 상대 경로가 지정된 경우 이는 &lt;a href=&quot;#flask.Flask.root_path&quot;&gt; &lt;code&gt;root_path&lt;/code&gt; &lt;/a&gt; 에 상대적입니다. 또는 &lt;code&gt;X-Sendfile&lt;/code&gt; 이 작동하지 않고 기존 방법으로 대체 될 수있는 파일 객체가 제공 될 수 있습니다 . &lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 파일 포인터가 전송할 데이터의 시작 위치에 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b243c6201da775366011fe3e7e1e8c251530c231" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;first_registration&lt;/strong&gt; &amp;ndash; Whether this is the first time this blueprint has been registered on the application.</source>
          <target state="translated">&lt;strong&gt;first_registration&lt;/strong&gt; &amp;ndash;이 Blueprint가 애플리케이션에 처음 등록되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="0c5c406c93fe42c8ef13ef5e92a06e3d3ba36e00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;follow_redirects&lt;/strong&gt; &amp;ndash; Set this to True if the &lt;code&gt;Client&lt;/code&gt; should follow HTTP redirects.</source>
          <target state="translated">&lt;strong&gt;follow_redirects&lt;/strong&gt; &amp;ndash; &lt;code&gt;Client&lt;/code&gt; 가 HTTP 리디렉션을 따라야 하는 경우이를 True로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6cb0062857f946730a45b909bd69cc590d53dd51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;force&lt;/strong&gt; &amp;ndash; Ignore the mimetype and always try to parse JSON.</source>
          <target state="translated">&lt;strong&gt;force&lt;/strong&gt; &amp;ndash; MIME 유형을 무시하고 항상 JSON 구문 분석을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="92112810027c67d9b6792923b7dd2679b7f72e31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;force&lt;/strong&gt; &amp;ndash; overwrite an existing tag. If false (default), a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;strong&gt;force&lt;/strong&gt; &amp;ndash; 기존 태그를 덮어 씁니다. false (기본값)이면 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b17302a6588d2c188c83a62e198d63eea8ecba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;host&lt;/strong&gt; &amp;ndash; the hostname to listen on. Set this to &lt;code&gt;'0.0.0.0'&lt;/code&gt; to have the server available externally as well. Defaults to &lt;code&gt;'127.0.0.1'&lt;/code&gt; or the host in the &lt;code&gt;SERVER_NAME&lt;/code&gt; config variable if present.</source>
          <target state="translated">&lt;strong&gt;host&lt;/strong&gt; &amp;ndash; 수신 할 호스트 이름. 서버를 외부에서도 사용할 수 있도록하려면 이것을 &lt;code&gt;'0.0.0.0'&lt;/code&gt; 으로 설정하십시오 . 기본값은 &lt;code&gt;'127.0.0.1'&lt;/code&gt; 또는 &lt;code&gt;SERVER_NAME&lt;/code&gt; 구성 변수 의 호스트 (있는 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="86c370d64230ab4ee40d4af15be746adee8d4b5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;host_matching&lt;/strong&gt; &amp;ndash; set &lt;code&gt;url_map.host_matching&lt;/code&gt; attribute. Defaults to False.</source>
          <target state="translated">&lt;strong&gt;host_matching&lt;/strong&gt; &amp;ndash; &lt;code&gt;url_map.host_matching&lt;/code&gt; 속성을 설정 합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="c6abfc3fd60a142efad961727eba950cfe4696e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;httponly&lt;/strong&gt; &amp;ndash; disallow JavaScript to access the cookie. This is an extension to the cookie standard and probably not supported by all browsers.</source>
          <target state="translated">&lt;strong&gt;httponly&lt;/strong&gt; &amp;ndash; JavaScript가 쿠키에 액세스하는 것을 허용하지 않습니다. 이것은 쿠키 표준의 확장이며 모든 브라우저에서 지원되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc1c4bf93cb56cb42972a3aa6f81234dcccf558a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;import_name&lt;/strong&gt; &amp;ndash; The name of the blueprint package, usually &lt;code&gt;__name__&lt;/code&gt;. This helps locate the &lt;code&gt;root_path&lt;/code&gt; for the blueprint.</source>
          <target state="translated">&lt;strong&gt;import_name&lt;/strong&gt; &amp;ndash; 블루 프린트 패키지의 이름, 일반적으로 &lt;code&gt;__name__&lt;/code&gt; . 이는 블루 프린트 의 &lt;code&gt;root_path&lt;/code&gt; 를 찾는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcb74794c3d0d61273113000a619afa0150c7bce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;import_name&lt;/strong&gt; &amp;ndash; the name of the application package</source>
          <target state="translated">&lt;strong&gt;import_name&lt;/strong&gt; &amp;ndash; 애플리케이션 패키지의 이름</target>
        </trans-unit>
        <trans-unit id="4f91914607be62ff620695373d2b333f2de9db31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;index&lt;/strong&gt; &amp;ndash; index to insert the new tag in the tag order. Useful when the new tag is a special case of an existing tag. If &lt;code&gt;None&lt;/code&gt; (default), the tag is appended to the end of the order.</source>
          <target state="translated">&lt;strong&gt;index&lt;/strong&gt; &amp;ndash; 태그 순서에 새 태그를 삽입하는 인덱스입니다. 새 태그가 기존 태그의 특수한 경우에 유용합니다. 경우 &lt;code&gt;None&lt;/code&gt; (기본값), 태그는 순서의 끝에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba583a2c3dccbae2f348febde867610db8de4f9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;installation manager&lt;/strong&gt;: &lt;strong&gt;pip&lt;/strong&gt; can install other libraries for you.</source>
          <target state="translated">&lt;strong&gt;설치 관리자&lt;/strong&gt; : &lt;strong&gt;pip&lt;/strong&gt; 는 다른 라이브러리를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e237783436526a4dbaf8a1a8216564f65f960f82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;instance_path&lt;/strong&gt; &amp;ndash; An alternative instance path for the application. By default the folder &lt;code&gt;'instance'&lt;/code&gt; next to the package or module is assumed to be the instance path.</source>
          <target state="translated">&lt;strong&gt;instance_path&lt;/strong&gt; &amp;ndash; 응용 프로그램의 대체 인스턴스 경로입니다. 기본적으로 패키지 또는 모듈 옆의 &lt;code&gt;'instance'&lt;/code&gt; 폴더 는 인스턴스 경로로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a96923e1e1d0bb10ac916e97ee22707b6b284e21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;instance_relative_config&lt;/strong&gt; &amp;ndash; if set to &lt;code&gt;True&lt;/code&gt; relative filenames for loading the config are assumed to be relative to the instance path instead of the application root.</source>
          <target state="translated">&lt;strong&gt;instance_relative_config&lt;/strong&gt; &amp;ndash; &lt;code&gt;True&lt;/code&gt; 로 설정된 경우 구성을로드하기위한 상대 파일 이름은 응용 프로그램 루트가 아닌 인스턴스 경로에 상대적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="233542655672f9caab9f52e00cb2eee8eeb306f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;json&lt;/strong&gt; &amp;ndash; If given, this is serialized as JSON and passed as &lt;code&gt;data&lt;/code&gt;. Also defaults &lt;code&gt;content_type&lt;/code&gt; to &lt;code&gt;application/json&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;json&lt;/strong&gt; &amp;ndash; 제공되는 경우 JSON으로 직렬화되고 &lt;code&gt;data&lt;/code&gt; 전달됩니다 . 또한 &lt;code&gt;content_type&lt;/code&gt; 을 &lt;code&gt;application/json&lt;/code&gt; 으로 기본 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="20bababe99e1be9594e2bb0c9974fe55cda58a3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;key&lt;/strong&gt; &amp;ndash; the key (name) of the cookie to be set.</source>
          <target state="translated">&lt;strong&gt;key&lt;/strong&gt; &amp;ndash; 설정할 쿠키의 키 (이름)입니다.</target>
        </trans-unit>
        <trans-unit id="f8e0eef1f9bb1a0200cab8b9e78f7736ecd3e56f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;kwargs&lt;/strong&gt; &amp;ndash; Extra arguments passed to &lt;a href=&quot;https://docs.python.org/3/library/json.html#json.dumps&quot;&gt;&lt;code&gt;json.dumps()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;kwargs&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/3/library/json.html#json.dumps&quot;&gt; &lt;code&gt;json.dumps()&lt;/code&gt; &lt;/a&gt; 전달 된 추가 인수 .</target>
        </trans-unit>
        <trans-unit id="644840f93feb77f79303ee2c707aa05a89f72d47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;kwargs&lt;/strong&gt; &amp;ndash; other keyword arguments passed to &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt;&lt;code&gt;EnvironBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;kwargs&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt; &lt;code&gt;EnvironBuilder&lt;/code&gt; 에&lt;/a&gt; 전달 된 기타 키워드 인수 .</target>
        </trans-unit>
        <trans-unit id="328399b8acbd1e22ad94652c48f0592e8b8906b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;last_modified&lt;/strong&gt; &amp;ndash; set the &lt;code&gt;Last-Modified&lt;/code&gt; header to this value, a &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; or timestamp. If a file was passed, this overrides its mtime.</source>
          <target state="translated">&lt;strong&gt;last_modified&lt;/strong&gt; &amp;ndash; &lt;code&gt;Last-Modified&lt;/code&gt; 헤더를이 값, &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 또는 timestamp로 설정합니다. 파일이 전달되면 mtime을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="9e3edb5f3799659366d8469b680ec30ab00d3303" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;load_dotenv&lt;/strong&gt; &amp;ndash; Load the nearest &lt;code&gt;.env&lt;/code&gt; and &lt;code&gt;.flaskenv&lt;/code&gt; files to set environment variables. Will also change the working directory to the directory containing the first file found.</source>
          <target state="translated">&lt;strong&gt;load_dotenv&lt;/strong&gt; &amp;ndash; 가장 가까운 &lt;code&gt;.env&lt;/code&gt; 및 &lt;code&gt;.flaskenv&lt;/code&gt; 파일을 로드하여 환경 변수를 설정합니다. 또한 작업 디렉토리를 찾은 첫 번째 파일이 포함 된 디렉토리로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="fb9259596f24c3b95d94b25aa3dad4cab66fe87d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;location&lt;/strong&gt; &amp;ndash; the location the response should redirect to.</source>
          <target state="translated">&lt;strong&gt;위치&lt;/strong&gt; &amp;ndash; 응답이 리디렉션되어야하는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="cfa78e8e12ae03fa578950a522088cca5df93006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;lowercase&lt;/strong&gt; &amp;ndash; a flag indicating if the keys of the resulting dictionary should be lowercase</source>
          <target state="translated">&lt;strong&gt;소문자&lt;/strong&gt; &amp;ndash; 결과 사전의 키가 &lt;strong&gt;소문자 여야&lt;/strong&gt; 하는지 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="341507770f7f23ece6752ad0185313bb18a98df1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;max_age&lt;/strong&gt; &amp;ndash; should be a number of seconds, or &lt;code&gt;None&lt;/code&gt; (default) if the cookie should last only as long as the client&amp;rsquo;s browser session.</source>
          <target state="translated">&lt;strong&gt;max_age&lt;/strong&gt; &amp;ndash; 시간 (초)이거나 쿠키가 클라이언트의 브라우저 세션 동안 만 지속되어야하는 경우 &lt;code&gt;None&lt;/code&gt; (기본값)이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9b9e378667506600bae479abb7484f59412dc7e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;message&lt;/strong&gt; &amp;ndash; the message to be flashed.</source>
          <target state="translated">&lt;strong&gt;message&lt;/strong&gt; &amp;ndash; 깜박일 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="83abaed0475e11c5dde04305f8e3692fc8f92c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mimetype&lt;/strong&gt; &amp;ndash; the mimetype of the file if provided. If a file path is given, auto detection happens as fallback, otherwise an error will be raised.</source>
          <target state="translated">&lt;strong&gt;mimetype&lt;/strong&gt; &amp;ndash; 제공된 경우 파일의 MIME 유형입니다. 파일 경로가 제공되면 자동 감지가 대체로 발생하고 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8fca33211b8363f7bd1d42f537d4b3666e63820b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mode&lt;/strong&gt; &amp;ndash; Open file in this mode. Only reading is supported, valid values are &amp;ldquo;r&amp;rdquo; (or &amp;ldquo;rt&amp;rdquo;) and &amp;ldquo;rb&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;mode&lt;/strong&gt; &amp;ndash;이 모드에서 파일을 엽니 다. 읽기만 지원되며 유효한 값은 &quot;r&quot;(또는 &quot;rt&quot;) 및 &quot;rb&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3221b90ec75d5af5e416ae14d47ed39a687dfadf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mode&lt;/strong&gt; &amp;ndash; resource file opening mode, default is &amp;lsquo;rb&amp;rsquo;.</source>
          <target state="translated">&lt;strong&gt;mode&lt;/strong&gt; &amp;ndash; 리소스 파일 열기 모드, 기본값은 'rb'입니다.</target>
        </trans-unit>
        <trans-unit id="6eefdbc1e241938ab196d36c1a6a08cde6a760af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; Name of attribute to get.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; 가져올 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="71880a7d1a09f14383780d930ed9dd0b071ebdad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; Name of attribute to pop.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; 팝업 할 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9fae89b5d7a4b2e0d0b6f61434c499fa833bcfd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; The name of the blueprint. Will be prepended to each endpoint name.</source>
          <target state="translated">&lt;strong&gt;이름&lt;/strong&gt; &amp;ndash; 청사진의 이름입니다. 각 엔드 포인트 이름 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ce95bfb5395d0eb5de5b2344a61f26643041f839" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; the optional name of the filter, otherwise the function name will be used.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; 필터의 선택적 이름. 그렇지 않으면 함수 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a8d0f4a1f689fc86b2632d5b129e0bd41e90051" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; the optional name of the global function, otherwise the function name will be used.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; 전역 함수의 선택적 이름. 그렇지 않으면 함수 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="23fcade274165f87a767fc3d9050b92cf7c48ed2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; the optional name of the global, otherwise the function name will be used.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; 글로벌의 선택적 이름. 그렇지 않으면 함수 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76f060be3e4ec9eb75bc2094253c4413d21a3e9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; the optional name of the test, otherwise the function name will be used.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; 테스트의 선택적 이름. 그렇지 않으면 함수 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3443af278f6c89d30edeaafaf6c849e230f0414a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;namespace&lt;/strong&gt; &amp;ndash; a configuration namespace</source>
          <target state="translated">&lt;strong&gt;네임 스페이스&lt;/strong&gt; &amp;ndash; 구성 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="09f6744c9ffc17ea40fc7e54317b18225c43b912" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj&lt;/strong&gt; &amp;ndash; Object to serialize to JSON.</source>
          <target state="translated">&lt;strong&gt;obj&lt;/strong&gt; &amp;ndash; JSON으로 직렬화 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b9954097bf5706b9d236899858c29b202cafaedd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj&lt;/strong&gt; &amp;ndash; an import name or object</source>
          <target state="translated">&lt;strong&gt;obj&lt;/strong&gt; &amp;ndash; 가져 오기 이름 또는 개체</target>
        </trans-unit>
        <trans-unit id="45883785729a9ca6fff35a1f93ab5b82a6a65429" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; Additional keyword arguments are passed to &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt;&lt;code&gt;BlueprintSetupState&lt;/code&gt;&lt;/a&gt;. They can be accessed in &lt;a href=&quot;#flask.Blueprint.record&quot;&gt;&lt;code&gt;record()&lt;/code&gt;&lt;/a&gt; callbacks.</source>
          <target state="translated">&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; 추가 키워드 인수가 &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt; &lt;code&gt;BlueprintSetupState&lt;/code&gt; 에&lt;/a&gt; 전달됩니다 . &lt;a href=&quot;#flask.Blueprint.record&quot;&gt; &lt;code&gt;record()&lt;/code&gt; &lt;/a&gt; 콜백 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20c0918b0f29f6c5d49b69e6bcb7f6865e8d1a78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; Keyword arguments forwarded from &lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt;&lt;code&gt;register_blueprint()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt; &lt;code&gt;register_blueprint()&lt;/code&gt; &lt;/a&gt; 에서 전달 된 키워드 인수 .</target>
        </trans-unit>
        <trans-unit id="63fd14ff3e936f5aa5b55e19b61fc482f5d9044f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; optional keyword arguments that are directly forwarded to &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; &lt;/a&gt; 직접 전달되는 선택적 키워드 인수 .</target>
        </trans-unit>
        <trans-unit id="0cfd35d594098c111cd3256a2ece7c2e59090363" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; the options to be forwarded to the underlying &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt;&lt;code&gt;Rule&lt;/code&gt;&lt;/a&gt; object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; etc.). By default a rule just listens for &lt;code&gt;GET&lt;/code&gt; (and implicitly &lt;code&gt;HEAD&lt;/code&gt;). Starting with Flask 0.6, &lt;code&gt;OPTIONS&lt;/code&gt; is implicitly added and handled by the standard request handling.</source>
          <target state="translated">&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; 기본 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt; &lt;code&gt;Rule&lt;/code&gt; &lt;/a&gt; 객체 로 전달할 옵션 입니다. Werkzeug의 변경 사항은 메소드 옵션 처리입니다. methods는이 규칙이 제한되어야하는 메서드 목록입니다 ( &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 등). 기본적으로 규칙은 &lt;code&gt;GET&lt;/code&gt; (및 암시 적으로 &lt;code&gt;HEAD&lt;/code&gt; ) 만 수신합니다 . Flask 0.6부터 &lt;code&gt;OPTIONS&lt;/code&gt; 는 표준 요청 처리에 의해 암시 적으로 추가되고 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="acde59954db3e79b78a4399703b7183b6850bfc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; the options to be forwarded to the underlying Werkzeug server. See &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt;&lt;code&gt;werkzeug.serving.run_simple()&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;strong&gt;options&lt;/strong&gt; &amp;ndash; 기본 Werkzeug 서버로 전달할 옵션입니다. 자세한 내용은 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt; &lt;code&gt;werkzeug.serving.run_simple()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4b91c31816a15754693895030e4bc812d600a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;package registry&lt;/strong&gt;: setuptools registers your package with your Python installation. This makes it possible to query information provided by one package from another package. The best known feature of this system is the entry point support which allows one package to declare an &amp;ldquo;entry point&amp;rdquo; that another package can hook into to extend the other package.</source>
          <target state="translated">&lt;strong&gt;package registry&lt;/strong&gt; : setuptools는 Python 설치에 패키지를 등록합니다. 이를 통해 한 패키지가 제공하는 정보를 다른 패키지에서 쿼리 할 수 ​​있습니다. 이 시스템의 가장 잘 알려진 기능은 한 패키지가 다른 패키지를 확장하기 위해 연결할 수있는 &quot;진입 지점&quot;을 선언 할 수있는 진입 점 지원입니다.</target>
        </trans-unit>
        <trans-unit id="4651aafe54b0b3efe08850be207249afdb946617" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path&lt;/strong&gt; &amp;ndash; Load the file at this location instead of searching.</source>
          <target state="translated">&lt;strong&gt;경로&lt;/strong&gt; &amp;ndash; 검색하는 대신이 위치에서 파일을로드합니다.</target>
        </trans-unit>
        <trans-unit id="616809a2b19be481cfef32d2c30be25b47a487a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path&lt;/strong&gt; &amp;ndash; URL path being requested.</source>
          <target state="translated">&lt;strong&gt;path&lt;/strong&gt; &amp;ndash; 요청중인 URL 경로입니다.</target>
        </trans-unit>
        <trans-unit id="64e3dcc1fc99ee5f72e7717ac10b6d90665f578c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path&lt;/strong&gt; &amp;ndash; limits the cookie to a given path, per default it will span the whole domain.</source>
          <target state="translated">&lt;strong&gt;경로&lt;/strong&gt; &amp;ndash; 쿠키를 지정된 경로로 제한하며 기본적으로 전체 도메인에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="1547b9b759195c1bf4fce9f654fb421c815e9ce6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;pathnames&lt;/strong&gt; &amp;ndash; the untrusted pathnames relative to that directory.</source>
          <target state="translated">&lt;strong&gt;pathnames&lt;/strong&gt; &amp;ndash; 해당 디렉토리에 상대적인 신뢰할 수없는 경로 이름.</target>
        </trans-unit>
        <trans-unit id="9dbc57aa22e3ce50d65f9ec92b784d030742b924" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;port&lt;/strong&gt; &amp;ndash; the port of the webserver. Defaults to &lt;code&gt;5000&lt;/code&gt; or the port defined in the &lt;code&gt;SERVER_NAME&lt;/code&gt; config variable if present.</source>
          <target state="translated">&lt;strong&gt;port&lt;/strong&gt; &amp;ndash; 웹 서버의 포트. 기본값은 &lt;code&gt;5000&lt;/code&gt; 또는 &lt;code&gt;SERVER_NAME&lt;/code&gt; 구성 변수 (있는 경우)에 정의 된 포트 입니다.</target>
        </trans-unit>
        <trans-unit id="62b17d46b038075847273f6d8e88c6e866ad377a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;prog_name&lt;/strong&gt; &amp;ndash; the program name that should be used. By default the program name is constructed by taking the file name from &lt;code&gt;sys.argv[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;prog_name&lt;/strong&gt; &amp;ndash; 사용해야하는 프로그램 이름. 기본적으로 프로그램 이름은 &lt;code&gt;sys.argv[0]&lt;/code&gt; 에서 파일 이름을 사용하여 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae0eeab87bd56487427841a3f0860c76160f7a52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;provide_automatic_options&lt;/strong&gt; &amp;ndash; controls whether the &lt;code&gt;OPTIONS&lt;/code&gt; method should be added automatically. This can also be controlled by setting the &lt;code&gt;view_func.provide_automatic_options = False&lt;/code&gt; before adding the rule.</source>
          <target state="translated">&lt;strong&gt;provide_automatic_options&lt;/strong&gt; &amp;ndash; &lt;code&gt;OPTIONS&lt;/code&gt; 메소드가 자동으로 추가되어야 하는지 여부를 제어합니다 . 규칙을 추가하기 전에 &lt;code&gt;view_func.provide_automatic_options = False&lt;/code&gt; 를 설정하여 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b152617d548ba0b03f8171a3a574efefa172471" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;request&lt;/strong&gt; &amp;ndash; an instance of &lt;a href=&quot;#flask.Flask.request_class&quot;&gt;&lt;code&gt;request_class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;request&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;#flask.Flask.request_class&quot;&gt; &lt;code&gt;request_class&lt;/code&gt; &lt;/a&gt; 의 인스턴스 .</target>
        </trans-unit>
        <trans-unit id="6ec94dfa7647b3552d6221d5884a774d1334e7af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;resource&lt;/strong&gt; &amp;ndash; the name of the resource. To access resources within subfolders use forward slashes as separator.</source>
          <target state="translated">&lt;strong&gt;자원&lt;/strong&gt; &amp;ndash; &lt;strong&gt;자원&lt;/strong&gt; 의 이름. 하위 폴더 내의 리소스에 액세스하려면 슬래시를 구분 기호로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee9b13dbad768d5c2f557d9416f58257f023e6a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;response&lt;/strong&gt; &amp;ndash; a &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;strong&gt;response&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="94138dc48a11b641d919e8ad2fc83e01ba77f4f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;response&lt;/strong&gt; &amp;ndash; an instance of &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;응답&lt;/strong&gt; - 인스턴스 &lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="838218d17dfba493873c47fbc2bfecfaece04b8b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;root_path&lt;/strong&gt; &amp;ndash; By default, the blueprint will automatically this based on &lt;code&gt;import_name&lt;/code&gt;. In certain situations this automatic detection can fail, so the path can be specified manually instead.</source>
          <target state="translated">&lt;strong&gt;root_path&lt;/strong&gt; &amp;ndash; 기본적으로 Blueprint는 &lt;code&gt;import_name&lt;/code&gt; 을 기반으로 자동으로이를 수행 합니다. 특정 상황에서이 자동 감지가 실패 할 수 있으므로 대신 수동으로 경로를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7d4dd605a6153d7e6092a1f948e6ebf4e7a6269" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;root_path&lt;/strong&gt; &amp;ndash; Flask by default will automatically calculate the path to the root of the application. In certain situations this cannot be achieved (for instance if the package is a Python 3 namespace package) and needs to be manually defined.</source>
          <target state="translated">&lt;strong&gt;root_path&lt;/strong&gt; &amp;ndash; 기본적으로 Flask는 응용 프로그램의 루트 경로를 자동으로 계산합니다. 특정 상황에서는이를 달성 할 수 없으며 (예 : 패키지가 Python 3 네임 스페이스 패키지 인 경우) 수동으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="0de3b7ef6cf94a3875eeec18bdf3efd8c4a41f40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;root_path&lt;/strong&gt; &amp;ndash; path to which files are read relative from. When the config object is created by the application, this is the application&amp;rsquo;s &lt;a href=&quot;#flask.Flask.root_path&quot;&gt;&lt;code&gt;root_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;root_path&lt;/strong&gt; &amp;ndash; 상대적으로 파일을 읽을 경로입니다. 구성 객체가 응용 프로그램에 의해 생성되면 이것은 응용 프로그램의 &lt;a href=&quot;#flask.Flask.root_path&quot;&gt; &lt;code&gt;root_path&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d3b8771cc9fe0c3d20ad6d12e73da6ced124021" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rule&lt;/strong&gt; &amp;ndash; the URL rule as string</source>
          <target state="translated">&lt;strong&gt;rule&lt;/strong&gt; &amp;ndash; URL 규칙 (문자열)</target>
        </trans-unit>
        <trans-unit id="6eaaddbe3c3e69fa5b71f13a9ebcc3cc5fccdd51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rv&lt;/strong&gt; &amp;ndash;</source>
          <target state="translated">&lt;strong&gt;rv&lt;/strong&gt; &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="b95eaf1af945c8c6bd20efa56e9ede33cd08d71a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;s&lt;/strong&gt; &amp;ndash; JSON string to deserialize.</source>
          <target state="translated">&lt;strong&gt;s&lt;/strong&gt; &amp;ndash; 역 직렬화 할 JSON 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="42a589dce52343199459383329b4d931b13763f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;samesite&lt;/strong&gt; &amp;ndash; Limits the scope of the cookie such that it will only be attached to requests if those requests are &amp;ldquo;same-site&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;samesite&lt;/strong&gt; &amp;ndash; 요청이 &quot;동일 사이트&quot;인 경우에만 요청에 첨부되도록 쿠키의 범위를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="ceddad5eb9b07ac149c718e003962beb5ca775d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;secure&lt;/strong&gt; &amp;ndash; If &lt;code&gt;True&lt;/code&gt;, the cookie will only be available via HTTPS</source>
          <target state="translated">&lt;strong&gt;secure&lt;/strong&gt; &amp;ndash; &lt;code&gt;True&lt;/code&gt; 인 경우 쿠키는 HTTPS를 통해서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb43fa9182a4ffa8037c2310458a0feb63b724d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;session&lt;/strong&gt; &amp;ndash; the session to be saved (a &lt;code&gt;SecureCookie&lt;/code&gt; object)</source>
          <target state="translated">&lt;strong&gt;session&lt;/strong&gt; &amp;ndash; 저장할 세션 ( &lt;code&gt;SecureCookie&lt;/code&gt; 객체)</target>
        </trans-unit>
        <trans-unit id="cc698330dd71198b795cc28c41456151b3da349e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;set_debug_flag&lt;/strong&gt; &amp;ndash; Set the app&amp;rsquo;s debug flag based on the active environment</source>
          <target state="translated">&lt;strong&gt;set_debug_flag&lt;/strong&gt; &amp;ndash; 활성 환경을 기반으로 앱의 디버그 플래그 설정</target>
        </trans-unit>
        <trans-unit id="1ff4595f55bb6d1a9c333e706d65881c01cb6e59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;silent&lt;/strong&gt; &amp;ndash; Silence parsing errors and return &lt;code&gt;None&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt;silent&lt;/strong&gt; &amp;ndash; 구문 분석 오류를 차단하고 대신 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b82bed6f63753e6ee4f8f3b99342863e4608a427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;silent&lt;/strong&gt; &amp;ndash; set to &lt;code&gt;True&lt;/code&gt; if you want silent failure for missing files.</source>
          <target state="translated">&lt;strong&gt;silent&lt;/strong&gt; &amp;ndash; 누락 된 파일에 대한 자동 실패를 원하는 경우 &lt;code&gt;True&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="64a139cf485a0698b6fc63a1906d5c4decb255b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;source&lt;/strong&gt; &amp;ndash; the source code of the template to be rendered</source>
          <target state="translated">&lt;strong&gt;source&lt;/strong&gt; &amp;ndash; 렌더링 할 템플릿의 소스 코드</target>
        </trans-unit>
        <trans-unit id="2a1934ff83305c7b43db5df1d07634a8d55c23bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;standalone_mode&lt;/strong&gt; &amp;ndash; the default behavior is to invoke the script in standalone mode. Click will then handle exceptions and convert them into error messages and the function will never return but shut down the interpreter. If this is set to &lt;code&gt;False&lt;/code&gt; they will be propagated to the caller and the return value of this function is the return value of &lt;code&gt;invoke()&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;standalone_mode&lt;/strong&gt; &amp;ndash; 기본 동작은 독립형 모드에서 스크립트를 호출하는 것입니다. 그런 다음 Click은 예외를 처리하고 오류 메시지로 변환하며 함수는 반환되지 않고 인터프리터를 종료합니다. &lt;code&gt;False&lt;/code&gt; 로 설정 하면 호출자에게 전파되고이 함수의 반환 값은 &lt;code&gt;invoke()&lt;/code&gt; 의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="bd6707148fd29a9b7cf10c41d91b2563ece080a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start_response&lt;/strong&gt; &amp;ndash; A callable accepting a status code, a list of headers, and an optional exception context to start the response.</source>
          <target state="translated">&lt;strong&gt;start_response&lt;/strong&gt; &amp;ndash; 상태 코드, 헤더 목록 및 응답을 시작하기위한 선택적 예외 컨텍스트를 수락하는 콜 &lt;strong&gt;러블&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a38b56ef2f5c4468fdb63f07a9ca3f865b531bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;static_folder&lt;/strong&gt; &amp;ndash; A folder with static files that should be served by the blueprint&amp;rsquo;s static route. The path is relative to the blueprint&amp;rsquo;s root path. Blueprint static files are disabled by default.</source>
          <target state="translated">&lt;strong&gt;static_folder&lt;/strong&gt; &amp;ndash; Blueprint의 정적 경로에서 제공해야하는 정적 파일이있는 폴더입니다. 경로는 Blueprint의 루트 경로에 상대적입니다. 블루 프린트 정적 파일은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0792f5e1146067466be3321b475a3e54e270e8ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;static_folder&lt;/strong&gt; &amp;ndash; The folder with static files that is served at &lt;code&gt;static_url_path&lt;/code&gt;. Relative to the application &lt;code&gt;root_path&lt;/code&gt; or an absolute path. Defaults to &lt;code&gt;'static'&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;static_folder&lt;/strong&gt; -으로 제공됩니다 정적 파일과 폴더 &lt;code&gt;static_url_path&lt;/code&gt; . 응용 프로그램 &lt;code&gt;root_path&lt;/code&gt; 또는 절대 경로에 상대적 입니다. 기본값은 &lt;code&gt;'static'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d75cee46de5939c97c2dbf9f3a5b4dcf51d690c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;static_host&lt;/strong&gt; &amp;ndash; the host to use when adding the static route. Defaults to None. Required when using &lt;code&gt;host_matching=True&lt;/code&gt; with a &lt;code&gt;static_folder&lt;/code&gt; configured.</source>
          <target state="translated">&lt;strong&gt;static_host&lt;/strong&gt; &amp;ndash; 정적 경로를 추가 할 때 사용할 호스트입니다. 기본값은 없음입니다. &lt;code&gt;static_folder&lt;/code&gt; 가 구성된 &lt;code&gt;host_matching=True&lt;/code&gt; 를 사용할 때 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="636e1339c26731ba765922a3fafce45cd370d8ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;static_url_path&lt;/strong&gt; &amp;ndash; The url to serve static files from. Defaults to &lt;code&gt;static_folder&lt;/code&gt;. If the blueprint does not have a &lt;code&gt;url_prefix&lt;/code&gt;, the app&amp;rsquo;s static route will take precedence, and the blueprint&amp;rsquo;s static files won&amp;rsquo;t be accessible.</source>
          <target state="translated">&lt;strong&gt;static_url_path&lt;/strong&gt; &amp;ndash; 정적 파일을 제공 할 URL입니다. 기본값은 &lt;code&gt;static_folder&lt;/code&gt; 입니다. 블루 프린트에 &lt;code&gt;url_prefix&lt;/code&gt; 가 없으면 앱의 정적 경로가 우선 적용되며 블루 프린트의 정적 파일에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2c7eeb12209f130ea71e49d9876d5e23d174d1e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;static_url_path&lt;/strong&gt; &amp;ndash; can be used to specify a different path for the static files on the web. Defaults to the name of the &lt;code&gt;static_folder&lt;/code&gt; folder.</source>
          <target state="translated">&lt;strong&gt;static_url_path&lt;/strong&gt; &amp;ndash; 웹에서 정적 파일에 대해 다른 경로를 지정하는 데 사용할 수 있습니다. 기본값은 &lt;code&gt;static_folder&lt;/code&gt; 폴더 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="43de4e96f5888d465bae1ccc9861692a8491c5df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;subdomain&lt;/strong&gt; &amp;ndash; A subdomain that blueprint routes will match on by default.</source>
          <target state="translated">&lt;strong&gt;하위 도메인&lt;/strong&gt; &amp;ndash; Blueprint 경로가 기본적으로 일치하는 하위 도메인입니다.</target>
        </trans-unit>
        <trans-unit id="28bb932225862f7e5066663987e458c136fd1fd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;subdomain&lt;/strong&gt; &amp;ndash; Blueprint routes will match on this subdomain.</source>
          <target state="translated">&lt;strong&gt;하위 도메인&lt;/strong&gt; &amp;ndash; 블루 프린트 경로가이 하위 도메인에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="89d1ddcdf4dce18e70405d776c3cffc8e5ae1ba0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;subdomain&lt;/strong&gt; &amp;ndash; Subdomain name to append to &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;subdomain&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt; &lt;code&gt;SERVER_NAME&lt;/code&gt; &lt;/a&gt; 에 추가 할 하위 도메인 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="28f1ce45cd5c09ca98e9ce5025533da7a78db9b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;subdomain_matching&lt;/strong&gt; &amp;ndash; consider the subdomain relative to &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;/a&gt; when matching routes. Defaults to False.</source>
          <target state="translated">&lt;strong&gt;subdomain_matching&lt;/strong&gt; &amp;ndash; 경로를 일치시킬 때 &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt; &lt;code&gt;SERVER_NAME&lt;/code&gt; 에&lt;/a&gt; 상대적인 하위 도메인을 고려합니다 . 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="f046344fb991494cfc8ee13ae6fec25a29336574" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;support for dependencies&lt;/strong&gt;: a library or application can declare a list of other libraries it depends on which will be installed automatically for you.</source>
          <target state="translated">&lt;strong&gt;의존성 지원&lt;/strong&gt; : 라이브러리 또는 애플리케이션은 자동으로 설치 될 다른 라이브러리 목록을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52010c2493a4864b79c4bbbae3428f0c5955aa55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tag_class&lt;/strong&gt; &amp;ndash; tag class to register. Will be instantiated with this serializer instance.</source>
          <target state="translated">&lt;strong&gt;tag_class&lt;/strong&gt; &amp;ndash; 등록 할 태그 클래스. 이 serializer 인스턴스로 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="a75441c29c39f78a649f4538e43cf30ef8a11788" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;template_folder&lt;/strong&gt; &amp;ndash; A folder with templates that should be added to the app&amp;rsquo;s template search path. The path is relative to the blueprint&amp;rsquo;s root path. Blueprint templates are disabled by default. Blueprint templates have a lower precedence than those in the app&amp;rsquo;s templates folder.</source>
          <target state="translated">&lt;strong&gt;template_folder&lt;/strong&gt; &amp;ndash; 앱의 템플릿 검색 경로에 추가해야하는 템플릿이있는 폴더입니다. 경로는 Blueprint의 루트 경로에 상대적입니다. 블루 프린트 템플릿은 기본적으로 비활성화되어 있습니다. 블루 프린트 템플릿은 앱의 템플릿 폴더에있는 템플릿보다 우선 순위가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="b134dfa058aff59df5a8f3dad11fe5004684b1e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;template_folder&lt;/strong&gt; &amp;ndash; the folder that contains the templates that should be used by the application. Defaults to &lt;code&gt;'templates'&lt;/code&gt; folder in the root path of the application.</source>
          <target state="translated">&lt;strong&gt;template_folder&lt;/strong&gt; &amp;ndash; 응용 프로그램에서 사용해야하는 템플릿이 포함 된 폴더입니다. 기본값 은 응용 프로그램의 루트 경로에있는 &lt;code&gt;'templates'&lt;/code&gt; 폴더입니다.</target>
        </trans-unit>
        <trans-unit id="78ad3456f1e1d5f215f966fc6df4dbf3b23a4564" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;template_name&lt;/strong&gt; &amp;ndash; the name of the template</source>
          <target state="translated">&lt;strong&gt;template_name&lt;/strong&gt; &amp;ndash; &lt;strong&gt;템플릿&lt;/strong&gt; 의 이름</target>
        </trans-unit>
        <trans-unit id="be08cfdbf4304955f3c4f6d7159667d9ff895284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;template_name_or_list&lt;/strong&gt; &amp;ndash; the name of the template to be rendered, or an iterable with template names the first one existing will be rendered</source>
          <target state="translated">&lt;strong&gt;template_name_or_list&lt;/strong&gt; &amp;ndash; 렌더링 할 템플릿의 이름, 또는 처음 존재하는 템플릿 이름이있는 iterable이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="8c7a73816a41bd97ccb7f96c095d7faf63ca4e09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;trim_namespace&lt;/strong&gt; &amp;ndash; a flag indicating if the keys of the resulting dictionary should not include the namespace</source>
          <target state="translated">&lt;strong&gt;trim_namespace&lt;/strong&gt; &amp;ndash; 결과 딕셔너리의 키에 네임 스페이스가 포함되지 않아야하는지 여부를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="a1df9c9f71715518d521ca7c9ab97f53ddc18b9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;url_defaults&lt;/strong&gt; &amp;ndash; A dict of default values that blueprint routes will receive by default.</source>
          <target state="translated">&lt;strong&gt;url_defaults&lt;/strong&gt; &amp;ndash; 블루 프린트 라우트가 기본적으로 수신 할 기본값의 사전입니다.</target>
        </trans-unit>
        <trans-unit id="041e919e409b4a2e66d21f7ed719244b7a4ead48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;url_defaults&lt;/strong&gt; &amp;ndash; Blueprint routes will use these default values for view arguments.</source>
          <target state="translated">&lt;strong&gt;url_defaults&lt;/strong&gt; &amp;ndash; 블루 프린트 라우트는 뷰 인수에이 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b9cc976587c1aac4187b91b7493c8a2420429fb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;url_prefix&lt;/strong&gt; &amp;ndash; A path to prepend to all of the blueprint&amp;rsquo;s URLs, to make them distinct from the rest of the app&amp;rsquo;s routes.</source>
          <target state="translated">&lt;strong&gt;url_prefix&lt;/strong&gt; &amp;ndash; 앱의 나머지 경로와 구별되도록 모든 Blueprint의 URL 앞에 추가 할 경로입니다.</target>
        </trans-unit>
        <trans-unit id="f7f2fe1dd2fc43a6ea07decc9bd7de936fa594bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;url_prefix&lt;/strong&gt; &amp;ndash; Blueprint routes will be prefixed with this.</source>
          <target state="translated">&lt;strong&gt;url_prefix&lt;/strong&gt; &amp;ndash; 블루 프린트 라우트에이 접두사가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="d52c3f8fa8bfa44568e1d2b8c68184d204345d41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;url_scheme&lt;/strong&gt; &amp;ndash; Scheme to use instead of &lt;a href=&quot;../config/index#PREFERRED_URL_SCHEME&quot;&gt;&lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;url_scheme&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;../config/index#PREFERRED_URL_SCHEME&quot;&gt; &lt;code&gt;PREFERRED_URL_SCHEME&lt;/code&gt; &lt;/a&gt; 대신 사용할 체계 .</target>
        </trans-unit>
        <trans-unit id="7d5037fc2f8c82bc073044c9938dfef0ed80d7b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value&lt;/strong&gt; &amp;ndash; the value of the cookie.</source>
          <target state="translated">&lt;strong&gt;value&lt;/strong&gt; &amp;ndash; 쿠키의 값.</target>
        </trans-unit>
        <trans-unit id="026d77bd8f2cf9d11fd1fcf1941ef90e01ae50e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;values&lt;/strong&gt; &amp;ndash; the variable arguments of the URL rule</source>
          <target state="translated">&lt;strong&gt;values&lt;/strong&gt; &amp;ndash; URL 규칙의 변수 인수</target>
        </trans-unit>
        <trans-unit id="afe3909c51c5dd518fc5ec8446070e9a35f915b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;variable_name&lt;/strong&gt; &amp;ndash; name of the environment variable</source>
          <target state="translated">&lt;strong&gt;variable_name&lt;/strong&gt; &amp;ndash; 환경 변수의 이름</target>
        </trans-unit>
        <trans-unit id="aa3c8e695730991824b688f4d438175f363598e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;view_func&lt;/strong&gt; &amp;ndash; the function to call when serving a request to the provided endpoint</source>
          <target state="translated">&lt;strong&gt;view_func&lt;/strong&gt; &amp;ndash; 제공된 엔드 포인트에 요청을 제공 할 때 호출 할 함수</target>
        </trans-unit>
        <trans-unit id="e293ef0644700b0ed58cc9cf00f447f987e009a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;with_categories&lt;/strong&gt; &amp;ndash; set to &lt;code&gt;True&lt;/code&gt; to also receive categories.</source>
          <target state="translated">&lt;strong&gt;with_categories&lt;/strong&gt; &amp;ndash; 카테고리도 수신 하려면 &lt;code&gt;True&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="4335ddcceeadc3c2980168f3d242e2e9008f888d" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;favicon&amp;rdquo; is an icon used by browsers for tabs and bookmarks. This helps to distinguish your website and to give it a unique brand.</source>
          <target state="translated">&quot;파비콘&quot;은 브라우저에서 탭과 북마크에 사용하는 아이콘입니다. 이렇게하면 웹 사이트를 구별하고 고유 한 브랜드를 부여하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dc085f3b5d831be583daaae065343cf9dd73051f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; can add handlers for these events that are specific to the blueprint. The handlers for a blueprint will run if the blueprint owns the route that matches the request.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt; 청사진에 고유 한 이러한 이벤트에 대한 처리기를 추가 할 수 있습니다. Blueprint가 요청과 일치하는 경로를 소유하면 Blueprint에 대한 핸들러가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8cf6544702b00c1cf49361d5d7c487c20fdc22f2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner&quot;&gt;&lt;code&gt;CliRunner&lt;/code&gt;&lt;/a&gt; for testing a Flask app&amp;rsquo;s CLI commands. Typically created using &lt;a href=&quot;#flask.Flask.test_cli_runner&quot;&gt;&lt;code&gt;test_cli_runner()&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;../testing/index#testing-cli&quot;&gt;Testing CLI Commands&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner&quot;&gt; &lt;code&gt;CliRunner&lt;/code&gt; &lt;/a&gt; 플라스 크 응용 프로그램의 CLI 명령을 테스트. 일반적으로 &lt;a href=&quot;#flask.Flask.test_cli_runner&quot;&gt; &lt;code&gt;test_cli_runner()&lt;/code&gt; &lt;/a&gt; 사용하여 생성됩니다 . &lt;a href=&quot;../testing/index#testing-cli&quot;&gt;CLI 명령 테스트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20941e86e984d7a85b36ba57ef58dcb2bf4f9086" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; which is used as default cache_timeout for the &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt; functions. The default is 12 hours.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 에 대한 기본 cache_timeout로 사용 &lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; &lt;/a&gt; 함수. 기본값은 12 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b8edb7ada96e4aed24b77e4d67610d222c9cc85b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; which is used to set the expiration date of a permanent session. The default is 31 days which makes a permanent session survive for roughly one month.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 영구 세션의 유효 기간을 설정하는 데 사용됩니다. 기본값은 31 일이며 영구 세션은 대략 한 달 동안 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b457d5ab81cf21b08672a9090c915aa457cdc524" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; with the contents of all cookies transmitted with the request.</source>
          <target state="translated">요청과 함께 전송 된 모든 쿠키의 내용이 포함 된 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a499f563648ad62aa50de74d59d98dfbaac9bb50" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.CombinedMultiDict&quot;&gt;&lt;code&gt;werkzeug.datastructures.CombinedMultiDict&lt;/code&gt;&lt;/a&gt; that combines &lt;a href=&quot;#flask.Request.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.Request.form&quot;&gt;&lt;code&gt;form&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#flask.Request.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#flask.Request.form&quot;&gt; &lt;code&gt;form&lt;/code&gt; &lt;/a&gt; 을 결합 하는 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.CombinedMultiDict&quot;&gt; &lt;code&gt;werkzeug.datastructures.CombinedMultiDict&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2fa30b4bddca6906d7577cce861c27765dae15c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.Headers&quot;&gt;&lt;code&gt;Headers&lt;/code&gt;&lt;/a&gt; object representing the response headers.</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.Headers&quot;&gt; &lt;code&gt;Headers&lt;/code&gt; &lt;/a&gt; 응답 헤더를 나타내는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="6642f19f183bb71c8f314208a5214be3a49d9502" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.RequestCacheControl&quot;&gt;&lt;code&gt;RequestCacheControl&lt;/code&gt;&lt;/a&gt; object for the incoming cache control headers.</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.RequestCacheControl&quot;&gt; &lt;code&gt;RequestCacheControl&lt;/code&gt; 는&lt;/a&gt; 들어오는 캐시 제어 헤더에 대한 객체.</target>
        </trans-unit>
        <trans-unit id="19b9de965b0e40a9ffe87881eaa522535109a99f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag is marked with &lt;code&gt;enctype=multipart/form-data&lt;/code&gt; and an &lt;code&gt;&amp;lt;input type=file&amp;gt;&lt;/code&gt; is placed in that form.</source>
          <target state="translated">&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그로 표시되는 &lt;code&gt;enctype=multipart/form-data&lt;/code&gt; 및 &lt;code&gt;&amp;lt;input type=file&amp;gt;&lt;/code&gt; 이 형태로 배치된다.</target>
        </trans-unit>
        <trans-unit id="ce4516b136c5bf25d0b2a0f5d2f80c7b2dd69d8e" translate="yes" xml:space="preserve">
          <source>A Gentle Introduction</source>
          <target state="translated">부드러운 소개</target>
        </trans-unit>
        <trans-unit id="4d38a89fdf3cd17e8a79ed93a3db0e50a5e35ed0" translate="yes" xml:space="preserve">
          <source>A Minimal Application</source>
          <target state="translated">최소한의 애플리케이션</target>
        </trans-unit>
        <trans-unit id="39706d28b9141573035b4927993c2623672a7bbb" translate="yes" xml:space="preserve">
          <source>A Python web application based on WSGI has to have one central callable object that implements the actual application. In Flask this is an instance of the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; class. Each Flask application has to create an instance of this class itself and pass it the name of the module, but why can&amp;rsquo;t Flask do that itself?</source>
          <target state="translated">WSGI를 기반으로하는 Python 웹 애플리케이션에는 실제 애플리케이션을 구현하는 하나의 중앙 호출 가능 개체가 있어야합니다. Flask에서 이것은 &lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 클래스 의 인스턴스입니다 . 각 Flask 애플리케이션은이 클래스 자체의 인스턴스를 만들고 모듈 이름을 전달해야하지만 Flask가 자체적으로 수행 할 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1f01334abc2e009bc8e41c2daeae9b2af970ed8f" translate="yes" xml:space="preserve">
          <source>A basic &lt;code&gt;setup.py&lt;/code&gt; file for a Flask application looks like this:</source>
          <target state="translated">Flask 애플리케이션 의 기본 &lt;code&gt;setup.py&lt;/code&gt; 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="538357571bbc255d4d781423e527f50d623c1218" translate="yes" xml:space="preserve">
          <source>A basic FastCGI configuration for lighttpd looks like that:</source>
          <target state="translated">lighttpd에 대한 기본 FastCGI 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f48e6ec2be15786faa6c603c20ba50ae5511ef46" translate="yes" xml:space="preserve">
          <source>A basic Flask FastCGI configuration for nginx looks like this:</source>
          <target state="translated">nginx의 기본 Flask FastCGI 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2fd3ceedec9d8911f0a73dafbf7c92b1f515b0f" translate="yes" xml:space="preserve">
          <source>A basic flask nginx configuration looks like this:</source>
          <target state="translated">기본 플라스크 nginx 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fd63952630dd4b6f44457e3b807f7fb40266af3" translate="yes" xml:space="preserve">
          <source>A blueprint can expose a folder with static files by providing the path to the folder on the filesystem with the &lt;code&gt;static_folder&lt;/code&gt; argument. It is either an absolute path or relative to the blueprint&amp;rsquo;s location:</source>
          <target state="translated">Blueprint는 &lt;code&gt;static_folder&lt;/code&gt; 인수 를 사용하여 파일 시스템의 폴더 경로를 제공하여 정적 파일이있는 폴더를 노출 할 수 있습니다 . 절대 경로이거나 Blueprint의 위치에 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="717fe32550a4264473932c96d8bf2285e92e14a5" translate="yes" xml:space="preserve">
          <source>A blueprint in Flask is not a pluggable app because it is not actually an application &amp;ndash; it&amp;rsquo;s a set of operations which can be registered on an application, even multiple times. Why not have multiple application objects? You can do that (see &lt;a href=&quot;../patterns/appdispatch/index#app-dispatch&quot;&gt;Application Dispatching&lt;/a&gt;), but your applications will have separate configs and will be managed at the WSGI layer.</source>
          <target state="translated">Flask의 청사진은 실제로 응용 프로그램이 아니기 때문에 플러그 가능한 응용 프로그램이 아닙니다. 이는 응용 프로그램에 여러 번 등록 할 수있는 일련의 작업입니다. 여러 응용 프로그램 개체가없는 이유는 무엇입니까? 이를 수행 할 수 있지만 ( &lt;a href=&quot;../patterns/appdispatch/index#app-dispatch&quot;&gt;애플리케이션 디스패치&lt;/a&gt; 참조 ) 애플리케이션은 별도의 구성을 가지며 WSGI 계층에서 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="947b41ec478d3b35232e29596a89532b6866316e" translate="yes" xml:space="preserve">
          <source>A blueprint is an object that allows defining application functions without requiring an application object ahead of time. It uses the same decorators as &lt;a href=&quot;#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt;, but defers the need for an application by recording them for later registration.</source>
          <target state="translated">청사진은 애플리케이션 객체를 미리 요구하지 않고도 애플리케이션 기능을 정의 할 수있는 객체입니다. &lt;a href=&quot;#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 와 동일한 데코레이터를 사용 하지만 나중에 등록 할 수 있도록 기록하여 애플리케이션의 필요성을 연기합니다.</target>
        </trans-unit>
        <trans-unit id="baab44730efc2515b4d79e67f8f95a25efc365b7" translate="yes" xml:space="preserve">
          <source>A child template might look like this:</source>
          <target state="translated">하위 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ee10b23ae58442c19b92190b48d7d42664b8f84" translate="yes" xml:space="preserve">
          <source>A class-based view that dispatches request methods to the corresponding class methods. For example, if you implement a &lt;code&gt;get&lt;/code&gt; method, it will be used to handle &lt;code&gt;GET&lt;/code&gt; requests.</source>
          <target state="translated">요청 메서드를 해당 클래스 메서드로 전달하는 클래스 기반 뷰입니다. 예를 들어, &lt;code&gt;get&lt;/code&gt; 메서드 를 구현하면 &lt;code&gt;GET&lt;/code&gt; 요청 을 처리하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b65be65d78a3f2f2bb402cc257ef307b4385c8c" translate="yes" xml:space="preserve">
          <source>A common pattern invented by the TurboGears guys a while back is a templating decorator. The idea of that decorator is that you return a dictionary with the values passed to the template from the view function and the template is automatically rendered. With that, the following three examples do exactly the same:</source>
          <target state="translated">TurboGears 사람들이 오래전에 발명 한 일반적인 패턴은 템플릿 데코레이터입니다. 이 데코레이터의 아이디어는 뷰 함수에서 템플릿으로 전달 된 값이있는 사전을 반환하고 템플릿이 자동으로 렌더링된다는 것입니다. 이를 통해 다음 세 가지 예는 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9f748c723ecbb5f9a1812f05b54ad30d86d7b35e" translate="yes" xml:space="preserve">
          <source>A common question is how to add a favicon to a Flask application. First, of course, you need an icon. It should be 16 &amp;times; 16 pixels and in the ICO file format. This is not a requirement but a de-facto standard supported by all relevant browsers. Put the icon in your static directory as &lt;code&gt;favicon.ico&lt;/code&gt;.</source>
          <target state="translated">일반적인 질문은 Flask 애플리케이션에 파비콘을 추가하는 방법입니다. 먼저 아이콘이 필요합니다. 16 &amp;times; 16 픽셀이어야하며 ICO 파일 형식이어야합니다. 이것은 요구 사항이 아니라 모든 관련 브라우저에서 지원하는 사실상의 표준입니다. 아이콘을 정적 디렉토리에 &lt;code&gt;favicon.ico&lt;/code&gt; 로 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="1959d4fdae056b89b355d80ffdb10f02de7a3b96" translate="yes" xml:space="preserve">
          <source>A common response format when writing an API is JSON. It&amp;rsquo;s easy to get started writing such an API with Flask. If you return a &lt;code&gt;dict&lt;/code&gt; from a view, it will be converted to a JSON response.</source>
          <target state="translated">API를 작성할 때 일반적인 응답 형식은 JSON입니다. Flask로 이러한 API 작성을 시작하는 것은 쉽습니다. 뷰에서 &lt;code&gt;dict&lt;/code&gt; 를 반환 하면 JSON 응답으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="323df0dc4b2114fb866b83451b32513e79d173af" translate="yes" xml:space="preserve">
          <source>A common use for &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; is to manage resources during a request.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; 의 일반적인 용도 는 요청 중에 리소스를 관리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a84a122039e77a32723b3921b16cd5e8292d0f32" translate="yes" xml:space="preserve">
          <source>A compact representation for lossless serialization of non-standard JSON types. &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface&quot;&gt;&lt;code&gt;SecureCookieSessionInterface&lt;/code&gt;&lt;/a&gt; uses this to serialize the session data, but it may be useful in other places. It can be extended to support other types.</source>
          <target state="translated">비표준 JSON 유형의 무손실 직렬화를위한 간결한 표현입니다. &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface&quot;&gt; &lt;code&gt;SecureCookieSessionInterface&lt;/code&gt; &lt;/a&gt; 는 이것을 사용하여 세션 데이터를 직렬화하지만 다른 곳에서는 유용 할 수 있습니다. 다른 유형을 지원하도록 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e436e4de42b803e4f825856478e4c148026932" translate="yes" xml:space="preserve">
          <source>A decorator that is used to register a custom template global function. You can specify a name for the global function, otherwise the function name will be used. Example:</source>
          <target state="translated">사용자 지정 템플릿 전역 함수를 등록하는 데 사용되는 데코레이터입니다. 전역 함수의 이름을 지정할 수 있습니다. 그렇지 않으면 함수 이름이 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="dcef09237708fa729080d1cd3a45f161f3a78173" translate="yes" xml:space="preserve">
          <source>A decorator that is used to register a function given an error code. Example:</source>
          <target state="translated">오류 코드가있는 함수를 등록하는 데 사용되는 데코레이터입니다. 예:</target>
        </trans-unit>
        <trans-unit id="5ce20a3efb5f7382979a3a761cad531f9d44ce61" translate="yes" xml:space="preserve">
          <source>A decorator that is used to register a view function for a given URL rule. This does the same thing as &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; but is intended for decorator usage:</source>
          <target state="translated">주어진 URL 규칙에 대한보기 기능을 등록하는 데 사용되는 데코레이터입니다. 이것은 &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt; 과 동일한 작업을 수행 하지만 데코레이터 사용을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="48c9d6e1ce427a51f3730cd63f72dc320ca87c6c" translate="yes" xml:space="preserve">
          <source>A decorator that is used to register custom template filter. You can specify a name for the filter, otherwise the function name will be used. Example:</source>
          <target state="translated">사용자 지정 템플릿 필터를 등록하는 데 사용되는 데코레이터입니다. 필터 이름을 지정할 수 있습니다. 그렇지 않으면 함수 이름이 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="de84f30c0a9b1b31048271eb8625c12d3c8e17df" translate="yes" xml:space="preserve">
          <source>A decorator that is used to register custom template test. You can specify a name for the test, otherwise the function name will be used. Example:</source>
          <target state="translated">사용자 지정 템플릿 테스트를 등록하는 데 사용되는 데코레이터입니다. 테스트 이름을 지정할 수 있습니다. 그렇지 않으면 함수 이름이 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="4c77f40c0399cd72328d9019d30c3986e5adb2a4" translate="yes" xml:space="preserve">
          <source>A decorator to register a function as an endpoint. Example:</source>
          <target state="translated">함수를 끝점으로 등록하는 데코레이터입니다. 예:</target>
        </trans-unit>
        <trans-unit id="900df345e72f33af46f34332213c6e5174cf5f03" translate="yes" xml:space="preserve">
          <source>A descriptor that calls &lt;code&gt;get_data()&lt;/code&gt; and &lt;code&gt;set_data()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_data()&lt;/code&gt; 및 &lt;code&gt;set_data()&lt;/code&gt; 를 호출하는 설명자 .</target>
        </trans-unit>
        <trans-unit id="fd1b2762dcd919e1e0e00830acc726fd79b129e2" translate="yes" xml:space="preserve">
          <source>A dict of view arguments that matched the request. If an exception happened when matching, this will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">요청과 일치하는 뷰 인수의 사전입니다. 일치 할 때 예외가 발생하면 &lt;code&gt;None&lt;/code&gt; 이됩니다 .</target>
        </trans-unit>
        <trans-unit id="8207f625528912a3f93634a66a8276a0959993ba" translate="yes" xml:space="preserve">
          <source>A dictionary of all registered error handlers. The key is &lt;code&gt;None&lt;/code&gt; for error handlers active on the application, otherwise the key is the name of the blueprint. Each key points to another dictionary where the key is the status code of the http exception. The special key &lt;code&gt;None&lt;/code&gt; points to a list of tuples where the first item is the class for the instance check and the second the error handler function.</source>
          <target state="translated">등록 된 모든 오류 처리기의 사전입니다. 응용 프로그램에서 활성화 된 오류 처리기 의 경우 키는 &lt;code&gt;None&lt;/code&gt; 이고, 그렇지 않으면 키는 Blueprint의 이름입니다. 각 키는 키가 http 예외의 상태 코드 인 다른 사전을 가리 킵니다. 특수 키 &lt;code&gt;None&lt;/code&gt; 은 첫 번째 항목이 인스턴스 검사를위한 클래스이고 두 번째 항목이 오류 처리기 함수 인 튜플 목록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="245ff3a9d696c535678c50df5309abfb18036b9e" translate="yes" xml:space="preserve">
          <source>A dictionary of all view functions registered. The keys will be function names which are also used to generate URLs and the values are the function objects themselves. To register a view function, use the &lt;a href=&quot;#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">등록 된 모든보기 기능의 사전. 키는 URL을 생성하는데도 사용되는 함수 이름이며 값은 함수 객체 자체입니다. 뷰 함수를 등록하려면 &lt;a href=&quot;#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a31e3ecd44d38cbe93426a981e770094dd70627" translate="yes" xml:space="preserve">
          <source>A dictionary that will be jsonify&amp;rsquo;d before being returned.</source>
          <target state="translated">반환되기 전에 jsonify 될 사전입니다.</target>
        </trans-unit>
        <trans-unit id="77bf2ac8d819c8f0bed5b57c455bee4354d82875" translate="yes" xml:space="preserve">
          <source>A dictionary with URL defaults that is added to each and every URL that was defined with the blueprint.</source>
          <target state="translated">Blueprint로 정의 된 각각의 모든 URL에 추가되는 URL 기본값이있는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="7e87505f9a6e000044a3690e919f8a858f0640eb" translate="yes" xml:space="preserve">
          <source>A dictionary with arbitrary data that can be associated with this script info.</source>
          <target state="translated">이 스크립트 정보와 연관 될 수있는 임의의 데이터가있는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="fb2676a1158a218c2c1deb11c20b63a6c7788b31" translate="yes" xml:space="preserve">
          <source>A dictionary with defaults for this rule. See the example above for how defaults work.</source>
          <target state="translated">이 규칙에 대한 기본값이있는 사전입니다. 기본값 작동 방식은 위의 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3994a23152b5db01fb43f08862f57787a4d3df00" translate="yes" xml:space="preserve">
          <source>A dictionary with list of functions that are called without argument to populate the template context. The key of the dictionary is the name of the blueprint this function is active for, &lt;code&gt;None&lt;/code&gt; for all requests. Each returns a dictionary that the template context is updated with. To register a function here, use the &lt;a href=&quot;#flask.Flask.context_processor&quot;&gt;&lt;code&gt;context_processor()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">템플릿 컨텍스트를 채우기 위해 인수없이 호출되는 함수 목록이있는 사전입니다. 딕셔너리의 핵심은이 기능이 활성화 된 청사진의 이름이며 모든 요청에 ​​대해 &lt;code&gt;None&lt;/code&gt; 입니다. 각각은 템플릿 컨텍스트가 업데이트되는 사전을 반환합니다. 여기에 함수를 등록하려면 &lt;a href=&quot;#flask.Flask.context_processor&quot;&gt; &lt;code&gt;context_processor()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="60db2de6d989f347ec7927eefb6e65b33ac9858f" translate="yes" xml:space="preserve">
          <source>A dictionary with lists of functions that are called after each request, even if an exception has occurred. The key of the dictionary is the name of the blueprint this function is active for, &lt;code&gt;None&lt;/code&gt; for all requests. These functions are not allowed to modify the request, and their return values are ignored. If an exception occurred while processing the request, it gets passed to each teardown_request function. To register a function here, use the &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">예외가 발생한 경우에도 각 요청 후에 호출되는 함수 목록이있는 사전입니다. 딕셔너리의 핵심은이 기능이 활성화 된 청사진의 이름이며 모든 요청에 ​​대해 &lt;code&gt;None&lt;/code&gt; 입니다. 이러한 함수는 요청을 수정할 수 없으며 반환 값은 무시됩니다. 요청을 처리하는 동안 예외가 발생하면 각 teardown_request 함수에 전달됩니다. 여기에 함수를 등록하려면 &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="3e17b27134f42815a9fd648cf168dcb75ebd0d63" translate="yes" xml:space="preserve">
          <source>A dictionary with lists of functions that are called before the &lt;a href=&quot;#flask.Flask.before_request_funcs&quot;&gt;&lt;code&gt;before_request_funcs&lt;/code&gt;&lt;/a&gt; functions. The key of the dictionary is the name of the blueprint this function is active for, or &lt;code&gt;None&lt;/code&gt; for all requests. To register a function, use &lt;a href=&quot;#flask.Flask.url_value_preprocessor&quot;&gt;&lt;code&gt;url_value_preprocessor()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#flask.Flask.before_request_funcs&quot;&gt; &lt;code&gt;before_request_funcs&lt;/code&gt; &lt;/a&gt; 함수 전에 호출되는 함수 목록이있는 사전입니다 . 사전의 키는이 기능이 활성화 된 청사진의 이름이거나 모든 요청에 ​​대해 &lt;code&gt;None&lt;/code&gt; 입니다. 함수를 등록하려면 &lt;a href=&quot;#flask.Flask.url_value_preprocessor&quot;&gt; &lt;code&gt;url_value_preprocessor()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b118ff8185ba397df2b956462f241589aa6546ab" translate="yes" xml:space="preserve">
          <source>A dictionary with lists of functions that can be used as URL value preprocessors. The key &lt;code&gt;None&lt;/code&gt; here is used for application wide callbacks, otherwise the key is the name of the blueprint. Each of these functions has the chance to modify the dictionary of URL values before they are used as the keyword arguments of the view function. For each function registered this one should also provide a &lt;a href=&quot;#flask.Flask.url_defaults&quot;&gt;&lt;code&gt;url_defaults()&lt;/code&gt;&lt;/a&gt; function that adds the parameters automatically again that were removed that way.</source>
          <target state="translated">URL 값 전처리기로 사용할 수있는 함수 목록이있는 사전입니다. 여기서 &lt;code&gt;None&lt;/code&gt; 키 는 애플리케이션 전체 콜백에 사용됩니다. 그렇지 않으면 키는 블루 프린트의 이름입니다. 이러한 각 함수는보기 함수의 키워드 인수로 사용되기 전에 URL 값의 사전을 수정할 수 있습니다. 등록 된 각 함수에 &lt;a href=&quot;#flask.Flask.url_defaults&quot;&gt; &lt;code&gt;url_defaults()&lt;/code&gt; &lt;/a&gt; 함수는 제거 된 매개 변수를 자동으로 다시 추가 하는 url_defaults () 함수 도 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="fcf777258e11b21b8302a1700ac3aff7438a3934" translate="yes" xml:space="preserve">
          <source>A dictionary with lists of functions that should be called after each request. The key of the dictionary is the name of the blueprint this function is active for, &lt;code&gt;None&lt;/code&gt; for all requests. This can for example be used to close database connections. To register a function here, use the &lt;a href=&quot;#flask.Flask.after_request&quot;&gt;&lt;code&gt;after_request()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">각 요청 후에 호출해야하는 함수 목록이있는 사전입니다. 딕셔너리의 핵심은이 기능이 활성화 된 청사진의 이름이며 모든 요청에 ​​대해 &lt;code&gt;None&lt;/code&gt; 입니다. 예를 들어 데이터베이스 연결을 닫는 데 사용할 수 있습니다. 여기에 함수를 등록하려면 &lt;a href=&quot;#flask.Flask.after_request&quot;&gt; &lt;code&gt;after_request()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="73dd1a44d8a77c7b6dcb8ecceaeb1e3e1bc1acb4" translate="yes" xml:space="preserve">
          <source>A dictionary with lists of functions that will be called at the beginning of each request. The key of the dictionary is the name of the blueprint this function is active for, or &lt;code&gt;None&lt;/code&gt; for all requests. To register a function, use the &lt;a href=&quot;#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">각 요청이 시작될 때 호출 될 함수 목록이있는 사전입니다. 사전의 키는이 기능이 활성화 된 청사진의 이름이거나 모든 요청에 ​​대해 &lt;code&gt;None&lt;/code&gt; 입니다. 함수를 등록하려면 &lt;a href=&quot;#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5a03301ac45aae268d4c7d5a463a22071af9d73" translate="yes" xml:space="preserve">
          <source>A fabfile is what controls what Fabric executes. It is named &lt;code&gt;fabfile.py&lt;/code&gt; and executed by the &lt;code&gt;fab&lt;/code&gt; command. All the functions defined in that file will show up as &lt;code&gt;fab&lt;/code&gt; subcommands. They are executed on one or more hosts. These hosts can be defined either in the fabfile or on the command line. In this case we will add them to the fabfile.</source>
          <target state="translated">fabfile은 Fabric이 실행하는 것을 제어하는 ​​것입니다. 이름은 &lt;code&gt;fabfile.py&lt;/code&gt; 이고 &lt;code&gt;fab&lt;/code&gt; 명령에 의해 실행됩니다 . 해당 파일에 정의 된 모든 함수는 &lt;code&gt;fab&lt;/code&gt; 하위 명령 으로 표시됩니다 . 하나 이상의 호스트에서 실행됩니다. 이러한 호스트는 fabfile 또는 명령 줄에서 정의 할 수 있습니다. 이 경우 fabfile에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="77fb4e9e2fa8aae0bcbaa9811970f8f98aaf8c87" translate="yes" xml:space="preserve">
          <source>A flag that indicates if the session interface is pickle based. This can be used by Flask extensions to make a decision in regards to how to deal with the session object.</source>
          <target state="translated">세션 인터페이스가 피클 기반인지 여부를 나타내는 플래그입니다. 이것은 세션 객체를 처리하는 방법과 관련하여 결정을 내리기 위해 Flask 확장에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5d5e0cf304acde482ca37e6aa187d3d73b9897" translate="yes" xml:space="preserve">
          <source>A handler for &amp;ldquo;500 Internal Server Error&amp;rdquo; will not be used when running in debug mode. Instead, the interactive debugger will be shown.</source>
          <target state="translated">디버그 모드에서 실행할 때 &quot;500 내부 서버 오류&quot;에 대한 처리기가 사용되지 않습니다. 대신 대화 형 디버거가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="877fd45656589ff0abe332cf073dfb38833d201d" translate="yes" xml:space="preserve">
          <source>A helper function that decorates a function to retain the current request context. This is useful when working with greenlets. The moment the function is decorated a copy of the request context is created and then pushed when the function is called. The current session is also included in the copied request context.</source>
          <target state="translated">현재 요청 컨텍스트를 유지하기 위해 함수를 장식하는 도우미 함수입니다. 이것은 그린 렛으로 작업 할 때 유용합니다. 함수가 데코 레이팅되는 순간 요청 컨텍스트의 복사본이 생성되고 함수가 호출 될 때 푸시됩니다. 현재 세션도 복사 된 요청 컨텍스트에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a6f6d37781c521b83a8d6d38a8dd457d0554b477" translate="yes" xml:space="preserve">
          <source>A helper method that returns an expiration date for the session or &lt;code&gt;None&lt;/code&gt; if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.</source>
          <target state="translated">세션의 만료 날짜를 반환하거나 세션이 브라우저 세션에 연결된 경우 &lt;code&gt;None&lt;/code&gt; 을 반환하는 도우미 메서드입니다 . 기본 구현은 이제 + 애플리케이션에 구성된 영구 세션 수명을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af337e647b0908b71e085b15c36290a8021ba3e9" translate="yes" xml:space="preserve">
          <source>A helper method to register a rule (and optionally a view function) to the application. The endpoint is automatically prefixed with the blueprint&amp;rsquo;s name.</source>
          <target state="translated">규칙 (및 선택적으로보기 기능)을 애플리케이션에 등록하는 도우미 메서드입니다. 엔드 포인트에는 Blueprint의 이름이 자동으로 접두사로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="d16a96a51e68c5d63eb67bf46f156e82cc4875dd" translate="yes" xml:space="preserve">
          <source>A list of functions that are called when &lt;a href=&quot;#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; raises a &lt;code&gt;BuildError&lt;/code&gt;. Each function registered here is called with &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;endpoint&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt;. If a function returns &lt;code&gt;None&lt;/code&gt; or raises a &lt;code&gt;BuildError&lt;/code&gt; the next function is tried.</source>
          <target state="translated">때 호출되는 함수의 목록 &lt;a href=&quot;#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt; 제기 &lt;code&gt;BuildError&lt;/code&gt; 가 . 여기에 등록 된 각 함수는 &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;endpoint&lt;/code&gt; 및 &lt;code&gt;values&lt;/code&gt; 과 함께 호출 됩니다 . 함수가 &lt;code&gt;None&lt;/code&gt; 을 반환 하거나 &lt;code&gt;BuildError&lt;/code&gt; 를 발생 시키면 다음 함수가 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="62166dcc5f18957b7025e155f6df8a637b3b6241" translate="yes" xml:space="preserve">
          <source>A list of functions that are called when the application context is destroyed. Since the application context is also torn down if the request ends this is the place to store code that disconnects from databases.</source>
          <target state="translated">애플리케이션 컨텍스트가 소멸 될 때 호출되는 함수 목록입니다. 요청이 종료되면 애플리케이션 컨텍스트도 해체되므로 데이터베이스에서 연결을 끊는 코드를 저장하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="5725cfc79acde172d099c9e4e5a5c7afa1b78259" translate="yes" xml:space="preserve">
          <source>A list of functions that will be called at the beginning of the first request to this instance. To register a function, use the &lt;a href=&quot;#flask.Flask.before_first_request&quot;&gt;&lt;code&gt;before_first_request()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">이 인스턴스에 대한 첫 번째 요청이 시작될 때 호출 될 함수 목록입니다. 함수를 등록하려면 &lt;a href=&quot;#flask.Flask.before_first_request&quot;&gt; &lt;code&gt;before_first_request()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="638434024ce44dea060e4a13ec38eef4b806199e" translate="yes" xml:space="preserve">
          <source>A list of methods this view can handle.</source>
          <target state="translated">이보기에서 처리 할 수있는 메서드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d4813dc7dbccd523eb07c1573b9bf7469939f254" translate="yes" xml:space="preserve">
          <source>A list of shell context processor functions that should be run when a shell context is created.</source>
          <target state="translated">셸 컨텍스트를 만들 때 실행해야하는 셸 컨텍스트 프로세서 함수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fc46f637f28745b1eac15ee56b93a4eea06e86fa" translate="yes" xml:space="preserve">
          <source>A minimal Flask application looks something like this:</source>
          <target state="translated">최소 Flask 애플리케이션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcad68396d130250f6c207cc06348265369371af" translate="yes" xml:space="preserve">
          <source>A namespace object that can store data during an &lt;a href=&quot;../appcontext/index&quot;&gt;application context&lt;/a&gt;. This is an instance of &lt;a href=&quot;#flask.Flask.app_ctx_globals_class&quot;&gt;&lt;code&gt;Flask.app_ctx_globals_class&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;#flask.ctx._AppCtxGlobals&quot;&gt;&lt;code&gt;ctx._AppCtxGlobals&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../appcontext/index&quot;&gt;응용 프로그램 컨텍스트&lt;/a&gt; 동안 데이터를 저장할 수있는 네임 스페이스 개체입니다 . 이것은 &lt;a href=&quot;#flask.Flask.app_ctx_globals_class&quot;&gt; &lt;code&gt;Flask.app_ctx_globals_class&lt;/code&gt; &lt;/a&gt; 의 인스턴스이며 기본값은 &lt;a href=&quot;#flask.ctx._AppCtxGlobals&quot;&gt; &lt;code&gt;ctx._AppCtxGlobals&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="68ade762655aa55873b4a03c6bf0b34f6e963c3a" translate="yes" xml:space="preserve">
          <source>A note on cookie-based sessions: Flask will take the values you put into the session object and serialize them into a cookie. If you are finding some values do not persist across requests, cookies are indeed enabled, and you are not getting a clear error message, check the size of the cookie in your page responses compared to the size supported by web browsers.</source>
          <target state="translated">쿠키 기반 세션에 대한 참고 사항 : Flask는 세션 개체에 입력 한 값을 가져 와서 쿠키에 직렬화합니다. 일부 값이 요청간에 유지되지 않고 쿠키가 실제로 활성화되어 있으며 명확한 오류 메시지가 표시되지 않는 경우 웹 브라우저에서 지원하는 크기와 비교하여 페이지 응답에서 쿠키 크기를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1d550ed3186c925dbac6530c84342967ffa4f08f" translate="yes" xml:space="preserve">
          <source>A plain object. Used as a namespace for storing data during an application context.</source>
          <target state="translated">평범한 물건. 애플리케이션 컨텍스트 중에 데이터를 저장하기위한 네임 스페이스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a07553b4c53b846f04dac7e59114abc4e157c81" translate="yes" xml:space="preserve">
          <source>A popular approach is to store configuration files for different servers in a separate version control repository and check them out on all servers. Then symlink the file that is active for the server into the location where it&amp;rsquo;s expected (eg: &lt;code&gt;/var/www/yourapplication&lt;/code&gt;).</source>
          <target state="translated">널리 사용되는 접근 방식은 다른 서버의 구성 파일을 별도의 버전 관리 저장소에 저장하고 모든 서버에서 체크 아웃하는 것입니다. 그런 다음 서버에서 활성화 된 파일을 예상되는 위치 (예 : &lt;code&gt;/var/www/yourapplication&lt;/code&gt; )에 심볼릭 링크합니다 .</target>
        </trans-unit>
        <trans-unit id="c8244c56c78d01af5d79981d8b120e47277d5732" translate="yes" xml:space="preserve">
          <source>A proxy to the application handling the current request. This is useful to access the application without needing to import it, or if it can&amp;rsquo;t be imported, such as when using the application factory pattern or in blueprints and extensions.</source>
          <target state="translated">현재 요청을 처리하는 응용 프로그램에 대한 프록시입니다. 이는 가져올 필요없이 애플리케이션에 액세스하는 데 유용합니다. 또는 애플리케이션 팩토리 패턴을 사용하거나 블루 프린트 및 확장에서 가져올 수없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="80c351c8028197c250f2ad835ad88c6e52c9a82e" translate="yes" xml:space="preserve">
          <source>A python serializer for the payload. The default is a compact JSON derived serializer with support for some extra Python types such as datetime objects or tuples.</source>
          <target state="translated">페이로드를위한 파이썬 시리얼 라이저. 기본값은 datetime 객체 또는 튜플과 같은 일부 추가 Python 유형을 지원하는 컴팩트 JSON 파생 직렬 변환기입니다.</target>
        </trans-unit>
        <trans-unit id="9b42bad88d454b45cd82ee1a8d3ba0b23f8e0bbe" translate="yes" xml:space="preserve">
          <source>A response object is created with the bytes as the body.</source>
          <target state="translated">응답 객체는 바이트를 본문으로 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="47b0e2fc51dfad01a11e843e5b0f3d3293e3160e" translate="yes" xml:space="preserve">
          <source>A response object is created with the string encoded to UTF-8 as the body.</source>
          <target state="translated">UTF-8로 인코딩 된 문자열을 본문으로 사용하여 응답 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f665ba292928be380e7047549501f99ec244b9a4" translate="yes" xml:space="preserve">
          <source>A running MongoDB server and &lt;a href=&quot;https://flask-mongoengine.readthedocs.io&quot;&gt;Flask-MongoEngine&lt;/a&gt; are required.</source>
          <target state="translated">실행중인 MongoDB 서버와 &lt;a href=&quot;https://flask-mongoengine.readthedocs.io&quot;&gt;Flask-MongoEngine&lt;/a&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bc1f6de9c518c33c5d1eaec0994cfaa9d6a70d4c" translate="yes" xml:space="preserve">
          <source>A secret key should be as random as possible. Your operating system has ways to generate pretty random data based on a cryptographic random generator. Use the following command to quickly generate a value for &lt;code&gt;Flask.secret_key&lt;/code&gt; (or &lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">비밀 키는 가능한 한 임의적이어야합니다. 운영 체제에는 암호화 랜덤 생성기를 기반으로 매우 임의의 데이터를 생성하는 방법이 있습니다. 다음 명령을 사용하여 &lt;code&gt;Flask.secret_key&lt;/code&gt; (또는 &lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt; &lt;code&gt;SECRET_KEY&lt;/code&gt; &lt;/a&gt; )에 대한 값을 빠르게 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b129545568738486b440e9a7ff56c6213f91ad86" translate="yes" xml:space="preserve">
          <source>A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random string of bytes, although unicode is accepted too. For example, copy the output of this to your config:</source>
          <target state="translated">세션 쿠키에 안전하게 서명하는 데 사용되며 확장 또는 애플리케이션의 기타 보안 관련 요구에 사용할 수있는 비밀 키입니다. 유니 코드도 허용되지만 긴 임의의 바이트 문자열이어야합니다. 예를 들어이 출력을 구성에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="c83004bb384877de6b8aedb1f06bda3d62f1b310" translate="yes" xml:space="preserve">
          <source>A simple method would be to add a script tag to our page that sets a global variable to the prefix to the root of the application. Something like this:</source>
          <target state="translated">간단한 방법은 응용 프로그램의 루트에 대한 접두사에 전역 변수를 설정하는 스크립트 태그를 페이지에 추가하는 것입니다. 이 같은:</target>
        </trans-unit>
        <trans-unit id="85f1b3a6db6815b953dc4ed0ab8e8ccb783f02dc" translate="yes" xml:space="preserve">
          <source>A standard Python &lt;a href=&quot;https://docs.python.org/3/library/logging.html#logging.Logger&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; for the app, with the same name as &lt;a href=&quot;#flask.Flask.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 파이썬 &lt;a href=&quot;https://docs.python.org/3/library/logging.html#logging.Logger&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 와 같은 이름을 가진 응용 프로그램에 대한, &lt;a href=&quot;#flask.Flask.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6cbef69121802ea63d9627dc73ebafe3137d2a" translate="yes" xml:space="preserve">
          <source>A string that is ready to be safely inserted into an HTML or XML document, either because it was escaped or because it was marked safe.</source>
          <target state="translated">이스케이프되었거나 안전한 것으로 표시 되었기 때문에 HTML 또는 XML 문서에 안전하게 삽입 할 준비가 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="53686b42419f8f4dbe2ab7372fc0562d7a17ac82" translate="yes" xml:space="preserve">
          <source>A string with a response status.</source>
          <target state="translated">응답 상태가있는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8312ed623273d2bbf97ae1b91de3300621acd2f3" translate="yes" xml:space="preserve">
          <source>A template abstraction layer that would not take the unique features of the template engines away is a science on its own and a too large undertaking for a microframework like Flask.</source>
          <target state="translated">템플릿 엔진의 고유 한 기능을 제거하지 않는 템플릿 추상화 계층은 그 자체로 과학이며 Flask와 같은 마이크로 프레임 워크에는 너무 큰 작업입니다.</target>
        </trans-unit>
        <trans-unit id="8975cfcc10bef0093ca48dca76a64fc9c064c9b2" translate="yes" xml:space="preserve">
          <source>A very common example would be creating applications per subdomain. For instance you configure your webserver to dispatch all requests for all subdomains to your application and you then use the subdomain information to create user-specific instances. Once you have your server set up to listen on all subdomains you can use a very simple WSGI application to do the dynamic application creation.</source>
          <target state="translated">매우 일반적인 예는 하위 도메인별로 응용 프로그램을 만드는 것입니다. 예를 들어 모든 하위 도메인에 대한 모든 요청을 애플리케이션으로 전달하도록 웹 서버를 구성한 다음 하위 도메인 정보를 사용하여 사용자 별 인스턴스를 만듭니다. 모든 하위 도메인에서 수신하도록 서버를 설정 한 후에는 매우 간단한 WSGI 애플리케이션을 사용하여 동적 애플리케이션 생성을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bf6d9ecc409d8e72167f4acb805f0dda0a9936f" translate="yes" xml:space="preserve">
          <source>A very common pattern is to store user authorization information and database connections on the application context or the &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;flask.g&lt;/code&gt;&lt;/a&gt; object. The general pattern for this is to put the object on there on first usage and then to remove it on a teardown. Imagine for instance this code to get the current user:</source>
          <target state="translated">매우 일반적인 패턴은 사용자 인증 정보와 데이터베이스 연결을 애플리케이션 컨텍스트 또는 &lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;flask.g&lt;/code&gt; &lt;/a&gt; 객체에 저장하는 것입니다. 이에 대한 일반적인 패턴은 처음 사용할 때 개체를 거기에 놓은 다음 분해에서 제거하는 것입니다. 예를 들어 현재 사용자를 얻기 위해 다음 코드를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="b0e1c2e8cb52258c006921b3f9ef96e0b82b5fd6" translate="yes" xml:space="preserve">
          <source>A view can now raise that exception with an error message. Additionally some extra payload can be provided as a dictionary through the &lt;code&gt;payload&lt;/code&gt; parameter.</source>
          <target state="translated">이제 뷰는 오류 메시지와 함께 해당 예외를 발생시킬 수 있습니다. 또한 일부 추가 페이로드는 &lt;code&gt;payload&lt;/code&gt; 매개 변수를 통해 사전으로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="009d6bc8881431b80879ec0792ab311b338d4fc4" translate="yes" xml:space="preserve">
          <source>A warning is raised if the size of the cookie header exceeds &lt;a href=&quot;#flask.Response.max_cookie_size&quot;&gt;&lt;code&gt;max_cookie_size&lt;/code&gt;&lt;/a&gt;, but the header will still be set.</source>
          <target state="translated">쿠키 헤더의 크기가 &lt;a href=&quot;#flask.Response.max_cookie_size&quot;&gt; &lt;code&gt;max_cookie_size&lt;/code&gt; 를&lt;/a&gt; 초과하면 경고가 발생 하지만 헤더는 계속 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="52205ce119095e91e587bedec05385e81a8334ef" translate="yes" xml:space="preserve">
          <source>A while ago many developers had the idea to read the incoming file in small chunks and store the upload progress in the database to be able to poll the progress with JavaScript from the client. Long story short: the client asks the server every 5 seconds how much it has transmitted already. Do you realize the irony? The client is asking for something it should already know.</source>
          <target state="translated">얼마 전에 많은 개발자가 들어오는 파일을 작은 청크로 읽고 업로드 진행 상황을 데이터베이스에 저장하여 클라이언트에서 JavaScript로 진행 상황을 폴링 할 수 있다는 아이디어를 얻었습니다. 간단히 말해서 클라이언트는 이미 전송 된 양을 5 초마다 서버에 묻습니다. 아이러니를 알고 있습니까? 클라이언트는 이미 알아야 할 것을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="30a07f7b3bbff0aa5b2092f5e4d749547f6a51af" translate="yes" xml:space="preserve">
          <source>A working deployment with setuptools is the first step into more complex and more automated deployment scenarios. If you want to fully automate the process, also read the &lt;a href=&quot;../fabric/index#fabric-deployment&quot;&gt;Deploying with Fabric&lt;/a&gt; chapter.</source>
          <target state="translated">setuptools를 사용한 작업 배포는 더 복잡하고 자동화 된 배포 시나리오의 첫 번째 단계입니다. 프로세스를 완전히 자동화하려면 &lt;a href=&quot;../fabric/index#fabric-deployment&quot;&gt;Deploying with Fabric&lt;/a&gt; 장도 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="891d9413ccc83954f2ea96980ec8180731f1316c" translate="yes" xml:space="preserve">
          <source>AJAX with jQuery</source>
          <target state="translated">jQuery를 사용한 AJAX</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="7d5977939c64905e9a0e5f90931e54f7476dac2f" translate="yes" xml:space="preserve">
          <source>APIs with JSON</source>
          <target state="translated">JSON을 사용한 API</target>
        </trans-unit>
        <trans-unit id="468b873f605e4145cc4e3acfa8d0fe4679f057af" translate="yes" xml:space="preserve">
          <source>About Responses</source>
          <target state="translated">응답 정보</target>
        </trans-unit>
        <trans-unit id="a984dc1047c363a49ef23d22296179eca51a08ce" translate="yes" xml:space="preserve">
          <source>About the First Parameter</source>
          <target state="translated">첫 번째 매개 변수 정보</target>
        </trans-unit>
        <trans-unit id="b0ccbdac92041a3fa0f7869a9fd9b0a3df5f5e5d" translate="yes" xml:space="preserve">
          <source>Absolute path to the package on the filesystem. Used to look up resources contained in the package.</source>
          <target state="translated">파일 시스템에있는 패키지의 절대 경로입니다. 패키지에 포함 된 리소스를 조회하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c07cfe24a9ec09966271c82da4347537504d1c55" translate="yes" xml:space="preserve">
          <source>Accessing &lt;code&gt;db&lt;/code&gt; will call &lt;code&gt;get_db&lt;/code&gt; internally, in the same way that &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; works.</source>
          <target state="translated">&lt;code&gt;db&lt;/code&gt; 에 액세스 하면 &lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; 이&lt;/a&gt; 작동 하는 것과 같은 방식으로 내부적으로 &lt;code&gt;get_db&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="0dddabb232a4aaa6d37bd9600f9561d723401cd1" translate="yes" xml:space="preserve">
          <source>Accessing Request Data</source>
          <target state="translated">요청 데이터 액세스</target>
        </trans-unit>
        <trans-unit id="2850868565d5b47a5b973c2e462d8fc71b039b6b" translate="yes" xml:space="preserve">
          <source>Accessing and Modifying Sessions</source>
          <target state="translated">세션 액세스 및 수정</target>
        </trans-unit>
        <trans-unit id="f3783082f0137f59df1cab159ae075bda60c4fd4" translate="yes" xml:space="preserve">
          <source>Activate the environment</source>
          <target state="translated">환경 활성화</target>
        </trans-unit>
        <trans-unit id="a75ddeed53a524edde151ba3c4787d4816c58571" translate="yes" xml:space="preserve">
          <source>Add in WSGI middlewares when the application is being created if necessary.</source>
          <target state="translated">필요한 경우 응용 프로그램을 만들 때 WSGI 미들웨어에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="87d0ba5dd26967ca3dd5b55d0c39f01f1278f98c" translate="yes" xml:space="preserve">
          <source>Add the following lines to the top of your &lt;code&gt;.wsgi&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;.wsgi&lt;/code&gt; 파일 맨 위에 다음 행을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="93a2db68bacb8a024322f756c1ea89f8ea016b58" translate="yes" xml:space="preserve">
          <source>Add the following two functions to your &lt;code&gt;test_flaskr.py&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;test_flaskr.py&lt;/code&gt; 파일에 다음 두 가지 함수를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="9e7d40fdab3e79e7165991bc9998f958e37bc56e" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; to reflect the &lt;code id=&quot;index-6&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-6&quot;&gt;FLASK_ENV&lt;/code&gt; 환경 변수 를 반영하기 위해 &lt;a href=&quot;#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt; 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d6034182326769eded1b010ed731e1198e02e1b7" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;#MAX_COOKIE_SIZE&quot;&gt;&lt;code&gt;MAX_COOKIE_SIZE&lt;/code&gt;&lt;/a&gt; to control a warning from Werkzeug.</source>
          <target state="translated">Werkzeug의 경고를 제어하기 위해 &lt;a href=&quot;#MAX_COOKIE_SIZE&quot;&gt; &lt;code&gt;MAX_COOKIE_SIZE&lt;/code&gt; &lt;/a&gt; 를 추가 했습니다 .</target>
        </trans-unit>
        <trans-unit id="aa027a90c34da609b268658fc144f63ad08e3ad1" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;#SESSION_COOKIE_SAMESITE&quot;&gt;&lt;code&gt;SESSION_COOKIE_SAMESITE&lt;/code&gt;&lt;/a&gt; to control the session cookie&amp;rsquo;s &lt;code&gt;SameSite&lt;/code&gt; option.</source>
          <target state="translated">세션 쿠키의 &lt;code&gt;SameSite&lt;/code&gt; 옵션 을 제어하기 위해 &lt;a href=&quot;#SESSION_COOKIE_SAMESITE&quot;&gt; &lt;code&gt;SESSION_COOKIE_SAMESITE&lt;/code&gt; &lt;/a&gt; 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="dd924e17ab60955a28522675ced687e361560e43" translate="yes" xml:space="preserve">
          <source>Adding HTTP Method Overrides</source>
          <target state="translated">HTTP 메서드 재정의 추가</target>
        </trans-unit>
        <trans-unit id="7affb5674b8ae889619124d08682d0b24c2fc63d" translate="yes" xml:space="preserve">
          <source>Adding a favicon</source>
          <target state="translated">파비콘 추가</target>
        </trans-unit>
        <trans-unit id="a6886107051f6296b301c835737605aa7c616a6a" translate="yes" xml:space="preserve">
          <source>Additional Notes</source>
          <target state="translated">추가 참고 사항</target>
        </trans-unit>
        <trans-unit id="e2a0e3fa912210406e5e52b83da112ca9a3a6b1e" translate="yes" xml:space="preserve">
          <source>Additional parameters:</source>
          <target state="translated">추가 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="9add2d256255839d07e8b0f22c208bd4534ee7d2" translate="yes" xml:space="preserve">
          <source>Additionally if you are in a view function of a blueprint or a rendered template and you want to link to another endpoint of the same blueprint, you can use relative redirects by prefixing the endpoint with a dot only:</source>
          <target state="translated">또한 Blueprint 또는 렌더링 된 템플릿의보기 기능에 있고 동일한 Blueprint의 다른 끝점에 연결하려는 경우 끝점에 점만 접두사로 지정하여 상대 리디렉션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e864ed2640b8b686a1fa444db0f7f1c2ede9b0e" translate="yes" xml:space="preserve">
          <source>Additionally there is a convenient helper method (&lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connected_to&quot;&gt;&lt;code&gt;connected_to()&lt;/code&gt;&lt;/a&gt;) that allows you to temporarily subscribe a function to a signal with a context manager on its own. Because the return value of the context manager cannot be specified that way, you have to pass the list in as an argument:</source>
          <target state="translated">추가적으로 편리한 도우미 메서드 ( &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connected_to&quot;&gt; &lt;code&gt;connected_to()&lt;/code&gt; &lt;/a&gt; )가있어 컨텍스트 관리자를 사용하여 신호에 함수를 일시적으로 구독 할 수 있습니다. 컨텍스트 관리자의 반환 값은 그렇게 지정할 수 없기 때문에 목록을 인수로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="328b25d62d10fd5c70e5a8517e3003fafc4b306b" translate="yes" xml:space="preserve">
          <source>Additionally, it is a good idea to provide a query function that combines getting the cursor, executing and fetching the results:</source>
          <target state="translated">또한 커서 가져 오기, 실행 및 결과 가져 오기를 결합하는 쿼리 함수를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="127732c29c9f760c125cb94d6d574062abce1917" translate="yes" xml:space="preserve">
          <source>Additionally, you may pass optional keyword arguments that will then be passed to the application&amp;rsquo;s &lt;a href=&quot;#flask.Flask.test_client_class&quot;&gt;&lt;code&gt;test_client_class&lt;/code&gt;&lt;/a&gt; constructor. For example:</source>
          <target state="translated">또한 애플리케이션의 &lt;a href=&quot;#flask.Flask.test_client_class&quot;&gt; &lt;code&gt;test_client_class&lt;/code&gt; &lt;/a&gt; 생성자에 전달되는 선택적 키워드 인수를 전달할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c41c4c058075a99159d98df7edbd6d610ccc00bd" translate="yes" xml:space="preserve">
          <source>Advanced JavaScript APIs like Web Storage, Web Workers, Web Sockets, geolocation, and offline applications.</source>
          <target state="translated">웹 스토리지, 웹 작업자, 웹 소켓, 지리적 위치 및 오프라인 애플리케이션과 같은 고급 JavaScript API.</target>
        </trans-unit>
        <trans-unit id="e08852c98886ad9736bc0e4e330820e9bc018643" translate="yes" xml:space="preserve">
          <source>After installation, failures leading to an Internal Server Error are automatically reported to Sentry and from there you can receive error notifications.</source>
          <target state="translated">설치 후 내부 서버 오류로 이어지는 오류는 자동으로 Sentry에보고되며 여기에서 오류 알림을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818dc311a7b948e1bd4163f31be21530c088dc04" translate="yes" xml:space="preserve">
          <source>After the request is dispatched and a response is generated and sent, the request context is popped, which then pops the application context. Immediately before they are popped, the &lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt;&lt;code&gt;teardown_appcontext()&lt;/code&gt;&lt;/a&gt; functions are executed. These execute even if an unhandled exception occurred during dispatch.</source>
          <target state="translated">요청이 발송되고 응답이 생성되고 전송 된 후 요청 컨텍스트가 팝되고 애플리케이션 컨텍스트가 팝됩니다. 팝되기 직전에 &lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt; &lt;code&gt;teardown_appcontext()&lt;/code&gt; &lt;/a&gt; 함수가 실행됩니다. 디스패치 중에 처리되지 않은 예외가 발생한 경우에도 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6a98c08486fa3c149bb2785aac365101720d6591" translate="yes" xml:space="preserve">
          <source>After the response is returned, the contexts are popped, which calls the &lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt;&lt;code&gt;teardown_appcontext()&lt;/code&gt;&lt;/a&gt; functions. These functions are called even if an unhandled exception was raised at any point above.</source>
          <target state="translated">응답이 반환 된 후 컨텍스트가 팝되고 &lt;a href=&quot;../api/index#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/index#flask.Flask.teardown_appcontext&quot;&gt; &lt;code&gt;teardown_appcontext()&lt;/code&gt; &lt;/a&gt; 함수 를 호출합니다 . 이러한 함수는 위의 어느 지점에서든 처리되지 않은 예외가 발생한 경우에도 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d78392f79e5d33adbca1d23f20e3e6ce7cc1ec49" translate="yes" xml:space="preserve">
          <source>Ah yes, the good old problem of file uploads. The basic idea of file uploads is actually quite simple. It basically works like this:</source>
          <target state="translated">예, 파일 업로드의 좋은 오래된 문제입니다. 파일 업로드의 기본 아이디어는 실제로 매우 간단합니다. 기본적으로 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f268864f45c6e3f315eaaf78468f53b4cb4c0952" translate="yes" xml:space="preserve">
          <source>All the other objects that are context bound can be used in the same way.</source>
          <target state="translated">컨텍스트 바인딩 된 다른 모든 개체는 동일한 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc690de98c0fa022cc0df286ef0a014ef8a36240" translate="yes" xml:space="preserve">
          <source>All the template rendering in the code issued by the application &lt;code&gt;app&lt;/code&gt; in the body of the &lt;code&gt;with&lt;/code&gt; block will now be recorded in the &lt;code&gt;templates&lt;/code&gt; variable. Whenever a template is rendered, the template object as well as context are appended to it.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 의 본문 에있는 애플리케이션 &lt;code&gt;app&lt;/code&gt; 에서 발행 한 코드의 모든 템플릿 렌더링 이 이제 &lt;code&gt;templates&lt;/code&gt; 변수에 기록됩니다 . 템플릿이 렌더링 될 때마다 템플릿 개체와 컨텍스트가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="507aeda80f656daba1b3289b226bdb1c488abd21" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;../becomingbig/index#becomingbig&quot;&gt;Becoming Big&lt;/a&gt; section of the documentation for some inspiration for larger applications based on Flask.</source>
          <target state="translated">Flask를 기반으로 한 대규모 응용 프로그램에 대한 영감을 얻으려면 설명서 의 &lt;a href=&quot;../becomingbig/index#becomingbig&quot;&gt;Becoming Big&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c138c145742327977f47edc9d06d1fb8f77b58d" translate="yes" xml:space="preserve">
          <source>Alternative error attach function to the &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; decorator that is more straightforward to use for non decorator usage.</source>
          <target state="translated">데코레이터가 아닌 용도로 사용하기 더 쉬운 &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt; 데코레이터 에 대한 대체 오류 첨부 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="1449967837a0f8f4f2767773f545dc5489fa6df1" translate="yes" xml:space="preserve">
          <source>Alternative way to use view functions. A subclass has to implement &lt;a href=&quot;#flask.views.View.dispatch_request&quot;&gt;&lt;code&gt;dispatch_request()&lt;/code&gt;&lt;/a&gt; which is called with the view arguments from the URL routing system. If &lt;a href=&quot;#flask.views.View.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; is provided the methods do not have to be passed to the &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; method explicitly:</source>
          <target state="translated">보기 기능을 사용하는 다른 방법입니다. 서브 클래스는 URL 라우팅 시스템에서 뷰 인수로 호출되는 &lt;a href=&quot;#flask.views.View.dispatch_request&quot;&gt; &lt;code&gt;dispatch_request()&lt;/code&gt; &lt;/a&gt; 를 구현해야 합니다. 경우 &lt;a href=&quot;#flask.views.View.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt; 제공되는 방법은 전달 될 필요가 없습니다 &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt; 를 명시 적 방법 :</target>
        </trans-unit>
        <trans-unit id="16a9f9ac0ad45f893764dca63328a8a18a337d1b" translate="yes" xml:space="preserve">
          <source>Alternatively it can also be used around a specific generator:</source>
          <target state="translated">또는 특정 생성기 주변에서 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2e3c156eae7e4ca0c182f1eb6c2fca29b85396d" translate="yes" xml:space="preserve">
          <source>Alternatively you can also just test any of the context bound objects (such as &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;) for truthness:</source>
          <target state="translated">또는 컨텍스트 바인딩 된 객체 (예 : &lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; )의 진실성을 테스트 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cea46e1c9b2aeb57996f86aa618a4207b57e71b4" translate="yes" xml:space="preserve">
          <source>Alternatively you can also replace the standard out in the .wsgi file with a different stream:</source>
          <target state="translated">또는 .wsgi 파일의 표준 출력을 다른 스트림으로 바꿀 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce2f89670629847eb1b287b3acf601d237c323c0" translate="yes" xml:space="preserve">
          <source>Alternatively you can register &lt;code&gt;uploaded_file&lt;/code&gt; as &lt;code&gt;build_only&lt;/code&gt; rule and use the &lt;code&gt;SharedDataMiddleware&lt;/code&gt;. This also works with older versions of Flask:</source>
          <target state="translated">또는 당신이 등록 할 수 있습니다 &lt;code&gt;uploaded_file&lt;/code&gt; 로 &lt;code&gt;build_only&lt;/code&gt; 규칙과 사용 &lt;code&gt;SharedDataMiddleware&lt;/code&gt; 을 . 이것은 이전 버전의 Flask에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1209a2348e6f6f0f951ea448d089b55c306ae4a6" translate="yes" xml:space="preserve">
          <source>Alternatively you can use &lt;strong&gt;python -m flask&lt;/strong&gt;:</source>
          <target state="translated">또는 &lt;strong&gt;python -m flask를&lt;/strong&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f5d4d0c1794ab8d85dc447dd48c6b661b53ecee" translate="yes" xml:space="preserve">
          <source>Always keep security in mind when building web applications.</source>
          <target state="translated">웹 애플리케이션을 빌드 할 때 항상 보안을 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="289ede90dd7a50f8dd5352e865474a0d7cdee654" translate="yes" xml:space="preserve">
          <source>Always sends the &lt;a href=&quot;#flask.got_request_exception&quot;&gt;&lt;code&gt;got_request_exception&lt;/code&gt;&lt;/a&gt; signal.</source>
          <target state="translated">항상 &lt;a href=&quot;#flask.got_request_exception&quot;&gt; &lt;code&gt;got_request_exception&lt;/code&gt; &lt;/a&gt; 신호를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="847ed59d1e01df705057858a74719c5037938d57" translate="yes" xml:space="preserve">
          <source>An Easier Solution</source>
          <target state="translated">더 쉬운 솔루션</target>
        </trans-unit>
        <trans-unit id="f423e3fcd05e8dc46c86b0cbca3a05651f9d0906" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Namespace&quot;&gt;&lt;code&gt;blinker.base.Namespace&lt;/code&gt;&lt;/a&gt; if blinker is available, otherwise a dummy class that creates fake signals. This class is available for Flask extensions that want to provide the same fallback system as Flask itself.</source>
          <target state="translated">blinker를 사용할 수 있으면 &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Namespace&quot;&gt; &lt;code&gt;blinker.base.Namespace&lt;/code&gt; &lt;/a&gt; 의 별칭이고 , 그렇지 않으면 가짜 신호를 생성하는 더미 클래스입니다. 이 클래스는 Flask 자체와 동일한 대체 시스템을 제공하려는 Flask 확장에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85acfaaa1d25e718c9bad28068ae4867c9912c4f" translate="yes" xml:space="preserve">
          <source>An application context is automatically pushed by &lt;a href=&quot;#flask.ctx.RequestContext.push&quot;&gt;&lt;code&gt;RequestContext.push()&lt;/code&gt;&lt;/a&gt; when handling a request, and when running a CLI command. Use this to manually create a context outside of these situations.</source>
          <target state="translated">애플리케이션 컨텍스트는 요청을 처리 할 때와 CLI 명령을 실행할 때 &lt;a href=&quot;#flask.ctx.RequestContext.push&quot;&gt; &lt;code&gt;RequestContext.push()&lt;/code&gt; &lt;/a&gt; 의해 자동으로 푸시됩니다 . 이를 사용하여 이러한 상황 외부의 컨텍스트를 수동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="db9a574fa10b39c1cfd2a8d50039899172a86858" translate="yes" xml:space="preserve">
          <source>An error handler for &lt;code&gt;Exception&lt;/code&gt; might seem useful for changing how all errors, even unhandled ones, are presented to the user. However, this is similar to doing &lt;code&gt;except Exception:&lt;/code&gt; in Python, it will capture &lt;em&gt;all&lt;/em&gt; otherwise unhandled errors, including all HTTP status codes. In most cases it will be safer to register handlers for more specific exceptions. Since &lt;code&gt;HTTPException&lt;/code&gt; instances are valid WSGI responses, you could also pass them through directly.</source>
          <target state="translated">&lt;code&gt;Exception&lt;/code&gt; 대한 오류 처리기는 처리되지 않은 오류를 포함하여 모든 오류가 사용자에게 표시되는 방식을 변경하는 데 유용 할 수 있습니다. 그러나 이것은 &lt;code&gt;except Exception:&lt;/code&gt; 수행하는 것과 유사합니다 . Python에서는 모든 HTTP 상태 코드를 포함하여 처리되지 않은 &lt;em&gt;모든&lt;/em&gt; 오류를 캡처 &lt;em&gt;합니다&lt;/em&gt; . 대부분의 경우보다 구체적인 예외에 대한 처리기를 등록하는 것이 더 안전합니다. 이후 &lt;code&gt;HTTPException&lt;/code&gt; 인스턴스가 유효한 WSGI 응답은, 당신은 또한 직접 통과 할 수있다.</target>
        </trans-unit>
        <trans-unit id="3cf7f03bc9cf3707b9e0a35fa42e6ebd435a7a93" translate="yes" xml:space="preserve">
          <source>An error handler for &lt;code&gt;HTTPException&lt;/code&gt; might be useful for turning the default HTML errors pages into JSON, for example. However, this handler will trigger for things you don&amp;rsquo;t cause directly, such as 404 and 405 errors during routing. Be sure to craft your handler carefully so you don&amp;rsquo;t lose information about the HTTP error.</source>
          <target state="translated">예를 들어 &lt;code&gt;HTTPException&lt;/code&gt; 에 대한 오류 처리기 는 기본 HTML 오류 페이지를 JSON으로 전환하는 데 유용 할 수 있습니다. 그러나이 핸들러는 라우팅 중 404 및 405 오류와 같이 직접 유발하지 않는 항목에 대해 트리거합니다. HTTP 오류에 대한 정보가 손실되지 않도록 핸들러를 신중하게 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="31553be53bb397057392a940613ecd9d65a72fe6" translate="yes" xml:space="preserve">
          <source>An error handler is a function that returns a response when a type of error is raised, similar to how a view is a function that returns a response when a request URL is matched. It is passed the instance of the error being handled, which is most likely a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt;&lt;code&gt;HTTPException&lt;/code&gt;&lt;/a&gt;. An error handler for &amp;ldquo;500 Internal Server Error&amp;rdquo; will be passed uncaught exceptions in addition to explicit 500 errors.</source>
          <target state="translated">오류 처리기는 요청 URL이 일치 할 때보기가 응답을 반환하는 함수와 유사하게 오류 유형이 발생할 때 응답을 반환하는 함수입니다. 처리중인 오류의 인스턴스가 전달되며, 이는 대부분 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt; &lt;code&gt;HTTPException&lt;/code&gt; &lt;/a&gt; 입니다. &quot;500 내부 서버 오류&quot;에 대한 오류 처리기는 명시적인 500 오류와 함께 포착되지 않은 예외로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7583cf64c46b4ac7bd718bfd4455b17f59b37498" translate="yes" xml:space="preserve">
          <source>An error handler is a normal view function that returns a response, but instead of being registered for a route, it is registered for an exception or HTTP status code that would be raised while trying to handle a request.</source>
          <target state="translated">오류 처리기는 응답을 반환하는 일반보기 함수이지만 경로에 등록되는 대신 요청을 처리하려고 할 때 발생하는 예외 또는 HTTP 상태 코드에 대해 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="babf81c1e676cd3c68fece610d7bb3758e7d05e3" translate="yes" xml:space="preserve">
          <source>An error handler is registered with the &lt;a href=&quot;../../api/index#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; decorator or the &lt;a href=&quot;../../api/index#flask.Flask.register_error_handler&quot;&gt;&lt;code&gt;register_error_handler()&lt;/code&gt;&lt;/a&gt; method. A handler can be registered for a status code, like 404, or for an exception class.</source>
          <target state="translated">오류 처리기는 &lt;a href=&quot;../../api/index#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt; 데코레이터 또는 &lt;a href=&quot;../../api/index#flask.Flask.register_error_handler&quot;&gt; &lt;code&gt;register_error_handler()&lt;/code&gt; &lt;/a&gt; 메서드로 등록 됩니다. 핸들러는 404와 같은 상태 코드 또는 예외 클래스에 대해 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e14cc8fbc30e28e618c2dc3eecbc26215104a2b7" translate="yes" xml:space="preserve">
          <source>An example task</source>
          <target state="translated">예제 작업</target>
        </trans-unit>
        <trans-unit id="f6efc1688d5a45daa290e6d6cf264158bc711124" translate="yes" xml:space="preserve">
          <source>An example template might be this:</source>
          <target state="translated">예제 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0d6c061e1875fe92697103d688b473d28a68e1b" translate="yes" xml:space="preserve">
          <source>An important detail to keep in mind is how Flask deals with trailing slashes. The idea is to keep each URL unique so the following rules apply:</source>
          <target state="translated">명심해야 할 중요한 세부 사항은 Flask가 후행 슬래시를 처리하는 방법입니다. 아이디어는 다음 규칙이 적용되도록 각 URL을 고유하게 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="db5b90452dd064b31721fc5161870ff65a1aed6c" translate="yes" xml:space="preserve">
          <source>An interesting pattern is also to use classes and inheritance for configuration:</source>
          <target state="translated">흥미로운 패턴은 구성에 클래스와 상속을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="09f0293c81e7740c4bd123ab3e57e0c70615a643" translate="yes" xml:space="preserve">
          <source>An object containing all the etags in the &lt;code&gt;If-Match&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;If-Match&lt;/code&gt; 헤더 의 모든 etag를 포함하는 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac2d842f3e90047f4f1e54d903702a071851a89" translate="yes" xml:space="preserve">
          <source>An object containing all the etags in the &lt;code&gt;If-None-Match&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;If-None-Match&lt;/code&gt; 헤더 의 모든 etag를 포함하는 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="3b562e8c6436c654e7061c45b6c3fe3434dbbf56" translate="yes" xml:space="preserve">
          <source>Anatomy of an Extension</source>
          <target state="translated">확장의 구조</target>
        </trans-unit>
        <trans-unit id="e94319c1bf020c401da5f3f38cbf5025e4617c04" translate="yes" xml:space="preserve">
          <source>And a user requests the following URI:</source>
          <target state="translated">그리고 사용자는 다음 URI를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="f7d26d21cdeed0981240f879769f3bcdfe79034a" translate="yes" xml:space="preserve">
          <source>And here is the &lt;code&gt;layout.html&lt;/code&gt; template which does the magic:</source>
          <target state="translated">다음은 마법을 수행하는 &lt;code&gt;layout.html&lt;/code&gt; 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="3fb8c7b4995666cd2e7120ed7c08c418f0cce52c" translate="yes" xml:space="preserve">
          <source>And here is the &lt;code&gt;login.html&lt;/code&gt; template which also inherits from &lt;code&gt;layout.html&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;layout.html&lt;/code&gt; 에서 상속 된 &lt;code&gt;login.html&lt;/code&gt; 템플릿입니다 .</target>
        </trans-unit>
        <trans-unit id="0f5d18a3536983dc4e531b9dcaec9bbbfaaaea40" translate="yes" xml:space="preserve">
          <source>And in the testcode:</source>
          <target state="translated">그리고 테스트 코드에서 :</target>
        </trans-unit>
        <trans-unit id="1dba1cb85dcb715842f60c2067d240d784c1221c" translate="yes" xml:space="preserve">
          <source>And on PowerShell:</source>
          <target state="translated">그리고 PowerShell에서 :</target>
        </trans-unit>
        <trans-unit id="56ad954bc5ec6a3d5f7af6316f565b18e4f67f08" translate="yes" xml:space="preserve">
          <source>And sure enough, these are the generated rules:</source>
          <target state="translated">그리고 다음은 생성 된 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="9c7d77850f3305d286ef176ad6e2e9c956efe4e4" translate="yes" xml:space="preserve">
          <source>And that&amp;rsquo;s just a small sample of issues you could be facing. So how do we deal with that sort of problem? By default if your application runs in production mode, Flask will display a very simple page for you and log the exception to the &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그리고 그것은 당신이 직면 할 수있는 문제의 작은 샘플 일뿐입니다. 그렇다면 우리는 그런 종류의 문제를 어떻게 처리할까요? 기본적으로 애플리케이션이 프로덕션 모드에서 실행되는 경우 Flask는 매우 간단한 페이지를 표시하고 &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;logger&lt;/code&gt; 에&lt;/a&gt; 예외를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="a6bfc1d25efcb26f880d506024421cf94ad2ccb3" translate="yes" xml:space="preserve">
          <source>And then a file that sets up an application which maps the functions to URLs:</source>
          <target state="translated">그런 다음 함수를 URL에 매핑하는 애플리케이션을 설정하는 파일 :</target>
        </trans-unit>
        <trans-unit id="b51c9c5b85631e4acc879d8a1bce348186845eb5" translate="yes" xml:space="preserve">
          <source>And then add this to your Flask app:</source>
          <target state="translated">그런 다음 Flask 앱에 다음을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="533b002a87d2ada0769f6ee0fea913c8766087fc" translate="yes" xml:space="preserve">
          <source>And then to use it:</source>
          <target state="translated">그리고 그것을 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="6e0ae17b7d6a99158683a033596570964168bdf9" translate="yes" xml:space="preserve">
          <source>And then when you want to render the template, use &lt;code&gt;admin/index.html&lt;/code&gt; as the name to look up the template by. If you encounter problems loading the correct templates enable the &lt;code&gt;EXPLAIN_TEMPLATE_LOADING&lt;/code&gt; config variable which will instruct Flask to print out the steps it goes through to locate templates on every &lt;code&gt;render_template&lt;/code&gt; call.</source>
          <target state="translated">그런 다음 템플릿을 렌더링하려면 &lt;code&gt;admin/index.html&lt;/code&gt; 을 이름으로 사용하여 템플릿 을 찾습니다. 올바른 템플릿을로드하는 데 문제가 발생하면 모든 &lt;code&gt;render_template&lt;/code&gt; 호출 에서 템플릿을 찾기 위해 거치는 단계를 Flask에 인쇄하도록 지시 하는 &lt;code&gt;EXPLAIN_TEMPLATE_LOADING&lt;/code&gt; 구성 변수를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="e0926bf13e68014c22b95c5b92238ab1ee81f50c" translate="yes" xml:space="preserve">
          <source>And then you can register it like this:</source>
          <target state="translated">그런 다음 다음과 같이 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b18253d5b5036b46f7874c91258b409cd9052845" translate="yes" xml:space="preserve">
          <source>And this is what &lt;code&gt;views.py&lt;/code&gt; would look like:</source>
          <target state="translated">그리고 이것은 &lt;code&gt;views.py&lt;/code&gt; 의 모습입니다.</target>
        </trans-unit>
        <trans-unit id="1c739d246cd7cfddce1c486f15c60ae63ce3a75c" translate="yes" xml:space="preserve">
          <source>Another big problem is CSRF. This is a very complex topic and I won&amp;rsquo;t outline it here in detail just mention what it is and how to theoretically prevent it.</source>
          <target state="translated">또 다른 큰 문제는 CSRF입니다. 이것은 매우 복잡한 주제이며 여기에서 자세히 설명하지는 않겠습니다. 단지 그것이 무엇인지, 이론적으로 방지하는 방법 만 언급합니다.</target>
        </trans-unit>
        <trans-unit id="9d664dbb52b649d8964427320da489a5d20fd371" translate="yes" xml:space="preserve">
          <source>Another design decision with the Werkzeug routing system is that routes in Werkzeug try to ensure that URLs are unique. Werkzeug will go quite far with that in that it will automatically redirect to a canonical URL if a route is ambiguous.</source>
          <target state="translated">Werkzeug 라우팅 시스템의 또 다른 설계 결정은 Werkzeug의 경로가 URL이 고유한지 확인하는 것입니다. Werkzeug는 경로가 모호한 경우 자동으로 표준 URL로 리디렉션된다는 점에서 상당히 멀리 갈 것입니다.</target>
        </trans-unit>
        <trans-unit id="03fe96f9915fd131d685227fdc60d18426d288b7" translate="yes" xml:space="preserve">
          <source>Another method is using Google&amp;rsquo;s &lt;a href=&quot;https://developers.google.com/speed/libraries/&quot;&gt;AJAX Libraries API&lt;/a&gt; to load jQuery:</source>
          <target state="translated">또 다른 방법은 Google의 &lt;a href=&quot;https://developers.google.com/speed/libraries/&quot;&gt;AJAX Libraries API&lt;/a&gt; 를 사용하여 jQuery를로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2456b1a3a9821378311c6dec588b175df7e9dab" translate="yes" xml:space="preserve">
          <source>Another thing that becomes possible when you have an explicit object lying around in your code is that you can subclass the base class (&lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt;) to alter specific behavior. This would not be possible without hacks if the object were created ahead of time for you based on a class that is not exposed to you.</source>
          <target state="translated">코드에 명시적인 객체가있을 때 가능한 또 다른 것은 기본 클래스 ( &lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; )를 하위 클래스 로 지정하여 특정 동작을 변경할 수 있다는 것 입니다. 노출되지 않은 클래스를 기반으로 객체가 미리 생성 된 경우 해킹 없이는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ae7b0ced90a594a50519111fa1d63f8619905a17" translate="yes" xml:space="preserve">
          <source>Another thing that is very important are unquoted attributes. While Jinja2 can protect you from XSS issues by escaping HTML, there is one thing it cannot protect you from: XSS by attribute injection. To counter this possible attack vector, be sure to always quote your attributes with either double or single quotes when using Jinja expressions in them:</source>
          <target state="translated">매우 중요한 또 다른 것은 인용되지 않은 속성입니다. Jinja2는 HTML을 이스케이프하여 XSS 문제로부터 보호 할 수 있지만, 보호 할 수없는 한 가지는 속성 삽입에 의한 XSS입니다. 이 가능한 공격 벡터에 대응하려면 Jinja 표현식을 사용할 때 항상 큰 따옴표 또는 작은 따옴표로 속성을 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="718f58352cedf44e36e0f654d175821a4736704d" translate="yes" xml:space="preserve">
          <source>Any object with an &lt;code&gt;__html__&lt;/code&gt; method (like &lt;a href=&quot;#flask.Markup&quot;&gt;&lt;code&gt;Markup&lt;/code&gt;&lt;/a&gt;) will have that method called and then the return value is serialized as string.</source>
          <target state="translated">&lt;code&gt;__html__&lt;/code&gt; 메서드 (예 : &lt;a href=&quot;#flask.Markup&quot;&gt; &lt;code&gt;Markup&lt;/code&gt; &lt;/a&gt; )가있는 모든 객체 는 해당 메서드를 호출 한 다음 반환 값을 문자열로 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="0479bfa099a793b60ba5208efaa383042bc3c9c1" translate="yes" xml:space="preserve">
          <source>Anyways. To load such a file with Unicode you can use the built-in &lt;code&gt;str.decode()&lt;/code&gt; method:</source>
          <target state="translated">어쨌든. 이러한 파일을 유니 코드로로드하려면 내장 &lt;code&gt;str.decode()&lt;/code&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1baa5b3ea0aca60d8df85215f2f50bbe50e938a" translate="yes" xml:space="preserve">
          <source>Application Context</source>
          <target state="translated">애플리케이션 컨텍스트</target>
        </trans-unit>
        <trans-unit id="0b382e09fb96276f58d69081b28a4a6e7d24739f" translate="yes" xml:space="preserve">
          <source>Application Discovery</source>
          <target state="translated">애플리케이션 검색</target>
        </trans-unit>
        <trans-unit id="1befde27444168f0e15104dc1b3aed7343803483" translate="yes" xml:space="preserve">
          <source>Application Dispatching</source>
          <target state="translated">애플리케이션 파견</target>
        </trans-unit>
        <trans-unit id="482ce780a5a165b1acfc8f8173b16ab3c6c8c6e5" translate="yes" xml:space="preserve">
          <source>Application Errors</source>
          <target state="translated">응용 프로그램 오류</target>
        </trans-unit>
        <trans-unit id="1bbc88ce9d07e37b4bb0b9866ce7644caa8d1c0d" translate="yes" xml:space="preserve">
          <source>Application Factories</source>
          <target state="translated">응용 공장</target>
        </trans-unit>
        <trans-unit id="94eaee228802c36ccb1a20ce13dc259101e14953" translate="yes" xml:space="preserve">
          <source>Application Globals</source>
          <target state="translated">응용 프로그램 글로벌</target>
        </trans-unit>
        <trans-unit id="ec9fe4cad234fdd15a2851dbfe19cbf2c5368828" translate="yes" xml:space="preserve">
          <source>Application Object</source>
          <target state="translated">응용 프로그램 개체</target>
        </trans-unit>
        <trans-unit id="232ecb9d5f268ee33ecdfed2a13f507af5beb63e" translate="yes" xml:space="preserve">
          <source>Application Setup</source>
          <target state="translated">애플리케이션 설정</target>
        </trans-unit>
        <trans-unit id="70b524dbe1132c4b96eabd899598de1aca99c423" translate="yes" xml:space="preserve">
          <source>Application dispatching is the process of combining multiple Flask applications on the WSGI level. You can combine not only Flask applications but any WSGI application. This would allow you to run a Django and a Flask application in the same interpreter side by side if you want. The usefulness of this depends on how the applications work internally.</source>
          <target state="translated">애플리케이션 디스패치는 WSGI 수준에서 여러 Flask 애플리케이션을 결합하는 프로세스입니다. Flask 애플리케이션뿐만 아니라 모든 WSGI 애플리케이션을 결합 할 수 있습니다. 이렇게하면 원하는 경우 동일한 인터프리터에서 Django와 Flask 애플리케이션을 나란히 실행할 수 있습니다. 이것의 유용성은 응용 프로그램이 내부적으로 작동하는 방식에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a56c88741c7e75a94576f97ad9746d79e4d28901" translate="yes" xml:space="preserve">
          <source>Applications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. Here are some situations where perfectly fine code can lead to server errors:</source>
          <target state="translated">응용 프로그램이 실패하고 서버가 실패합니다. 조만간 프로덕션에서 예외가 표시됩니다. 코드가 100 % 정확하더라도 때때로 예외가 표시됩니다. 왜? 관련된 다른 모든 것이 실패하기 때문입니다. 다음은 완벽하게 정밀한 코드가 서버 오류로 이어질 수있는 몇 가지 상황입니다.</target>
        </trans-unit>
        <trans-unit id="d45766f0635638f2ac9ce97c726e692ce0ecbdd9" translate="yes" xml:space="preserve">
          <source>Applications need some kind of configuration. There are different settings you might want to change depending on the application environment like toggling the debug mode, setting the secret key, and other such environment-specific things.</source>
          <target state="translated">응용 프로그램에는 일종의 구성이 필요합니다. 디버그 모드 토글, 비밀 키 설정 및 기타 환경 관련 사항과 같이 애플리케이션 환경에 따라 변경할 수있는 다른 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="90073c69af9d03e9a79810f9c95f1f88d5c2cb59" translate="yes" xml:space="preserve">
          <source>Approved Extensions</source>
          <target state="translated">승인 된 확장</target>
        </trans-unit>
        <trans-unit id="f44bc1a10c4bec381194608fd123a45248619d7b" translate="yes" xml:space="preserve">
          <source>Artwork License</source>
          <target state="translated">작품 라이선스</target>
        </trans-unit>
        <trans-unit id="dfa73e1e38fc2d416312358f3e1de2d800c1d565" translate="yes" xml:space="preserve">
          <source>As an alternative, you can use &lt;a href=&quot;../../api/index#flask.after_this_request&quot;&gt;&lt;code&gt;after_this_request()&lt;/code&gt;&lt;/a&gt; to register callbacks that will execute after only the current request. This way you can defer code execution from anywhere in the application, based on the current request.</source>
          <target state="translated">대안으로 &lt;a href=&quot;../../api/index#flask.after_this_request&quot;&gt; &lt;code&gt;after_this_request()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 현재 요청 후에 만 ​​실행할 콜백을 등록 할 수 있습니다 . 이렇게하면 현재 요청을 기반으로 애플리케이션의 어느 위치에서든 코드 실행을 연기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ecf9e555ec328f54e5247ab141edcb313ea9b75" translate="yes" xml:space="preserve">
          <source>As in the declarative approach, you need to close the session after each request or application context shutdown. Put this into your application module:</source>
          <target state="translated">선언적 접근 방식과 마찬가지로 각 요청 또는 응용 프로그램 컨텍스트 종료 후 세션을 닫아야합니다. 이것을 애플리케이션 모듈에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="429d3190ab064762d7b5234e7814106f35e03fc0" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, dependencies are pulled from PyPI. What if you want to depend on a package that cannot be found on PyPI and won&amp;rsquo;t be because it is an internal package you don&amp;rsquo;t want to share with anyone? Just do it as if there was a PyPI entry and provide a list of alternative locations where setuptools should look for tarballs:</source>
          <target state="translated">앞서 언급했듯이 종속성은 PyPI에서 가져옵니다. PyPI에서 찾을 수없고 다른 사람과 공유하고 싶지 않은 내부 패키지이기 때문에 그렇지 않은 패키지에 의존하고 싶다면 어떻게해야합니까? PyPI 항목이있는 것처럼 수행하고 setuptools에서 tarball을 찾아야하는 대체 위치 목록을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="eb64137b80238c32059106f4cddd486b74d8f58b" translate="yes" xml:space="preserve">
          <source>As of Flask 0.7 this function might not be executed at the end of the request in case an unhandled exception occurred.</source>
          <target state="translated">Flask 0.7부터는 처리되지 않은 예외가 발생한 경우 요청이 끝날 때이 함수가 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa7f26ffb521cfc0ecadd4e7f3c8f302e825a39f" translate="yes" xml:space="preserve">
          <source>As of Flask 0.9, this will also be passed an &lt;code&gt;exc&lt;/code&gt; keyword argument that has a reference to the exception that caused the teardown if there was one.</source>
          <target state="translated">Flask 0.9부터 이것은 분해를 일으킨 예외에 대한 참조가있는 &lt;code&gt;exc&lt;/code&gt; 키워드 인수 도 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe672ca9561da98cf07399388755d626bf69a9e" translate="yes" xml:space="preserve">
          <source>As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.</source>
          <target state="translated">Werkzeug 0.14부터 HTTP 예외가 자동으로 포착되어 실패하지 않고 응답으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1e52f8f55011c6536fc417782b079d231f951bf5" translate="yes" xml:space="preserve">
          <source>As you can see I also added an &lt;code&gt;index&lt;/code&gt; method here that renders a template. This template will load jQuery as above and have a little form where we can add two numbers and a link to trigger the function on the server side.</source>
          <target state="translated">보시다시피 여기에 템플릿을 렌더링 하는 &lt;code&gt;index&lt;/code&gt; 메서드 도 추가했습니다 . 이 템플릿은 위와 같이 jQuery를로드하며 두 개의 숫자와 링크를 추가하여 서버 측에서 함수를 트리거 할 수있는 작은 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="29cdb0959749af801ddc6eca01d61d36324926d8" translate="yes" xml:space="preserve">
          <source>As you can see what you have to do is to create a subclass of &lt;a href=&quot;../api/index#flask.views.View&quot;&gt;&lt;code&gt;flask.views.View&lt;/code&gt;&lt;/a&gt; and implement &lt;a href=&quot;../api/index#flask.views.View.dispatch_request&quot;&gt;&lt;code&gt;dispatch_request()&lt;/code&gt;&lt;/a&gt;. Then we have to convert that class into an actual view function by using the &lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt;&lt;code&gt;as_view()&lt;/code&gt;&lt;/a&gt; class method. The string you pass to that function is the name of the endpoint that view will then have. But this by itself is not helpful, so let&amp;rsquo;s refactor the code a bit:</source>
          <target state="translated">당신이해야 할 일은 &lt;a href=&quot;../api/index#flask.views.View&quot;&gt; &lt;code&gt;flask.views.View&lt;/code&gt; &lt;/a&gt; 의 서브 클래스를 만들고 &lt;a href=&quot;../api/index#flask.views.View.dispatch_request&quot;&gt; &lt;code&gt;dispatch_request()&lt;/code&gt; &lt;/a&gt; 구현하는 것 입니다. 그런 다음 &lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt; &lt;code&gt;as_view()&lt;/code&gt; &lt;/a&gt; 클래스 메서드를 사용하여 해당 클래스를 실제 뷰 함수로 변환해야 합니다. 해당 함수에 전달하는 문자열은 뷰가 가질 엔드 포인트의 이름입니다. 그러나 이것은 그 자체로는 도움이되지 않으므로 코드를 약간 리팩토링 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7f480542440e3e9b25f0e27742f1cd4a8e4ba701" translate="yes" xml:space="preserve">
          <source>As you can see, if no template name is provided it will use the endpoint of the URL map with dots converted to slashes + &lt;code&gt;'.html'&lt;/code&gt;. Otherwise the provided template name is used. When the decorated function returns, the dictionary returned is passed to the template rendering function. If &lt;code&gt;None&lt;/code&gt; is returned, an empty dictionary is assumed, if something else than a dictionary is returned we return it from the function unchanged. That way you can still use the redirect function or return simple strings.</source>
          <target state="translated">보시다시피 템플릿 이름이 제공되지 않으면 점이 슬래시 + &lt;code&gt;'.html'&lt;/code&gt; 로 변환 된 URL 맵의 끝점을 사용합니다 . 그렇지 않으면 제공된 템플릿 이름이 사용됩니다. 데코 레이팅 된 함수가 반환되면 반환 된 사전이 템플릿 렌더링 함수로 전달됩니다. 경우 &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다 사전보다는 뭔가 다른 우리가 변경되지 않은 함수에서 반환 반환되는 경우, 빈 사전이, 가정한다. 이렇게하면 리디렉션 기능을 계속 사용하거나 간단한 문자열을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c4862932ab4b825fb6f01d93b96faac82e20fa2" translate="yes" xml:space="preserve">
          <source>As your codebase grows, you are free to make the design decisions appropriate for your project. Flask will continue to provide a very simple glue layer to the best that Python has to offer. You can implement advanced patterns in SQLAlchemy or another database tool, introduce non-relational data persistence as appropriate, and take advantage of framework-agnostic tools built for WSGI, the Python web interface.</source>
          <target state="translated">코드베이스가 커짐에 따라 프로젝트에 적합한 디자인 결정을 자유롭게 내릴 수 있습니다. Flask는 계속해서 Python이 제공해야하는 최선의 매우 간단한 접착 레이어를 제공 할 것입니다. SQLAlchemy 또는 다른 데이터베이스 도구에서 고급 패턴을 구현하고, 비 관계형 데이터 지속성을 적절하게 도입하고, Python 웹 인터페이스 인 WSGI 용으로 구축 된 프레임 워크에 구애받지 않는 도구를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df9635df2ab1616721bfddb6e3cb27a07c99352d" translate="yes" xml:space="preserve">
          <source>Assuming the number of &lt;code&gt;../&lt;/code&gt; is correct and you would join this with the &lt;code&gt;UPLOAD_FOLDER&lt;/code&gt; the user might have the ability to modify a file on the server&amp;rsquo;s filesystem he or she should not modify. This does require some knowledge about how the application looks like, but trust me, hackers are patient :)</source>
          <target state="translated">&lt;code&gt;../&lt;/code&gt; 의 수가 정확하고이를 &lt;code&gt;UPLOAD_FOLDER&lt;/code&gt; 와 결합 하면 사용자는 수정해서는 안되는 서버의 파일 시스템에있는 파일을 수정할 수 있습니다. 이것은 응용 프로그램이 어떻게 보이는지에 대한 지식이 필요하지만 나를 믿으십시오. 해커는 인내심이 있습니다. :)</target>
        </trans-unit>
        <trans-unit id="0b1d5b963a3d02a52dae0984ed55325d9ee52447" translate="yes" xml:space="preserve">
          <source>At any time during a request, we can register a function to be called at the end of the request. For example you can remember the current language of the user in a cookie in a &lt;a href=&quot;../../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">요청 중 언제든지 요청이 끝날 때 호출 할 함수를 등록 할 수 있습니다. 예를 들어 &lt;a href=&quot;../../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt; 콜백 의 쿠키에서 사용자의 현재 언어를 기억할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="322acaee058caa60e169e066cbcd8e93462dfb2d" translate="yes" xml:space="preserve">
          <source>At that point views can raise that error, but it would immediately result in an internal server error. The reason for this is that there is no handler registered for this error class. That however is easy to add:</source>
          <target state="translated">이 시점에서 뷰는 해당 오류를 일으킬 수 있지만 즉시 내부 서버 오류가 발생합니다. 그 이유는이 오류 클래스에 대해 등록 된 핸들러가 없기 때문입니다. 그러나 추가하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="c9a96008e518a9139314992c3ed94fb69a2219c1" translate="yes" xml:space="preserve">
          <source>At the end of a request, the request context is popped and all data associated with it is destroyed. If an error occurs during development, it is useful to delay destroying the data for debugging purposes.</source>
          <target state="translated">요청이 끝나면 요청 컨텍스트가 팝되고 이와 관련된 모든 데이터가 삭제됩니다. 개발 중에 오류가 발생하면 디버깅 목적으로 데이터 삭제를 지연하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="74e0b9c80dca267a78a89ad68a2f6c73241b5973" translate="yes" xml:space="preserve">
          <source>Attention</source>
          <target state="translated">Attention</target>
        </trans-unit>
        <trans-unit id="a9c2465d40c6ff28cd0028a8b25fb8a625fe36a4" translate="yes" xml:space="preserve">
          <source>Auto-Sort JSON Keys</source>
          <target state="translated">JSON 키 자동 정렬</target>
        </trans-unit>
        <trans-unit id="431768b965122900cb3abe050d3738818642ba2f" translate="yes" xml:space="preserve">
          <source>Autoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt; as well as &lt;code&gt;'&lt;/code&gt;. Because these characters carry specific meanings in documents on their own you have to replace them by so called &amp;ldquo;entities&amp;rdquo; if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see &lt;a href=&quot;../security/index#xss&quot;&gt;Cross-Site Scripting (XSS)&lt;/a&gt;)</source>
          <target state="translated">자동 이스케이프는 특수 문자를 자동으로 이스케이프하는 개념입니다. HTML (또는 XML, 따라서 XHTML)의 의미에서 특수 문자는 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; 및 &lt;code&gt;'&lt;/code&gt; 입니다. 이러한 문자는 문서에서 특정 의미를 가지고 있기 때문에 소위&quot;엔티티 &quot;로 대체해야합니다. 텍스트에 사용하려는 경우. 이렇게하지 않으면 텍스트에서 이러한 문자를 사용할 수 없어 사용자가 불만을 가질뿐만 아니라 보안 문제가 발생할 수도 있습니다 &lt;a href=&quot;../security/index#xss&quot;&gt;(XSS (교차 사이트 스크립팅) 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5a41840a815d8a5bb36e5aec0415e559e6edd94" translate="yes" xml:space="preserve">
          <source>Automatic Conversion</source>
          <target state="translated">자동 변환</target>
        </trans-unit>
        <trans-unit id="898bd70882d28216c8eaa47b2cb22b340d9a636b" translate="yes" xml:space="preserve">
          <source>Automatic escaping is enabled, so if &lt;code&gt;name&lt;/code&gt; contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Markup&quot;&gt;&lt;code&gt;Markup&lt;/code&gt;&lt;/a&gt; class or by using the &lt;code&gt;|safe&lt;/code&gt; filter in the template. Head over to the Jinja 2 documentation for more examples.</source>
          <target state="translated">자동 이스케이프가 활성화되어 있으므로 &lt;code&gt;name&lt;/code&gt; 에 HTML이 포함 되어 있으면 자동으로 이스케이프됩니다. 변수를 신뢰할 수 있고 그것이 안전한 HTML이라는 것을 알고 있다면 (예를 들어 위키 마크 업을 HTML로 변환하는 모듈에서 왔기 때문에) &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Markup&quot;&gt; &lt;code&gt;Markup&lt;/code&gt; &lt;/a&gt; 클래스를 사용하거나 &lt;code&gt;|safe&lt;/code&gt; 필터를 사용 하여 안전한 것으로 표시 할 수 있습니다 . 템플릿. 더 많은 예제를 보려면 Jinja 2 문서로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="635dad9cdab682202ef019467eedc43b2db6b953" translate="yes" xml:space="preserve">
          <source>Base Template</source>
          <target state="translated">기본 템플릿</target>
        </trans-unit>
        <trans-unit id="d7af0727c1e939b73c0e17de1cc4586281bf2e99" translate="yes" xml:space="preserve">
          <source>Base class for defining type tags for &lt;a href=&quot;#flask.json.tag.TaggedJSONSerializer&quot;&gt;&lt;code&gt;TaggedJSONSerializer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#flask.json.tag.TaggedJSONSerializer&quot;&gt; &lt;code&gt;TaggedJSONSerializer&lt;/code&gt; 의&lt;/a&gt; 유형 태그를 정의하기위한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="9286d334e6e100f71897534c374b139c406bf6ec" translate="yes" xml:space="preserve">
          <source>Base class for sessions based on signed cookies.</source>
          <target state="translated">서명 된 쿠키를 기반으로하는 세션의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bd469c56906ea9e74e4f792af86add46cb4f5100" translate="yes" xml:space="preserve">
          <source>Basic Configuration</source>
          <target state="translated">기본 구성</target>
        </trans-unit>
        <trans-unit id="a107e1836ce82fe9574c5042911e8e3638b91058" translate="yes" xml:space="preserve">
          <source>Basic Factories</source>
          <target state="translated">기본 공장</target>
        </trans-unit>
        <trans-unit id="91c71a0c161c3ad6867849ce33b18ad61cecc69c" translate="yes" xml:space="preserve">
          <source>Basic Principle</source>
          <target state="translated">기초 원리</target>
        </trans-unit>
        <trans-unit id="9c212f3efd5bb5d69784cc276ebd4bee1712b7de" translate="yes" xml:space="preserve">
          <source>Basic Setup Script</source>
          <target state="translated">기본 설정 스크립트</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="4eb7f2e37f3e5a48905b7cc1e0e3480bac481332" translate="yes" xml:space="preserve">
          <source>Basic setup can be done by defining &lt;code&gt;MONGODB_SETTINGS&lt;/code&gt; on &lt;code&gt;app.config&lt;/code&gt; and creating a &lt;code&gt;MongoEngine&lt;/code&gt; instance.</source>
          <target state="translated">기본 설정은 &lt;code&gt;app.config&lt;/code&gt; 에서 &lt;code&gt;MONGODB_SETTINGS&lt;/code&gt; 를 정의 하고 &lt;code&gt;MongoEngine&lt;/code&gt; 인스턴스를 생성하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31d67a3d9dab80eee447b1ef5b8330cd90fbc902" translate="yes" xml:space="preserve">
          <source>Basic usage is outlined in the &lt;a href=&quot;../testing/index#testing&quot;&gt;Testing Flask Applications&lt;/a&gt; chapter.</source>
          <target state="translated">기본 사용법은 &lt;a href=&quot;../testing/index#testing&quot;&gt;Flask 애플리케이션 테스트&lt;/a&gt; 장에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ebdcc5883245e308a52923dcb83fb481aef99f6" translate="yes" xml:space="preserve">
          <source>Basically this example:</source>
          <target state="translated">기본적으로이 예 :</target>
        </trans-unit>
        <trans-unit id="3da77b5a25e7609d5941425853c06683bc283931" translate="yes" xml:space="preserve">
          <source>Be careful when enabling this, as it is very difficult to undo if you set up or upgrade your key incorrectly.</source>
          <target state="translated">키를 잘못 설정하거나 업그레이드 한 경우 실행 취소하기가 매우 어렵 기 때문에 활성화 할 때주의하십시오.</target>
        </trans-unit>
        <trans-unit id="e0aea438e5506ba10731c5e3c1eb32960490ea5b" translate="yes" xml:space="preserve">
          <source>Because SQLAlchemy is a common database abstraction layer and object relational mapper that requires a little bit of configuration effort, there is a Flask extension that handles that for you. This is recommended if you want to get started quickly.</source>
          <target state="translated">SQLAlchemy는 약간의 구성 작업이 필요한 일반적인 데이터베이스 추상화 계층 및 개체 관계형 매퍼이므로이를 처리하는 Flask 확장이 있습니다. 빠르게 시작하려는 경우 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="f8a76bb5f330a4ddd98d1a4e197d37b503ba1110" translate="yes" xml:space="preserve">
          <source>Because SQLite3 is filesystem-based, we can easily use the &lt;a href=&quot;https://docs.python.org/3/library/tempfile.html#module-tempfile&quot;&gt;&lt;code&gt;tempfile&lt;/code&gt;&lt;/a&gt; module to create a temporary database and initialize it. The &lt;a href=&quot;https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt; function does two things for us: it returns a low-level file handle and a random file name, the latter we use as database name. We just have to keep the &lt;code&gt;db_fd&lt;/code&gt; around so that we can use the &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.close&quot;&gt;&lt;code&gt;os.close()&lt;/code&gt;&lt;/a&gt; function to close the file.</source>
          <target state="translated">SQLite3는 파일 시스템 기반이기 때문에 &lt;a href=&quot;https://docs.python.org/3/library/tempfile.html#module-tempfile&quot;&gt; &lt;code&gt;tempfile&lt;/code&gt; &lt;/a&gt; 모듈을 쉽게 사용하여 임시 데이터베이스를 만들고 초기화 할 수 있습니다. &lt;a href=&quot;https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; 함수는 우리를 위해이 일을 : 그것은 낮은 수준의 파일 핸들과 임의의 파일 이름, 데이터베이스 이름과 후자의 우리의 사용을 반환합니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.close&quot;&gt; &lt;code&gt;os.close()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 파일을 닫을 수 있도록 &lt;code&gt;db_fd&lt;/code&gt; 를 유지 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="03053882cbbd40735671a6a0246419440cdeb62c" translate="yes" xml:space="preserve">
          <source>Because blueprints can automatically prefix all URLs with a common string it&amp;rsquo;s easy to automatically do that for every function. Furthermore blueprints can have per-blueprint URL processors which removes a whole lot of logic from the &lt;a href=&quot;../../api/index#flask.Flask.url_defaults&quot;&gt;&lt;code&gt;url_defaults()&lt;/code&gt;&lt;/a&gt; function because it no longer has to check if the URL is really interested in a &lt;code&gt;'lang_code'&lt;/code&gt; parameter:</source>
          <target state="translated">청사진은 모든 URL에 공통 문자열을 자동으로 접두사로 붙일 수 있기 때문에 모든 함수에 대해 자동으로 쉽게 수행 할 수 있습니다. 또한 블루 프린트는 URL이 &lt;code&gt;'lang_code'&lt;/code&gt; 매개 변수 에 실제로 관심이 있는지 더 이상 확인할 필요가 없기 때문에 &lt;a href=&quot;../../api/index#flask.Flask.url_defaults&quot;&gt; &lt;code&gt;url_defaults()&lt;/code&gt; &lt;/a&gt; 함수 에서 많은 로직을 제거하는 블루 프린트 별 URL 프로세서를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7518eb9cac99d309b153989a9c66124299d72fa" translate="yes" xml:space="preserve">
          <source>Because the common pattern for file uploads exists almost unchanged in all applications dealing with uploads, there is also a Flask extension called &lt;a href=&quot;https://pythonhosted.org/Flask-Uploads/&quot;&gt;Flask-Uploads&lt;/a&gt; that implements a full fledged upload mechanism with white and blacklisting of extensions and more.</source>
          <target state="translated">파일 업로드의 일반적인 패턴은 업로드를 처리하는 모든 애플리케이션에서 거의 변경되지 않았기 때문에 &lt;a href=&quot;https://pythonhosted.org/Flask-Uploads/&quot;&gt;Flask-Uploads&lt;/a&gt; 라는 Flask 확장 프로그램이 있으며 확장 프로그램의 화이트리스트 및 블랙리스트 등이 포함 된 완전한 업로드 메커니즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8e7c6e95260e22d70d78d585270c698ff3cc6d7f" translate="yes" xml:space="preserve">
          <source>Because the contexts are stacks, other contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together.</source>
          <target state="translated">컨텍스트가 스택이기 때문에 요청 중에 프록시를 변경하기 위해 다른 컨텍스트가 푸시 될 수 있습니다. 이것은 일반적인 패턴은 아니지만 고급 애플리케이션에서 예를 들어 내부 리디렉션을 수행하거나 서로 다른 애플리케이션을 함께 연결하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9663e12afd3f3f464b408c3bdc0363d90b893bcc" translate="yes" xml:space="preserve">
          <source>Because you have Flask installed, you have setuptools available on your system. Flask already depends upon setuptools.</source>
          <target state="translated">Flask가 설치되어 있으므로 시스템에서 사용할 수있는 setuptools가 있습니다. Flask는 이미 setuptools에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="919dac07248373ed4b099b9f81e3fb183ac920dd" translate="yes" xml:space="preserve">
          <source>Becoming Big</source>
          <target state="translated">커지다</target>
        </trans-unit>
        <trans-unit id="89ec4a3236b5dbb059e79dd553185c8dedfdf40f" translate="yes" xml:space="preserve">
          <source>Before each request, &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; functions are called. If one of these functions return a value, the other functions are skipped. The return value is treated as the response and the view function is not called.</source>
          <target state="translated">각 요청 전에 &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt; 함수가 호출됩니다. 이러한 함수 중 하나가 값을 반환하면 다른 함수는 건너 뜁니다. 반환 값은 응답으로 처리되고 뷰 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01f06cbbeba52066464fca94256f9c78e9879377" translate="yes" xml:space="preserve">
          <source>Before we get started, here a quick checklist of things we have to ensure upfront:</source>
          <target state="translated">시작하기 전에 먼저 확인해야 할 사항에 대한 빠른 체크리스트를 확인하세요.</target>
        </trans-unit>
        <trans-unit id="773697863a1f19274a7dfd29269ef9ba65571ae6" translate="yes" xml:space="preserve">
          <source>Before you work on your project, activate the corresponding environment:</source>
          <target state="translated">프로젝트에서 작업하기 전에 해당 환경을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="da988a71250c443db442047cbf96e2efb65f766d" translate="yes" xml:space="preserve">
          <source>Besides the default client-side based sessions, if you want to handle sessions on the server-side instead, there are several Flask extensions that support this.</source>
          <target state="translated">기본 클라이언트 측 기반 세션 외에도 서버 측에서 세션을 처리하려는 경우이를 지원하는 여러 Flask 확장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd25541894888f37726e1f600a45fb7d7ef0a699" translate="yes" xml:space="preserve">
          <source>Besides using the test client as shown above, there is also the &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; method that can be used in combination with the &lt;code&gt;with&lt;/code&gt; statement to activate a request context temporarily. With this you can access the &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; objects like in view functions. Here is a full example that demonstrates this approach:</source>
          <target state="translated">위와 같이 테스트 클라이언트를 사용하는 것 외에도 &lt;code&gt;with&lt;/code&gt; 문과 함께 사용하여 요청 컨텍스트를 일시적으로 활성화 할 수있는 &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt; 메서드도 있습니다 . 이를 통해 보기 함수에서와 같이 &lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt; 객체에 액세스 할 수 있습니다 . 다음은이 접근 방식을 보여주는 전체 예입니다.</target>
        </trans-unit>
        <trans-unit id="a9f2010cd78892a4a87daaa8bd15390675aec382" translate="yes" xml:space="preserve">
          <source>Binds the app context to the current context.</source>
          <target state="translated">앱 컨텍스트를 현재 컨텍스트에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="c56c640305e7ac28f9122f43101dd9822c8a2ac6" translate="yes" xml:space="preserve">
          <source>Binds the request context to the current context.</source>
          <target state="translated">요청 컨텍스트를 현재 컨텍스트에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="ce7cb6bc22a89b2c6c5e6c013f51a9e7e9390e3a" translate="yes" xml:space="preserve">
          <source>Blinker API Changes</source>
          <target state="translated">Blinker API 변경 사항</target>
        </trans-unit>
        <trans-unit id="28523a50c311d95033bcd6fd0e09721675b39480" translate="yes" xml:space="preserve">
          <source>Blog Blueprint</source>
          <target state="translated">블로그 청사진</target>
        </trans-unit>
        <trans-unit id="e187454ce032cd2b74b8cbc3b2f690806bdf8987" translate="yes" xml:space="preserve">
          <source>Blueprint Objects</source>
          <target state="translated">청사진 개체</target>
        </trans-unit>
        <trans-unit id="8869680c1558ac786aa3fd64f14a5e39ef4524f7" translate="yes" xml:space="preserve">
          <source>Blueprint Resource Folder</source>
          <target state="translated">청사진 리소스 폴더</target>
        </trans-unit>
        <trans-unit id="19df03c6577c532919c585ae6d4a950e40f55cb6" translate="yes" xml:space="preserve">
          <source>Blueprint Resources</source>
          <target state="translated">청사진 리소스</target>
        </trans-unit>
        <trans-unit id="9d1763e90fc1c5206782d556f03d6d89e0f509b8" translate="yes" xml:space="preserve">
          <source>Blueprint local JSON decoder class to use. Set to &lt;code&gt;None&lt;/code&gt; to use the app&amp;rsquo;s &lt;code&gt;json_decoder&lt;/code&gt;.</source>
          <target state="translated">사용할 블루 프린트 로컬 JSON 디코더 클래스입니다. 앱의 &lt;code&gt;json_decoder&lt;/code&gt; 를 사용하려면 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f443a88ab0f754e6786c7c59e6380fc6cae7bf5c" translate="yes" xml:space="preserve">
          <source>Blueprint local JSON decoder class to use. Set to &lt;code&gt;None&lt;/code&gt; to use the app&amp;rsquo;s &lt;code&gt;json_encoder&lt;/code&gt;.</source>
          <target state="translated">사용할 블루 프린트 로컬 JSON 디코더 클래스입니다. 앱의 &lt;code&gt;json_encoder&lt;/code&gt; 를 사용하려면 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e26872b9648b776c064bd79ecbeb13d9a710f560" translate="yes" xml:space="preserve">
          <source>Blueprints and Views</source>
          <target state="translated">청사진 및보기</target>
        </trans-unit>
        <trans-unit id="9b9934a2bb165a997112188dfcc8ed30bc79eba7" translate="yes" xml:space="preserve">
          <source>Blueprints can provide resources as well. Sometimes you might want to introduce a blueprint only for the resources it provides.</source>
          <target state="translated">청사진은 리소스도 제공 할 수 있습니다. 때로는 제공하는 리소스에 대해서만 청사진을 도입하고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbb06dcf201c264530fdf4fc015b64e6f5dc1dcc" translate="yes" xml:space="preserve">
          <source>Blueprints however can also be mounted at different locations:</source>
          <target state="translated">그러나 청사진은 다른 위치에 장착 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e877154c7c59941449dd208a49e022478d7785d9" translate="yes" xml:space="preserve">
          <source>Blueprints in Flask are intended for these cases:</source>
          <target state="translated">Flask의 블루 프린트는 다음과 같은 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="68cf96389be6dd8a1eb52d5bfe610261c8c10c10" translate="yes" xml:space="preserve">
          <source>Blueprints instead provide separation at the Flask level, share application config, and can change an application object as necessary with being registered. The downside is that you cannot unregister a blueprint once an application was created without having to destroy the whole application object.</source>
          <target state="translated">Blueprint는 대신 Flask 수준에서 분리를 제공하고 애플리케이션 구성을 공유하며 등록과 함께 필요에 따라 애플리케이션 개체를 변경할 수 있습니다. 단점은 전체 애플리케이션 객체를 삭제하지 않고 애플리케이션이 생성 된 후에 청사진을 등록 취소 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32da83077ee38787003fa60e4e6d4cc5dfea7fb1" translate="yes" xml:space="preserve">
          <source>Blueprints support the &lt;code&gt;errorhandler&lt;/code&gt; decorator just like the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; application object, so it is easy to make Blueprint-specific custom error pages.</source>
          <target state="translated">Blueprint 는 &lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 애플리케이션 객체 와 마찬가지로 &lt;code&gt;errorhandler&lt;/code&gt; 데코레이터를 지원 하므로 Blueprint 관련 사용자 지정 오류 페이지를 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ad8e3e212daf47ac1270042fe516649f6d171fe" translate="yes" xml:space="preserve">
          <source>Both args and kwargs: Behavior undefined and will throw an exception.</source>
          <target state="translated">args와 kwargs 둘 다 : 동작이 정의되지 않았으며 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a2bf4bcf38add73d606007219a80dd201626ca24" translate="yes" xml:space="preserve">
          <source>Browsers recognize various response headers in order to control security. We recommend reviewing each of the headers below for use in your application. The &lt;a href=&quot;https://github.com/GoogleCloudPlatform/flask-talisman&quot;&gt;Flask-Talisman&lt;/a&gt; extension can be used to manage HTTPS and the security headers for you.</source>
          <target state="translated">브라우저는 보안을 제어하기 위해 다양한 응답 헤더를 인식합니다. 애플리케이션에서 사용하려면 아래의 각 헤더를 검토하는 것이 좋습니다. &lt;a href=&quot;https://github.com/GoogleCloudPlatform/flask-talisman&quot;&gt;플라스크 - 부적의&lt;/a&gt; 확장은 HTTPS 및 보안 헤더를 관리하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10ae17083002920b48a55b3bfde49290c0d8e24" translate="yes" xml:space="preserve">
          <source>Browsers will not allow JavaScript access to cookies marked as &amp;ldquo;HTTP only&amp;rdquo; for security.</source>
          <target state="translated">브라우저는 보안을 위해 &quot;HTTP 전용&quot;으로 표시된 쿠키에 대한 JavaScript 액세스를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5beb7ec44719f6a2a355f608eae77f829da17828" translate="yes" xml:space="preserve">
          <source>Browsers will only send cookies with requests over HTTPS if the cookie is marked &amp;ldquo;secure&amp;rdquo;. The application must be served over HTTPS for this to make sense.</source>
          <target state="translated">브라우저는 쿠키가 &quot;보안&quot;으로 표시된 경우에만 HTTPS를 통해 요청과 함께 쿠키를 보냅니다. 이를 위해서는 애플리케이션이 HTTPS를 통해 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e3d2578989b066f6d4e0e3d492f28b294aef6801" translate="yes" xml:space="preserve">
          <source>Building Extensions</source>
          <target state="translated">건물 확장</target>
        </trans-unit>
        <trans-unit id="24a17a340fbee0864ce0a8271da3ffb26fa7ec22" translate="yes" xml:space="preserve">
          <source>Building URLs</source>
          <target state="translated">URL 구축</target>
        </trans-unit>
        <trans-unit id="3f67d141fd1b87061a795432bd6a02f61faa7895" translate="yes" xml:space="preserve">
          <source>Builtin Configuration Values</source>
          <target state="translated">기본 구성 값</target>
        </trans-unit>
        <trans-unit id="47093a2abfc52cd76841b5fbf3ca50afcf5cf0a6" translate="yes" xml:space="preserve">
          <source>But how do you run your application now? The naive &lt;code&gt;python
yourapplication/__init__.py&lt;/code&gt; will not work. Let&amp;rsquo;s just say that Python does not want modules in packages to be the startup file. But that is not a big problem, just add a new file called &lt;code&gt;setup.py&lt;/code&gt; next to the inner &lt;code&gt;yourapplication&lt;/code&gt; folder with the following contents:</source>
          <target state="translated">하지만 지금 애플리케이션을 어떻게 실행합니까? 순진한 &lt;code&gt;python yourapplication/__init__.py&lt;/code&gt; 가 작동하지 않습니다. 파이썬이 패키지의 모듈이 시작 파일이되는 것을 원하지 않는다고 가정 해 봅시다. 그러나 그것은 큰 문제가 아닙니다 . 다음과 같은 내용 이있는 내부 &lt;code&gt;yourapplication&lt;/code&gt; 폴더 옆에 &lt;code&gt;setup.py&lt;/code&gt; 라는 새 파일을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2716a82e2c1adf6b0097dc58eab7f3e25a902033" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s about where similarities end. Jinja2 for example has an extensive filter system, a certain way to do template inheritance, support for reusable blocks (macros) that can be used from inside templates and also from Python code, uses Unicode for all operations, supports iterative template rendering, configurable syntax and more. On the other hand an engine like Genshi is based on XML stream evaluation, template inheritance by taking the availability of XPath into account and more. Mako on the other hand treats templates similar to Python modules.</source>
          <target state="translated">그러나 그것은 유사성이 끝나는 곳입니다. 예를 들어 Jinja2에는 광범위한 필터 시스템, 템플릿 상속을 수행하는 특정 방법, 템플릿 내부 및 Python 코드에서 사용할 수있는 재사용 가능한 블록 (매크로) 지원, 모든 작업에 유니 코드 사용, 반복 템플릿 렌더링 지원, 구성 가능한 구문 지원 그리고 더. 반면 Genshi와 같은 엔진은 XML 스트림 평가, XPath의 가용성 등을 고려하여 템플릿 상속을 기반으로합니다. 반면에 Mako는 Python 모듈과 유사한 템플릿을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0228d7a741a09feff13178679bff86e3565bf31c" translate="yes" xml:space="preserve">
          <source>But there is another very important reason why Flask depends on an explicit instantiation of that class: the package name. Whenever you create a Flask instance you usually pass it &lt;code&gt;__name__&lt;/code&gt; as package name. Flask depends on that information to properly load resources relative to your module. With Python&amp;rsquo;s outstanding support for reflection it can then access the package to figure out where the templates and static files are stored (see &lt;a href=&quot;../api/index#flask.Flask.open_resource&quot;&gt;&lt;code&gt;open_resource()&lt;/code&gt;&lt;/a&gt;). Now obviously there are frameworks around that do not need any configuration and will still be able to load templates relative to your application module. But they have to use the current working directory for that, which is a very unreliable way to determine where the application is. The current working directory is process-wide and if you are running multiple applications in one process (which could happen in a webserver without you knowing) the paths will be off. Worse: many webservers do not set the working directory to the directory of your application but to the document root which does not have to be the same folder.</source>
          <target state="translated">그러나 Flask가 해당 클래스의 명시 적 인스턴스화에 의존하는 또 다른 매우 중요한 이유가 있습니다. 바로 패키지 이름입니다. Flask 인스턴스를 만들 때마다 일반적으로 &lt;code&gt;__name__&lt;/code&gt; 을 패키지 이름 으로 전달합니다 . Flask는 해당 정보에 따라 모듈과 관련된 리소스를 적절하게로드합니다. 리플렉션에 대한 Python의 뛰어난 지원을 통해 패키지에 액세스하여 템플릿과 정적 파일이 저장되는 위치를 파악할 수 있습니다 ( &lt;a href=&quot;../api/index#flask.Flask.open_resource&quot;&gt; &lt;code&gt;open_resource()&lt;/code&gt; &lt;/a&gt; 참조 ).). 이제는 구성이 필요하지 않고 애플리케이션 모듈과 관련된 템플릿을로드 할 수있는 프레임 워크가 있습니다. 그러나 그들은이를 위해 현재 작업 디렉토리를 사용해야하는데, 이는 애플리케이션이 어디에 있는지 결정하는 데 매우 신뢰할 수없는 방법입니다. 현재 작업 디렉토리는 프로세스 전체이며 한 프로세스에서 여러 응용 프로그램을 실행하는 경우 (알지 못하는 사이 웹 서버에서 발생할 수 있음) 경로가 해제됩니다. 더 나쁜 것은 많은 웹 서버가 작업 디렉토리를 애플리케이션의 디렉토리로 설정하지 않고 동일한 폴더 일 필요는없는 문서 루트로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e9c0a6f5ac7abfd4b33cc718933fabd02c8a453c" translate="yes" xml:space="preserve">
          <source>But there is more you can do, and we will cover some better setups to deal with errors.</source>
          <target state="translated">하지만 더 많은 작업을 수행 할 수 있으며 오류를 처리하기위한 더 나은 설정을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc57173736c33e36ad242c7b7809992d13821316" translate="yes" xml:space="preserve">
          <source>But, rather, in model.py (or equivalent):</source>
          <target state="translated">그러나 오히려 model.py (또는 동등한 것)에서 :</target>
        </trans-unit>
        <trans-unit id="d40d812bb7e58370cc1c31b48503c3bfde276a18" translate="yes" xml:space="preserve">
          <source>By default a black and white error page is shown for each error code. If you want to customize the error page, you can use the &lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; decorator:</source>
          <target state="translated">기본적으로 각 오류 코드에 대해 흑백 오류 페이지가 표시됩니다. 오류 페이지를 사용자 정의하려면 &lt;a href=&quot;../api/index#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="705af05a972476503093f5f52593005e3900f0f8" translate="yes" xml:space="preserve">
          <source>By default an &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt;&lt;code&gt;ImmutableMultiDict&lt;/code&gt;&lt;/a&gt; is returned from this function. This can be changed by setting &lt;a href=&quot;#flask.Request.parameter_storage_class&quot;&gt;&lt;code&gt;parameter_storage_class&lt;/code&gt;&lt;/a&gt; to a different type. This might be necessary if the order of the form data is important.</source>
          <target state="translated">기본적 으로이 함수에서 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt; &lt;code&gt;ImmutableMultiDict&lt;/code&gt; &lt;/a&gt; 가 반환됩니다. &lt;a href=&quot;#flask.Request.parameter_storage_class&quot;&gt; &lt;code&gt;parameter_storage_class&lt;/code&gt; &lt;/a&gt; 를 다른 유형 으로 설정하여 변경할 수 있습니다 . 이는 양식 데이터의 순서가 중요한 경우 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa324463dddeb7587a1bd5fa1deda99b3eadb17c" translate="yes" xml:space="preserve">
          <source>By default it will try to guess the mimetype for you, but you can also explicitly provide one. For extra security you probably want to send certain files as attachment (HTML for instance). The mimetype guessing requires a &lt;code&gt;filename&lt;/code&gt; or an &lt;code&gt;attachment_filename&lt;/code&gt; to be provided.</source>
          <target state="translated">기본적으로 MIME 유형을 추측하려고 시도하지만 명시 적으로 제공 할 수도 있습니다. 추가 보안을 위해 특정 파일을 첨부 파일 (예 : HTML)로 보낼 수 있습니다. MIME 유형 추측에는 &lt;code&gt;filename&lt;/code&gt; 또는 &lt;code&gt;attachment_filename&lt;/code&gt; 을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9244e5d670a2b2166553492f54e25b7c0a90b5c3" translate="yes" xml:space="preserve">
          <source>By default the rightmost part of the path is where it is exposed on the web. This can be changed with the &lt;code&gt;static_url_path&lt;/code&gt; argument. Because the folder is called &lt;code&gt;static&lt;/code&gt; here it will be available at the &lt;code&gt;url_prefix&lt;/code&gt; of the blueprint + &lt;code&gt;/static&lt;/code&gt;. If the blueprint has the prefix &lt;code&gt;/admin&lt;/code&gt;, the static URL will be &lt;code&gt;/admin/static&lt;/code&gt;.</source>
          <target state="translated">기본적으로 경로의 가장 오른쪽 부분은 웹에서 노출되는 위치입니다. &lt;code&gt;static_url_path&lt;/code&gt; 인수 로 변경할 수 있습니다 . 여기서 폴더는 &lt;code&gt;static&lt;/code&gt; 이라고 불리기 때문에 blueprint + &lt;code&gt;/static&lt;/code&gt; 의 &lt;code&gt;url_prefix&lt;/code&gt; 에서 사용할 수 있습니다 . Blueprint에 접두사 &lt;code&gt;/admin&lt;/code&gt; 이 있으면 정적 URL은 &lt;code&gt;/admin/static&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="e33bc041f1e2672ff9cdea25dfabb46bfc20b468" translate="yes" xml:space="preserve">
          <source>By default, Flask does not include a database abstraction layer, form validation or anything else where different libraries already exist that can handle that. Instead, Flask supports extensions to add such functionality to your application as if it was implemented in Flask itself. Numerous extensions provide database integration, form validation, upload handling, various open authentication technologies, and more. Flask may be &amp;ldquo;micro&amp;rdquo;, but it&amp;rsquo;s ready for production use on a variety of needs.</source>
          <target state="translated">기본적으로 Flask에는 데이터베이스 추상화 계층, 양식 유효성 검사 또는이를 처리 할 수있는 다른 라이브러리가 이미 존재하는 다른 항목이 포함되지 않습니다. 대신 Flask는 Flask 자체에서 구현 된 것처럼 애플리케이션에 이러한 기능을 추가하는 확장을 지원합니다. 수많은 확장 기능은 데이터베이스 통합, 양식 유효성 검사, 업로드 처리, 다양한 개방형 인증 기술 등을 제공합니다. Flask는 &quot;마이크로&quot;일 수 있지만 다양한 요구에 따라 프로덕션 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd5c518b32ef7d8499e45e0e2cb3ccec25fa1fb" translate="yes" xml:space="preserve">
          <source>By default, this function returns &lt;code&gt;SEND_FILE_MAX_AGE_DEFAULT&lt;/code&gt; from the configuration of &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로이 함수는 &lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt; 구성에서 &lt;code&gt;SEND_FILE_MAX_AGE_DEFAULT&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1dc20db63d6a814114bebe0e66f4763c87871daf" translate="yes" xml:space="preserve">
          <source>By just creating a request context, you still don&amp;rsquo;t have run the code that is normally run before a request. This might result in your database being unavailable if you are connecting to the database in a before-request callback or the current user not being stored on the &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; object etc.</source>
          <target state="translated">요청 컨텍스트를 생성하는 것만으로는 요청 전에 정상적으로 실행되는 코드를 아직 실행하지 않았습니다. 이로 인해 사전 요청 콜백에서 데이터베이스에 연결하거나 현재 사용자가 &lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; 객체 등에 저장되지 않은 경우 데이터베이스를 사용할 수 없게 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e06655b31f31ab05d5e8ebc805ad257cfe3fc781" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;client.get&lt;/code&gt; we can send an HTTP &lt;code&gt;GET&lt;/code&gt; request to the application with the given path. The return value will be a &lt;a href=&quot;../api/index#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt; object. We can now use the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.BaseResponse.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; attribute to inspect the return value (as string) from the application. In this case, we ensure that &lt;code&gt;'No entries here so far'&lt;/code&gt; is part of the output.</source>
          <target state="translated">&lt;code&gt;client.get&lt;/code&gt; 을 사용 하여 주어진 경로 로 HTTP &lt;code&gt;GET&lt;/code&gt; 요청을 애플리케이션에 보낼 수 있습니다 . 반환 값은 &lt;a href=&quot;../api/index#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt; 객체입니다. 이제 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/wrappers/#werkzeug.wrappers.BaseResponse.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 속성을 사용 하여 애플리케이션의 반환 값 (문자열)을 검사 할 수 있습니다 . 이 경우 &lt;code&gt;'No entries here so far'&lt;/code&gt; 이 출력의 일부 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="422f720e7d72716b7017e69268406be073cfc7c1" translate="yes" xml:space="preserve">
          <source>CGI</source>
          <target state="translated">CGI</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="fa7a765eebede2924a55a0ecd02f377dfcd2431e" translate="yes" xml:space="preserve">
          <source>Caching Decorator</source>
          <target state="translated">캐싱 데코레이터</target>
        </trans-unit>
        <trans-unit id="2979c7cbb96018aa5c344fb9ca98f07e3c5830a1" translate="yes" xml:space="preserve">
          <source>Call a function from a blueprint when the application is setting up so that you have a place to modify attributes of the application (like hooking in before/after request handlers etc.)</source>
          <target state="translated">애플리케이션이 설정 될 때 청사진에서 함수를 호출하여 애플리케이션의 속성을 수정할 수 있습니다 (예 : 요청 처리 전 / 후 요청 처리기 후킹 등).</target>
        </trans-unit>
        <trans-unit id="2bd82f73e6a0f96f069750699a8705dc94d7d185" translate="yes" xml:space="preserve">
          <source>Callback function for URL defaults for all view functions of the application. It&amp;rsquo;s called with the endpoint and values and should update the values passed in place.</source>
          <target state="translated">애플리케이션의 모든보기 기능에 대한 URL 기본값에 대한 콜백 기능입니다. 엔드 포인트 및 값과 함께 호출되며 전달 된 값을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d579239a51d202138f27cd6372c3f1eb4242b42" translate="yes" xml:space="preserve">
          <source>Callback function for URL defaults for this blueprint. It&amp;rsquo;s called with the endpoint and values and should update the values passed in place.</source>
          <target state="translated">이 Blueprint의 URL 기본값에 대한 콜백 함수입니다. 엔드 포인트 및 값과 함께 호출되며 전달 된 값을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bfc93a9f7e526c5ae8404a2bce0314c50bfc679" translate="yes" xml:space="preserve">
          <source>Callbacks and Errors</source>
          <target state="translated">콜백 및 오류</target>
        </trans-unit>
        <trans-unit id="0a53a6eeaf676904ee956eb0583a92a5487ca8f6" translate="yes" xml:space="preserve">
          <source>Called after the request is dispatched and the response is returned, right before the request context is popped.</source>
          <target state="translated">요청이 전달되고 응답이 반환 된 후 요청 컨텍스트가 팝되기 직전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1d5ffbeea0b81dd766563faf084ba7ad33acfb05" translate="yes" xml:space="preserve">
          <source>Called before the request is dispatched. Calls &lt;a href=&quot;#flask.Flask.url_value_preprocessors&quot;&gt;&lt;code&gt;url_value_preprocessors&lt;/code&gt;&lt;/a&gt; registered with the app and the current blueprint (if any). Then calls &lt;a href=&quot;#flask.Flask.before_request_funcs&quot;&gt;&lt;code&gt;before_request_funcs&lt;/code&gt;&lt;/a&gt; registered with the app and the blueprint.</source>
          <target state="translated">요청이 전달되기 전에 호출됩니다. 앱 및 현재 Blueprint (있는 경우)에 등록 된 &lt;a href=&quot;#flask.Flask.url_value_preprocessors&quot;&gt; &lt;code&gt;url_value_preprocessors&lt;/code&gt; 를&lt;/a&gt; 호출 합니다. 그런 다음 앱과 블루 프린트에 등록 된 &lt;a href=&quot;#flask.Flask.before_request_funcs&quot;&gt; &lt;code&gt;before_request_funcs&lt;/code&gt; 를&lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5bf0c8d21a0f7c8bbd06e2aac344800a96e684ca" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt;&lt;code&gt;Flask.register_blueprint()&lt;/code&gt;&lt;/a&gt; to register all views and callbacks registered on the blueprint with the application. Creates a &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt;&lt;code&gt;BlueprintSetupState&lt;/code&gt;&lt;/a&gt; and calls each &lt;a href=&quot;#flask.Blueprint.record&quot;&gt;&lt;code&gt;record()&lt;/code&gt;&lt;/a&gt; callback with it.</source>
          <target state="translated">&lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt; &lt;code&gt;Flask.register_blueprint()&lt;/code&gt; &lt;/a&gt; 에서 호출하여 블루 프린트 에 등록 된 모든 뷰와 콜백을 애플리케이션에 등록합니다. &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt; &lt;code&gt;BlueprintSetupState&lt;/code&gt; 를&lt;/a&gt; 생성하고이를 사용하여 각 &lt;a href=&quot;#flask.Blueprint.record&quot;&gt; &lt;code&gt;record()&lt;/code&gt; &lt;/a&gt; 콜백을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6a507dfdcdaa46e8bb5483d6716bc5fba2501d26" translate="yes" xml:space="preserve">
          <source>Called if &lt;a href=&quot;#flask.Request.get_json&quot;&gt;&lt;code&gt;get_json()&lt;/code&gt;&lt;/a&gt; parsing fails and isn&amp;rsquo;t silenced. If this method returns a value, it is used as the return value for &lt;a href=&quot;#flask.Request.get_json&quot;&gt;&lt;code&gt;get_json()&lt;/code&gt;&lt;/a&gt;. The default implementation raises &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.BadRequest&quot;&gt;&lt;code&gt;BadRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#flask.Request.get_json&quot;&gt; &lt;code&gt;get_json()&lt;/code&gt; &lt;/a&gt; 파싱이 실패하고 침묵하지 않으면 호출됩니다 . 이 메서드가 값을 반환하면 &lt;a href=&quot;#flask.Request.get_json&quot;&gt; &lt;code&gt;get_json()&lt;/code&gt; &lt;/a&gt; 의 반환 값으로 사용됩니다 . 기본 구현은 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.BadRequest&quot;&gt; &lt;code&gt;BadRequest&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04d0afb7ba8e052eb39bf8ad4b6fea283deb990a" translate="yes" xml:space="preserve">
          <source>Called right before the application context is popped.</source>
          <target state="translated">애플리케이션 컨텍스트가 팝되기 직전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2e14385bd719b9248e6758bc883d4544d8ee279e" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;#flask.Request.get_json&quot;&gt;&lt;code&gt;get_json()&lt;/code&gt;&lt;/a&gt; with default arguments.</source>
          <target state="translated">기본 인수로 &lt;a href=&quot;#flask.Request.get_json&quot;&gt; &lt;code&gt;get_json()&lt;/code&gt; &lt;/a&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="738ca101490e25936f15eb43d94d119890996786" translate="yes" xml:space="preserve">
          <source>Calls the blueprint&amp;rsquo;s &lt;a href=&quot;#flask.Blueprint.register&quot;&gt;&lt;code&gt;register()&lt;/code&gt;&lt;/a&gt; method after recording the blueprint in the application&amp;rsquo;s &lt;a href=&quot;#flask.Flask.blueprints&quot;&gt;&lt;code&gt;blueprints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">블루 프린트를 애플리케이션의 &lt;a href=&quot;#flask.Flask.blueprints&quot;&gt; &lt;code&gt;blueprints&lt;/code&gt; &lt;/a&gt; 프린트에 기록한 후 블루 프린트의 &lt;a href=&quot;#flask.Blueprint.register&quot;&gt; &lt;code&gt;register()&lt;/code&gt; &lt;/a&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a2ab0c5086ad98412932b7183084c45853c63438" translate="yes" xml:space="preserve">
          <source>Can be overridden by a subclass to hook into the matching of the request.</source>
          <target state="translated">요청 일치에 연결하기 위해 하위 클래스에 의해 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bbc19fbb36a9ea73894cf61e18bd57dc7392b74" translate="yes" xml:space="preserve">
          <source>Can be overridden in order to modify the response object before it&amp;rsquo;s sent to the WSGI server. By default this will call all the &lt;a href=&quot;#flask.Flask.after_request&quot;&gt;&lt;code&gt;after_request()&lt;/code&gt;&lt;/a&gt; decorated functions.</source>
          <target state="translated">WSGI 서버로 보내기 전에 응답 개체를 수정하기 위해 재정의 할 수 있습니다. 기본적으로 이것은 모든 &lt;a href=&quot;#flask.Flask.after_request&quot;&gt; &lt;code&gt;after_request()&lt;/code&gt; &lt;/a&gt; 데코 레이팅 된 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c328a2f448b0c49ea943b45a5a2408ab39d7b8cb" translate="yes" xml:space="preserve">
          <source>Caution: zero-padded file modes</source>
          <target state="translated">주의 : 제로 패딩 파일 모드</target>
        </trans-unit>
        <trans-unit id="323cbbb5f4247a5ea61539fae440e7218cdda264" translate="yes" xml:space="preserve">
          <source>Celery Background Tasks</source>
          <target state="translated">셀러리 백그라운드 작업</target>
        </trans-unit>
        <trans-unit id="9a4f54ac55f0c6ed996e0aef19fafdd20ab3d04c" translate="yes" xml:space="preserve">
          <source>Celery is a powerful task queue that can be used for simple background tasks as well as complex multi-stage programs and schedules. This guide will show you how to configure Celery using Flask, but assumes you&amp;rsquo;ve already read the &lt;a href=&quot;https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html&quot;&gt;First Steps with Celery&lt;/a&gt; guide in the Celery documentation.</source>
          <target state="translated">Celery는 간단한 백그라운드 작업은 물론 복잡한 다단계 프로그램 및 일정에 사용할 수있는 강력한 작업 대기열입니다. 이 가이드는 Flask를 사용하여 Celery를 구성하는 방법을 보여 주지만 &lt;a href=&quot;https://celery.readthedocs.io/en/latest/getting-started/first-steps-with-celery.html&quot;&gt;Celery&lt;/a&gt; 설명서에서 Celery 가이드 의 첫 단계를 이미 읽었다 고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="5a51a2695422e1b5d3fcc0f1a5bb8ea8726564db" translate="yes" xml:space="preserve">
          <source>Celery is a separate Python package. Install it from PyPI using pip:</source>
          <target state="translated">Celery는 별도의 Python 패키지입니다. pip를 사용하여 PyPI에서 설치합니다.</target>
        </trans-unit>
        <trans-unit id="855a4e5dbf42168858107dd9c3d3ac937288a59e" translate="yes" xml:space="preserve">
          <source>Certain configuration values are also forwarded to the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; object so you can read and write them from there:</source>
          <target state="translated">특정 구성 값도 &lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 개체로 전달 되므로 여기에서 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db21d3c3927dc58365d564728cd7ac2c802b0f45" translate="yes" xml:space="preserve">
          <source>Certain features and interactions are common enough that you will find them in most web applications. For example, many applications use a relational database and user authentication. They will open a database connection at the beginning of the request and get the information for the logged in user. At the end of the request, the database connection is closed.</source>
          <target state="translated">특정 기능 및 상호 작용은 대부분의 웹 응용 프로그램에서 찾을 수있을만큼 일반적입니다. 예를 들어, 많은 애플리케이션이 관계형 데이터베이스와 사용자 인증을 사용합니다. 요청을 시작할 때 데이터베이스 연결을 열고 로그인 한 사용자에 대한 정보를 얻습니다. 요청이 끝나면 데이터베이스 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="0258efae02185b002344d155e38f15aa764f2fba" translate="yes" xml:space="preserve">
          <source>Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand.</source>
          <target state="translated">Flask의 특정 개체는 전역 개체이지만 일반적인 종류는 아닙니다. 이러한 개체는 실제로 특정 컨텍스트에 로컬 인 개체에 대한 프록시입니다. 한입. 그러나 그것은 실제로 이해하기 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f54568b936358680a3fa49167eb17f0c78d85257" translate="yes" xml:space="preserve">
          <source>Changed in version 0.10: Bound to the application context instead of the request context.</source>
          <target state="translated">버전 0.10에서 변경 : 요청 컨텍스트 대신 응용 프로그램 컨텍스트에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="605745d8d5fd9d633eefde1ec4886c7742a12b50" translate="yes" xml:space="preserve">
          <source>Changed in version 0.10: The default port is now picked from the &lt;code&gt;SERVER_NAME&lt;/code&gt; variable.</source>
          <target state="translated">버전 0.10에서 변경 : 이제 기본 포트가 &lt;code&gt;SERVER_NAME&lt;/code&gt; 변수 에서 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="bce2a66ad40b0d8fe9c5f63b44b357d8482257c4" translate="yes" xml:space="preserve">
          <source>Changed in version 0.10: This is now always available, even in imported templates.</source>
          <target state="translated">버전 0.10에서 변경 : 이제 가져온 템플릿에서도 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829a79c49973549437410fdb8545a5c2d0d5eda9" translate="yes" xml:space="preserve">
          <source>Changed in version 0.11: &lt;code&gt;Environment.auto_reload&lt;/code&gt; set in accordance with &lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt; configuration option.</source>
          <target state="translated">버전 0.11에서 변경 : &lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt; 구성 옵션 에 따라 설정된 &lt;code&gt;Environment.auto_reload&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5785d06d7ff21977b677d27b1b4f7ea2dc1294" translate="yes" xml:space="preserve">
          <source>Changed in version 0.11: Added &lt;code&gt;**kwargs&lt;/code&gt; to support passing additional keyword arguments to the constructor of &lt;a href=&quot;#flask.Flask.test_client_class&quot;&gt;&lt;code&gt;test_client_class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 0.11에서 변경 : &lt;a href=&quot;#flask.Flask.test_client_class&quot;&gt; &lt;code&gt;test_client_class&lt;/code&gt; &lt;/a&gt; 생성자에 추가 키워드 인수를 전달하는 것을 지원하기 위해 &lt;code&gt;**kwargs&lt;/code&gt; 가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ff6b071f85c139bb3678ddd1122227ced691247a" translate="yes" xml:space="preserve">
          <source>Changed in version 0.11: Added support for serializing top-level arrays. This introduces a security risk in ancient browsers. See &lt;a href=&quot;../security/index#json-security&quot;&gt;JSON Security&lt;/a&gt; for details.</source>
          <target state="translated">버전 0.11에서 변경 : 최상위 배열 직렬화 지원이 추가되었습니다. 이것은 고대 브라우저에서 보안 위험을 초래합니다. 자세한 내용은 &lt;a href=&quot;../security/index#json-security&quot;&gt;JSON 보안&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4770479c09c8ed054c68088248739ac5d536f1bf" translate="yes" xml:space="preserve">
          <source>Changed in version 0.12: &lt;code&gt;app.test_client()&lt;/code&gt; includes preset default environment, which can be set after instantiation of the &lt;code&gt;app.test_client()&lt;/code&gt; object in &lt;code&gt;client.environ_base&lt;/code&gt;.</source>
          <target state="translated">버전 0.12에서 변경 : &lt;code&gt;app.test_client()&lt;/code&gt; 에는 &lt;code&gt;client.environ_base&lt;/code&gt; 에서 &lt;code&gt;app.test_client()&lt;/code&gt; 객체를 인스턴스화 한 후 설정할 수있는 사전 설정된 기본 환경이 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="aaa607a4b5a05abeb2d9c1d31859a82dd97baaf0" translate="yes" xml:space="preserve">
          <source>Changed in version 0.12: The &lt;code&gt;attachment_filename&lt;/code&gt; is preferred over &lt;code&gt;filename&lt;/code&gt; for MIME-type detection.</source>
          <target state="translated">버전 0.12에서 변경 : MIME 유형 감지를 위해 &lt;code&gt;filename&lt;/code&gt; 보다 &lt;code&gt;attachment_filename&lt;/code&gt; 이 선호 됩니다.</target>
        </trans-unit>
        <trans-unit id="dc28c13b8e5bdb67417e473e1e37e3f9d04c0937" translate="yes" xml:space="preserve">
          <source>Changed in version 0.12: The filename is no longer automatically inferred from file objects. If you want to use automatic mimetype and etag support, pass a filepath via &lt;code&gt;filename_or_fp&lt;/code&gt; or &lt;code&gt;attachment_filename&lt;/code&gt;.</source>
          <target state="translated">버전 0.12에서 변경 : 파일 이름이 더 이상 파일 객체에서 자동으로 유추되지 않습니다. 자동 mimetype 및 etag 지원을 사용하려면 &lt;code&gt;filename_or_fp&lt;/code&gt; 또는 &lt;code&gt;attachment_filename&lt;/code&gt; 을 통해 파일 경로를 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ba843f0522657a4ee3bd5d5b52d24edd74a1a30" translate="yes" xml:space="preserve">
          <source>Changed in version 0.2: &lt;code&gt;view_func&lt;/code&gt; parameter added.</source>
          <target state="translated">버전 0.2에서 변경 : &lt;code&gt;view_func&lt;/code&gt; 매개 변수가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="67e76ef75a3a7d325ec11d04f351eeb1ea8e1661" translate="yes" xml:space="preserve">
          <source>Changed in version 0.3: &lt;code&gt;category&lt;/code&gt; parameter added.</source>
          <target state="translated">버전 0.3에서 변경 : &lt;code&gt;category&lt;/code&gt; 매개 변수가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e45e6697f64cfeabcaa2210338ba66da387b2c55" translate="yes" xml:space="preserve">
          <source>Changed in version 0.3: &lt;code&gt;with_categories&lt;/code&gt; parameter added.</source>
          <target state="translated">버전 0.3에서 변경 : &lt;code&gt;with_categories&lt;/code&gt; 매개 변수가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e140a8ee898c22d45901a012e83b5df79d99a03f" translate="yes" xml:space="preserve">
          <source>Changed in version 0.4: added support for &lt;code&gt;with&lt;/code&gt; block usage for the client.</source>
          <target state="translated">버전 0.4에서 변경 : 클라이언트에 대한 &lt;code&gt;with&lt;/code&gt; 블록 사용에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9019df17febdb2683288bfb09551cf1184199f7d" translate="yes" xml:space="preserve">
          <source>Changed in version 0.5: As of Flask 0.5 the functions registered for after request execution are called in reverse order of registration.</source>
          <target state="translated">버전 0.5에서 변경 : Flask 0.5부터 요청 실행 후 등록 된 함수는 등록의 역순으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b3217c39d85fd4fc74e1d0f98738c542c3a612c9" translate="yes" xml:space="preserve">
          <source>Changed in version 0.5: Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: &lt;code&gt;.html&lt;/code&gt;, &lt;code&gt;.htm&lt;/code&gt;, &lt;code&gt;.xml&lt;/code&gt;, &lt;code&gt;.xhtml&lt;/code&gt;. Templates loaded from a string will have autoescaping disabled.</source>
          <target state="translated">버전 0.5에서 변경 : 모든 템플릿에 대해 더 이상 자동 이스케이프가 활성화되지 않습니다. 템플릿에 대한 다음 확장은 자동 이스 케이 핑을 트리거합니다 : &lt;code&gt;.html&lt;/code&gt; , &lt;code&gt;.htm&lt;/code&gt; , &lt;code&gt;.xml&lt;/code&gt; , &lt;code&gt;.xhtml&lt;/code&gt; . 문자열에서로드 된 템플릿은 자동 이스케이프가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7c944a5006e742b6d044a1f0f0ac33490ea3da" translate="yes" xml:space="preserve">
          <source>Changed in version 0.5: If a dict is provided as file in the dict for the &lt;code&gt;data&lt;/code&gt; parameter the content type has to be called &lt;code&gt;content_type&lt;/code&gt; now instead of &lt;code&gt;mimetype&lt;/code&gt;. This change was made for consistency with &lt;code&gt;werkzeug.FileWrapper&lt;/code&gt;.</source>
          <target state="translated">버전 0.5에서 변경 : dict가 &lt;code&gt;data&lt;/code&gt; 매개 변수 에 대한 dict의 파일로 제공되는 경우 콘텐츠 유형은 이제 &lt;code&gt;mimetype&lt;/code&gt; 대신 &lt;code&gt;content_type&lt;/code&gt; 이라고 불러야 합니다. 이 변경 사항은 &lt;code&gt;werkzeug.FileWrapper&lt;/code&gt; 와의 일관성을 위해 만들어 졌습니다 .</target>
        </trans-unit>
        <trans-unit id="3a8bf9e8650ef2d0afaa92378deff74f9a2f67ba" translate="yes" xml:space="preserve">
          <source>Changed in version 0.5: This method now accepts the same arguments as &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt;&lt;code&gt;EnvironBuilder&lt;/code&gt;&lt;/a&gt;. Because of this the &lt;code&gt;environ&lt;/code&gt; parameter is now called &lt;code&gt;environ_overrides&lt;/code&gt;.</source>
          <target state="translated">버전 0.5에서 변경 : 이제이 메서드는 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt; &lt;code&gt;EnvironBuilder&lt;/code&gt; &lt;/a&gt; 와 동일한 인수를 받습니다 . 이 때문에 &lt;code&gt;environ&lt;/code&gt; 매개 변수는 이제 &lt;code&gt;environ_overrides&lt;/code&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="e24d1a61e980fb84afdfeb15acfe23eb1df54904" translate="yes" xml:space="preserve">
          <source>Changed in version 0.6: &lt;code&gt;OPTIONS&lt;/code&gt; is added automatically as method.</source>
          <target state="translated">버전 0.6에서 변경 : &lt;code&gt;OPTIONS&lt;/code&gt; 가 메소드로 자동 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a270d26e90bce3a7f4d6a8d953b4b74728512c" translate="yes" xml:space="preserve">
          <source>Changed in version 0.7: Teardown events for the request and app contexts are called even if an unhandled error occurs. Other events may not be called depending on when an error occurs during dispatch. See &lt;a href=&quot;../reqcontext/index#callbacks-and-errors&quot;&gt;Callbacks and Errors&lt;/a&gt;.</source>
          <target state="translated">버전 0.7에서 변경 : 처리되지 않은 오류가 발생하더라도 요청 및 앱 컨텍스트에 대한 Teardown 이벤트가 호출됩니다. 디스패치 중 오류 발생시기에 따라 다른 이벤트가 호출되지 않을 수 있습니다. &lt;a href=&quot;../reqcontext/index#callbacks-and-errors&quot;&gt;콜백 및 오류를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8567838966398b020e1e7ddbc47f9d4bb21929c4" translate="yes" xml:space="preserve">
          <source>Changed in version 0.7: This no longer does the exception handling, this code was moved to the new &lt;a href=&quot;#flask.Flask.full_dispatch_request&quot;&gt;&lt;code&gt;full_dispatch_request()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 0.7에서 변경 : 이것은 더 이상 예외 처리를하지 않으며,이 코드는 새로운 &lt;a href=&quot;#flask.Flask.full_dispatch_request&quot;&gt; &lt;code&gt;full_dispatch_request()&lt;/code&gt; &lt;/a&gt; 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="100dad4cffa367b16bbe9c971ead31a395b38090" translate="yes" xml:space="preserve">
          <source>Changed in version 0.7: mimetype guessing and etag support for file objects was deprecated because it was unreliable. Pass a filename if you are able to, otherwise attach an etag yourself. This functionality will be removed in Flask 1.0</source>
          <target state="translated">버전 0.7에서 변경 : 파일 객체에 대한 mimetype 추측 및 etag 지원은 신뢰할 수 없기 때문에 더 이상 사용되지 않습니다. 가능하면 파일 이름을 전달하고 그렇지 않으면 직접 etag를 첨부하십시오. 이 기능은 Flask 1.0에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a67a8deb011a9e1086ccf017044f9389946bc237" translate="yes" xml:space="preserve">
          <source>Changed in version 0.9: &lt;code&gt;category_filter&lt;/code&gt; parameter added.</source>
          <target state="translated">버전 0.9에서 변경 : &lt;code&gt;category_filter&lt;/code&gt; 매개 변수가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="061290043e887df579ac6aa26641297952336a94" translate="yes" xml:space="preserve">
          <source>Changed in version 0.9: Added the &lt;code&gt;exc&lt;/code&gt; argument.</source>
          <target state="translated">버전 0.9에서 변경 : &lt;code&gt;exc&lt;/code&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2981bd33f703e7132d67ffdde50c672176b7bb13" translate="yes" xml:space="preserve">
          <source>Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.</source>
          <target state="translated">버전 0.9에서 변경 : Werkzeug 0.9 이전에는 POST 및 PUT 요청에 대한 양식 데이터 만 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="b31d7fbe8a6b93bcee6ad7be9feef6f47bcb54d6" translate="yes" xml:space="preserve">
          <source>Changed in version 0.9: Previously a tuple was interpreted as the arguments for the response object.</source>
          <target state="translated">버전 0.9에서 변경 : 이전에는 튜플이 응답 객체의 인수로 해석되었습니다.</target>
        </trans-unit>
        <trans-unit id="b4499d4fa7acb2135451622491738d22bd80f909" translate="yes" xml:space="preserve">
          <source>Changed in version 0.9: This can now also be called without a request object when the URL adapter is created for the application context.</source>
          <target state="translated">버전 0.9에서 변경 : 이제 URL 어댑터가 응용 프로그램 컨텍스트에 대해 생성 될 때 요청 객체 없이도 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1e6b6ea304c4bda574ec8ac5b4d88a5cbd059c4" translate="yes" xml:space="preserve">
          <source>Changed in version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.</source>
          <target state="translated">버전 0.9에서 변경 :이 스트림은 이제 항상 사용할 수 있지만 나중에 양식 파서에서 사용할 수 있습니다. 이전에는 구문 분석이 발생하지 않은 경우에만 스트림이 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="017ee4d56d1d3a44df43b173e01e08ff0b1d3164" translate="yes" xml:space="preserve">
          <source>Changed in version 0.9: cache_timeout pulls its default from application config, when None.</source>
          <target state="translated">버전 0.9에서 변경 : cache_timeout은 None 인 경우 애플리케이션 구성에서 기본값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ba97b2f008b120f3e2c95fa311d55ba95b383534" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0.0: Behavior was simplified. The logger is always named &lt;code&gt;&quot;flask.app&quot;&lt;/code&gt;. The level is only set during configuration, it doesn&amp;rsquo;t check &lt;code&gt;app.debug&lt;/code&gt; each time. Only one format is used, not different ones depending on &lt;code&gt;app.debug&lt;/code&gt;. No handlers are removed, and a handler is only added if no handlers are already configured.</source>
          <target state="translated">버전 1.0.0에서 변경 : 동작이 단순화되었습니다. 로거의 이름은 항상 &lt;code&gt;&quot;flask.app&quot;&lt;/code&gt; 입니다. 레벨은 구성 중에 만 설정 &lt;code&gt;app.debug&lt;/code&gt; 매번 app.debug를 확인하지 않습니다 . &lt;code&gt;app.debug&lt;/code&gt; 에 따라 다른 형식이 아닌 하나의 형식 만 사용됩니다 . 처리기가 제거되지 않으며 처리기가 이미 구성되지 않은 경우에만 처리기가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d27f1b352bfdba0e405bc337b1ece652a9ac37a9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0.3: &lt;code&gt;RoutingException&lt;/code&gt;, used internally for actions such as slash redirects during routing, is not passed to error handlers.</source>
          <target state="translated">버전 1.0.3에서 변경 : 라우팅 중 슬래시 리디렉션과 같은 작업에 내부적으로 사용되는 &lt;code&gt;RoutingException&lt;/code&gt; 은 오류 처리기에 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c708fa1c251665c0f9a94eaab8b8cda92a20ff61" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0.3: &lt;code&gt;app&lt;/code&gt; can be passed directly, rather than requiring an app context for configuration.</source>
          <target state="translated">버전 1.0.3에서 변경 : 구성을 위해 앱 컨텍스트를 요구하지 않고 &lt;code&gt;app&lt;/code&gt; 을 직접 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ce237b9573e46d9ea004a2c67342f99c4a9c5aa" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0.3: Filenames are encoded with ASCII instead of Latin-1 for broader compatibility with WSGI servers.</source>
          <target state="translated">버전 1.0.3에서 변경 : WSGI 서버와의 광범위한 호환성을 위해 파일 이름이 Latin-1 대신 ASCII로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="530747c1fe3c08a22d46307a57fb7025a4e93789" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;/a&gt; no longer implicitly enables subdomain matching. Use &lt;code&gt;subdomain_matching&lt;/code&gt; instead.</source>
          <target state="translated">버전 1.0에서 변경 : &lt;a href=&quot;../config/index#SERVER_NAME&quot;&gt; &lt;code&gt;SERVER_NAME&lt;/code&gt; 은&lt;/a&gt; 더 이상 하위 도메인 일치를 암시 적으로 사용하지 않습니다. 대신 &lt;code&gt;subdomain_matching&lt;/code&gt; 을 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="543ff53301533e4f550b7c462c3e84f798f89353" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: &lt;code&gt;LOGGER_NAME&lt;/code&gt; and &lt;code&gt;LOGGER_HANDLER_POLICY&lt;/code&gt; were removed. See &lt;a href=&quot;../logging/index&quot;&gt;Logging&lt;/a&gt; for information about configuration.</source>
          <target state="translated">버전 1.0에서 변경 : &lt;code&gt;LOGGER_NAME&lt;/code&gt; 및 &lt;code&gt;LOGGER_HANDLER_POLICY&lt;/code&gt; 가 제거되었습니다. 구성에 대한 정보는 &lt;a href=&quot;../logging/index&quot;&gt;로깅&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c39da31ef3132ba1764bbf7452a641658a6f007" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: Added &lt;a href=&quot;#flask.Response.max_cookie_size&quot;&gt;&lt;code&gt;max_cookie_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 1.0에서 변경 : &lt;a href=&quot;#flask.Response.max_cookie_size&quot;&gt; &lt;code&gt;max_cookie_size&lt;/code&gt; &lt;/a&gt; 추가 .</target>
        </trans-unit>
        <trans-unit id="66673fd866ee44be9d7493ef63daa07913b84df4" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: Added &lt;code id=&quot;index-3&quot;&gt;FLASK_ENV&lt;/code&gt; to control the environment separately from debug mode. The development environment enables debug mode.</source>
          <target state="translated">버전 1.0에서 변경 : 디버그 모드와 별도로 환경을 제어하기 위해 &lt;code id=&quot;index-3&quot;&gt;FLASK_ENV&lt;/code&gt; 가 추가되었습니다 . 개발 환경은 디버그 모드를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d59846f0a659e337ee9eb0a27ac6c91bc816a27a" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: Bad request errors are not trapped by default in debug mode.</source>
          <target state="translated">버전 1.0에서 변경 : 잘못된 요청 오류는 디버그 모드에서 기본적으로 트랩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0680913b099b08430879b04379e2a4ce8f80f962" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: Exceptions are looked up by code &lt;em&gt;and&lt;/em&gt; by MRO, so &lt;code&gt;HTTPExcpetion&lt;/code&gt; subclasses can be handled with a catch-all handler for the base &lt;code&gt;HTTPException&lt;/code&gt;.</source>
          <target state="translated">버전 1.0에서 변경 : 예외는 코드 &lt;em&gt;와&lt;/em&gt; MRO에 의해 &lt;code&gt;HTTPExcpetion&lt;/code&gt; 되므로 HTTPExcpetion 서브 클래스는 기본 &lt;code&gt;HTTPException&lt;/code&gt; 에 대한 포괄 처리기로 처리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb9a24cca46fac3b3f7db186ff77e386118c0e72" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from &lt;code&gt;.env&lt;/code&gt; and &lt;code&gt;.flaskenv&lt;/code&gt; files.</source>
          <target state="translated">버전 1.0에서 변경 : 설치된 경우 python-dotenv는 &lt;code&gt;.env&lt;/code&gt; 및 &lt;code&gt;.flaskenv&lt;/code&gt; 파일 에서 환경 변수를로드하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9f97fa236ed2f96e5a6afc6795ec71b3fc8004d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: JSON support is added to the response, like the request. This is useful when testing to get the test client response data as JSON.</source>
          <target state="translated">버전 1.0에서 변경 : JSON 지원이 요청과 같이 응답에 추가됩니다. 이는 테스트 클라이언트 응답 데이터를 JSON으로 가져 오기 위해 테스트 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b1205bcf53e911b37e990649e7f0b43e7bc82bad" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: Key errors raised from request data like &lt;code&gt;form&lt;/code&gt; show the bad key in debug mode rather than a generic bad request message.</source>
          <target state="translated">버전 1.0에서 변경 : &lt;code&gt;form&lt;/code&gt; 과 같은 요청 데이터에서 발생한 키 오류 는 일반적인 잘못된 요청 메시지가 아닌 디버그 모드에서 잘못된 키를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="480fb8f5c40da31a71e65735506f7dfdfa90271d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.0: UTF-8 filenames, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231#section-4&quot;&gt;RFC 2231&lt;/a&gt;, are supported.</source>
          <target state="translated">버전 1.0에서 변경 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2231#section-4&quot;&gt;RFC 2231에&lt;/a&gt; 지정된 UTF-8 파일 이름 이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f28613bd5a6640e621261a5fe7d88a4ed7d98c9c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1.0: &lt;code&gt;after_request&lt;/code&gt; functions and other finalization is done even for the default 500 response when there is no handler.</source>
          <target state="translated">버전 1.1.0에서 변경 : 핸들러가없는 경우 기본 500 응답에 대해서도 &lt;code&gt;after_request&lt;/code&gt; 함수 및 기타 종료가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ae0cb9edb5bd9f9ec41e15eb67df147285fa701e" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1.0: Always passes the &lt;code&gt;InternalServerError&lt;/code&gt; instance to the handler, setting &lt;code&gt;original_exception&lt;/code&gt; to the unhandled error.</source>
          <target state="translated">버전 1.1.0에서 변경 : 항상 &lt;code&gt;InternalServerError&lt;/code&gt; 인스턴스를 핸들러에 전달하여 &lt;code&gt;original_exception&lt;/code&gt; 을 처리되지 않은 오류로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="c53c17602f66b9ee70164cde54aba4dabea3b107" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1.0: Blueprints have a &lt;code&gt;cli&lt;/code&gt; group to register nested CLI commands. The &lt;code&gt;cli_group&lt;/code&gt; parameter controls the name of the group under the &lt;code&gt;flask&lt;/code&gt; command.</source>
          <target state="translated">버전 1.1.0에서 변경 : 블루 프린트에는 중첩 된 CLI 명령을 등록하기 위한 &lt;code&gt;cli&lt;/code&gt; 그룹이 있습니다. &lt;code&gt;cli_group&lt;/code&gt; 의 파라미터는 아래의 그룹 이름 제어 &lt;code&gt;flask&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="ef15a9b14f4d9a6be7679c58d803d719f0b92a43" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1.0: Returns &lt;code&gt;False&lt;/code&gt; when python-dotenv is not installed, or when the given path isn&amp;rsquo;t a file.</source>
          <target state="translated">버전 1.1.0에서 변경 : python-dotenv가 설치되지 않았거나 주어진 경로가 파일이 아닐 때 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="be7453bdec6d05c8ce6ed40c15218ee2b55257f0" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1.0: The logger takes the same name as &lt;a href=&quot;#flask.Flask.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; rather than hard-coding &lt;code&gt;&quot;flask.app&quot;&lt;/code&gt;.</source>
          <target state="translated">버전 1.1.0에서 변경 : 로거는 같은 이름을 따 &lt;a href=&quot;#flask.Flask.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 보다는 하드 코딩 &lt;code&gt;&quot;flask.app&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb7624fdce9cd3a9c63df93c78790bef06f1883f" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1.0: This is a &lt;code&gt;dict&lt;/code&gt; instead of an &lt;code&gt;ImmutableDict&lt;/code&gt; to allow easier configuration.</source>
          <target state="translated">버전 1.1.0에서 변경 : 쉽게 구성 할 수 있도록 &lt;code&gt;ImmutableDict&lt;/code&gt; 대신 &lt;code&gt;dict&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="936acd205fcb35799a07d5577e294a83787810ae" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1: Filename may be a &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.PathLike&quot;&gt;&lt;code&gt;PathLike&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">버전 1.1에서 변경 : 파일 이름은 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.PathLike&quot;&gt; &lt;code&gt;PathLike&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfe7793a1baf5db03eea81381b524729f16566d2" translate="yes" xml:space="preserve">
          <source>Changed in version 1.1: The current session object is used instead of reloading the original data. This prevents &lt;code&gt;flask.session&lt;/code&gt; pointing to an out-of-date object.</source>
          <target state="translated">버전 1.1에서 변경 : 원래 데이터를 다시로드하는 대신 현재 세션 개체가 사용됩니다. 이렇게하면 &lt;code&gt;flask.session&lt;/code&gt; 이 오래된 개체를 가리키는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">Changelog</target>
        </trans-unit>
        <trans-unit id="a6a550313950793f43fcdccc977fcc602b343eec" translate="yes" xml:space="preserve">
          <source>Changes the current working directory to the location of the first file found, with the assumption that it is in the top level project directory and will be where the Python path should import local packages from.</source>
          <target state="translated">현재 작업 디렉토리를 발견 된 첫 번째 파일의 위치로 변경합니다.이 파일이 최상위 프로젝트 디렉토리에 있고 Python 경로가 로컬 패키지를 가져와야한다는 가정하에 있습니다.</target>
        </trans-unit>
        <trans-unit id="10cfb8cc2efa818ff89d75f91707cfa564c685bc" translate="yes" xml:space="preserve">
          <source>Check if the given value should be tagged by this tag.</source>
          <target state="translated">주어진 값이이 태그로 태그되어야하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="641aac0c9684915aabd699c951d8ec617774e547" translate="yes" xml:space="preserve">
          <source>Check if the mimetype indicates JSON data, either &lt;em&gt;application/json&lt;/em&gt; or &lt;em&gt;application/*+json&lt;/em&gt;.</source>
          <target state="translated">mimetype이 JSON 데이터 ( &lt;em&gt;application / json&lt;/em&gt; 또는 &lt;em&gt;application / * + json)를&lt;/em&gt; 나타내는 지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a2bd2191dd53bf804cecbea6e6c0059fa22f6e3" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/javascript&quot;&gt;example source&lt;/a&gt; for a full application demonstrating the code on this page, as well as the same thing using &lt;code&gt;XMLHttpRequest&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">이 페이지의 코드를 보여주는 전체 애플리케이션 의 &lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/javascript&quot;&gt;예제 소스&lt;/a&gt; 와 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 및 &lt;code&gt;fetch&lt;/code&gt; 를 사용하는 동일한 내용을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3acbe77462385c47c90f53a2ddeb65fd3178323e" translate="yes" xml:space="preserve">
          <source>Check whether an attribute is present.</source>
          <target state="translated">속성이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="562f4457cdac9f9d83ad8c8bec00f0b64776ade9" translate="yes" xml:space="preserve">
          <source>Checks if a given object is a null session. Null sessions are not asked to be saved.</source>
          <target state="translated">주어진 개체가 null 세션인지 확인합니다. Null 세션은 저장하도록 요청하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eed940608d7f5f1e191bc381759874f13f41547e" translate="yes" xml:space="preserve">
          <source>Checks if an HTTP exception should be trapped or not. By default this will return &lt;code&gt;False&lt;/code&gt; for all exceptions except for a bad request key error if &lt;code&gt;TRAP_BAD_REQUEST_ERRORS&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;. It also returns &lt;code&gt;True&lt;/code&gt; if &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">HTTP 예외를 트랩해야하는지 여부를 확인합니다. 기본적으로 &lt;code&gt;TRAP_BAD_REQUEST_ERRORS&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 설정된 경우 잘못된 요청 키 오류를 제외한 모든 예외에 대해 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 설정된 경우 에도 &lt;code&gt;True&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="996e31f727a5d55f1c2c9ecc6fab3703f07517ac" translate="yes" xml:space="preserve">
          <source>Child Template</source>
          <target state="translated">자식 템플릿</target>
        </trans-unit>
        <trans-unit id="5d6c8c45e03fa1ec85b300a7838589e4acb12446" translate="yes" xml:space="preserve">
          <source>Circular Imports</source>
          <target state="translated">순환 수입품</target>
        </trans-unit>
        <trans-unit id="dabf48f5c37968ebc8b7067b43a4200f99b0bf66" translate="yes" xml:space="preserve">
          <source>Class used to generate nicer error messages if sessions are not available. Will still allow read-only access to the empty session but fail on setting.</source>
          <target state="translated">세션을 사용할 수없는 경우 더 좋은 오류 메시지를 생성하는 데 사용되는 클래스입니다. 빈 세션에 대한 읽기 전용 액세스는 계속 허용하지만 설정은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="dbe7859b2e1a88ecab20f8c8168b42e346ebba7a" translate="yes" xml:space="preserve">
          <source>Class-Based Views</source>
          <target state="translated">클래스 기반 뷰</target>
        </trans-unit>
        <trans-unit id="e89444d78a509a1079a310628ba8ab3a600c1fa3" translate="yes" xml:space="preserve">
          <source>Click &lt;em&gt;Apply&lt;/em&gt; to save the configuration, or &lt;em&gt;OK&lt;/em&gt; to save and close the window. Select the configuration in the main PyCharm window and click the play button next to it to run the server.</source>
          <target state="translated">&lt;em&gt;적용&lt;/em&gt; 을 클릭 하여 구성을 저장하거나 &lt;em&gt;확인&lt;/em&gt; 을 &lt;em&gt;클릭&lt;/em&gt; 하여 창을 저장하고 닫습니다. 기본 PyCharm 창에서 구성을 선택하고 옆에있는 재생 버튼을 클릭하여 서버를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a5bc9d3b8f0532f468bf5a7abccc7961c2c502e1" translate="yes" xml:space="preserve">
          <source>Click comes with &lt;a href=&quot;https://click.palletsprojects.com/testing/&quot;&gt;utilities for testing&lt;/a&gt; your CLI commands. A &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner&quot;&gt;&lt;code&gt;CliRunner&lt;/code&gt;&lt;/a&gt; runs commands in isolation and captures the output in a &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.Result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">Click은 CLI 명령 &lt;a href=&quot;https://click.palletsprojects.com/testing/&quot;&gt;을 테스트&lt;/a&gt; 하기 위한 유틸리티 와 함께 제공됩니다 . &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.CliRunner&quot;&gt; &lt;code&gt;CliRunner&lt;/code&gt; 는&lt;/a&gt; 고립과 캡처에서의 출력 명령을 실행 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.Result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="4b07517f2e8cd64be6c27681fd9e505c16a3ccab" translate="yes" xml:space="preserve">
          <source>Click is configured to load default values for command options from environment variables. The variables use the pattern &lt;code&gt;FLASK_COMMAND_OPTION&lt;/code&gt;. For example, to set the port for the run command, instead of &lt;code&gt;flask run --port 8000&lt;/code&gt;:</source>
          <target state="translated">Click은 환경 변수에서 명령 옵션의 기본값을로드하도록 구성됩니다. 변수는 &lt;code&gt;FLASK_COMMAND_OPTION&lt;/code&gt; 패턴을 사용합니다 . 예를 들어, &lt;code&gt;flask run --port 8000&lt;/code&gt; 대신 실행 명령에 대한 포트를 설정하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c911ef71110e243506968e28e6a274e9d363ebce" translate="yes" xml:space="preserve">
          <source>Click the + (&lt;em&gt;Add New Configuration&lt;/em&gt;) button and select &lt;em&gt;Python&lt;/em&gt;. Give the configuration a name such as &amp;ldquo;flask run&amp;rdquo;. For the &lt;code&gt;flask run&lt;/code&gt; command, check &amp;ldquo;Single instance only&amp;rdquo; since you can&amp;rsquo;t run the server more than once at the same time.</source>
          <target state="translated">+ ( &lt;em&gt;새 구성 추가&lt;/em&gt; ) 버튼을 클릭하고 &lt;em&gt;Python을&lt;/em&gt; 선택 합니다. 구성에 &quot;flask run&quot;과 같은 이름을 지정합니다. 를 들어 &lt;code&gt;flask run&lt;/code&gt; 명령을 동시에 서버 번 이상 실행할 수 없기 때문에 &quot;유일한 단일 인스턴스를&quot;확인.</target>
        </trans-unit>
        <trans-unit id="b92c64e81f38256df32ca5b73521725a71f7d1fa" translate="yes" xml:space="preserve">
          <source>Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.</source>
          <target state="translated">이 요청 개체의 관련 리소스를 닫습니다. 이렇게하면 모든 파일 핸들이 명시 적으로 닫힙니다. 자동으로 닫는 with 문에서 요청 객체를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1f68976708b837c03478655407a1c18ea2131a" translate="yes" xml:space="preserve">
          <source>Closing the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;dd&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;th&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt; tags.</source>
          <target state="translated">폐쇄 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 를 , &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;dd&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;th&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;tbody&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;thead&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;tfoot&amp;gt;&lt;/code&gt; 태그.</target>
        </trans-unit>
        <trans-unit id="26aae42a54d179145601c0e2e0564e3fdc13b7de" translate="yes" xml:space="preserve">
          <source>Combining Applications</source>
          <target state="translated">응용 프로그램 결합</target>
        </trans-unit>
        <trans-unit id="59b0754344014d9d6347724f39bcacbaf47c2e7d" translate="yes" xml:space="preserve">
          <source>Command Line</source>
          <target state="translated">명령 줄</target>
        </trans-unit>
        <trans-unit id="14c818412d017dcc7f2635ecf050b64a83410b23" translate="yes" xml:space="preserve">
          <source>Command Line Interface</source>
          <target state="translated">명령 줄 인터페이스</target>
        </trans-unit>
        <trans-unit id="df75135b9b55e9b43958302eae145b5e5ee8e9ac" translate="yes" xml:space="preserve">
          <source>Commands added using the Flask app&amp;rsquo;s &lt;code&gt;cli&lt;/code&gt;&lt;a href=&quot;../api/index#flask.cli.AppGroup.command&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt; decorator will be executed with an application context pushed, so your command and extensions have access to the app and its configuration. If you create a command using the Click &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.command&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt; decorator instead of the Flask decorator, you can use &lt;a href=&quot;../api/index#flask.cli.with_appcontext&quot;&gt;&lt;code&gt;with_appcontext()&lt;/code&gt;&lt;/a&gt; to get the same behavior.</source>
          <target state="translated">Flask 앱의 &lt;code&gt;cli&lt;/code&gt; &lt;a href=&quot;../api/index#flask.cli.AppGroup.command&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하여 추가 된 명령 은 애플리케이션 컨텍스트가 푸시 된 상태로 실행되므로 명령 및 확장 프로그램은 앱 및 해당 구성에 액세스 할 수 있습니다. Flask 데코레이터 대신 Click &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.command&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하여 명령을 생성하는 경우 &lt;a href=&quot;../api/index#flask.cli.with_appcontext&quot;&gt; &lt;code&gt;with_appcontext()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 동일한 동작을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="07526cc884ff576fd27c4c2c8cbc43f0383ca45a" translate="yes" xml:space="preserve">
          <source>Common Error Codes</source>
          <target state="translated">일반적인 오류 코드</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="c3636eba47dc98ed183b0a505511b3f0cb92c4a8" translate="yes" xml:space="preserve">
          <source>Configuration Basics</source>
          <target state="translated">구성 기본 사항</target>
        </trans-unit>
        <trans-unit id="2ca0acc8c987489855b6839a6449d80f5cf645df" translate="yes" xml:space="preserve">
          <source>Configuration Best Practices</source>
          <target state="translated">구성 모범 사례</target>
        </trans-unit>
        <trans-unit id="947037540f91ad75a7410f76e2780e57172310f3" translate="yes" xml:space="preserve">
          <source>Configuration Handling</source>
          <target state="translated">구성 처리</target>
        </trans-unit>
        <trans-unit id="c7b69eebde1920c1ad92c566ca3c31ff7d836748" translate="yes" xml:space="preserve">
          <source>Configuration and Conventions</source>
          <target state="translated">구성 및 규칙</target>
        </trans-unit>
        <trans-unit id="07c89ed7f1376d563730caf4a704b3fe844e17b2" translate="yes" xml:space="preserve">
          <source>Configuration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. This makes packaging and distributing your application possible via various package handling tools (&lt;a href=&quot;../patterns/distribute/index#distribute-deployment&quot;&gt;Deploying with Setuptools&lt;/a&gt;) and finally modifying the configuration file afterwards.</source>
          <target state="translated">구성은 실제 응용 프로그램 패키지 외부에있는 별도의 파일에 저장할 수 있으면 더 유용합니다. 이렇게하면 다양한 패키지 처리 도구 ( &lt;a href=&quot;../patterns/distribute/index#distribute-deployment&quot;&gt;Setuptools로 배포)를&lt;/a&gt; 통해 애플리케이션을 패키징하고 배포 하고 나중에 구성 파일을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="980d5b1c06e8f4d113fc8db17751e044dea31a8c" translate="yes" xml:space="preserve">
          <source>Configuration values &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; and &lt;code&gt;SERVER_NAME&lt;/code&gt; are only used when generating URLs outside of a request context.</source>
          <target state="translated">구성 값 &lt;code&gt;APPLICATION_ROOT&lt;/code&gt; 및 &lt;code&gt;SERVER_NAME&lt;/code&gt; 은 요청 컨텍스트 외부에서 URL을 생성 할 때만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="792c81a4cfdcb5b45d688cb03c2fd2e816f86d44" translate="yes" xml:space="preserve">
          <source>Configure</source>
          <target state="translated">Configure</target>
        </trans-unit>
        <trans-unit id="b6f09b9822b4fcc7ee7448f402f4626bb6d634c3" translate="yes" xml:space="preserve">
          <source>Configuring Apache</source>
          <target state="translated">Apache 구성</target>
        </trans-unit>
        <trans-unit id="8723c91a26f3282fe4650425efecae4ed51752a1" translate="yes" xml:space="preserve">
          <source>Configuring Editors</source>
          <target state="translated">편집기 구성</target>
        </trans-unit>
        <trans-unit id="36bebb88549e20848eac184f7f24a372e60ed389" translate="yes" xml:space="preserve">
          <source>Configuring from Environment Variables</source>
          <target state="translated">환경 변수에서 구성</target>
        </trans-unit>
        <trans-unit id="021beea13173e9cf21786fcd04772141b1cea519" translate="yes" xml:space="preserve">
          <source>Configuring from Files</source>
          <target state="translated">파일에서 구성</target>
        </trans-unit>
        <trans-unit id="17a00dd6d951e56894e460b8058ca64b1426b083" translate="yes" xml:space="preserve">
          <source>Configuring lighttpd</source>
          <target state="translated">lighttpd 구성</target>
        </trans-unit>
        <trans-unit id="2031ab4ee84e7e349fa32c5b2095aa6cafb6bd65" translate="yes" xml:space="preserve">
          <source>Configuring nginx</source>
          <target state="translated">nginx 구성</target>
        </trans-unit>
        <trans-unit id="15e24671676e84438ca9c55f877c74c7ed8e2f78" translate="yes" xml:space="preserve">
          <source>Connect on Demand</source>
          <target state="translated">주문형 연결</target>
        </trans-unit>
        <trans-unit id="3cea5c66435a8314ec0ec1fa060f95e4a2f16488" translate="yes" xml:space="preserve">
          <source>Connection Reset Issue</source>
          <target state="translated">연결 재설정 문제</target>
        </trans-unit>
        <trans-unit id="27879abb1038347eda0c2acbe56b48df3e1e8613" translate="yes" xml:space="preserve">
          <source>Connects a URL rule. Works exactly like the &lt;a href=&quot;#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator. If a view_func is provided it will be registered with the endpoint.</source>
          <target state="translated">URL 규칙을 연결합니다. &lt;a href=&quot;#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 데코레이터 와 똑같이 작동 합니다 . view_func가 제공되면 엔드 포인트에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="c4e5233899505cdb1415bf52d9bb31c23e19a404" translate="yes" xml:space="preserve">
          <source>Consider an application like this:</source>
          <target state="translated">다음과 같은 응용 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="83cfba6e56880df7292464a3eb3187ef846ad8b6" translate="yes" xml:space="preserve">
          <source>Consider you have a function that loads a list of objects from the database and renders into a template:</source>
          <target state="translated">데이터베이스에서 개체 목록을로드하고 템플릿으로 렌더링하는 함수가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ae72e42f4a286c599cb89ee099a31d8370cd2e1f" translate="yes" xml:space="preserve">
          <source>Consult each extension&amp;rsquo;s documentation for installation, configuration, and usage instructions. Generally, extensions pull their own configuration from &lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt;&lt;code&gt;app.config&lt;/code&gt;&lt;/a&gt; and are passed an application instance during initialization. For example, an extension called &amp;ldquo;Flask-Foo&amp;rdquo; might be used like this:</source>
          <target state="translated">설치, 구성 및 사용 지침은 각 확장의 설명서를 참조하십시오. 일반적으로 확장 프로그램은 &lt;a href=&quot;../api/index#flask.Flask.config&quot;&gt; &lt;code&gt;app.config&lt;/code&gt; &lt;/a&gt; 에서 자체 구성을 가져 오고 초기화 중에 애플리케이션 인스턴스에 전달됩니다. 예를 들어 &quot;Flask-Foo&quot;라는 확장명은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b026d758e9428598f6aaf36a47b70b8dfedc05ed" translate="yes" xml:space="preserve">
          <source>Contains the incoming request data as string in case it came with a mimetype Werkzeug does not handle.</source>
          <target state="translated">MIME 유형이있는 경우 Werkzeug가 처리하지 않는 경우 수신 요청 데이터를 문자열로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1f0b9e7737dbe888e3c4a34fd9fec25e884beb80" translate="yes" xml:space="preserve">
          <source>Content Security Policy (CSP)</source>
          <target state="translated">콘텐츠 보안 정책 (CSP)</target>
        </trans-unit>
        <trans-unit id="6fc861b80fe824989e2d975a178656a309350316" translate="yes" xml:space="preserve">
          <source>Context Locals</source>
          <target state="translated">컨텍스트 지역</target>
        </trans-unit>
        <trans-unit id="2a0542c7f5eaeec1627aaad6d002f4c17c9f6284" translate="yes" xml:space="preserve">
          <source>Context Preservation on Error</source>
          <target state="translated">오류에 대한 컨텍스트 보존</target>
        </trans-unit>
        <trans-unit id="6c5f9260c7d70c6083c18687eebff6f32db22de3" translate="yes" xml:space="preserve">
          <source>Context Processors</source>
          <target state="translated">컨텍스트 프로세서</target>
        </trans-unit>
        <trans-unit id="90dd65cc4d3b83da255e787a77e65059063439b9" translate="yes" xml:space="preserve">
          <source>Context locals are implemented in Werkzeug. See &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/&quot;&gt;Context Locals&lt;/a&gt; for more information on how this works internally.</source>
          <target state="translated">컨텍스트 지역은 Werkzeug에서 구현됩니다. 내부적으로 작동하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/&quot;&gt;컨텍스트 로컬&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ebb48a164609ce25aedfcfad30fac45d4336901" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;../installation/index#installation&quot;&gt;Installation&lt;/a&gt;, the &lt;a href=&quot;../quickstart/index#quickstart&quot;&gt;Quickstart&lt;/a&gt;, or the &lt;a href=&quot;../advanced_foreword/index#advanced-foreword&quot;&gt;Foreword for Experienced Programmers&lt;/a&gt;.</source>
          <target state="translated">계속해서 &lt;a href=&quot;../installation/index#installation&quot;&gt;설치&lt;/a&gt; , &lt;a href=&quot;../quickstart/index#quickstart&quot;&gt;빠른 시작&lt;/a&gt; 또는 &lt;a href=&quot;../advanced_foreword/index#advanced-foreword&quot;&gt;숙련 된 프로그래머를위한 서문을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c505cafa4a88fb39a2a239f6bb9cede7184e1a26" translate="yes" xml:space="preserve">
          <source>Control whether the cookie is sent with every response when &lt;code&gt;session.permanent&lt;/code&gt; is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected.</source>
          <target state="translated">&lt;code&gt;session.permanent&lt;/code&gt; 가 true 일 때 모든 응답과 함께 쿠키를 보낼지 여부를 제어합니다 . 매번 쿠키를 보내면 (기본값) 세션이 만료되는 것을보다 안정적으로 유지할 수 있지만 더 많은 대역폭을 사용합니다. 비 영구 세션은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b39861c919d6bf2ea971382a2f4f27b9be0c9ae8" translate="yes" xml:space="preserve">
          <source>Controlling Autoescaping</source>
          <target state="translated">자동 이스케이프 제어</target>
        </trans-unit>
        <trans-unit id="ab2b5b4018ef91761be4bdc4e6684063ef9f1144" translate="yes" xml:space="preserve">
          <source>Convert a tagged representation back to the original type.</source>
          <target state="translated">태그가 지정된 표현을 다시 원래 유형으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fc055a9c6e9a09ade4d48479eabb98ffd004e579" translate="yes" xml:space="preserve">
          <source>Convert a value to a tagged representation if necessary.</source>
          <target state="translated">필요한 경우 값을 태그가있는 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7a708d5af0cab331869a43d779c1cf37f1e403cd" translate="yes" xml:space="preserve">
          <source>Convert escaped markup back into a text string. This replaces HTML entities with the characters they represent.</source>
          <target state="translated">이스케이프 된 마크 업을 다시 텍스트 문자열로 변환합니다. 이것은 HTML 엔티티를 그들이 나타내는 문자로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="50d962a4bc191ec08e3a320c4a10035f2cf7526e" translate="yes" xml:space="preserve">
          <source>Convert the JSON representation back to the correct type. The tag will already be removed.</source>
          <target state="translated">JSON 표현을 올바른 유형으로 다시 변환하십시오. 태그는 이미 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6ed2a5a6e468b40adaf19a2de9ae3b4071ea6a00" translate="yes" xml:space="preserve">
          <source>Convert the Python object to an object that is a valid JSON type. The tag will be added later.</source>
          <target state="translated">Python 개체를 유효한 JSON 유형 인 개체로 변환합니다. 태그는 나중에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="290425dbe558478e9b2edeb4618bed65fb78985e" translate="yes" xml:space="preserve">
          <source>Convert the characters &amp;amp;, &amp;lt;, &amp;gt;, &amp;lsquo;, and &amp;rdquo; in string s to HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. Marks return value as markup string.</source>
          <target state="translated">문자열 s의 &amp;amp;, &amp;lt;,&amp;gt;, ',&amp;rdquo;문자를 HTML 안전 시퀀스로 변환합니다. HTML에서 이러한 문자를 포함 할 수있는 텍스트를 표시해야하는 경우이를 사용하십시오. 반환 값을 마크 업 문자열로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9beb4e678615ef953631294bcc81ba85a12fbd0c" translate="yes" xml:space="preserve">
          <source>Convert the return value from a view function to an instance of &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">뷰 함수의 반환 값을 &lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt; 의 인스턴스로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="4ca78e500522dd9b7d9714d1bf5a33d4a828bee6" translate="yes" xml:space="preserve">
          <source>Convert the value to a valid JSON type and add the tag structure around it.</source>
          <target state="translated">값을 유효한 JSON 유형으로 변환하고 그 주위에 태그 구조를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="01951bf0b553cf3fa14d183b90fda4a932d6af5a" translate="yes" xml:space="preserve">
          <source>Converter types:</source>
          <target state="translated">변환기 유형 :</target>
        </trans-unit>
        <trans-unit id="8b8224aeef50fb6f2c89422b6f816ea0ad33cd27" translate="yes" xml:space="preserve">
          <source>Converting to Centralized URL Map</source>
          <target state="translated">중앙 집중식 URL 맵으로 변환</target>
        </trans-unit>
        <trans-unit id="a69346065c5fd101c06b40f99ba7f2259fcbf29e" translate="yes" xml:space="preserve">
          <source>Converts the class into an actual view function that can be used with the routing system. Internally this generates a function on the fly which will instantiate the &lt;a href=&quot;#flask.views.View&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; on each request and call the &lt;a href=&quot;#flask.views.View.dispatch_request&quot;&gt;&lt;code&gt;dispatch_request()&lt;/code&gt;&lt;/a&gt; method on it.</source>
          <target state="translated">클래스를 라우팅 시스템과 함께 사용할 수있는 실제보기 기능으로 변환합니다. 내부적으로 이것은 각 요청 에서 &lt;a href=&quot;#flask.views.View&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; 를 인스턴스화 하고 &lt;a href=&quot;#flask.views.View.dispatch_request&quot;&gt; &lt;code&gt;dispatch_request()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하는 즉시 함수를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="524cf50b5df5f29161c0600989922de48abede70" translate="yes" xml:space="preserve">
          <source>Cookies</source>
          <target state="translated">Cookies</target>
        </trans-unit>
        <trans-unit id="eeb7ec02d038601642aaf465827fa51f8d9042df" translate="yes" xml:space="preserve">
          <source>Copy/Paste to Terminal</source>
          <target state="translated">터미널에 복사 / 붙여 넣기</target>
        </trans-unit>
        <trans-unit id="f3461a68c7c56e18955464730df3878d145abaf4" translate="yes" xml:space="preserve">
          <source>Core Signals</source>
          <target state="translated">핵심 신호</target>
        </trans-unit>
        <trans-unit id="2abf006838b6a0c15a7627b50e09b20403721261" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt; for a WSGI environment created from the given values. This is mostly useful during testing, where you may want to run a function that uses request data without dispatching a full request.</source>
          <target state="translated">크리에이트 &lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; &lt;/a&gt; 주어진 값에서 만든 WSGI 환경을. 이는 전체 요청을 발송하지 않고 요청 데이터를 사용하는 함수를 실행하려는 테스트 중에 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ebed2a8b4bca78ceee896ecc18fb30be0fcde705" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt; representing a WSGI environment. Use a &lt;code&gt;with&lt;/code&gt; block to push the context, which will make &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; point at this request.</source>
          <target state="translated">WSGI 환경을 나타내는 &lt;a href=&quot;#flask.ctx.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; 를&lt;/a&gt; 만듭니다 . &lt;code&gt;with&lt;/code&gt; 블록을 사용 하여 컨텍스트를 푸시하면 이 요청에서 &lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 지점이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9a8ae20dcb469eff099677004f5d85897334936f" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;bootstrap&lt;/code&gt; command that initializes new servers. It could initialize a new virtual environment, setup apache appropriately etc.</source>
          <target state="translated">새 서버를 초기화 하는 &lt;code&gt;bootstrap&lt;/code&gt; 명령을 만듭니다 . 새로운 가상 환경을 초기화하고 아파치를 적절하게 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2a4373e8091ad2a37f9bc4f94c091368f63ff6" translate="yes" xml:space="preserve">
          <source>Create a CLI runner for testing CLI commands. See &lt;a href=&quot;../testing/index#testing-cli&quot;&gt;Testing CLI Commands&lt;/a&gt;.</source>
          <target state="translated">CLI 명령을 테스트하기위한 CLI 실행기를 만듭니다. &lt;a href=&quot;../testing/index#testing-cli&quot;&gt;CLI 명령 테스트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b68c520797adb62152ba5d3e1988b421c07abdc" translate="yes" xml:space="preserve">
          <source>Create a new Apache config for &lt;code&gt;yourapplication&lt;/code&gt; and activate it. Make sure to activate watching for changes of the &lt;code&gt;.wsgi&lt;/code&gt; file so that we can automatically reload the application by touching it. (See &lt;a href=&quot;../../deploying/mod_wsgi/index#mod-wsgi-deployment&quot;&gt;mod_wsgi (Apache)&lt;/a&gt; for more information)</source>
          <target state="translated">&lt;code&gt;yourapplication&lt;/code&gt; 대한 새 Apache 구성을 만들고 활성화합니다. &lt;code&gt;.wsgi&lt;/code&gt; 파일의 변경 사항 감시를 활성화 하여 애플리케이션을 터치하여 자동으로 다시로드 할 수 있도록합니다. (자세한 내용은 &lt;a href=&quot;../../deploying/mod_wsgi/index#mod-wsgi-deployment&quot;&gt;mod_wsgi (Apache)&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f43d8d7a820db4cff416112c527769a8fee403e2" translate="yes" xml:space="preserve">
          <source>Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (&lt;code&gt;Client&lt;/code&gt;) that allows to create multipart requests, support for cookies etc.</source>
          <target state="translated">제공된 값을 기반으로 새 요청 객체를 만듭니다. 환경이 주어지면 거기에서 누락 된 값이 채워집니다. 이 방법은 URL의 요청을 시뮬레이션해야 할 때 작은 스크립트에 유용합니다. 단위 테스트에이 방법을 사용하지 마십시오. 멀티 파트 요청, 쿠키 지원 등을 생성 할 수 있는 완전한 기능을 갖춘 클라이언트 객체 ( &lt;code&gt;Client&lt;/code&gt; )가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d7bab9c458c379d7fb6249f2afb7b8b4c407669" translate="yes" xml:space="preserve">
          <source>Create a project folder and a &lt;code&gt;venv&lt;/code&gt; folder within:</source>
          <target state="translated">다음 위치에 프로젝트 폴더와 &lt;code&gt;venv&lt;/code&gt; 폴더를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="870e698752801b694402df7b56aab507f6d080d1" translate="yes" xml:space="preserve">
          <source>Create an &lt;a href=&quot;#flask.ctx.AppContext&quot;&gt;&lt;code&gt;AppContext&lt;/code&gt;&lt;/a&gt;. Use as a &lt;code&gt;with&lt;/code&gt; block to push the context, which will make &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; point at this application.</source>
          <target state="translated">&lt;a href=&quot;#flask.ctx.AppContext&quot;&gt; &lt;code&gt;AppContext&lt;/code&gt; 를&lt;/a&gt; 만듭니다 . &lt;code&gt;with&lt;/code&gt; 블록으로 사용 하여 컨텍스트를 푸시하면 이 응용 프로그램에서 &lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; 을&lt;/a&gt; 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="da9089a1f4a11bdfe489309552073a0f2b060b49" translate="yes" xml:space="preserve">
          <source>Create an environment</source>
          <target state="translated">환경 만들기</target>
        </trans-unit>
        <trans-unit id="ef8cf0d2a4c22bfce0baca51da251526b0f8c83c" translate="yes" xml:space="preserve">
          <source>Create an instance of &lt;a href=&quot;../api/index#flask.cli.FlaskGroup&quot;&gt;&lt;code&gt;FlaskGroup&lt;/code&gt;&lt;/a&gt; and pass it the factory:</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.cli.FlaskGroup&quot;&gt; &lt;code&gt;FlaskGroup&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 만들고 팩토리에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e013e65fe07005958c797116954bebd302c45d60" translate="yes" xml:space="preserve">
          <source>Create the Jinja environment based on &lt;a href=&quot;#flask.Flask.jinja_options&quot;&gt;&lt;code&gt;jinja_options&lt;/code&gt;&lt;/a&gt; and the various Jinja-related methods of the app. Changing &lt;a href=&quot;#flask.Flask.jinja_options&quot;&gt;&lt;code&gt;jinja_options&lt;/code&gt;&lt;/a&gt; after this will have no effect. Also adds Flask-related globals and filters to the environment.</source>
          <target state="translated">&lt;a href=&quot;#flask.Flask.jinja_options&quot;&gt; &lt;code&gt;jinja_options&lt;/code&gt; &lt;/a&gt; 및 앱의 다양한 Jinja 관련 메소드를 기반으로 Jinja 환경을 만듭니다 . 이후 &lt;a href=&quot;#flask.Flask.jinja_options&quot;&gt; &lt;code&gt;jinja_options&lt;/code&gt; &lt;/a&gt; 를 변경해 도 아무 효과가 없습니다. 또한 환경에 Flask 관련 전역 및 필터를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="854368d3b9542c7d97c318defcbd2b02990fdc66" translate="yes" xml:space="preserve">
          <source>Create the directory structure in &lt;code&gt;/var/www&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/var/www&lt;/code&gt; 에 디렉토리 구조를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="336b904a19a00a7d7ac124035b144a9e7ab7c7f7" translate="yes" xml:space="preserve">
          <source>Create your application in a function and register blueprints on it. That way you can create multiple instances of your application with different configurations attached which makes unit testing a lot easier. You can use this to pass in configuration as needed.</source>
          <target state="translated">함수에서 애플리케이션을 만들고 여기에 청사진을 등록합니다. 이렇게하면 서로 다른 구성이 연결된 애플리케이션의 여러 인스턴스를 만들 수 있으므로 단위 테스트가 훨씬 쉬워집니다. 이를 사용하여 필요에 따라 구성을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ce090f48340be4922123e27fd9ba47d0369102d" translate="yes" xml:space="preserve">
          <source>Creates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly.</source>
          <target state="translated">주어진 요청에 대한 URL 어댑터를 만듭니다. URL 어댑터는 요청 컨텍스트가 아직 설정되지 않은 지점에서 생성되므로 요청이 명시 적으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="cc8687bae264c1191540124b0569a9a5df1b1449" translate="yes" xml:space="preserve">
          <source>Creates a copy of this request context with the same request object. This can be used to move a request context to a different greenlet. Because the actual request object is the same this cannot be used to move a request context to a different thread unless access to the request object is locked.</source>
          <target state="translated">동일한 요청 개체를 사용하여이 요청 컨텍스트의 복사본을 만듭니다. 요청 컨텍스트를 다른 그린 렛으로 이동하는 데 사용할 수 있습니다. 실제 요청 객체가 동일하기 때문에 요청 객체에 대한 액세스가 잠겨 있지 않으면 요청 컨텍스트를 다른 스레드로 이동하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac93ab01aaa2c2f3dd00b4b63b0c93557bfb37ba" translate="yes" xml:space="preserve">
          <source>Creates a new instance of a missing session. Instead of overriding this method we recommend replacing the &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt;&lt;code&gt;session_interface&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누락 된 세션의 새 인스턴스를 만듭니다. 이 메서드를 재정의하는 대신 &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt; &lt;code&gt;session_interface&lt;/code&gt; 를&lt;/a&gt; 교체하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="028dc9433d732ea25eea04a22fa6db725b7572b8" translate="yes" xml:space="preserve">
          <source>Creates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; for all other operations, including connecting.</source>
          <target state="translated">깜박이를 사용할 수있는 경우이 네임 스페이스에 대한 새 신호를 만들고, 그렇지 않으면 아무 작업도 수행하지 않지만 연결을 포함하여 다른 모든 작업에 대해 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 와 함께 실패하는 전송 메서드가있는 가짜 신호를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3ab65be4424372df58669ae5a8bf9bc812477dda" translate="yes" xml:space="preserve">
          <source>Creates a new user</source>
          <target state="translated">새 사용자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f7bd41e9945d17a28dbd056f9f039d22cab8674b" translate="yes" xml:space="preserve">
          <source>Creates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed.</source>
          <target state="translated">구성 오류로 인해 실제 세션 지원을로드 할 수없는 경우 대체 개체 역할을하는 null 세션을 만듭니다. 널 세션의 작업은 불평없이 조회를 지원하는 것이지만 수정은 실패한 것에 대한 유용한 오류 메시지로 응답되기 때문에 주로 사용자 경험에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2ff796e806cf79a41e686d4636ed79f3495b2738" translate="yes" xml:space="preserve">
          <source>Creates a test client for this application. For information about unit testing head over to &lt;a href=&quot;../testing/index#testing&quot;&gt;Testing Flask Applications&lt;/a&gt;.</source>
          <target state="translated">이 응용 프로그램에 대한 테스트 클라이언트를 만듭니다. 단위 테스트에 대한 정보는 &lt;a href=&quot;../testing/index#testing&quot;&gt;Testing Flask Applications를 참조&lt;/a&gt; 하세요.</target>
        </trans-unit>
        <trans-unit id="b87f18af03ea7704172f0c3251bd0b772f8956db" translate="yes" xml:space="preserve">
          <source>Creates an instance of &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt;&lt;code&gt;BlueprintSetupState()&lt;/code&gt;&lt;/a&gt; object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state.</source>
          <target state="translated">나중에 등록 콜백 함수에 전달되는 &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt; &lt;code&gt;BlueprintSetupState()&lt;/code&gt; &lt;/a&gt; 객체 의 인스턴스를 만듭니다 . 하위 클래스는이를 재정 의하여 설정 상태의 하위 클래스를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7efd9805b7736b6b91d776f8053202ff54a9a90" translate="yes" xml:space="preserve">
          <source>Creates or opens a new session. Default implementation stores all session data in a signed cookie. This requires that the &lt;a href=&quot;#flask.Flask.secret_key&quot;&gt;&lt;code&gt;secret_key&lt;/code&gt;&lt;/a&gt; is set. Instead of overriding this method we recommend replacing the &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt;&lt;code&gt;session_interface&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 세션을 만들거나 엽니 다. 기본 구현은 모든 세션 데이터를 서명 된 쿠키에 저장합니다. 이를 위해서는 &lt;a href=&quot;#flask.Flask.secret_key&quot;&gt; &lt;code&gt;secret_key&lt;/code&gt; &lt;/a&gt; 가 설정되어 있어야합니다 . 이 메서드를 재정의하는 대신 &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt; &lt;code&gt;session_interface&lt;/code&gt; 를&lt;/a&gt; 교체하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="041bf2b2d80bfcbdac102121d31a4e295f48905d" translate="yes" xml:space="preserve">
          <source>Creates the form data parser. Instantiates the &lt;a href=&quot;#flask.Request.form_data_parser_class&quot;&gt;&lt;code&gt;form_data_parser_class&lt;/code&gt;&lt;/a&gt; with some parameters.</source>
          <target state="translated">양식 데이터 구문 분석기를 만듭니다. 일부 매개 변수를 사용 하여 &lt;a href=&quot;#flask.Request.form_data_parser_class&quot;&gt; &lt;code&gt;form_data_parser_class&lt;/code&gt; &lt;/a&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="fde0d1b29a3024624d92a7809d8899dc3ec40a21" translate="yes" xml:space="preserve">
          <source>Creates the loader for the Jinja2 environment. Can be used to override just the loader and keeping the rest unchanged. It&amp;rsquo;s discouraged to override this function. Instead one should override the &lt;a href=&quot;#flask.Flask.jinja_loader&quot;&gt;&lt;code&gt;jinja_loader()&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">Jinja2 환경에 대한 로더를 만듭니다. 로더 만 무시하고 나머지는 변경하지 않고 유지하는 데 사용할 수 있습니다. 이 기능을 재정의하는 것은 권장되지 않습니다. 대신 &lt;a href=&quot;#flask.Flask.jinja_loader&quot;&gt; &lt;code&gt;jinja_loader()&lt;/code&gt; &lt;/a&gt; 함수를 재정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="863436689eb43379a9e4f7029b6c931b26d44eeb" translate="yes" xml:space="preserve">
          <source>Creating Data</source>
          <target state="translated">데이터 생성</target>
        </trans-unit>
        <trans-unit id="9cd4d0074e8513650af5927e8e1e57714ecdfec7" translate="yes" xml:space="preserve">
          <source>Creating Signals</source>
          <target state="translated">신호 생성</target>
        </trans-unit>
        <trans-unit id="d3096a1bfadf6a5390a3c7740c99ab21db9b03bc" translate="yes" xml:space="preserve">
          <source>Creating a &lt;code&gt;.cgi&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.cgi&lt;/code&gt; 파일 만들기</target>
        </trans-unit>
        <trans-unit id="202bcc9482ac6bf984de4291478aa2d4a7004ee5" translate="yes" xml:space="preserve">
          <source>Creating a &lt;code&gt;.fcgi&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.fcgi&lt;/code&gt; 파일 만들기</target>
        </trans-unit>
        <trans-unit id="94a061fab3866a644b0c2d14fbada1672a5b15d0" translate="yes" xml:space="preserve">
          <source>Creating a &lt;code&gt;.wsgi&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.wsgi&lt;/code&gt; 파일 만들기</target>
        </trans-unit>
        <trans-unit id="3a27b9a2d33638ae440e5363720830105001a306" translate="yes" xml:space="preserve">
          <source>Creating a Request Context</source>
          <target state="translated">요청 컨텍스트 생성</target>
        </trans-unit>
        <trans-unit id="d6ced0e943066859c844636b504bf3f94ff33bb9" translate="yes" xml:space="preserve">
          <source>Creating an app context automatically creates this object, which is made available as the &lt;code&gt;g&lt;/code&gt; proxy.</source>
          <target state="translated">앱 컨텍스트를 만들면이 개체가 자동으로 만들어지며 &lt;code&gt;g&lt;/code&gt; 프록시 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05b07ee63db417ba7d303d36fcb2d96c92e11b00" translate="yes" xml:space="preserve">
          <source>Creating the first Fabfile</source>
          <target state="translated">첫 번째 Fabfile 만들기</target>
        </trans-unit>
        <trans-unit id="d787b2d10725662437f6f86883d39caada12487f" translate="yes" xml:space="preserve">
          <source>Cross site scripting is the concept of injecting arbitrary HTML (and with it JavaScript) into the context of a website. To remedy this, developers have to properly escape text so that it cannot include arbitrary HTML tags. For more information on that have a look at the Wikipedia article on &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;Cross-Site Scripting&lt;/a&gt;.</source>
          <target state="translated">크로스 사이트 스크립팅은 임의의 HTML (및 JavaScript 포함)을 웹 사이트 컨텍스트에 삽입하는 개념입니다. 이 문제를 해결하려면 개발자는 임의의 HTML 태그를 포함 할 수 없도록 텍스트를 적절하게 이스케이프해야합니다. 이에 대한 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;Cross-Site Scripting&lt;/a&gt; 에 대한 Wikipedia 기사를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05c240d8789c5452e6ca247f3420096c06587e74" translate="yes" xml:space="preserve">
          <source>Cross-Site Request Forgery (CSRF)</source>
          <target state="translated">교차 사이트 요청 위조 (CSRF)</target>
        </trans-unit>
        <trans-unit id="ba6857199648fdaee3fe1fa91cacdbd4e4ff17bb" translate="yes" xml:space="preserve">
          <source>Cross-Site Scripting (XSS)</source>
          <target state="translated">교차 사이트 스크립팅 (XSS)</target>
        </trans-unit>
        <trans-unit id="7dddf3e94824ffd47f9e62529e8c106117e275a8" translate="yes" xml:space="preserve">
          <source>Currently, the answer is HTML5. There are very few reasons to use XHTML considering the latest developments in Web browsers. To summarize the reasons given above:</source>
          <target state="translated">현재 답은 HTML5입니다. 웹 브라우저의 최신 개발을 고려할 때 XHTML을 사용하는 이유는 거의 없습니다. 위에 주어진 이유를 요약하면 :</target>
        </trans-unit>
        <trans-unit id="c48e024e0cec2f563e6f2442f0eebafd432290c2" translate="yes" xml:space="preserve">
          <source>Custom Commands</source>
          <target state="translated">사용자 지정 명령</target>
        </trans-unit>
        <trans-unit id="8394a6d089573458fed901e2364c860b5809ed9b" translate="yes" xml:space="preserve">
          <source>Custom Error Pages</source>
          <target state="translated">사용자 정의 오류 페이지</target>
        </trans-unit>
        <trans-unit id="8c9e25b3af1b776210f9e25278b4a11354555c7b" translate="yes" xml:space="preserve">
          <source>Custom Scripts</source>
          <target state="translated">커스텀 스크립트</target>
        </trans-unit>
        <trans-unit id="9f35b65543115d20435f84af5be5337feadd84ec" translate="yes" xml:space="preserve">
          <source>Custom converters can be defined using &lt;a href=&quot;#flask.Flask.url_map&quot;&gt;&lt;code&gt;flask.Flask.url_map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 지정 변환기는 &lt;a href=&quot;#flask.Flask.url_map&quot;&gt; &lt;code&gt;flask.Flask.url_map&lt;/code&gt; 을&lt;/a&gt; 사용하여 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c083af7b5668ed424a691c18119e1aa24da7ae0b" translate="yes" xml:space="preserve">
          <source>Debug Mode</source>
          <target state="translated">디버그 모드</target>
        </trans-unit>
        <trans-unit id="e72121a338fc7b9db56f12991bf684adceb7d477" translate="yes" xml:space="preserve">
          <source>Debug Note</source>
          <target state="translated">디버그 노트</target>
        </trans-unit>
        <trans-unit id="62d49dcbef2e47ed15aa63da66ea451dc658c1fe" translate="yes" xml:space="preserve">
          <source>Debug mode will be enabled when &lt;code id=&quot;index-1&quot;&gt;FLASK_ENV&lt;/code&gt; is &lt;code&gt;development&lt;/code&gt;, as described above. If you want to control debug mode separately, use &lt;code id=&quot;index-2&quot;&gt;FLASK_DEBUG&lt;/code&gt;. The value &lt;code&gt;1&lt;/code&gt; enables it, &lt;code&gt;0&lt;/code&gt; disables it.</source>
          <target state="translated">위에서 설명한 것처럼 &lt;code id=&quot;index-1&quot;&gt;FLASK_ENV&lt;/code&gt; 가 &lt;code&gt;development&lt;/code&gt; 일 때 디버그 모드가 활성화됩니다 . 디버그 모드를 별도로 제어하려면 &lt;code id=&quot;index-2&quot;&gt;FLASK_DEBUG&lt;/code&gt; 를 사용 하십시오 . 값 &lt;code&gt;1&lt;/code&gt; 은 활성화하고 &lt;code&gt;0&lt;/code&gt; 은 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="96aada265c8a0699251db13adc60ecf78db42adc" translate="yes" xml:space="preserve">
          <source>Debugging Application Errors</source>
          <target state="translated">응용 프로그램 오류 디버깅</target>
        </trans-unit>
        <trans-unit id="3484c6fcb53ac09a3fead481f71e452bc3f9e097" translate="yes" xml:space="preserve">
          <source>Declarative</source>
          <target state="translated">Declarative</target>
        </trans-unit>
        <trans-unit id="40ada97aca7c427ad624f8966c42530cc9acd1d3" translate="yes" xml:space="preserve">
          <source>Declaring Dependencies</source>
          <target state="translated">종속성 선언</target>
        </trans-unit>
        <trans-unit id="d94b5ca8135fe0b34894cc18d8bac9aafb732ed0" translate="yes" xml:space="preserve">
          <source>Decorate a function as responder that accepts the request as the last argument. This works like the &lt;code&gt;responder()&lt;/code&gt; decorator but the function is passed the request object as the last argument and the request object will be closed automatically:</source>
          <target state="translated">요청을 마지막 인수로 받아들이는 응답자로 함수를 장식합니다. 이것은 &lt;code&gt;responder()&lt;/code&gt; 데코레이터 처럼 작동 하지만 함수는 요청 객체를 마지막 인자로 전달하고 요청 객체는 자동으로 닫힙니다 :</target>
        </trans-unit>
        <trans-unit id="cd194692420ba01cba1b988fd42b55c02d21995f" translate="yes" xml:space="preserve">
          <source>Decorating Views</source>
          <target state="translated">보기 꾸미기</target>
        </trans-unit>
        <trans-unit id="e341d7a9fbac220ffb71b033c23032421c1e7dfb" translate="yes" xml:space="preserve">
          <source>Decorating a function with a blueprint creates a deferred function that is called with &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt;&lt;code&gt;BlueprintSetupState&lt;/code&gt;&lt;/a&gt; when the blueprint is registered on an application.</source>
          <target state="translated">블루 프린트로 함수를 장식 하면 블루 프린트가 애플리케이션에 등록 될 때 &lt;a href=&quot;#flask.blueprints.BlueprintSetupState&quot;&gt; &lt;code&gt;BlueprintSetupState&lt;/code&gt; &lt;/a&gt; 로 호출되는 지연된 함수가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="fd4aca9db99281c3e1879e390dcbc6189c4b7bb5" translate="yes" xml:space="preserve">
          <source>Decorator Based Signal Subscriptions</source>
          <target state="translated">데코레이터 기반 신호 구독</target>
        </trans-unit>
        <trans-unit id="d7c410ed08cd649b4845058755d627f755f950e7" translate="yes" xml:space="preserve">
          <source>Default Configuration</source>
          <target state="translated">기본 구성</target>
        </trans-unit>
        <trans-unit id="fe2d9e588dfbd6a7b3aec5fb15feab080a1d2aad" translate="yes" xml:space="preserve">
          <source>Default configuration parameters.</source>
          <target state="translated">기본 구성 매개 변수.</target>
        </trans-unit>
        <trans-unit id="0196e5ded7a96507722ab400f335ed4fa4dab0ed" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'/'&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;'/'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a13c1ac0c60a19d13e7486d480e0f5c5ce7cf090" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'application/json'&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;'application/json'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d91f926bbe3d04172b9b3e28a0d30f56d5d053ee" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'http'&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;'http'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e3dddbaa713ca4e8e5cae2e3e402c704e602fbb" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'production'&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;'production'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c643885940b09552f0b0175e6458362f165f9f66" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;'session'&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;'session'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25a9084be6987615bf532ff3db85aaec6121b192" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;False&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;False&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e4f64360906e7f1452e75f1085dc507b2bff801" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;None&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c8ca82e4a52fce1712b0adec6141e66b586eb41" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="beb221267bc5495a3520e52977fe13781d45641a" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;True&lt;/code&gt; if &lt;a href=&quot;#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;'development'&lt;/code&gt;, or &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">기본값 : &lt;a href=&quot;#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;'development'&lt;/code&gt; 이면 &lt;code&gt;True&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4456f9ce9edff337e01369e566a6661c91dff4d1" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;True&lt;/code&gt; if &lt;a href=&quot;#flask.Flask.env&quot;&gt;&lt;code&gt;env&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;'development'&lt;/code&gt;, or &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">기본값 : &lt;a href=&quot;#flask.Flask.env&quot;&gt; &lt;code&gt;env&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;'development'&lt;/code&gt; 이면 &lt;code&gt;True&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="571c9fa10a1cc419710c9227bca9459a764c992b" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;timedelta(days=31)&lt;/code&gt; (&lt;code&gt;2678400&lt;/code&gt; seconds)</source>
          <target state="translated">기본값 : &lt;code&gt;2678400&lt;/code&gt; &lt;code&gt;timedelta(days=31)&lt;/code&gt; ( 2678400 초)</target>
        </trans-unit>
        <trans-unit id="d6f2eb0c347d29cd4fd0435471c2569489ab32c2" translate="yes" xml:space="preserve">
          <source>Default: &lt;code&gt;timedelta(hours=12)&lt;/code&gt; (&lt;code&gt;43200&lt;/code&gt; seconds)</source>
          <target state="translated">기본값 : &lt;code&gt;timedelta(hours=12)&lt;/code&gt; ( &lt;code&gt;43200&lt;/code&gt; 초)</target>
        </trans-unit>
        <trans-unit id="3d6aee6c0e5f8e0c705a9c27ff500a7721719d95" translate="yes" xml:space="preserve">
          <source>Deferred Request Callbacks</source>
          <target state="translated">지연된 요청 콜백</target>
        </trans-unit>
        <trans-unit id="4191bbaa7c7ebba7b680dfcab193f76a3d7a5c0f" translate="yes" xml:space="preserve">
          <source>Define and Access the Database</source>
          <target state="translated">데이터베이스 정의 및 액세스</target>
        </trans-unit>
        <trans-unit id="a6b009cac3c163d53b16bcba6adb508af0eb0e03" translate="yes" xml:space="preserve">
          <source>Define the entry point in &lt;code&gt;setup.py&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;setup.py&lt;/code&gt; 에 진입 점을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b51ad281f3faf1267f0540a1afb8a394f48164a" translate="yes" xml:space="preserve">
          <source>Deletes a single user</source>
          <target state="translated">단일 사용자를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a1b177b6f8cc8ec01616fc9e6645549a9600faef" translate="yes" xml:space="preserve">
          <source>Dependencies are declared in the &lt;code&gt;install_requires&lt;/code&gt; parameter as a list. Each item in that list is the name of a package that should be pulled from PyPI on installation. By default it will always use the most recent version, but you can also provide minimum and maximum version requirements. Here some examples:</source>
          <target state="translated">종속성은 &lt;code&gt;install_requires&lt;/code&gt; 매개 변수에 목록으로 선언됩니다 . 해당 목록의 각 항목은 설치시 PyPI에서 가져와야하는 패키지의 이름입니다. 기본적으로 항상 최신 버전을 사용하지만 최소 및 최대 버전 요구 사항을 제공 할 수도 있습니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="aaf21660cc95d75cb418b238525459c62d0c2505" translate="yes" xml:space="preserve">
          <source>Depending on the error code it is less or more likely for the user to actually see such an error.</source>
          <target state="translated">오류 코드에 따라 사용자가 실제로 이러한 오류를 볼 가능성이 적거나 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="01ecf467a026bf549b4931105862e9c223ea4863" translate="yes" xml:space="preserve">
          <source>Depending on the situation, an extension may choose to log to &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;app.logger&lt;/code&gt;&lt;/a&gt; or its own named logger. Consult each extension&amp;rsquo;s documentation for details.</source>
          <target state="translated">상황에 따라 확장 프로그램은 &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;app.logger&lt;/code&gt; &lt;/a&gt; 또는 자체 명명 된 로거 에 로깅하도록 선택할 수 있습니다 . 자세한 내용은 각 확장의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c652187dd8316dd7a76a32708cb4494136883efc" translate="yes" xml:space="preserve">
          <source>Depending on your API design, you may want to create JSON responses for types other than &lt;code&gt;dict&lt;/code&gt;. In that case, use the &lt;a href=&quot;../api/index#flask.json.jsonify&quot;&gt;&lt;code&gt;jsonify()&lt;/code&gt;&lt;/a&gt; function, which will serialize any supported JSON data type. Or look into Flask community extensions that support more complex applications.</source>
          <target state="translated">API 디자인에 따라 &lt;code&gt;dict&lt;/code&gt; 이외의 유형에 대한 JSON 응답을 만들 수 있습니다 . 이 경우 지원되는 모든 JSON 데이터 유형을 직렬화 하는 &lt;a href=&quot;../api/index#flask.json.jsonify&quot;&gt; &lt;code&gt;jsonify()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 또는 더 복잡한 애플리케이션을 지원하는 Flask 커뮤니티 확장을 살펴보세요.</target>
        </trans-unit>
        <trans-unit id="e9f08b8f7e5ce8a1a056e1249da425838703f241" translate="yes" xml:space="preserve">
          <source>Depending on your project, it may be more useful to configure each logger you care about separately, instead of configuring only the root logger.</source>
          <target state="translated">프로젝트에 따라 루트 로거 만 구성하는 대신 관심있는 각 로거를 개별적으로 구성하는 것이 더 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="533dc0526c50ec24defb1ea5ab54b0509d86a95a" translate="yes" xml:space="preserve">
          <source>Deploy to Production</source>
          <target state="translated">프로덕션에 배포</target>
        </trans-unit>
        <trans-unit id="b9b08c85a94085816dfb4720d4c9df97093e04ec" translate="yes" xml:space="preserve">
          <source>Deploying Flask on AWS Elastic Beanstalk</source>
          <target state="translated">AWS Elastic Beanstalk에 Flask 배포</target>
        </trans-unit>
        <trans-unit id="2b0ffd5f37a8e9660897e0f7d112a6c40d925769" translate="yes" xml:space="preserve">
          <source>Deploying Flask on Google App Engine</source>
          <target state="translated">Google App Engine에 Flask 배포</target>
        </trans-unit>
        <trans-unit id="dbff7693aad1b9d465dbd0bb656ce387fc8779dc" translate="yes" xml:space="preserve">
          <source>Deploying Flask on Heroku</source>
          <target state="translated">Heroku에 Flask 배포</target>
        </trans-unit>
        <trans-unit id="14242242a003a494052717e6e1bba4c8abf020e2" translate="yes" xml:space="preserve">
          <source>Deploying on Azure (IIS)</source>
          <target state="translated">Azure (IIS)에 배포</target>
        </trans-unit>
        <trans-unit id="70dbd20fa74dccd549d1baddd83c6a217514f65a" translate="yes" xml:space="preserve">
          <source>Deploying on PythonAnywhere</source>
          <target state="translated">PythonAnywhere에 배포</target>
        </trans-unit>
        <trans-unit id="830c35dde7b610b59d255bfb3ce6abf83a826b0f" translate="yes" xml:space="preserve">
          <source>Deploying to a Web Server</source>
          <target state="translated">웹 서버에 배포</target>
        </trans-unit>
        <trans-unit id="563685d42d790a91c34cd04871b91d18df903b8f" translate="yes" xml:space="preserve">
          <source>Deploying with Fabric</source>
          <target state="translated">Fabric으로 배포</target>
        </trans-unit>
        <trans-unit id="ed48d82f7f3c3c94b230372cdc032df5a5a542a2" translate="yes" xml:space="preserve">
          <source>Deploying with Setuptools</source>
          <target state="translated">Setuptools로 배포</target>
        </trans-unit>
        <trans-unit id="75ea0f0f131646beaae8a786a5660a123ed0f564" translate="yes" xml:space="preserve">
          <source>Deployment Options</source>
          <target state="translated">배포 옵션</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="f990604e5b5c7d7f580485e30d099b2729ecdf3e" translate="yes" xml:space="preserve">
          <source>Deserialize an object from a JSON-formatted string &lt;code&gt;s&lt;/code&gt;. If there is an app context pushed, use the current app&amp;rsquo;s configured decoder (&lt;a href=&quot;#flask.Flask.json_decoder&quot;&gt;&lt;code&gt;json_decoder&lt;/code&gt;&lt;/a&gt;), or fall back to the default &lt;a href=&quot;#flask.json.JSONDecoder&quot;&gt;&lt;code&gt;JSONDecoder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JSON 형식 문자열 &lt;code&gt;s&lt;/code&gt; 에서 객체를 역 직렬화합니다 . 푸시 된 앱 컨텍스트가있는 경우 현재 앱의 구성된 디코더 ( &lt;a href=&quot;#flask.Flask.json_decoder&quot;&gt; &lt;code&gt;json_decoder&lt;/code&gt; &lt;/a&gt; )를 사용하거나 기본 &lt;a href=&quot;#flask.json.JSONDecoder&quot;&gt; &lt;code&gt;JSONDecoder&lt;/code&gt; 로 대체&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7cb641b314418aeef441ea38e15fa297d758c2e0" translate="yes" xml:space="preserve">
          <source>Design Decisions in Flask</source>
          <target state="translated">Flask의 디자인 결정</target>
        </trans-unit>
        <trans-unit id="8507bcec67aeb78c726b1d36b017e6b903cc4a33" translate="yes" xml:space="preserve">
          <source>Design notes, legal information and changelog are here for the interested.</source>
          <target state="translated">관심있는 분들을 위해 디자인 노트, 법률 정보 및 변경 내역이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccf6f64343c2a95ab78e3f2145ceebadea0cfd83" translate="yes" xml:space="preserve">
          <source>Develop for the Web with Caution</source>
          <target state="translated">주의하여 웹용으로 개발</target>
        </trans-unit>
        <trans-unit id="8a5788dc39a5268cde4953004c367427a99a7b40" translate="yes" xml:space="preserve">
          <source>Development / Production</source>
          <target state="translated">개발 / 생산</target>
        </trans-unit>
        <trans-unit id="fc4a596c61c8ff4265a0bdc8aec42adf91ae57e8" translate="yes" xml:space="preserve">
          <source>Development Server</source>
          <target state="translated">개발 서버</target>
        </trans-unit>
        <trans-unit id="9670c1a01b1a6d40746a2c8343271f9640fbfa2e" translate="yes" xml:space="preserve">
          <source>Development of the HTML5 specification was started in 2004 under the name &amp;ldquo;Web Applications 1.0&amp;rdquo; by the Web Hypertext Application Technology Working Group, or WHATWG (which was formed by the major browser vendors Apple, Mozilla, and Opera) with the goal of writing a new and improved HTML specification, based on existing browser behavior instead of unrealistic and backwards-incompatible specifications.</source>
          <target state="translated">HTML5 사양의 개발은 Web Hypertext Application Technology Working Group 또는 WHATWG (주요 브라우저 공급 업체 인 Apple, Mozilla 및 Opera에 의해 구성됨)에서 &quot;Web Applications 1.0&quot;이라는 이름으로 2004 년에 시작되었습니다. 비현실적이고 이전 버전과 호환되지 않는 사양 대신 기존 브라우저 동작을 기반으로 한 새롭고 향상된 HTML 사양.</target>
        </trans-unit>
        <trans-unit id="ef9a4fd3c12913b8d8f2d5b2f1e144d211e3fafb" translate="yes" xml:space="preserve">
          <source>Did you know that there the &amp;ldquo;404 Not Found&amp;rdquo; has a brother named &amp;ldquo;410 Gone&amp;rdquo;? Few people actually implement that, but the idea is that resources that previously existed and got deleted answer with 410 instead of 404. If you are not deleting documents permanently from the database but just mark them as deleted, do the user a favour and use the 410 code instead and display a message that what they were looking for was deleted for all eternity.</source>
          <target state="translated">&quot;404 Not Found&quot;에 &quot;410 Gone&quot;이라는 형제가 있다는 것을 알고 계셨습니까? 실제로 구현하는 사람은 거의 없지만 이전에 존재하고 삭제 된 리소스가 404 대신 410으로 응답한다는 아이디어입니다. 데이터베이스에서 문서를 영구적으로 삭제하지 않고 삭제 된 것으로 표시하는 경우 사용자에게 호의를 베풀고 410 코드 대신 그들이 찾고 있던 것이 영원히 삭제되었다는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b7cfdfb49228eda86de24ebe3696407b0d6c6e25" translate="yes" xml:space="preserve">
          <source>Different python interpreters being used.</source>
          <target state="translated">다른 파이썬 인터프리터가 사용되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ba9dcf4a6a6670d6de1f01c5deed27e08f2d463" translate="yes" xml:space="preserve">
          <source>Directories are scanned upwards from the directory you call &lt;code&gt;flask&lt;/code&gt; from to locate the files. The current working directory will be set to the location of the file, with the assumption that that is the top level project directory.</source>
          <target state="translated">디렉토리는 파일을 찾기 위해 &lt;code&gt;flask&lt;/code&gt; 를 호출하는 디렉토리에서 위쪽으로 스캔됩니다 . 현재 작업 디렉토리는 최상위 프로젝트 디렉토리라는 가정하에 파일의 위치로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b667a1c66d5fa69a50f25506bc59090a2f81efa2" translate="yes" xml:space="preserve">
          <source>Disable dotenv</source>
          <target state="translated">dotenv 비활성화</target>
        </trans-unit>
        <trans-unit id="ab40562d520188596aaf09cf4f5b86a2fcb3b834" translate="yes" xml:space="preserve">
          <source>Discuss with the community.</source>
          <target state="translated">커뮤니티와 토론하십시오.</target>
        </trans-unit>
        <trans-unit id="34ff714bcb6da41d123d435181e70985ef355030" translate="yes" xml:space="preserve">
          <source>Dispatch by Path</source>
          <target state="translated">경로 별 발송</target>
        </trans-unit>
        <trans-unit id="3bb8c5635612d55af5fbbbefbf96898c39ba711a" translate="yes" xml:space="preserve">
          <source>Dispatch by Subdomain</source>
          <target state="translated">하위 도메인으로 발송</target>
        </trans-unit>
        <trans-unit id="d3b20052c385d5404f447adadfc45f0606d318a3" translate="yes" xml:space="preserve">
          <source>Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling.</source>
          <target state="translated">요청을 전달하고 그 위에 요청 전처리 및 후 처리뿐만 아니라 HTTP 예외 포착 및 오류 처리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0b660a569f6b30711fc4ac343f925947ba3e446c" translate="yes" xml:space="preserve">
          <source>Dispatching by a path on the URL is very similar. Instead of looking at the &lt;code&gt;Host&lt;/code&gt; header to figure out the subdomain one simply looks at the request path up to the first slash:</source>
          <target state="translated">URL의 경로를 통한 디스패치도 매우 유사합니다. 하위 도메인을 파악하기 위해 &lt;code&gt;Host&lt;/code&gt; 헤더를 보는 대신 첫 번째 슬래시까지 요청 경로를 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="4b27420a0ae855b3dcdc4b7f6a5fe47e87132383" translate="yes" xml:space="preserve">
          <source>Distributing Resources</source>
          <target state="translated">자원 배포</target>
        </trans-unit>
        <trans-unit id="911ab07ce036d8f4bc4c14a11044214831727c88" translate="yes" xml:space="preserve">
          <source>Do not attempt to use this class directly, instead use &lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.Flask.request_context&quot;&gt;&lt;code&gt;request_context()&lt;/code&gt;&lt;/a&gt; to create this object.</source>
          <target state="translated">이 클래스를 직접 사용하지 말고 대신 &lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#flask.Flask.request_context&quot;&gt; &lt;code&gt;request_context()&lt;/code&gt; &lt;/a&gt; 를 사용하여이 객체를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7fdd40ec4deccd052c514dab94a0af1148a2ecf3" translate="yes" xml:space="preserve">
          <source>Do not enable &lt;a href=&quot;../config/index#PRESERVE_CONTEXT_ON_EXCEPTION&quot;&gt;&lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt;&lt;/a&gt; in production, as it will cause your application to leak memory on exceptions.</source>
          <target state="translated">프로덕션에서 &lt;a href=&quot;../config/index#PRESERVE_CONTEXT_ON_EXCEPTION&quot;&gt; &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt; &lt;/a&gt; 을 활성화하지 마십시오. 애플리케이션이 예외로 인해 메모리를 누수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01deec9759baa67e1c18ed860d661a89f3bb8d63" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;run()&lt;/code&gt; in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see &lt;a href=&quot;../deploying/index#deployment&quot;&gt;Deployment Options&lt;/a&gt; for WSGI server recommendations.</source>
          <target state="translated">프로덕션 설정에서 &lt;code&gt;run()&lt;/code&gt; 을 사용하지 마십시오 . 프로덕션 서버에 대한 보안 및 성능 요구 사항을 충족하기위한 것이 아닙니다. 대신 WSGI 서버 권장 사항에 대한 &lt;a href=&quot;../deploying/index#deployment&quot;&gt;배포 옵션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="125de58a9d457e204e1db1b20b98b0dde0c104c6" translate="yes" xml:space="preserve">
          <source>Do not use this command to run your application in production. Only use the development server during development. The development server is provided for convenience, but is not designed to be particularly secure, stable, or efficient. See &lt;a href=&quot;../deploying/index#deployment&quot;&gt;Deployment Options&lt;/a&gt; for how to run in production.</source>
          <target state="translated">이 명령을 사용하여 프로덕션에서 애플리케이션을 실행하지 마십시오. 개발 중에 만 개발 서버를 사용하십시오. 개발 서버는 편의를 위해 제공되지만 특별히 안전하거나 안정적이거나 효율적으로 설계되지 않았습니다. 프로덕션에서 실행하는 방법 은 &lt;a href=&quot;../deploying/index#deployment&quot;&gt;배포 옵션&lt;/a&gt; 을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="eb1784d1ac210f6e089f70f257f9ade70aeff6d2" translate="yes" xml:space="preserve">
          <source>Do not write code that needs the configuration at import time. If you limit yourself to request-only accesses to the configuration you can reconfigure the object later on as needed.</source>
          <target state="translated">가져올 때 구성이 필요한 코드를 작성하지 마십시오. 구성에 대한 요청 전용 액세스로 제한하는 경우 나중에 필요에 따라 객체를 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a948b285d32a20eeb02885fbe2180dc20b88a0a8" translate="yes" xml:space="preserve">
          <source>Do you know where your application is? If you are developing the answer is quite simple: it&amp;rsquo;s on localhost port something and directly on the root of that server. But what if you later decide to move your application to a different location? For example to &lt;code&gt;http://example.com/myapp&lt;/code&gt;? On the server side this never was a problem because we were using the handy &lt;a href=&quot;../../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; function that could answer that question for us, but if we are using jQuery we should not hardcode the path to the application but make that dynamic, so how can we do that?</source>
          <target state="translated">귀하의 응용 프로그램이 어디에 있는지 알고 있습니까? 개발중인 경우 대답은 매우 간단합니다. 로컬 호스트 포트에 있고 해당 서버의 루트에 직접 있습니다. 하지만 나중에 응용 프로그램을 다른 위치로 옮기기로 결정하면 어떻게됩니까? 예를 들어 &lt;code&gt;http://example.com/myapp&lt;/code&gt; ? 서버 측에서는이 질문에 답할 수 있는 편리한 &lt;a href=&quot;../../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt; 함수를 사용했기 때문에 문제 가되지 않았지만 jQuery를 사용하는 경우 애플리케이션 경로를 하드 코딩하지 말고 동적으로 만들어야합니다. 우리가하는거야?</target>
        </trans-unit>
        <trans-unit id="4f9095933912561f96f6400b90f6ef8100c5b8bc" translate="yes" xml:space="preserve">
          <source>Docstrings</source>
          <target state="translated">Docstrings</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="a40486d9b2f45f1bf8c19541879932a4c01ddbf6" translate="yes" xml:space="preserve">
          <source>Does the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call &lt;a href=&quot;#flask.make_response&quot;&gt;&lt;code&gt;make_response()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청을 발송합니다. URL과 일치하고보기 또는 오류 처리기의 반환 값을 반환합니다. 응답 개체 일 필요는 없습니다. 반환 값을 적절한 응답 객체로 변환하려면 &lt;a href=&quot;#flask.make_response&quot;&gt; &lt;code&gt;make_response()&lt;/code&gt; &lt;/a&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc29792391a5089c5d49b05658acb8eef08967a1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that even if you enlist them in your &lt;code&gt;MANIFEST.in&lt;/code&gt; file, they won&amp;rsquo;t be installed for you unless you set the &lt;code&gt;include_package_data&lt;/code&gt; parameter of the &lt;code&gt;setup&lt;/code&gt; function to &lt;code&gt;True&lt;/code&gt;!</source>
          <target state="translated">당신이 그들을 입대 경우에도 잊지 마세요 &lt;code&gt;MANIFEST.in&lt;/code&gt; 의 파일을 사용자가 설정하지 않는 한, 그들은 당신을 위해 설치되지 않습니다 &lt;code&gt;include_package_data&lt;/code&gt; 의 매개 변수를 &lt;code&gt;setup&lt;/code&gt; 하는 기능 &lt;code&gt;True&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="693a4c9e9a89655d0fae73a1e439d27103b053b2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t pop the request context when an exception occurs. If not set, this is true if &lt;code&gt;DEBUG&lt;/code&gt; is true. This allows debuggers to introspect the request data on errors, and should normally not need to be set directly.</source>
          <target state="translated">예외가 발생할 때 요청 컨텍스트를 팝하지 마십시오. 설정되지 않은 경우 &lt;code&gt;DEBUG&lt;/code&gt; 가 true이면 true입니다. 이를 통해 디버거는 오류에 대한 요청 데이터를 조사 할 수 있으며 일반적으로 직접 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ddb78e099c7cece323a2fce684442682d15b4c58" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t read more than this many bytes from the incoming request data. If not set and the request does not specify a &lt;code&gt;CONTENT_LENGTH&lt;/code&gt;, no data will be read for security.</source>
          <target state="translated">들어오는 요청 데이터에서 이보다 많은 바이트를 읽지 마십시오. 설정되지 않고 요청이 &lt;code&gt;CONTENT_LENGTH&lt;/code&gt; 를 지정하지 않으면 보안을 위해 데이터를 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d2948b288465419591697ee1c77d7daba99dc87" translate="yes" xml:space="preserve">
          <source>Due to the implicit self from the caller&amp;rsquo;s perspective you cannot use regular view decorators on the individual methods of the view however, keep this in mind.</source>
          <target state="translated">호출자의 관점에서 볼 때 암시 적 자체로 인해 뷰의 개별 메서드에서 일반 뷰 데코레이터를 사용할 수는 없지만이를 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="e19f23432479b65facd9f7df1b58d14d2bbf7832" translate="yes" xml:space="preserve">
          <source>During a request, every call to &lt;code&gt;get_db()&lt;/code&gt; will return the same connection, and it will be closed automatically at the end of the request.</source>
          <target state="translated">요청 중에 &lt;code&gt;get_db()&lt;/code&gt; 모든 호출 은 동일한 연결을 반환하며 요청이 끝나면 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="003213e2a7a3322a29b606d17f754043f166faa9" translate="yes" xml:space="preserve">
          <source>During setup, the &lt;code&gt;TESTING&lt;/code&gt; config flag is activated. What this does is disable error catching during request handling, so that you get better error reports when performing test requests against the application.</source>
          <target state="translated">설정 중에 &lt;code&gt;TESTING&lt;/code&gt; 구성 플래그가 활성화됩니다. 이것이하는 일은 요청 처리 중 오류 포착을 비활성화하여 애플리케이션에 대해 테스트 요청을 수행 할 때 더 나은 오류 보고서를 얻을 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="08485b8831a37d7ae6c20cf92647a5dc253fcc94" translate="yes" xml:space="preserve">
          <source>During testing, it can be useful to defer popping the contexts after the request ends, so that their data can be accessed in the test function. Use the &lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt;&lt;code&gt;test_client()&lt;/code&gt;&lt;/a&gt; as a &lt;code&gt;with&lt;/code&gt; block to preserve the contexts until the &lt;code&gt;with&lt;/code&gt; block exits.</source>
          <target state="translated">테스트 중에 요청이 끝난 후 컨텍스트 팝을 연기하여 테스트 함수에서 데이터에 액세스 할 수 있도록하는 것이 유용 할 수 있습니다. &lt;code&gt;with&lt;/code&gt; 블록이 종료 될 때까지 컨텍스트를 보존 하려면 &lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt; &lt;code&gt;test_client()&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;with&lt;/code&gt; 블록 으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6d16064f47fdc6d3948fcd18a134b1cd48c5ad2" translate="yes" xml:space="preserve">
          <source>Dynamic web applications also need static files. That&amp;rsquo;s usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called &lt;code&gt;static&lt;/code&gt; in your package or next to your module and it will be available at &lt;code&gt;/static&lt;/code&gt; on the application.</source>
          <target state="translated">동적 웹 응용 프로그램에는 정적 파일도 필요합니다. 일반적으로 CSS 및 JavaScript 파일의 출처입니다. 이상적으로는 웹 서버가이를 제공하도록 구성되어 있지만 개발 중에 Flask도 그렇게 할 수 있습니다. 패키지 또는 모듈 옆에 &lt;code&gt;static&lt;/code&gt; 이라는 폴더를 생성 하면 응용 프로그램의 &lt;code&gt;/static&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="199dd57b3df32b49f721b7342203a332300e1df2" translate="yes" xml:space="preserve">
          <source>ECMAScript 5 closed this vulnerability, so only extremely old browsers are still vulnerable. All of these browsers have &lt;a href=&quot;https://github.com/pallets/flask/issues/248#issuecomment-59934857&quot;&gt;other more serious vulnerabilities&lt;/a&gt;, so this behavior was changed and &lt;code&gt;jsonify()&lt;/code&gt; now supports serializing arrays.</source>
          <target state="translated">ECMAScript 5는이 취약점을 닫았으므로 매우 오래된 브라우저 만 여전히 취약합니다. 이러한 모든 브라우저에는 &lt;a href=&quot;https://github.com/pallets/flask/issues/248#issuecomment-59934857&quot;&gt;다른 더 심각한 취약성&lt;/a&gt; 이 &lt;code&gt;jsonify()&lt;/code&gt; 동작이 변경되었으며 jsonify ()는 이제 배열 직렬화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f35a0a66536c1eb098c32ac6bdc33d97f387d051" translate="yes" xml:space="preserve">
          <source>ETags will also be attached automatically if a &lt;code&gt;filename&lt;/code&gt; is provided. You can turn this off by setting &lt;code&gt;add_etags=False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 이 제공 되면 ETag도 자동으로 첨부됩니다 . &lt;code&gt;add_etags=False&lt;/code&gt; 를 설정 하여이 기능을 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceb77775b90d60af0c851ed8bb9f46c38ba61508" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;yield&lt;/code&gt; expression is directly sent to the browser. Note though that some WSGI middlewares might break streaming, so be careful there in debug environments with profilers and other things you might have enabled.</source>
          <target state="translated">각 &lt;code&gt;yield&lt;/code&gt; 표현식은 브라우저로 직접 전송됩니다. 일부 WSGI 미들웨어는 스트리밍을 중단 할 수 있으므로 프로파일 러 및 활성화했을 수있는 기타 사항이있는 디버그 환경에서주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b826677f1ad0530922f6b5cad107cb853697ed88" translate="yes" xml:space="preserve">
          <source>Each of the techniques and examples below results in an &lt;code&gt;application&lt;/code&gt; object that can be run with any WSGI server. For production, see &lt;a href=&quot;../../deploying/index#deployment&quot;&gt;Deployment Options&lt;/a&gt;. For development, Werkzeug provides a builtin server for development available at &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt;&lt;code&gt;werkzeug.serving.run_simple()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">아래의 각 기술과 예제 는 모든 WSGI 서버에서 실행할 수 있는 &lt;code&gt;application&lt;/code&gt; 개체를 생성합니다. 프로덕션의 경우 &lt;a href=&quot;../../deploying/index#deployment&quot;&gt;배포 옵션을&lt;/a&gt; 참조하십시오 . 개발을 위해 Werkzeug는 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/serving/#werkzeug.serving.run_simple&quot;&gt; &lt;code&gt;werkzeug.serving.run_simple()&lt;/code&gt; &lt;/a&gt; 에서 사용할 수있는 개발 용 내장 서버를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5e0ac6815d3759a08b5026277eda8940c5c056ac" translate="yes" xml:space="preserve">
          <source>Eager to get started? This page gives a good introduction to Flask. It assumes you already have Flask installed. If you do not, head over to the &lt;a href=&quot;../installation/index#installation&quot;&gt;Installation&lt;/a&gt; section.</source>
          <target state="translated">시작하고 싶으신가요? 이 페이지는 Flask에 대한 좋은 소개를 제공합니다. Flask가 이미 설치되어 있다고 가정합니다. 그렇지 않은 경우 &lt;a href=&quot;../installation/index#installation&quot;&gt;설치&lt;/a&gt; 섹션으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="c537ae89dce66ac276f4bd6c238b3267cc4d0b44" translate="yes" xml:space="preserve">
          <source>Easy Querying</source>
          <target state="translated">쉬운 쿼리</target>
        </trans-unit>
        <trans-unit id="1bf78e9414fd1146a27d6d0673c1e70798519c19" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;(body, status, headers)&lt;/code&gt;, &lt;code&gt;(body, status)&lt;/code&gt;, or &lt;code&gt;(body, headers)&lt;/code&gt;, where &lt;code&gt;body&lt;/code&gt; is any of the other types allowed here, &lt;code&gt;status&lt;/code&gt; is a string or an integer, and &lt;code&gt;headers&lt;/code&gt; is a dictionary or a list of &lt;code&gt;(key, value)&lt;/code&gt; tuples. If &lt;code&gt;body&lt;/code&gt; is a &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;status&lt;/code&gt; overwrites the exiting value and &lt;code&gt;headers&lt;/code&gt; are extended.</source>
          <target state="translated">일방 &lt;code&gt;(body, status, headers)&lt;/code&gt; , &lt;code&gt;(body, status)&lt;/code&gt; 또는 &lt;code&gt;(body, headers)&lt;/code&gt; , &lt;code&gt;body&lt;/code&gt; 여기에 허용되는 다른 유형의되고, &lt;code&gt;status&lt;/code&gt; 문자열 또는 정수이고, &lt;code&gt;headers&lt;/code&gt; 사전이나리스트이다 &lt;code&gt;(key, value)&lt;/code&gt; 튜플. 경우 &lt;code&gt;body&lt;/code&gt; A는 &lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; 의&lt;/a&gt; 예는, &lt;code&gt;status&lt;/code&gt; 유출되는 값을 덮어 &lt;code&gt;headers&lt;/code&gt; 확장된다.</target>
        </trans-unit>
        <trans-unit id="a9bd113dee92cff6478e76925b5a67562d2dc854" translate="yes" xml:space="preserve">
          <source>Either way, in our case here we only expect one or two servers and we can upload them ahead of time by hand.</source>
          <target state="translated">어느 쪽이든, 여기서 우리의 경우에는 하나 또는 두 개의 서버 만 예상하고 미리 수동으로 업로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84fcecf06a1fe81abdca7fbff69090fc1250bd41" translate="yes" xml:space="preserve">
          <source>Either you can fill the config from a config file:</source>
          <target state="translated">구성 파일에서 구성을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d16fecec3b8ea720b4da2d2377ee01375c7c95a" translate="yes" xml:space="preserve">
          <source>Emacs: either use an encoding cookie or put this into your &lt;code&gt;.emacs&lt;/code&gt; file:</source>
          <target state="translated">Emacs : 인코딩 쿠키를 사용하거나이를 &lt;code&gt;.emacs&lt;/code&gt; 파일에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="7f76c2025c37b59dda0f6fc1db7ebf6a6d237087" translate="yes" xml:space="preserve">
          <source>Email Errors to Admins</source>
          <target state="translated">관리자에게 이메일 오류</target>
        </trans-unit>
        <trans-unit id="533a75753c90c3ededa9f4e61b72e9f3077ca942" translate="yes" xml:space="preserve">
          <source>Enable testing mode. Exceptions are propagated rather than handled by the the app&amp;rsquo;s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests.</source>
          <target state="translated">테스트 모드를 활성화합니다. 예외는 앱의 오류 핸들러에 의해 처리되지 않고 전파됩니다. 확장 기능은 더 쉬운 테스트를 위해 동작을 변경할 수도 있습니다. 자체 테스트에서이를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b78b3978b94aceb057e4f8fadc5d43173e0dd23c" translate="yes" xml:space="preserve">
          <source>Enable this if you want to use the X-Sendfile feature. Keep in mind that the server has to support this. This only affects files sent with the &lt;a href=&quot;#flask.send_file&quot;&gt;&lt;code&gt;send_file()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">X-Sendfile 기능을 사용하려면 이것을 활성화하십시오. 서버가이를 지원해야한다는 점을 명심하십시오. 이것은 &lt;a href=&quot;#flask.send_file&quot;&gt; &lt;code&gt;send_file()&lt;/code&gt; &lt;/a&gt; 메소드로 전송 된 파일에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="1a12430ea5f508d50caa84d035c740c51c7c2f5a" translate="yes" xml:space="preserve">
          <source>Encoding and Decoding Yourself</source>
          <target state="translated">자신을 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="eeb4cd7ae37c8ec6b52e9c5df704488228c5e0ca" translate="yes" xml:space="preserve">
          <source>Endpoint Decorator</source>
          <target state="translated">엔드 포인트 데코레이터</target>
        </trans-unit>
        <trans-unit id="83ad3ca88d08cf0032b025e03ebc5f8c912823af" translate="yes" xml:space="preserve">
          <source>Environment Variables From dotenv</source>
          <target state="translated">dotenv의 환경 변수</target>
        </trans-unit>
        <trans-unit id="c9cb81cb79b42acef70ba280d65e3c93920d2264" translate="yes" xml:space="preserve">
          <source>Environment Variables From virtualenv</source>
          <target state="translated">virtualenv의 환경 변수</target>
        </trans-unit>
        <trans-unit id="05b5e4f8dac95635fa6818c0539b686d5dc44abe" translate="yes" xml:space="preserve">
          <source>Environment and Debug Features</source>
          <target state="translated">환경 및 디버그 기능</target>
        </trans-unit>
        <trans-unit id="308558adc2a5b3e3613035109b0c936cd6490357" translate="yes" xml:space="preserve">
          <source>Environment variables can be set on Linux or OS X with the export command in the shell before starting the server:</source>
          <target state="translated">서버를 시작하기 전에 쉘에서 export 명령을 사용하여 Linux 또는 OS X에서 환경 변수를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="d3e856491e1bc6fd30d79529b1024eb08ed1e4e9" translate="yes" xml:space="preserve">
          <source>Error Handlers</source>
          <target state="translated">오류 처리기</target>
        </trans-unit>
        <trans-unit id="e1eb3543d668adf6c024d2ed49c60f9dbfc782ef" translate="yes" xml:space="preserve">
          <source>Error Logging Tools</source>
          <target state="translated">오류 로깅 도구</target>
        </trans-unit>
        <trans-unit id="20791d12fa1fa30a50ea85f3ef8663e6597d50fb" translate="yes" xml:space="preserve">
          <source>Error handlers</source>
          <target state="translated">오류 처리기</target>
        </trans-unit>
        <trans-unit id="cdec94d9930dba7a87a9bceae416a8ba3c2f134b" translate="yes" xml:space="preserve">
          <source>Error handlers still respect the exception class hierarchy. If you register handlers for both &lt;code&gt;HTTPException&lt;/code&gt; and &lt;code&gt;Exception&lt;/code&gt;, the &lt;code&gt;Exception&lt;/code&gt; handler will not handle &lt;code&gt;HTTPException&lt;/code&gt; subclasses because it the &lt;code&gt;HTTPException&lt;/code&gt; handler is more specific.</source>
          <target state="translated">오류 처리기는 여전히 예외 클래스 계층 구조를 따릅니다. 당신이 모두 핸들러를 등록하면 &lt;code&gt;HTTPException&lt;/code&gt; 과 &lt;code&gt;Exception&lt;/code&gt; 의 &lt;code&gt;Exception&lt;/code&gt; 핸들러가 처리하지 않습니다 &lt;code&gt;HTTPException&lt;/code&gt; 서브 클래스 그것 때문에 &lt;code&gt;HTTPException&lt;/code&gt; 핸들러는 더 구체적이다.</target>
        </trans-unit>
        <trans-unit id="d6f999f23354f1683e1429a3f7e63d1347345781" translate="yes" xml:space="preserve">
          <source>Errors in Custom Scripts</source>
          <target state="translated">사용자 지정 스크립트의 오류</target>
        </trans-unit>
        <trans-unit id="5c61080c98ba61644c790d949caea6eb75a8fd94" translate="yes" xml:space="preserve">
          <source>Escape a string. Calls &lt;a href=&quot;#flask.escape&quot;&gt;&lt;code&gt;escape()&lt;/code&gt;&lt;/a&gt; and ensures that for subclasses the correct type is returned.</source>
          <target state="translated">문자열을 이스케이프합니다. &lt;a href=&quot;#flask.escape&quot;&gt; &lt;code&gt;escape()&lt;/code&gt; &lt;/a&gt; 호출 하고 서브 클래스에 대해 올바른 유형이 리턴되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="90faedadf6cbc4354ba5bacea10f95f826641a56" translate="yes" xml:space="preserve">
          <source>Even though it did not run any actual tests, we already know that our &lt;code&gt;flaskr&lt;/code&gt; application is syntactically valid, otherwise the import would have died with an exception.</source>
          <target state="translated">실제 테스트를 실행하지는 않았지만 우리는 &lt;code&gt;flaskr&lt;/code&gt; 응용 프로그램이 구문 적으로 유효 하다는 것을 이미 알고 있습니다 . 그렇지 않으면 가져 오기가 예외와 함께 죽었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0753b4da3377b81eb95a865215d8cb1d2b964acf" translate="yes" xml:space="preserve">
          <source>Even though the interactive debugger does not work in forking environments (which makes it nearly impossible to use on production servers), it still allows the execution of arbitrary code. This makes it a major security risk and therefore it &lt;strong&gt;must never be used on production machines&lt;/strong&gt;.</source>
          <target state="translated">인터랙티브 디버거가 포크 환경에서 작동하지 않더라도 (프로덕션 서버에서 사용하기가 거의 불가능 함), 여전히 임의의 코드 실행을 허용합니다. 이로 인해 보안 위험이 커지므로 &lt;strong&gt;프로덕션 시스템에서 사용해서는 안됩니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a92872ebe335af81d26aa88871bec3597972f12e" translate="yes" xml:space="preserve">
          <source>Events and Signals</source>
          <target state="translated">이벤트 및 신호</target>
        </trans-unit>
        <trans-unit id="7ac625818b3b1271f433452ffc81e8203b2f86a6" translate="yes" xml:space="preserve">
          <source>Every Python programmer hates them, and yet we just added some: circular imports (That&amp;rsquo;s when two modules depend on each other. In this case &lt;code&gt;views.py&lt;/code&gt; depends on &lt;code&gt;__init__.py&lt;/code&gt;). Be advised that this is a bad idea in general but here it is actually fine. The reason for this is that we are not actually using the views in &lt;code&gt;__init__.py&lt;/code&gt; and just ensuring the module is imported and we are doing that at the bottom of the file.</source>
          <target state="translated">모든 파이썬 프로그래머는 그것들을 싫어하지만 우리는 몇 가지를 추가했습니다 : 순환 가져 오기 (두 모듈이 서로 의존 할 때입니다.이 경우 &lt;code&gt;views.py&lt;/code&gt; 는 &lt;code&gt;__init__.py&lt;/code&gt; 에 의존합니다 ). 이것은 일반적으로 나쁜 생각이지만 실제로는 괜찮습니다. 그 이유는 우리가 실제로 &lt;code&gt;__init__.py&lt;/code&gt; 의 뷰를 사용하지 않고 모듈이 임포트되었는지 확인하고 파일 하단에서 수행하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6bc4454be1928e28629ba6f372fa6357c111ba06" translate="yes" xml:space="preserve">
          <source>Example of module-based configuration:</source>
          <target state="translated">모듈 기반 구성의 예 :</target>
        </trans-unit>
        <trans-unit id="3f8ab7311cf060a7b36d8e4837e43ee7a62c9296" translate="yes" xml:space="preserve">
          <source>Example subscriber:</source>
          <target state="translated">구독자 예 :</target>
        </trans-unit>
        <trans-unit id="48de07fa94f40329fbebd9e57597d46bb49db0e2" translate="yes" xml:space="preserve">
          <source>Example usage for both:</source>
          <target state="translated">둘 다 사용 예 :</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="29a9028915cca93417a879c1813bb5cd5c9e844e" translate="yes" xml:space="preserve">
          <source>Exceptions are re-raised rather than being handled by the app&amp;rsquo;s error handlers. If not set, this is implicitly true if &lt;code&gt;TESTING&lt;/code&gt; or &lt;code&gt;DEBUG&lt;/code&gt; is enabled.</source>
          <target state="translated">예외는 앱의 오류 핸들러에 의해 처리되지 않고 다시 발생합니다. 설정되지 않은 경우 &lt;code&gt;TESTING&lt;/code&gt; 또는 &lt;code&gt;DEBUG&lt;/code&gt; 가 활성화 된 경우 암시 적으로 참 입니다.</target>
        </trans-unit>
        <trans-unit id="49ff9a3fdca032ed4d98fc6ac3021c2e22c955b1" translate="yes" xml:space="preserve">
          <source>Executes a function after this request. This is useful to modify response objects. The function is passed the response object and has to return the same or a new one.</source>
          <target state="translated">이 요청 후에 함수를 실행합니다. 이는 응답 객체를 수정하는 데 유용합니다. 함수는 응답 객체에 전달되고 동일하거나 새로운 객체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="52fb03d0b6df9c8675509ec8b43832cdc59a1263" translate="yes" xml:space="preserve">
          <source>Expands a basic dictionary with session attributes.</source>
          <target state="translated">세션 속성으로 기본 사전을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="d39cea4c06ebe8e64c3c9b00c20aef174e194ea9" translate="yes" xml:space="preserve">
          <source>Expressions and Statements</source>
          <target state="translated">식과 진술</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="5a850c4a7f6071878c684e309ff4b1fdae68c1ee" translate="yes" xml:space="preserve">
          <source>Extensions are extra packages that add functionality to a Flask application. For example, an extension might add support for sending email or connecting to a database. Some extensions add entire new frameworks to help build certain types of applications, like a REST API.</source>
          <target state="translated">확장은 Flask 애플리케이션에 기능을 추가하는 추가 패키지입니다. 예를 들어 확장 프로그램은 이메일 전송 또는 데이터베이스 연결에 대한 지원을 추가 할 수 있습니다. 일부 확장은 REST API와 같은 특정 유형의 애플리케이션을 빌드하는 데 도움이되는 완전히 새로운 프레임 워크를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="35ef9e0d39d36c86e46287c793b6a8163c6f6a6d" translate="yes" xml:space="preserve">
          <source>Extensions are packages that help you accomplish common tasks. For example, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask.</source>
          <target state="translated">확장은 일반적인 작업을 수행하는 데 도움이되는 패키지입니다. 예를 들어 Flask-SQLAlchemy는 Flask에서 간단하고 쉽게 사용할 수 있도록 SQLAlchemy 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff127d5b1010f9f82f3ec88e10ac79ec202051bb" translate="yes" xml:space="preserve">
          <source>Externally Visible Server</source>
          <target state="translated">외부에서 볼 수있는 서버</target>
        </trans-unit>
        <trans-unit id="49bd1f7bce33a8da223ea7ca046f470b719fc306" translate="yes" xml:space="preserve">
          <source>Fabric 1.0 has to be installed locally. This tutorial assumes the latest version of Fabric.</source>
          <target state="translated">Fabric 1.0은 로컬로 설치해야합니다. 이 자습서에서는 최신 버전의 Fabric을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="42efac530815d6792637c25ea08f41c3f7ddf65d" translate="yes" xml:space="preserve">
          <source>Fabric will now connect to all servers and run the commands as written down in the fabfile. First it will execute pack so that we have our tarball ready and then it will execute deploy and upload the source code to all servers and install it there. Thanks to the &lt;code&gt;setup.py&lt;/code&gt; file we will automatically pull in the required libraries into our virtual environment.</source>
          <target state="translated">이제 Fabric은 모든 서버에 연결하고 fabfile에 기록 된대로 명령을 실행합니다. 먼저 패키지를 실행하여 tarball을 준비한 다음 배포를 실행하고 모든 서버에 소스 코드를 업로드하고 거기에 설치합니다. &lt;code&gt;setup.py&lt;/code&gt; 파일 덕분에 필요한 라이브러리를 가상 환경으로 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="19d28ee5c651574f219b3b7f8ecbfc5eddc2f232" translate="yes" xml:space="preserve">
          <source>Factor an application into a set of blueprints. This is ideal for larger applications; a project could instantiate an application object, initialize several extensions, and register a collection of blueprints.</source>
          <target state="translated">애플리케이션을 청사진 세트로 팩터링합니다. 이것은 더 큰 애플리케이션에 이상적입니다. 프로젝트는 애플리케이션 개체를 인스턴스화하고 여러 확장을 초기화하고 청사진 컬렉션을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab8a69ff145a8161b2fb1bf4d78c1f5dfb69c533" translate="yes" xml:space="preserve">
          <source>Factories &amp;amp; Extensions</source>
          <target state="translated">공장 및 확장</target>
        </trans-unit>
        <trans-unit id="8a92039eca1d52ebb1bbdc830e32a1822033e488" translate="yes" xml:space="preserve">
          <source>Factory Improvements</source>
          <target state="translated">공장 개선</target>
        </trans-unit>
        <trans-unit id="e5703e970a05a2a2783a34de47e138b96e238231" translate="yes" xml:space="preserve">
          <source>Faking Resources and Context</source>
          <target state="translated">가짜 리소스 및 컨텍스트</target>
        </trans-unit>
        <trans-unit id="e3a5a0bdbde438449796dfbadacba89a6f5afbcf" translate="yes" xml:space="preserve">
          <source>FastCGI</source>
          <target state="translated">FastCGI</target>
        </trans-unit>
        <trans-unit id="3a55b4118364b95e5543633d3422a67be3b5ca5e" translate="yes" xml:space="preserve">
          <source>FastCGI deployments tend to be hard to debug on most web servers. Very often the only thing the server log tells you is something along the lines of &amp;ldquo;premature end of headers&amp;rdquo;. In order to debug the application the only thing that can really give you ideas why it breaks is switching to the correct user and executing the application by hand.</source>
          <target state="translated">FastCGI 배포는 대부분의 웹 서버에서 디버그하기 어려운 경향이 있습니다. 매우 자주 서버 로그에서 &quot;헤더의 조기 끝&quot;줄에있는 내용 만 알려줍니다. 응용 프로그램을 디버깅하기 위해 왜 중단되었는지 알 수있는 유일한 방법은 올바른 사용자로 전환하고 응용 프로그램을 직접 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="31d8fd1a5fa75a518320fca490223d3265a21c5b" translate="yes" xml:space="preserve">
          <source>FastCGI is a deployment option on servers like &lt;a href=&quot;https://nginx.org/&quot;&gt;nginx&lt;/a&gt;, &lt;a href=&quot;https://www.lighttpd.net/&quot;&gt;lighttpd&lt;/a&gt;, and &lt;a href=&quot;http://cherokee-project.com/&quot;&gt;cherokee&lt;/a&gt;; see &lt;a href=&quot;../uwsgi/index&quot;&gt;uWSGI&lt;/a&gt; and &lt;a href=&quot;../wsgi-standalone/index&quot;&gt;Standalone WSGI Containers&lt;/a&gt; for other options. To use your WSGI application with any of them you will need a FastCGI server first. The most popular one is &lt;a href=&quot;https://pypi.org/project/flup/&quot;&gt;flup&lt;/a&gt; which we will use for this guide. Make sure to have it installed to follow along.</source>
          <target state="translated">FastCGI는 &lt;a href=&quot;https://nginx.org/&quot;&gt;nginx&lt;/a&gt; , &lt;a href=&quot;https://www.lighttpd.net/&quot;&gt;lighttpd&lt;/a&gt; 및 &lt;a href=&quot;http://cherokee-project.com/&quot;&gt;cherokee&lt;/a&gt; 와 같은 서버의 배포 옵션입니다 . 다른 옵션 은 &lt;a href=&quot;../uwsgi/index&quot;&gt;uWSGI&lt;/a&gt; 및 &lt;a href=&quot;../wsgi-standalone/index&quot;&gt;독립형 WSGI 컨테이너&lt;/a&gt; 를 참조하십시오 . WSGI 응용 프로그램을 이들과 함께 사용하려면 먼저 FastCGI 서버가 필요합니다. 가장 인기있는 것은 이 가이드에서 사용할 &lt;a href=&quot;https://pypi.org/project/flup/&quot;&gt;flup&lt;/a&gt; 입니다. 따라하기 위해 설치했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c09ab9ea91985578fea6798c7cff8723d2b9441b" translate="yes" xml:space="preserve">
          <source>File Uploads</source>
          <target state="translated">파일 업로드</target>
        </trans-unit>
        <trans-unit id="b4051ead58df2934293cc3ebbd08435e33e52795" translate="yes" xml:space="preserve">
          <source>Filter the flashed messages to one or more categories by providing those categories in &lt;code&gt;category_filter&lt;/code&gt;. This allows rendering categories in separate html blocks. The &lt;code&gt;with_categories&lt;/code&gt; and &lt;code&gt;category_filter&lt;/code&gt; arguments are distinct:</source>
          <target state="translated">에 그 범주를 제공하여 하나 개 이상의 범주에 번쩍 메시지를 필터링 &lt;code&gt;category_filter&lt;/code&gt; . 이를 통해 별도의 html 블록에서 범주를 렌더링 할 수 있습니다. &lt;code&gt;with_categories&lt;/code&gt; 및 &lt;code&gt;category_filter&lt;/code&gt; 의 인수는 별개 :</target>
        </trans-unit>
        <trans-unit id="6312251a367ac7a0f52a5fbb72985571982b28cc" translate="yes" xml:space="preserve">
          <source>Filtering Flash Messages</source>
          <target state="translated">플래시 메시지 필터링</target>
        </trans-unit>
        <trans-unit id="2d0017e9d51524cb3c6e068a73ecbb9611619463" translate="yes" xml:space="preserve">
          <source>Finding Extensions</source>
          <target state="translated">확장 찾기</target>
        </trans-unit>
        <trans-unit id="9698dff9608cc2d365b7ec76ba76253b42ece6b4" translate="yes" xml:space="preserve">
          <source>Firing Before/After Request</source>
          <target state="translated">요청 전 / 후 실행</target>
        </trans-unit>
        <trans-unit id="2787e5842e17571de57f71d1b139e63963085bd5" translate="yes" xml:space="preserve">
          <source>First Deployment</source>
          <target state="translated">첫 번째 배포</target>
        </trans-unit>
        <trans-unit id="45323d3473ef62b5b0e0ed5e05f9a86b189e7442" translate="yes" xml:space="preserve">
          <source>First we imported the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; class. An instance of this class will be our WSGI application.</source>
          <target state="translated">먼저 &lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 클래스를 가져 왔습니다 . 이 클래스의 인스턴스는 WSGI 응용 프로그램이됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed54dfcd30b6e2c6dec64cf59275915b6ed6381" translate="yes" xml:space="preserve">
          <source>First you need to create the CGI application file. Let&amp;rsquo;s call it &lt;code&gt;yourapplication.cgi&lt;/code&gt;:</source>
          <target state="translated">먼저 CGI 응용 프로그램 파일을 만들어야합니다. &lt;code&gt;yourapplication.cgi&lt;/code&gt; 라고 부르 자 .</target>
        </trans-unit>
        <trans-unit id="4f86b142381e8923b00fe6d89c7fd087fb7c679f" translate="yes" xml:space="preserve">
          <source>First you need to create the FastCGI server file. Let&amp;rsquo;s call it &lt;code&gt;yourapplication.fcgi&lt;/code&gt;:</source>
          <target state="translated">먼저 FastCGI 서버 파일을 만들어야합니다. &lt;code&gt;yourapplication.fcgi&lt;/code&gt; 라고 부르 자 .</target>
        </trans-unit>
        <trans-unit id="a2d94730c89b0f9f5654afd730e5a7357a7bb538" translate="yes" xml:space="preserve">
          <source>First, we need an application to test; we will use the application from the &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;Tutorial&lt;/a&gt;. If you don&amp;rsquo;t have that application yet, get the source code from &lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/tutorial&quot;&gt;the examples&lt;/a&gt;.</source>
          <target state="translated">먼저 테스트 할 애플리케이션이 필요합니다. &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;Tutorial&lt;/a&gt; 의 응용 프로그램을 사용합니다 . 해당 애플리케이션이 아직없는 경우 &lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/tutorial&quot;&gt;예제&lt;/a&gt; 에서 소스 코드를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3a1237103746170aadab1582b59ffdcd5fce3033" translate="yes" xml:space="preserve">
          <source>Flashes a message to the next request. In order to remove the flashed message from the session and to display it to the user, the template has to call &lt;a href=&quot;#flask.get_flashed_messages&quot;&gt;&lt;code&gt;get_flashed_messages()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 요청으로 메시지를 깜박입니다. 세션에서 플래시 된 메시지를 제거하고 사용자에게 표시하려면 템플릿에서 &lt;a href=&quot;#flask.get_flashed_messages&quot;&gt; &lt;code&gt;get_flashed_messages()&lt;/code&gt; &lt;/a&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cd7933a74919977ce76e10d0054fc9b1128c8839" translate="yes" xml:space="preserve">
          <source>Flashing With Categories</source>
          <target state="translated">카테고리로 깜박임</target>
        </trans-unit>
        <trans-unit id="184857a3477425828543a9f61fa5ec27aef8247f" translate="yes" xml:space="preserve">
          <source>Flask 0.7 introduces pluggable views inspired by the generic views from Django which are based on classes instead of functions. The main intention is that you can replace parts of the implementations and this way have customizable pluggable views.</source>
          <target state="translated">Flask 0.7은 함수 대신 클래스를 기반으로하는 Django의 일반 뷰에서 영감을받은 플러그 형 뷰를 도입합니다. 주요 의도는 구현의 일부를 교체 할 수 있으며 이러한 방식으로 사용자 정의 가능한 플러그 형 뷰를 가질 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d66f673bd05f637408e454ade54d953e23dde2ef" translate="yes" xml:space="preserve">
          <source>Flask 0.7 introduces the concept of URL processors. The idea is that you might have a bunch of resources with common parts in the URL that you don&amp;rsquo;t always explicitly want to provide. For instance you might have a bunch of URLs that have the language code in it but you don&amp;rsquo;t want to have to handle it in every single function yourself.</source>
          <target state="translated">Flask 0.7은 URL 프로세서의 개념을 도입했습니다. 아이디어는 URL에 항상 명시 적으로 제공하고 싶지 않은 공통 부분이있는 많은 리소스가있을 수 있다는 것입니다. 예를 들어 언어 코드가 포함 된 URL이 여러 개있을 수 있지만 모든 단일 기능에서 직접 처리 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7336a5940cd7eaef29da9c7ed83389ae8a483e2c" translate="yes" xml:space="preserve">
          <source>Flask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application&amp;rsquo;s folder directly (via &lt;code&gt;Flask.root_path&lt;/code&gt;). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package.</source>
          <target state="translated">Flask 0.8에는 인스턴스 폴더가 도입되었습니다. 오랫동안 Flask를 사용하면 &lt;code&gt;Flask.root_path&lt;/code&gt; 를 통해 응용 프로그램의 폴더와 관련된 경로를 직접 참조 할 수 있었습니다 . 이것은 또한 얼마나 많은 개발자가 애플리케이션 옆에 저장된 구성을로드했는지였습니다. 그러나 불행히도 이것은 루트 경로가 패키지의 내용을 참조하는 경우 응용 프로그램이 패키지가 아닌 경우에만 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6ca6e322ef9508c8f852221cb04dda494cc4c884" translate="yes" xml:space="preserve">
          <source>Flask Extension Development</source>
          <target state="translated">Flask 확장 개발</target>
        </trans-unit>
        <trans-unit id="db5cc1c927a8222d5daadad778e1c2e919b49f45" translate="yes" xml:space="preserve">
          <source>Flask Extensions</source>
          <target state="translated">플라스크 확장</target>
        </trans-unit>
        <trans-unit id="121515282ba7b4b45588478efeb96caa28c7733d" translate="yes" xml:space="preserve">
          <source>Flask automatically &lt;em&gt;pushes&lt;/em&gt; a request context when handling a request. View functions, error handlers, and other functions that run during a request will have access to the &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; proxy, which points to the request object for the current request.</source>
          <target state="translated">Flask 는 요청을 처리 할 때 요청 컨텍스트를 자동으로 &lt;em&gt;푸시&lt;/em&gt; 합니다. 요청 중에 실행되는보기 함수, 오류 처리기 및 기타 함수 는 현재 요청에 대한 요청 개체를 가리키는 &lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 프록시에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8cf751ea16e9e36c28dac408c8275133b72b565" translate="yes" xml:space="preserve">
          <source>Flask automatically &lt;em&gt;pushes&lt;/em&gt; an application context when handling a request. View functions, error handlers, and other functions that run during a request will have access to &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Flask 는 요청을 처리 할 때 애플리케이션 컨텍스트를 자동으로 &lt;em&gt;푸시&lt;/em&gt; 합니다. 요청 중에 실행되는보기 함수, 오류 처리기 및 기타 함수는 &lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; 에&lt;/a&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ebd986d793a85d37fb76d52f22349000a17f808" translate="yes" xml:space="preserve">
          <source>Flask can be used to serve Single-Page Applications (SPA) by placing static files produced by your frontend framework in a subfolder inside of your project. You will also need to create a catch-all endpoint that routes all requests to your SPA.</source>
          <target state="translated">Flask는 프런트 엔드 프레임 워크에서 생성 된 정적 파일을 프로젝트 내부의 하위 폴더에 배치하여 SPA (단일 페이지 애플리케이션)를 제공하는 데 사용할 수 있습니다. 또한 모든 요청을 SPA로 라우팅하는 포괄 엔드 포인트도 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="962535d28a565e89a4b72774e6dead5c9009a579" translate="yes" xml:space="preserve">
          <source>Flask comes with a couple of signals and other extensions might provide more. Also keep in mind that signals are intended to notify subscribers and should not encourage subscribers to modify data. You will notice that there are signals that appear to do the same thing like some of the builtin decorators do (eg: &lt;a href=&quot;../api/index#flask.request_started&quot;&gt;&lt;code&gt;request_started&lt;/code&gt;&lt;/a&gt; is very similar to &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt;). However, there are differences in how they work. The core &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; handler, for example, is executed in a specific order and is able to abort the request early by returning a response. In contrast all signal handlers are executed in undefined order and do not modify any data.</source>
          <target state="translated">Flask는 몇 가지 신호와 함께 제공되며 다른 확장은 더 많은 것을 제공 할 수 있습니다. 또한 신호는 구독자에게 알리기위한 것이며 구독자가 데이터를 수정하도록 권장해서는 안됩니다. 일부 내장 데코레이터가하는 것과 같은 일을하는 것처럼 보이는 신호가 있음을 알 수 있습니다 (예 : &lt;a href=&quot;../api/index#flask.request_started&quot;&gt; &lt;code&gt;request_started&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt; 와 매우 유사합니다 ). 그러나 작동 방식에는 차이가 있습니다. 예를 들어 핵심 &lt;a href=&quot;../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt; 핸들러는 특정 순서로 실행되며 응답을 반환하여 요청을 조기에 중단 할 수 있습니다. 반대로 모든 신호 핸들러는 정의되지 않은 순서로 실행되며 데이터를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2495a0e910d664897990cda168ba874b0ac057d" translate="yes" xml:space="preserve">
          <source>Flask comes with a handy &lt;a href=&quot;../../api/index#flask.abort&quot;&gt;&lt;code&gt;abort()&lt;/code&gt;&lt;/a&gt; function that aborts a request with an HTTP error code early. It will also provide a plain black and white error page for you with a basic description, but nothing fancy.</source>
          <target state="translated">Flask에는 HTTP 오류 코드로 요청을 일찍 &lt;a href=&quot;../../api/index#flask.abort&quot;&gt; &lt;code&gt;abort()&lt;/code&gt; &lt;/a&gt; 하는 편리한 abort () 함수 가 함께 제공됩니다 . 또한 기본적인 설명과 함께 평범한 흑백 오류 페이지를 제공하지만 화려하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bfbc50c634dc82c7a7509c6ab88140b7334267f" translate="yes" xml:space="preserve">
          <source>Flask configures Jinja2 to automatically escape all values unless explicitly told otherwise. This should rule out all XSS problems caused in templates, but there are still other places where you have to be careful:</source>
          <target state="translated">Flask는 별도로 명시하지 않는 한 모든 값을 자동으로 이스케이프하도록 Jinja2를 구성합니다. 이렇게하면 템플릿에서 발생하는 모든 XSS 문제를 배제 할 수 있지만주의해야 할 다른 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="011f84949573277b9a231ea8fb197f9af7805953" translate="yes" xml:space="preserve">
          <source>Flask decides on one template engine: Jinja2. Why doesn&amp;rsquo;t Flask have a pluggable template engine interface? You can obviously use a different template engine, but Flask will still configure Jinja2 for you. While that limitation that Jinja2 is &lt;em&gt;always&lt;/em&gt; configured will probably go away, the decision to bundle one template engine and use that will not.</source>
          <target state="translated">Flask는 하나의 템플릿 엔진 인 Jinja2를 결정합니다. Flask에 플러그인 가능한 템플릿 엔진 인터페이스가없는 이유는 무엇입니까? 분명히 다른 템플릿 엔진을 사용할 수 있지만 Flask는 여전히 Jinja2를 구성합니다. Jinja2가 &lt;em&gt;항상&lt;/em&gt; 구성 되는 제한은 사라지 겠지만 템플릿 엔진 하나를 번들로 묶어 사용하기로 한 결정은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="349844a7d2c8432e99b406d743435a48b68ddf97" translate="yes" xml:space="preserve">
          <source>Flask depends on the &lt;a href=&quot;https://www.palletsprojects.com/p/jinja/&quot;&gt;Jinja&lt;/a&gt; template engine and the &lt;a href=&quot;https://www.palletsprojects.com/p/werkzeug/&quot;&gt;Werkzeug&lt;/a&gt; WSGI toolkit. The documentation for these libraries can be found at:</source>
          <target state="translated">Flask는 &lt;a href=&quot;https://www.palletsprojects.com/p/jinja/&quot;&gt;Jinja&lt;/a&gt; 템플릿 엔진과 &lt;a href=&quot;https://www.palletsprojects.com/p/werkzeug/&quot;&gt;Werkzeug&lt;/a&gt; WSGI 툴킷 에 의존합니다 . 이러한 라이브러리에 대한 문서는 다음에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f4785f37d3f33e82cf8e01880bffeab1c7bc723" translate="yes" xml:space="preserve">
          <source>Flask dispatches a request in multiple stages which can affect the request, response, and how errors are handled. The contexts are active during all of these stages.</source>
          <target state="translated">Flask는 요청, 응답 및 오류 처리 방법에 영향을 줄 수있는 여러 단계로 요청을 전달합니다. 컨텍스트는 이러한 모든 단계에서 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a6b65d1799953f803b62a9ee3777c45ce8d89713" translate="yes" xml:space="preserve">
          <source>Flask extensions are usually named &amp;ldquo;Flask-Foo&amp;rdquo; or &amp;ldquo;Foo-Flask&amp;rdquo;. You can search PyPI for packages tagged with &lt;a href=&quot;https://pypi.org/search/?c=Framework+%3A%3A+Flask&quot;&gt;Framework :: Flask&lt;/a&gt;.</source>
          <target state="translated">Flask 확장의 이름은 일반적으로 &quot;Flask-Foo&quot;또는 &quot;Foo-Flask&quot;입니다. &lt;a href=&quot;https://pypi.org/search/?c=Framework+%3A%3A+Flask&quot;&gt;Framework :: Flask&lt;/a&gt; 태그가 지정된 패키지에 대해 PyPI를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="984e9db92c2cd36a47948b3a990931a7d5df904e" translate="yes" xml:space="preserve">
          <source>Flask has a few assumptions about your application (which you can change of course) that give you basic and painless Unicode support:</source>
          <target state="translated">Flask에는 기본적이고 간편한 유니 코드 지원을 제공하는 애플리케이션 (물론 변경할 수 있음)에 대한 몇 가지 가정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="71a713f5f554d2d08db1fcf694d2bb2407e63b0b" translate="yes" xml:space="preserve">
          <source>Flask has great support for JSON, and is a popular choice for building JSON APIs. Making requests with JSON data and examining JSON data in responses is very convenient:</source>
          <target state="translated">Flask는 JSON을 크게 지원하며 JSON API를 빌드하는 데 널리 사용됩니다. JSON 데이터로 요청하고 응답에서 JSON 데이터를 검사하는 것은 매우 편리합니다.</target>
        </trans-unit>
        <trans-unit id="fe12eb4cba00e9cf730434bd7ac354dd2d25542e" translate="yes" xml:space="preserve">
          <source>Flask has many configuration values, with sensible defaults, and a few conventions when getting started. By convention, templates and static files are stored in subdirectories within the application&amp;rsquo;s Python source tree, with the names &lt;code&gt;templates&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; respectively. While this can be changed, you usually don&amp;rsquo;t have to, especially when getting started.</source>
          <target state="translated">Flask에는 합리적인 기본값과 함께 시작할 때 몇 가지 규칙이있는 많은 구성 값이 있습니다. 관례에 따라 템플릿과 정적 파일은 각각 &lt;code&gt;templates&lt;/code&gt; 과 &lt;code&gt;static&lt;/code&gt; 이라는 이름을 사용 하여 애플리케이션의 Python 소스 트리 내의 하위 디렉터리에 저장 됩니다. 변경할 수 있지만 일반적으로 특히 시작할 때 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc7225882d68f7184effec3b5f15fcdfff0f04a6" translate="yes" xml:space="preserve">
          <source>Flask includes many hooks to customize its behavior. Should you need more customization, the Flask class is built for subclassing. If you are interested in that, check out the &lt;a href=&quot;../becomingbig/index#becomingbig&quot;&gt;Becoming Big&lt;/a&gt; chapter. If you are curious about the Flask design principles, head over to the section about &lt;a href=&quot;../design/index#design&quot;&gt;Design Decisions in Flask&lt;/a&gt;.</source>
          <target state="translated">Flask에는 동작을 사용자 지정하는 많은 후크가 포함되어 있습니다. 더 많은 사용자 정의가 필요한 경우 Flask 클래스가 하위 클래스로 만들어집니다. 관심이 있으시면 &lt;a href=&quot;../becomingbig/index#becomingbig&quot;&gt;Becoming Big&lt;/a&gt; 챕터를 확인하세요 . Flask 디자인 원칙에 대해 궁금한 경우 Flask의 &lt;a href=&quot;../design/index#design&quot;&gt;디자인 결정&lt;/a&gt; 섹션으로 이동하세요 .</target>
        </trans-unit>
        <trans-unit id="d12b0ef17d6033f3181d63aa1007fac6cbf08de4" translate="yes" xml:space="preserve">
          <source>Flask inserts a couple of global functions and helpers into the Jinja2 context, additionally to the values that are present by default.</source>
          <target state="translated">Flask는 기본적으로 존재하는 값 외에도 Jinja2 컨텍스트에 몇 가지 전역 함수와 도우미를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ccfc3dc53b9acb968e4ad36ab34b609bd1412605" translate="yes" xml:space="preserve">
          <source>Flask is a framework that takes advantage of the work already done by Werkzeug to properly interface WSGI (which can be a complex task at times). Thanks to recent developments in the Python package infrastructure, packages with dependencies are no longer an issue and there are very few reasons against having libraries that depend on others.</source>
          <target state="translated">Flask는 Werkzeug가 이미 수행 한 작업을 활용하여 WSGI (때때로 복잡한 작업이 될 수 있음)와 올바르게 인터페이스하는 프레임 워크입니다. Python 패키지 인프라의 최근 개발 덕분에 종속성이있는 패키지는 더 이상 문제가되지 않으며 다른 라이브러리에 의존하는 라이브러리를 사용할 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c22b3f6618cef75dd42bf0710bffc58dd1998440" translate="yes" xml:space="preserve">
          <source>Flask is no different from any other framework in that you the developer must build with caution, watching for exploits when building to your requirements.</source>
          <target state="translated">Flask는 개발자가 신중하게 빌드하고 요구 사항에 맞게 빌드 할 때 익스플로잇을 관찰해야한다는 점에서 다른 프레임 워크와 다르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8e8957bc00d9f2d56468f15068253da3d81c9ca" translate="yes" xml:space="preserve">
          <source>Flask is now installed. Check out the &lt;a href=&quot;../quickstart/index&quot;&gt;Quickstart&lt;/a&gt; or go to the &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/&quot;&gt;Documentation Overview&lt;/a&gt;.</source>
          <target state="translated">이제 Flask가 설치되었습니다. &lt;a href=&quot;../quickstart/index&quot;&gt;빠른 시작을&lt;/a&gt; 확인 하거나 &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/&quot;&gt;문서 개요&lt;/a&gt; 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="be9956685dd3e8bf2b0d47b7543cdce26b6b46f1" translate="yes" xml:space="preserve">
          <source>Flask is usually used with the decorators. Decorators are simple and you have the URL right next to the function that is called for that specific URL. However there is a downside to this approach: it means all your code that uses decorators has to be imported upfront or Flask will never actually find your function.</source>
          <target state="translated">Flask는 일반적으로 데코레이터와 함께 사용됩니다. 데코레이터는 간단하며 특정 URL에 대해 호출되는 함수 바로 옆에 URL이 있습니다. 그러나이 방법에는 단점이 있습니다. 즉, 데코레이터를 사용하는 모든 코드를 미리 가져와야합니다. 그렇지 않으면 Flask가 실제로 함수를 찾지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c3312274ffbbc81aa6441afc0527d6a114cb302" translate="yes" xml:space="preserve">
          <source>Flask itself does not provide caching for you, but &lt;a href=&quot;https://flask-caching.readthedocs.io/en/latest/&quot;&gt;Flask-Caching&lt;/a&gt;, an extension for Flask does. Flask-Caching supports various backends, and it is even possible to develop your own caching backend.</source>
          <target state="translated">Flask 자체는 캐싱을 제공하지 않지만 &lt;a href=&quot;https://flask-caching.readthedocs.io/en/latest/&quot;&gt;Flask&lt;/a&gt; 의 확장 기능인 Flask-Caching 은 제공합니다. Flask-Caching은 다양한 백엔드를 지원하며 자체 캐싱 백엔드를 개발하는 것도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e8ea4f79aa7d3767df2be47a3f7dcd8914540bc" translate="yes" xml:space="preserve">
          <source>Flask itself, and all the libraries you can find on PyPI are distributed with either setuptools or distutils.</source>
          <target state="translated">Flask 자체와 PyPI에서 찾을 수있는 모든 라이브러리는 setuptools 또는 distutils와 함께 배포됩니다.</target>
        </trans-unit>
        <trans-unit id="216a26977bf976ac27b44c2d9a5c3afd6a52c0ef" translate="yes" xml:space="preserve">
          <source>Flask leverages Jinja2 as its template engine. You are obviously free to use a different template engine, but you still have to install Jinja2 to run Flask itself. This requirement is necessary to enable rich extensions. An extension can depend on Jinja2 being present.</source>
          <target state="translated">Flask는 Jinja2를 템플릿 엔진으로 활용합니다. 분명히 다른 템플릿 엔진을 자유롭게 사용할 수 있지만 Flask 자체를 실행하려면 Jinja2를 설치해야합니다. 이 요구 사항은 풍부한 확장을 활성화하는 데 필요합니다. 확장은 Jinja2의 존재 여부에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="797a4e89f4f35323c05d5147f201c0ff39c056ef" translate="yes" xml:space="preserve">
          <source>Flask provides &lt;a href=&quot;../api/index#flask.Flask.test_cli_runner&quot;&gt;&lt;code&gt;test_cli_runner()&lt;/code&gt;&lt;/a&gt; to create a &lt;a href=&quot;../api/index#flask.testing.FlaskCliRunner&quot;&gt;&lt;code&gt;FlaskCliRunner&lt;/code&gt;&lt;/a&gt; that passes the Flask app to the CLI automatically. Use its &lt;a href=&quot;../api/index#flask.testing.FlaskCliRunner.invoke&quot;&gt;&lt;code&gt;invoke()&lt;/code&gt;&lt;/a&gt; method to call commands in the same way they would be called from the command line.</source>
          <target state="translated">Flask는 Flask 앱을 ​​CLI에 자동으로 전달 하는 &lt;a href=&quot;../api/index#flask.testing.FlaskCliRunner&quot;&gt; &lt;code&gt;FlaskCliRunner&lt;/code&gt; &lt;/a&gt; 를 생성하기 위해 &lt;a href=&quot;../api/index#flask.Flask.test_cli_runner&quot;&gt; &lt;code&gt;test_cli_runner()&lt;/code&gt; &lt;/a&gt; 를 제공합니다 . &lt;a href=&quot;../api/index#flask.testing.FlaskCliRunner.invoke&quot;&gt; &lt;code&gt;invoke()&lt;/code&gt; &lt;/a&gt; 메서드를 사용 하여 명령 줄에서 호출되는 것과 동일한 방식으로 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d1f14fcd1f773fbf3404998311f0e848207d715d" translate="yes" xml:space="preserve">
          <source>Flask provides a way to test your application by exposing the Werkzeug test &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client&quot;&gt;&lt;code&gt;Client&lt;/code&gt;&lt;/a&gt; and handling the context locals for you. You can then use that with your favourite testing solution.</source>
          <target state="translated">Flask는 Werkzeug 테스트 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client&quot;&gt; &lt;code&gt;Client&lt;/code&gt; &lt;/a&gt; 를 노출 하고 컨텍스트 로컬을 처리 하여 애플리케이션을 테스트하는 방법을 제공 합니다. 그런 다음 선호하는 테스트 솔루션과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="592508769a663493ec87d7350733770daa63ae25" translate="yes" xml:space="preserve">
          <source>Flask provides the following Jinja2 filters in addition to the filters provided by Jinja2 itself:</source>
          <target state="translated">Flask는 Jinja2 자체에서 제공하는 필터 외에도 다음과 같은 Jinja2 필터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7677418e6b0708f772ad69283cd9ec61046dcb75" translate="yes" xml:space="preserve">
          <source>Flask solves this issue with the &lt;em&gt;application context&lt;/em&gt;. Rather than referring to an &lt;code&gt;app&lt;/code&gt; directly, you use the &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; proxy, which points to the application handling the current activity.</source>
          <target state="translated">Flask는 &lt;em&gt;응용 프로그램 컨텍스트&lt;/em&gt; 로이 문제를 해결합니다 . &lt;code&gt;app&lt;/code&gt; 직접 참조하는 대신 현재 활동을 처리하는 애플리케이션을 가리키는 &lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt; 프록시 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c464e39a968f5ed13ba3700778f653b853744270" translate="yes" xml:space="preserve">
          <source>Flask started in part to demonstrate how to build your own framework on top of existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it developed, it became useful to a wide audience. As you grow your codebase, don&amp;rsquo;t just use Flask &amp;ndash; understand it. Read the source. Flask&amp;rsquo;s code is written to be read; its documentation is published so you can use its internal APIs. Flask sticks to documented APIs in upstream libraries, and documents its internal utilities so that you can find the hook points needed for your project.</source>
          <target state="translated">Flask는 부분적으로 잘 사용되는 기존 도구 Werkzeug (WSGI) 및 Jinja (템플릿) 위에 자신 만의 프레임 워크를 구축하는 방법을 시연하기 시작했으며, 개발되면서 광범위한 청중에게 유용 해졌습니다. 코드베이스를 확장 할 때 Flask를 사용하는 것이 아니라 이해하십시오. 소스를 읽으십시오. Flask의 코드는 읽을 수 있도록 작성되었습니다. 내부 API를 사용할 수 있도록 문서가 게시됩니다. Flask는 업스트림 라이브러리의 문서화 된 API를 고수하고 프로젝트에 필요한 후크 포인트를 찾을 수 있도록 내부 유틸리티를 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="e0847a4729c2097676fe122c07038993b602337b" translate="yes" xml:space="preserve">
          <source>Flask uses &lt;code&gt;simplejson&lt;/code&gt; for the JSON implementation. Since simplejson is provided by both the standard library as well as extension, Flask will try simplejson first and then fall back to the stdlib json module. On top of that it will delegate access to the current application&amp;rsquo;s JSON encoders and decoders for easier customization.</source>
          <target state="translated">Flask는 JSON 구현을 위해 &lt;code&gt;simplejson&lt;/code&gt; 을 사용합니다 . simplejson은 표준 라이브러리와 확장 모두에서 제공되므로 Flask는 먼저 simplejson을 시도한 다음 stdlib json 모듈로 폴백합니다. 또한 더 쉬운 사용자 지정을 위해 현재 애플리케이션의 JSON 인코더 및 디코더에 대한 액세스 권한을 위임합니다.</target>
        </trans-unit>
        <trans-unit id="04b788af2413b20c6ad3c20dfd4c63fe9f8e44b0" translate="yes" xml:space="preserve">
          <source>Flask uses a concept of &lt;em&gt;blueprints&lt;/em&gt; for making application components and supporting common patterns within an application or across applications. Blueprints can greatly simplify how large applications work and provide a central means for Flask extensions to register operations on applications. A &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; object works similarly to a &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; application object, but it is not actually an application. Rather it is a &lt;em&gt;blueprint&lt;/em&gt; of how to construct or extend an application.</source>
          <target state="translated">Flask는 애플리케이션 구성 요소를 만들고 애플리케이션 내에서 또는 애플리케이션 전체에서 공통 패턴을 지원하기 위해 &lt;em&gt;청사진&lt;/em&gt; 개념을 사용합니다 . Blueprint는 대규모 애플리케이션의 작동 방식을 크게 단순화하고 Flask 확장이 애플리케이션에 대한 작업을 등록하는 중앙 수단을 제공 할 수 있습니다. &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt; 객체는 비슷하게 작동 &lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 응용 프로그램 개체,하지만 실제로 응용 프로그램이 아닙니다. 오히려 애플리케이션을 구성하거나 확장하는 방법에 대한 &lt;em&gt;청사진&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ff93cdd56eadc6b49c0e952f58aa8c1fd9716d3" translate="yes" xml:space="preserve">
          <source>Flask uses standard Python &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt;. Messages about your Flask application are logged with &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;app.logger&lt;/code&gt;&lt;/a&gt;, which takes the same name as &lt;a href=&quot;../api/index#flask.Flask.name&quot;&gt;&lt;code&gt;app.name&lt;/code&gt;&lt;/a&gt;. This logger can also be used to log your own messages.</source>
          <target state="translated">Flask는 표준 Python &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 사용합니다 . Flask 애플리케이션에 대한 메시지는 &lt;a href=&quot;../api/index#flask.Flask.name&quot;&gt; &lt;code&gt;app.name&lt;/code&gt; &lt;/a&gt; 과 동일한 이름을 사용하는 &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;app.logger&lt;/code&gt; &lt;/a&gt; 로 기록됩니다 . 이 로거는 자신의 메시지를 기록하는데도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="966cba7aad20c82412e3f9304afdaeaa3f924428" translate="yes" xml:space="preserve">
          <source>Flask uses the Werkzeug routing system which was designed to automatically order routes by complexity. This means that you can declare routes in arbitrary order and they will still work as expected. This is a requirement if you want to properly implement decorator based routing since decorators could be fired in undefined order when the application is split into multiple modules.</source>
          <target state="translated">Flask는 복잡성에 따라 경로를 자동으로 정렬하도록 설계된 Werkzeug 라우팅 시스템을 사용합니다. 즉, 임의의 순서로 경로를 선언 할 수 있으며 예상대로 계속 작동합니다. 이는 애플리케이션이 여러 모듈로 분할 될 때 정의되지 않은 순서로 데코레이터가 실행될 수 있으므로 데코레이터 기반 라우팅을 올바르게 구현하려는 경우 요구 사항입니다.</target>
        </trans-unit>
        <trans-unit id="f64b76eb50c19b570be3d1b4da0a3c2a61849c6a" translate="yes" xml:space="preserve">
          <source>Flask uses thread local objects (context local objects in fact, they support greenlet contexts as well) for request, session and an extra object you can put your own things on (&lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;). Why is that and isn&amp;rsquo;t that a bad idea?</source>
          <target state="translated">Flask는 요청, 세션 및 추가 개체 ( &lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; ) 에 스레드 로컬 개체 (사실 컨텍스트 로컬 개체, 그린 렛 컨텍스트도 지원 )를 사용합니다. 왜 그게 나쁜 생각이 아닌가?</target>
        </trans-unit>
        <trans-unit id="e8f95c85455d7c537f929e2111aa40076fc9d4af" translate="yes" xml:space="preserve">
          <source>Flask will also automatically push an app context when running CLI commands registered with &lt;code&gt;Flask.cli&lt;/code&gt; using &lt;code&gt;@app.cli.command()&lt;/code&gt;.</source>
          <target state="translated">Flask는 &lt;code&gt;@app.cli.command()&lt;/code&gt; 사용하여 &lt;code&gt;Flask.cli&lt;/code&gt; 에 등록 된 CLI 명령을 실행할 때 앱 컨텍스트를 자동으로 푸시합니다 .</target>
        </trans-unit>
        <trans-unit id="197c96d166d5f07e5e553d5a623a785e17727d4c" translate="yes" xml:space="preserve">
          <source>Flask will automatically detect the factory (&lt;code&gt;create_app&lt;/code&gt; or &lt;code&gt;make_app&lt;/code&gt;) in &lt;code&gt;myapp&lt;/code&gt;. You can also pass arguments to the factory like this:</source>
          <target state="translated">Flask는 &lt;code&gt;myapp&lt;/code&gt; 에서 팩토리 ( &lt;code&gt;create_app&lt;/code&gt; 또는 &lt;code&gt;make_app&lt;/code&gt; )를 자동으로 감지합니다 . 다음과 같이 팩토리에 인수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="41635622907fe7eb6accd34a417b68f988a7414e" translate="yes" xml:space="preserve">
          <source>Flask will automatically load commands specified in the &lt;code&gt;flask.commands&lt;/code&gt;&lt;a href=&quot;https://packaging.python.org/tutorials/packaging-projects/#entry-points&quot;&gt;entry point&lt;/a&gt;. This is useful for extensions that want to add commands when they are installed. Entry points are specified in &lt;code&gt;setup.py&lt;/code&gt;</source>
          <target state="translated">Flask는 &lt;code&gt;flask.commands&lt;/code&gt; &lt;a href=&quot;https://packaging.python.org/tutorials/packaging-projects/#entry-points&quot;&gt;진입 점에&lt;/a&gt; 지정된 명령을 자동으로로드합니다 . 이것은 설치할 때 명령을 추가하려는 확장에 유용합니다. 진입 점은 &lt;code&gt;setup.py&lt;/code&gt; 에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="79fc3ae08938577b775d2129f2a713beb05d21f1" translate="yes" xml:space="preserve">
          <source>Flask will look for templates in the &lt;code&gt;templates&lt;/code&gt; folder. So if your application is a module, this folder is next to that module, if it&amp;rsquo;s a package it&amp;rsquo;s actually inside your package:</source>
          <target state="translated">Flask는 &lt;code&gt;templates&lt;/code&gt; 폴더 에서 템플릿을 찾습니다 . 따라서 애플리케이션이 모듈 인 경우이 폴더는 해당 모듈 옆에 있고, 패키지 인 경우 실제로 패키지 내부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="47ed72509cd7ffd050f17838ecd2120f51b86190" translate="yes" xml:space="preserve">
          <source>Flask will never have a database layer. It will not have a form library or anything else in that direction. Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions.</source>
          <target state="translated">Flask에는 데이터베이스 레이어가 없습니다. 양식 라이브러리 또는 해당 방향의 다른 항목이 없습니다. Flask 자체는 Werkzeug와 연결하여 적절한 WSGI 애플리케이션을 구현하고 Jinja2에 연결하여 템플릿을 처리합니다. 또한 로깅과 같은 몇 가지 공통 표준 라이브러리 패키지에 바인딩됩니다. 다른 모든 것은 확장을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1868082db1e2cb6290f6a1a4b5973c897d996d1f" translate="yes" xml:space="preserve">
          <source>Flask will suppress any server error with a generic error page unless it is in debug mode. As such to enable just the interactive debugger without the code reloading, you have to invoke &lt;a href=&quot;#flask.Flask.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;debug=True&lt;/code&gt; and &lt;code&gt;use_reloader=False&lt;/code&gt;. Setting &lt;code&gt;use_debugger&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt; without being in debug mode won&amp;rsquo;t catch any exceptions because there won&amp;rsquo;t be any to catch.</source>
          <target state="translated">Flask는 디버그 모드가 아닌 경우 일반 오류 페이지와 함께 모든 서버 오류를 억제합니다. 따라서 코드가 다시로드하지 않고 바로 대화 형 디버거를 사용하려면 호출해야 &lt;a href=&quot;#flask.Flask.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;debug=True&lt;/code&gt; 과 &lt;code&gt;use_reloader=False&lt;/code&gt; . 디버그 모드에 있지 않고 &lt;code&gt;use_debugger&lt;/code&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정하면 포착 할 항목이 없기 때문에 예외가 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81df7e8c0f93acb5a5a5ecf0b36c8528cbbae99e" translate="yes" xml:space="preserve">
          <source>Flask&amp;rsquo;s default cookie implementation validates that the cryptographic signature is not older than this value.</source>
          <target state="translated">Flask의 기본 쿠키 구현은 암호화 서명이이 값보다 오래되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b9b2f2fc826d2d34b827124bfc78bf5924d909cf" translate="yes" xml:space="preserve">
          <source>Flask, like Jinja2 and Werkzeug, is totally Unicode based when it comes to text. Not only these libraries, also the majority of web related Python libraries that deal with text. If you don&amp;rsquo;t know Unicode so far, you should probably read &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&lt;/a&gt;. This part of the documentation just tries to cover the very basics so that you have a pleasant experience with Unicode related things.</source>
          <target state="translated">Jinja2 및 Werkzeug와 같은 Flask는 텍스트와 관련하여 완전히 유니 코드 기반입니다. 이러한 라이브러리뿐만 아니라 텍스트를 처리하는 대부분의 웹 관련 Python 라이브러리도 있습니다. 지금까지 유니 코드를 모른다면 &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets를 읽어야&lt;/a&gt; 합니다. 문서의이 부분은 유니 코드 관련 항목에 대한 즐거운 경험을 할 수 있도록 기본 사항을 다루려고합니다.</target>
        </trans-unit>
        <trans-unit id="da951b0087f383da0dadb1545c31347a1b494bce" translate="yes" xml:space="preserve">
          <source>Flask-MongoEngine adds helpful utilities on top of MongoEngine. Check out their &lt;a href=&quot;https://flask-mongoengine.readthedocs.io&quot;&gt;documentation&lt;/a&gt; as well.</source>
          <target state="translated">Flask-MongoEngine은 MongoEngine 위에 유용한 유틸리티를 추가합니다. &lt;a href=&quot;https://flask-mongoengine.readthedocs.io&quot;&gt;설명서&lt;/a&gt; 도 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5f610c58c52a1e9bdc835cded1ae836455c1f50" translate="yes" xml:space="preserve">
          <source>Flask-SQLAlchemy Extension</source>
          <target state="translated">Flask-SQLAlchemy 확장</target>
        </trans-unit>
        <trans-unit id="44a37755d5acf7902c3c6e3b3f691c61af8d571d" translate="yes" xml:space="preserve">
          <source>Follow-up reads:</source>
          <target state="translated">후속 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45ba4780b08621c81336622af654cfda776db6c3" translate="yes" xml:space="preserve">
          <source>For Extension Developers</source>
          <target state="translated">확장 개발자 용</target>
        </trans-unit>
        <trans-unit id="d6336e424a4c221ea4a7c85e4aea50d64686baa9" translate="yes" xml:space="preserve">
          <source>For Python 3 add the following lines to the top of your &lt;code&gt;.wsgi&lt;/code&gt; file:</source>
          <target state="translated">Python 3의 경우 &lt;code&gt;.wsgi&lt;/code&gt; 파일 상단에 다음 줄을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="8b15b27d11c853c2b1e263cb44437a2e2829cb75" translate="yes" xml:space="preserve">
          <source>For RESTful APIs it&amp;rsquo;s especially helpful to execute a different function for each HTTP method. With the &lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt;&lt;code&gt;flask.views.MethodView&lt;/code&gt;&lt;/a&gt; you can easily do that. Each HTTP method maps to a function with the same name (just in lowercase):</source>
          <target state="translated">RESTful API의 경우 각 HTTP 메서드에 대해 다른 기능을 실행하는 것이 특히 유용합니다. &lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt; &lt;code&gt;flask.views.MethodView&lt;/code&gt; &lt;/a&gt; 를 사용하면 쉽게 할 수 있습니다. 각 HTTP 메서드는 동일한 이름 (소문자)을 가진 함수에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="fb34ccf1fce26db178b23572af7020d4fcf94407" translate="yes" xml:space="preserve">
          <source>For a full list of methods and attributes of the request object, head over to the &lt;a href=&quot;../api/index#flask.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">요청 객체의 메서드 및 속성에 대한 전체 목록은 &lt;a href=&quot;../api/index#flask.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="852be1abc142c93285f091d4730ad4750901f0c8" translate="yes" xml:space="preserve">
          <source>For a more optimized setup, see &lt;a href=&quot;../uwsgi/index&quot;&gt;configuring uWSGI and NGINX&lt;/a&gt;.</source>
          <target state="translated">보다 최적화 된 설정은 &lt;a href=&quot;../uwsgi/index&quot;&gt;uWSGI 및 NGINX 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bebceeec666b0a7aca2ebfb4e47773a6cab3a11f" translate="yes" xml:space="preserve">
          <source>For a test it would be nice to override this user from the outside without having to change some code. This can be accomplished with hooking the &lt;a href=&quot;../api/index#flask.appcontext_pushed&quot;&gt;&lt;code&gt;flask.appcontext_pushed&lt;/code&gt;&lt;/a&gt; signal:</source>
          <target state="translated">테스트를 위해 코드를 변경하지 않고 외부에서이 사용자를 재정의하는 것이 좋습니다. 이는 &lt;a href=&quot;../api/index#flask.appcontext_pushed&quot;&gt; &lt;code&gt;flask.appcontext_pushed&lt;/code&gt; &lt;/a&gt; 신호 를 연결하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e361326d2c4c5412fd98c0d28458fdeff67da3c6" translate="yes" xml:space="preserve">
          <source>For a while, it appeared that HTML was about to be replaced by XHTML. However, barely any websites on the Internet are actual XHTML (which is HTML processed using XML rules). There are a couple of major reasons why this is the case. One of them is Internet Explorer&amp;rsquo;s lack of proper XHTML support. The XHTML spec states that XHTML must be served with the MIME type &lt;em&gt;application/xhtml+xml&lt;/em&gt;, but Internet Explorer refuses to read files with that MIME type. While it is relatively easy to configure Web servers to serve XHTML properly, few people do. This is likely because properly using XHTML can be quite painful.</source>
          <target state="translated">잠시 동안 HTML이 XHTML로 대체 될 것 같았습니다. 그러나 인터넷의 거의 모든 웹 사이트가 실제 XHTML (XML 규칙을 사용하여 처리 된 HTML)입니다. 이것이 사실 인 몇 가지 주요 이유가 있습니다. 그중 하나는 Internet Explorer의 적절한 XHTML 지원 부족입니다. XHTML 사양에 따르면 XHTML은 MIME 유형 &lt;em&gt;application / xhtml + xml&lt;/em&gt; 과 함께 제공되어야 하지만 Internet Explorer는 해당 MIME 유형의 파일 읽기를 거부합니다. XHTML을 적절하게 제공하도록 웹 서버를 구성하는 것은 비교적 쉽지만 그렇게하는 사람은 거의 없습니다. XHTML을 올바르게 사용하는 것은 상당히 고통 스러울 수 있기 때문일 것입니다.</target>
        </trans-unit>
        <trans-unit id="ae0456f3508c3cc308f522071d0398758e1e51cc" translate="yes" xml:space="preserve">
          <source>For all core Flask signals, the sender is the application that issued the signal. When you subscribe to a signal, be sure to also provide a sender unless you really want to listen for signals from all applications. This is especially true if you are developing an extension.</source>
          <target state="translated">모든 핵심 Flask 신호의 경우 발신자는 신호를 발행 한 애플리케이션입니다. 신호를 구독 할 때 실제로 모든 애플리케이션의 신호를 수신하고 싶지 않은 경우 발신자도 제공해야합니다. 확장 프로그램을 개발하는 경우 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="602725e0805d60d6c95b054da78f128df24a8b1e" translate="yes" xml:space="preserve">
          <source>For clarity, the JSON serialization behavior has the following differences from &lt;a href=&quot;#flask.json.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">명확성을 위해 JSON 직렬화 동작은 &lt;a href=&quot;#flask.json.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt; 와 다음과 같은 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d298197fabc90e461895f9a5bb6e0307c01b8b0" translate="yes" xml:space="preserve">
          <source>For example if your application is defined in &lt;code&gt;yourapplication/app.py&lt;/code&gt; you should create it with one of the two versions below:</source>
          <target state="translated">예를 들어 애플리케이션이 &lt;code&gt;yourapplication/app.py&lt;/code&gt; 에 정의되어있는 경우 아래 두 버전 중 하나로 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f886823d78ebe1c764bbf36533828ec0353bbf2" translate="yes" xml:space="preserve">
          <source>For example you could have your main application run on &lt;code&gt;/&lt;/code&gt; and your backend interface on &lt;code&gt;/backend&lt;/code&gt;:</source>
          <target state="translated">예를 들어 주 애플리케이션은 &lt;code&gt;/&lt;/code&gt; 에서 실행 하고 백엔드 인터페이스는 &lt;code&gt;/backend&lt;/code&gt; 에서 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7965408e907b234adbb533b0d3875674b21916c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;import y\bose\bm\bi\bt\be\b&lt;/code&gt; renders as &lt;code&gt;import yosemite&lt;/code&gt; in HTML, but the backspaces are applied when pasted into a terminal, and it becomes &lt;code&gt;import os&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;import y\bose\bm\bi\bt\be\b&lt;/code&gt; 는 HTML에서 &lt;code&gt;import yosemite&lt;/code&gt; 로 렌더링 되지만 터미널에 붙여 넣을 때 백 스페이스가 적용되고 &lt;code&gt;import os&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="1e43eb31fc813c5f923980877e2fb8078248f8b1" translate="yes" xml:space="preserve">
          <source>For example, here is a helper context manager that can be used in a unit test to determine which templates were rendered and what variables were passed to the template:</source>
          <target state="translated">예를 들어 다음은 단위 테스트에서 렌더링 된 템플릿과 템플릿에 전달 된 변수를 확인하는 데 사용할 수있는 도우미 컨텍스트 관리자입니다.</target>
        </trans-unit>
        <trans-unit id="1ac7193f33e2a1a5285e969b8574eea26f749376" translate="yes" xml:space="preserve">
          <source>For example, here we use the &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; method to try out &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; tells Flask to behave as though it&amp;rsquo;s handling a request even while we use a Python shell. See &lt;a href=&quot;#context-locals&quot;&gt;Context Locals&lt;/a&gt;.</source>
          <target state="translated">예를 들어, 우리가 사용 &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt; 시도하는 방법을 &lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt; 는 Flask에게 Python 셸을 사용하는 동안에도 요청을 처리하는 것처럼 동작하도록 지시합니다. &lt;a href=&quot;#context-locals&quot;&gt;컨텍스트 로컬을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="883783a3b51480050247036b40d3fc0bad6bc871" translate="yes" xml:space="preserve">
          <source>For example, if an instance of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError&quot;&gt;&lt;code&gt;ConnectionRefusedError&lt;/code&gt;&lt;/a&gt; is raised, and a handler is registered for &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionError&quot;&gt;&lt;code&gt;ConnectionError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError&quot;&gt;&lt;code&gt;ConnectionRefusedError&lt;/code&gt;&lt;/a&gt;, the more specific &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError&quot;&gt;&lt;code&gt;ConnectionRefusedError&lt;/code&gt;&lt;/a&gt; handler is called with the exception instance to generate the response.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError&quot;&gt; &lt;code&gt;ConnectionRefusedError&lt;/code&gt; &lt;/a&gt; 인스턴스 가 발생하고 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionError&quot;&gt; &lt;code&gt;ConnectionError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError&quot;&gt; &lt;code&gt;ConnectionRefusedError&lt;/code&gt; 에&lt;/a&gt; 대한 핸들러가 등록 된 경우 예외 인스턴스와 함께 보다 구체적인 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ConnectionRefusedError&quot;&gt; &lt;code&gt;ConnectionRefusedError&lt;/code&gt; &lt;/a&gt; 핸들러가 호출되어 응답을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c57a9c603517bcff04062afdd1207b6e304607bb" translate="yes" xml:space="preserve">
          <source>For example, in HTML4 &lt;code&gt;&amp;lt;title/Hello/&lt;/code&gt; theoretically parses exactly the same as &lt;code&gt;&amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt;&lt;/code&gt;. However, since people were using XHTML-like tags along the lines of &lt;code&gt;&amp;lt;link /&amp;gt;&lt;/code&gt;, browser vendors implemented the XHTML syntax over the syntax defined by the specification.</source>
          <target state="translated">예를 들어 HTML4에서 &lt;code&gt;&amp;lt;title/Hello/&lt;/code&gt; 이론적으로 &lt;code&gt;&amp;lt;title&amp;gt;Hello&amp;lt;/title&amp;gt;&lt;/code&gt; 과 정확히 동일하게 구문 분석합니다 . 그러나 사람들이 &lt;code&gt;&amp;lt;link /&amp;gt;&lt;/code&gt; 행을 따라 XHTML과 유사한 태그를 사용했기 때문에 브라우저 공급 업체는 사양에 정의 된 구문에 XHTML 구문을 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="5f7f169d696bd4859c7d62722e255e130a0d58b2" translate="yes" xml:space="preserve">
          <source>For example, this can be used to open a database connection, or to load the logged in user from the session.</source>
          <target state="translated">예를 들어, 데이터베이스 연결을 열거 나 세션에서 로그인 한 사용자를로드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b93ac1384be7b98f164f6c81fd59de15e924427b" translate="yes" xml:space="preserve">
          <source>For example, to support arbitrary iterators, you could implement default like this:</source>
          <target state="translated">예를 들어 임의의 반복자를 지원하려면 다음과 같이 기본값을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d940741039c1f345d0ac522ca3b87bf2df00afd6" translate="yes" xml:space="preserve">
          <source>For example, you can manage a database connection using this pattern:</source>
          <target state="translated">예를 들어 다음 패턴을 사용하여 데이터베이스 연결을 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2912df1f1980f249ef7de59b3463e780b0784332" translate="yes" xml:space="preserve">
          <source>For example, you may want to override how request parameters are handled to preserve their order:</source>
          <target state="translated">예를 들어, 순서를 유지하기 위해 요청 매개 변수가 처리되는 방식을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="debb0beb540a42cd537f85fd337ef30b9b6414a7" translate="yes" xml:space="preserve">
          <source>For information as of why this is useful see &lt;a href=&quot;../cli/index#custom-scripts&quot;&gt;Custom Scripts&lt;/a&gt;.</source>
          <target state="translated">이것이 유용한 이유에 대한 정보는 &lt;a href=&quot;../cli/index#custom-scripts&quot;&gt;사용자 정의 스크립트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39f6b25f27aa04f48e67acdfcca4a18c3ff242a7" translate="yes" xml:space="preserve">
          <source>For information on how to use the request context from the interactive Python shell, see &lt;a href=&quot;../shell/index&quot;&gt;Working with the Shell&lt;/a&gt;.</source>
          <target state="translated">대화 형 Python 셸에서 요청 컨텍스트를 사용하는 방법에 대한 자세한 내용 &lt;a href=&quot;../shell/index&quot;&gt;은 셸 작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3461ff5d08944821a6fef08ed0b1e78007fae30f" translate="yes" xml:space="preserve">
          <source>For instance you can place this in a &lt;code&gt;tasks&lt;/code&gt; module. While you can use Celery without any reconfiguration with Flask, it becomes a bit nicer by subclassing tasks and adding support for Flask&amp;rsquo;s application contexts and hooking it up with the Flask configuration.</source>
          <target state="translated">예를 들어 &lt;code&gt;tasks&lt;/code&gt; 모듈 에 배치 할 수 있습니다 . Flask를 사용하여 재구성하지 않고도 Celery를 사용할 수 있지만 작업을 서브 클래 싱하고 Flask의 애플리케이션 컨텍스트에 대한 지원을 추가하고 Flask 구성과 연결하면 조금 더 멋지게됩니다.</target>
        </trans-unit>
        <trans-unit id="65a34159c97111fe467f921c0acffc6bf00f7353" translate="yes" xml:space="preserve">
          <source>For internal usage the view functions can have some attributes attached to customize behavior the view function would normally not have control over. The following attributes can be provided optionally to either override some defaults to &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; or general behavior:</source>
          <target state="translated">내부 사용을 위해보기 함수는 일반적으로보기 함수가 제어 할 수없는 동작을 사용자 정의하기 위해 일부 속성을 첨부 할 수 있습니다. &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt; 일부 기본값을 재정의 하거나 일반 동작 을 재정의하기 위해 다음 속성을 선택적으로 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bb89b8293a721e777316826fb9dd84ef29a3d7a" translate="yes" xml:space="preserve">
          <source>For many web applications the complexity of the code is less an issue than the scaling for the number of users or data entries expected. Flask by itself is only limited in terms of scaling by your application code, the data store you want to use and the Python implementation and webserver you are running on.</source>
          <target state="translated">많은 웹 애플리케이션의 경우 코드의 복잡성은 예상되는 사용자 수 또는 데이터 항목 수를 확장하는 것보다 문제가 적습니다. Flask 자체는 응용 프로그램 코드, 사용하려는 데이터 저장소, 실행중인 Python 구현 및 웹 서버에 의한 확장 측면에서만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c75b1524eea5e1c8ad9554a46a18aaa9f95b4603" translate="yes" xml:space="preserve">
          <source>For more information about SQLAlchemy, head over to the &lt;a href=&quot;https://www.sqlalchemy.org/&quot;&gt;website&lt;/a&gt;.</source>
          <target state="translated">SQLAlchemy에 대한 자세한 내용은 &lt;a href=&quot;https://www.sqlalchemy.org/&quot;&gt;웹 사이트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6910140027c454811ffe6c060e59b7c75ca9740" translate="yes" xml:space="preserve">
          <source>For more information about WTForms, head over to the &lt;a href=&quot;https://wtforms.readthedocs.io/&quot;&gt;WTForms website&lt;/a&gt;.</source>
          <target state="translated">WTForms에 대한 자세한 내용은 &lt;a href=&quot;https://wtforms.readthedocs.io/&quot;&gt;WTForms 웹 사이트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26c676cfe1bf09eefe3c640fa7269c515aa994c1" translate="yes" xml:space="preserve">
          <source>For more information about resource loading, see &lt;a href=&quot;#flask.Flask.open_resource&quot;&gt;&lt;code&gt;open_resource()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리소스 로딩에 대한 자세한 내용은 &lt;a href=&quot;#flask.Flask.open_resource&quot;&gt; &lt;code&gt;open_resource()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d7c61701522358cd62c289e983d48bc5ce0e73d" translate="yes" xml:space="preserve">
          <source>For more information consult the &lt;a href=&quot;https://modwsgi.readthedocs.io/en/develop/index.html&quot;&gt;mod_wsgi documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://modwsgi.readthedocs.io/en/develop/index.html&quot;&gt;mod_wsgi 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d497fb9a32dd07e38cff498dc23f3a5b9b6e151b" translate="yes" xml:space="preserve">
          <source>For more information consult the documentation of your webserver.</source>
          <target state="translated">자세한 내용은 웹 서버 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="65fc5cd0329a15e669f40a6314f74a4894796e31" translate="yes" xml:space="preserve">
          <source>For more information refer to &lt;a href=&quot;#url-route-registrations&quot;&gt;URL Route Registrations&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#url-route-registrations&quot;&gt;URL 경로 등록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e4242a17f6168eff05e582324129bcb3c3609fc" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;../cli/index#cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../cli/index#cli&quot;&gt;명령 줄 인터페이스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96ffa420aafd2b0a1da48fb8d118ed5184307e18" translate="yes" xml:space="preserve">
          <source>For more information, head over to the &lt;a href=&quot;../quickstart/index#url-building&quot;&gt;Quickstart&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../quickstart/index#url-building&quot;&gt;빠른 시작을 참조하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b238a8f8ecb3cfeee721d10a79e12c784d251cd9" translate="yes" xml:space="preserve">
          <source>For more on Flask extensions, have a look at &lt;a href=&quot;../extensions/index#extensions&quot;&gt;Extensions&lt;/a&gt;.</source>
          <target state="translated">Flask 확장에 대한 자세한 내용은 &lt;a href=&quot;../extensions/index#extensions&quot;&gt;Extensions를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08ccc04f4b09e557203832e162c4316053df6c3d" translate="yes" xml:space="preserve">
          <source>For most applications the following file should be sufficient:</source>
          <target state="translated">대부분의 응용 프로그램의 경우 다음 파일이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="2f219ada346b45d8c7667a14341443f29fecbadd" translate="yes" xml:space="preserve">
          <source>For most applications, it is undoubtedly better to use HTML5 than XHTML.</source>
          <target state="translated">대부분의 응용 프로그램에서는 의심 할 여지없이 XHTML보다 HTML5를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6cdd55ddc74118dd549ad90538568333e1aa5764" translate="yes" xml:space="preserve">
          <source>For some better examples, checkout the &lt;a href=&quot;../patterns/fileuploads/index#uploading-files&quot;&gt;Uploading Files&lt;/a&gt; pattern.</source>
          <target state="translated">더 나은 예를 보려면 &lt;a href=&quot;../patterns/fileuploads/index#uploading-files&quot;&gt;파일 업로드&lt;/a&gt; 패턴을 확인하세요.</target>
        </trans-unit>
        <trans-unit id="c3a85b2f0b6d32788dc4f65977fe3d87b39f063e" translate="yes" xml:space="preserve">
          <source>For static files, the path can be absolute or relative to the blueprint resource folder.</source>
          <target state="translated">정적 파일의 경우 경로는 Blueprint 리소스 폴더에 대해 절대적이거나 상대적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e34ba096e84b49ede4d12557b7a4c2049b6e00fa" translate="yes" xml:space="preserve">
          <source>For templates you can use the full power of Jinja2 templates. Head over to the official &lt;a href=&quot;http://jinja.pocoo.org/docs/templates/&quot;&gt;Jinja2 Template Documentation&lt;/a&gt; for more information.</source>
          <target state="translated">템플릿의 경우 Jinja2 템플릿의 모든 기능을 사용할 수 있습니다. 자세한 내용 은 공식 &lt;a href=&quot;http://jinja.pocoo.org/docs/templates/&quot;&gt;Jinja2 템플릿 문서&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="dbe64a41a97c60888d18be39d069e4ea5673c865" translate="yes" xml:space="preserve">
          <source>For that, just add the following directive to your &lt;code&gt;Directory&lt;/code&gt; section:</source>
          <target state="translated">이를 위해 &lt;code&gt;Directory&lt;/code&gt; 섹션에 다음 지시문을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="5fdeec8470e6f1d3534ca076d60cc8dd75706b10" translate="yes" xml:space="preserve">
          <source>For the latter, this is where &lt;a href=&quot;../../api/index#flask.Flask.url_defaults&quot;&gt;&lt;code&gt;url_defaults()&lt;/code&gt;&lt;/a&gt; functions come in. They can automatically inject values into a call to &lt;a href=&quot;../../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt;. The code below checks if the language code is not yet in the dictionary of URL values and if the endpoint wants a value named &lt;code&gt;'lang_code'&lt;/code&gt;:</source>
          <target state="translated">후자의 경우 &lt;a href=&quot;../../api/index#flask.Flask.url_defaults&quot;&gt; &lt;code&gt;url_defaults()&lt;/code&gt; &lt;/a&gt; 함수가 들어오는 곳입니다. &lt;a href=&quot;../../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt; 호출에 값을 자동으로 주입 할 수 있습니다 . 아래 코드는 언어 코드가 URL 값 사전에 아직 없는지와 엔드 포인트가 &lt;code&gt;'lang_code'&lt;/code&gt; 라는 값을 원하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="4010a72b1d3a75f8c224867c7f05a4021176a527" translate="yes" xml:space="preserve">
          <source>For the session cookie, if &lt;a href=&quot;../api/index#flask.session.permanent&quot;&gt;&lt;code&gt;session.permanent&lt;/code&gt;&lt;/a&gt; is set, then &lt;a href=&quot;../config/index#PERMANENT_SESSION_LIFETIME&quot;&gt;&lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt;&lt;/a&gt; is used to set the expiration. Flask&amp;rsquo;s default cookie implementation validates that the cryptographic signature is not older than this value. Lowering this value may help mitigate replay attacks, where intercepted cookies can be sent at a later time.</source>
          <target state="translated">세션 쿠키의 경우 &lt;a href=&quot;../api/index#flask.session.permanent&quot;&gt; &lt;code&gt;session.permanent&lt;/code&gt; &lt;/a&gt; 가 설정되면 &lt;a href=&quot;../config/index#PERMANENT_SESSION_LIFETIME&quot;&gt; &lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt; &lt;/a&gt; 이 만료를 설정하는 데 사용됩니다. Flask의 기본 쿠키 구현은 암호화 서명이이 값보다 오래되지 않았는지 확인합니다. 이 값을 낮추면 나중에 가로채는 쿠키를 보낼 수있는 재생 공격을 완화하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84299e585343bb5542a8f50373462429504abc6a" translate="yes" xml:space="preserve">
          <source>For this also see &lt;a href=&quot;#about-responses&quot;&gt;About Responses&lt;/a&gt;.</source>
          <target state="translated">이에 대해서는 &lt;a href=&quot;#about-responses&quot;&gt;응답 정보&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c59322c251a8060f91dbda9fc8d3fd2ab7ca665" translate="yes" xml:space="preserve">
          <source>For usage examples, read the &lt;a href=&quot;https://docs.python.org/3/library/json.html#module-json&quot;&gt;&lt;code&gt;json&lt;/code&gt;&lt;/a&gt; documentation in the standard library. The following extensions are by default applied to the stdlib&amp;rsquo;s JSON module:</source>
          <target state="translated">사용 예 는 표준 라이브러리 의 &lt;a href=&quot;https://docs.python.org/3/library/json.html#module-json&quot;&gt; &lt;code&gt;json&lt;/code&gt; &lt;/a&gt; 문서를 참조하세요. 다음 확장은 기본적으로 stdlib의 JSON 모듈에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="22aad63bbc23b36e8396af95652e151b02aca08d" translate="yes" xml:space="preserve">
          <source>For web applications it&amp;rsquo;s crucial to react to the data a client sends to the server. In Flask this information is provided by the global &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:</source>
          <target state="translated">웹 애플리케이션의 경우 클라이언트가 서버에 보내는 데이터에 반응하는 것이 중요합니다. Flask에서이 정보는 전역 &lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 객체에 의해 제공됩니다 . Python에 대한 경험이 있다면 해당 객체가 전역이 될 수있는 방법과 Flask가 여전히 스레드 안전을 유지하도록 관리하는 방법이 궁금 할 것입니다. 대답은 컨텍스트 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="19f942d75513250d44b0876d9d21389c4f0e9e9a" translate="yes" xml:space="preserve">
          <source>Forces the browser to honor the response content type instead of trying to detect it, which can be abused to generate a cross-site scripting (XSS) attack.</source>
          <target state="translated">브라우저가 응답 콘텐츠 유형을 탐지하는 대신이를 준수하도록 강제합니다. 이는 크로스 사이트 스크립팅 (XSS) 공격을 생성하는 데 악용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="cb0f7cde9536262276c8be00c624483687467819" translate="yes" xml:space="preserve">
          <source>Foreword for Experienced Programmers</source>
          <target state="translated">숙련 된 프로그래머를위한 서문</target>
        </trans-unit>
        <trans-unit id="3c4cf50500bc9cf1811c3a459e2c13addbb13630" translate="yes" xml:space="preserve">
          <source>Fork.</source>
          <target state="translated">Fork.</target>
        </trans-unit>
        <trans-unit id="8a397b07290b295ac7cd4c8e3f342c4fdab1857a" translate="yes" xml:space="preserve">
          <source>Form Validation with WTForms</source>
          <target state="translated">WTForms로 양식 유효성 검사</target>
        </trans-unit>
        <trans-unit id="3613274d7a36f2cd58d7183913973cec6bfe359b" translate="yes" xml:space="preserve">
          <source>Forms in Templates</source>
          <target state="translated">템플릿의 양식</target>
        </trans-unit>
        <trans-unit id="5c78b545c79d47fb767247ccd24aa8a68ebc5b9d" translate="yes" xml:space="preserve">
          <source>Fortunately this is however very simple to change by wrapping the input stream.</source>
          <target state="translated">다행히 입력 스트림을 래핑하여 변경하는 것은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="4a0eb9cd9f3f87f33727b5283aad8418862e9fdf" translate="yes" xml:space="preserve">
          <source>From that point onwards there is so much that can be done to make deployment actually fun:</source>
          <target state="translated">그 이후로 배포를 실제로 재미있게 만들기 위해 수행 할 수있는 작업이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="fed970f2b1c40dab4973dc1659618174a74fec91" translate="yes" xml:space="preserve">
          <source>From that point onwards you can work with the request object until you call &lt;code&gt;pop&lt;/code&gt;:</source>
          <target state="translated">이 시점부터 &lt;code&gt;pop&lt;/code&gt; 을 호출 할 때까지 request 객체로 작업 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71167a98b027eb8f37fc94a7b48be4b95f155ca7" translate="yes" xml:space="preserve">
          <source>Full example:</source>
          <target state="translated">전체 예 :</target>
        </trans-unit>
        <trans-unit id="73bc5958e0adc87435e31b0dc3ad501d52e9b354" translate="yes" xml:space="preserve">
          <source>Function used internally to send static files from the static folder to the browser.</source>
          <target state="translated">정적 폴더에서 브라우저로 정적 파일을 보내기 위해 내부적으로 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1fd4ccf95871981ebe5c324a17b16a4de4274ee7" translate="yes" xml:space="preserve">
          <source>Further Improving the Shell Experience</source>
          <target state="translated">셸 경험 향상</target>
        </trans-unit>
        <trans-unit id="0efedf0c6b670e2ce0672f0ef9c217cbf50d893b" translate="yes" xml:space="preserve">
          <source>Furthermore extensions can then easily depend on one template language being present. You can easily use your own templating language, but an extension could still depend on Jinja itself.</source>
          <target state="translated">또한 확장은 존재하는 하나의 템플릿 언어에 쉽게 의존 할 수 있습니다. 자체 템플릿 언어를 쉽게 사용할 수 있지만 확장 기능은 여전히 ​​Jinja 자체에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ec0684ee62f011eaa603defd807f7a55d3fcab" translate="yes" xml:space="preserve">
          <source>Furthermore this design makes it possible to use a factory function to create the application which is very helpful for unit testing and similar things (&lt;a href=&quot;../patterns/appfactories/index#app-factories&quot;&gt;Application Factories&lt;/a&gt;).</source>
          <target state="translated">또한이 디자인은 팩토리 기능을 사용하여 단위 테스트 및 유사 항목 ( &lt;a href=&quot;../patterns/appfactories/index#app-factories&quot;&gt;애플리케이션 팩토리&lt;/a&gt; )에 매우 유용한 애플리케이션을 생성 할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="ef6cd29e26fd057dd9cc7b436f96304533c01d52" translate="yes" xml:space="preserve">
          <source>General Layout</source>
          <target state="translated">일반적인 구조</target>
        </trans-unit>
        <trans-unit id="8ff31423daecd4d40fa050e94b7328135dc12b1c" translate="yes" xml:space="preserve">
          <source>Generally it&amp;rsquo;s recommended that you read the &lt;a href=&quot;../reqcontext/index#request-context&quot;&gt;The Request Context&lt;/a&gt; chapter of the documentation first.</source>
          <target state="translated">일반적으로 문서 의 &lt;a href=&quot;../reqcontext/index#request-context&quot;&gt;The Request Context&lt;/a&gt; 장 을 먼저 읽어 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f38d937b67a517c7b17571b0e3be0e7fe99cac39" translate="yes" xml:space="preserve">
          <source>Generally teardown functions must take every necessary step to avoid that they will fail. If they do execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors.</source>
          <target state="translated">일반적으로 분해 기능은 실패하지 않도록 필요한 모든 단계를 수행해야합니다. 실패 할 수있는 코드를 실행하는 경우 이러한 코드 실행을 try / except 문으로 둘러싸고 발생하는 오류를 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="9354224b16a6d7a2e49efc11b360a486260b6712" translate="yes" xml:space="preserve">
          <source>Generally there are three ways to define rules for the routing system:</source>
          <target state="translated">일반적으로 라우팅 시스템에 대한 규칙을 정의하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6cd2908be4611e3e9a6d20324a5c5e9ca67465" translate="yes" xml:space="preserve">
          <source>Generates a URL to the given endpoint with the method provided.</source>
          <target state="translated">제공된 메소드를 사용하여 지정된 엔드 포인트에 대한 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="39f70a95cb7fa697ccd66951ba49c23b8169a6e4" translate="yes" xml:space="preserve">
          <source>Generating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the &lt;a href=&quot;http://jinja.pocoo.org/&quot;&gt;Jinja2&lt;/a&gt; template engine for you automatically.</source>
          <target state="translated">Python 내에서 HTML을 생성하는 것은 재미가 없으며 실제로는 애플리케이션 보안을 유지하기 위해 HTML 이스케이프를 직접 수행해야하기 때문에 매우 번거 롭습니다. 그 때문에 Flask는 자동으로 &lt;a href=&quot;http://jinja.pocoo.org/&quot;&gt;Jinja2&lt;/a&gt; 템플릿 엔진을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="8c2091cd919c6e15679a9de0df2481c15b476786" translate="yes" xml:space="preserve">
          <source>Generic Exception Handlers</source>
          <target state="translated">일반 예외 처리기</target>
        </trans-unit>
        <trans-unit id="526063035f490202532da79b4a74a58bc766ab80" translate="yes" xml:space="preserve">
          <source>Get an attribute by name, or a default value. Like &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt;&lt;code&gt;dict.get()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름 또는 기본값으로 속성을 가져옵니다. &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt; &lt;code&gt;dict.get()&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="120b79df9ef6109443e1f90eb2263e43de92e19f" translate="yes" xml:space="preserve">
          <source>Get and remove an attribute by name. Like &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.pop&quot;&gt;&lt;code&gt;dict.pop()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름으로 속성을 가져오고 제거합니다. &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.pop&quot;&gt; &lt;code&gt;dict.pop()&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b094ad795c8dbb684d0c2fc284e1cb6c61154fa1" translate="yes" xml:space="preserve">
          <source>Get the value of an attribute if it is present, otherwise set and return a default value. Like &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt;&lt;code&gt;dict.setdefault()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이있는 경우 속성 값을 가져오고, 그렇지 않으면 기본값을 설정하고 반환합니다. &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.setdefault&quot;&gt; &lt;code&gt;dict.setdefault()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8639e1e9acc423435c672ae34940c40ad6cd364d" translate="yes" xml:space="preserve">
          <source>Getting started with Sentry</source>
          <target state="translated">Sentry 시작하기</target>
        </trans-unit>
        <trans-unit id="e2944f09961f5a9ae869464e9228417549ec03a6" translate="yes" xml:space="preserve">
          <source>Getting the most out of WTForms with an Extension</source>
          <target state="translated">확장 기능으로 WTForms 최대한 활용하기</target>
        </trans-unit>
        <trans-unit id="17c6bf64bf960c6bdea9f0d103dff20d00bac154" translate="yes" xml:space="preserve">
          <source>Gevent</source>
          <target state="translated">Gevent</target>
        </trans-unit>
        <trans-unit id="3e7aaadc138b974d13e7102c656b91b34e978b7f" translate="yes" xml:space="preserve">
          <source>Given a context and a command name, this returns a &lt;code&gt;Command&lt;/code&gt; object if it exists or returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">컨텍스트와 명령 이름이 주어지면 &lt;code&gt;Command&lt;/code&gt; 객체가 있으면 반환하거나 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a83b225228b4c85eecbf276fcc574bd26c6627b4" translate="yes" xml:space="preserve">
          <source>Given a flask application in myapp.py, use the following command:</source>
          <target state="translated">myapp.py의 플라스크 애플리케이션이 주어지면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cf37cba8ba1e2ac4ef8c0aa3c1e79f1ab39f8ab3" translate="yes" xml:space="preserve">
          <source>Gives a list of all users</source>
          <target state="translated">모든 사용자의 목록을 제공합니다</target>
        </trans-unit>
        <trans-unit id="0fe742f573d5b23041106b5bc954af4a6ac13614" translate="yes" xml:space="preserve">
          <source>Go to &lt;em&gt;Settings -&amp;gt; Preferences &amp;hellip;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;설정-&amp;gt; 환경 설정&amp;hellip;으로&lt;/em&gt; 이동합니다 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="74b73c5dad39ae6ea01d5c58570191b64a2e6ad0" translate="yes" xml:space="preserve">
          <source>Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it next request and only next request. This is usually combined with a layout template that does this. Note that browsers and sometimes web servers enforce a limit on cookie sizes. This means that flashing messages that are too large for session cookies causes message flashing to fail silently.</source>
          <target state="translated">좋은 애플리케이션과 사용자 인터페이스는 모두 피드백에 관한 것입니다. 사용자가 충분한 피드백을받지 못하면 응용 프로그램을 싫어하게 될 것입니다. Flask는 플래싱 시스템을 사용하여 사용자에게 피드백을 제공하는 매우 간단한 방법을 제공합니다. 플래싱 시스템은 기본적으로 요청이 끝날 때 메시지를 기록하고 다음 요청과 다음 요청에만 액세스 할 수 있도록합니다. 일반적으로이를 수행하는 레이아웃 템플릿과 결합됩니다. 브라우저와 때때로 웹 서버는 쿠키 크기에 제한을 적용합니다. 이는 세션 쿠키에 비해 너무 큰 플래싱 메시지로 인해 메시지 플래싱이 자동으로 실패 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="89fa02cb05a5f5ba6570ea3afbb4e2b0516a34ac" translate="yes" xml:space="preserve">
          <source>Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it on the next (and only the next) request. This is usually combined with a layout template to expose the message.</source>
          <target state="translated">좋은 애플리케이션과 사용자 인터페이스는 모두 피드백에 관한 것입니다. 사용자가 충분한 피드백을받지 못하면 응용 프로그램을 싫어하게 될 것입니다. Flask는 플래싱 시스템을 사용하여 사용자에게 피드백을 제공하는 매우 간단한 방법을 제공합니다. 플래싱 시스템은 기본적으로 요청이 끝날 때 메시지를 기록하고 다음 요청 (그리고 다음 요청에만)에 액세스 할 수 있도록합니다. 이것은 일반적으로 메시지를 노출하기 위해 레이아웃 템플릿과 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="919642530da33bfbe2717d85dea4c123b2751556" translate="yes" xml:space="preserve">
          <source>Growing with Flask</source>
          <target state="translated">플라스크로 성장</target>
        </trans-unit>
        <trans-unit id="fd93c7d855d6c7d32aa7b74fbe15c55de7127ff7" translate="yes" xml:space="preserve">
          <source>Gunicorn</source>
          <target state="translated">Gunicorn</target>
        </trans-unit>
        <trans-unit id="bfc70d716210500886f45bba07e350857dc0128c" translate="yes" xml:space="preserve">
          <source>HTML versus XHTML</source>
          <target state="translated">HTML 대 XHTML</target>
        </trans-unit>
        <trans-unit id="5fa4afad6bbd90302287a6340127a9d9b97a655c" translate="yes" xml:space="preserve">
          <source>HTML/XHTML FAQ</source>
          <target state="translated">HTML/XHTML FAQ</target>
        </trans-unit>
        <trans-unit id="43b487b9b6125c8580298b1c314887147fe68454" translate="yes" xml:space="preserve">
          <source>HTML4.01</source>
          <target state="translated">HTML4.01</target>
        </trans-unit>
        <trans-unit id="93444192491e31ec8001fcf32b5ec8e7a3030b8d" translate="yes" xml:space="preserve">
          <source>HTML5</source>
          <target state="translated">HTML5</target>
        </trans-unit>
        <trans-unit id="19feb5fc01dd877ff77844a63bc933293caf9569" translate="yes" xml:space="preserve">
          <source>HTML5 adds many new features that make Web applications easier to write and to use.</source>
          <target state="translated">HTML5는 웹 애플리케이션을보다 쉽게 ​​작성하고 사용할 수 있도록하는 많은 새로운 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c52421ce541d2c1191bd95481f86bf0c9f651e55" translate="yes" xml:space="preserve">
          <source>HTML5 adds several new features, including semantic tags and the long-awaited &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; tags.</source>
          <target state="translated">HTML5는 시맨틱 태그와 오랫동안 기다려온 &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 태그를 포함하여 몇 가지 새로운 기능을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="0a76f6c58d67e6163bc15f64fe7e33b9c9c20852" translate="yes" xml:space="preserve">
          <source>HTML5 has strictly defined parsing rules, but it also specifies exactly how a browser should react to parsing errors - unlike XHTML, which simply states parsing should abort. Some people are confused by apparently invalid syntax that still generates the expected results (for example, missing end tags or unquoted attribute values).</source>
          <target state="translated">HTML5에는 엄격하게 정의 된 구문 분석 규칙이 있지만 단순히 구문 분석을 중단해야한다고 명시하는 XHTML과 달리 브라우저가 구문 분석 오류에 어떻게 반응해야하는지 정확히 지정합니다. 어떤 사람들은 여전히 ​​예상되는 결과를 생성하는 명백하게 잘못된 구문 (예 : 누락 된 끝 태그 또는 인용되지 않은 속성 값)으로 인해 혼란스러워합니다.</target>
        </trans-unit>
        <trans-unit id="0d0e89ab8fb5de0b2f0ce37c01d8fe6ac1289b49" translate="yes" xml:space="preserve">
          <source>HTTP Methods</source>
          <target state="translated">HTTP 방법</target>
        </trans-unit>
        <trans-unit id="a59d4db939b632ce4c9f5a7a491b7acc6640bc88" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning (HPKP)</source>
          <target state="translated">HTTP 공개 키 고정 (HPKP)</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HSTS (HTTP Strict Transport Security)</target>
        </trans-unit>
        <trans-unit id="992a4a00b73bdef8e3e7db8dd2b16508514a7e0b" translate="yes" xml:space="preserve">
          <source>HTTP is based on bytes. Not only the protocol, also the system used to address documents on servers (so called URIs or URLs). However HTML which is usually transmitted on top of HTTP supports a large variety of character sets and which ones are used, are transmitted in an HTTP header. To not make this too complex Flask just assumes that if you are sending Unicode out you want it to be UTF-8 encoded. Flask will do the encoding and setting of the appropriate headers for you.</source>
          <target state="translated">HTTP는 바이트를 기반으로합니다. 프로토콜뿐만 아니라 서버에서 문서 주소를 지정하는 데 사용되는 시스템 (URI 또는 ​​URL이라고 함). 그러나 일반적으로 HTTP 위에서 전송되는 HTML은 다양한 문자 집합을 지원하며 사용되는 문자 집합은 HTTP 헤더로 전송됩니다. 이것을 너무 복잡하게 만들지 않기 위해 Flask는 유니 코드를 보내는 경우 UTF-8 인코딩을 원한다고 가정합니다. Flask는 적절한 헤더의 인코딩 및 설정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1dac7187341f9512582cd474dd42779d77be2bf7" translate="yes" xml:space="preserve">
          <source>Handle &lt;code&gt;BuildError&lt;/code&gt; on &lt;a href=&quot;#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">처리 &lt;code&gt;BuildError&lt;/code&gt; 을 에 &lt;a href=&quot;#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7484d7a15d53a01b0a6d16fba0b55fc292df89fa" translate="yes" xml:space="preserve">
          <source>Handle an exception that did not have an error handler associated with it, or that was raised from an error handler. This always causes a 500 &lt;code&gt;InternalServerError&lt;/code&gt;.</source>
          <target state="translated">연관된 오류 핸들러가 없거나 오류 핸들러에서 발생한 예외를 처리합니다. 이로 인해 항상 500 &lt;code&gt;InternalServerError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="72aebc3492e54170f8f60570483b96dcf23d1895" translate="yes" xml:space="preserve">
          <source>Handlers can be registered for any exception class, not just &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt;&lt;code&gt;HTTPException&lt;/code&gt;&lt;/a&gt; subclasses or HTTP status codes. Handlers can be registered for a specific class, or for all subclasses of a parent class.</source>
          <target state="translated">핸들러는 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt; &lt;code&gt;HTTPException&lt;/code&gt; &lt;/a&gt; 하위 클래스 또는 HTTP 상태 코드 뿐만 아니라 모든 예외 클래스에 대해 등록 할 수 있습니다 . 핸들러는 특정 클래스 또는 상위 클래스의 모든 하위 클래스에 대해 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ccefdb1c2c25390b19193b3c2d639cc2d6c7d6" translate="yes" xml:space="preserve">
          <source>Handlers registered on the blueprint take precedence over those registered globally on the application, assuming a blueprint is handling the request that raises the exception. However, the blueprint cannot handle 404 routing errors because the 404 occurs at the routing level before the blueprint can be determined.</source>
          <target state="translated">Blueprint에 등록 된 핸들러는 Blueprint가 예외를 발생시키는 요청을 처리한다고 가정 할 때 애플리케이션에 전역 적으로 등록 된 핸들러보다 우선합니다. 그러나 청사진이 결정되기 전에 라우팅 수준에서 404가 발생하기 때문에 청사진은 404 라우팅 오류를 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="5ba7685be3dc2228d202d7e0ceaea35806d9b5c9" translate="yes" xml:space="preserve">
          <source>Handles an HTTP exception. By default this will invoke the registered error handlers and fall back to returning the exception as response.</source>
          <target state="translated">HTTP 예외를 처리합니다. 기본적으로 이것은 등록 된 오류 처리기를 호출하고 예외를 응답으로 반환하도록 대체합니다.</target>
        </trans-unit>
        <trans-unit id="6c94476426e33912a7b4edacba6d1ed36bc700b6" translate="yes" xml:space="preserve">
          <source>Handling</source>
          <target state="translated">Handling</target>
        </trans-unit>
        <trans-unit id="d7e16c110185aed367037ee568f9aee84e279921" translate="yes" xml:space="preserve">
          <source>Have another debugger in mind? See &lt;a href=&quot;../errorhandling/index#working-with-debuggers&quot;&gt;Working with Debuggers&lt;/a&gt;.</source>
          <target state="translated">다른 디버거를 염두에두고 계십니까? &lt;a href=&quot;../errorhandling/index#working-with-debuggers&quot;&gt;디버거 작업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c1ee18c5b18313ce44c099aad0c4280f97e871a" translate="yes" xml:space="preserve">
          <source>Helper object to deal with Flask applications. This is usually not necessary to interface with as it&amp;rsquo;s used internally in the dispatching to click. In future versions of Flask this object will most likely play a bigger role. Typically it&amp;rsquo;s created automatically by the &lt;a href=&quot;#flask.cli.FlaskGroup&quot;&gt;&lt;code&gt;FlaskGroup&lt;/code&gt;&lt;/a&gt; but you can also manually create it and pass it onwards as click object.</source>
          <target state="translated">Flask 응용 프로그램을 처리하기위한 도우미 개체입니다. 클릭을위한 디스패치에서 내부적으로 사용되므로 일반적으로 인터페이스에 필요하지 않습니다. Flask의 향후 버전에서는이 개체가 더 큰 역할을 할 가능성이 높습니다. 일반적으로 &lt;a href=&quot;#flask.cli.FlaskGroup&quot;&gt; &lt;code&gt;FlaskGroup&lt;/code&gt; 에&lt;/a&gt; 의해 자동 으로 생성되지만 수동으로 생성하여 클릭 객체로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b00d5d42c3560a2c22733bc27cb6a6cb21211f1b" translate="yes" xml:space="preserve">
          <source>Here are some example log calls:</source>
          <target state="translated">다음은 로그 호출의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="96c0087be117090683f18bca7d084ad0ae2a6eee" translate="yes" xml:space="preserve">
          <source>Here are the parameters that &lt;a href=&quot;#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; accept. The only difference is that with the route parameter the view function is defined with the decorator instead of the &lt;code&gt;view_func&lt;/code&gt; parameter.</source>
          <target state="translated">다음은 &lt;a href=&quot;#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt; 허용 하는 매개 변수입니다 . 유일한 차이점은 route 매개 변수를 사용하면 &lt;code&gt;view_func&lt;/code&gt; 매개 변수 대신 데코레이터로보기 함수가 정의 된다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="59664846ffb98a6ebf28d906800702b7fce75a4d" translate="yes" xml:space="preserve">
          <source>Here are your options when growing your codebase or scaling your application.</source>
          <target state="translated">다음은 코드베이스를 확장하거나 애플리케이션을 확장 할 때 선택할 수있는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="bab08bb257fccab09b6805f507628b74a8ed9dde" translate="yes" xml:space="preserve">
          <source>Here is a basic introduction to how the &lt;code&gt;Markup&lt;/code&gt; class works:</source>
          <target state="translated">다음은 &lt;code&gt;Markup&lt;/code&gt; 클래스의 작동 방식에 대한 기본 소개입니다 .</target>
        </trans-unit>
        <trans-unit id="529a82251514d911561ecf0af9c012e76bc3ef3c" translate="yes" xml:space="preserve">
          <source>Here is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists:</source>
          <target state="translated">다음은 모듈에서 구성을 미리로드 한 다음 존재하는 경우 인스턴스 폴더의 파일에서 구성을 재정의하도록 Flask를 구성하는 방법의 전체 예입니다.</target>
        </trans-unit>
        <trans-unit id="01abff76f19ffcb24a01ff8f4d19b0b3563991d7" translate="yes" xml:space="preserve">
          <source>Here is a simple example of how you can use SQLite 3 with Flask:</source>
          <target state="translated">다음은 Flask와 함께 SQLite 3를 사용하는 방법에 대한 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="7979c3c7d1fc4a7c69d0b22aa1f8ba37eac0aebd" translate="yes" xml:space="preserve">
          <source>Here is an example &lt;code&gt;database.py&lt;/code&gt; module for your application:</source>
          <target state="translated">다음은 애플리케이션에 대한 &lt;code&gt;database.py&lt;/code&gt; 모듈 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f96a9a39915c888332d35f65052b0d9119707f4b" translate="yes" xml:space="preserve">
          <source>Here is an example cache function. It generates the cache key from a specific prefix (actually a format string) and the current path of the request. Notice that we are using a function that first creates the decorator that then decorates the function. Sounds awful? Unfortunately it is a little bit more complex, but the code should still be straightforward to read.</source>
          <target state="translated">다음은 캐시 기능의 예입니다. 특정 접두사 (실제로는 형식 문자열)와 요청의 현재 경로에서 캐시 키를 생성합니다. 먼저 데코레이터를 생성 한 다음 그 함수를 데코 레이팅하는 함수를 사용하고 있습니다. 끔찍하게 들리나요? 불행히도 조금 더 복잡하지만 코드는 여전히 읽기가 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2b632cce10c358638a82ddcdc218d628c926834" translate="yes" xml:space="preserve">
          <source>Here is an example for a &amp;ldquo;404 Page Not Found&amp;rdquo; exception:</source>
          <target state="translated">다음은 &quot;404 페이지를 찾을 수 없음&quot;예외의 예입니다.</target>
        </trans-unit>
        <trans-unit id="66a2a5114052bdd62573ad7f12e3421e7731b791" translate="yes" xml:space="preserve">
          <source>Here is an example implementation for a &amp;ldquo;404 Page Not Found&amp;rdquo; exception:</source>
          <target state="translated">다음은 &quot;404 페이지를 찾을 수 없음&quot;예외에 대한 구현의 예입니다.</target>
        </trans-unit>
        <trans-unit id="196dd282fd3a943f29215eaedc5157da8662a4b9" translate="yes" xml:space="preserve">
          <source>Here is an example model (put this into &lt;code&gt;models.py&lt;/code&gt;, e.g.):</source>
          <target state="translated">다음은 예제 모델입니다 ( 예 : &lt;code&gt;models.py&lt;/code&gt; 에 넣습니다 ).</target>
        </trans-unit>
        <trans-unit id="12a6e5bd799454c7817a77c01df02472eeb88521" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration file that uses environment variables:</source>
          <target state="translated">다음은 환경 변수를 사용하는 구성 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="32c4c2cffde17e8b9e6a384d41aac062af362f49" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration file:</source>
          <target state="translated">다음은 구성 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="bf05454ee73b985b8236fc836f9ab575e6b25ad3" translate="yes" xml:space="preserve">
          <source>Here is an example table and model (put this into &lt;code&gt;models.py&lt;/code&gt;):</source>
          <target state="translated">다음은 테이블 및 모델의 예입니다 ( &lt;code&gt;models.py&lt;/code&gt; 에 입력 ).</target>
        </trans-unit>
        <trans-unit id="5fd5f5ad67d5ede190a7c0ff2b35f76abf6fea94" translate="yes" xml:space="preserve">
          <source>Here is an example template:</source>
          <target state="translated">다음은 예제 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="fc86141138a2bca4d4a2877158dc19f60644960a" translate="yes" xml:space="preserve">
          <source>Here is how a view can use that functionality:</source>
          <target state="translated">뷰가 해당 기능을 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8280b6dab7e95d9198a58ecf112e27e66b640e9" translate="yes" xml:space="preserve">
          <source>Here is how you can use it:</source>
          <target state="translated">사용 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ee9c897f2be37bca8313318b413a0a0aacba622" translate="yes" xml:space="preserve">
          <source>Here is the &lt;code&gt;index.html&lt;/code&gt; template which inherits from &lt;code&gt;layout.html&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;layout.html&lt;/code&gt; 에서 상속 된 &lt;code&gt;index.html&lt;/code&gt; 템플릿입니다 .</target>
        </trans-unit>
        <trans-unit id="e2b08feac2a1913b4494e4928964c1e934ae725d" translate="yes" xml:space="preserve">
          <source>Here is the &lt;code&gt;register.html&lt;/code&gt; template for the function we used above, which takes advantage of the &lt;code&gt;_formhelpers.html&lt;/code&gt; template:</source>
          <target state="translated">여기서이다 &lt;code&gt;register.html&lt;/code&gt; 에서 의 활용 위에서 사용 된 함수에 대한 템플릿 &lt;code&gt;_formhelpers.html&lt;/code&gt; 의 서식 :</target>
        </trans-unit>
        <trans-unit id="f4250cbaf6a70f66c3d3b3a261b5a74f3ee76610" translate="yes" xml:space="preserve">
          <source>Here is the code for that decorator:</source>
          <target state="translated">해당 데코레이터의 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f1b1ce18b30b0e28019aaade27d4e6d5b79581c" translate="yes" xml:space="preserve">
          <source>Here the code:</source>
          <target state="translated">여기에 코드 :</target>
        </trans-unit>
        <trans-unit id="bad8dad888b16ae9980034e2c75e2c01cc386daf" translate="yes" xml:space="preserve">
          <source>Here we check that HTML is allowed in the text but not in the title, which is the intended behavior.</source>
          <target state="translated">여기서는 HTML이 텍스트에는 허용되지만 제목에는 허용되지 않는지 확인합니다. 이는 의도 된 동작입니다.</target>
        </trans-unit>
        <trans-unit id="37e47e5bd52366016656e0092bd4089c97c1b82d" translate="yes" xml:space="preserve">
          <source>Here we look up the name of a template in the config.</source>
          <target state="translated">여기서 우리는 구성에서 템플릿의 이름을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="28fa75f4bf24f9c7190607285bee12e6152aefcb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple nginx configuration which proxies to an application served on localhost at port 8000, setting appropriate headers:</source>
          <target state="translated">다음은 적절한 헤더를 설정하여 포트 8000의 localhost에서 제공되는 애플리케이션에 프록시하는 간단한 nginx 구성입니다.</target>
        </trans-unit>
        <trans-unit id="266f08ac4ec357edbbcc87c64905df9f885eeaf2" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example &lt;code&gt;__init__.py&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;__init__.py&lt;/code&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="90a3932844aaefc6a3dac93da5198672a940fb3d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example &lt;code&gt;_formhelpers.html&lt;/code&gt; template with such a macro:</source>
          <target state="translated">다음 은 이러한 매크로가 포함 된 &lt;code&gt;_formhelpers.html&lt;/code&gt; 템플릿 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="bffaa03836e9d24c6a3869e87ce2e5bb80a0d23e" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the example &lt;code&gt;database.py&lt;/code&gt; module for your application:</source>
          <target state="translated">다음 은 애플리케이션에 대한 &lt;code&gt;database.py&lt;/code&gt; 모듈 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="fa291d6d0149ef01662436167c1193b57d7c842e" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;error&lt;/code&gt; is the instance of &lt;code&gt;BuildError&lt;/code&gt;, and &lt;code&gt;endpoint&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are the arguments passed into &lt;code&gt;url_for&lt;/code&gt;. Note that this is for building URLs outside the current application, and not for handling 404 NotFound errors.</source>
          <target state="translated">여기서 &lt;code&gt;error&lt;/code&gt; 는 &lt;code&gt;BuildError&lt;/code&gt; 의 인스턴스 이고 &lt;code&gt;endpoint&lt;/code&gt; 과 &lt;code&gt;values&lt;/code&gt; 은 &lt;code&gt;url_for&lt;/code&gt; 에 전달 된 인수 입니다. 이는 현재 애플리케이션 외부에서 URL을 빌드하기위한 것이며 404 NotFound 오류를 처리하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8f2f97a4345749bf27f32e8e24fa74e2a5a75154" translate="yes" xml:space="preserve">
          <source>Hidden characters such as the backspace character (&lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;^H&lt;/code&gt;) can cause text to render differently in HTML than how it is interpreted if &lt;a href=&quot;https://security.stackexchange.com/q/39118&quot;&gt;pasted into a terminal&lt;/a&gt;.</source>
          <target state="translated">백 스페이스 문자 ( &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;^H&lt;/code&gt; ) 와 같은 숨겨진 문자 는 텍스트를 &lt;a href=&quot;https://security.stackexchange.com/q/39118&quot;&gt;터미널에 붙여 넣을&lt;/a&gt; 때 해석되는 방식과 다르게 HTML에서 렌더링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e87157723c34c744feedc125de7ca0448c2c92c2" translate="yes" xml:space="preserve">
          <source>History of HTML5</source>
          <target state="translated">HTML5의 역사</target>
        </trans-unit>
        <trans-unit id="ab32f1070a1d72abbffdd10095567593e0a5e0a2" translate="yes" xml:space="preserve">
          <source>History of XHTML</source>
          <target state="translated">XHTML의 역사</target>
        </trans-unit>
        <trans-unit id="e1993822ab994ac5d511a886b06b5bb38d31f8f7" translate="yes" xml:space="preserve">
          <source>Holds the path to the instance folder.</source>
          <target state="translated">인스턴스 폴더의 경로를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6a9f2ad3318d5023767a1899a377ee407450a192" translate="yes" xml:space="preserve">
          <source>Hook. Extend.</source>
          <target state="translated">훅. 넓히다.</target>
        </trans-unit>
        <trans-unit id="a2f12d7b800cf6cc6fb149d27038b0bbc7451863" translate="yes" xml:space="preserve">
          <source>Hooking in WSGI Middleware</source>
          <target state="translated">WSGI 미들웨어의 후킹</target>
        </trans-unit>
        <trans-unit id="0dc31d2de482d0e2f889d3090aeacf7cc57ed56f" translate="yes" xml:space="preserve">
          <source>Hosted options</source>
          <target state="translated">호스팅 옵션</target>
        </trans-unit>
        <trans-unit id="18a39a6d0f98a72c12a0931758ff6fd73b7da33c" translate="yes" xml:space="preserve">
          <source>How can you prevent that? Basically for each request that modifies content on the server you would have to either use a one-time token and store that in the cookie &lt;strong&gt;and&lt;/strong&gt; also transmit it with the form data. After receiving the data on the server again, you would then have to compare the two tokens and ensure they are equal.</source>
          <target state="translated">어떻게 방지 할 수 있습니까? 기본적으로 각 요청에 대한 서버의 수정 내용은 당신이 중 하나를 사용하여 쿠키에있는 토큰을 한 번 저장해야한다고 &lt;strong&gt;하고&lt;/strong&gt; 도하는 형태의 데이터를 전송합니다. 서버에서 데이터를 다시 수신 한 후 두 토큰을 비교하고 동일한 지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="33c571c2482df1d76606439c867c2a60f80f6a2d" translate="yes" xml:space="preserve">
          <source>How the Context Works</source>
          <target state="translated">컨텍스트 작동 방식</target>
        </trans-unit>
        <trans-unit id="afe184f305cda6085301e61fa0f7567846827e31" translate="yes" xml:space="preserve">
          <source>How to contribute to Flask</source>
          <target state="translated">Flask에 기여하는 방법</target>
        </trans-unit>
        <trans-unit id="de45f6f0a2da8e60eae750338ca57f9ce8c7fe3b" translate="yes" xml:space="preserve">
          <source>How to generate good secret keys</source>
          <target state="translated">좋은 비밀 키를 생성하는 방법</target>
        </trans-unit>
        <trans-unit id="c8648573eb8989aeb828922f9607ff461ba4eaf8" translate="yes" xml:space="preserve">
          <source>However this requires that our server already has the &lt;code&gt;/var/www/yourapplication&lt;/code&gt; folder created and &lt;code&gt;/var/www/yourapplication/env&lt;/code&gt; to be a virtual environment. Furthermore are we not creating the configuration or &lt;code&gt;.wsgi&lt;/code&gt; file on the server. So how do we bootstrap a new server into our infrastructure?</source>
          <target state="translated">그러나이를 위해서는 서버에 이미 생성 된 &lt;code&gt;/var/www/yourapplication&lt;/code&gt; 폴더가 있고 &lt;code&gt;/var/www/yourapplication/env&lt;/code&gt; 가 가상 환경이되어야합니다. 또한 서버에 구성 또는 &lt;code&gt;.wsgi&lt;/code&gt; 파일을 생성하지 않습니다 . 그렇다면 새 서버를 인프라에 어떻게 부트 스트랩합니까?</target>
        </trans-unit>
        <trans-unit id="4e20dc778842f13f42a27f3dc1536160f3b3cb42" translate="yes" xml:space="preserve">
          <source>However, if the blueprint does not have a &lt;code&gt;url_prefix&lt;/code&gt;, it is not possible to access the blueprint&amp;rsquo;s static folder. This is because the URL would be &lt;code&gt;/static&lt;/code&gt; in this case, and the application&amp;rsquo;s &lt;code&gt;/static&lt;/code&gt; route takes precedence. Unlike template folders, blueprint static folders are not searched if the file does not exist in the application static folder.</source>
          <target state="translated">그러나 Blueprint에 &lt;code&gt;url_prefix&lt;/code&gt; 가 없으면 Blueprint의 정적 폴더에 액세스 할 수 없습니다. 이 경우 URL이 &lt;code&gt;/static&lt;/code&gt; 이고 응용 프로그램의 &lt;code&gt;/static&lt;/code&gt; 경로가 우선하기 때문입니다. 템플릿 폴더와 달리 Blueprint 정적 폴더는 파일이 애플리케이션 정적 폴더에없는 경우 검색되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d53d672d6e82f58cd69977da260d6994e5b9fd67" translate="yes" xml:space="preserve">
          <source>I won&amp;rsquo;t go into detail here about how jQuery works, just a very quick explanation of the little bit of code above:</source>
          <target state="translated">여기서는 jQuery의 작동 방식에 대해 자세히 설명하지 않고 위의 코드에 대한 간단한 설명 만하겠습니다.</target>
        </trans-unit>
        <trans-unit id="83c38317c2728b89aa5b994e15204bf11f68863b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#flask.Flask.propagate_exceptions&quot;&gt;&lt;code&gt;propagate_exceptions&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, such as in debug mode, the error will be re-raised so that the debugger can display it. Otherwise, the original exception is logged, and an &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.InternalServerError&quot;&gt;&lt;code&gt;InternalServerError&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">경우 &lt;a href=&quot;#flask.Flask.propagate_exceptions&quot;&gt; &lt;code&gt;propagate_exceptions&lt;/code&gt; 가&lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; 같은 디버그 모드로, 오류가 디버거를 표시 할 수 있도록 제기 재됩니다. 그렇지 않으면 원래 예외가 기록되고 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.InternalServerError&quot;&gt; &lt;code&gt;InternalServerError&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d73563f425afc6cccf62dd18c4caa8095aa2f14d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;None&lt;/code&gt; Flask will call into &lt;a href=&quot;#flask.sessions.SessionInterface.make_null_session&quot;&gt;&lt;code&gt;make_null_session()&lt;/code&gt;&lt;/a&gt; to create a session that acts as replacement if the session support cannot work because some requirement is not fulfilled. The default &lt;a href=&quot;#flask.sessions.NullSession&quot;&gt;&lt;code&gt;NullSession&lt;/code&gt;&lt;/a&gt; class that is created will complain that the secret key was not set.</source>
          <target state="translated">경우 &lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt; 를 반환 &lt;code&gt;None&lt;/code&gt; 영약으로 호출 &lt;a href=&quot;#flask.sessions.SessionInterface.make_null_session&quot;&gt; &lt;code&gt;make_null_session()&lt;/code&gt; &lt;/a&gt; 세션 지원이 몇 가지 요구 사항이 충족되지 아니 작업 할 수 있기 때문에 경우에 대체 역할을하는 세션을 만들 수 있습니다. 생성 된 기본 &lt;a href=&quot;#flask.sessions.NullSession&quot;&gt; &lt;code&gt;NullSession&lt;/code&gt; &lt;/a&gt; 클래스는 비밀 키가 설정되지 않았다고 불평합니다.</target>
        </trans-unit>
        <trans-unit id="1f6ba9d2828ca44174bbd6d652513f2f7151ba16" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../api/index#flask.signals.signals_available&quot;&gt;&lt;code&gt;signals_available&lt;/code&gt;&lt;/a&gt; is true, the following signals are sent:</source>
          <target state="translated">경우 &lt;a href=&quot;../api/index#flask.signals.signals_available&quot;&gt; &lt;code&gt;signals_available&lt;/code&gt; 는&lt;/a&gt; 사실, 다음과 같은 신호가 전송됩니다 :</target>
        </trans-unit>
        <trans-unit id="6435a8fad15f8208e40c19ff587755730cfbad02" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../api/index#flask.signals.signals_available&quot;&gt;&lt;code&gt;signals_available&lt;/code&gt;&lt;/a&gt; is true, the following signals are sent: &lt;a href=&quot;../api/index#flask.appcontext_pushed&quot;&gt;&lt;code&gt;appcontext_pushed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.appcontext_tearing_down&quot;&gt;&lt;code&gt;appcontext_tearing_down&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/index#flask.appcontext_popped&quot;&gt;&lt;code&gt;appcontext_popped&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;../api/index#flask.signals.signals_available&quot;&gt; &lt;code&gt;signals_available&lt;/code&gt; 는&lt;/a&gt; 사실, 다음 신호가 전송됩니다 &lt;a href=&quot;../api/index#flask.appcontext_pushed&quot;&gt; &lt;code&gt;appcontext_pushed&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/index#flask.appcontext_tearing_down&quot;&gt; &lt;code&gt;appcontext_tearing_down&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/index#flask.appcontext_popped&quot;&gt; &lt;code&gt;appcontext_popped&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9379e74c8121313abe8e72a58aaa425e3e5a993" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;python-dotenv&lt;/a&gt; is installed, running the &lt;code&gt;flask&lt;/code&gt; command will set environment variables defined in the files &lt;code&gt;.env&lt;/code&gt; and &lt;code&gt;.flaskenv&lt;/code&gt;. This can be used to avoid having to set &lt;code&gt;FLASK_APP&lt;/code&gt; manually every time you open a new terminal, and to set configuration using environment variables similar to how some deployment services work.</source>
          <target state="translated">경우 &lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;파이썬 dotenv가&lt;/a&gt; 설치되어 실행중인 &lt;code&gt;flask&lt;/code&gt; 명령은 환경 파일에 정의 된 변수를 설정합니다 &lt;code&gt;.env&lt;/code&gt; 의 와 &lt;code&gt;.flaskenv&lt;/code&gt; 을 . 이는 새 터미널을 열 때마다 수동으로 &lt;code&gt;FLASK_APP&lt;/code&gt; 를 설정하지 않고 일부 배포 서비스가 작동하는 방식과 유사한 환경 변수를 사용하여 구성을 설정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8c22e38f2591a439dd091afd294c3c02d99894d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FLASK_APP&lt;/code&gt; is not set, the command will try to import &amp;ldquo;app&amp;rdquo; or &amp;ldquo;wsgi&amp;rdquo; (as a &amp;ldquo;.py&amp;rdquo; file, or package) and try to detect an application instance or factory.</source>
          <target state="translated">&lt;code&gt;FLASK_APP&lt;/code&gt; 가 설정되지 않은 경우 명령은 &quot;app&quot;또는 &quot;wsgi&quot;( &quot;. py&quot;파일 또는 패키지로) 가져 오기를 시도하고 애플리케이션 인스턴스 또는 팩토리 검색을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="77421760d1261f970b1769311a4b8b6cd975de2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GET&lt;/code&gt; is present, Flask automatically adds support for the &lt;code&gt;HEAD&lt;/code&gt; method and handles &lt;code&gt;HEAD&lt;/code&gt; requests according to the &lt;a href=&quot;https://www.ietf.org/rfc/rfc2068.txt&quot;&gt;HTTP RFC&lt;/a&gt;. Likewise, &lt;code&gt;OPTIONS&lt;/code&gt; is automatically implemented for you.</source>
          <target state="translated">경우 &lt;code&gt;GET&lt;/code&gt; 가 존재하고, 플라스크가 자동으로에 대한 지원을 추가 &lt;code&gt;HEAD&lt;/code&gt; 의 방법 및 핸들은 &lt;code&gt;HEAD&lt;/code&gt; 에 따라 요청을 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2068.txt&quot;&gt;HTTP RFC&lt;/a&gt; . 마찬가지로 &lt;code&gt;OPTIONS&lt;/code&gt; 가 자동으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c844f29923da60b3760a49fdfa670a08e7a602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;as_text&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; the return value will be a decoded unicode string.</source>
          <target state="translated">경우 &lt;code&gt;as_text&lt;/code&gt; 가 설정되어 &lt;code&gt;True&lt;/code&gt; 반환 값은 디코딩 유니 코드 문자열입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
