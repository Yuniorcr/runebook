<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="flask">
    <body>
      <group id="flask">
        <trans-unit id="321b3650948ac8831655e280eaf2cb55a9f3ee98" translate="yes" xml:space="preserve">
          <source>The trick here is to get the template object from the Jinja2 environment on the application and to call &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.stream&quot;&gt;&lt;code&gt;stream()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt; which returns a stream object instead of a string. Since we&amp;rsquo;re bypassing the Flask template render functions and using the template object itself we have to make sure to update the render context ourselves by calling &lt;a href=&quot;../../api/index#flask.Flask.update_template_context&quot;&gt;&lt;code&gt;update_template_context()&lt;/code&gt;&lt;/a&gt;. The template is then evaluated as the stream is iterated over. Since each time you do a yield the server will flush the content to the client you might want to buffer up a few items in the template which you can do with &lt;code&gt;rv.enable_buffering(size)&lt;/code&gt;. &lt;code&gt;5&lt;/code&gt; is a sane default.</source>
          <target state="translated">여기서 트릭은 애플리케이션의 Jinja2 환경에서 템플릿 객체를 가져 오고 문자열 대신 스트림 객체를 반환하는 &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;https://jinja.palletsprojects.com/en/2.11.x/api/#jinja2.Template.stream&quot;&gt; &lt;code&gt;stream()&lt;/code&gt; &lt;/a&gt; 을 호출 하는 것입니다. Flask 템플릿 렌더링 함수를 우회하고 템플릿 객체 자체를 사용하고 있으므로 &lt;a href=&quot;../../api/index#flask.Flask.update_template_context&quot;&gt; &lt;code&gt;update_template_context()&lt;/code&gt; &lt;/a&gt; 를 호출하여 렌더링 컨텍스트를 직접 업데이트해야합니다 . 그런 다음 스트림이 반복 될 때 템플릿이 평가됩니다. 양보를 할 때마다 서버는 콘텐츠를 클라이언트에 플러시하기 때문에 &lt;code&gt;rv.enable_buffering(size)&lt;/code&gt; 할 수있는 템플릿의 몇 가지 항목을 버퍼링 할 수 있습니다 . &lt;code&gt;5&lt;/code&gt; 는 정상적인 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="20ea639ec0667a7a3b220eab0f8dd66f08181b21" translate="yes" xml:space="preserve">
          <source>The two following examples work the same and both reverse an object:</source>
          <target state="translated">다음 두 예제는 동일하게 작동하며 둘 다 객체를 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="d9fcc990d6599d2d6adb3a5b14b618e8528fdd1d" translate="yes" xml:space="preserve">
          <source>The underlying WSGI environment.</source>
          <target state="translated">기본 WSGI 환경.</target>
        </trans-unit>
        <trans-unit id="537b4935e3367592afab1eae9f2141c7cd4601e7" translate="yes" xml:space="preserve">
          <source>The upside of this approach (connecting on first use) is that this will only open the connection if truly necessary. If you want to use this code outside a request context you can use it in a Python shell by opening the application context by hand:</source>
          <target state="translated">이 접근 방식 (처음 사용할 때 연결)의 장점은 이것이 진정으로 필요한 경우에만 연결을 열 수 있다는 것입니다. 요청 컨텍스트 외부에서이 코드를 사용하려면 애플리케이션 컨텍스트를 직접 열어 Python 셸에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3aaa9460c11fe5351084c66f73bb024d869f2d" translate="yes" xml:space="preserve">
          <source>The way Flask is designed usually requires the configuration to be available when the application starts up. You can hard code the configuration in the code, which for many small applications is not actually that bad, but there are better ways.</source>
          <target state="translated">Flask가 설계되는 방식은 일반적으로 응용 프로그램이 시작될 때 구성을 사용할 수 있어야합니다. 코드에서 구성을 하드 코딩 할 수 있습니다. 많은 소규모 애플리케이션의 경우 실제로 그렇게 나쁘지는 않지만 더 좋은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3654d59a4128e3439eda626c3c65d729fcf239be" translate="yes" xml:space="preserve">
          <source>The way this works is by letting the client do an HTTP POST request and set the &lt;code&gt;X-HTTP-Method-Override&lt;/code&gt; header. Then the method is replaced with the header value before being passed to Flask.</source>
          <target state="translated">이것이 작동하는 방식은 클라이언트가 HTTP POST 요청을 수행하고 &lt;code&gt;X-HTTP-Method-Override&lt;/code&gt; 헤더를 설정하도록하는 것 입니다. 그런 다음 메서드는 Flask에 전달되기 전에 헤더 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="bf47bc15260487d4b0ab18941315bb211a355f52" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;create_app&lt;/code&gt; factory in &lt;code&gt;myapp&lt;/code&gt; is called with the string &lt;code&gt;'dev'&lt;/code&gt; as the argument. See &lt;a href=&quot;../../cli/index&quot;&gt;Command Line Interface&lt;/a&gt; for more detail.</source>
          <target state="translated">그런 다음 &lt;code&gt;myapp&lt;/code&gt; 의 &lt;code&gt;create_app&lt;/code&gt; 팩토리가 &lt;code&gt;'dev'&lt;/code&gt; 문자열을 인수로 사용하여 호출됩니다. 자세한 내용은 &lt;a href=&quot;../../cli/index&quot;&gt;명령 줄 인터페이스&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b18db475760288f2b455d0b5f405a9f302f85ca" translate="yes" xml:space="preserve">
          <source>Then you can define your central place to combine the views like this:</source>
          <target state="translated">그런 다음 중앙 위치를 정의하여 다음과 같이보기를 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d03dcf4c35736174cd9b7d74bec6f051b55e1d0" translate="yes" xml:space="preserve">
          <source>Then you can either declare the tables in your code like in the examples above, or automatically load them:</source>
          <target state="translated">그런 다음 위의 예와 같이 코드에서 테이블을 선언하거나 자동으로로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daec0a62173c4e0a469a18d74aa20df51a68a78a" translate="yes" xml:space="preserve">
          <source>Then you just have to add a separate &lt;code&gt;config.py&lt;/code&gt; file and export &lt;code&gt;YOURAPPLICATION_SETTINGS=/path/to/config.py&lt;/code&gt; and you are done. However there are alternative ways as well. For example you could use imports or subclassing.</source>
          <target state="translated">그런 다음 별도의 &lt;code&gt;config.py&lt;/code&gt; 파일 을 추가하고 &lt;code&gt;YOURAPPLICATION_SETTINGS=/path/to/config.py&lt;/code&gt; 를 내 보내면 됩니다. 그러나 다른 방법도 있습니다. 예를 들어 가져 오기 또는 하위 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9589a37c12b59e56b807d74432ef16cb2859ed1a" translate="yes" xml:space="preserve">
          <source>Then you still have the original application object around and can continue to call methods on it.</source>
          <target state="translated">그런 다음 여전히 원래 응용 프로그램 개체를 가지고 있으며 계속해서 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09ad95fe308e16d1fbef8a9aa708b10443608c06" translate="yes" xml:space="preserve">
          <source>Then, with the centralized approach you would have one file with the views (&lt;code&gt;views.py&lt;/code&gt;) but without any decorator:</source>
          <target state="translated">그런 다음 중앙 집중식 접근 방식을 사용하면 뷰 ( &lt;code&gt;views.py&lt;/code&gt; )가 있지만 데코레이터가없는 하나의 파일을 갖게됩니다 .</target>
        </trans-unit>
        <trans-unit id="472eacc74a9f0d6593fc850c37ed65a338647890" translate="yes" xml:space="preserve">
          <source>There are four very common ways to use SQLAlchemy. I will outline each of them here:</source>
          <target state="translated">SQLAlchemy를 사용하는 매우 일반적인 네 가지 방법이 있습니다. 여기에서 각각에 대해 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="71e898a483ad3580ae10e846efe9e8b850777f96" translate="yes" xml:space="preserve">
          <source>There are however some handy helpers to make playing around in the shell a more pleasant experience. The main issue with interactive console sessions is that you&amp;rsquo;re not triggering a request like a browser does which means that &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; and others are not available. But the code you want to test might depend on them, so what can you do?</source>
          <target state="translated">그러나 쉘에서 더 즐거운 경험을 할 수 있도록 몇 가지 편리한 도우미가 있습니다. 대화 형 콘솔 세션의 주요 문제는 브라우저처럼 요청을 트리거하지 않는다는 것입니다. 즉, &lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 및 기타를 사용할 수 없습니다. 그러나 테스트하려는 코드는 이들에 따라 달라질 수 있으므로 무엇을 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="7fded1f4fb1cfe9ac220017de27a35fbdb9cb1eb" translate="yes" xml:space="preserve">
          <source>There are many different ways and it&amp;rsquo;s up to you how you want to manage your configuration files. However here a list of good recommendations:</source>
          <target state="translated">다양한 방법이 있으며 구성 파일을 관리하는 방법은 사용자에게 달려 있습니다. 그러나 여기에 좋은 권장 사항 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="da96bc2de1277b8591d8d2bcf01d23096d9c88eb" translate="yes" xml:space="preserve">
          <source>There are many more ways to define and query documents with MongoEngine. For more information, check out the &lt;a href=&quot;http://mongoengine.org&quot;&gt;official documentation&lt;/a&gt;.</source>
          <target state="translated">MongoEngine을 사용하여 문서를 정의하고 쿼리하는 더 많은 방법이 있습니다. 자세한 내용은 &lt;a href=&quot;http://mongoengine.org&quot;&gt;공식 문서를&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="9a2e6264017a6edd0235b922fdb00233ee18c526" translate="yes" xml:space="preserve">
          <source>There are more parameters that are explained in the &lt;a href=&quot;../server/index#server&quot;&gt;Development Server&lt;/a&gt; docs.</source>
          <target state="translated">&lt;a href=&quot;../server/index#server&quot;&gt;개발 서버&lt;/a&gt; 문서에 설명 된 더 많은 매개 변수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5898775a2c63e8590f3b9e33a65778d8d0a352aa" translate="yes" xml:space="preserve">
          <source>There are popular servers written in Python that contain WSGI applications and serve HTTP. These servers stand alone when they run; you can proxy to them from your web server. Note the section on &lt;a href=&quot;#deploying-proxy-setups&quot;&gt;Proxy Setups&lt;/a&gt; if you run into issues.</source>
          <target state="translated">WSGI 애플리케이션을 포함하고 HTTP를 제공하는 Python으로 작성된 인기있는 서버가 있습니다. 이러한 서버는 실행시 단독으로 실행됩니다. 웹 서버에서 프록시 할 수 있습니다. 문제가 발생하면 &lt;a href=&quot;#deploying-proxy-setups&quot;&gt;프록시 설정&lt;/a&gt; 섹션을 참고하십시오 .</target>
        </trans-unit>
        <trans-unit id="928ecf304db8ea6d6fa56d3b9b51260430f1de46" translate="yes" xml:space="preserve">
          <source>There are still some problems with that approach but if you want to use decorators there is no way around that. Check out the &lt;a href=&quot;../../becomingbig/index#becomingbig&quot;&gt;Becoming Big&lt;/a&gt; section for some inspiration how to deal with that.</source>
          <target state="translated">그 접근 방식에는 여전히 몇 가지 문제가 있지만 데코레이터를 사용하려는 경우에는 그 방법이 없습니다. 이를 처리하는 방법에 대한 영감을 얻으 려면 &lt;a href=&quot;../../becomingbig/index#becomingbig&quot;&gt;Becoming Big&lt;/a&gt; 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="15e96a27ee4082ad0311662e2a39dd9fd3f40168" translate="yes" xml:space="preserve">
          <source>There are three major reasons for this. The most important one is that implicit application objects require that there may only be one instance at the time. There are ways to fake multiple applications with a single application object, like maintaining a stack of applications, but this causes some problems I won&amp;rsquo;t outline here in detail. Now the question is: when does a microframework need more than one application at the same time? A good example for this is unit testing. When you want to test something it can be very helpful to create a minimal application to test specific behavior. When the application object is deleted everything it allocated will be freed again.</source>
          <target state="translated">이에 대한 세 가지 주요 이유가 있습니다. 가장 중요한 것은 암시 적 응용 프로그램 개체가 한 번에 하나의 인스턴스 만있을 수 있어야한다는 것입니다. 애플리케이션 스택을 유지하는 것과 같이 단일 애플리케이션 객체로 여러 애플리케이션을 위조하는 방법이 있지만 이로 인해 여기서 자세히 설명하지 않을 몇 가지 문제가 발생합니다. 이제 문제는 마이크로 프레임 워크에 동시에 두 개 이상의 애플리케이션이 필요한 경우입니다. 이에 대한 좋은 예는 단위 테스트입니다. 무언가를 테스트하고 싶을 때 특정 동작을 테스트하기위한 최소한의 애플리케이션을 만드는 것이 매우 유용 할 수 있습니다. 응용 프로그램 개체가 삭제되면 할당 된 모든 항목이 다시 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d6faad00ba8c341e9b40b3f7db4c5ea5520d4cbb" translate="yes" xml:space="preserve">
          <source>There are three ways to accomplish that:</source>
          <target state="translated">이를 수행하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c9c5c28e806eb842806889bd3af7ae28e6215bb" translate="yes" xml:space="preserve">
          <source>There is one class of XSS issues that Jinja&amp;rsquo;s escaping does not protect against. The &lt;code&gt;a&lt;/code&gt; tag&amp;rsquo;s &lt;code&gt;href&lt;/code&gt; attribute can contain a &lt;code&gt;javascript:&lt;/code&gt; URI, which the browser will execute when clicked if not secured properly.</source>
          <target state="translated">Jinja의 이스케이프가 보호하지 못하는 XSS 문제에는 한 종류가 있습니다. &lt;code&gt;a&lt;/code&gt; 태그의 &lt;code&gt;href&lt;/code&gt; 속성은 포함 할 수 있습니다 &lt;code&gt;javascript:&lt;/code&gt; 제대로 확보하지 않을 경우 클릭하면 브라우저가 실행됩니다 URI를.</target>
        </trans-unit>
        <trans-unit id="c7c00687affa82f91d7111a12efc15fe808a7f0c" translate="yes" xml:space="preserve">
          <source>There is only one limiting factor regarding scaling in Flask which are the context local proxies. They depend on context which in Flask is defined as being either a thread, process or greenlet. If your server uses some kind of concurrency that is not based on threads or greenlets, Flask will no longer be able to support these global proxies. However the majority of servers are using either threads, greenlets or separate processes to achieve concurrency which are all methods well supported by the underlying Werkzeug library.</source>
          <target state="translated">컨텍스트 로컬 프록시 인 Flask의 확장과 관련된 제한 요소는 하나뿐입니다. Flask에서 스레드, 프로세스 또는 그린 렛으로 정의 된 컨텍스트에 따라 다릅니다. 서버가 스레드 또는 그린 렛을 기반으로하지 않는 일종의 동시성을 사용하는 경우 Flask는 더 이상 이러한 글로벌 프록시를 지원할 수 없습니다. 그러나 대부분의 서버는 기본 Werkzeug 라이브러리에서 잘 지원하는 모든 방법 인 동시성을 달성하기 위해 스레드, 그린 렛 또는 별도의 프로세스를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c3884cf380a23933fa4502691cf2361b8e81b98" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s quite a few options to change, but once we&amp;rsquo;ve done it for one command, we can easily copy the entire configuration and make a single tweak to give us access to other commands, including any custom ones you may implement yourself.</source>
          <target state="translated">변경할 수있는 옵션이 상당히 많지만 한 명령에 대해 수행 한 후에는 전체 구성을 쉽게 복사하고 사용자가 직접 구현할 수있는 사용자 지정 명령을 포함하여 다른 명령에 액세스 할 수 있도록 단일 조정을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35835fa75ed9020125850c44ceab56114f95b1f4" translate="yes" xml:space="preserve">
          <source>These can be added to the &lt;code&gt;.flaskenv&lt;/code&gt; file just like &lt;code&gt;FLASK_APP&lt;/code&gt; to control default command options.</source>
          <target state="translated">&lt;code&gt;.flaskenv&lt;/code&gt; 처럼 &lt;code&gt;FLASK_APP&lt;/code&gt; 파일에 추가하여 기본 명령 옵션을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a09cd827fffcec8212a890c079cd0551e75f1e7" translate="yes" xml:space="preserve">
          <source>These distributions will be installed automatically when installing Flask.</source>
          <target state="translated">이러한 배포는 Flask를 설치할 때 자동으로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="29d64fd15b4970cdfba96a6647045f8c7097f977" translate="yes" xml:space="preserve">
          <source>These distributions will not be installed automatically. Flask will detect and use them if you install them.</source>
          <target state="translated">이러한 배포는 자동으로 설치되지 않습니다. Flask는 설치하면이를 감지하고 사용합니다.</target>
        </trans-unit>
        <trans-unit id="48d2d208ca1e3d8126722d439eafac881a1103e5" translate="yes" xml:space="preserve">
          <source>These options can be added to a &lt;code&gt;Set-Cookie&lt;/code&gt; header to improve their security. Flask has configuration options to set these on the session cookie. They can be set on other cookies too.</source>
          <target state="translated">이러한 옵션을 &lt;code&gt;Set-Cookie&lt;/code&gt; 헤더에 추가하여 보안을 향상시킬 수 있습니다. Flask에는 세션 쿠키에이를 설정하는 구성 옵션이 있습니다. 다른 쿠키에도 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="134b21b8282573374e68bc59df1e0bbfa4d8e714" translate="yes" xml:space="preserve">
          <source>These processes will be managed by Apache. If you&amp;rsquo;re using a standalone FastCGI server, you can use the FastCgiExternalServer directive instead. Note that in the following the path is not real, it&amp;rsquo;s simply used as an identifier to other directives such as AliasMatch:</source>
          <target state="translated">이러한 프로세스는 Apache에서 관리합니다. 독립형 FastCGI 서버를 사용하는 경우 대신 FastCgiExternalServer 지시문을 사용할 수 있습니다. 다음에서 경로는 실제가 아니며 단순히 AliasMatch와 같은 다른 지시문에 대한 식별자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dbf05e019d39bb46213a7d05f2b3c2772d8ba685" translate="yes" xml:space="preserve">
          <source>These results are also dict-like tuples:</source>
          <target state="translated">이 결과는 또한 dict와 유사한 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="858f8f2bc57fff1a6d23326726e5ee5dfcfd7d80" translate="yes" xml:space="preserve">
          <source>These types of patterns may be a bit outside the scope of Flask itself, but Flask makes it easy to implement them. Some common patterns are collected in the following pages.</source>
          <target state="translated">이러한 유형의 패턴은 Flask 자체의 범위를 약간 벗어날 수 있지만 Flask를 사용하면 쉽게 구현할 수 있습니다. 다음 페이지에는 몇 가지 일반적인 패턴이 수집되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ce013ab8e968381e9cf7d34f24ab30caf79bf3d" translate="yes" xml:space="preserve">
          <source>These variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit.</source>
          <target state="translated">이러한 변수는 변수 컨텍스트에 추가되며 전역 변수가 아닙니다. 차이점은 기본적으로 가져온 템플릿의 컨텍스트에 표시되지 않는다는 것입니다. 이것은 부분적으로 성능 고려 사항으로 인해 발생하며 부분적으로는 명시 적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d02efca86e66ddac497e623f13ad84f059c26ada" translate="yes" xml:space="preserve">
          <source>Things to remember:</source>
          <target state="translated">기억해야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="9162813227931fe8d990673b898b0b235811b1de" translate="yes" xml:space="preserve">
          <source>This accepts the same options as the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt;&lt;code&gt;EnvironBuilder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.EnvironBuilder&quot;&gt; &lt;code&gt;EnvironBuilder&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="dc7c127cfd36f7c9a5636e65dc46def80fe46ca3" translate="yes" xml:space="preserve">
          <source>This allows subclasses to change the behavior when sending files based on the filename. For example, to set the cache timeout for .js files to 60 seconds:</source>
          <target state="translated">이렇게하면 하위 클래스가 파일 이름을 기반으로 파일을 보낼 때 동작을 변경할 수 있습니다. 예를 들어 .js 파일의 캐시 시간 제한을 60 초로 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6a875a3e4b070b9429d7cd3fe3ab0b39962bb0f8" translate="yes" xml:space="preserve">
          <source>This approach is explained in detail in the &lt;a href=&quot;../../config/index#config&quot;&gt;Configuration Handling&lt;/a&gt; section of the documentation.</source>
          <target state="translated">이 접근 방식은 설명서 의 &lt;a href=&quot;../../config/index#config&quot;&gt;구성 처리&lt;/a&gt; 섹션 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="804fc35c2d664df58f4558921552568d52bf51fd" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt;&lt;/a&gt; configuration key. Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;../config/index#SECRET_KEY&quot;&gt; &lt;code&gt;SECRET_KEY&lt;/code&gt; &lt;/a&gt; 구성 키를 사용하여 구성에서 구성 할 수도 있습니다 . 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c14ba1a484a4372f0ddfd5c528d2b89bea6dce02" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt; configuration key. Defaults to &lt;code&gt;timedelta(days=31)&lt;/code&gt;</source>
          <target state="translated">이 속성은 &lt;code&gt;PERMANENT_SESSION_LIFETIME&lt;/code&gt; 구성 키를 사용하여 구성에서 구성 할 수도 있습니다 . 기본값은 &lt;code&gt;timedelta(days=31)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1b0634c22ecf7528db41462ccae50eda62c4bd" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;SEND_FILE_MAX_AGE_DEFAULT&lt;/code&gt; configuration key. This configuration variable can also be set with an integer value used as seconds. Defaults to &lt;code&gt;timedelta(hours=12)&lt;/code&gt;</source>
          <target state="translated">이 속성은 &lt;code&gt;SEND_FILE_MAX_AGE_DEFAULT&lt;/code&gt; 구성 키를 사용하여 구성에서 구성 할 수도 있습니다 . 이 구성 변수는 초로 사용되는 정수 값으로 설정할 수도 있습니다. 기본값은 &lt;code&gt;timedelta(hours=12)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13dd8d3fce11a07385f0308479a9b1d2ab1e432e" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;SESSION_COOKIE_NAME&lt;/code&gt; configuration key. Defaults to &lt;code&gt;'session'&lt;/code&gt;</source>
          <target state="translated">이 속성은 &lt;code&gt;SESSION_COOKIE_NAME&lt;/code&gt; 구성 키를 사용하여 구성에서 구성 할 수도 있습니다 . 기본값은 &lt;code&gt;'session'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30f40dd48468931411ebedba547d4a02062370c7" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;TESTING&lt;/code&gt; configuration key. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">이 속성은 &lt;code&gt;TESTING&lt;/code&gt; 구성 키를 사용하여 구성에서 구성 할 수도 있습니다 . 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ddb27d3c8d3d1616f3a14c012b99110fce2ce8fa" translate="yes" xml:space="preserve">
          <source>This attribute can also be configured from the config with the &lt;code&gt;USE_X_SENDFILE&lt;/code&gt; configuration key. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">이 속성은 &lt;code&gt;USE_X_SENDFILE&lt;/code&gt; 구성 키를 사용하여 구성에서 구성 할 수도 있습니다 . 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a77842201b2dc95e38106579423d0ecc80ebc21" translate="yes" xml:space="preserve">
          <source>This attribute can be configured with &lt;a href=&quot;../config/index#TEMPLATES_AUTO_RELOAD&quot;&gt;&lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt;&lt;/a&gt;. If not set, it will be enabled in debug mode.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;../config/index#TEMPLATES_AUTO_RELOAD&quot;&gt; &lt;code&gt;TEMPLATES_AUTO_RELOAD&lt;/code&gt; &lt;/a&gt; 로 구성 할 수 있습니다 . 설정하지 않으면 디버그 모드에서 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="93f1355d94a62d3dcc34ca90ecdf621370445f30" translate="yes" xml:space="preserve">
          <source>This attribute is set to &lt;code&gt;True&lt;/code&gt; if the application started handling the first request.</source>
          <target state="translated">애플리케이션이 첫 번째 요청을 처리하기 시작한 경우이 속성은 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="47c31973616f3cefb86bc251826d632ace30be60" translate="yes" xml:space="preserve">
          <source>This behavior can be controlled with the &lt;a href=&quot;../config/index#PRESERVE_CONTEXT_ON_EXCEPTION&quot;&gt;&lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt;&lt;/a&gt; config. As described above, it defaults to &lt;code&gt;True&lt;/code&gt; in the development environment.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;../config/index#PRESERVE_CONTEXT_ON_EXCEPTION&quot;&gt; &lt;code&gt;PRESERVE_CONTEXT_ON_EXCEPTION&lt;/code&gt; &lt;/a&gt; 구성 으로 제어 할 수 있습니다 . 위에서 설명한대로 개발 환경 에서는 기본값이 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44d1d6597dfd8a5eacaee7c2854ab9392c0bf744" translate="yes" xml:space="preserve">
          <source>This calls all functions decorated with &lt;a href=&quot;#flask.Flask.teardown_appcontext&quot;&gt;&lt;code&gt;teardown_appcontext()&lt;/code&gt;&lt;/a&gt;. Then the &lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt;&lt;code&gt;appcontext_tearing_down&lt;/code&gt;&lt;/a&gt; signal is sent.</source>
          <target state="translated">이것은 &lt;a href=&quot;#flask.Flask.teardown_appcontext&quot;&gt; &lt;code&gt;teardown_appcontext()&lt;/code&gt; &lt;/a&gt; 장식 된 모든 함수를 호출합니다 . 그런 다음 &lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt; &lt;code&gt;appcontext_tearing_down&lt;/code&gt; &lt;/a&gt; 신호가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="85d062da99b51b692d776f88345dfb31cbf16f69" translate="yes" xml:space="preserve">
          <source>This calls all functions decorated with &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#flask.Blueprint.teardown_request&quot;&gt;&lt;code&gt;Blueprint.teardown_request()&lt;/code&gt;&lt;/a&gt; if a blueprint handled the request. Finally, the &lt;a href=&quot;#flask.request_tearing_down&quot;&gt;&lt;code&gt;request_tearing_down&lt;/code&gt;&lt;/a&gt; signal is sent.</source>
          <target state="translated">이것은 &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#flask.Blueprint.teardown_request&quot;&gt; &lt;code&gt;Blueprint.teardown_request()&lt;/code&gt; &lt;/a&gt; 프린트가 요청을 처리했다면 Blueprint.teardown_request ()로 장식 된 모든 함수를 호출합니다 . 마지막으로 &lt;a href=&quot;#flask.request_tearing_down&quot;&gt; &lt;code&gt;request_tearing_down&lt;/code&gt; &lt;/a&gt; 신호가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="12d85f9a8204975d20437b4f139f4f382330c8d3" translate="yes" xml:space="preserve">
          <source>This can be a problem if your application has to import quick. It might have to do that on systems like Google&amp;rsquo;s App Engine or other systems. So if you suddenly notice that your application outgrows this approach you can fall back to a centralized URL mapping.</source>
          <target state="translated">응용 프로그램을 빠르게 가져와야하는 경우 문제가 될 수 있습니다. Google의 App Engine이나 다른 시스템과 같은 시스템에서 그렇게해야 할 수도 있습니다. 따라서 애플리케이션이이 접근 방식을 능가하는 것을 갑자기 발견하면 중앙 집중식 URL 매핑으로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="455ece4693060f7c6e43193844070f1932581a01" translate="yes" xml:space="preserve">
          <source>This can be accomplished with an HTTP middleware:</source>
          <target state="translated">이는 HTTP 미들웨어로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c0dd21e69d0a8a798a621d9bc8ff4a9841cbd7" translate="yes" xml:space="preserve">
          <source>This can be necessary to open database connections or something similar depending on how your application was designed.</source>
          <target state="translated">이것은 애플리케이션이 디자인 된 방식에 따라 데이터베이스 연결 또는 이와 유사한 것을 여는 데 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f376e8b728e1d3a7d77a33e5ed80767b6ee59ead" translate="yes" xml:space="preserve">
          <source>This can now easily be paired with a test client:</source>
          <target state="translated">이제 테스트 클라이언트와 쉽게 페어링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e3a6b916130c10b66b2e43aab3914b4c0640b93" translate="yes" xml:space="preserve">
          <source>This check is usually skipped if the session was deleted.</source>
          <target state="translated">세션이 삭제 된 경우이 검사는 일반적으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="afa6d452e4abff29640ff00bcd2267f10d8de51a" translate="yes" xml:space="preserve">
          <source>This checks if the object is an instance of &lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt;&lt;code&gt;null_session_class&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">이것은 객체가 기본적 으로 &lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt; &lt;code&gt;null_session_class&lt;/code&gt; &lt;/a&gt; 의 인스턴스인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="730a4146b3fdf2a11277d63dc15bebc83bd17dfe" translate="yes" xml:space="preserve">
          <source>This client fixture will be called by each individual test. It gives us a simple interface to the application, where we can trigger test requests to the application. The client will also keep track of cookies for us.</source>
          <target state="translated">이 클라이언트 고정 장치는 각 개별 테스트에서 호출됩니다. 애플리케이션에 대한 테스트 요청을 트리거 할 수있는 애플리케이션에 대한 간단한 인터페이스를 제공합니다. 고객은 또한 당사를 위해 쿠키를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="335d39c4ec67765057fa66ec21f6f1010b5650d7" translate="yes" xml:space="preserve">
          <source>This configuration binds the application to &lt;code&gt;/yourapplication&lt;/code&gt;. If you want to have it in the URL root it&amp;rsquo;s a bit simpler because you don&amp;rsquo;t have to figure out how to calculate &lt;code&gt;PATH_INFO&lt;/code&gt; and &lt;code&gt;SCRIPT_NAME&lt;/code&gt;:</source>
          <target state="translated">이 구성은 애플리케이션을 &lt;code&gt;/yourapplication&lt;/code&gt; 에 바인딩합니다 . URL 루트에 포함하고 싶다면 &lt;code&gt;PATH_INFO&lt;/code&gt; 및 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 을 계산하는 방법을 알아낼 필요가 없기 때문에 조금 더 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="7bd999f74182b278e30e7d8447d9cd71a92772ae" translate="yes" xml:space="preserve">
          <source>This configuration binds the application to &lt;code&gt;/yourapplication&lt;/code&gt;. If you want to have it in the URL root its a bit simpler:</source>
          <target state="translated">이 구성은 애플리케이션을 &lt;code&gt;/yourapplication&lt;/code&gt; 에 바인딩합니다 . URL 루트에 넣으려면 조금 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1d6a76c6c818fd4fcb0ca0f5afdbdd7643bc6fc3" translate="yes" xml:space="preserve">
          <source>This creates an instance of &lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt;&lt;code&gt;null_session_class&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">이것은 기본적 으로 &lt;a href=&quot;#flask.sessions.SessionInterface.null_session_class&quot;&gt; &lt;code&gt;null_session_class&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c3a00ac514ae27d7a421f076066c74db3d510a43" translate="yes" xml:space="preserve">
          <source>This dispatcher can then be used like this:</source>
          <target state="translated">이 디스패처는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71b5d1f44dfc118ba731271d0278017136ca6711" translate="yes" xml:space="preserve">
          <source>This does the following things:</source>
          <target state="translated">이것은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d25e537830a08f59356a72a2248d40060f19ac8b" translate="yes" xml:space="preserve">
          <source>This enables the development environment, including the interactive debugger and reloader, and then starts the server on &lt;em&gt;http://localhost:5000/&lt;/em&gt;.</source>
          <target state="translated">이렇게하면 대화 형 디버거 및 리 로더를 포함한 개발 환경이 활성화되고 &lt;em&gt;http : // localhost : 5000 /&lt;/em&gt; 에서 서버가 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0c2ade2b72b6546273b4c212a19aefe3247b955" translate="yes" xml:space="preserve">
          <source>This example adds the command &lt;code&gt;create-user&lt;/code&gt; that takes the argument &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 &lt;code&gt;name&lt;/code&gt; 인수를 &lt;code&gt;create-user&lt;/code&gt; 하는 create-user 명령을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="de849750f32cffa06ab924f2ed604d03a611bbe8" translate="yes" xml:space="preserve">
          <source>This example adds the same command, but as &lt;code&gt;user create&lt;/code&gt;, a command in a group. This is useful if you want to organize multiple related commands.</source>
          <target state="translated">이 예제는 동일한 명령을 추가하지만 &lt;code&gt;user create&lt;/code&gt; 로 그룹의 명령을 추가합니다. 여러 관련 명령을 구성하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="53eb57f385f61f99404d1b82afc101ef669d207f" translate="yes" xml:space="preserve">
          <source>This example assumes that the login page is called &lt;code&gt;'login'&lt;/code&gt; and that the current user is stored in &lt;code&gt;g.user&lt;/code&gt; and is &lt;code&gt;None&lt;/code&gt; if there is no-one logged in.</source>
          <target state="translated">이 예는 로그인 페이지가 호출되어 있다고 가정 &lt;code&gt;'login'&lt;/code&gt; 현재 사용자가 저장되어 &lt;code&gt;g.user&lt;/code&gt; 및 없습니다 &lt;code&gt;None&lt;/code&gt; 아무도 로그인이없는 경우.</target>
        </trans-unit>
        <trans-unit id="a843d35be9f7ac67abc22b06ca404c1c0e6cf06c" translate="yes" xml:space="preserve">
          <source>This example assumes your application is called &lt;code&gt;application.fcgi&lt;/code&gt; and that your web server user is &lt;code&gt;www-data&lt;/code&gt;:</source>
          <target state="translated">이 예에서는 애플리케이션이 &lt;code&gt;application.fcgi&lt;/code&gt; 이고 웹 서버 사용자가 &lt;code&gt;www-data&lt;/code&gt; 라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="92bea2ee7419e83ce35e916efc02ce6605f0b02e" translate="yes" xml:space="preserve">
          <source>This example uses &lt;a href=&quot;https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; to create a logging configuration similar to Flask&amp;rsquo;s default, except for all logs:</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;https://docs.python.org/3/library/logging.config.html#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 를 사용하여 모든 로그를 제외하고 Flask의 기본값과 유사한 로깅 구성을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="868633009eb64678813d2196ce60e646fa6bc37c" translate="yes" xml:space="preserve">
          <source>This example will run a Flask application called &lt;code&gt;app&lt;/code&gt; from a module named &lt;code&gt;myproject&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;myproject&lt;/code&gt; 라는 모듈에서 &lt;code&gt;app&lt;/code&gt; 이라는 Flask 애플리케이션을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="6dc0d95707083419da80a27283400cfeba0441bf" translate="yes" xml:space="preserve">
          <source>This feature was added in Flask 0.6 but can be achieved in older versions as well by subclassing the request object. For more information on that consult the Werkzeug documentation on file handling.</source>
          <target state="translated">이 기능은 Flask 0.6에 추가되었지만 이전 버전에서도 요청 객체를 서브 클래 싱하여 달성 할 수 있습니다. 이에 대한 자세한 내용은 파일 처리에 대한 Werkzeug 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c51dcdf50421641b399abea56e11fa9fdb760755" translate="yes" xml:space="preserve">
          <source>This first loads the configuration from the &lt;code&gt;yourapplication.default_settings&lt;/code&gt; module and then overrides the values with the contents of the file the &lt;code id=&quot;index-7&quot;&gt;YOURAPPLICATION_SETTINGS&lt;/code&gt; environment variable points to. This environment variable can be set on Linux or OS X with the export command in the shell before starting the server:</source>
          <target state="translated">이렇게하면 먼저 &lt;code&gt;yourapplication.default_settings&lt;/code&gt; 모듈 에서 구성을로드 한 다음 &lt;code id=&quot;index-7&quot;&gt;YOURAPPLICATION_SETTINGS&lt;/code&gt; 환경 변수가 가리키는 파일의 내용으로 값을 재정의합니다 . 이 환경 변수는 서버를 시작하기 전에 쉘의 export 명령을 사용하여 Linux 또는 OS X에서 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93a061c53a6a1f7322f4b0c0db48c51cb2839390" translate="yes" xml:space="preserve">
          <source>This function accepts the very same arguments you can return from a view function. This for example creates a response with a 404 error code:</source>
          <target state="translated">이 함수는 뷰 함수에서 반환 할 수있는 것과 동일한 인수를받습니다. 예를 들어 다음은 404 오류 코드가있는 응답을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2080b6a130b94d25e7f0dd83fa3d5df340b0169a" translate="yes" xml:space="preserve">
          <source>This function converts the given object into JSON representation. This is for example very helpful if you try to generate JavaScript on the fly.</source>
          <target state="translated">이 함수는 주어진 객체를 JSON 표현으로 변환합니다. 예를 들어 JavaScript를 즉석에서 생성하려고 할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a7a0b8273f4be29272636fe85cacb7d0671fd4b3" translate="yes" xml:space="preserve">
          <source>This function however can help you keep the context around for longer:</source>
          <target state="translated">그러나이 기능은 컨텍스트를 더 오래 유지하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69cc0c0a2456c84caa837cbacfc20a90b5032a6" translate="yes" xml:space="preserve">
          <source>This function wraps &lt;a href=&quot;#flask.json.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; to add a few enhancements that make life easier. It turns the JSON output into a &lt;a href=&quot;#flask.Response&quot;&gt;&lt;code&gt;Response&lt;/code&gt;&lt;/a&gt; object with the &lt;em&gt;application/json&lt;/em&gt; mimetype. For convenience, it also converts multiple arguments into an array or multiple keyword arguments into a dict. This means that both &lt;code&gt;jsonify(1,2,3)&lt;/code&gt; and &lt;code&gt;jsonify([1,2,3])&lt;/code&gt; serialize to &lt;code&gt;[1,2,3]&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#flask.json.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt; 를 래핑 하여 삶을 더 쉽게 만드는 몇 가지 개선 사항을 추가합니다. JSON 출력을 &lt;em&gt;application / json&lt;/em&gt; mimetype 을 사용하여 &lt;a href=&quot;#flask.Response&quot;&gt; &lt;code&gt;Response&lt;/code&gt; &lt;/a&gt; 객체로 변환합니다 . 편의를 위해 여러 인수를 배열로 변환하거나 여러 키워드 인수를 dict로 변환합니다. 이 수단 모두 &lt;code&gt;jsonify(1,2,3)&lt;/code&gt; 과 &lt;code&gt;jsonify([1,2,3])&lt;/code&gt; 직렬화 &lt;code&gt;[1,2,3]&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79d2a3ea0351f5548eb71bf7129f4e01a7f9ada3" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s response will be pretty printed if the &lt;code&gt;JSONIFY_PRETTYPRINT_REGULAR&lt;/code&gt; config parameter is set to True or the Flask app is running in debug mode. Compressed (not pretty) formatting currently means no indents and no spaces after separators.</source>
          <target state="translated">이 함수의 응답은 &lt;code&gt;JSONIFY_PRETTYPRINT_REGULAR&lt;/code&gt; 구성 매개 변수가 True로 설정되어 있거나 Flask 앱이 디버그 모드에서 실행중인 경우 예쁘게 인쇄 됩니다. 압축 (예쁘지 않음) 서식은 현재 들여 쓰기가없고 구분 기호 뒤에 공백이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e35115eb5260b1850b74a2e84ba968ba59bfcd27" translate="yes" xml:space="preserve">
          <source>This handy little function, in combination with a row factory, makes working with the database much more pleasant than it is by just using the raw cursor and connection objects.</source>
          <target state="translated">행 팩토리와 결합 된이 편리한 작은 기능은 원시 커서 및 연결 개체를 사용하는 것보다 데이터베이스 작업을 훨씬 더 즐겁게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8018d23ab92b8722785a664ab85f7b3ef277bded" translate="yes" xml:space="preserve">
          <source>This has the advantage of just installing a link to the site-packages folder instead of copying the data over. You can then continue to work on the code without having to run &lt;code&gt;install&lt;/code&gt; again after each change.</source>
          <target state="translated">이것은 데이터를 복사하는 대신 사이트 패키지 폴더에 대한 링크를 설치하는 장점이 있습니다. 그런 다음 변경할 때마다 다시 &lt;code&gt;install&lt;/code&gt; 를 실행할 필요없이 코드 작업을 계속할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2be3b218ec4671cb9e0aeffe4a987808599e9e6" translate="yes" xml:space="preserve">
          <source>This however can easily be done yourself. Just call &lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt;&lt;code&gt;preprocess_request()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그러나 이것은 쉽게 할 수 있습니다. &lt;a href=&quot;../api/index#flask.Flask.preprocess_request&quot;&gt; &lt;code&gt;preprocess_request()&lt;/code&gt; &lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="5691d6a04305258f7635e3ef8ce85f0fa05b7a81" translate="yes" xml:space="preserve">
          <source>This however does not make it possible to also modify the session or to access the session before a request was fired. Starting with Flask 0.8 we provide a so called &amp;ldquo;session transaction&amp;rdquo; which simulates the appropriate calls to open a session in the context of the test client and to modify it. At the end of the transaction the session is stored and ready to be used by the test client. This works independently of the session backend used:</source>
          <target state="translated">그러나 요청이 시작되기 전에 세션을 수정하거나 세션에 액세스 할 수는 없습니다. Flask 0.8부터는 테스트 클라이언트의 컨텍스트에서 세션을 열고 수정하기위한 적절한 호출을 시뮬레이션하는 소위 &quot;세션 트랜잭션&quot;을 제공합니다. 트랜잭션이 끝나면 세션이 저장되고 테스트 클라이언트에서 사용할 준비가됩니다. 이것은 사용 된 세션 백엔드와 독립적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7117c6a3dcd2866f4c938cbc4ba178ac19db3a23" translate="yes" xml:space="preserve">
          <source>This implements the &lt;code&gt;__html__()&lt;/code&gt; interface that some frameworks use. Passing an object that implements &lt;code&gt;__html__()&lt;/code&gt; will wrap the output of that method, marking it safe.</source>
          <target state="translated">이것은 일부 프레임 워크에서 사용 하는 &lt;code&gt;__html__()&lt;/code&gt; 인터페이스를 구현합니다 . &lt;code&gt;__html__()&lt;/code&gt; 을 구현하는 객체를 전달하면 해당 메서드의 출력을 래핑하여 안전한 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7ad573f36373ed94556684aac3b301523702cd53" translate="yes" xml:space="preserve">
          <source>This in general is less useful because at that point you can directly start using the test client.</source>
          <target state="translated">이것은 일반적으로 덜 유용합니다. 그 시점에서 테스트 클라이언트 사용을 직접 시작할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3d95231a701c4ba1d1cfc52722e39c7371c5fc47" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;True&lt;/code&gt; if the package bound object&amp;rsquo;s container has a folder for static files.</source>
          <target state="translated">이다 &lt;code&gt;True&lt;/code&gt; 패키지 바인딩 개체의 컨테이너가 정적 파일에 대한 폴더가있는 경우.</target>
        </trans-unit>
        <trans-unit id="2d4967d8fe1a5097eb7a73f5a9ab1048d814108a" translate="yes" xml:space="preserve">
          <source>This is a basic first example that has the ability to upload the current source code to the server and install it into a pre-existing virtual environment:</source>
          <target state="translated">다음은 현재 소스 코드를 서버에 업로드하고 기존 가상 환경에 설치할 수있는 기본적인 첫 번째 예제입니다.</target>
        </trans-unit>
        <trans-unit id="1a9744c7f7ae4309f914377a3bd10e2310ba8a75" translate="yes" xml:space="preserve">
          <source>This is a basic view function that generates a lot of CSV data on the fly. The trick is to have an inner function that uses a generator to generate data and to then invoke that function and pass it to a response object:</source>
          <target state="translated">즉석에서 많은 CSV 데이터를 생성하는 기본보기 기능입니다. 트릭은 생성기를 사용하여 데이터를 생성 한 다음 해당 함수를 호출하고 응답 객체에 전달하는 내부 함수를 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6f43712ca948bc7c2c3c303592e601b39bdf98cb" translate="yes" xml:space="preserve">
          <source>This is a good place to store resources during a request. During testing, you can use the &lt;a href=&quot;../testing/index#faking-resources&quot;&gt;Faking Resources and Context&lt;/a&gt; pattern to pre-configure such resources.</source>
          <target state="translated">요청 중에 리소스를 저장하기에 좋은 장소입니다. 테스트 중에 &lt;a href=&quot;../testing/index#faking-resources&quot;&gt;Faking Resources 및 Context&lt;/a&gt; 패턴을 사용하여 이러한 리소스를 사전 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="406dab1677f6a99e2f21a491c09196ff930e32b6" translate="yes" xml:space="preserve">
          <source>This is a no-op if &lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;python-dotenv&lt;/a&gt; is not installed.</source>
          <target state="translated">경우는 무 조작입니다 &lt;a href=&quot;https://github.com/theskumar/python-dotenv#readme&quot;&gt;파이썬 dotenv이&lt;/a&gt; 설치되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a89540d15c0128066ffd467328875d183143de8" translate="yes" xml:space="preserve">
          <source>This is a proxy. See &lt;a href=&quot;../reqcontext/index#notes-on-proxies&quot;&gt;Notes On Proxies&lt;/a&gt; for more information.</source>
          <target state="translated">이것은 프록시입니다. 자세한 내용은 &lt;a href=&quot;../reqcontext/index#notes-on-proxies&quot;&gt;프록시에&lt;/a&gt; 대한 참고 사항 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="04991e67d423d17308d3fad8e905743b1218a127" translate="yes" xml:space="preserve">
          <source>This is a rather pointless example because a user will be redirected from the index to a page they cannot access (401 means access denied) but it shows how that works.</source>
          <target state="translated">이것은 사용자가 인덱스에서 액세스 할 수없는 페이지 (401은 액세스 거부를 의미)로 리디렉션되기 때문에 다소 의미가없는 예이지만 작동 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7b17e1e6cdd25360c33b96a51ecebcdb598bc6f3" translate="yes" xml:space="preserve">
          <source>This is a simple example:</source>
          <target state="translated">다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="7d2893e07954b65e2f755bd7e378c7d1ebc3f5c1" translate="yes" xml:space="preserve">
          <source>This is a subclass of the text type (&lt;code&gt;str&lt;/code&gt; in Python 3, &lt;code&gt;unicode&lt;/code&gt; in Python 2). It has the same methods as that type, but all methods escape their arguments and return a &lt;code&gt;Markup&lt;/code&gt; instance.</source>
          <target state="translated">이것은 텍스트 유형 ( Python 3에서는 &lt;code&gt;str&lt;/code&gt; , Python 2에서는 &lt;code&gt;unicode&lt;/code&gt; )의 하위 클래스입니다 . 해당 유형과 동일한 메서드가 있지만 모든 메서드는 인수를 이스케이프하고 &lt;code&gt;Markup&lt;/code&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="11de1a39a894debac70bde810ca5d91378bec443" translate="yes" xml:space="preserve">
          <source>This is all that is necessary to properly integrate Celery with Flask:</source>
          <target state="translated">Celery와 Flask를 적절하게 통합하는 데 필요한 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e06d505bfc76629ae867309e258c944c796935c" translate="yes" xml:space="preserve">
          <source>This is also the way you can use a Flask application on Google&amp;rsquo;s &lt;a href=&quot;https://cloud.google.com/appengine/docs/&quot;&gt;App Engine&lt;/a&gt;, where execution happens in a CGI-like environment.</source>
          <target state="translated">이것은 또한 CGI와 유사한 환경에서 실행되는 Google의 &lt;a href=&quot;https://cloud.google.com/appengine/docs/&quot;&gt;App Engine&lt;/a&gt; 에서 Flask 애플리케이션을 사용할 수있는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="6899f8a640681b1ea207c43caef3c33f1bc6b70b" translate="yes" xml:space="preserve">
          <source>This is an awful lot of repetition as you have to handle the language code setting on the &lt;a href=&quot;../../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; object yourself in every single function. Sure, a decorator could be used to simplify this, but if you want to generate URLs from one function to another you would have to still provide the language code explicitly which can be annoying.</source>
          <target state="translated">모든 단일 함수에서 &lt;a href=&quot;../../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; 객체 에 대한 언어 코드 설정을 직접 처리해야하기 때문에 이것은 엄청나게 많은 반복 입니다. 물론 데코레이터를 사용하여이를 단순화 할 수 있지만 한 함수에서 다른 함수로 URL을 생성하려면 여전히 성가신 언어 코드를 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4a329b37f616542b0a8ece21c3ec7d1a16be968" translate="yes" xml:space="preserve">
          <source>This is an example form for a typical registration page:</source>
          <target state="translated">다음은 일반적인 등록 페이지의 예제 양식입니다.</target>
        </trans-unit>
        <trans-unit id="0018a869c40ef0a3e25a09c44f2e50ee3503172b" translate="yes" xml:space="preserve">
          <source>This is an obscure feature inherited from SGML. It is usually not supported by browsers, for reasons detailed above.</source>
          <target state="translated">이것은 SGML에서 상속 된 모호한 기능입니다. 위에 설명 된 이유로 일반적으로 브라우저에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0832a770d929c0bc1c49acfb7ec467f594f73cac" translate="yes" xml:space="preserve">
          <source>This is called by &lt;a href=&quot;#flask.ctx.AppContext.pop&quot;&gt;&lt;code&gt;AppContext.pop()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#flask.ctx.AppContext.pop&quot;&gt; &lt;code&gt;AppContext.pop()&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="749036b6d5970b4554ef8800a254e4aed729e006" translate="yes" xml:space="preserve">
          <source>This is called by &lt;a href=&quot;#flask.ctx.RequestContext.pop&quot;&gt;&lt;code&gt;RequestContext.pop()&lt;/code&gt;&lt;/a&gt;, which may be delayed during testing to maintain access to resources.</source>
          <target state="translated">이것은 &lt;a href=&quot;#flask.ctx.RequestContext.pop&quot;&gt; &lt;code&gt;RequestContext.pop()&lt;/code&gt; &lt;/a&gt; 의해 호출되며 , 리소스에 대한 액세스를 유지하기 위해 테스트 중에 지연 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25a19177e9fead1dc9c7e88220893e3ce7cdfb21" translate="yes" xml:space="preserve">
          <source>This is called for actual sessions returned by &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt; at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.</source>
          <target state="translated">요청이 끝날 때 &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 실제 세션에 대해 호출됩니다 . 이것은 요청 컨텍스트 중에 여전히 호출되므로 요청에 대한 액세스가 절대적으로 필요한 경우 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee7deb8ede6b2dddf03427ee56f596d3c595e7f" translate="yes" xml:space="preserve">
          <source>This is called for actual sessions returned by &lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt;&lt;code&gt;open_session()&lt;/code&gt;&lt;/a&gt; at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.</source>
          <target state="translated">요청이 끝날 때 &lt;a href=&quot;#flask.sessions.SessionInterface.open_session&quot;&gt; &lt;code&gt;open_session()&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 실제 세션에 대해 호출됩니다 . 이것은 요청 컨텍스트 중에 여전히 호출되므로 요청에 대한 액세스가 절대적으로 필요한 경우 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f50e39c8418ad62af7e3eb9129e991de42066d1" translate="yes" xml:space="preserve">
          <source>This is called for all HTTP exceptions raised by a view function. If it returns &lt;code&gt;True&lt;/code&gt; for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.</source>
          <target state="translated">뷰 함수에 의해 발생하는 모든 HTTP 예외에 대해 호출됩니다. 모든 예외에 대해 &lt;code&gt;True&lt;/code&gt; 를 반환 하면이 예외에 대한 오류 처리기가 호출되지 않고 트레이스 백에서 일반 예외로 표시됩니다. 이는 암시 적으로 발생한 HTTP 예외를 디버깅하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="399bbe1dc073334d3ef5342ad07290b8905cb6a0" translate="yes" xml:space="preserve">
          <source>This is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns &lt;code&gt;True&lt;/code&gt; then the teardown handlers will not be passed the error.</source>
          <target state="translated">이것은 분해 시스템에 관한 한 오류를 무시해야하는지 여부를 파악하기 위해 호출됩니다. 이 함수가 &lt;code&gt;True&lt;/code&gt; 를 반환 하면 분해 처리기에 오류가 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fc02267b47b562f013ae64d2cb483ffdf64aba1" translate="yes" xml:space="preserve">
          <source>This is consistent with how web servers deal with static files. This also makes it possible to use relative link targets safely.</source>
          <target state="translated">이것은 웹 서버가 정적 파일을 처리하는 방식과 일치합니다. 또한 상대 링크 대상을 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7362e74b32b4ea2cdf1bf8a5aead79ccca7056d0" translate="yes" xml:space="preserve">
          <source>This is enough for Apache to work, however nginx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the &lt;code&gt;WSGIServer&lt;/code&gt;:</source>
          <target state="translated">이것은 Apache가 작동하기에 충분하지만 nginx 및 이전 버전의 lighttpd는 FastCGI 서버와 통신하기 위해 명시 적으로 소켓을 전달해야합니다. 작동하려면 &lt;code&gt;WSGIServer&lt;/code&gt; 에 소켓 경로를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="28f568388aa2f7a11b2f8c90b81642f71002249c" translate="yes" xml:space="preserve">
          <source>This is for compatibility with server code that generates XHTML for tags such as &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;. It should not be used in new code.</source>
          <target state="translated">이는 &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 과 같은 태그에 대해 XHTML을 생성하는 서버 코드와의 호환성을위한 것 입니다. 새 코드에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6c18944170282f8c3549748409b58c2a7235d7a7" translate="yes" xml:space="preserve">
          <source>This is just one example of how to render these flashed messages. One might also use the category to add a prefix such as &lt;code&gt;&amp;lt;strong&amp;gt;Error:&amp;lt;/strong&amp;gt;&lt;/code&gt; to the message.</source>
          <target state="translated">이것은 이러한 플래시 메시지를 렌더링하는 방법의 한 예일뿐입니다. 카테고리를 사용 하여 메시지에 &lt;code&gt;&amp;lt;strong&amp;gt;Error:&amp;lt;/strong&amp;gt;&lt;/code&gt; 와 같은 접두사를 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97e58fe407e3962722431677e369c51c27425d17" translate="yes" xml:space="preserve">
          <source>This is more useful if a function other than the view function wants to modify a response. For instance think of a decorator that wants to add some headers without converting the return value into a response object.</source>
          <target state="translated">이는보기 기능 이외의 기능이 응답을 수정하려는 경우에 더 유용합니다. 예를 들어 반환 값을 응답 객체로 변환하지 않고 일부 헤더를 추가하려는 데코레이터를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="aa420fdcaab1e763e3afd355b66cc8c992c104f0" translate="yes" xml:space="preserve">
          <source>This is not unique to Flask. Many people use patched and modified versions of their framework to counter shortcomings. This idea is also reflected in the license of Flask. You don&amp;rsquo;t have to contribute any changes back if you decide to modify the framework.</source>
          <target state="translated">이것은 Flask에만 국한되지 않습니다. 많은 사람들이 단점을 보완하기 위해 프레임 워크의 패치 및 수정 버전을 사용합니다. 이 아이디어는 Flask 라이센스에도 반영됩니다. 프레임 워크를 수정하기로 결정한 경우 변경 사항을 다시 제공 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b30c688e010cf67471b7a00c77af144feb450a08" translate="yes" xml:space="preserve">
          <source>This is often useful when configuration options map directly to keyword arguments in functions or class constructors.</source>
          <target state="translated">이는 구성 옵션이 함수 또는 클래스 생성자의 키워드 인수에 직접 매핑 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="266f8af16ea4522a6df0e9570795d35f6a7fdc38" translate="yes" xml:space="preserve">
          <source>This is only available when an &lt;a href=&quot;../appcontext/index&quot;&gt;application context&lt;/a&gt; is pushed. This happens automatically during requests and CLI commands. It can be controlled manually with &lt;a href=&quot;#flask.Flask.app_context&quot;&gt;&lt;code&gt;app_context()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 &lt;a href=&quot;../appcontext/index&quot;&gt;애플리케이션 컨텍스트&lt;/a&gt; 가 푸시 된 경우에만 사용할 수 있습니다 . 이는 요청 및 CLI 명령 중에 자동으로 발생합니다. &lt;a href=&quot;#flask.Flask.app_context&quot;&gt; &lt;code&gt;app_context()&lt;/code&gt; &lt;/a&gt; 하여 수동으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50a07b1a7e2fed61143d19358431950d58c53b28" translate="yes" xml:space="preserve">
          <source>This is similar to the &lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt;, which keeps track of the application-level data independent of a request. A corresponding application context is pushed when a request context is pushed.</source>
          <target state="translated">이는 요청과 관계없이 애플리케이션 수준 데이터를 추적 하는 &lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt; 와 유사합니다 . 요청 컨텍스트가 푸시 될 때 해당 애플리케이션 컨텍스트가 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="f1ec20c59c3ad8750fe8e0e9b913a7e19dbc0e72" translate="yes" xml:space="preserve">
          <source>This is similar to the &lt;a href=&quot;../reqcontext/index&quot;&gt;The Request Context&lt;/a&gt;, which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed.</source>
          <target state="translated">이는 요청 중에 요청 수준 데이터를 추적 하는 &lt;a href=&quot;../reqcontext/index&quot;&gt;The Request Context&lt;/a&gt; 와 유사합니다 . 요청 컨텍스트가 푸시 될 때 해당 애플리케이션 컨텍스트가 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3c79a2614f389c7648b70b313e742568fbb652" translate="yes" xml:space="preserve">
          <source>This is simple and flexible, but if you want to provide this view in a generic fashion that can be adapted to other models and templates as well you might want more flexibility. This is where pluggable class-based views come into place. As the first step to convert this into a class based view you would do this:</source>
          <target state="translated">이것은 간단하고 유연하지만 다른 모델과 템플릿에도 적용 할 수있는 일반적인 방식으로이 뷰를 제공하려는 경우 더 많은 유연성을 원할 수 있습니다. 플러그 가능한 클래스 기반 뷰가 등장하는 곳입니다. 이것을 클래스 기반 뷰로 변환하는 첫 번째 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0e4c3d37fb2cc0272478b8ac349962dbe2d8e79" translate="yes" xml:space="preserve">
          <source>This is the recommended approach for overriding or augmenting Flask&amp;rsquo;s internal functionality.</source>
          <target state="translated">이것은 Flask의 내부 기능을 재정의하거나 보강하는 데 권장되는 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="baafc5bbf292d550e9090df3ef8edc09b6c35429" translate="yes" xml:space="preserve">
          <source>This is the way to invoke a script with all the bells and whistles as a command line application. This will always terminate the application after a call. If this is not wanted, &lt;code&gt;SystemExit&lt;/code&gt; needs to be caught.</source>
          <target state="translated">이것은 명령 줄 응용 프로그램으로 모든 종소리와 휘파람이있는 스크립트를 호출하는 방법입니다. 이렇게하면 통화 후 항상 응용 프로그램이 종료됩니다. 원하지 않는 경우 &lt;code&gt;SystemExit&lt;/code&gt; 를 포착해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc013b5ff0c5cb5b144ee886b8c94f110d06f83c" translate="yes" xml:space="preserve">
          <source>This is useful for executing small snippets of management code without having to manually configure the application.</source>
          <target state="translated">이는 애플리케이션을 수동으로 구성 할 필요없이 관리 코드의 작은 조각을 실행하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7d03112cbe505ffcd573533b559001fe8f8bb114" translate="yes" xml:space="preserve">
          <source>This is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates:</source>
          <target state="translated">이것은 매우 기본적인 청사진의 모습입니다. 이 경우 정적 템플릿의 간단한 렌더링을 수행하는 청사진을 구현하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8bde888d98ec80618c69e86986c8c5b6dc5e136c" translate="yes" xml:space="preserve">
          <source>This is where some helper functions come in handy. Keep in mind however that these functions are not only there for interactive shell usage, but also for unit testing and other situations that require a faked request context.</source>
          <target state="translated">여기에서 일부 도우미 기능이 유용합니다. 그러나 이러한 함수는 대화 형 셸 사용뿐 아니라 단위 테스트 및 가짜 요청 컨텍스트가 필요한 기타 상황을위한 것임을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="c7e6f33f620e775ba946d8b7003fd7687dba593b" translate="yes" xml:space="preserve">
          <source>This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see &lt;a href=&quot;../deploying/index#deployment&quot;&gt;Deployment Options&lt;/a&gt;.</source>
          <target state="translated">이렇게하면 매우 간단한 내장 서버가 시작됩니다. 테스트에는 충분하지만 프로덕션에서 사용하려는 것은 아닙니다. 배포 옵션은 &lt;a href=&quot;../deploying/index#deployment&quot;&gt;배포 옵션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9a6b2a87ac23327a94bfc0bbb9ae6b337c0e1bc" translate="yes" xml:space="preserve">
          <source>This macro accepts a couple of keyword arguments that are forwarded to WTForm&amp;rsquo;s field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call &lt;code&gt;render_field(form.username, class='username')&lt;/code&gt; to add a class to the input element. Note that WTForms returns standard Python unicode strings, so we have to tell Jinja2 that this data is already HTML-escaped with the &lt;code&gt;|safe&lt;/code&gt; filter.</source>
          <target state="translated">이 매크로는 필드를 렌더링하는 WTForm의 필드 함수로 전달되는 몇 가지 키워드 인수를받습니다. 키워드 인수는 HTML 속성으로 삽입됩니다. 따라서 예를 들어 &lt;code&gt;render_field(form.username, class='username')&lt;/code&gt; 를 호출 하여 입력 요소에 클래스를 추가 할 수 있습니다. WTForms는 표준 Python 유니 코드 문자열을 반환하므로이 데이터가 이미 &lt;code&gt;|safe&lt;/code&gt; 필터로 HTML 이스케이프 처리되었음을 Jinja2에 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="148961bbaa188d129234e09d949f0ab77206d08b" translate="yes" xml:space="preserve">
          <source>This means the following page in HTML5 is perfectly valid:</source>
          <target state="translated">이는 HTML5의 다음 페이지가 완벽하게 유효 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d0c14628b051dd87ce257c5b36a216b0f016fe6f" translate="yes" xml:space="preserve">
          <source>This method has to be implemented and must either return &lt;code&gt;None&lt;/code&gt; in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on &lt;a href=&quot;#flask.sessions.SessionMixin&quot;&gt;&lt;code&gt;SessionMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메서드는 구현되어야 하며 구성 오류 또는 &lt;a href=&quot;#flask.sessions.SessionMixin&quot;&gt; &lt;code&gt;SessionMixin&lt;/code&gt; &lt;/a&gt; 의 메서드 및 속성과 같은 사전을 구현하는 세션 개체의 인스턴스 또는 구성 오류로 인해로드에 실패한 경우 &lt;code&gt;None&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="51abe9bd4cf4df621c7d3cbc4f700835d5fb3a46" translate="yes" xml:space="preserve">
          <source>This method is also available by directly calling the instance of a &lt;code&gt;Command&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 &lt;code&gt;Command&lt;/code&gt; 인스턴스를 직접 호출하여 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce1af51351825fc103cbb8249c0d00a090d5430b" translate="yes" xml:space="preserve">
          <source>This method is called to create the default &lt;code&gt;OPTIONS&lt;/code&gt; response. This can be changed through subclassing to change the default behavior of &lt;code&gt;OPTIONS&lt;/code&gt; responses.</source>
          <target state="translated">이 메서드는 기본 &lt;code&gt;OPTIONS&lt;/code&gt; 응답 을 만들기 위해 호출됩니다 . &lt;code&gt;OPTIONS&lt;/code&gt; 응답 의 기본 동작을 변경하기 위해 서브 클래 싱을 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e38f0adf010a505599147af043f0577667266e1" translate="yes" xml:space="preserve">
          <source>This method is called whenever an exception occurs that should be handled. A special case is &lt;code&gt;HTTPException&lt;/code&gt; which is forwarded to the &lt;a href=&quot;#flask.Flask.handle_http_exception&quot;&gt;&lt;code&gt;handle_http_exception()&lt;/code&gt;&lt;/a&gt; method. This function will either return a response value or reraise the exception with the same traceback.</source>
          <target state="translated">이 메서드는 처리해야하는 예외가 발생할 때마다 호출됩니다. 특별한 경우는 &lt;a href=&quot;#flask.Flask.handle_http_exception&quot;&gt; &lt;code&gt;handle_http_exception()&lt;/code&gt; &lt;/a&gt; 메소드로 전달되는 &lt;code&gt;HTTPException&lt;/code&gt; 입니다 . 이 함수는 응답 값을 반환하거나 동일한 트레이스 백으로 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bb88f88821b6bb4a97c0268d99ef3bd91c6dd6f3" translate="yes" xml:space="preserve">
          <source>This now depends on the number of servers we want to set up. If we just have one application server (which the majority of applications will have), creating a command in the fabfile for this is overkill. But obviously you can do that. In that case you would probably call it &lt;code&gt;setup&lt;/code&gt; or &lt;code&gt;bootstrap&lt;/code&gt; and then pass the servername explicitly on the command line:</source>
          <target state="translated">이제 설정하려는 서버 수에 따라 다릅니다. 애플리케이션 서버가 하나만있는 경우 (대부분의 애플리케이션에 적용됨)이를 위해 fabfile에 명령을 생성하는 것은 과도합니다. 하지만 분명히 그렇게 할 수 있습니다. 이 경우 &lt;code&gt;setup&lt;/code&gt; 또는 &lt;code&gt;bootstrap&lt;/code&gt; 이라고 부르고 명령 줄에 명시 적으로 서버 이름을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ace9fe73304dbcfa089f71562dc9d47be23596d7" translate="yes" xml:space="preserve">
          <source>This of course is not that helpful for such a small example, but it&amp;rsquo;s good enough to explain the basic principle. When you have a class-based view the question comes up what &lt;code&gt;self&lt;/code&gt; points to. The way this works is that whenever the request is dispatched a new instance of the class is created and the &lt;a href=&quot;../api/index#flask.views.View.dispatch_request&quot;&gt;&lt;code&gt;dispatch_request()&lt;/code&gt;&lt;/a&gt; method is called with the parameters from the URL rule. The class itself is instantiated with the parameters passed to the &lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt;&lt;code&gt;as_view()&lt;/code&gt;&lt;/a&gt; function. For instance you can write a class like this:</source>
          <target state="translated">물론 이것은 그러한 작은 예에는 도움이되지 않지만 기본 원리를 설명하기에 충분합니다. 수업 기반의 견해가있을 때 &lt;code&gt;self&lt;/code&gt; 가 무엇을 가리키는 지 질문이 나옵니다 . 이것이 작동하는 방식은 요청이 디스패치 될 때마다 클래스의 새 인스턴스가 생성되고 &lt;a href=&quot;../api/index#flask.views.View.dispatch_request&quot;&gt; &lt;code&gt;dispatch_request()&lt;/code&gt; &lt;/a&gt; 메서드가 URL 규칙의 매개 변수와 함께 호출 된다는 것 입니다. 클래스 자체는 &lt;a href=&quot;../api/index#flask.views.View.as_view&quot;&gt; &lt;code&gt;as_view()&lt;/code&gt; &lt;/a&gt; 함수에 전달 된 매개 변수로 인스턴스화됩니다 . 예를 들어 다음과 같은 클래스를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa46890d0628d16b5ee8a4d93210b9108ba9baaa" translate="yes" xml:space="preserve">
          <source>This part of the documentation covers all the interfaces of Flask. For parts where Flask depends on external libraries, we document the most important right here and provide links to the canonical documentation.</source>
          <target state="translated">문서의이 부분은 Flask의 모든 인터페이스를 다룹니다. Flask가 외부 라이브러리에 의존하는 부분의 경우 여기에 가장 중요한 문서를 문서화하고 표준 문서에 대한 링크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6d84cc3f7287a2ee2e5c3046eb982091e418d2d9" translate="yes" xml:space="preserve">
          <source>This part of the documentation, which is mostly prose, begins with some background information about Flask, then focuses on step-by-step instructions for web development with Flask.</source>
          <target state="translated">대부분 산문 인 문서의이 부분은 Flask에 대한 배경 정보로 시작하여 Flask를 사용한 웹 개발을위한 단계별 지침에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="a0443f4192ba55338acf65e28bc1d0911a821ac2" translate="yes" xml:space="preserve">
          <source>This reads the buffered incoming data from the client into one bytestring. By default this is cached but that behavior can be changed by setting &lt;code&gt;cache&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">클라이언트에서 버퍼링 된 수신 데이터를 하나의 바이트 문자열로 읽습니다. 기본적으로 이것은 캐시되지만 &lt;code&gt;cache&lt;/code&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정하여 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2d066ef0e30256a871174ab278fbc4ffe61eae7" translate="yes" xml:space="preserve">
          <source>This reflects the &lt;code&gt;'_permanent'&lt;/code&gt; key in the dict.</source>
          <target state="translated">이것은 dict 의 &lt;code&gt;'_permanent'&lt;/code&gt; 키를 반영합니다 .</target>
        </trans-unit>
        <trans-unit id="0bf1b89d694c89fcbad9aec8321f2d4db2744ef7" translate="yes" xml:space="preserve">
          <source>This requires that you have an SMTP server set up on the same server. See the Python docs for more information about configuring the handler.</source>
          <target state="translated">이를 위해서는 동일한 서버에 SMTP 서버가 설정되어 있어야합니다. 핸들러 구성에 대한 자세한 정보는 Python 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="270175471e4ec857589b8873458b82d851e98c01" translate="yes" xml:space="preserve">
          <source>This section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine&amp;rsquo;s syntax itself, head over to the official &lt;a href=&quot;http://jinja.pocoo.org/docs/templates/&quot;&gt;Jinja2 Template Documentation&lt;/a&gt; for more information.</source>
          <target state="translated">이 섹션에서는 Jinja2가 Flask에 통합되는 방법에 대한 매우 간단한 소개 만 제공합니다. 템플릿 엔진의 구문 자체에 대한 정보를 원한다면 공식 &lt;a href=&quot;http://jinja.pocoo.org/docs/templates/&quot;&gt;Jinja2 템플릿 문서&lt;/a&gt; 에서 자세한 정보를 확인하세요.</target>
        </trans-unit>
        <trans-unit id="f25b81ad93936c67288b7d1f65590fdff1c733a8" translate="yes" xml:space="preserve">
          <source>This server is for development purposes only. It does not provide the stability, security, or performance of production WSGI servers.</source>
          <target state="translated">이 서버는 개발 목적으로 만 사용됩니다. 프로덕션 WSGI 서버의 안정성, 보안 또는 성능을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a9df7f5dbbbee76e4a132df811890b1541f2b7b" translate="yes" xml:space="preserve">
          <source>This session backend will set the &lt;a href=&quot;#flask.sessions.SecureCookieSession.modified&quot;&gt;&lt;code&gt;modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.sessions.SecureCookieSession.accessed&quot;&gt;&lt;code&gt;accessed&lt;/code&gt;&lt;/a&gt; attributes. It cannot reliably track whether a session is new (vs. empty), so &lt;code&gt;new&lt;/code&gt; remains hard coded to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">이 세션 백엔드는 &lt;a href=&quot;#flask.sessions.SecureCookieSession.modified&quot;&gt; &lt;code&gt;modified&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#flask.sessions.SecureCookieSession.accessed&quot;&gt; &lt;code&gt;accessed&lt;/code&gt; &lt;/a&gt; 속성을 설정 합니다. 세션이 새로운 것인지 (비어있는 경우) 확실하게 추적 할 수 없으므로 &lt;code&gt;new&lt;/code&gt; 는 &lt;code&gt;False&lt;/code&gt; 로 하드 코딩 된 상태로 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="d4f1608ec67c25daab64236040db8f15506c4cac" translate="yes" xml:space="preserve">
          <source>This sets up the load paths according to the settings of the virtual environment. Keep in mind that the path has to be absolute.</source>
          <target state="translated">가상 환경의 설정에 따라로드 경로를 설정합니다. 경로는 절대적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6308cf351995eb1f37faf1ec06a37f9ce49f3300" translate="yes" xml:space="preserve">
          <source>This should typically only happen when testing code that expects an active request. One option is to use the &lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt;&lt;code&gt;test client&lt;/code&gt;&lt;/a&gt; to simulate a full request. Or you can use &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;with&lt;/code&gt; block, and everything that runs in the block will have access to &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;, populated with your test data.</source>
          <target state="translated">이는 일반적으로 활성 요청을 예상하는 코드를 테스트 할 때만 발생합니다. 한 가지 옵션은 &lt;a href=&quot;../api/index#flask.Flask.test_client&quot;&gt; &lt;code&gt;test client&lt;/code&gt; &lt;/a&gt; 를 사용하여 전체 요청을 시뮬레이션하는 것입니다. 또는 &lt;code&gt;with&lt;/code&gt; 블록 에서 &lt;a href=&quot;../api/index#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있으며 블록에서 실행되는 모든 항목은 테스트 데이터로 채워진 &lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; 에&lt;/a&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f384bb732cce9a51c8f13cf90e053742c6f8c76d" translate="yes" xml:space="preserve">
          <source>This signal is sent before template rendering process. The signal is invoked with the instance of the template as &lt;code&gt;template&lt;/code&gt; and the context as dictionary (named &lt;code&gt;context&lt;/code&gt;).</source>
          <target state="translated">이 신호는 템플릿 렌더링 프로세스 전에 전송됩니다. 신호는 다음과 같이 템플릿의 인스턴스를 호출 &lt;code&gt;template&lt;/code&gt; 과 사전 (이름과 같은 컨텍스트 &lt;code&gt;context&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="30321d60bd10e50962b2db78a34f560a5109a0aa" translate="yes" xml:space="preserve">
          <source>This signal is sent right before the response is sent to the client. It is passed the response to be sent named &lt;code&gt;response&lt;/code&gt;.</source>
          <target state="translated">이 신호는 응답이 클라이언트로 전송되기 직전에 전송됩니다. 그것은 이름을 송신하는 응답 전달되는 &lt;code&gt;response&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cf67b9ba49e71aaf5208f3b0f80cd853995270e" translate="yes" xml:space="preserve">
          <source>This signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as &lt;code&gt;template&lt;/code&gt; and the context as dictionary (named &lt;code&gt;context&lt;/code&gt;).</source>
          <target state="translated">이 신호는 템플릿이 성공적으로 렌더링되었을 때 전송됩니다. 신호는 다음과 같이 템플릿의 인스턴스를 호출 &lt;code&gt;template&lt;/code&gt; 과 사전 (이름과 같은 컨텍스트 &lt;code&gt;context&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="63814476c7961e9203086ab2baf64d53d935aee6" translate="yes" xml:space="preserve">
          <source>This signal is sent when an application context is popped. The sender is the application. This usually falls in line with the &lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt;&lt;code&gt;appcontext_tearing_down&lt;/code&gt;&lt;/a&gt; signal.</source>
          <target state="translated">이 신호는 애플리케이션 컨텍스트가 팝될 때 전송됩니다. 보낸 사람은 응용 프로그램입니다. 이것은 일반적으로 &lt;a href=&quot;#flask.appcontext_tearing_down&quot;&gt; &lt;code&gt;appcontext_tearing_down&lt;/code&gt; &lt;/a&gt; 신호 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="af983ab8cec24e5ec060b24622d536d0e1d76eb2" translate="yes" xml:space="preserve">
          <source>This signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the &lt;code&gt;g&lt;/code&gt; object.</source>
          <target state="translated">이 신호는 애플리케이션 컨텍스트가 푸시 될 때 전송됩니다. 보낸 사람은 응용 프로그램입니다. 이것은 일반적으로 정보를 일시적으로 연결하기위한 단위 테스트에 유용합니다. 예를 들어 &lt;code&gt;g&lt;/code&gt; 객체 에 리소스를 일찍 설정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21f1c7f8803d66330d20c50b6b29e110b5593d9b" translate="yes" xml:space="preserve">
          <source>This signal is sent when an exception happens during request processing. It is sent &lt;em&gt;before&lt;/em&gt; the standard exception handling kicks in and even in debug mode, where no exception handling happens. The exception itself is passed to the subscriber as &lt;code&gt;exception&lt;/code&gt;.</source>
          <target state="translated">이 신호는 요청 처리 중에 예외가 발생할 때 전송됩니다. 그것은 전송 &lt;em&gt;하기 전에&lt;/em&gt; 에서, 심지어 예외 처리가 발생하지 디버그 모드에서 표준 예외 처리 차기. 예외 자체는 구독자에게 &lt;code&gt;exception&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3a56ac4353921050fea906e63a972f356f7dae0" translate="yes" xml:space="preserve">
          <source>This signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.</source>
          <target state="translated">이 신호는 앱 컨텍스트가 해체 될 때 전송됩니다. 예외가 발생하더라도 항상 호출됩니다. 현재이 신호를 수신하는 함수는 일반 분해 처리기 이후에 호출되지만 신뢰할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b438296180226526fadefc3339f0a37f8ad2af4f" translate="yes" xml:space="preserve">
          <source>This signal is sent when the application is flashing a message. The messages is sent as &lt;code&gt;message&lt;/code&gt; keyword argument and the category as &lt;code&gt;category&lt;/code&gt;.</source>
          <target state="translated">이 신호는 애플리케이션이 메시지를 깜박일 때 전송됩니다. 메시지는 다음과 같이 전송되는 &lt;code&gt;message&lt;/code&gt; 키워드 인수와 같은 범주 &lt;code&gt;category&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de256fd131d5644204d31a34a6a11c561c14bf32" translate="yes" xml:space="preserve">
          <source>This signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 신호는 요청 처리가 발생하기 전에 요청 컨텍스트가 설정 될 때 전송됩니다. 요청 컨텍스트가 이미 바인딩되어 있기 때문에 가입자는 다음과 같은 표준 글로벌 프록시를 사용하여 요청에 액세스 할 수 있습니다 &lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23d5b96fc0abcd08d44e898fb889962e7b3f74d6" translate="yes" xml:space="preserve">
          <source>This signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.</source>
          <target state="translated">이 신호는 요청이 해체 될 때 전송됩니다. 예외가 발생하더라도 항상 호출됩니다. 현재이 신호를 수신하는 함수는 일반 분해 처리기 이후에 호출되지만 신뢰할 수있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a62c8c1db62dcb425205260e56527fe973908037" translate="yes" xml:space="preserve">
          <source>This specifies that &lt;code&gt;/users/&lt;/code&gt; will be the URL for page one and &lt;code&gt;/users/page/N&lt;/code&gt; will be the URL for page &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;/users/&lt;/code&gt; 가 페이지 1의 URL이되고 &lt;code&gt;/users/page/N&lt;/code&gt; 이 페이지 &lt;code&gt;N&lt;/code&gt; 의 URL이되도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0c3d8be9b8127c58bfe70c563eaca0d5dfe04a94" translate="yes" xml:space="preserve">
          <source>This task can now be called in the background:</source>
          <target state="translated">이제이 작업을 백그라운드에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88f6d2188dc461b9d34ced5bc64ba2378724ea3d" translate="yes" xml:space="preserve">
          <source>This tells the browser to authenticate with the server using only the specific certificate key to prevent MITM attacks.</source>
          <target state="translated">이것은 MITM 공격을 방지하기 위해 특정 인증서 키만 사용하여 서버에 인증하도록 브라우저에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="a606d3b373d852c1393f5ec1fe858bcbc42622a5" translate="yes" xml:space="preserve">
          <source>This tells your operating system to listen on all public IPs.</source>
          <target state="translated">이렇게하면 운영 체제가 모든 공용 IP에서 수신하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="685903a0d50b3526f1b9a69870d1c25209077857" translate="yes" xml:space="preserve">
          <source>This template, which we&amp;rsquo;ll call &lt;code&gt;layout.html&lt;/code&gt;, defines a simple HTML skeleton document that you might use for a simple two-column page. It&amp;rsquo;s the job of &amp;ldquo;child&amp;rdquo; templates to fill the empty blocks with content:</source>
          <target state="translated">&lt;code&gt;layout.html&lt;/code&gt; 이라고 부르는이 템플릿 은 간단한 2 열 페이지에 사용할 수있는 간단한 HTML 스켈레톤 문서를 정의합니다. 빈 블록을 내용으로 채우는 것이 &quot;자식&quot;템플릿의 역할입니다.</target>
        </trans-unit>
        <trans-unit id="4f53c0131c2542f9612c58c664e5bfbf76081646" translate="yes" xml:space="preserve">
          <source>This will also be passed an &lt;code&gt;exc&lt;/code&gt; keyword argument that has a reference to the exception that caused the teardown if there was one.</source>
          <target state="translated">또한 해체를 일으킨 예외에 대한 참조가있는 경우 &lt;code&gt;exc&lt;/code&gt; 키워드 인수가 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="740681369b3b41339095a45f318c35cfcae5001f" translate="yes" xml:space="preserve">
          <source>This will link to &lt;code&gt;admin.index&lt;/code&gt; for instance in case the current request was dispatched to any other admin blueprint endpoint.</source>
          <target state="translated">예를 들어 현재 요청이 다른 관리자 청사진 끝점으로 발송 된 경우 &lt;code&gt;admin.index&lt;/code&gt; 에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="b71ce56b62b4a6141ff4e1c6fcbf7fbb8d64661a" translate="yes" xml:space="preserve">
          <source>This will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in &lt;code&gt;get_db&lt;/code&gt; instead:</source>
          <target state="translated">이것은 sqlite3 모듈이이 데이터베이스 연결에 대한 딕셔너리를 반환하게 할 것입니다. 더 간단하게는 이것을 &lt;code&gt;get_db&lt;/code&gt; 에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b99a42484154d682991f9a2ddea852601c52a17" translate="yes" xml:space="preserve">
          <source>This will reference the index function local to the current blueprint:</source>
          <target state="translated">이것은 현재 블루 프린트에 로컬 인덱스 함수를 참조합니다 :</target>
        </trans-unit>
        <trans-unit id="ba22a9098184804f2bbe59f5971c4cc7d7929d78" translate="yes" xml:space="preserve">
          <source>This will send a JSON response like this to the browser:</source>
          <target state="translated">그러면 다음과 같은 JSON 응답이 브라우저에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="df7d29e076fb2490907c4627fc46c19e9ded6279" translate="yes" xml:space="preserve">
          <source>This works exactly like the method of the same name on a regular &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt;&lt;code&gt;click.Group&lt;/code&gt;&lt;/a&gt; but it defaults the group class to &lt;a href=&quot;#flask.cli.AppGroup&quot;&gt;&lt;code&gt;AppGroup&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt; &lt;code&gt;click.Group&lt;/code&gt; &lt;/a&gt; 에서 동일한 이름의 메서드와 똑같이 작동 하지만 그룹 클래스의 기본값은 &lt;a href=&quot;#flask.cli.AppGroup&quot;&gt; &lt;code&gt;AppGroup&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c5b1bd25ca66eaefccf4709595523bed248e70ca" translate="yes" xml:space="preserve">
          <source>This works exactly like the method of the same name on a regular &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt;&lt;code&gt;click.Group&lt;/code&gt;&lt;/a&gt; but it wraps callbacks in &lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt;&lt;code&gt;with_appcontext()&lt;/code&gt;&lt;/a&gt; unless it&amp;rsquo;s disabled by passing &lt;code&gt;with_appcontext=False&lt;/code&gt;.</source>
          <target state="translated">이것은 일반 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt; &lt;code&gt;click.Group&lt;/code&gt; &lt;/a&gt; 에서 동일한 이름의 메서드와 똑같이 작동 하지만 &lt;code&gt;with_appcontext=False&lt;/code&gt; 를 전달하여 비활성화하지 않는 한 &lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt; &lt;code&gt;with_appcontext()&lt;/code&gt; &lt;/a&gt; 에서 콜백을 래핑 합니다.</target>
        </trans-unit>
        <trans-unit id="048bbc4ef88d4696e23cbb8f5215851a6a04fee9" translate="yes" xml:space="preserve">
          <source>This works similar to a regular click &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt;&lt;code&gt;Group&lt;/code&gt;&lt;/a&gt; but it changes the behavior of the &lt;a href=&quot;#flask.cli.AppGroup.command&quot;&gt;&lt;code&gt;command()&lt;/code&gt;&lt;/a&gt; decorator so that it automatically wraps the functions in &lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt;&lt;code&gt;with_appcontext()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 일반 클릭 &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.Group&quot;&gt; &lt;code&gt;Group&lt;/code&gt; &lt;/a&gt; 과 유사하게 작동 하지만 &lt;a href=&quot;#flask.cli.AppGroup.command&quot;&gt; &lt;code&gt;command()&lt;/code&gt; &lt;/a&gt; 데코레이터 의 동작을 변경 하여 함수를 &lt;a href=&quot;#flask.cli.with_appcontext&quot;&gt; &lt;code&gt;with_appcontext()&lt;/code&gt; &lt;/a&gt; 에 자동으로 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="04d82ffa704bf546ce29907b084ecf32cbf71088" translate="yes" xml:space="preserve">
          <source>This works well for the common case but it does not work well for development which is why from Flask 0.11 onwards the &lt;strong&gt;flask&lt;/strong&gt; method is recommended. The reason for this is that due to how the reload mechanism works there are some bizarre side-effects (like executing certain code twice, sometimes crashing without message or dying when a syntax or import error happens).</source>
          <target state="translated">이것은 일반적인 경우에는 잘 작동하지만 개발에는 잘 작동하지 않으므로 Flask 0.11부터 &lt;strong&gt;플라스크&lt;/strong&gt; 방법을 권장합니다. 그 이유는 다시로드 메커니즘이 작동하는 방식으로 인해 기괴한 부작용이 있기 때문입니다 (특정 코드를 두 번 실행하거나 때로는 메시지없이 충돌하거나 구문 또는 가져 오기 오류가 발생하면 죽는 등).</target>
        </trans-unit>
        <trans-unit id="a8d246cb8dba4b5b2505bbf5e67242d645dc7790" translate="yes" xml:space="preserve">
          <source>This would use Row objects rather than dicts to return the results of queries. These are &lt;code&gt;namedtuple&lt;/code&gt; s, so we can access them either by index or by key. For example, assuming we have a &lt;code&gt;sqlite3.Row&lt;/code&gt; called &lt;code&gt;r&lt;/code&gt; for the rows &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;FirstName&lt;/code&gt;, &lt;code&gt;LastName&lt;/code&gt;, and &lt;code&gt;MiddleInitial&lt;/code&gt;:</source>
          <target state="translated">쿼리 결과를 반환하기 위해 dicts가 아닌 Row 개체를 사용합니다. 이것들은 &lt;code&gt;namedtuple&lt;/code&gt; 이므로 인덱스 나 키로 접근 할 수 있습니다. 예를 들어, &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;FirstName&lt;/code&gt; , &lt;code&gt;LastName&lt;/code&gt; 및 &lt;code&gt;MiddleInitial&lt;/code&gt; 행에 대해 &lt;code&gt;r&lt;/code&gt; 이라는 &lt;code&gt;sqlite3.Row&lt;/code&gt; 가 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c4c878a67ee574af9969b64cc6b404d8760885ff" translate="yes" xml:space="preserve">
          <source>Thread Locals</source>
          <target state="translated">스레드 지역</target>
        </trans-unit>
        <trans-unit id="4f13d81133b998892b6e7fb45730343862ff8863" translate="yes" xml:space="preserve">
          <source>Thread-Locals in Flask</source>
          <target state="translated">Flask의 스레드 로컬</target>
        </trans-unit>
        <trans-unit id="a05b908e90b584ff0a2935d00857fc4cef6f217f" translate="yes" xml:space="preserve">
          <source>Threaded mode is enabled by default.</source>
          <target state="translated">스레드 모드는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="bd1ed9d20cc0d2af2d08a4ca307a4057dede220c" translate="yes" xml:space="preserve">
          <source>To access cookies you can use the &lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt;&lt;code&gt;cookies&lt;/code&gt;&lt;/a&gt; attribute. To set cookies you can use the &lt;a href=&quot;../api/index#flask.Response.set_cookie&quot;&gt;&lt;code&gt;set_cookie&lt;/code&gt;&lt;/a&gt; method of response objects. The &lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt;&lt;code&gt;cookies&lt;/code&gt;&lt;/a&gt; attribute of request objects is a dictionary with all the cookies the client transmits. If you want to use sessions, do not use the cookies directly but instead use the &lt;a href=&quot;#sessions&quot;&gt;Sessions&lt;/a&gt; in Flask that add some security on top of cookies for you.</source>
          <target state="translated">쿠키에 액세스하려면 &lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt; &lt;code&gt;cookies&lt;/code&gt; &lt;/a&gt; 속성을 사용할 수 있습니다 . 쿠키를 설정하려면 응답 객체 의 &lt;a href=&quot;../api/index#flask.Response.set_cookie&quot;&gt; &lt;code&gt;set_cookie&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다 . 요청 개체 의 &lt;a href=&quot;../api/index#flask.Request.cookies&quot;&gt; &lt;code&gt;cookies&lt;/code&gt; &lt;/a&gt; 속성은 클라이언트가 전송하는 모든 쿠키가 포함 된 사전입니다. 세션을 사용하려면 쿠키를 직접 사용하지 말고 대신 쿠키 위에 보안을 추가하는 Flask 의 &lt;a href=&quot;#sessions&quot;&gt;세션&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4b26d9eb9fc845c05b903282d2f8d57ec058f32" translate="yes" xml:space="preserve">
          <source>To access incoming request data, you can use the global &lt;code&gt;request&lt;/code&gt; object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment.</source>
          <target state="translated">들어오는 요청 데이터에 액세스하려면 전역 &lt;code&gt;request&lt;/code&gt; 개체를 사용할 수 있습니다 . Flask는 들어오는 요청 데이터를 구문 분석하고 해당 전역 개체를 통해 액세스 할 수 있도록합니다. 내부적으로 Flask는 다중 스레드 환경에있는 경우 항상 활성 스레드에 대한 올바른 데이터를 얻도록합니다.</target>
        </trans-unit>
        <trans-unit id="93c907be4da14da2a5091dcce3d29a18de7bd6f2" translate="yes" xml:space="preserve">
          <source>To access parameters submitted in the URL (&lt;code&gt;?key=value&lt;/code&gt;) you can use the &lt;a href=&quot;../api/index#flask.Request.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">URL ( &lt;code&gt;?key=value&lt;/code&gt; )에 제출 된 매개 변수에 액세스하려면 &lt;a href=&quot;../api/index#flask.Request.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="621dac882c1e3b180fff49e6a7618de84a783c99" translate="yes" xml:space="preserve">
          <source>To access the current session you can use the &lt;a href=&quot;#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; object:</source>
          <target state="translated">현재 세션에 액세스하려면 &lt;a href=&quot;#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt; 개체를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b812da36595883e5eeb8dca68fb7852151f5157d" translate="yes" xml:space="preserve">
          <source>To add WSGI middleware to your Flask application, wrap the application&amp;rsquo;s &lt;code&gt;wsgi_app&lt;/code&gt; attribute. For example, to apply Werkzeug&amp;rsquo;s &lt;code&gt;ProxyFix&lt;/code&gt; middleware for running behind Nginx:</source>
          <target state="translated">Flask 애플리케이션에 WSGI 미들웨어를 추가하려면 애플리케이션의 &lt;code&gt;wsgi_app&lt;/code&gt; 속성을 래핑 합니다. 예를 들어 Nginx 뒤에서 실행하기 위해 Werkzeug의 &lt;code&gt;ProxyFix&lt;/code&gt; 미들웨어 를 적용하려면 :</target>
        </trans-unit>
        <trans-unit id="9d505128b82e741413f1b28090a73abdb720e6e7" translate="yes" xml:space="preserve">
          <source>To be proactive about discovering and fixing bugs, you can configure a &lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SMTPHandler&quot;&gt;&lt;code&gt;logging.handlers.SMTPHandler&lt;/code&gt;&lt;/a&gt; to send an email when errors and higher are logged.</source>
          <target state="translated">사전에 버그를 발견하고 수정하려면 &lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.handlers.SMTPHandler&quot;&gt; &lt;code&gt;logging.handlers.SMTPHandler&lt;/code&gt; &lt;/a&gt; 를 구성하여 오류 이상이 기록 될 때 이메일을 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe76da13b091b052b5b37287489d80f8715fec52" translate="yes" xml:space="preserve">
          <source>To build a URL to a specific function, use the &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters.</source>
          <target state="translated">특정 함수에 대한 URL을 작성하려면 &lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 함수의 이름을 첫 번째 인수로 받아들이고 각각 ​​URL 규칙의 변수 부분에 해당하는 여러 키워드 인수를받습니다. 알 수없는 변수 부분이 쿼리 매개 변수로 URL에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a12458096d7a344e2bd4a39b0d6031b1cc8ac1d0" translate="yes" xml:space="preserve">
          <source>To convert that into a larger one, just create a new folder &lt;code&gt;yourapplication&lt;/code&gt; inside the existing one and move everything below it. Then rename &lt;code&gt;yourapplication.py&lt;/code&gt; to &lt;code&gt;__init__.py&lt;/code&gt;. (Make sure to delete all &lt;code&gt;.pyc&lt;/code&gt; files first, otherwise things would most likely break)</source>
          <target state="translated">큰 하나에 그 변환하려면, 단지 새 폴더 생성 &lt;code&gt;yourapplication&lt;/code&gt; 아래에있는 기존 및 이동 모든 내부. 그런 다음 &lt;code&gt;yourapplication.py&lt;/code&gt; 이름 을 &lt;code&gt;__init__.py&lt;/code&gt; 로 바꿉니다 . ( 먼저 모든 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 삭제해야합니다 . 그렇지 않으면 문제가 발생할 가능성이 높습니다.)</target>
        </trans-unit>
        <trans-unit id="7351c32491e91781aa14cc64a3439677be49d792" translate="yes" xml:space="preserve">
          <source>To create the database you can use the &lt;code&gt;init_db&lt;/code&gt; function:</source>
          <target state="translated">데이터베이스를 생성하려면 &lt;code&gt;init_db&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1552e2ef44bcdc258f0dff07f8e9456e2cc247b0" translate="yes" xml:space="preserve">
          <source>To declare a model that represents a Mongo document, create a class that inherits from &lt;code&gt;Document&lt;/code&gt; and declare each of the fields.</source>
          <target state="translated">Mongo 문서를 나타내는 모델을 선언하려면 &lt;code&gt;Document&lt;/code&gt; 에서 상속하는 클래스를 만들고 각 필드를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="a04e8278e482f23a25aa11a2f56acbbbe8f14a13" translate="yes" xml:space="preserve">
          <source>To define your models, just subclass the &lt;code&gt;Base&lt;/code&gt; class that was created by the code above. If you are wondering why we don&amp;rsquo;t have to care about threads here (like we did in the SQLite3 example above with the &lt;a href=&quot;../../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; object): that&amp;rsquo;s because SQLAlchemy does that for us already with the &lt;code&gt;scoped_session&lt;/code&gt;.</source>
          <target state="translated">모델을 정의하려면 위의 코드로 만든 &lt;code&gt;Base&lt;/code&gt; 클래스를 하위 클래스로 만드십시오. 왜 우리가 여기서 쓰레드를 신경 쓸 필요가 없는지 궁금하다면 (위의 SQLite3 예제에서 &lt;a href=&quot;../../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; 객체 로했던 것처럼 ) : 그것은 SQLAlchemy가 이미 &lt;code&gt;scoped_session&lt;/code&gt; 으로 우리를 위해 그렇게하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="617eb7f710ae3aabc70b2828e96591e69a824e91" translate="yes" xml:space="preserve">
          <source>To delete the database after the test, the fixture closes the file and removes it from the filesystem.</source>
          <target state="translated">테스트 후 데이터베이스를 삭제하기 위해 조명기는 파일을 닫고 파일 시스템에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="edbc05132eafa778a9a8f96fbc79cd1475a1d140" translate="yes" xml:space="preserve">
          <source>To disable the autoescape system in templates, you can use the &lt;code&gt;{%
autoescape %}&lt;/code&gt; block:</source>
          <target state="translated">템플릿에서 자동 탈출 시스템을 비활성화하려면 &lt;code&gt;{% autoescape %}&lt;/code&gt; 블록을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecfe7763079667f035480f2de104909cbbd3b532" translate="yes" xml:space="preserve">
          <source>To enable all development features (including debug mode) you can export the &lt;code&gt;FLASK_ENV&lt;/code&gt; environment variable and set it to &lt;code&gt;development&lt;/code&gt; before running the server:</source>
          <target state="translated">모든 개발 기능 (디버그 모드 포함)을 활성화하려면 &lt;code&gt;FLASK_ENV&lt;/code&gt; 환경 변수를 내보내고 서버를 실행하기 전에 &lt;code&gt;development&lt;/code&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9938f0fdba64d198c72d3f8de75439aef9a04c7" translate="yes" xml:space="preserve">
          <source>To enable such a config you just have to call into &lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이러한 구성을 활성화하려면 &lt;a href=&quot;../api/index#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt; 를 호출하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8c7eb28a8a3cd82785800c49ac2c8451234880a" translate="yes" xml:space="preserve">
          <source>To explore the data in your application, you can start an interactive Python shell with the &lt;a href=&quot;../api/index#flask.cli.shell_command&quot;&gt;&lt;code&gt;shell&lt;/code&gt;&lt;/a&gt; command. An application context will be active, and the app instance will be imported.</source>
          <target state="translated">애플리케이션의 데이터를 탐색하려면 &lt;a href=&quot;../api/index#flask.cli.shell_command&quot;&gt; &lt;code&gt;shell&lt;/code&gt; &lt;/a&gt; 명령어를 사용하여 대화 형 Python 셸을 시작할 수 있습니다 . 애플리케이션 컨텍스트가 활성화되고 앱 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0fd3592a9cca63dcac7681c39222688a86c62178" translate="yes" xml:space="preserve">
          <source>To flash a message use the &lt;a href=&quot;../api/index#flask.flash&quot;&gt;&lt;code&gt;flash()&lt;/code&gt;&lt;/a&gt; method, to get hold of the messages you can use &lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt;&lt;code&gt;get_flashed_messages()&lt;/code&gt;&lt;/a&gt; which is also available in the templates. Check out the &lt;a href=&quot;../patterns/flashing/index#message-flashing-pattern&quot;&gt;Message Flashing&lt;/a&gt; for a full example.</source>
          <target state="translated">메시지를 플래시하려면 flash &lt;a href=&quot;../api/index#flask.flash&quot;&gt; &lt;code&gt;flash()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하고, 메시지 를 가져 오려면 템플릿에서도 사용할 수있는 &lt;a href=&quot;../api/index#flask.get_flashed_messages&quot;&gt; &lt;code&gt;get_flashed_messages()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다. 전체 예제를 보려면 &lt;a href=&quot;../patterns/flashing/index#message-flashing-pattern&quot;&gt;메시지 깜박임&lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b816b46d33ad0b0902d2c4af5ecc92e61b6e91d" translate="yes" xml:space="preserve">
          <source>To flash a message with a different category, just use the second argument to the &lt;a href=&quot;../../api/index#flask.flash&quot;&gt;&lt;code&gt;flash()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">다른 범주의 메시지를 플래시하려면 flash &lt;a href=&quot;../../api/index#flask.flash&quot;&gt; &lt;code&gt;flash()&lt;/code&gt; &lt;/a&gt; 함수에 두 번째 인수를 사용하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="d35a98cf4f1cac2dc6eaa5449354434f06345604" translate="yes" xml:space="preserve">
          <source>To further reiterate this: if you have a blueprint named &lt;code&gt;admin&lt;/code&gt; and you want to render a template called &lt;code&gt;index.html&lt;/code&gt; which is specific to this blueprint, the best idea is to lay out your templates like this:</source>
          <target state="translated">이를 다시 반복하려면 : &lt;code&gt;admin&lt;/code&gt; 이라는 청사진이 있고이 청사진에 특정한 &lt;code&gt;index.html&lt;/code&gt; 이라는 템플릿을 렌더링하려는 경우 가장 좋은 방법은 다음과 같이 템플릿을 배치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a42f41d321a27499f22140ca4956aa12e4b31ba2" translate="yes" xml:space="preserve">
          <source>To generate URLs for static files, use the special &lt;code&gt;'static'&lt;/code&gt; endpoint name:</source>
          <target state="translated">정적 파일에 대한 URL을 생성하려면 특수한 &lt;code&gt;'static'&lt;/code&gt; 엔드 포인트 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7766aaf6770c2635d1f681195492db0d16d070c0" translate="yes" xml:space="preserve">
          <source>To go from Unicode into a specific charset such as UTF-8 you can use the &lt;code&gt;unicode.encode()&lt;/code&gt; method:</source>
          <target state="translated">유니 코드에서 UTF-8과 같은 특정 문자 &lt;code&gt;unicode.encode()&lt;/code&gt; 하려면 unicode.encode () 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86d26dae4df8fae537e133954dc773bbd4f2c469" translate="yes" xml:space="preserve">
          <source>To help deployment tools you can activate support for automatic reloading. Whenever something changes the &lt;code&gt;.wsgi&lt;/code&gt; file, &lt;code&gt;mod_wsgi&lt;/code&gt; will reload all the daemon processes for us.</source>
          <target state="translated">배포 도구를 돕기 위해 자동 다시로드 지원을 활성화 할 수 있습니다. &lt;code&gt;.wsgi&lt;/code&gt; 파일이 변경 될 때마다 &lt;code&gt;mod_wsgi&lt;/code&gt; 는 모든 데몬 프로세스를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="c65e52cfad61d22c99212ea16b3007ad1db7cbb4" translate="yes" xml:space="preserve">
          <source>To inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app:</source>
          <target state="translated">템플릿의 컨텍스트에 새 변수를 자동으로 삽입하기 위해 컨텍스트 프로세서가 Flask에 존재합니다. 컨텍스트 프로세서는 템플릿이 렌더링되기 전에 실행되며 템플릿 컨텍스트에 새 값을 삽입 할 수 있습니다. 컨텍스트 프로세서는 사전을 반환하는 함수입니다. 그런 다음이 사전의 키와 값이 앱의 모든 템플릿에 대해 템플릿 컨텍스트와 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="a822b2a4eba7f3d869b6903c17c94bd84d3e9cda" translate="yes" xml:space="preserve">
          <source>To insert data you can use the &lt;code&gt;insert&lt;/code&gt; method. We have to get a connection first so that we can use a transaction:</source>
          <target state="translated">데이터를 삽입하기 위해 당신이 사용할 수있는 &lt;code&gt;insert&lt;/code&gt; 방법. 트랜잭션을 사용할 수 있도록 먼저 연결을 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="befca72bc129b7178d70685483257779431b3651" translate="yes" xml:space="preserve">
          <source>To install your application (ideally into a virtualenv) just run the &lt;code&gt;setup.py&lt;/code&gt; script with the &lt;code&gt;install&lt;/code&gt; parameter. It will install your application into the virtualenv&amp;rsquo;s site-packages folder and also download and install all dependencies:</source>
          <target state="translated">애플리케이션을 설치하려면 (이상적으로는 virtualenv에) &lt;code&gt;install&lt;/code&gt; 매개 변수 와 함께 &lt;code&gt;setup.py&lt;/code&gt; 스크립트를 실행하십시오 . 응용 프로그램을 virtualenv의 site-packages 폴더에 설치하고 모든 종속성을 다운로드하여 설치합니다.</target>
        </trans-unit>
        <trans-unit id="484c14f1d3c0d76fcc5a407bed7bf241a6e99829" translate="yes" xml:space="preserve">
          <source>To integrate applications, &lt;a href=&quot;#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; has a hook to intercept URL build errors through &lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt;&lt;code&gt;Flask.url_build_error_handlers&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;url_for&lt;/code&gt; function results in a &lt;code&gt;BuildError&lt;/code&gt; when the current app does not have a URL for the given endpoint and values. When it does, the &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; calls its &lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt;&lt;code&gt;url_build_error_handlers&lt;/code&gt;&lt;/a&gt; if it is not &lt;code&gt;None&lt;/code&gt;, which can return a string to use as the result of &lt;code&gt;url_for&lt;/code&gt; (instead of &lt;code&gt;url_for&lt;/code&gt;&amp;rsquo;s default to raise the &lt;code&gt;BuildError&lt;/code&gt; exception) or re-raise the exception. An example:</source>
          <target state="translated">애플리케이션을 통합하기 위해 &lt;a href=&quot;#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt; &lt;code&gt;Flask.url_build_error_handlers&lt;/code&gt; 를&lt;/a&gt; 통해 URL 빌드 오류를 가로 챌 수있는 후크가 있습니다. &lt;code&gt;url_for&lt;/code&gt; A의 함수 결과 &lt;code&gt;BuildError&lt;/code&gt; 이 때 현재의 응용 프로그램은 주어진 엔드 포인트 및 값에 대한 URL이 없습니다. 이 수행되면, &lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt; 그 호출 &lt;a href=&quot;#flask.Flask.url_build_error_handlers&quot;&gt; &lt;code&gt;url_build_error_handlers&lt;/code&gt; 을&lt;/a&gt; 그렇지 않는 경우 &lt;code&gt;None&lt;/code&gt; 의 결과로 사용하는 문자열을 반환 할 수 있습니다, &lt;code&gt;url_for&lt;/code&gt; (대신 &lt;code&gt;url_for&lt;/code&gt; 인상하기의 기본 &lt;code&gt;BuildError&lt;/code&gt; 의 또는 예외를 다시 인상 예외). 예 :</target>
        </trans-unit>
        <trans-unit id="cf6214cd7590455bcab5a6a311902e638580fd66" translate="yes" xml:space="preserve">
          <source>To pass variable parts to the SQL statement, use a question mark in the statement and pass in the arguments as a list. Never directly add them to the SQL statement with string formatting because this makes it possible to attack the application using &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injections&lt;/a&gt;.</source>
          <target state="translated">SQL 문에 변수 부분을 전달하려면 문에 물음표를 사용하고 인수를 목록으로 전달합니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL 삽입을&lt;/a&gt; 사용하여 응용 프로그램을 공격 할 수 있으므로 문자열 형식을 사용하여 SQL 문에 직접 추가하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="ec5a5f74702dd95d4e7a845702eba953e569ee84" translate="yes" xml:space="preserve">
          <source>To prevent this, you&amp;rsquo;ll need to set the &lt;a href=&quot;#security-csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt; response header.</source>
          <target state="translated">이를 방지하려면 &lt;a href=&quot;#security-csp&quot;&gt;CSP (콘텐츠 보안 정책)&lt;/a&gt; 응답 헤더 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3119d63c0272400ae0b58e3bd2e8d1d9ce954eb3" translate="yes" xml:space="preserve">
          <source>To query your database, you use the engine directly or use a connection:</source>
          <target state="translated">데이터베이스를 쿼리하려면 엔진을 직접 사용하거나 연결을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="704e2160429f4da487552c86de50b136105bb4f8" translate="yes" xml:space="preserve">
          <source>To quickly open sources from this folder you can use the &lt;a href=&quot;../api/index#flask.Blueprint.open_resource&quot;&gt;&lt;code&gt;open_resource()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이 폴더에서 소스를 빠르게 열려면 &lt;a href=&quot;../api/index#flask.Blueprint.open_resource&quot;&gt; &lt;code&gt;open_resource()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce37f0fb86710f94c114ddfaf1395b5873e7e9c4" translate="yes" xml:space="preserve">
          <source>To redirect a user to another endpoint, use the &lt;a href=&quot;../api/index#flask.redirect&quot;&gt;&lt;code&gt;redirect()&lt;/code&gt;&lt;/a&gt; function; to abort a request early with an error code, use the &lt;a href=&quot;../api/index#flask.abort&quot;&gt;&lt;code&gt;abort()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">사용자를 다른 끝점으로 리디렉션하려면 redirect &lt;a href=&quot;../api/index#flask.redirect&quot;&gt; &lt;code&gt;redirect()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 . 오류 코드로 요청을 조기에 &lt;a href=&quot;../api/index#flask.abort&quot;&gt; &lt;code&gt;abort()&lt;/code&gt; &lt;/a&gt; 하려면 abort () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="11df7bdb0ab8dab0067f6e4b9634162320857669" translate="yes" xml:space="preserve">
          <source>To register an error handler, use the &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">오류 핸들러를 등록하려면 &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="55db3e9d5a71adf8cb2a37301e4f64c447cada25" translate="yes" xml:space="preserve">
          <source>To render a template you can use the &lt;a href=&quot;../api/index#flask.render_template&quot;&gt;&lt;code&gt;render_template()&lt;/code&gt;&lt;/a&gt; method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here&amp;rsquo;s a simple example of how to render a template:</source>
          <target state="translated">템플릿을 렌더링하려면 &lt;a href=&quot;../api/index#flask.render_template&quot;&gt; &lt;code&gt;render_template()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 . 여러분이해야 할 일은 템플릿의 이름과 템플릿 엔진에 키워드 인자로 전달할 변수를 제공하는 것뿐입니다. 다음은 템플릿을 렌더링하는 방법에 대한 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="89852e42ea0dd6de7cefcf4d3a7ff383decef7e2" translate="yes" xml:space="preserve">
          <source>To replace the session interface on an application all you have to do is to assign &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt;&lt;code&gt;flask.Flask.session_interface&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">응용 프로그램에서 세션 인터페이스를 교체하려면 &lt;a href=&quot;#flask.Flask.session_interface&quot;&gt; &lt;code&gt;flask.Flask.session_interface&lt;/code&gt; &lt;/a&gt; 를 할당하기 만하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="88ddea77b1adaf28c6fc2c7cc07594c546ee3c5e" translate="yes" xml:space="preserve">
          <source>To run such an application, you can use the &lt;strong&gt;flask&lt;/strong&gt; command:</source>
          <target state="translated">이러한 응용 프로그램을 실행하려면 &lt;strong&gt;flask&lt;/strong&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c292b2cfd2f5284d0e125ad58099be01c7125d0d" translate="yes" xml:space="preserve">
          <source>To run the application you can either use the &lt;strong&gt;flask&lt;/strong&gt; command or python&amp;rsquo;s &lt;code&gt;-m&lt;/code&gt; switch with Flask. Before you can do that you need to tell your terminal the application to work with by exporting the &lt;code&gt;FLASK_APP&lt;/code&gt; environment variable:</source>
          <target state="translated">응용 프로그램을 실행하려면 &lt;strong&gt;flask&lt;/strong&gt; 명령을 사용하거나 Flask와 함께 python의 &lt;code&gt;-m&lt;/code&gt; 스위치를 사용할 수 있습니다 . 이를 수행하기 전에 &lt;code&gt;FLASK_APP&lt;/code&gt; 환경 변수를 내 보내어 응용 프로그램이 작동하도록 터미널에 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="2c86414bed10fbdff55ce3b53f322730faff1038" translate="yes" xml:space="preserve">
          <source>To run your application you need a &lt;code&gt;yourapplication.wsgi&lt;/code&gt; file. This file contains the code &lt;code&gt;mod_wsgi&lt;/code&gt; is executing on startup to get the application object. The object called &lt;code&gt;application&lt;/code&gt; in that file is then used as application.</source>
          <target state="translated">애플리케이션을 실행하려면 &lt;code&gt;yourapplication.wsgi&lt;/code&gt; 파일 이 필요 합니다. 이 파일에는 응용 프로그램 개체를 가져 오기 위해 시작시 &lt;code&gt;mod_wsgi&lt;/code&gt; 가 실행 하는 코드 가 포함되어 있습니다 . 그러면 해당 파일에서 &lt;code&gt;application&lt;/code&gt; 이라는 개체가 응용 프로그램 으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6eb5820888b69629537c0389aab12263c5f14443" translate="yes" xml:space="preserve">
          <source>To setup a new server you would roughly do these steps:</source>
          <target state="translated">새 서버를 설정하려면 대략 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f9ef209a6b01aa558f49d827a62a2a159258935f" translate="yes" xml:space="preserve">
          <source>To share data that is valid for one request only from one function to another, a global variable is not good enough because it would break in threaded environments. Flask provides you with a special object that ensures it is only valid for the active request and that will return different values for each request. In a nutshell: it does the right thing, like it does for &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">한 함수에서 다른 함수로만 하나의 요청에 유효한 데이터를 공유하려면 전역 변수가 스레드 환경에서 중단되기 때문에 충분하지 않습니다. Flask는 활성 요청에 대해서만 유효하고 각 요청에 대해 서로 다른 값을 반환하는 특수 개체를 제공합니다. 간단히 말해서 &lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt; 에서처럼 올바른 일을 합니다.</target>
        </trans-unit>
        <trans-unit id="b92d75b4d5a6e5c6a7dd4ffc865e69b2b1f22b46" translate="yes" xml:space="preserve">
          <source>To shutdown a request, you need to trick a bit before the after request functions (triggered by &lt;a href=&quot;../api/index#flask.Flask.process_response&quot;&gt;&lt;code&gt;process_response()&lt;/code&gt;&lt;/a&gt;) operate on a response object:</source>
          <target state="translated">요청을 종료하려면 요청 후 함수 ( &lt;a href=&quot;../api/index#flask.Flask.process_response&quot;&gt; &lt;code&gt;process_response()&lt;/code&gt; &lt;/a&gt; 에 의해 트리거 됨 )가 응답 객체에서 작동 하기 전에 약간의 속임수가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="be13ab9ab1cb83c668628ec6ddb741e0e3e2506f" translate="yes" xml:space="preserve">
          <source>To subscribe to a signal, you can use the &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.disconnect&quot;&gt;&lt;code&gt;disconnect()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">신호를 구독하려면 신호의 &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 . 첫 번째 인수는 신호가 방출 될 때 호출되어야하는 함수이고 선택적 두 번째 인수는 송신자를 지정합니다. 신호 구독을 취소하려면 &lt;a href=&quot;https://pythonhosted.org/blinker/index.html#blinker.base.Signal.disconnect&quot;&gt; &lt;code&gt;disconnect()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bec3dbd348720352fd046a06c9618afaa811067" translate="yes" xml:space="preserve">
          <source>To switch Flask to the development environment and enable debug mode, set &lt;code id=&quot;index-4&quot;&gt;FLASK_ENV&lt;/code&gt;:</source>
          <target state="translated">Flask를 개발 환경으로 전환하고 디버그 모드를 활성화하려면 &lt;code id=&quot;index-4&quot;&gt;FLASK_ENV&lt;/code&gt; 를 설정 합니다 .</target>
        </trans-unit>
        <trans-unit id="ed842eff799c3ef4a6df84ac92bedcb63ead05b7" translate="yes" xml:space="preserve">
          <source>To update multiple keys at once you can use the &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.update&quot;&gt;&lt;code&gt;dict.update()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">한 번에 여러 키를 업데이트하려면 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.update&quot;&gt; &lt;code&gt;dict.update()&lt;/code&gt; &lt;/a&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fce4f4f3c6ccfcc68d89b4b50d8c2835231a5012" translate="yes" xml:space="preserve">
          <source>To use SQLAlchemy in a declarative way with your application, you just have to put the following code into your application module. Flask will automatically remove database sessions at the end of the request or when the application shuts down:</source>
          <target state="translated">애플리케이션에서 선언적 방식으로 SQLAlchemy를 사용하려면 애플리케이션 모듈에 다음 코드를 추가하기 만하면됩니다. Flask는 요청이 끝나거나 애플리케이션이 종료 될 때 데이터베이스 세션을 자동으로 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f3de54306a7a8c4c4ce40732e1b9c320a5fc9873" translate="yes" xml:space="preserve">
          <source>To use Sentry you need to install the &lt;code&gt;sentry-sdk&lt;/code&gt; client with extra &lt;code&gt;flask&lt;/code&gt; dependencies:</source>
          <target state="translated">Sentry를 사용하려면 추가 &lt;code&gt;flask&lt;/code&gt; 종속성이 있는 &lt;code&gt;sentry-sdk&lt;/code&gt; 클라이언트 를 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a85b68d89c59e497538c13d04e2859d992ab11d" translate="yes" xml:space="preserve">
          <source>To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the &lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator is the outermost.</source>
          <target state="translated">데코레이터를 사용하려면 뷰 함수에 가장 안쪽 데코레이터로 적용합니다. 추가 데코레이터를 적용 할 때 항상 &lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 데코레이터가 가장 바깥 쪽 이라는 것을 기억하십시오 .</target>
        </trans-unit>
        <trans-unit id="c51bb9aa951ba13a62b3530e77baa79bf4d5ae32" translate="yes" xml:space="preserve">
          <source>To use this with Flask, wrap the app object with the middleware:</source>
          <target state="translated">Flask와 함께 사용하려면 미들웨어로 앱 개체를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="130a013fc92ef6fe552ebe43fb5089da049d2a21" translate="yes" xml:space="preserve">
          <source>To use this, all you need to do is to hook the calculating stream in before the request starts consuming data. (Eg: be careful accessing &lt;code&gt;request.form&lt;/code&gt; or anything of that nature. &lt;code&gt;before_request_handlers&lt;/code&gt; for instance should be careful not to access it).</source>
          <target state="translated">이를 사용하려면 요청이 데이터 소비를 시작하기 전에 계산 스트림을 연결하기 만하면됩니다. (예 : &lt;code&gt;request.form&lt;/code&gt; 또는 그 특성 에 액세스하는 데주의하십시오 . 예를 들어 &lt;code&gt;before_request_handlers&lt;/code&gt; 는 액세스하지 않도록주의해야합니다).</target>
        </trans-unit>
        <trans-unit id="cb1070677e443d2c3f2643dcfeaed5987d6da4f1" translate="yes" xml:space="preserve">
          <source>Tries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named &lt;code&gt;instance&lt;/code&gt; next to your main file or the package.</source>
          <target state="translated">응용 프로그램 클래스의 생성자에 제공되지 않은 경우 인스턴스 경로를 찾으려고합니다. 기본적으로 기본 파일 또는 패키지 옆에 &lt;code&gt;instance&lt;/code&gt; 라는 폴더의 경로를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="064ec595836541fdcd69d60534f2d709b5723b20" translate="yes" xml:space="preserve">
          <source>Trusting Headers</source>
          <target state="translated">신뢰 헤더</target>
        </trans-unit>
        <trans-unit id="2e15aea469fb18f944108235f06c502c3941d7d8" translate="yes" xml:space="preserve">
          <source>Try to always pick a good sender. If you have a class that is emitting a signal, pass &lt;code&gt;self&lt;/code&gt; as sender. If you are emitting a signal from a random function, you can pass &lt;code&gt;current_app._get_current_object()&lt;/code&gt; as sender.</source>
          <target state="translated">항상 좋은 발신자를 선택하십시오. 신호를 내보내는 클래스가있는 경우 &lt;code&gt;self&lt;/code&gt; 를 보낸 사람으로 전달 합니다. 임의 함수에서 신호를 내보내는 경우 &lt;code&gt;current_app._get_current_object()&lt;/code&gt; 를 보낸 사람으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90d52a00458514c0d16ade46588691374f96864b" translate="yes" xml:space="preserve">
          <source>Trying to access a key that doesn&amp;rsquo;t exist from request dicts like &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;form&lt;/code&gt; will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt;. If unset, it is enabled in debug mode.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;form&lt;/code&gt; 과 같은 요청 딕셔너리에서 존재하지 않는 키에 액세스하려고 하면 400 Bad Request 오류 페이지가 반환됩니다. 대화 형 디버거를 얻을 수 있도록 대신 오류를 처리되지 않은 예외로 처리하려면이 옵션을 활성화하십시오. 이것은 &lt;code&gt;TRAP_HTTP_EXCEPTIONS&lt;/code&gt; 의보다 구체적인 버전입니다 . 설정하지 않으면 디버그 모드에서 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="e042bdec66ef8705a7dc314bf4bd08b69778589f" translate="yes" xml:space="preserve">
          <source>Twisted Web</source>
          <target state="translated">꼬인 웹</target>
        </trans-unit>
        <trans-unit id="69ac9ef86066ef724082e99927f52d684fa3c3f1" translate="yes" xml:space="preserve">
          <source>Twisted Web supports many flags and options, and the &lt;code&gt;twistd&lt;/code&gt; utility does as well; see &lt;code&gt;twistd -h&lt;/code&gt; and &lt;code&gt;twistd web -h&lt;/code&gt; for more information. For example, to run a Twisted Web server in the foreground, on port 8080, with an application from &lt;code&gt;myproject&lt;/code&gt;:</source>
          <target state="translated">Twisted Web은 많은 플래그와 옵션을 지원하며 &lt;code&gt;twistd&lt;/code&gt; 유틸리티도 지원합니다. 자세한 내용은 &lt;code&gt;twistd -h&lt;/code&gt; 및 &lt;code&gt;twistd web -h&lt;/code&gt; 를 참조하십시오. 예를 들어, 포 그라운드에서 포트 8080에서 &lt;code&gt;myproject&lt;/code&gt; 의 애플리케이션을 사용하여 Twisted Web 서버를 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="38ba707fd47e085f2d36a672c4b56ef31fb0e967" translate="yes" xml:space="preserve">
          <source>Typically you should not call this from your own code. A request context is automatically pushed by the &lt;a href=&quot;#flask.Flask.wsgi_app&quot;&gt;&lt;code&gt;wsgi_app()&lt;/code&gt;&lt;/a&gt; when handling a request. Use &lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt;&lt;code&gt;test_request_context()&lt;/code&gt;&lt;/a&gt; to create an environment and context instead of this method.</source>
          <target state="translated">일반적으로 자신의 코드에서 이것을 호출해서는 안됩니다. 요청 컨텍스트는 요청을 처리 할 때 &lt;a href=&quot;#flask.Flask.wsgi_app&quot;&gt; &lt;code&gt;wsgi_app()&lt;/code&gt; &lt;/a&gt; 의해 자동으로 푸시됩니다 . 이 메소드 대신 &lt;a href=&quot;#flask.Flask.test_request_context&quot;&gt; &lt;code&gt;test_request_context()&lt;/code&gt; &lt;/a&gt; 를 사용하여 환경과 컨텍스트를 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="13b5d05532b07faf15d5bc8d6e70fc16c37d4210" translate="yes" xml:space="preserve">
          <source>URL Building</source>
          <target state="translated">URL 구축</target>
        </trans-unit>
        <trans-unit id="6cfae7b9ef1be2e28c39d07fa02ec884c76b0aae" translate="yes" xml:space="preserve">
          <source>URL Route Registrations</source>
          <target state="translated">URL 경로 등록</target>
        </trans-unit>
        <trans-unit id="9c343fe26c823573d689b5e40d4a78b69116bc2a" translate="yes" xml:space="preserve">
          <source>URL building handles escaping of special characters and Unicode data transparently.</source>
          <target state="translated">URL 구축은 특수 문자 및 유니 코드 데이터의 이스케이프를 투명하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6598668044de3dea678621d0a802a16e2b0c07cc" translate="yes" xml:space="preserve">
          <source>URL processors are especially helpful when combined with blueprints. We will handle both application specific URL processors here as well as blueprint specifics.</source>
          <target state="translated">URL 프로세서는 청사진과 결합 할 때 특히 유용합니다. 여기서는 애플리케이션 별 URL 프로세서와 청사진 세부 사항을 모두 처리합니다.</target>
        </trans-unit>
        <trans-unit id="00a7c4c398f08b618e6a7ccdfe4d69a79b0e20e8" translate="yes" xml:space="preserve">
          <source>URL scheme (http or https).</source>
          <target state="translated">URL 체계 (http 또는 https).</target>
        </trans-unit>
        <trans-unit id="69365c9980b58a3de2323899e7b2f4ac1597aae4" translate="yes" xml:space="preserve">
          <source>Unfortunately, there are many ways the security of a web application can be compromised. Flask protects you against one of the most common security problems of modern web applications: cross-site scripting (XSS). Unless you deliberately mark insecure HTML as secure, Flask and the underlying Jinja2 template engine have you covered. But there are many more ways to cause security problems.</source>
          <target state="translated">불행히도 웹 애플리케이션의 보안이 손상 될 수있는 방법은 많습니다. Flask는 최신 웹 애플리케이션의 가장 일반적인 보안 문제 중 하나 인 XSS (교차 사이트 스크립팅)로부터 사용자를 보호합니다. 고의로 안전하지 않은 HTML을 보안으로 표시하지 않는 한 Flask와 기본 Jinja2 템플릿 엔진을 사용하면됩니다. 그러나 보안 문제를 일으키는 방법은 더 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="70041289ff0f2ea5e6c0475984bb067b7f0b8190" translate="yes" xml:space="preserve">
          <source>Unhandled Exceptions</source>
          <target state="translated">처리되지 않은 예외</target>
        </trans-unit>
        <trans-unit id="05af273276f2dfb2aaa6b648d23c61ed363494f6" translate="yes" xml:space="preserve">
          <source>Unicode in Flask</source>
          <target state="translated">Flask의 유니 코드</target>
        </trans-unit>
        <trans-unit id="30106e63de01ae03ae4faf05cd18ee64e950a1bb" translate="yes" xml:space="preserve">
          <source>Uninstalled module:</source>
          <target state="translated">제거 된 모듈 :</target>
        </trans-unit>
        <trans-unit id="023fc67bbfa08f8441012160fe5863ef8a339e26" translate="yes" xml:space="preserve">
          <source>Uninstalled package:</source>
          <target state="translated">제거 된 패키지 :</target>
        </trans-unit>
        <trans-unit id="1e16c081c54d2cfa3e5302be199e16e680ddd1ff" translate="yes" xml:space="preserve">
          <source>Unique URLs / Redirection Behavior</source>
          <target state="translated">고유 URL / 리디렉션 동작</target>
        </trans-unit>
        <trans-unit id="e63c6a8059140dd4c872231e2c32dcf2c6762269" translate="yes" xml:space="preserve">
          <source>Unix Bash (Linux, Mac, etc.):</source>
          <target state="translated">Unix Bash (Linux, Mac 등) :</target>
        </trans-unit>
        <trans-unit id="65d328122e54afef38b44beac4b291d86385f25e" translate="yes" xml:space="preserve">
          <source>Unix Bash, &lt;code&gt;venv/bin/activate&lt;/code&gt;:</source>
          <target state="translated">Unix Bash, &lt;code&gt;venv/bin/activate&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="d6556a94edb141c3dd2a3f95f1c09e23d76d9d1f" translate="yes" xml:space="preserve">
          <source>Unless customized, Jinja2 is configured by Flask as follows:</source>
          <target state="translated">사용자 지정하지 않는 한 Jinja2는 Flask에 의해 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8892faedefb1b4483300dec78974e0f4a4b9caeb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;input_stream&lt;/code&gt; this stream is properly guarded that you can&amp;rsquo;t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.</source>
          <target state="translated">&lt;code&gt;input_stream&lt;/code&gt; 과 달리이 스트림은 실수로 입력 길이를 초과 하여 읽을 수 없도록 적절히 보호됩니다. Werkzeug는 내부적으로 항상이 스트림을 참조하여 데이터를 읽어이 객체를 필터링을 수행하는 스트림으로 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff09f86459eb75462db6bc0d8857a8d0a8c27945" translate="yes" xml:space="preserve">
          <source>Unsure what that &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt; object is? It&amp;rsquo;s something in which you can store information for your own needs, check the documentation of that object (&lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;) and the &lt;a href=&quot;../patterns/sqlite3/index#sqlite3&quot;&gt;Using SQLite 3 with Flask&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; 개체가 무엇인지 확실하지 않습니까? 자신의 필요에 맞는 정보를 저장할 수 있습니다. 자세한 내용은 해당 객체 ( &lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; ) 의 문서 및 &lt;a href=&quot;../patterns/sqlite3/index#sqlite3&quot;&gt;Flask와 함께 SQLite 3 사용&lt;/a&gt; 을 확인하세요.</target>
        </trans-unit>
        <trans-unit id="e63bd9653bea617f92b8ec34e72d810c6c75b909" translate="yes" xml:space="preserve">
          <source>Update the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.</source>
          <target state="translated">일반적으로 사용되는 몇 가지 변수로 템플릿 컨텍스트를 업데이트합니다. 이것은 request, session, config 및 g를 템플릿 컨텍스트뿐만 아니라 템플릿 컨텍스트 프로세서가 주입하려는 모든 항목에 주입합니다. Flask 0.6부터 컨텍스트 프로세서가 동일한 키를 가진 값을 반환하기로 결정하면 컨텍스트의 원래 값이 재정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6cff59697edfb27029babcd747574af5e98c198" translate="yes" xml:space="preserve">
          <source>Updates a single user</source>
          <target state="translated">단일 사용자 업데이트</target>
        </trans-unit>
        <trans-unit id="dedaad5adeb05d2c5ca2960618f1cfd3ec1be5ac" translate="yes" xml:space="preserve">
          <source>Updates the config like &lt;code&gt;update()&lt;/code&gt; ignoring items with non-upper keys.</source>
          <target state="translated">상위 키가 아닌 항목을 무시하고 &lt;code&gt;update()&lt;/code&gt; 와 같은 구성을 업데이트 합니다.</target>
        </trans-unit>
        <trans-unit id="cf76c75ba18ce13a14e013ebc65243cff6fdd377" translate="yes" xml:space="preserve">
          <source>Updates the values from the given object. An object can be of one of the following two types:</source>
          <target state="translated">주어진 개체에서 값을 업데이트합니다. 객체는 다음 두 가지 유형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b529d89e45de502bf3f072f4116830049480c8" translate="yes" xml:space="preserve">
          <source>Updates the values in the config from a JSON file. This function behaves as if the JSON object was a dictionary and passed to the &lt;a href=&quot;#flask.Config.from_mapping&quot;&gt;&lt;code&gt;from_mapping()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">JSON 파일에서 구성의 값을 업데이트합니다. 이 함수는 JSON 객체가 사전이고 &lt;a href=&quot;#flask.Config.from_mapping&quot;&gt; &lt;code&gt;from_mapping()&lt;/code&gt; &lt;/a&gt; 함수에 전달 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5d4ed68ff32f747c1cd8385a4f8eb1ee0640e590" translate="yes" xml:space="preserve">
          <source>Updates the values in the config from a Python file. This function behaves as if the file was imported as module with the &lt;a href=&quot;#flask.Config.from_object&quot;&gt;&lt;code&gt;from_object()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Python 파일에서 구성의 값을 업데이트합니다. 이 함수는 파일을 &lt;a href=&quot;#flask.Config.from_object&quot;&gt; &lt;code&gt;from_object()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 모듈로 가져온 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2605a6749654fbaf5ef309b0bae9ea3d105db9e4" translate="yes" xml:space="preserve">
          <source>Upgrading to Newer Releases</source>
          <target state="translated">최신 릴리스로 업그레이드</target>
        </trans-unit>
        <trans-unit id="76c1699688a1d4877c098b406b7d0feb8e4c64d9" translate="yes" xml:space="preserve">
          <source>Upload Progress Bars</source>
          <target state="translated">진행률 표시 줄 업로드</target>
        </trans-unit>
        <trans-unit id="4d3c89ffcc90ad2ed133dab31e32cb6194549ac0" translate="yes" xml:space="preserve">
          <source>Upload a new &lt;code&gt;application.wsgi&lt;/code&gt; file to the server and the configuration file for the application (eg: &lt;code&gt;application.cfg&lt;/code&gt;)</source>
          <target state="translated">새 &lt;code&gt;application.wsgi&lt;/code&gt; 파일을 서버에 업로드하고 애플리케이션 의 구성 파일 (예 : &lt;code&gt;application.cfg&lt;/code&gt; )을 업로드합니다 .</target>
        </trans-unit>
        <trans-unit id="065bd038e566243f5546d7980c58a2be8219ade5" translate="yes" xml:space="preserve">
          <source>Uploaded files are stored in memory or at a temporary location on the filesystem. You can access those files by looking at the &lt;code&gt;files&lt;/code&gt; attribute on the request object. Each uploaded file is stored in that dictionary. It behaves just like a standard Python &lt;code&gt;file&lt;/code&gt; object, but it also has a &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; method that allows you to store that file on the filesystem of the server. Here is a simple example showing how that works:</source>
          <target state="translated">업로드 된 파일은 메모리 또는 파일 시스템의 임시 위치에 저장됩니다. 요청 개체 의 &lt;code&gt;files&lt;/code&gt; 속성을 확인하여 해당 파일에 액세스 할 수 있습니다 . 업로드 된 각 파일은 해당 사전에 저장됩니다. 표준 Python &lt;code&gt;file&lt;/code&gt; 객체 처럼 작동 하지만 서버의 파일 시스템에 해당 파일을 저장할 수 있는 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 메서드도 있습니다. 다음은 작동 방식을 보여주는 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="943e26649b772824ba55708d2fd502f15bc84dd0" translate="yes" xml:space="preserve">
          <source>Uploading Files</source>
          <target state="translated">파일 업로드</target>
        </trans-unit>
        <trans-unit id="a4dc156f1123229f489136c1b679228a7e504a57" translate="yes" xml:space="preserve">
          <source>Usage in Views</source>
          <target state="translated">보기에서의 사용</target>
        </trans-unit>
        <trans-unit id="ff391bd34c07e4e0118919461472326cec1fdff6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../api/index#flask.Flask.shell_context_processor&quot;&gt;&lt;code&gt;shell_context_processor()&lt;/code&gt;&lt;/a&gt; to add other automatic imports.</source>
          <target state="translated">다른 자동 가져 오기를 추가 하려면 &lt;a href=&quot;../api/index#flask.Flask.shell_context_processor&quot;&gt; &lt;code&gt;shell_context_processor()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4932654a1f49f282baa9773400511de8d3b4e599" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;itsdangerous.TimedSerializer&lt;/code&gt; to sign and validate other cookie values (or any values that need secure signatures).</source>
          <target state="translated">&lt;code&gt;itsdangerous.TimedSerializer&lt;/code&gt; 를 사용 하여 다른 쿠키 값 (또는 보안 서명이 필요한 모든 값)에 서명하고 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="9adcbc78a5d7f9ce777a41b5671c32e5ca319b93" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;with&lt;/code&gt; block to push the context, which will make &lt;a href=&quot;#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; point at the request for the created environment.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록을 사용 하여 컨텍스트를 푸시 하면 생성 된 환경에 대한 요청에서 &lt;a href=&quot;#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 지점이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d2c0bbc423e751c6a1d36bb16286aa4a14756df" translate="yes" xml:space="preserve">
          <source>Use a tool like &lt;a href=&quot;https://www.fabfile.org/&quot;&gt;fabric&lt;/a&gt; in production to push code and configurations separately to the production server(s). For some details about how to do that, head over to the &lt;a href=&quot;../patterns/fabric/index#fabric-deployment&quot;&gt;Deploying with Fabric&lt;/a&gt; pattern.</source>
          <target state="translated">프로덕션에서 &lt;a href=&quot;https://www.fabfile.org/&quot;&gt;패브릭&lt;/a&gt; 과 같은 도구를 사용하여 코드와 구성을 프로덕션 서버에 별도로 푸시합니다. 이를 수행하는 방법에 대한 세부 사항은 &lt;a href=&quot;../patterns/fabric/index#fabric-deployment&quot;&gt;Fabric&lt;/a&gt; 패턴으로 배치로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="953a7fc5851c23d07844eae60c7f119f3a233621" translate="yes" xml:space="preserve">
          <source>Use a virtual environment to manage the dependencies for your project, both in development and in production.</source>
          <target state="translated">가상 환경을 사용하여 개발 및 프로덕션 모두에서 프로젝트의 종속성을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="9d056cf2bffbd094bc5cf3578463f963f5ee511d" translate="yes" xml:space="preserve">
          <source>Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you.</source>
          <target state="translated">환경 변수를 사용하여 구성간에 전환하십시오. 이 작업은 Python 인터프리터 외부에서 수행 할 수 있으며 코드를 전혀 건드리지 않고도 다른 구성간에 빠르고 쉽게 전환 할 수 있기 때문에 개발 및 배포가 훨씬 쉬워집니다. 여러 프로젝트에서 자주 작업하는 경우 가상 환경을 활성화하고 개발 구성을 내보내는 소싱 용 스크립트를 직접 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8804ea444a85e8d948b803f1d1d33e53900a14d9" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator to bind a function to a URL.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하여 함수를 URL에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="5d0a34f0054bbd84451285011a5f14f90064ed8f" translate="yes" xml:space="preserve">
          <source>Use the class &lt;code&gt;objects&lt;/code&gt; attribute to make queries. A keyword argument looks for an equal value on the field.</source>
          <target state="translated">쿼리를 만들 려면 클래스 &lt;code&gt;objects&lt;/code&gt; 속성을 사용하십시오 . 키워드 인수는 필드에서 동일한 값을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="394dfd225f6710f4b932b0a967a9da46bf13c16d" translate="yes" xml:space="preserve">
          <source>Use this scheme for generating external URLs when not in a request context.</source>
          <target state="translated">요청 컨텍스트에 있지 않을 때 외부 URL을 생성하려면이 체계를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bbf8d7f6eaaa5f4d198daab7f63993733ff2d0ce" translate="yes" xml:space="preserve">
          <source>Used by session backends to determine if a &lt;code&gt;Set-Cookie&lt;/code&gt; header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the &lt;code&gt;SESSION_REFRESH_EACH_REQUEST&lt;/code&gt; config is true, the cookie is always set.</source>
          <target state="translated">이 응답에 대해이 세션 쿠키에 &lt;code&gt;Set-Cookie&lt;/code&gt; 헤더를 설정해야하는지 여부를 결정하기 위해 세션 백엔드에서 사용됩니다 . 세션이 수정 된 경우 쿠키가 설정됩니다. 세션이 영구적이고 &lt;code&gt;SESSION_REFRESH_EACH_REQUEST&lt;/code&gt; 구성이 true이면 쿠키가 항상 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa1c92c5ba844472ba11e0f24b92c62160cfe538" translate="yes" xml:space="preserve">
          <source>Used to create the config attribute by the Flask constructor. The &lt;code&gt;instance_relative&lt;/code&gt; parameter is passed in from the constructor of Flask (there named &lt;code&gt;instance_relative_config&lt;/code&gt;) and indicates if the config should be relative to the instance path or the root path of the application.</source>
          <target state="translated">Flask 생성자에서 구성 속성을 만드는 데 사용됩니다. &lt;code&gt;instance_relative&lt;/code&gt; 파라미터 플라스크 (이 명명 생성자에서 전달 &lt;code&gt;instance_relative_config&lt;/code&gt; ) 및 구성은 예 경로 또는 응용 프로그램의 루트 경로에 대하여되어야 하는지를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="55d94821286572aa212d68fcce4d7f8a4c368304" translate="yes" xml:space="preserve">
          <source>Useful Functions and Classes</source>
          <target state="translated">유용한 기능과 클래스</target>
        </trans-unit>
        <trans-unit id="ea3159ece1b30f0a353cbfdd4607304374d1ab0d" translate="yes" xml:space="preserve">
          <source>Useful Internals</source>
          <target state="translated">유용한 내부</target>
        </trans-unit>
        <trans-unit id="cdbcc85b59e2fa3bd5873c0d45ca407de2a4f1a5" translate="yes" xml:space="preserve">
          <source>User&amp;rsquo;s Guide</source>
          <target state="translated">사용자 가이드</target>
        </trans-unit>
        <trans-unit id="c3f04f1f0861787d5cf121bd553081654560b497" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; if it is configured, otherwise falls back to detecting the domain based on &lt;code&gt;SERVER_NAME&lt;/code&gt;.</source>
          <target state="translated">구성된 경우 &lt;code&gt;SESSION_COOKIE_DOMAIN&lt;/code&gt; 을 사용 하고, 그렇지 않으면 &lt;code&gt;SERVER_NAME&lt;/code&gt; 을 기반으로 도메인을 감지하도록 폴백 합니다.</target>
        </trans-unit>
        <trans-unit id="6d77efc15638aea2259c996f3e70e71b3ca59abd" translate="yes" xml:space="preserve">
          <source>Uses the &lt;code&gt;app2&lt;/code&gt; Flask instance in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 에서 &lt;code&gt;app2&lt;/code&gt; Flask 인스턴스를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e690d0122228c9ccc000118916dfe735e74c8003" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy&lt;/a&gt;, as an example, you should not do something along those lines:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy를&lt;/a&gt; 사용하면 다음과 같은 작업을 수행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="aa651d27cac34cfd9ddfaaedf3f7be0d6a42bffc" translate="yes" xml:space="preserve">
          <source>Using Applications</source>
          <target state="translated">응용 프로그램 사용</target>
        </trans-unit>
        <trans-unit id="fa10774d0e271ce1daa32ba7d67741dff0dd4dd8" translate="yes" xml:space="preserve">
          <source>Using Extensions</source>
          <target state="translated">확장 사용</target>
        </trans-unit>
        <trans-unit id="8f3a39bf26744b168a92a9dec95f273aa851d694" translate="yes" xml:space="preserve">
          <source>Using Flask Extensions</source>
          <target state="translated">Flask 확장 사용</target>
        </trans-unit>
        <trans-unit id="59171ad1690c758aab10d7ffbe8f77353f558b43" translate="yes" xml:space="preserve">
          <source>Using SQLite 3 with Flask</source>
          <target state="translated">Flask와 함께 SQLite 3 사용</target>
        </trans-unit>
        <trans-unit id="ab50f5e5004a55f81f6c1cc33064027f3f663005" translate="yes" xml:space="preserve">
          <source>Using URL Processors</source>
          <target state="translated">URL 프로세서 사용</target>
        </trans-unit>
        <trans-unit id="68523b2455f2cfaa75da6c1dfdcffe84f7651754" translate="yes" xml:space="preserve">
          <source>Using _app_ctx_stack</source>
          <target state="translated">_app_ctx_stack 사용</target>
        </trans-unit>
        <trans-unit id="54d0a04af554f5c6e119de6afe0d933caca31c6a" translate="yes" xml:space="preserve">
          <source>Using a document database like MongoDB is a common alternative to relational SQL databases. This pattern shows how to use &lt;a href=&quot;http://mongoengine.org&quot;&gt;MongoEngine&lt;/a&gt;, a document mapper library, to integrate with MongoDB.</source>
          <target state="translated">MongoDB와 같은 문서 데이터베이스를 사용하는 것은 관계형 SQL 데이터베이스의 일반적인 대안입니다. 이 패턴은 문서 매퍼 라이브러리 인 &lt;a href=&quot;http://mongoengine.org&quot;&gt;MongoEngine&lt;/a&gt; 을 사용 하여 MongoDB와 통합 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a72a4a0d027f04806694ac19f72ac5da3ad06de2" translate="yes" xml:space="preserve">
          <source>Using the environment variables as described above is recommended. While it is possible to set &lt;a href=&quot;#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; in your config or code, this is strongly discouraged. They can&amp;rsquo;t be read early by the &lt;code&gt;flask&lt;/code&gt; command, and some systems or extensions may have already configured themselves based on a previous value.</source>
          <target state="translated">위에서 설명한대로 환경 변수를 사용하는 것이 좋습니다. 구성 또는 코드에서 &lt;a href=&quot;#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; &lt;/a&gt; 를 설정할 수 있지만 이는 권장되지 않습니다. 그들은 &lt;code&gt;flask&lt;/code&gt; 명령으로 일찍 읽을 수 없으며 일부 시스템 또는 확장은 이전 값을 기반으로 이미 구성되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92a20b90af7e10a8cb54c4e913cfe44df2dc002e" translate="yes" xml:space="preserve">
          <source>Using this design pattern, no application-specific state is stored on the extension object, so one extension object can be used for multiple apps. For more information about the design of extensions refer to &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask Extension Development&lt;/a&gt;.</source>
          <target state="translated">이 디자인 패턴을 사용하면 애플리케이션 특정 상태가 확장 개체에 저장되지 않으므로 하나의 확장 개체를 여러 앱에 사용할 수 있습니다. 확장 디자인에 대한 자세한 내용은 &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask 확장 개발을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc1c502b56fb7ed2173d741dc07017b93a3f4930" translate="yes" xml:space="preserve">
          <source>Usually happens on programming errors or if the server is overloaded. A terribly good idea is to have a nice page there, because your application &lt;em&gt;will&lt;/em&gt; fail sooner or later (see also: &lt;a href=&quot;../../errorhandling/index#application-errors&quot;&gt;Application Errors&lt;/a&gt;).</source>
          <target state="translated">일반적으로 프로그래밍 오류 또는 서버가 과부하 된 경우에 발생합니다. 응용 프로그램 &lt;em&gt;이&lt;/em&gt; 조만간 실패 할 것이기 때문에 멋진 페이지를 만드는 것이 매우 좋습니다 ( &lt;a href=&quot;../../errorhandling/index#application-errors&quot;&gt;응용 프로그램 오류&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0f68bf97c736657b510dc0525880f20b4e753ec0" translate="yes" xml:space="preserve">
          <source>Usually it&amp;rsquo;s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.</source>
          <target state="translated">일반적으로 클라이언트가 서버에 메모리 문제를 일으키기 위해 수십 메가 바이트 이상을 보낼 수 있으므로 먼저 콘텐츠 길이를 확인하지 않고이 메서드를 호출하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee3573f7a3179c375fa029a209dd8e1fd304efdd" translate="yes" xml:space="preserve">
          <source>Usually there are two ways to configure the server. Either just copy the &lt;code&gt;.cgi&lt;/code&gt; into a &lt;code&gt;cgi-bin&lt;/code&gt; (and use &lt;code&gt;mod_rewrite&lt;/code&gt; or something similar to rewrite the URL) or let the server point to the file directly.</source>
          <target state="translated">일반적으로 서버를 구성하는 두 가지 방법이 있습니다. &lt;code&gt;.cgi&lt;/code&gt; 를 &lt;code&gt;cgi-bin&lt;/code&gt; 에 복사 하거나 (그리고 &lt;code&gt;mod_rewrite&lt;/code&gt; 또는 URL을 재 작성하기 위해 유사한 것을 사용 ) 서버가 파일을 직접 가리 키도록하십시오.</target>
        </trans-unit>
        <trans-unit id="6c9db0f33e8df86a9e2fd4170047aa601d973ffc" translate="yes" xml:space="preserve">
          <source>Usually you create a &lt;a href=&quot;#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; instance in your main module or in the &lt;code&gt;__init__.py&lt;/code&gt; file of your package like this:</source>
          <target state="translated">일반적으로 다음 과 같이 기본 모듈 또는 패키지 의 &lt;code&gt;__init__.py&lt;/code&gt; 파일에 &lt;a href=&quot;#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 인스턴스 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1a254ac2d222d900e45034142431497e6c61b13b" translate="yes" xml:space="preserve">
          <source>Variable Rules</source>
          <target state="translated">가변 규칙</target>
        </trans-unit>
        <trans-unit id="b6b9c9cce79cbad858deab2deb4dde87f6d49c08" translate="yes" xml:space="preserve">
          <source>Variable arguments that are unknown to the target endpoint are appended to the generated URL as query arguments. If the value of a query argument is &lt;code&gt;None&lt;/code&gt;, the whole pair is skipped. In case blueprints are active you can shortcut references to the same blueprint by prefixing the local endpoint with a dot (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">대상 엔드 포인트에 알려지지 않은 변수 인수는 생성 된 URL에 쿼리 인수로 추가됩니다. 쿼리 인수의 값이 &lt;code&gt;None&lt;/code&gt; 이면 전체 쌍을 건너 뜁니다. Blueprint가 활성화 된 경우 로컬 엔드 포인트 앞에 점 ( &lt;code&gt;.&lt;/code&gt; ) 을 붙여 동일한 Blueprint에 대한 참조를 바로 가기로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f7a411624b18078c29244d7d1ba19714505c9fc" translate="yes" xml:space="preserve">
          <source>Variable parts are passed to the view function as keyword arguments.</source>
          <target state="translated">변수 부분은 키워드 인수로 뷰 함수에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="94fb3451dd394e4d83a6168ec1c8f7ea90fe2357" translate="yes" xml:space="preserve">
          <source>Variable parts in the route can be specified with angular brackets (&lt;code&gt;/user/&amp;lt;username&amp;gt;&lt;/code&gt;). By default a variable part in the URL accepts any string without a slash however a different converter can be specified as well by using &lt;code&gt;&amp;lt;converter:name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경로의 가변 부분은 꺾쇠 괄호 ( &lt;code&gt;/user/&amp;lt;username&amp;gt;&lt;/code&gt; ) 로 지정할 수 있습니다 . 기본적으로 URL의 변수 부분은 슬래시가없는 모든 문자열을 허용하지만 &lt;code&gt;&amp;lt;converter:name&amp;gt;&lt;/code&gt; 을 사용하여 다른 변환기를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4081d2758e2b78ac5f9108f1b3c58568ba1f532e" translate="yes" xml:space="preserve">
          <source>Variables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions):</source>
          <target state="translated">변수는 값으로 제한되지 않습니다. 컨텍스트 프로세서는 또한 템플릿에서 함수를 사용할 수 있도록 만들 수 있습니다 (파이썬이 함수 전달을 허용하기 때문에) :</target>
        </trans-unit>
        <trans-unit id="a05176f61235d3c969d9c9934bdb3aec954de530" translate="yes" xml:space="preserve">
          <source>Variables set on the command line are used over those set in &lt;code&gt;.env&lt;/code&gt;, which are used over those set in &lt;code&gt;.flaskenv&lt;/code&gt;. &lt;code&gt;.flaskenv&lt;/code&gt; should be used for public variables, such as &lt;code&gt;FLASK_APP&lt;/code&gt;, while &lt;code&gt;.env&lt;/code&gt; should not be committed to your repository so that it can set private variables.</source>
          <target state="translated">명령 줄에 설정된 변수는 &lt;code&gt;.env&lt;/code&gt; 에 설정된 변수보다 사용되며 &lt;code&gt;.flaskenv&lt;/code&gt; 에 설정된 변수 보다 사용됩니다 . &lt;code&gt;.flaskenv&lt;/code&gt; 은 같은 공용 변수에 사용되어야한다 &lt;code&gt;FLASK_APP&lt;/code&gt; 동안, &lt;code&gt;.env&lt;/code&gt; 의는 비공개 변수를 설정할 수 있도록 저장소에 전념 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b801ef48bde4544f0c6bc3b66af26f71700fc254" translate="yes" xml:space="preserve">
          <source>Various pieces of code can consume the request data and preprocess it. For instance JSON data ends up on the request object already read and processed, form data ends up there as well but goes through a different code path. This seems inconvenient when you want to calculate the checksum of the incoming request data. This is necessary sometimes for some APIs.</source>
          <target state="translated">다양한 코드 조각이 요청 데이터를 사용하고이를 전처리 할 수 ​​있습니다. 예를 들어 JSON 데이터는 이미 읽고 처리 된 요청 객체에서 끝나고, 양식 데이터도 거기에서 끝나지만 다른 코드 경로를 통과합니다. 들어오는 요청 데이터의 체크섬을 계산할 때 불편 해 보입니다. 이것은 때때로 일부 API에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e3d0872296106e3000cffa85fb872e5af669a0e5" translate="yes" xml:space="preserve">
          <source>Version 0.1</source>
          <target state="translated">버전 0.1</target>
        </trans-unit>
        <trans-unit id="164ecd0042d125b561c75b19302a2c4b6d04645a" translate="yes" xml:space="preserve">
          <source>Version 0.10</source>
          <target state="translated">버전 0.10</target>
        </trans-unit>
        <trans-unit id="fa2e2ff37b4ee75634af1d71a64a7181860dfb27" translate="yes" xml:space="preserve">
          <source>Version 0.10.1</source>
          <target state="translated">버전 0.10.1</target>
        </trans-unit>
        <trans-unit id="d0b0f515ad64ca357140d4d452724c6892bbe084" translate="yes" xml:space="preserve">
          <source>Version 0.11</source>
          <target state="translated">버전 0.11</target>
        </trans-unit>
        <trans-unit id="753aec77a66df488af72cbb036b532c40217773f" translate="yes" xml:space="preserve">
          <source>Version 0.11.1</source>
          <target state="translated">버전 0.11.1</target>
        </trans-unit>
        <trans-unit id="4f4478af417dc964c1b38d03dea6990e6b59337d" translate="yes" xml:space="preserve">
          <source>Version 0.12</source>
          <target state="translated">버전 0.12</target>
        </trans-unit>
        <trans-unit id="00294dfe7244c1c8a6ae8954ef35804a4f8f3d5c" translate="yes" xml:space="preserve">
          <source>Version 0.12.1</source>
          <target state="translated">버전 0.12.1</target>
        </trans-unit>
        <trans-unit id="0426376b735575754e18cb94472bd40428064299" translate="yes" xml:space="preserve">
          <source>Version 0.12.2</source>
          <target state="translated">버전 0.12.2</target>
        </trans-unit>
        <trans-unit id="ae08f6f45f11cde8465017f7bdc6358df900b06e" translate="yes" xml:space="preserve">
          <source>Version 0.12.3</source>
          <target state="translated">버전 0.12.3</target>
        </trans-unit>
        <trans-unit id="ad89dbfb3304e3dff8542a4558fe1c6d6c78522f" translate="yes" xml:space="preserve">
          <source>Version 0.12.4</source>
          <target state="translated">버전 0.12.4</target>
        </trans-unit>
        <trans-unit id="f1fd67cdc7fe9aecb65a0b4336efb55efbfe8a6e" translate="yes" xml:space="preserve">
          <source>Version 0.12.5</source>
          <target state="translated">버전 0.12.5</target>
        </trans-unit>
        <trans-unit id="4c2611dcd833d75b55bc4f279b6d5537b8078f6e" translate="yes" xml:space="preserve">
          <source>Version 0.2</source>
          <target state="translated">버전 0.2</target>
        </trans-unit>
        <trans-unit id="bd19664b1e20352cc8967604f9641063bf46ee3c" translate="yes" xml:space="preserve">
          <source>Version 0.3</source>
          <target state="translated">버전 0.3</target>
        </trans-unit>
        <trans-unit id="c60fb31f26ed760097b45e6923562b1bdca9fee7" translate="yes" xml:space="preserve">
          <source>Version 0.3.1</source>
          <target state="translated">버전 0.3.1</target>
        </trans-unit>
        <trans-unit id="d9478ca0c30be3f7ddcc6a3d34473ce1d43d002a" translate="yes" xml:space="preserve">
          <source>Version 0.4</source>
          <target state="translated">버전 0.4</target>
        </trans-unit>
        <trans-unit id="5d2d8d5e17454d27c1958a6163d0f5311b955848" translate="yes" xml:space="preserve">
          <source>Version 0.5</source>
          <target state="translated">버전 0.5</target>
        </trans-unit>
        <trans-unit id="4d89d286db5b379e1bb6d168b02f880eb33b6e5e" translate="yes" xml:space="preserve">
          <source>Version 0.5.1</source>
          <target state="translated">버전 0.5.1</target>
        </trans-unit>
        <trans-unit id="729dcc0b43dc9aa3f192d5feba417eb1fdc7befd" translate="yes" xml:space="preserve">
          <source>Version 0.5.2</source>
          <target state="translated">버전 0.5.2</target>
        </trans-unit>
        <trans-unit id="13469640a1fe1773fa321106c2212786331ada92" translate="yes" xml:space="preserve">
          <source>Version 0.6</source>
          <target state="translated">버전 0.6</target>
        </trans-unit>
        <trans-unit id="235d0a7098aaa1f18850e8ba6bad0e8cc2d9951e" translate="yes" xml:space="preserve">
          <source>Version 0.6.1</source>
          <target state="translated">버전 0.6.1</target>
        </trans-unit>
        <trans-unit id="207feffb493fb78e452158045a56535661eeb035" translate="yes" xml:space="preserve">
          <source>Version 0.7</source>
          <target state="translated">버전 0.7</target>
        </trans-unit>
        <trans-unit id="67e76e75fb41fae561d77cc18f14d2ecd9eacddb" translate="yes" xml:space="preserve">
          <source>Version 0.7.1</source>
          <target state="translated">버전 0.7.1</target>
        </trans-unit>
        <trans-unit id="74c92ba64e880fb8f1afdbaf1cd19da3e2022233" translate="yes" xml:space="preserve">
          <source>Version 0.7.2</source>
          <target state="translated">버전 0.7.2</target>
        </trans-unit>
        <trans-unit id="9dd5ffb2f943217a769996eec5354793a3427344" translate="yes" xml:space="preserve">
          <source>Version 0.8</source>
          <target state="translated">버전 0.8</target>
        </trans-unit>
        <trans-unit id="4a6ec3c768cfa78b196ed4d3a0018ca950193a31" translate="yes" xml:space="preserve">
          <source>Version 0.8.1</source>
          <target state="translated">버전 0.8.1</target>
        </trans-unit>
        <trans-unit id="55985e570c95697b91d8cafbaae783a9f9588693" translate="yes" xml:space="preserve">
          <source>Version 0.9</source>
          <target state="translated">버전 0.9</target>
        </trans-unit>
        <trans-unit id="084e67410714ed45209c2fc1829d3b5161821488" translate="yes" xml:space="preserve">
          <source>Version 1.0</source>
          <target state="translated">버전 1.0</target>
        </trans-unit>
        <trans-unit id="afc7a8db48b4af8c0902573c671a14cb065e54bc" translate="yes" xml:space="preserve">
          <source>Version 1.0.1</source>
          <target state="translated">버전 1.0.1</target>
        </trans-unit>
        <trans-unit id="4641cda3030bb07e688577979dc28ccecd7d91ff" translate="yes" xml:space="preserve">
          <source>Version 1.0.2</source>
          <target state="translated">버전 1.0.2</target>
        </trans-unit>
        <trans-unit id="e90f48a372608ce366a5303d82f97d5851ec2fde" translate="yes" xml:space="preserve">
          <source>Version 1.0.3</source>
          <target state="translated">버전 1.0.3</target>
        </trans-unit>
        <trans-unit id="af770758b7da72f3fa1cb83fa78633e916b2b798" translate="yes" xml:space="preserve">
          <source>Version 1.0.4</source>
          <target state="translated">버전 1.0.4</target>
        </trans-unit>
        <trans-unit id="cc5415d679d743c1f626a7010ea6e9a819bfe776" translate="yes" xml:space="preserve">
          <source>Version 1.1.0</source>
          <target state="translated">버전 1.1.0</target>
        </trans-unit>
        <trans-unit id="35b11926e0f83c641c3f635b76f318ee712f5b9c" translate="yes" xml:space="preserve">
          <source>Version 1.1.1</source>
          <target state="translated">버전 1.1.1</target>
        </trans-unit>
        <trans-unit id="85375768918903e3572b17aa529198b1c65b5726" translate="yes" xml:space="preserve">
          <source>Version 1.1.2</source>
          <target state="translated">버전 1.1.2</target>
        </trans-unit>
        <trans-unit id="05a0f0046d66eda8feb53e6944b9778e51c342fa" translate="yes" xml:space="preserve">
          <source>Version 1.1.x</source>
          <target state="translated">버전 1.1.x</target>
        </trans-unit>
        <trans-unit id="afa179baae45b80856738215ce8eb1ee41f8da3b" translate="yes" xml:space="preserve">
          <source>Versions of Flask older than 0.11 used to have different ways to start the application. In short, the &lt;strong&gt;flask&lt;/strong&gt; command did not exist, and neither did &lt;strong&gt;python -m flask&lt;/strong&gt;. In that case you have two options: either upgrade to newer Flask versions or have a look at the &lt;a href=&quot;../server/index#server&quot;&gt;Development Server&lt;/a&gt; docs to see the alternative method for running a server.</source>
          <target state="translated">0.11보다 오래된 Flask 버전은 응용 프로그램을 시작하는 다른 방법을 사용했습니다. 간단히 말해, &lt;strong&gt;flask&lt;/strong&gt; 명령은 존재하지 않았고 &lt;strong&gt;python -m flask&lt;/strong&gt; 도 존재하지 않았습니다 . 이 경우 두 가지 옵션이 있습니다. 새로운 Flask 버전으로 업그레이드하거나 &lt;a href=&quot;../server/index#server&quot;&gt;개발 서버&lt;/a&gt; 문서를 살펴보고 서버를 실행하는 대체 방법을 확인하세요.</target>
        </trans-unit>
        <trans-unit id="a7c64b82a2412fa0f94a98767e1c4169eab860be" translate="yes" xml:space="preserve">
          <source>View Decorators</source>
          <target state="translated">데코레이터보기</target>
        </trans-unit>
        <trans-unit id="7c1c6b2905acb0b1e45734d020245d65938c5558" translate="yes" xml:space="preserve">
          <source>View Function Options</source>
          <target state="translated">기능 옵션보기</target>
        </trans-unit>
        <trans-unit id="2bb2e23c022063c95b22ddfed2740c9b08a4b03f" translate="yes" xml:space="preserve">
          <source>Vim: put &lt;code&gt;set enc=utf-8&lt;/code&gt; to your &lt;code&gt;.vimrc&lt;/code&gt; file.</source>
          <target state="translated">Vim : &lt;code&gt;set enc=utf-8&lt;/code&gt; 을 &lt;code&gt;.vimrc&lt;/code&gt; 파일에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="6f746bf843c7ebd4981d768101e7250eddd98ac6" translate="yes" xml:space="preserve">
          <source>Virtual environments</source>
          <target state="translated">가상 환경</target>
        </trans-unit>
        <trans-unit id="8a94c4f48d0fc6f98d4e011608e99f0d9b58d791" translate="yes" xml:space="preserve">
          <source>Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system&amp;rsquo;s packages.</source>
          <target state="translated">가상 환경은 각 프로젝트에 하나씩, 독립적 인 Python 라이브러리 그룹입니다. 한 프로젝트에 설치된 패키지는 다른 프로젝트 나 운영 체제의 패키지에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f15fa5845396d80011966aef2c45d5e0eb991ec8" translate="yes" xml:space="preserve">
          <source>Virtual environments have the advantage that they never install the required dependencies system wide so you have a better control over what is used where. If you want to use a virtual environment with mod_wsgi you have to modify your &lt;code&gt;.wsgi&lt;/code&gt; file slightly.</source>
          <target state="translated">가상 환경은 시스템 전체에 필요한 종속성을 설치하지 않는다는 이점이 있으므로 어디에 사용되는지 더 잘 제어 할 수 있습니다. mod_wsgi와 함께 가상 환경을 사용하려면 &lt;code&gt;.wsgi&lt;/code&gt; 파일을 약간 수정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="78aaa591cd24917ca6698492c64305ef7d62a886" translate="yes" xml:space="preserve">
          <source>Warn if cookie headers are larger than this many bytes. Defaults to &lt;code&gt;4093&lt;/code&gt;. Larger cookies may be silently ignored by browsers. Set to &lt;code&gt;0&lt;/code&gt; to disable the warning.</source>
          <target state="translated">쿠키 헤더가이 바이트보다 큰 경우 경고합니다. 기본값은 &lt;code&gt;4093&lt;/code&gt; 입니다. 더 큰 쿠키는 브라우저에서 자동으로 무시 될 수 있습니다. 로 설정 &lt;code&gt;0&lt;/code&gt; 은 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="2988833d3cf2aef3ff8b9e9f464e37662ffb04ee" translate="yes" xml:space="preserve">
          <source>Watch Extra Files with the Reloader</source>
          <target state="translated">Reloader로 추가 파일보기</target>
        </trans-unit>
        <trans-unit id="8685d8c928bed9e5c568a36068031b763aa68707" translate="yes" xml:space="preserve">
          <source>Watch Out</source>
          <target state="translated">조심해</target>
        </trans-unit>
        <trans-unit id="6f3b59c116abfcdbfb8d99f316f0fbe89662fda3" translate="yes" xml:space="preserve">
          <source>We begin by adding a tests directory under the application root. Then create a Python file to store our tests (&lt;code&gt;test_flaskr.py&lt;/code&gt;). When we format the filename like &lt;code&gt;test_*.py&lt;/code&gt;, it will be auto-discoverable by pytest.</source>
          <target state="translated">애플리케이션 루트 아래에 테스트 디렉토리를 추가하는 것으로 시작합니다. 그런 다음 테스트를 저장할 Python 파일 ( &lt;code&gt;test_flaskr.py&lt;/code&gt; )을 만듭니다. &lt;code&gt;test_*.py&lt;/code&gt; 와 같은 파일 이름의 형식을 지정하면 pytest에서 자동으로 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b10601842ee67f4dca19afa4e98a24271f434f6" translate="yes" xml:space="preserve">
          <source>We can leave out the explicit mimetype and it will be guessed, but we may as well specify it to avoid the extra guessing, as it will always be the same.</source>
          <target state="translated">명시적인 mimetype을 생략 할 수 있으며 추측 할 수 있지만 항상 동일하므로 추가 추측을 피하기 위해 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8de3606754ff0c187695b35fc0dd6e228c76e67d" translate="yes" xml:space="preserve">
          <source>We recommend accessing URL parameters with &lt;code&gt;get&lt;/code&gt; or by catching the &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; because users might change the URL and presenting them a 400 bad request page in that case is not user friendly.</source>
          <target state="translated">사용자가 URL을 변경하고 400 개의 잘못된 요청 페이지를 표시하는 것은 사용자 친화적이지 않기 때문에 &lt;code&gt;get&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 를 포착하여 URL 매개 변수에 액세스하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="528117f7383c0abb1248d2d81f9eb889a6b611c0" translate="yes" xml:space="preserve">
          <source>We recommend using the latest version of Python 3. Flask supports Python 3.5 and newer, Python 2.7, and PyPy.</source>
          <target state="translated">최신 버전의 Python 3을 사용하는 것이 좋습니다. Flask는 Python 3.5 이상, Python 2.7 및 PyPy를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b1ef0d837e5ffb749ddec2d5ba2103e141a7ac43" translate="yes" xml:space="preserve">
          <source>We should also test that adding messages works. Add a new test function like this:</source>
          <target state="translated">또한 메시지 추가가 작동하는지 테스트해야합니다. 다음과 같은 새 테스트 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="926c5dab40b0fcc69f6e1f83fb9d6997d771be34" translate="yes" xml:space="preserve">
          <source>We then use the &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator to tell Flask what URL should trigger our function.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용하여 함수를 트리거해야하는 URL을 Flask에 알립니다.</target>
        </trans-unit>
        <trans-unit id="f3bd4d70f70c09ab7a8affa842636aed131b2e58" translate="yes" xml:space="preserve">
          <source>Web APIs are often working very closely with HTTP verbs so it makes a lot of sense to implement such an API based on the &lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt;&lt;code&gt;MethodView&lt;/code&gt;&lt;/a&gt;. That said, you will notice that the API will require different URL rules that go to the same method view most of the time. For instance consider that you are exposing a user object on the web:</source>
          <target state="translated">웹 API는 종종 HTTP 동사와 매우 밀접하게 작동하므로 &lt;a href=&quot;../api/index#flask.views.MethodView&quot;&gt; &lt;code&gt;MethodView&lt;/code&gt; 를&lt;/a&gt; 기반으로 이러한 API를 구현하는 것이 좋습니다 . 즉, API에는 대부분의 경우 동일한 메서드보기로 이동하는 다른 URL 규칙이 필요합니다. 예를 들어 웹에 사용자 개체를 노출한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ae3e635e8da96ed44d6d3f4f2134f5d110192f88" translate="yes" xml:space="preserve">
          <source>Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to &lt;code&gt;GET&lt;/code&gt; requests. You can use the &lt;code&gt;methods&lt;/code&gt; argument of the &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator to handle different HTTP methods.</source>
          <target state="translated">웹 응용 프로그램은 URL에 액세스 할 때 다른 HTTP 방법을 사용합니다. Flask로 작업 할 때 HTTP 메서드에 익숙해 져야합니다. 기본적으로 경로는 &lt;code&gt;GET&lt;/code&gt; 요청 에만 응답 합니다. &lt;a href=&quot;../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 데코레이터 의 &lt;code&gt;methods&lt;/code&gt; 인수를 사용하여 다른 HTTP 메서드를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="01d4c08a27b0f4434d689f0c5a387519db91702b" translate="yes" xml:space="preserve">
          <source>Web applications usually face all kinds of security problems and it&amp;rsquo;s very hard to get everything right. Flask tries to solve a few of these things for you, but there are a couple more you have to take care of yourself.</source>
          <target state="translated">웹 애플리케이션은 일반적으로 모든 종류의 보안 문제에 직면하고 있으며 모든 것을 올바르게 설정하는 것은 매우 어렵습니다. Flask는 이러한 문제 중 몇 가지를 해결하려고 시도하지만 자신을 돌봐야 할 몇 가지가 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd705fd9d6238c9288757a4cd3c55bec155ca90f" translate="yes" xml:space="preserve">
          <source>Welcome to Flask</source>
          <target state="translated">Flask에 오신 것을 환영합니다</target>
        </trans-unit>
        <trans-unit id="884756b6fe3af804f25191c3cb6413ffd4e35ea4" translate="yes" xml:space="preserve">
          <source>Welcome to Flask&amp;rsquo;s documentation. Get started with &lt;a href=&quot;installation/index#installation&quot;&gt;Installation&lt;/a&gt; and then get an overview with the &lt;a href=&quot;quickstart/index#quickstart&quot;&gt;Quickstart&lt;/a&gt;. There is also a more detailed &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;Tutorial&lt;/a&gt; that shows how to create a small but complete application with Flask. Common patterns are described in the &lt;a href=&quot;patterns/index#patterns&quot;&gt;Patterns for Flask&lt;/a&gt; section. The rest of the docs describe each component of Flask in detail, with a full reference in the &lt;a href=&quot;api/index#api&quot;&gt;API&lt;/a&gt; section.</source>
          <target state="translated">Flask 문서에 오신 것을 환영합니다. 시작하기 &lt;a href=&quot;installation/index#installation&quot;&gt;설치&lt;/a&gt; 한 다음에 대한 개요 얻을 &lt;a href=&quot;quickstart/index#quickstart&quot;&gt;빠른 시작을&lt;/a&gt; . Flask를 사용하여 작지만 완전한 애플리케이션을 만드는 방법을 보여주는 더 자세한 &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;자습서&lt;/a&gt; 도 있습니다 . 일반적인 패턴은 &lt;a href=&quot;patterns/index#patterns&quot;&gt;Flask 용 패턴&lt;/a&gt; 섹션에 설명되어 있습니다. 나머지 문서에서는 &lt;a href=&quot;api/index#api&quot;&gt;API&lt;/a&gt; 섹션 의 전체 참조와 함께 Flask의 각 구성 요소를 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="dfa660bfef7f591b7517f18760d971917ecae5b5" translate="yes" xml:space="preserve">
          <source>Werkzeug</source>
          <target state="translated">Werkzeug</target>
        </trans-unit>
        <trans-unit id="634b3fe7f14ea67e329b5f26cc3087fcd651862e" translate="yes" xml:space="preserve">
          <source>Werkzeug documentation</source>
          <target state="translated">Werkzeug 문서</target>
        </trans-unit>
        <trans-unit id="575c73b8eee979fa1e1115330178dff49867d45a" translate="yes" xml:space="preserve">
          <source>Werkzeug logs basic request/response information to the &lt;code&gt;'werkzeug'&lt;/code&gt; logger. If the root logger has no handlers configured, Werkzeug adds a &lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler&quot;&gt;&lt;code&gt;StreamHandler&lt;/code&gt;&lt;/a&gt; to its logger.</source>
          <target state="translated">Werkzeug는 기본 요청 / 응답 정보를 &lt;code&gt;'werkzeug'&lt;/code&gt; 로거에 기록합니다. 루트 로거에 구성된 처리기가없는 경우 Werkzeug는 해당 로거에 &lt;a href=&quot;https://docs.python.org/3/library/logging.handlers.html#logging.StreamHandler&quot;&gt; &lt;code&gt;StreamHandler&lt;/code&gt; &lt;/a&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="5c2ad382fdcac2d37e83dd6d7afea777fe527b03" translate="yes" xml:space="preserve">
          <source>What Flask is, What Flask is Not</source>
          <target state="translated">Flask가 무엇인지, Flask가 아닌지</target>
        </trans-unit>
        <trans-unit id="a993d0df079902f1680cbe816d0d863c1aa505a5" translate="yes" xml:space="preserve">
          <source>What are signals? Signals help you decouple applications by sending notifications when actions occur elsewhere in the core framework or another Flask extensions. In short, signals allow certain senders to notify subscribers that something happened.</source>
          <target state="translated">신호 란 무엇입니까? 신호는 핵심 프레임 워크 또는 다른 Flask 확장의 다른 곳에서 작업이 발생할 때 알림을 보내 애플리케이션을 분리하는 데 도움이됩니다. 요컨대, 신호를 통해 특정 발신자는 가입자에게 어떤 일이 발생했음을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="045f9ba546b476d3b53fb9ccf7cf2bce7bcd3a69" translate="yes" xml:space="preserve">
          <source>What did we gain from this? Now we can restructure the application a bit into multiple modules. The only thing you have to remember is the following quick checklist:</source>
          <target state="translated">이것에서 우리는 무엇을 얻었습니까? 이제 우리는 애플리케이션을 여러 모듈로 약간 재구성 할 수 있습니다. 기억해야 할 것은 다음과 같은 빠른 체크리스트입니다.</target>
        </trans-unit>
        <trans-unit id="3bc6248c3f391b2bec2b67a4e4a3d36d4afe4a64" translate="yes" xml:space="preserve">
          <source>What does &amp;ldquo;micro&amp;rdquo; mean?</source>
          <target state="translated">&quot;마이크로&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="fd82fce5e00af1121754a6b181ab0e8514c89b7c" translate="yes" xml:space="preserve">
          <source>What does &amp;ldquo;strict&amp;rdquo; mean?</source>
          <target state="translated">&amp;ldquo;엄격&amp;rdquo;이란 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="7bc7cc52960852df2d37be00de9570bf0ff3ecfc" translate="yes" xml:space="preserve">
          <source>What does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities:</source>
          <target state="translated">이것은 당신에게 무엇을 의미합니까? 가져 오려는 매크로가 있고 요청 개체에 액세스해야하는 경우 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d455b67b4ac38c1aa7206eea4f18cdab1c8c95" translate="yes" xml:space="preserve">
          <source>What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The &lt;a href=&quot;../api/index#flask.Flask.env&quot;&gt;&lt;code&gt;env&lt;/code&gt;&lt;/a&gt; attribute maps to this config key. This is set by the &lt;code id=&quot;index-5&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable and may not behave as expected if set in code.</source>
          <target state="translated">앱이 실행되는 환경입니다. Flask 및 확장 프로그램은 디버그 모드 활성화와 같은 환경에 따라 동작을 활성화 할 수 있습니다. &lt;a href=&quot;../api/index#flask.Flask.env&quot;&gt; &lt;code&gt;env&lt;/code&gt; &lt;/a&gt; 속성이 설정 키에 매핑됩니다. 이것은 &lt;code id=&quot;index-5&quot;&gt;FLASK_ENV&lt;/code&gt; 환경 변수에 의해 설정되며 코드에 설정된 경우 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="786bbf029ba7cc03bad69f95f9eda65970237493" translate="yes" xml:space="preserve">
          <source>What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. This maps to the &lt;a href=&quot;../config/index#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; config key. This is set by the &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; environment variable and may not behave as expected if set in code.</source>
          <target state="translated">앱이 실행되는 환경입니다. Flask 및 확장 프로그램은 디버그 모드 활성화와 같은 환경에 따라 동작을 활성화 할 수 있습니다. 이것은 &lt;a href=&quot;../config/index#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt; 구성 키에 매핑됩니다 . 이것은 &lt;code id=&quot;index-0&quot;&gt;FLASK_ENV&lt;/code&gt; 환경 변수에 의해 설정되며 코드에 설정된 경우 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddbbecf0cf7d796fb1916c11312610804fe7f8e" translate="yes" xml:space="preserve">
          <source>What happens if the key does not exist in the &lt;code&gt;form&lt;/code&gt; attribute? In that case a special &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised. You can catch it like a standard &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; but if you don&amp;rsquo;t do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don&amp;rsquo;t have to deal with that problem.</source>
          <target state="translated">&lt;code&gt;form&lt;/code&gt; 속성 에 키가 없으면 어떻게됩니까 ? 이 경우 특별한 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 표준 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 처럼 잡을 수 있지만 그렇게하지 않으면 HTTP 400 Bad Request 오류 페이지가 대신 표시됩니다. 따라서 많은 상황에서 그 문제를 다룰 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f799ff46e731165b67fccc952dd8e58a2d01d96e" translate="yes" xml:space="preserve">
          <source>What happens if you want to modify the response at a point where the response does not exist yet? A common example for that would be a &lt;a href=&quot;../../api/index#flask.Flask.before_request&quot;&gt;&lt;code&gt;before_request()&lt;/code&gt;&lt;/a&gt; callback that wants to set a cookie on the response object.</source>
          <target state="translated">응답이 아직 존재하지 않는 지점에서 응답을 수정하려면 어떻게됩니까? 이에 대한 일반적인 예 는 응답 객체에 쿠키를 설정하려는 &lt;a href=&quot;../../api/index#flask.Flask.before_request&quot;&gt; &lt;code&gt;before_request()&lt;/code&gt; &lt;/a&gt; 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="ef34bd40210e7c78bf7dd9459e679f6fd77a1418" translate="yes" xml:space="preserve">
          <source>What is very popular in the Django world is to make the import explicit in the config file by adding &lt;code&gt;from yourapplication.default_settings
import *&lt;/code&gt; to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like &lt;code&gt;YOURAPPLICATION_MODE&lt;/code&gt; and set that to &lt;code&gt;production&lt;/code&gt;, &lt;code&gt;development&lt;/code&gt; etc and import different hard-coded files based on that.</source>
          <target state="translated">Django 세계에서 매우 인기있는 것은 &lt;code&gt;from yourapplication.default_settings import *&lt;/code&gt; 를 파일 상단 에 추가 한 다음 수동으로 변경 사항을 재정 의하여 구성 파일에서 가져 오기를 명시 적으로 만드는 것 입니다. &lt;code&gt;YOURAPPLICATION_MODE&lt;/code&gt; 와 같은 환경 변수를 검사하고 이를 &lt;code&gt;production&lt;/code&gt; , &lt;code&gt;development&lt;/code&gt; 등으로 설정하고이를 기반으로 다른 하드 코딩 된 파일을 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3adae2193d51366a5aedd1ef9204593ef9e14d07" translate="yes" xml:space="preserve">
          <source>What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project.</source>
          <target state="translated">가상 환경은 어떤 문제를 해결합니까? Python 프로젝트가 많을수록 다른 버전의 Python 라이브러리 또는 Python 자체로 작업해야 할 가능성이 높아집니다. 한 프로젝트에 대한 최신 버전의 라이브러리는 다른 프로젝트에서 호환성을 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc8f062d14647fc9ca8040ce266b9e9356704932" translate="yes" xml:space="preserve">
          <source>What should be used?</source>
          <target state="translated">무엇을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="c91c3c01668a3837994712b84720447b327a76c8" translate="yes" xml:space="preserve">
          <source>What to do if the Server does not Start</source>
          <target state="translated">서버가 시작되지 않는 경우 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="69878fc09a7386f79c2e427381836112d91587d9" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s important here is is that &lt;code&gt;__module__&lt;/code&gt; and &lt;code&gt;__name__&lt;/code&gt; are properly set. This is used by Flask internally to figure out how to name the URL rules in case you don&amp;rsquo;t provide a name for the rule yourself.</source>
          <target state="translated">여기서 중요한 것은 &lt;code&gt;__module__&lt;/code&gt; 및 &lt;code&gt;__name__&lt;/code&gt; 이 올바르게 설정되어 있다는 것입니다. 이것은 사용자가 규칙의 이름을 직접 제공하지 않는 경우 URL 규칙의 이름을 지정하는 방법을 알아 내기 위해 내부적으로 Flask에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="51da398a77747873e16493c2bd3f1d127173785c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ctx.pop()&lt;/code&gt; is executed in the above example, the teardown functions are called just before the app context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.</source>
          <target state="translated">경우 &lt;code&gt;ctx.pop()&lt;/code&gt; 상기 예에서 실행되면, 분해 함수는 단지 컨텍스트 활성 스택에서 앱 컨텍스트 이동 전에 호출된다. 테스트에서 이러한 구성을 사용하는 경우 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f3f8338954d6124db4f9ce27d351b75068a3b9d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ctx.pop()&lt;/code&gt; is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.</source>
          <target state="translated">경우 &lt;code&gt;ctx.pop()&lt;/code&gt; 상기 예에서 실행되면, 분해 함수는 단지 컨텍스트 활성 스택에서 요청 문맥 이동 전에 호출된다. 테스트에서 이러한 구성을 사용하는 경우 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7220c06f573a7a83a77b73f3b5239b51d394689e" translate="yes" xml:space="preserve">
          <source>When a Flask application begins handling a request, it pushes a request context, which also pushes an &lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt;. When the request ends it pops the request context then the application context.</source>
          <target state="translated">Flask 애플리케이션이 요청 처리를 시작하면 요청 컨텍스트를 푸시하고 &lt;a href=&quot;../appcontext/index&quot;&gt;The Application Context&lt;/a&gt; 도 푸시합니다 . 요청이 종료되면 요청 컨텍스트를 팝한 다음 애플리케이션 컨텍스트를 팝합니다.</target>
        </trans-unit>
        <trans-unit id="305dba4e121167b6f41e362fa7726df729eaa541" translate="yes" xml:space="preserve">
          <source>When a teardown function was called because of an exception it will be passed an error object.</source>
          <target state="translated">예외로 인해 분해 함수가 호출되면 오류 개체가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f08c489eb6af656bb1498c12342bf4f2c7271f36" translate="yes" xml:space="preserve">
          <source>When a teardown function was called because of an unhandled exception it will be passed an error object. If an &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt;&lt;code&gt;errorhandler()&lt;/code&gt;&lt;/a&gt; is registered, it will handle the exception and the teardown will not receive it.</source>
          <target state="translated">처리되지 않은 예외로 인해 분해 함수가 호출되면 오류 개체가 전달됩니다. 는 IF &lt;a href=&quot;#flask.Flask.errorhandler&quot;&gt; &lt;code&gt;errorhandler()&lt;/code&gt; &lt;/a&gt; 등록되어, 상기 예외를 처리 및 해체가 수신하지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="d46c1cd4ca4c6228133ce107516406cfd6cfbd50" translate="yes" xml:space="preserve">
          <source>When an exception is caught by Flask while handling a request, it is first looked up by code. If no handler is registered for the code, it is looked up by its class hierarchy; the most specific handler is chosen. If no handler is registered, &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt;&lt;code&gt;HTTPException&lt;/code&gt;&lt;/a&gt; subclasses show a generic message about their code, while other exceptions are converted to a generic 500 Internal Server Error.</source>
          <target state="translated">요청을 처리하는 동안 Flask가 예외를 포착하면 먼저 코드에서 조회합니다. 코드에 대해 등록 된 처리기가 없으면 해당 클래스 계층에서 조회됩니다. 가장 구체적인 핸들러가 선택됩니다. 핸들러가 등록되지 않은 경우 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/exceptions/#werkzeug.exceptions.HTTPException&quot;&gt; &lt;code&gt;HTTPException&lt;/code&gt; &lt;/a&gt; 하위 클래스는 해당 코드에 대한 일반 메시지를 표시하고 다른 예외는 일반 500 내부 서버 오류로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="73bbe6a85029094e364cf88273d8175952c1ac75" translate="yes" xml:space="preserve">
          <source>When calling an application factory, if the factory takes an argument named &lt;code&gt;script_info&lt;/code&gt;, then the &lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt;&lt;code&gt;ScriptInfo&lt;/code&gt;&lt;/a&gt; instance is passed as a keyword argument. If the application factory takes only one argument and no parentheses follow the factory name, the &lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt;&lt;code&gt;ScriptInfo&lt;/code&gt;&lt;/a&gt; instance is passed as a positional argument. If parentheses follow the factory name, their contents are parsed as Python literals and passes as arguments to the function. This means that strings must still be in quotes.</source>
          <target state="translated">애플리케이션 팩토리를 호출 할 때 팩토리가 &lt;code&gt;script_info&lt;/code&gt; 라는 인수 를 사용하면 &lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt; &lt;code&gt;ScriptInfo&lt;/code&gt; &lt;/a&gt; 인스턴스가 키워드 인수로 전달됩니다. 애플리케이션 팩토리가 하나의 인수 만 취하고 팩토리 이름 뒤에 괄호가없는 경우 &lt;a href=&quot;../api/index#flask.cli.ScriptInfo&quot;&gt; &lt;code&gt;ScriptInfo&lt;/code&gt; &lt;/a&gt; 인스턴스가 위치 인수로 전달됩니다. 괄호가 팩토리 이름 뒤에 오면 내용이 Python 리터럴로 구문 분석되고 함수에 인수로 전달됩니다. 즉, 문자열은 여전히 ​​따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="1fbee1cd7d8e91959210444b6c7cf1ffd6ad35b6" translate="yes" xml:space="preserve">
          <source>When data is changed, this is set to &lt;code&gt;True&lt;/code&gt;. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to &lt;code&gt;True&lt;/code&gt; manually when modifying that data. The session cookie will only be written to the response if this is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">데이터가 변경되면 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 . 세션 사전 자체 만 추적됩니다. 세션에 변경 가능한 데이터 (예 : 중첩 된 dict)가 포함 된 경우 해당 데이터를 수정할 때 수동으로 &lt;code&gt;True&lt;/code&gt; 로 설정해야합니다 . 세션 쿠키는 &lt;code&gt;True&lt;/code&gt; 인 경우에만 응답에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb684fd2f73217d4e0fcb89d9d4cbddadfdd0f4b" translate="yes" xml:space="preserve">
          <source>When handling a request, the application context is popped after the request context. See &lt;a href=&quot;#flask.Flask.do_teardown_request&quot;&gt;&lt;code&gt;do_teardown_request()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">요청을 처리 할 때 응용 프로그램 컨텍스트는 요청 컨텍스트 다음에 팝됩니다. &lt;a href=&quot;#flask.Flask.do_teardown_request&quot;&gt; &lt;code&gt;do_teardown_request()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c27b7e4685a13b92c05481524906313b57e4ee31" translate="yes" xml:space="preserve">
          <source>When in Doubt, Run Manually</source>
          <target state="translated">의심스러운 경우 수동으로 실행</target>
        </trans-unit>
        <trans-unit id="06a42a02f9638b807bbf1e063932e1f28e1d2a94" translate="yes" xml:space="preserve">
          <source>When it comes to connecting a template engine with an application or framework there is more than just rendering templates. For instance, Flask uses Jinja2&amp;rsquo;s extensive autoescaping support. Also it provides ways to access macros from Jinja2 templates.</source>
          <target state="translated">템플릿 엔진을 애플리케이션 또는 프레임 워크와 연결하는 데있어 템플릿 렌더링 이상의 의미가 있습니다. 예를 들어 Flask는 Jinja2의 광범위한 자동 이스케이프 지원을 사용합니다. 또한 Jinja2 템플릿에서 매크로에 액세스하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8238a66d94dec84e7f35758961f6dd77232b7462" translate="yes" xml:space="preserve">
          <source>When running the application on a remote server for production, you probably won&amp;rsquo;t be looking at the log messages very often. The WSGI server will probably send log messages to a file, and you&amp;rsquo;ll only check that file if a user tells you something went wrong.</source>
          <target state="translated">프로덕션을 위해 원격 서버에서 애플리케이션을 실행할 때 로그 메시지를 자주 보지 않을 것입니다. WSGI 서버는 아마도 로그 메시지를 파일로 보낼 것이고, 사용자가 무언가 잘못되었다고 말한 경우에만 해당 파일을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2a00678214872af6bc61ee5b93852bad37e06926" translate="yes" xml:space="preserve">
          <source>When serving files, set the &lt;code&gt;X-Sendfile&lt;/code&gt; header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server.</source>
          <target state="translated">파일을 제공 할 때 Flask로 데이터를 제공하는 대신 &lt;code&gt;X-Sendfile&lt;/code&gt; 헤더를 설정합니다 . Apache와 같은 일부 웹 서버는이를 인식하고 데이터를보다 효율적으로 제공합니다. 이것은 그러한 서버를 사용할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d32404dba314b02f2819112bc7559a4b773d6ce" translate="yes" xml:space="preserve">
          <source>When serving files, set the cache control max age to this number of seconds. Can either be a &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt;&lt;code&gt;datetime.timedelta&lt;/code&gt;&lt;/a&gt; or an &lt;code&gt;int&lt;/code&gt;. Override this value on a per-file basis using &lt;a href=&quot;../api/index#flask.Flask.get_send_file_max_age&quot;&gt;&lt;code&gt;get_send_file_max_age()&lt;/code&gt;&lt;/a&gt; on the application or blueprint.</source>
          <target state="translated">파일을 제공 할 때 캐시 제어 최대 기간을이 시간 (초)으로 설정하십시오. 중 하나가 될 수 &lt;a href=&quot;https://docs.python.org/3/library/datetime.html#datetime.timedelta&quot;&gt; &lt;code&gt;datetime.timedelta&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;int&lt;/code&gt; . 애플리케이션 또는 청사진에서 &lt;a href=&quot;../api/index#flask.Flask.get_send_file_max_age&quot;&gt; &lt;code&gt;get_send_file_max_age()&lt;/code&gt; &lt;/a&gt; 를 사용하여 파일 별로이 값을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="7fd91765b27cdfadd4433d4db1da78ed28b926e6" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../api/index#flask.Flask&quot;&gt;&lt;code&gt;Flask&lt;/code&gt;&lt;/a&gt; application handles a request, it creates a &lt;a href=&quot;../api/index#flask.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object based on the environment it received from the WSGI server. Because a &lt;em&gt;worker&lt;/em&gt; (thread, process, or coroutine depending on the server) handles only one request at a time, the request data can be considered global to that worker during that request. Flask uses the term &lt;em&gt;context local&lt;/em&gt; for this.</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.Flask&quot;&gt; &lt;code&gt;Flask&lt;/code&gt; &lt;/a&gt; 애플리케이션이 요청을 처리 할 때 WSGI 서버에서받은 환경을 기반으로 &lt;a href=&quot;../api/index#flask.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 . 때문에 &lt;em&gt;작업자&lt;/em&gt; (서버에 따라 스레드, 프로세스, 또는 코 루틴)는 한 번에 하나의 요청을 처리하고 요청 된 데이터를 요청하는 동안에 그 작업자 글로벌 간주 될 수있다. Flask는 이를 위해 &lt;em&gt;컨텍스트 로컬&lt;/em&gt; 이라는 용어를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3103d134c4aeb275f63815ba62e9c5696777521e" translate="yes" xml:space="preserve">
          <source>When the development server is running in development mode (the &lt;code&gt;FLASK_ENV&lt;/code&gt; environment variable is set to &lt;code&gt;'development'&lt;/code&gt;), the error and data will be preserved and shown in the interactive debugger.</source>
          <target state="translated">개발 서버가 개발 모드에서 실행 중이면 ( &lt;code&gt;FLASK_ENV&lt;/code&gt; 환경 변수가 &lt;code&gt;'development'&lt;/code&gt; 로 설정 됨 ) 오류와 데이터가 보존되고 대화 형 디버거에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e55c75b73bc6dd6de03a65abce273358e363777" translate="yes" xml:space="preserve">
          <source>When the request context is popped, it will evaluate all the functions registered on the application for teardown execution (&lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt;&lt;code&gt;teardown_request()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">요청 컨텍스트가 팝되면 응용 프로그램에 등록 된 모든 함수가 해제 실행 ( &lt;a href=&quot;#flask.Flask.teardown_request&quot;&gt; &lt;code&gt;teardown_request()&lt;/code&gt; &lt;/a&gt; )을 위해 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dd7f654f135d993f0fb9d6a4491c29bafee37b6" translate="yes" xml:space="preserve">
          <source>When the request starts, a &lt;a href=&quot;../api/index#flask.ctx.RequestContext&quot;&gt;&lt;code&gt;RequestContext&lt;/code&gt;&lt;/a&gt; is created and pushed, which creates and pushes an &lt;a href=&quot;../api/index#flask.ctx.AppContext&quot;&gt;&lt;code&gt;AppContext&lt;/code&gt;&lt;/a&gt; first if a context for that application is not already the top context. While these contexts are pushed, the &lt;a href=&quot;../api/index#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.g&quot;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/index#flask.request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/index#flask.session&quot;&gt;&lt;code&gt;session&lt;/code&gt;&lt;/a&gt; proxies are available to the original thread handling the request.</source>
          <target state="translated">요청이 시작되면 &lt;a href=&quot;../api/index#flask.ctx.RequestContext&quot;&gt; &lt;code&gt;RequestContext&lt;/code&gt; &lt;/a&gt; 가 생성되고 푸시됩니다. 그러면 해당 애플리케이션의 컨텍스트가 아직 최상위 컨텍스트가 아닌 경우 &lt;a href=&quot;../api/index#flask.ctx.AppContext&quot;&gt; &lt;code&gt;AppContext&lt;/code&gt; 를&lt;/a&gt; 먼저 생성하고 푸시합니다 . 이러한 컨텍스트가 푸시되는 동안 &lt;a href=&quot;../api/index#flask.request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 처리하는 원래 스레드 에서 &lt;a href=&quot;../api/index#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/index#flask.g&quot;&gt; &lt;code&gt;g&lt;/code&gt; &lt;/a&gt; , request 및 &lt;a href=&quot;../api/index#flask.session&quot;&gt; &lt;code&gt;session&lt;/code&gt; &lt;/a&gt; 프록시를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="435a763e1c90a1b6384f01e02165782cf98540c0" translate="yes" xml:space="preserve">
          <source>When the user would then move with the mouse over the input, the cookie would be presented to the user in an alert window. But instead of showing the cookie to the user, a good attacker might also execute any other JavaScript code. In combination with CSS injections the attacker might even make the element fill out the entire page so that the user would just have to have the mouse anywhere on the page to trigger the attack.</source>
          <target state="translated">사용자가 입력 위로 마우스를 이동하면 경고 창에서 쿠키가 사용자에게 표시됩니다. 그러나 좋은 공격자는 사용자에게 쿠키를 표시하는 대신 다른 JavaScript 코드를 실행할 수도 있습니다. CSS 삽입과 함께 공격자는 요소가 전체 페이지를 채우도록 만들 수도 있으므로 사용자가 페이지의 아무 곳에 나 마우스를 가져 가면 공격을 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0467b7acdfba3a7eb8f631c45c8ef6ce0f4234c5" translate="yes" xml:space="preserve">
          <source>When there is no error handler registered for an exception, a 500 Internal Server Error will be returned instead. See &lt;a href=&quot;../api/index#flask.Flask.handle_exception&quot;&gt;&lt;code&gt;flask.Flask.handle_exception()&lt;/code&gt;&lt;/a&gt; for information about this behavior.</source>
          <target state="translated">예외에 대해 등록 된 오류 처리기가 없으면 대신 500 내부 서버 오류가 반환됩니다. 이 동작에 대한 정보는 &lt;a href=&quot;../api/index#flask.Flask.handle_exception&quot;&gt; &lt;code&gt;flask.Flask.handle_exception()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8778dd974cd267f31d5c376567b1d22a2d99d395" translate="yes" xml:space="preserve">
          <source>When used in combination with a &lt;code&gt;with&lt;/code&gt; statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the &lt;code&gt;with&lt;/code&gt; block is left the session is stored back.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문과 함께 사용 하면 세션 트랜잭션이 열립니다. 이것은 테스트 클라이언트가 사용하는 세션을 수정하는 데 사용할 수 있습니다. &lt;code&gt;with&lt;/code&gt; 블록이 남아 있으면 세션이 다시 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d2d0ec0ea78ea1936f21e2b02b0acc0a2ec073da" translate="yes" xml:space="preserve">
          <source>When using Flask for web APIs, you can use the same techniques as above to return JSON responses to API errors. &lt;a href=&quot;../../api/index#flask.abort&quot;&gt;&lt;code&gt;abort()&lt;/code&gt;&lt;/a&gt; is called with a &lt;code&gt;description&lt;/code&gt; parameter. The &lt;code&gt;errorhandler()&lt;/code&gt; will use that as the JSON error message, and set the status code to 404.</source>
          <target state="translated">웹 API 용 Flask를 사용할 때 위와 동일한 기술을 사용하여 API 오류에 대한 JSON 응답을 반환 할 수 있습니다. &lt;a href=&quot;../../api/index#flask.abort&quot;&gt; &lt;code&gt;abort()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;description&lt;/code&gt; 매개 변수 와 함께 호출됩니다 . &lt;code&gt;errorhandler()&lt;/code&gt; JSON 에러 메시지로, 404 상태 코드를 설정 한 것을 사용한다.</target>
        </trans-unit>
        <trans-unit id="bd49cfeb453fd5bf186d266b02fe67d1d413e8b6" translate="yes" xml:space="preserve">
          <source>When using a custom script, if you introduce an error in your module-level code, the reloader will fail because it can no longer load the entry point.</source>
          <target state="translated">사용자 정의 스크립트를 사용할 때 모듈 수준 코드에 오류가 발생하면 더 이상 진입 점을로드 할 수 없기 때문에 리 로더가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="453110846042107e1d8711c3a7dce570e47fd01a" translate="yes" xml:space="preserve">
          <source>When using development mode, the reloader will trigger whenever your Python code or imported modules change. The reloader can watch additional files with the &lt;code&gt;--extra-files&lt;/code&gt; option, or the &lt;code&gt;FLASK_RUN_EXTRA_FILES&lt;/code&gt; environment variable. Multiple paths are separated with &lt;code&gt;:&lt;/code&gt;, or &lt;code&gt;;&lt;/code&gt; on Windows.</source>
          <target state="translated">개발 모드를 사용하는 경우 Python 코드 또는 가져온 모듈이 변경 될 때마다 리 로더가 트리거됩니다. 리 로더는 &lt;code&gt;--extra-files&lt;/code&gt; 옵션 또는 &lt;code&gt;FLASK_RUN_EXTRA_FILES&lt;/code&gt; 환경 변수를 사용하여 추가 파일을 감시 할 수 있습니다 . 여러 경로는 &lt;code&gt;:&lt;/code&gt; 또는 &lt;code&gt;;&lt;/code&gt; 로 구분됩니다 . Windows에서.</target>
        </trans-unit>
        <trans-unit id="b2239df8391dc993ac72ed2e640392eb94eb7909" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../appfactories/index#app-factories&quot;&gt;application factory pattern&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../appfactories/index#app-factories&quot;&gt;애플리케이션 팩토리 패턴을&lt;/a&gt; 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="a405ff8856d1d2bb6f33781f21256ab263ac1b03" translate="yes" xml:space="preserve">
          <source>When using the local development server, you may get a connection reset error instead of a 413 response. You will get the correct status response when running the app with a production WSGI server.</source>
          <target state="translated">로컬 개발 서버를 사용할 때 413 응답 대신 연결 재설정 오류가 발생할 수 있습니다. 프로덕션 WSGI 서버로 앱을 실행할 때 올바른 상태 응답을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="fe3529efc2fe6aa70c5cbe6159c0ab217237cec4" translate="yes" xml:space="preserve">
          <source>When using the shell, it may be easier to push and pop the context manually to avoid indentation.</source>
          <target state="translated">셸을 사용할 때 들여 쓰기를 방지하기 위해 컨텍스트를 수동으로 푸시하고 팝하는 것이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="202b8d0ed31dbf31e58dcc9f53bba3835a804155" translate="yes" xml:space="preserve">
          <source>When you are using the app factory pattern, it may be more convenient to define your own Click script. Instead of using &lt;code&gt;FLASK_APP&lt;/code&gt; and letting Flask load your application, you can create your own Click object and export it as a &lt;a href=&quot;https://packaging.python.org/tutorials/packaging-projects/#console-scripts&quot;&gt;console script&lt;/a&gt; entry point.</source>
          <target state="translated">앱 팩토리 패턴을 사용하는 경우 고유 한 Click 스크립트를 정의하는 것이 더 편리 할 수 ​​있습니다. &lt;code&gt;FLASK_APP&lt;/code&gt; 를 사용 하고 Flask가 애플리케이션을로드하도록 하는 대신 고유 한 Click 개체를 만들고 &lt;a href=&quot;https://packaging.python.org/tutorials/packaging-projects/#console-scripts&quot;&gt;콘솔 스크립트&lt;/a&gt; 진입 점 으로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2959a7d1a2d78202afd13f0201890d8adbe0038" translate="yes" xml:space="preserve">
          <source>When you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (&lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Larger Applications&lt;/a&gt;) for that and adding a separate module for the forms.</source>
          <target state="translated">WTForms로 작업 할 때 먼저 양식을 클래스로 정의해야합니다. 이를 위해 애플리케이션을 여러 모듈 ( &lt;a href=&quot;../packages/index#larger-applications&quot;&gt;Larger Applications&lt;/a&gt; )로 나누고 양식에 대해 별도의 모듈을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3c57429f094e6f244e6c6e23c4b635a6519ba190" translate="yes" xml:space="preserve">
          <source>When you bind a function with the help of the &lt;code&gt;@simple_page.route&lt;/code&gt; decorator, the blueprint will record the intention of registering the function &lt;code&gt;show&lt;/code&gt; on the application when it&amp;rsquo;s later registered. Additionally it will prefix the endpoint of the function with the name of the blueprint which was given to the &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; constructor (in this case also &lt;code&gt;simple_page&lt;/code&gt;). The blueprint&amp;rsquo;s name does not modify the URL, only the endpoint.</source>
          <target state="translated">&lt;code&gt;@simple_page.route&lt;/code&gt; 데코레이터 의 도움으로 함수를 바인딩 하면 청사진은 나중에 등록 될 때 애플리케이션에 함수 &lt;code&gt;show&lt;/code&gt; 를 등록하려는 의도를 기록합니다 . 또한 함수의 끝점 앞에 &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt; 생성자 에 주어진 블루 프린트의 이름을 붙입니다 (이 경우에도 &lt;code&gt;simple_page&lt;/code&gt; ). Blueprint의 이름은 URL을 수정하지 않고 끝점 만 수정합니다.</target>
        </trans-unit>
        <trans-unit id="73b8e09128004281e69fc88b02a77e6f3b0d1507" translate="yes" xml:space="preserve">
          <source>When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is &lt;a href=&quot;https://wtforms.readthedocs.io/&quot;&gt;WTForms&lt;/a&gt; which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try.</source>
          <target state="translated">브라우저보기에서 제출 한 양식 데이터로 작업해야하는 경우 코드를 빠르게 읽기가 매우 어려워집니다. 이 프로세스를보다 쉽게 ​​관리 할 수 ​​있도록 설계된 라이브러리가 있습니다. 그중 하나는 여기서 처리 할 &lt;a href=&quot;https://wtforms.readthedocs.io/&quot;&gt;WTForms&lt;/a&gt; 입니다. 다양한 형태의 상황에 처해 있다면 한 번 시도해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e124bcfd21c7a0a58e753e33350e12e8f3015b2f" translate="yes" xml:space="preserve">
          <source>When you want to configure logging for your project, you should do it as soon as possible when the program starts. If &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt;&lt;code&gt;app.logger&lt;/code&gt;&lt;/a&gt; is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object.</source>
          <target state="translated">프로젝트에 대한 로깅을 구성하려면 프로그램이 시작될 때 가능한 한 빨리 구성해야합니다. 경우 &lt;a href=&quot;../api/index#flask.Flask.logger&quot;&gt; &lt;code&gt;app.logger&lt;/code&gt; 이&lt;/a&gt; 로깅이 구성되기 전에 액세스 할 수 있습니다, 그것은 기본 핸들러를 추가합니다. 가능하면 응용 프로그램 개체를 만들기 전에 로깅을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="30dc6f270b8a620923d2dfdcdb2f1311fcb381f6" translate="yes" xml:space="preserve">
          <source>When you want to decorate a pluggable view you will have to either do that when the view function is created (by wrapping the return value of &lt;a href=&quot;#flask.views.View.as_view&quot;&gt;&lt;code&gt;as_view()&lt;/code&gt;&lt;/a&gt;) or you can use the &lt;a href=&quot;#flask.views.View.decorators&quot;&gt;&lt;code&gt;decorators&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">플러그 형 뷰를 장식하려면 뷰 함수가 생성 될 때 ( &lt;a href=&quot;#flask.views.View.as_view&quot;&gt; &lt;code&gt;as_view()&lt;/code&gt; &lt;/a&gt; 의 반환 값을 래핑하여 ) 그렇게 하거나 &lt;a href=&quot;#flask.views.View.decorators&quot;&gt; &lt;code&gt;decorators&lt;/code&gt; &lt;/a&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed96f5e04c45ceb58d7163959ca69f2ff4bd80f7" translate="yes" xml:space="preserve">
          <source>When you want to use the werkzeug routing system for more flexibility you need to map the endpoint as defined in the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt;&lt;code&gt;Rule&lt;/code&gt;&lt;/a&gt; to a view function. This is possible with this decorator. For example:</source>
          <target state="translated">더 많은 유연성을 위해 werkzeug 라우팅 시스템을 사용하려면 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt; &lt;code&gt;Rule&lt;/code&gt; &lt;/a&gt; 에 정의 된 엔드 포인트를 보기 기능 에 매핑해야 합니다. 이것은이 데코레이터로 가능합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="80d878683e23024c3da2342716a6191b5bd1ae64" translate="yes" xml:space="preserve">
          <source>When your application runs slow, throw some caches in. Well, at least it&amp;rsquo;s the easiest way to speed up things. What does a cache do? Say you have a function that takes some time to complete but the results would still be good enough if they were 5 minutes old. So then the idea is that you actually put the result of that calculation into a cache for some time.</source>
          <target state="translated">응용 프로그램이 느리게 실행될 때 캐시를 좀 넣어주세요. 적어도 속도를 높이는 가장 쉬운 방법입니다. 캐시는 무엇을합니까? 완료하는 데 약간의 시간이 걸리지 만 5 분 전이면 결과가 여전히 충분하다고 가정 해 보겠습니다. 그래서 아이디어는 실제로 그 계산의 결과를 얼마 동안 캐시에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="24852195225c09c2edf347e2b71ca7539c5984a0" translate="yes" xml:space="preserve">
          <source>Whenever you do this, please be very cautious about the variables you are using in this block.</source>
          <target state="translated">이 작업을 수행 할 때마다이 블록에서 사용하는 변수에 대해 매우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="36f39dfb0af7dbae67d14debecc78ff94595daf2" translate="yes" xml:space="preserve">
          <source>Where is My Site?</source>
          <target state="translated">내 사이트는 어디에 있습니까?</target>
        </trans-unit>
        <trans-unit id="c12a31a0fe38466ad8f8474f9ad58ac9b6e84905" translate="yes" xml:space="preserve">
          <source>Whether debug mode is enabled. When using &lt;code&gt;flask run&lt;/code&gt; to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The &lt;a href=&quot;../api/index#flask.Flask.debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt; attribute maps to this config key. This is enabled when &lt;a href=&quot;#ENV&quot;&gt;&lt;code&gt;ENV&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;'development'&lt;/code&gt; and is overridden by the &lt;code&gt;FLASK_DEBUG&lt;/code&gt; environment variable. It may not behave as expected if set in code.</source>
          <target state="translated">디버그 모드 활성화 여부. &lt;code&gt;flask run&lt;/code&gt; 을 사용 하여 개발 서버를 시작할 때 처리되지 않은 예외에 대해 대화 형 디버거가 표시되고 코드가 변경되면 서버가 다시로드됩니다. &lt;a href=&quot;../api/index#flask.Flask.debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/a&gt; 속성이 설정 키에 매핑됩니다. &lt;a href=&quot;#ENV&quot;&gt; &lt;code&gt;ENV&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;'development'&lt;/code&gt; 이고 &lt;code&gt;FLASK_DEBUG&lt;/code&gt; 환경 변수에 의해 재정의 될 때 활성화됩니다 . 코드에 설정된 경우 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14f9a14ac1faf7d967445c7b976063b3d9532148" translate="yes" xml:space="preserve">
          <source>Whether debug mode is enabled. When using &lt;code&gt;flask run&lt;/code&gt; to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. This maps to the &lt;a href=&quot;../config/index#DEBUG&quot;&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/a&gt; config key. This is enabled when &lt;a href=&quot;#flask.Flask.env&quot;&gt;&lt;code&gt;env&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;'development'&lt;/code&gt; and is overridden by the &lt;code&gt;FLASK_DEBUG&lt;/code&gt; environment variable. It may not behave as expected if set in code.</source>
          <target state="translated">디버그 모드 활성화 여부. &lt;code&gt;flask run&lt;/code&gt; 을 사용 하여 개발 서버를 시작할 때 처리되지 않은 예외에 대해 대화 형 디버거가 표시되고 코드가 변경되면 서버가 다시로드됩니다. 이것은 &lt;a href=&quot;../config/index#DEBUG&quot;&gt; &lt;code&gt;DEBUG&lt;/code&gt; &lt;/a&gt; 구성 키에 매핑됩니다 . &lt;a href=&quot;#flask.Flask.env&quot;&gt; &lt;code&gt;env&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;'development'&lt;/code&gt; 일 때 활성화 되고 &lt;code&gt;FLASK_DEBUG&lt;/code&gt; 환경 변수에 의해 재정의됩니다 . 코드에 설정된 경우 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b45717b316c6a3080d74b5ba1017480da127881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;FLASK_APP&lt;/code&gt; supports a variety of options for specifying your application, most use cases should be simple. Here are the typical values:</source>
          <target state="translated">&lt;code&gt;FLASK_APP&lt;/code&gt; 는 애플리케이션을 지정하기위한 다양한 옵션을 지원 하지만 대부분의 사용 사례는 간단해야합니다. 다음은 일반적인 값입니다.</target>
        </trans-unit>
        <trans-unit id="81c2db9e41d064c933605ca9f1efd8b050ea385e" translate="yes" xml:space="preserve">
          <source>While lightweight and easy to use, &lt;strong&gt;Flask&amp;rsquo;s built-in server is not suitable for production&lt;/strong&gt; as it doesn&amp;rsquo;t scale well. Some of the options available for properly running Flask in production are documented here.</source>
          <target state="translated">가볍고 사용하기 쉽지만 &lt;strong&gt;Flask의 내장 서버는&lt;/strong&gt; 확장 성이 좋지 않기 때문에 &lt;strong&gt;프로덕션에 적합&lt;/strong&gt; 하지 않습니다. 프로덕션에서 Flask를 올바르게 실행하는 데 사용할 수있는 일부 옵션은 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d07d2de19ae3b2a6b9ab804781d083894fe2d51e" translate="yes" xml:space="preserve">
          <source>While the &lt;a href=&quot;https://pypi.org/search/?c=Framework+%3A%3A+Flask&quot;&gt;PyPI&lt;/a&gt; contains many Flask extensions, you may not find an extension that fits your need. If this is the case, you can create your own. Read &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask Extension Development&lt;/a&gt; to develop your own Flask extension.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/search/?c=Framework+%3A%3A+Flask&quot;&gt;PyPI&lt;/a&gt; 에는 많은 Flask 확장이 포함되어 있지만 필요에 맞는 확장을 찾지 못할 수도 있습니다. 이 경우 직접 만들 수 있습니다. 자신 만의 &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/extensiondev/&quot;&gt;Flask 확장을 개발&lt;/a&gt; 하려면 Flask 확장 개발 을 읽어 보세요.</target>
        </trans-unit>
        <trans-unit id="02679d3c3fe3c6f7c158317557829dd0576fd671" translate="yes" xml:space="preserve">
          <source>While this approach is straightforward to use, it is important to remember that environment variables are strings &amp;ndash; they are not automatically deserialized into Python types.</source>
          <target state="translated">이 접근 방식은 사용하기 쉽지만 환경 변수는 문자열이라는 점을 기억하는 것이 중요합니다. 자동으로 Python 유형으로 역 직렬화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03da2a6cf735a3ba4eab16a5c1690117a76827b3" translate="yes" xml:space="preserve">
          <source>While this is fine for small applications, for larger applications it&amp;rsquo;s a good idea to use a package instead of a module. The &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;tutorial&lt;/a&gt; is structured to use the package pattern, see the &lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/tutorial&quot;&gt;example code&lt;/a&gt;.</source>
          <target state="translated">작은 응용 프로그램에서는 괜찮지 만 큰 응용 프로그램에서는 모듈 대신 패키지를 사용하는 것이 좋습니다. &lt;a href=&quot;https://flask.palletsprojects.com/en/1.1.x/tutorial/#tutorial&quot;&gt;튜토리얼&lt;/a&gt; 패키지 패턴을 사용하도록 구성되는 참조 &lt;a href=&quot;https://github.com/pallets/flask/tree/1.1.2/examples/tutorial&quot;&gt;예 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98386f17d4cb4e1aaaca5cdf5e27ab3dfdff2169" translate="yes" xml:space="preserve">
          <source>Why Blueprints?</source>
          <target state="translated">왜 청사진인가?</target>
        </trans-unit>
        <trans-unit id="f194a70ddaebaa73a44954e0eeb520b55d695a16" translate="yes" xml:space="preserve">
          <source>Why do we limit the extensions that are allowed? You probably don&amp;rsquo;t want your users to be able to upload everything there if the server is directly sending out the data to the client. That way you can make sure that users are not able to upload HTML files that would cause XSS problems (see &lt;a href=&quot;../../security/index#xss&quot;&gt;Cross-Site Scripting (XSS)&lt;/a&gt;). Also make sure to disallow &lt;code&gt;.php&lt;/code&gt; files if the server executes them, but who has PHP installed on their server, right? :)</source>
          <target state="translated">허용되는 확장을 제한하는 이유는 무엇입니까? 서버가 데이터를 클라이언트로 직접 보내는 경우 사용자가 모든 것을 업로드하지 못하도록 할 수 있습니다. 이렇게하면 사용자가 XSS 문제를 일으킬 수있는 HTML 파일을 업로드 할 수 없도록 할 수 있습니다 (XSS ( &lt;a href=&quot;../../security/index#xss&quot;&gt;Cross-Site Scripting) 참조&lt;/a&gt; ). 또한 서버가 &lt;code&gt;.php&lt;/code&gt; 파일을 실행하는 경우 허용하지 않도록하십시오 .하지만 서버에 PHP가 설치된 사람은 누구입니까? :)</target>
        </trans-unit>
        <trans-unit id="a891bc4d84ab79562769f837680612b2cabc5301" translate="yes" xml:space="preserve">
          <source>Why does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn&amp;rsquo;t it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it&amp;rsquo;s called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it&amp;rsquo;s sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage.</source>
          <target state="translated">Flask는 왜 자신을 마이크로 프레임 워크라고 부르지 만 두 라이브러리 (즉 Werkzeug 및 Jinja2)에 의존합니다. 왜 안돼? 웹 개발의 Ruby 측면을 살펴보면 WSGI와 매우 유사한 프로토콜이 있습니다. 거기에 Rack이라고 불리지 만 그 외에도 Ruby 용 WSGI 변환과 매우 흡사합니다. 그러나 Ruby land의 거의 모든 응용 프로그램은 Rack에서 직접 작동하지 않고 같은 이름의 라이브러리 위에서 작동합니다. 이 Rack 라이브러리는 Python에 WebOb (이전의 Paste)와 Werkzeug의 두 가지 동등 항목이 있습니다. 붙여 넣기는 여전히 주변에 있지만 내 이해에 따르면 WebOb를 선호하여 사용되지 않습니다. WebOb 및 Werkzeug의 개발은 유사한 아이디어를 염두에두고 시작되었습니다. 다른 응용 프로그램을 활용하기 위해 WSGI를 잘 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e947cc8d1476a1a5c0754ed8528b8fbc9bf733d" translate="yes" xml:space="preserve">
          <source>Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.</source>
          <target state="translated">Flask가 왜 그렇게하지 않습니까? 이를위한 이상적인 장소는 Flask에없는 양식 유효성 검사 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="a450869eb0a7c72b90aca6748427f275b0b43873" translate="yes" xml:space="preserve">
          <source>Why is that? The application will work even with &lt;code&gt;__name__&lt;/code&gt;, thanks to how resources are looked up. However it will make debugging more painful. Certain extensions can make assumptions based on the import name of your application. For example the Flask-SQLAlchemy extension will look for the code in your application that triggered an SQL query in debug mode. If the import name is not properly set up, that debugging information is lost. (For example it would only pick up SQL queries in &lt;code&gt;yourapplication.app&lt;/code&gt; and not &lt;code&gt;yourapplication.views.frontend&lt;/code&gt;)</source>
          <target state="translated">왜 그런 겁니까? 리소스 조회 방식 덕분에 애플리케이션은 &lt;code&gt;__name__&lt;/code&gt; 에서도 작동 합니다. 그러나 디버깅이 더 힘들어집니다. 특정 확장은 애플리케이션의 가져 오기 이름을 기반으로 가정 할 수 있습니다. 예를 들어 Flask-SQLAlchemy 확장은 디버그 모드에서 SQL 쿼리를 트리거 한 애플리케이션의 코드를 찾습니다. 가져 오기 이름이 제대로 설정되지 않으면 해당 디버깅 정보가 손실됩니다. (예를 들어 &lt;code&gt;yourapplication.app&lt;/code&gt; 가 아닌 &lt;code&gt;yourapplication.views.frontend&lt;/code&gt; 에서 SQL 쿼리 만 선택합니다. )</target>
        </trans-unit>
        <trans-unit id="4681cdb6e9e01e1e10c7820d390f76fe2e1a7e8b" translate="yes" xml:space="preserve">
          <source>Why is this necessary? Because if you would not be doing that, an attacker could easily inject custom JavaScript handlers. For example an attacker could inject this piece of HTML+JavaScript:</source>
          <target state="translated">왜 이것이 필요한가요? 그렇게하지 않으면 공격자가 사용자 지정 JavaScript 처리기를 쉽게 삽입 할 수 있기 때문입니다. 예를 들어 공격자는이 HTML + JavaScript를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4eee296c48eb4cdd05301ab2d560574507089d" translate="yes" xml:space="preserve">
          <source>Why is this the case? Because people have different preferences and requirements and Flask could not meet those if it would force any of this into the core. The majority of web applications will need a template engine in some sort. However not every application needs a SQL database.</source>
          <target state="translated">왜 그렇습니까? 사람들은 선호와 요구 사항이 다르기 때문에 Flask는이 중 하나를 핵심으로 강제 할 경우이를 충족 할 수 없습니다. 대부분의 웹 애플리케이션에는 일종의 템플릿 엔진이 필요합니다. 그러나 모든 애플리케이션에 SQL 데이터베이스가 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="97f00272d21ad51c5b8a40e2a7111d5b291d8db6" translate="yes" xml:space="preserve">
          <source>Why would you want to build URLs using the URL reversing function &lt;a href=&quot;../api/index#flask.url_for&quot;&gt;&lt;code&gt;url_for()&lt;/code&gt;&lt;/a&gt; instead of hard-coding them into your templates?</source>
          <target state="translated">URL을 템플릿에 하드 코딩하는 대신 URL 반전 함수 &lt;a href=&quot;../api/index#flask.url_for&quot;&gt; &lt;code&gt;url_for()&lt;/code&gt; &lt;/a&gt; 를 사용하여 URL을 빌드하려는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="a397bf775e16587aa5e8208e6a96c9178b091928" translate="yes" xml:space="preserve">
          <source>Will be used for the session cookie path if &lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt; is not set.</source>
          <target state="translated">&lt;code&gt;SESSION_COOKIE_PATH&lt;/code&gt; 가 설정되지 않은 경우 세션 쿠키 경로에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3edee93e1605bff216d9b2854ee9508e7ccca23" translate="yes" xml:space="preserve">
          <source>Windows CMD, &lt;code&gt;venv\Scripts\activate.bat&lt;/code&gt;:</source>
          <target state="translated">Windows CMD, &lt;code&gt;venv\Scripts\activate.bat&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="34bbe867e973001f4b07ccf1a35edb30be3bd482" translate="yes" xml:space="preserve">
          <source>Windows CMD:</source>
          <target state="translated">Windows CMD:</target>
        </trans-unit>
        <trans-unit id="e35f0573f4fc191914534f505ab1d46e2f50a916" translate="yes" xml:space="preserve">
          <source>Windows PowerShell:</source>
          <target state="translated">Windows PowerShell:</target>
        </trans-unit>
        <trans-unit id="5029e0c2b03b9f2c262221dbd5b5bd90e8899da0" translate="yes" xml:space="preserve">
          <source>With Blinker 1.1 you can also easily subscribe to signals by using the new &lt;code&gt;connect_via()&lt;/code&gt; decorator:</source>
          <target state="translated">Blinker 1.1에서는 새로운 &lt;code&gt;connect_via()&lt;/code&gt; 데코레이터를 사용하여 신호를 쉽게 구독 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ea1dbfb2b35223e6cae63e931f186e0a336e4e7" translate="yes" xml:space="preserve">
          <source>With CGI, you will also have to make sure that your code does not contain any &lt;code&gt;print&lt;/code&gt; statements, or that &lt;code&gt;sys.stdout&lt;/code&gt; is overridden by something that doesn&amp;rsquo;t write into the HTTP response.</source>
          <target state="translated">CGI를 사용하면 코드에 &lt;code&gt;print&lt;/code&gt; 문이 포함되어 있지 않거나 &lt;code&gt;sys.stdout&lt;/code&gt; 이 HTTP 응답에 쓰지 않는 항목에 의해 재정의 되는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0051dded9ef7854e2e91003b8a9cd19576810dc4" translate="yes" xml:space="preserve">
          <source>With Flask 0.8 a new attribute was introduced: &lt;code&gt;Flask.instance_path&lt;/code&gt;. It refers to a new concept called the &amp;ldquo;instance folder&amp;rdquo;. The instance folder is designed to not be under version control and be deployment specific. It&amp;rsquo;s the perfect place to drop things that either change at runtime or configuration files.</source>
          <target state="translated">Flask 0.8에서는 새로운 속성 &lt;code&gt;Flask.instance_path&lt;/code&gt; 가 도입 되었습니다 . &quot;인스턴스 폴더&quot;라는 새로운 개념을 나타냅니다. 인스턴스 폴더는 버전 제어를받지 않고 배포별로 설계되었습니다. 런타임 또는 구성 파일에서 변경되는 항목을 삭제하기에 완벽한 장소입니다.</target>
        </trans-unit>
        <trans-unit id="5fc1194f30d57b98a20e902b58db54a5ef167375" translate="yes" xml:space="preserve">
          <source>Within the activated environment, use the following command to install Flask:</source>
          <target state="translated">활성화 된 환경에서 다음 명령을 사용하여 Flask를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="5cf10057ee349ea81d4a2c30fb8f6b3e1f3dba10" translate="yes" xml:space="preserve">
          <source>Within the given import, the command looks for an application instance named &lt;code&gt;app&lt;/code&gt; or &lt;code&gt;application&lt;/code&gt;, then any application instance. If no instance is found, the command looks for a factory function named &lt;code&gt;create_app&lt;/code&gt; or &lt;code&gt;make_app&lt;/code&gt; that returns an instance.</source>
          <target state="translated">지정된 가져 오기 내에서 명령은 &lt;code&gt;app&lt;/code&gt; 또는 &lt;code&gt;application&lt;/code&gt; 이라는 애플리케이션 인스턴스를 찾은 다음 모든 애플리케이션 인스턴스를 찾습니다 . 인스턴스가 없으면 명령은 인스턴스를 반환하는 &lt;code&gt;create_app&lt;/code&gt; 또는 &lt;code&gt;make_app&lt;/code&gt; 이라는 팩토리 함수를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="2edfb5fdcbb446c6233ab769a480e6a1eb85d46b" translate="yes" xml:space="preserve">
          <source>Without such an explicit application object the following code:</source>
          <target state="translated">이러한 명시적인 응용 프로그램 개체가 없으면 다음 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ded186b0185fad2c663e992ba2b819e1d95a9cc7" translate="yes" xml:space="preserve">
          <source>Without the &lt;a href=&quot;../../api/index#flask.stream_with_context&quot;&gt;&lt;code&gt;stream_with_context()&lt;/code&gt;&lt;/a&gt; function you would get a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; at that point.</source>
          <target state="translated">&lt;a href=&quot;../../api/index#flask.stream_with_context&quot;&gt; &lt;code&gt;stream_with_context()&lt;/code&gt; &lt;/a&gt; 함수가 없으면 해당 지점에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="82022f415aa2304fa555c4874534511aebb29b09" translate="yes" xml:space="preserve">
          <source>Working with Blueprints</source>
          <target state="translated">블루 프린트 작업</target>
        </trans-unit>
        <trans-unit id="174dfaa3b837fd42113fd4b450ec06ae175bd24c" translate="yes" xml:space="preserve">
          <source>Working with Debuggers</source>
          <target state="translated">디버거 작업</target>
        </trans-unit>
        <trans-unit id="8e91ae4e49f91300d85f9ba8895465dc940a2f4f" translate="yes" xml:space="preserve">
          <source>Working with Fabric is fun and you will notice that it&amp;rsquo;s quite magical to type &lt;code&gt;fab deploy&lt;/code&gt; and see your application being deployed automatically to one or more remote servers.</source>
          <target state="translated">Fabric으로 작업하는 것은 재미 있으며 &lt;code&gt;fab deploy&lt;/code&gt; 를 입력 하고 하나 이상의 원격 서버에 애플리케이션이 자동으로 배포되는 것을 보는 것이 매우 마술 적이라는 것을 알게 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5c7ec70627234962f0a47ddb780aaca80066a4d5" translate="yes" xml:space="preserve">
          <source>Working with Virtual Environments</source>
          <target state="translated">가상 환경 작업</target>
        </trans-unit>
        <trans-unit id="5962457b820c4c6e261a2c144cd8a01a0d9e31ec" translate="yes" xml:space="preserve">
          <source>Working with the Shell</source>
          <target state="translated">셸 작업</target>
        </trans-unit>
        <trans-unit id="aa95b4eb1753a08bb133e2cb9411a34b99fac635" translate="yes" xml:space="preserve">
          <source>Working with this Document</source>
          <target state="translated">이 문서 작업</target>
        </trans-unit>
        <trans-unit id="ea7207f47a6cecde08b584e2bc317e220ad1a6bd" translate="yes" xml:space="preserve">
          <source>Works exactly like a dict but provides ways to fill it from files or special dictionaries. There are two common patterns to populate the config.</source>
          <target state="translated">dict와 똑같이 작동하지만 파일이나 특수 사전에서 채울 수있는 방법을 제공합니다. 구성을 채우는 데는 두 가지 일반적인 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4abba765ed12c340a7b3f93bc430769734fb1cde" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#flask.Blueprint.record&quot;&gt;&lt;code&gt;record()&lt;/code&gt;&lt;/a&gt; but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.</source>
          <target state="translated">&lt;a href=&quot;#flask.Blueprint.record&quot;&gt; &lt;code&gt;record()&lt;/code&gt; &lt;/a&gt; 처럼 작동 하지만 함수가 한 번만 호출되도록하는 다른 함수로 함수를 래핑합니다. 청사진이 애플리케이션에 두 번째로 등록되면 전달 된 함수가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af16180fe9c836cb3c8620984015754fd76bd557" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#flask.has_request_context&quot;&gt;&lt;code&gt;has_request_context()&lt;/code&gt;&lt;/a&gt; but for the application context. You can also just do a boolean check on the &lt;a href=&quot;#flask.current_app&quot;&gt;&lt;code&gt;current_app&lt;/code&gt;&lt;/a&gt; object instead.</source>
          <target state="translated">&lt;a href=&quot;#flask.has_request_context&quot;&gt; &lt;code&gt;has_request_context()&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 응용 프로그램 컨텍스트에 대해 작동합니다. 대신 &lt;a href=&quot;#flask.current_app&quot;&gt; &lt;code&gt;current_app&lt;/code&gt; &lt;/a&gt; 객체 에서 부울 검사를 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b7d2b65bd7a2ebb1ffea7d8ba55adb9788a66b1" translate="yes" xml:space="preserve">
          <source>Works like a regular Werkzeug test client but has some knowledge about how Flask works to defer the cleanup of the request context stack to the end of a &lt;code&gt;with&lt;/code&gt; body when used in a &lt;code&gt;with&lt;/code&gt; statement. For general information about how to use this class refer to &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client&quot;&gt;&lt;code&gt;werkzeug.test.Client&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 Werkzeug 테스트 클라이언트처럼 작동하지만 , &lt;code&gt;with&lt;/code&gt; 문 에서 사용될 때 요청 컨텍스트 스택의 정리를 &lt;code&gt;with&lt;/code&gt; 본문 의 끝까지 연기하는 Flask 작동 방식에 대한 지식이 있습니다. 이 클래스를 사용하는 방법에 대한 일반적인 정보는 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/test/#werkzeug.test.Client&quot;&gt; &lt;code&gt;werkzeug.test.Client&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="658a4eab006ab7fa193f4ca8097129fa50591b9f" translate="yes" xml:space="preserve">
          <source>Would look like this instead:</source>
          <target state="translated">대신 다음과 같이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="b61966a6eb8b4a6698bc9475263ea8c711f2b9d9" translate="yes" xml:space="preserve">
          <source>Wrap with middleware.</source>
          <target state="translated">미들웨어로 감싸십시오.</target>
        </trans-unit>
        <trans-unit id="740e3b31cb73b82925495c4bf9da460f8228f3a8" translate="yes" xml:space="preserve">
          <source>Wrapping &lt;code&gt;app.wsgi_app&lt;/code&gt; instead of &lt;code&gt;app&lt;/code&gt; means that &lt;code&gt;app&lt;/code&gt; still points at your Flask application, not at the middleware, so you can continue to use and configure &lt;code&gt;app&lt;/code&gt; directly.</source>
          <target state="translated">포장 &lt;code&gt;app.wsgi_app&lt;/code&gt; 대신 &lt;code&gt;app&lt;/code&gt; 을 의미 &lt;code&gt;app&lt;/code&gt; 하여 플라스크 응용 프로그램에서 아직 포인트가 아닌 미들웨어에서, 당신은 계속 사용하고 구성 할 수 있습니다 &lt;code&gt;app&lt;/code&gt; 직접.</target>
        </trans-unit>
        <trans-unit id="0f51226c51b17263badab9df2106d7cff82896c0" translate="yes" xml:space="preserve">
          <source>Wrapping header elements in &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; or the body elements in &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 의 헤더 요소 또는 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 의 본문 요소 래핑</target>
        </trans-unit>
        <trans-unit id="1f81513709adf5d23b6dade29c1709cf60afacea" translate="yes" xml:space="preserve">
          <source>Wrapping the document in an &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; tag</source>
          <target state="translated">&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 태그로 문서 감싸기</target>
        </trans-unit>
        <trans-unit id="08243519171e58eb5620942b8910f8f357da7888" translate="yes" xml:space="preserve">
          <source>Wraps a callback so that it&amp;rsquo;s guaranteed to be executed with the script&amp;rsquo;s application context. If callbacks are registered directly to the &lt;code&gt;app.cli&lt;/code&gt; object then they are wrapped with this function by default unless it&amp;rsquo;s disabled.</source>
          <target state="translated">스크립트의 응용 프로그램 컨텍스트로 실행되도록 콜백을 래핑합니다. 콜백이 &lt;code&gt;app.cli&lt;/code&gt; 객체에 직접 등록 된 경우 비활성화되지 않는 한 기본적으로이 함수로 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b1d3f473c48021046e7ba3468f5cf21e1b0e7ddd" translate="yes" xml:space="preserve">
          <source>X-Content-Type-Options</source>
          <target state="translated">X-Content-Type-Options</target>
        </trans-unit>
        <trans-unit id="06d18ff7a6daa0422e0cad3f72e863617cee9d06" translate="yes" xml:space="preserve">
          <source>X-Frame-Options</source>
          <target state="translated">X-Frame-Options</target>
        </trans-unit>
        <trans-unit id="c7215a317b6dd9b4629392c1b06074727d0d0713" translate="yes" xml:space="preserve">
          <source>X-XSS-Protection</source>
          <target state="translated">X-XSS-Protection</target>
        </trans-unit>
        <trans-unit id="a6a5d99b17036813c63f08d13c7714df3b475074" translate="yes" xml:space="preserve">
          <source>XHTML 1.0 is the last XHTML standard that allows to be served as &lt;code&gt;text/html&lt;/code&gt; for backwards compatibility reasons.</source>
          <target state="translated">XHTML 1.0은 이전 버전과의 호환성을 위해 &lt;code&gt;text/html&lt;/code&gt; 로 제공 할 수있는 마지막 XHTML 표준입니다 .</target>
        </trans-unit>
        <trans-unit id="bda24e4e25235f523a1e01a6e41ad928b404f09d" translate="yes" xml:space="preserve">
          <source>XHTML also changed the way JavaScript is used. To properly work with XHTML, programmers have to use the namespaced DOM interface with the XHTML namespace to query for HTML elements.</source>
          <target state="translated">XHTML은 또한 JavaScript가 사용되는 방식을 변경했습니다. XHTML로 제대로 작업하려면 프로그래머는 XHTML 네임 스페이스와 함께 네임 스페이스 DOM 인터페이스를 사용하여 HTML 요소를 쿼리해야합니다.</target>
        </trans-unit>
        <trans-unit id="39bd3f4531a613bddcbdda33a96b21dae6406a84" translate="yes" xml:space="preserve">
          <source>XHTML1.1</source>
          <target state="translated">XHTML1.1</target>
        </trans-unit>
        <trans-unit id="d4d7254077087144effdb1513a82294c56883462" translate="yes" xml:space="preserve">
          <source>Yes it is usually not such a bright idea to use thread locals. They cause troubles for servers that are not based on the concept of threads and make large applications harder to maintain. However Flask is just not designed for large applications or asynchronous servers. Flask wants to make it quick and easy to write a traditional web application.</source>
          <target state="translated">예, 일반적으로 스레드 로컬을 사용하는 것은 그렇게 밝은 생각이 아닙니다. 스레드 개념에 기반하지 않은 서버에 문제를 일으키고 대규모 애플리케이션을 유지 관리하기 어렵게 만듭니다. 그러나 Flask는 대규모 응용 프로그램이나 비동기 서버용으로 설계되지 않았습니다. Flask는 기존 웹 애플리케이션을 빠르고 쉽게 작성하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="1f3136380e3ce32df5b6cde5bb51ed47e0e4277b" translate="yes" xml:space="preserve">
          <source>You can access this from Python code like this:</source>
          <target state="translated">다음과 같이 Python 코드에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09586c1075eecf1c5e26ddb7ff9daf06bf262694" translate="yes" xml:space="preserve">
          <source>You can add variable sections to a URL by marking sections with &lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt;. Your function then receives the &lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt; as a keyword argument. Optionally, you can use a converter to specify the type of the argument like &lt;code&gt;&amp;lt;converter:variable_name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt; 으로 섹션을 표시하여 URL에 변수 섹션을 추가 할 수 있습니다 . 그러면 함수는 &lt;code&gt;&amp;lt;variable_name&amp;gt;&lt;/code&gt; 을 키워드 인수로받습니다. 선택적으로 변환기를 사용하여 &lt;code&gt;&amp;lt;converter:variable_name&amp;gt;&lt;/code&gt; 과 같은 인수 유형을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13a798184000342bdc31c2a5d39aa34d03700383" translate="yes" xml:space="preserve">
          <source>You can also control debug mode separately from the environment by exporting &lt;code&gt;FLASK_DEBUG=1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FLASK_DEBUG=1&lt;/code&gt; 을 내 보내서 환경과 별도로 디버그 모드를 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="735c2a045909269887c922feb75c408a35900aed" translate="yes" xml:space="preserve">
          <source>You can also define multiple rules for the same function. They have to be unique however. Defaults can also be specified. Here for example is a definition for a URL that accepts an optional page:</source>
          <target state="translated">동일한 기능에 대해 여러 규칙을 정의 할 수도 있습니다. 그러나 그들은 독특해야합니다. 기본값도 지정할 수 있습니다. 다음은 선택적 페이지를 허용하는 URL에 대한 정의입니다.</target>
        </trans-unit>
        <trans-unit id="c07d08db159eb42de824b9b610a9aa3c991453bc" translate="yes" xml:space="preserve">
          <source>You can also pass strings of SQL statements to the &lt;code&gt;execute()&lt;/code&gt; method:</source>
          <target state="translated">SQL 문의 문자열을 &lt;code&gt;execute()&lt;/code&gt; 메서드에 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54ed7476202f966af3321d87dd224a1e7c1875f4" translate="yes" xml:space="preserve">
          <source>You can also register handlers for arbitrary exceptions:</source>
          <target state="translated">임의의 예외에 대한 핸들러를 등록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d214d9a4e07beaff0c04d1de76e20e5640f7609" translate="yes" xml:space="preserve">
          <source>You can alter the group name by specifying the &lt;code&gt;cli_group&lt;/code&gt; parameter when creating the &lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt;&lt;code&gt;Blueprint&lt;/code&gt;&lt;/a&gt; object, or later with &lt;a href=&quot;../api/index#flask.Flask.register_blueprint&quot;&gt;&lt;code&gt;app.register_blueprint(bp, cli_group='...')&lt;/code&gt;&lt;/a&gt;. The following are equivalent:</source>
          <target state="translated">&lt;a href=&quot;../api/index#flask.Blueprint&quot;&gt; &lt;code&gt;Blueprint&lt;/code&gt; &lt;/a&gt; 객체를 생성 할 때 &lt;code&gt;cli_group&lt;/code&gt; 파라미터 를 지정 하거나 나중에 &lt;a href=&quot;../api/index#flask.Flask.register_blueprint&quot;&gt; &lt;code&gt;app.register_blueprint(bp, cli_group='...')&lt;/code&gt; &lt;/a&gt; 하여 그룹 이름을 변경할 수 있습니다 . 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7bc1d29b17b575666e4a90412225f097a550cd2b" translate="yes" xml:space="preserve">
          <source>You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs.</source>
          <target state="translated">하드 코딩 된 URL을 수동으로 변경하는 것을 기억할 필요없이 한 번에 URL을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ffc15f46b9fc31451c1c483533ea6a89df66fd3" translate="yes" xml:space="preserve">
          <source>You can directly access the underlying Werkzeug routing system which is exposed as &lt;a href=&quot;#flask.Flask.url_map&quot;&gt;&lt;code&gt;flask.Flask.url_map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#flask.Flask.url_map&quot;&gt; &lt;code&gt;flask.Flask.url_map&lt;/code&gt; &lt;/a&gt; 으로 노출되는 기본 Werkzeug 라우팅 시스템에 직접 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="984bdc98632cae814fe71e5886652cb89c6f02a5" translate="yes" xml:space="preserve">
          <source>You can do more! You can make parts of the URL dynamic and attach multiple rules to a function.</source>
          <target state="translated">더 많은 일을 할 수 있습니다! URL의 일부를 동적으로 만들고 함수에 여러 규칙을 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e8721c2666e9d94927a964e4bfa0d0fd1c1b0a2" translate="yes" xml:space="preserve">
          <source>You can download &lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy&lt;/a&gt; from &lt;a href=&quot;https://pypi.org/project/Flask-SQLAlchemy/&quot;&gt;PyPI&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://flask-sqlalchemy.palletsprojects.com/&quot;&gt;Flask-SQLAlchemy&lt;/a&gt; 는 &lt;a href=&quot;https://pypi.org/project/Flask-SQLAlchemy/&quot;&gt;PyPI&lt;/a&gt; 에서 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1841a7437382f970ce54e43474bd5546830e026a" translate="yes" xml:space="preserve">
          <source>You can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the &lt;code&gt;instance_path&lt;/code&gt; parameter:</source>
          <target state="translated">Flask 애플리케이션을 만들 때 인스턴스 폴더의 경로를 명시 적으로 제공하거나 Flask가 인스턴스 폴더를 자동 감지하도록 할 수 있습니다. 명시 적 구성을 위해 &lt;code&gt;instance_path&lt;/code&gt; 매개 변수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2c612caac21987cc43757018ba10328146f3bed" translate="yes" xml:space="preserve">
          <source>You can further optimize this in terms of amount of keystrokes needed to write this by having a function that calls into &lt;a href=&quot;../../api/index#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;add_url_rule()&lt;/code&gt;&lt;/a&gt; by prefixing a string with the project name and a dot, and by wrapping &lt;code&gt;view_func&lt;/code&gt; in a &lt;code&gt;LazyView&lt;/code&gt; as needed.</source>
          <target state="translated">프로젝트 이름과 점을 문자열에 접두사 로 &lt;code&gt;LazyView&lt;/code&gt; 하고 필요에 따라 &lt;code&gt;view_func&lt;/code&gt; 에서 view_func 를 래핑 하여 &lt;a href=&quot;../../api/index#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;add_url_rule()&lt;/code&gt; &lt;/a&gt; 을 호출하는 함수를 사용하여이를 작성하는 데 필요한 키 입력의 양 측면에서이를 최적화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fc74331c51a31cc667477b55c84860ef9ff5efa" translate="yes" xml:space="preserve">
          <source>You can handle uploaded files with Flask easily. Just make sure not to forget to set the &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt; attribute on your HTML form, otherwise the browser will not transmit your files at all.</source>
          <target state="translated">Flask로 업로드 된 파일을 쉽게 처리 할 수 ​​있습니다. HTML 양식에 &lt;code&gt;enctype=&quot;multipart/form-data&quot;&lt;/code&gt; 속성 을 설정하는 것을 잊지 마십시오 . 그렇지 않으면 브라우저가 파일을 전혀 전송하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd9da2c829c808ae14ff97b60dd99fcb9a6b4883" translate="yes" xml:space="preserve">
          <source>You can insert entries into the database like this:</source>
          <target state="translated">다음과 같이 데이터베이스에 항목을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1d53f100f52d39105a86264c6559de894d8334" translate="yes" xml:space="preserve">
          <source>You can instead just do this:</source>
          <target state="translated">대신 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7f86adef7d97a12c6e377396fd8ca61a55243a" translate="yes" xml:space="preserve">
          <source>You can now do something like this:</source>
          <target state="translated">이제 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a2c49b664210fffc70a580adc0af1ac23349ed7" translate="yes" xml:space="preserve">
          <source>You can place one or more decorators in this list and whenever the view function is created the result is automatically decorated.</source>
          <target state="translated">이 목록에 하나 이상의 데코레이터를 배치 할 수 있으며보기 기능이 생성 될 때마다 결과가 자동으로 데코 레이팅됩니다.</target>
        </trans-unit>
        <trans-unit id="1da6800140a00549a2a623ca1a3a17260035bf50" translate="yes" xml:space="preserve">
          <source>You can skip this next step if you&amp;rsquo;re using &lt;a href=&quot;#dotenv&quot;&gt;Environment Variables From dotenv&lt;/a&gt;. We need to add an environment variable (&lt;strong&gt;C&lt;/strong&gt;) to identify our application. Click on the browse button and add an entry with &lt;code&gt;FLASK_APP&lt;/code&gt; on the left and the Python import or file on the right (&lt;code&gt;hello&lt;/code&gt; for example). Add an entry with &lt;code&gt;FLASK_ENV&lt;/code&gt; and set it to &lt;code&gt;development&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#dotenv&quot;&gt;dotenv의 환경 변수를&lt;/a&gt; 사용하는 경우이 다음 단계를 건너 뛸 수 있습니다 . 애플리케이션을 식별 하려면 환경 변수 ( &lt;strong&gt;C&lt;/strong&gt; ) 를 추가해야 합니다. 찾아보기 버튼을 클릭 하고 왼쪽에 &lt;code&gt;FLASK_APP&lt;/code&gt; 이 있고 오른쪽에 Python 가져 오기 또는 파일이 있는 항목을 추가합니다 ( 예 : &lt;code&gt;hello&lt;/code&gt; ). 에 항목 추가 &lt;code&gt;FLASK_ENV&lt;/code&gt; 를 하고로 설정 &lt;code&gt;development&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6483d3813ab3e4bbce930c0177fee5b4b04ae4c2" translate="yes" xml:space="preserve">
          <source>You can tell Flask not to load dotenv files even when python-dotenv is installed by setting the &lt;code&gt;FLASK_SKIP_DOTENV&lt;/code&gt; environment variable. This can be useful if you want to load them manually, or if you&amp;rsquo;re using a project runner that loads them already. Keep in mind that the environment variables must be set before the app loads or it won&amp;rsquo;t configure as expected.</source>
          <target state="translated">&lt;code&gt;FLASK_SKIP_DOTENV&lt;/code&gt; 환경 변수를 설정하여 python-dotenv가 설치된 경우에도 Flask에 dotenv 파일을로드하지 않도록 지시 할 수 있습니다 . 수동으로로드하려는 경우 또는 이미로드 한 프로젝트 실행기를 사용하는 경우 유용 할 수 있습니다. 앱이로드되기 전에 환경 변수를 설정해야합니다. 그렇지 않으면 예상대로 구성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="360d91d2ad0114d0798c198d383101249bada607" translate="yes" xml:space="preserve">
          <source>You can then create such a database from the Python shell:</source>
          <target state="translated">그런 다음 Python 셸에서 이러한 데이터베이스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08695aa15a5b055d73bcc0d2bca100ad13902124" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalProxy&quot;&gt;&lt;code&gt;LocalProxy&lt;/code&gt;&lt;/a&gt; to make a new context local from &lt;code&gt;get_db()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/local/#werkzeug.local.LocalProxy&quot;&gt; &lt;code&gt;LocalProxy&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;get_db()&lt;/code&gt; 에서 새 컨텍스트를 로컬로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47f8c607be57c7e02cb9fab7cb7b0024d86b7c09" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt;&lt;code&gt;flask.Flask.add_url_rule()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#flask.Flask.add_url_rule&quot;&gt; &lt;code&gt;flask.Flask.add_url_rule()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0033b8cf3589b920481f85c256e584b5e0fcaf7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#flask.Flask.route&quot;&gt;&lt;code&gt;flask.Flask.route()&lt;/code&gt;&lt;/a&gt; decorator.</source>
          <target state="translated">&lt;a href=&quot;#flask.Flask.route&quot;&gt; &lt;code&gt;flask.Flask.route()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26aa41ee25e6511c598ffd1f66556225da3cc416" translate="yes" xml:space="preserve">
          <source>You could also build &lt;code&gt;format_price&lt;/code&gt; as a template filter (see &lt;a href=&quot;#registering-filters&quot;&gt;Registering Filters&lt;/a&gt;), but this demonstrates how to pass functions in a context processor.</source>
          <target state="translated">&lt;code&gt;format_price&lt;/code&gt; 를 템플릿 필터로 빌드 할 수도 있지만 ( &lt;a href=&quot;#registering-filters&quot;&gt;필터 등록&lt;/a&gt; 참조 ) 이는 컨텍스트 프로세서에서 함수를 전달하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="06e519ae82314491880a1655b2f4854bdd260692" translate="yes" xml:space="preserve">
          <source>You could also put your application code into a repository and check out the latest version on the server and then install. That way you can also easily go back to older versions.</source>
          <target state="translated">애플리케이션 코드를 저장소에 넣고 서버에서 최신 버전을 확인한 다음 설치할 수도 있습니다. 이렇게하면 이전 버전으로 쉽게 돌아갈 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4bce016fc9ebac48214337e2a1de5a11069c45" translate="yes" xml:space="preserve">
          <source>You have an &lt;code&gt;app.run()&lt;/code&gt; call in your application file that is not guarded by an &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; condition. Either remove that &lt;a href=&quot;../../api/index#flask.Flask.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; call from the file and move it into a separate &lt;code&gt;run.py&lt;/code&gt; file or put it into such an if block.</source>
          <target state="translated">당신은이 &lt;code&gt;app.run()&lt;/code&gt; 에 의해 보호되지 않는 응용 프로그램 파일에서 호출 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 조건을. 파일에서 해당 &lt;a href=&quot;../../api/index#flask.Flask.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 호출을 제거 하고 별도의 &lt;code&gt;run.py&lt;/code&gt; 파일 로 이동 하거나 if 블록에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="c9aef93067b1b7feb6791fe058c941f0937284cd" translate="yes" xml:space="preserve">
          <source>You just need to wrap the return expression with &lt;a href=&quot;../api/index#flask.make_response&quot;&gt;&lt;code&gt;make_response()&lt;/code&gt;&lt;/a&gt; and get the response object to modify it, then return it:</source>
          <target state="translated">반환 표현식을 &lt;a href=&quot;../api/index#flask.make_response&quot;&gt; &lt;code&gt;make_response()&lt;/code&gt; &lt;/a&gt; 로 래핑하고 응답 객체를 가져와 수정 한 다음 반환하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ccb316b6f984e4a0d0734c1e9d3210e73911985c" translate="yes" xml:space="preserve">
          <source>You may still want to log that something fishy happened. This is where loggers come in handy. As of Flask 0.3 a logger is preconfigured for you to use.</source>
          <target state="translated">수상한 일이 발생했음을 여전히 기록 할 수 있습니다. 이것은 로거가 유용한 곳입니다. Flask 0.3부터 로거는 사용자가 사용할 수 있도록 미리 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="131a474e8d2db7a2ce99cea260c961a79a516952" translate="yes" xml:space="preserve">
          <source>You might find this helpful for unittests where you need the information from the context local around for a little longer. Make sure to properly &lt;code&gt;pop()&lt;/code&gt; the stack yourself in that situation, otherwise your unittests will leak memory.</source>
          <target state="translated">조금 더 오랫동안 로컬 컨텍스트의 정보가 필요한 단위 테스트에 유용 할 수 있습니다. 해당 상황에서 스택 을 올바르게 &lt;code&gt;pop()&lt;/code&gt; 해야합니다. 그렇지 않으면 unittest에서 메모리가 누수됩니다.</target>
        </trans-unit>
        <trans-unit id="4087f0e14a4fc2025a17cd9f490cadae80a8e78b" translate="yes" xml:space="preserve">
          <source>You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers.</source>
          <target state="translated">오류가 발생하면 사용자에게 사용자 지정 오류 페이지를 표시 할 수 있습니다. 이는 오류 처리기를 등록하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c387a2ea009900c09409376e8f474b91f18a442" translate="yes" xml:space="preserve">
          <source>You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with &lt;a href=&quot;#flask.Config.from_pyfile&quot;&gt;&lt;code&gt;from_pyfile()&lt;/code&gt;&lt;/a&gt; and ideally from a location not within the package because the package might be installed system wide.</source>
          <target state="translated">이 기능을 사용하여 실제 구성을로드하지 말고 구성 기본값을로드해야합니다. 실제 구성은 &lt;a href=&quot;#flask.Config.from_pyfile&quot;&gt; &lt;code&gt;from_pyfile()&lt;/code&gt; &lt;/a&gt; 하여 로드해야하며 패키지가 시스템 전체에 설치 될 수 있으므로 패키지 내에없는 위치에서 로드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="afed527d7fe63d12afd6f537cf3ead38ff61b4bc" translate="yes" xml:space="preserve">
          <source>You should then end up with something like that:</source>
          <target state="translated">그러면 다음과 같은 결과를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="ca217b5e5b4a7e2a4079ec329762d36dfbd58657" translate="yes" xml:space="preserve">
          <source>Your application probably is a single .py file you symlinked into the site-packages folder. Please be aware that this does not work, instead you either have to put the folder into the pythonpath the file is stored in, or convert your application into a package.</source>
          <target state="translated">응용 프로그램은 아마도 사이트 패키지 폴더에 심볼릭 링크 한 단일 .py 파일 일 것입니다. 이것은 작동하지 않습니다. 대신 파일이 저장된 pythonpath에 폴더를 넣거나 응용 프로그램을 패키지로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="793e39ae6efa6796aa3799fc56e6e5b36f9bcd06" translate="yes" xml:space="preserve">
          <source>Your function must take one parameter, an instance of &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt; and return a new response object or the same (see &lt;a href=&quot;#flask.Flask.process_response&quot;&gt;&lt;code&gt;process_response()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수는 하나의 매개 변수, &lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 가져 와서 새로운 응답 객체를 반환 해야합니다 ( &lt;a href=&quot;#flask.Flask.process_response&quot;&gt; &lt;code&gt;process_response()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3aa5c2fe53f1c07b3ac2fdcbca7b97d864161297" translate="yes" xml:space="preserve">
          <source>Your index.html template either has to extend a &lt;code&gt;layout.html&lt;/code&gt; template with jQuery loaded and the &lt;code&gt;$SCRIPT_ROOT&lt;/code&gt; variable set, or do that on the top. Here&amp;rsquo;s the HTML code needed for our little application (&lt;code&gt;index.html&lt;/code&gt;). Notice that we also drop the script directly into the HTML here. It is usually a better idea to have that in a separate script file:</source>
          <target state="translated">index.html 템플릿은 jQuery &lt;code&gt;$SCRIPT_ROOT&lt;/code&gt; 드되고 $ SCRIPT_ROOT 변수가 설정된 &lt;code&gt;layout.html&lt;/code&gt; 템플릿 을 확장 하거나 맨 위에서 수행해야합니다. 다음은 우리의 작은 애플리케이션 ( &lt;code&gt;index.html&lt;/code&gt; )에 필요한 HTML 코드 입니다. 여기에서 스크립트를 HTML에 직접 놓는 것도 주목하십시오. 일반적으로 별도의 스크립트 파일에 포함하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9f0da206cf401eaf4f08889caadd9b50cfcd7e96" translate="yes" xml:space="preserve">
          <source>Your setup code always goes into a file named &lt;code&gt;setup.py&lt;/code&gt; next to your application. The name of the file is only convention, but because everybody will look for a file with that name, you better not change it.</source>
          <target state="translated">설정 코드는 항상 애플리케이션 옆에있는 &lt;code&gt;setup.py&lt;/code&gt; 파일에 저장 됩니다. 파일 이름은 관례 일 뿐이지 만 모든 사람이 해당 이름을 가진 파일을 찾게되므로 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="56ddffc04b417958566e4f6b3cd5b2756a0b2d24" translate="yes" xml:space="preserve">
          <source>Your shell prompt will change to show the name of the activated environment.</source>
          <target state="translated">활성화 된 환경의 이름을 표시하도록 쉘 프롬프트가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="00d6c9fb75aaf9f3bd3e1c0e3bc9ef2fba03017f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.Result&quot;&gt;&lt;code&gt;Result&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;https://click.palletsprojects.com/en/7.x/api/#click.testing.Result&quot;&gt; &lt;code&gt;Result&lt;/code&gt; &lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2450b54b8a547a6079ccd10a7df3d2f50aefe2c1" translate="yes" xml:space="preserve">
          <source>a backend server overloaded</source>
          <target state="translated">백엔드 서버 과부하</target>
        </trans-unit>
        <trans-unit id="8b54e3e39c211c1d2ed964bb67b3ce7615ba831f" translate="yes" xml:space="preserve">
          <source>a dictionary with all options that were passed to the &lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt;&lt;code&gt;register_blueprint()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#flask.Flask.register_blueprint&quot;&gt; &lt;code&gt;register_blueprint()&lt;/code&gt; &lt;/a&gt; 메서드에 전달 된 모든 옵션이있는 사전</target>
        </trans-unit>
        <trans-unit id="dc884e9bb787bf47ef4edbab4e6fa2e77f432c05" translate="yes" xml:space="preserve">
          <source>a filesystem is full</source>
          <target state="translated">파일 시스템이 가득 찼습니다</target>
        </trans-unit>
        <trans-unit id="b6cb00de8b8b56e0903b4feb0e38730544748a4c" translate="yes" xml:space="preserve">
          <source>a harddrive crashed</source>
          <target state="translated">하드 드라이브가 추락</target>
        </trans-unit>
        <trans-unit id="65bbce0e91382b668dfe4edd6c02e9b88f6a133d" translate="yes" xml:space="preserve">
          <source>a new WSGI callable</source>
          <target state="translated">새로운 WSGI 콜 러블</target>
        </trans-unit>
        <trans-unit id="4671c349c92f6e9fdad6ee703f94caae27ee6da4" translate="yes" xml:space="preserve">
          <source>a new response object or the same, has to be an instance of &lt;a href=&quot;#flask.Flask.response_class&quot;&gt;&lt;code&gt;response_class&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 응답 객체 또는 동일한 객체는 &lt;a href=&quot;#flask.Flask.response_class&quot;&gt; &lt;code&gt;response_class&lt;/code&gt; &lt;/a&gt; 의 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="e7673ad4b36808b0f7db947f79d48ddd260aa6fa" translate="yes" xml:space="preserve">
          <source>a place where extensions can store application specific state. For example this is where an extension could store database engines and similar things. For backwards compatibility extensions should register themselves like this:</source>
          <target state="translated">확장 프로그램이 애플리케이션 특정 상태를 저장할 수있는 장소입니다. 예를 들어 이것은 확장이 데이터베이스 엔진과 유사한 것들을 저장할 수있는 곳입니다. 이전 버전과의 호환성 확장은 다음과 같이 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f14a3f9a798fcf78cff84703b5bb18e6a7c9473" translate="yes" xml:space="preserve">
          <source>a programming error in a library you are using</source>
          <target state="translated">사용중인 라이브러리의 프로그래밍 오류</target>
        </trans-unit>
        <trans-unit id="1e615b318ad6d9a03cb112c79943b5bdbdf834e1" translate="yes" xml:space="preserve">
          <source>a reference to the blueprint that created this setup state.</source>
          <target state="translated">이 설정 상태를 생성 한 청사진에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="58d3625eb6247ee9032d7d40f1d9803825e9f0b9" translate="yes" xml:space="preserve">
          <source>a reference to the current application</source>
          <target state="translated">현재 애플리케이션에 대한 참조</target>
        </trans-unit>
        <trans-unit id="67cfe3f11b03b091a7c1b1d270b829fcfec74ce1" translate="yes" xml:space="preserve">
          <source>a string: in this case the object with that name will be imported</source>
          <target state="translated">문자열 :이 경우 해당 이름을 가진 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="16108f3b3b62f856e8b62b403c6463f1dd1665de" translate="yes" xml:space="preserve">
          <source>a template has the ability to opt in/out autoescaping with the &lt;code&gt;{% autoescape %}&lt;/code&gt; tag.</source>
          <target state="translated">템플릿에는 &lt;code&gt;{% autoescape %}&lt;/code&gt; 태그를 사용하여 자동 이스케이프를 선택 / 선택 해제 할 수있는 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc89470cf6ccba89f0885c9b9c825819a09c012f" translate="yes" xml:space="preserve">
          <source>accepts UUID strings</source>
          <target state="translated">UUID 문자열 허용</target>
        </trans-unit>
        <trans-unit id="73920f8fabb6e4df93d4e0c0fb0007d5917c26c4" translate="yes" xml:space="preserve">
          <source>accepts any text without a slash (the default)</source>
          <target state="translated">슬래시가없는 모든 텍스트를 허용합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="6aac90ae348c2df71fe04c7e2412a63945a41c85" translate="yes" xml:space="preserve">
          <source>accepts integers</source>
          <target state="translated">정수 허용</target>
        </trans-unit>
        <trans-unit id="9fd792ff5273d01b2ec1a20e9ab350d77a4b393f" translate="yes" xml:space="preserve">
          <source>accepts positive floating point values</source>
          <target state="translated">양의 부동 소수점 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8c872cecc579af8eff46d4c028a80edc0a46c6d2" translate="yes" xml:space="preserve">
          <source>accepts positive integers</source>
          <target state="translated">양의 정수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c4989e7b489e0e12580f117ad3fc69849ac688f4" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.ctx._AppCtxGlobals&quot;&gt;&lt;code&gt;flask.ctx._AppCtxGlobals&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.ctx._AppCtxGlobals&quot;&gt; &lt;code&gt;flask.ctx._AppCtxGlobals&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="cb35c19247ab4bad6b6e062619e8b816ffc02d6e" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.json.JSONDecoder&quot;&gt;&lt;code&gt;flask.json.JSONDecoder&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.json.JSONDecoder&quot;&gt; &lt;code&gt;flask.json.JSONDecoder&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="66651beedc7e81d8e380d4fcd15453801383a5a9" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.json.JSONEncoder&quot;&gt;&lt;code&gt;flask.json.JSONEncoder&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.json.JSONEncoder&quot;&gt; &lt;code&gt;flask.json.JSONEncoder&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="690767bb0c2669b4ca83625b253dc199e64911cc" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.sessions.NullSession&quot;&gt;&lt;code&gt;NullSession&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.sessions.NullSession&quot;&gt; &lt;code&gt;NullSession&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="09fa8da242d22107a8cfa434a0016e8a0bf9c7c3" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;#flask.sessions.SecureCookieSession&quot;&gt;&lt;code&gt;SecureCookieSession&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#flask.sessions.SecureCookieSession&quot;&gt; &lt;code&gt;SecureCookieSession&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="a73b23479970f8c02dcbabd2cdd2419665a96c53" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableList&quot;&gt;&lt;code&gt;werkzeug.datastructures.ImmutableList&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableList&quot;&gt; &lt;code&gt;werkzeug.datastructures.ImmutableList&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="66290f21838c7a15b714447f70aeef154dd517b4" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt;&lt;code&gt;werkzeug.datastructures.ImmutableMultiDict&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.ImmutableMultiDict&quot;&gt; &lt;code&gt;werkzeug.datastructures.ImmutableMultiDict&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="5281cc7d496c8f6ed91ea46c7f60bb89553290d2" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/http/#werkzeug.formparser.FormDataParser&quot;&gt;&lt;code&gt;werkzeug.formparser.FormDataParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/http/#werkzeug.formparser.FormDataParser&quot;&gt; &lt;code&gt;werkzeug.formparser.FormDataParser&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="b053a6ac812a7c13e3ebf7e90705179dec419313" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map&quot;&gt;&lt;code&gt;werkzeug.routing.Map&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Map&quot;&gt; &lt;code&gt;werkzeug.routing.Map&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="cb0bbd02b31d9fed8c14bd74cf6ba51e71f570a6" translate="yes" xml:space="preserve">
          <source>alias of &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt;&lt;code&gt;werkzeug.routing.Rule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt; &lt;code&gt;werkzeug.routing.Rule&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="a073ce2245881b33c56658f828d261f7ec2651fc" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.config.Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.config.Config&lt;/code&gt; 의 별칭</target>
        </trans-unit>
        <trans-unit id="b5989ba4cef40c68a626cc81b29649588b8386ff" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.templating.Environment&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.templating.Environment&lt;/code&gt; 의 별칭</target>
        </trans-unit>
        <trans-unit id="33cf8b355af41b59f7b04114c18afec2353245b0" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.wrappers.Request&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.wrappers.Request&lt;/code&gt; 의 별칭</target>
        </trans-unit>
        <trans-unit id="2e4522e9eb3fd7d67055fefd7c35ad6ad1e6bff7" translate="yes" xml:space="preserve">
          <source>alias of &lt;code&gt;flask.wrappers.Response&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;flask.wrappers.Response&lt;/code&gt; 의 별칭</target>
        </trans-unit>
        <trans-unit id="5cab9c937ecf5c576b0fe8ca35ffd141b06af830" translate="yes" xml:space="preserve">
          <source>all the attached blueprints in a dictionary by name. Blueprints can be attached multiple times so this dictionary does not tell you how often they got attached.</source>
          <target state="translated">이름별로 사전에 첨부 된 모든 청사진. 블루 프린트는 여러 번 첨부 될 수 있으므로이 사전은 얼마나 자주 첨부되었는지 알려주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="410160aaf22d9d2f8eb4888d810b9db5407aeaec" translate="yes" xml:space="preserve">
          <source>all the view functions (the ones with a &lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt;&lt;code&gt;route()&lt;/code&gt;&lt;/a&gt; decorator on top) have to be imported in the &lt;code&gt;__init__.py&lt;/code&gt; file. Not the object itself, but the module it is in. Import the view module &lt;strong&gt;after the application object is created&lt;/strong&gt;.</source>
          <target state="translated">모든 뷰 함수 ( 위에 &lt;a href=&quot;../../api/index#flask.Flask.route&quot;&gt; &lt;code&gt;route()&lt;/code&gt; &lt;/a&gt; 데코레이터 가있는 함수 )는 &lt;code&gt;__init__.py&lt;/code&gt; 파일 로 가져와야 합니다. 객체 자체가 아니라 해당 모듈이 있습니다. &lt;strong&gt;응용 프로그램 객체가 생성 된 후&lt;/strong&gt; 뷰 모듈 &lt;strong&gt;을&lt;/strong&gt; 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="49181a2e1d08486dbf83e366d4338f6ecd662c9e" translate="yes" xml:space="preserve">
          <source>an actual object reference: that object is used directly</source>
          <target state="translated">실제 객체 참조 : 해당 객체가 직접 사용됨</target>
        </trans-unit>
        <trans-unit id="9515b16847e6846c43ea51cc397430476b986fed" translate="yes" xml:space="preserve">
          <source>an internal cache for the flashed messages.</source>
          <target state="translated">플래시 된 메시지를위한 내부 캐시.</target>
        </trans-unit>
        <trans-unit id="37e07b0c4e95ecdc752b79ffe45ae2bb1efa4a05" translate="yes" xml:space="preserve">
          <source>an object with all the attributes of the &lt;a href=&quot;#flask.g&quot;&gt;&lt;code&gt;flask.g&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#flask.g&quot;&gt; &lt;code&gt;flask.g&lt;/code&gt; &lt;/a&gt; 객체 의 모든 속성을 가진 객체.</target>
        </trans-unit>
        <trans-unit id="c7cfaa36598717cf613a98e5fdba5a094250b7df" translate="yes" xml:space="preserve">
          <source>and in your application.py (or equivalent):</source>
          <target state="translated">그리고 당신의 application.py (또는 동등한 것)에서 :</target>
        </trans-unit>
        <trans-unit id="8bf0d292878e774684dbb3719239f003be573ceb" translate="yes" xml:space="preserve">
          <source>as blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already.</source>
          <target state="translated">청사진은 응용 프로그램에 여러 번 등록 할 수 있고 모든 항목이 여러 번 등록되기를 원하지는 않기 때문에이 속성을 사용하여 청사진이 이미 과거에 등록되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8223feff2f9a7f1ef9e4349b456a5122ac32b65c" translate="yes" xml:space="preserve">
          <source>as long as you are using ASCII code points only (basically numbers, some special characters of Latin letters without umlauts or anything fancy) you can use regular string literals (&lt;code&gt;'Hello World'&lt;/code&gt;).</source>
          <target state="translated">ASCII 코드 포인트 만 사용하는 한 (기본적으로 숫자, 움라우트가없는 라틴 문자의 일부 특수 문자) 일반 문자열 리터럴 ( &lt;code&gt;'Hello World'&lt;/code&gt; )을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e86120103ff7602f5f66345524e7915c16237124" translate="yes" xml:space="preserve">
          <source>autoescaping is enabled for all strings when using &lt;code&gt;render_template_string()&lt;/code&gt;.</source>
          <target state="translated">사용하는 경우 autoescaping 모든 문자열을 사용할 수 있습니다 &lt;code&gt;render_template_string()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="182887cf6ecfdf4ef002369893829b23ee92ca32" translate="yes" xml:space="preserve">
          <source>autoescaping is enabled for all templates ending in &lt;code&gt;.html&lt;/code&gt;, &lt;code&gt;.htm&lt;/code&gt;, &lt;code&gt;.xml&lt;/code&gt; as well as &lt;code&gt;.xhtml&lt;/code&gt; when using &lt;code&gt;render_template()&lt;/code&gt;.</source>
          <target state="translated">자동 이스 케이 핑은 &lt;code&gt;render_template()&lt;/code&gt; 사용할 때 &lt;code&gt;.html&lt;/code&gt; , &lt;code&gt;.htm&lt;/code&gt; , &lt;code&gt;.xml&lt;/code&gt; 및 &lt;code&gt;.xhtml&lt;/code&gt; 로 끝나는 모든 템플릿에 대해 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f39411275ad23ada80267103f4b8daa8e988fdfe" translate="yes" xml:space="preserve">
          <source>bool. &lt;code&gt;True&lt;/code&gt; if able to load config, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">bool. 구성을로드 할 수 있으면 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다.</target>
        </trans-unit>
        <trans-unit id="0f39a7887e076551ace4670d7fe95e8998e83f6c" translate="yes" xml:space="preserve">
          <source>boolean that is &lt;code&gt;True&lt;/code&gt; if the application is served by a WSGI server that spawns multiple processes.</source>
          <target state="translated">여러 프로세스를 생성하는 WSGI 서버에서 애플리케이션을 제공하는 경우 &lt;code&gt;True&lt;/code&gt; 인 부울입니다 .</target>
        </trans-unit>
        <trans-unit id="2e6a184add8b1bccdad2e1862952a5a2b8016d2d" translate="yes" xml:space="preserve">
          <source>boolean that is &lt;code&gt;True&lt;/code&gt; if the application is served by a multithreaded WSGI server.</source>
          <target state="translated">다중 스레드 WSGI 서버에서 응용 프로그램을 제공하는 경우 &lt;code&gt;True&lt;/code&gt; 인 부울입니다 .</target>
        </trans-unit>
        <trans-unit id="f2b73ab96a72da4e8962bbd797c1f18d2b381964" translate="yes" xml:space="preserve">
          <source>boolean that is &lt;code&gt;True&lt;/code&gt; if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it&amp;rsquo;s not guaranteed that the execution only happens one time.</source>
          <target state="translated">응용 프로그램이 프로세스 수명 동안 한 번만 실행되는 경우 &lt;code&gt;True&lt;/code&gt; 인 부울입니다 . 예를 들어 CGI의 경우이지만 실행이 한 번만 발생한다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="362782f1ef7f7ace335abfa298fd729c16783522" translate="yes" xml:space="preserve">
          <source>calling &lt;a href=&quot;../api/index#flask.Markup&quot;&gt;&lt;code&gt;Markup&lt;/code&gt;&lt;/a&gt; on data submitted by users</source>
          <target state="translated">사용자가 제출 한 데이터에 대한 &lt;a href=&quot;../api/index#flask.Markup&quot;&gt; &lt;code&gt;Markup&lt;/code&gt; &lt;/a&gt; 호출</target>
        </trans-unit>
        <trans-unit id="c5a3472f438c362a06e8293e2f245c81093c2143" translate="yes" xml:space="preserve">
          <source>create the form from the request &lt;code&gt;form&lt;/code&gt; value if the data is submitted via the HTTP &lt;code&gt;POST&lt;/code&gt; method and &lt;code&gt;args&lt;/code&gt; if the data is submitted as &lt;code&gt;GET&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;POST&lt;/code&gt; 메소드 를 통해 데이터가 제출되면 요청 &lt;code&gt;form&lt;/code&gt; 값 에서 양식을 작성하고 데이터가 &lt;code&gt;GET&lt;/code&gt; 로 제출되면 &lt;code&gt;args&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b663758ff91fad1073f3728ff1e8a01b521d5831" translate="yes" xml:space="preserve">
          <source>default: Value to set and return if the attribute is not present.</source>
          <target state="translated">기본값 : 속성이없는 경우 설정하고 반환 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="8dad931d1e8bcc914af754ed12df94e2d4869138" translate="yes" xml:space="preserve">
          <source>encoding and decoding happens whenever you are talking over a protocol that requires bytes to be transmitted.</source>
          <target state="translated">인코딩 및 디코딩은 바이트 전송이 필요한 프로토콜을 통해 통신 할 때마다 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6ac4ed31f78fb56c3738cfa3f8b4930eb281d8e4" translate="yes" xml:space="preserve">
          <source>generating HTML without the help of Jinja2</source>
          <target state="translated">Jinja2의 도움없이 HTML 생성</target>
        </trans-unit>
        <trans-unit id="a89dffe8101396723763af2159ebf1baae75cd12" translate="yes" xml:space="preserve">
          <source>get the unique cache key for the current request based on the current path.</source>
          <target state="translated">현재 경로를 기반으로 현재 요청에 대한 고유 캐시 키를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="feba9a44c7eacc6396c7902226b22869b66381e9" translate="yes" xml:space="preserve">
          <source>get the value for that key from the cache. If the cache returned something we will return that value.</source>
          <target state="translated">캐시에서 해당 키의 값을 가져옵니다. 캐시가 무언가를 반환했다면 우리는 그 값을 반환 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="535358cd1b423cdd42aef419fc6e36ef1e7acd71" translate="yes" xml:space="preserve">
          <source>header, which allows caching proxies to cache different pages for different users.</source>
          <target state="translated">헤더를 사용하면 캐싱 프록시가 다른 사용자를 위해 다른 페이지를 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d902eba506e195d6edc2f3d81eabe797b17e974b" translate="yes" xml:space="preserve">
          <source>hook in testing functionality so that you can deploy to an external server and run the test suite.</source>
          <target state="translated">테스트 기능을 연결하여 외부 서버에 배포하고 테스트 스위트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb33e6cc47b061ed77bc263f202bed926cf18725" translate="yes" xml:space="preserve">
          <source>if more than one argument is passed, the arguments are passed to the &lt;a href=&quot;#flask.Flask.make_response&quot;&gt;&lt;code&gt;flask.Flask.make_response()&lt;/code&gt;&lt;/a&gt; function as tuple.</source>
          <target state="translated">둘 이상의 인수가 전달되면 인수는 &lt;a href=&quot;#flask.Flask.make_response&quot;&gt; &lt;code&gt;flask.Flask.make_response()&lt;/code&gt; &lt;/a&gt; 함수에 튜플로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f76d1c9d9a5811fae8d97454c6ef3710e00b5e6f" translate="yes" xml:space="preserve">
          <source>if no arguments are passed, it creates a new response argument</source>
          <target state="translated">인수가 전달되지 않으면 새 응답 인수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="62e1874b111ae27261c412adc1ad2f49a1ff858a" translate="yes" xml:space="preserve">
          <source>if one argument is passed, &lt;a href=&quot;#flask.Flask.make_response&quot;&gt;&lt;code&gt;flask.Flask.make_response()&lt;/code&gt;&lt;/a&gt; is invoked with it.</source>
          <target state="translated">하나의 인수가 전달되면 &lt;a href=&quot;#flask.Flask.make_response&quot;&gt; &lt;code&gt;flask.Flask.make_response()&lt;/code&gt; &lt;/a&gt; 가 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="417a342084b4091981d8749717e8ff0d5f0ef08c" translate="yes" xml:space="preserve">
          <source>if you are using non-Unicode characters in your Python files you have to tell Python which encoding your file uses. Again, I recommend UTF-8 for this purpose. To tell the interpreter your encoding you can put the &lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt; into the first or second line of your Python source file.</source>
          <target state="translated">Python 파일에서 유니 코드가 아닌 문자를 사용하는 경우 파일에서 사용하는 인코딩을 Python에 알려야합니다. 다시 말하지만이 목적을 위해 UTF-8을 권장합니다. 인터프리터에게 인코딩을 알리기 위해 &lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt; 을 Python 소스 파일의 첫 번째 또는 두 번째 줄에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1afc33da71707b0f0464cbc99720f3ee65ce0238" translate="yes" xml:space="preserve">
          <source>if you need anything else than ASCII in a string you have to mark this string as Unicode string by prefixing it with a lowercase &lt;code&gt;u&lt;/code&gt;. (like &lt;code&gt;u'H&amp;auml;nsel und Gretel'&lt;/code&gt;)</source>
          <target state="translated">문자열에 ASCII 이외의 것이 필요한 경우 소문자 &lt;code&gt;u&lt;/code&gt; 접두사를 붙여이 문자열을 유니 코드 문자열로 표시해야합니다 . (예 : &lt;code&gt;u'H&amp;auml;nsel und Gretel'&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d65e5d5f8dec2384b8e97081da1cbfeb9d1c3094" translate="yes" xml:space="preserve">
          <source>inline MathML</source>
          <target state="translated">인라인 MathML</target>
        </trans-unit>
        <trans-unit id="b6a430671d0a9588c117dd38b07d7158402b4b9e" translate="yes" xml:space="preserve">
          <source>inline SVG</source>
          <target state="translated">인라인 SVG</target>
        </trans-unit>
        <trans-unit id="1456b45d5164c8075b3ef02a6029d6cc9194bce1" translate="yes" xml:space="preserve">
          <source>internally you will always use Unicode exclusively for text except for literal strings with only ASCII character points.</source>
          <target state="translated">내부적으로는 ASCII 문자 포인트 만있는 리터럴 문자열을 제외하고 항상 텍스트에만 유니 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e520ac39dfbeea0b1dcead65fd3537317fc76b94" translate="yes" xml:space="preserve">
          <source>it activates the automatic reloader</source>
          <target state="translated">자동 재장 전기를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="23826120fd321590f8403714453f3f7a4b0a2d08" translate="yes" xml:space="preserve">
          <source>it activates the debugger</source>
          <target state="translated">디버거를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3e12d260df8328be968a7e89a55d3cac7b7ae638" translate="yes" xml:space="preserve">
          <source>it enables the debug mode on the Flask application.</source>
          <target state="translated">Flask 애플리케이션에서 디버그 모드를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c27b409c0058ca262c00d4bc5b311b17467a5275" translate="yes" xml:space="preserve">
          <source>like &lt;code&gt;int&lt;/code&gt; but for floating point values</source>
          <target state="translated">같은 &lt;code&gt;int&lt;/code&gt; 하지만 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="f0d5190a8041319df229e98046658c7c08b2c0e6" translate="yes" xml:space="preserve">
          <source>like &lt;code&gt;string&lt;/code&gt; but also accepts slashes</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 과 비슷 하지만 슬래시도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="efce8c9011a808bb6bf9de1b830f8e261eb89c78" translate="yes" xml:space="preserve">
          <source>like the default but also accepts slashes</source>
          <target state="translated">기본값과 같지만 슬래시도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9a528abb653db79506821c6e058d0fee2b671cb1" translate="yes" xml:space="preserve">
          <source>matches one of the items provided</source>
          <target state="translated">제공된 항목 중 하나와 일치</target>
        </trans-unit>
        <trans-unit id="deac6525f100db1c8ece6f318bb1f7313f8d8291" translate="yes" xml:space="preserve">
          <source>mod_wsgi (Apache)</source>
          <target state="translated">mod_wsgi (Apache)</target>
        </trans-unit>
        <trans-unit id="ab895fb15ede50af7ed7785e5743ecb4fef78106" translate="yes" xml:space="preserve">
          <source>network connection of the server to another system failed</source>
          <target state="translated">서버와 다른 시스템의 네트워크 연결에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="b71754b52dc5a29619add8e188a3b2f8622750e6" translate="yes" xml:space="preserve">
          <source>otherwise the original function is called and the return value is stored in the cache for the timeout provided (by default 5 minutes).</source>
          <target state="translated">그렇지 않으면 원래 함수가 호출되고 반환 값은 제공된 시간 제한 (기본값 : 5 분) 동안 캐시에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="829aff059e8c8831f8ffeab4ef912013147f6dc9" translate="yes" xml:space="preserve">
          <source>request object</source>
          <target state="translated">요청 객체</target>
        </trans-unit>
        <trans-unit id="d09b53ab8c818d54dfe8427f21aede4595b31668" translate="yes" xml:space="preserve">
          <source>sending out HTML from uploaded files, never do that, use the &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; header to prevent that problem.</source>
          <target state="translated">업로드 된 파일에서 HTML을 전송하지 &lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 헤더를 사용하여 문제를 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="ef88fe04c86583c8d352796166d79a400ea7aaf7" translate="yes" xml:space="preserve">
          <source>sending out textfiles from uploaded files. Some browsers are using content-type guessing based on the first few bytes so users could trick a browser to execute HTML.</source>
          <target state="translated">업로드 된 파일에서 텍스트 파일을 보냅니다. 일부 브라우저는 처음 몇 바이트를 기반으로 콘텐츠 유형 추측을 사용하므로 사용자가 브라우저를 속여 HTML을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d250c538e374f94a199010467ed426bfdd515f38" translate="yes" xml:space="preserve">
          <source>should be served as &lt;code&gt;application/xhtml+xml&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;application/xhtml+xml&lt;/code&gt; 로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0c6b34129d5ea370904f8e0b5557494ec05cd78" translate="yes" xml:space="preserve">
          <source>should be served as &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;text/html&lt;/code&gt; 로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a6c98c7baadee2946da9e6affe75e118bb0e9f49" translate="yes" xml:space="preserve">
          <source>specifies the rule for the subdomain in case subdomain matching is in use. If not specified the default subdomain is assumed.</source>
          <target state="translated">하위 도메인 일치가 사용중인 경우 하위 도메인에 대한 규칙을 지정합니다. 지정하지 않으면 기본 하위 도메인이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce6c00135f1bdc72b86079d54a87495e6bbdcb09" translate="yes" xml:space="preserve">
          <source>strict error handling</source>
          <target state="translated">엄격한 오류 처리</target>
        </trans-unit>
        <trans-unit id="4ad0e1b83e7a464a4bb7b7665eadcf5823558111" translate="yes" xml:space="preserve">
          <source>the &lt;code&gt;Flask&lt;/code&gt; application object creation has to be in the &lt;code&gt;__init__.py&lt;/code&gt; file. That way each module can import it safely and the &lt;code&gt;__name__&lt;/code&gt; variable will resolve to the correct package.</source>
          <target state="translated">&lt;code&gt;Flask&lt;/code&gt; 응용 프로그램 개체의 생성은에 있어야한다 &lt;code&gt;__init__.py&lt;/code&gt; 의 파일. 이렇게하면 각 모듈이 안전하게 가져올 수 있으며 &lt;code&gt;__name__&lt;/code&gt; 변수는 올바른 패키지로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0073219b5af8f0052a1b0b4675d5fdd8ca8e7adf" translate="yes" xml:space="preserve">
          <source>the URL adapter that was used to match the request.</source>
          <target state="translated">요청을 일치시키는 데 사용 된 URL 어댑터.</target>
        </trans-unit>
        <trans-unit id="08af32314d28d8bb46aa1326c9ed906721f73187" translate="yes" xml:space="preserve">
          <source>the URL rule as string</source>
          <target state="translated">URL 규칙을 문자열로</target>
        </trans-unit>
        <trans-unit id="64113f45da91ceda3658fdd669c8b1def46ff802" translate="yes" xml:space="preserve">
          <source>the active Flask application.</source>
          <target state="translated">활성 Flask 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="a2cb4fcdc91c5610d90aff1aab70ff2b23f23575" translate="yes" xml:space="preserve">
          <source>the active session object.</source>
          <target state="translated">활성 세션 개체</target>
        </trans-unit>
        <trans-unit id="963ff94953ee748c0917675522a8c9c7a8adc5da" translate="yes" xml:space="preserve">
          <source>the client terminated the request early and the application was still reading from the incoming data</source>
          <target state="translated">클라이언트가 요청을 일찍 종료했고 애플리케이션은 여전히 ​​수신 데이터를 읽고있었습니다.</target>
        </trans-unit>
        <trans-unit id="0bf35c8ee9bd6070016a1d57d69d358ef00d3ea0" translate="yes" xml:space="preserve">
          <source>the current request object.</source>
          <target state="translated">현재 요청 객체</target>
        </trans-unit>
        <trans-unit id="310e66995d61a1787a8ad1128858c9030822c7cb" translate="yes" xml:space="preserve">
          <source>the database server was overloaded and could not handle the query</source>
          <target state="translated">데이터베이스 서버가 오버로드되어 쿼리를 처리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="63489725fe632565a9f3b6b78724d1e49463af3a" translate="yes" xml:space="preserve">
          <source>the encoding for text on your website is UTF-8</source>
          <target state="translated">웹 사이트의 텍스트 인코딩은 UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="9073e0170afa49209bb1b656f622001db6580bd5" translate="yes" xml:space="preserve">
          <source>the endpoint for the registered URL rule. Flask itself assumes that the name of the view function is the name of the endpoint if not explicitly stated.</source>
          <target state="translated">등록 된 URL 규칙의 끝점입니다. Flask 자체는 명시 적으로 언급되지 않은 경우 뷰 함수의 이름이 엔드 포인트의 이름이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b6fc3644392cebe10d467090e7649b5ea6a2430e" translate="yes" xml:space="preserve">
          <source>the function to call when serving a request to the provided endpoint. If this is not provided one can specify the function later by storing it in the &lt;a href=&quot;#flask.Flask.view_functions&quot;&gt;&lt;code&gt;view_functions&lt;/code&gt;&lt;/a&gt; dictionary with the endpoint as key.</source>
          <target state="translated">제공된 엔드 포인트에 요청을 제공 할 때 호출 할 함수입니다. 이것이 제공되지 않으면 나중에 엔드 포인트를 키로 하여 &lt;a href=&quot;#flask.Flask.view_functions&quot;&gt; &lt;code&gt;view_functions&lt;/code&gt; &lt;/a&gt; 사전 에 저장하여 함수를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29ce9a6c8520d124b40219bafe921d69241783b5" translate="yes" xml:space="preserve">
          <source>the hash function to use for the signature. The default is sha1</source>
          <target state="translated">서명에 사용할 해시 함수입니다. 기본값은 sha1입니다.</target>
        </trans-unit>
        <trans-unit id="c8391f181c288eadeca0aab6fa21c429a0b39b8b" translate="yes" xml:space="preserve">
          <source>the name of the itsdangerous supported key derivation. The default is hmac.</source>
          <target state="translated">지원되는 위험한 키 파생의 이름입니다. 기본값은 hmac입니다.</target>
        </trans-unit>
        <trans-unit id="ec3bdab824e3eb590fac4319e902c2eae8721f99" translate="yes" xml:space="preserve">
          <source>the options to be forwarded to the underlying &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt;&lt;code&gt;Rule&lt;/code&gt;&lt;/a&gt; object. A change to Werkzeug is handling of method options. methods is a list of methods this rule should be limited to (&lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt; etc.). By default a rule just listens for &lt;code&gt;GET&lt;/code&gt; (and implicitly &lt;code&gt;HEAD&lt;/code&gt;). Starting with Flask 0.6, &lt;code&gt;OPTIONS&lt;/code&gt; is implicitly added and handled by the standard request handling. They have to be specified as keyword arguments.</source>
          <target state="translated">기본 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/routing/#werkzeug.routing.Rule&quot;&gt; &lt;code&gt;Rule&lt;/code&gt; &lt;/a&gt; 객체 로 전달할 옵션 입니다. Werkzeug의 변경 사항은 메소드 옵션 처리입니다. methods는이 규칙이 제한되어야하는 메서드 목록입니다 ( &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 등). 기본적으로 규칙은 &lt;code&gt;GET&lt;/code&gt; (및 암시 적으로 &lt;code&gt;HEAD&lt;/code&gt; ) 만 수신합니다 . Flask 0.6부터 &lt;code&gt;OPTIONS&lt;/code&gt; 는 표준 요청 처리에 의해 암시 적으로 추가되고 처리됩니다. 키워드 인수로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc9dd0effeaac7f439fc8993ec7630ae431c32ac" translate="yes" xml:space="preserve">
          <source>the return value from the view function. The view function must return a response. Returning &lt;code&gt;None&lt;/code&gt;, or the view ending without returning, is not allowed. The following types are allowed for &lt;code&gt;view_rv&lt;/code&gt;:</source>
          <target state="translated">뷰 함수의 반환 값. 보기 함수는 응답을 반환해야합니다. &lt;code&gt;None&lt;/code&gt; 을 반환 하거나 반환하지 않고 종료되는 뷰는 허용되지 않습니다. &lt;code&gt;view_rv&lt;/code&gt; 에는 다음 유형이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="87770d3126b9858a2b1363aef7784412afb6ec28" translate="yes" xml:space="preserve">
          <source>the salt that should be applied on top of the secret key for the signing of cookie based sessions.</source>
          <target state="translated">쿠키 기반 세션의 서명을 위해 비밀 키 위에 적용되어야하는 솔트.</target>
        </trans-unit>
        <trans-unit id="97a2093cc3750a62d3495b04049b131c0408ecac" translate="yes" xml:space="preserve">
          <source>the session interface to use. By default an instance of &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface&quot;&gt;&lt;code&gt;SecureCookieSessionInterface&lt;/code&gt;&lt;/a&gt; is used here.</source>
          <target state="translated">사용할 세션 인터페이스입니다. 기본적으로 &lt;a href=&quot;#flask.sessions.SecureCookieSessionInterface&quot;&gt; &lt;code&gt;SecureCookieSessionInterface&lt;/code&gt; &lt;/a&gt; 의 인스턴스 가 여기에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="627ebf7f4ac1a73c30ca2ba6fbdc47e9b0c01e1d" translate="yes" xml:space="preserve">
          <source>the test client that is used with when &lt;code&gt;test_client&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;test_client&lt;/code&gt; 가 사용될 때 함께 사용되는 테스트 클라이언트 .</target>
        </trans-unit>
        <trans-unit id="2ec328b21f21f581a15283dc372ce0119a31529e" translate="yes" xml:space="preserve">
          <source>to access individual values from the form, access &lt;code&gt;form.&amp;lt;NAME&amp;gt;.data&lt;/code&gt;.</source>
          <target state="translated">양식에서 개별 값에 액세스하려면 &lt;code&gt;form.&amp;lt;NAME&amp;gt;.data&lt;/code&gt; 에 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dba151e97e915b82075cb812abc29b962582c25" translate="yes" xml:space="preserve">
          <source>to httpd 2.4 syntax</source>
          <target state="translated">httpd 2.4 구문에</target>
        </trans-unit>
        <trans-unit id="99e1a478ed987013c90ad73a60f613f19fb46353" translate="yes" xml:space="preserve">
          <source>to validate the data, call the &lt;code&gt;validate()&lt;/code&gt; method, which will return &lt;code&gt;True&lt;/code&gt; if the data validates, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">데이터의 &lt;code&gt;validate()&lt;/code&gt; 하려면 validate () 메서드를 호출하여 데이터가 유효성을 검사하면 &lt;code&gt;True&lt;/code&gt; 를 반환하고 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bb64abee6ddffb1dec2cea2a56e4250cbee775a" translate="yes" xml:space="preserve">
          <source>uWSGI</source>
          <target state="translated">uWSGI</target>
        </trans-unit>
        <trans-unit id="65b89a169808c59d7a3e2afadbdcb4a1c28c90a1" translate="yes" xml:space="preserve">
          <source>uWSGI is a deployment option on servers like &lt;a href=&quot;https://nginx.org/&quot;&gt;nginx&lt;/a&gt;, &lt;a href=&quot;https://www.lighttpd.net/&quot;&gt;lighttpd&lt;/a&gt;, and &lt;a href=&quot;http://cherokee-project.com/&quot;&gt;cherokee&lt;/a&gt;; see &lt;a href=&quot;../fastcgi/index&quot;&gt;FastCGI&lt;/a&gt; and &lt;a href=&quot;../wsgi-standalone/index&quot;&gt;Standalone WSGI Containers&lt;/a&gt; for other options. To use your WSGI application with uWSGI protocol you will need a uWSGI server first. uWSGI is both a protocol and an application server; the application server can serve uWSGI, FastCGI, and HTTP protocols.</source>
          <target state="translated">uWSGI 같은 서버에 배포 옵션 &lt;a href=&quot;https://nginx.org/&quot;&gt;의 nginx&lt;/a&gt; , &lt;a href=&quot;https://www.lighttpd.net/&quot;&gt;lighttpd를&lt;/a&gt; , 그리고 &lt;a href=&quot;http://cherokee-project.com/&quot;&gt;체로키&lt;/a&gt; ; 다른 옵션 은 &lt;a href=&quot;../fastcgi/index&quot;&gt;FastCGI&lt;/a&gt; 및 &lt;a href=&quot;../wsgi-standalone/index&quot;&gt;독립형 WSGI 컨테이너&lt;/a&gt; 를 참조하십시오 . uWSGI 프로토콜과 함께 WSGI 응용 프로그램을 사용하려면 먼저 uWSGI 서버가 필요합니다. uWSGI는 프로토콜이자 응용 프로그램 서버입니다. 응용 프로그램 서버는 uWSGI, FastCGI 및 HTTP 프로토콜을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="015e89d43f5824651d95ba9192a510412b0f886a" translate="yes" xml:space="preserve">
          <source>use the &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt; method of the file to save the file permanently somewhere on the filesystem.</source>
          <target state="translated">파일 의 &lt;a href=&quot;https://werkzeug.palletsprojects.com/en/1.0.x/datastructures/#werkzeug.datastructures.FileStorage.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 파일 시스템의 어딘가에 영구적으로 파일을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5968b1444db31c860615aae7aabae156567a5e7d" translate="yes" xml:space="preserve">
          <source>you explicitly pass the request to the macro as parameter, or the attribute of the request object you are interested in.</source>
          <target state="translated">요청을 매크로에 매개 변수 또는 관심있는 요청 객체의 속성으로 명시 적으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="053e201b4099f3c3b39a0dce48070c615aa744a2" translate="yes" xml:space="preserve">
          <source>you import the macro &amp;ldquo;with context&amp;rdquo;.</source>
          <target state="translated">&quot;컨텍스트와 함께&quot;매크로를 가져옵니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
