<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sass">
    <body>
      <group id="sass">
        <trans-unit id="851a2a27867c5ea0d06fb7ad6ca3007c1728423a" translate="yes" xml:space="preserve">
          <source>Makes a color darker. Takes a color and a number between 0% and 100%, and returns a color with the lightness decreased by that amount.</source>
          <target state="translated">색상을 어둡게 만듭니다. 색상과 0 %에서 100 % 사이의 숫자를 가져와 그 양만큼 밝기가 감소 된 색상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77ee8f07a8c8bad26149c6d0da1b59832f988738" translate="yes" xml:space="preserve">
          <source>Makes a color less saturated. Takes a color and a number between 0% and 100%, and returns a color with the saturation decreased by that value.</source>
          <target state="translated">채도를 덜 채 웁니다. 색상과 0 %에서 100 % 사이의 숫자를 가져와 채도가 해당 값만큼 감소한 색상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="647de436b4025a40c3c05b643dfe7af49febeb1d" translate="yes" xml:space="preserve">
          <source>Makes a color lighter. Takes a color and a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt;, and returns a color with the lightness increased by that amount.</source>
          <target state="translated">색상을 밝게 만듭니다. 색상과 &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; 사이의 숫자를 가져와 그 양만큼 밝기가 증가한 색상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1202144871a6d134734e77e6f3d6ff43dcdf0d0b" translate="yes" xml:space="preserve">
          <source>Makes a color more opaque. Takes a color and a number between 0 and 1, and returns a color with the opacity increased by that amount.</source>
          <target state="translated">색상을 더 불투명하게 만듭니다. 색상과 0과 1 사이의 숫자를 가져와 불투명도가 해당 양만큼 증가한 색상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="908e36df6b3e3510d087b869b3ee05a7946f3ab4" translate="yes" xml:space="preserve">
          <source>Makes a color more saturated. Takes a color and a number between 0% and 100%, and returns a color with the saturation increased by that amount.</source>
          <target state="translated">색상을 더 채 웁니다. 색상과 0 %에서 100 % 사이의 숫자를 가져와 채도가 그 양만큼 증가한 색상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10e046f0668046295e6f040e6154687feaedeac3" translate="yes" xml:space="preserve">
          <source>Makes a color more transparent. Takes a color and a number between 0 and 1, and returns a color with the opacity decreased by that amount.</source>
          <target state="translated">색상을 더 투명하게 만듭니다. 색상과 0과 1 사이의 숫자를 가져와 불투명도가 그 양만큼 감소한 색상을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04a4606724a73e5ff1ba9485b82d41dc451cb728" translate="yes" xml:space="preserve">
          <source>Mandatory and Optional Extends</source>
          <target state="translated">필수 및 선택적 확장</target>
        </trans-unit>
        <trans-unit id="6c492e19352987aad4627ca16fec2584efdd4af1" translate="yes" xml:space="preserve">
          <source>Many &lt;a href=&quot;sass/script/functions&quot;&gt;useful functions&lt;/a&gt; for manipulating colors and other values</source>
          <target state="translated">색상 및 기타 값 조작에 &lt;a href=&quot;sass/script/functions&quot;&gt;유용한&lt;/a&gt; 많은 기능</target>
        </trans-unit>
        <trans-unit id="99d42d39d47641e2c830f19e5708bbe88e43bf4a" translate="yes" xml:space="preserve">
          <source>Many CSS properties start with the same prefix that acts as a kind of namespace. For example, &lt;code&gt;font-family&lt;/code&gt;, &lt;code&gt;font-size&lt;/code&gt;, and &lt;code&gt;font-weight&lt;/code&gt; all start with &lt;code&gt;font-&lt;/code&gt;. Sass makes this easier and less redundant by allowing property declarations to be nested. The outer property names are added to the inner, separated by a hyphen.</source>
          <target state="translated">많은 CSS 속성은 일종의 네임 스페이스 역할을하는 동일한 접두사로 시작합니다. 예를 들어 &lt;code&gt;font-family&lt;/code&gt; , &lt;code&gt;font-size&lt;/code&gt; 및 &lt;code&gt;font-weight&lt;/code&gt; 는 모두 &lt;code&gt;font-&lt;/code&gt; 로 시작 합니다. Sass는 속성 선언이 중첩 될 수 있도록함으로써이를 더 쉽고 덜 중복되게 만듭니다. 외부 속성 이름은 하이픈으로 구분하여 내부에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0e45c14832666db8154c98279d7b4ef0f7fdfc0e" translate="yes" xml:space="preserve">
          <source>Many of these functions take or return numbers, called &lt;em&gt;indexes&lt;/em&gt;, that refer to the elements in a list. The index 1 indicates the first element of the list. Note that this is different than many programming languages where indexes start at 0! Sass also makes it easy to refer to the end of a list. The index -1 refers to the last element in a list, -2 refers to the second-to-last, and so on.</source>
          <target state="translated">이러한 함수의 대부분은 목록의 요소를 참조하는 &lt;em&gt;indexes&lt;/em&gt; 라고하는 숫자를 취하거나 반환 합니다. 인덱스 1은 목록의 첫 번째 요소를 나타냅니다. 이것은 인덱스가 0에서 시작하는 많은 프로그래밍 언어와 다릅니다! Sass를 사용하면 목록 끝을 쉽게 참조 할 수 있습니다. 인덱스 -1은 목록의 마지막 요소를 참조하고 -2는 마지막에서 두 번째 요소를 참조하는 식입니다.</target>
        </trans-unit>
        <trans-unit id="087ea5ef70a667c3f4a3b6d1d5862a41c81236d1" translate="yes" xml:space="preserve">
          <source>Many-to-Many Mode</source>
          <target state="translated">다 대다 모드</target>
        </trans-unit>
        <trans-unit id="366296dc9a88f7a8f38a18287666cfd9d309343d" translate="yes" xml:space="preserve">
          <source>Many-to-many Mode</source>
          <target state="translated">다 대다 모드</target>
        </trans-unit>
        <trans-unit id="f7bb1487586dc664a1a3a3e010343aeb82600e81" translate="yes" xml:space="preserve">
          <source>Many-to-many mode compiles one or more input files to one or more output files. The inputs are separated from the outputs with colons. It can also compile all Sass files in a directory to CSS files with the same names in another directory.</source>
          <target state="translated">다 대다 모드는 하나 이상의 입력 파일을 하나 이상의 출력 파일로 컴파일합니다. 입력은 콜론으로 출력과 구분됩니다. 또한 디렉터리의 모든 Sass 파일을 다른 디렉터리에있는 동일한 이름의 CSS 파일로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c003d0031df8db1646d141722584209580bad863" translate="yes" xml:space="preserve">
          <source>Many-to-many mode compiles one or more input files to one or more output files. The inputs are separated from the outputs with colons. It can also compile all Sass files in a directory to CSS files with the same names in another directory. Many-to-many mode is enabled when any argument contains a colon, &lt;em&gt;or&lt;/em&gt; when the &lt;a href=&quot;#update&quot;&gt;&lt;code&gt;--update&lt;/code&gt; flag&lt;/a&gt; or the &lt;a href=&quot;#watch&quot;&gt;&lt;code&gt;--watch&lt;/code&gt; flag&lt;/a&gt; is passed.</source>
          <target state="translated">다 대다 모드는 하나 이상의 입력 파일을 하나 이상의 출력 파일로 컴파일합니다. 입력은 콜론으로 출력과 구분됩니다. 또한 디렉토리의 모든 Sass 파일을 다른 디렉토리에있는 동일한 이름의 CSS 파일로 컴파일 할 수 있습니다. 다 대다 모드는 인수가 콜론이 포함 된 경우 사용할 수 있습니다, &lt;em&gt;또는&lt;/em&gt; 때 &lt;a href=&quot;#update&quot;&gt; &lt;code&gt;--update&lt;/code&gt; 플래그&lt;/a&gt; 또는 &lt;a href=&quot;#watch&quot;&gt; &lt;code&gt;--watch&lt;/code&gt; 플래그가&lt;/a&gt; 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="80b0a029997a082113570a2bb733b56c05b12359" translate="yes" xml:space="preserve">
          <source>Many-to-many mode will only compile stylesheets whose dependencies have been modified more recently than the corresponding CSS file was generated. It will also print status messages when updating stylesheets.</source>
          <target state="translated">다 대다 모드는 해당 CSS 파일이 생성 된 것보다 더 최근에 종속성이 수정 된 스타일 시트 만 컴파일합니다. 또한 스타일 시트를 업데이트 할 때 상태 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="b262d9ae1e64d70be3bbb65675f5b105183f3e1e" translate="yes" xml:space="preserve">
          <source>Maps allow any Sass values to be used as their keys. The &lt;a href=&quot;../operators/equality&quot;&gt;&lt;code&gt;==&lt;/code&gt; operator&lt;/a&gt; is used to determine whether two keys are the same.</source>
          <target state="translated">맵을 사용하면 모든 Sass 값을 키로 사용할 수 있습니다. &lt;a href=&quot;../operators/equality&quot;&gt; &lt;code&gt;==&lt;/code&gt; 의 오퍼레이터는&lt;/a&gt; 두 개의 키가 동일한 것인지를 결정하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="cce96232fc4038e65cda3f21c77a761f06c9cc13" translate="yes" xml:space="preserve">
          <source>Maps are all about associating keys and values, so naturally there&amp;rsquo;s a way to get the value associated with a key: the &lt;a href=&quot;../modules/map#get&quot;&gt;&lt;code&gt;map.get($map, $key)&lt;/code&gt; function&lt;/a&gt;! This function returns the value in the map associated with the given key. It returns &lt;a href=&quot;null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; if the map doesn&amp;rsquo;t contain the key.</source>
          <target state="translated">맵은 키와 값을 연결하는 것이므로 자연스럽게 키와 관련된 값을 가져 오는 방법이 있습니다. &lt;a href=&quot;../modules/map#get&quot;&gt; &lt;code&gt;map.get($map, $key)&lt;/code&gt; 함수&lt;/a&gt; ! 이 함수는 주어진 키와 관련된 맵의 값을 반환합니다. 지도에 키가 없으면 &lt;a href=&quot;null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7908a2bbd7a8ad31b242280b31b2c7d491579a76" translate="yes" xml:space="preserve">
          <source>Maps can also be used anywhere lists can. When used by a list function, a map is treated as a list of pairs. For example, &lt;code&gt;(key1: value1, key2: value2)&lt;/code&gt; would be treated as the nested list &lt;code&gt;key1 value1, key2 value2&lt;/code&gt; by list functions. Lists cannot be treated as maps, though, with the exception of the empty list. &lt;code&gt;()&lt;/code&gt; represents both a map with no key/value pairs and a list with no elements.</source>
          <target state="translated">목록은 어디에서나 사용할 수 있습니다. 리스트 함수에 의해 사용될 때 맵은 쌍리스트로 취급됩니다. 예를 들어 &lt;code&gt;(key1: value1, key2: value2)&lt;/code&gt; 는 목록 함수별로 중첩 목록 &lt;code&gt;key1 value1, key2 value2&lt;/code&gt; 로 처리됩니다 . 빈 목록을 제외하고 목록은 맵으로 취급 할 수 없습니다. &lt;code&gt;()&lt;/code&gt; 는 키 / 값 쌍이없는지도와 요소가없는 목록을 모두 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="89e949ab7dcea4e2be5a81f1c90709f5ee38dbbd" translate="yes" xml:space="preserve">
          <source>Maps cannot be converted to plain CSS. Using one as the value of a variable or an argument to a CSS function will cause an error. Use the &lt;code&gt;inspect($value)&lt;/code&gt; function to produce an output string useful for debugging maps.</source>
          <target state="translated">지도를 일반 CSS로 변환 할 수 없습니다. 하나를 변수의 값으로 사용하거나 CSS 함수의 인수로 사용하면 오류가 발생합니다. 사용 &lt;code&gt;inspect($value)&lt;/code&gt; 지도를 디버깅에 유용한 출력 문자열을 생성하는 기능.</target>
        </trans-unit>
        <trans-unit id="ed2d94a1db9fc5b83f3a946bfb51b010f8a1984d" translate="yes" xml:space="preserve">
          <source>Maps created through this API are still forbidden from having duplicate keys.</source>
          <target state="translated">이 API를 통해 생성 된지도는 여전히 중복 키를 갖는 것이 금지되어 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="73855d8f1e07ea5cf14e0b18c6224668001cc571" translate="yes" xml:space="preserve">
          <source>Maps in Sass are &lt;em&gt;immutable&lt;/em&gt;, which means that the contents of a map value never changes. Sass&amp;rsquo;s map functions all return new maps rather than modifying the originals. Immutability helps avoid lots of sneaky bugs that can creep in when the same map is shared across different parts of the stylesheet.</source>
          <target state="translated">Sass의지도는 &lt;em&gt;변경할 수 없습니다&lt;/em&gt; . 즉,지도 값의 내용이 변경되지 않습니다. Sass의지도 기능은 모두 원본을 수정하지 않고 새지도를 반환합니다. 불변성은 스타일 시트의 다른 부분에서 동일한 맵을 공유 할 때 발생할 수있는 많은 교활한 버그를 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7d356183b77929938ce65e1b5ffc1230ed4bc0" translate="yes" xml:space="preserve">
          <source>Maps in Sass hold pairs of keys and values, and make it easy to look up a value by its corresponding key. They&amp;rsquo;re written &lt;code&gt;(&amp;lt;expression&amp;gt;: &amp;lt;expression&amp;gt;, &amp;lt;expression&amp;gt;: &amp;lt;expression&amp;gt;)&lt;/code&gt;. The &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; before the &lt;code&gt;:&lt;/code&gt; is the key, and the expression after is the value associated with that key. The keys must be unique, but the values may be duplicated. Unlike &lt;a href=&quot;lists&quot;&gt;lists&lt;/a&gt;, maps &lt;em&gt;must&lt;/em&gt; be written with parentheses around them. A map with no pairs is written &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Sass의 맵은 키와 값 쌍을 보유하고 있으며 해당 키로 값을 쉽게 찾을 수 있도록합니다. 작성되었습니다 &lt;code&gt;(&amp;lt;expression&amp;gt;: &amp;lt;expression&amp;gt;, &amp;lt;expression&amp;gt;: &amp;lt;expression&amp;gt;)&lt;/code&gt; . &lt;code&gt;:&lt;/code&gt; 앞 의 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;표현식&lt;/a&gt; 은 키이고 뒤의 표현식은 해당 키와 관련된 값입니다. 키는 고유해야하지만 값이 중복 될 수 있습니다. &lt;a href=&quot;lists&quot;&gt;목록&lt;/a&gt; 과 달리 지도 &lt;em&gt;는&lt;/em&gt; 괄호로 묶어야합니다. 쌍이없는 맵이 작성됩니다 &lt;code&gt;()&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18460ede0e77cbca4b62b2e50b96144bebae56ee" translate="yes" xml:space="preserve">
          <source>Maps represent an association between keys and values, where keys are used to look up values. They make it easy to collect values into named groups and access those groups dynamically. They have no direct parallel in CSS, although they're syntactically similar to media query expressions:</source>
          <target state="translated">맵은 키와 값 사이의 연결을 나타내며 키는 값을 찾는 데 사용됩니다. 이름이 지정된 그룹으로 값을 쉽게 수집하고 해당 그룹에 동적으로 액세스 할 수 있습니다. 미디어 쿼리 표현식과 구문 상 유사하지만 CSS에서 직접 병렬이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6651c921f3e6878f503603068099966453a6ba18" translate="yes" xml:space="preserve">
          <source>Members (variables, functions, and mixins) loaded with &lt;code&gt;@use&lt;/code&gt; are only visible in the stylesheet that loads them. Other stylesheets will need to write their own &lt;code&gt;@use&lt;/code&gt; rules if they also want to access them. This helps make it easy to figure out exactly where each member is coming from. If you want to load members from many files at once, you can use the &lt;a href=&quot;forward&quot;&gt;&lt;code&gt;@forward&lt;/code&gt; rule&lt;/a&gt; to forward them all from one shared file.</source>
          <target state="translated">&lt;code&gt;@use&lt;/code&gt; 로 로드 된 멤버 (변수, 함수 및 믹스 인) 는 해당 멤버 를로드하는 스타일 시트에서만 볼 수 있습니다. 다른 스타일 시트 도 액세스하려면 고유 한 &lt;code&gt;@use&lt;/code&gt; 규칙 을 작성해야 합니다. 이렇게하면 각 구성원이 어디에서 왔는지 쉽게 파악할 수 있습니다. 한 번에 여러 파일에서 구성원을로드하려면 &lt;a href=&quot;forward&quot;&gt; &lt;code&gt;@forward&lt;/code&gt; 규칙&lt;/a&gt; 을 사용하여 하나의 공유 파일 에서 구성원을 모두 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="266e0db2e6092e7da33438bebb8386fdab1f84e9" translate="yes" xml:space="preserve">
          <source>Merges two maps together into a new map. Keys in &lt;code&gt;$map2&lt;/code&gt; will take precedence over keys in &lt;code&gt;$map1&lt;/code&gt;.</source>
          <target state="translated">두 개의 맵을 새로운 맵으로 병합합니다. 의 키 &lt;code&gt;$map2&lt;/code&gt; 의 키보다 우선합니다 &lt;code&gt;$map1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51a9c2b299ed6b9e7a2c1942c4f2f202f049e8e3" translate="yes" xml:space="preserve">
          <source>Merging Selector Sequences</source>
          <target state="translated">선택기 시퀀스 병합</target>
        </trans-unit>
        <trans-unit id="dca984afd74a0089c1d5a5816e4de2e8d46a60b5" translate="yes" xml:space="preserve">
          <source>Migrations</source>
          <target state="translated">Migrations</target>
        </trans-unit>
        <trans-unit id="e0c1c8591cf6a520cc156585232fdfa4562258f3" translate="yes" xml:space="preserve">
          <source>Migrator</source>
          <target state="translated">Migrator</target>
        </trans-unit>
        <trans-unit id="1a5d17590464c69e30696f59e46e452b8da18b54" translate="yes" xml:space="preserve">
          <source>Mixes two colors together. Specifically, takes the average of each of the RGB components, optionally weighted by the given percentage. The opacity of the colors is also considered when weighting the components.</source>
          <target state="translated">두 가지 색상을 혼합합니다. 구체적으로, 임의의 주어진 백분율에 의해 가중 된 각각의 RGB 성분의 평균을 취한다. 구성 요소에 가중치를 부여 할 때 색상의 불투명도 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="3e03964482bfe1b1c6309d26cc15ab431a314d03" translate="yes" xml:space="preserve">
          <source>Mixin Directives #mixins</source>
          <target state="translated">Mixin 지시문 #mixins</target>
        </trans-unit>
        <trans-unit id="12f1da765fb7717db8da107e51c52eb9c8a76e44" translate="yes" xml:space="preserve">
          <source>Mixin definitions can also include other mixins. For example:</source>
          <target state="translated">믹스 인 정의에는 다른 믹스 인도 포함될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cec7617bbb6d9892fc290c647e0a6b541abeb1d" translate="yes" xml:space="preserve">
          <source>Mixin names, like all Sass identifiers, treat hyphens and underscores as identical. This means that &lt;code&gt;reset-list&lt;/code&gt; and &lt;code&gt;reset_list&lt;/code&gt; both refer to the same mixin. This is a historical holdover from the very early days of Sass, when it &lt;em&gt;only&lt;/em&gt; allowed underscores in identifier names. Once Sass added support for hyphens to match CSS&amp;rsquo;s syntax, the two were made equivalent to make migration easier.</source>
          <target state="translated">모든 Sass 식별자와 마찬가지로 Mixin 이름은 하이픈과 밑줄을 동일하게 취급합니다. 즉, &lt;code&gt;reset-list&lt;/code&gt; 와 &lt;code&gt;reset_list&lt;/code&gt; 는 모두 동일한 믹스 인을 참조합니다. 이것은 식별자 이름에 밑줄 &lt;em&gt;만&lt;/em&gt; 허용 했던 Sass 초기 시절의 역사적 유보입니다 . Sass가 CSS의 구문과 일치하도록 하이픈에 대한 지원을 추가 한 후에는 두 가지가 동일하게 만들어져 마이그레이션이 더 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="e55eee6e21d1bac315ca1a356e8d30a8a5b61967" translate="yes" xml:space="preserve">
          <source>Mixins allow you to define styles that can be re-used throughout the stylesheet without needing to resort to non-semantic classes like &lt;code&gt;.float-left&lt;/code&gt;. Mixins can also contain full CSS rules, and anything else allowed elsewhere in a Sass document. They can even take &lt;a href=&quot;#mixin-arguments&quot;&gt;arguments&lt;/a&gt; which allows you to produce a wide variety of styles with very few mixins.</source>
          <target state="translated">Mixins를 사용하면 &lt;code&gt;.float-left&lt;/code&gt; 와 같은 의미가없는 클래스에 의존하지 않고도 스타일 시트 전체에서 재사용 할 수있는 스타일을 정의 할 수 있습니다 . 믹스 인은 또한 완전한 CSS 규칙과 Sass 문서의 다른 곳에서 허용되는 모든 것을 포함 할 수 있습니다. 심지어 믹스 인을 거의 사용하지 않고 다양한 스타일을 생성 할 수있는 &lt;a href=&quot;#mixin-arguments&quot;&gt;논증&lt;/a&gt; 을 취할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a14ae4a02552d5310b5b307c5a6669df8e7abf30" translate="yes" xml:space="preserve">
          <source>Mixins allow you to define styles that can be re-used throughout your stylesheet. They make it easy to avoid using non-semantic classes like &lt;code&gt;.float-left&lt;/code&gt;, and to distribute collections of styles in libraries.</source>
          <target state="translated">믹스 인을 사용하면 스타일 시트 전체에서 재사용 할 수있는 스타일을 정의 할 수 있습니다. &lt;code&gt;.float-left&lt;/code&gt; 와 같은 의미없는 클래스를 사용하지 않고 라이브러리에서 스타일 모음을 배포 하기가 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="3a0ecb07e9c0f451b790fb7125d9f99ec780ec5d" translate="yes" xml:space="preserve">
          <source>Mixins are defined using the &lt;code&gt;@mixin&lt;/code&gt; at-rule, which is written &lt;code&gt;@mixin &amp;lt;name&amp;gt; { ... }&lt;/code&gt; or &lt;code&gt;@mixin name(&amp;lt;arguments...&amp;gt;) { ... }&lt;/code&gt;. A mixin&amp;rsquo;s name can be any Sass identifier, and it can contain any &lt;a href=&quot;../syntax/structure#statements&quot;&gt;statement&lt;/a&gt; other than &lt;a href=&quot;../syntax/structure#top-level-statements&quot;&gt;top-level statements&lt;/a&gt;. They can be used to encapsulate styles that can be dropped into a single &lt;a href=&quot;../style-rules&quot;&gt;style rule&lt;/a&gt;; they can contain style rules of their own that can be nested in other rules or included at the top level of the stylesheet; or they can just serve to modify variables.</source>
          <target state="translated">&lt;code&gt;@mixin&lt;/code&gt; 인은 &lt;code&gt;@mixin &amp;lt;name&amp;gt; { ... }&lt;/code&gt; 또는 &lt;code&gt;@mixin name(&amp;lt;arguments...&amp;gt;) { ... }&lt;/code&gt; 로 쓰여진 @mixin at-rule을 사용하여 정의됩니다 . 믹스 인의 이름은 Sass 식별자가 될 수 있으며 &lt;a href=&quot;../syntax/structure#top-level-statements&quot;&gt;최상위 &lt;/a&gt;&lt;a href=&quot;../syntax/structure#statements&quot;&gt;문&lt;/a&gt; 이외의 모든 문을 포함 할 수 있습니다 . 단일 &lt;a href=&quot;../style-rules&quot;&gt;스타일 규칙에&lt;/a&gt; 놓을 수있는 스타일을 캡슐화하는 데 사용할 수 있습니다 . 다른 규칙에 중첩되거나 스타일 시트의 최상위 수준에 포함될 수있는 자체 스타일 규칙을 포함 할 수 있습니다. 또는 변수를 수정하는 역할 만 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="644fdc872f40164f56f1c53cce947da35dec5fbf" translate="yes" xml:space="preserve">
          <source>Mixins are defined with the &lt;code&gt;@mixin&lt;/code&gt; directive. It's followed by the name of the mixin and optionally the &lt;a href=&quot;#mixin-arguments&quot;&gt;arguments&lt;/a&gt;, and a block containing the contents of the mixin. For example, the &lt;code&gt;large-text&lt;/code&gt; mixin is defined as follows:</source>
          <target state="translated">&lt;code&gt;@mixin&lt;/code&gt; 은 @mixin 지시문 으로 정의됩니다 . 그 다음에는 mixin의 이름과 선택적으로 &lt;a href=&quot;#mixin-arguments&quot;&gt;arguments&lt;/a&gt; 및 mixin의 내용을 포함하는 블록 이옵니다. 예를 들어, &lt;code&gt;large-text&lt;/code&gt; 믹스 인은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8abeb939278636d23f3812346051fac3995b1507" translate="yes" xml:space="preserve">
          <source>Mixins are included in the document with the &lt;code&gt;@include&lt;/code&gt; directive. This takes the name of a mixin and optionally &lt;a href=&quot;#mixin-arguments&quot;&gt;arguments to pass to it&lt;/a&gt;, and includes the styles defined by that mixin into the current rule. For example:</source>
          <target state="translated">믹스 인은 &lt;code&gt;@include&lt;/code&gt; 지시문 과 함께 문서에 포함됩니다 . 여기에는 믹스 인의 이름과 선택적으로 &lt;a href=&quot;#mixin-arguments&quot;&gt;인수를 전달&lt;/a&gt; 하고 해당 믹스 인에 의해 정의 된 스타일을 현재 규칙에 포함시킵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0abd91185955b760fd8e194eea9c215e7514a33c" translate="yes" xml:space="preserve">
          <source>Mixins are included into the current context using the &lt;code&gt;@include&lt;/code&gt; at-rule, which is written &lt;code&gt;@include &amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;@include &amp;lt;name&amp;gt;(&amp;lt;arguments...&amp;gt;)&lt;/code&gt;, with the name of the mixin being included.</source>
          <target state="translated">믹스 인은 &lt;code&gt;@include &amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;@include &amp;lt;name&amp;gt;(&amp;lt;arguments...&amp;gt;)&lt;/code&gt; 로 쓰여진 &lt;code&gt;@include&lt;/code&gt; at-rule을 사용하여 현재 컨텍스트에 포함되며 믹스 인의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="aa625b8e1fe09d8119662f87727f1fd539968fe6" translate="yes" xml:space="preserve">
          <source>Mixins can also be included using explicit keyword arguments. For instance, the above example could be written as:</source>
          <target state="translated">명시적인 키워드 인수를 사용하여 믹스 인을 포함 할 수도 있습니다. 예를 들어, 위 예제는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5c96c9da9afb1e3ab9aeab4756923db18e85058" translate="yes" xml:space="preserve">
          <source>Mixins can also specify default values for their arguments using the normal variable-setting syntax. Then when the mixin is included, if it doesn't pass in that argument, the default value will be used instead. For example:</source>
          <target state="translated">믹스 인은 일반 변수 설정 구문을 사용하여 인수의 기본값을 지정할 수도 있습니다. 그런 다음 믹스 인이 포함될 때 해당 인수를 전달하지 않으면 기본값이 대신 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cee9487bef7a98638f1813c34014ac1e4a7ef631" translate="yes" xml:space="preserve">
          <source>Mixins can also take arguments, which allows their behavior to be customized each time they&amp;rsquo;re called. The arguments are specified in the &lt;code&gt;@mixin&lt;/code&gt; rule after the mixin&amp;rsquo;s name, as a list of variable names surrounded by parentheses. The mixin must then be included with the same number of arguments in the form of &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript expressions&lt;/a&gt;. The values of these expression are available within the mixin&amp;rsquo;s body as the corresponding variables.</source>
          <target state="translated">Mixins는 또한 인자를받을 수있어 호출 될 때마다 동작을 사용자 정의 할 수 있습니다. 인수는 믹스 인 이름 뒤 의 &lt;code&gt;@mixin&lt;/code&gt; 규칙에 괄호로 묶인 변수 이름 목록으로 지정됩니다. 믹스 인은 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript 표현식&lt;/a&gt; 의 형식으로 동일한 수의 인수와 함께 포함되어야합니다 . 이 표현식의 값은 믹스 인의 본문 내에서 해당 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89f1e192461e5943e97df4ea266b05de3cfe71b" translate="yes" xml:space="preserve">
          <source>Mixins can take SassScript values as arguments, which are given when the mixin is included and made available within the mixin as variables.</source>
          <target state="translated">믹스 인은 SassScript 값을 인수로 사용할 수 있으며, 믹스 인이 포함되어 믹스 인 내에 변수로 제공 될 때 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2071f293bfe403300472d64fe85c7676303d0010" translate="yes" xml:space="preserve">
          <source>Mixins may also be included outside of any rule (that is, at the root of the document) as long as they don't directly define any properties or use any parent references. For example:</source>
          <target state="translated">믹스 인은 속성을 직접 정의하지 않거나 부모 참조를 사용하지 않는 한 모든 규칙 외부 (즉, 문서 루트)에 포함될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b75de159e94ab7dfa1b34d271e0ee2373620128" translate="yes" xml:space="preserve">
          <source>Mixins may also contain selectors, possibly mixed with properties. The selectors can even contain &lt;a href=&quot;#referencing_parent_selectors_&quot;&gt;parent references&lt;/a&gt;. For example:</source>
          <target state="translated">믹스 인에는 속성과 혼합 된 선택기가 포함될 수도 있습니다. 선택기는 &lt;a href=&quot;#referencing_parent_selectors_&quot;&gt;부모 참조를&lt;/a&gt; 포함 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e0ba38fcb196c03060e6db7ef49eab994c721b6" translate="yes" xml:space="preserve">
          <source>Mixins may include themselves. This is different than the behavior of Sass versions prior to 3.3, where mixin recursion was forbidden.</source>
          <target state="translated">믹스 인은 자신을 포함 할 수 있습니다. 이것은 mixin 재귀가 금지 된 3.3 이전의 Sass 버전의 동작과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="11ace01bca95506e406ba754b7248182fab3d1d8" translate="yes" xml:space="preserve">
          <source>Mixins that only define descendent selectors can be safely mixed into the top most level of a document.</source>
          <target state="translated">하위 선택기 만 정의하는 믹스 인은 문서의 최상위 레벨에 안전하게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="03ee36e7d4d406da6169a9a269a027aeecb4cec4" translate="yes" xml:space="preserve">
          <source>Modules are only loaded once, so if you change the configuration after you &lt;code&gt;@import&lt;/code&gt; a module for the first time (even indirectly), the change will be ignored if you &lt;code&gt;@import&lt;/code&gt; the module again.</source>
          <target state="translated">모듈은 한 번만로드되므로 처음으로 모듈을 &lt;code&gt;@import&lt;/code&gt; 한 후에 구성을 변경하면 (간접적으로도) 모듈을 다시 &lt;code&gt;@import&lt;/code&gt; 하면 변경 사항이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7eac0786d726187f2fd764b601f5ededf17daa6" translate="yes" xml:space="preserve">
          <source>Modules will always be loaded relative to the current file first, though. Load paths will only be used if no relative file exists that matches the module&amp;rsquo;s URL. This ensures that you can&amp;rsquo;t accidentally mess up your relative imports when you add a new library.</source>
          <target state="translated">하지만 모듈은 항상 현재 파일을 기준으로 먼저로드됩니다. 로드 경로는 모듈의 URL과 일치하는 상대 파일이없는 경우에만 사용됩니다. 이렇게하면 새 라이브러리를 추가 할 때 상대 가져 오기를 실수로 엉망으로 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e212feca960df74d558bb69cf520167281ac39e5" translate="yes" xml:space="preserve">
          <source>Most of the time, it&amp;rsquo;s a good idea to use &lt;a href=&quot;strings#quoted&quot;&gt;quoted strings&lt;/a&gt; rather than &lt;a href=&quot;strings#unquoted&quot;&gt;unquoted strings&lt;/a&gt; for map keys. This is because some values, such as color names, may &lt;em&gt;look&lt;/em&gt; like unquoted strings but actually be other types. To avoid confusing problems down the line, just use quotes!</source>
          <target state="translated">대부분의 시간, 그것은 사용하는 것이 좋습니다 &lt;a href=&quot;strings#quoted&quot;&gt;인용 문자열&lt;/a&gt; 이 아닌 &lt;a href=&quot;strings#unquoted&quot;&gt;인용되지 않은 문자열을&lt;/a&gt; 지도 키 위해. 같은 색상 이름과 같은 일부 값은, 수 있기 때문입니다 &lt;em&gt;볼&lt;/em&gt; 인용되지 않은 문자열처럼 실제로 다른 종류의 수. 혼란스러운 문제를 피하려면 따옴표를 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="6caa57f1b284ddb2fbcb690abae7336beef21a73" translate="yes" xml:space="preserve">
          <source>Most popular Node.js build systems have integrations available for the JSAPI:</source>
          <target state="translated">가장 널리 사용되는 Node.js 빌드 시스템에는 JSAPI에 사용할 수있는 통합 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ecffc55002b5b51a6ea33821a9ca1648bf908e4" translate="yes" xml:space="preserve">
          <source>Most web servers compress the CSS they serve using an algorithm that&amp;rsquo;s very good at handling repeated chunks of identical text. This means that, although mixins may produce more CSS than extends, they probably won&amp;rsquo;t substantially increase the amount your users need to download. So choose the feature that makes the most sense for your use-case, not the one that generates the least CSS!</source>
          <target state="translated">대부분의 웹 서버는 동일한 텍스트의 반복 된 청크를 매우 잘 처리하는 알고리즘을 사용하여 제공하는 CSS를 압축합니다. 즉, mixin은 확장보다 더 많은 CSS를 생성 할 수 있지만 사용자가 다운로드해야하는 양을 크게 늘리지는 않을 것입니다. 따라서 CSS를 가장 적게 생성하는 기능이 아니라 사용 사례에 가장 적합한 기능을 선택하십시오!</target>
        </trans-unit>
        <trans-unit id="4d5c195b3ec1480b097649cc98e70b7c7295f4d9" translate="yes" xml:space="preserve">
          <source>Much of Sass&amp;rsquo;s extra functionality comes in the form of new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule&quot;&gt;at-rules&lt;/a&gt; it adds on top of CSS:</source>
          <target state="translated">Sass의 추가 기능은 대부분 CSS 위에 추가되는 새로운 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule&quot;&gt;at-rule&lt;/a&gt; 의 형태로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d16a27d69c336f36f8b8c3be089eb20a3976fee1" translate="yes" xml:space="preserve">
          <source>Multiple Assignment #each-multi-assign</source>
          <target state="translated">다중 할당 # each-multi-assign</target>
        </trans-unit>
        <trans-unit id="e6f913e5657c2f46bca6d86b0b282bdb4e92d9bf" translate="yes" xml:space="preserve">
          <source>Multiple Extends</source>
          <target state="translated">여러 확장</target>
        </trans-unit>
        <trans-unit id="6b9c3fd36c58a4b311728f37c3faf47f2b86cda9" translate="yes" xml:space="preserve">
          <source>Multiple extends can also be written using a comma-separated list of selectors. For example, &lt;code&gt;@extend .error, .attention&lt;/code&gt; is the same as &lt;code&gt;@extend .error; @extend .attention&lt;/code&gt;.</source>
          <target state="translated">쉼표로 구분 된 선택기 목록을 사용하여 여러 확장을 작성할 수도 있습니다. 예를 들어 &lt;code&gt;@extend .error, .attention&lt;/code&gt; 은 &lt;code&gt;@extend .error; @extend .attention&lt;/code&gt; 와 같습니다. @ extend.attention .</target>
        </trans-unit>
        <trans-unit id="ba6f5c598a8196a3ad3093fcbf81e9ebc9a9bbaa" translate="yes" xml:space="preserve">
          <source>Named arguments can be passed in any order, and arguments with default values can be omitted. Since the named arguments are variable names, underscores and dashes can be used interchangeably.</source>
          <target state="translated">명명 된 인수는 임의의 순서로 전달 될 수 있으며 기본값을 가진 인수는 생략 할 수 있습니다. 명명 된 인수는 변수 이름이므로 밑줄과 대시를 서로 바꿔 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1f60bbdf9d3e6d11e707a834a9fa47911129fbc" translate="yes" xml:space="preserve">
          <source>Negative index values address elements in reverse order, starting with the last element in the list.</source>
          <target state="translated">음수 인덱스 값은 목록의 마지막 요소부터 시작하여 요소를 역순으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2e21957ba8ac2ad32ca0fe1899ea29dd3dc4d523" translate="yes" xml:space="preserve">
          <source>Nested &lt;code&gt;@import&lt;/code&gt; #nested-import</source>
          <target state="translated">중첩 된 &lt;code&gt;@import&lt;/code&gt; # nested-import</target>
        </trans-unit>
        <trans-unit id="ea53187d0b8860192e4cc973b4edf4179ca436b1" translate="yes" xml:space="preserve">
          <source>Nested Properties</source>
          <target state="translated">중첩 속성</target>
        </trans-unit>
        <trans-unit id="ecf40457f10c33b29daa2a84e20b485cd1d251d0" translate="yes" xml:space="preserve">
          <source>Nested Rules</source>
          <target state="translated">중첩 규칙</target>
        </trans-unit>
        <trans-unit id="ded4993ce5217af403db83036f4428e8476a2e11" translate="yes" xml:space="preserve">
          <source>Nested imports are very useful for scoping third-party stylesheets, but if you&amp;rsquo;re the author of the stylesheet you&amp;rsquo;re importing, it&amp;rsquo;s usually a better idea to write your styles in a &lt;a href=&quot;mixin&quot;&gt;mixin&lt;/a&gt; and include that mixin in the nested context. A mixin can be used in more flexible ways, and it&amp;rsquo;s clearer when looking at the imported stylesheet how it&amp;rsquo;s intended to be used.</source>
          <target state="translated">중첩 된 수입은 타사 스타일 시트를 범위 지정에 매우 유용하지만, 당신이 가져 오는 스타일 시트의 저자라면, 그것은 당신의 스타일을 작성하는 것이 더 나은 아이디어를의 &lt;a href=&quot;mixin&quot;&gt;믹스 인&lt;/a&gt; 및 중첩 된 상황에서 그 믹스 인을 포함한다. 믹스 인은보다 유연한 방식으로 사용할 수 있으며 가져온 스타일 시트가 사용되는 방식을 볼 때 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="029abc8fcd094e12c6bd6cb1af59a9ff787923a7" translate="yes" xml:space="preserve">
          <source>Nested properties</source>
          <target state="translated">중첩 속성</target>
        </trans-unit>
        <trans-unit id="f0b610f173b363c6d397168ae6e235e8c6ca1741" translate="yes" xml:space="preserve">
          <source>Nested rules</source>
          <target state="translated">중첩 규칙</target>
        </trans-unit>
        <trans-unit id="898fb9c1d3df88b05af2c35f92fa9855403317fd" translate="yes" xml:space="preserve">
          <source>Nested rules are clever about handling selector lists (that is, comma-separated selectors). Each complex selector (the ones between the commas) is nested separately, and then they&amp;rsquo;re combined back into a selector list.</source>
          <target state="translated">중첩 규칙은 선택자 목록 (즉, 쉼표로 구분 된 선택자)을 처리하는 데 영리합니다. 각 복합 선택기 (쉼표 사이에있는 선택기)는 개별적으로 중첩 된 다음 선택기 목록으로 다시 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="8ba546c34feebcc571b499703908b859182411c0" translate="yes" xml:space="preserve">
          <source>Nested rules are super helpful, but they can also make it hard to visualize how much CSS you&amp;rsquo;re actually generating. The deeper you nest, the more bandwidth it takes to serve your CSS and the more work it takes the browser to render it. Keep those selectors shallow!</source>
          <target state="translated">중첩 규칙은 매우 유용하지만 실제로 생성하는 CSS의 양을 시각화하기 어렵게 만들 수도 있습니다. 중첩이 깊을수록 CSS를 제공하는 데 더 많은 대역폭이 필요하고 브라우저가이를 렌더링하는 데 더 많은 작업이 필요합니다. 선택자를 얕게 유지하십시오!</target>
        </trans-unit>
        <trans-unit id="829996697cf657d3999063e276100b291e8b02d6" translate="yes" xml:space="preserve">
          <source>Nested style is the default Sass style, because it reflects the structure of the CSS styles and the HTML document they're styling. Each property has its own line, but the indentation isn't constant. Each rule is indented based on how deeply it's nested. For example:</source>
          <target state="translated">중첩 스타일은 기본 Sass 스타일입니다. CSS 스타일의 구조와 스타일을 지정하는 HTML 문서를 반영하기 때문입니다. 각 속성에는 고유 한 줄이 있지만 들여 쓰기는 일정하지 않습니다. 각 규칙은 얼마나 깊이 중첩되어 있는지에 따라 들여 쓰기됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="500e991d7263822a1c7bc95c88315929abd16088" translate="yes" xml:space="preserve">
          <source>Nested style is very useful when looking at large CSS files: it allows you to easily grasp the structure of the file without actually reading anything.</source>
          <target state="translated">중첩 스타일은 큰 CSS 파일을 볼 때 매우 유용합니다. 실제로 아무것도 읽지 않고도 파일의 구조를 쉽게 파악할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="bf84d228c3d06053863c78671c4f2260ed4d3b10" translate="yes" xml:space="preserve">
          <source>New possible values may be added in the future. It may return either &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; for &lt;code&gt;()&lt;/code&gt;, depending on whether or not it was returned by a &lt;a href=&quot;map&quot;&gt;map function&lt;/a&gt;.</source>
          <target state="translated">새로운 가능한 값은 향후에 추가 될 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ &lt;a href=&quot;map&quot;&gt;지도 함수에&lt;/a&gt; 의해 반환되었는지 여부에 따라 &lt;code&gt;()&lt;/code&gt; 에 대한 &lt;code&gt;list&lt;/code&gt; 또는 &lt;code&gt;map&lt;/code&gt; 를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42c9a5ee2dab1779e68f9b7a64ca2d27ba2ceeb6" translate="yes" xml:space="preserve">
          <source>No matter how a Sass color is originally written, it can be used with both HSL-based and RGB-based functions!</source>
          <target state="translated">Sass 색상이 원래 어떻게 작성되었는지에 관계없이 HSL 기반 및 RGB 기반 함수와 함께 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="ea89deb3b3ac3462ef826d2e89bb608cba87394f" translate="yes" xml:space="preserve">
          <source>Node Sass</source>
          <target state="translated">노드 Sass</target>
        </trans-unit>
        <trans-unit id="033bb91d5d01ceb3484df5688dfd173443293f8f" translate="yes" xml:space="preserve">
          <source>Node Sass and older versions of Dart Sass support loading files with the extension &lt;code&gt;.css&lt;/code&gt;, but contrary to the specification they&amp;rsquo;re treated as SCSS files rather than being parsed as CSS. This behavior has been deprecated in Node Sass, and an update is in the works to load them as plain CSS instead.</source>
          <target state="translated">Node Sass 및 이전 버전의 Dart Sass는 확장자가 &lt;code&gt;.css&lt;/code&gt; 인 파일로드를 지원 하지만 사양과는 반대로 CSS로 구문 분석되지 않고 SCSS 파일로 처리됩니다. 이 동작은 Node Sass에서 더 이상 사용되지 않으며 대신 일반 CSS로로드하는 업데이트가 진행 중입니다.</target>
        </trans-unit>
        <trans-unit id="72afbf7761abcd7a500b7e8851fd9c6a7a3b749e" translate="yes" xml:space="preserve">
          <source>Normally when you assign a value to a variable, if that variable already had a value, its old value is overwritten. But if you&amp;rsquo;re writing a Sass library, you might want to allow your users to configure your library&amp;rsquo;s variables before you use them to generate CSS.</source>
          <target state="translated">일반적으로 변수에 값을 할당 할 때 해당 변수에 이미 값이있는 경우 이전 값을 덮어 씁니다. 그러나 Sass 라이브러리를 작성하는 경우 CSS를 생성하는 데 사용하기 전에 사용자가 라이브러리의 변수를 구성하도록 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b80d909c92f046f3dca9e5eef78526694d5082" translate="yes" xml:space="preserve">
          <source>Normally when you extend a selector, it's an error if that &lt;code&gt;@extend&lt;/code&gt; doesn't work. For example, if you write &lt;code&gt;a.important {@extend .notice}&lt;/code&gt;, it's an error if there are no selectors that contain &lt;code&gt;.notice&lt;/code&gt;. It's also an error if the only selector containing &lt;code&gt;.notice&lt;/code&gt; is &lt;code&gt;h1.notice&lt;/code&gt;, since &lt;code&gt;h1&lt;/code&gt; conflicts with &lt;code&gt;a&lt;/code&gt; and so no new selector would be generated.</source>
          <target state="translated">일반적으로 선택기를 확장하면 &lt;code&gt;@extend&lt;/code&gt; 가 작동하지 않으면 오류가 발생합니다 . 당신이 쓰는 예를 들어, &lt;code&gt;a.important {@extend .notice}&lt;/code&gt; 포함하는 더 선택기가없는 경우, 에러의 &lt;code&gt;.notice&lt;/code&gt; 가 . 포함 된 유일한 선택하는 경우에도 오류의 &lt;code&gt;.notice&lt;/code&gt; 가 없습니다 &lt;code&gt;h1.notice&lt;/code&gt; 때문에, &lt;code&gt;h1&lt;/code&gt; 충돌 등 새로운 선택이 생성 될 것이다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="123af529f72c6cde57409cdfddfd0d2f87ec972b" translate="yes" xml:space="preserve">
          <source>Normally, every argument a function declares must be passed when that function is included. However, you can make an argument optional by defining a &lt;em&gt;default value&lt;/em&gt; which will be used if that arguments isn&amp;rsquo;t passed. Default values use the same syntax as &lt;a href=&quot;../variables&quot;&gt;variable declarations&lt;/a&gt;: the variable name, followed by a colon and a &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript expression&lt;/a&gt;. This makes it easy to define flexible function APIs that can be used in simple or complex ways.</source>
          <target state="translated">일반적으로 함수가 선언하는 모든 인수는 해당 함수가 포함될 때 전달되어야합니다. 그러나 해당 인수가 전달되지 않은 경우 사용할 &lt;em&gt;기본값&lt;/em&gt; 을 정의하여 인수를 선택적으로 만들 수 있습니다 . 기본값은 &lt;a href=&quot;../variables&quot;&gt;변수 선언&lt;/a&gt; 과 동일한 구문을 사용합니다 . 변수 이름, 콜론 및 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript 표현식&lt;/a&gt; 이 뒤 따릅니다 . 따라서 간단하거나 복잡한 방식으로 사용할 수있는 유연한 함수 API를 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cdb53eefbdfee3b12bbcd04afce357361a5861c" translate="yes" xml:space="preserve">
          <source>Normally, every argument a mixin declares must be passed when that mixin is included. However, you can make an argument optional by defining a &lt;em&gt;default value&lt;/em&gt; which will be used if that arguments isn&amp;rsquo;t passed. Default values use the same syntax as &lt;a href=&quot;../variables&quot;&gt;variable declarations&lt;/a&gt;: the variable name, followed by a colon and a &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript expression&lt;/a&gt;. This makes it easy to define flexible mixin APIs that can be used in simple or complex ways.</source>
          <target state="translated">일반적으로 mixin이 선언하는 모든 인수는 해당 mixin이 포함될 때 전달되어야합니다. 그러나 해당 인수가 전달되지 않은 경우 사용할 &lt;em&gt;기본값&lt;/em&gt; 을 정의하여 인수를 선택적으로 만들 수 있습니다 . 기본값은 &lt;a href=&quot;../variables&quot;&gt;변수 선언&lt;/a&gt; 과 동일한 구문을 사용합니다 . 변수 이름, 콜론 및 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript 표현식&lt;/a&gt; 이 뒤 따릅니다 . 이를 통해 간단하거나 복잡한 방식으로 사용할 수있는 유연한 mixin API를 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36600b2266d9bc4bf738096ec98ade6b06055762" translate="yes" xml:space="preserve">
          <source>Normally, if an &lt;code&gt;@extend&lt;/code&gt; doesn&amp;rsquo;t match any selectors in the stylesheet, Sass will produce an error. This helps protect from typos or from renaming a selector without renaming the selectors that inherit from it. Extends that require that the extended selector exists are &lt;em&gt;mandatory&lt;/em&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;@extend&lt;/code&gt; 가 스타일 시트의 선택기와 일치하지 않으면 Sass는 오류를 생성합니다. 이렇게하면 선택자로부터 상속받은 선택 자의 이름을 바꾸지 않고 오타 나 선택 자의 이름을 바꾸는 것을 방지 할 수 있습니다. 확장 선택기가 있어야하는 확장은 &lt;em&gt;필수&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d5e7d2febd1afc13a90b92a80b1aeafd1143806" translate="yes" xml:space="preserve">
          <source>Not all identifiers are parsed as unquoted strings:</source>
          <target state="translated">모든 식별자가 인용되지 않은 문자열로 구문 분석되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8a8ffe4eac13c64877326301c06fafbcccc8ae5e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$selector&lt;/code&gt;&lt;strong&gt;must be&lt;/strong&gt; a &lt;a href=&quot;http://dev.w3.org/csswg/selectors4/#compound&quot;&gt;compound selector&lt;/a&gt;. That means it cannot contain commas or spaces. It also means that unlike other selector functions, this takes only strings, not lists.</source>
          <target state="translated">참고 &lt;code&gt;$selector&lt;/code&gt; &lt;strong&gt;있어야합니다 &lt;/strong&gt;&lt;a href=&quot;http://dev.w3.org/csswg/selectors4/#compound&quot;&gt;화합물 선택&lt;/a&gt; . 즉, 쉼표 나 공백을 포함 할 수 없습니다. 또한 다른 선택기 함수와 달리 목록이 아닌 문자열 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="080f6eb3b348145b6c90e2a7243299a34e1dd466" translate="yes" xml:space="preserve">
          <source>Note that because Sass maps are &lt;a href=&quot;#immutability&quot;&gt;immutable&lt;/a&gt;, &lt;code&gt;map.set()&lt;/code&gt; and &lt;code&gt;map.merge()&lt;/code&gt; do not modify the original list.</source>
          <target state="translated">말대꾸지도이기 때문에 참고하는 것이 &lt;a href=&quot;#immutability&quot;&gt;불변&lt;/a&gt; , &lt;code&gt;map.set()&lt;/code&gt; 와 &lt;code&gt;map.merge()&lt;/code&gt; 원래 목록을 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="693df4e52e4ff8d7b0244ad166c78c841dadae76" translate="yes" xml:space="preserve">
          <source>Note that colors with an alpha channel (those created with the &lt;a href=&quot;sass/script/functions#rgba-instance_method&quot;&gt;rgba&lt;/a&gt; or &lt;a href=&quot;sass/script/functions#hsla-instance_method&quot;&gt;hsla&lt;/a&gt; functions) must have the same alpha value in order for color arithmetic to be done with them. The arithmetic doesn't affect the alpha value. For example:</source>
          <target state="translated">알파 채널이있는 색상 ( &lt;a href=&quot;sass/script/functions#rgba-instance_method&quot;&gt;rgba&lt;/a&gt; 또는 &lt;a href=&quot;sass/script/functions#hsla-instance_method&quot;&gt;hsla&lt;/a&gt; 함수로 만든 색상)은 색상 산술을 수행하기 위해 동일한 알파 값을 가져야합니다. 산술은 알파 값에 영향을 미치지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac74dad262169f45fae2cdcb5fd6e40b4714ec50" translate="yes" xml:space="preserve">
          <source>Note that for these implementations, the &lt;code&gt;$alpha&lt;/code&gt; argument is &lt;em&gt;required&lt;/em&gt; if the function name &lt;code&gt;hsla()&lt;/code&gt; is used, and &lt;em&gt;forbidden&lt;/em&gt; if the function name &lt;code&gt;hsl()&lt;/code&gt; is used.</source>
          <target state="translated">이러한 구현 들어 있습니다 &lt;code&gt;$alpha&lt;/code&gt; 인수가 &lt;em&gt;필요한&lt;/em&gt; 함수 이름의 경우 &lt;code&gt;hsla()&lt;/code&gt; 사용되며, &lt;em&gt;금지 된&lt;/em&gt; 함수 이름의 경우 &lt;code&gt;hsl()&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="0a444c8d85a7c0b8c797f36d3a2b3e89f3c45b43" translate="yes" xml:space="preserve">
          <source>Note that for these implementations, the &lt;code&gt;$alpha&lt;/code&gt; argument is &lt;em&gt;required&lt;/em&gt; if the function name &lt;code&gt;rgba()&lt;/code&gt; is used, and &lt;em&gt;forbidden&lt;/em&gt; if the function name &lt;code&gt;rgb()&lt;/code&gt; is used.</source>
          <target state="translated">이러한 구현의 경우 함수 이름 &lt;code&gt;rgba()&lt;/code&gt; 가 사용 &lt;em&gt;되는&lt;/em&gt; 경우 &lt;code&gt;$alpha&lt;/code&gt; 인수가 &lt;em&gt;필요&lt;/em&gt; 하고 함수 이름 &lt;code&gt;rgb()&lt;/code&gt; 가 사용되는 경우 &lt;em&gt;금지&lt;/em&gt; 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0de89687514028e280bf5b669d5f5d71ff81cee1" translate="yes" xml:space="preserve">
          <source>Note that if a quoted string is added to an unquoted string (that is, the quoted string is to the left of the &lt;code&gt;+&lt;/code&gt;), the result is a quoted string. Likewise, if an unquoted string is added to a quoted string (the unquoted string is to the left of the &lt;code&gt;+&lt;/code&gt;), the result is an unquoted string. For example:</source>
          <target state="translated">인용 된 문자열이 인용되지 않은 문자열에 추가되는 경우 (즉, 인용 된 문자열은 &lt;code&gt;+&lt;/code&gt; 왼쪽에 있음 ) 결과는 인용 된 문자열입니다. 마찬가지로, 인용되지 않은 문자열이 인용 된 문자열에 추가되면 (인용되지 않은 문자열은 &lt;code&gt;+&lt;/code&gt; 왼쪽에 있음 ) 결과는 인용되지 않은 문자열입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a7263acabd39aa1aeb77388ab202b8bd00638a1" translate="yes" xml:space="preserve">
          <source>Note that map keys can be any Sass data type (even another map) and the syntax for declaring a map allows arbitrary SassScript expressions that will be evaluated to determine the key.</source>
          <target state="translated">맵 키는 임의의 Sass 데이터 유형 (다른 맵일 수도 있음) 일 수 있으며 맵 선언 구문은 키를 결정하기 위해 평가되는 임의의 SassScript 표현식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cbe4b8b6895d926247872a4e26c38d5715d96998" translate="yes" xml:space="preserve">
          <source>Note that this command does &lt;em&gt;not&lt;/em&gt; generate CSS files. For that, use the &lt;code&gt;sass&lt;/code&gt; command described elsewhere.</source>
          <target state="translated">이 명령은 CSS 파일을 생성 하지 &lt;em&gt;않습니다&lt;/em&gt; . 이를 위해 다른 곳에 설명 된 &lt;code&gt;sass&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f4a910276bcd8ea1488e67ca3bd4f98c83aad73" translate="yes" xml:space="preserve">
          <source>Note that this is different than CSS, which specifies how to recover from most errors rather than failing immediately. This is one of the few cases where SCSS isn&amp;rsquo;t &lt;em&gt;strictly&lt;/em&gt; a superset of CSS. However, it&amp;rsquo;s much more useful to Sass users to see errors immediately, rather than having them passed through to the CSS output.</source>
          <target state="translated">이는 즉시 실패하지 않고 대부분의 오류에서 복구하는 방법을 지정하는 CSS와 다릅니다. 이 SCSS가되지 않습니다 몇 가지 경우 중 하나입니다 &lt;em&gt;엄격하게&lt;/em&gt; CSS의 상위 집합. 그러나 Sass 사용자는 오류를 CSS 출력으로 전달하는 것보다 즉시 오류를 확인하는 것이 훨씬 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="798ca29359409d2bb8b40c00921c5354ce6bb1c2" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;#join&quot;&gt;&lt;code&gt;list.join()&lt;/code&gt;&lt;/a&gt;, if &lt;code&gt;$val&lt;/code&gt; is a list it&amp;rsquo;s nested within the returned list rather than having all its elements added to the returned list.</source>
          <target state="translated">참고는 달리 &lt;a href=&quot;#join&quot;&gt; &lt;code&gt;list.join()&lt;/code&gt; &lt;/a&gt; , 경우 &lt;code&gt;$val&lt;/code&gt; 오히려 반환 목록에 추가 된 모든 요소를 필요없이 반환 된 목록 내에서 중첩 된 것 목록입니다.</target>
        </trans-unit>
        <trans-unit id="183963367a5b456c3047b44221867d6cef4d1e24" translate="yes" xml:space="preserve">
          <source>Note that unlike some languages, the first character in a Sass string is number 1, the second number 2, and so forth.</source>
          <target state="translated">일부 언어와 달리 Sass 문자열의 첫 번째 문자는 숫자 1, 두 번째 숫자 2 등입니다.</target>
        </trans-unit>
        <trans-unit id="68ca367d5eae7afa2e54d9286cb52633f444a09d" translate="yes" xml:space="preserve">
          <source>Note that unlike some languages, the first item in a Sass list is number 1, the second number 2, and so forth.</source>
          <target state="translated">일부 언어와 달리 Sass 목록의 첫 번째 항목은 숫자 1, 두 번째 숫자 2 등입니다.</target>
        </trans-unit>
        <trans-unit id="e7d5e88030367084f32b1e63e394a792c554cdc8" translate="yes" xml:space="preserve">
          <source>Note that you may not include a partial and a non-partial with the same name in the same directory. For example, &lt;code&gt;_colors.scss&lt;/code&gt; may not exist alongside &lt;code&gt;colors.scss&lt;/code&gt;.</source>
          <target state="translated">동일한 디렉토리에 동일한 이름을 가진 부분 및 비 부분을 포함 할 수 없습니다. 예를 들어 &lt;code&gt;_colors.scss&lt;/code&gt; 는 &lt;code&gt;colors.scss&lt;/code&gt; 와 함께 존재하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8e5b80cd153ea290fe80ec507174a87bc55c594" translate="yes" xml:space="preserve">
          <source>Now everything with class &lt;code&gt;.seriousError&lt;/code&gt; also has class &lt;code&gt;.error&lt;/code&gt;, and everything with class &lt;code&gt;.criticalError&lt;/code&gt; has class &lt;code&gt;.seriousError&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; class &lt;code&gt;.error&lt;/code&gt;. It's compiled to:</source>
          <target state="translated">클래스 이제 모든 &lt;code&gt;.seriousError&lt;/code&gt; 는 또한 클래스가 &lt;code&gt;.error&lt;/code&gt; , 그리고 클래스의 모든 &lt;code&gt;.criticalError&lt;/code&gt; 는 클래스가 &lt;code&gt;.seriousError&lt;/code&gt; &lt;em&gt;및&lt;/em&gt; 클래스 &lt;code&gt;.error&lt;/code&gt; . 다음과 같이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="ab0e1a3421b3343f3824ef813b9855587c7d9d08" translate="yes" xml:space="preserve">
          <source>Null values are treated as empty strings for string interpolation:</source>
          <target state="translated">널 값은 문자열 보간을위한 빈 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e399d7ce3aaf6001026fc3298df535b4d6c80f77" translate="yes" xml:space="preserve">
          <source>Number Operations</source>
          <target state="translated">숫자 연산</target>
        </trans-unit>
        <trans-unit id="c0c3b5ef095430d85fb2cd85d4948d220c3f5146" translate="yes" xml:space="preserve">
          <source>Number operations</source>
          <target state="translated">숫자 연산</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="c663fdca24c7159c6bd1b244fb7e89d6041729f0" translate="yes" xml:space="preserve">
          <source>Numbers are rounded to 10 digits of precision &lt;em&gt;lazily&lt;/em&gt; when they&amp;rsquo;re used in a place where precision is relevant. This means that math functions will work with the full number value internally to avoid accumulating extra rounding errors.</source>
          <target state="translated">숫자는 정밀도가 관련된 장소에서 사용되는 경우 10 자리 정밀도로 &lt;em&gt;느리게&lt;/em&gt; 반올림됩니다 . 이는 추가 반올림 오류가 누적되지 않도록 수학 함수가 내부적으로 전체 숫자 값으로 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7add39ef0137375d64b6e0da1f8af3370308cddd" translate="yes" xml:space="preserve">
          <source>Numbers can&amp;rsquo;t be used as the left-hand value, because they have &lt;a href=&quot;numeric&quot;&gt;their own operators&lt;/a&gt;.</source>
          <target state="translated">숫자에는 &lt;a href=&quot;numeric&quot;&gt;자체 연산자&lt;/a&gt; 가 있으므로 왼쪽 값으로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4458336f995ee954ae912a60445e848b6d7e2ba1" translate="yes" xml:space="preserve">
          <source>Numbers in Sass have two components: the number itself, and its units. For example, in &lt;code&gt;16px&lt;/code&gt; the number is &lt;code&gt;16&lt;/code&gt; and the unit is &lt;code&gt;px&lt;/code&gt;. Numbers can have no units, and they can have complex units. See &lt;a href=&quot;#units&quot;&gt;Units&lt;/a&gt; below for more details.</source>
          <target state="translated">Sass의 숫자에는 숫자 자체와 단위의 두 가지 구성 요소가 있습니다. 예를 들어 &lt;code&gt;16px&lt;/code&gt; 에서 숫자는 &lt;code&gt;16&lt;/code&gt; 이고 단위는 &lt;code&gt;px&lt;/code&gt; 입니다. 숫자는 단위를 가질 수 없으며 복잡한 단위를 가질 수 있습니다. 자세한 내용은 아래 &lt;a href=&quot;#units&quot;&gt;단위&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d864be7003009ab9323673cc5aa11aa6064e96d" translate="yes" xml:space="preserve">
          <source>Numbers with incompatible units can&amp;rsquo;t be compared.</source>
          <target state="translated">호환되지 않는 단위가있는 숫자는 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c56a326279c48d05e1b61788ac9e9d3dedacabac" translate="yes" xml:space="preserve">
          <source>Numbers with incompatible units can&amp;rsquo;t be used with addition, subtraction, or modulo.</source>
          <target state="translated">호환되지 않는 단위가있는 숫자는 더하기, 빼기 또는 모듈로와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d95b983f6c9e56b561073c45b8366ac693fc7cf" translate="yes" xml:space="preserve">
          <source>Numeric Operators</source>
          <target state="translated">숫자 연산자</target>
        </trans-unit>
        <trans-unit id="b54293c92bcdf1550000796fb4b3f602c64581d8" translate="yes" xml:space="preserve">
          <source>Of course, selectors aren&amp;rsquo;t just used on their own in style rules. Sass knows to extend &lt;em&gt;everywhere&lt;/em&gt; the selector is used. This ensures that your elements are styled exactly as if they matched the extended selector.</source>
          <target state="translated">물론 선택자는 스타일 규칙에서 그 자체로 사용되는 것은 아닙니다. Sass는 선택기가 사용되는 &lt;em&gt;모든 곳&lt;/em&gt; 으로 확장하는 것을 알고 &lt;em&gt;있습니다&lt;/em&gt; . 이렇게하면 요소가 확장 된 선택기와 일치하는 것처럼 정확하게 스타일이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9d8672fb5aad66a7b49f343531639b5bd3fc9fb1" translate="yes" xml:space="preserve">
          <source>Often it's more useful to use &lt;a href=&quot;sass/script/functions&quot;&gt;color functions&lt;/a&gt; than to try to use color arithmetic to achieve the same effect.</source>
          <target state="translated">동일한 효과를 얻기 위해 색상 산술을 사용하는 것보다 &lt;a href=&quot;sass/script/functions&quot;&gt;색상 기능&lt;/a&gt; 을 사용하는 것이 더 유용한 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="40deaf425eb79f678e7bbcc711dbc6c75a76f1bc" translate="yes" xml:space="preserve">
          <source>Older Sass versions allowed &lt;code&gt;!global&lt;/code&gt; to be used for a variable that doesn&amp;rsquo;t exist yet. This behavior was deprecated to make sure each stylesheet declares the same variables no matter how it&amp;rsquo;s executed.</source>
          <target state="translated">이전 Sass 버전에서는 아직 존재하지 않는 변수에 &lt;code&gt;!global&lt;/code&gt; 을 사용할 수있었습니다 . 이 동작은 실행 방법에 관계없이 각 스타일 시트가 동일한 변수를 선언하도록하기 위해 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d649544f98508586062c569381e1cc2845d8025" translate="yes" xml:space="preserve">
          <source>Older implementations of LibSass and Ruby Sass didn&amp;rsquo;t support lists with square brackets.</source>
          <target state="translated">LibSass 및 Ruby Sass의 이전 구현은 대괄호가있는 목록을 지원하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7e37838a29deb996fb1aefeb35e62fe2dfe97a80" translate="yes" xml:space="preserve">
          <source>Older versions of LibSass and Ruby Sass parsed custom property declarations just like any other property declaration, allowing the full range of SassScript expressions as values. Even when using these versions, it&amp;rsquo;s recommended that you use interpolation to inject SassScript values for forwards-compatibility.</source>
          <target state="translated">이전 버전의 LibSass 및 Ruby Sass는 다른 속성 선언과 마찬가지로 사용자 지정 속성 선언을 구문 분석하여 SassScript 표현식의 전체 범위를 값으로 허용했습니다. 이러한 버전을 사용하는 경우에도 순방향 호환성을 위해 SassScript 값을 삽입하기 위해 보간을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b50d95bcb356944982379a6144f75e2538ea60b4" translate="yes" xml:space="preserve">
          <source>On its own, &lt;code&gt;@at-root&lt;/code&gt; only gets rid of &lt;a href=&quot;../style-rules&quot;&gt;style rules&lt;/a&gt;. Any at-rules like &lt;a href=&quot;css#media&quot;&gt;&lt;code&gt;@media&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;css#supports&quot;&gt;&lt;code&gt;@supports&lt;/code&gt;&lt;/a&gt; will be left in. If this isn&amp;rsquo;t what you want, though, you can control exactly what it includes or includes using syntax like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries#Targeting_media_features&quot;&gt;media query features&lt;/a&gt;, written &lt;code&gt;@at-root (with: &amp;lt;rules...&amp;gt;) { ... }&lt;/code&gt; or &lt;code&gt;@at-root (without: &amp;lt;rules...&amp;gt;) { ... }&lt;/code&gt;. The &lt;code&gt;(without: ...)&lt;/code&gt; query tells Sass which rules should be excluded; the &lt;code&gt;(with: ...)&lt;/code&gt; query excludes all rules &lt;em&gt;except&lt;/em&gt; those that are listed.</source>
          <target state="translated">그 자체로 &lt;code&gt;@at-root&lt;/code&gt; 는 &lt;a href=&quot;../style-rules&quot;&gt;스타일 규칙&lt;/a&gt; 만 제거 합니다. 원하는에서-규칙 &lt;a href=&quot;css#media&quot;&gt; &lt;code&gt;@media&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;css#supports&quot;&gt; &lt;code&gt;@supports&lt;/code&gt; 은&lt;/a&gt; 남아있을 것입니다 이것은 당신이 원하는,하지만 당신이 포함 나 같은 구문을 사용하여 포함 정확하게 제어 할 수없는 경우. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries#Targeting_media_features&quot;&gt;미디어 쿼리 기능&lt;/a&gt; 서면 &lt;code&gt;@at-root (with: &amp;lt;rules...&amp;gt;) { ... }&lt;/code&gt; 또는 &lt;code&gt;@at-root (without: &amp;lt;rules...&amp;gt;) { ... }&lt;/code&gt; . &lt;code&gt;(without: ...)&lt;/code&gt; 쿼리 규칙이 제외해야 말대꾸를 알려줍니다; &lt;code&gt;(with: ...)&lt;/code&gt; 쿼리 제외 모든 규칙 &lt;em&gt;을 제외하고&lt;/em&gt; 나열된들.</target>
        </trans-unit>
        <trans-unit id="c1bb7de4e712a1102afa787f557e76b7b4a19cb6" translate="yes" xml:space="preserve">
          <source>On their own, lists don't do much, but the &lt;a href=&quot;sass/script/functions#list-functions&quot;&gt;SassScript list functions&lt;/a&gt; make them useful. The &lt;a href=&quot;sass/script/functions#nth-instance_method&quot;&gt;&lt;code&gt;nth&lt;/code&gt; function&lt;/a&gt; can access items in a list, the &lt;a href=&quot;sass/script/functions#join-instance_method&quot;&gt;&lt;code&gt;join&lt;/code&gt; function&lt;/a&gt; can join multiple lists together, and the &lt;a href=&quot;sass/script/functions#append-instance_method&quot;&gt;&lt;code&gt;append&lt;/code&gt; function&lt;/a&gt; can add items to lists. The &lt;a href=&quot;#each-directive&quot;&gt;&lt;code&gt;@each&lt;/code&gt; directive&lt;/a&gt; can also add styles for each item in a list.</source>
          <target state="translated">자체적으로는 목록이별로 도움이되지 않지만 &lt;a href=&quot;sass/script/functions#list-functions&quot;&gt;SassScript 목록 기능&lt;/a&gt; 은 유용합니다. &lt;a href=&quot;sass/script/functions#nth-instance_method&quot;&gt; &lt;code&gt;nth&lt;/code&gt; 기능은&lt;/a&gt; (가), 목록의 항목에 액세스 할 수 있습니다 &lt;a href=&quot;sass/script/functions#join-instance_method&quot;&gt; &lt;code&gt;join&lt;/code&gt; 기능이&lt;/a&gt; 함께 여러 목록에 가입 할 수 있으며 &lt;a href=&quot;sass/script/functions#append-instance_method&quot;&gt; &lt;code&gt;append&lt;/code&gt; 기능&lt;/a&gt; 목록에 항목을 추가 할 수 있습니다. &lt;a href=&quot;#each-directive&quot;&gt; &lt;code&gt;@each&lt;/code&gt; 의 지시어는&lt;/a&gt; 또한 목록의 각 항목에 대한 스타일을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70b57e7b3d16bab3bdd24991cb5e543ffb1d4d18" translate="yes" xml:space="preserve">
          <source>On their own, without any use of &lt;code&gt;@extend&lt;/code&gt;, rulesets that use placeholder selectors will not be rendered to CSS.</source>
          <target state="translated">&lt;code&gt;@extend&lt;/code&gt; 를 사용하지 않고 자리 표시 자 선택기를 사용하는 규칙 세트는 CSS로 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f5c31ad520a711b13920ae472c88c9a76daa966" translate="yes" xml:space="preserve">
          <source>One-to-One Mode</source>
          <target state="translated">일대일 모드</target>
        </trans-unit>
        <trans-unit id="24571e3b4baecae7440bbeb4a2255d252ac930d0" translate="yes" xml:space="preserve">
          <source>One-to-one mode compiles a single input file (&lt;code&gt;input.scss&lt;/code&gt;) to a single output location (&lt;code&gt;output.css&lt;/code&gt;). If no output location is passed, the compiled CSS is printed to the terminal.</source>
          <target state="translated">일대일 모드는 단일 입력 파일 ( &lt;code&gt;input.scss&lt;/code&gt; )을 단일 출력 위치 ( &lt;code&gt;output.css&lt;/code&gt; ) 로 컴파일합니다 . 출력 위치가 전달되지 않으면 컴파일 된 CSS가 터미널에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="edb159cbb61b421bbd771c449269f563dafce1a0" translate="yes" xml:space="preserve">
          <source>One-to-one mode compiles a single input file (&lt;code&gt;input.scss&lt;/code&gt;) to a single output location (&lt;code&gt;output.css&lt;/code&gt;). If no output location is passed, the compiled CSS is printed to the terminal. If no input &lt;em&gt;or&lt;/em&gt; output is passed, the CSS is read from &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;standard input&lt;/a&gt; and printed to the terminal.</source>
          <target state="translated">일대일 모드는 단일 입력 파일 ( &lt;code&gt;input.scss&lt;/code&gt; )을 단일 출력 위치 ( &lt;code&gt;output.css&lt;/code&gt; ) 로 컴파일합니다 . 출력 위치가 전달되지 않으면 컴파일 된 CSS가 터미널에 인쇄됩니다. 입력 &lt;em&gt;또는&lt;/em&gt; 출력이 전달 되지 않으면 CSS를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;표준 입력&lt;/a&gt; 에서 읽어 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="cf10f4fc5f8c1b96d8d45a350d364f2fb15e1585" translate="yes" xml:space="preserve">
          <source>Only &lt;em&gt;simple selectors&lt;/em&gt;&amp;mdash;individual selectors like &lt;code&gt;.info&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;&amp;mdash;can be extended. If &lt;code&gt;.message.info&lt;/code&gt; could be extended, the definition of &lt;code&gt;@extend&lt;/code&gt; says that elements matching the extender would be styled as though they matched &lt;code&gt;.message.info&lt;/code&gt;. That&amp;rsquo;s just the same as matching both &lt;code&gt;.message&lt;/code&gt; and &lt;code&gt;.info&lt;/code&gt;, so there wouldn&amp;rsquo;t be any benefit in writing that instead of &lt;code&gt;@extend .message, .info&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;단순한 선택기 ( &lt;/em&gt; &lt;code&gt;.info&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 와 같은 개별 선택기) 만 확장 할 수 있습니다. 경우 &lt;code&gt;.message.info&lt;/code&gt; 을 확장 할 수의 정의 &lt;code&gt;@extend&lt;/code&gt; 는 그들이 일치하는 것처럼 확장 일치하는 요소 스타일 될 것이라고 말했습니다 &lt;code&gt;.message.info&lt;/code&gt; . 이는 &lt;code&gt;.message&lt;/code&gt; 및 &lt;code&gt;.info&lt;/code&gt; 모두 일치하는 것과 동일 하므로 &lt;code&gt;@extend .message, .info&lt;/code&gt; 대신 작성해도 이점이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2a082a950bb023fe1441646f549c479c4653830f" translate="yes" xml:space="preserve">
          <source>Only Dart Sass currently supports &lt;code&gt;@use&lt;/code&gt;. Users of other implementations must use the &lt;a href=&quot;at-rules/import&quot;&gt;&lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; instead.</source>
          <target state="translated">현재 Dart Sass만이 &lt;code&gt;@use&lt;/code&gt; 를 지원합니다 . 다른 구현의 사용자는 대신 &lt;a href=&quot;at-rules/import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; 규칙을&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2a6ca7c41d0c8d1f014f27078da3ddbc2740ad16" translate="yes" xml:space="preserve">
          <source>Only Dart Sass currently supports &lt;code&gt;@use&lt;/code&gt;. Users of other implementations must use the &lt;a href=&quot;import&quot;&gt;&lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; instead.</source>
          <target state="translated">현재 Dart Sass만이 &lt;code&gt;@use&lt;/code&gt; 를 지원합니다 . 다른 구현의 사용자는 대신 &lt;a href=&quot;import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; 규칙을&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="910233028133b5559bedec3464f28101d7700c64" translate="yes" xml:space="preserve">
          <source>Only Dart Sass currently supports loading built-in modules with &lt;code&gt;@use&lt;/code&gt;. Users of other implementations must call functions using their global names instead.</source>
          <target state="translated">현재 Dart Sass만이 &lt;code&gt;@use&lt;/code&gt; 로 내장 모듈로드를 지원합니다 . 다른 구현의 사용자는 대신 전역 이름을 사용하여 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea513e19214391d7fd937c9ac0305b2259c66810" translate="yes" xml:space="preserve">
          <source>Only Dart Sass currently supports this function.</source>
          <target state="translated">현재 Dart Sass만이이 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="90eec0f0afd2a96532c59e2797cf4fc9dbbaecaa" translate="yes" xml:space="preserve">
          <source>Only Dart Sass currently supports this mixin.</source>
          <target state="translated">현재 Dart Sass만이이 믹스 인을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a970adf23a6034dda28b3b855d26e02bf91c5d5a" translate="yes" xml:space="preserve">
          <source>Only Dart Sass supports calling &lt;code&gt;map.get()&lt;/code&gt; with more than two arguments.</source>
          <target state="translated">Dart Sass만이 3 개 이상의 인수를 사용하여 &lt;code&gt;map.get()&lt;/code&gt; 호출을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="71d07d036bdc525bdaaeee2d72cecd917c927d73" translate="yes" xml:space="preserve">
          <source>Only Dart Sass supports calling &lt;code&gt;map.has-key()&lt;/code&gt; with more than two arguments.</source>
          <target state="translated">Dart Sass만이 3 개 이상의 인수를 사용하여 &lt;code&gt;map.has-key()&lt;/code&gt; 호출을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2e8fe6ecdb955bb280deb608924c91a08f3dbc21" translate="yes" xml:space="preserve">
          <source>Only Dart Sass supports calling &lt;code&gt;map.merge()&lt;/code&gt; with more than two arguments.</source>
          <target state="translated">Dart Sass만이 두 개 이상의 인수를 사용하여 &lt;code&gt;map.merge()&lt;/code&gt; 호출을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="702b3281eb7a66baba422cd8e40b47d38304ec7a" translate="yes" xml:space="preserve">
          <source>Only Dart Sass supports calling &lt;code&gt;map.set()&lt;/code&gt; with more than three arguments.</source>
          <target state="translated">Dart Sass만이 3 개 이상의 인수를 사용하여 &lt;code&gt;map.set()&lt;/code&gt; 호출을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="27eecb4694b35a30f383992bf0ccc2c715666339" translate="yes" xml:space="preserve">
          <source>Only the first ten digits of a number after the decimal point will be included in the generated CSS.</source>
          <target state="translated">소수점 이하 숫자의 처음 10 자리 만 생성 된 CSS에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="ee8ffe5145f760b95344b6c4011186301159b8f2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;a href=&quot;../operators/equality&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../operators/relational&quot;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/a&gt; will consider two numbers equivalent if they&amp;rsquo;re the same up to the tenth digit after the decimal point.</source>
          <target state="translated">&lt;a href=&quot;../operators/equality&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../operators/relational&quot;&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;/a&gt; 와 같은 연산 은 소수점 이하 10 번째 자리까지 동일한 경우 두 숫자를 동등한 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="d691ad463ac25297b3313f781ce7492928f99d06" translate="yes" xml:space="preserve">
          <source>Optional Arguments</source>
          <target state="translated">선택적 인수</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="9d722ae6ba6a2a258f254b324106a2e548339c2b" translate="yes" xml:space="preserve">
          <source>Options can be set by setting the &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Plugin/Configuration.html#options-instance_method&quot;&gt;Sass::Plugin#options&lt;/a&gt; hash in &lt;code&gt;environment.rb&lt;/code&gt; in Rails or &lt;code&gt;config.ru&lt;/code&gt; in Rack...</source>
          <target state="translated">Rails의 &lt;code&gt;environment.rb&lt;/code&gt; 에서 &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Plugin/Configuration.html#options-instance_method&quot;&gt;Sass :: Plugin # options&lt;/a&gt; 해시를 설정 하거나 Rack에서 &lt;code&gt;config.ru&lt;/code&gt; 를 설정하여 옵션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f526dde77cafc7928204d8dac6318bed6f35f64" translate="yes" xml:space="preserve">
          <source>Or it can be used with a block containing multiple selectors:</source>
          <target state="translated">또는 여러 선택기를 포함하는 블록과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="991e00c3f59f6acfcfc8e5941ba49ff4fa5a9c11" translate="yes" xml:space="preserve">
          <source>Or the &lt;a href=&quot;https://pub.dartlang.org/documentation/sass/latest/sass/sass-library.html&quot;&gt;Dart API documentation&lt;/a&gt; if you&amp;rsquo;re calling it from Dart.</source>
          <target state="translated">또는 &lt;a href=&quot;https://pub.dartlang.org/documentation/sass/latest/sass/sass-library.html&quot;&gt;Dart&lt;/a&gt; 에서 호출하는 경우 Dart API 문서 .</target>
        </trans-unit>
        <trans-unit id="9f1762b33b20d79d93b528934ab2323b45f0b56c" translate="yes" xml:space="preserve">
          <source>Order of Operations</source>
          <target state="translated">운영 순서</target>
        </trans-unit>
        <trans-unit id="aac9354f153ca67ac7552c458c3f44c1c1e84690" translate="yes" xml:space="preserve">
          <source>Other Expressions</source>
          <target state="translated">기타 표현</target>
        </trans-unit>
        <trans-unit id="551852c7028ddd04d28686d5a46f202fe2ad7cb7" translate="yes" xml:space="preserve">
          <source>Other Functions</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="9cb6f2fb01dfa81e12bc1e11f0e7b676e54669fd" translate="yes" xml:space="preserve">
          <source>Other Options</source>
          <target state="translated">다른 옵션</target>
        </trans-unit>
        <trans-unit id="202290c40aa058f54ae62f34c03332e3c0bc905d" translate="yes" xml:space="preserve">
          <source>Other Statements</source>
          <target state="translated">기타 진술</target>
        </trans-unit>
        <trans-unit id="d4f2619ee691b00d4f190fa8da9ca100f4cc10ea" translate="yes" xml:space="preserve">
          <source>Other rules that use &lt;code&gt;.error&lt;/code&gt; will work for &lt;code&gt;.seriousError&lt;/code&gt; as well. For example, if we have special styles for errors caused by hackers:</source>
          <target state="translated">&lt;code&gt;.error&lt;/code&gt; 를 사용하는 다른 규칙 은 &lt;code&gt;.seriousError&lt;/code&gt; 에서도 작동 합니다. 예를 들어, 해커로 인한 오류에 대한 특별한 스타일이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="40613b5d36cb20b7a8b3a1d9a6d819b039917ec9" translate="yes" xml:space="preserve">
          <source>Otherwise, UTF-8 is used.</source>
          <target state="translated">그렇지 않으면 UTF-8이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8452d751fd66064e8d7e9ffc8192f29e849a7c39" translate="yes" xml:space="preserve">
          <source>Otherwise, the lowercase Unicode escape is included with a trailing space. For example, &lt;code&gt;\7Fx&lt;/code&gt; returns the unquoted string &lt;code&gt;\7f x&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 소문자 유니 코드 이스케이프가 후행 공백과 함께 포함됩니다. 예를 들어, &lt;code&gt;\7Fx&lt;/code&gt; 는 인용되지 않은 문자열 &lt;code&gt;\7f x&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d66c03870df0ff9473afa65ef1992159ba004acc" translate="yes" xml:space="preserve">
          <source>Otherwise, use the table of contents for the language reference!</source>
          <target state="translated">그렇지 않으면 목차를 언어 참조로 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="3aef76f8ba6fd4806d49ff4edaf1a4218d4bfc97" translate="yes" xml:space="preserve">
          <source>Output Style</source>
          <target state="translated">출력 스타일</target>
        </trans-unit>
        <trans-unit id="a2aaba6b325189ed96937a41610eb44a978a20f8" translate="yes" xml:space="preserve">
          <source>Output Styles</source>
          <target state="translated">출력 스타일</target>
        </trans-unit>
        <trans-unit id="2df118b905265e6c5d11e3b228c057a3b6eccb04" translate="yes" xml:space="preserve">
          <source>Overloads:</source>
          <target state="translated">Overloads:</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="2802c22f4a72970e1d5045219159766660c1f721" translate="yes" xml:space="preserve">
          <source>Page Sections</source>
          <target state="translated">페이지 섹션</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="e5755d5078efbd7029e3f77b63cab946bb4a078c" translate="yes" xml:space="preserve">
          <source>Parent Selector</source>
          <target state="translated">부모 선택기</target>
        </trans-unit>
        <trans-unit id="f9627107a88876f4aaf6d7e0b0c19984c3a631ae" translate="yes" xml:space="preserve">
          <source>Parentheses</source>
          <target state="translated">Parentheses</target>
        </trans-unit>
        <trans-unit id="5a5d3ecaebab08de9a057833d6989aba76a6656a" translate="yes" xml:space="preserve">
          <source>Parentheses can be used to affect the order of operations:</source>
          <target state="translated">괄호를 사용하여 작업 순서에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f107d199b440ddc83cfe6fc9c01e968a85b4fc6e" translate="yes" xml:space="preserve">
          <source>Parse Errors</source>
          <target state="translated">구문 분석 오류</target>
        </trans-unit>
        <trans-unit id="475223ba441a6a2cbde2eba855bcbcf7b222ffeb" translate="yes" xml:space="preserve">
          <source>Parses a user-provided selector into a list of lists of strings as returned by &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 에서 반환 한대로 사용자 제공 선택기를 문자열 목록으로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="937e56ec95ac76ea5d4634fb284a0618006151c7" translate="yes" xml:space="preserve">
          <source>Parsing a Stylesheet</source>
          <target state="translated">스타일 시트 구문 분석</target>
        </trans-unit>
        <trans-unit id="e1aae818953eb8ca4053c4ff30bde9bc13d7517f" translate="yes" xml:space="preserve">
          <source>Partials</source>
          <target state="translated">Partials</target>
        </trans-unit>
        <trans-unit id="382fe0b44eb7a4d065589fd8df9dba7c7e579df1" translate="yes" xml:space="preserve">
          <source>Partials #partials</source>
          <target state="translated">부분 # 부분</target>
        </trans-unit>
        <trans-unit id="1cf4a0797da5ae4515cb354c7e3d2506d5c0da4d" translate="yes" xml:space="preserve">
          <source>Passing Arbitrary Arguments</source>
          <target state="translated">임의의 인수 전달</target>
        </trans-unit>
        <trans-unit id="10b517a0c326f7cdb5514a5c17c1c8f9ba90f4ac" translate="yes" xml:space="preserve">
          <source>Passing Arguments to Content Blocks</source>
          <target state="translated">콘텐츠 블록에 인수 전달</target>
        </trans-unit>
        <trans-unit id="174507f368602cb47eca3dcf6a7c4744ce9c47f3" translate="yes" xml:space="preserve">
          <source>Passing Content Blocks to a Mixin #mixin-content</source>
          <target state="translated">콘텐츠 블록을 Mixin # mixin-content로 전달</target>
        </trans-unit>
        <trans-unit id="5e004b68598c82268398e8120c7b803ce3195f47" translate="yes" xml:space="preserve">
          <source>Passing a string to &lt;code&gt;call()&lt;/code&gt; still works in all implementations, but it&amp;rsquo;s deprecated and will be disallowed in future versions.</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 문자열을 전달하는 것은 모든 구현에서 여전히 작동하지만 더 이상 사용되지 않으며 향후 버전에서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f12f6ea0eb6ec50433a4ceb50c8f15be1cde0e3" translate="yes" xml:space="preserve">
          <source>Percentages in Sass work just like every other unit. They are &lt;em&gt;not&lt;/em&gt; interchangeable with decimals, because in CSS decimals and percentages mean different things. For example, &lt;code&gt;50%&lt;/code&gt; is a number with &lt;code&gt;%&lt;/code&gt; as its unit, and Sass considers it different than the number &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">Sass의 백분율은 다른 모든 단위와 동일하게 작동합니다. 그들은는 &lt;em&gt;하지&lt;/em&gt; 때문에 CSS의 소수에서, 소수와 상호 교환 및 비율은 다른 것을 의미한다. 예를 들어, &lt;code&gt;50%&lt;/code&gt; 는 &lt;code&gt;%&lt;/code&gt; 를 단위로 하는 숫자 이고 Sass는 &lt;code&gt;0.5&lt;/code&gt; 와 다른 것으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="12caa4cc15915e649a7170042a5b32c438105b72" translate="yes" xml:space="preserve">
          <source>Placeholder Selectors</source>
          <target state="translated">자리 표시 자 선택기</target>
        </trans-unit>
        <trans-unit id="b8dbc970b1740db190bc80080356a5c06b33e85a" translate="yes" xml:space="preserve">
          <source>Placeholder Selectors: &lt;code&gt;%foo&lt;/code&gt;</source>
          <target state="translated">자리 표시 자 선택기 : &lt;code&gt;%foo&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a1807298fe43d85bf2f7dc3cf4646e2cb1464c0" translate="yes" xml:space="preserve">
          <source>Placeholder selectors are useful when writing a Sass library where each style rule may or may not be used. As a rule of thumb, if you&amp;rsquo;re writing a stylesheet just for your own app, it&amp;rsquo;s often better to just extend a class selector if one is available.</source>
          <target state="translated">자리 표시 자 선택기는 각 스타일 규칙이 사용되거나 사용되지 않을 수있는 Sass 라이브러리를 작성할 때 유용합니다. 경험적으로 자신의 앱만을위한 스타일 시트를 작성하는 경우 클래스 선택기를 사용할 수있는 경우 확장하는 것이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b0f1e4410b7c54d63bca94a5b0237017928759bd" translate="yes" xml:space="preserve">
          <source>Placeholder selectors look like class and id selectors, except the &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; is replaced by &lt;code&gt;%&lt;/code&gt;. They can be used anywhere a class or id could, and on their own they prevent rulesets from being rendered to CSS. For example:</source>
          <target state="translated">자리 표시 자 선택기는 제외하고, 클래스와 ID 선택기처럼 &lt;code&gt;#&lt;/code&gt; 또는 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; 로 대체되었습니다 . 클래스 나 ID가있는 곳이면 어디에서나 사용할 수 있으며, 자체적으로 규칙 세트가 CSS로 렌더링되는 것을 방지합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a175e693b374d4493d7b0e3d217567c76d1d2ae" translate="yes" xml:space="preserve">
          <source>Plain CSS &lt;code&gt;@import&lt;/code&gt;s</source>
          <target state="translated">일반 CSS &lt;code&gt;@import&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="e95f4c628e1950df7e58d812c64c34abd443548d" translate="yes" xml:space="preserve">
          <source>Plain CSS Functions</source>
          <target state="translated">일반 CSS 함수</target>
        </trans-unit>
        <trans-unit id="c69c7edce2e30c07d4d24840b8b06debd3d19b52" translate="yes" xml:space="preserve">
          <source>Plain CSS function names</source>
          <target state="translated">일반 CSS 함수 이름</target>
        </trans-unit>
        <trans-unit id="a327806ce6bc8e41e7a15559687d221d323ede6f" translate="yes" xml:space="preserve">
          <source>Plain CSS&lt;code&gt;@import&lt;/code&gt;s</source>
          <target state="translated">일반 CSS &lt;code&gt;@import&lt;/code&gt; s</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="17cf3dabf6bc7dc21b9d1a5d6c5ffd7fbfeb0605" translate="yes" xml:space="preserve">
          <source>Private Members</source>
          <target state="translated">개인 회원</target>
        </trans-unit>
        <trans-unit id="b531a743226fd315cba3a568c4d2adb5df8bdde7" translate="yes" xml:space="preserve">
          <source>Private Placeholders</source>
          <target state="translated">비공개 자리 표시 자</target>
        </trans-unit>
        <trans-unit id="8026192ae46c8d75559c9211d8ad7ffaa4f4585a" translate="yes" xml:space="preserve">
          <source>Property Declarations</source>
          <target state="translated">속성 선언</target>
        </trans-unit>
        <trans-unit id="bd13ea8b9b871dd6b38cca8e0f1184b0535d90e7" translate="yes" xml:space="preserve">
          <source>Property names in declarations</source>
          <target state="translated">선언의 속성 이름</target>
        </trans-unit>
        <trans-unit id="8e06ee91ee276aa5597f240bfdf862c7bbaaf1af" translate="yes" xml:space="preserve">
          <source>Quoted</source>
          <target state="translated">Quoted</target>
        </trans-unit>
        <trans-unit id="e555ca00e12644d44994f87d0f5b40e67a4fe054" translate="yes" xml:space="preserve">
          <source>Quoted Strings</source>
          <target state="translated">인용 된 문자열</target>
        </trans-unit>
        <trans-unit id="433e8cd6ceba6fbb5365d4cbc4c77708250468d1" translate="yes" xml:space="preserve">
          <source>Quoted or unquoted strings</source>
          <target state="translated">인용되거나 인용되지 않은 문자열</target>
        </trans-unit>
        <trans-unit id="2a9325146b5d935a8e4b2b7fa3f8c22c67f62d01" translate="yes" xml:space="preserve">
          <source>Quoted strings are guaranteed to be compiled to CSS strings that have the same contents as the original Sass strings. The exact format may vary based on the implementation or configuration&amp;mdash;a string containing a double quote may be compiled to &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; or &lt;code&gt;'&quot;'&lt;/code&gt;, and a non-&lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; character may or may not be escaped. But that should be parsed the same in any standards-compliant CSS implementation, including all browsers.</source>
          <target state="translated">인용 된 문자열은 원래 Sass 문자열과 동일한 내용을 가진 CSS 문자열로 컴파일됩니다. 정확한 형식은 구현 또는 구성에 따라 다를 수 있습니다. 큰 따옴표가 포함 된 문자열은 &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&quot;'&lt;/code&gt; 로 컴파일 될 수 있으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; 가 아닌 문자는 이스케이프되거나 이스케이프되지 않을 수 있습니다. 그러나 모든 브라우저를 포함하여 모든 표준 호환 CSS 구현에서 동일하게 구문 분석되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e82ae9017bba7215709a258269319fec1393b498" translate="yes" xml:space="preserve">
          <source>Quoted strings are written between either single or double quotes, as in &lt;code&gt;&quot;Helvetica Neue&quot;&lt;/code&gt;. They can contain &lt;a href=&quot;../interpolation&quot;&gt;interpolation&lt;/a&gt;, as well as any unescaped character except for:</source>
          <target state="translated">인용 된 문자열은 &lt;code&gt;&quot;Helvetica Neue&quot;&lt;/code&gt; 에서와 같이 작은 따옴표 또는 큰 따옴표 사이에 작성 됩니다. 다음을 제외한 모든 이스케이프 처리되지 않은 문자뿐만 아니라 &lt;a href=&quot;../interpolation&quot;&gt;보간&lt;/a&gt; 을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="919c02f72c8dc766a3ec88ccb258a30d50b18ab4" translate="yes" xml:space="preserve">
          <source>Rack/Rails/Merb Plugin</source>
          <target state="translated">랙 / 레일 / Merb 플러그인</target>
        </trans-unit>
        <trans-unit id="cbab26157fbc3b0526dc0021d74676f7ac742b77" translate="yes" xml:space="preserve">
          <source>Railroad diagram copyright &amp;copy; 2018 W3C&lt;sup&gt;&amp;reg;&lt;/sup&gt; (MIT, ERCIM, Keio, Beihang). W3C&lt;a href=&quot;http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer&quot;&gt;liability&lt;/a&gt;, &lt;a href=&quot;http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks&quot;&gt;trademark&lt;/a&gt; and &lt;a href=&quot;http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document&quot;&gt;permissive document license&lt;/a&gt; rules apply.</source>
          <target state="translated">철도 다이어그램 저작권 &amp;copy; 2018 W3C &lt;sup&gt;&amp;reg;&lt;/sup&gt; (MIT, ERCIM, Keio, Beihang). W3C &lt;a href=&quot;http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer&quot;&gt;책임&lt;/a&gt; , &lt;a href=&quot;http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks&quot;&gt;상표&lt;/a&gt; 및 &lt;a href=&quot;http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document&quot;&gt;허용 문서 라이선스&lt;/a&gt; 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="79395baf2e1c527bae4141a75235a0eefb3f634b" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;$base&lt;/code&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Exponentiation&quot;&gt;to the power of&lt;/a&gt;&lt;code&gt;$exponent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$base&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponentiation&quot;&gt;를 &lt;/a&gt; &lt;code&gt;$exponent&lt;/code&gt; 제곱으로 올립니다 .</target>
        </trans-unit>
        <trans-unit id="e0eb5268f437200e3ca42ec2d178bdfb80e8e252" translate="yes" xml:space="preserve">
          <source>Raises:</source>
          <target state="translated">Raises:</target>
        </trans-unit>
        <trans-unit id="c07be06a9d0942a578db072018d18f8a662503c6" translate="yes" xml:space="preserve">
          <source>Referencing Parent Selectors: &lt;code&gt;&amp;amp;&lt;/code&gt; #parent-selector</source>
          <target state="translated">부모 선택기 참조 : &lt;code&gt;&amp;amp;&lt;/code&gt; # parent-selector</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">관계 연산자</target>
        </trans-unit>
        <trans-unit id="300d986e9c634e87b8a5acab34b704dc9f08b5e3" translate="yes" xml:space="preserve">
          <source>Relational operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;) are also supported for numbers, and equality operators (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) are supported for all types.</source>
          <target state="translated">관계 연산자 ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; )도 숫자에 대한 지원, 평등 연산자 ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; ) 모든 종류의 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="94ea463c80df7da62ba5fb4fca637b727cbb79df" translate="yes" xml:space="preserve">
          <source>Relational operators determine whether &lt;a href=&quot;../values/numbers&quot;&gt;numbers&lt;/a&gt; are larger or smaller than one another. They automatically convert between compatible units.</source>
          <target state="translated">관계 연산자는 &lt;a href=&quot;../values/numbers&quot;&gt;숫자&lt;/a&gt; 가 서로 큰지 작은 지를 결정합니다 . 호환되는 단위간에 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="670a1246f19c95ceec3dc72fea9216deb3b1e8e8" translate="yes" xml:space="preserve">
          <source>Removes quotes from a string. If the string is already unquoted, this will return it unmodified.</source>
          <target state="translated">문자열에서 따옴표를 제거합니다. 문자열이 이미 인용되지 않은 경우 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1607356e597f16ff04732753955c924b6ac2187c" translate="yes" xml:space="preserve">
          <source>Replaces all instances of &lt;code&gt;$original&lt;/code&gt; with &lt;code&gt;$replacement&lt;/code&gt; in &lt;code&gt;$selector&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$selector&lt;/code&gt; 에서 $ &lt;code&gt;$original&lt;/code&gt; 의 모든 인스턴스 를 &lt;code&gt;$replacement&lt;/code&gt; 로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="cfa5e2d887f8850689969682acba8e894f56eb38" translate="yes" xml:space="preserve">
          <source>Restricts &lt;code&gt;$number&lt;/code&gt; to the range between &lt;code&gt;$min&lt;/code&gt; and &lt;code&gt;$max&lt;/code&gt;. If &lt;code&gt;$number&lt;/code&gt; is less than &lt;code&gt;$min&lt;/code&gt; this returns &lt;code&gt;$min&lt;/code&gt;, and if it&amp;rsquo;s greater than &lt;code&gt;$max&lt;/code&gt; this returns &lt;code&gt;$max&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 를 &lt;code&gt;$min&lt;/code&gt; 에서 &lt;code&gt;$max&lt;/code&gt; 사이의 범위로 제한 합니다. 경우 &lt;code&gt;$number&lt;/code&gt; 미만 &lt;code&gt;$min&lt;/code&gt; 이 반환 &lt;code&gt;$min&lt;/code&gt; , 그리고보다 그것의 더 큰 경우 &lt;code&gt;$max&lt;/code&gt; 이 반환 &lt;code&gt;$max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92b958d353c51af8e3a7d9c86b9846f96f7b31d5" translate="yes" xml:space="preserve">
          <source>Result Object</source>
          <target state="translated">결과 개체</target>
        </trans-unit>
        <trans-unit id="0a098796ce9c4464f246388db35938a4fb8e9e25" translate="yes" xml:space="preserve">
          <source>Return a decimal between 0 and 1, inclusive of 0 but not 1.</source>
          <target state="translated">0을 포함하지만 1은 포함하지 않는 0과 1 사이의 소수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca697c9676025d695d9bb3bdfe66da3ae3200550" translate="yes" xml:space="preserve">
          <source>Return a new list, based on the list provided, but with the nth element changed to the value given.</source>
          <target state="translated">제공된 목록을 기준으로 새 목록을 반환하지만 n 번째 요소가 제공된 값으로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="f6a62674270588e7988262fa17987874416e5829" translate="yes" xml:space="preserve">
          <source>Return a new selector with all selectors in &lt;code&gt;$selectors&lt;/code&gt; appended one another as though they had been nested in the stylesheet as &lt;code&gt;$selector1 { &amp;amp;$selector2 { ... } }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$selector1 { &amp;amp;$selector2 { ... } }&lt;/code&gt; 로 스타일 시트에 중첩 된 것처럼 &lt;code&gt;$selectors&lt;/code&gt; 모든 선택기가 서로 추가 된 새 선택기를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d786c6c7ee742054a909f7c1b81b3ba1b0385868" translate="yes" xml:space="preserve">
          <source>Return a new selector with all selectors in &lt;code&gt;$selectors&lt;/code&gt; nested beneath one another as though they had been nested in the stylesheet as &lt;code&gt;$selector1 { $selector2 { ... } }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$selector1 { $selector2 { ... } }&lt;/code&gt; 로 스타일 시트에 중첩 된 것처럼 &lt;code&gt;$selectors&lt;/code&gt; 모든 선택기가 서로 중첩 된 새 선택기를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="fecae0aae65cbb793f8b56a5e7bd50520734109b" translate="yes" xml:space="preserve">
          <source>Return a string containing the value as its Sass representation.</source>
          <target state="translated">Sass 표현으로 값을 포함하는 문자열을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="90e91a4bbe1cfd7eb6a7673ffd79bad43d456339" translate="yes" xml:space="preserve">
          <source>Return an integer between 1 and &lt;code&gt;$limit&lt;/code&gt;, inclusive of both 1 and &lt;code&gt;$limit&lt;/code&gt;.</source>
          <target state="translated">1 사이의 정수 반환 &lt;code&gt;$limit&lt;/code&gt; 모두 1 포함, &lt;code&gt;$limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c07470b33157e00d0801cb59275e075b771c1ccb" translate="yes" xml:space="preserve">
          <source>Return the length of a list.</source>
          <target state="translated">리스트의 길이를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="fb057ce72403b54191be4a09c94e8f9300c7aced" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;../values/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; if the map does not have a value associated with the key, or if any key in &lt;code&gt;$keys&lt;/code&gt; is missing from a map or references a value that is not a map.</source>
          <target state="translated">맵에 키와 연결된 값 이 없거나 &lt;code&gt;$keys&lt;/code&gt; 가 맵에서 누락되었거나 맵이 아닌 값을 참조하는 경우 &lt;a href=&quot;../values/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 을&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e4cdf5d42c0671647d2b7bb0968806799a4eb199" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;$if-true&lt;/code&gt; if &lt;code&gt;$condition&lt;/code&gt; is &lt;a href=&quot;at-rules/control/if#truthiness-and-falsiness&quot;&gt;truthy&lt;/a&gt;, and &lt;code&gt;$if-false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;$if-true&lt;/code&gt; 경우 &lt;code&gt;$condition&lt;/code&gt; 이다 &lt;a href=&quot;at-rules/control/if#truthiness-and-falsiness&quot;&gt;truthy&lt;/a&gt; , 및 &lt;code&gt;$if-false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="9c3297b36141174e06a6196507a7b94b480afdf1" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;$selector&lt;/code&gt; in the &lt;a href=&quot;#selector-values&quot;&gt;selector value&lt;/a&gt; format.</source>
          <target state="translated">&lt;a href=&quot;#selector-values&quot;&gt;선택기 값&lt;/a&gt; 형식으로 &lt;code&gt;$selector&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="249ffe23331434e32c564f1a4689c2eaac25ee4a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;$string&lt;/code&gt; as a quoted string.</source>
          <target state="translated">&lt;code&gt;$string&lt;/code&gt; 을 인용 된 문자열 로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="32ff0d023ae7d1a21de339c4dbe7f0ad73b60841" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;$string&lt;/code&gt; as an unquoted string. This can produce strings that aren&amp;rsquo;t valid CSS, so use with caution.</source>
          <target state="translated">&lt;code&gt;$string&lt;/code&gt; 을 인용되지 않은 문자열 로 반환 합니다. 이것은 유효한 CSS가 아닌 문자열을 생성 할 수 있으므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c0906bcfe3179993cff5b2ec089cc5ae3a58639f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;false&lt;/code&gt; for any unrecognized &lt;code&gt;$feature&lt;/code&gt;.</source>
          <target state="translated">인식 할 수없는 &lt;code&gt;$feature&lt;/code&gt; 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="eb5215354c106af2212e9f9c422fc9ba94c22cc4" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;$selector1&lt;/code&gt; and &lt;code&gt;$selector2&lt;/code&gt; don&amp;rsquo;t match any of the same elements, or if there&amp;rsquo;s no selector that can express their overlap.</source>
          <target state="translated">&lt;code&gt;$selector1&lt;/code&gt; 및 &lt;code&gt;$selector2&lt;/code&gt; 가 동일한 요소와 일치하지 않거나 중첩을 표현할 수있는 선택 기가 &lt;code&gt;null&lt;/code&gt; 경우 null을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="898a6b17935b803e11e9f1af1939dd597811f399" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the boolean is the Sass value &lt;code&gt;true&lt;/code&gt;, and false if it&amp;rsquo;s the Sass value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 부울는 말대꾸 값의 경우 &lt;code&gt;true&lt;/code&gt; 가 말대꾸 값의 경우, 거짓 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9088f434b0b978079a78739bbc1126fd623b13" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the list is comma-separated, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">목록이 쉼표로 구분되면 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f6a052d8f52ede9829ca353baf2ad1fe25aef91" translate="yes" xml:space="preserve">
          <source>Returns A list of lists of strings representing &lt;code&gt;$selector&lt;/code&gt;. This is in the same format as a selector returned by &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$selector&lt;/code&gt; 나타내는 문자열 목록을 리턴합니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 로 반환 된 선택기와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="c8b878ae579da9409cf7d7baa8ef1f74d25be570" translate="yes" xml:space="preserve">
          <source>Returns A list of lists of strings representing the result of appending &lt;code&gt;$selectors&lt;/code&gt;. This is in the same format as a selector returned by &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$selectors&lt;/code&gt; 추가 결과를 나타내는 문자열 목록을 리턴합니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 로 반환 된 선택기와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="681bf66491ff841a9a3ecda1364da535f5efc671" translate="yes" xml:space="preserve">
          <source>Returns A list of lists of strings representing the result of nesting &lt;code&gt;$selectors&lt;/code&gt;. This is in the same format as a selector returned by &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$selectors&lt;/code&gt; 를 중첩 한 결과를 나타내는 문자열 목록을 반환합니다 . &lt;code&gt;&amp;amp;&lt;/code&gt; 로 반환 된 선택기와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="cafdbbccfa855d711958927868096ff911afe9f8" translate="yes" xml:space="preserve">
          <source>Returns A list of lists of strings representing the result of the extension. This is in the same format as a selector returned by &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">확장 결과를 나타내는 문자열 목록을 반환합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 로 반환 된 선택기와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="cb3112dd58bcce2f656ec836bc0870940f3b7cb6" translate="yes" xml:space="preserve">
          <source>Returns A list of lists of strings representing the result of the unification, or null if no unification exists. This is in the same format as a selector returned by &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">통합 결과를 나타내는 문자열 목록을 리턴하거나 통합이없는 경우 널을 리턴합니다. &lt;code&gt;&amp;amp;&lt;/code&gt; 로 반환 된 선택기와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="7fff605b99df76ab731c698f7cedf9a3671871f0" translate="yes" xml:space="preserve">
          <source>Returns A list of simple selectors in the compound selector.</source>
          <target state="translated">복합 선택기의 단순 선택기 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7810bbd9c0fa87887e06262e239afdf0537d4582" translate="yes" xml:space="preserve">
          <source>Returns The substring. This will be quoted if and only if &lt;code&gt;$string&lt;/code&gt; was quoted</source>
          <target state="translated">부분 문자열을 반환합니다. &lt;code&gt;$string&lt;/code&gt; 이 인용 된 경우에만 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="45122d96ce3cff3b4f36a0787a2f17262c4946d7" translate="yes" xml:space="preserve">
          <source>Returns Whether &lt;code&gt;$selector1&lt;/code&gt; is a superselector of &lt;code&gt;$selector2&lt;/code&gt;.</source>
          <target state="translated">반환 여부 &lt;code&gt;$selector1&lt;/code&gt; 의 superselector입니다 &lt;code&gt;$selector2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb4dbde3c3c8c57700438662f9506d8ae071fbad" translate="yes" xml:space="preserve">
          <source>Returns a color with the given &lt;a href=&quot;https://en.wikipedia.org/wiki/HSL_and_HSV&quot;&gt;hue, saturation, and lightness&lt;/a&gt; and the given alpha channel.</source>
          <target state="translated">주어진 &lt;a href=&quot;https://en.wikipedia.org/wiki/HSL_and_HSV&quot;&gt;색조, 채도 및 밝기&lt;/a&gt; 와 주어진 알파 채널을 사용 하여 색상을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0a771f31e003265d47ff5059f6063e4fc6c60309" translate="yes" xml:space="preserve">
          <source>Returns a color with the given &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;hue, whiteness, and blackness&lt;/a&gt; and the given alpha channel.</source>
          <target state="translated">주어진 &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;색조, 흰색,&lt;/a&gt; 검은 색과 주어진 알파 채널을 가진 색상을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf7dc97931e2c724e27a45cddb7b9661e795fc9" translate="yes" xml:space="preserve">
          <source>Returns a comma-separated list of all the keys in &lt;code&gt;$map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$map&lt;/code&gt; 에있는 모든 키의 쉼표로 구분 된 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d91484bd86a0364328a9c0b93244c9110296ab27" translate="yes" xml:space="preserve">
          <source>Returns a comma-separated list of all the values in &lt;code&gt;$map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$map&lt;/code&gt; 에있는 모든 값의 쉼표로 구분 된 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="34c050842516f7ed7ff369ad29af1a56ecd1f223" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$list&lt;/code&gt; with &lt;code&gt;$val&lt;/code&gt; added to the end.</source>
          <target state="translated">반환의 사본 &lt;code&gt;$list&lt;/code&gt; 에 &lt;code&gt;$val&lt;/code&gt; 끝에 추가.</target>
        </trans-unit>
        <trans-unit id="574d67fd095aa48e4721721aa10937adce3804cc" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$list&lt;/code&gt; with the element at &lt;a href=&quot;../values/lists#indexes&quot;&gt;index&lt;/a&gt;&lt;code&gt;$n&lt;/code&gt; replaced with &lt;code&gt;$value&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../values/lists#indexes&quot;&gt;색인 &lt;/a&gt; &lt;code&gt;$n&lt;/code&gt; 의 요소 가 &lt;code&gt;$value&lt;/code&gt; 로 대체 된 &lt;code&gt;$list&lt;/code&gt; 복사본을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="f241867340b7c15856db35eed80a96f8aea1d893" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$map1&lt;/code&gt; where the targeted map is replaced by a new map that contains all the keys and values from both the targeted map and &lt;code&gt;$map2&lt;/code&gt;.</source>
          <target state="translated">대상 맵이 대상 맵과 &lt;code&gt;$map2&lt;/code&gt; 모두의 모든 키와 값을 포함하는 새 맵으로 대체 된 &lt;code&gt;$map1&lt;/code&gt; 의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="be8bee096f60104df2d8fd1d8c1c4eb80b03713c" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$map&lt;/code&gt; where the targeted map does not have a value associated with the last key in &lt;code&gt;$keys&lt;/code&gt;.</source>
          <target state="translated">대상지도에 &lt;code&gt;$keys&lt;/code&gt; 의 마지막 키와 연결된 값이없는 &lt;code&gt;$map&lt;/code&gt; 의 복사본을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6c894af178358e70ca8e2d2d9e86041f354a12f9" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$map&lt;/code&gt; with the targeted map&amp;rsquo;s value at &lt;code&gt;$key&lt;/code&gt; set to &lt;code&gt;$value&lt;/code&gt;.</source>
          <target state="translated">반환의 사본 &lt;code&gt;$map&lt;/code&gt; 에 표적으로 한지도의 값이 &lt;code&gt;$key&lt;/code&gt; 를 설정 &lt;code&gt;$value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c60794a6f9628dd3dda1513f7c6114c4478a2bfe" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$map&lt;/code&gt; without any values associated with &lt;code&gt;$keys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$keys&lt;/code&gt; 와 관련된 값없이 &lt;code&gt;$map&lt;/code&gt; 의 복사본을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a61ba0a1e026ee99909219dc83cdb6658860c89" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$selector&lt;/code&gt; modified with the following &lt;code&gt;@extend&lt;/code&gt; rule:</source>
          <target state="translated">다음 &lt;code&gt;@extend&lt;/code&gt; 규칙으로 수정 된 &lt;code&gt;$selector&lt;/code&gt; 의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="561de92c8c64c2ef01cb3a98b778ed6c436ea936" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$selector&lt;/code&gt; with all instances of &lt;code&gt;$original&lt;/code&gt; replaced by &lt;code&gt;$replacement&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$original&lt;/code&gt; 의 모든 인스턴스 가 &lt;code&gt;$replacement&lt;/code&gt; 로 대체 된 $ &lt;code&gt;$selector&lt;/code&gt; 의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="54c79e29002621547c98326d51f8a1b588a64144" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$string&lt;/code&gt; with &lt;code&gt;$insert&lt;/code&gt; inserted at &lt;a href=&quot;../values/strings#string-indexes&quot;&gt;&lt;code&gt;$index&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환의 사본 &lt;code&gt;$string&lt;/code&gt; 에 &lt;code&gt;$insert&lt;/code&gt; 삽입 &lt;a href=&quot;../values/strings#string-indexes&quot;&gt; &lt;code&gt;$index&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3dee6dc39f9d5b855dd2a4b9732b7dc5b322965e" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$string&lt;/code&gt; with the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; letters converted to lower case.</source>
          <target state="translated">반환의 사본 &lt;code&gt;$string&lt;/code&gt; 와 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;의 ASCII&lt;/a&gt; 문자는 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c841eb151c8f746dc1d40708bfcfe8a0711ab217" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;$string&lt;/code&gt; with the &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; letters converted to upper case.</source>
          <target state="translated">의 카피를 돌려줍니다 &lt;code&gt;$string&lt;/code&gt; 와 &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;아스키&lt;/a&gt; 문자가 대문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="998630824c12877f4b98b871bfb29c286be6f247" translate="yes" xml:space="preserve">
          <source>Returns a gray color with the same lightness as &lt;code&gt;$color&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 와 동일한 밝기로 회색을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f45056679ba8933cc8f58a15e532480b82589e48" translate="yes" xml:space="preserve">
          <source>Returns a list of all keys in a map.</source>
          <target state="translated">지도의 모든 키 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="468e70b240f8d38fce4be5ca4f56db2f415dfc22" translate="yes" xml:space="preserve">
          <source>Returns a list of all values in a map. This list may include duplicate values, if multiple keys have the same value.</source>
          <target state="translated">지도의 모든 값 목록을 반환합니다. 여러 키의 값이 동일한 경우이 목록에 중복 값이 ​​포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731483297ad07944a7979ff17ba55a9526f7a6a4" translate="yes" xml:space="preserve">
          <source>Returns a list of simple selectors in &lt;code&gt;$selector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$selector&lt;/code&gt; 의 단순 선택기 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d46d68e2902846fb9c9a2fbc4818a68607ba48cc" translate="yes" xml:space="preserve">
          <source>Returns a new list containing the elements of &lt;code&gt;$list1&lt;/code&gt; followed by the elements of &lt;code&gt;$list2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$list1&lt;/code&gt; 의 요소와 &lt;code&gt;$list2&lt;/code&gt; 의 요소를 포함하는 새 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f6d643e2176a2ae6ca49ca4e54fd08bc70807b73" translate="yes" xml:space="preserve">
          <source>Returns a new map with keys removed.</source>
          <target state="translated">키가 제거 된 새지도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa71fec219d9e6da99bbca84041bb4d3e6acaaca" translate="yes" xml:space="preserve">
          <source>Returns a new version of &lt;code&gt;$selector&lt;/code&gt; with &lt;code&gt;$extendee&lt;/code&gt; extended with &lt;code&gt;$extender&lt;/code&gt;. This works just like the result of</source>
          <target state="translated">반환의 새로운 버전 &lt;code&gt;$selector&lt;/code&gt; 와 &lt;code&gt;$extendee&lt;/code&gt; 로 확장 &lt;code&gt;$extender&lt;/code&gt; . 이것은 다음과 같은 결과로 작동합니다</target>
        </trans-unit>
        <trans-unit id="f7debff9e64a5e5c07bf9f9de9a936a9ddb28823" translate="yes" xml:space="preserve">
          <source>Returns a number that&amp;rsquo;s a mixture of &lt;code&gt;$color1&lt;/code&gt; and &lt;code&gt;$color2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$color1&lt;/code&gt; 과 &lt;code&gt;$color2&lt;/code&gt; 가 혼합 된 숫자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a269eb48227cbf36d12e9a515e49e1d887b7b9e2" translate="yes" xml:space="preserve">
          <source>Returns a randomly-generated unquoted string that&amp;rsquo;s guaranteed to be a valid CSS identifier and to be unique within the current Sass compilation.</source>
          <target state="translated">유효한 CSS 식별자이고 현재 Sass 컴파일 내에서 고유함이 보장되는 무작위로 생성 된 인용되지 않은 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79db0f86648abae15ff2e887d2f8b783c7aca591" translate="yes" xml:space="preserve">
          <source>Returns a reference to a function for later invocation with the &lt;code&gt;call()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;call()&lt;/code&gt; 함수를 사용하여 나중에 호출하기위한 함수에 대한 참조를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fb890b6d723e63def5ce0abf7a2a0288c8371f79" translate="yes" xml:space="preserve">
          <source>Returns a representation of &lt;em&gt;any&lt;/em&gt; Sass value, not just those that can be represented in CSS. As such, its return value is not guaranteed to be valid CSS.</source>
          <target state="translated">CSS로 표현할 수있는 값뿐만 아니라 &lt;em&gt;모든&lt;/em&gt; Sass 값 의 표현을 반환합니다 . 따라서 반환 값이 유효한 CSS라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="55957dece7996a4bb4c9e933d3ef17428ea6ccc2" translate="yes" xml:space="preserve">
          <source>Returns a selector that matches only elements matched by &lt;em&gt;both&lt;/em&gt;&lt;code&gt;$selector1&lt;/code&gt; and &lt;code&gt;$selector2&lt;/code&gt;.</source>
          <target state="translated">반환 일치하는 경우에만 요소가 일치하는 선택 &lt;em&gt;모두 &lt;/em&gt; &lt;code&gt;$selector1&lt;/code&gt; 및 &lt;code&gt;$selector2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf02f500fc1bb9a15c95b64ce230fe9e60ebab27" translate="yes" xml:space="preserve">
          <source>Returns a string representation of &lt;code&gt;$number&lt;/code&gt;&amp;rsquo;s units.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 단위 의 문자열 표현을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7b483cc27e0b71d6a9790908fd380625bd214385" translate="yes" xml:space="preserve">
          <source>Returns a string representation of &lt;code&gt;$value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$value&lt;/code&gt; 의 문자열 표현을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="dd453ac892432e3a43f7f4574d7f4c8c32a37a86" translate="yes" xml:space="preserve">
          <source>Returns a unique CSS identifier. The identifier is returned as an unquoted string. The identifier returned is only guaranteed to be unique within the scope of a single Sass run.</source>
          <target state="translated">고유 한 CSS 식별자를 반환합니다. 식별자는 따옴표없는 문자열로 반환됩니다. 반환 된 식별자는 단일 Sass 실행 범위 내에서만 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e88c3f2a49533d48f659fa7d55bbeea7e08df4" translate="yes" xml:space="preserve">
          <source>Returns all the functions defined in a module, as a map from function names to &lt;a href=&quot;../values/functions&quot;&gt;function values&lt;/a&gt;.</source>
          <target state="translated">함수 이름에서 &lt;a href=&quot;../values/functions&quot;&gt;함수 값&lt;/a&gt; 으로의 맵으로 모듈에 정의 된 모든 함수를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e1a867f177933e46962d4756bbe2151595608646" translate="yes" xml:space="preserve">
          <source>Returns all the variables defined in a module, as a map from variable names (without &lt;code&gt;$&lt;/code&gt;) to the values of those variables.</source>
          <target state="translated">모듈에 정의 된 모든 변수를 변수 이름 ( &lt;code&gt;$&lt;/code&gt; 제외)에서 해당 변수 값 으로의 맵으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cf954a08b11faca5408ee01bc1ffa94e703030e4" translate="yes" xml:space="preserve">
          <source>Returns an unquoted string that represents &lt;code&gt;$color&lt;/code&gt; in the &lt;code&gt;#AARRGGBB&lt;/code&gt; format expected by Internet Explorer&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter&quot;&gt;&lt;code&gt;-ms-filter&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">Internet Explorer의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter&quot;&gt; &lt;code&gt;-ms-filter&lt;/code&gt; &lt;/a&gt; 속성 에 필요한 &lt;code&gt;#AARRGGBB&lt;/code&gt; 형식으로 &lt;code&gt;$color&lt;/code&gt; 를 나타내는 인용되지 않은 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9785c9f859f3c8c15e02ae07fa4b5f4713dda054" translate="yes" xml:space="preserve">
          <source>Returns false if it does not, or if any key in &lt;code&gt;$keys&lt;/code&gt; is missing from a map or references a value that is not a map.</source>
          <target state="translated">그렇지 않은 경우 또는 &lt;code&gt;$keys&lt;/code&gt; 가 맵에서 누락되었거나 맵이 아닌 값을 참조하는 경우 false를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ebd04b66d30293595136a62cc8fac8b316642c0c" translate="yes" xml:space="preserve">
          <source>Returns one of two values, depending on whether or not &lt;code&gt;$condition&lt;/code&gt; is true. Just like in &lt;code&gt;@if&lt;/code&gt;, all values other than &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; are considered to be true.</source>
          <target state="translated">&lt;code&gt;$condition&lt;/code&gt; 이 true 인지 여부에 따라 두 값 중 하나를 리턴 합니다. &lt;code&gt;@if&lt;/code&gt; 에서 와 같이 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 이외의 모든 값 은 true로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fd33c97a0ae0e81976060eb166d228e16c63a6ab" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;../values/functions&quot;&gt;function&lt;/a&gt; named &lt;code&gt;$name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$name&lt;/code&gt; 이라는 &lt;a href=&quot;../values/functions&quot;&gt;함수를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9c491a40c3cd07f70c78be29b35baeb2a15115dd" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;../values/lists#indexes&quot;&gt;index&lt;/a&gt; of &lt;code&gt;$value&lt;/code&gt; in &lt;code&gt;$list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$list&lt;/code&gt; 에서 $ &lt;code&gt;$value&lt;/code&gt; 의 &lt;a href=&quot;../values/lists#indexes&quot;&gt;인덱스&lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="64badb95bd6e180f7ab47ec8541c943a1790de67" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;http://dev.w3.org/csswg/selectors4/#simple&quot;&gt;simple selectors&lt;/a&gt; that comprise the compound selector &lt;code&gt;$selector&lt;/code&gt;.</source>
          <target state="translated">복합 선택기 &lt;code&gt;$selector&lt;/code&gt; 를 구성 하는 &lt;a href=&quot;http://dev.w3.org/csswg/selectors4/#simple&quot;&gt;단순 선택기&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b5ab43ce15abec778e6e5e697d298143d6e24c17" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Absolute_value&quot;&gt;absolute value&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt;. If &lt;code&gt;$number&lt;/code&gt; is negative, this returns &lt;code&gt;-$number&lt;/code&gt;, and if &lt;code&gt;$number&lt;/code&gt; is positive, it returns &lt;code&gt;$number&lt;/code&gt; as-is.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Absolute_value&quot;&gt;절대 값&lt;/a&gt; 을 반환합니다 . 경우 &lt;code&gt;$number&lt;/code&gt; 음수,이 반환 &lt;code&gt;-$number&lt;/code&gt; 있다면, 그리고 &lt;code&gt;$number&lt;/code&gt; 긍정적, 그것은 반환 &lt;code&gt;$number&lt;/code&gt; 있는 그대로를.</target>
        </trans-unit>
        <trans-unit id="558ce99a8774f76eafa5c1514b499da914a2dfb5" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;2-argument arctangent&lt;/a&gt; of &lt;code&gt;$y&lt;/code&gt; and &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;이 인수 아크 탄젠트&lt;/a&gt; 의 &lt;code&gt;$y&lt;/code&gt; 하고 &lt;code&gt;$x&lt;/code&gt; 의 &lt;code&gt;deg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c70101d5df99f9e098c9e7c88a88dd4badd69367" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;HWB&lt;/a&gt; blackness of &lt;code&gt;$color&lt;/code&gt; as a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;HWB의&lt;/a&gt; 의 한밤중 &lt;code&gt;$color&lt;/code&gt; 사이의 숫자로 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bacb56dcfcd02485fbd390f20c91cf95cdda760" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;HWB&lt;/a&gt; whiteness of &lt;code&gt;$color&lt;/code&gt; as a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;HWB&lt;/a&gt; 백색도를 &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; 사이의 숫자로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f01cdcee0c0e2dd3375ed15b23a43fa6ef8910e" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Basic_properties&quot;&gt;arccosine&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt; in &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">수익 &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Basic_properties&quot;&gt;아크 코사인&lt;/a&gt; 의 &lt;code&gt;$number&lt;/code&gt; 있는 &lt;code&gt;deg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93cf297beeb3f84b4cae229e1ca66f125974efeb" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Basic_properties&quot;&gt;arcsine&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt; in &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">수익 &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Basic_properties&quot;&gt;아크 사인&lt;/a&gt; 의 &lt;code&gt;$number&lt;/code&gt; 있는 &lt;code&gt;deg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a91ea40690f109e18f38fc8f66e6d95c3627242d" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Basic_properties&quot;&gt;arctangent&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt; in &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">수익 &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Basic_properties&quot;&gt;아크 탄젠트&lt;/a&gt; 의 &lt;code&gt;$number&lt;/code&gt; 있는 &lt;code&gt;deg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed6c6850ab46fba9e8b74a80ec7c6335232e0bd1" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;logarithm&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt; with respect to &lt;code&gt;$base&lt;/code&gt;. If &lt;code&gt;$base&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the &lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_logarithm&quot;&gt;natural log&lt;/a&gt; is calculated.</source>
          <target state="translated">&lt;code&gt;$base&lt;/code&gt; 대한 &lt;code&gt;$number&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;로그&lt;/a&gt; 를 반환합니다 . 경우 &lt;code&gt;$base&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Natural_logarithm&quot;&gt;자연 로그가&lt;/a&gt; 계산된다.</target>
        </trans-unit>
        <trans-unit id="6262ac1c1d312314eb42212de183e8ae6b51a80c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Square_root&quot;&gt;square root&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Square_root&quot;&gt;제곱근&lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c2a7865ad59bcc46083a11d427a7148df32a1ff2" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_functions#Right-angled_triangle_definitions&quot;&gt;cosine&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_functions#Right-angled_triangle_definitions&quot;&gt;코사인&lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5f2398f9908d92e8a4027a8ceb29865872bf251" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_functions#Right-angled_triangle_definitions&quot;&gt;sine&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_functions#Right-angled_triangle_definitions&quot;&gt;사인&lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f5b40a38c3b8c0c8a07cedae85b79d928e58c774" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_functions#Right-angled_triangle_definitions&quot;&gt;tangent&lt;/a&gt; of &lt;code&gt;$number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Trigonometric_functions#Right-angled_triangle_definitions&quot;&gt;탄젠트&lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e54230321a0a2c8b8d60eef72dfa778df95011c8" translate="yes" xml:space="preserve">
          <source>Returns the HSL lightness of &lt;code&gt;$color&lt;/code&gt; as a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 HSL 밝기를 &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; 사이의 숫자로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="440282d3eb2159266a78c63eba26932b43e9fe9b" translate="yes" xml:space="preserve">
          <source>Returns the HSL saturation of &lt;code&gt;$color&lt;/code&gt; as a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 HSL 채도를 &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; 사이의 숫자로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="351daf3fdcec5b30d7b691b8d6ce6d28025f7a0d" translate="yes" xml:space="preserve">
          <source>Returns the RGB&lt;a href=&quot;https://en.wikipedia.org/wiki/Complementary_colors&quot;&gt;complement&lt;/a&gt; of &lt;code&gt;$color&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 RGB &lt;a href=&quot;https://en.wikipedia.org/wiki/Complementary_colors&quot;&gt;보완&lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="92873924a9d3752bf60b47c8caa32746f6f19e6a" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of a number.</source>
          <target state="translated">숫자의 절대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="956a5fd04c6f7591ec3594c61af0bdc05c2a2649" translate="yes" xml:space="preserve">
          <source>Returns the alpha channel of &lt;code&gt;$color&lt;/code&gt; as a number between 0 and 1.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 알파 채널을 0과 1 사이의 숫자로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4ce4198b9b1a07a40932a8b70d57cf084905cd80" translate="yes" xml:space="preserve">
          <source>Returns the alpha channel of the color as a number from 0 to 1.</source>
          <target state="translated">색상의 알파 채널을 0에서 1 사이의 숫자로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f46b179b300313527135804bce4ea7f6a9606098" translate="yes" xml:space="preserve">
          <source>Returns the alpha component (opacity) of a color. This is 1 unless otherwise specified.</source>
          <target state="translated">색상의 알파 성분 (불투명도)을 반환합니다. 달리 지정하지 않는 한 1입니다.</target>
        </trans-unit>
        <trans-unit id="c6b9b75b9e0756005c7ef91bf83d5c4cef80546d" translate="yes" xml:space="preserve">
          <source>Returns the blue channel of &lt;code&gt;$color&lt;/code&gt; as a number between 0 and 255.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 파란색 채널을 0에서 255 사이의 숫자로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="01c52e317dd7839c6bbed0b61dbb192bc0073172" translate="yes" xml:space="preserve">
          <source>Returns the blue channel of the color as an integer from 0 to 255.</source>
          <target state="translated">색상의 파란색 채널을 0에서 255 사이의 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12c86362af22b819d23c565553dc7874f1a4f890" translate="yes" xml:space="preserve">
          <source>Returns the complement of a color. This is identical to &lt;code&gt;adjust-hue(color, 180deg)&lt;/code&gt;.</source>
          <target state="translated">색의 보수를 돌려줍니다. 이것은 &lt;code&gt;adjust-hue(color, 180deg)&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="abba6e7eda85ec1fe3c99331052256f271640d4b" translate="yes" xml:space="preserve">
          <source>Returns the contents of the string. If the string contains escapes, those escapes are included literally if it&amp;rsquo;s &lt;a href=&quot;values/strings#unquoted&quot;&gt;unquoted&lt;/a&gt;, while the values of the escapes are included if it&amp;rsquo;s &lt;a href=&quot;values/strings#quoted&quot;&gt;quoted&lt;/a&gt;.</source>
          <target state="translated">문자열의 내용을 반환합니다. 문자열에 이스케이프가 포함 된 경우 해당 이스케이프는 &lt;a href=&quot;values/strings#unquoted&quot;&gt;인용되지 않은&lt;/a&gt; 경우 문자 그대로 포함 되고, &lt;a href=&quot;values/strings#quoted&quot;&gt;인용&lt;/a&gt; 된 경우 이스케이프 값이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="43ab8abdd40ea0b2633b9ceaea3dfd1b3a66a221" translate="yes" xml:space="preserve">
          <source>Returns the element at the given (0-based) index in the list.</source>
          <target state="translated">목록에서 주어진 (0부터 시작하는) 인덱스에있는 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a12aa5b6c1355eecf90b931c05fa6d696da596ce" translate="yes" xml:space="preserve">
          <source>Returns the element of &lt;code&gt;$list&lt;/code&gt; at &lt;a href=&quot;../values/lists#indexes&quot;&gt;index&lt;/a&gt;&lt;code&gt;$n&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../values/lists#indexes&quot;&gt;인덱스 &lt;/a&gt; &lt;code&gt;$n&lt;/code&gt; 에서 &lt;code&gt;$list&lt;/code&gt; 의 요소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c6084dcf14c02906372d609bce7a8bdb6cad0766" translate="yes" xml:space="preserve">
          <source>Returns the first &lt;a href=&quot;../values/strings#string-indexes&quot;&gt;index&lt;/a&gt; of &lt;code&gt;$substring&lt;/code&gt; in &lt;code&gt;$string&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;$string&lt;/code&gt; doesn&amp;rsquo;t contain &lt;code&gt;$substring&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$string&lt;/code&gt; 에서 &lt;code&gt;$substring&lt;/code&gt; 의 첫 번째 &lt;a href=&quot;../values/strings#string-indexes&quot;&gt;인덱스&lt;/a&gt; 를 반환 하거나 &lt;code&gt;$string&lt;/code&gt; &lt;code&gt;$substring&lt;/code&gt; 포함되지 않은 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b934a9f264610fff88b26d4c9b93d2188230bcee" translate="yes" xml:space="preserve">
          <source>Returns the green channel of &lt;code&gt;$color&lt;/code&gt; as a number between 0 and 255.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 녹색 채널을 0에서 255 사이의 숫자로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b53925e9fbb42def142fe0330b3f102d4ea3eadc" translate="yes" xml:space="preserve">
          <source>Returns the green channel of the color as an integer from 0 to 255.</source>
          <target state="translated">색상의 녹색 채널을 0에서 255 사이의 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="637627cc357ce99db5f9d4f43522fea396a41893" translate="yes" xml:space="preserve">
          <source>Returns the highest of one or more numbers.</source>
          <target state="translated">하나 이상의 숫자 중 가장 높은 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b714880704f4221e7c84d524db3b93d8c1914511" translate="yes" xml:space="preserve">
          <source>Returns the hue component of a color. See &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;the CSS3 HSL specification&lt;/a&gt;. Calculated from RGB where necessary via &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;this algorithm&lt;/a&gt;.</source>
          <target state="translated">색상의 색조 구성 요소를 반환합니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;CSS3 HSL 사양을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;이 알고리즘을&lt;/a&gt; 통해 필요한 경우 RGB에서 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="0c6f24c55d46fbda2dbcac4c7fb4c63b6f2a96d4" translate="yes" xml:space="preserve">
          <source>Returns the hue of &lt;code&gt;$color&lt;/code&gt; as a number between &lt;code&gt;0deg&lt;/code&gt; and &lt;code&gt;360deg&lt;/code&gt;.</source>
          <target state="translated">반환의 색조 &lt;code&gt;$color&lt;/code&gt; 사이의 숫자로 &lt;code&gt;0deg&lt;/code&gt; 와 &lt;code&gt;360deg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a86d40dc31663716b8dd230ca848ea8debb7627" translate="yes" xml:space="preserve">
          <source>Returns the index of the first occurrence of &lt;code&gt;$substring&lt;/code&gt; in &lt;code&gt;$string&lt;/code&gt;. If there is no such occurrence, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$string&lt;/code&gt; 에서 $ &lt;code&gt;$substring&lt;/code&gt; 이 처음 나타나는 색인을 리턴합니다 . 그러한 발생이 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b0f1c6f93d5d7d41e6d57ca82b7380bcf1c5f875" translate="yes" xml:space="preserve">
          <source>Returns the inverse (negative) of a color. The red, green, and blue values are inverted, while the opacity is left alone.</source>
          <target state="translated">색상의 역수 (음수)를 반환합니다. 빨강, 녹색 및 파랑 값은 반전되고 불투명도는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bd690716c4a4140be5acd243c710dcc4bb56637a" translate="yes" xml:space="preserve">
          <source>Returns the inverse or &lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_(photography)&quot;&gt;negative&lt;/a&gt; of &lt;code&gt;$color&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 역 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_(photography)&quot;&gt;음수&lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ff6a7dd87898c815b9e29f8214afef311ee2101b" translate="yes" xml:space="preserve">
          <source>Returns the key in the key/value pair at the given (0-based) index in the map.</source>
          <target state="translated">맵의 지정된 (0 기반) 인덱스에서 키 / 값 쌍의 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9169bbcb044591bf447c18062ef83cbf3620a1f" translate="yes" xml:space="preserve">
          <source>Returns the keywords passed to a mixin or function that takes &lt;a href=&quot;../at-rules/mixin#taking-arbitrary-arguments&quot;&gt;arbitrary arguments&lt;/a&gt;. The &lt;code&gt;$args&lt;/code&gt; argument must be an &lt;a href=&quot;../values/lists#argument-lists&quot;&gt;argument list&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../at-rules/mixin#taking-arbitrary-arguments&quot;&gt;임의의 인수&lt;/a&gt; 를받는 믹스 인 또는 함수에 전달 된 키워드를 반환합니다 . &lt;code&gt;$args&lt;/code&gt; 인수는해야합니다 &lt;a href=&quot;../values/lists#argument-lists&quot;&gt;인수 목록&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="733925db6e2ff87b4f177c099159873161eb9c27" translate="yes" xml:space="preserve">
          <source>Returns the length of &lt;code&gt;$list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$list&lt;/code&gt; 의 길이를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="866a84054beb8465535cfab0aaa1fcfc423fd75f" translate="yes" xml:space="preserve">
          <source>Returns the length of the &lt;em&gt;n&lt;/em&gt;-dimensional &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_vector&quot;&gt;vector&lt;/a&gt; that has components equal to each &lt;code&gt;$number&lt;/code&gt;. For example, for three numbers &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, and &lt;em&gt;c&lt;/em&gt;, this returns the square root of &lt;em&gt;a&amp;sup2; + b&amp;sup2; + c&amp;sup2;&lt;/em&gt;.</source>
          <target state="translated">각 &lt;code&gt;$number&lt;/code&gt; 동일한 구성 요소를 가진 &lt;em&gt;n&lt;/em&gt; 차원 &lt;a href=&quot;https://en.wikipedia.org/wiki/Euclidean_vector&quot;&gt;벡터&lt;/a&gt; 의 길이를 반환합니다 . 예를 들어, 세 개의 숫자 &lt;em&gt;a&lt;/em&gt; , &lt;em&gt;b&lt;/em&gt; , &lt;em&gt;c&lt;/em&gt; 의 경우 &lt;em&gt;a&amp;sup2; + b&amp;sup2; + c&amp;sup2;의&lt;/em&gt; 제곱근을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dda555fb62111de0a6fb209830d06dd85ab5571c" translate="yes" xml:space="preserve">
          <source>Returns the lightness component of a color. See &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;the CSS3 HSL specification&lt;/a&gt;. Calculated from RGB where necessary via &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;this algorithm&lt;/a&gt;.</source>
          <target state="translated">색상의 밝기 구성 요소를 반환합니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;CSS3 HSL 사양을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;이 알고리즘을&lt;/a&gt; 통해 필요한 경우 RGB에서 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ce506f9fdd9de2be99bce839024cd6d51ed9912" translate="yes" xml:space="preserve">
          <source>Returns the lowest of one or more numbers.</source>
          <target state="translated">하나 이상의 숫자 중 가장 낮은 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4c72c1f0ec9a89d8e1d0dd82e563fd74978d2df" translate="yes" xml:space="preserve">
          <source>Returns the map of named arguments passed to a function or mixin that takes a variable argument list. The argument names are strings, and they do not contain the leading &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">변수 인수 목록을 취하는 함수 또는 믹스 인에 전달 된 명명 된 인수의 맵을 리턴합니다. 인수 이름은 문자열이며 앞에 &lt;code&gt;$&lt;/code&gt; 가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f9042791358dd3eff5509186d46759b1f27e9a95" translate="yes" xml:space="preserve">
          <source>Returns the name of the separator used by &lt;code&gt;$list&lt;/code&gt;, either &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;comma&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$list&lt;/code&gt; 에서 사용하는 구분 기호의 이름 ( &lt;code&gt;space&lt;/code&gt; 또는 &lt;code&gt;comma&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d3ba9d6f63d0849882d5f1a33c39e21b9152e562" translate="yes" xml:space="preserve">
          <source>Returns the number of characters in &lt;code&gt;$string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$string&lt;/code&gt; 의 문자 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e9d66a090772cb1ac29a4a909fc75131e66ec53a" translate="yes" xml:space="preserve">
          <source>Returns the number of characters in a string.</source>
          <target state="translated">문자열의 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc72d5b2c1136fe75f094ce06d69250ac6ba9b2b" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the list.</source>
          <target state="translated">목록의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="79d40f0dec271e7c8bdd2623e057c540e17422af" translate="yes" xml:space="preserve">
          <source>Returns the number of key/value pairs in the map.</source>
          <target state="translated">맵에있는 키 / 값 쌍의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="51adfc85d1372e7351711e3637b7302b4685ad67" translate="yes" xml:space="preserve">
          <source>Returns the position of a value within a list. If the value isn't found, returns &lt;code&gt;null&lt;/code&gt; instead.</source>
          <target state="translated">목록 내에서 값의 위치를 ​​반환합니다. 값을 찾을 수 없으면 대신 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c3a7650066d93652567ae1b3ba371000626bd904" translate="yes" xml:space="preserve">
          <source>Returns the red channel of &lt;code&gt;$color&lt;/code&gt; as a number between 0 and 255.</source>
          <target state="translated">&lt;code&gt;$color&lt;/code&gt; 의 빨간색 채널을 0에서 255 사이의 숫자로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="05824c8214f50acefd75c7369451c94d4559c1e4" translate="yes" xml:space="preserve">
          <source>Returns the red channel of the color as an integer from 0 to 255.</source>
          <target state="translated">색상의 빨간색 채널을 0에서 255 사이의 정수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6cdad8aaddc6f132e2bab59fdb694bb44740b3e" translate="yes" xml:space="preserve">
          <source>Returns the saturation component of a color. See &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;the CSS3 HSL specification&lt;/a&gt;. Calculated from RGB where necessary via &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;this algorithm&lt;/a&gt;.</source>
          <target state="translated">색상의 채도 구성 요소를 반환합니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;CSS3 HSL 사양을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;http://en.wikipedia.org/wiki/HSL_and_HSV#Conversion_from_RGB_to_HSL_or_HSV&quot;&gt;이 알고리즘을&lt;/a&gt; 통해 필요한 경우 RGB에서 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f998c8bd6e3f467c292b5f896cdc1bfbad1e118" translate="yes" xml:space="preserve">
          <source>Returns the separator of a list. If the list doesn't have a separator due to having fewer than two elements, returns &lt;code&gt;space&lt;/code&gt;.</source>
          <target state="translated">리스트의 분리자를 돌려줍니다. 두 개 미만의 요소로 인해 목록에 구분 기호가없는 경우 &lt;code&gt;space&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a65e32f8c02df40961f91c148db4db09835cb3d" translate="yes" xml:space="preserve">
          <source>Returns the slice of &lt;code&gt;$string&lt;/code&gt; starting at &lt;a href=&quot;../values/strings#string-indexes&quot;&gt;index&lt;/a&gt;&lt;code&gt;$start-at&lt;/code&gt; and ending at index &lt;code&gt;$end-at&lt;/code&gt; (both inclusive).</source>
          <target state="translated">&lt;code&gt;$start-at&lt;/code&gt; at &lt;a href=&quot;../values/strings#string-indexes&quot;&gt;인덱스&lt;/a&gt; 에서 시작하여 &lt;code&gt;$end-at&lt;/code&gt; 인덱스 (둘 다 포함) 에서 끝나는 &lt;code&gt;$string&lt;/code&gt; 조각을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6d8ce8ca6fbc77475cd2ce1a8bc0f94445877b40" translate="yes" xml:space="preserve">
          <source>Returns the type of &lt;code&gt;$value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$value&lt;/code&gt; 유형을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e4dd2b713f992a8bd714d2b748a64683b9489dc1" translate="yes" xml:space="preserve">
          <source>Returns the type of a value.</source>
          <target state="translated">값의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="52c8bae0dde8ae72c66d9780a9be60588342bc2f" translate="yes" xml:space="preserve">
          <source>Returns the unit(s) associated with a number. Complex units are sorted in alphabetical order by numerator and denominator.</source>
          <target state="translated">숫자와 관련된 단위를 반환합니다. 복소수는 분자와 분모로 알파벳 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="7342bc67328744667620916e07e0fe0d8094ce2a" translate="yes" xml:space="preserve">
          <source>Returns the units of the number as a string. Complex units are returned in the same format that &lt;a href=&quot;#new-types-number-value-unit-39-39&quot;&gt;the constructor&lt;/a&gt; accepts them.</source>
          <target state="translated">숫자 단위를 문자열로 반환합니다. 복잡한 단위는 &lt;a href=&quot;#new-types-number-value-unit-39-39&quot;&gt;생성자가&lt;/a&gt; 허용 하는 것과 동일한 형식으로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="01c83de52a2dca912d609d97b917f8b85561d97e" translate="yes" xml:space="preserve">
          <source>Returns the value in a map associated with the given key. If the map doesn't have such a key, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">주어진 키와 관련된 맵의 값을 반환합니다. 지도에 그러한 키가 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b7dcd0fde1ea1271c2e4e394fc0e76520a8b73a1" translate="yes" xml:space="preserve">
          <source>Returns the value in the key/value pair at the given (0-based) index in the map.</source>
          <target state="translated">맵의 지정된 (0 기반) 인덱스에서 키 / 값 쌍의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ba96e8a2cacf3edcfdf78e551c810331039247f" translate="yes" xml:space="preserve">
          <source>Returns the value in the targeted map associated with the last key in &lt;code&gt;$keys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$keys&lt;/code&gt; 의 마지막 키와 연결된 대상 맵의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b99b1d620bd47818bd025c5f2aec49ec31e3d15e" translate="yes" xml:space="preserve">
          <source>Returns the value of the number, ignoring units.</source>
          <target state="translated">단위를 무시하고 숫자 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="839fe7fa12d4083ad1ec2e51a91dcfad578997d6" translate="yes" xml:space="preserve">
          <source>Returns true if the targeted map contains a value associated with the last key in &lt;code&gt;$keys&lt;/code&gt;.</source>
          <target state="translated">대상지도에 &lt;code&gt;$keys&lt;/code&gt; 의 마지막 키와 관련된 값이 포함되어 있으면 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fe7cddced15d06b3d5c223fb2136c8fade2dd322" translate="yes" xml:space="preserve">
          <source>Returns whether &lt;code&gt;$list&lt;/code&gt; has square brackets.</source>
          <target state="translated">&lt;code&gt;$list&lt;/code&gt; 에 대괄호가 있는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7d29acfc6bc8d53a72d17f8bcfcd995c9a16cd9b" translate="yes" xml:space="preserve">
          <source>Returns whether &lt;code&gt;$number1&lt;/code&gt; and &lt;code&gt;$number2&lt;/code&gt; have compatible units.</source>
          <target state="translated">&lt;code&gt;$number1&lt;/code&gt; 과 &lt;code&gt;$number2&lt;/code&gt; 에 호환되는 단위가 있는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="16105bd9d6359d5c603aca235a69b56edbc68880" translate="yes" xml:space="preserve">
          <source>Returns whether &lt;code&gt;$number&lt;/code&gt; has no units.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 에 단위가 없는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6a53ebaa01a91a951006e99359c0e5fcf7bd6b1c" translate="yes" xml:space="preserve">
          <source>Returns whether &lt;code&gt;$super&lt;/code&gt; is a superselector of &lt;code&gt;$sub&lt;/code&gt;. This means that &lt;code&gt;$super&lt;/code&gt; matches all the elements that &lt;code&gt;$sub&lt;/code&gt; matches, as well as possibly additional elements. In general, simpler selectors tend to be superselectors of more complex oned.</source>
          <target state="translated">&lt;code&gt;$super&lt;/code&gt; 가 &lt;code&gt;$sub&lt;/code&gt; 의 수퍼 셀렉터 인지 여부를 리턴합니다 . 이는 &lt;code&gt;$super&lt;/code&gt; 가 &lt;code&gt;$sub&lt;/code&gt; 와 일치 하는 모든 요소 및 추가 요소 와 일치 함을 의미합니다 . 일반적으로 간단한 선택기는 더 복잡한 선택기 인 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5a461f81dc964c8ffe655fbe4cf442722eaefef" translate="yes" xml:space="preserve">
          <source>Returns whether a &lt;a href=&quot;../at-rules/mixin&quot;&gt;mixin&lt;/a&gt; named &lt;code&gt;$name&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;$name&lt;/code&gt; 이라는 &lt;a href=&quot;../at-rules/mixin&quot;&gt;믹스&lt;/a&gt; 인이 있는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b08538c9fc216ee1a181b365f5fae070a1be06c8" translate="yes" xml:space="preserve">
          <source>Returns whether a &lt;a href=&quot;../variables#scope&quot;&gt;global variable&lt;/a&gt; named &lt;code&gt;$name&lt;/code&gt; (without the &lt;code&gt;$&lt;/code&gt;) exists.</source>
          <target state="translated">&lt;code&gt;$name&lt;/code&gt; 이라는 &lt;a href=&quot;../variables#scope&quot;&gt;전역 변수&lt;/a&gt; ( &lt;code&gt;$&lt;/code&gt; 제외)가 있는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="002cc08698af3245841b56580f4802889b222e9b" translate="yes" xml:space="preserve">
          <source>Returns whether a feature exists in the current Sass runtime.</source>
          <target state="translated">현재 Sass 런타임에 기능이 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f392e55228a2fdd8a56fd4308ff7cf31d1eb488e" translate="yes" xml:space="preserve">
          <source>Returns whether a function named &lt;code&gt;$name&lt;/code&gt; is defined, either as a built-in function or a user-defined function.</source>
          <target state="translated">&lt;code&gt;$name&lt;/code&gt; 이라는 함수 가 내장 함수 또는 사용자 정의 함수로 정의 되었는지 여부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9e1c1081c33d4ac1921a8fcefbe4187e66d4fcc4" translate="yes" xml:space="preserve">
          <source>Returns whether a list uses square brackets.</source>
          <target state="translated">리스트가 대괄호를 사용하는지 여부를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b00d68d5169484005d39afdd83116fbb95e55a30" translate="yes" xml:space="preserve">
          <source>Returns whether a map has a value associated with a given key.</source>
          <target state="translated">지도에 지정된 키와 관련된 값이 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ede60bc210641adae890fb0f1eb3bd4419854021" translate="yes" xml:space="preserve">
          <source>Returns whether a number has units.</source>
          <target state="translated">숫자에 단위가 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a00004e2b1935c2c2bb553d7222c71479652921" translate="yes" xml:space="preserve">
          <source>Returns whether a variable named &lt;code&gt;$name&lt;/code&gt; (without the &lt;code&gt;$&lt;/code&gt;) exists in the current &lt;a href=&quot;../variables#scope&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$name&lt;/code&gt; 이라는 변수 ( &lt;code&gt;$&lt;/code&gt; 없음 )가 현재 &lt;a href=&quot;../variables#scope&quot;&gt;범위에&lt;/a&gt; 있는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e7d91f0199ba497c7b277def80c45a510f116eb5" translate="yes" xml:space="preserve">
          <source>Returns whether the current Sass implementation supports &lt;code&gt;$feature&lt;/code&gt;.</source>
          <target state="translated">현재 Sass 구현이 &lt;code&gt;$feature&lt;/code&gt; 지원하는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6f11efcfe4fdc93eb0599f90fd09d155adadc82d" translate="yes" xml:space="preserve">
          <source>Returns whether the current mixin was passed a &lt;a href=&quot;../at-rules/mixin#content-blocks&quot;&gt;&lt;code&gt;@content&lt;/code&gt; block&lt;/a&gt;.</source>
          <target state="translated">현재 믹스 인이 &lt;a href=&quot;../at-rules/mixin#content-blocks&quot;&gt; &lt;code&gt;@content&lt;/code&gt; 블록&lt;/a&gt; 을 통과했는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab4234ef8368f2204ca85546406db77877de7567" translate="yes" xml:space="preserve">
          <source>Returns whether the selector &lt;code&gt;$super&lt;/code&gt; matches all the elements that the selector &lt;code&gt;$sub&lt;/code&gt; matches.</source>
          <target state="translated">&lt;code&gt;$super&lt;/code&gt; 선택기가 &lt;code&gt;$sub&lt;/code&gt; 선택자가 일치하는 모든 요소와 일치 하는지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="513e5d1980899cec88f10b5fa101612d18128fb5" translate="yes" xml:space="preserve">
          <source>Returns whether two numbers can added, subtracted, or compared.</source>
          <target state="translated">두 숫자를 더하거나 빼거나 비교할 수 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7749fcf802c472b6c2f5bd0556805e456ffd5674" translate="yes" xml:space="preserve">
          <source>Returns:</source>
          <target state="translated">Returns:</target>
        </trans-unit>
        <trans-unit id="468c97f783f63508d1c9aa234bf9b14d8b85daa7" translate="yes" xml:space="preserve">
          <source>Rounds &lt;code&gt;$number&lt;/code&gt; down to the next lowest whole number.</source>
          <target state="translated">라운드 &lt;code&gt;$number&lt;/code&gt; 다음으로 낮은 정수에 이르기까지.</target>
        </trans-unit>
        <trans-unit id="b3b88df508b4bd76b987a32f554d7fe62a550de7" translate="yes" xml:space="preserve">
          <source>Rounds &lt;code&gt;$number&lt;/code&gt; to the nearest whole number.</source>
          <target state="translated">반올림 &lt;code&gt;$number&lt;/code&gt; 가장 가까운 정수로합니다.</target>
        </trans-unit>
        <trans-unit id="27f2ccfb483d701c47177c4c8dc3ce3be55a77f8" translate="yes" xml:space="preserve">
          <source>Rounds &lt;code&gt;$number&lt;/code&gt; up to the next highest whole number.</source>
          <target state="translated">&lt;code&gt;$number&lt;/code&gt; 를 다음으로 높은 정수로 반올림 합니다.</target>
        </trans-unit>
        <trans-unit id="ceac41cf1a3ce44c31141786b8378b18726d6760" translate="yes" xml:space="preserve">
          <source>Rounds a number down to the previous whole number.</source>
          <target state="translated">숫자를 이전 정수로 내림합니다.</target>
        </trans-unit>
        <trans-unit id="76c0fc06f4f913113e6238495ff0b6e9310e1e71" translate="yes" xml:space="preserve">
          <source>Rounds a number to the nearest whole number.</source>
          <target state="translated">가장 가까운 정수로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="ec103be4593a89ce5a25e929fcd41f443602c66e" translate="yes" xml:space="preserve">
          <source>Rounds a number up to the next whole number.</source>
          <target state="translated">숫자를 다음 정수로 올림합니다.</target>
        </trans-unit>
        <trans-unit id="d109063cf01f9c37fecefd29123037ad01772828" translate="yes" xml:space="preserve">
          <source>Ruby Sass</source>
          <target state="translated">Ruby Sass</target>
        </trans-unit>
        <trans-unit id="f277e1a9f789f12942dd174d6519f1cab0e2c4de" translate="yes" xml:space="preserve">
          <source>Ruby Sass Command-Line Interface</source>
          <target state="translated">Ruby Sass 명령 줄 인터페이스</target>
        </trans-unit>
        <trans-unit id="0e5024456419e499b005f0de7645e6e670bd9ae6" translate="yes" xml:space="preserve">
          <source>SCSS</source>
          <target state="translated">SCSS</target>
        </trans-unit>
        <trans-unit id="abfed73ccc2166edcf9c63923b94efcd1a7b8d04" translate="yes" xml:space="preserve">
          <source>SCSS looks like this:</source>
          <target state="translated">SCSS는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6eeeb3abd2a7bc179a6b6d5c56488b5f8c903a7" translate="yes" xml:space="preserve">
          <source>Sass</source>
          <target state="translated">Sass</target>
        </trans-unit>
        <trans-unit id="10f303be29e42d399e1affaea1a02b6e87b23864" translate="yes" xml:space="preserve">
          <source>Sass (Syntactically Awesome StyleSheets)</source>
          <target state="translated">Sass (구문 적으로 멋진 스타일 시트)</target>
        </trans-unit>
        <trans-unit id="341d3556acd434f0488bd651ce9f2aa58ae8059e" translate="yes" xml:space="preserve">
          <source>Sass Functions</source>
          <target state="translated">사스 함수</target>
        </trans-unit>
        <trans-unit id="3b3252d26bb63e6d23bdbd217a16bb9101e80665" translate="yes" xml:space="preserve">
          <source>Sass allows &lt;em&gt;any text&lt;/em&gt; in these function calls, including nested parentheses. Nothing is interpreted as a SassScript expression, with the exception that &lt;a href=&quot;../interpolation&quot;&gt;interpolation&lt;/a&gt; can be used to inject dynamic values.</source>
          <target state="translated">Sass는 중첩 된 괄호를 포함하여 이러한 함수 호출의 &lt;em&gt;모든 텍스트&lt;/em&gt; 를 허용 &lt;em&gt;합니다&lt;/em&gt; . &lt;a href=&quot;../interpolation&quot;&gt;보간&lt;/a&gt; 을 사용하여 동적 값을 주입 할 수 있다는 점을 제외하고는 SassScript 표현식으로 해석되는 것은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="12104abfe0a714244e52948eb45c8539279c98f2" translate="yes" xml:space="preserve">
          <source>Sass allows CSS rules to be nested within one another. The inner rule then only applies within the outer rule's selector. For example:</source>
          <target state="translated">Sass를 사용하면 CSS 규칙을 서로 중첩시킬 수 있습니다. 그러면 내부 규칙은 외부 규칙의 선택기에만 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c4356380b68b4f78ea663bc4f71a4efe353604b" translate="yes" xml:space="preserve">
          <source>Sass allows you to choose between four different output styles by setting the &lt;a href=&quot;#style-option&quot;&gt;&lt;code&gt;:style&lt;/code&gt; option&lt;/a&gt; or using the &lt;code&gt;--style&lt;/code&gt; command-line flag.</source>
          <target state="translated">Sass에서는 &lt;a href=&quot;#style-option&quot;&gt; &lt;code&gt;:style&lt;/code&gt; 옵션&lt;/a&gt; 을 설정 하거나 &lt;code&gt;--style&lt;/code&gt; 명령 줄 플래그를 사용하여 네 가지 출력 스타일 중에서 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bea2380d4aa23d0747a343c92acdacbbb84e0d8d" translate="yes" xml:space="preserve">
          <source>Sass also has some special behavior for &lt;a href=&quot;at-rules/css&quot;&gt;plain CSS at-rules&lt;/a&gt;: they can contain &lt;a href=&quot;interpolation&quot;&gt;interpolation&lt;/a&gt;, and they can be nested in style rules. Some of them, like &lt;a href=&quot;at-rules/css#media&quot;&gt;&lt;code&gt;@media&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;at-rules/css#supports&quot;&gt;&lt;code&gt;@supports&lt;/code&gt;&lt;/a&gt;, also allow SassScript to be used directly in the rule itself without interpolation.</source>
          <target state="translated">Sass는 또한 &lt;a href=&quot;at-rules/css&quot;&gt;일반 CSS at-rule에&lt;/a&gt; 대한 몇 가지 특별한 동작을 가지고 있습니다. &lt;a href=&quot;interpolation&quot;&gt;보간&lt;/a&gt; 을 포함 할 수 있으며 스타일 규칙에 중첩 될 수 있습니다. 그들 중 일부는, 같은 &lt;a href=&quot;at-rules/css#media&quot;&gt; &lt;code&gt;@media&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;at-rules/css#supports&quot;&gt; &lt;code&gt;@supports&lt;/code&gt; &lt;/a&gt; , 또한 SassScript 보간없이 규칙 자체에서 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fcecb417df186591f20e0217f21fc1287957cb4" translate="yes" xml:space="preserve">
          <source>Sass caches parsed documents so that they can be reused without parsing them again unless they have changed. By default, Sass will write these cache files to a location on the filesystem indicated by &lt;a href=&quot;#cache_location-option&quot;&gt;&lt;code&gt;:cache_location&lt;/code&gt;&lt;/a&gt;. If you cannot write to the filesystem or need to share cache across ruby processes or machines, then you can define your own cache store and set the&lt;a href=&quot;#cache_store-option&quot;&gt;&lt;code&gt;:cache_store&lt;/code&gt; option&lt;/a&gt;. For details on creating your own cache store, please see the &lt;a href=&quot;http://sass-lang.com/documentation/Sass/CacheStores/Base.html&quot;&gt;source documentation&lt;/a&gt;.</source>
          <target state="translated">Sass는 구문 분석 된 문서를 캐시하여 변경하지 않는 한 다시 구문 분석하지 않고 재사용 할 수 있도록합니다. 기본적으로 Sass는 이러한 캐시 파일을 &lt;a href=&quot;#cache_location-option&quot;&gt; &lt;code&gt;:cache_location&lt;/code&gt; 으로&lt;/a&gt; 표시된 파일 시스템의 위치에 씁니다 . 파일 시스템에 쓸 수 없거나 루비 프로세스 또는 머신에서 캐시를 공유해야하는 경우 고유 한 캐시 저장소를 정의하고 &lt;a href=&quot;#cache_store-option&quot;&gt; &lt;code&gt;:cache_store&lt;/code&gt; 옵션을&lt;/a&gt; 설정할 수 있습니다 . 자체 캐시 저장소 작성에 대한 자세한 내용은 &lt;a href=&quot;http://sass-lang.com/documentation/Sass/CacheStores/Base.html&quot;&gt;소스 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfd8d49434b5dc18b7647e61d36eb01f1ddf972c" translate="yes" xml:space="preserve">
          <source>Sass can be used in three ways: as a command-line tool, as a standalone Ruby module, and as a plugin for any Rack-enabled framework, including Ruby on Rails and Merb. The first step for all of these is to install the Sass gem:</source>
          <target state="translated">Sass는 명령 줄 도구, 독립형 Ruby 모듈 및 Ruby on Rails 및 Merb를 포함한 모든 랙 지원 프레임 워크의 플러그인으로 세 가지 방식으로 사용할 수 있습니다. 이 모든 것의 첫 번째 단계는 Sass gem을 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2d315da5236e9452c305d3574bf77c578942e42" translate="yes" xml:space="preserve">
          <source>Sass defines syntax for a number of operations:</source>
          <target state="translated">Sass는 여러 작업에 대한 구문을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="92dff0f242d6fcdad22301185abdc13bbad14028" translate="yes" xml:space="preserve">
          <source>Sass doesn&amp;rsquo;t distinguish between whole numbers and decimals, so for example &lt;code&gt;5
/ 2&lt;/code&gt; returns &lt;code&gt;2.5&lt;/code&gt; rather than &lt;code&gt;2&lt;/code&gt;. This is the same behavior as JavaScript, but different than many other programming languages.</source>
          <target state="translated">말대꾸 그래서 예를 들어, 정수 및 소수 구분하지 않습니다 &lt;code&gt;5 / 2&lt;/code&gt; 수익률 &lt;code&gt;2.5&lt;/code&gt; 보다는 &lt;code&gt;2&lt;/code&gt; . 이것은 JavaScript와 동일한 동작이지만 다른 많은 프로그래밍 언어와는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="337bc0dd2cba2d8a74fcc3d911ca1ad24d782a82" translate="yes" xml:space="preserve">
          <source>Sass extends CSS's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@import&quot;&gt;&lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; with the ability to import Sass and CSS stylesheets, providing access to &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt;, &lt;a href=&quot;function&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../variables&quot;&gt;variables&lt;/a&gt; and combining multiple stylesheets' CSS together. Unlike plain CSS imports, which require the browser to make multiple HTTP requests as it renders your page, Sass imports are handled entirely during compilation.</source>
          <target state="translated">Sass는 CSS의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; 규칙&lt;/a&gt; 을 Sass 및 CSS 스타일 시트를 가져 오는 기능으로 확장 하여 &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt; , &lt;a href=&quot;function&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../variables&quot;&gt;변수에&lt;/a&gt; 대한 액세스를 제공 하고 여러 스타일 시트의 CSS를 함께 결합합니다. 브라우저가 페이지를 렌더링 할 때 여러 HTTP 요청을해야하는 일반 CSS 가져 오기와 달리 Sass 가져 오기는 컴파일 중에 전적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9785c4245593a2393e5e7772e6bebb5a19179df5" translate="yes" xml:space="preserve">
          <source>Sass extends the CSS &lt;code&gt;@import&lt;/code&gt; rule to allow it to import SCSS and Sass files. All imported SCSS and Sass files will be merged together into a single CSS output file. In addition, any variables or &lt;a href=&quot;#mixins&quot;&gt;mixins&lt;/a&gt; defined in imported files can be used in the main file.</source>
          <target state="translated">Sass는 CSS &lt;code&gt;@import&lt;/code&gt; 규칙을 확장하여 SCSS 및 Sass 파일을 가져올 수 있습니다. 가져온 모든 SCSS 및 Sass 파일은 단일 CSS 출력 파일로 병합됩니다. 또한 가져온 파일에 정의 된 모든 변수 또는 &lt;a href=&quot;#mixins&quot;&gt;믹스 인을&lt;/a&gt; 기본 파일에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f61b7c2b219adb088c062ff92b89a8fd236d7b6" translate="yes" xml:space="preserve">
          <source>Sass functions can also be called using explicit keyword arguments. The above example can also be written as:</source>
          <target state="translated">명시 적 키워드 인수를 사용하여 Sass 함수를 호출 할 수도 있습니다. 위의 예제는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff550501230dff58e1d23dbb2ecaaabad4f2a87d" translate="yes" xml:space="preserve">
          <source>Sass has a number of &lt;a href=&quot;../modules/string&quot;&gt;string functions&lt;/a&gt; that take or return numbers, called &lt;em&gt;indexes&lt;/em&gt;, that refer to the characters in a string. The index 1 indicates the first character of the string. Note that this is different than many programming languages where indexes start at 0! Sass also makes it easy to refer to the end of a string. The index -1 refers to the last character in a string, -2 refers to the second-to-last, and so on.</source>
          <target state="translated">Sass에는 &lt;a href=&quot;../modules/string&quot;&gt;문자열&lt;/a&gt; 의 문자를 참조하는 &lt;em&gt;indexes&lt;/em&gt; 라는 숫자를 가져 오거나 반환 하는 여러 문자열 함수 가 있습니다 . 인덱스 1은 문자열의 첫 번째 문자를 나타냅니다. 이것은 인덱스가 0에서 시작하는 많은 프로그래밍 언어와 다릅니다! Sass를 사용하면 문자열의 끝을 쉽게 참조 할 수 있습니다. 인덱스 -1은 문자열의 마지막 문자를 나타내고 -2는 마지막에서 두 번째를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f30d9a097206202b2e27bc2923ae98f1086693c" translate="yes" xml:space="preserve">
          <source>Sass has a pretty standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages&quot;&gt;order of operations&lt;/a&gt;, from tightest to loosest:</source>
          <target state="translated">Sass는 가장 엄격한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Order_of_operations#Programming_languages&quot;&gt;것부터&lt;/a&gt; 가장 느슨한 것까지 매우 표준적인 작업 순서를 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11f0a2ddd6b73783822a7ce23cfd75f0585a6384" translate="yes" xml:space="preserve">
          <source>Sass has a special kind of selector known as a &amp;ldquo;placeholder&amp;rdquo;. It looks and acts a lot like a class selector, but it starts with a &lt;code&gt;%&lt;/code&gt; and it's not included in the CSS output. In fact, any complex selector (the ones between the commas) that even &lt;em&gt;contains&lt;/em&gt; a placeholder selector isn't included in the CSS, nor is any style rule whose selectors all contain placeholders,</source>
          <target state="translated">Sass에는 &quot;자리 표시 자&quot;라고하는 특별한 종류의 선택기가 있습니다. 클래스 선택자처럼 보이고 작동하지만 &lt;code&gt;%&lt;/code&gt; 로 시작 하며 CSS 출력에 포함되지 않습니다. 실제로 자리 표시 자 선택기를 &lt;em&gt;포함&lt;/em&gt; 하는 복잡한 선택기 (쉼표 사이의 선택자)는 CSS에 포함되지 않으며 선택기 모두에 자리 표시자를 포함하는 스타일 규칙도 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce2b28d788b61de8fde6c17d043022ab46d4d693" translate="yes" xml:space="preserve">
          <source>Sass has built-in support for color values. Just like CSS colors, they represent points in the &lt;a href=&quot;https://en.wikipedia.org/wiki/SRGB&quot;&gt;sRGB color space&lt;/a&gt;, although many Sass &lt;a href=&quot;../modules/color&quot;&gt;color functions&lt;/a&gt; operate using &lt;a href=&quot;https://en.wikipedia.org/wiki/HSL_and_HSV&quot;&gt;HSL coordinates&lt;/a&gt; (which are just another way of expressing sRGB colors). Sass colors can be written as hex codes (&lt;code&gt;#f2ece4&lt;/code&gt; or &lt;code&gt;#b37399aa&lt;/code&gt;), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords&quot;&gt;CSS color names&lt;/a&gt; (&lt;code&gt;midnightblue&lt;/code&gt;, &lt;code&gt;transparent&lt;/code&gt;), or the functions &lt;a href=&quot;../modules#rgb&quot;&gt;&lt;code&gt;rgb()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../modules#rgba&quot;&gt;&lt;code&gt;rgba()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../modules#hsl&quot;&gt;&lt;code&gt;hsl()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../modules#hsla&quot;&gt;&lt;code&gt;hsla()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Sass는 색상 값을 기본적으로 지원합니다. 많은 Sass &lt;a href=&quot;../modules/color&quot;&gt;색상 함수가 &lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/HSL_and_HSV&quot;&gt;HSL 좌표&lt;/a&gt; (sRGB 색상을 표현하는 또 다른 방법)를 사용하여 작동 하지만 CSS 색상과 마찬가지로 &lt;a href=&quot;https://en.wikipedia.org/wiki/SRGB&quot;&gt;sRGB 색상 공간의&lt;/a&gt; 포인트를 나타냅니다 . Sass 색상은 16 진수 코드 ( &lt;code&gt;#f2ece4&lt;/code&gt; 또는 &lt;code&gt;#b37399aa&lt;/code&gt; ), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords&quot;&gt;CSS 색상 이름&lt;/a&gt; ( &lt;code&gt;midnightblue&lt;/code&gt; , &lt;code&gt;transparent&lt;/code&gt; ) 또는 &lt;a href=&quot;../modules#rgb&quot;&gt; &lt;code&gt;rgb()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../modules#rgba&quot;&gt; &lt;code&gt;rgba()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../modules#hsl&quot;&gt; &lt;code&gt;hsl()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../modules#hsla&quot;&gt; &lt;code&gt;hsla()&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cc09a0fb175527dc21d3ed9c5a3f39cbe698f37" translate="yes" xml:space="preserve">
          <source>Sass has powerful &lt;a href=&quot;values/numbers#units&quot;&gt;unit arithmetic&lt;/a&gt; that you can use instead. For example, instead of writing &lt;code&gt;#{$width}px&lt;/code&gt;, write &lt;code&gt;$width * 1px&lt;/code&gt;&amp;mdash;or better yet, declare the &lt;code&gt;$width&lt;/code&gt; variable in terms of &lt;code&gt;px&lt;/code&gt; to begin with. That way if &lt;code&gt;$width&lt;/code&gt; already has units, you&amp;rsquo;ll get a nice error message instead of compiling bogus CSS.</source>
          <target state="translated">Sass에는 대신 사용할 수있는 강력한 &lt;a href=&quot;values/numbers#units&quot;&gt;단위 산술&lt;/a&gt; 이 있습니다. 예를 들어 &lt;code&gt;#{$width}px&lt;/code&gt; 를 쓰는 대신 &lt;code&gt;$width * 1px&lt;/code&gt; 쓰거나 더 좋은 방법은 &lt;code&gt;$width&lt;/code&gt; 변수를 &lt;code&gt;px&lt;/code&gt; 로 선언하여 시작하는 것입니다. 이렇게하면 &lt;code&gt;$width&lt;/code&gt; 이미 단위가있는 경우 가짜 CSS를 컴파일하는 대신 멋진 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b0401d0f31b23c64c98d17c0dd08346bbdbb842" translate="yes" xml:space="preserve">
          <source>Sass has powerful support for manipulating units based on how &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_of_measurement#Calculations_with_units_of_measurement&quot;&gt;real-world unit calculations&lt;/a&gt; work. When two numbers are multiplied, their units are multiplied as well. When one number is divided by another, the result takes its numerator units from the first number and its denominator units from the second. A number can have any number of units in the numerator and/or denominator.</source>
          <target state="translated">Sass는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_of_measurement#Calculations_with_units_of_measurement&quot;&gt;실제 단위 계산이&lt;/a&gt; 작동 하는 방식을 기반으로 단위를 조작하는 강력한 지원을 제공 합니다. 두 숫자를 곱하면 단위도 곱해집니다. 한 숫자를 다른 숫자로 나누면 결과는 첫 번째 숫자에서 분자 단위를 가져오고 두 번째 숫자에서 분모 단위를 가져옵니다. 숫자는 분자 및 / 또는 분모의 단위를 얼마든지 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfa9fc50eb1a1d181640003689cbe25d33fc0977" translate="yes" xml:space="preserve">
          <source>Sass importers are in charge of taking paths passed to &lt;code&gt;@import&lt;/code&gt; and finding the appropriate Sass code for those paths. By default, this code is loaded from the &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Importers/Filesystem.html&quot;&gt;filesystem&lt;/a&gt;, but importers could be added to load from a database, over HTTP, or use a different file naming scheme than what Sass expects.</source>
          <target state="translated">Sass 수입 업체는 &lt;code&gt;@import&lt;/code&gt; 로 전달 된 경로를 가져와 해당 경로에 적합한 Sass 코드를 찾는 작업 을 담당 합니다. 기본적으로이 코드는 &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Importers/Filesystem.html&quot;&gt;파일 시스템&lt;/a&gt; 에서로드 되지만 가져 오기 프로그램을 추가하여 데이터베이스를 통해로드하거나 HTTP를 통해 추가하거나 Sass가 예상하는 것과 다른 파일 이름 지정 체계를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c23b0c647f0aa1cdb3a101c61a06d56093b805e0" translate="yes" xml:space="preserve">
          <source>Sass imports have the same syntax as CSS imports, except that they allow multiple imports to be separated by commas rather than requiring each one to have its own &lt;code&gt;@import&lt;/code&gt;. Also, in the &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;indented syntax&lt;/a&gt;, imported URLs aren&amp;rsquo;t required to have quotes.</source>
          <target state="translated">Sass 가져 오기는 CSS 가져 오기와 동일한 구문을 갖지만 여러 가져 오기를 쉼표로 구분할 수 있다는 점을 제외하면 각각 고유 한 &lt;code&gt;@import&lt;/code&gt; 를 갖도록 요구하지 않습니다 . 또한 &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;들여 쓰기 구문&lt;/a&gt; 에서 가져온 URL에는 따옴표가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71828edc965d80bf34fc48b3e8c5143a963e50da" translate="yes" xml:space="preserve">
          <source>Sass is a stylesheet language that&amp;rsquo;s compiled to CSS. It allows you to use &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt;, &lt;a href=&quot;style-rules#nesting&quot;&gt;nested rules&lt;/a&gt;, &lt;a href=&quot;at-rules/mixin&quot;&gt;mixins&lt;/a&gt;, &lt;a href=&quot;modules&quot;&gt;functions&lt;/a&gt;, and more, all with a fully CSS-compatible syntax. Sass helps keep large stylesheets well-organized and makes it easy to share design within and across projects.</source>
          <target state="translated">Sass는 CSS로 컴파일 된 스타일 시트 언어입니다. 완전히 CSS 호환 구문으로 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; , &lt;a href=&quot;style-rules#nesting&quot;&gt;중첩 규칙&lt;/a&gt; , &lt;a href=&quot;at-rules/mixin&quot;&gt;믹스 인&lt;/a&gt; , &lt;a href=&quot;modules&quot;&gt;함수&lt;/a&gt; 등 을 사용할 수 있습니다 . Sass는 큰 스타일 시트를 잘 구성하고 프로젝트 내부와 프로젝트간에 디자인을 쉽게 공유 할 수 있도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="55fbe07c7def3c112a3dd15dcf43d50ee3a3c5a8" translate="yes" xml:space="preserve">
          <source>Sass is an extension of CSS that adds power and elegance to the basic language. It allows you to use &lt;a href=&quot;#variables_&quot;&gt;variables&lt;/a&gt;, &lt;a href=&quot;#nested_rules&quot;&gt;nested rules&lt;/a&gt;, &lt;a href=&quot;#mixins&quot;&gt;mixins&lt;/a&gt;, &lt;a href=&quot;#import&quot;&gt;inline imports&lt;/a&gt;, and more, all with a fully CSS-compatible syntax. Sass helps keep large stylesheets well-organized, and get small stylesheets up and running quickly, particularly with the help of &lt;a href=&quot;http://compass-style.org&quot;&gt;the Compass style library&lt;/a&gt;.</source>
          <target state="translated">Sass는 기본 언어에 힘과 우아함을 더하는 CSS의 확장입니다. 완전한 CSS 호환 구문 을 사용하여 &lt;a href=&quot;#variables_&quot;&gt;변수&lt;/a&gt; , &lt;a href=&quot;#nested_rules&quot;&gt;중첩 규칙&lt;/a&gt; , &lt;a href=&quot;#mixins&quot;&gt;mixin&lt;/a&gt; , &lt;a href=&quot;#import&quot;&gt;인라인 가져 오기&lt;/a&gt; 등 을 사용할 수 있습니다 . Sass는 특히 &lt;a href=&quot;http://compass-style.org&quot;&gt;Compass 스타일 라이브러리를&lt;/a&gt; 사용하여 큰 스타일 시트를 체계적으로 구성하고 작은 스타일 시트를 빠르게 실행하는 데 도움을 줍니다 .</target>
        </trans-unit>
        <trans-unit id="ddcdbf1cd9ff7a1977259d98743c6fafd982298a" translate="yes" xml:space="preserve">
          <source>Sass libraries and design systems tend to share and override configurations that are represented as nested maps (maps that contain maps that contain maps).</source>
          <target state="translated">Sass 라이브러리 및 디자인 시스템은 중첩 된 맵 (맵을 포함하는 맵을 포함하는 맵)으로 표시되는 구성을 공유하고 재정의하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f326907522a69fe4d59a051e191ed4e4cf75ebdf" translate="yes" xml:space="preserve">
          <source>Sass lists can contain one or even zero elements. A single-element list can be written either &lt;code&gt;(&amp;lt;expression&amp;gt;,)&lt;/code&gt; or &lt;code&gt;[&amp;lt;expression&amp;gt;]&lt;/code&gt;, and a zero-element list can be written either &lt;code&gt;()&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt;. Also, all &lt;a href=&quot;../modules/list&quot;&gt;list functions&lt;/a&gt; will treat individual values that aren&amp;rsquo;t in lists as though they&amp;rsquo;re lists containing that value, which means you rarely need to explicitly create single-element lists.</source>
          <target state="translated">Sass 목록에는 하나 또는 0 개의 요소가 포함될 수 있습니다. 단일 요소 목록은 &lt;code&gt;(&amp;lt;expression&amp;gt;,)&lt;/code&gt; 또는 &lt;code&gt;[&amp;lt;expression&amp;gt;]&lt;/code&gt; 중 하나로 작성 될 수 있으며 0 요소 목록은 &lt;code&gt;()&lt;/code&gt; 또는 &lt;code&gt;[]&lt;/code&gt; 중 하나로 작성 될 수 있습니다 . 또한 모든 &lt;a href=&quot;../modules/list&quot;&gt;목록 함수&lt;/a&gt; 는 목록 에없는 개별 값을 해당 값을 포함하는 목록 인 것처럼 취급하므로 단일 요소 목록을 명시 적으로 만들 필요가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a69154c2b4acc4e55d312e10bb9b932ccfca243" translate="yes" xml:space="preserve">
          <source>Sass looks for other Sass files in the current directory, and the Sass file directory under Rack, Rails, or Merb. Additional search directories may be specified using the &lt;a href=&quot;#load_paths-option&quot;&gt;&lt;code&gt;:load_paths&lt;/code&gt;&lt;/a&gt; option, or the &lt;code&gt;--load-path&lt;/code&gt; option on the command line.</source>
          <target state="translated">Sass는 현재 디렉토리에서 다른 Sass 파일을 찾고 Rack, Rails 또는 Merb에서 Sass 파일 디렉토리를 찾습니다. 추가 검색 디렉토리는 &lt;a href=&quot;#load_paths-option&quot;&gt; &lt;code&gt;:load_paths&lt;/code&gt; &lt;/a&gt; 옵션 또는 명령 줄 의 &lt;code&gt;--load-path&lt;/code&gt; 옵션을 사용하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb312b8bd38832476537b6a48f7e3156e89b7ab3" translate="yes" xml:space="preserve">
          <source>Sass makes this easy with the &lt;code&gt;@error&lt;/code&gt; rule, which is written &lt;code&gt;@error &amp;lt;expression&amp;gt;&lt;/code&gt;. It prints the value of the &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; (usually a string) along with a stack trace indicating how the current mixin or function was called. Once the error is printed, Sass stops compiling the stylesheet and tells whatever system is running it that an error occurred.</source>
          <target state="translated">말대꾸는이 쉽게 &lt;code&gt;@error&lt;/code&gt; 의 작성 규칙, &lt;code&gt;@error &amp;lt;expression&amp;gt;&lt;/code&gt; . 현재 믹스 인 또는 함수가 호출 된 방법을 나타내는 스택 추적과 함께 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;표현식&lt;/a&gt; (일반적으로 문자열) 의 값을 인쇄합니다 . 오류가 인쇄되면 Sass는 스타일 시트 컴파일을 중지하고이를 실행중인 시스템에 오류가 발생했음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="f3c25609caf02ddbba8fecd7b0288531ed8f4254" translate="yes" xml:space="preserve">
          <source>Sass numbers support the same formats as CSS numbers, including &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation&quot;&gt;scientific notation&lt;/a&gt;, which is written with an &lt;code&gt;e&lt;/code&gt; between the number and its power of 10. Because support for scientific notation in browsers has historically been spotty, Sass always compiles it to fully expanded numbers.</source>
          <target state="translated">Sass 숫자 는 숫자와 10의 거듭 제곱 사이에 &lt;code&gt;e&lt;/code&gt; 로 쓰여진 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation&quot;&gt;과학적 표기법을&lt;/a&gt; 포함하여 CSS 번호와 동일한 형식을 지원합니다 . 브라우저에서 과학적 표기법에 대한 지원은 역사적으로 불안정했기 때문에 Sass는 항상 완전히 확장 된 숫자로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="0642b9446f0b3a3e84ed89b56af8007af3e74738" translate="yes" xml:space="preserve">
          <source>Sass numbers support up to 10 digits of precision after the decimal point. This means a few different things:</source>
          <target state="translated">Sass 숫자는 소수점 이하 최대 10 자리의 정밀도를 지원합니다. 이것은 몇 가지 다른 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f686501493359aaeb6e8334dfbf749c38492e851" translate="yes" xml:space="preserve">
          <source>Sass only parses selectors &lt;em&gt;after&lt;/em&gt; interpolation is resolved. This means you can safely use interpolation to generate any part of the selector without worrying that it won&amp;rsquo;t parse.</source>
          <target state="translated">Sass는 보간이 해결 된 &lt;em&gt;후에&lt;/em&gt; 만 선택자를 구문 분석 합니다. 즉, 보간법을 사용하여 구문 분석하지 않을까 걱정하지 않고 선택기의 모든 부분을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de1e726ce1dc0c72b1e4f870bd0f36653583003" translate="yes" xml:space="preserve">
          <source>Sass provides a handful of &lt;a href=&quot;../modules/list&quot;&gt;functions&lt;/a&gt; that make it possible to use lists to write powerful style libraries, or to make your app&amp;rsquo;s stylesheet cleaner and more maintainable.</source>
          <target state="translated">Sass는 목록을 사용하여 강력한 스타일 라이브러리를 작성하거나 앱의 스타일 시트를 더 깨끗하고 유지 관리 할 수 ​​있도록 하는 몇 가지 &lt;a href=&quot;../modules/list&quot;&gt;함수&lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b0009ffe7a96796da80e21fa04676bad52a846b6" translate="yes" xml:space="preserve">
          <source>Sass provides a number of advanced customizations for users with unique requirements. Using these features requires a strong understanding of Ruby.</source>
          <target state="translated">Sass는 고유 한 요구 사항이있는 사용자를 위해 여러 가지 고급 사용자 지정 기능을 제공합니다. 이러한 기능을 사용하려면 Ruby에 대한 이해가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="33c553d9dc71a86be474f4c5f11876d63d15791a" translate="yes" xml:space="preserve">
          <source>Sass provides a number of at-rules that make it possible to control whether styles get emitted, or to emit them multiple times with small variations. They can also be used in &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt; and &lt;a href=&quot;function&quot;&gt;functions&lt;/a&gt; to write small algorithms to make writing your Sass easier. Sass supports four flow control rules:</source>
          <target state="translated">Sass는 스타일을 내보낼 지 여부를 제어하거나 작은 변형으로 여러 번 내보낼 수있는 여러 at- 규칙을 제공합니다. 또한 &lt;a href=&quot;mixin&quot;&gt;믹스 인&lt;/a&gt; 및 &lt;a href=&quot;function&quot;&gt;함수&lt;/a&gt; 에서 Sass를 더 쉽게 작성하기 위해 작은 알고리즘을 작성 하는 데 사용할 수 있습니다 . Sass는 네 가지 흐름 제어 규칙을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="49527978dd2cf7878bba69f22d0f51b489af35ee" translate="yes" xml:space="preserve">
          <source>Sass provides many built-in modules which contain useful functions (and the occasional mixin). These modules can be loaded with the &lt;a href=&quot;at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt; like any user-defined stylesheet, and their functions can be called &lt;a href=&quot;at-rules/use#loading-members&quot;&gt;like any other module member&lt;/a&gt;. All built-in module URLs begin with &lt;code&gt;sass:&lt;/code&gt; to indicate that they're part of Sass itself.</source>
          <target state="translated">Sass는 유용한 기능 (및 가끔 믹스 인)을 포함하는 많은 내장 모듈을 제공합니다. 이러한 모듈은 사용자 정의 스타일 시트처럼 &lt;a href=&quot;at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 규칙을&lt;/a&gt; 사용하여로드 할 수 있으며 해당 함수는 &lt;a href=&quot;at-rules/use#loading-members&quot;&gt;다른 모듈 멤버처럼&lt;/a&gt; 호출 할 수 있습니다 . 모든 내장 모듈 URL은 &lt;code&gt;sass:&lt;/code&gt; 로 시작하여 Sass 자체의 일부임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4ab8d4eb5816ea54277da228d107eca369d01633" translate="yes" xml:space="preserve">
          <source>Sass provides the following built-in modules:</source>
          <target state="translated">Sass는 다음과 같은 기본 제공 모듈을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4025d3f80e1fb8425ab404ceb4a3d8a1c0ee9b9f" translate="yes" xml:space="preserve">
          <source>Sass stylesheets don't work the same as views. They don't contain dynamic content, so the CSS only needs to be generated when the Sass file has been updated. By default, &lt;code&gt;.sass&lt;/code&gt; and &lt;code&gt;.scss&lt;/code&gt; files are placed in public/stylesheets/sass (this can be customized with the &lt;a href=&quot;#template_location-option&quot;&gt;&lt;code&gt;:template_location&lt;/code&gt;&lt;/a&gt; option). Then, whenever necessary, they're compiled into corresponding CSS files in public/stylesheets. For instance, public/stylesheets/sass/main.scss would be compiled to public/stylesheets/main.css.</source>
          <target state="translated">Sass 스타일 시트는보기와 동일하게 작동하지 않습니다. 동적 컨텐츠를 포함하지 않으므로 Sass 파일이 업데이트 된 경우에만 CSS를 생성해야합니다. 기본적으로 &lt;code&gt;.sass&lt;/code&gt; 및 &lt;code&gt;.scss&lt;/code&gt; 파일은 public / stylesheets / sass에 배치됩니다 ( &lt;a href=&quot;#template_location-option&quot;&gt; &lt;code&gt;:template_location&lt;/code&gt; &lt;/a&gt; 옵션 으로 사용자 정의 할 수 있음 ). 그런 다음 필요할 때마다 공개 / 스타일 시트에서 해당 CSS 파일로 컴파일됩니다. 예를 들어, public / stylesheets / sass / main.scss는 public / stylesheets / main.css로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="c61e231625156d893ed8fe4d22fab81c39ec0d02" translate="yes" xml:space="preserve">
          <source>Sass supports a few operators that generate &lt;a href=&quot;../values/strings&quot;&gt;strings&lt;/a&gt;:</source>
          <target state="translated">Sass는 &lt;a href=&quot;../values/strings&quot;&gt;문자열&lt;/a&gt; 을 생성하는 몇 가지 연산자를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="960801c5484134bb382dec9eafb1a76226deb27a" translate="yes" xml:space="preserve">
          <source>Sass supports a handful of useful &lt;code&gt;operators&lt;/code&gt; for working with different values. These include the standard mathematical operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;, as well as operators for various other types:</source>
          <target state="translated">Sass는 다양한 값으로 작업하는 데 유용한 몇 가지 &lt;code&gt;operators&lt;/code&gt; 를 지원 합니다. 여기에는 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;*&lt;/code&gt; 와 같은 표준 수학 연산자와 기타 다양한 유형의 연산자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="434a0ae241ff4bb8417d3c68ada1d1863e788791" translate="yes" xml:space="preserve">
          <source>Sass supports a number of value types, most of which come straight from CSS. Every &lt;a href=&quot;syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; produces a value, &lt;a href=&quot;variables&quot;&gt;variables&lt;/a&gt; hold values. Most value types come straight from CSS:</source>
          <target state="translated">Sass는 많은 값 유형을 지원하며, 대부분은 CSS에서 직접 제공됩니다. 모든 &lt;a href=&quot;syntax/structure#expressions&quot;&gt;표현식&lt;/a&gt; 은 값을 생성하고 &lt;a href=&quot;variables&quot;&gt;변수&lt;/a&gt; 는 값을 보유합니다. 대부분의 값 유형은 CSS에서 직접 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="dcbfa369bee1ee5f03dba6ad8ae4403b6fb0b310" translate="yes" xml:space="preserve">
          <source>Sass supports a special &lt;code&gt;=&lt;/code&gt; operator that&amp;rsquo;s only allowed in function arguments, which just creates an &lt;a href=&quot;values/strings#unquoted&quot;&gt;unquoted string&lt;/a&gt; with its two operands separated by &lt;code&gt;=&lt;/code&gt;. This exists for backwards-compatibility with very old IE-only syntax.</source>
          <target state="translated">Sass는 함수 인수에서만 허용 되는 특수 &lt;code&gt;=&lt;/code&gt; 연산자를 지원합니다.이 연산자 는 두 개의 피연산자가 &lt;code&gt;=&lt;/code&gt; 로 구분 된 &lt;a href=&quot;values/strings#unquoted&quot;&gt;따옴표없는 문자열&lt;/a&gt; 을 만듭니다 . 이것은 매우 오래된 IE 전용 구문과의 하위 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a1d70054db4e1dfd0e0b67c3e7e01b1d3bfc6c9a" translate="yes" xml:space="preserve">
          <source>Sass supports a special type of selector called a &quot;placeholder selector&quot;. These look like class and id selectors, except the &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; is replaced by &lt;code&gt;%&lt;/code&gt;. They're meant to be used with the &lt;a href=&quot;#extend&quot;&gt;&lt;code&gt;@extend&lt;/code&gt; directive&lt;/a&gt;; for more information see &lt;a href=&quot;#placeholders&quot;&gt;&lt;code&gt;@extend&lt;/code&gt;-Only Selectors&lt;/a&gt;.</source>
          <target state="translated">Sass는 &quot;자리 표시 자 선택기&quot;라는 특수한 유형의 선택기를 지원합니다. 클래스와 ID 선택기 같은이 모습은 제외시켰다 &lt;code&gt;#&lt;/code&gt; 을 하거나 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; 로 대체되었습니다 . &lt;a href=&quot;#extend&quot;&gt; &lt;code&gt;@extend&lt;/code&gt; 지시어&lt;/a&gt; 와 함께 사용하도록되어 있습니다 . 자세한 내용은 &lt;a href=&quot;#placeholders&quot;&gt; &lt;code&gt;@extend&lt;/code&gt; Selectors를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2109347200ea29f2dbcac97a7a1a0cbae14f6ebb" translate="yes" xml:space="preserve">
          <source>Sass supports all CSS3 &lt;code&gt;@&lt;/code&gt;-rules, as well as some additional Sass-specific ones known as &quot;directives.&quot; These have various effects in Sass, detailed below. See also &lt;a href=&quot;#control_directives&quot;&gt;control directives&lt;/a&gt; and &lt;a href=&quot;#mixins&quot;&gt;mixin directives&lt;/a&gt;.</source>
          <target state="translated">Sass는 모든 CSS3 &lt;code&gt;@&lt;/code&gt; -rules 및 &quot;directives&quot;라고하는 추가 Sass 관련 항목을 지원합니다. 이것들은 Sass에서 다양한 효과를냅니다. &lt;a href=&quot;#control_directives&quot;&gt;제어 지시문&lt;/a&gt; 및 &lt;a href=&quot;#mixins&quot;&gt;mixin 지시문&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="efff7bc7d11d2d156e403b4d0c736e7d9c2a72aa" translate="yes" xml:space="preserve">
          <source>Sass supports all the at-rules that are part of CSS proper. To stay flexible and forwards-compatible with future versions of CSS, Sass has general support that covers almost all at-rules by default. A CSS at-rule is written &lt;code&gt;@&amp;lt;name&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;, &lt;code&gt;@&amp;lt;name&amp;gt; { ... }&lt;/code&gt;, or &lt;code&gt;@&amp;lt;name&amp;gt; &amp;lt;value&amp;gt; { ... }&lt;/code&gt;. The name must be an identifier, and the value (if one exists) can be pretty much anything. Both the name and the value can contain &lt;a href=&quot;../interpolation&quot;&gt;interpolation&lt;/a&gt;.</source>
          <target state="translated">Sass는 적절한 CSS의 일부인 모든 at- 규칙을 지원합니다. CSS의 향후 버전과 유연하고 포워드 호환성을 유지하기 위해 Sass는 기본적으로 거의 모든 at- 규칙을 다루는 일반적인 지원을 제공합니다. CSS at-rule은 &lt;code&gt;@&amp;lt;name&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; , &lt;code&gt;@&amp;lt;name&amp;gt; { ... }&lt;/code&gt; 또는 &lt;code&gt;@&amp;lt;name&amp;gt; &amp;lt;value&amp;gt; { ... }&lt;/code&gt; 됩니다. 이름은 식별자 여야하며 값 (있는 경우)은 거의 모든 것이 될 수 있습니다. 이름과 값 모두 &lt;a href=&quot;../interpolation&quot;&gt;보간&lt;/a&gt; 을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0edbace979a3c6494ad08643df2a24269d903d3e" translate="yes" xml:space="preserve">
          <source>Sass supports many useful &lt;a href=&quot;../modules/color&quot;&gt;color functions&lt;/a&gt; that can be used to create new colors based on existing ones by &lt;a href=&quot;../modules/color#mix&quot;&gt;mixing colors together&lt;/a&gt; or &lt;a href=&quot;../modules/color#scale&quot;&gt;scaling their hue, saturation, or lightness&lt;/a&gt;.</source>
          <target state="translated">Sass는 색상을 &lt;a href=&quot;../modules/color#mix&quot;&gt;혼합&lt;/a&gt; 하거나 &lt;a href=&quot;../modules/color#scale&quot;&gt;색상, 채도 또는 밝기를 조정 &lt;/a&gt;하여 기존 색상을 기반으로 새로운 색상을 만드는 데 사용할 수있는 많은 유용한 &lt;a href=&quot;../modules/color&quot;&gt;색상 기능&lt;/a&gt; 을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9215ecc9de12de338c73b85746fafdaaf6b06e16" translate="yes" xml:space="preserve">
          <source>Sass supports standard multiline CSS comments with &lt;code&gt;/* */&lt;/code&gt;, as well as single-line comments with &lt;code&gt;//&lt;/code&gt;. The multiline comments are preserved in the CSS output where possible, while the single-line comments are removed. For example:</source>
          <target state="translated">Sass는 &lt;code&gt;/* */&lt;/code&gt; 사용한 표준 여러 줄 CSS 주석과 &lt;code&gt;//&lt;/code&gt; 를 사용한 한 줄 주석을 지원 합니다. 여러 줄 주석은 가능한 경우 CSS 출력에 유지되며 한 줄 주석은 제거됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad387609919992a7464bd532cbb72109ece70665" translate="yes" xml:space="preserve">
          <source>Sass supports the standard set of mathematical operators for &lt;a href=&quot;../values/numbers&quot;&gt;numbers&lt;/a&gt;. They automatically convert between compatible units.</source>
          <target state="translated">Sass는 &lt;a href=&quot;../values/numbers&quot;&gt;숫자에&lt;/a&gt; 대한 표준 수학 연산자 집합을 지원합니다 . 호환되는 단위간에 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e55bf6412b58a50f76ff43db8dc64446bdfa78d4" translate="yes" xml:space="preserve">
          <source>Sass supports two different syntaxes. Each one can load the other, so it's up to you and your team which one to choose.</source>
          <target state="translated">Sass는 두 가지 다른 구문을 지원합니다. 각각은 다른 하나를로드 할 수 있으므로 선택하는 것은 귀하와 귀하의 팀에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8f3ecedc8edcdcd2ba7a7cf536fa8406d7ccdf" translate="yes" xml:space="preserve">
          <source>Sass variables are &lt;em&gt;imperative&lt;/em&gt;, which means if you use a variable and then change its value, the earlier use will stay the same. CSS variables are &lt;em&gt;declarative&lt;/em&gt;, which means if you change the value, it&amp;rsquo;ll affect both earlier uses and later uses.</source>
          <target state="translated">Sass 변수는 &lt;em&gt;필수적&lt;/em&gt; 입니다. 즉, 변수를 사용한 다음 해당 값을 변경하면 이전 사용이 동일하게 유지됩니다. CSS 변수는 &lt;em&gt;선언적&lt;/em&gt; 이므로 값을 변경하면 이전 사용과 이후 사용 모두에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="b52ce5915995653ac969d0c85917aef9719a1096" translate="yes" xml:space="preserve">
          <source>Sass variables are all compiled away by Sass. CSS variables are included in the CSS output.</source>
          <target state="translated">Sass 변수는 모두 Sass에 의해 컴파일됩니다. CSS 변수는 CSS 출력에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9af20c986ec9da33a8716c1d52ee89798428472d" translate="yes" xml:space="preserve">
          <source>Sass variables are simple: you assign a value to a name that begins with &lt;code&gt;$&lt;/code&gt;, and then you can refer to that name instead of the value itself. But despite their simplicity, they're one of the most useful tools Sass brings to the table. Variables make it possible to reduce repetition, do complex math, configure libraries, and much more.</source>
          <target state="translated">Sass 변수는 간단합니다. &lt;code&gt;$&lt;/code&gt; 로 시작하는 이름에 값을 할당 한 다음 값 자체 대신 해당 이름을 참조 할 수 있습니다. 그러나 단순함에도 불구하고 Sass가 제공하는 가장 유용한 도구 중 하나입니다. 변수를 사용하면 반복을 줄이고 복잡한 수학을 수행하며 라이브러리를 구성하는 등의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="005fc56aea0ad08689769aa5d4e9066a2c9fa4e5" translate="yes" xml:space="preserve">
          <source>Sass variables, like all Sass identifiers, treat hyphens and underscores as identical. This means that &lt;code&gt;$font-size&lt;/code&gt; and &lt;code&gt;$font_size&lt;/code&gt; both refer to the same variable. This is a historical holdover from the very early days of Sass, when it &lt;em&gt;only&lt;/em&gt; allowed underscores in identifier names. Once Sass added support for hyphens to match CSS&amp;rsquo;s syntax, the two were made equivalent to make migration easier.</source>
          <target state="translated">모든 Sass 식별자와 마찬가지로 Sass 변수는 하이픈과 밑줄을 동일하게 취급합니다. 이는 &lt;code&gt;$font-size&lt;/code&gt; 와 &lt;code&gt;$font_size&lt;/code&gt; 모두 동일한 변수를 참조 함을 의미합니다. 이것은 식별자 이름에 밑줄 &lt;em&gt;만&lt;/em&gt; 허용 했던 Sass 초기 시절의 역사적 유보입니다 . Sass가 CSS의 구문과 일치하도록 하이픈에 대한 지원을 추가 한 후에는 두 가지가 동일하게 만들어져 마이그레이션이 더 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="86fc2e831482914e7d296b365a94c163b569e70a" translate="yes" xml:space="preserve">
          <source>Sass will always encode its output as UTF-8. It will include a &lt;code&gt;@charset&lt;/code&gt; declaration if and only if the output file contains non-ASCII characters. In compressed mode, a UTF-8 byte order mark is used in place of a &lt;code&gt;@charset&lt;/code&gt; declaration.</source>
          <target state="translated">Sass는 항상 출력을 UTF-8로 인코딩합니다. 출력 파일에 ASCII가 아닌 문자가 포함 된 경우에만 &lt;code&gt;@charset&lt;/code&gt; 선언 이 포함됩니다 . 압축 모드에서는 &lt;code&gt;@charset&lt;/code&gt; 선언 대신 UTF-8 바이트 순서 표시가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ad32e6ce5a92b0d94044a1ca6fda1872af3807e" translate="yes" xml:space="preserve">
          <source>Sass will automatically convert between compatible units, although which unit it will choose for the result depends on which implementation of Sass you&amp;rsquo;re using.If you try to combine incompatible units, like &lt;code&gt;1in + 1em&lt;/code&gt;, Sass will throw an error.</source>
          <target state="translated">그 결과가 당신이 좋아, 호환되지 않는 장치를 결합 using.If하려고있는 거 말대꾸 어떤 구현에 따라 달라 선택되는 단위 있지만 말대꾸가 자동으로 호환 단위 사이의 변환합니다 &lt;code&gt;1in + 1em&lt;/code&gt; , 말대꾸 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8cd620b61343aa6fe6e3e1e3a184d2f9a181519d" translate="yes" xml:space="preserve">
          <source>Sass&amp;rsquo;s &lt;a href=&quot;../operators/numeric#slash-separated-values&quot;&gt;special parsing rules&lt;/a&gt; for slash-separated values make it difficult to pass variables for &lt;code&gt;$blackness&lt;/code&gt; or &lt;code&gt;$alpha&lt;/code&gt; when using the &lt;code&gt;color.hwb($hue $whiteness $blackness / $alpha)&lt;/code&gt; signature. Consider using &lt;code&gt;color.hwb($hue, $whiteness, $blackness, $alpha)&lt;/code&gt; instead.</source>
          <target state="translated">슬래시로 구분 된 값에 대한 Sass의 &lt;a href=&quot;../operators/numeric#slash-separated-values&quot;&gt;특수 구문 분석 규칙&lt;/a&gt; 은 &lt;code&gt;color.hwb($hue $whiteness $blackness / $alpha)&lt;/code&gt; 서명을 사용할 때 &lt;code&gt;$blackness&lt;/code&gt; 또는 &lt;code&gt;$alpha&lt;/code&gt; 대한 변수를 전달하기 어렵게 만듭니다 . 사용을 고려 &lt;code&gt;color.hwb($hue, $whiteness, $blackness, $alpha)&lt;/code&gt; 를 대신.</target>
        </trans-unit>
        <trans-unit id="1fe37750469e345e571d1fb1921fe49b388c53c7" translate="yes" xml:space="preserve">
          <source>Sass&amp;rsquo;s &lt;a href=&quot;operators/numeric#slash-separated-values&quot;&gt;special parsing rules&lt;/a&gt; for slash-separated values make it difficult to pass variables for &lt;code&gt;$blue&lt;/code&gt; or &lt;code&gt;$alpha&lt;/code&gt; when using the &lt;code&gt;rgb($red $green $blue / $alpha)&lt;/code&gt; signature. Consider using &lt;code&gt;rgb($red, $green, $blue, $alpha)&lt;/code&gt; instead.</source>
          <target state="translated">슬래시로 구분 된 값에 대한 Sass의 &lt;a href=&quot;operators/numeric#slash-separated-values&quot;&gt;특수 구문 분석 규칙&lt;/a&gt; 은 &lt;code&gt;rgb($red $green $blue / $alpha)&lt;/code&gt; 서명을 사용할 때 &lt;code&gt;$blue&lt;/code&gt; 또는 &lt;code&gt;$alpha&lt;/code&gt; 대한 변수를 전달하기 어렵게 만듭니다 . 사용을 고려 &lt;code&gt;rgb($red, $green, $blue, $alpha)&lt;/code&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="4a04fb2da5e9764122c9c7d75ec45d105af5287b" translate="yes" xml:space="preserve">
          <source>Sass&amp;rsquo;s &lt;a href=&quot;operators/numeric#slash-separated-values&quot;&gt;special parsing rules&lt;/a&gt; for slash-separated values make it difficult to pass variables for &lt;code&gt;$lightness&lt;/code&gt; or &lt;code&gt;$alpha&lt;/code&gt; when using the &lt;code&gt;hsl($hue $saturation $lightness / $alpha)&lt;/code&gt; signature. Consider using &lt;code&gt;hsl($hue, $saturation, $lightness, $alpha)&lt;/code&gt; instead.</source>
          <target state="translated">슬래시로 구분 된 값에 대한 Sass의 &lt;a href=&quot;operators/numeric#slash-separated-values&quot;&gt;특수 구문 분석 규칙&lt;/a&gt; 은 &lt;code&gt;hsl($hue $saturation $lightness / $alpha)&lt;/code&gt; 서명을 사용할 때 &lt;code&gt;$lightness&lt;/code&gt; 또는 &lt;code&gt;$alpha&lt;/code&gt; 대한 변수를 전달하기 어렵게 만듭니다 . 사용을 고려 &lt;code&gt;hsl($hue, $saturation, $lightness, $alpha)&lt;/code&gt; 를 대신.</target>
        </trans-unit>
        <trans-unit id="ce844da4e80d92bf1eb0bc6278bf298072b631c5" translate="yes" xml:space="preserve">
          <source>Sass&amp;rsquo;s &lt;a href=&quot;use&quot;&gt;module system&lt;/a&gt; integrates seamlessly with &lt;code&gt;@import&lt;/code&gt;, whether you&amp;rsquo;re importing a file that contains &lt;code&gt;@use&lt;/code&gt; rules or loading a file that contains imports as a module. We want to make the transition from &lt;code&gt;@import&lt;/code&gt; to &lt;code&gt;@use&lt;/code&gt; as smooth as possible.</source>
          <target state="translated">Sass의 &lt;a href=&quot;use&quot;&gt;모듈 시스템&lt;/a&gt; 은 &lt;code&gt;@use&lt;/code&gt; 규칙 이 포함 된 파일을 가져 오든 모듈로 가져 오기를 포함하는 파일을로드 하든 상관없이 &lt;code&gt;@import&lt;/code&gt; 와 원활하게 통합 됩니다. &lt;code&gt;@import&lt;/code&gt; 에서 &lt;code&gt;@use&lt;/code&gt; 로 최대한 원활하게 전환하고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="6babd285fe65d953ef5ca31abc267f057579bc8e" translate="yes" xml:space="preserve">
          <source>Sass&amp;rsquo;s &lt;code&gt;@extend&lt;/code&gt; rule solves this. It&amp;rsquo;s written &lt;code&gt;@extend &amp;lt;selector&amp;gt;&lt;/code&gt;, and it tells Sass that one selector should inherit the styles of another.</source>
          <target state="translated">Sass의 &lt;code&gt;@extend&lt;/code&gt; 규칙이이 문제를 해결합니다. &lt;code&gt;@extend &amp;lt;selector&amp;gt;&lt;/code&gt; 로 작성 되었으며 Sass에게 한 선택자가 다른 선택 자의 스타일을 상속해야한다고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="9a029dc1ee662d27c405277aa39c5baecc4c4ef5" translate="yes" xml:space="preserve">
          <source>SassScript</source>
          <target state="translated">SassScript</target>
        </trans-unit>
        <trans-unit id="1e9e5f520b46482b7d78207fd2f87587cbd9101f" translate="yes" xml:space="preserve">
          <source>SassScript #sassscript</source>
          <target state="translated">SassScript #sassscript</target>
        </trans-unit>
        <trans-unit id="eddf0c34ceef208253270813e40998133922216a" translate="yes" xml:space="preserve">
          <source>SassScript also supports all other types of CSS property value, such as Unicode ranges and &lt;code&gt;!important&lt;/code&gt; declarations. However, it has no special handling for these types. They're treated just like unquoted strings.</source>
          <target state="translated">SassScript는 유니 코드 범위 및 &lt;code&gt;!important&lt;/code&gt; 선언 과 같은 다른 모든 유형의 CSS 속성 값도 지원합니다 . 그러나 이러한 유형에 대한 특별한 처리는 없습니다. 인용되지 않은 문자열처럼 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="30070efcd26bcdfe4438c8cf2d17f83b0465a179" translate="yes" xml:space="preserve">
          <source>SassScript can also be used to generate selectors and property names, which is useful when writing &lt;a href=&quot;#mixins&quot;&gt;mixins&lt;/a&gt;. This is done via &lt;a href=&quot;#interpolation_&quot;&gt;interpolation&lt;/a&gt;.</source>
          <target state="translated">SassScript를 사용하여 선택기와 속성 이름을 생성 할 수도 있습니다. 이는 &lt;a href=&quot;#mixins&quot;&gt;mixin을&lt;/a&gt; 작성할 때 유용합니다 . 이것은 &lt;a href=&quot;#interpolation_&quot;&gt;보간을&lt;/a&gt; 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="596d9a884cf209787a0dc4c00e05192356951ab7" translate="yes" xml:space="preserve">
          <source>SassScript defines some useful functions that are called using the normal CSS function syntax:</source>
          <target state="translated">SassScript는 일반적인 CSS 함수 구문을 사용하여 호출되는 유용한 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6a72866c8b59f464530dbfd219c2c0c494590ba2" translate="yes" xml:space="preserve">
          <source>SassScript supports &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;not&lt;/code&gt; operators for boolean values.</source>
          <target state="translated">SassScript 지원 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , 그리고 &lt;code&gt;not&lt;/code&gt; 부울 값에 대한 연산자.</target>
        </trans-unit>
        <trans-unit id="c989ac7fb0836232ff868fa3ef818e56620ba887" translate="yes" xml:space="preserve">
          <source>SassScript supports basic control directives and expressions for including styles only under some conditions or including the same style several times with variations.</source>
          <target state="translated">SassScript는 일부 조건에서만 스타일을 포함하거나 변형과 동일한 스타일을 여러 번 포함하기위한 기본 제어 지시문 및 표현식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8bc453bdb705d2d310a2a0bf56ccd55390ab99d1" translate="yes" xml:space="preserve">
          <source>SassScript supports eight data types:</source>
          <target state="translated">SassScript는 8 가지 데이터 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5719e48057100bfd7e91627b5815247b4ef02f26" translate="yes" xml:space="preserve">
          <source>SassScript supports the standard arithmetic operations on numbers (addition &lt;code&gt;+&lt;/code&gt;, subtraction &lt;code&gt;-&lt;/code&gt;, multiplication &lt;code&gt;*&lt;/code&gt;, division &lt;code&gt;/&lt;/code&gt;, and modulo &lt;code&gt;%&lt;/code&gt;). Sass math functions preserve units during arithmetic operations. This means that, just like in real life, you cannot work on numbers with incompatible units (such as adding a number with &lt;code&gt;px&lt;/code&gt; and &lt;code&gt;em&lt;/code&gt;) and two numbers with the same unit that are multiplied together will produce square units (&lt;code&gt;10px * 10px == 100px * px&lt;/code&gt;). &lt;strong&gt;Be Aware&lt;/strong&gt; that &lt;code&gt;px * px&lt;/code&gt; is an invalid CSS unit and you will get an error from Sass for attempting to use invalid units in CSS.</source>
          <target state="translated">SassScript는 숫자에 대한 표준 산술 연산 (더하기 &lt;code&gt;+&lt;/code&gt; , 빼기 &lt;code&gt;-&lt;/code&gt; , 곱하기 &lt;code&gt;*&lt;/code&gt; , 나누기 &lt;code&gt;/&lt;/code&gt; 및 모듈로 &lt;code&gt;%&lt;/code&gt; )을 지원합니다. Sass math 함수는 산술 연산 중에 단위를 유지합니다. 즉, 실제와 마찬가지로 호환되지 않는 단위 (예 : &lt;code&gt;px&lt;/code&gt; 및 &lt;code&gt;em&lt;/code&gt; 을 추가하는 숫자 )와 같은 단위를 가진 두 숫자를 곱하면 제곱 단위 ( &lt;code&gt;10px * 10px == 100px * px&lt;/code&gt; ). &lt;strong&gt;인식 할 수&lt;/strong&gt; 있다는 &lt;code&gt;px * px&lt;/code&gt; 잘못된 CSS 단위이며 CSS에서 유효하지 않은 단위를 사용하기 위해 말대꾸에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="fdce4e45667836eb9d8dd8e9ca3ec97d8b2e1359" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://sass-lang.com/documentation/breaking-changes/css-vars&quot;&gt;the breaking change page&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://sass-lang.com/documentation/breaking-changes/css-vars&quot;&gt;은 주요 변경 사항 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d2a2a03777527a2a4ffd15581a1e95ce8b0c1bd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://sass-lang.com/documentation/breaking-changes/extend-compound&quot;&gt;the breaking change page&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://sass-lang.com/documentation/breaking-changes/extend-compound&quot;&gt;은 주요 변경 사항 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd4881bdb25c2fafab7ffd312ea4c42d08299488" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sass/script/functions&quot;&gt;Sass::Script::Functions&lt;/a&gt; for a full listing of Sass functions and their argument names, as well as instructions on defining your own in Ruby.</source>
          <target state="translated">Sass 함수 및 인수 이름의 전체 목록과 Ruby에서 사용자 정의에 대한 지시 사항 은 &lt;a href=&quot;sass/script/functions&quot;&gt;Sass :: Script :: Functions&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3f9123bc3816ae829779a66a9e07ec9052ed653" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sass/script/functions&quot;&gt;this page&lt;/a&gt; for a full list of available functions.</source>
          <target state="translated">사용 가능한 전체 기능 목록은 &lt;a href=&quot;sass/script/functions&quot;&gt;이 페이지&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0da0a68ff9c18e145ed1ed1a7381ab7f293f8a59" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#adjust&quot;&gt;&lt;code&gt;color.adjust()&lt;/code&gt;&lt;/a&gt;, which can adjust any property of a color.</source>
          <target state="translated">색상의 모든 속성을 조정할 수있는 &lt;a href=&quot;#adjust&quot;&gt; &lt;code&gt;color.adjust()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="679cd26786cb638c2927566e24f8fc70fa1dc8fb" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#append&quot;&gt;&lt;code&gt;selector.append()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#append&quot;&gt; &lt;code&gt;selector.append()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3df27adbbcfb9c31baf1c2529d72651e352386fd" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#extend&quot;&gt;&lt;code&gt;selector.extend()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#extend&quot;&gt; &lt;code&gt;selector.extend()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cb4f1c630458ad1e373eb58ccdd19f455e76f9c" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#global-variable-exists&quot;&gt;&lt;code&gt;meta.global-variable-exists()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#global-variable-exists&quot;&gt; &lt;code&gt;meta.global-variable-exists()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e089753345cfe250442e9879e62c37578a29bb28" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#nest&quot;&gt;&lt;code&gt;selector.nest()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#nest&quot;&gt; &lt;code&gt;selector.nest()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43f93bf24749e90a4432789b5a135b28bdffc679" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#replace&quot;&gt;&lt;code&gt;selector.replace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#replace&quot;&gt; &lt;code&gt;selector.replace()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6004a2fc2bea20b2200359dfa598d09d55491c91" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#variable-exists&quot;&gt;&lt;code&gt;meta.variable-exists()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#variable-exists&quot;&gt; &lt;code&gt;meta.variable-exists()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="ef7c4e67c26ce55409670b54814f736a8e82f373" translate="yes" xml:space="preserve">
          <source>Selector Combinators</source>
          <target state="translated">선택기 결합 자</target>
        </trans-unit>
        <trans-unit id="9b1a3a5f7fb5e0d301d5ae1e7fbf8ed1b7dd7b4d" translate="yes" xml:space="preserve">
          <source>Selector Lists</source>
          <target state="translated">선택자 목록</target>
        </trans-unit>
        <trans-unit id="011a99b67cb875077910ef37dc00f4c9e77d86ba" translate="yes" xml:space="preserve">
          <source>Selector Sequences</source>
          <target state="translated">선택기 시퀀스</target>
        </trans-unit>
        <trans-unit id="6c23fedd19e084993aa1db6f749810cb7556b88b" translate="yes" xml:space="preserve">
          <source>Selector Values</source>
          <target state="translated">선택기 값</target>
        </trans-unit>
        <trans-unit id="39877f1ff80fe84908056627a6a3288f55e0cb06" translate="yes" xml:space="preserve">
          <source>Selector arguments to these functions may be in the same format, but they can also just be normal strings (quoted or unquoted), or a combination. For example, &lt;code&gt;&quot;.main aside:hover, .sidebar p&quot;&lt;/code&gt; is a valid selector argument.</source>
          <target state="translated">이러한 함수에 대한 선택기 인수는 동일한 형식 일 수 있지만 일반 문자열 (따옴표 또는 따옴표 없음) 또는 조합 일 수도 있습니다. 예를 들어 &lt;code&gt;&quot;.main aside:hover, .sidebar p&quot;&lt;/code&gt; 는 유효한 선택자 인수입니다.</target>
        </trans-unit>
        <trans-unit id="f0c6b6a8a3a0d2a9f1359a91eb7e3caf91f383a3" translate="yes" xml:space="preserve">
          <source>Selector sequences, such as &lt;code&gt;.foo .bar&lt;/code&gt; or &lt;code&gt;.foo + .bar&lt;/code&gt;, currently can't be extended. However, it is possible for nested selectors themselves to use &lt;code&gt;@extend&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;.foo .bar&lt;/code&gt; 또는 &lt;code&gt;.foo + .bar&lt;/code&gt; 와 같은 선택기 시퀀스는 현재 확장 할 수 없습니다. 그러나 중첩 된 선택기 자체가 &lt;code&gt;@extend&lt;/code&gt; 를 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7faab062482c099de7813c7ea8e22561e5d6c502" translate="yes" xml:space="preserve">
          <source>Selectors in style rules</source>
          <target state="translated">스타일 규칙의 선택기</target>
        </trans-unit>
        <trans-unit id="a69ae3b958e7fe99a574b24124ac812c6522e4bb" translate="yes" xml:space="preserve">
          <source>Sets one or more properties of a color to new values.</source>
          <target state="translated">하나 이상의 색상 속성을 새 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d83074a15945b9150660fab7a66aca419880e86c" translate="yes" xml:space="preserve">
          <source>Sets the alpha channel of the color. The value must be a number between 0 and 1 (inclusive).</source>
          <target state="translated">색상의 알파 채널을 설정합니다. 값은 0과 1 (포함) 사이의 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7437e748303fdad54500657645d4f95bf3ac84fa" translate="yes" xml:space="preserve">
          <source>Sets the blue channel of the color. The value must be an integer between 0 and 255 (inclusive).</source>
          <target state="translated">색상의 파란색 채널을 설정합니다. 값은 0에서 255 (포함) 사이의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cc5a7bf9585c7fd476dab4da07edc8dace4f58b8" translate="yes" xml:space="preserve">
          <source>Sets the contents of the string.</source>
          <target state="translated">문자열의 내용을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b55d5b21d0404d4e0507ed2a5caa69669328c36f" translate="yes" xml:space="preserve">
          <source>Sets the element at the given (0-based) index in the list to the given value.</source>
          <target state="translated">목록의 지정된 (0 기반) 인덱스에있는 요소를 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c31b9d3c5fafd3f68a502e5e4c266afc4f4028bb" translate="yes" xml:space="preserve">
          <source>Sets the green channel of the color. The value must be an integer between 0 and 255 (inclusive).</source>
          <target state="translated">색상의 녹색 채널을 설정합니다. 값은 0에서 255 (포함) 사이의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="21d0b7c11fbb51189adb544dcb538f4e1d782c1e" translate="yes" xml:space="preserve">
          <source>Sets the key of the key/value pair at the given (0-based) index in the map to the given value.</source>
          <target state="translated">맵의 지정된 (0 기반) 인덱스에있는 키 / 값 쌍의 키를 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="161391ae0530d71d60db033d508408f8310295b7" translate="yes" xml:space="preserve">
          <source>Sets the opacity of an existing color.</source>
          <target state="translated">기존 색상의 불투명도를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e1e8d33426f0769fa417a2b16357eebf5a72c77a" translate="yes" xml:space="preserve">
          <source>Sets the red channel of the color. The value must be an integer between 0 and 255 (inclusive).</source>
          <target state="translated">색상의 빨간색 채널을 설정합니다. 값은 0에서 255 (포함) 사이의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="26b90f3e3030a5386b9db65e2a5772ec9bc0acf0" translate="yes" xml:space="preserve">
          <source>Sets the units of the number, independent of its numeric value. Complex units are specified in the same format as for &lt;a href=&quot;#new-types-number-value-unit-39-39&quot;&gt;the constructor&lt;/a&gt;.</source>
          <target state="translated">숫자 값에 관계없이 숫자 단위를 설정합니다. 복잡한 단위는 &lt;a href=&quot;#new-types-number-value-unit-39-39&quot;&gt;생성자&lt;/a&gt; 와 동일한 형식으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5c27baf89870000789311c5c322d343e54cf2cd" translate="yes" xml:space="preserve">
          <source>Sets the value of the key/value pair at the given (0-based) index in the map to the given value.</source>
          <target state="translated">맵의 지정된 (0 기반) 인덱스에서 키 / 값 쌍의 값을 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3aff50d684bdec6d813485557cf666de2f96600a" translate="yes" xml:space="preserve">
          <source>Sets the value of the number, independent of its units.</source>
          <target state="translated">단위에 관계없이 숫자 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ba13de59430e2d1224a010aedf6f89003b2bc3eb" translate="yes" xml:space="preserve">
          <source>Sets whether the list is comma-separated.</source>
          <target state="translated">목록이 쉼표로 구분되는지 여부를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7331278fb5718617e233df649e90ba9b72bfb49e" translate="yes" xml:space="preserve">
          <source>Shadowing</source>
          <target state="translated">Shadowing</target>
        </trans-unit>
        <trans-unit id="263c53971890113309f9896944379e4ddf6823bc" translate="yes" xml:space="preserve">
          <source>Similarly, if &lt;code&gt;.main .info&lt;/code&gt; could be extended, it would do (almost) the same thing as extending &lt;code&gt;.info&lt;/code&gt; on its own. The subtle differences aren&amp;rsquo;t worth the confusion of looking like it&amp;rsquo;s doing something substantially different, so this isn&amp;rsquo;t allowed either.</source>
          <target state="translated">경우 마찬가지로, &lt;code&gt;.main .info&lt;/code&gt; 확장 할 수 있습니다, 그것은 확장으로 (거의) 같은 일을 할 것 &lt;code&gt;.info&lt;/code&gt; 그 자체. 미묘한 차이는 상당히 다른 일을하는 것처럼 보이기 때문에 혼란 스러울 가치가 없으므로 이것도 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="594ff1d40a265dff076fc1b134721daddcc676ed" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;#maps&quot;&gt;maps&lt;/a&gt; are treated as lists of pairs, multiple assignment works with them as well. For example:</source>
          <target state="translated">때문에 &lt;a href=&quot;#maps&quot;&gt;지도가&lt;/a&gt; 쌍 목록으로 취급, 다중 할당뿐만 아니라 그들과 함께 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7200d8e0523e5177b5aeb63ebb9805abf7e11f71" translate="yes" xml:space="preserve">
          <source>Since maps aren&amp;rsquo;t valid CSS values, they don&amp;rsquo;t do much of anything on their own. That&amp;rsquo;s why Sass provides a bunch of &lt;a href=&quot;../modules/map&quot;&gt;functions&lt;/a&gt; to create maps and access the values they contain.</source>
          <target state="translated">맵은 유효한 CSS 값이 아니기 때문에 자체적으로 많은 작업을 수행하지 않습니다. 그렇기 때문에 Sass는 맵을 생성하고 포함 된 값에 액세스 할 수 있는 여러 &lt;a href=&quot;../modules/map&quot;&gt;기능&lt;/a&gt; 을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ae3ed84c656302ff446453d77e6e47fa6b24d100" translate="yes" xml:space="preserve">
          <source>Since multiline comments become part of the resulting CSS, interpolation within them is resolved. For example:</source>
          <target state="translated">여러 줄 주석은 결과 CSS의 일부가되므로 그 안의 보간이 해결됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="243ff2986e1cbe1a398f0a477a1de767e1fc9147" translate="yes" xml:space="preserve">
          <source>Single Equals</source>
          <target state="translated">단일 같음</target>
        </trans-unit>
        <trans-unit id="be1899ccc3c28b0b29b93f473affed2193d2d07d" translate="yes" xml:space="preserve">
          <source>Slash-Separated Values</source>
          <target state="translated">슬래시로 구분 된 값</target>
        </trans-unit>
        <trans-unit id="b0265b93f57e530525fb4bd6540dfd8865202988" translate="yes" xml:space="preserve">
          <source>Some CSS functions, like &lt;code&gt;calc()&lt;/code&gt; and &lt;code&gt;element()&lt;/code&gt; have unusual syntax. Sass &lt;a href=&quot;../syntax/special-functions&quot;&gt;parses these functions specially&lt;/a&gt; as &lt;a href=&quot;../values/strings#unquoted&quot;&gt;unquoted strings&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;calc()&lt;/code&gt; 및 &lt;code&gt;element()&lt;/code&gt; 와 같은 일부 CSS 함수 에는 비정상적인 구문이 있습니다. Sass &lt;a href=&quot;../syntax/special-functions&quot;&gt;는 특히 &lt;/a&gt;&lt;a href=&quot;../values/strings#unquoted&quot;&gt;인용되지 않은 문자열&lt;/a&gt; 로 이러한 함수를 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="c8e12ba4011b926975609b7327dbec9b181996fb" translate="yes" xml:space="preserve">
          <source>Some languages consider more values falsey than just &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. Sass isn&amp;rsquo;t one of those languages! Empty strings, empty lists, and the number &lt;code&gt;0&lt;/code&gt; are all truthy in Sass.</source>
          <target state="translated">일부 언어는 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;null&lt;/code&gt; 보다 더 많은 값을 거짓으로 간주합니다 . Sass는 그러한 언어 중 하나가 아닙니다! 빈 문자열, 빈 목록 및 숫자 &lt;code&gt;0&lt;/code&gt; 은 모두 Sass에서 진실입니다.</target>
        </trans-unit>
        <trans-unit id="08e4ee6af9721071a87baaed7a28bb29fafa67c5" translate="yes" xml:space="preserve">
          <source>Some mixins may require a passed content block or may have different behavior depending on whether a content block was passed. The &lt;a href=&quot;sass/script/functions#content_exists-instance_method&quot;&gt;&lt;code&gt;content-exists()&lt;/code&gt; function&lt;/a&gt; will return true when a content block is passed to the current mixin and can be used to implement such behaviors.</source>
          <target state="translated">일부 믹스 인은 전달 된 컨텐츠 블록이 필요하거나 컨텐츠 블록이 전달되었는지 여부에 따라 다른 동작을 가질 수 있습니다. &lt;a href=&quot;sass/script/functions#content_exists-instance_method&quot;&gt; &lt;code&gt;content-exists()&lt;/code&gt; 함수는&lt;/a&gt; 콘텐츠 블록이 현재의 믹스 인에 전달하고 같은 동작을 구현하는 데 사용할 수있는 경우에 true를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="2fbaedc36a96d170cb5fde555c76e912ae92d5f1" translate="yes" xml:space="preserve">
          <source>Some of these CSS properties have shorthand versions that use the namespace as the property name. For these, you can write both the shorthand value &lt;em&gt;and&lt;/em&gt; the more explicit nested versions.</source>
          <target state="translated">이러한 CSS 속성 중 일부에는 네임 스페이스를 속성 이름으로 사용하는 약식 버전이 있습니다. 이를 위해 속기 값 &lt;em&gt;과&lt;/em&gt; 보다 명시적인 중첩 버전을 모두 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6a2a3f264e74ed32785ea446916a7a5ec1a6004" translate="yes" xml:space="preserve">
          <source>Someday we hope to have &lt;code&gt;@extend&lt;/code&gt; supported natively in the browser, which will allow it to be used within &lt;code&gt;@media&lt;/code&gt; and other directives.</source>
          <target state="translated">언젠가 우리는 &lt;code&gt;@extend&lt;/code&gt; 를 브라우저에서 기본적으로 지원하여 &lt;code&gt;@media&lt;/code&gt; 및 기타 지시문 내에서 사용할 수 있기를 희망합니다 .</target>
        </trans-unit>
        <trans-unit id="2360319b1a3c1bfdc51f2c01b1bb2ac6b9bb4efd" translate="yes" xml:space="preserve">
          <source>Sometimes a selector sequence extends another selector that appears in another sequence. In this case, the two sequences need to be merged. For example:</source>
          <target state="translated">때로는 선택기 시퀀스가 ​​다른 시퀀스에 나타나는 다른 선택기를 확장합니다. 이 경우 두 시퀀스를 병합해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f95e9286fc3d862bc7f1f917870ab369becd35a" translate="yes" xml:space="preserve">
          <source>Sometimes it makes sense for a mixin or function to take an unknown number of arguments. For example, a mixin for creating box shadows might take any number of shadows as arguments. For these situations, Sass supports &quot;variable arguments,&quot; which are arguments at the end of a mixin or function declaration that take all leftover arguments and package them up as a &lt;a href=&quot;#lists&quot;&gt;list&lt;/a&gt;. These arguments look just like normal arguments, but are followed by &lt;code&gt;...&lt;/code&gt;. For example:</source>
          <target state="translated">때로는 믹스 인이나 함수가 알려지지 않은 수의 인수를 취하는 것이 합리적입니다. 예를 들어, 상자 그림자를 만들기위한 믹스 인은 여러 그림자를 인수로 사용할 수 있습니다. 이러한 상황에서 Sass는 &quot;variable arguments&quot;를 지원합니다. &quot;variable arguments&quot;는 믹스 인 또는 함수 선언의 끝에서 모든 나머지 인수를 가져 와서 &lt;a href=&quot;#lists&quot;&gt;목록&lt;/a&gt; 으로 패키지화하는 인수 입니다. 이러한 인수는 일반 인수와 유사하지만 &lt;code&gt;...&lt;/code&gt; 뒤에옵니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a9047975f81c7beb3b1d0835b88132f5ea1d02d" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful for a function to be able to take any number of arguments. If the last argument in a &lt;code&gt;@function&lt;/code&gt; declaration ends in &lt;code&gt;...&lt;/code&gt;, then all extra arguments to that function are passed to that argument as a &lt;a href=&quot;../values/lists&quot;&gt;list&lt;/a&gt;. This argument is known as an &lt;a href=&quot;../values/lists#argument-lists&quot;&gt;argument list&lt;/a&gt;.</source>
          <target state="translated">때로는 함수가 여러 인수를 취할 수있는 것이 유용합니다. &lt;code&gt;@function&lt;/code&gt; 선언 의 마지막 인수가 &lt;code&gt;...&lt;/code&gt; 로 끝나면 해당 함수 에 대한 모든 추가 인수가 해당 인수에 &lt;a href=&quot;../values/lists&quot;&gt;목록&lt;/a&gt; 으로 전달됩니다 . 이 인수를 &lt;a href=&quot;../values/lists#argument-lists&quot;&gt;인수 목록&lt;/a&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="1235e537acae969a32efd55393d8d9d439d84bcf" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful for a mixin to be able to take any number of arguments. If the last argument in a &lt;code&gt;@mixin&lt;/code&gt; declaration ends in &lt;code&gt;...&lt;/code&gt;, then all extra arguments to that mixin are passed to that argument as a &lt;a href=&quot;../values/lists&quot;&gt;list&lt;/a&gt;. This argument is known as an &lt;a href=&quot;../values/lists#argument-lists&quot;&gt;argument list&lt;/a&gt;.</source>
          <target state="translated">때로는 믹스 인이 여러 인수를 취할 수있는 것이 유용합니다. &lt;code&gt;@mixin&lt;/code&gt; 선언 의 마지막 인수가 &lt;code&gt;...&lt;/code&gt; 로 끝나면 해당 mixin에 대한 모든 추가 인수가 해당 인수에 &lt;a href=&quot;../values/lists&quot;&gt;목록&lt;/a&gt; 으로 전달됩니다 . 이 인수를 &lt;a href=&quot;../values/lists#argument-lists&quot;&gt;인수 목록&lt;/a&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="638691b864cb05325bd7992b94b7474184591d49" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to see the value of a &lt;a href=&quot;../variables&quot;&gt;variable&lt;/a&gt; or &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; while you&amp;rsquo;re developing your stylesheet. That&amp;rsquo;s what the &lt;code&gt;@debug&lt;/code&gt; rule is for: it&amp;rsquo;s written &lt;code&gt;@debug &amp;lt;expression&amp;gt;&lt;/code&gt;, and it prints the value of that expression, along with the filename and line number.</source>
          <target state="translated">스타일 시트를 개발하는 동안 &lt;a href=&quot;../variables&quot;&gt;변수&lt;/a&gt; 또는 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;표현식&lt;/a&gt; 의 값을 확인하는 것이 유용 할 때도 있습니다 . 이것이 &lt;code&gt;@debug&lt;/code&gt; 규칙의 목적입니다. &lt;code&gt;@debug &amp;lt;expression&amp;gt;&lt;/code&gt; 으로 작성 되고 파일 이름 및 줄 번호와 함께 해당 표현식의 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="de837228c307548c576c781e6e2aace1352e73cd" translate="yes" xml:space="preserve">
          <source>Sometimes it's useful to use a nested rule's parent selector in other ways than the default. For instance, you might want to have special styles for when that selector is hovered over or for when the body element has a certain class. In these cases, you can explicitly specify where the parent selector should be inserted using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. For example:</source>
          <target state="translated">경우에 따라 중첩 규칙의 부모 선택기를 기본값 이외의 다른 방법으로 사용하는 것이 유용합니다. 예를 들어, 선택기가 마우스 오버 될 때 또는 본문 요소에 특정 클래스가있는 경우에 대한 특수 스타일을 원할 수 있습니다. 이 경우 &lt;code&gt;&amp;amp;&lt;/code&gt; 문자를 사용하여 상위 선택기를 삽입 할 위치를 명시 적으로 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15075cef17f614335551b6872537859d19cd0f37" translate="yes" xml:space="preserve">
          <source>Sometimes you only want a property declaration to show up some of the time. If a declaration&amp;rsquo;s value is &lt;a href=&quot;../values/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; or an empty &lt;a href=&quot;../values/strings#unquoted&quot;&gt;unquoted string&lt;/a&gt;, Sass won&amp;rsquo;t compile that declaration to CSS at all.</source>
          <target state="translated">때로는 속성 선언이 일정 시간 동안 만 표시되기를 원합니다. 선언의 값이 &lt;a href=&quot;../values/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 이거나 &lt;a href=&quot;../values/strings#unquoted&quot;&gt;인용되지 않은&lt;/a&gt; 빈 문자열 인 경우 Sass는 해당 선언을 CSS로 전혀 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7253019e67572cdd9cb7df95fe8f2fec09a73e0d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to write a style rule that&amp;rsquo;s &lt;em&gt;only&lt;/em&gt; intended to be extended. In that case, you can use &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;placeholder selectors&lt;/a&gt;, which look like class selectors that start with &lt;code&gt;%&lt;/code&gt; instead of &lt;code&gt;.&lt;/code&gt;. Any selectors that include placeholders aren&amp;rsquo;t included in the CSS output, but selectors that extend them are.</source>
          <target state="translated">확장 &lt;em&gt;할&lt;/em&gt; 목적으로 &lt;em&gt;만&lt;/em&gt; 의도 된 스타일 규칙을 작성하고 싶을 때가 있습니다 . 이 경우 대신 &lt;code&gt;%&lt;/code&gt; 로 시작하는 클래스 선택기처럼 보이는 &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;자리 표시 자 선택기를&lt;/a&gt; 사용할 수 있습니다 &lt;code&gt;.&lt;/code&gt; . 자리 표시자를 포함하는 선택기는 CSS 출력에 포함되지 않지만이를 확장하는 선택기는 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0845a8f1f700d1c042600138ed83f134ce0b65" translate="yes" xml:space="preserve">
          <source>Sometimes you'll write styles for a class that you only ever want to &lt;code&gt;@extend&lt;/code&gt;, and never want to use directly in your HTML. This is especially true when writing a Sass library, where you may provide styles for users to &lt;code&gt;@extend&lt;/code&gt; if they need and ignore if they don't.</source>
          <target state="translated">때로는 &lt;code&gt;@extend&lt;/code&gt; 만하고 싶거나 HTML에서 직접 사용하고 싶지 않은 클래스의 스타일을 작성 하는 경우가 있습니다. 이것은 Sass 라이브러리를 작성할 때 특히 그렇습니다. 사용자가 필요하면 &lt;code&gt;@extend&lt;/code&gt; 로 스타일을 제공 하고 필요하지 않으면 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="043702c4e4501889e7730a9fb7aa95851a7a377c" translate="yes" xml:space="preserve">
          <source>Sometimes, though, you want to allow an &lt;code&gt;@extend&lt;/code&gt; not to produce any new selectors. To do so, just add the &lt;code&gt;!optional&lt;/code&gt; flag after the selector. For example:</source>
          <target state="translated">그러나 때로는 &lt;code&gt;@extend&lt;/code&gt; 가 새로운 선택자를 생성하지 못하게 할 수 있습니다. 이렇게하려면 선택기 뒤에 &lt;code&gt;!optional&lt;/code&gt; 플래그를 추가하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8fb5d37f19dc5afc9bd658c4a0cfdc8b9c40414" translate="yes" xml:space="preserve">
          <source>Sometimes, you don&amp;rsquo;t want to forward &lt;em&gt;every&lt;/em&gt; member from a module. You may want to keep some members private so that only your package can use them, or you may want to require your users to load some members a different way. You can control exactly which members get forwarded by writing &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot; hide &amp;lt;members...&amp;gt;&lt;/code&gt; or &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot; show &amp;lt;members...&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">때로는 모듈의 &lt;em&gt;모든&lt;/em&gt; 구성원 을 전달하고 싶지 않을 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 패키지 만 사용할 수 있도록 일부 구성원을 비공개로 유지하거나 사용자가 일부 구성원을 다른 방식으로로드하도록 요구할 수 있습니다. &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot; hide &amp;lt;members...&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot; show &amp;lt;members...&amp;gt;&lt;/code&gt; 를 작성하여 전달할 구성원을 정확하게 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5774da7b802f7af9150c4273aaf57f7387c8eb1d" translate="yes" xml:space="preserve">
          <source>Source Maps</source>
          <target state="translated">소스 맵</target>
        </trans-unit>
        <trans-unit id="65399d0ea1cef2d124f5e222cb41a41015dc0477" translate="yes" xml:space="preserve">
          <source>Source maps are files that tell browsers or other tools that consume CSS how that CSS corresponds to the Sass files from which it was generated. They make it possible to see and even edit your Sass files in browsers. See instructions for using source maps in &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps&quot;&gt;Chrome&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Style_Editor#Source_map_support&quot;&gt;Firefox&lt;/a&gt;.</source>
          <target state="translated">소스 맵은 CSS를 사용하는 브라우저 또는 기타 도구에 CSS가 생성 된 Sass 파일에 해당하는 방식을 알려주는 파일입니다. 브라우저에서 Sass 파일을보고 편집 할 수도 있습니다. &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps&quot;&gt;Chrome&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Style_Editor#Source_map_support&quot;&gt;Firefox&lt;/a&gt; 에서 소스 맵 사용에 대한 안내를 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="2ca36f19363605580ce8ff8c0b8ba94b1548e941" translate="yes" xml:space="preserve">
          <source>Special Functions</source>
          <target state="translated">특수 기능</target>
        </trans-unit>
        <trans-unit id="cb5cdb4d83d13dcb9044f5371c6dcdabd5610f8d" translate="yes" xml:space="preserve">
          <source>Special functions</source>
          <target state="translated">특수 기능</target>
        </trans-unit>
        <trans-unit id="1d10323c27ec5f9982ad73377fd582ff949840f8" translate="yes" xml:space="preserve">
          <source>Standalone</source>
          <target state="translated">Standalone</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="781a867e9de4908f79fe38c77c92d50f5d889295" translate="yes" xml:space="preserve">
          <source>Still returns true even if &lt;code&gt;$super&lt;/code&gt; matches &lt;em&gt;more&lt;/em&gt; elements than &lt;code&gt;$sub&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$super&lt;/code&gt; 가 &lt;code&gt;$sub&lt;/code&gt; 보다 &lt;em&gt;많은&lt;/em&gt; 요소 와 일치 하더라도 여전히 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9af895dea7d1df874079777fbd39a8b66ee1f435" translate="yes" xml:space="preserve">
          <source>String Indexes</source>
          <target state="translated">문자열 인덱스</target>
        </trans-unit>
        <trans-unit id="905138067416afbda69a807c2dbf96fa6f2ae8dd" translate="yes" xml:space="preserve">
          <source>String Operations</source>
          <target state="translated">문자열 연산</target>
        </trans-unit>
        <trans-unit id="27b5731f3ec14f393ba8332d57e541a658e0f241" translate="yes" xml:space="preserve">
          <source>String Operators</source>
          <target state="translated">문자열 연산자</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">문자열 연산</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="b36b4bf7e1749dda82b6b7f07a772067f3f1d4c8" translate="yes" xml:space="preserve">
          <source>Strings #sass-script-strings</source>
          <target state="translated">문자열 # sass-script-strings</target>
        </trans-unit>
        <trans-unit id="f7cc4cbb7491950861a99a5d073ec4ccae816299" translate="yes" xml:space="preserve">
          <source>Strings are sequences of characters (specifically &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;Unicode code points&lt;/a&gt;). Sass supports two kinds of strings whose internal structure is the same but which are rendered differently: &lt;a href=&quot;#quoted&quot;&gt;quoted strings&lt;/a&gt;, like &lt;code&gt;&quot;Helvetica Neue&quot;&lt;/code&gt;, and &lt;a href=&quot;#unquoted&quot;&gt;unquoted strings&lt;/a&gt; (also known as &lt;em&gt;identifiers&lt;/em&gt;), like &lt;code&gt;bold&lt;/code&gt;. Together, these cover the different kinds of text that appear in CSS.</source>
          <target state="translated">문자열은 일련의 문자 (특히 &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_point&quot;&gt;유니 코드 코드 포인트&lt;/a&gt; )입니다. : 사스 내부 구조 같지만 다르게 렌더링 된 문자열 두 종류의 지원 &lt;a href=&quot;#quoted&quot;&gt;인용 문자열을&lt;/a&gt; 원한다면, &lt;code&gt;&quot;Helvetica Neue&quot;&lt;/code&gt; 및 &lt;a href=&quot;#unquoted&quot;&gt;인용되지 않은 문자열&lt;/a&gt; (라고도 &lt;em&gt;식별자&lt;/em&gt; 등), &lt;code&gt;bold&lt;/code&gt; . 함께 CSS에 나타나는 다양한 종류의 텍스트를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="c8b7bcfcaa8b48cf4e7f414a5fda711253e9e86e" translate="yes" xml:space="preserve">
          <source>Structure of a Stylesheet</source>
          <target state="translated">스타일 시트의 구조</target>
        </trans-unit>
        <trans-unit id="54d18fc7c92dafab4d4826d2656548e1f06e5d63" translate="yes" xml:space="preserve">
          <source>Style Rules</source>
          <target state="translated">스타일 규칙</target>
        </trans-unit>
        <trans-unit id="6c50a97969161ac3123602bb3cb47e1e89a746ba" translate="yes" xml:space="preserve">
          <source>Style rules are the foundation of Sass, just like they are for CSS. And they work the same way: you choose which elements to style with a selector, and &lt;a href=&quot;style-rules/declarations&quot;&gt;declare properties&lt;/a&gt; that affect how those elements look.</source>
          <target state="translated">스타일 규칙은 CSS와 마찬가지로 Sass의 기초입니다. 또한 동일한 방식으로 작동합니다. 선택기로 스타일을 지정할 요소를 선택하고 해당 요소의 모양에 영향을주는 &lt;a href=&quot;style-rules/declarations&quot;&gt;속성&lt;/a&gt; 을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="391aa759e0f627e3cb08a330a5127ac56b6fa86a" translate="yes" xml:space="preserve">
          <source>Subtraction, Negative Numbers, and &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">빼기, 음수 및 &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="f58a1a1b995bb6193210ff877811ca67724e98f1" translate="yes" xml:space="preserve">
          <source>Syntax Selection</source>
          <target state="translated">구문 선택</target>
        </trans-unit>
        <trans-unit id="06bda05a8b16ee488a4324d815b666ba4c8fb984" translate="yes" xml:space="preserve">
          <source>Taking Arbitrary Arguments</source>
          <target state="translated">임의의 주장을하기</target>
        </trans-unit>
        <trans-unit id="935c2523e729956822e96e5ae256d27cdd1bee57" translate="yes" xml:space="preserve">
          <source>Taking Arbitrary Keyword Arguments</source>
          <target state="translated">임의의 키워드 인수 취하기</target>
        </trans-unit>
        <trans-unit id="1df350cc36b8067fbef394752946ccef525865c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module&quot;&gt;module migrator&lt;/a&gt; assumes that any stylesheet that is depended on using a &lt;a href=&quot;../at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt; or a &lt;a href=&quot;../at-rules/forward&quot;&gt;&lt;code&gt;@forward&lt;/code&gt; rule&lt;/a&gt; has already been migrated to the module system, so it won&amp;rsquo;t attempt to migrate them, even when the &lt;code&gt;--migrate-deps&lt;/code&gt; option is passed.</source>
          <target state="translated">&lt;a href=&quot;#module&quot;&gt;모듈 Migrator를가&lt;/a&gt; 사용에 의존하는 모든 스타일 있다고 가정 &lt;a href=&quot;../at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 의 규칙&lt;/a&gt; 또는 &lt;a href=&quot;../at-rules/forward&quot;&gt; &lt;code&gt;@forward&lt;/code&gt; 의 규칙이&lt;/a&gt; 그들 마이그레이션을 시도하지 않습니다 있도록 경우에도 이미 모듈 시스템으로 마이그레이션 된 &lt;code&gt;--migrate-deps&lt;/code&gt; 옵션입니다 통과했습니다.</target>
        </trans-unit>
        <trans-unit id="a35dc086e1aba5e6f5680ea344f3541b4641a187" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#single-equals&quot;&gt;&lt;code&gt;=&lt;/code&gt; operator&lt;/a&gt;, when it&amp;rsquo;s available.</source>
          <target state="translated">&lt;a href=&quot;#single-equals&quot;&gt; &lt;code&gt;=&lt;/code&gt; 연산자는&lt;/a&gt; , 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6fb1156c24130389f0a5c30c31228891820b439" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../at-rules/at-root&quot;&gt;&lt;code&gt;@at-root&lt;/code&gt; rule&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../at-rules/at-root&quot;&gt; &lt;code&gt;@at-root&lt;/code&gt; 규칙&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7af532e60d3ebbaf37412d839134df1e45749782" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../at-rules/error&quot;&gt;&lt;code&gt;@error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../at-rules/warn&quot;&gt;&lt;code&gt;@warn&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../at-rules/debug&quot;&gt;&lt;code&gt;@debug&lt;/code&gt;&lt;/a&gt; rules.</source>
          <target state="translated">&lt;a href=&quot;../at-rules/error&quot;&gt; &lt;code&gt;@error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../at-rules/warn&quot;&gt; &lt;code&gt;@warn&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../at-rules/debug&quot;&gt; &lt;code&gt;@debug&lt;/code&gt; 의&lt;/a&gt; 규칙.</target>
        </trans-unit>
        <trans-unit id="e279da5dc12be931a6b03f93cccc63f265420ed7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../at-rules/extend&quot;&gt;&lt;code&gt;@extend&lt;/code&gt; rule&lt;/a&gt; may only be used within style rules.</source>
          <target state="translated">&lt;a href=&quot;../at-rules/extend&quot;&gt; &lt;code&gt;@extend&lt;/code&gt; 의 규칙은&lt;/a&gt; 단지 스타일 규칙 내에서 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="e764626fb8b6b9c1761d43c7e39c8dbac88e0256" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../at-rules/import&quot;&gt;&lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; put all top-level members in one global scope, so when it was the standard way of loading stylesheets, everyone was incentivized to add prefixes to all their member names to avoid accidentally redefining some other stylesheet&amp;rsquo;s. The module system solves this problem, so it&amp;rsquo;s useful to automatically strip those old prefixes now that they&amp;rsquo;re unnecessary.</source>
          <target state="translated">&lt;a href=&quot;../at-rules/import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; 의 규칙&lt;/a&gt; 이로드 스타일 시트의 표준 방법이었다 그렇게 할 때, 하나 개의 글로벌 범위에 모든 최상위 멤버를 넣어, 모두 다른 스타일 시트의 재정의 실수 피하기 위해 모든 구성원 이름에 접두사를 추가 인센티브했다. 모듈 시스템은이 문제를 해결하므로 불필요한 이전 접두사를 자동으로 제거하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="07acd81e46c0a7ab120f6274a1e06d58df71e026" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../modules#if&quot;&gt;&lt;code&gt;if()&lt;/code&gt; function&lt;/a&gt; returns one value if its argument is &lt;code&gt;true&lt;/code&gt; and another if its argument is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../modules#if&quot;&gt; &lt;code&gt;if()&lt;/code&gt; 함수가&lt;/a&gt; 인수 인 경우 하나 개의 값을 반환 &lt;code&gt;true&lt;/code&gt; 과 또 다른 인수 인 경우 &lt;code&gt;false&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9816be82754bef9a251b615fcd56acfd706e26c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;indented syntax&lt;/a&gt; has a special syntax for defining and using mixins, in addition to the standard &lt;code&gt;@mixin&lt;/code&gt; and &lt;code&gt;@include&lt;/code&gt;. Mixins are defined using the character &lt;code&gt;=&lt;/code&gt;, and they&amp;rsquo;re included using &lt;code&gt;+&lt;/code&gt;. Although this syntax is terser, it&amp;rsquo;s also harder to understand at a glance and users are encouraged to avoid it.</source>
          <target state="translated">&lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;들여 쓰기 구문은&lt;/a&gt; 표준에 추가로 정의하고 유지 mixin을 사용하기위한 특수 구문이 &lt;code&gt;@mixin&lt;/code&gt; 및 &lt;code&gt;@include&lt;/code&gt; 을 . 믹스 인은 문자 &lt;code&gt;=&lt;/code&gt; 를 사용하여 정의 되며 &lt;code&gt;+&lt;/code&gt; 를 사용하여 포함됩니다 . 이 구문은 간결하지만 한눈에 이해하기 어렵고 사용자는이를 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="546e68a86c3bae99e2cda1604fb5f3b73ff303c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../values/booleans&quot;&gt;boolean&lt;/a&gt; literals &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../values/booleans&quot;&gt;부울&lt;/a&gt; 리터럴 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43966c7793685352c760e920ff46480362a4ce1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes&quot;&gt;&lt;code&gt;@keyframes&lt;/code&gt; rule&lt;/a&gt; works just like a general at-rule, except that its child rules must be valid keyframe rules (&lt;code&gt;&amp;lt;number&amp;gt;%&lt;/code&gt;, &lt;code&gt;from&lt;/code&gt;, or &lt;code&gt;to&lt;/code&gt;) rather than normal selectors.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes&quot;&gt; &lt;code&gt;@keyframes&lt;/code&gt; 는 지배&lt;/a&gt; 하위 규칙 (유효 키 프레임 규칙해야한다는 점을 제외하고 단지에서 규칙 일반 같은 작품, &lt;code&gt;&amp;lt;number&amp;gt;%&lt;/code&gt; , &lt;code&gt;from&lt;/code&gt; , 또는 &lt;code&gt;to&lt;/code&gt; ) 오히려 정상보다 선택기.</target>
        </trans-unit>
        <trans-unit id="c3c7db39bce25a15f11f3de9502b2243b480cd04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@supports&quot;&gt;&lt;code&gt;@supports&lt;/code&gt; rule&lt;/a&gt; also allows &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript expressions&lt;/a&gt; to be used in the declaration queries.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@supports&quot;&gt; &lt;code&gt;@supports&lt;/code&gt; 는 규칙&lt;/a&gt; 도 있습니다 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript 표현식&lt;/a&gt; 선언 쿼리에 사용되는.</target>
        </trans-unit>
        <trans-unit id="4d9a8ca1113531c6caee68650fcde23a31203429" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries&quot;&gt;&lt;code&gt;@media&lt;/code&gt; rule&lt;/a&gt; does all of the above and more. In addition to allowing interpolation, it allows &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript expressions&lt;/a&gt; to be used directly in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries#Targeting_media_features&quot;&gt;feature queries&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries&quot;&gt; &lt;code&gt;@media&lt;/code&gt; 의 규칙은&lt;/a&gt; 위 더의 모든 작업을 수행합니다. 보간을 허용하는 것 외에도 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries#Targeting_media_features&quot;&gt;기능 쿼리&lt;/a&gt; 에서 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript 표현식&lt;/a&gt; 을 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32b754ca442416d6b24fdf2b658f5e4777f3dafb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/calc&quot;&gt;&lt;code&gt;calc()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/element&quot;&gt;&lt;code&gt;element()&lt;/code&gt;&lt;/a&gt; functions are defined in the CSS spec. Because &lt;code&gt;calc()&lt;/code&gt;&amp;rsquo;s mathematical expressions conflict with Sass&amp;rsquo;s arithmetic, and &lt;code&gt;element()&lt;/code&gt;&amp;rsquo;s IDs could be parsed as colors, they need special parsing.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/calc&quot;&gt; &lt;code&gt;calc()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/element&quot;&gt; &lt;code&gt;element()&lt;/code&gt; &lt;/a&gt; 함수는 CSS 규격에 정의되어있다. 때문에 &lt;code&gt;calc()&lt;/code&gt; '말대꾸의 연산과와의 수학적 표현의 갈등 &lt;code&gt;element()&lt;/code&gt; 의 ID를 색상으로 해석 될 수있다, 그들은 특별한 구문 분석이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b3644104902986cb6220a6dbc81e265a8112f51c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/url&quot;&gt;&lt;code&gt;url()&lt;/code&gt; function&lt;/a&gt; is commonly used in CSS, but its syntax is different than other functions: it can take either a quoted &lt;em&gt;or&lt;/em&gt; unquoted URL. Because an unquoted URL isn&amp;rsquo;t a valid SassScript expression, Sass needs special logic to parse it.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/url&quot;&gt; &lt;code&gt;url()&lt;/code&gt; 함수는&lt;/a&gt; 일반적으로 CSS에서 사용되지만, 그 구문은 다른 기능과 다른 : 그것은 하나 인용 걸릴 수 있습니다 &lt;em&gt;또는&lt;/em&gt; 인용 부호가없는 URL을. 인용되지 않은 URL은 유효한 SassScript 표현식이 아니기 때문에 Sass는이를 구문 분석하기위한 특별한 논리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="504c598702deb5ae9c07c5b795fd6eea9ac69750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Exit_status&quot;&gt;exit status&lt;/a&gt; that should be used if this error causes the enclosing program to exit.</source>
          <target state="translated">이 오류로 인해 엔 클로징 프로그램이 종료되는 경우 사용해야 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Exit_status&quot;&gt;종료 상태&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="90a7c84d55aa25b6f5ccfeaf9b8e39ab88891aa5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules/color&quot;&gt;&lt;code&gt;sass:color&lt;/code&gt; module&lt;/a&gt; generates new &lt;a href=&quot;values/colors&quot;&gt;colors&lt;/a&gt; based on existing ones, making it easy to build color themes.</source>
          <target state="translated">&lt;a href=&quot;modules/color&quot;&gt; &lt;code&gt;sass:color&lt;/code&gt; 모듈은&lt;/a&gt; 새로운 생성 &lt;a href=&quot;values/colors&quot;&gt;색상&lt;/a&gt; 빌드 색상 테마에 쉽게 그것을 만들기, 기존 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="86c32d20d922c8144b235390be507cfe7a7bcfdc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules/list&quot;&gt;&lt;code&gt;sass:list&lt;/code&gt; module&lt;/a&gt; lets you access and modify values in &lt;a href=&quot;values/lists&quot;&gt;lists&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;modules/list&quot;&gt; &lt;code&gt;sass:list&lt;/code&gt; 모듈&lt;/a&gt; 에 액세스하고 값을 수정할 수 있습니다 &lt;a href=&quot;values/lists&quot;&gt;나열합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a3348385f1cc4573040876c2576083f07e6df79" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules/map&quot;&gt;&lt;code&gt;sass:map&lt;/code&gt; module&lt;/a&gt; makes it possible to look up the value associated with a key in a &lt;a href=&quot;values/maps&quot;&gt;map&lt;/a&gt;, and much more.</source>
          <target state="translated">&lt;a href=&quot;modules/map&quot;&gt; &lt;code&gt;sass:map&lt;/code&gt; 모듈&lt;/a&gt; 것이 가능 A의 키에 관련 지을 수 있었던 값 찾아 볼 수 있습니다 &lt;a href=&quot;values/maps&quot;&gt;지도&lt;/a&gt; 훨씬 더하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8865eb3b8e8ce060456ad6e1ba1c735fc530d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules/math&quot;&gt;&lt;code&gt;sass:math&lt;/code&gt; module&lt;/a&gt; provides functions that operate on &lt;a href=&quot;values/numbers&quot;&gt;numbers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;modules/math&quot;&gt; &lt;code&gt;sass:math&lt;/code&gt; 모듈&lt;/a&gt; 에서 작동 기능을 제공합니다 &lt;a href=&quot;values/numbers&quot;&gt;번호를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90c727a3c07ed26c23654ef3b56ebfba2c2d06c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules/meta&quot;&gt;&lt;code&gt;sass:meta&lt;/code&gt; module&lt;/a&gt; exposes the details of Sass&amp;rsquo;s inner workings.</source>
          <target state="translated">&lt;a href=&quot;modules/meta&quot;&gt; &lt;code&gt;sass:meta&lt;/code&gt; 모듈은&lt;/a&gt; 사스의 내부 동작의 세부 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="110e0cd56b20ddb998588a804d44d1ea832def3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules/selector&quot;&gt;&lt;code&gt;sass:selector&lt;/code&gt; module&lt;/a&gt; provides access to Sass&amp;rsquo;s powerful selector engine.</source>
          <target state="translated">&lt;a href=&quot;modules/selector&quot;&gt; &lt;code&gt;sass:selector&lt;/code&gt; 모듈은&lt;/a&gt; 사스의 강력한 셀렉터 엔진에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="54dfcea8115cb33be27886c112e9c90f72682507" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;modules/string&quot;&gt;&lt;code&gt;sass:string&lt;/code&gt; module&lt;/a&gt; makes it easy to combine, search, or split apart &lt;a href=&quot;values/strings&quot;&gt;strings&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;modules/string&quot;&gt; &lt;code&gt;sass:string&lt;/code&gt; 모듈은&lt;/a&gt; 쉽게, 통합 검색, 또는 따로 따로 분리 할 수 있습니다 &lt;a href=&quot;values/strings&quot;&gt;문자열을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89e281de7fe71f9d7e978e0dcc7f0c975ef7cc4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;operators/boolean&quot;&gt;&lt;code&gt;and&lt;/code&gt; operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;operators/boolean&quot;&gt; &lt;code&gt;and&lt;/code&gt; 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea7bd2e4f24204137c741038b95fe2e8c73c0b40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;operators/boolean&quot;&gt;&lt;code&gt;or&lt;/code&gt; operator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;operators/boolean&quot;&gt; &lt;code&gt;or&lt;/code&gt; 오퍼레이터&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5b6172d556d839b7898b61eaa922d25bd4d4cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;operators/equality&quot;&gt;&lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; operators&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;operators/equality&quot;&gt; &lt;code&gt;==&lt;/code&gt; 와 &lt;code&gt;!=&lt;/code&gt; 연산자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ae555915d9d54310df43b693be8ea1864d4d676" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;operators/numeric&quot;&gt;&lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; operators&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;operators/numeric&quot;&gt; &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , 그리고 &lt;code&gt;%&lt;/code&gt; 의 운영자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59563c809c27268f326e609b737862755c99a72f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;operators/numeric&quot;&gt;&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; operators&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;operators/numeric&quot;&gt; &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;-&lt;/code&gt; 연산자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="618c79b16e0882a5777cca82b8bf498f8d9fe33e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;operators/relational&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;lt;=&lt;/code&gt; operators&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;operators/relational&quot;&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;=&lt;/code&gt; 연산자를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa9ba7d7d8e02a7b1a43b44f6f7cc825694f46c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;values/booleans&quot;&gt;boolean&lt;/a&gt; values &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;values/booleans&quot;&gt;부울&lt;/a&gt; 값 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d27406385a4e5687c92af81ead0967b4f6262d2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!global&lt;/code&gt; flag may only be used to set a variable that has already been declared at the top level of a file. It &lt;em&gt;may not&lt;/em&gt; be used to declare a new variable.</source>
          <target state="translated">&lt;code&gt;!global&lt;/code&gt; 플래그는 이미 파일의 최상위에서 선언 된 변수를 설정하는 데 사용할 수 있습니다. &lt;em&gt;하지 않을 수 있습니다&lt;/em&gt; 새 변수를 선언하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="3f97e42d9d5b69a774e97737b80e7f4c2688e12c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;!optional&lt;/code&gt; Flag</source>
          <target state="translated">&lt;code&gt;!optional&lt;/code&gt; 신고</target>
        </trans-unit>
        <trans-unit id="c03f67f369a61677f5c02cee6e2182a58640cf23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$amount&lt;/code&gt; must be a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive). Decreases the HSL lightness of &lt;code&gt;$color&lt;/code&gt; by that amount.</source>
          <target state="translated">&lt;code&gt;$amount&lt;/code&gt; 사이의 숫자 여야 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; (포함). &lt;code&gt;$color&lt;/code&gt; 의 HSL 밝기를 그만큼 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b120dd6580b4c5c0e4798be85af712083941d6b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$amount&lt;/code&gt; must be a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive). Decreases the HSL saturation of &lt;code&gt;$color&lt;/code&gt; by that amount.</source>
          <target state="translated">&lt;code&gt;$amount&lt;/code&gt; 사이의 숫자 여야 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; (포함). 해당 금액만큼 &lt;code&gt;$color&lt;/code&gt; 의 HSL 채도 를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="4783522ab9ae33f630fd170459e21adcb50e4681" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$amount&lt;/code&gt; must be a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive). Increases the HSL lightness of &lt;code&gt;$color&lt;/code&gt; by that amount.</source>
          <target state="translated">&lt;code&gt;$amount&lt;/code&gt; 사이의 숫자 여야 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; (포함). &lt;code&gt;$color&lt;/code&gt; 의 HSL 밝기를 그만큼 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="bd3b5d2ada6b2cb60ba3837b90e51002801935ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$amount&lt;/code&gt; must be a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive). Increases the HSL saturation of &lt;code&gt;$color&lt;/code&gt; by that amount.</source>
          <target state="translated">&lt;code&gt;$amount&lt;/code&gt; 사이의 숫자 여야 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; (포함). &lt;code&gt;$color&lt;/code&gt; 의 HSL 채도를 해당 양만큼 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="96994319d0eea47efaf2c2a413bfc6b197f92c8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$amount&lt;/code&gt; must be a number between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; (inclusive). Decreases the alpha channel of &lt;code&gt;$color&lt;/code&gt; by that amount.</source>
          <target state="translated">&lt;code&gt;$amount&lt;/code&gt; 사이의 숫자 여야 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; (포함). 그 양만큼 &lt;code&gt;$color&lt;/code&gt; 의 알파 채널 을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7a720d48c684b3afc6f3e93caf13808a416c260f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$amount&lt;/code&gt; must be a number between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; (inclusive). Increases the alpha channel of &lt;code&gt;$color&lt;/code&gt; by that amount.</source>
          <target state="translated">&lt;code&gt;$amount&lt;/code&gt; 사이의 숫자 여야 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; (포함). 그 양만큼 &lt;code&gt;$color&lt;/code&gt; 의 알파 채널을 늘 립니다.</target>
        </trans-unit>
        <trans-unit id="ba4101ab4f45dcc288c144bb1dfb9e8553917722" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$feature&lt;/code&gt; must be a string. The currently recognized features are:</source>
          <target state="translated">&lt;code&gt;$feature&lt;/code&gt; 문자열이어야합니다. 현재 인식되는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac782584e5608fef03b3c8ec321127fef4a8c4f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$function&lt;/code&gt; should be a &lt;a href=&quot;../values/functions&quot;&gt;function&lt;/a&gt; returned by &lt;a href=&quot;#get-function&quot;&gt;&lt;code&gt;meta.get-function()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$function&lt;/code&gt; 해야 &lt;a href=&quot;../values/functions&quot;&gt;함수&lt;/a&gt; 에 의해 반환 &lt;a href=&quot;#get-function&quot;&gt; &lt;code&gt;meta.get-function()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7211fa6409e40acd2c882d6480c1c5b61f6af84b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$hue&lt;/code&gt; must be a number between &lt;code&gt;-360deg&lt;/code&gt; and &lt;code&gt;360deg&lt;/code&gt; (inclusive) to add to &lt;code&gt;$color&lt;/code&gt;&amp;rsquo;s hue. It may be &lt;a href=&quot;../values/numbers#units&quot;&gt;unitless&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$hue&lt;/code&gt; 사이의 숫자 여야합니다 &lt;code&gt;-360deg&lt;/code&gt; 와 &lt;code&gt;360deg&lt;/code&gt; (포함)을 추가 할 &lt;code&gt;$color&lt;/code&gt; 의 색조. &lt;a href=&quot;../values/numbers#units&quot;&gt;단위&lt;/a&gt; 가 없을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b40d85f830bf5953f725bc895e473ddd4a7dc3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$module&lt;/code&gt; parameter must be a string matching the namespace of a &lt;a href=&quot;../at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt; in the current file.</source>
          <target state="translated">&lt;code&gt;$module&lt;/code&gt; 매개 변수는의 네임 스페이스와 일치하는 문자열이어야합니다 &lt;a href=&quot;../at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 의 규칙&lt;/a&gt; 현재 파일을.</target>
        </trans-unit>
        <trans-unit id="9dc3b8b704898c3d531f3c842fb6eedd2bfc28bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$selector&lt;/code&gt; must be a single string that contains a compound selector. This means it may not contains combinators (including spaces) or commas.</source>
          <target state="translated">&lt;code&gt;$selector&lt;/code&gt; 복합 선택기를 포함하는 단일 문자열이어야합니다. 이는 결합 자 (공백 포함) 또는 쉼표를 포함 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7658cf7eadbd403e669ddf2edbac3c571d5fef04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$selector&lt;/code&gt;, &lt;code&gt;$extendee&lt;/code&gt;, and &lt;code&gt;$extender&lt;/code&gt; selectors may contain &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;placeholder selectors&lt;/a&gt;, but not &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;parent selectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$selector&lt;/code&gt; , &lt;code&gt;$extendee&lt;/code&gt; , 및 &lt;code&gt;$extender&lt;/code&gt; 선택기 포함 할 수 있습니다 &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;자리 선택기&lt;/a&gt; ,하지만 &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;부모 선택기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8718d6667f1564575e7b546a27af7454cbde19ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$selector&lt;/code&gt;, &lt;code&gt;$original&lt;/code&gt;, and &lt;code&gt;$replacement&lt;/code&gt; selectors may contain &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;placeholder selectors&lt;/a&gt;, but not &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;parent selectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$selector&lt;/code&gt; , &lt;code&gt;$original&lt;/code&gt; , 및 &lt;code&gt;$replacement&lt;/code&gt; 선택기 포함 할 수 있습니다 &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;자리 선택기&lt;/a&gt; ,하지만 &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;부모 선택기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75c3eb689436931e9df15f8b6398ac7260b7905b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$selectors&lt;/code&gt; may contain &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;placeholder selectors&lt;/a&gt;, but not &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;parent selectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$selectors&lt;/code&gt; 포함 할 수 있습니다 &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;자리 선택기&lt;/a&gt; ,하지만 &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;부모 선택기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99c3b1aeb37bcaae820907bf62915cfbd3f2307f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$selectors&lt;/code&gt; may contain &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;placeholder selectors&lt;/a&gt;. Unlike other selector functions, all of them except the first may also contain &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;parent selectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$selectors&lt;/code&gt; 포함 할 수 있습니다 &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;자리 선택기&lt;/a&gt; . 다른 선택기 함수와 달리 첫 번째를 제외한 모든 함수는 &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;부모 선택자를&lt;/a&gt; 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f27e43e203c7e00de5997156048f34462d3a1542" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$super&lt;/code&gt; and &lt;code&gt;$sub&lt;/code&gt; selectors may contain &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;placeholder selectors&lt;/a&gt;, but not &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;parent selectors&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;$super&lt;/code&gt; 과 &lt;code&gt;$sub&lt;/code&gt; 선택자는 포함 할 수 있습니다 &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;자리 선택기&lt;/a&gt; ,하지만 &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;부모 선택기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd3aff068e048b533a1aaff4551bf95e22adb6e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$url&lt;/code&gt; parameter should be a string containing a URL like you&amp;rsquo;d pass to the &lt;code&gt;@use&lt;/code&gt; rule. It shouldn&amp;rsquo;t be a CSS&lt;code&gt;url()&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;$url&lt;/code&gt; 당신이에 전달할 것처럼 매개 변수는 URL을 포함하는 문자열을해야 &lt;code&gt;@use&lt;/code&gt; 의 규칙입니다. CSS &lt;code&gt;url()&lt;/code&gt; 이 아니어야합니다 !</target>
        </trans-unit>
        <trans-unit id="b770a67f5aa20b7b21c52621dfdd1dd135413c4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$weight&lt;/code&gt; must be a number between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive). A higher weight means the result will be closer to the negative, and a lower weight means it will be closer to &lt;code&gt;$color&lt;/code&gt;. Weight &lt;code&gt;50%&lt;/code&gt; will always produce &lt;code&gt;#808080&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$weight&lt;/code&gt; 사이의 숫자 여야 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; (포함). 가중치가 높을수록 결과가 음수에 가까워지고 가중치가 낮을수록 &lt;code&gt;$color&lt;/code&gt; 가까워 집니다 . 가중치 &lt;code&gt;50%&lt;/code&gt; 는 항상 &lt;code&gt;#808080&lt;/code&gt; 을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="8d311629ed69e85e7c92883aa048934bd395d0f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; operation can be used to concatenate strings:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 의 작업은 CONCATENATE 문자열을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="021246515a78b57d10e8e4773809aa7f4e269719" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--force&lt;/code&gt; flag may not be passed alongside the &lt;a href=&quot;#watch&quot;&gt;&lt;code&gt;--watch&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 플래그는 함께 통과되지 않을 수 있습니다 &lt;a href=&quot;#watch&quot;&gt; &lt;code&gt;--watch&lt;/code&gt; 플래그&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="381872e396a2d6ecaafd47dffb57cd1bfbac87be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--indented&lt;/code&gt; flag is mostly useful when the input file is coming from &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;standard input&lt;/a&gt;, so its syntax can&amp;rsquo;t be automatically determined.</source>
          <target state="translated">&lt;code&gt;--indented&lt;/code&gt; 입력 파일에서 오는 경우 플래그는 대부분 유용 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;표준 입력&lt;/a&gt; 의 구문을 자동으로 결정되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c6dc667716faa84c747765a410c6ba35f078cbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--stdin&lt;/code&gt; flag may not be used with &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; 옵션 플래그와 함께 사용할 수 없습니다 &lt;a href=&quot;#many-to-many-mode&quot;&gt;대다 모드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c26608f553246175e669b6188f4f161a429a8ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@at-root&lt;/code&gt; directive causes one or more rules to be emitted at the root of the document, rather than being nested beneath their parent selectors. It can either be used with a single inline selector:</source>
          <target state="translated">&lt;code&gt;@at-root&lt;/code&gt; 지시어는 하나 이상의 규칙의 원인은 오히려 상위 선택기 아래에 중첩되지 않고, 문서의 루트에 방출한다. 단일 인라인 선택기와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04f5bafe73a7ff06650944de798f295db701f68" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@at-root&lt;/code&gt; rule can also be written &lt;code&gt;@at-root { ... }&lt;/code&gt; to put multiple style rules at the root of the document. In fact, &lt;code&gt;@at-root &amp;lt;selector&amp;gt; { ... }&lt;/code&gt; is just a shorthand for &lt;code&gt;@at-root { &amp;lt;selector&amp;gt; { ... } }&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;@at-root&lt;/code&gt; 규칙은 쓸 수 &lt;code&gt;@at-root { ... }&lt;/code&gt; 문서의 루트에 여러 스타일 규칙을 넣어. 사실, &lt;code&gt;@at-root &amp;lt;selector&amp;gt; { ... }&lt;/code&gt; 는 &lt;code&gt;@at-root { &amp;lt;selector&amp;gt; { ... } }&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="d10060bbe79ec42d8b08aac9649783f8377b2880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@at-root&lt;/code&gt; rule is necessary here because Sass doesn&amp;rsquo;t know what interpolation was used to generate a selector when it&amp;rsquo;s performing selector nesting. This means it will automatically add the outer selector to the inner selector &lt;em&gt;even if&lt;/em&gt; you used &lt;code&gt;&amp;amp;&lt;/code&gt; as a SassScript expression. The &lt;code&gt;@at-root&lt;/code&gt; explicitly tells Sass not to include the outer selector.</source>
          <target state="translated">&lt;code&gt;@at-root&lt;/code&gt; 말대꾸 그것은 선택의 중첩을 수행 할 때 선택기를 생성하는 데 사용 된 것을 보간 모르기 때문에 규칙은 여기 필요하다. 즉, &lt;code&gt;&amp;amp;&lt;/code&gt; 를 SassScript 표현식으로 사용한 &lt;em&gt;경우에도&lt;/em&gt; 내부 선택기에 외부 선택기를 자동으로 추가합니다 . &lt;code&gt;@at-root&lt;/code&gt; 명시 적으로 외부 선택기를 포함하지 말대꾸를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="ce63364621e44c979ffebfe98601536e79b7cbb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@at-root&lt;/code&gt; rule is usually written &lt;code&gt;@at-root &amp;lt;selector&amp;gt; { ... }&lt;/code&gt; and causes everything within it to be emitted at the root of the document instead of using the normal nesting. It's most often used when doing &lt;a href=&quot;../style-rules/parent-selector#advanced-nesting&quot;&gt;advanced nesting&lt;/a&gt; with the &lt;a href=&quot;../style-rules/parent-selector#in-sassscript&quot;&gt;SassScript parent selector&lt;/a&gt; and &lt;a href=&quot;../modules/selector&quot;&gt;selector functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@at-root&lt;/code&gt; 규칙은 일반적으로 기록 &lt;code&gt;@at-root &amp;lt;selector&amp;gt; { ... }&lt;/code&gt; 하고 그것이 정상 중첩을 사용하는 대신 문서의 루트에서 방출되는 내 모든됩니다. &lt;a href=&quot;../style-rules/parent-selector#in-sassscript&quot;&gt;SassScript 상위 선택기&lt;/a&gt; 및 &lt;a href=&quot;../modules/selector&quot;&gt;선택기 함수로 &lt;/a&gt;&lt;a href=&quot;../style-rules/parent-selector#advanced-nesting&quot;&gt;고급 중첩&lt;/a&gt; 을 수행 할 때 가장 자주 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac97b233f713059167f62c0586b91e0e4ff02b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@debug&lt;/code&gt; directive prints the value of a SassScript expression to the standard error output stream. It's useful for debugging Sass files that have complicated SassScript going on. For example:</source>
          <target state="translated">&lt;code&gt;@debug&lt;/code&gt; 의 지시자는 표준 에러 출력 스트림 SassScript 식의 값을 출력한다. 복잡한 SassScript가 진행중인 Sass 파일을 디버깅하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a8de215b1d2afff58e3e0991266e337bff2243e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@each&lt;/code&gt; directive can also use multiple variables, as in &lt;code&gt;@each $var1, $var2, ... in &amp;lt;list&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; is a list of lists, each element of the sub-lists is assigned to the respective variable. For example:</source>
          <target state="translated">&lt;code&gt;@each&lt;/code&gt; 의 지침은 또한 같이 여러 변수를 사용할 수 있습니다 &lt;code&gt;@each $var1, $var2, ... in &amp;lt;list&amp;gt;&lt;/code&gt; . 경우 &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; 리스트의 목록이며, 서브리스트의 각 요소가 각각의 변수에 할당된다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="77189bcd5e4b0bc4e721a8a2a8712e0b92a9d123" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@each&lt;/code&gt; directive usually has the form &lt;code&gt;@each $var in &amp;lt;list or map&amp;gt;&lt;/code&gt;. &lt;code&gt;$var&lt;/code&gt; can be any variable name, like &lt;code&gt;$length&lt;/code&gt; or &lt;code&gt;$name&lt;/code&gt;, and &lt;code&gt;&amp;lt;list or map&amp;gt;&lt;/code&gt; is a SassScript expression that returns a list or a map.</source>
          <target state="translated">&lt;code&gt;@each&lt;/code&gt; 의 지시어는 일반적으로 양식이 &lt;code&gt;@each $var in &amp;lt;list or map&amp;gt;&lt;/code&gt; . &lt;code&gt;$var&lt;/code&gt; 어떤 변수 이름이 될 수 있습니다, 같은 &lt;code&gt;$length&lt;/code&gt; 또는 &lt;code&gt;$name&lt;/code&gt; , 그리고 &lt;code&gt;&amp;lt;list or map&amp;gt;&lt;/code&gt; SassScript의 표현을 반환 목록이나지도가.</target>
        </trans-unit>
        <trans-unit id="0225182baa7696b2fea683be8aa23850c2e7b5b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@each&lt;/code&gt; rule makes it easy to emit styles or evaluate code for each element of a &lt;a href=&quot;../../values/lists&quot;&gt;list&lt;/a&gt; or each pair in a &lt;a href=&quot;../../values/maps&quot;&gt;map&lt;/a&gt;. It&amp;rsquo;s great for repetitive styles that only have a few variations between them. It&amp;rsquo;s usually written &lt;code&gt;@each &amp;lt;variable&amp;gt; in &amp;lt;expression&amp;gt; { ... }&lt;/code&gt;, where the &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; returns a list. The block is evaluated for each element of the list in turn, which is assigned to the given variable name.</source>
          <target state="translated">&lt;code&gt;@each&lt;/code&gt; 의 규칙은 쉽게 스타일을 방출하거나의 각 요소에 대한 코드를 평가 할 수 있습니다 &lt;a href=&quot;../../values/lists&quot;&gt;목록&lt;/a&gt; 또는 각 쌍의 &lt;a href=&quot;../../values/maps&quot;&gt;지도&lt;/a&gt; . 몇 가지 변형 만있는 반복적 인 스타일에 적합합니다. 그것은 일반적으로 쓰여 &lt;code&gt;@each &amp;lt;variable&amp;gt; in &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; 의 경우 &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;표현&lt;/a&gt; 목록을 반환합니다. 블록은 주어진 변수 이름에 할당 된 목록의 각 요소에 대해 차례로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="a5d3e0da53895d6c2ca9b6d7ddf835e8c137ddc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@each&lt;/code&gt; rule sets &lt;code&gt;$var&lt;/code&gt; to each item in the list or map, then outputs the styles it contains using that value of &lt;code&gt;$var&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;@each&lt;/code&gt; 의 규칙을 설정 &lt;code&gt;$var&lt;/code&gt; 다음, 목록 또는지도에서 각 항목을 그것의 값 사용이 포함 된 스타일을 출력 &lt;code&gt;$var&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8e8db811f079dead4aec85b222dc1cd538b7717" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@error&lt;/code&gt; directive throws the value of a SassScript expression as a fatal error, including a nice stack trace. It's useful for validating arguments to mixins and functions. For example:</source>
          <target state="translated">&lt;code&gt;@error&lt;/code&gt; 의 지시어는 좋은 스택 추적을 포함 치명적인 오류와 같은 SassScript 식의 값을 던졌습니다. 믹스 인과 함수에 대한 인수의 유효성을 검사하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53f2c089e6de93b3ee7b8e635ec337c2a031aa8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@extend&lt;/code&gt; directive avoids these problems by telling Sass that one selector should inherit the styles of another selector. For example:</source>
          <target state="translated">&lt;code&gt;@extend&lt;/code&gt; 의 지시어는 하나 개의 선택이 다른 선택의 스타일을 상속해야한다고 말대꾸를 이야기함으로써 이러한 문제를 방지 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd24d6037176ab3406afa46dabd5e8fd0a66b44a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@for&lt;/code&gt; directive repeatedly outputs a set of styles. For each repetition, a counter variable is used to adjust the output. The directive has two forms: &lt;code&gt;@for $var from &amp;lt;start&amp;gt; through &amp;lt;end&amp;gt;&lt;/code&gt; and &lt;code&gt;@for $var from &amp;lt;start&amp;gt; to &amp;lt;end&amp;gt;&lt;/code&gt;. Note the difference in the keywords &lt;code&gt;through&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt;. &lt;code&gt;$var&lt;/code&gt; can be any variable name, like &lt;code&gt;$i&lt;/code&gt;; &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; are SassScript expressions that should return integers. When &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; is greater than &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; the counter will decrement instead of increment.</source>
          <target state="translated">&lt;code&gt;@for&lt;/code&gt; 지시자 반복적 스타일의 세트를 출력한다. 각 반복에 대해 카운터 변수를 사용하여 출력을 조정합니다. 이 지시문은 &lt;code&gt;@for $var from &amp;lt;start&amp;gt; through &amp;lt;end&amp;gt;&lt;/code&gt; 및 &lt;code&gt;@for $var from &amp;lt;start&amp;gt; to &amp;lt;end&amp;gt;&lt;/code&gt; 두 가지 형식이 있습니다. 키워드의 차이에주의 &lt;code&gt;through&lt;/code&gt; 하고 &lt;code&gt;to&lt;/code&gt; . &lt;code&gt;$var&lt;/code&gt; 는 &lt;code&gt;$i&lt;/code&gt; 와 같은 변수 이름 일 수 있습니다 . &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 는 정수를 반환해야하는 SassScript 표현식입니다. 경우 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 보다 큰 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 카운터 대신 증분 감소한다.</target>
        </trans-unit>
        <trans-unit id="d5d494b6f3937f7b3c60dc32eb0f3aaa113c3dc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@for&lt;/code&gt; rule, written &lt;code&gt;@for &amp;lt;variable&amp;gt; from &amp;lt;expression&amp;gt; to &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; or &lt;code&gt;@for &amp;lt;variable&amp;gt; from &amp;lt;expression&amp;gt; through &amp;lt;expression&amp;gt; { ... }&lt;/code&gt;, counts up or down from one number (the result of the first &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt;) to another (the result of the second) and evaluates a block for each number in between. Each number along the way is assigned to the given variable name. If &lt;code&gt;to&lt;/code&gt; is used, the final number is excluded; if &lt;code&gt;through&lt;/code&gt; is used, it's included.</source>
          <target state="translated">&lt;code&gt;@for&lt;/code&gt; 규칙은 서면 &lt;code&gt;@for &amp;lt;variable&amp;gt; from &amp;lt;expression&amp;gt; to &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; 또는 &lt;code&gt;@for &amp;lt;variable&amp;gt; from &amp;lt;expression&amp;gt; through &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; , 카운트 위 또는 아래 하나에서 number (첫 번째 &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;표현식&lt;/a&gt; 의 결과 )를 다른 표현식 ( 두 번째 표현식 의 결과)으로 바꾸고 그 사이의 각 숫자에 대해 블록을 평가합니다. 길을 따라 각 숫자는 주어진 변수 이름에 할당됩니다. 경우 &lt;code&gt;to&lt;/code&gt; 사용되며, 최종 숫자는 제외; &lt;code&gt;through&lt;/code&gt; 가 사용되는 경우 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6cc80ba19e8e34770568d4790b64ef08713b73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@for&lt;/code&gt; statement sets &lt;code&gt;$var&lt;/code&gt; to each successive number in the specified range and each time outputs the nested styles using that value of &lt;code&gt;$var&lt;/code&gt;. For the form &lt;code&gt;from ... through&lt;/code&gt;, the range &lt;em&gt;includes&lt;/em&gt; the values of &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, but the form &lt;code&gt;from ... to&lt;/code&gt; runs up to &lt;em&gt;but not including&lt;/em&gt; the value of &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;. Using the &lt;code&gt;through&lt;/code&gt; syntax,</source>
          <target state="translated">&lt;code&gt;@for&lt;/code&gt; 문은 설정 &lt;code&gt;$var&lt;/code&gt; 지정된 범위에있는 각 연속 된 번호로 각 시간의 값 사용하여 중첩 스타일을 출력 &lt;code&gt;$var&lt;/code&gt; . 폼 &lt;code&gt;from ... through&lt;/code&gt; 상기 범위를 &lt;em&gt;포함하는&lt;/em&gt; 의 값 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 하지만 형태 &lt;code&gt;from ... to&lt;/code&gt; 최대 실행 &lt;em&gt;되지만 제외한&lt;/em&gt; 값 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; . &lt;code&gt;through&lt;/code&gt; 구문을 사용하여</target>
        </trans-unit>
        <trans-unit id="d73c45d52c35f506c461be84582c5b2c7b61e21e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@forward&lt;/code&gt; rule acts just like &lt;code&gt;@use&lt;/code&gt; when it comes to a module&amp;rsquo;s CSS. Styles from a forwarded module will be included in the compiled CSS output, and the module with the &lt;code&gt;@forward&lt;/code&gt; can &lt;a href=&quot;extend&quot;&gt;extend&lt;/a&gt; it, even if it isn&amp;rsquo;t also &lt;code&gt;@use&lt;/code&gt;d.</source>
          <target state="translated">&lt;code&gt;@forward&lt;/code&gt; 의 규칙은 같은 역할을 &lt;code&gt;@use&lt;/code&gt; 이 모듈의 CSS에 관해서. 전달 된 모듈의 스타일은 컴파일 된 CSS 출력에 포함되며 &lt;code&gt;@forward&lt;/code&gt; 가 있는 모듈 은 &lt;code&gt;@use&lt;/code&gt; d 가 아니더라도이를 &lt;a href=&quot;extend&quot;&gt;확장&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9eba786d5218457f5f5148db81062de63448cdf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@forward&lt;/code&gt; rule can also load a module with &lt;a href=&quot;use#configuration&quot;&gt;configuration&lt;/a&gt;. This mostly works the same as it does for &lt;code&gt;@use&lt;/code&gt;, with one addition: a &lt;code&gt;@forward&lt;/code&gt; rule&amp;rsquo;s configuration can use the &lt;code&gt;!default&lt;/code&gt; flag in its configuration. This allows a module to change the defaults of an upstream stylesheet while still allowing downstream stylesheets to override them.</source>
          <target state="translated">&lt;code&gt;@forward&lt;/code&gt; 의 규칙은있는 모듈을로드 할 수 있습니다 &lt;a href=&quot;use#configuration&quot;&gt;구성&lt;/a&gt; . 이것은 대부분 &lt;code&gt;@use&lt;/code&gt; 와 동일하게 작동하지만 한 가지 추가 사항이 있습니다. &lt;code&gt;@forward&lt;/code&gt; 규칙의 구성은 구성에서 &lt;code&gt;!default&lt;/code&gt; 플래그를 사용할 수 있습니다 . 이를 통해 모듈은 업스트림 스타일 시트의 기본값을 변경하면서 다운 스트림 스타일 시트가 기본값을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a48f18648f8f823009940af90f7a3398299a276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@forward&lt;/code&gt; rule loads a Sass stylesheet and makes its &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt;, &lt;a href=&quot;function&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../variables&quot;&gt;variables&lt;/a&gt; available when your stylesheet is loaded with the &lt;a href=&quot;use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt;. It makes it possible to organize Sass libraries across many files, while allowing their users to load a single entrypoint file.</source>
          <target state="translated">&lt;code&gt;@forward&lt;/code&gt; 의 규칙을로드 말대꾸 스타일 시트를하고 있습니다 &lt;a href=&quot;mixin&quot;&gt;유지 mixin&lt;/a&gt; , &lt;a href=&quot;function&quot;&gt;기능&lt;/a&gt; 및 &lt;a href=&quot;../variables&quot;&gt;변수는&lt;/a&gt; 스타일 시트가로드 될 때 사용할 수 &lt;a href=&quot;use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 의 규칙&lt;/a&gt; . 사용자가 단일 진입 점 파일을로드 할 수 있도록 허용하면서 여러 파일에 걸쳐 Sass 라이브러리를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edae6f073c38434d3e207e7a5dafb837955a0007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@if&lt;/code&gt; directive takes a SassScript expression and uses the styles nested beneath it if the expression returns anything other than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;@if&lt;/code&gt; 의 지시어는 SassScript 식을 취하고 이외의 표현을 반환 아무것도 경우 아래에 중첩 스타일을 사용하여 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="97751d4897d5c8ad3677b64fd0bdc183e62db874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@if&lt;/code&gt; rule is written &lt;code&gt;@if &amp;lt;expression&amp;gt; { ... }&lt;/code&gt;, and it controls whether or not its block gets evaluated (including emitting any styles as CSS). The &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; usually returns either &lt;a href=&quot;../../values/booleans&quot;&gt;&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;&lt;/a&gt;&amp;mdash;if the expression returns &lt;code&gt;true&lt;/code&gt;, the block is evaluated, and if the expression returns &lt;code&gt;false&lt;/code&gt; it&amp;rsquo;s not.</source>
          <target state="translated">&lt;code&gt;@if&lt;/code&gt; 의 규칙 작성된 &lt;code&gt;@if &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; 하고, 그 블록 (CSS 스타일 어떠한 발광 포함) 평가 도착하는지 여부를 제어한다. &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;표현은&lt;/a&gt; 일반적으로 하나 반환 &lt;a href=&quot;../../values/booleans&quot;&gt; &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; &lt;/a&gt; 표현을 반환 -if &lt;code&gt;true&lt;/code&gt; 블록이 평가되고, 그리고 표현을 반환하는 경우 &lt;code&gt;false&lt;/code&gt; 이 아니다.</target>
        </trans-unit>
        <trans-unit id="7b1bac589cac69a197e403f499df3a9993010d02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@if&lt;/code&gt; statement can be followed by several &lt;code&gt;@else if&lt;/code&gt; statements and one &lt;code&gt;@else&lt;/code&gt; statement. If the &lt;code&gt;@if&lt;/code&gt; statement fails, the &lt;code&gt;@else if&lt;/code&gt; statements are tried in order until one succeeds or the &lt;code&gt;@else&lt;/code&gt; is reached. For example:</source>
          <target state="translated">&lt;code&gt;@if&lt;/code&gt; 문 뒤에 여러 &lt;code&gt;@else if&lt;/code&gt; 문과 하나의 &lt;code&gt;@else&lt;/code&gt; 문 이 올 수 있습니다 . 는 IF &lt;code&gt;@if&lt;/code&gt; 의 문이 실패의 &lt;code&gt;@else if&lt;/code&gt; 문 하나까지 순서대로 시도됩니다 성공 또는 &lt;code&gt;@else&lt;/code&gt; 이 도달. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87ed2b45b30496b3ac781e14bbec2d833422c474" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@import&lt;/code&gt; rule has a number of serious issues:</source>
          <target state="translated">&lt;code&gt;@import&lt;/code&gt; 의 규칙은 심각한 문제의 번호를 가지고 :</target>
        </trans-unit>
        <trans-unit id="6f889f3526a88c98f27cf8326bcc19306272b7ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@return&lt;/code&gt; at-rule indicates the value to use as the result of calling a function. It&amp;rsquo;s only allowed within a &lt;code&gt;@function&lt;/code&gt; body, and each &lt;code&gt;@function&lt;/code&gt; must end with a &lt;code&gt;@return&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@return&lt;/code&gt; 의 규칙은 함수 호출의 결과로서 사용할 수있는 값을 나타낸다. &lt;code&gt;@function&lt;/code&gt; 본문 내에서만 허용 되며 각 &lt;code&gt;@function&lt;/code&gt; 은 &lt;code&gt;@return&lt;/code&gt; 으로 끝나야합니다 .</target>
        </trans-unit>
        <trans-unit id="8103b04685af8b03bffdc2e4a7d93a3cd56d4a2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@use&lt;/code&gt; or &lt;code&gt;@import&lt;/code&gt; rule&amp;rsquo;s URL as a string, exactly as it appears in the stylesheet.</source>
          <target state="translated">&lt;code&gt;@use&lt;/code&gt; 또는 &lt;code&gt;@import&lt;/code&gt; 문자열로 규칙의 URL, 그것은 스타일 시트에 표시된대로 정확하게.</target>
        </trans-unit>
        <trans-unit id="53379d29c03ea52485bc34dcc7e79b10efe878cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@use&lt;/code&gt; rule loads &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt;, &lt;a href=&quot;function&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../variables&quot;&gt;variables&lt;/a&gt; from other Sass stylesheets, and combines CSS from multiple stylesheets together. Stylesheets loaded by &lt;code&gt;@use&lt;/code&gt; are called &quot;modules&quot;. Sass also provides &lt;a href=&quot;../modules&quot;&gt;built-in modules&lt;/a&gt; full of useful functions.</source>
          <target state="translated">&lt;code&gt;@use&lt;/code&gt; 의 규칙로드 &lt;a href=&quot;mixin&quot;&gt;유지 mixin&lt;/a&gt; , &lt;a href=&quot;function&quot;&gt;기능&lt;/a&gt; 및 &lt;a href=&quot;../variables&quot;&gt;변수&lt;/a&gt; 함께 여러 스타일 시트에서 다른 말대꾸 스타일 시트에서, 및 콤바인은 CSS. &lt;code&gt;@use&lt;/code&gt; 에 의해로드 된 스타일 시트를 &quot;모듈&quot;이라고합니다. Sass는 또한 유용한 기능으로 가득 찬 &lt;a href=&quot;../modules&quot;&gt;내장 모듈을&lt;/a&gt; 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="cb66e645f955007af31d85000b8a746fec7c41a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@warn&lt;/code&gt; directive prints the value of a SassScript expression to the standard error output stream. It's useful for libraries that need to warn users of deprecations or recovering from minor mixin usage mistakes. There are two major distinctions between &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@debug&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;@warn&lt;/code&gt; 의 지시자는 표준 에러 출력 스트림 SassScript 식의 값을 출력한다. 사용 중단을 사용자에게 경고하거나 사소한 믹스 인 사용 실수로부터 복구해야하는 라이브러리에 유용합니다. &lt;code&gt;@warn&lt;/code&gt; 과 &lt;code&gt;@debug&lt;/code&gt; 에는 크게 두 가지 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="842f0db216c7751e5b0d64bb0ced32af40468fb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@warn&lt;/code&gt; rule is designed just for that. It&amp;rsquo;s written &lt;code&gt;@warn &amp;lt;expression&amp;gt;&lt;/code&gt; and it prints the value of the &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; (usually a string) for the user, along with a stack trace indicating how the current mixin or function was called. Unlike the &lt;a href=&quot;error&quot;&gt;&lt;code&gt;@error&lt;/code&gt; rule&lt;/a&gt;, though, it doesn&amp;rsquo;t stop Sass entirely.</source>
          <target state="translated">&lt;code&gt;@warn&lt;/code&gt; 의 규칙은 단지 설계되었습니다. &lt;code&gt;@warn &amp;lt;expression&amp;gt;&lt;/code&gt; 으로 작성 되고 현재 믹스 인 또는 함수가 호출 된 방법을 나타내는 스택 추적과 함께 사용자에 대한 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;표현식&lt;/a&gt; (일반적으로 문자열) 의 값을 인쇄합니다 . 그러나 &lt;a href=&quot;error&quot;&gt; &lt;code&gt;@error&lt;/code&gt; 규칙&lt;/a&gt; 과 달리 Sass를 완전히 중지하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="036d9853511ea7f8a9eed6ee63043a942bfb4426" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@while&lt;/code&gt; directive takes a SassScript expression and repeatedly outputs the nested styles until the statement evaluates to &lt;code&gt;false&lt;/code&gt;. This can be used to achieve more complex looping than the &lt;code&gt;@for&lt;/code&gt; statement is capable of, although this is rarely necessary. For example:</source>
          <target state="translated">&lt;code&gt;@while&lt;/code&gt; 의 지시어는 SassScript 식을 취하고 반복적으로 문들을 평가까지 중첩 스타일을 출력 &lt;code&gt;false&lt;/code&gt; . 이것은 거의 필요하지 않지만 &lt;code&gt;@for&lt;/code&gt; 문 보다 더 복잡한 루핑을 달성하는 데 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1eed5d1b65fbddfb1ff1766c10939e5ff18aba3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@while&lt;/code&gt; rule, written &lt;code&gt;@while &amp;lt;expression&amp;gt; { ... }&lt;/code&gt;, evaluates its block if its &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;expression&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;. Then, if its expression still returns &lt;code&gt;true&lt;/code&gt;, it evaluates its block again. This continues until the expression finally returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@while&lt;/code&gt; 의 규칙 작성 &lt;code&gt;@while &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; 의 경우, 그 블록을 평가하는 &lt;a href=&quot;../../syntax/structure#expressions&quot;&gt;표현&lt;/a&gt; 을 반환 &lt;code&gt;true&lt;/code&gt; . 그런 다음 표현식이 여전히 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 해당 블록을 다시 평가합니다. 표현식이 마침내 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때까지 계속 됩니다.</target>
        </trans-unit>
        <trans-unit id="6df43083b5d905e4f6e4599386fbd9b21782a3aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;darken()&lt;/code&gt; function decreases lightness by a fixed amount, which is often not the desired effect. To make a color a certain percentage darker than it was before, use &lt;a href=&quot;#scale&quot;&gt;&lt;code&gt;color.scale()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;darken()&lt;/code&gt; 함수는 종종 원하는 효과없는 일정량 의해 명도 감소한다. 색상을 이전보다 일정 비율 어둡게 만들려면 대신 &lt;a href=&quot;#scale&quot;&gt; &lt;code&gt;color.scale()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f15eab2ee580d26be0dc39d5d78797282d2640b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;desaturate()&lt;/code&gt; function decreases saturation by a fixed amount, which is often not the desired effect. To make a color a certain percentage less saturated than it was before, use &lt;a href=&quot;#scale&quot;&gt;&lt;code&gt;color.scale()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;desaturate()&lt;/code&gt; 함수는 종종 원하는 효과없는 일정량 의하여 채도를 감소시킨다. 색상을 이전보다 채도가 낮은 특정 비율로 만들려면 대신 &lt;a href=&quot;#scale&quot;&gt; &lt;code&gt;color.scale()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3865c4ef8bb9e296ed155f02c937738292eba0d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hide&lt;/code&gt; form means that the listed members shouldn&amp;rsquo;t be forwarded, but everything else should. The &lt;code&gt;show&lt;/code&gt; form means that &lt;em&gt;only&lt;/em&gt; the named members should be forwarded. In both forms, you list the names of mixins, functions, or variables (including the &lt;code&gt;$&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;hide&lt;/code&gt; 형태 수단 나열된 멤버는 전달되지해야하지만 다른 모든 것을. &lt;code&gt;show&lt;/code&gt; 형태 수단 &lt;em&gt;에만&lt;/em&gt; 명명 된 회원이 전달되어야한다. 두 형식 모두 믹스 인, 함수 또는 변수의 이름 ( &lt;code&gt;$&lt;/code&gt; 포함 ) 을 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="2653cd871e8a970f8c3859e972619b3b4b753f85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; property contains a string that includes tab-separated information about the Sass implementation. For Dart Sass, this is the version of Dart Sass and the version of the &lt;a href=&quot;https://webdev.dartlang.org/tools/dart2js&quot;&gt;dart2js&lt;/a&gt; compiler used to compile it to JavaScript; for LibSass, it&amp;rsquo;s the version of LibSass and the version of &lt;a href=&quot;https://www.npmjs.com/package/node-sass&quot;&gt;Node Sass&lt;/a&gt; that wraps it.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 속성은 말대꾸 구현에 대한 탭으로 구분 된 정보를 포함하는 문자열을 포함합니다. Dart Sass의 경우 이는 Dart Sass 버전이며 JavaScript로 컴파일하는 데 사용되는 &lt;a href=&quot;https://webdev.dartlang.org/tools/dart2js&quot;&gt;dart2js&lt;/a&gt; 컴파일러 버전입니다 . LibSass의 경우 LibSass 버전과 이를 래핑하는 &lt;a href=&quot;https://www.npmjs.com/package/node-sass&quot;&gt;Node Sass&lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="3be55fd27d6d1ab938ce65274a35e09cfe42e00e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lighten()&lt;/code&gt; function increases lightness by a fixed amount, which is often not the desired effect. To make a color a certain percentage lighter than it was before, use &lt;a href=&quot;#scale&quot;&gt;&lt;code&gt;scale()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;lighten()&lt;/code&gt; 함수의 증가는 종종 원하는 효과없는 일정량 의해 가벼움. 색상을 이전보다 일정 비율 더 밝게 만들려면 대신 &lt;a href=&quot;#scale&quot;&gt; &lt;code&gt;scale()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0a82c740138100094d9ee76c788128f778853e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opacify()&lt;/code&gt; function increases the alpha channel by a fixed amount, which is often not the desired effect. To make a color a certain percentage more opaque than it was before, use &lt;a href=&quot;#scale&quot;&gt;&lt;code&gt;scale()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;opacify()&lt;/code&gt; 함수는 종종 원하는 효과없는 정량에 의한 알파 채널을 증가한다. 색상을 이전보다 일정 비율 더 불투명하게 만들려면 대신 &lt;a href=&quot;#scale&quot;&gt; &lt;code&gt;scale()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f40efbde0e63d7b92586646b70aa859773ed959b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;saturate()&lt;/code&gt; function increases saturation by a fixed amount, which is often not the desired effect. To make a color a certain percentage more saturated than it was before, use &lt;a href=&quot;#scale&quot;&gt;&lt;code&gt;scale()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;saturate()&lt;/code&gt; 함수는 종종 원하는 효과없는 일정량 의하여 채도를 증가시킨다. 색상을 이전보다 특정 비율로 더 포화 시키려면 대신 &lt;a href=&quot;#scale&quot;&gt; &lt;code&gt;scale()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="28bcccc07982bc5e35fca76e43cb56f152b6b2fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transparentize()&lt;/code&gt; function decreases the alpha channel by a fixed amount, which is often not the desired effect. To make a color a certain percentage more transparent than it was before, use &lt;a href=&quot;#scale&quot;&gt;&lt;code&gt;color.scale()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;transparentize()&lt;/code&gt; 함수는 종종 원하는 효과없는 정량에 의한 알파 채널을 감소시킨다. 색상을 이전보다 일정 비율 더 투명하게 만들려면 대신 &lt;a href=&quot;#scale&quot;&gt; &lt;code&gt;color.scale()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f599890a4f44b440fdb51059955b49736633394d" translate="yes" xml:space="preserve">
          <source>The CSS in nested imports is evaluated like a mixin, which means that any &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;parent selectors&lt;/a&gt; will refer to the selector in which the stylesheet is nested.</source>
          <target state="translated">중첩 된 가져 오기의 CSS는 믹스 인처럼 평가됩니다. 즉, 모든 &lt;a href=&quot;../style-rules/parent-selector&quot;&gt;상위 선택자는&lt;/a&gt; 스타일 시트가 중첩 된 선택기 를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="2bccc239d00eaf8f1c0f5a285a794c300a62c09a" translate="yes" xml:space="preserve">
          <source>The Dart Sass executable can be invoked in one of two modes.</source>
          <target state="translated">Dart Sass 실행 파일은 두 가지 모드 중 하나로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9823180853274c3ed3c798208454cbc6cdd7343f" translate="yes" xml:space="preserve">
          <source>The Indented Syntax</source>
          <target state="translated">들여 쓴 구문</target>
        </trans-unit>
        <trans-unit id="a79922841f2b9904dc1ccf8c993b6a2a89f4cee3" translate="yes" xml:space="preserve">
          <source>The Ruby Sass executable can be invoked in one of two modes.</source>
          <target state="translated">Ruby Sass 실행 파일은 두 가지 모드 중 하나로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2855bfaa1d17b7d3ed0e26fa30a8df99f684a0a" translate="yes" xml:space="preserve">
          <source>The SCSS syntax uses the file extension &lt;code&gt;.scss&lt;/code&gt;. With a few small exceptions, it&amp;rsquo;s a superset of CSS, which means essentially &lt;strong&gt;all valid CSS is valid SCSS as well&lt;/strong&gt;. Because of its similarity to CSS, it&amp;rsquo;s the easiest syntax to get used to and the most popular.</source>
          <target state="translated">SCSS 구문은 파일 확장자 &lt;code&gt;.scss&lt;/code&gt; 를 사용합니다 . 몇 가지 작은 예외를 제외하고는 CSS의 상위 집합입니다. 즉, 기본적으로 &lt;strong&gt;모든 유효한 CSS도 유효한 SCSS&lt;/strong&gt; 입니다. CSS와 유사하기 때문에 익숙해지기 쉽고 가장 인기있는 구문입니다.</target>
        </trans-unit>
        <trans-unit id="40cd0e11b0583d27d0d7156f2bf116a792340ddc" translate="yes" xml:space="preserve">
          <source>The Sass JSAPI makes source maps available using the &lt;a href=&quot;#result-map&quot;&gt;&lt;code&gt;result.map&lt;/code&gt; field&lt;/a&gt;.</source>
          <target state="translated">Sass JSAPI는 &lt;a href=&quot;#result-map&quot;&gt; &lt;code&gt;result.map&lt;/code&gt; 필드를&lt;/a&gt; 사용하여 소스 맵을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="7dbd956ef12d159ddf033d9c2ae5230695500357" translate="yes" xml:space="preserve">
          <source>The Sass command-line tool will use the file extension to determine which syntax you are using, but there's not always a filename. The &lt;code&gt;sass&lt;/code&gt; command-line program defaults to the indented syntax but you can pass the &lt;code&gt;--scss&lt;/code&gt; option to it if the input should be interpreted as SCSS syntax. Alternatively, you can use the &lt;code&gt;scss&lt;/code&gt; command-line program which is exactly like the &lt;code&gt;sass&lt;/code&gt; program but it defaults to assuming the syntax is SCSS.</source>
          <target state="translated">Sass 명령 줄 도구는 파일 확장자를 사용하여 사용중인 구문을 결정하지만 항상 파일 이름이있는 것은 아닙니다. &lt;code&gt;sass&lt;/code&gt; 들여 쓰기 구문 명령 줄 프로그램은 기본적으로 있지만 통과 할 수 &lt;code&gt;--scss&lt;/code&gt; 입력이 SCSS 구문으로 해석 할 필요가있는 경우 여기에 옵션을 선택합니다. 또는 &lt;code&gt;sass&lt;/code&gt; 프로그램 과 정확히 동일한 &lt;code&gt;scss&lt;/code&gt; 명령 줄 프로그램을 사용할 수 있지만 구문이 SCSS라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="49cc07728709e0752a5bd9c9ca000ab89c40539a" translate="yes" xml:space="preserve">
          <source>The Sass core library provides a couple advanced functions for working with variables. The &lt;a href=&quot;modules/meta#variable-exists&quot;&gt;&lt;code&gt;meta.variable-exists()&lt;/code&gt; function&lt;/a&gt; returns whether a variable with the given name exists in the current scope, and the &lt;a href=&quot;modules/meta#global-variable-exists&quot;&gt;&lt;code&gt;meta.global-variable-exists()&lt;/code&gt; function&lt;/a&gt; does the same but only for the global scope.</source>
          <target state="translated">Sass 코어 라이브러리는 변수 작업을위한 몇 가지 고급 기능을 제공합니다. &lt;a href=&quot;modules/meta#variable-exists&quot;&gt; &lt;code&gt;meta.variable-exists()&lt;/code&gt; 함수&lt;/a&gt; 로 지정된 이름의 변수가 현재 범위에 존재하는지 여부를 반환하고, &lt;a href=&quot;modules/meta#global-variable-exists&quot;&gt; &lt;code&gt;meta.global-variable-exists()&lt;/code&gt; 함수는&lt;/a&gt; 단지 전역 범위에 대한하지만 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e97c8a0fe445977b0b6a657b28d30949285d2895" translate="yes" xml:space="preserve">
          <source>The Sass migrator automatically updates your Sass files to help you move on to the latest and greatest version of the language. Each of its commands migrates a single feature, to give you as much control as possible over what you update and when.</source>
          <target state="translated">Sass 마이그레이션 도구는 최신 버전의 언어로 이동할 수 있도록 Sass 파일을 자동으로 업데이트합니다. 각 명령은 단일 기능을 마이그레이션하여 업데이트 내용과시기를 가능한 한 많이 제어 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d20e8542d5b0783516e2e0e242a1e43d12c5a8ad" translate="yes" xml:space="preserve">
          <source>The Sass module provides two functions with similar APIs.</source>
          <target state="translated">Sass 모듈은 유사한 API로 두 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5e7a80e2ce0603f294bc4436485a59be5b53a3b8" translate="yes" xml:space="preserve">
          <source>The Sass team discourages the continued use of the &lt;code&gt;@import&lt;/code&gt; rule. Sass will &lt;a href=&quot;https://github.com/sass/sass/blob/master/accepted/module-system.md#timeline&quot;&gt;gradually phase it out&lt;/a&gt; over the next few years, and eventually remove it from the language entirely. Prefer the &lt;a href=&quot;use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt; instead. (Note that only Dart Sass currently supports &lt;code&gt;@use&lt;/code&gt;. Users of other implementations must use the &lt;code&gt;@import&lt;/code&gt; rule instead.)</source>
          <target state="translated">Sass 팀은 &lt;code&gt;@import&lt;/code&gt; 규칙 의 지속적인 사용을 권장하지 않습니다 . Sass는 향후 몇 년 동안 &lt;a href=&quot;https://github.com/sass/sass/blob/master/accepted/module-system.md#timeline&quot;&gt;점차적으로 단계적&lt;/a&gt; 으로 제거하고 결국 언어에서 완전히 제거 할 것입니다. 대신 &lt;a href=&quot;use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 규칙을&lt;/a&gt; 선호하십시오 . (현재 Dart Sass 만 &lt;code&gt;@use&lt;/code&gt; 를 지원합니다 . 다른 구현의 사용자는 대신 &lt;code&gt;@import&lt;/code&gt; 규칙을 사용해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="5ad5ee8442b7be18229c8032bdbe771af8814c90" translate="yes" xml:space="preserve">
          <source>The Sass value &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Sass 값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="249cb1c95e1a126a7b34c1bcc56fae2dea8359d9" translate="yes" xml:space="preserve">
          <source>The Sass value &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Sass 값 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b4397f4896d98b65aec6ed8c3c675b6f5aa9a50" translate="yes" xml:space="preserve">
          <source>The Sass value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Sass 값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36ec8433431c6f31089da9aad58c0b8ed355cd19" translate="yes" xml:space="preserve">
          <source>The absolute path of the input file passed as the &lt;a href=&quot;#file&quot;&gt;&lt;code&gt;file&lt;/code&gt; option&lt;/a&gt;, or &lt;code&gt;&quot;data&quot;&lt;/code&gt; if the &lt;a href=&quot;#data&quot;&gt;&lt;code&gt;data&lt;/code&gt; option&lt;/a&gt; was passed instead.</source>
          <target state="translated">&lt;a href=&quot;#file&quot;&gt; &lt;code&gt;file&lt;/code&gt; 옵션&lt;/a&gt; 으로 전달 된 입력 파일의 절대 경로 또는 &lt;a href=&quot;#data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 옵션 이 대신 전달 된 경우 &lt;code&gt;&quot;data&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="629ffa2442fc4371dc88961319dce02104a6b90d" translate="yes" xml:space="preserve">
          <source>The alpha channel of a color can be adjusted using the &lt;a href=&quot;sass/script/functions#opacify-instance_method&quot;&gt;opacify&lt;/a&gt; and &lt;a href=&quot;sass/script/functions#transparentize-instance_method&quot;&gt;transparentize&lt;/a&gt; functions. For example:</source>
          <target state="translated">&lt;a href=&quot;sass/script/functions#opacify-instance_method&quot;&gt;불투명&lt;/a&gt; 및 &lt;a href=&quot;sass/script/functions#transparentize-instance_method&quot;&gt;투명화&lt;/a&gt; 기능을 사용하여 색상의 알파 채널을 조정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f0c9af133a56cf709eabce5c6b2068a2f64a4ff" translate="yes" xml:space="preserve">
          <source>The block of content passed to a mixin are evaluated in the scope where the block is defined, not in the scope of the mixin. This means that variables local to the mixin &lt;strong&gt;cannot&lt;/strong&gt; be used within the passed style block and variables will resolve to the global value:</source>
          <target state="translated">믹스 인에 전달 된 컨텐츠 블록은 믹스 인의 범위가 아니라 블록이 정의 된 범위에서 평가됩니다. 즉, 믹스 인에 로컬 인 변수 는 전달 된 스타일 블록 내에서 사용할 &lt;strong&gt;수 없으며&lt;/strong&gt; 변수는 전역 값으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1bcb97b641d09ebb9846d4a65721d499bc5f2c78" translate="yes" xml:space="preserve">
          <source>The built-in &lt;code&gt;if()&lt;/code&gt; function allows you to branch on a condition and returns only one of two possible outcomes. It can be used in any script context. The &lt;code&gt;if&lt;/code&gt; function only evaluates the argument corresponding to the one that it will return -- this allows you to refer to variables that may not be defined or to have calculations that would otherwise cause an error (E.g. divide by zero).</source>
          <target state="translated">내장 &lt;code&gt;if()&lt;/code&gt; 함수를 사용하면 조건을 분기하고 두 가지 가능한 결과 중 하나만 반환 할 수 있습니다. 모든 스크립트 컨텍스트에서 사용할 수 있습니다. &lt;code&gt;if&lt;/code&gt; 함수는이 반환하는 하나에 해당하는 인수를 평가 - 이것이 당신이 정의되지 않을 수 있습니다 변수를 참조하거나 계산을 할 수 있다는 것, 그렇지 않으면 오류 (0으로 예 격차) 원인.</target>
        </trans-unit>
        <trans-unit id="ab48b414878c480f8c51b965b64c4b9a5d4944bb" translate="yes" xml:space="preserve">
          <source>The column of &lt;a href=&quot;#error-line&quot;&gt;&lt;code&gt;error.line&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;#error-file&quot;&gt;&lt;code&gt;error.file&lt;/code&gt;&lt;/a&gt; on which the error occurred.</source>
          <target state="translated">의 열 &lt;a href=&quot;#error-line&quot;&gt; &lt;code&gt;error.line&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;#error-file&quot;&gt; &lt;code&gt;error.file&lt;/code&gt; 이&lt;/a&gt; 되는 에러가 발생 하였다.</target>
        </trans-unit>
        <trans-unit id="a7fd5041403501eaa3a3142efda256c050688b7b" translate="yes" xml:space="preserve">
          <source>The compiled CSS, as a &lt;a href=&quot;https://nodejs.org/api/buffer.html&quot;&gt;Buffer&lt;/a&gt;. This can be converted to a string by calling &lt;a href=&quot;https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end&quot;&gt;&lt;code&gt;Buffer.toString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 CSS, &lt;a href=&quot;https://nodejs.org/api/buffer.html&quot;&gt;Buffer&lt;/a&gt; . &lt;a href=&quot;https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end&quot;&gt; &lt;code&gt;Buffer.toString()&lt;/code&gt; &lt;/a&gt; 을 호출하여 문자열로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5911b098efb0f894cf7becb1324dc18dcf7724c3" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;-&lt;/code&gt; in Sass take precedence in the following order:</source>
          <target state="translated">Sass에서 &lt;code&gt;-&lt;/code&gt; 의 다른 의미 는 다음 순서로 우선합니다.</target>
        </trans-unit>
        <trans-unit id="bd67186bd98e8190eb31017e67db7ed517d63d54" translate="yes" xml:space="preserve">
          <source>The different meanings of &lt;code&gt;-&lt;/code&gt; take precedence in the following order:</source>
          <target state="translated">의 다른 의미는 &lt;code&gt;-&lt;/code&gt; 다음과 같은 순서로 우선합니다 :</target>
        </trans-unit>
        <trans-unit id="411aca0656eb98a728ef767976eddacbf1ed4c24" translate="yes" xml:space="preserve">
          <source>The equality operators return whether or not two values are the same. They&amp;rsquo;re written &lt;code&gt;&amp;lt;expression&amp;gt; == &amp;lt;expression&amp;gt;&lt;/code&gt;, which returns whether two &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;expressions&lt;/a&gt; are equal, and &lt;code&gt;&amp;lt;expression&amp;gt; != &amp;lt;expression&amp;gt;&lt;/code&gt;, which returns whether two expressions are &lt;em&gt;not&lt;/em&gt; equal. Two values are considered equal if they&amp;rsquo;re the same type &lt;em&gt;and&lt;/em&gt; the same value, which means different things for different types:</source>
          <target state="translated">같음 연산자는 두 값이 동일한 지 여부를 반환합니다. 그들은 작성하고 &lt;code&gt;&amp;lt;expression&amp;gt; == &amp;lt;expression&amp;gt;&lt;/code&gt; , 두 여부를 반환하는 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;표현이&lt;/a&gt; 동일하고, &lt;code&gt;&amp;lt;expression&amp;gt; != &amp;lt;expression&amp;gt;&lt;/code&gt; , 두 표현식 여부를 반환되는 &lt;em&gt;하지&lt;/em&gt; 동일. 두 값이 동일한 유형 &lt;em&gt;이고&lt;/em&gt; 동일한 값이면 동일한 것으로 간주됩니다. 즉, 유형에 따라 다른 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="91bc219ab8ac1aec885b10df0e7b5efb82c47f13" translate="yes" xml:space="preserve">
          <source>The exact format of the debug message varies from implementation to implementation. This is what it looks like in Dart Sass:</source>
          <target state="translated">디버그 메시지의 정확한 형식은 구현마다 다릅니다. Dart Sass에서 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="2f6d331e3a47aaaeb0efa6e128428c63dad27747" translate="yes" xml:space="preserve">
          <source>The exact format of the error and stack trace varies from implementation to implementation, and can also depend on your build system. This is what it looks like in Dart Sass when run from the command line:</source>
          <target state="translated">오류 및 스택 추적의 정확한 형식은 구현마다 다르며 빌드 시스템에 따라 다를 수도 있습니다. 명령 줄에서 실행할 때 Dart Sass에서 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="3f11145521151b80c5c3bc7f7d5d9191835bdf80" translate="yes" xml:space="preserve">
          <source>The exact format of the warning and stack trace varies from implementation to implementation. This is what it looks like in Dart Sass:</source>
          <target state="translated">경고 및 스택 추적의 정확한 형식은 구현마다 다릅니다. Dart Sass에서 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="9b92a4c7223dc172f932e908e2fd37b99a3b5469" translate="yes" xml:space="preserve">
          <source>The following features are supported:</source>
          <target state="translated">다음과 같은 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="19fea2b888e49ae8a6f6f13465e6dc849402cf66" translate="yes" xml:space="preserve">
          <source>The functions in this module inspect and manipulate selectors. Whenever they return a selector, it&amp;rsquo;s always a comma-separated &lt;a href=&quot;../values/lists&quot;&gt;list&lt;/a&gt; (the selector list) that contains space-separated lists (the complex selectors) that contain &lt;a href=&quot;../values/strings#unquoted&quot;&gt;unquoted strings&lt;/a&gt; (the compound selectors). For example, the selector &lt;code&gt;.main aside:hover, .sidebar p&lt;/code&gt; would be returned as:</source>
          <target state="translated">이 모듈의 함수는 선택기를 검사하고 조작합니다. 선택자를 반환 할 때마다 &lt;a href=&quot;../values/strings#unquoted&quot;&gt;따옴표가없는 문자열&lt;/a&gt; ( 복합 선택자)을 포함하는 공백으로 구분 된 목록 (복합 선택자)을 포함 하는 쉼표로 구분 된 &lt;a href=&quot;../values/lists&quot;&gt;목록&lt;/a&gt; (선택자 목록)입니다 . 예를 들어, 선택기 &lt;code&gt;.main aside:hover, .sidebar p&lt;/code&gt; 는 다음과 같이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f917e97c3a12a6186a7ac26d1e2c5bea57b4a97d" translate="yes" xml:space="preserve">
          <source>The global name of this function is &lt;code&gt;compa&lt;strong&gt;ra&lt;/strong&gt;ble&lt;/code&gt;, but when it was added to the &lt;code&gt;sass:math&lt;/code&gt; module the name was changed to &lt;code&gt;compa&lt;strong&gt;ti&lt;/strong&gt;ble&lt;/code&gt; to more clearly convey what the function does.</source>
          <target state="translated">이 함수의 전역 이름은 &lt;code&gt;compa&lt;strong&gt;ra&lt;/strong&gt;ble&lt;/code&gt; 만이 추가 될 때 &lt;code&gt;sass:math&lt;/code&gt; 모듈 이름이 변경되었습니다 &lt;code&gt;compa&lt;strong&gt;ti&lt;/strong&gt;ble&lt;/code&gt; 더 명확하게 함수가 무엇을 전달.</target>
        </trans-unit>
        <trans-unit id="c07ae330d5f2e56007474c07d2b2acf32e6179cc" translate="yes" xml:space="preserve">
          <source>The hue is a number between &lt;code&gt;0deg&lt;/code&gt; and &lt;code&gt;360deg&lt;/code&gt; (inclusive). The saturation and lightness are numbers between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive). All these numbers may be &lt;a href=&quot;values/numbers#units&quot;&gt;unitless&lt;/a&gt;. The alpha channel can be specified as either a unitless number between 0 and 1 (inclusive), or a percentage between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive).</source>
          <target state="translated">색조는 0 &lt;code&gt;0deg&lt;/code&gt; 에서 &lt;code&gt;360deg&lt;/code&gt; (포함) 사이의 숫자 입니다. 채도와 밝기는 &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; (포함) 사이의 숫자 입니다. 이 모든 숫자는 &lt;a href=&quot;values/numbers#units&quot;&gt;단위&lt;/a&gt; 가 없을 수 있습니다 . 알파 채널은 0과 1 (포함) 사이의 단위없는 숫자 또는 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; (포함) 사이의 백분율로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35bfd02780d11ebf66e10972c6d36c9b4995652b" translate="yes" xml:space="preserve">
          <source>The hue is a number between &lt;code&gt;0deg&lt;/code&gt; and &lt;code&gt;360deg&lt;/code&gt; (inclusive). The whiteness and blackness are numbers between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive). The hue may be &lt;a href=&quot;../values/numbers#units&quot;&gt;unitless&lt;/a&gt;, but the whiteness and blackness must have unit &lt;code&gt;%&lt;/code&gt;. The alpha channel can be specified as either a unitless number between 0 and 1 (inclusive), or a percentage between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt; (inclusive).</source>
          <target state="translated">색조는 0 &lt;code&gt;0deg&lt;/code&gt; 에서 &lt;code&gt;360deg&lt;/code&gt; (포함) 사이의 숫자 입니다. 백색도와 흑색도는 &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; (포함) 사이의 숫자 입니다. 색조는 &lt;a href=&quot;../values/numbers#units&quot;&gt;단위&lt;/a&gt; 가 없을 수 있지만 흰색과 검은 색은 단위 &lt;code&gt;%&lt;/code&gt; 여야합니다 . 알파 채널은 0과 1 (포함) 사이의 단위없는 숫자 또는 &lt;code&gt;0%&lt;/code&gt; 와 &lt;code&gt;100%&lt;/code&gt; (포함) 사이의 백분율로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46c43ea532f48970a41f84360de25891f628d9cb" translate="yes" xml:space="preserve">
          <source>The indented syntax looks like this:</source>
          <target state="translated">들여 쓴 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21ec2f9027347a7f5f44a91224336d28cb8d15a0" translate="yes" xml:space="preserve">
          <source>The indented syntax was Sass&amp;rsquo;s original syntax, and so it uses the file extension &lt;code&gt;.sass&lt;/code&gt;. Because of this extension, it&amp;rsquo;s sometimes just called &amp;ldquo;Sass&amp;rdquo;. The indented syntax supports all the same features as SCSS, but it uses indentation instead of curly braces and semicolons to describe the format of the document.</source>
          <target state="translated">들여 쓴 구문은 Sass의 원래 구문이므로 파일 확장자 &lt;code&gt;.sass&lt;/code&gt; 를 사용합니다 . 이 확장 기능으로 인해 &quot;Sass&quot;라고도합니다. 들여 쓰기 구문은 SCSS와 동일한 기능을 모두 지원하지만 문서 형식을 설명하기 위해 중괄호와 세미콜론 대신 들여 쓰기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c4902488b96afeba8e351c58307203dd93e55c48" translate="yes" xml:space="preserve">
          <source>The initial keys and values of the map are undefined. They must be set using the &lt;a href=&quot;#map-setkey-index-key&quot;&gt;&lt;code&gt;setKey()&lt;/code&gt; method&lt;/a&gt; and the &lt;a href=&quot;#map-setvalue-index-value&quot;&gt;&lt;code&gt;setValue()&lt;/code&gt; method&lt;/a&gt; before accessing them or passing the map back to Sass.</source>
          <target state="translated">맵의 초기 키와 값은 정의되어 있지 않습니다. &lt;a href=&quot;#map-setkey-index-key&quot;&gt; &lt;code&gt;setKey()&lt;/code&gt; 메소드&lt;/a&gt; 와 &lt;a href=&quot;#map-setvalue-index-value&quot;&gt; &lt;code&gt;setValue()&lt;/code&gt; 메소드&lt;/a&gt; 를 사용하여 설정해야합니다. 액세스하거나 맵을 Sass로 다시 전달하기 전에.</target>
        </trans-unit>
        <trans-unit id="cc75b255410e0f231915e9a6ce5657dd664328ac" translate="yes" xml:space="preserve">
          <source>The initial values of the list elements are undefined. These elements must be set using the &lt;a href=&quot;#list-setvalue-index-value&quot;&gt;&lt;code&gt;setValue()&lt;/code&gt; method&lt;/a&gt; before accessing them or passing the list back to Sass.</source>
          <target state="translated">목록 요소의 초기 값은 정의되지 않습니다. 이러한 요소는 액세스하거나 목록을 Sass로 다시 전달하기 전에 &lt;a href=&quot;#list-setvalue-index-value&quot;&gt; &lt;code&gt;setValue()&lt;/code&gt; 메서드&lt;/a&gt; 를 사용하여 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2163b399ef4c7e2507a390b0834022d2945f43c7" translate="yes" xml:space="preserve">
          <source>The input file is parsed as &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt; if its extension is &lt;code&gt;.scss&lt;/code&gt; or as the &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;indented syntax&lt;/a&gt; if its extension is &lt;code&gt;.sass&lt;/code&gt;. If it doesn&amp;rsquo;t have one of these two extensions, or if it comes from standard input, it&amp;rsquo;s parsed as the indented syntax by default. This can be controlled with the &lt;a href=&quot;#scss&quot;&gt;&lt;code&gt;--scss&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">입력 파일로 구문 분석 &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt; 확장자이면 &lt;code&gt;.scss&lt;/code&gt; 또는로 &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;들여 구문&lt;/a&gt; 확장자이면 &lt;code&gt;.sass&lt;/code&gt; . 이 두 확장 중 하나가 없거나 표준 입력에서 오는 경우 기본적으로 들여 쓰기 된 구문으로 구문 분석됩니다. 이것은 &lt;a href=&quot;#scss&quot;&gt; &lt;code&gt;--scss&lt;/code&gt; 플래그&lt;/a&gt; 로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65f157d77ebfafa2731f0aa177168b912acaa0cb" translate="yes" xml:space="preserve">
          <source>The input file is parsed as &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt; if its extension is &lt;code&gt;.scss&lt;/code&gt;, as the &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;indented syntax&lt;/a&gt; if its extension is &lt;code&gt;.sass&lt;/code&gt;, or as &lt;a href=&quot;../at-rules/import#importing-css&quot;&gt;plain CSS&lt;/a&gt; if its extension is &lt;code&gt;.css&lt;/code&gt;. If it doesn&amp;rsquo;t have one of these three extensions, or if it comes from standard input, it&amp;rsquo;s parsed as SCSS by default. This can be controlled with the &lt;a href=&quot;#indented&quot;&gt;&lt;code&gt;--indented&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">입력 파일로 구문 분석됩니다 &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt; 의 확장 인 경우 &lt;code&gt;.scss&lt;/code&gt; 는 AS, &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;들여 쓰기 구문&lt;/a&gt; 의 확장 인 경우 &lt;code&gt;.sass&lt;/code&gt; , 또는 &lt;a href=&quot;../at-rules/import#importing-css&quot;&gt;일반 CSS&lt;/a&gt; 의 확장 인 경우 &lt;code&gt;.css&lt;/code&gt; . 이 세 가지 확장 중 하나가 없거나 표준 입력에서 오는 경우 기본적으로 SCSS로 구문 분석됩니다. &lt;a href=&quot;#indented&quot;&gt; &lt;code&gt;--indented&lt;/code&gt; 플래그&lt;/a&gt; 로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abc67cfb01cacb557f8249bd4fd0217570606bf9" translate="yes" xml:space="preserve">
          <source>The keywords are returned as a map from argument names as unquoted strings (not including &lt;code&gt;$&lt;/code&gt;) to the values of those arguments.</source>
          <target state="translated">키워드는 인수 이름에서 인용되지 않은 문자열 ( &lt;code&gt;$&lt;/code&gt; 제외)로 해당 인수의 값에 대한 맵으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="258da41117a38a10268ce6458531112c24def106" translate="yes" xml:space="preserve">
          <source>The length of the resulting list is the length of the shortest list.</source>
          <target state="translated">결과 목록의 길이는 가장 짧은 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="b4b40069f33bd6ccd0979468cea7082518ea2c50" translate="yes" xml:space="preserve">
          <source>The line in &lt;a href=&quot;#error-file&quot;&gt;&lt;code&gt;error.file&lt;/code&gt;&lt;/a&gt; on which the error occurred.</source>
          <target state="translated">오류가 발생한 &lt;a href=&quot;#error-file&quot;&gt; &lt;code&gt;error.file&lt;/code&gt; &lt;/a&gt; 의 줄입니다 .</target>
        </trans-unit>
        <trans-unit id="f99bafff4bc0c23462183c18f83b139c5bb10044" translate="yes" xml:space="preserve">
          <source>The location of parse errors can be accessed through implementation-specific APIs. For example, in Dart Sass you can access &lt;a href=&quot;https://pub.dartlang.org/documentation/sass/latest/sass/SassException/span.html&quot;&gt;&lt;code&gt;SassException.span&lt;/code&gt;&lt;/a&gt;, and in Node Sass&amp;rsquo;s and Dart Sass&amp;rsquo;s JSAPI you can access the &lt;a href=&quot;https://github.com/sass/node-sass#error-object&quot;&gt;&lt;code&gt;file&lt;/code&gt;, &lt;code&gt;line&lt;/code&gt;, and &lt;code&gt;column&lt;/code&gt;&lt;/a&gt; properties.</source>
          <target state="translated">구문 분석 오류의 위치는 구현 별 API를 통해 액세스 할 수 있습니다. 예를 들어 Dart Sass에서 &lt;a href=&quot;https://pub.dartlang.org/documentation/sass/latest/sass/SassException/span.html&quot;&gt; &lt;code&gt;SassException.span&lt;/code&gt; &lt;/a&gt; 에 액세스 할 수 있으며 Node Sass 및 Dart Sass의 JSAPI에서 &lt;a href=&quot;https://github.com/sass/node-sass#error-object&quot;&gt; &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;line&lt;/code&gt; 및 &lt;code&gt;column&lt;/code&gt; &lt;/a&gt; 속성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5ecca3ec18dfc00e101be629990aabccaac98c6" translate="yes" xml:space="preserve">
          <source>The migrator currently supports only one migration, but expect more to come as the Sass language continues to evolve!</source>
          <target state="translated">마이그레이션 프로그램은 현재 하나의 마이그레이션 만 지원하지만 Sass 언어가 계속 발전함에 따라 더 많은 마이그레이션이 제공 될 것으로 예상합니다!</target>
        </trans-unit>
        <trans-unit id="4df49a4caa7694bdcf35284bcfc20924016482ef" translate="yes" xml:space="preserve">
          <source>The module URL being loaded can come from a variable and include &lt;a href=&quot;../interpolation&quot;&gt;interpolation&lt;/a&gt;.</source>
          <target state="translated">로드되는 모듈 URL은 변수에서 가져올 수 있으며 &lt;a href=&quot;../interpolation&quot;&gt;보간을&lt;/a&gt; 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4178ed4ddf29fe6ada191630e63ef84f219db6c1" translate="yes" xml:space="preserve">
          <source>The module migrator needs to be able to read all of the stylesheets depended on by the ones it&amp;rsquo;s migrating, even if the &lt;a href=&quot;#migrate-deps&quot;&gt;&lt;code&gt;--migrate-deps&lt;/code&gt; option&lt;/a&gt; is not passed. If the migrator fails to find a dependency, you&amp;rsquo;ll get an error.</source>
          <target state="translated">모듈 마이그레이션자는 &lt;a href=&quot;#migrate-deps&quot;&gt; &lt;code&gt;--migrate-deps&lt;/code&gt; 옵션&lt;/a&gt; 이 전달되지 않은 경우에도 마이그레이션중인 스타일 시트에 의존하는 모든 스타일 시트를 읽을 수 있어야합니다 . 마이그레이션자가 종속성을 찾지 못하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06f9c260a7ec62319c981e555fd7eba4596789bb" translate="yes" xml:space="preserve">
          <source>The most straightforward way to use SassScript is to use variables. Variables begin with dollar signs, and are set like CSS properties:</source>
          <target state="translated">SassScript를 사용하는 가장 간단한 방법은 변수를 사용하는 것입니다. 변수는 달러 기호로 시작하며 CSS 속성과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6152fec5717bae0e93b4246533a89841d2d271fe" translate="yes" xml:space="preserve">
          <source>The new module system and the &lt;code&gt;@use&lt;/code&gt; rule address all these problems.</source>
          <target state="translated">새로운 모듈 시스템과 &lt;code&gt;@use&lt;/code&gt; 규칙은 이러한 모든 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="59fae2fe3c85c45f8ff213c1fc19e8efe071e614" translate="yes" xml:space="preserve">
          <source>The number of milliseconds between 1 January 1970 at 00:00:00 UTC and the time at which Sass compilation began.</source>
          <target state="translated">1970 년 1 월 1 일 00:00:00 UTC와 Sass 컴파일이 시작된 시간 사이의 밀리 초 수입니다.</target>
        </trans-unit>
        <trans-unit id="550de4953924f4bca43ab5446ec8ed787baf3146" translate="yes" xml:space="preserve">
          <source>The number of milliseconds between 1 January 1970 at 00:00:00 UTC and the time at which Sass compilation ended.</source>
          <target state="translated">1970 년 1 월 1 일 00:00:00 UTC와 Sass 컴파일이 종료 된 시간 사이의 밀리 초 수입니다.</target>
        </trans-unit>
        <trans-unit id="9fa1487d1587c995f0bcb697c890b6c891f95903" translate="yes" xml:space="preserve">
          <source>The number of milliseconds it took to compile the Sass file. This is always equal to &lt;a href=&quot;#result-stats-start&quot;&gt;&lt;code&gt;result.stats.start&lt;/code&gt;&lt;/a&gt; minus &lt;a href=&quot;#result-stats-end&quot;&gt;&lt;code&gt;result.stats.end&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Sass 파일을 컴파일하는 데 걸린 시간 (밀리 초)입니다. 이것은 항상 &lt;a href=&quot;#result-stats-start&quot;&gt; &lt;code&gt;result.stats.start&lt;/code&gt; &lt;/a&gt; 빼기 &lt;a href=&quot;#result-stats-end&quot;&gt; &lt;code&gt;result.stats.end&lt;/code&gt; 와 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7abbbaf1e251eee094649d42d65fbbe127a68f" translate="yes" xml:space="preserve">
          <source>The numbers must either all have compatible units, or all be unitless. And since the numbers&amp;rsquo; units may differ, the output takes the unit of the first number.</source>
          <target state="translated">숫자에는 모두 호환되는 단위가 있거나 모두 단위가 없어야합니다. 그리고 숫자의 단위가 다를 수 있으므로 출력은 첫 번째 숫자의 단위를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f8e696f26ae38f53863611394de68aa0bb01f4f" translate="yes" xml:space="preserve">
          <source>The operation is surrounded by parentheses, unless those parentheses are outside a list that contains the operation.</source>
          <target state="translated">해당 괄호가 작업을 포함하는 목록 외부에 있지 않는 한 작업은 괄호로 묶여 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01dbf707a09e349e25aa75b85c419e95881e1bf" translate="yes" xml:space="preserve">
          <source>The parent selector can also be used within SassScript. It&amp;rsquo;s a special expression that returns the current parent selector in the same format used by &lt;a href=&quot;../modules/selector#selector-values&quot;&gt;selector functions&lt;/a&gt;: a comma-separated list (the selector list) that contains space-separated lists (the complex selectors) that contain unquoted strings (the compound selectors).</source>
          <target state="translated">상위 선택기는 SassScript 내에서도 사용할 수 있습니다. &lt;a href=&quot;../modules/selector#selector-values&quot;&gt;선택자 함수에서&lt;/a&gt; 사용하는 것과 동일한 형식으로 현재 부모 선택자를 반환하는 특수 표현식입니다 . 따옴표로 묶지 않은 문자열 (복합 선택자)을 포함하는 공백으로 구분 된 목록 (복합 선택자)을 포함하는 쉼표로 구분 된 목록 (선택자 목록)입니다.</target>
        </trans-unit>
        <trans-unit id="33cf53c06757f4836b577423ea6b3e12913ce928" translate="yes" xml:space="preserve">
          <source>The parent selector, &lt;code&gt;&amp;amp;&lt;/code&gt;, is a special selector invented by Sass that&amp;rsquo;s used in &lt;a href=&quot;../style-rules#nesting&quot;&gt;nested selectors&lt;/a&gt; to refer to the outer selector. It makes it possible to re-use the outer selector in more complex ways, like adding a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes&quot;&gt;pseudo-class&lt;/a&gt; or adding a selector &lt;em&gt;before&lt;/em&gt; the parent.</source>
          <target state="translated">부모 선택자 &lt;code&gt;&amp;amp;&lt;/code&gt; 는 Sass가 개발 한 특수 선택자로서, &lt;a href=&quot;../style-rules#nesting&quot;&gt;중첩 선택자&lt;/a&gt; 에서 외부 선택자를 참조하는 데 사용됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes&quot;&gt;의사 클래스를&lt;/a&gt; 추가하거나 부모 &lt;em&gt;앞에&lt;/em&gt; 선택자를 추가하는 것과 같이 더 복잡한 방법으로 외부 선택기를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6045ebfa783a9c7f7a09d4adea3c9f23c023f23d" translate="yes" xml:space="preserve">
          <source>The property namespace itself can also have a value. For example:</source>
          <target state="translated">속성 네임 스페이스 자체도 값을 가질 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9faf02a5d158700112a121804e3476e1e235849f" translate="yes" xml:space="preserve">
          <source>The result is stored in a variable or returned by a function.</source>
          <target state="translated">결과는 변수에 저장되거나 함수에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b68e2b075df984e14d6bb9bdb6c77aed78be95b7" translate="yes" xml:space="preserve">
          <source>The result is used as part of another operation (other than &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">결과는 다른 작업의 일부로 사용됩니다 ( &lt;code&gt;/&lt;/code&gt; 제외).</target>
        </trans-unit>
        <trans-unit id="f3cf804d759af28028f8dc65268ebce4d85fc673" translate="yes" xml:space="preserve">
          <source>The returned function can be called using &lt;a href=&quot;#call&quot;&gt;&lt;code&gt;meta.call()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 함수는 &lt;a href=&quot;#call&quot;&gt; &lt;code&gt;meta.call()&lt;/code&gt; &lt;/a&gt; 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad79e11fc27ef9189366d5666deab3f58929d61" translate="yes" xml:space="preserve">
          <source>The returned list is always comma-separated and the sub-lists are always space-separated.</source>
          <target state="translated">반환 된 목록은 항상 쉼표로 구분되고 하위 목록은 항상 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb24797caa0933903bba73e0a6f76e56dd41773" translate="yes" xml:space="preserve">
          <source>The returned list is comma-separated, and the simple selectors are unquoted strings.</source>
          <target state="translated">반환 된 목록은 쉼표로 구분되며 단순 선택기는 따옴표가없는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="757025ff75dab36d072fa990d532475fa92d86c9" translate="yes" xml:space="preserve">
          <source>The rule is written &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot;&lt;/code&gt;. It loads the module at the given URL just like &lt;code&gt;@use&lt;/code&gt;, but it makes the &lt;a href=&quot;use#private-members&quot;&gt;public&lt;/a&gt; members of the loaded module available to users of your module as though they were defined directly in your module. Those members aren&amp;rsquo;t available in your module, though&amp;mdash;if you want that, you&amp;rsquo;ll need to write a &lt;code&gt;@use&lt;/code&gt; rule as well. Don&amp;rsquo;t worry, it&amp;rsquo;ll only load the module once!</source>
          <target state="translated">규칙은 &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot;&lt;/code&gt; 로 작성 됩니다. &lt;code&gt;@use&lt;/code&gt; 처럼 주어진 URL에서 모듈을로드 하지만 로드 된 모듈 의 &lt;a href=&quot;use#private-members&quot;&gt;공용&lt;/a&gt; 멤버를 모듈에서 직접 정의한 것처럼 모듈 사용자가 사용할 수 있도록합니다. 하지만 이러한 멤버는 모듈에서 사용할 수 없습니다. 원하는 경우 &lt;code&gt;@use&lt;/code&gt; 규칙도 작성해야합니다 . 걱정하지 마세요. 모듈은 한 번만로드됩니다!</target>
        </trans-unit>
        <trans-unit id="d4b2d6f15b257b97df1f0f2487bd98118e3ddbbe" translate="yes" xml:space="preserve">
          <source>The same mixins can be done in the &lt;code&gt;.sass&lt;/code&gt; shorthand syntax:</source>
          <target state="translated">&lt;code&gt;.sass&lt;/code&gt; 속기 구문 에서 동일한 믹스 인을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e43b849eba22e5bd20a341f09cad9fb44cd8782" translate="yes" xml:space="preserve">
          <source>The second and older syntax, known as the indented syntax (or sometimes just &quot;Sass&quot;), provides a more concise way of writing CSS. It uses indentation rather than brackets to indicate nesting of selectors, and newlines rather than semicolons to separate properties. Some people find this to be easier to read and quicker to write than SCSS. The indented syntax has all the same features, although some of them have slightly different syntax; this is described in &lt;a href=&quot;http://sass-lang.com/documentation/file.INDENTED_SYNTAX.html&quot;&gt;the indented syntax reference&lt;/a&gt;. Files using this syntax have the &lt;code&gt;.sass&lt;/code&gt; extension.</source>
          <target state="translated">들여 쓰기 된 구문 (또는 때로는 &quot;Sass&quot;)으로 알려진 두 번째 및 이전 구문은 CSS를보다 간결하게 작성하는 방법을 제공합니다. 선택기의 중첩을 나타 내기 위해 대괄호 대신 들여 쓰기를 사용하고 속성을 구분하기 위해 세미콜론 대신 개행을 사용합니다. 어떤 사람들은 SCSS보다 읽기 쉽고 쓰기가 더 쉽다고 생각합니다. 들여 쓰기 된 구문은 모든 기능이 동일하지만 일부 구문은 약간 다릅니다. 이것은 &lt;a href=&quot;http://sass-lang.com/documentation/file.INDENTED_SYNTAX.html&quot;&gt;들여 쓰기 된 구문 참조에&lt;/a&gt; 설명되어 있습니다. 이 구문을 사용하는 파일의 확장자 는 &lt;code&gt;.sass&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36a43cc0355a475c3a5d17b8d4af8d46efc2ad81" translate="yes" xml:space="preserve">
          <source>The simplest &lt;code&gt;@use&lt;/code&gt; rule is written &lt;code&gt;@use &quot;&amp;lt;url&amp;gt;&quot;&lt;/code&gt;, which loads the module at the given URL. Any styles loaded this way will be included exactly once in the compiled CSS output, no matter how many times those styles are loaded.</source>
          <target state="translated">가장 간단한 &lt;code&gt;@use&lt;/code&gt; 규칙은 주어진 URL에서 모듈을로드하는 &lt;code&gt;@use &quot;&amp;lt;url&amp;gt;&quot;&lt;/code&gt; 로 작성됩니다. 이러한 방식으로로드 된 모든 스타일은 해당 스타일이로드 된 횟수에 관계없이 컴파일 된 CSS 출력에 정확히 한 번 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b582fe54adc0be359d0bf8ca9baee65d6ece85" translate="yes" xml:space="preserve">
          <source>The simplest expressions just represent static values:</source>
          <target state="translated">가장 간단한 표현식은 정적 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9cb763b215fc2725feaff8287b961843109bd5dc" translate="yes" xml:space="preserve">
          <source>The singleton &lt;a href=&quot;../values/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">싱글 톤 &lt;a href=&quot;../values/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de66954bc00010aadd593163369a10f26534482a" translate="yes" xml:space="preserve">
          <source>The singleton &lt;a href=&quot;values/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">싱글 톤 &lt;a href=&quot;values/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="5d900ce8f41e3928d18e3297e89e7fb17b931b22" translate="yes" xml:space="preserve">
          <source>The source map that maps the compiled CSS to the source files from which it was generated, as a &lt;a href=&quot;https://nodejs.org/api/buffer.html&quot;&gt;Buffer&lt;/a&gt;. This can be converted to a string by calling &lt;a href=&quot;https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end&quot;&gt;&lt;code&gt;Buffer.toString()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 CSS를 생성 된 소스 파일에 &lt;a href=&quot;https://nodejs.org/api/buffer.html&quot;&gt;Buffer&lt;/a&gt; 로 매핑하는 소스 맵입니다 . &lt;a href=&quot;https://nodejs.org/api/buffer.html#buffer_buf_tostring_encoding_start_end&quot;&gt; &lt;code&gt;Buffer.toString()&lt;/code&gt; &lt;/a&gt; 을 호출하여 문자열로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="436159b068f42295d043bea8e8ff93d4d6028a14" translate="yes" xml:space="preserve">
          <source>The source map uses absolute &lt;a href=&quot;https://en.wikipedia.org/wiki/File_URI_scheme&quot;&gt;&lt;code&gt;file:&lt;/code&gt; URLs&lt;/a&gt; to link to the Sass source files, except if the source file comes from the &lt;a href=&quot;#data&quot;&gt;&lt;code&gt;data&lt;/code&gt; option&lt;/a&gt; in which case it lists its URL as &lt;code&gt;stdin&lt;/code&gt;.</source>
          <target state="translated">소스 맵은 절대 &lt;a href=&quot;https://en.wikipedia.org/wiki/File_URI_scheme&quot;&gt; &lt;code&gt;file:&lt;/code&gt; URL&lt;/a&gt; 을 사용 하여 Sass 소스 파일에 링크합니다. 단, 소스 파일이 &lt;a href=&quot;#data&quot;&gt; &lt;code&gt;data&lt;/code&gt; 옵션&lt;/a&gt; 에서 가져온 경우에는 URL이 &lt;code&gt;stdin&lt;/code&gt; 으로 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3954505b46420b22fa34aefdf8731c17376b09c" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;-&lt;/code&gt; can be passed in place of the input file to tell Sass to read the input file from &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;standard input&lt;/a&gt;. Sass will default to parsing it as SCSS unless the &lt;a href=&quot;#indented&quot;&gt;&lt;code&gt;--indented&lt;/code&gt; flag&lt;/a&gt; is passed.</source>
          <target state="translated">특수 문자열 &lt;code&gt;-&lt;/code&gt; 의 입력 파일을 읽을 말대꾸를 말할 입력 파일의 위치에 전달 될 수있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;표준 입력을&lt;/a&gt; . Sass는 &lt;a href=&quot;#indented&quot;&gt; &lt;code&gt;--indented&lt;/code&gt; 플래그&lt;/a&gt; 가 전달 되지 않는 한 기본적으로 SCSS로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="b03fb84cc6c300d7b847ab2fd90d935f166ef691" translate="yes" xml:space="preserve">
          <source>The stylesheet where the error occurred. If the error occurred in a stylesheet loaded from disk, this is the absolute path of that stylesheet. If the error occurred in a stylesheet that was loaded from an &lt;a href=&quot;#importer&quot;&gt;importer&lt;/a&gt; which returned the stylesheet&amp;rsquo;s contents, this is the raw string of the &lt;code&gt;@use&lt;/code&gt; or &lt;code&gt;@import&lt;/code&gt; that loaded that stylesheet. If it occurred in the contents of the &lt;a href=&quot;#data&quot;&gt;&lt;code&gt;data&lt;/code&gt; option&lt;/a&gt;, this is the string &lt;code&gt;&quot;stdin&quot;&lt;/code&gt;.</source>
          <target state="translated">오류가 발생한 스타일 시트입니다. 디스크에서로드 된 스타일 시트에서 오류가 발생한 경우 이는 해당 스타일 시트의 절대 경로입니다. 스타일 시트의 내용을 반환 한 &lt;a href=&quot;#importer&quot;&gt;임포터&lt;/a&gt; 에서로드 된 스타일 시트에서 오류가 발생한 경우 이는 해당 스타일 시트를로드 한 &lt;code&gt;@use&lt;/code&gt; 또는 &lt;code&gt;@import&lt;/code&gt; 의 원시 문자열입니다 . &lt;a href=&quot;#data&quot;&gt; &lt;code&gt;data&lt;/code&gt; 옵션&lt;/a&gt; 의 내용에서 발생한 경우 &lt;code&gt;&quot;stdin&quot;&lt;/code&gt; 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="8cee4b3810dd190702d457b5ef9a574057431cd1" translate="yes" xml:space="preserve">
          <source>The unary operators &lt;a href=&quot;operators/boolean&quot;&gt;&lt;code&gt;not&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;operators/numeric#unary-operators&quot;&gt;&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;operators/string#unary-operators&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단항 연산자 &lt;a href=&quot;operators/boolean&quot;&gt; &lt;code&gt;not&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;operators/numeric#unary-operators&quot;&gt; &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;operators/string#unary-operators&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f820cb74662ee617b7748c4280229a892155029" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;!important&lt;/code&gt;, which is parsed as an unquoted string.</source>
          <target state="translated">따옴표없는 문자열로 구문 분석되는 &lt;code&gt;!important&lt;/code&gt; 값 .</target>
        </trans-unit>
        <trans-unit id="796e8e6715b0c6ac314131eb3bc93601c66c2752" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;null&lt;/code&gt; is the only value of its type. It represents the absence of a value, and is often returned by &lt;a href=&quot;../at-rules/function&quot;&gt;functions&lt;/a&gt; to indicate the lack of a result.</source>
          <target state="translated">값 &lt;code&gt;null&lt;/code&gt; 가 해당 유형의 유일한 값입니다. 값이 없음을 나타내며 종종 결과가 없음을 나타내는 &lt;a href=&quot;../at-rules/function&quot;&gt;함수&lt;/a&gt; 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4369cb10498fe9fea655a2a3987028bc59e3d23" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$selector&lt;/code&gt; is now &lt;code&gt;((&quot;.foo.bar&quot; &quot;.baz.bang&quot;), &quot;.bip.qux&quot;)&lt;/code&gt;. The compound selectors are quoted here to indicate that they're strings, but in reality they would be unquoted. Even if the parent selector doesn't contain a comma or a space, &lt;code&gt;&amp;amp;&lt;/code&gt; will always have two levels of nesting, so it can be accessed consistently.</source>
          <target state="translated">&lt;code&gt;$selector&lt;/code&gt; 의 값 은 이제 &lt;code&gt;((&quot;.foo.bar&quot; &quot;.baz.bang&quot;), &quot;.bip.qux&quot;)&lt;/code&gt; 입니다. 복합 선택기는 여기에 인용되어있어 문자열임을 나타내지 만 실제로는 인용되지 않습니다. 상위 셀렉터에 쉼표 나 공백이 포함되어 있지 않아도 &lt;code&gt;&amp;amp;&lt;/code&gt; 에는 항상 두 가지 수준의 중첩이 있으므로 일관되게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a4948c64a83be42d30b89a53e4d8614912e979e" translate="yes" xml:space="preserve">
          <source>The way Sass comments work differs substantially between SCSS and the indented syntax. Both syntaxes support two types of comments: comments defined using &lt;code&gt;/* */&lt;/code&gt; that are (usually) compiled to CSS, and comments defined using &lt;code&gt;//&lt;/code&gt; that are not.</source>
          <target state="translated">Sass 주석이 작동하는 방식은 SCSS와 들여 쓰기 구문간에 상당히 다릅니다. 두 구문 모두 두 가지 유형의 주석을 지원합니다. (일반적으로) CSS로 컴파일되는 &lt;code&gt;/* */&lt;/code&gt; 를 사용하여 정의 된 주석 과 그렇지 않은 &lt;code&gt;//&lt;/code&gt; 를 사용하여 정의 된 주석 입니다.</target>
        </trans-unit>
        <trans-unit id="7b8a877b8636d49ac3f65f0bacf33bcb5a47ce42" translate="yes" xml:space="preserve">
          <source>The weight specifies the amount of the first color that should be included in the returned color. The default, &lt;code&gt;50%&lt;/code&gt;, means that half the first color and half the second color should be used. &lt;code&gt;25%&lt;/code&gt; means that a quarter of the first color and three quarters of the second color should be used.</source>
          <target state="translated">가중치는 반환 된 색상에 포함되어야하는 첫 번째 색상의 양을 지정합니다. 기본값 인 &lt;code&gt;50%&lt;/code&gt; 는 첫 번째 색의 절반과 두 번째 색의 절반을 사용해야 함을 의미합니다. &lt;code&gt;25%&lt;/code&gt; 는 첫 번째 색의 1/4과 두 번째 색의 3/4을 사용해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="177252848a5ac086129dcafe1bbac98faf2b4389" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;&amp;lt;div class=&quot;seriousError intrusion&quot;&amp;gt;&lt;/code&gt; will have the &lt;code&gt;hacked.png&lt;/code&gt; background image as well.</source>
          <target state="translated">그런 다음 &lt;code&gt;&amp;lt;div class=&quot;seriousError intrusion&quot;&amp;gt;&lt;/code&gt; 에는 &lt;code&gt;hacked.png&lt;/code&gt; 배경 이미지도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ab2aea6319171b326eb82c34f0565c2dbb0f73" translate="yes" xml:space="preserve">
          <source>There are a number of different things &lt;code&gt;-&lt;/code&gt; can mean in CSS and in Sass. It can be a subtraction operator (as in &lt;code&gt;5px - 3px&lt;/code&gt;), the beginning of a negative number (as in &lt;code&gt;-3px&lt;/code&gt;), a unary negation operator (as in &lt;code&gt;-$var&lt;/code&gt;), or part of an identifier (as in &lt;code&gt;font-weight&lt;/code&gt;). Most of the time, it's clear which is which, but there are some tricky cases. As a general rule, you're safest if:</source>
          <target state="translated">여러 가지가 있습니다 &lt;code&gt;-&lt;/code&gt; CSS와 사스의 의미는. 빼기 연산자 ( &lt;code&gt;5px - 3px&lt;/code&gt; ), 음수의 시작 ( &lt;code&gt;-3px&lt;/code&gt; ), 단항 부정 연산자 ( &lt;code&gt;-$var&lt;/code&gt; ) 또는 식별자의 일부 ( &lt;code&gt;font-weight&lt;/code&gt; ) ). 대부분의 경우 어느 것이 어느 것인지 분명하지만, 까다로운 경우가 있습니다. 일반적으로 다음과 같은 경우 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8f0ec852d33f9ad4e0e7df6cbcabfcee4d9009eb" translate="yes" xml:space="preserve">
          <source>There are often cases when designing a page when one class should have all the styles of another class, as well as its own specific styles. For example, the &lt;a href=&quot;http://getbem.com/naming/&quot;&gt;BEM methodology&lt;/a&gt; encourages modifier classes that go on the same elements as block or element classes. But this can create cluttered HTML, it's prone to errors from forgetting to include both classes, and it can bring non-semantic style concerns into your markup.</source>
          <target state="translated">페이지를 디자인 할 때 한 클래스가 다른 클래스의 모든 스타일과 고유 한 스타일을 가져야하는 경우가 종종 있습니다. 예를 들어, &lt;a href=&quot;http://getbem.com/naming/&quot;&gt;BEM 방법론&lt;/a&gt; 은 블록 또는 요소 클래스와 동일한 요소로 이동하는 수정 자 클래스를 권장합니다. 그러나 이것은 혼란스러운 HTML을 만들 수 있고, 두 클래스를 모두 포함하는 것을 잊음으로 인해 오류가 발생하기 쉬우 며, 마크 업에 의미없는 스타일 문제를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7ab8877161595d185108311821356f071bb55a2" translate="yes" xml:space="preserve">
          <source>There are often cases when designing a page when one class should have all the styles of another class, as well as its own specific styles. The most common way of handling this is to use both the more general class and the more specific class in the HTML. For example, suppose we have a design for a normal error and also for a serious error. We might write our markup like so:</source>
          <target state="translated">한 클래스가 다른 클래스의 모든 스타일과 고유 한 스타일을 가져야하는 경우 페이지를 디자인 할 때가 종종 있습니다. 이를 처리하는 가장 일반적인 방법은 HTML에서보다 일반적인 클래스와보다 구체적인 클래스를 모두 사용하는 것입니다. 예를 들어, 정상적인 오류와 심각한 오류에 대한 설계가 있다고 가정합니다. 마크 업을 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5462dc7a171bbf438178cd731b27497ccb08cbce" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of &lt;code&gt;@extend&lt;/code&gt; within directives such as &lt;code&gt;@media&lt;/code&gt;. Sass is unable to make CSS rules outside of the &lt;code&gt;@media&lt;/code&gt; block apply to selectors inside it without creating a huge amount of stylesheet bloat by copying styles all over the place. This means that if you use &lt;code&gt;@extend&lt;/code&gt; within &lt;code&gt;@media&lt;/code&gt; (or other CSS directives), you may only extend selectors that appear within the same directive block.</source>
          <target state="translated">&lt;code&gt;@media&lt;/code&gt; 와 같은 지시문 내 에서 &lt;code&gt;@extend&lt;/code&gt; 사용에 대한 제한이 있습니다 . Sass는 &lt;code&gt;@media&lt;/code&gt; 블록 외부의 CSS 규칙을 사방에 스타일을 복사하여 엄청난 양의 스타일 시트 팽창을 만들지 않으면 서 내부의 선택기에 적용 할 수 없습니다. 이는 &lt;code&gt;@media&lt;/code&gt; (또는 다른 CSS 지시문) 내에서 &lt;code&gt;@extend&lt;/code&gt; 를 사용하는 경우 동일한 지시문 블록 내에 나타나는 선택기 만 확장 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="937ed733728f67555d53882c99fae9ce9823cc28" translate="yes" xml:space="preserve">
          <source>There are two special values you can pass to &lt;code&gt;@at-root&lt;/code&gt;. &quot;rule&quot; refers to normal CSS rules; &lt;code&gt;@at-root (without: rule)&lt;/code&gt; is the same as &lt;code&gt;@at-root&lt;/code&gt; with no query. &lt;code&gt;@at-root (without: all)&lt;/code&gt; means that the styles should be moved outside of &lt;em&gt;all&lt;/em&gt; directives and CSS rules.</source>
          <target state="translated">&lt;code&gt;@at-root&lt;/code&gt; 전달할 수있는 두 가지 특수 값이 있습니다 . &quot;rule&quot;은 일반적인 CSS 규칙을 나타냅니다. &lt;code&gt;@at-root (without: rule)&lt;/code&gt; 는 &lt;code&gt;@at-root&lt;/code&gt; 와 같 으며 쿼리는 없습니다. &lt;code&gt;@at-root (without: all)&lt;/code&gt; 는 스타일이 &lt;em&gt;모든&lt;/em&gt; 지시문 및 CSS 규칙 외부로 이동되어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="b519ebe4607dfda6aeda062897ebaecfe93b3483" translate="yes" xml:space="preserve">
          <source>There are two syntaxes available for Sass. The first, known as SCSS (Sassy CSS) and used throughout this reference, is an extension of the syntax of CSS. This means that every valid CSS stylesheet is a valid SCSS file with the same meaning. In addition, SCSS understands most CSS hacks and vendor-specific syntax, such as &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms530752.aspx&quot;&gt;IE's old &lt;code&gt;filter&lt;/code&gt; syntax&lt;/a&gt;. This syntax is enhanced with the Sass features described below. Files using this syntax have the &lt;code&gt;.scss&lt;/code&gt; extension.</source>
          <target state="translated">Sass에는 두 가지 구문이 있습니다. SCSS (Sassy CSS)라고하며이 참조에서 사용되는 첫 번째는 CSS 구문의 확장입니다. 이는 모든 유효한 CSS 스타일 시트가 동일한 의미를 가진 유효한 SCSS 파일임을 의미합니다. 또한 SCSS는 대부분의 CSS 핵과 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms530752.aspx&quot;&gt;IE의 오래된 &lt;code&gt;filter&lt;/code&gt; 구문&lt;/a&gt; 과 같은 공급 업체별 구문을 이해 합니다 . 이 구문은 아래 설명 된 Sass 기능으로 향상되었습니다. 이 구문을 사용하는 파일의 확장자 는 &lt;code&gt;.scss&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a26deaf0a9439c6e86ec39bb3fa8607ec5746ff" translate="yes" xml:space="preserve">
          <source>There is currently no way to catch errors.</source>
          <target state="translated">현재 오류를 잡을 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="35e08781e208d3af3549928c34bda4ca6736f556" translate="yes" xml:space="preserve">
          <source>There is one exception to this, though: when using &lt;a href=&quot;#interpolation_&quot;&gt;&lt;code&gt;#{}&lt;/code&gt; interpolation&lt;/a&gt;, quoted strings are unquoted. This makes it easier to use e.g. selector names in &lt;a href=&quot;#mixins&quot;&gt;mixins&lt;/a&gt;. For example:</source>
          <target state="translated">그러나 여기에는 한 가지 예외가 있습니다 : &lt;a href=&quot;#interpolation_&quot;&gt; &lt;code&gt;#{}&lt;/code&gt; interpolation을&lt;/a&gt; 사용할 때 인용 된 문자열은 인용되지 않습니다. 예를 들어 &lt;a href=&quot;#mixins&quot;&gt;mixin&lt;/a&gt; 에서 선택기 이름을 사용하기가 더 쉽습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20dbaee7ae0e6049cad0173a88c1ba4a30c40de1" translate="yes" xml:space="preserve">
          <source>There was no way to define private members or placeholder selectors that were inaccessible to downstream stylesheets.</source>
          <target state="translated">다운 스트림 스타일 시트에 액세스 할 수없는 개인 멤버 또는 플레이스 홀더 선택기를 정의 할 방법이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="82eb3717df0020ad61d2402a572d1d55730be5fa" translate="yes" xml:space="preserve">
          <source>These operators don&amp;rsquo;t just work for strings! They can be used with any values that can be written to CSS, with a few exceptions:</source>
          <target state="translated">이 연산자는 문자열에서만 작동하지 않습니다! 몇 가지 예외를 제외하고 CSS에 쓸 수있는 모든 값과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b097c3dab72faa37e38ebf74cdf858cfe6fb45c" translate="yes" xml:space="preserve">
          <source>These options affect &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션은 &lt;a href=&quot;#many-to-many-mode&quot;&gt;다 대다 모드에&lt;/a&gt; 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="c05227572a6357ec4b3012292934e49cb3804f64" translate="yes" xml:space="preserve">
          <source>These options are available for all migrators.</source>
          <target state="translated">이러한 옵션은 모든 이주자에 대해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd355594db8f1eb5026bc040673b5d51f4bbe6d" translate="yes" xml:space="preserve">
          <source>These options control how Sass loads it input files.</source>
          <target state="translated">이 옵션은 Sass가 입력 파일을로드하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="ef7ae2a9372ce8271bb3541f0d94e91316325eb9" translate="yes" xml:space="preserve">
          <source>These options control how Sass loads its input files and how it produces output files.</source>
          <target state="translated">이 옵션은 Sass가 입력 파일을로드하는 방법과 출력 파일을 생성하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="10dd9f6d527c692240ebf4989eeba62d38c61af6" translate="yes" xml:space="preserve">
          <source>These options control how Sass produces output files.</source>
          <target state="translated">이 옵션은 Sass가 출력 파일을 생성하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b66c047e9e9ad78bc0a2546bbc62740889bf561f" translate="yes" xml:space="preserve">
          <source>These options use JavaScript callbacks to expand the functionality of Sass compilation.</source>
          <target state="translated">이 옵션은 JavaScript 콜백을 사용하여 Sass 컴파일의 기능을 확장합니다.</target>
        </trans-unit>
        <trans-unit id="7ea9aa39dc5c3bedef3d7efd5836c2b8e43f3d9b" translate="yes" xml:space="preserve">
          <source>These statements can only be used at the top level of a stylesheet, or nested within a CSS statement at the top level:</source>
          <target state="translated">이러한 문은 스타일 시트의 최상위 수준에서만 사용되거나 최상위 수준의 CSS 문 내에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea27c3dc02e951c57770c285fb9fd953594e4c9" translate="yes" xml:space="preserve">
          <source>These statements produce CSS. They can be used anywhere except within a &lt;code&gt;@function&lt;/code&gt;:</source>
          <target state="translated">이 문은 CSS를 생성합니다. &lt;code&gt;@function&lt;/code&gt; 내를 제외하고 어디에서나 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d950e2ea927a1928b9ee8e793a562a1b5b5b427" translate="yes" xml:space="preserve">
          <source>These types of statements can be used anywhere in a Sass stylesheet:</source>
          <target state="translated">이러한 유형의 문은 Sass 스타일 시트의 어느 곳에서나 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a58582d7e3c0936698ed9917e60005f1e3ac96e" translate="yes" xml:space="preserve">
          <source>This API currently provides no way of creating a &lt;a href=&quot;values/strings#quoted&quot;&gt;quoted&lt;/a&gt; string.</source>
          <target state="translated">이 API는 현재 &lt;a href=&quot;values/strings#quoted&quot;&gt;인용 된&lt;/a&gt; 문자열 을 생성하는 방법을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="62f2e41a71d691060ac046f08fee96ede20d16ff" translate="yes" xml:space="preserve">
          <source>This API currently provides no way of distinguishing between a &lt;a href=&quot;values/strings#quoted&quot;&gt;quoted&lt;/a&gt; and &lt;a href=&quot;values/strings#unquoted&quot;&gt;unquoted&lt;/a&gt; string.</source>
          <target state="translated">이 API는 현재 구별 방법 제공하지 않습니다 &lt;a href=&quot;values/strings#quoted&quot;&gt;인용&lt;/a&gt; 과 &lt;a href=&quot;values/strings#unquoted&quot;&gt;인용되지 않은&lt;/a&gt; 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="1a041603c99f20b135e1d025e99e27e8081832ea" translate="yes" xml:space="preserve">
          <source>This array of strings option provides &lt;a href=&quot;at-rules/import#load-paths&quot;&gt;load paths&lt;/a&gt; for Sass to look for imports. Earlier load paths will take precedence over later ones.</source>
          <target state="translated">이 문자열 배열 옵션은 Sass가 가져 오기를 찾을 수 있도록 &lt;a href=&quot;at-rules/import#load-paths&quot;&gt;로드 경로&lt;/a&gt; 를 제공합니다 . 이전로드 경로가 이후 경로보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f824a5f4c71aaf76fa508508688408b5e1e19520" translate="yes" xml:space="preserve">
          <source>This behavior wasn&amp;rsquo;t very useful, since it channel-by-channel RGB arithmetic didn&amp;rsquo;t correspond well to how humans perceive color. &lt;a href=&quot;modules/color&quot;&gt;Color functions&lt;/a&gt; were added which are much more useful, and color operations were deprecated. They&amp;rsquo;re still supported in LibSass and Ruby Sass, but they&amp;rsquo;ll produce warnings and users are strongly encouraged to avoid them.</source>
          <target state="translated">이 동작은 채널 별 RGB 산술이 인간이 색상을 인식하는 방식과 잘 일치하지 않았기 때문에 그다지 유용하지 않았습니다. 훨씬 더 유용한 &lt;a href=&quot;modules/color&quot;&gt;색상 기능&lt;/a&gt; 이 추가되었으며 색상 작업은 더 이상 사용되지 않습니다. LibSass 및 Ruby Sass에서 여전히 지원되지만 경고를 생성하므로 사용자는이를 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="393062f3a86260cfd89e3908eb5da02d6428b041" translate="yes" xml:space="preserve">
          <source>This can also return the number of pairs in a map.</source>
          <target state="translated">이것은 또한 맵에서 쌍의 수를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c69a73969e7d7990817c39402f17797d2d227a" translate="yes" xml:space="preserve">
          <source>This can be used anywhere in a stylesheet. It can even be nested within style rules to create nested styles!</source>
          <target state="translated">스타일 시트의 어느 곳에서나 사용할 수 있습니다. 스타일 규칙 내에 중첩되어 중첩 된 스타일을 만들 수도 있습니다!</target>
        </trans-unit>
        <trans-unit id="cdb80bd6c90ed216da3aefd940259e454d1d891f" translate="yes" xml:space="preserve">
          <source>This can change the red, green, blue, saturation, value, and alpha properties. The properties are specified as keyword arguments. All arguments should be percentages between &lt;code&gt;0%&lt;/code&gt; and &lt;code&gt;100%&lt;/code&gt;.</source>
          <target state="translated">빨강, 녹색, 파랑, 채도, 값 및 알파 속성을 변경할 수 있습니다. 속성은 키워드 인수로 지정됩니다. 모든 인수는 &lt;code&gt;0%&lt;/code&gt; 에서 &lt;code&gt;100%&lt;/code&gt; 사이의 백분율이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6eaf8514edecd38eceb75d33a0b8c207db8941fb" translate="yes" xml:space="preserve">
          <source>This can return the following values:</source>
          <target state="translated">다음 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e2c17d4304cc87c1fc694bbfd2c75778c87cdc6" translate="yes" xml:space="preserve">
          <source>This can return the nth pair in a map as well.</source>
          <target state="translated">지도에서 n 번째 쌍도 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d5d8211da10fe571fd182677e98f081c6280cc4" translate="yes" xml:space="preserve">
          <source>This can return the number of pairs in a map as well.</source>
          <target state="translated">지도의 쌍 수를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8071308e261c0171947c455efd036ab5b392e9a" translate="yes" xml:space="preserve">
          <source>This can return the position of a pair in a map as well.</source>
          <target state="translated">지도에서 쌍의 위치를 ​​반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="448ab533cf42f63c3d93b37aaf75e3db827f3221" translate="yes" xml:space="preserve">
          <source>This cannot provide configuration to a module that&amp;rsquo;s already been loaded, whether or not it was already loaded with configuration.</source>
          <target state="translated">이는 이미 구성과 함께로드되었는지 여부에 관계없이 이미로드 된 모듈에 구성을 제공 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2470ec1e576bd8bfdffd93d37a0c8c8ffb1bcadf" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;values/booleans&quot;&gt;Sass boolean&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;values/booleans&quot;&gt;Sass 부울을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec35d9eaaecbd91ad5d3c671be2f701bc9ef78f6" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;values/colors&quot;&gt;Sass color&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;values/colors&quot;&gt;Sass 색상을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d09011ebcd78969c2878a36e8ce4bc298d76f554" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;values/lists&quot;&gt;Sass list&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;values/lists&quot;&gt;Sass 목록을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6c4afb0aabba5307b0ecddc274c63299172dc9e5" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;values/maps&quot;&gt;Sass map&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;values/maps&quot;&gt;Sass 맵을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1967f3e1349722685a8352787230c4240b7e0e19" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;values/numbers&quot;&gt;Sass number&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;values/numbers&quot;&gt;Sass 번호를&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ca7d84bac27fa6d9dff8ed90618e050e58854643" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;values/strings&quot;&gt;Sass string&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;values/strings&quot;&gt;Sass 문자열을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e789b7f43d1e4e8d8e1d9b1ec84f49058bbdf636" translate="yes" xml:space="preserve">
          <source>This class represents the &lt;a href=&quot;values/null&quot;&gt;Sass &lt;code&gt;null&lt;/code&gt; value&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;values/null&quot;&gt;Sass &lt;code&gt;null&lt;/code&gt; 값을&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9ecaa4da7a11bff49a6a10777103a7831874c43a" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually use a function, but it&amp;rsquo;s still one of the most common ways to use lists. The &lt;a href=&quot;../at-rules/control/each&quot;&gt;&lt;code&gt;@each&lt;/code&gt; rule&lt;/a&gt; evaluates a block of styles for each element in a list, and assigns that element to a variable.</source>
          <target state="translated">이것은 실제로 함수를 사용하지 않지만 여전히 목록을 사용하는 가장 일반적인 방법 중 하나입니다. &lt;a href=&quot;../at-rules/control/each&quot;&gt; &lt;code&gt;@each&lt;/code&gt; 의 규칙&lt;/a&gt; 변수에 해당 요소 목록의 각 요소의 스타일의 블럭을 평가하고 할당한다.</target>
        </trans-unit>
        <trans-unit id="8644e33918a2fb396c4458617394ab090c44dffe" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually use a function, but it&amp;rsquo;s still one of the most common ways to use maps. The &lt;a href=&quot;../at-rules/control/each&quot;&gt;&lt;code&gt;@each&lt;/code&gt; rule&lt;/a&gt; evaluates a block of styles for each key/value pair in a map. The key and the value are assigned to variables so they can easily be accessed in the block.</source>
          <target state="translated">이것은 실제로 함수를 사용하지 않지만 여전히지도를 사용하는 가장 일반적인 방법 중 하나입니다. &lt;a href=&quot;../at-rules/control/each&quot;&gt; &lt;code&gt;@each&lt;/code&gt; 의 규칙은&lt;/a&gt; 맵에서 각각의 키 / 값 쌍에 대해 스타일의 블럭을 평가한다. 키와 값은 변수에 할당되어 블록에서 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76d2e1e886dbf0b292e84944953c3b291a0fa41e" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t make any members from the loaded module available in the current module.</source>
          <target state="translated">로드 된 모듈의 멤버를 현재 모듈에서 사용할 수있게 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3145a9fe89c45897693d218f34c1456c6f180d14" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-C&lt;/code&gt;) tells Sass not to cache parsed files at all.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-C&lt;/code&gt; )는 Sass에게 구문 분석 된 파일을 전혀 캐시하지 않도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="cba58e5da7cf96a522bb540b339ad57565167faf" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-c&lt;/code&gt;) tells Sass to emit &lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code#Colors&quot;&gt;terminal colors&lt;/a&gt;, and the inverse &lt;code&gt;--no-color&lt;/code&gt; tells it not to emit colors. By default, it will emit colors if it looks like it&amp;rsquo;s being run on a terminal that supports them.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-c&lt;/code&gt; )는 Sass에게 &lt;a href=&quot;https://en.wikipedia.org/wiki/ANSI_escape_code#Colors&quot;&gt;터미널 색상&lt;/a&gt; 을 방출하도록 지시 하고 역 &lt;code&gt;--no-color&lt;/code&gt; 는 색상을 방출하지 않도록 지시합니다. 기본적으로 색상을 지원하는 터미널에서 실행되는 것처럼 보이면 색상을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="59b8db0c6f851879c91baf0a6e97c2614e836de5" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-c&lt;/code&gt;) tells Sass to verify that the syntax of its input file is valid without executing that file. If the syntax is valid, it exits with &lt;a href=&quot;https://en.wikipedia.org/wiki/Exit_status&quot;&gt;status&lt;/a&gt; 0. It can&amp;rsquo;t be used in &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-c&lt;/code&gt; )는 입력 파일의 구문이 해당 파일을 실행하지 않고 유효한지 확인하도록 Sass에 지시합니다. 구문이 유효하면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Exit_status&quot;&gt;상태&lt;/a&gt; 0으로 종료 &lt;a href=&quot;#many-to-many-mode&quot;&gt;됩니다&lt;/a&gt; . 다 대다 모드에서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ba94eb2765b012d717e240bf9fc4ef42327807a7" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-f&lt;/code&gt;) may only be passed in &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;. It causes Sass files to &lt;em&gt;always&lt;/em&gt; be compiled to CSS files, instead of only being compiled when the source files are more up-to-date than the output.</source>
          <target state="translated">이 플래그 (약식 &lt;code&gt;-f&lt;/code&gt; )는 다 &lt;a href=&quot;#many-to-many-mode&quot;&gt;대다 모드&lt;/a&gt; 로만 전달 될 수 있습니다 . 소스 파일이 출력보다 최신 일 때만 컴파일되는 대신 Sass 파일이 &lt;em&gt;항상&lt;/em&gt; CSS 파일로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb018de0f2666a606d2352ee84304116a8530b2" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-g&lt;/code&gt;) causes Sass to emit dummy &lt;code&gt;@media&lt;/code&gt; queries that indicate where each style rule was defined in the source stylehseet.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-g&lt;/code&gt; )는 Sass가 소스 스타일 시트에서 각 스타일 규칙이 정의 된 위치를 나타내는 더미 &lt;code&gt;@media&lt;/code&gt; 쿼리를 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="ca1572ca86d7ca4546485ffae2c95c2feb7d3cd9" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-h&lt;/code&gt; and &lt;code&gt;-?&lt;/code&gt;) prints a summary of this documentation.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-h&lt;/code&gt; 및 &lt;code&gt;-?&lt;/code&gt; )는이 문서의 요약을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="026a755beccf80cc347b2cc858639f7f26bde58f" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-h&lt;/code&gt;) prints a summary of this documentation.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-h&lt;/code&gt; )는이 문서의 요약을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b985fb7aea9074824137eee30bd5515e66afcfea" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-i&lt;/code&gt;) tells Sass to run in interactive mode, where you can write &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript expressions&lt;/a&gt; and see their results. Interactive mode also supports &lt;a href=&quot;../variables&quot;&gt;variables&lt;/a&gt; and &lt;a href=&quot;../at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rules&lt;/a&gt;.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-i&lt;/code&gt; )는 Sass에게 대화식 모드에서 실행하도록 지시합니다. 여기서 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript 표현식을 작성&lt;/a&gt; 하고 그 결과를 볼 수 있습니다. 대화 형 모드는 &lt;a href=&quot;../variables&quot;&gt;변수&lt;/a&gt; 와 &lt;a href=&quot;../at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 규칙&lt;/a&gt; 도 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="d7c211daef8f069d5b4f6c3ebf373af28aae5593" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-i&lt;/code&gt;) tells Sass to run in interactive mode, where you can write &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript expressions&lt;/a&gt; and see their results. Interactive mode also supports &lt;a href=&quot;../variables&quot;&gt;variables&lt;/a&gt;.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-i&lt;/code&gt; )는 Sass에게 대화식 모드에서 실행하도록 지시합니다. 여기서 &lt;a href=&quot;../syntax/structure#expressions&quot;&gt;SassScript 표현식을 작성&lt;/a&gt; 하고 그 결과를 볼 수 있습니다. 대화 형 모드는 &lt;a href=&quot;../variables&quot;&gt;변수&lt;/a&gt; 도 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="20b50e46535fbc3d6b2e5cd25f77b9d77592dc82" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-n&lt;/code&gt;) tells the migrator not to save any changes to disk. It instead prints the list of files that it would have changed. This is commonly paired with the &lt;a href=&quot;#verbose&quot;&gt;&lt;code&gt;--verbose&lt;/code&gt; option&lt;/a&gt; to print the contents of the changes that would have been made as well.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-n&lt;/code&gt; )는 디스크에 변경 사항을 저장하지 않도록 마이그레이션 자에게 지시합니다. 대신 변경되었을 파일 목록을 인쇄합니다. 이것은 일반적으로 &lt;a href=&quot;#verbose&quot;&gt; &lt;code&gt;--verbose&lt;/code&gt; 옵션&lt;/a&gt; 과 쌍을 이루어 변경된 내용도 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4083b415c480872d9a15ce7ea5d8ccf78b7ada07" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-q&lt;/code&gt;) tells Sass not to emit any warnings when compiling. By default, Sass emits warnings when deprecated features are used or when the &lt;a href=&quot;../at-rules/warn&quot;&gt;&lt;code&gt;@warn&lt;/code&gt; rule&lt;/a&gt; is encountered. It also silences the &lt;a href=&quot;../at-rules/debug&quot;&gt;&lt;code&gt;@debug&lt;/code&gt; rule&lt;/a&gt;.</source>
          <target state="translated">이 플래그 (약식 &lt;code&gt;-q&lt;/code&gt; )는 Sass에게 컴파일 할 때 경고를 표시하지 않도록 지시합니다. 기본적으로 Sass는 더 이상 사용되지 않는 기능이 사용되거나 &lt;a href=&quot;../at-rules/warn&quot;&gt; &lt;code&gt;@warn&lt;/code&gt; 규칙&lt;/a&gt; 이 발생할 때 경고를 내 보냅니다 . 또한 &lt;a href=&quot;../at-rules/debug&quot;&gt; &lt;code&gt;@debug&lt;/code&gt; 규칙을&lt;/a&gt; 침묵시킵니다 .</target>
        </trans-unit>
        <trans-unit id="481e3113fa63399f20eae70eaf8d42a21d099ac4" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-s&lt;/code&gt;) is tells Sass to read its input file from &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;standard input&lt;/a&gt;. When it&amp;rsquo;s passed, no input file may be passed.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-s&lt;/code&gt; )는 Sass에게 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;표준 입력&lt;/a&gt; 에서 입력 파일을 읽도록 지시 합니다 . 전달되면 입력 파일이 전달되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938d6dfc32bd09fc6ce49b539a9b090948a44c7a" translate="yes" xml:space="preserve">
          <source>This flag (abbreviated &lt;code&gt;-v&lt;/code&gt;) tells the migrator to print extra information to the console. By default, it just prints the name of files that are changed, but when combined with the &lt;a href=&quot;#dry-run&quot;&gt;&lt;code&gt;--dry-run&lt;/code&gt; option&lt;/a&gt; it also prints those files&amp;rsquo; new contents.</source>
          <target state="translated">이 플래그 (약어 &lt;code&gt;-v&lt;/code&gt; )는 이주자에게 추가 정보를 콘솔에 인쇄하도록 지시합니다. 기본적으로 변경된 파일의 이름 만 인쇄하지만 &lt;a href=&quot;#dry-run&quot;&gt; &lt;code&gt;--dry-run&lt;/code&gt; 옵션&lt;/a&gt; 과 함께 사용하면 해당 파일의 새 내용도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1b283a36217d300f6fcb0ec4098971332e3ad019" translate="yes" xml:space="preserve">
          <source>This flag (also available as &lt;code&gt;--line-numbers&lt;/code&gt;, abbreviated as &lt;code&gt;-l&lt;/code&gt;) causes Sass to emit comments for every style rule that indicate where each style rule was defined in the source stylesheet.</source>
          <target state="translated">이 플래그 ( &lt;code&gt;--line-numbers&lt;/code&gt; 로도 사용 가능 , &lt;code&gt;-l&lt;/code&gt; 로 축약 됨 )는 Sass가 소스 스타일 시트에서 각 스타일 규칙이 정의 된 위치를 나타내는 모든 스타일 규칙에 대한 주석을 내도록합니다.</target>
        </trans-unit>
        <trans-unit id="cce3e0d7d2eab228413af73d4c1139ff0a33906f" translate="yes" xml:space="preserve">
          <source>This flag acts like the &lt;a href=&quot;#update&quot;&gt;&lt;code&gt;--update&lt;/code&gt; flag&lt;/a&gt;, but after the first round compilation is done Sass stays open and continues compiling stylesheets whenever they or their dependencies change.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;#update&quot;&gt; &lt;code&gt;--update&lt;/code&gt; 플래그&lt;/a&gt; 처럼 작동 하지만 첫 번째 라운드 컴파일이 완료된 후 Sass는 열려 있고 스타일 시트 또는 종속성이 변경 될 때마다 계속해서 스타일 시트를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="008f036652ed82163e6fdef4c42e5d167a8929e6" translate="yes" xml:space="preserve">
          <source>This flag causes Sass not to link from the generated CSS to the source map.</source>
          <target state="translated">이 플래그는 Sass가 생성 된 CSS에서 소스 맵으로 링크하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="520dda4365b641fb8f3fd0b1ef7af7bad4b10820" translate="yes" xml:space="preserve">
          <source>This flag causes Sass to emit comments for every style rule that indicate where each style rule was defined in the source stylesheet. It defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 플래그를 사용하면 Sass가 소스 스타일 시트에서 각 스타일 규칙이 정의 된 위치를 나타내는 모든 스타일 규칙에 대한 주석을 내 보냅니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="770f83dc55da77ed6bbfbab6c47b0b88f83fb5ea" translate="yes" xml:space="preserve">
          <source>This flag controls whether source maps are generated.</source>
          <target state="translated">이 플래그는 소스 맵 생성 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a66efbc5e880a51bb21527cb2546a1532014bf38" translate="yes" xml:space="preserve">
          <source>This flag controls whether the &lt;a href=&quot;#data&quot;&gt;&lt;code&gt;data&lt;/code&gt; option&lt;/a&gt; is parsed as the &lt;a href=&quot;syntax#the-indented-syntax&quot;&gt;indented syntax&lt;/a&gt; or not. It defaults to &lt;code&gt;false&lt;/code&gt;. It has no effect on stylesheets loaded using the &lt;a href=&quot;#file&quot;&gt;&lt;code&gt;file&lt;/code&gt; option&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;#data&quot;&gt; &lt;code&gt;data&lt;/code&gt; 옵션&lt;/a&gt; 이 &lt;a href=&quot;syntax#the-indented-syntax&quot;&gt;들여 쓰기 된 구문으로 구문&lt;/a&gt; 분석 되는지 여부를 제어합니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;a href=&quot;#file&quot;&gt; &lt;code&gt;file&lt;/code&gt; 옵션을&lt;/a&gt; 사용하여로드 된 스타일 시트에는 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cdb9919ff824d6b4c8732edc39c48653df2eb814" translate="yes" xml:space="preserve">
          <source>This flag enables &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;, even if none of the arguments are colon-separated pairs.</source>
          <target state="translated">이 플래그는 인수가 콜론으로 구분 된 쌍이 아니더라도 다 &lt;a href=&quot;#many-to-many-mode&quot;&gt;대다 모드를&lt;/a&gt; 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="4bbc13d561d74375e00461d0d2fcb0403a4c7259" translate="yes" xml:space="preserve">
          <source>This flag is an alternative way of telling Sass that it should read its input file from &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;standard input&lt;/a&gt;. When it&amp;rsquo;s passed, no input file may be passed.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;표준 입력&lt;/a&gt; 에서 입력 파일을 읽어야한다고 Sass에게 알리는 또 다른 방법입니다 . 전달되면 입력 파일이 전달되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb1434afea68c3907e4b83e9245b440f2f0a6d1" translate="yes" xml:space="preserve">
          <source>This flag loads the &lt;a href=&quot;http://compass-style.org/&quot;&gt;Compass framework&lt;/a&gt; and makes its mixins and functions available for use in Sass.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;http://compass-style.org/&quot;&gt;Compass 프레임 워크를&lt;/a&gt; 로드하고 Sass에서 사용할 수있는 믹스 인과 함수를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="65b7022d96f92316215554a90b1c4a5f92a5aa93" translate="yes" xml:space="preserve">
          <source>This flag may only be passed in &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;. It tells Sass to stop compiling immediately when an error is detected, rather than trying to compile other Sass files that may not contain errors.</source>
          <target state="translated">이 플래그는 다 &lt;a href=&quot;#many-to-many-mode&quot;&gt;대다 모드&lt;/a&gt; 에서만 전달 될 수 있습니다 . 오류가 없을 수있는 다른 Sass 파일을 컴파일하는 대신 오류가 감지되면 즉시 컴파일을 중지하도록 Sass에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9f4221e93b16540bae9c482931cf0a247062f047" translate="yes" xml:space="preserve">
          <source>This flag only exists for backwards-compatibility. Source maps are now the recommended way of mapping CSS back to the Sass that generated it.</source>
          <target state="translated">이 플래그는 이전 버전과의 호환성을 위해서만 존재합니다. 소스 맵은 이제 CSS를 생성 한 Sass에 다시 매핑하는 권장 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c81c4dd7d61d0e75b5a0eacbf2ef77cde55ae4ab" translate="yes" xml:space="preserve">
          <source>This flag prints the current version of Sass.</source>
          <target state="translated">이 플래그는 현재 버전의 Sass를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="489139386d874cbededf45319050a1bc0b332829" translate="yes" xml:space="preserve">
          <source>This flag tells Sass never to emit a &lt;code&gt;@charset&lt;/code&gt; declaration or a UTF-8 &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;byte-order mark&lt;/a&gt;. By default, or if &lt;code&gt;--charset&lt;/code&gt; is passed, Sass will insert either a &lt;code&gt;@charset&lt;/code&gt; declaration (in expanded output mode) or a byte-order mark (in compressed output mode) if the stylesheet contains any non-ASCII characters.</source>
          <target state="translated">이 플래그는 Sass에게 &lt;code&gt;@charset&lt;/code&gt; 선언 또는 UTF-8 &lt;a href=&quot;https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8&quot;&gt;바이트 순서 표시를&lt;/a&gt; 절대 내 보내지 않도록 지시합니다 . 기본적으로 또는 &lt;code&gt;--charset&lt;/code&gt; 이 전달되면 Sass는 스타일 시트에 ASCII가 아닌 문자가 포함 된 경우 &lt;code&gt;@charset&lt;/code&gt; 선언 (확장 출력 모드) 또는 바이트 순서 표시 (압축 출력 모드)를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ed118a706d7f6858b3e8cd19e01f4bbe7a9b58c1" translate="yes" xml:space="preserve">
          <source>This flag tells Sass only to emit ASCII characters to the terminal as part of error messages. By default, or if &lt;code&gt;--unicode&lt;/code&gt; is passed, Sass will emit non-ASCII characters for these messages. This flag does not affect the CSS output.</source>
          <target state="translated">이 플래그는 Sass에게 오류 메시지의 일부로 터미널에 ASCII 문자 만 내보내도록 지시합니다. 기본적으로 또는 &lt;code&gt;--unicode&lt;/code&gt; 가 전달되면 Sass는 이러한 메시지에 대해 ASCII가 아닌 문자를 내 보냅니다. 이 플래그는 CSS 출력에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fff230b7eba99f6e2555a7fdafd47c24716ee72b" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to embed the contents of the source map file in the generated CSS, rather than creating a separate file and linking to it from the CSS.</source>
          <target state="translated">이 플래그는 Sass에게 별도의 파일을 만들고 CSS에서 링크하는 대신 생성 된 CSS에 소스 맵 파일의 내용을 포함하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="1e970be72cae8099bef28e91ebc3def905419fce" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to embed the entire contents of the Sass files that contributed to the generated CSS in the source map. This may produce very large source maps, but it guarantees that the source will be available on any computer no matter how the CSS is served.</source>
          <target state="translated">이 플래그는 생성 된 CSS에 기여한 Sass 파일의 전체 내용을 소스 맵에 포함하도록 Sass에 지시합니다. 이렇게하면 매우 큰 소스 맵이 생성 될 수 있지만 CSS가 제공되는 방식에 관계없이 모든 컴퓨터에서 소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b114f75a5d2bf10deeb92482b12e858d673044" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to generate output files with whose lines are separated with the U+000ALINEFEED character, as opposed to the operating system default (on Windows, this is U+000DCARRIAGERETURN followed by U+000ALINEFEED). It&amp;rsquo;s always true on systems that default to Unix-style newlines.</source>
          <target state="translated">이 플래그는 Sass에게 운영 체제 기본값 (Windows에서는 U + 000DCARRIAGERETURN 다음에 U + 000ALINEFEED가 뒤 따름)과 달리 U + 000ALINEFEED 문자로 행이 구분되는 출력 파일을 생성하도록 지시합니다. 기본적으로 Unix 스타일의 줄 바꿈을 사용하는 시스템에서는 항상 사실입니다.</target>
        </trans-unit>
        <trans-unit id="41d18c271e854a0f47cde32ba292a5b1181ce9ce" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to parse &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;standard input&lt;/a&gt; as &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 Sass에게 &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_streams#Standard_input_(stdin)&quot;&gt;표준 입력&lt;/a&gt; 을 &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt; 로 구문 분석하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="69ea66bcb32f2bbb25fb4e03965a2ea55967763d" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to parse the input file as the &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;indented syntax&lt;/a&gt;. If it&amp;rsquo;s used in &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;, all input files are parsed as the indented syntax, although files they &lt;a href=&quot;../at-rules/use&quot;&gt;use&lt;/a&gt; will have their syntax determined as usual. The inverse, &lt;code&gt;--no-indented&lt;/code&gt;, can be used to force all input files to be parsed as &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt; instead.</source>
          <target state="translated">이 플래그는 Sass에게 &lt;a href=&quot;../syntax#the-indented-syntax&quot;&gt;들여 쓰기 된 구문&lt;/a&gt; 으로 입력 파일을 구문 분석하도록 지시 합니다 . 다 &lt;a href=&quot;#many-to-many-mode&quot;&gt;대다 모드&lt;/a&gt; 에서 사용되는 경우 모든 입력 파일은 들여 쓰기 된 구문으로 구문 분석되지만 &lt;a href=&quot;../at-rules/use&quot;&gt;사용하는&lt;/a&gt; 파일 은 평소와 같이 구문이 결정됩니다. 반대로 &lt;code&gt;--no-indented&lt;/code&gt; 를 사용하면 모든 입력 파일이 대신 &lt;a href=&quot;../syntax#scss&quot;&gt;SCSS&lt;/a&gt; 로 구문 분석되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="261932def279e4e25bcafb9ee69ba68de17fc2cd" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to print the full Dart or JavaScript stack trace when an error is encountered. It&amp;rsquo;s used by the Sass team for debugging errors.</source>
          <target state="translated">이 플래그는 오류가 발생했을 때 Sass에게 전체 Dart 또는 JavaScript 스택 추적을 인쇄하도록 지시합니다. 오류 디버깅을 위해 Sass 팀에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6aee8e8f9b6873df9a0c3b6f1037565470cd184c" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to print the full Ruby stack trace when an error is encountered. It&amp;rsquo;s used by the Sass team for debugging errors.</source>
          <target state="translated">이 플래그는 오류가 발생하면 Sass에게 전체 Ruby 스택 추적을 인쇄하도록 지시합니다. 오류 디버깅을 위해 Sass 팀에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f30b97d7c89a086eb4184dcce6ad5907604121a6" translate="yes" xml:space="preserve">
          <source>This flag tells Sass to stop compiling immediately when an error is detected, rather than trying to compile other Sass files that may not contain errors. It&amp;rsquo;s mostly useful in &lt;a href=&quot;#many-to-many-mode&quot;&gt;many-to-many mode&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 오류를 포함하지 않을 수있는 다른 Sass 파일을 컴파일하는 대신 오류가 감지되면 즉시 컴파일을 중지하도록 Sass에 지시합니다. 대부분 다 &lt;a href=&quot;#many-to-many-mode&quot;&gt;대다 모드&lt;/a&gt; 에서 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="0e551d22518856816c9007c1610e52677c03122e" translate="yes" xml:space="preserve">
          <source>This flag tells Sass whether to emit a CSS file when an error occurs during compilation. This CSS file describes the error in a comment &lt;em&gt;and&lt;/em&gt; in the &lt;code&gt;content&lt;/code&gt; property of &lt;code&gt;body::before&lt;/code&gt;, so that you can see the error message in the browser without needing to switch back to the terminal.</source>
          <target state="translated">이 플래그는 컴파일 중에 오류가 발생할 때 CSS 파일을 내보낼 지 여부를 Sass에게 알려줍니다. 이 CSS 파일 은 &lt;code&gt;body::before&lt;/code&gt; 의 &lt;code&gt;content&lt;/code&gt; 속성 &lt;em&gt;과&lt;/em&gt; 주석의 오류를 설명 하므로 터미널로 다시 전환 할 필요없이 브라우저에서 오류 메시지를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74bd5c3c493f219a5698982ea1762d9530b723f1" translate="yes" xml:space="preserve">
          <source>This flag tells the Sass migrator only to emit ASCII characters to the terminal as part of error messages. By default, or if &lt;code&gt;--unicode&lt;/code&gt; is passed, the migrator will emit non-ASCII characters for these messages. This flag does not affect the CSS output.</source>
          <target state="translated">이 플래그는 Sass 이주자에게 오류 메시지의 일부로 ASCII 문자를 터미널에 내보내도록 지시합니다. 기본적으로 또는 &lt;code&gt;--unicode&lt;/code&gt; 가 전달 된 경우 마이그레이션 자는 이러한 메시지에 대해 ASCII가 아닌 문자를 내 보냅니다. 이 플래그는 CSS 출력에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="092a47804096f16727719ec2d51cd484592182a2" translate="yes" xml:space="preserve">
          <source>This flag, which may only be passed along with &lt;code&gt;--watch&lt;/code&gt;, tells Sass to manually check for changes to the source files every so often instead of relying on the operating system to notify it when something changes. This may be necessary if you&amp;rsquo;re editing Sass on a remote drive where the operating system&amp;rsquo;s notification system doesn&amp;rsquo;t work.</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; 와 함께 만 전달 될 수있는이 플래그 는 Sass가 변경 사항이있을 때이를 알리기 위해 운영 체제에 의존하는 대신 매번 소스 파일의 변경 사항을 수동으로 확인하도록 지시합니다. 운영 체제의 알림 시스템이 작동하지 않는 원격 드라이브에서 Sass를 편집하는 경우 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcba487e25a70112a116129dc10ffe7263d66e13" translate="yes" xml:space="preserve">
          <source>This function also supports the proprietary Microsoft &lt;code&gt;alpha(opacity=20)&lt;/code&gt; syntax as a special case.</source>
          <target state="translated">이 함수는 또한 독점적 인 Microsoft &lt;code&gt;alpha(opacity=20)&lt;/code&gt; 구문을 특수한 경우로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8ab88bf70f783e7fcd01b6b5416b77e42a5ce5f6" translate="yes" xml:space="preserve">
          <source>This function asynchronously compiles a Sass file to CSS, and calls a standard Node callback with the &lt;a href=&quot;#result-object&quot;&gt;result&lt;/a&gt; or an &lt;a href=&quot;#error-object&quot;&gt;error&lt;/a&gt; when the rendering is complete. It takes an &lt;a href=&quot;#options&quot;&gt;options object&lt;/a&gt;, which must have either the &lt;a href=&quot;#file&quot;&gt;&lt;code&gt;file&lt;/code&gt; option&lt;/a&gt; or the &lt;a href=&quot;#data&quot;&gt;&lt;code&gt;data&lt;/code&gt; option&lt;/a&gt; set.</source>
          <target state="translated">이 함수는 Sass 파일을 CSS로 비동기 적으로 컴파일 하고 렌더링이 완료되면 &lt;a href=&quot;#result-object&quot;&gt;결과&lt;/a&gt; 또는 &lt;a href=&quot;#error-object&quot;&gt;오류&lt;/a&gt; 와 함께 표준 Node 콜백을 호출합니다 . &lt;a href=&quot;#file&quot;&gt; &lt;code&gt;file&lt;/code&gt; &lt;/a&gt; 옵션 또는 &lt;a href=&quot;#data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 옵션 세트 가 있어야 하는 &lt;a href=&quot;#options&quot;&gt;options 객체&lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a3ec67208ac7bb6eabc68a4fc13211dcca66ecda" translate="yes" xml:space="preserve">
          <source>This function is identical to &lt;code&gt;$number * 100%&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;$number * 100%&lt;/code&gt; 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c91f2265d2fb6814a1f9c51ca956dd838028dd10" translate="yes" xml:space="preserve">
          <source>This function is intended for debugging; its output format is not guaranteed to be consistent across Sass versions or implementations.</source>
          <target state="translated">이 함수는 디버깅을위한 것입니다. 출력 형식은 Sass 버전 또는 구현에서 일관성이 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="edd6c3ec260853e8165e9d5f02880f2100e03896" translate="yes" xml:space="preserve">
          <source>This function is special in that it doesn&amp;rsquo;t even evaluate the argument that isn&amp;rsquo;t returned, so it&amp;rsquo;s safe to call even if the unused argument would throw an error.</source>
          <target state="translated">이 함수는 반환되지 않은 인수도 평가하지 않는다는 점에서 특별하므로 사용하지 않는 인수가 오류를 던지더라도 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6a3573a179a37f564a66c0924cf072b52d52b1fb" translate="yes" xml:space="preserve">
          <source>This function only exists as a workaround for IE7's &lt;a href=&quot;http://jes.st/2013/ie7s-css-breaking-content-counter-bug/&quot;&gt;&lt;code&gt;content: counter&lt;/code&gt; bug&lt;/a&gt;. It works identically to any other plain-CSS function, except it avoids adding spaces between the argument commas.</source>
          <target state="translated">이 기능은 IE7의 &lt;a href=&quot;http://jes.st/2013/ie7s-css-breaking-content-counter-bug/&quot;&gt; &lt;code&gt;content: counter&lt;/code&gt; &lt;/a&gt; 대한 해결책으로 만 존재 합니다 : counter bug . 인수 쉼표 사이에 공백을 추가하지 않는 것을 제외하고 다른 일반 CSS 기능과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="daf2b443b96645b11ed97e65e9593d416da219dd" translate="yes" xml:space="preserve">
          <source>This function synchronously compiles a Sass file to CSS. If it succeeds, it returns the &lt;a href=&quot;#result-object&quot;&gt;result&lt;/a&gt;, and if it fails it throws an &lt;a href=&quot;#error-object&quot;&gt;error&lt;/a&gt;. It takes an &lt;a href=&quot;#options&quot;&gt;options object&lt;/a&gt;, which must have either the &lt;a href=&quot;#file&quot;&gt;&lt;code&gt;file&lt;/code&gt; option&lt;/a&gt; or the &lt;a href=&quot;#data&quot;&gt;&lt;code&gt;data&lt;/code&gt; option&lt;/a&gt; set.</source>
          <target state="translated">이 함수는 Sass 파일을 CSS로 동 기적으로 컴파일합니다. 성공하면 &lt;a href=&quot;#result-object&quot;&gt;결과를&lt;/a&gt; 반환하고 실패하면 &lt;a href=&quot;#error-object&quot;&gt;오류를 발생시킵니다&lt;/a&gt; . &lt;a href=&quot;#file&quot;&gt; &lt;code&gt;file&lt;/code&gt; &lt;/a&gt; 옵션 또는 &lt;a href=&quot;#data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 옵션 세트 가 있어야 하는 &lt;a href=&quot;#options&quot;&gt;options 객체&lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="becb36fdda822271a471a4076796d5427550c1dd" translate="yes" xml:space="preserve">
          <source>This helps avoid repetition of parent selectors, and makes complex CSS layouts with lots of nested selectors much simpler. For example:</source>
          <target state="translated">이렇게하면 부모 선택기의 반복을 피할 수 있으며 중첩 된 선택기가 많은 복잡한 CSS 레이아웃이 훨씬 간단 해집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7c27d5f2519a24dc7dea8213d4df671fe7bff26" translate="yes" xml:space="preserve">
          <source>This integer option controls how many spaces or tabs (depending on the &lt;a href=&quot;#indenttype&quot;&gt;&lt;code&gt;indentType&lt;/code&gt; option&lt;/a&gt;) should be used per indentation level in the generated CSS. It defaults to 2, and must be between 0 and 10 (inclusive).</source>
          <target state="translated">이 정수 옵션 은 생성 된 CSS에서 들여 쓰기 수준 당 사용할 공백 또는 탭 수 ( &lt;a href=&quot;#indenttype&quot;&gt; &lt;code&gt;indentType&lt;/code&gt; 옵션&lt;/a&gt; 에 따라 다름)를 제어합니다 . 기본값은 2이며 0에서 10 (포함) 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="34f22156c5f9aff9552abf02f175ab3d68f6556b" translate="yes" xml:space="preserve">
          <source>This integer option determines the &lt;a href=&quot;values/numbers#precision&quot;&gt;precision&lt;/a&gt; that will be used when generating CSS that includes numbers. It defaults to 5 for Node Sass.</source>
          <target state="translated">이 정수 옵션 은 숫자를 포함하는 CSS를 생성 할 때 사용할 &lt;a href=&quot;values/numbers#precision&quot;&gt;정밀도&lt;/a&gt; 를 결정합니다 . Node Sass의 경우 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="82958030813dcf4173ba17af6911b53aafc8dc87" translate="yes" xml:space="preserve">
          <source>This is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; unless either</source>
          <target state="translated">다음 중 하나가 아니면 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="354efb4bef49ea8ecc4d2b7e5de75478212615f4" translate="yes" xml:space="preserve">
          <source>This is compiled to:</source>
          <target state="translated">이것은 다음과 같이 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2971968cb63bb3ba3336da8300f448d320db3b" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;a href=&quot;#adjust&quot;&gt;&lt;code&gt;color.adjust($color, $hue: 180deg)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#adjust&quot;&gt; &lt;code&gt;color.adjust($color, $hue: 180deg)&lt;/code&gt; &lt;/a&gt; )와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8d6c74d7d93db471f4634ad59a89ec9a51e20945" translate="yes" xml:space="preserve">
          <source>This is identical to &lt;a href=&quot;#change&quot;&gt;&lt;code&gt;color.change($color, $saturation: 0%)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#change&quot;&gt; &lt;code&gt;color.change($color, $saturation: 0%)&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b35482a13bdb28379dcfca04aa43ea21461d0dd9" translate="yes" xml:space="preserve">
          <source>This is the best way to add new values to a map.</source>
          <target state="translated">이것이지도에 새로운 값을 추가하는 가장 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="98104c1defbcfa22163c726d1c7b5a22484fe2f7" translate="yes" xml:space="preserve">
          <source>This is written &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot; as &amp;lt;prefix&amp;gt;-*&lt;/code&gt;, and it adds the given prefix to the beginning of every mixin, function, and variable name forwarded by the module. For example, if the module defines a member named &lt;code&gt;reset&lt;/code&gt; and it&amp;rsquo;s forwarded &lt;code&gt;as list-*&lt;/code&gt;, downstream stylesheets will refer to it as &lt;code&gt;list-reset&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;@forward &quot;&amp;lt;url&amp;gt;&quot; as &amp;lt;prefix&amp;gt;-*&lt;/code&gt; 로 작성하고 모듈이 전달하는 모든 믹스 인, 함수 및 변수 이름의 시작 부분에 주어진 접두사를 추가합니다. 예를 들어 모듈이 &lt;code&gt;reset&lt;/code&gt; 이라는 멤버를 정의하고 &lt;code&gt;as list-*&lt;/code&gt; 전달 되는 경우 다운 스트림 스타일 시트는이를 &lt;code&gt;list-reset&lt;/code&gt; 으로 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="66cc39014e692b9c2ec58982e284851ffb243362" translate="yes" xml:space="preserve">
          <source>This list type&amp;rsquo;s methods use 0-based indexing, even though within Sass lists use 1-based indexing. These methods also don&amp;rsquo;t support using negative numbers to index backwards from the end of the list.</source>
          <target state="translated">이 목록 유형의 메서드는 Sass 목록 내에서 1 기반 인덱싱을 사용하더라도 0 기반 인덱싱을 사용합니다. 이러한 메서드는 목록 끝에서 역순으로 인덱싱하기 위해 음수를 사용하는 것도 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3fdbea09d23c3600fc8d38d90c5625833f167bb0" translate="yes" xml:space="preserve">
          <source>This makes it easy to convert start using &lt;code&gt;@use&lt;/code&gt; in a stylesheet even before all the libraries you depend on have converted to the new module system. Be aware, though, that if they do convert their APIs may well change!</source>
          <target state="translated">따라서 의존하는 모든 라이브러리가 새 모듈 시스템으로 변환되기 전에도 스타일 시트에서 &lt;code&gt;@use&lt;/code&gt; 를 사용하여 쉽게 변환 할 수 있습니다. 하지만 변환하면 API가 잘 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e221cb98e8206a7921fde60e73a3967e13fd2b1" translate="yes" xml:space="preserve">
          <source>This map type is represented as a list of key-value pairs rather than a mapping from keys to values. The only way to find the value associated with a given key is to iterate through the map checking for that key.</source>
          <target state="translated">이 맵 유형은 키에서 값으로의 매핑이 아니라 키-값 쌍의 목록으로 표시됩니다. 주어진 키와 관련된 값을 찾는 유일한 방법은 해당 키를 확인하는 맵을 반복하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d4b5297fc6c26f52ee02451883faebe1c0d4eed2" translate="yes" xml:space="preserve">
          <source>This may not always be what you want, though. If you want the &lt;code&gt;@extend&lt;/code&gt; to do nothing if the extended selector doesn&amp;rsquo;t exist, just add &lt;code&gt;!optional&lt;/code&gt; to the end.</source>
          <target state="translated">그래도 항상 원하는 것은 아닙니다. 당신이 원하는 경우 &lt;code&gt;@extend&lt;/code&gt; 이 아무것도하지 않는 확장 된 선택이 존재하지 않는 경우, 단지 추가 &lt;code&gt;!optional&lt;/code&gt; 끝까지.</target>
        </trans-unit>
        <trans-unit id="bbb320de60e960922ca4332b4c5c60f6e3d77221" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;96px&lt;/code&gt; and &lt;code&gt;1in&lt;/code&gt; will return different values, even though they represent the same length.</source>
          <target state="translated">즉, &lt;code&gt;96px&lt;/code&gt; 와 &lt;code&gt;1in&lt;/code&gt; 은 동일한 길이를 나타내더라도 다른 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c81188216579c60386c9bf463658b27afd3b16a4" translate="yes" xml:space="preserve">
          <source>This means that all styles defined for &lt;code&gt;.error&lt;/code&gt; are also applied to &lt;code&gt;.seriousError&lt;/code&gt;, in addition to the styles specific to &lt;code&gt;.seriousError&lt;/code&gt;. In effect, every element with class &lt;code&gt;.seriousError&lt;/code&gt; also has class &lt;code&gt;.error&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;code&gt;.error&lt;/code&gt; 에 대해 정의 된 모든 스타일 이 &lt;code&gt;.seriousError&lt;/code&gt; 에 고유 한 스타일 외에 .seriousError 에도 적용됨 을 &lt;code&gt;.seriousError&lt;/code&gt; 합니다. 실제로 &lt;code&gt;.seriousError&lt;/code&gt; 클래스를 가진 모든 요소 에는 &lt;code&gt;.error&lt;/code&gt; 클래스도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f06057a82e5b41504f1fcfaaaa0944e7b90136e" translate="yes" xml:space="preserve">
          <source>This migration converts stylesheets that use the old &lt;a href=&quot;../at-rules/import&quot;&gt;&lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; to load dependencies so that they use the Sass module system via the &lt;a href=&quot;../at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt; instead. It doesn&amp;rsquo;t just na&amp;iuml;vely change &lt;code&gt;@import&lt;/code&gt;s to &lt;code&gt;@use&lt;/code&gt;s&amp;mdash;it updates stylesheets intelligently so that they keep working the same way they did before, including:</source>
          <target state="translated">이 마이그레이션은 이전 &lt;a href=&quot;../at-rules/import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; 규칙&lt;/a&gt; 을 사용하는 스타일 시트를 변환 하여 종속성을로드하므로 &lt;a href=&quot;../at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 규칙을&lt;/a&gt; 통해 Sass 모듈 시스템을 대신 사용합니다. 순진하게 &lt;code&gt;@import&lt;/code&gt; 를 &lt;code&gt;@use&lt;/code&gt; 로 변경하는 것이 아니라 스타일 시트를 지능적으로 업데이트하여 다음을 포함하여 이전과 동일한 방식으로 계속 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d2cc90c66d823a4240b48018c1fbef57a01492db" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-E&lt;/code&gt;) controls the default &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;character encoding&lt;/a&gt; that Sass will use to load source files that don&amp;rsquo;t &lt;a href=&quot;../syntax/parsing#input-encoding&quot;&gt;explicitly specify&lt;/a&gt; a character encoding. It defaults to the operating system&amp;rsquo;s default encoding.</source>
          <target state="translated">이 옵션 (약어 &lt;code&gt;-E&lt;/code&gt; )은 Sass가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Character_encoding&quot;&gt;문자 인코딩&lt;/a&gt; 을 &lt;a href=&quot;../syntax/parsing#input-encoding&quot;&gt;명시 적으로 지정&lt;/a&gt; 하지 않은 소스 파일을로드하는 데 사용할 기본 문자 인코딩 을 제어합니다 . 기본값은 운영 체제의 기본 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="68c01aa4a878cbdaf03b04a511a81fd78f16f841" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-I&lt;/code&gt;) adds an additional &lt;a href=&quot;../at-rules/use#load-paths&quot;&gt;load path&lt;/a&gt; for Sass to look for stylesheets. It can be passed multiple times to provide multiple load paths. Earlier load paths will take precedence over later ones.</source>
          <target state="translated">이 옵션 (약어 &lt;code&gt;-I&lt;/code&gt; ) 은 Sass가 스타일 시트를 찾도록 추가 &lt;a href=&quot;../at-rules/use#load-paths&quot;&gt;로드 경로&lt;/a&gt; 를 추가합니다 . 여러로드 경로를 제공하기 위해 여러 번 전달할 수 있습니다. 이전로드 경로가 이후 경로보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="40df9e52efc93c154e3c66293c74a56a82b46a41" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-I&lt;/code&gt;) tells the migrator a &lt;a href=&quot;../at-rules/use#load-paths&quot;&gt;load path&lt;/a&gt; where it should look for stylesheets. It can be passed multiple times to provide multiple load paths. Earlier load paths will take precedence over later ones.</source>
          <target state="translated">이 옵션 (약어 &lt;code&gt;-I&lt;/code&gt; )은 이주자에게 스타일 시트를 찾아야 하는 &lt;a href=&quot;../at-rules/use#load-paths&quot;&gt;로드 경로를&lt;/a&gt; 알려줍니다 . 여러로드 경로를 제공하기 위해 여러 번 전달할 수 있습니다. 이전로드 경로가 이후 경로보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1eb6566934c4d48b5b2e54badec7e20e5a08cdfc" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-d&lt;/code&gt;) tells the migrator to change not just the stylesheets that are explicitly passed on the command line, but also any stylesheets that they depend on using the &lt;a href=&quot;../at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt;, &lt;a href=&quot;../at-rules/forward&quot;&gt;&lt;code&gt;@forward&lt;/code&gt; rule&lt;/a&gt;, or &lt;a href=&quot;../at-rules/import&quot;&gt;&lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt;.</source>
          <target state="translated">이 옵션 (약어 &lt;code&gt;-d&lt;/code&gt; )은 명령 줄에서 명시 적으로 전달되는 스타일 시트뿐만 아니라 &lt;a href=&quot;../at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 규칙&lt;/a&gt; , &lt;a href=&quot;../at-rules/forward&quot;&gt; &lt;code&gt;@forward&lt;/code&gt; 규칙&lt;/a&gt; 또는 &lt;a href=&quot;../at-rules/import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; 규칙&lt;/a&gt; 을 사용하여 의존하는 스타일 시트도 변경하도록 마이그레이션 자 에게 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="a30ca8a9fed1c579edd78e22f1aa5fa313051f20" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-p&lt;/code&gt;) takes an identifier prefix to remove from the beginning of all variable, mixin, and function names when they&amp;rsquo;re migrated. Members that don&amp;rsquo;t start with this prefix will remain unchanged.</source>
          <target state="translated">이 옵션 (약어 &lt;code&gt;-p&lt;/code&gt; )은 마이그레이션 될 때 모든 변수, 믹스 인 및 함수 이름의 시작 부분에서 제거 할 식별자 접두사를 사용합니다. 이 접두사로 시작하지 않는 구성원은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="351b9ff8d5b293705fd9f9b352bcec3be172918d" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-r&lt;/code&gt;) loads a &lt;a href=&quot;https://rubygems.org/&quot;&gt;Ruby gem&lt;/a&gt; before running Sass. It can be used to load functions defined in Ruby into your Sass environment.</source>
          <target state="translated">이 옵션 (줄임말 &lt;code&gt;-r&lt;/code&gt; )은 Sass를 실행하기 전에 &lt;a href=&quot;https://rubygems.org/&quot;&gt;Ruby gem을&lt;/a&gt; 로드합니다 . Ruby에 정의 된 함수를 Sass 환경에로드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c31966521c62023c72dfe6e82e1289f60ffd7794" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-s&lt;/code&gt;) controls the output style of the resulting CSS. Dart Sass supports two output styles:</source>
          <target state="translated">이 옵션 (약어 &lt;code&gt;-s&lt;/code&gt; )은 결과 CSS의 출력 스타일을 제어합니다. Dart Sass는 두 가지 출력 스타일을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e933d89a8c2346341280fafa03084c4579c2c4bd" translate="yes" xml:space="preserve">
          <source>This option (abbreviated &lt;code&gt;-t&lt;/code&gt;) controls the output style of the resulting CSS. Ruby Sass supports four output styles:</source>
          <target state="translated">이 옵션 (약어 &lt;code&gt;-t&lt;/code&gt; )은 결과 CSS의 출력 스타일을 제어합니다. Ruby Sass는 4 가지 출력 스타일을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="aa47431b1a0a7c2b08d798b7e2cd93cf6145e46f" translate="yes" xml:space="preserve">
          <source>This option controls how Sass generates source maps, which are files that tell browsers or other tools that consume CSS how that CSS corresponds to the Sass files from which it was generated. They make it possible to see and even edit your Sass files in browsers. See instructions for using source maps in &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps&quot;&gt;Chrome&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Style_Editor#Source_map_support&quot;&gt;Firefox&lt;/a&gt;. It has four possible values:</source>
          <target state="translated">이 옵션은 Sass가 소스 맵을 생성하는 방법을 제어합니다. 소스 맵은 해당 CSS가 생성 된 Sass 파일에 해당하는 방법을 CSS를 사용하는 브라우저 또는 기타 도구에 알려주는 파일입니다. 브라우저에서 Sass 파일을보고 편집 할 수도 있습니다. &lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/javascript/source-maps&quot;&gt;Chrome&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Style_Editor#Source_map_support&quot;&gt;Firefox&lt;/a&gt; 에서 소스 맵 사용에 대한 안내를 참조 하세요 . 네 가지 가능한 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f705d47660fd87b5e100093f85edbb0055e3715b" translate="yes" xml:space="preserve">
          <source>This option controls how the source maps that Sass generates link back to the Sass files that contributed to the generated CSS. Dart Sass supports two types of URLs:</source>
          <target state="translated">이 옵션은 Sass가 생성 한 CSS에 기여한 Sass 파일에 대한 링크를 생성하는 소스 매핑 방법을 제어합니다. Dart Sass는 두 가지 유형의 URL을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="98a6d64e316376be8102c627ffed4c42e5800314" translate="yes" xml:space="preserve">
          <source>This option defines additional built-in Sass functions that are available in all stylesheets. It&amp;rsquo;s an object whose keys are Sass function signatures and whose values are JavaScript functions. Each function should take the same arguments as its signature. If the signature takes &lt;a href=&quot;at-rules/function#taking-arbitrary-arguments&quot;&gt;arbitrary arguments&lt;/a&gt;, the JavaScript function should take a single argument.</source>
          <target state="translated">이 옵션은 모든 스타일 시트에서 사용할 수있는 추가 내장 Sass 함수를 정의합니다. 키가 Sass 함수 서명이고 값이 JavaScript 함수 인 객체입니다. 각 함수는 시그니처와 동일한 인수를 가져야합니다. 서명이 &lt;a href=&quot;at-rules/function#taking-arbitrary-arguments&quot;&gt;임의의 인수를&lt;/a&gt; 취 하면 JavaScript 함수는 단일 인수를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="c44c0b48314a6840f72e6d98c7a87086a22e1110" translate="yes" xml:space="preserve">
          <source>This option defines one or more additional handlers for loading files when a &lt;a href=&quot;at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt; or an &lt;a href=&quot;at-rules/import&quot;&gt;&lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; is encountered. It can either be a single JavaScript function, or an array of functions. These functions are always passed two arguments:</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 규칙&lt;/a&gt; 또는 &lt;a href=&quot;at-rules/import&quot;&gt; &lt;code&gt;@import&lt;/code&gt; 규칙&lt;/a&gt; 이 발생할 때 파일을로드하기위한 하나 이상의 추가 처리기를 정의합니다 . 단일 JavaScript 함수이거나 함수 배열 일 수 있습니다. 이러한 함수에는 항상 두 개의 인수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9ef78e8ebc3e7bdba4cad7cfb89eb248d4c3ddb9" translate="yes" xml:space="preserve">
          <source>This option is allowed, but will have no effect, when using Node Sass or when using the &lt;code&gt;renderSync()&lt;/code&gt; function.</source>
          <target state="translated">이 옵션은 허용되지만 Node Sass를 사용하거나 &lt;code&gt;renderSync()&lt;/code&gt; 함수를 사용할 때 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8acd15d7d66acae93362e5789441c0092a2d064b" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t supported by Dart Sass, because source maps are recommended as the best way of determining where a style rule is defined.</source>
          <target state="translated">이 옵션은 Dart Sass에서 지원하지 않습니다. 스타일 규칙이 정의 된 위치를 결정하는 가장 좋은 방법으로 소스 맵이 권장되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="53ef4f19a4cd9dd3d9ed890bf9aa51ee7a491b09" translate="yes" xml:space="preserve">
          <source>This option may be passed multiple times, or with multiple values separated by commas. Each prefix will be removed from any members that have it. If a member matches multiple prefixes, the longest matching prefix will be removed.</source>
          <target state="translated">이 옵션은 여러 번 전달되거나 쉼표로 구분 된 여러 값으로 전달 될 수 있습니다. 각 접두사는 해당 접두사가있는 모든 구성원에서 제거됩니다. 멤버가 여러 접두사와 일치하는 경우 가장 긴 일치 접두사가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1a73d0b6760b165e6ce4434e66962afbfab91869" translate="yes" xml:space="preserve">
          <source>This option tells Sass how many digits of &lt;a href=&quot;../values/numbers#precision&quot;&gt;precision&lt;/a&gt; to use when emitting decimal numbers.</source>
          <target state="translated">이 옵션은 십진수를 내보낼 때 사용할 &lt;a href=&quot;../values/numbers#precision&quot;&gt;정밀도&lt;/a&gt; 자릿수를 Sass에 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="fa81c495129da0136ccaa79b312184373578f890" translate="yes" xml:space="preserve">
          <source>This option tells Sass where to store its cache of parsed files, so it can run faster in future invocations. It defaults to &lt;code&gt;.sass-cache&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 Sass에게 파싱 된 파일의 캐시를 저장할 위치를 알려주므로 향후 호출에서 더 빠르게 실행할 수 있습니다. 기본값은 &lt;code&gt;.sass-cache&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c6bd2913b8cf5c4b140be8024cfc59d5c863d38" translate="yes" xml:space="preserve">
          <source>This option tells the migrator which members to forward using the &lt;a href=&quot;../at-rules/forward&quot;&gt;&lt;code&gt;@forward&lt;/code&gt; rule&lt;/a&gt;. It supports the following settings:</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../at-rules/forward&quot;&gt; &lt;code&gt;@forward&lt;/code&gt; 규칙을&lt;/a&gt; 사용하여 전달할 구성원을 마이그레이션 자 에게 알려줍니다 . 다음 설정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8509229a012c8bd7dc34ab68217fc98fbefbea4c" translate="yes" xml:space="preserve">
          <source>This string option controls the output style of the resulting CSS. There are four possible output styles:</source>
          <target state="translated">이 문자열 옵션은 결과 CSS의 출력 스타일을 제어합니다. 네 가지 가능한 출력 스타일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f58fc9cbc010789c328210a7c6cdc61a5c02463c" translate="yes" xml:space="preserve">
          <source>This string option controls what character sequence is used at the end of each line in the generated CSS. It can have the following values:</source>
          <target state="translated">이 문자열 옵션은 생성 된 CSS의 각 줄 끝에 사용되는 문자 시퀀스를 제어합니다. 다음 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b459312d3b18bd16169ce05d7c25272833f4e31" translate="yes" xml:space="preserve">
          <source>This string option determines whether the generated CSS should use spaces (with the value &lt;code&gt;&quot;space&quot;&lt;/code&gt;) or tabs (with the value &lt;code&gt;&quot;tab&quot;&lt;/code&gt;) for indentation. It defaults to &lt;code&gt;&quot;space&quot;&lt;/code&gt;.</source>
          <target state="translated">이 문자열 옵션은 생성 된 CSS가 들여 쓰기에 공백 ( &lt;code&gt;&quot;space&quot;&lt;/code&gt; 값 포함 ) 또는 탭 ( &lt;code&gt;&quot;tab&quot;&lt;/code&gt; 값 포함)을 사용해야하는지 여부를 결정합니다 . 기본값은 &lt;code&gt;&quot;space&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81d6d6fc32e183a1183288282bf71d1854c3d3b6" translate="yes" xml:space="preserve">
          <source>This string option is prepended to all the links from the source map to the Sass source files.</source>
          <target state="translated">이 문자열 옵션은 소스 맵에서 Sass 소스 파일로의 모든 링크 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c96e029983830e06b1455d34eecdbc80371b397" translate="yes" xml:space="preserve">
          <source>This string option is the location that Sass expects the generated CSS to be saved to. It&amp;rsquo;s used to determine the URL used to link from the generated CSS to the source map, and &lt;em&gt;from&lt;/em&gt; the source map to the Sass source files.</source>
          <target state="translated">이 문자열 옵션은 Sass가 생성 된 CSS가 저장 될 것으로 예상하는 위치입니다. 소스 맵에 생성 된 CSS에서 링크에 사용되는 URL을 결정하는 데 사용하고있어 &lt;em&gt;에서&lt;/em&gt; 말대꾸 소스 파일에 소스지도.</target>
        </trans-unit>
        <trans-unit id="45028baa6be17d2a72664c3a38a4df0af9b7562d" translate="yes" xml:space="preserve">
          <source>This string option is the path to the file for Sass to load and compile. If the file&amp;rsquo;s extension is &lt;code&gt;.scss&lt;/code&gt;, it will be parsed as &lt;a href=&quot;syntax#scss&quot;&gt;SCSS&lt;/a&gt;; if it&amp;rsquo;s &lt;code&gt;.sass&lt;/code&gt;, it will be parsed as the &lt;a href=&quot;syntax#the-indented-syntax&quot;&gt;indented syntax&lt;/a&gt;; and if it&amp;rsquo;s &lt;code&gt;.css&lt;/code&gt;, it will be parsed as &lt;a href=&quot;at-rules/import#importing-css&quot;&gt;plain CSS&lt;/a&gt;. If it has no extension, it will be parsed as SCSS.</source>
          <target state="translated">이 문자열 옵션은 Sass가로드하고 컴파일 할 파일의 경로입니다. 파일 확장자가 &lt;code&gt;.scss&lt;/code&gt; 이면 &lt;a href=&quot;syntax#scss&quot;&gt;SCSS&lt;/a&gt; 로 구문 분석됩니다 . 그것의 경우 &lt;code&gt;.sass&lt;/code&gt; 를 , 그것은으로 해석됩니다 &lt;a href=&quot;syntax#the-indented-syntax&quot;&gt;들여 쓰기 구문&lt;/a&gt; ; 과의 경우 &lt;code&gt;.css&lt;/code&gt; , 그것은으로 해석됩니다 &lt;a href=&quot;at-rules/import#importing-css&quot;&gt;일반 CSS&lt;/a&gt; . 확장자가 없으면 SCSS로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="d219e3904d30ed2ba0b59639aaa6c8472d320ff6" translate="yes" xml:space="preserve">
          <source>This string option provides the contents of the stylesheet to compile. Unless the &lt;a href=&quot;#file&quot;&gt;&lt;code&gt;file&lt;/code&gt; option&lt;/a&gt; is passed as well, the stylesheet&amp;rsquo;s URL is set to &lt;code&gt;&quot;stdin&quot;&lt;/code&gt;.</source>
          <target state="translated">이 문자열 옵션은 컴파일 할 스타일 시트의 내용을 제공합니다. &lt;a href=&quot;#file&quot;&gt; &lt;code&gt;file&lt;/code&gt; 옵션&lt;/a&gt; 도 전달 되지 않는 한 스타일 시트의 URL은 &lt;code&gt;&quot;stdin&quot;&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d08f0562a4fe34e5c5501a0c25d0bb8dbdba77d" translate="yes" xml:space="preserve">
          <source>This uses the &lt;a href=&quot;../at-rules/extend&quot;&gt;&lt;code&gt;@extend&lt;/code&gt; rule&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;../at-rules/extend#how-it-works&quot;&gt;intelligent unification&lt;/a&gt; to make sure &lt;code&gt;$replacement&lt;/code&gt; is seamlessly integrated into &lt;code&gt;$selector&lt;/code&gt;. If &lt;code&gt;$selector&lt;/code&gt; doesn&amp;rsquo;t contain &lt;code&gt;$original&lt;/code&gt;, returns it as-is.</source>
          <target state="translated">이는 &lt;a href=&quot;../at-rules/extend&quot;&gt; &lt;code&gt;@extend&lt;/code&gt; 규칙&lt;/a&gt; 의 &lt;a href=&quot;../at-rules/extend#how-it-works&quot;&gt;지능적인 통합&lt;/a&gt; 을 사용하여 &lt;code&gt;$replacement&lt;/code&gt; 가 &lt;code&gt;$selector&lt;/code&gt; 원활하게 통합되도록 합니다. 경우 &lt;code&gt;$selector&lt;/code&gt; 포함되지 않은 &lt;code&gt;$original&lt;/code&gt; , 그대로 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="545791d74954d8abe66caac2fc59ede691f8aa64" translate="yes" xml:space="preserve">
          <source>This will only evaluate the given module once, even if it&amp;rsquo;s loaded multiple times in different ways.</source>
          <target state="translated">다른 방식으로 여러 번로드 되더라도 주어진 모듈을 한 번만 평가합니다.</target>
        </trans-unit>
        <trans-unit id="b1a72864e0bd50d769e6dea5e5ce673bba1458c1" translate="yes" xml:space="preserve">
          <source>This works by using &lt;code&gt;@extend&lt;/code&gt; and throwing away the original selector. This means that it can be used to do very advanced replacements; see the examples below.</source>
          <target state="translated">이것은 &lt;code&gt;@extend&lt;/code&gt; 를 사용 하고 원래 선택기 를 버려서 작동합니다 . 이는 매우 고급 교체를 수행하는 데 사용될 수 있음을 의미합니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fde2343337cbb8bf9b90da7e0ff1431427016760" translate="yes" xml:space="preserve">
          <source>Throws an error if called outside of a mixin.</source>
          <target state="translated">믹스 인 외부에서 호출되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e5cbb065759288edecad2c65efb1b31b56a60f88" translate="yes" xml:space="preserve">
          <source>To enable Sass in Merb, add the following line to &lt;code&gt;config/dependencies.rb&lt;/code&gt;:</source>
          <target state="translated">Merb에서 Sass를 활성화하려면 &lt;code&gt;config/dependencies.rb&lt;/code&gt; 에 다음 행을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d0729184767803da147daf282f65d916eb3027e" translate="yes" xml:space="preserve">
          <source>To enable Sass in Rails versions before Rails 3, add the following line to &lt;code&gt;environment.rb&lt;/code&gt;:</source>
          <target state="translated">Rails 3 이전의 Rails 버전에서 Sass를 활성화하려면 &lt;code&gt;environment.rb&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="16af8bdd69375a45a6eaabb6d2429473b658ecb7" translate="yes" xml:space="preserve">
          <source>To enable Sass in a Rack application, add the following lines to &lt;code&gt;config.ru&lt;/code&gt;.</source>
          <target state="translated">랙 애플리케이션에서 Sass를 사용하려면 &lt;code&gt;config.ru&lt;/code&gt; 에 다음 행을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d48f9832eda1e4b352dca419f4d8b94e22a5ed7" translate="yes" xml:space="preserve">
          <source>To ensure that stylesheets work on every operating system, Sass imports files by &lt;em&gt;URL&lt;/em&gt;, not by &lt;em&gt;file path&lt;/em&gt;. This means you need to use forward slashes, not backslashes, even when you&amp;rsquo;re on Windows.</source>
          <target state="translated">스타일 시트가 모든 운영 체제에서 작동하도록하기 위해 Sass 는 &lt;em&gt;파일 경로가&lt;/em&gt; 아닌 &lt;em&gt;URL로&lt;/em&gt; 파일을 가져옵니다 . 즉, Windows를 사용하는 경우에도 백 슬래시가 아닌 슬래시를 사용해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8d5853cb0db6b839240fc7067de4871071f153d" translate="yes" xml:space="preserve">
          <source>To ensure that stylesheets work on every operating system, Sass loads files by &lt;em&gt;URL&lt;/em&gt;, not by &lt;em&gt;file path&lt;/em&gt;. This means you need to use forward slashes, not backslashes, even on Windows.</source>
          <target state="translated">스타일 시트가 모든 운영 체제에서 작동하도록하기 위해 Sass 는 &lt;em&gt;파일 경로가&lt;/em&gt; 아닌 &lt;em&gt;URL로&lt;/em&gt; 파일을로드합니다 . 즉, Windows에서도 백 슬래시가 아닌 슬래시를 사용해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24104d743ce156119c7b4c8d0844608f2e0d9ad9" translate="yes" xml:space="preserve">
          <source>To explicitly specify the encoding of your stylesheet, use a &lt;code&gt;@charset&lt;/code&gt; declaration just like in CSS. Add &lt;code&gt;@charset &quot;encoding-name&quot;;&lt;/code&gt; at the beginning of the stylesheet (before any whitespace or comments) and Sass will interpret it as the given encoding. Note that whatever encoding you use, it must be convertible to Unicode.</source>
          <target state="translated">스타일 시트의 인코딩을 명시 적으로 지정하려면 CSS에서와 같이 &lt;code&gt;@charset&lt;/code&gt; 선언을 사용하십시오 . &lt;code&gt;@charset &quot;encoding-name&quot;;&lt;/code&gt; 추가하십시오 . 스타일 시트의 시작 부분에 (공백이나 주석이 있기 전에) Sass는 주어진 인코딩으로 해석합니다. 어떤 인코딩을 사용하든 유니 코드로 변환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="708a54b9a1991506dc324585e8d8c1e2bf6ad675" translate="yes" xml:space="preserve">
          <source>To help you work with nested maps, some map functions support deep operations. For example, if you pass multiple keys to &lt;code&gt;map.get()&lt;/code&gt;, it will follow those keys to find the desired nested map:</source>
          <target state="translated">중첩 된 맵 작업을 돕기 위해 일부 맵 함수는 심층 작업을 지원합니다. 예를 들어 여러 키를 &lt;code&gt;map.get()&lt;/code&gt; 전달하면 해당 키를 따라 원하는 중첩 맵을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="56703fbca11248f0b2bdf6c377b490bcccf84fef" translate="yes" xml:space="preserve">
          <source>To load a module with configuration, write &lt;code&gt;@use &amp;lt;url&amp;gt; with (&amp;lt;variable&amp;gt;: &amp;lt;value&amp;gt;, &amp;lt;variable&amp;gt;: &amp;lt;value&amp;gt;)&lt;/code&gt;. The configured values will override the variables&amp;rsquo; default values. Only variables written at the top level of the stylesheet with a &lt;code&gt;!default&lt;/code&gt; flag can be configured.</source>
          <target state="translated">구성이있는 모듈을로드하려면 &lt;code&gt;@use &amp;lt;url&amp;gt; with (&amp;lt;variable&amp;gt;: &amp;lt;value&amp;gt;, &amp;lt;variable&amp;gt;: &amp;lt;value&amp;gt;)&lt;/code&gt; 작성 하십시오 . 구성된 값은 변수의 기본값을 재정의합니다. &lt;code&gt;!default&lt;/code&gt; 플래그 를 사용하여 스타일 시트의 최상위 레벨에서 작성된 변수 만 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4700448ab20b7b5bddd738a4a176c18a266ac776" translate="yes" xml:space="preserve">
          <source>To make this easier, Sass also supports &lt;em&gt;import-only files&lt;/em&gt;. If you name a file &lt;code&gt;&amp;lt;name&amp;gt;.import.scss&lt;/code&gt;, it will only be loaded for imports, not for &lt;code&gt;@use&lt;/code&gt;s. This way, you can retain compatibility for &lt;code&gt;@import&lt;/code&gt; users while still providing a nice API for users of the new module system.</source>
          <target state="translated">이를 쉽게하기 위해 Sass는 &lt;em&gt;가져 오기 전용 파일&lt;/em&gt; 도 지원 &lt;em&gt;합니다&lt;/em&gt; . 파일 &lt;code&gt;&amp;lt;name&amp;gt;.import.scss&lt;/code&gt; 로 지정하면 &lt;code&gt;@use&lt;/code&gt; 가 아닌 가져 오기 용으로 만로드됩니다 . 이렇게하면 &lt;code&gt;@import&lt;/code&gt; 사용자에 대한 호환성을 유지 하면서 새 모듈 시스템 사용자에게 멋진 API를 계속 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a73d12abde4b58b4eaa56bb3215149ea76d6023" translate="yes" xml:space="preserve">
          <source>To make this possible, Sass provides the &lt;code&gt;!default&lt;/code&gt; flag. This assigns a value to a variable &lt;em&gt;only if&lt;/em&gt; that variable isn&amp;rsquo;t defined or its value is &lt;a href=&quot;values/null&quot;&gt;&lt;code&gt;null&lt;/code&gt;&lt;/a&gt;. Otherwise, the existing value will be used.</source>
          <target state="translated">이를 가능하게하기 위해 Sass는 &lt;code&gt;!default&lt;/code&gt; 플래그를 제공합니다 . 이것은 변수가 정의되지 않았거나 그 값이 &lt;a href=&quot;values/null&quot;&gt; &lt;code&gt;null&lt;/code&gt; 인&lt;/a&gt;&lt;em&gt; 경우에만&lt;/em&gt; 변수에 값을 할당합니다 . 그렇지 않으면 기존 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de06f9c502e4b3a7ffd0a3aad024b2ec4db54a94" translate="yes" xml:space="preserve">
          <source>To run Sass from the command line, just use</source>
          <target state="translated">커맨드 라인에서 Sass를 실행하려면</target>
        </trans-unit>
        <trans-unit id="72fe2963a498fec5325682da190f5643827f2e5c" translate="yes" xml:space="preserve">
          <source>To use the Sass migrator, tell it &lt;a href=&quot;#migrations&quot;&gt;which migration&lt;/a&gt; you want to run and what Sass files you want to migrate:</source>
          <target state="translated">Sass &lt;a href=&quot;#migrations&quot;&gt;마이그레이션&lt;/a&gt; 을 사용하려면 실행할 마이그레이션 과 마이그레이션 할 Sass 파일을 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="d123a8228b0a744cf53e7a8a514533230368d6dd" translate="yes" xml:space="preserve">
          <source>Top-Level Statements</source>
          <target state="translated">최상위 문</target>
        </trans-unit>
        <trans-unit id="7012e685210c7d03883f55753c7a5d74cf85f50a" translate="yes" xml:space="preserve">
          <source>Trailing Commas</source>
          <target state="translated">후행 쉼표</target>
        </trans-unit>
        <trans-unit id="4dc570712796d1d30cb56fc1e8aa44450bbca7cc" translate="yes" xml:space="preserve">
          <source>Trigonometric Functions</source>
          <target state="translated">삼각 함수</target>
        </trans-unit>
        <trans-unit id="caed6e0171f434a95e774f963eaf8636e990320e" translate="yes" xml:space="preserve">
          <source>Truthiness and Falsiness</source>
          <target state="translated">진실성과 허위</target>
        </trans-unit>
        <trans-unit id="be4c6f650182af9a4487d0aef4c894ed7255e95f" translate="yes" xml:space="preserve">
          <source>Unary Operators</source>
          <target state="translated">단항 연산자</target>
        </trans-unit>
        <trans-unit id="7b7d44c14475d66e338dbc16f27abd28b9cd8e9c" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;a href=&quot;../interpolation&quot;&gt;interpolation&lt;/a&gt; removes quotes from strings, which makes it difficult to use quoted strings as values for custom properties when they come from Sass variables. As a workaround, you can use the &lt;a href=&quot;../modules/meta#inspect&quot;&gt;&lt;code&gt;meta.inspect()&lt;/code&gt; function&lt;/a&gt; to preserve the quotes.</source>
          <target state="translated">안타깝게도 &lt;a href=&quot;../interpolation&quot;&gt;보간&lt;/a&gt; 은 문자열에서 따옴표를 제거하므로 Sass 변수에서 가져온 사용자 지정 속성의 값으로 따옴표로 묶인 문자열을 사용하기가 어렵습니다. 해결 방법으로 &lt;a href=&quot;../modules/meta#inspect&quot;&gt; &lt;code&gt;meta.inspect()&lt;/code&gt; 함수&lt;/a&gt; 를 사용하여 따옴표를 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad44dbaa4831c5a7c1830010ae4c038f6307e75" translate="yes" xml:space="preserve">
          <source>Unfortunately, the migrator does not support custom importers, but it does have built-in support for resolving URLs starting with &lt;code&gt;~&lt;/code&gt; by searching in &lt;code&gt;node_modules&lt;/code&gt;, similar to &lt;a href=&quot;https://github.com/webpack-contrib/sass-loader#resolving-import-at-rules&quot;&gt;what Webpack supports&lt;/a&gt;.</source>
          <target state="translated">안타깝게도 &lt;code&gt;node_modules&lt;/code&gt; 사용자 정의 가져 오기 도구를 지원하지 않지만 &lt;a href=&quot;https://github.com/webpack-contrib/sass-loader#resolving-import-at-rules&quot;&gt;Webpack이 지원하는&lt;/a&gt; 것과 유사한 node_modules 에서 검색 하여 &lt;code&gt;~&lt;/code&gt; 로 시작하는 URL을 확인하기위한 기본 제공 지원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="800433e4e83820c982f054958922fa1bc7ca5d6b" translate="yes" xml:space="preserve">
          <source>Unfortunately, this means that we have to always remember to use &lt;code&gt;.error&lt;/code&gt; with &lt;code&gt;.seriousError&lt;/code&gt;. This is a maintenance burden, leads to tricky bugs, and can bring non-semantic style concerns into the markup.</source>
          <target state="translated">불행히도, 이것은 항상 &lt;code&gt;.seriousError&lt;/code&gt; 와 함께 &lt;code&gt;.error&lt;/code&gt; 를 사용해야한다는 것을 의미합니다 . 이것은 유지 관리 부담이며 까다로운 버그로 이어지며 시맨틱하지 않은 스타일 문제를 마크 업에 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9bcf9e83d2a79206f3f81d3f7ee3a998e877475" translate="yes" xml:space="preserve">
          <source>Unifies two selectors into a single selector that matches only elements matched by both input selectors. Returns &lt;code&gt;null&lt;/code&gt; if there is no such selector.</source>
          <target state="translated">두 입력 선택기와 일치하는 요소 만 일치하는 두 선택기를 단일 선택기로 통합합니다. 이러한 선택 기가 &lt;code&gt;null&lt;/code&gt; 경우 null을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="145ca07decf4a005fc7b4223bf113eafd0c159a5" translate="yes" xml:space="preserve">
          <source>Unit Functions</source>
          <target state="translated">단위 기능</target>
        </trans-unit>
        <trans-unit id="a20f2c0123b9a570feed93bcf0287608c8fcd4ab" translate="yes" xml:space="preserve">
          <source>Unitless numbers can be compared with any number. They&amp;rsquo;re automatically converted to that number&amp;rsquo;s unit.</source>
          <target state="translated">단위없는 숫자는 어떤 숫자와도 비교할 수 있습니다. 자동으로 해당 숫자의 단위로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ff92b0795ba3b810a6fc98a6cbdc208467bfe06b" translate="yes" xml:space="preserve">
          <source>Unitless numbers can be used with numbers of any unit.</source>
          <target state="translated">단위없는 숫자는 모든 단위의 숫자와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12748281e0f02357f2a2f65c1c6a7d01ee122506" translate="yes" xml:space="preserve">
          <source>Units</source>
          <target state="translated">Units</target>
        </trans-unit>
        <trans-unit id="674a459914b321a7319cdedafb8ad0a73245d853" translate="yes" xml:space="preserve">
          <source>Universal Statements</source>
          <target state="translated">보편적 성명</target>
        </trans-unit>
        <trans-unit id="872ca4c8eab59b0dd849420e210e766c26422591" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;$bracketed&lt;/code&gt; is passed, the resulting list is bracketed if the first parameter is.</source>
          <target state="translated">&lt;code&gt;$bracketed&lt;/code&gt; 가 전달 되지 않으면 첫 번째 매개 변수가 있으면 결과 목록이 괄호로 묶입니다.</target>
        </trans-unit>
        <trans-unit id="56dd328feb200abd01d0a7e6a97e6981481b2fe3" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;$separator&lt;/code&gt; is passed, if one list is comma-separated and one is space-separated, the first parameter's separator is used for the resulting list. If both lists have fewer than two items, spaces are used for the resulting list.</source>
          <target state="translated">&lt;code&gt;$separator&lt;/code&gt; 가 전달 되지 않으면 하나의 목록이 쉼표로 구분되고 하나의 공백이 분리되면 첫 번째 매개 변수의 구분 기호가 결과 목록에 사용됩니다. 두 목록에 두 개 미만의 항목이 있으면 공백이 결과 목록에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1363117536b31421047d80acd67a6865cb2a2442" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;content-exists()&lt;/code&gt; is called directly from a mixin, an error will be raised.</source>
          <target state="translated">&lt;code&gt;content-exists()&lt;/code&gt; mixin에서 직접 호출 하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76ff0ed4ac7d80876eaa702113778227c4cc8f99" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;$separator&lt;/code&gt; argument is passed, if the list had only one item, the resulting list will be space-separated.</source>
          <target state="translated">&lt;code&gt;$separator&lt;/code&gt; 인수가 전달 되지 않으면 목록에 항목이 하나만 있으면 결과 목록은 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="03700045476b208aa94420bb227309caff53b89c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt;, which copy styles into the current style rule, &lt;code&gt;@extend&lt;/code&gt; updates style rules that contain the extended selector so that they contain the extending selector as well. When extending selectors, Sass does &lt;em&gt;intelligent unification&lt;/em&gt;:</source>
          <target state="translated">달리 &lt;a href=&quot;mixin&quot;&gt;유지 mixin&lt;/a&gt; 현재 스타일 규칙으로 스타일을 복사, &lt;code&gt;@extend&lt;/code&gt; 그래서 그들은뿐만 아니라 확장 선택기를 포함하는 확장 된 선택을 포함하는 업데이트 스타일 규칙. 선택자를 확장 할 때 Sass는 &lt;em&gt;지능형 통합을 수행합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dd99d83979ddae906c6089d467e3a623d0862a94" translate="yes" xml:space="preserve">
          <source>Unlike languages like JavaScript, Sass uses words rather than symbols for its &lt;a href=&quot;../values/booleans&quot;&gt;boolean&lt;/a&gt; operators.</source>
          <target state="translated">JavaScript와 같은 언어와 달리 Sass는 &lt;a href=&quot;../values/booleans&quot;&gt;부울&lt;/a&gt; 연산자에 기호가 아닌 단어를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0a6bc63d843eef7902dbce3c20323a9013b9c162" translate="yes" xml:space="preserve">
          <source>Unlike lists, maps must always be surrounded by parentheses and must always be comma-separated. Both the keys and values in maps can be any SassScript object. A map may only have one value associated with a given key (although that value may be a list). A given value may be associated with many keys, though.</source>
          <target state="translated">목록과 달리 맵은 항상 괄호로 묶어야하며 항상 쉼표로 구분해야합니다. 맵의 키와 값은 모두 SassScript 객체 일 수 있습니다. 지도는 주어진 키와 관련된 하나의 값만 가질 수 있습니다 (값은 목록 일 수 있음). 그러나 주어진 값은 많은 키와 연관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28201693f03d1e9150ecab32994e775dd9a12c3d" translate="yes" xml:space="preserve">
          <source>Unlike most selector functions, &lt;code&gt;selector-nest&lt;/code&gt; allows the parent selector &lt;code&gt;&amp;amp;&lt;/code&gt; to be used in any selector but the first.</source>
          <target state="translated">대부분의 선택기 기능과 달리 &lt;code&gt;selector-nest&lt;/code&gt; 를 사용하면 상위 선택기 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 첫 번째가 아닌 모든 선택기에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="551837b66646048d4b86ccfc46a3d42e1edc7d86" translate="yes" xml:space="preserve">
          <source>Unlike some other languages, Sass doesn&amp;rsquo;t require that you use &lt;code&gt;./&lt;/code&gt; for relative imports. Relative imports are always available.</source>
          <target state="translated">다른 언어와 달리 Sass는 상대 가져 오기에 &lt;code&gt;./&lt;/code&gt; 를 사용할 필요가 없습니다 . 상대 가져 오기는 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f744b797c0dc9fec0ca998b0a785f44273c6e256" translate="yes" xml:space="preserve">
          <source>Unquoted</source>
          <target state="translated">Unquoted</target>
        </trans-unit>
        <trans-unit id="47e6566a6faff9be13195d1e7518a595fbf5e3dd" translate="yes" xml:space="preserve">
          <source>Unquoted strings are written as CSS&lt;a href=&quot;https://drafts.csswg.org/css-syntax-3/#ident-token-diagram&quot;&gt;identifiers&lt;/a&gt;, following the syntax diagram below. They may include &lt;a href=&quot;../interpolation&quot;&gt;interpolation&lt;/a&gt; anywhere.</source>
          <target state="translated">인용되지 않은 문자열은 아래 구문 다이어그램에 따라 CSS &lt;a href=&quot;https://drafts.csswg.org/css-syntax-3/#ident-token-diagram&quot;&gt;식별자&lt;/a&gt; 로 작성됩니다 . 어디에나 &lt;a href=&quot;../interpolation&quot;&gt;보간&lt;/a&gt; 이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="9629fc5be7eebf84f66a1a4fe14d7eee29fbc498" translate="yes" xml:space="preserve">
          <source>Usage Example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="5253f44b019d85657e950f8f9ef36c011d7df44a" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#append&quot;&gt;&lt;code&gt;list.append()&lt;/code&gt;&lt;/a&gt; instead to add a single value to a list. Only use &lt;code&gt;list.join()&lt;/code&gt; to combine two lists together into one.</source>
          <target state="translated">대신 &lt;a href=&quot;#append&quot;&gt; &lt;code&gt;list.append()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 목록에 단일 값을 추가하십시오. 두 개의 목록을 하나로 결합 하려면 &lt;code&gt;list.join()&lt;/code&gt; 만 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="936edae5d2de4429a13dfc88fb76048edb5d8873" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;sass --help&lt;/code&gt; for full documentation.</source>
          <target state="translated">전체 문서를 보려면 &lt;code&gt;sass --help&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="72a3ab63eb244754d6a277a8c18c9d671df5562a" translate="yes" xml:space="preserve">
          <source>User-created importers must inherit from &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Importers/Base.html&quot;&gt;Sass::Importers::Base&lt;/a&gt;.</source>
          <target state="translated">사용자가 만든 수입자는 &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Importers/Base.html&quot;&gt;Sass :: Importers :: Base&lt;/a&gt; 에서 상속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f68d8b77e8f10448a25ffec622ba4c62ca6e4441" translate="yes" xml:space="preserve">
          <source>User-defined functions also support &lt;a href=&quot;#variable_arguments&quot;&gt;variable arguments&lt;/a&gt; in the same way as mixins.</source>
          <target state="translated">사용자 정의 함수는 mixin과 같은 방식으로 &lt;a href=&quot;#variable_arguments&quot;&gt;변수 인수&lt;/a&gt; 를 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="f829b8497ac4cecc133647d21b9e7ab12512cc02" translate="yes" xml:space="preserve">
          <source>Users can define their own Sass functions using the Ruby API. For more information, see the &lt;a href=&quot;sass/script/functions#adding_custom_functions&quot;&gt;source documentation&lt;/a&gt;.</source>
          <target state="translated">사용자는 Ruby API를 사용하여 자체 Sass 기능을 정의 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;sass/script/functions#adding_custom_functions&quot;&gt;소스 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d723d10f9bd0508705580ce55ade8956c38bbce" translate="yes" xml:space="preserve">
          <source>Users occasionally want to use interpolation to define a variable name based on another variable. Sass doesn&amp;rsquo;t allow this, because it makes it much harder to tell at a glance which variables are defined where. What you &lt;em&gt;can&lt;/em&gt; do, though, is define a &lt;a href=&quot;values/maps&quot;&gt;map&lt;/a&gt; from names to values that you can then access using variables.</source>
          <target state="translated">사용자는 때때로 다른 변수를 기반으로 변수 이름을 정의하기 위해 보간법을 사용하려고합니다. Sass는이를 허용하지 않습니다. 왜냐하면 어떤 변수가 어디에 정의되어 있는지 한눈에 알 수 없기 때문입니다. 하지만 할 &lt;em&gt;수있는&lt;/em&gt; 일은 이름에서 값으로 의 &lt;a href=&quot;values/maps&quot;&gt;맵&lt;/a&gt; 을 정의한 다음 변수를 사용하여 액세스 할 수있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0657ce5b13a9064f9e46d1f3e7526bfff9804ecf" translate="yes" xml:space="preserve">
          <source>Uses the value passed for each keyword argument in place of the corresponding property of the color, and returns the changed color. It&amp;rsquo;s an error to specify an RGB property (&lt;code&gt;$red&lt;/code&gt;, &lt;code&gt;$green&lt;/code&gt;, and/or &lt;code&gt;$blue&lt;/code&gt;) at the same time as an HSL property (&lt;code&gt;$hue&lt;/code&gt;, &lt;code&gt;$saturation&lt;/code&gt;, and/or &lt;code&gt;$lightness&lt;/code&gt;), or either of those at the same time as an &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;HWB&lt;/a&gt; property (&lt;code&gt;$hue&lt;/code&gt;, &lt;code&gt;$whiteness&lt;/code&gt;, and/or &lt;code&gt;$blackness&lt;/code&gt;).</source>
          <target state="translated">색상의 해당 속성 대신 각 키워드 인수에 전달 된 값을 사용하고 변경된 색상을 반환합니다. RGB 속성 ( &lt;code&gt;$red&lt;/code&gt; , &lt;code&gt;$green&lt;/code&gt; 및 / 또는 &lt;code&gt;$blue&lt;/code&gt; )을 HSL 속성 ( &lt;code&gt;$hue&lt;/code&gt; , &lt;code&gt;$saturation&lt;/code&gt; 및 / 또는 &lt;code&gt;$lightness&lt;/code&gt; ) 과 동시에 지정 하거나 동일한 속성 중 하나를 지정하는 것은 오류입니다. 시간을 &lt;a href=&quot;https://en.wikipedia.org/wiki/HWB_color_model&quot;&gt;HWB&lt;/a&gt; 속성 ( &lt;code&gt;$hue&lt;/code&gt; , &lt;code&gt;$whiteness&lt;/code&gt; 및 / 또는 &lt;code&gt;$blackness&lt;/code&gt; )으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bb771266dd60384fa6e5f8ca9918cefcb5350d48" translate="yes" xml:space="preserve">
          <source>Using Booleans</source>
          <target state="translated">부울 사용</target>
        </trans-unit>
        <trans-unit id="5bd2ddfea3ed5ca85c4c809297e5606f9b9fb7fe" translate="yes" xml:space="preserve">
          <source>Using Lists</source>
          <target state="translated">목록 사용</target>
        </trans-unit>
        <trans-unit id="0b5599b18b26956af6df0d8513851d1358a34b31" translate="yes" xml:space="preserve">
          <source>Using Maps</source>
          <target state="translated">지도 사용</target>
        </trans-unit>
        <trans-unit id="a0ed3c8ffbb485bdcff1600b6b717d9db053867b" translate="yes" xml:space="preserve">
          <source>Using Sass</source>
          <target state="translated">Sass 사용</target>
        </trans-unit>
        <trans-unit id="6c9f5242fbc04bc1bf0061d659bc4abf5c91fc15" translate="yes" xml:space="preserve">
          <source>Using Sass in Ruby code is very simple. After installing the Sass gem, you can use it by running &lt;code&gt;require &quot;sass&quot;&lt;/code&gt; and using &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Engine.html&quot;&gt;Sass::Engine&lt;/a&gt; like so:</source>
          <target state="translated">Ruby 코드에서 Sass를 사용하는 것은 매우 간단합니다. Sass gem을 설치 한 후 &lt;code&gt;require &quot;sass&quot;&lt;/code&gt; 를 실행 하고 &lt;a href=&quot;http://sass-lang.com/documentation/Sass/Engine.html&quot;&gt;Sass :: Engine을&lt;/a&gt; 사용하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0701d51e2238471096af133360d47b98e784ca3c" translate="yes" xml:space="preserve">
          <source>Value Types</source>
          <target state="translated">값 유형</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="52941da9a3b3b2fc5e211993b41384faa81f65d4" translate="yes" xml:space="preserve">
          <source>Variable Arguments</source>
          <target state="translated">가변 인수</target>
        </trans-unit>
        <trans-unit id="ca4cab7a39afeea82a57b9d1ddd82f67a9f0f9d8" translate="yes" xml:space="preserve">
          <source>Variable Defaults: &lt;code&gt;!default&lt;/code&gt;</source>
          <target state="translated">변수 기본값 : &lt;code&gt;!default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a993f0ecb978e6d4f6c3f1eca6b0e43b6692410" translate="yes" xml:space="preserve">
          <source>Variable Scope and Content Blocks</source>
          <target state="translated">변수 범위 및 내용 블록</target>
        </trans-unit>
        <trans-unit id="34762da26e1639d54b003cb20434ff57de97fb21" translate="yes" xml:space="preserve">
          <source>Variable arguments also contain any keyword arguments passed to the mixin or function. These can be accessed using the &lt;a href=&quot;sass/script/functions#keywords-instance_method&quot;&gt;&lt;code&gt;keywords($args)&lt;/code&gt; function&lt;/a&gt;, which returns them as a map from strings (without &lt;code&gt;$&lt;/code&gt;) to values.</source>
          <target state="translated">변수 인수에는 mixin 또는 함수에 전달 된 키워드 인수도 포함됩니다. 이것들은 &lt;a href=&quot;sass/script/functions#keywords-instance_method&quot;&gt; &lt;code&gt;keywords($args)&lt;/code&gt; 함수를&lt;/a&gt; 사용하여 접근 할 수 있습니다.이 함수 는 문자열 ( &lt;code&gt;$&lt;/code&gt; 없이 )에서 값 으로의 맵으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="12bec1e6f5c7b6f13ec79c6d010470c778844034" translate="yes" xml:space="preserve">
          <source>Variable arguments can also be used when calling a mixin. Using the same syntax, you can expand a list of values so that each value is passed as a separate argument, or expand a map of values so that each pair is treated as a keyword argument. For example:</source>
          <target state="translated">믹스 인을 호출 할 때 변수 인수를 사용할 수도 있습니다. 동일한 구문을 사용하여 각 값이 별도의 인수로 전달되도록 값 목록을 확장하거나 각 쌍이 키워드 인수로 취급되도록 값의 맵을 확장 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="d8f6a1442eaa82ed2ef7bd36ce68687125894980" translate="yes" xml:space="preserve">
          <source>Variables are only available within the level of nested selectors where they're defined. If they're defined outside of any nested selectors, they're available everywhere. They can also be defined with the &lt;code&gt;!global&lt;/code&gt; flag, in which case they're also available everywhere. For example:</source>
          <target state="translated">변수는 정의 된 중첩 선택기 수준 내에서만 사용할 수 있습니다. 중첩 된 선택기 외부에서 정의 된 경우 어디에서나 사용할 수 있습니다. 또한 &lt;code&gt;!global&lt;/code&gt; 플래그 로 정의 할 수 있으며 ,이 경우 어디에서나 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e62bc3146d23cb11c46abb4734d92fcb2f16ae85" translate="yes" xml:space="preserve">
          <source>Variables declared at the top level of a stylesheet are &lt;em&gt;global&lt;/em&gt;. This means that they can be accessed anywhere in their module after they&amp;rsquo;ve been declared. But that&amp;rsquo;s not true for all variables. Those declared in blocks (curly braces in SCSS or indented code in Sass) are usually &lt;em&gt;local&lt;/em&gt;, and can only be accessed within the block they were declared.</source>
          <target state="translated">스타일 시트의 최상위 수준에서 선언 된 변수는 &lt;em&gt;전역 적&lt;/em&gt; 입니다. 즉, 선언 된 후 모듈의 어느 곳에서나 액세스 할 수 있습니다. 그러나 모든 변수에 해당되는 것은 아닙니다. 블록으로 선언 된 블록 (SCSS의 중괄호 또는 Sass의 들여 쓰기 코드)은 일반적으로 &lt;em&gt;local&lt;/em&gt; 이며 선언 된 블록 내에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8994031832487676846ac77fa7f0b8dec3b112" translate="yes" xml:space="preserve">
          <source>Variables declared in &lt;a href=&quot;at-rules/control&quot;&gt;flow control rules&lt;/a&gt; have special scoping rules: they don&amp;rsquo;t shadow variables at the same level as the flow control rule. Instead, they just assign to those variables. This makes it much easier to conditionally assign a value to a variable, or build up a value as part of a loop.</source>
          <target state="translated">&lt;a href=&quot;at-rules/control&quot;&gt;흐름 제어 규칙에&lt;/a&gt; 선언 된 변수 에는 특별한 범위 지정 규칙이 있습니다. 흐름 제어 규칙과 동일한 수준에서 변수를 숨기지 않습니다. 대신 해당 변수에 할당합니다. 이렇게하면 변수에 값을 조건부로 할당하거나 루프의 일부로 값을 구축하는 것이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="904235a134bb733bf81ca62491f8d250cf2ee574" translate="yes" xml:space="preserve">
          <source>Variables defined with &lt;code&gt;!default&lt;/code&gt; can be configured when loading a module with the &lt;a href=&quot;at-rules/use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt;. Sass libraries often use &lt;code&gt;!default&lt;/code&gt; variables to allow their users to configure the library&amp;rsquo;s CSS.</source>
          <target state="translated">&lt;code&gt;!default&lt;/code&gt; 정의 된 변수 는 &lt;a href=&quot;at-rules/use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 규칙으로&lt;/a&gt; 모듈을로드 할 때 구성 할 수 있습니다 . Sass 라이브러리는 종종 &lt;code&gt;!default&lt;/code&gt; 변수를 사용하여 사용자가 라이브러리의 CSS를 구성 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="65d06d898537d012a091ac8922afb3d1b05a0f0f" translate="yes" xml:space="preserve">
          <source>Variables in flow control scope can assign to existing variables in the outer scope, but they can&amp;rsquo;t declare new variables there. Make sure the variable is already declared before you assign to it, even if you need to declare it as &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">흐름 제어 범위의 변수는 외부 범위의 기존 변수에 할당 할 수 있지만 거기에서 새 변수를 선언 할 수는 없습니다. &lt;code&gt;null&lt;/code&gt; 로 선언해야하는 경우에도 변수를 할당하기 전에 변수가 이미 선언되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b030b4bb1d6b81c859be99cb4803003e9fe720b8" translate="yes" xml:space="preserve">
          <source>Variables that are defined by a &lt;a href=&quot;modules&quot;&gt;built-in module&lt;/a&gt; cannot be modified.</source>
          <target state="translated">&lt;a href=&quot;modules&quot;&gt;내장 모듈에&lt;/a&gt; 의해 정의 된 변수는 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cb19cba9d55dde6587abe0c14c4d12a21eb6bd0" translate="yes" xml:space="preserve">
          <source>Variables with &lt;code&gt;null&lt;/code&gt; values are treated as unassigned by !default:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 값을 가진 변수는 ! default에 의해 할당되지 않은 것으로 취급됩니다 :</target>
        </trans-unit>
        <trans-unit id="a26c9a48ab460ac1ce8cae1c7f4d0ff504a10df3" translate="yes" xml:space="preserve">
          <source>Variables: &lt;code&gt;$&lt;/code&gt; #variables_</source>
          <target state="translated">변수 : &lt;code&gt;$&lt;/code&gt; #variables_</target>
        </trans-unit>
        <trans-unit id="cb1d3dd192599c5c0c675baaf111eab2ce9bde05" translate="yes" xml:space="preserve">
          <source>Versions of Dart Sass before 1.20.2 preferred resolving imports using load paths (&lt;a href=&quot;#includepaths&quot;&gt;includePaths&lt;/a&gt;) before resolving them using custom importers.</source>
          <target state="translated">1.20.2 이전의 Dart Sass 버전은 사용자 정의 가져 오기 도구를 사용하여 해결하기 전에로드 경로 ( &lt;a href=&quot;#includepaths&quot;&gt;includePaths&lt;/a&gt; )를 사용하여 가져 오기를 해결하는 것을 선호 했습니다.</target>
        </trans-unit>
        <trans-unit id="b64307469adf2f5aedbcf95bfc09230b12d1624f" translate="yes" xml:space="preserve">
          <source>Versions of Node Sass before 2.0.0 don&amp;rsquo;t support the &lt;code&gt;importer&lt;/code&gt; option at all.</source>
          <target state="translated">2.0.0 이전의 Node Sass 버전은 &lt;code&gt;importer&lt;/code&gt; 옵션을 전혀 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f07d3145f49f291089821be2da8032e39ecd35c0" translate="yes" xml:space="preserve">
          <source>Versions of Node Sass before 3.0.0 don&amp;rsquo;t support arrays of importers, nor do they support importers that return &lt;code&gt;Error&lt;/code&gt; objects.</source>
          <target state="translated">3.0.0 이전의 Node Sass 버전은 임포터 배열을 지원하지 않으며 &lt;code&gt;Error&lt;/code&gt; 객체 를 반환하는 임포터도 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1d1f601ec35589e15e62cc3f14a2ecf6ef02dcd9" translate="yes" xml:space="preserve">
          <source>Watching and Updating</source>
          <target state="translated">시청 및 업데이트</target>
        </trans-unit>
        <trans-unit id="5296e040e5951a011bab7d361744570cafde9edc" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re looking into loosening this restriction, though. If you&amp;rsquo;d like to help make that happen, check out &lt;a href=&quot;https://github.com/sass/sass/issues/1425&quot;&gt;this GitHub issue&lt;/a&gt;.</source>
          <target state="translated">하지만 우리는이 제한을 완화하는 방법을 찾고 있습니다. 그렇게하는 데 도움이 필요하면 &lt;a href=&quot;https://github.com/sass/sass/issues/1425&quot;&gt;이 GitHub 문제를&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="81c072eafeee9ba2f1af1475d9e85b857253f7a2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve written a &lt;a href=&quot;../cli/migrator&quot;&gt;migration tool&lt;/a&gt; that automatically converts most &lt;code&gt;@import&lt;/code&gt;-based code to &lt;code&gt;@use&lt;/code&gt;-based code in a flash. Just point it at your entrypoints and let it run!</source>
          <target state="translated">대부분의 &lt;code&gt;@import&lt;/code&gt; 기반 코드를 &lt;code&gt;@use&lt;/code&gt; 기반 코드 로 자동 변환 하는 &lt;a href=&quot;../cli/migrator&quot;&gt;마이그레이션 도구&lt;/a&gt; 를 작성했습니다 . 진입 점을 가리키고 실행 시키십시오!</target>
        </trans-unit>
        <trans-unit id="00fe09362c5a1e8e9fe77fdafdd64aed2b63ed92" translate="yes" xml:space="preserve">
          <source>Webpack uses the &lt;a href=&quot;https://www.npmjs.com/package/sass-loader&quot;&gt;&lt;code&gt;sass-loader&lt;/code&gt; package&lt;/a&gt;.</source>
          <target state="translated">Webpack은 &lt;a href=&quot;https://www.npmjs.com/package/sass-loader&quot;&gt; &lt;code&gt;sass-loader&lt;/code&gt; 패키지를&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fc476ae6c1bd15ef6c5cb340c03e844433c803d7" translate="yes" xml:space="preserve">
          <source>Well-formatted, customizable output</source>
          <target state="translated">잘 포맷되고 사용자 정의 가능한 출력</target>
        </trans-unit>
        <trans-unit id="ae320f9f01d8ff3bba28de4f9a328eab4f9428a3" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s Wrong With &lt;code&gt;@import&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;@import&lt;/code&gt; 의 문제점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="dcb5c2e8b90de931f4b2425c9053cf7885cb9b69" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the use of a selector that isn&amp;rsquo;t emitted? It can still be &lt;a href=&quot;../at-rules/extend&quot;&gt;extended&lt;/a&gt;! Unlike class selectors, placeholders don&amp;rsquo;t clutter up the CSS if they aren&amp;rsquo;t extended and they don&amp;rsquo;t mandate that users of a library use specific class names for their HTML.</source>
          <target state="translated">방출되지 않는 선택기의 용도는 무엇입니까? 여전히 &lt;a href=&quot;../at-rules/extend&quot;&gt;연장&lt;/a&gt; 할 수 있습니다 ! 클래스 선택기와 달리 자리 표시자는 확장되지 않은 경우 CSS를 복잡하게 만들지 않으며 라이브러리 사용자가 HTML에 특정 클래스 이름을 사용하도록 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b28b040c3f84f76a7a3baeacd11bc2968574350" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#rendersync&quot;&gt;&lt;code&gt;renderSync()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt; fail, they provide an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt; object&lt;/a&gt; that contains information about the compilation. This object has the following properties, in addition to the standard &lt;code&gt;Error&lt;/code&gt; properties:</source>
          <target state="translated">때 &lt;a href=&quot;#rendersync&quot;&gt; &lt;code&gt;renderSync()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; 그들이 제공하는 실패 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; 객체&lt;/a&gt; 편집에 대한 정보가 포함되어 있습니다. 이 개체에는 표준 &lt;code&gt;Error&lt;/code&gt; 속성 외에도 다음 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2646c7df6f3b6ff686cf14096cfe715089548d29" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#rendersync&quot;&gt;&lt;code&gt;renderSync()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#render&quot;&gt;&lt;code&gt;render()&lt;/code&gt;&lt;/a&gt; succeed, they provide a result object that contains information about the compilation. This object has the following properties:</source>
          <target state="translated">때 &lt;a href=&quot;#rendersync&quot;&gt; &lt;code&gt;renderSync()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#render&quot;&gt; &lt;code&gt;render()&lt;/code&gt; &lt;/a&gt; 성공, 그들은 편집에 대한 정보가 포함 된 결과 객체를 제공합니다. 이 개체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="67751b65818c9029a2c762b1022f6376b14b4cce" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@extend&lt;/code&gt;&lt;a href=&quot;#how-it-works&quot;&gt;interleaves complex selectors&lt;/a&gt;, it doesn&amp;rsquo;t generate all possible combinations of ancestor selectors. Many of the selectors it could generate are unlikely to actually match real HTML, and generating them all would make stylesheets way too big for very little real value. Instead, it uses a &lt;a href=&quot;https://en.wikipedia.org/wiki/Heuristic&quot;&gt;heuristic&lt;/a&gt;: it assumes that each selector&amp;rsquo;s ancestors will be self-contained, without being interleaved with any other selector&amp;rsquo;s ancestors.</source>
          <target state="translated">&lt;code&gt;@extend&lt;/code&gt; 가&lt;a href=&quot;#how-it-works&quot;&gt;복잡한 선택자를 인터리브&lt;/a&gt; 할 때 조상 선택 자의 가능한 모든 조합을 생성하지는 않습니다. 생성 할 수있는 많은 선택기가 실제 HTML과 실제로 일치하지 않을 가능성이 높으며 모두 생성하면 스타일 시트가 너무 커져 실제 가치가 거의 없습니다. 대신, &lt;a href=&quot;https://en.wikipedia.org/wiki/Heuristic&quot;&gt;휴리스틱을&lt;/a&gt; 사용합니다 . 각 선택 자의 조상이 다른 선택 자의 조상과 인터리브되지 않고 자체 포함된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="109b6826f0b0eb1e61d89ae5125c5e7c1f41166b" translate="yes" xml:space="preserve">
          <source>When Sass encounters invalid syntax in a stylesheet, parsing will fail and an error will be presented to the user with information about the location of the invalid syntax and the reason it was invalid.</source>
          <target state="translated">Sass가 스타일 시트에서 잘못된 구문을 발견하면 구문 분석이 실패하고 잘못된 구문의 위치 및 잘못된 이유에 대한 정보와 함께 오류가 사용자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7384966515f04b8c7cc1bf90292a115d6c470017" translate="yes" xml:space="preserve">
          <source>When Sass imports a file, that file is evaluated as though its contents appeared directly in place of the &lt;code&gt;@import&lt;/code&gt;. Any &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt;, &lt;a href=&quot;function&quot;&gt;functions&lt;/a&gt;, and &lt;a href=&quot;../variables&quot;&gt;variables&lt;/a&gt; from the imported file are made available, and all its CSS is included at the exact point where the &lt;code&gt;@import&lt;/code&gt; was written. What&amp;rsquo;s more, any mixins, functions, or variables that were defined before the &lt;code&gt;@import&lt;/code&gt; (including from other &lt;code&gt;@import&lt;/code&gt;s) are available in the imported stylesheet.</source>
          <target state="translated">Sass가 파일을 &lt;code&gt;@import&lt;/code&gt; 때 해당 파일은 @import 대신 콘텐츠가 직접 나타난 것처럼 평가됩니다 . 가져온 파일의 모든 &lt;a href=&quot;mixin&quot;&gt;믹스 인&lt;/a&gt; , &lt;a href=&quot;function&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../variables&quot;&gt;변수&lt;/a&gt; 를 사용할 수 있으며 모든 CSS는 &lt;code&gt;@import&lt;/code&gt; 가 작성된 정확한 지점에 포함됩니다 . 또한, &lt;code&gt;@import&lt;/code&gt; 이전에 정의 된 모든 믹스 인, 함수 또는 변수 (다른 &lt;code&gt;@import&lt;/code&gt; 에서 가져온 것 포함 )는 가져온 스타일 시트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae1804a6635a94c5a2eab113966e0084f8548ecb" translate="yes" xml:space="preserve">
          <source>When Sass is nesting selectors, it doesn&amp;rsquo;t know what interpolation was used to generate them. This means it will automatically add the outer selector to the inner selector &lt;em&gt;even if&lt;/em&gt; you used &lt;code&gt;&amp;amp;&lt;/code&gt; as a SassScript expression. That&amp;rsquo;s why you need to explicitly use the &lt;a href=&quot;../at-rules/at-root&quot;&gt;&lt;code&gt;@at-root&lt;/code&gt; rule&lt;/a&gt; to tell Sass not to include the outer selector.</source>
          <target state="translated">Sass가 선택자를 중첩 할 때이를 생성하는 데 사용 된 보간법을 알지 못합니다. 즉, &lt;code&gt;&amp;amp;&lt;/code&gt; 를 SassScript 표현식으로 사용한 &lt;em&gt;경우에도&lt;/em&gt; 내부 선택기에 외부 선택기를 자동으로 추가합니다 . 그렇기 때문에 &lt;a href=&quot;../at-rules/at-root&quot;&gt; &lt;code&gt;@at-root&lt;/code&gt; &lt;/a&gt; 규칙 을 명시 적으로 사용하여 Sass에 외부 선택기를 포함하지 않도록 지시해야합니다.</target>
        </trans-unit>
        <trans-unit id="5edf8a38ebf65fb3df157cbcf947cdaeedd25f7d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;@return&lt;/code&gt; is encountered, it immediately ends the function and returns its result. Returning early can be useful for handling edge-cases or cases where a more efficient algorithm is available without wrapping the entire function in an &lt;a href=&quot;control/if#else&quot;&gt;&lt;code&gt;@else&lt;/code&gt; block&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;@return&lt;/code&gt; 이 발생, 즉시 기능을 종료하고 그 결과를 반환합니다. 조기 반환은 &lt;a href=&quot;control/if#else&quot;&gt; &lt;code&gt;@else&lt;/code&gt; 블록&lt;/a&gt; 에서 전체 함수를 래핑하지 않고보다 효율적인 알고리즘을 사용할 수있는 경우 또는 에지 케이스를 처리하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0a609947d51b2b71ada8e9fe7b263350a5becc1" translate="yes" xml:space="preserve">
          <source>When a file with &lt;code&gt;@use&lt;/code&gt; rules is imported, all the CSS transitively loaded by those is included in the resulting stylesheet, even if it&amp;rsquo;s already been included by another import. If you&amp;rsquo;re not careful, this can result in bloated CSS output!</source>
          <target state="translated">&lt;code&gt;@use&lt;/code&gt; 규칙이 있는 파일을 가져 오면 다른 가져 오기에 이미 포함 된 경우에도 해당 규칙에 의해 전 이적으로로드 된 모든 CSS가 결과 스타일 시트에 포함됩니다. 주의하지 않으면 CSS 출력이 커질 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="7c4504b06fe4f2d0632fed935fffecb31c8dbe15" translate="yes" xml:space="preserve">
          <source>When a function is called, arguments can be passed by name in addition to passing them by their position in the argument list. This is especially useful for functions with multiple optional arguments, or with &lt;a href=&quot;../values/booleans&quot;&gt;boolean&lt;/a&gt; arguments whose meanings aren&amp;rsquo;t obvious without a name to go with them. Keyword arguments use the same syntax as &lt;a href=&quot;../variables&quot;&gt;variable declarations&lt;/a&gt; and &lt;a href=&quot;#optional-arguments&quot;&gt;optional arguments&lt;/a&gt;.</source>
          <target state="translated">함수가 호출되면 인수 목록의 위치에 따라 인수를 전달하는 것 외에도 이름으로 인수를 전달할 수 있습니다. 이것은 여러 선택적 인수가있는 함수 또는 이름 없이는 의미가 명확하지 않은 &lt;a href=&quot;../values/booleans&quot;&gt;부울&lt;/a&gt; 인수가있는 함수에 특히 유용 합니다. 키워드 인수는 &lt;a href=&quot;../variables&quot;&gt;변수 선언&lt;/a&gt; 및 &lt;a href=&quot;#optional-arguments&quot;&gt;선택적 인수&lt;/a&gt; 와 동일한 구문을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bb06b4bcfec9f4720b7452a192e8cd3abfaf6ad8" translate="yes" xml:space="preserve">
          <source>When a mixin is included, arguments can be passed by name in addition to passing them by their position in the argument list. This is especially useful for mixins with multiple optional arguments, or with &lt;a href=&quot;../values/booleans&quot;&gt;boolean&lt;/a&gt; arguments whose meanings aren&amp;rsquo;t obvious without a name to go with them. Keyword arguments use the same syntax as &lt;a href=&quot;../variables&quot;&gt;variable declarations&lt;/a&gt; and &lt;a href=&quot;#optional-arguments&quot;&gt;optional arguments&lt;/a&gt;.</source>
          <target state="translated">믹스 인이 포함 된 경우 인수 목록의 위치에 따라 인수를 전달하는 것 외에도 이름으로 인수를 전달할 수 있습니다. 이것은 여러 선택적 인수가있는 믹스 인이나 이름 없이는 의미가 분명하지 않은 &lt;a href=&quot;../values/booleans&quot;&gt;부울&lt;/a&gt; 인수 와 함께 사용할 때 특히 유용 합니다. 키워드 인수는 &lt;a href=&quot;../variables&quot;&gt;변수 선언&lt;/a&gt; 및 &lt;a href=&quot;#optional-arguments&quot;&gt;선택적 인수&lt;/a&gt; 와 동일한 구문을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b7f513c450831f05e82ae2122380c6269d3cf6a8" translate="yes" xml:space="preserve">
          <source>When a parent selector is used in an inner selector, it&amp;rsquo;s replaced with the corresponding outer selector. This happens instead of the normal nesting behavior.</source>
          <target state="translated">내부 선택기에서 상위 선택기가 사용되면 해당 외부 선택기로 대체됩니다. 이것은 일반적인 중첩 동작 대신 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81668018632d182ee958edee74e2e2162a380c23" translate="yes" xml:space="preserve">
          <source>When a quoted string is injected into another value via interpolation, &lt;a href=&quot;../interpolation#quoted-strings&quot;&gt;its quotes are removed&lt;/a&gt;! This makes it easy to write strings containing selectors, for example, that can be injected into style rules without adding quotes.</source>
          <target state="translated">따옴표 붙은 문자열이 보간을 통해 다른 값에 삽입되면 &lt;a href=&quot;../interpolation#quoted-strings&quot;&gt;따옴표가 제거됩니다&lt;/a&gt; ! 예를 들어 따옴표를 추가하지 않고도 스타일 규칙에 삽입 할 수있는 선택자를 포함하는 문자열을 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad9a9930b743e6ec09722d7d13ac805fe155c4d" translate="yes" xml:space="preserve">
          <source>When an unquoted string is parsed, the literal text of escapes are parsed as part of the string. For example, &lt;code&gt;\a&lt;/code&gt; is parsed as the characters &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and space. In order to ensure that unquoted strings that have the same meanings in CSS are parsed the same way, though, these escapes are &lt;em&gt;normalized&lt;/em&gt;. For each code point, whether it&amp;rsquo;s escaped or unescaped:</source>
          <target state="translated">인용되지 않은 문자열이 구문 분석되면 이스케이프의 리터럴 텍스트가 문자열의 일부로 구문 분석됩니다. 예를 들어, &lt;code&gt;\a&lt;/code&gt; 는 문자 &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 및 공백으로 구문 분석됩니다 . 그러나 CSS에서 동일한 의미를 가진 인용되지 않은 문자열이 동일한 방식으로 구문 분석되도록하기 위해 이러한 이스케이프는 &lt;em&gt;정규화&lt;/em&gt; 됩니다. 이스케이프 또는 이스케이프되지 않은 각 코드 포인트에 대해 :</target>
        </trans-unit>
        <trans-unit id="218ab28d5f752f9a20108380952ae476cd785f73" translate="yes" xml:space="preserve">
          <source>When compiling whole directories, Sass will ignore &lt;a href=&quot;../at-rules/import#partials&quot;&gt;partial files&lt;/a&gt; whose names begin with &lt;code&gt;_&lt;/code&gt;. You can use partials to separate out your stylesheets without creating a bunch of unnecessary output files.</source>
          <target state="translated">전체 디렉토리를 컴파일 할 때 Sass는 이름이 &lt;code&gt;_&lt;/code&gt; 로 시작 하는 &lt;a href=&quot;../at-rules/import#partials&quot;&gt;부분 파일&lt;/a&gt; 을 무시 합니다 . 부분을 ​​사용하여 불필요한 출력 파일을 만들지 않고도 스타일 시트를 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="31bb94d366bd70bae726f8d286d66a9019433b73" translate="yes" xml:space="preserve">
          <source>When compiling whole directories, Sass will ignore &lt;a href=&quot;../at-rules/use#partials&quot;&gt;partial files&lt;/a&gt; whose names begin with &lt;code&gt;_&lt;/code&gt;. You can use partials to separate out your stylesheets without creating a bunch of unnecessary output files.</source>
          <target state="translated">전체 디렉토리를 컴파일 할 때 Sass는 이름이 &lt;code&gt;_&lt;/code&gt; 로 시작 하는 &lt;a href=&quot;../at-rules/use#partials&quot;&gt;부분 파일&lt;/a&gt; 을 무시 합니다 . 부분을 ​​사용하여 불필요한 출력 파일을 만들지 않고도 스타일 시트를 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="45cf9995f3f3b0a0c2fc12ee09c79fc32d152015" translate="yes" xml:space="preserve">
          <source>When defining a mixin, the arguments are written as variable names separated by commas, all in parentheses after the name. Then when including the mixin, values can be passed in in the same manner. For example:</source>
          <target state="translated">믹스 인을 정의 할 때 인수는 이름 뒤에 괄호 안에 쉼표로 구분 된 변수 이름으로 작성됩니다. 그런 다음 믹스 인을 포함 할 때 동일한 방식으로 값을 전달할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8eaf0650b12f4b6e13c45da64d3aefa7b846ec82" translate="yes" xml:space="preserve">
          <source>When lists are turned into plain CSS, Sass doesn't add any parentheses, since CSS doesn't understand them. That means that &lt;code&gt;(1px 2px) (5px 6px)&lt;/code&gt; and &lt;code&gt;1px 2px 5px 6px&lt;/code&gt; will look the same when they become CSS. However, they aren't the same when they're Sass: the first is a list containing two lists, while the second is a list containing four numbers.</source>
          <target state="translated">목록이 일반 CSS로 바뀌면 Sass는 CSS가 이해하지 못하므로 괄호를 추가하지 않습니다. 즉 &lt;code&gt;(1px 2px) (5px 6px)&lt;/code&gt; 와 &lt;code&gt;1px 2px 5px 6px&lt;/code&gt; 는 CSS가 될 때 동일하게 보입니다. 그러나 Sass 인 경우에는 동일하지 않습니다. 첫 번째는 두 개의 목록이 포함 된 목록이고 두 번째는 네 개의 숫자가 포함 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5aad5437d7dfdab5e62318eefd2c6cfb001cf4fa" translate="yes" xml:space="preserve">
          <source>When merging selectors, &lt;code&gt;@extend&lt;/code&gt; is smart enough to avoid unnecessary duplication, so something like &lt;code&gt;.seriousError.seriousError&lt;/code&gt; gets translated to &lt;code&gt;.seriousError&lt;/code&gt;. In addition, it won't produce selectors that can't match anything, like &lt;code&gt;#main#footer&lt;/code&gt;.</source>
          <target state="translated">선택기를 병합 할 때, &lt;code&gt;@extend&lt;/code&gt; 는 같은 때문에, 불필요한 중복을 피하기 위해 스마트 충분하다 &lt;code&gt;.seriousError.seriousError&lt;/code&gt; 이 로 번역됩니다 &lt;code&gt;.seriousError&lt;/code&gt; 은 . 또한 &lt;code&gt;#main#footer&lt;/code&gt; 와 같이 아무것도 일치하지 않는 선택기를 생성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8f354f1d9b0a162ef05bffc01d340d5b14007482" translate="yes" xml:space="preserve">
          <source>When one class extends another, Sass styles all elements that match the extender as though they also match the class being extended. When one class selector extends another, it works exactly as though you added the extended class to every element in your HTML that already had the extending class. You can just write &lt;code&gt;class=&quot;error--serious&quot;&lt;/code&gt;, and Sass will make sure it&amp;rsquo;s styled as though it had &lt;code&gt;class=&quot;error&quot;&lt;/code&gt; as well.</source>
          <target state="translated">한 클래스가 다른 클래스를 확장 할 때 Sass는 확장되는 클래스와 일치하는 것처럼 확장기와 일치하는 모든 요소의 스타일을 지정합니다. 한 클래스 선택기가 다른 선택기를 확장하면 확장 클래스가 이미있는 HTML의 모든 요소에 확장 클래스를 추가 한 것처럼 정확하게 작동합니다. &lt;code&gt;class=&quot;error--serious&quot;&lt;/code&gt; 라고 작성할 수 있으며 Sass는 마치 &lt;code&gt;class=&quot;error&quot;&lt;/code&gt; 가있는 것처럼 스타일이 지정되었는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="0fbff872cee0dbfc7c89c0c1981c0ec2426c6d70" translate="yes" xml:space="preserve">
          <source>When one stylesheet extends a selector, that extension will only affect style rules written in &lt;em&gt;upstream&lt;/em&gt; modules&amp;mdash;that is, modules that are loaded by that stylesheet using the &lt;a href=&quot;use&quot;&gt;&lt;code&gt;@use&lt;/code&gt; rule&lt;/a&gt; or the &lt;a href=&quot;forward&quot;&gt;&lt;code&gt;@forward&lt;/code&gt; rule&lt;/a&gt;, modules loaded by &lt;em&gt;those&lt;/em&gt; modules, and so on. This helps make your &lt;code&gt;@extend&lt;/code&gt; rules more predictable, ensuring that they affect only the styles you were aware of when you wrote them.</source>
          <target state="translated">하나의 스타일 시트가 선택을 확장하면 해당 확장에 기록 된 스타일 규칙에만 영향을줍니다 &lt;em&gt;업스트림&lt;/em&gt; 모듈-IS는 사용하여 해당 스타일 시트에 의해로드 된 모듈 &lt;a href=&quot;use&quot;&gt; &lt;code&gt;@use&lt;/code&gt; 의 규칙&lt;/a&gt; 또는 &lt;a href=&quot;forward&quot;&gt; &lt;code&gt;@forward&lt;/code&gt; 규칙&lt;/a&gt; 에 의해로드 된 모듈 &lt;em&gt;들&lt;/em&gt; 에 너무 모듈을하고 있습니다. 이렇게하면 &lt;code&gt;@extend&lt;/code&gt; 규칙을보다 예측 가능 하게 만들어 작성했을 때 알고 있던 스타일에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4d1e8800cde7c69cb821d81f06588373485353f5" translate="yes" xml:space="preserve">
          <source>When possible, Sass will also merge media queries that are nested within one another to make it easier to support browsers that don&amp;rsquo;t yet natively support nested &lt;code&gt;@media&lt;/code&gt; rules.</source>
          <target state="translated">가능한 경우 Sass는 중첩 된 &lt;code&gt;@media&lt;/code&gt; 규칙을 아직 기본적으로 지원하지 않는 브라우저를 더 쉽게 지원할 수 있도록 서로 중첩 된 미디어 쿼리를 병합합니다 .</target>
        </trans-unit>
        <trans-unit id="7ff3c92336d6818ffe06769d17b564b4cd912585" translate="yes" xml:space="preserve">
          <source>When resolving an &lt;code&gt;@import&lt;/code&gt;, Sass will go through the load paths looking for an importer that successfully imports the path. Once one is found, the imported file is used.</source>
          <target state="translated">&lt;code&gt;@import&lt;/code&gt; 를 해결할 때 Sass는로드 경로를 통과하여 경로를 성공적으로 가져 오는 가져 오기 도구를 찾습니다. 하나를 찾으면 가져온 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c5f3ede65042880a9261966a2c4d5c41201709d" translate="yes" xml:space="preserve">
          <source>When running on Ruby 1.9 and later, Sass is aware of the character encoding of documents. Sass follows the &lt;a href=&quot;http://www.w3.org/TR/2013/WD-css-syntax-3-20130919/#determine-the-fallback-encoding&quot;&gt;CSS spec&lt;/a&gt; to determine the encoding of a stylesheet, and falls back to the Ruby string encoding. This means that it first checks the Unicode byte order mark, then the &lt;code&gt;@charset&lt;/code&gt; declaration, then the Ruby string encoding. If none of these are set, it will assume the document is in UTF-8.</source>
          <target state="translated">Ruby 1.9 이상에서 실행할 때 Sass는 문서의 문자 인코딩을 인식합니다. Sass는 &lt;a href=&quot;http://www.w3.org/TR/2013/WD-css-syntax-3-20130919/#determine-the-fallback-encoding&quot;&gt;CSS 사양&lt;/a&gt; 에 따라 스타일 시트의 인코딩을 결정하고 Ruby 문자열 인코딩으로 대체합니다. 즉, 먼저 유니 코드 바이트 순서 표시, &lt;code&gt;@charset&lt;/code&gt; 선언, Ruby 문자열 인코딩을 확인합니다. 이들 중 어느 것도 설정되지 않으면 문서가 UTF-8 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="197dd69b8b83c74b1b436711b01fa575cee90c61" translate="yes" xml:space="preserve">
          <source>When the first letter of a multiline comment is &lt;code&gt;!&lt;/code&gt;, the comment will always rendered into css output even in compressed output modes. This is useful for adding Copyright notices to your generated CSS.</source>
          <target state="translated">여러 줄 주석의 첫 글자가 &lt;code&gt;!&lt;/code&gt; 압축 된 출력 모드에서도 주석은 항상 css 출력으로 렌더링됩니다. 생성 된 CSS에 저작권 표시를 추가하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5e4fd8404dc61ca660bd2f2f308dbfe931e2758a" translate="yes" xml:space="preserve">
          <source>When the last argument to a mixin or function is a positional or keyword-style argument, that argument can be followed by a trailing comma. Some prefer this coding style as it can lead to more concise diffs and fewer syntax errors when refactoring.</source>
          <target state="translated">믹스 인 또는 함수에 대한 마지막 인수가 위치 또는 키워드 스타일 인수 인 경우 해당 인수 다음에 쉼표가 올 수 있습니다. 일부는 리팩토링시 간결한 차이와 구문 오류를 유발할 수 있으므로이 코딩 스타일을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="cb17805af33bc17e9ee429b94eb2209b9ed1cc08" translate="yes" xml:space="preserve">
          <source>When the two sequences being merged have no selectors in common, then two new selectors are generated: one with the first sequence before the second, and one with the second sequence before the first. For example:</source>
          <target state="translated">병합되는 두 시퀀스에 공통으로 선택기가없는 경우 두 개의 새로운 선택기가 생성됩니다. 하나는 두 번째 이전에 첫 번째 시퀀스를 갖고 다른 하나는 첫 번째 이전에 두 번째 시퀀스를 갖습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af89e96670072f7489d5ea4d5b9921c482b4a965" translate="yes" xml:space="preserve">
          <source>When using Dart Sass, &lt;strong&gt;&lt;a href=&quot;#rendersync&quot;&gt;&lt;code&gt;renderSync()&lt;/code&gt;&lt;/a&gt; is almost twice as fast as &lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt; by default, due to the overhead of making the entire evaluation process asynchronous. To avoid this performance hit, you can pass the &lt;a href=&quot;#fiber&quot;&gt;&lt;code&gt;fiber&lt;/code&gt; option&lt;/a&gt; to &lt;code&gt;render()&lt;/code&gt;.</source>
          <target state="translated">Dart Sass를 사용할 때 &lt;strong&gt;&lt;a href=&quot;#rendersync&quot;&gt; &lt;code&gt;renderSync()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;render()&lt;/code&gt; &lt;/strong&gt; 전체 평가 프로세스를 비동기로 만드는 오버 헤드로 인해 기본적 &lt;strong&gt;으로 &lt;/strong&gt;&lt;strong&gt;render ()&lt;/strong&gt;&lt;strong&gt; 보다 거의 두 배 빠릅니다&lt;/strong&gt; . 이러한 성능 저하를 방지하려면 &lt;a href=&quot;#fiber&quot;&gt; &lt;code&gt;fiber&lt;/code&gt; 옵션&lt;/a&gt; 을 &lt;code&gt;render()&lt;/code&gt; 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b7a13914940166518300fa33331c64f13803b7e" translate="yes" xml:space="preserve">
          <source>When using Dart Sass, &lt;strong&gt;&lt;code&gt;renderSync()&lt;/code&gt; is more than twice as fast as &lt;code&gt;render()&lt;/code&gt;&lt;/strong&gt;, due to the overhead of asynchronous callbacks. To avoid this performance hit, &lt;code&gt;render()&lt;/code&gt; can use the &lt;a href=&quot;https://www.npmjs.com/package/fibers&quot;&gt;&lt;code&gt;fibers&lt;/code&gt;&lt;/a&gt; package to call asynchronous importers from the synchronous code path. To enable this, pass the &lt;code&gt;Fiber&lt;/code&gt; class to the &lt;code&gt;fiber&lt;/code&gt; option:</source>
          <target state="translated">Dart Sass를 사용할 때 &lt;strong&gt; &lt;code&gt;renderSync()&lt;/code&gt; 는 &lt;code&gt;render()&lt;/code&gt; &lt;/strong&gt; 비동기 콜백의 오버 헤드로 인해 &lt;strong&gt;render ()&lt;/strong&gt;&lt;strong&gt; 보다 두 배 이상 빠릅니다&lt;/strong&gt; . 이러한 성능 저하를 방지하기 위해 &lt;code&gt;render()&lt;/code&gt; 는 &lt;a href=&quot;https://www.npmjs.com/package/fibers&quot;&gt; &lt;code&gt;fibers&lt;/code&gt; &lt;/a&gt; 패키지를 사용 하여 동기 코드 경로에서 비동기 임포터를 호출 할 수 있습니다 . 이를 활성화하려면 &lt;code&gt;Fiber&lt;/code&gt; 클래스를 &lt;code&gt;fiber&lt;/code&gt; 옵션에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5bb132e14d6ab3a9f1a50fa2dc201c2d576155a" translate="yes" xml:space="preserve">
          <source>When writing &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt; and &lt;a href=&quot;function&quot;&gt;functions&lt;/a&gt; that take arguments, you usually want to ensure that those arguments have the types and formats your API expects. If they aren't, the user needs to be notified and your mixin/function needs to stop running.</source>
          <target state="translated">인수를받는 &lt;a href=&quot;mixin&quot;&gt;믹스 인&lt;/a&gt; 및 &lt;a href=&quot;function&quot;&gt;함수&lt;/a&gt; 를 작성할 때 일반적으로 해당 인수가 API에서 예상하는 유형과 형식을 갖도록해야합니다. 그렇지 않은 경우 사용자에게 알림을 보내야하며 믹스 인 / 함수 실행을 중지해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="622c01719e46c66c1777b18d05a1f9e6d2a3930c" translate="yes" xml:space="preserve">
          <source>When writing &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt; and &lt;a href=&quot;function&quot;&gt;functions&lt;/a&gt;, you may want to discourage users from passing certain arguments or certain values. They may be passing legacy arguments that are now deprecated, or they may be calling your API in a way that&amp;rsquo;s not quite optimal.</source>
          <target state="translated">&lt;a href=&quot;mixin&quot;&gt;믹스 인&lt;/a&gt; 및 &lt;a href=&quot;function&quot;&gt;함수를&lt;/a&gt; 작성할 때 사용자가 특정 인수 또는 특정 값을 전달하지 못하도록 할 수 있습니다. 현재 사용되지 않는 레거시 인수를 전달하거나 최적이 아닌 방식으로 API를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="263a2faa1ca3886c162feed06c743e2a35949aab" translate="yes" xml:space="preserve">
          <source>When writing custom functions, it&amp;rsquo;s important to ensure that all the arguments are the types you expect. Otherwise, users&amp;rsquo; stylesheets could crash in hard-to-debug ways or, worse, compile to meaningless CSS.</source>
          <target state="translated">사용자 정의 함수를 작성할 때 모든 인수가 예상 한 유형인지 확인하는 것이 중요합니다. 그렇지 않으면 사용자의 스타일 시트가 디버그하기 어려운 방식으로 충돌하거나 더 나쁜 경우 무의미한 CSS로 컴파일 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027bfd284e7508b4792085aecf46844ff4f38f1b" translate="yes" xml:space="preserve">
          <source>When writing style libraries using Sass, you can use comments to document the &lt;a href=&quot;../at-rules/mixin&quot;&gt;mixins&lt;/a&gt;, &lt;a href=&quot;../at-rules/function&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;../variables&quot;&gt;variables&lt;/a&gt;, and &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;placeholder selectors&lt;/a&gt; that your library provides, as well as the library itself. These are comments are read by the &lt;a href=&quot;http://sassdoc.com&quot;&gt;SassDoc&lt;/a&gt; tool, which uses them to generate beautiful documentation. Check out &lt;a href=&quot;http://oddbird.net/susy/docs/index.html&quot;&gt;the Susy grid engine&lt;/a&gt;&amp;rsquo;s documentation to see it in action!</source>
          <target state="translated">Sass를 사용하여 스타일 라이브러리를 작성할 때 주석을 사용 하여 라이브러리가 제공 하는 &lt;a href=&quot;../at-rules/mixin&quot;&gt;mixin&lt;/a&gt; , &lt;a href=&quot;../at-rules/function&quot;&gt;함수&lt;/a&gt; , &lt;a href=&quot;../variables&quot;&gt;변수&lt;/a&gt; 및 &lt;a href=&quot;../style-rules/placeholder-selectors&quot;&gt;자리 표시 자 선택기&lt;/a&gt; 와 라이브러리 자체 를 문서화 할 수 있습니다 . 이 주석은 &lt;a href=&quot;http://sassdoc.com&quot;&gt;SassDoc&lt;/a&gt; 도구 에서 읽으며 이를 사용하여 아름다운 문서를 생성합니다. 확인 &lt;a href=&quot;http://oddbird.net/susy/docs/index.html&quot;&gt;Susy 그리드 엔진&lt;/a&gt; 의 설명서 행동에 볼 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="482a4bbcee8e0f624a30032248fb70b16d73f815" translate="yes" xml:space="preserve">
          <source>When you declare a mixin or function that takes &lt;a href=&quot;../at-rules/mixin#taking-arbitrary-arguments&quot;&gt;arbitrary arguments&lt;/a&gt;, the value you get is a special list known as an &lt;em&gt;argument list&lt;/em&gt;. It acts just like a list that contains all the arguments passed to the mixin or function, with one extra feature: if the user passed keyword arguments, they can be accessed as a map by passing the argument list to the &lt;a href=&quot;../modules/meta#keywords&quot;&gt;&lt;code&gt;meta.keywords()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../at-rules/mixin#taking-arbitrary-arguments&quot;&gt;임의의 인수&lt;/a&gt; 를 취하는 믹스 인 또는 함수를 선언 할 때 얻는 값은 &lt;em&gt;인수 목록으로&lt;/em&gt; 알려진 특수 &lt;em&gt;목록&lt;/em&gt; 입니다. 믹스 인 또는 함수에 전달 된 모든 인수를 포함하는 목록과 같은 역할을합니다. 한 가지 추가 기능이 있습니다. 사용자가 키워드 인수를 전달하면 인수 목록을 &lt;a href=&quot;../modules/meta#keywords&quot;&gt; &lt;code&gt;meta.keywords()&lt;/code&gt; 함수&lt;/a&gt; 에 전달하여 맵으로 액세스 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="35b3433b081aebda0f31291c47558d163be8f0e7" translate="yes" xml:space="preserve">
          <source>When you import a file that contains &lt;code&gt;@use&lt;/code&gt; rules, the importing file has access to all members (even private members) defined directly in that file, but &lt;em&gt;not&lt;/em&gt; any members from modules that file has loaded. However, if that file contains &lt;a href=&quot;forward&quot;&gt;&lt;code&gt;@forward&lt;/code&gt; rules&lt;/a&gt;, the importing file will have access to forwarded members. This means that you can import a library that was written to be used with the module system.</source>
          <target state="translated">&lt;code&gt;@use&lt;/code&gt; 규칙 이 포함 된 파일을 가져 오는 경우 가져 오는 파일은 해당 파일에 직접 정의 된 모든 구성원 (개인 구성원 포함)에 액세스 할 수 있지만 파일이로드 한 모듈의 구성원 은 액세스 할 수 &lt;em&gt;없습니다&lt;/em&gt; . 그러나 해당 파일에 &lt;a href=&quot;forward&quot;&gt; &lt;code&gt;@forward&lt;/code&gt; 규칙이&lt;/a&gt; 포함 된 경우 가져 오는 파일은 전달 된 구성원에 액세스 할 수 있습니다. 이는 모듈 시스템에서 사용하도록 작성된 라이브러리를 가져올 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f7a75b711040d4798987157314d10ebb07704327" translate="yes" xml:space="preserve">
          <source>When you pass this option, the migrator will also generate an &lt;a href=&quot;../at-rules/import#import-only-files&quot;&gt;import-only stylesheet&lt;/a&gt; that &lt;a href=&quot;../at-rules/forward&quot;&gt;forwards&lt;/a&gt; all the members with the prefix added back, to preserve backwards-compatibility for users who were importing the library.</source>
          <target state="translated">이 옵션을 전달하면 마이그레이션자는 라이브러리를 가져 오는 사용자의 이전 버전과의 호환성을 유지하기 위해 접두어가 다시 추가 된 모든 구성원 을 &lt;a href=&quot;../at-rules/forward&quot;&gt;전달&lt;/a&gt; 하는 &lt;a href=&quot;../at-rules/import#import-only-files&quot;&gt;가져 오기 전용 스타일 시트&lt;/a&gt; 도 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7a75a804b614be27309836388101bf18c03f7792" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;@use&lt;/code&gt; (or &lt;code&gt;@forward&lt;/code&gt;) load a module that uses &lt;code&gt;@import&lt;/code&gt;, that module will contain all the public members defined by the stylesheet you load &lt;em&gt;and&lt;/em&gt; everything that stylesheet transitively imports. In other words, everything that&amp;rsquo;s imported is treated as though it were written in one big stylesheet.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;@use&lt;/code&gt; (또는 &lt;code&gt;@forward&lt;/code&gt; 이 )가 사용하는 것을 모듈로드 &lt;code&gt;@import&lt;/code&gt; 를 , 그 모듈은 당신이로드 스타일 시트에 의해 정의 된 모든 public 멤버 포함 &lt;em&gt;하고&lt;/em&gt; 모든 것을 그 스타일 이적으로 수입. 즉, 가져온 모든 항목이 하나의 큰 스타일 시트에 작성된 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6a96355c77e9fc9e8cf8a12bb300b15d130381c5" translate="yes" xml:space="preserve">
          <source>Which would output the following:</source>
          <target state="translated">다음을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="4456171cd4cc8074d8af762f53b44a9a7090c527" translate="yes" xml:space="preserve">
          <source>Which would produce:</source>
          <target state="translated">어떤 생산 :</target>
        </trans-unit>
        <trans-unit id="423708f9fef7104955a2e6081d74527cb46a6604" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;@extend&lt;/code&gt; is allowed within &lt;a href=&quot;css&quot;&gt;&lt;code&gt;@media&lt;/code&gt; and other CSS at-rules&lt;/a&gt;, it&amp;rsquo;s not allowed to extend selectors that appear outside its at-rule. This is because the extending selector only applies within the given media context, and there&amp;rsquo;s no way to make sure that restriction is preserved in the generated selector without duplicating the entire style rule.</source>
          <target state="translated">&lt;code&gt;@extend&lt;/code&gt; 는 &lt;a href=&quot;css&quot;&gt; &lt;code&gt;@media&lt;/code&gt; 및 기타 CSS at-rules&lt;/a&gt; 내에서 허용 되지만 at-rule 외부에 나타나는 선택기를 확장 할 수 없습니다. 확장 선택기는 지정된 미디어 컨텍스트 내에서만 적용되며 전체 스타일 규칙을 복제하지 않고 생성 된 선택기에서 제한이 유지되는지 확인할 수있는 방법이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2275e024f14cc0973d14e354edc2110a6fa18663" translate="yes" xml:space="preserve">
          <source>While it would technically be possible to generate all selectors that could possibly match either sequence, this would make the stylesheet far too large. The simple example above, for instance, would require ten selectors. Instead, Sass generates only selectors that are likely to be useful.</source>
          <target state="translated">기술적으로 두 시퀀스 중 하나와 일치 할 수있는 모든 선택기를 생성 할 수 있지만 스타일 시트가 너무 커집니다. 예를 들어 위의 간단한 예제에는 10 개의 선택기가 필요합니다. 대신 Sass는 유용 할 수있는 선택기 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3f3dbc007f7d47bfa51fca54bae8df73cbad2b6f" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s technically possible for functions to have side-effects like setting &lt;a href=&quot;../variables#scope&quot;&gt;global variables&lt;/a&gt;, this is strongly discouraged. Use &lt;a href=&quot;mixin&quot;&gt;mixins&lt;/a&gt; for side-effects, and use functions just to compute values.</source>
          <target state="translated">기술적으로 함수가 &lt;a href=&quot;../variables#scope&quot;&gt;전역 변수&lt;/a&gt; 설정과 같은 부작용을 가질 수 있지만 이는 강력히 권장하지 않습니다. 부작용에 &lt;a href=&quot;mixin&quot;&gt;믹스 인&lt;/a&gt; 을 사용 하고 값을 계산하기 위해 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb585dbae3a6f883c795f956780d12f4deb3d861" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s tempting to use this feature to convert quoted strings to unquoted strings, it&amp;rsquo;s a lot clearer to use the &lt;a href=&quot;modules/string#unquote&quot;&gt;&lt;code&gt;string.unquote()&lt;/code&gt; function&lt;/a&gt;. Instead of &lt;code&gt;#{$string}&lt;/code&gt;, write &lt;code&gt;string.unquote($string)&lt;/code&gt;!</source>
          <target state="translated">이 기능을 사용하여 인용 된 문자열을 인용되지 않은 문자열로 변환하고 &lt;a href=&quot;modules/string#unquote&quot;&gt; &lt;code&gt;string.unquote()&lt;/code&gt; 함수&lt;/a&gt; 를 사용하는 것이 훨씬 더 명확 합니다 . 대신 &lt;code&gt;#{$string}&lt;/code&gt; , 쓰기 &lt;code&gt;string.unquote($string)&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="b04bfd229cc5abb3ff13094b511bec694aad932a" translate="yes" xml:space="preserve">
          <source>While this is less concise, it can make the stylesheet easier to read. It also allows functions to present more flexible interfaces, providing many arguments without becoming difficult to call.</source>
          <target state="translated">간결하지는 않지만 스타일 시트를보다 쉽게 ​​읽을 수 있습니다. 또한 함수가보다 유연한 인터페이스를 제공하여 호출하기 어려운 많은 인수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4524b79210c6ea867e61f067f30b30c4e1fa6433" translate="yes" xml:space="preserve">
          <source>With Maps</source>
          <target state="translated">지도 사용</target>
        </trans-unit>
        <trans-unit id="2cc5600d98ace8d12a6fc5821568226d0593507c" translate="yes" xml:space="preserve">
          <source>With Mixins</source>
          <target state="translated">Mixins 사용</target>
        </trans-unit>
        <trans-unit id="f5e3d812af01ef111586dd7e7cd455fe9cd8f748" translate="yes" xml:space="preserve">
          <source>Within a string of text, #{} style interpolation can be used to place dynamic values within the string:</source>
          <target state="translated">문자열 내에서 # {} 스타일 보간을 사용하여 문자열 내에 동적 값을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d86af3b87d3bc635839ced821182161d6b68ee4" translate="yes" xml:space="preserve">
          <source>Without a framework, Sass puts the cached templates in the &lt;code&gt;.sass-cache&lt;/code&gt; directory. In Rails and Merb, they go in &lt;code&gt;tmp/sass-cache&lt;/code&gt;. The directory can be customized with the &lt;a href=&quot;#cache_location-option&quot;&gt;&lt;code&gt;:cache_location&lt;/code&gt;&lt;/a&gt; option. If you don't want Sass to use caching at all, set the &lt;a href=&quot;#cache-option&quot;&gt;&lt;code&gt;:cache&lt;/code&gt;&lt;/a&gt; option to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">프레임 워크가 없으면 Sass는 캐시 된 템플릿을 &lt;code&gt;.sass-cache&lt;/code&gt; 디렉토리 에 넣습니다 . Rails와 Merb에서는 &lt;code&gt;tmp/sass-cache&lt;/code&gt; 에 들어 갑니다. 디렉토리는 &lt;a href=&quot;#cache_location-option&quot;&gt; &lt;code&gt;:cache_location&lt;/code&gt; &lt;/a&gt; 옵션 으로 사용자 정의 할 수 있습니다 . Sass에서 캐싱을 전혀 사용하지 않으려면 &lt;a href=&quot;#cache-option&quot;&gt; &lt;code&gt;:cache&lt;/code&gt; &lt;/a&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b35c9196af84591c97165ecba0b974655c1c2024" translate="yes" xml:space="preserve">
          <source>Wrap unary negation in parentheses if it&amp;rsquo;s in a space-separated list.</source>
          <target state="translated">공백으로 구분 된 목록에있는 경우 단항 부정을 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="ced6547ebc9d97b74ce12d1a6de550438ee2144e" translate="yes" xml:space="preserve">
          <source>Write a space before &lt;code&gt;-&lt;/code&gt; but not after for a negative number or a unary negation.</source>
          <target state="translated">공간 전에 쓰기 &lt;code&gt;-&lt;/code&gt; 하지만 음수 또는 단항 부정에 대한 후를.</target>
        </trans-unit>
        <trans-unit id="f56b7d1c084ebe4783cdd34797281e416c05826e" translate="yes" xml:space="preserve">
          <source>You always include spaces on both sides of &lt;code&gt;-&lt;/code&gt; when subtracting.</source>
          <target state="translated">당신은 항상 양쪽에 공백이 포함 &lt;code&gt;-&lt;/code&gt; 빼서 때를.</target>
        </trans-unit>
        <trans-unit id="ec01032607173783a4fc4360a977b515e63fb44d" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;use#configuration&quot;&gt;configure modules&lt;/a&gt; that are loaded through an &lt;code&gt;@import&lt;/code&gt; by defining global variables prior the &lt;code&gt;@import&lt;/code&gt; that first loads that module.</source>
          <target state="translated">해당 모듈을 처음로드하는 &lt;code&gt;@import&lt;/code&gt; 이전에 전역 변수를 정의 하여 &lt;code&gt;@import&lt;/code&gt; 를 통해로드되는 &lt;a href=&quot;use#configuration&quot;&gt;모듈&lt;/a&gt; 을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47075dea023ce95f6054d9c81b74824443951572" translate="yes" xml:space="preserve">
          <source>You can access variables, functions, and mixins from another module by writing &lt;code&gt;&amp;lt;namespace&amp;gt;.&amp;lt;variable&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;namespace&amp;gt;.&amp;lt;function&amp;gt;()&lt;/code&gt;, or &lt;code&gt;@include &amp;lt;namespace&amp;gt;.&amp;lt;mixin&amp;gt;()&lt;/code&gt;. By default, the namespace is just the last component of the module&amp;rsquo;s URL.</source>
          <target state="translated">&lt;code&gt;&amp;lt;namespace&amp;gt;.&amp;lt;variable&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;namespace&amp;gt;.&amp;lt;function&amp;gt;()&lt;/code&gt; 또는 &lt;code&gt;@include &amp;lt;namespace&amp;gt;.&amp;lt;mixin&amp;gt;()&lt;/code&gt; 을 작성하여 다른 모듈에서 변수, 함수 및 믹스 인에 액세스 할 수 있습니다 . 기본적으로 네임 스페이스는 모듈 URL의 마지막 구성 요소 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="83572d7d18ba6a271f88ec6054ccb9dbc7eecc65" translate="yes" xml:space="preserve">
          <source>You can also choose whether to evaluate an &lt;code&gt;@else&lt;/code&gt; rule&amp;rsquo;s block by writing it &lt;code&gt;@else if &amp;lt;expression&amp;gt; { ... }&lt;/code&gt;. If you do, the block is evaluated only if the preceding &lt;code&gt;@if&lt;/code&gt;&amp;rsquo;s expression returns &lt;code&gt;false&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; the &lt;code&gt;@else if&lt;/code&gt;&amp;rsquo;s expression returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@else if &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; 을 작성 하여 &lt;code&gt;@else&lt;/code&gt; 규칙의 블록 을 평가할지 여부를 선택할 수도 있습니다 . 당신이 할 경우, 블록이 평가 된 경우에만 위의 경우 &lt;code&gt;@if&lt;/code&gt; 의 표현을 반환 &lt;code&gt;false&lt;/code&gt; &lt;em&gt;과 &lt;/em&gt; &lt;code&gt;@else if&lt;/code&gt; 의 표현을 반환 &lt;code&gt;true&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="81147456a5c44d6acef05640c6850187a2831f7b" translate="yes" xml:space="preserve">
          <source>You can also tell Sass to watch the file and update the CSS every time the Sass file changes:</source>
          <target state="translated">Sass에게 파일을보고 Sass 파일이 변경 될 때마다 CSS를 업데이트하도록 지시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d11ff44ce37f6004626be58674ebbb98268453b1" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;@each&lt;/code&gt; to iterate over every key/value pair in a map by writing it &lt;code&gt;@each &amp;lt;variable&amp;gt;, &amp;lt;variable&amp;gt; in &amp;lt;expression&amp;gt; { ... }&lt;/code&gt;. The key is assigned to the first variable name, and the element is assigned to the second.</source>
          <target state="translated">또한 &lt;code&gt;@each&lt;/code&gt; 를 사용 &lt;code&gt;@each &amp;lt;variable&amp;gt;, &amp;lt;variable&amp;gt; in &amp;lt;expression&amp;gt; { ... }&lt;/code&gt; 을 작성하여 맵의 모든 키 / 값 쌍을 반복 할 수 있습니다 . 키는 첫 번째 변수 이름에 할당되고 요소는 두 번째 변수 이름에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="c122ca56a2a3ed525462e2c06d796aee0409cb52" translate="yes" xml:space="preserve">
          <source>You can also use SassScript variables in selectors and property names using &lt;code&gt;#{}&lt;/code&gt; interpolation syntax:</source>
          <target state="translated">&lt;code&gt;#{}&lt;/code&gt; 보간 구문을 사용하여 선택기 및 속성 이름에 SassScript 변수를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbd0a04e3e99fb4e6c7c0365e57a28f8db7f75e2" translate="yes" xml:space="preserve">
          <source>You can also use the parent selector to add extra suffixes to the outer selector. This is particularly useful when using a methodology like &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt; that uses highly structured class names. As long as the outer selector ends with an alphanumeric name (like class, ID, and element selectors), you can use the parent selector to append additional text.</source>
          <target state="translated">부모 선택기를 사용하여 외부 선택기에 추가 접미사를 추가 할 수도 있습니다. 이것은 고도로 구조화 된 클래스 이름을 사용하는 &lt;a href=&quot;http://getbem.com/&quot;&gt;BEM&lt;/a&gt; 과 같은 방법론을 사용할 때 특히 유용 합니다. 외부 선택기가 영숫자 이름 (예 : 클래스, ID 및 요소 선택기)으로 끝나는 한 부모 선택기를 사용하여 추가 텍스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca9e78f4c3203621d63dc19b76b34f23aeb598e" translate="yes" xml:space="preserve">
          <source>You can also write &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; as unary operators, which take only one value:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 를 하나의 값만 취하는 단항 연산자로 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13d13633a9f0660c0009224931f186514fc691b4" translate="yes" xml:space="preserve">
          <source>You can assign to variables if they aren't already assigned by adding the &lt;code&gt;!default&lt;/code&gt; flag to the end of the value. This means that if the variable has already been assigned to, it won't be re-assigned, but if it doesn't have a value yet, it will be given one.</source>
          <target state="translated">값 끝에 &lt;code&gt;!default&lt;/code&gt; 플래그를 추가하여 변수가 아직 지정되지 않은 경우 변수에 지정할 수 있습니다 . 이는 변수가 이미 할당 된 경우 재 할당되지 않지만 아직 값이없는 경우 변수가 제공됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6367902cbbdd55926eaa7d9f403389bfe9ec844a" translate="yes" xml:space="preserve">
          <source>You can combine interpolation with the parent selector &lt;code&gt;&amp;amp;&lt;/code&gt;, the &lt;a href=&quot;at-rules/at-root&quot;&gt;&lt;code&gt;@at-root&lt;/code&gt; rule&lt;/a&gt;, and &lt;a href=&quot;modules/selector&quot;&gt;selector functions&lt;/a&gt; to wield some serious power when dynamically generating selectors. For more information, see the &lt;a href=&quot;style-rules/parent-selector&quot;&gt;parent selector documentation&lt;/a&gt;.</source>
          <target state="translated">보간을 부모 선택자 &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;a href=&quot;at-rules/at-root&quot;&gt; &lt;code&gt;@at-root&lt;/code&gt; 규칙&lt;/a&gt; 및 &lt;a href=&quot;modules/selector&quot;&gt;선택자 함수&lt;/a&gt; 와 결합하여 선택자를 동적으로 생성 할 때 강력한 힘을 발휘할 수 있습니다. 자세한 내용은 &lt;a href=&quot;style-rules/parent-selector&quot;&gt;상위 선택기 문서를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="889ad2c16e3f33d771b36be949dc75fcd418df43" translate="yes" xml:space="preserve">
          <source>You can convert a quoted string to an unquoted string using the &lt;a href=&quot;../modules/string#unquote&quot;&gt;&lt;code&gt;string.unquote()&lt;/code&gt; function&lt;/a&gt;, and you can convert an unquoted string to a quoted string using the &lt;a href=&quot;../modules/string#quote&quot;&gt;&lt;code&gt;string.quote()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../modules/string#unquote&quot;&gt; &lt;code&gt;string.unquote()&lt;/code&gt; 함수를&lt;/a&gt; 사용하여 인용 된 문자열을 인용되지 않은 문자열로 변환 할 수 있으며 &lt;a href=&quot;../modules/string#quote&quot;&gt; &lt;code&gt;string.quote()&lt;/code&gt; 함수를&lt;/a&gt; 사용하여 인용되지 않은 문자열을 인용 된 문자열로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64155bf8c629e795596b89f0d86392caee9adb84" translate="yes" xml:space="preserve">
          <source>You can convert between decimals and percentages using unit arithmetic. &lt;code&gt;$percentage / 100%&lt;/code&gt; will return the corresponding decimal, and &lt;code&gt;$decimal *
100%&lt;/code&gt; will return the corresponding percentage. You can also use the &lt;a href=&quot;../modules/math#percentage&quot;&gt;&lt;code&gt;math.percentage()&lt;/code&gt; function&lt;/a&gt; as a more explicit way of writing &lt;code&gt;$decimal *
100%&lt;/code&gt;.</source>
          <target state="translated">단위 산술을 사용하여 소수와 백분율간에 변환 할 수 있습니다. &lt;code&gt;$percentage / 100%&lt;/code&gt; 는 해당하는 소수를 반환하고 &lt;code&gt;$decimal * 100%&lt;/code&gt; 는 해당하는 백분율을 반환합니다. &lt;code&gt;$decimal * 100%&lt;/code&gt; 보다 명시 적으로 작성하는 방법으로 &lt;a href=&quot;../modules/math#percentage&quot;&gt; &lt;code&gt;math.percentage()&lt;/code&gt; 함수&lt;/a&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7257ebd10c09e050b2a0304e02e88ca5f9fe4ed" translate="yes" xml:space="preserve">
          <source>You can directly access Sass&amp;rsquo;s intelligent unification using &lt;a href=&quot;../modules/selector&quot;&gt;selector functions&lt;/a&gt;! The &lt;a href=&quot;../modules/selector#unify&quot;&gt;&lt;code&gt;selector.unify()&lt;/code&gt; function&lt;/a&gt; returns a selector that matches the intersection of two selectors, while the &lt;a href=&quot;../modules/selector#extend&quot;&gt;&lt;code&gt;selector.extend()&lt;/code&gt; function&lt;/a&gt; works just like &lt;code&gt;@extend&lt;/code&gt;, but on a single selector.</source>
          <target state="translated">&lt;a href=&quot;../modules/selector&quot;&gt;선택기 기능을&lt;/a&gt; 사용하여 Sass의 지능형 통합에 직접 액세스 할 수 있습니다 ! &lt;a href=&quot;../modules/selector#unify&quot;&gt; &lt;code&gt;selector.unify()&lt;/code&gt; 함수는&lt;/a&gt; 그동안 두 선택기의 교차점과 일치하는 선택 반환 &lt;a href=&quot;../modules/selector#extend&quot;&gt; &lt;code&gt;selector.extend()&lt;/code&gt; 함수&lt;/a&gt; 처럼 작동 &lt;code&gt;@extend&lt;/code&gt; 을 하지만, 하나의 선택에.</target>
        </trans-unit>
        <trans-unit id="9a523a74baa4d7c69d2164b235f4424055c471bb" translate="yes" xml:space="preserve">
          <source>You can easily experiment with SassScript using the interactive shell. To launch the shell run the sass command-line with the &lt;code&gt;-i&lt;/code&gt; option. At the prompt, enter any legal SassScript expression to have it evaluated and the result printed out for you:</source>
          <target state="translated">대화식 쉘을 사용하여 SassScript를 쉽게 실험 할 수 있습니다. 쉘을 시작하려면 &lt;code&gt;-i&lt;/code&gt; 옵션을 사용하여 sass 명령 행을 실행하십시오 . 프롬프트에서 유효한 SassScript 표현식을 입력하여 평가하고 결과를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="e8204e426cb1d70f7c8c54a53034f402d2bb85e6" translate="yes" xml:space="preserve">
          <source>You can even load a module &lt;em&gt;without&lt;/em&gt; a namespace by writing &lt;code&gt;@use &quot;&amp;lt;url&amp;gt;&quot; as *&lt;/code&gt;. We recommend you only do this for stylesheets written by you, though; otherwise, they may introduce new members that cause name conflicts!</source>
          <target state="translated">&lt;code&gt;@use &quot;&amp;lt;url&amp;gt;&quot; as *&lt;/code&gt; 작성하여 네임 스페이스 &lt;em&gt;없이&lt;/em&gt; 모듈 &lt;em&gt;을&lt;/em&gt; 로드 할 수도 있습니다 . 하지만 사용자가 작성한 스타일 시트에 대해서만이 작업을 수행하는 것이 좋습니다. 그렇지 않으면 이름 충돌을 일으키는 새로운 회원을 소개 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="372eddcbe9b5747f09ae847a3212b0fce70894c6" translate="yes" xml:space="preserve">
          <source>You can explicitly control the order of operations using parentheses. An operation inside parentheses is always evaluated before any operations outside of them. Parentheses can even be nested, in which case the innermost parentheses will be evaluated first.</source>
          <target state="translated">괄호를 사용하여 작업 순서를 명시 적으로 제어 할 수 있습니다. 괄호 안의 작업은 항상 그 밖의 작업보다 먼저 평가됩니다. 괄호는 중첩 될 수도 있으며,이 경우 가장 안쪽 괄호가 먼저 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="a6efbecc96c755932cef7a5a3a542ce06278b05c" translate="yes" xml:space="preserve">
          <source>You can explicitly test for &lt;code&gt;$var == false&lt;/code&gt; or &lt;code&gt;$var == null&lt;/code&gt; if you want to distinguish between these.</source>
          <target state="translated">이들을 구별하려면 &lt;code&gt;$var == false&lt;/code&gt; 또는 &lt;code&gt;$var == null&lt;/code&gt; 명시 적으로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6b7313195eca45da747eaf1431f9bea7a2775b5" translate="yes" xml:space="preserve">
          <source>You can install the Sass migrator from most of the same places that you can install &lt;a href=&quot;https://sass-lang.com/dart-sass&quot;&gt;Dart Sass&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://sass-lang.com/dart-sass&quot;&gt;Dart Sass를&lt;/a&gt; 설치할 수있는 대부분의 동일한 위치에서 Sass 마이그레이션을 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7d48bb0fe58549aa7d40409a08f52a1f1b549d8" translate="yes" xml:space="preserve">
          <source>You can install the Sass migrator on Windows, Mac, or Linux by downloading the package for your operating system &lt;a href=&quot;https://github.com/sass/migrator/releases&quot;&gt;from GitHub&lt;/a&gt; and &lt;a href=&quot;https://katiek2.github.io/path-doc/&quot;&gt;adding it to your &lt;code&gt;PATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신은 당신의 운영 시스템의 패키지를 다운로드하여 Windows, Mac 또는 Linux에서 말대꾸의 Migrator를 설치할 수 있습니다 &lt;a href=&quot;https://github.com/sass/migrator/releases&quot;&gt;GitHub의에서&lt;/a&gt; 그리고 &lt;a href=&quot;https://katiek2.github.io/path-doc/&quot;&gt;당신에 추가 &lt;code&gt;PATH&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aab828f202d59063ddc8d72971b50f5ef9487eb2" translate="yes" xml:space="preserve">
          <source>You can nest selectors that use combinators as well. You can put the combinator at the end of the outer selector, at the beginning of the inner selector, or even all on its own in between the two.</source>
          <target state="translated">결합자를 사용하는 선택기를 중첩 할 수도 있습니다. 콤비 네이터는 외부 선택기의 끝, 내부 선택기의 시작 또는 둘 사이에 모두 단독으로 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7623674f7f8c329d2e8140dfe81ffdabe697bfb0" translate="yes" xml:space="preserve">
          <source>You can pass &lt;a href=&quot;syntax/special-functions&quot;&gt;special functions&lt;/a&gt; like &lt;code&gt;calc()&lt;/code&gt; or &lt;code&gt;var()&lt;/code&gt; in place of any argument to &lt;code&gt;hsl()&lt;/code&gt;. You can even use &lt;code&gt;var()&lt;/code&gt; in place of multiple arguments, since it might be replaced by multiple values! When a color function is called this way, it returns an unquoted string using the same signature it was called with.</source>
          <target state="translated">&lt;code&gt;hsl()&lt;/code&gt; 에 대한 인수 대신 &lt;code&gt;calc()&lt;/code&gt; 또는 &lt;code&gt;var()&lt;/code&gt; 와 같은 &lt;a href=&quot;syntax/special-functions&quot;&gt;특수 함수&lt;/a&gt; 를 전달할 수 있습니다 . 여러 값으로 대체 될 수 있으므로 여러 인수 대신 &lt;code&gt;var()&lt;/code&gt; 를 사용할 수도 있습니다! 이러한 방식으로 색상 함수를 호출하면 호출 된 것과 동일한 서명을 사용하여 인용되지 않은 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5c00667667e5e6c3b209c2643ea04586de832bf" translate="yes" xml:space="preserve">
          <source>You can pass &lt;a href=&quot;syntax/special-functions&quot;&gt;special functions&lt;/a&gt; like &lt;code&gt;calc()&lt;/code&gt; or &lt;code&gt;var()&lt;/code&gt; in place of any argument to &lt;code&gt;rgb()&lt;/code&gt;. You can even use &lt;code&gt;var()&lt;/code&gt; in place of multiple arguments, since it might be replaced by multiple values! When a color function is called this way, it returns an unquoted string using the same signature it was called with.</source>
          <target state="translated">&lt;code&gt;rgb()&lt;/code&gt; 에 대한 인수 대신 &lt;code&gt;calc()&lt;/code&gt; 또는 &lt;code&gt;var()&lt;/code&gt; 와 같은 &lt;a href=&quot;syntax/special-functions&quot;&gt;특수 함수&lt;/a&gt; 를 전달할 수 있습니다 . 여러 값으로 대체 될 수 있으므로 여러 인수 대신 &lt;code&gt;var()&lt;/code&gt; 를 사용할 수도 있습니다! 이러한 방식으로 색상 함수를 호출하면 호출 된 것과 동일한 서명을 사용하여 인용되지 않은 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84f8f84f93c9060c537bf98a935e0372c6634707" translate="yes" xml:space="preserve">
          <source>You can pass any value to &lt;code&gt;@debug&lt;/code&gt;, not just a string! It prints the same representation of that value as the &lt;a href=&quot;../modules/meta#inspect&quot;&gt;&lt;code&gt;meta.inspect()&lt;/code&gt; function&lt;/a&gt;.</source>
          <target state="translated">문자열뿐만 아니라 모든 값을 &lt;code&gt;@debug&lt;/code&gt; 에 전달할 수 있습니다 ! &lt;a href=&quot;../modules/meta#inspect&quot;&gt; &lt;code&gt;meta.inspect()&lt;/code&gt; 함수&lt;/a&gt; 와 동일한 값의 표현을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="ba20eeb17ed1540c5890209e0bc6ad635fd905c9" translate="yes" xml:space="preserve">
          <source>You can pass both an argument list and a map as long as the list comes before the map, as in &lt;code&gt;@include colors($values..., $map...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@include colors($values..., $map...)&lt;/code&gt; 에서와 같이 목록이 맵보다 먼저 오는 한 인수 목록과 맵을 모두 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50bfb5f7fd5447b502e26a027c8983b8010ce664" translate="yes" xml:space="preserve">
          <source>You can still update your state over time by assigning new lists to the same variable, though. This is often used in functions and mixins to collect a bunch of values into one list.</source>
          <target state="translated">그래도 동일한 변수에 새 목록을 할당하여 시간이 지남에 따라 상태를 업데이트 할 수 있습니다. 이것은 여러 값을 하나의 목록으로 수집하기 위해 함수와 믹스 인에서 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4429feea85ca7d3118cb1e706111975f06894199" translate="yes" xml:space="preserve">
          <source>You can still update your state over time by assigning new maps to the same variable, though. This is often used in functions and mixins to track configuration in a map.</source>
          <target state="translated">하지만 동일한 변수에 새 맵을 할당하여 시간이 지남에 따라 상태를 업데이트 할 수 있습니다. 맵의 구성을 추적하기 위해 함수 및 믹스 인에서 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76d731fd27bb0a6fc509aa34683c1c6e1d903eaa" translate="yes" xml:space="preserve">
          <source>You can then refer to them in properties:</source>
          <target state="translated">그런 다음 속성에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf503cec47c517b787ea526c054cc2eb87d4090d" translate="yes" xml:space="preserve">
          <source>You can turn warnings off with the &lt;code&gt;--quiet&lt;/code&gt; command-line option or the &lt;code&gt;:quiet&lt;/code&gt; Sass option.</source>
          <target state="translated">&lt;code&gt;--quiet&lt;/code&gt; 명령 줄 옵션 또는 &lt;code&gt;:quiet&lt;/code&gt; Sass 옵션을 사용하여 경고를 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="414495accfc2ae8635088a2c927fc5861609acd6" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;interpolation&quot;&gt;interpolation&lt;/a&gt; to inject values from &lt;a href=&quot;syntax/structure#expressions&quot;&gt;expressions&lt;/a&gt; like variables and function calls into your selectors. This is particularly useful when you&amp;rsquo;re writing &lt;a href=&quot;at-rules/mixin&quot;&gt;mixins&lt;/a&gt;, since it allows you to create selectors from parameters your users pass in.</source>
          <target state="translated">&lt;a href=&quot;interpolation&quot;&gt;보간&lt;/a&gt; 을 사용 하여 변수 및 함수 호출과 같은 &lt;a href=&quot;syntax/structure#expressions&quot;&gt;표현식의&lt;/a&gt; 값을 선택기 에 삽입 할 수 있습니다 . 이것은 사용자가 전달하는 매개 변수에서 선택자를 만들 수 있기 때문에 &lt;a href=&quot;at-rules/mixin&quot;&gt;mixins를&lt;/a&gt; 작성할 때 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="84d5a8e1c75c160f58428bf6ef0ad93b66725dbc" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&amp;amp;&lt;/code&gt; as a normal SassScript expression, which means you can pass it to functions or include it in interpolation&amp;mdash;even in other selectors! Using it in combination with &lt;a href=&quot;../modules/selector#selector-values&quot;&gt;selector functions&lt;/a&gt; and the &lt;a href=&quot;../at-rules/at-root&quot;&gt;&lt;code&gt;@at-root&lt;/code&gt; rule&lt;/a&gt; allows you to nest selectors in very powerful ways.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 를 일반 SassScript 표현식으로 사용할 수 있습니다. 즉, 다른 선택기에서도 함수에 전달하거나 보간에 포함 할 수 있습니다! &lt;a href=&quot;../modules/selector#selector-values&quot;&gt;선택기 함수&lt;/a&gt; 및 &lt;a href=&quot;../at-rules/at-root&quot;&gt; &lt;code&gt;@at-root&lt;/code&gt; 규칙&lt;/a&gt; 과 함께 사용하면 매우 강력한 방법으로 선택기를 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49feb5899497bef208a42fb48189e577100fd7aa" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;@at-root (without: ...)&lt;/code&gt; to move outside of any directive. You can also do it with multiple directives separated by a space: &lt;code&gt;@at-root (without: media supports)&lt;/code&gt; moves outside of both &lt;code&gt;@media&lt;/code&gt; and &lt;code&gt;@supports&lt;/code&gt; queries.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;@at-root (without: ...)&lt;/code&gt; 어떤 지시어 외부에서 이동합니다. &lt;code&gt;@at-root (without: media supports)&lt;/code&gt; 는 &lt;code&gt;@media&lt;/code&gt; 및 &lt;code&gt;@supports&lt;/code&gt; 쿼리 외부로 이동 하여 여러 지시문을 공백으로 구분하여 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7dd01fe2a1bce2b0b3372e74bedff54a62e8e9a" translate="yes" xml:space="preserve">
          <source>You can use booleans to choose whether or not to do various things in Sass. The &lt;a href=&quot;../at-rules/control/if&quot;&gt;&lt;code&gt;@if&lt;/code&gt; rule&lt;/a&gt; evaluates a block of styles if its argument is &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">부울을 사용하여 Sass에서 다양한 작업을 수행할지 여부를 선택할 수 있습니다. &lt;a href=&quot;../at-rules/control/if&quot;&gt; &lt;code&gt;@if&lt;/code&gt; 의 규칙은&lt;/a&gt; 인수 인 경우 스타일의 블록을 평가 &lt;code&gt;true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da2b2af53c24dbda3080a6658d2d65594b29bdb2" translate="yes" xml:space="preserve">
          <source>You can use variable arguments to wrap a mixin and add additional styles without changing the argument signature of the mixin. If you do, keyword arguments will get directly passed through to the wrapped mixin. For example:</source>
          <target state="translated">변수 인수를 사용하여 믹스 인을 랩핑하고 믹스 인의 인수 서명을 변경하지 않고 추가 스타일을 추가 할 수 있습니다. 그렇게하면 키워드 인수가 래핑 된 믹스 인으로 직접 전달됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5cb4f8236e896fc97272ee5b42d8d1d6ffcc3b0" translate="yes" xml:space="preserve">
          <source>You can work with booleans using &lt;a href=&quot;../operators/boolean&quot;&gt;boolean operators&lt;/a&gt;. The &lt;code&gt;and&lt;/code&gt; operator returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;both&lt;/em&gt; sides are &lt;code&gt;true&lt;/code&gt;, and the &lt;code&gt;or&lt;/code&gt; operator returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;either&lt;/em&gt; side is &lt;code&gt;true&lt;/code&gt;. The &lt;code&gt;not&lt;/code&gt; operator returns the opposite of a single boolean value.</source>
          <target state="translated">&lt;a href=&quot;../operators/boolean&quot;&gt;부울 연산자를&lt;/a&gt; 사용하여 부울로 작업 할 수 있습니다 . &lt;code&gt;and&lt;/code&gt; 운영자 반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;em&gt;양쪽&lt;/em&gt; 측면은 &lt;code&gt;true&lt;/code&gt; 1, 및 &lt;code&gt;or&lt;/code&gt; 운영자 복귀 &lt;code&gt;true&lt;/code&gt; 경우 &lt;em&gt;어느&lt;/em&gt; 쪽이 &lt;code&gt;true&lt;/code&gt; . &lt;code&gt;not&lt;/code&gt; 연산자는 하나의 부울 값의 반대를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="214186f8652a0a9f83377311430be290c09851ce" translate="yes" xml:space="preserve">
          <source>You include a space before &lt;code&gt;-&lt;/code&gt; but not after for a negative number or a unary negation.</source>
          <target state="translated">당신은 공간 이전 포함 &lt;code&gt;-&lt;/code&gt; 하지만 음수 또는 단항 부정에 대한 후를.</target>
        </trans-unit>
        <trans-unit id="5577cb020efc3f3b98bd17cf8b1830fc6309b83a" translate="yes" xml:space="preserve">
          <source>You should especially avoid using interpolation like &lt;code&gt;#{$number}px&lt;/code&gt;. This doesn&amp;rsquo;t actually create a number! It creates an &lt;a href=&quot;../values/strings#unquoted&quot;&gt;unquoted string&lt;/a&gt; that &lt;em&gt;looks&lt;/em&gt; like a number, but won&amp;rsquo;t work with any &lt;a href=&quot;numeric&quot;&gt;number operations&lt;/a&gt; or &lt;a href=&quot;../modules/math&quot;&gt;functions&lt;/a&gt;. Try to make your math unit-clean so that &lt;code&gt;$number&lt;/code&gt; already has the unit &lt;code&gt;px&lt;/code&gt;, or write &lt;code&gt;$number * 1px&lt;/code&gt;.</source>
          <target state="translated">특히 &lt;code&gt;#{$number}px&lt;/code&gt; 와 같은 보간법을 사용하지 않아야합니다 . 이것은 실제로 숫자를 생성하지 않습니다! 숫자처럼 &lt;em&gt;보이는 &lt;/em&gt;&lt;a href=&quot;../values/strings#unquoted&quot;&gt;인용되지 않은 문자열&lt;/a&gt; 을 생성 하지만 &lt;a href=&quot;numeric&quot;&gt;숫자 연산&lt;/a&gt; 이나 &lt;a href=&quot;../modules/math&quot;&gt;함수&lt;/a&gt; 에서는 작동하지 않습니다 . &lt;code&gt;$number&lt;/code&gt; 이미 단위 &lt;code&gt;px&lt;/code&gt; 가 있도록 수학 단위를 깨끗하게 만들 거나 &lt;code&gt;$number * 1px&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2d14c022cbcc35de98b95b1362930e308663a4d" translate="yes" xml:space="preserve">
          <source>You should especially avoid using interpolation like &lt;code&gt;#{$number}px&lt;/code&gt;. This doesn&amp;rsquo;t actually create a number! It creates an &lt;a href=&quot;strings#unquoted&quot;&gt;unquoted string&lt;/a&gt; that &lt;em&gt;looks&lt;/em&gt; like a number, but won&amp;rsquo;t work with any &lt;a href=&quot;../operators/numeric&quot;&gt;number operations&lt;/a&gt; or &lt;a href=&quot;../modules/math&quot;&gt;functions&lt;/a&gt;. Try to make your math unit-clean so that &lt;code&gt;$number&lt;/code&gt; already has the unit &lt;code&gt;px&lt;/code&gt;, or write &lt;code&gt;$number * 1px&lt;/code&gt;.</source>
          <target state="translated">특히 &lt;code&gt;#{$number}px&lt;/code&gt; 와 같은 보간법을 사용하지 않아야합니다 . 이것은 실제로 숫자를 생성하지 않습니다! 숫자처럼 &lt;em&gt;보이는 &lt;/em&gt;&lt;a href=&quot;strings#unquoted&quot;&gt;인용되지 않은 문자열&lt;/a&gt; 을 생성 하지만 &lt;a href=&quot;../operators/numeric&quot;&gt;숫자 연산&lt;/a&gt; 이나 &lt;a href=&quot;../modules/math&quot;&gt;함수&lt;/a&gt; 에서는 작동하지 않습니다 . &lt;code&gt;$number&lt;/code&gt; 이미 단위 &lt;code&gt;px&lt;/code&gt; 가 있도록 수학 단위를 깨끗하게 만들 거나 &lt;code&gt;$number * 1px&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8816308f546f36ba1f2eb84b1922ab74be659ff1" translate="yes" xml:space="preserve">
          <source>You wrap a unary negation in parentheses if it's in a space-separated list, as in &lt;code&gt;10px (-$var)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;10px (-$var)&lt;/code&gt; 와 같이 공백으로 구분 된 목록에 있으면 단항 부정을 괄호로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="82451b41fd7878180b6aa2b54e369cbec4e8032c" translate="yes" xml:space="preserve">
          <source>abs</source>
          <target state="translated">abs</target>
        </trans-unit>
        <trans-unit id="41314a88f904c4689277b5eb551576181f8b03de" translate="yes" xml:space="preserve">
          <source>abs($number)</source>
          <target state="translated">abs($number)</target>
        </trans-unit>
        <trans-unit id="13fb83ffcf44c21e90625b65560d2cb3b38b1c37" translate="yes" xml:space="preserve">
          <source>adjust_color</source>
          <target state="translated">adjust_color</target>
        </trans-unit>
        <trans-unit id="fcde6841d6d75d592f338b4773bb5cc3d554e840" translate="yes" xml:space="preserve">
          <source>adjust_color($color, [$red], [$green], [$blue], [$hue], [$saturation], [$lightness], [$alpha])</source>
          <target state="translated">adjust_color ($ color, [$ red], [$ green], [$ blue], [$ hue], [$ saturation], [$ lightness], [$ alpha])</target>
        </trans-unit>
        <trans-unit id="9a48bad57d6bbbfcf761441534d9305586456562" translate="yes" xml:space="preserve">
          <source>adjust_hue</source>
          <target state="translated">adjust_hue</target>
        </trans-unit>
        <trans-unit id="a70422b686b9a2e20129773f335a21da1541c763" translate="yes" xml:space="preserve">
          <source>adjust_hue($color, $degrees)</source>
          <target state="translated">adjust_hue ($ 색, $도)</target>
        </trans-unit>
        <trans-unit id="be76331b95dfc399cd776d2fc68021e0db03cc4f" translate="yes" xml:space="preserve">
          <source>alpha</source>
          <target state="translated">alpha</target>
        </trans-unit>
        <trans-unit id="97fe9c0e1b5011367b9777a98fe408db58713477" translate="yes" xml:space="preserve">
          <source>alpha($color)</source>
          <target state="translated">alpha($color)</target>
        </trans-unit>
        <trans-unit id="515f232e78ae2bf61209d0acf67620a08cf72b8f" translate="yes" xml:space="preserve">
          <source>and &lt;code&gt;_colors.scss&lt;/code&gt; would be imported.</source>
          <target state="translated">및 &lt;code&gt;_colors.scss&lt;/code&gt; 를 가져올 수있다.</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="1f95e54ad17da9f7ddab05727617ccee32ba9d8b" translate="yes" xml:space="preserve">
          <source>append($list, $val, $separator:auto)</source>
          <target state="translated">추가 ($ list, $ val, $ separator : auto)</target>
        </trans-unit>
        <trans-unit id="4c9a82ce72ca2519f38d0af0abbb4cecb9fceca9" translate="yes" xml:space="preserve">
          <source>blue</source>
          <target state="translated">blue</target>
        </trans-unit>
        <trans-unit id="ab64ebf7ba79b4e2d077bfab54e1b739d4950074" translate="yes" xml:space="preserve">
          <source>blue($color)</source>
          <target state="translated">blue($color)</target>
        </trans-unit>
        <trans-unit id="e8f8fe62a522cc962a3179c2ef2f3161ee811ac5" translate="yes" xml:space="preserve">
          <source>booleans (e.g. &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;)</source>
          <target state="translated">부울 (예 : &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bc8d8647b02deea0ab3e715c220d041ee78cc19d" translate="yes" xml:space="preserve">
          <source>call</source>
          <target state="translated">call</target>
        </trans-unit>
        <trans-unit id="20dd91e57ed7bf204330eea88147ed9b194a7d8b" translate="yes" xml:space="preserve">
          <source>call($function, $args...)</source>
          <target state="translated">call ($ function, $ args ...)</target>
        </trans-unit>
        <trans-unit id="613af80c25dfbc9ef75ce605280571b9a518d632" translate="yes" xml:space="preserve">
          <source>ceil</source>
          <target state="translated">ceil</target>
        </trans-unit>
        <trans-unit id="780c60bd62c3b814b33370607671c80f0537384f" translate="yes" xml:space="preserve">
          <source>ceil($number)</source>
          <target state="translated">ceil($number)</target>
        </trans-unit>
        <trans-unit id="dc1b619e02e6d7ccbf209c87d6a683b6d399163a" translate="yes" xml:space="preserve">
          <source>change_color</source>
          <target state="translated">change_color</target>
        </trans-unit>
        <trans-unit id="38518de32ec42f346b3d323f9e208875a46949c1" translate="yes" xml:space="preserve">
          <source>change_color($color, [$red], [$green], [$blue], [$hue], [$saturation], [$lightness], [$alpha])</source>
          <target state="translated">change_color ($ color, [$ red], [$ green], [$ blue], [$ hue], [$ saturation], [$ lightness], [$ alpha])</target>
        </trans-unit>
        <trans-unit id="1c04e58b4f0ee405df5a6e58ecfc03f4bb77f299" translate="yes" xml:space="preserve">
          <source>colors (e.g. &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;#04a3f9&lt;/code&gt;, &lt;code&gt;rgba(255, 0, 0, 0.5)&lt;/code&gt;)</source>
          <target state="translated">색상 (예 : &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;#04a3f9&lt;/code&gt; , &lt;code&gt;rgba(255, 0, 0, 0.5)&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="41dfc188a657086391d84f0d7d61638c451f41b5" translate="yes" xml:space="preserve">
          <source>comparable</source>
          <target state="translated">comparable</target>
        </trans-unit>
        <trans-unit id="a17ecb8b3662485fab6e4862ac7b6bb4a854fe32" translate="yes" xml:space="preserve">
          <source>comparable($number1, $number2)</source>
          <target state="translated">비교 가능 ($ number1, $ number2)</target>
        </trans-unit>
        <trans-unit id="6d5c9dab960e525ed112945029e61215d50dbc52" translate="yes" xml:space="preserve">
          <source>complement</source>
          <target state="translated">complement</target>
        </trans-unit>
        <trans-unit id="b589ca7a7c989e0d901f5953e557459e953b843c" translate="yes" xml:space="preserve">
          <source>complement($color)</source>
          <target state="translated">complement($color)</target>
        </trans-unit>
        <trans-unit id="48f7116d514a7e1a200742892a25afba9684b2c2" translate="yes" xml:space="preserve">
          <source>computes &lt;code&gt;01 * 2 = 02&lt;/code&gt;, &lt;code&gt;02 * 2 = 04&lt;/code&gt;, and &lt;code&gt;03 * 2 = 06&lt;/code&gt;, and is compiled to:</source>
          <target state="translated">계산해 &lt;code&gt;01 * 2 = 02&lt;/code&gt; , &lt;code&gt;02 * 2 = 04&lt;/code&gt; 및 &lt;code&gt;03 * 2 = 06&lt;/code&gt; , 그리고 컴파일된다 :</target>
        </trans-unit>
        <trans-unit id="5d144fff406c46e1c643e6341d2218f55a50f5ab" translate="yes" xml:space="preserve">
          <source>computes &lt;code&gt;01 + 04 = 05&lt;/code&gt;, &lt;code&gt;02 + 05 = 07&lt;/code&gt;, and &lt;code&gt;03 + 06 = 09&lt;/code&gt;, and is compiled to:</source>
          <target state="translated">계산해 &lt;code&gt;01 + 04 = 05&lt;/code&gt; , &lt;code&gt;02 + 05 = 07&lt;/code&gt; 및 &lt;code&gt;03 + 06 = 09&lt;/code&gt; 및 컴파일된다 :</target>
        </trans-unit>
        <trans-unit id="f18c929905ac2ff3971ff803fb0536e1135f7bd0" translate="yes" xml:space="preserve">
          <source>content_exists</source>
          <target state="translated">content_exists</target>
        </trans-unit>
        <trans-unit id="458796e4e963a163322319ba62d683315a930a09" translate="yes" xml:space="preserve">
          <source>counter</source>
          <target state="translated">counter</target>
        </trans-unit>
        <trans-unit id="823683510d4f10536d4a492b82ca2b1bc24f5fcb" translate="yes" xml:space="preserve">
          <source>counter($args...)</source>
          <target state="translated">counter($args...)</target>
        </trans-unit>
        <trans-unit id="9ef65378b90a121f4afd568ccf6ba8211b70ec73" translate="yes" xml:space="preserve">
          <source>counters</source>
          <target state="translated">counters</target>
        </trans-unit>
        <trans-unit id="9eaea663fc86510b9de7edd46ad9ca14dad1f321" translate="yes" xml:space="preserve">
          <source>counters($args...)</source>
          <target state="translated">counters($args...)</target>
        </trans-unit>
        <trans-unit id="e52f1f026347e253ce2eed323018bd1b14329d74" translate="yes" xml:space="preserve">
          <source>css(Bool) &amp;mdash; Whether to get a plain CSS function.</source>
          <target state="translated">css (Bool) &amp;mdash; 일반 CSS 함수를 가져올 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="9d434f61af343dbcd39c63e84bbeee6944187977" translate="yes" xml:space="preserve">
          <source>darken</source>
          <target state="translated">darken</target>
        </trans-unit>
        <trans-unit id="8286568ef2f919cb3a12a1b2bfe6e62463c6f81b" translate="yes" xml:space="preserve">
          <source>darken($color, $amount)</source>
          <target state="translated">어둡게 ($ color, $ amount)</target>
        </trans-unit>
        <trans-unit id="6d5b4b9af4cabbe1e4882083c53be8a7f7344c86" translate="yes" xml:space="preserve">
          <source>desaturate</source>
          <target state="translated">desaturate</target>
        </trans-unit>
        <trans-unit id="c0827bd704098219bedc6b15f2fd5c64a9846b8d" translate="yes" xml:space="preserve">
          <source>desaturate($color, $amount)</source>
          <target state="translated">채도 ($ color, $ amount)</target>
        </trans-unit>
        <trans-unit id="4addec3932ac055130662ca9b3b2926fcde4d2b1" translate="yes" xml:space="preserve">
          <source>feature_exists</source>
          <target state="translated">feature_exists</target>
        </trans-unit>
        <trans-unit id="84729169c70a4fa6f86b34577ef113554c52b4e8" translate="yes" xml:space="preserve">
          <source>feature_exists($feature)</source>
          <target state="translated">feature_exists($feature)</target>
        </trans-unit>
        <trans-unit id="3684c9d3c05e7bee19e2728c6a5b2bbccf0cd9c7" translate="yes" xml:space="preserve">
          <source>floor</source>
          <target state="translated">floor</target>
        </trans-unit>
        <trans-unit id="00dff11ab1e2ad6add8f49c93694d595233d86a8" translate="yes" xml:space="preserve">
          <source>floor($number)</source>
          <target state="translated">floor($number)</target>
        </trans-unit>
        <trans-unit id="cd5cb66563a5f1dd282896b4bd49e68528a39782" translate="yes" xml:space="preserve">
          <source>function references</source>
          <target state="translated">함수 참조</target>
        </trans-unit>
        <trans-unit id="8b93d084be74d48f58fef2ec03bee143b1bd2e7e" translate="yes" xml:space="preserve">
          <source>function_exists</source>
          <target state="translated">function_exists</target>
        </trans-unit>
        <trans-unit id="73efae2687075416b181ef3fbdb71a8be3fb8c1d" translate="yes" xml:space="preserve">
          <source>function_exists($name)</source>
          <target state="translated">function_exists($name)</target>
        </trans-unit>
        <trans-unit id="9a810897a9090fd61a907f05d62146e8d95779e0" translate="yes" xml:space="preserve">
          <source>get_function</source>
          <target state="translated">get_function</target>
        </trans-unit>
        <trans-unit id="73a94d5898a6c4c7ff69ab7a3f58d514f0f4ea66" translate="yes" xml:space="preserve">
          <source>get_function($name, $css:false)</source>
          <target state="translated">get_function ($ name, $ css : false)</target>
        </trans-unit>
        <trans-unit id="53db0bb67179b9cf1b228159b12f80aa5b9543fc" translate="yes" xml:space="preserve">
          <source>global_variable_exists</source>
          <target state="translated">global_variable_exists</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
