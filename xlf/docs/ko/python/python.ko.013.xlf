<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="44f1c1068fb3f75ecb6e1e324e661782e6111e57" translate="yes" xml:space="preserve">
          <source>If the path that &lt;em&gt;cfile&lt;/em&gt; becomes (either explicitly specified or computed) is a symlink or non-regular file, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; will be raised. This is to act as a warning that import will turn those paths into regular files if it is allowed to write byte-compiled files to those paths. This is a side-effect of import using file renaming to place the final byte-compiled file into place to prevent concurrent file writing issues.</source>
          <target state="translated">&lt;em&gt;cfile&lt;/em&gt; 이 되는 경로 (명시 적으로 지정되거나 계산 된)가 symlink 또는 비정규 파일 인 경우 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 바이트 컴파일 파일을 해당 경로에 쓸 수 있으면 가져 오기에서 해당 경로를 일반 파일로 변환한다는 경고의 역할을합니다. 이는 파일 이름 바꾸기를 사용하여 최종 바이트 컴파일 된 파일을 제자리에 배치하여 동시 파일 쓰기 문제를 방지하는 가져 오기의 부작용입니다.</target>
        </trans-unit>
        <trans-unit id="ae2d2687ad3551ef8bd1472c724bb07372b1e0e7" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; function, this mapping may be used to modify the environment as well as query the environment. &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; will be called automatically when the mapping is modified.</source>
          <target state="translated">플랫폼이 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 함수를 지원하는 경우이 맵핑을 사용하여 환경을 조회하고 환경을 조회 할 수 있습니다. &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 는 매핑이 수정 될 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="359b0fc2d0ac172f51521bc634e7ed8e651ae47d" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; function, you can delete items in this mapping to unset environment variables. &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; will be called automatically when an item is deleted from &lt;code&gt;os.environ&lt;/code&gt;, and when one of the &lt;code&gt;pop()&lt;/code&gt; or &lt;code&gt;clear()&lt;/code&gt; methods is called.</source>
          <target state="translated">플랫폼이 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 함수를 지원하는 경우이 맵핑에서 항목을 삭제하여 환경 변수를 설정 해제 할 수 있습니다. &lt;code&gt;os.environ&lt;/code&gt; 에서 항목이 삭제되고 &lt;code&gt;pop()&lt;/code&gt; 또는 &lt;code&gt;clear()&lt;/code&gt; 메소드 중 하나 가 호출되면 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 가 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c98e4ced54c3de726831a13682ac05eaffe4094a" translate="yes" xml:space="preserve">
          <source>If the priority of a task changes, how do you move it to a new position in the heap?</source>
          <target state="translated">작업의 우선 순위가 변경되면 어떻게 작업을 힙의 새로운 위치로 이동합니까?</target>
        </trans-unit>
        <trans-unit id="a498076041fadf1d07bb9300b846a643e776f60f" translate="yes" xml:space="preserve">
          <source>If the process does not terminate after &lt;em&gt;timeout&lt;/em&gt; seconds, a &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt;&lt;code&gt;TimeoutExpired&lt;/code&gt;&lt;/a&gt; exception will be raised. Catching this exception and retrying communication will not lose any output.</source>
          <target state="translated">&lt;em&gt;타임 아웃&lt;/em&gt; 초 후에 프로세스가 종료되지 않으면 &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt; &lt;code&gt;TimeoutExpired&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 이 예외를 포착하고 통신을 다시 시도해도 출력이 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d9458f7fed96d843f923a0a12238a4b1050fd9f" translate="yes" xml:space="preserve">
          <source>If the process does not terminate after &lt;em&gt;timeout&lt;/em&gt; seconds, raise a &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt;&lt;code&gt;TimeoutExpired&lt;/code&gt;&lt;/a&gt; exception. It is safe to catch this exception and retry the wait.</source>
          <target state="translated">프로세스가 이후에 종료되지 않는 경우 &lt;em&gt;제한 시간&lt;/em&gt; (초), 인상 &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt; &lt;code&gt;TimeoutExpired&lt;/code&gt; 의&lt;/a&gt; 예외. 이 예외를 포착하고 대기를 재 시도하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="29bf9cf7b23c8ae6d712f6a347508cd693444005" translate="yes" xml:space="preserve">
          <source>If the process exited normally (if &lt;code&gt;WIFEXITED(status)&lt;/code&gt; is true), return the process exit status (return &lt;code&gt;WEXITSTATUS(status)&lt;/code&gt;): result greater than or equal to 0.</source>
          <target state="translated">프로세스가 정상적으로 종료되면 ( &lt;code&gt;WIFEXITED(status)&lt;/code&gt; 가 true 인 경우) 프로세스 종료 상태를 반환합니다 (return &lt;code&gt;WEXITSTATUS(status)&lt;/code&gt; ) : 결과가 0보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="053fd58ab602e7071a8906f099acb443c648c32b" translate="yes" xml:space="preserve">
          <source>If the process runs longer than &lt;em&gt;timeout&lt;/em&gt; seconds (&lt;a href=&quot;#test.support.SHORT_TIMEOUT&quot;&gt;&lt;code&gt;SHORT_TIMEOUT&lt;/code&gt;&lt;/a&gt; by default), kill the process and raise an &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;. The timeout feature is not available on Windows.</source>
          <target state="translated">프로세스가 &lt;em&gt;시간 초과&lt;/em&gt; 초 ( 기본적으로 &lt;a href=&quot;#test.support.SHORT_TIMEOUT&quot;&gt; &lt;code&gt;SHORT_TIMEOUT&lt;/code&gt; )&lt;/a&gt; 보다 오래 실행되면 프로세스를 &lt;em&gt;종료&lt;/em&gt; 하고 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 시간 제한 기능은 Windows에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="69ed2fec98f279431226b0412fb7368d8cbf983e" translate="yes" xml:space="preserve">
          <source>If the process was terminated by a signal (if &lt;code&gt;WIFSIGNALED(status)&lt;/code&gt; is true), return &lt;code&gt;-signum&lt;/code&gt; where &lt;em&gt;signum&lt;/em&gt; is the number of the signal that caused the process to terminate (return &lt;code&gt;-WTERMSIG(status)&lt;/code&gt;): result less than 0.</source>
          <target state="translated">프로세스가 신호에 의해 종료 된 경우 ( &lt;code&gt;WIFSIGNALED(status)&lt;/code&gt; 가 true 인 경우) &lt;code&gt;-signum&lt;/code&gt; 을 반환 합니다. 여기서 &lt;em&gt;signum&lt;/em&gt; 은 프로세스를 종료 한 신호의 번호입니다 (return &lt;code&gt;-WTERMSIG(status)&lt;/code&gt; ) : 결과가 0보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="f7262122dc4b6b829f446558da074d130b2a5add" translate="yes" xml:space="preserve">
          <source>If the queue was initialized with &lt;code&gt;maxsize=0&lt;/code&gt; (the default), then &lt;a href=&quot;#asyncio.Queue.full&quot;&gt;&lt;code&gt;full()&lt;/code&gt;&lt;/a&gt; never returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">큐가 &lt;code&gt;maxsize=0&lt;/code&gt; (기본값) 으로 초기화 된 경우 &lt;a href=&quot;#asyncio.Queue.full&quot;&gt; &lt;code&gt;full()&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;True&lt;/code&gt; 를 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d78a8ec352511b839919bc03232ce959083bf45a" translate="yes" xml:space="preserve">
          <source>If the referent is unpicklable then this will raise an exception.</source>
          <target state="translated">심판이 피클 링 할 수 없으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91ada59b96a0d8cfa6712ce3f61b93c29c1b67a6" translate="yes" xml:space="preserve">
          <source>If the referent no longer exists, calling the reference object returns &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">참조자가 더 이상 존재하지 않으면 참조 객체를 호출하면 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 이&lt;/a&gt; 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="909c01304c9716dba0fff5875fca0ce88ce2dc59" translate="yes" xml:space="preserve">
          <source>If the regular expression uses the &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; syntax, the &lt;em&gt;groupN&lt;/em&gt; arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">정규식이 &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 구문을 사용하는 경우 &lt;em&gt;groupN&lt;/em&gt; 인수는 그룹 이름으로 그룹을 식별하는 문자열 일 수도 있습니다. 패턴에서 문자열 인수가 그룹 이름으로 사용되지 않으면 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9150bc1a07c7bb0e57bdc9eaf32d4f61f9798eda" translate="yes" xml:space="preserve">
          <source>If the reply matches the digest of the message using &lt;em&gt;authkey&lt;/em&gt; as the key then a welcome message is sent to the other end of the connection. Otherwise &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt;&lt;code&gt;AuthenticationError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">응답이 &lt;em&gt;authkey&lt;/em&gt; 를 키로 사용하여 메시지의 요약과 일치 하면 연결의 다른 쪽 끝으로 환영 메시지가 전송됩니다. 그렇지 않으면 &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt; &lt;code&gt;AuthenticationError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="335f0408ae4594f8d3341768174fc78d95715a5d" translate="yes" xml:space="preserve">
          <source>If the request was mapped to a directory, the directory is checked for a file named &lt;code&gt;index.html&lt;/code&gt; or &lt;code&gt;index.htm&lt;/code&gt; (in that order). If found, the file&amp;rsquo;s contents are returned; otherwise a directory listing is generated by calling the &lt;code&gt;list_directory()&lt;/code&gt; method. This method uses &lt;a href=&quot;os#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt; to scan the directory, and returns a &lt;code&gt;404&lt;/code&gt; error response if the &lt;a href=&quot;os#os.listdir&quot;&gt;&lt;code&gt;listdir()&lt;/code&gt;&lt;/a&gt; fails.</source>
          <target state="translated">요청이 디렉토리에 맵핑 된 경우, 디렉토리는 &lt;code&gt;index.html&lt;/code&gt; 또는 &lt;code&gt;index.htm&lt;/code&gt; (순서대로) 파일을 점검합니다 . 발견되면 파일 내용이 반환됩니다. 그렇지 않으면 &lt;code&gt;list_directory()&lt;/code&gt; 메소드를 호출하여 디렉토리 목록이 생성됩니다 . 이 메소드는 &lt;a href=&quot;os#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 디렉토리를 스캔 하고 &lt;a href=&quot;os#os.listdir&quot;&gt; &lt;code&gt;listdir()&lt;/code&gt; &lt;/a&gt; 이 실패하면 &lt;code&gt;404&lt;/code&gt; 오류 응답을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="785b81ecc43784be1a5372c2c81457edd17d9681" translate="yes" xml:space="preserve">
          <source>If the request was mapped to a file, it is opened. Any &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception in opening the requested file is mapped to a &lt;code&gt;404&lt;/code&gt;, &lt;code&gt;'File not found'&lt;/code&gt; error. If there was a &lt;code&gt;'If-Modified-Since'&lt;/code&gt; header in the request, and the file was not modified after this time, a &lt;code&gt;304&lt;/code&gt;, &lt;code&gt;'Not Modified'&lt;/code&gt; response is sent. Otherwise, the content type is guessed by calling the &lt;code&gt;guess_type()&lt;/code&gt; method, which in turn uses the &lt;em&gt;extensions_map&lt;/em&gt; variable, and the file contents are returned.</source>
          <target state="translated">요청이 파일에 맵핑 된 경우 열립니다. 모든 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 요청 된 파일을 여는 예외가 매핑됩니다 &lt;code&gt;404&lt;/code&gt; , &lt;code&gt;'File not found'&lt;/code&gt; 오류가 발생했습니다. 거기 경우 &lt;code&gt;'If-Modified-Since'&lt;/code&gt; 요청의 헤더 및 파일이 시간 후에 변형되지 않은 &lt;code&gt;304&lt;/code&gt; , &lt;code&gt;'Not Modified'&lt;/code&gt; 응답이 전송된다. 그렇지 않은 경우, &lt;em&gt;extensions_map&lt;/em&gt; 변수를 사용하는 &lt;code&gt;guess_type()&lt;/code&gt; 메소드 를 호출하여 컨텐츠 유형을 추측 하고 파일 컨텐츠가 리턴됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="164f68a4853c0030aecaf77543f70404dffd338d" translate="yes" xml:space="preserve">
          <source>If the requested module already exists in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;, that module should be used and reloaded. Otherwise the loader should create a new module and insert it into &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; before any loading begins, to prevent recursion from the import. If the loader inserted a module and the load fails, it must be removed by the loader from &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;; modules already in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; before the loader began execution should be left alone (see &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt;&lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">요청 된 모듈이 이미 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 존재 하면 해당 모듈을 사용하고 다시로드해야합니다. 그렇지 않으면 로더는 가져 오기에서 재귀를 방지하기 위해로드를 시작하기 전에 새 모듈을 작성하고 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 삽입해야 합니다. 로더가 모듈을 삽입했는데로드가 실패하면 로더가 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에서 제거해야합니다 . 로더가 실행을 시작하기 전에 이미 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에있는 모듈 은 그대로 두어야합니다 ( &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt; &lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="03b4e196b2e9acd5ba4a384dea909aa2a6ee615a" translate="yes" xml:space="preserve">
          <source>If the resource cannot be found, &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">리소스를 찾을 수 없으면 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0df3e09c5b36021f773ac46f41a2c43194c9fca6" translate="yes" xml:space="preserve">
          <source>If the resource cleanup isn&amp;rsquo;t already neatly bundled into a standalone function, then it is still possible to use the decorator form of &lt;a href=&quot;#contextlib.ExitStack.callback&quot;&gt;&lt;code&gt;ExitStack.callback()&lt;/code&gt;&lt;/a&gt; to declare the resource cleanup in advance:</source>
          <target state="translated">자원 정리가 아직 독립형 함수에 깔끔하게 번들되어 있지 않은 경우에도 &lt;a href=&quot;#contextlib.ExitStack.callback&quot;&gt; &lt;code&gt;ExitStack.callback()&lt;/code&gt; &lt;/a&gt; 형식 ExitStack.callback () 을 사용하여 자원 정리를 미리 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1ab5f376bf69b7b54158c8e22471cb84fdbe8d" translate="yes" xml:space="preserve">
          <source>If the resource does not concretely exist on the file system, raise &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자원이 파일 시스템에 구체적으로 존재하지 않으면 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; &lt;/a&gt; 를 발생 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="e8f1ce475d9c36397896ac205e613c6b1f406f21" translate="yes" xml:space="preserve">
          <source>If the result is zero then its sign will be the sign of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">결과가 0이면 해당 부호는 &lt;em&gt;self&lt;/em&gt; 의 부호입니다 .</target>
        </trans-unit>
        <trans-unit id="5a98dda2c1e7c49ba619d9723afd406089bc22f0" translate="yes" xml:space="preserve">
          <source>If the return code was non-zero it raises a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt; object will have the return code in the &lt;a href=&quot;#subprocess.CalledProcessError.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; attribute and any output in the &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">리턴 코드가 0이 아닌 경우 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다. &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 의&lt;/a&gt; 객체는의 리턴 코드가됩니다 &lt;a href=&quot;#subprocess.CalledProcessError.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 특성과 어떤 출력 &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="1499f9fffce42eacfcc4c16359b64bca87b01b5c" translate="yes" xml:space="preserve">
          <source>If the return value &lt;em&gt;is&lt;/em&gt; an iterator, then iterating over it once will consume it and subsequent iterations will result in an empty list:</source>
          <target state="translated">반환 값 &lt;em&gt;이&lt;/em&gt; 이터레이터 인 경우 한 번 반복 하면 그 값 &lt;em&gt;이&lt;/em&gt; 소비되고 그 이후의 반복에서는 빈 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="108f2d44c66943b7534256bc63b5f502b9a8ba5a" translate="yes" xml:space="preserve">
          <source>If the root is reached, and it has a level of NOTSET, then all messages will be processed. Otherwise, the root&amp;rsquo;s level will be used as the effective level.</source>
          <target state="translated">루트에 도달하고 레벨이 NOTSET이면 모든 메시지가 처리됩니다. 그렇지 않으면 루트 레벨이 유효 레벨로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09d539352f4b8bde471c4c7a5b1b7605d75d424f" translate="yes" xml:space="preserve">
          <source>If the sample size is larger than the population size, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">표본 크기가 모집단 크기보다 크면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d4676a6fdc2402cf5a3dbbb4a4b2ed50deb25ed" translate="yes" xml:space="preserve">
          <source>If the second argument is omitted, the super object returned is unbound. If the second argument is an object, &lt;code&gt;isinstance(obj, type)&lt;/code&gt; must be true. If the second argument is a type, &lt;code&gt;issubclass(type2, type)&lt;/code&gt; must be true (this is useful for classmethods).</source>
          <target state="translated">두 번째 인수가 생략되면 리턴 된 수퍼 오브젝트가 바인드되지 않습니다. 두 번째 인수가 객체 인 경우 &lt;code&gt;isinstance(obj, type)&lt;/code&gt; 는 true 여야합니다. 두 번째 인수가 유형 인 경우 &lt;code&gt;issubclass(type2, type)&lt;/code&gt; 는 true 여야합니다 (이는 클래스 메소드에 유용합니다).</target>
        </trans-unit>
        <trans-unit id="5001076d001501658658c23588861355b9db6f5b" translate="yes" xml:space="preserve">
          <source>If the signal is not trapped (default), mixing floats and Decimals is permitted in the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; constructor, &lt;a href=&quot;#decimal.Context.create_decimal&quot;&gt;&lt;code&gt;create_decimal()&lt;/code&gt;&lt;/a&gt; and all comparison operators. Both conversion and comparisons are exact. Any occurrence of a mixed operation is silently recorded by setting &lt;a href=&quot;#decimal.FloatOperation&quot;&gt;&lt;code&gt;FloatOperation&lt;/code&gt;&lt;/a&gt; in the context flags. Explicit conversions with &lt;a href=&quot;#decimal.Decimal.from_float&quot;&gt;&lt;code&gt;from_float()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#decimal.Context.create_decimal_from_float&quot;&gt;&lt;code&gt;create_decimal_from_float()&lt;/code&gt;&lt;/a&gt; do not set the flag.</source>
          <target state="translated">신호가 트래핑되지 않으면 (기본값) 부동 소수점과 소수를 혼합하는 것이 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 생성자, &lt;a href=&quot;#decimal.Context.create_decimal&quot;&gt; &lt;code&gt;create_decimal()&lt;/code&gt; &lt;/a&gt; 및 모든 비교 연산자 에서 허용됩니다 . 변환과 비교는 모두 정확합니다. 컨텍스트 플래그에서 &lt;a href=&quot;#decimal.FloatOperation&quot;&gt; &lt;code&gt;FloatOperation&lt;/code&gt; &lt;/a&gt; 을 설정하면 혼합 작업이 자동으로 기록됩니다 . &lt;a href=&quot;#decimal.Decimal.from_float&quot;&gt; &lt;code&gt;from_float()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#decimal.Context.create_decimal_from_float&quot;&gt; &lt;code&gt;create_decimal_from_float()&lt;/code&gt; &lt;/a&gt; 를 사용한 명시 적 변환 은 플래그를 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5eb98687458be9bdfcd1779f07871d42fe11615b" translate="yes" xml:space="preserve">
          <source>If the specified check is not supported, an &lt;a href=&quot;#lzma.LZMAError&quot;&gt;&lt;code&gt;LZMAError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 검사가 지원되지 않으면 &lt;a href=&quot;#lzma.LZMAError&quot;&gt; &lt;code&gt;LZMAError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b54c9f0cfe02eb7352da72b9945e23c261ee5f4" translate="yes" xml:space="preserve">
          <source>If the specified sound cannot be found, do not play the system default sound.</source>
          <target state="translated">지정된 사운드를 찾을 수 없으면 시스템 기본 사운드를 재생하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="778c39a7849194812f3b69dbd53ec4638f531eda" translate="yes" xml:space="preserve">
          <source>If the specified value is &lt;code&gt;True&lt;/code&gt;, the configuration is processed as described in the section on &lt;a href=&quot;#logging-config-dict-incremental&quot;&gt;Incremental Configuration&lt;/a&gt;.</source>
          <target state="translated">지정된 값이 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;#logging-config-dict-incremental&quot;&gt;증분 구성&lt;/a&gt; 섹션에 설명 된대로 구성이 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="06cc8f856e11dad88ac598335b513ab61be78c92" translate="yes" xml:space="preserve">
          <source>If the start method has not been fixed and &lt;em&gt;allow_none&lt;/em&gt; is false, then the start method is fixed to the default and the name is returned. If the start method has not been fixed and &lt;em&gt;allow_none&lt;/em&gt; is true then &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">start 메소드가 수정되지 않고 &lt;em&gt;allow_none&lt;/em&gt; 이 false 인 경우 start 메소드가 기본값으로 고정되고 이름이 리턴됩니다. start 메소드가 수정되지 않고 &lt;em&gt;allow_none&lt;/em&gt; 이 true이면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8dc33b40746a00e1cdecb86672318e2613660654" translate="yes" xml:space="preserve">
          <source>If the string ends with the &lt;em&gt;suffix&lt;/em&gt; string and that &lt;em&gt;suffix&lt;/em&gt; is not empty, return &lt;code&gt;string[:-len(suffix)]&lt;/code&gt;. Otherwise, return a copy of the original string:</source>
          <target state="translated">문자열이 &lt;em&gt;접미사&lt;/em&gt; 문자열로 끝나고 해당 &lt;em&gt;접미사&lt;/em&gt; 가 비어 있지 않으면 &lt;code&gt;string[:-len(suffix)]&lt;/code&gt; 반환 합니다 . 그렇지 않으면 원래 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da4843e8d12f8d5f0a56e982e7b90def6480848b" translate="yes" xml:space="preserve">
          <source>If the string starts with the &lt;em&gt;prefix&lt;/em&gt; string, return &lt;code&gt;string[len(prefix):]&lt;/code&gt;. Otherwise, return a copy of the original string:</source>
          <target state="translated">문자열이 &lt;em&gt;접두사&lt;/em&gt; 문자열로 시작하면 &lt;code&gt;string[len(prefix):]&lt;/code&gt; 반환 합니다 . 그렇지 않으면 원래 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b8c9208a62d78a294576a65a53059a1c5f6f17a" translate="yes" xml:space="preserve">
          <source>If the subclass overrides the constructor, it must make sure to invoke the base class constructor (&lt;code&gt;Thread.__init__()&lt;/code&gt;) before doing anything else to the thread.</source>
          <target state="translated">서브 클래스가 생성자를 대체하는 경우 스레드에 다른 작업을 수행하기 전에 기본 클래스 생성자 ( &lt;code&gt;Thread.__init__()&lt;/code&gt; ) 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="acce8b93fe985a72766f9ac89c69d8af02e986e6" translate="yes" xml:space="preserve">
          <source>If the submitted form data contains more than one field with the same name, the object retrieved by &lt;code&gt;form[key]&lt;/code&gt; is not a &lt;code&gt;FieldStorage&lt;/code&gt; or &lt;code&gt;MiniFieldStorage&lt;/code&gt; instance but a list of such instances. Similarly, in this situation, &lt;code&gt;form.getvalue(key)&lt;/code&gt; would return a list of strings. If you expect this possibility (when your HTML form contains multiple fields with the same name), use the &lt;a href=&quot;#cgi.FieldStorage.getlist&quot;&gt;&lt;code&gt;getlist()&lt;/code&gt;&lt;/a&gt; method, which always returns a list of values (so that you do not need to special-case the single item case). For example, this code concatenates any number of username fields, separated by commas:</source>
          <target state="translated">제출 된 양식 데이터에 동일한 이름의 필드가 둘 이상 있으면 &lt;code&gt;form[key]&lt;/code&gt; 의해 검색된 오브젝트 는 &lt;code&gt;FieldStorage&lt;/code&gt; 또는 &lt;code&gt;MiniFieldStorage&lt;/code&gt; 인스턴스가 아니라 해당 인스턴스 목록입니다. 이와 유사 &lt;code&gt;form.getvalue(key)&lt;/code&gt; 상황에서 form.getvalue (key) 는 문자열 목록을 반환합니다. 이러한 가능성이 예상되면 (HTML 양식에 동일한 이름을 가진 여러 필드가 포함 된 경우) &lt;a href=&quot;#cgi.FieldStorage.getlist&quot;&gt; &lt;code&gt;getlist()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오.이 메소드는 항상 값 목록을 리턴하므로 단일 항목 케이스를 특수하게 처리 할 필요가 없습니다. 예를 들어이 코드는 쉼표로 구분하여 여러 사용자 이름 필드를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="5ca69890189daafd25a2e36e6b3b7787040e88e4" translate="yes" xml:space="preserve">
          <source>If the subprocess hasn&amp;rsquo;t returned yet, and close transports of &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt;, and &lt;em&gt;stderr&lt;/em&gt; pipes.</source>
          <target state="translated">서브 프로세스가 아직 리턴되지 않은 경우 &lt;em&gt;stdin&lt;/em&gt; , &lt;em&gt;stdout&lt;/em&gt; 및 &lt;em&gt;stderr&lt;/em&gt; 파이프의 전송을 닫으십시오 .</target>
        </trans-unit>
        <trans-unit id="97b2ccdb92b73cedf9597250b83de25464d1e506" translate="yes" xml:space="preserve">
          <source>If the supplied path directly references a script file (whether as source or as precompiled byte code), then &lt;code&gt;__file__&lt;/code&gt; will be set to the supplied path, and &lt;code&gt;__spec__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; will all be set to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 경로가 스크립트 파일 (소스 또는 사전 컴파일 된 바이트 코드)을 직접 참조하는 경우 &lt;code&gt;__file__&lt;/code&gt; 은 제공된 경로로 설정되고 &lt;code&gt;__spec__&lt;/code&gt; , &lt;code&gt;__cached__&lt;/code&gt; , &lt;code&gt;__loader__&lt;/code&gt; 및 &lt;code&gt;__package__&lt;/code&gt; 는 모두 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c60916833581a918770fd11c43105b09a19f5fd3" translate="yes" xml:space="preserve">
          <source>If the supplied path is a reference to a valid sys.path entry, then &lt;code&gt;__spec__&lt;/code&gt; will be set appropriately for the imported &lt;code&gt;__main__&lt;/code&gt; module (that is, &lt;code&gt;__spec__.name&lt;/code&gt; will always be &lt;code&gt;__main__&lt;/code&gt;). &lt;code&gt;__file__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; will be &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#import-mod-attrs&quot;&gt;set as normal&lt;/a&gt; based on the module spec.</source>
          <target state="translated">제공된 경로가 유효한 sys.path 항목에 대한 참조 이면 가져온 &lt;code&gt;__main__&lt;/code&gt; 모듈에 대해 &lt;code&gt;__spec__&lt;/code&gt; 이 적절하게 설정됩니다 (즉, &lt;code&gt;__spec__.name&lt;/code&gt; 은 항상 &lt;code&gt;__main__&lt;/code&gt; 입니다 ). &lt;code&gt;__file__&lt;/code&gt; , &lt;code&gt;__cached__&lt;/code&gt; , &lt;code&gt;__loader__&lt;/code&gt; 및 &lt;code&gt;__package__&lt;/code&gt; 는 모듈 사양에 따라 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#import-mod-attrs&quot;&gt;정상적으로 설정됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f2aeb9c49d543acbef15ce0272a7d7b10a0003a" translate="yes" xml:space="preserve">
          <source>If the supplied path is a reference to a valid sys.path entry, then &lt;code&gt;__spec__&lt;/code&gt; will be set appropriately for the imported &lt;code&gt;__main__&lt;/code&gt; module (that is, &lt;code&gt;__spec__.name&lt;/code&gt; will always be &lt;code&gt;__main__&lt;/code&gt;). &lt;code&gt;__file__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; will be &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#import-mod-attrs&quot;&gt;set as normal&lt;/a&gt; based on the module spec.</source>
          <target state="translated">제공된 경로가 유효한 sys.path 항목에 대한 참조 인 경우 &lt;code&gt;__spec__&lt;/code&gt; 은 가져온 &lt;code&gt;__main__&lt;/code&gt; 모듈에 대해 적절하게 설정됩니다 (즉, &lt;code&gt;__spec__.name&lt;/code&gt; 은 항상 &lt;code&gt;__main__&lt;/code&gt; ). &lt;code&gt;__file__&lt;/code&gt; , &lt;code&gt;__cached__&lt;/code&gt; , &lt;code&gt;__loader__&lt;/code&gt; 및 &lt;code&gt;__package__&lt;/code&gt; 는 모듈 사양에 따라 &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#import-mod-attrs&quot;&gt;정상&lt;/a&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1adf55313515a9d46f4badde3d9f05bb3bac807d" translate="yes" xml:space="preserve">
          <source>If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an &lt;a href=&quot;exceptions#InterruptedError&quot;&gt;&lt;code&gt;InterruptedError&lt;/code&gt;&lt;/a&gt; exception (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0475&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;PEP 475&lt;/strong&gt;&lt;/a&gt; for the rationale).</source>
          <target state="translated">시스템 호출이 중단되고 신호 핸들러가 예외를 발생시키지 않으면이 함수는 이제 &lt;a href=&quot;exceptions#InterruptedError&quot;&gt; &lt;code&gt;InterruptedError&lt;/code&gt; &lt;/a&gt; 예외 를 발생시키는 대신 시스템 호출을 재 시도합니다 ( 이론 은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0475&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;PEP 475&lt;/strong&gt;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a6d43cf81da71fff4123417dbbd417d2066dd963" translate="yes" xml:space="preserve">
          <source>If the system has little free memory, snapshots can be written on disk using the &lt;a href=&quot;#tracemalloc.Snapshot.dump&quot;&gt;&lt;code&gt;Snapshot.dump()&lt;/code&gt;&lt;/a&gt; method to analyze the snapshot offline. Then use the &lt;a href=&quot;#tracemalloc.Snapshot.load&quot;&gt;&lt;code&gt;Snapshot.load()&lt;/code&gt;&lt;/a&gt; method reload the snapshot.</source>
          <target state="translated">시스템에 사용 가능한 메모리가 거의없는 경우 &lt;a href=&quot;#tracemalloc.Snapshot.dump&quot;&gt; &lt;code&gt;Snapshot.dump()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 디스크에 스냅 샷을 작성 하여 스냅 샷을 오프라인으로 분석 할 수 있습니다 . 그런 다음 &lt;a href=&quot;#tracemalloc.Snapshot.load&quot;&gt; &lt;code&gt;Snapshot.load()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 스냅 샷을 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="31f84dc9d5116f5e6dfe6a1466f5a476a9188d05" translate="yes" xml:space="preserve">
          <source>If the target is omitted (or &lt;code&gt;None&lt;/code&gt;), the source must be a directory and the target will be a file with the same name as the source, with a &lt;code&gt;.pyz&lt;/code&gt; extension added.</source>
          <target state="translated">대상이 생략 된 경우 (또는 &lt;code&gt;None&lt;/code&gt; ) 소스는 디렉토리 여야하며 대상은 소스와 이름이 같은 파일 &lt;code&gt;.pyz&lt;/code&gt; 확장자 는 .pyz 입니다.</target>
        </trans-unit>
        <trans-unit id="a81ad72c0eb0b73e6a8f61b1a3e045791f08818e" translate="yes" xml:space="preserve">
          <source>If the terminal size cannot be successfully queried, either because the system doesn&amp;rsquo;t support querying, or because we are not connected to a terminal, the value given in &lt;code&gt;fallback&lt;/code&gt; parameter is used. &lt;code&gt;fallback&lt;/code&gt; defaults to &lt;code&gt;(80, 24)&lt;/code&gt; which is the default size used by many terminal emulators.</source>
          <target state="translated">시스템이 쿼리를 지원하지 않거나 터미널에 연결되어 있지 않기 때문에 터미널 크기를 성공적으로 쿼리 할 수없는 경우 &lt;code&gt;fallback&lt;/code&gt; 매개 변수에 지정된 값 이 사용됩니다. &lt;code&gt;fallback&lt;/code&gt; 디폴트 &lt;code&gt;(80, 24)&lt;/code&gt; 많은 단말기 에뮬레이터에 의해 사용되는 디폴트 크기.</target>
        </trans-unit>
        <trans-unit id="2de2938d3bd0d33a2753ba4337962dd33d95e0ce" translate="yes" xml:space="preserve">
          <source>If the testing strategy changes, there is no need to change the source code.</source>
          <target state="translated">테스트 전략이 변경되면 소스 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcd64126f5fb037416eebb3476593dfc24805624" translate="yes" xml:space="preserve">
          <source>If the transport has a buffer for outgoing data, buffered data will be flushed asynchronously. No more data will be received. After all buffered data is flushed, the protocol&amp;rsquo;s &lt;a href=&quot;#asyncio.BaseProtocol.connection_lost&quot;&gt;&lt;code&gt;protocol.connection_lost()&lt;/code&gt;&lt;/a&gt; method will be called with &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; as its argument.</source>
          <target state="translated">전송에 나가는 데이터에 대한 버퍼가있는 경우 버퍼링 된 데이터는 비동기 적으로 플러시됩니다. 더 이상 데이터가 수신되지 않습니다. 버퍼링 된 모든 데이터가 플러시 된 후, 프로토콜의 &lt;a href=&quot;#asyncio.BaseProtocol.connection_lost&quot;&gt; &lt;code&gt;protocol.connection_lost()&lt;/code&gt; &lt;/a&gt; 메소드가 인수 로 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f1d6afc6fe93a09cfe3361f1b4868b729dcdad9" translate="yes" xml:space="preserve">
          <source>If the two operands are unequal, return the number closest to the first operand in the direction of the second operand. If both operands are numerically equal, return a copy of the first operand with the sign set to be the same as the sign of the second operand.</source>
          <target state="translated">두 피연산자가 같지 않으면 두 번째 피연산자 방향으로 첫 번째 피연산자에 가장 가까운 숫자를 반환하십시오. 두 피연산자가 모두 숫자가 같으면 부호가 두 번째 피연산자의 부호와 동일하게 설정된 첫 번째 피연산자의 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5a546ad02eac6e07241889e84cea3b1a7f283a82" translate="yes" xml:space="preserve">
          <source>If the underlying object is writable, the memoryview supports one-dimensional slice assignment. Resizing is not allowed:</source>
          <target state="translated">기본 개체가 쓰기 가능한 경우 memoryview는 1 차원 슬라이스 할당을 지원합니다. 크기 조정은 허용되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="348a791e58f575f17b67e607cf2cfc4ed4735592" translate="yes" xml:space="preserve">
          <source>If the user would like catch errors manually, the feature can be enable by setting &lt;code&gt;exit_on_error&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;:</source>
          <target state="translated">사용자가 수동으로 오류를 포착하려는 경우 &lt;code&gt;exit_on_error&lt;/code&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정하여 기능을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1896841bb368d293e9660afd2874585397d59819" translate="yes" xml:space="preserve">
          <source>If the value &amp;ldquo;using_IDLE&amp;rdquo; in the configuration dictionary is &lt;code&gt;False&lt;/code&gt; (default value), also enter mainloop. Remark: If IDLE with the &lt;code&gt;-n&lt;/code&gt; switch (no subprocess) is used, this value should be set to &lt;code&gt;True&lt;/code&gt; in &lt;code&gt;turtle.cfg&lt;/code&gt;. In this case IDLE&amp;rsquo;s own mainloop is active also for the client script.</source>
          <target state="translated">구성 사전의&amp;ldquo;using_IDLE&amp;rdquo;값이 &lt;code&gt;False&lt;/code&gt; (기본값) 인 경우 mainloop 도 입력하십시오. 비고 다음과 IDLE 경우 &lt;code&gt;-n&lt;/code&gt; 스위치 (NO 하위 프로세스)을 사용하고,이 값을 설정해야 &lt;code&gt;True&lt;/code&gt; 으로 &lt;code&gt;turtle.cfg&lt;/code&gt; . 이 경우 IDLE의 자체 메인 루프는 클라이언트 스크립트에서도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="89e5de1d1a57cbd9a0fc9d4e4a4217ecc10e0356" translate="yes" xml:space="preserve">
          <source>If the value contains binary data, it is converted into a &lt;a href=&quot;email.header#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; object using the &lt;code&gt;unknown-8bit&lt;/code&gt; charset. Otherwise it is returned unmodified.</source>
          <target state="translated">값에 이진 데이터가 포함되어 있으면 &lt;code&gt;unknown-8bit&lt;/code&gt; 문자 집합을 사용하여 &lt;a href=&quot;email.header#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 개체 로 변환됩니다 . 그렇지 않으면 수정되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3065c24d18047dbd8738a4165aafe7e2b3d722cb" translate="yes" xml:space="preserve">
          <source>If the value contains non-ASCII characters, the charset and language may be explicitly controlled by specifying the value as a three tuple in the format &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt;, where &lt;code&gt;CHARSET&lt;/code&gt; is a string naming the charset to be used to encode the value, &lt;code&gt;LANGUAGE&lt;/code&gt; can usually be set to &lt;code&gt;None&lt;/code&gt; or the empty string (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; for other possibilities), and &lt;code&gt;VALUE&lt;/code&gt; is the string value containing non-ASCII code points. If a three tuple is not passed and the value contains non-ASCII characters, it is automatically encoded in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; format using a &lt;code&gt;CHARSET&lt;/code&gt; of &lt;code&gt;utf-8&lt;/code&gt; and a &lt;code&gt;LANGUAGE&lt;/code&gt; of &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">값에 ASCII가 아닌 문자가 포함 된 경우 &lt;code&gt;(CHARSET, LANGUAGE, VALUE)&lt;/code&gt; 형식으로 값을 3 개의 튜플로 지정하여 문자 세트 및 언어를 명시 적으로 제어 할 수 있습니다 . 여기서 &lt;code&gt;CHARSET&lt;/code&gt; 은 값은, &lt;code&gt;LANGUAGE&lt;/code&gt; 일반적으로 설정 될 수 &lt;code&gt;None&lt;/code&gt; 또는 빈 문자열 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 다른 가능성에 대한)을하고, &lt;code&gt;VALUE&lt;/code&gt; 는 비 ASCII 코드 포인트가 포함 된 문자열 값입니다. 세 튜플이 통과하고 값이 비 ASCII 문자가 포함되어 있지 않은 경우, 자동으로 인코딩 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 사용하여 형식 &lt;code&gt;CHARSET&lt;/code&gt; 의 &lt;code&gt;utf-8&lt;/code&gt; 과 &lt;code&gt;LANGUAGE&lt;/code&gt; 의를 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8fcbdf6220f66ea7da06b9cbc74f6b8c7af4352" translate="yes" xml:space="preserve">
          <source>If the value contains non-ASCII characters, the charset and language may be explicitly specified using the optional &lt;em&gt;charset&lt;/em&gt; and &lt;em&gt;language&lt;/em&gt; parameters. Optional &lt;em&gt;language&lt;/em&gt; specifies the &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; language, defaulting to the empty string. Both &lt;em&gt;charset&lt;/em&gt; and &lt;em&gt;language&lt;/em&gt; should be strings. The default is to use the &lt;code&gt;utf8&lt;/code&gt;&lt;em&gt;charset&lt;/em&gt; and &lt;code&gt;None&lt;/code&gt; for the &lt;em&gt;language&lt;/em&gt;.</source>
          <target state="translated">값에 ASCII가 아닌 문자가 포함 된 경우 선택적 &lt;em&gt;문자 집합&lt;/em&gt; 및 &lt;em&gt;언어&lt;/em&gt; 매개 변수를 사용하여 &lt;em&gt;문자 집합&lt;/em&gt; 및 &lt;em&gt;언어&lt;/em&gt; 를 명시 적으로 지정할 수 있습니다 . 선택적 &lt;em&gt;언어&lt;/em&gt; 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;&lt;em&gt; 언어를&lt;/em&gt; 지정하며 기본값은 빈 문자열입니다. 두 &lt;em&gt;캐릭터 세트&lt;/em&gt; 와 &lt;em&gt;언어는&lt;/em&gt; 문자열이어야합니다. 기본값은 사용하는 것입니다 &lt;code&gt;utf8&lt;/code&gt; &lt;em&gt;캐릭터 세트&lt;/em&gt; 및 &lt;code&gt;None&lt;/code&gt; 위한 &lt;em&gt;언어&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fd5432d4a79d323ca399133a88c268b9b6146b6f" translate="yes" xml:space="preserve">
          <source>If the value for a header in the &lt;code&gt;Message&lt;/code&gt; object originated from a &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; (as opposed to being set by a program), this attribute indicates whether or not a generator should refold that value when transforming the message back into serialized form. The possible values are:</source>
          <target state="translated">&lt;code&gt;Message&lt;/code&gt; 객체 의 헤더 값 이 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 에서 시작된 경우 (프로그램에 의해 설정되는 것이 아니라),이 속성은 메시지를 직렬화 된 형식으로 다시 변환 할 때 생성기가 해당 값을 다시 접어야하는지 여부를 나타냅니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61f619f6c6e535a52f8e51d5c113f91f23edb137" translate="yes" xml:space="preserve">
          <source>If the value has (or contains an object that has) an unsupported type, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception is raised &amp;mdash; but garbage data will also be written to the file. The object will not be properly read back by &lt;a href=&quot;#marshal.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값에 지원되지 않는 유형이 있거나 포함 된 객체가 포함 된 경우 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외가 발생하지만 가비지 데이터도 파일에 기록됩니다. &lt;a href=&quot;#marshal.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 객체를 제대로 읽지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="ac70e682ecd6b9523bcc00452173d51c8483ed90" translate="yes" xml:space="preserve">
          <source>If the value has a &lt;code&gt;name&lt;/code&gt; attribute, it is returned to unmodified. Otherwise the &lt;em&gt;name&lt;/em&gt;, and the &lt;em&gt;value&lt;/em&gt; with any CR or LF characters removed, are passed to the &lt;code&gt;header_factory&lt;/code&gt;, and the resulting header object is returned. Any surrogateescaped bytes get turned into the unicode unknown-character glyph.</source>
          <target state="translated">값에 &lt;code&gt;name&lt;/code&gt; 속성이 있으면 수정되지 않은 상태로 반환됩니다. 그렇지 않으면 &lt;em&gt;name&lt;/em&gt; 과 CR 또는 LF 문자가 제거 된 &lt;em&gt;값&lt;/em&gt; 이 &lt;code&gt;header_factory&lt;/code&gt; 로 전달되고 결과 헤더 객체가 반환됩니다. 대리 이스케이프 된 바이트는 유니 코드 알 수없는 문자 글리프로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="ecac18b5d34fc503358e09e7a4c0d8959266d301" translate="yes" xml:space="preserve">
          <source>If the wait is cancelled, the future &lt;em&gt;aw&lt;/em&gt; is also cancelled.</source>
          <target state="translated">대기가 취소되면 향후 &lt;em&gt;aw&lt;/em&gt; 도 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="56c5f97d09e31156fff54feae27ef3f4943d5433" translate="yes" xml:space="preserve">
          <source>If the watcher was previously attached to an event loop, then it is first detached before attaching to the new loop.</source>
          <target state="translated">감시자가 이전에 이벤트 루프에 연결된 경우 새 루프에 연결하기 전에 먼저 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="2bf203d12061685d40f0461125be7723191a6603" translate="yes" xml:space="preserve">
          <source>If the whole &lt;em&gt;string&lt;/em&gt; matches the regular expression &lt;em&gt;pattern&lt;/em&gt;, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">전체 &lt;em&gt;문자열이&lt;/em&gt; 정규식 &lt;em&gt;패턴 &lt;/em&gt;&lt;a href=&quot;#match-objects&quot;&gt;과 일치&lt;/a&gt; 하면 해당하는 일치 객체를 반환 합니다 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="59c52023f4547acb57c7c8cf28c845aed9e66702" translate="yes" xml:space="preserve">
          <source>If the whole &lt;em&gt;string&lt;/em&gt; matches this regular expression, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">전체 &lt;em&gt;문자열&lt;/em&gt; 이이 정규식과 일치하면 해당하는 &lt;a href=&quot;#match-objects&quot;&gt;일치 오브젝트를&lt;/a&gt; 리턴하십시오 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4d277c1615b59061e36b6cff551c4b7615a3cee8" translate="yes" xml:space="preserve">
          <source>If the wrapped coroutine is not done, this returns the stack where it is suspended. If the coroutine has completed successfully or was cancelled, this returns an empty list. If the coroutine was terminated by an exception, this returns the list of traceback frames.</source>
          <target state="translated">랩핑 된 코 루틴이 수행되지 않으면, 중단 된 스택을 리턴합니다. 코 루틴이 성공적으로 완료되었거나 취소 된 경우 빈 목록이 반환됩니다. 코 루틴이 예외로 종료 된 경우, 이는 역 추적 프레임 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="18bdf0075a155b02791d5a0bac71eb783654ca33" translate="yes" xml:space="preserve">
          <source>If the wrapped coroutine raised an exception that exception is returned. If the wrapped coroutine returned normally this method returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">랩핑 된 코 루틴에서 예외가 발생하면 해당 예외가 리턴됩니다. 랩핑 된 코 루틴이 정상적으로 반환되면이 메서드는 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f7728d4c859a24cbc45d6d58427ec4561648e7f" translate="yes" xml:space="preserve">
          <source>If there are any exceptions raised during one of the shared fixture functions the test is reported as an error. Because there is no corresponding test instance an &lt;code&gt;_ErrorHolder&lt;/code&gt; object (that has the same interface as a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt;) is created to represent the error. If you are just using the standard unittest test runner then this detail doesn&amp;rsquo;t matter, but if you are a framework author it may be relevant.</source>
          <target state="translated">공유 픽스처 기능 중 하나에서 예외가 발생하면 테스트는 오류로보고됩니다. 해당 테스트 인스턴스가 &lt;code&gt;_ErrorHolder&lt;/code&gt; 오류를 나타내는 _ErrorHolder 객체 ( &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 와 동일한 인터페이스 )가 작성됩니다. 표준 unittest 테스트 러너를 사용하는 경우이 세부 사항은 중요하지 않지만 프레임 워크 작성자 인 경우 관련이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d4834d5062c8d19bbd59417935a75681b0f714" translate="yes" xml:space="preserve">
          <source>If there are arguments:</source>
          <target state="translated">인수가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="afe713097f513403e4602cccddaf88e097fca7b5" translate="yes" xml:space="preserve">
          <source>If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string:</source>
          <target state="translated">구분 기호에 캡처 그룹이 있고 문자열 시작시 일치하면 결과는 빈 문자열로 시작합니다. 문자열 끝에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b105dd89905ca457b0617942c150ccc9ce8c2ecd" translate="yes" xml:space="preserve">
          <source>If there are keyword arguments, they will set the attributes of the same names to the given values.</source>
          <target state="translated">키워드 인수가 있으면 동일한 이름의 속성을 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="06875e271bfc97aca9aed5132911283e876fd1e3" translate="yes" xml:space="preserve">
          <source>If there are multiple modes with the same frequency, returns the first one encountered in the &lt;em&gt;data&lt;/em&gt;. If the smallest or largest of those is desired instead, use &lt;code&gt;min(multimode(data))&lt;/code&gt; or &lt;code&gt;max(multimode(data))&lt;/code&gt;. If the input &lt;em&gt;data&lt;/em&gt; is empty, &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">주파수가 동일한 여러 모드가있는 경우 &lt;em&gt;데이터&lt;/em&gt; 에서 처음 발견 된 모드를 반환합니다 . 가장 작거나 가장 큰 것을 원하는 경우 &lt;code&gt;min(multimode(data))&lt;/code&gt; 또는 &lt;code&gt;max(multimode(data))&lt;/code&gt; . 입력 &lt;em&gt;데이터&lt;/em&gt; 가 비어 있으면 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f44c76149f8456dfb2f9b8dc82d343dcb9e7029d" translate="yes" xml:space="preserve">
          <source>If there are no remaining path segments in &lt;code&gt;PATH_INFO&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">에 남아 패스 세그먼트 (segment)가없는 경우 &lt;code&gt;PATH_INFO&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70b04fc0fe654b81856797a63a15dc517bb87a72" translate="yes" xml:space="preserve">
          <source>If there are positional arguments, there must be as many as there are items in &lt;code&gt;T._fields&lt;/code&gt;; they will be assigned as attributes of these names.</source>
          <target state="translated">위치 인수가 있으면 &lt;code&gt;T._fields&lt;/code&gt; 에 항목이있는 수만큼 있어야합니다 . 이러한 이름의 속성으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0f42d2c2054cdfdb7413a7243a89893529ac2223" translate="yes" xml:space="preserve">
          <source>If there are two arguments, they must be strings of equal length, and in the resulting dictionary, each character in x will be mapped to the character at the same position in y. If there is a third argument, it must be a string, whose characters will be mapped to &lt;code&gt;None&lt;/code&gt; in the result.</source>
          <target state="translated">두 개의 인수가 있으면 길이가 같은 문자열이어야하며 결과 사전에서 x의 각 문자는 y의 동일한 위치에있는 문자에 매핑됩니다. 세 번째 인수가 있는 경우 결과에서 문자가 &lt;code&gt;None&lt;/code&gt; 에 매핑되는 문자열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="710f0541779e51ddda266bf2e4665a21cc66a9aa" translate="yes" xml:space="preserve">
          <source>If there has been no previous &lt;code&gt;EHLO&lt;/code&gt; or &lt;code&gt;HELO&lt;/code&gt; command this session, this method tries ESMTP &lt;code&gt;EHLO&lt;/code&gt; first.</source>
          <target state="translated">이 세션에 이전 &lt;code&gt;EHLO&lt;/code&gt; 또는 &lt;code&gt;HELO&lt;/code&gt; 명령이 없는 경우이 방법은 먼저 ESMTP &lt;code&gt;EHLO&lt;/code&gt; 를 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1386edd9abb7368a780ead9fa2633755d22aab5e" translate="yes" xml:space="preserve">
          <source>If there has been no previous &lt;code&gt;EHLO&lt;/code&gt; or &lt;code&gt;HELO&lt;/code&gt; command this session, this method tries ESMTP &lt;code&gt;EHLO&lt;/code&gt; first. If the server does ESMTP, message size and each of the specified options will be passed to it (if the option is in the feature set the server advertises). If &lt;code&gt;EHLO&lt;/code&gt; fails, &lt;code&gt;HELO&lt;/code&gt; will be tried and ESMTP options suppressed.</source>
          <target state="translated">이 세션에 이전 &lt;code&gt;EHLO&lt;/code&gt; 또는 &lt;code&gt;HELO&lt;/code&gt; 명령이 없는 경우이 방법은 먼저 ESMTP &lt;code&gt;EHLO&lt;/code&gt; 를 시도합니다 . 서버가 ESMTP를 수행하면 메시지 크기 및 지정된 각 옵션이 전달됩니다 (옵션이 기능 세트에있는 경우 서버가 알립니다). 경우 &lt;code&gt;EHLO&lt;/code&gt; 가 실패 &lt;code&gt;HELO&lt;/code&gt; 이 시도되고 ESMTP 옵션을 억제.</target>
        </trans-unit>
        <trans-unit id="8264923428e93189de3d9488f3d02a8d83fd11ec" translate="yes" xml:space="preserve">
          <source>If there is a character stream specified, the SAX parser will ignore any byte stream and will not attempt to open a URI connection to the system identifier.</source>
          <target state="translated">문자 스트림이 지정된 경우 SAX 파서는 바이트 스트림을 무시하고 시스템 식별자에 대한 URI 연결을 열려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7846e0ef14d60bd28e7efa81ee77d44a8c2917bd" translate="yes" xml:space="preserve">
          <source>If there is a problem with &lt;em&gt;source&lt;/em&gt;, an exception will be raised. &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; is raised if there is invalid Python syntax, and &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if there is an invalid literal.</source>
          <target state="translated">&lt;em&gt;source에&lt;/em&gt; 문제가 있으면 예외가 발생합니다. 유효하지 않은 Python 구문이 있으면 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 가 발생 하고 유효하지 않은 리터럴이 있으면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c624ff3e0c15c1748938e12da19d4755d79f2928" translate="yes" xml:space="preserve">
          <source>If there is an decoding error on the server name, the TLS connection will terminate with an &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt;&lt;/a&gt; fatal TLS alert message to the client.</source>
          <target state="translated">서버 이름에 디코딩 오류가있는 경우 클라이언트에 대한 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt; &lt;/a&gt; 치명적인 TLS 경고 메시지 와 함께 TLS 연결이 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="c08a28ed04606b4fe20cd569bde11df730c25ffd" translate="yes" xml:space="preserve">
          <source>If there is an error opening the terminal, the underlying curses library may cause the interpreter to exit.</source>
          <target state="translated">터미널을 여는 중 오류가 발생하면 기본 curses 라이브러리가 인터프리터를 종료시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20d9f9895dc923352fb368d4bf728ee9c56de965" translate="yes" xml:space="preserve">
          <source>If there is any error occurred in the trace function, it will be unset, just like &lt;code&gt;settrace(None)&lt;/code&gt; is called.</source>
          <target state="translated">추적 기능에서 오류가 발생하면 &lt;code&gt;settrace(None)&lt;/code&gt; 이 호출되는 것처럼 설정이 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="0926a91c9853e7eeca2a1fc656ef6115ed6a1bf4" translate="yes" xml:space="preserve">
          <source>If there is no certificate for the peer on the other end of the connection, return &lt;code&gt;None&lt;/code&gt;. If the SSL handshake hasn&amp;rsquo;t been done yet, raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결의 다른 쪽 끝에 피어에 대한 인증서가 없으면 &lt;code&gt;None&lt;/code&gt; 을 반환하십시오 . SSL 핸드 셰이크가 아직 완료되지 않은 경우 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를 발생&lt;/a&gt; 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="a481584adca4c60e65b9d654251ba60c649258fd" translate="yes" xml:space="preserve">
          <source>If there is no current event loop set in the current OS thread, the OS thread is main, and &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt;&lt;code&gt;set_event_loop()&lt;/code&gt;&lt;/a&gt; has not yet been called, asyncio will create a new event loop and set it as the current one.</source>
          <target state="translated">현재 OS 스레드에 현재 이벤트 루프가 설정되어 있지 않고 OS 스레드가 main이고 &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt; &lt;code&gt;set_event_loop()&lt;/code&gt; &lt;/a&gt; 가 아직 호출되지 않은 경우 asyncio는 새 이벤트 루프를 생성하고 현재 이벤트 루프로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a16e417025a92b683985a38322a1cd0d3d0859ca" translate="yes" xml:space="preserve">
          <source>If there is no existing &lt;em&gt;MIME-Version&lt;/em&gt; header one will be added. If there is no existing &lt;em&gt;Content-Type&lt;/em&gt; header, one will be added with a value of &lt;em&gt;text/plain&lt;/em&gt;. Whether the &lt;em&gt;Content-Type&lt;/em&gt; header already exists or not, its &lt;code&gt;charset&lt;/code&gt; parameter will be set to &lt;em&gt;charset.output_charset&lt;/em&gt;. If &lt;em&gt;charset.input_charset&lt;/em&gt; and &lt;em&gt;charset.output_charset&lt;/em&gt; differ, the payload will be re-encoded to the &lt;em&gt;output_charset&lt;/em&gt;. If there is no existing &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header, then the payload will be transfer-encoded, if needed, using the specified &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt;, and a header with the appropriate value will be added. If a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header already exists, the payload is assumed to already be correctly encoded using that &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; and is not modified.</source>
          <target state="translated">기존 &lt;em&gt;MIME 버전&lt;/em&gt; 헤더 가없는 경우 헤더가 추가됩니다. 기존 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 가 없으면 &lt;em&gt;text / plain&lt;/em&gt; 값으로 추가됩니다 . &lt;em&gt;Content-Type&lt;/em&gt; 헤더의 존재 여부에 관계없이 해당 &lt;code&gt;charset&lt;/code&gt; 매개 변수는 &lt;em&gt;charset.output_charset&lt;/em&gt; 로 설정됩니다 . 경우 &lt;em&gt;charset.input_charset&lt;/em&gt; 및 &lt;em&gt;charset.output_charset가&lt;/em&gt; 다를 상기 페이로드로 재 인코딩 될 것이다 &lt;em&gt;output_charset&lt;/em&gt; . 기존 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더 가없는 경우 페이로드는 필요한 경우 지정된 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; 을&lt;/a&gt; 사용하여 전송 인코딩됩니다.적절한 값을 가진 헤더가 추가됩니다. 경우 &lt;em&gt;콘텐츠 전송 인코딩&lt;/em&gt; 헤더가 이미 존재, 페이로드는 사용하여 이미 제대로 인코딩 된 것으로 간주됩니다 &lt;em&gt;콘텐츠 전송 인코딩을&lt;/em&gt; 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="668457ccf6ecd6f3a813b38d49f7b92435618884" translate="yes" xml:space="preserve">
          <source>If there is no running event loop a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised. This function can only be called from a coroutine or a callback.</source>
          <target state="translated">실행중인 이벤트 루프가 없으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 이 함수는 코 루틴이나 콜백에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69cac254e6b298fe4270f509ae2413d5927fd1a9" translate="yes" xml:space="preserve">
          <source>If there is no value for the variable in the current context, the method will:</source>
          <target state="translated">현재 컨텍스트에 변수 값이 없으면 메소드는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="80c2dc75a994416645ae1c9380a6d0ceb3f65147" translate="yes" xml:space="preserve">
          <source>If there is only one argument, it must be a dictionary mapping Unicode ordinals (integers) or characters (strings of length 1) to Unicode ordinals, strings (of arbitrary lengths) or &lt;code&gt;None&lt;/code&gt;. Character keys will then be converted to ordinals.</source>
          <target state="translated">인수가 하나만있는 경우 유니 코드 서수 (정수) 또는 문자 (길이 1의 문자열)를 유니 코드 서수, 문자열 (임의의 길이) 또는 &lt;code&gt;None&lt;/code&gt; 에 매핑하는 사전이어야합니다 . 문자 키는 서수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b89ec1a8424896e51072da33f9efe49e974e577" translate="yes" xml:space="preserve">
          <source>If there is only one possible completion for the characters entered, a</source>
          <target state="translated">입력 한 문자에 대해 하나의 가능한 완성 만 있으면</target>
        </trans-unit>
        <trans-unit id="8b2610dd6d4564147cdc6a071edbeae596a215ec" translate="yes" xml:space="preserve">
          <source>If these attributes are marked as optional in the grammar (using a question mark), the value might be &lt;code&gt;None&lt;/code&gt;. If the attributes can have zero-or-more values (marked with an asterisk), the values are represented as Python lists. All possible attributes must be present and have valid values when compiling an AST with &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문법에서 이러한 속성이 선택 사항으로 표시되면 (물음표 사용) 값은 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 속성이 별표로 표시된 0 개 이상의 값을 가질 수있는 경우 값은 Python 목록으로 표시됩니다. &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; AST를 컴파일 할 때 가능한 모든 속성이 존재하고 유효한 값을 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="4cc8f6301859f9ffe9df6772bfd5316c956f6429" translate="yes" xml:space="preserve">
          <source>If this attribute evaluates to true, events logged to this logger will be passed to the handlers of higher level (ancestor) loggers, in addition to any handlers attached to this logger. Messages are passed directly to the ancestor loggers&amp;rsquo; handlers - neither the level nor filters of the ancestor loggers in question are considered.</source>
          <target state="translated">이 속성이 true로 평가되면이 로거에 기록 된 이벤트는이 로거에 첨부 된 핸들러와 함께 상위 레벨 (로스터) 로거의 핸들러로 전달됩니다. 메시지는 조상 로거의 처리기로 직접 전달됩니다. 해당 조상 로거의 수준이나 필터는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="abdb9590d870789abfb1d2c6cd1c630b5f260a6c" translate="yes" xml:space="preserve">
          <source>If this attribute is accessed before the end of the stream has been reached, its value will be &lt;code&gt;b''&lt;/code&gt;.</source>
          <target state="translated">스트림의 끝에 도달하기 전에이 속성에 액세스하면 해당 값은 &lt;code&gt;b''&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57abef9824fea6e680f0e895e49db397a22940bc" translate="yes" xml:space="preserve">
          <source>If this attribute is not &lt;code&gt;None&lt;/code&gt; (the default), all test methods to be included in test suites must match one of the patterns in this list. Note that matches are always performed using &lt;a href=&quot;fnmatch#fnmatch.fnmatchcase&quot;&gt;&lt;code&gt;fnmatch.fnmatchcase()&lt;/code&gt;&lt;/a&gt;, so unlike patterns passed to the &lt;code&gt;-v&lt;/code&gt; option, simple substring patterns will have to be converted using &lt;code&gt;*&lt;/code&gt; wildcards.</source>
          <target state="translated">이 속성이 &lt;code&gt;None&lt;/code&gt; (기본값) 이 아닌 경우 테스트 스위트에 포함 할 모든 테스트 메소드는이 목록의 패턴 중 하나와 일치해야합니다. 일치는 항상 &lt;a href=&quot;fnmatch#fnmatch.fnmatchcase&quot;&gt; &lt;code&gt;fnmatch.fnmatchcase()&lt;/code&gt; &lt;/a&gt; 사용하여 수행 되므로 &lt;code&gt;-v&lt;/code&gt; 옵션에 전달 된 패턴과 달리 간단한 하위 문자열 패턴은 &lt;code&gt;*&lt;/code&gt; 와일드 카드를 사용하여 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0e0a95050375345febb5eec5f5dd1307acaa7573" translate="yes" xml:space="preserve">
          <source>If this attribute is numeric and &lt;code&gt;1&lt;/code&gt; or more, a &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; instance will print verbose progress output on its behavior. If you need to use this, you can read the module source code to learn the details.</source>
          <target state="translated">이 속성이 숫자이고 &lt;code&gt;1&lt;/code&gt; 이상인 경우 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 인스턴스는 동작에 대한 자세한 진행률 출력을 인쇄합니다. 이것을 사용해야 할 경우, 세부 사항을 배우기 위해 모듈 소스 코드를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b804a91b5f1f64f8e7129df9975fc4040a040277" translate="yes" xml:space="preserve">
          <source>If this attribute is set to a callable, the &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/a&gt; method delegates to this callable. The parameters passed to the callable are those passed to &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성이 호출 가능으로 설정된 경우 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt; &lt;code&gt;rotate()&lt;/code&gt; &lt;/a&gt; 메소드는이 호출 가능에 위임합니다. 콜 러블에 전달 된 매개 변수는 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotate&quot;&gt; &lt;code&gt;rotate()&lt;/code&gt; &lt;/a&gt; 전달 된 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="7ebbb6f8f84980f280f393669d0bd62b9cd2bef9" translate="yes" xml:space="preserve">
          <source>If this attribute is set to a callable, the &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt;&lt;code&gt;rotation_filename()&lt;/code&gt;&lt;/a&gt; method delegates to this callable. The parameters passed to the callable are those passed to &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt;&lt;code&gt;rotation_filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성이 호출 가능으로 설정된 경우 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt; &lt;code&gt;rotation_filename()&lt;/code&gt; &lt;/a&gt; 메서드는이 호출 가능에 위임합니다. 콜 러블에 전달 된 매개 변수는 &lt;a href=&quot;#logging.handlers.BaseRotatingHandler.rotation_filename&quot;&gt; &lt;code&gt;rotation_filename()&lt;/code&gt; &lt;/a&gt; 전달 된 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="dff1b29a4811ae4a2758c854c0086cdf364b91aa" translate="yes" xml:space="preserve">
          <source>If this bit is set, then random bytes are drawn from the &lt;code&gt;/dev/random&lt;/code&gt; pool instead of the &lt;code&gt;/dev/urandom&lt;/code&gt; pool.</source>
          <target state="translated">이 비트가 설정되면 &lt;code&gt;/dev/urandom&lt;/code&gt; 풀 대신 &lt;code&gt;/dev/random&lt;/code&gt; 풀 에서 임의 바이트가 그려집니다 .</target>
        </trans-unit>
        <trans-unit id="90bb6faa5b3834263ad7c4573939b37c5a542a65" translate="yes" xml:space="preserve">
          <source>If this evaluates to false, logging messages are not passed to the handlers of ancestor loggers.</source>
          <target state="translated">이것이 거짓으로 평가되면, 로깅 메시지는 상위 로거의 핸들러로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="017d3d68f19210726c382bec27e52a2d417c3981" translate="yes" xml:space="preserve">
          <source>If this function raises an exception, &lt;a href=&quot;sys#sys.excepthook&quot;&gt;&lt;code&gt;sys.excepthook()&lt;/code&gt;&lt;/a&gt; is called to handle it.</source>
          <target state="translated">이 함수에서 예외가 발생하면이 를 처리하기 위해 &lt;a href=&quot;sys#sys.excepthook&quot;&gt; &lt;code&gt;sys.excepthook()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="58d8a99c356472fc70700f6ecb9c84865af60bb2" translate="yes" xml:space="preserve">
          <source>If this gives an error of type 404, the server cannot find the script &amp;ndash; perhaps you need to install it in a different directory. If it gives another error, there&amp;rsquo;s an installation problem that you should fix before trying to go any further. If you get a nicely formatted listing of the environment and form content (in this example, the fields should be listed as &amp;ldquo;addr&amp;rdquo; with value &amp;ldquo;At Home&amp;rdquo; and &amp;ldquo;name&amp;rdquo; with value &amp;ldquo;Joe Blow&amp;rdquo;), the &lt;code&gt;cgi.py&lt;/code&gt; script has been installed correctly. If you follow the same procedure for your own script, you should now be able to debug it.</source>
          <target state="translated">404 유형의 오류가 발생하면 서버가 스크립트를 찾을 수 없습니다. 다른 디렉토리에 스크립트를 설치해야합니다. 다른 오류가 발생하면 더 이상 진행하기 전에 수정해야하는 설치 문제가 있습니다. &lt;code&gt;cgi.py&lt;/code&gt; 스크립트 는 환경과 양식 컨텐츠의 형식이 잘 지정된 목록 (이 예제에서 &quot;At Home&quot;및 &quot;name&quot;, &quot;Joe Blow&quot;값을 갖는 &quot;addr&quot;)으로 나열되어야합니다. 올바르게 설치되었습니다. 자신의 스크립트에 대해 동일한 절차를 따르면 이제 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f7b6501e5b158a220ae98c2d595a7087ee640a" translate="yes" xml:space="preserve">
          <source>If this handler is not provided, external entities are reported by the &lt;a href=&quot;#xml.parsers.expat.xmlparser.DefaultHandler&quot;&gt;&lt;code&gt;DefaultHandler&lt;/code&gt;&lt;/a&gt; callback, if provided.</source>
          <target state="translated">이 핸들러가 제공되지 않으면 외부 엔티티가 제공되는 경우 &lt;a href=&quot;#xml.parsers.expat.xmlparser.DefaultHandler&quot;&gt; &lt;code&gt;DefaultHandler&lt;/code&gt; &lt;/a&gt; 콜백에 의해보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="85450d770d6418bc4deec157d80a4e51aa30db87" translate="yes" xml:space="preserve">
          <source>If this heap invariant is protected at all time, index 0 is clearly the overall winner. The simplest algorithmic way to remove it and find the &amp;ldquo;next&amp;rdquo; winner is to move some loser (let&amp;rsquo;s say cell 30 in the diagram above) into the 0 position, and then percolate this new 0 down the tree, exchanging values, until the invariant is re-established. This is clearly logarithmic on the total number of items in the tree. By iterating over all items, you get an O(n log n) sort.</source>
          <target state="translated">이 힙 불변 값이 항상 보호되는 경우 인덱스 0은 분명히 전체 승자입니다. 그것을 제거하고 &quot;다음&quot;우승자를 찾는 가장 간단한 알고리즘 방법은 패자를 (위의 다이어그램에서 30 번 셀이라고합시다) 0 위치로 옮기고 불변 할 때까지 값을 교환하면서이 새로운 0을 트리 아래로 퍼뜨리는 것입니다. 다시 설립되었습니다. 이것은 트리의 총 항목 수에 대해 분명히 대수입니다. 모든 항목을 반복하면 O (n log n) 정렬이됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3e8042246e5ac5ba9685632876ea8a3d42c4e7" translate="yes" xml:space="preserve">
          <source>If this is set (not &lt;code&gt;None&lt;/code&gt;), Python will write bytecode-cache &lt;code&gt;.pyc&lt;/code&gt; files to (and read them from) a parallel directory tree rooted at this directory, rather than from &lt;code&gt;__pycache__&lt;/code&gt; directories in the source code tree. Any &lt;code&gt;__pycache__&lt;/code&gt; directories in the source code tree will be ignored and new &lt;code&gt;.pyc&lt;/code&gt; files written within the pycache prefix. Thus if you use &lt;a href=&quot;compileall#module-compileall&quot;&gt;&lt;code&gt;compileall&lt;/code&gt;&lt;/a&gt; as a pre-build step, you must ensure you run it with the same pycache prefix (if any) that you will use at runtime.</source>
          <target state="translated">이것이 설정되어 있지 않으면 ( &lt;code&gt;None&lt;/code&gt; 아님), 파이썬은 소스 코드 트리의 &lt;code&gt;__pycache__&lt;/code&gt; 디렉토리가 아닌이 디렉토리에 뿌리를 둔 병렬 디렉토리 트리에 bytecode-cache &lt;code&gt;.pyc&lt;/code&gt; 파일을 쓰고 읽습니다 . 소스 코드 트리의 모든 &lt;code&gt;__pycache__&lt;/code&gt; 디렉토리는 무시되고 pycache 접두사 안에 새 &lt;code&gt;.pyc&lt;/code&gt; 파일이 작성됩니다. 따라서 &lt;a href=&quot;compileall#module-compileall&quot;&gt; &lt;code&gt;compileall&lt;/code&gt; &lt;/a&gt; 을 사전 빌드 단계로 사용하는 경우 런타임시 사용할 동일한 pycache 접두어 (있는 경우)로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b26511950bcfbe88174f69e9200e69454a2056a" translate="yes" xml:space="preserve">
          <source>If this is true, Python won&amp;rsquo;t try to write &lt;code&gt;.pyc&lt;/code&gt; files on the import of source modules. This value is initially set to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; depending on the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id1&quot;&gt;&lt;code&gt;-B&lt;/code&gt;&lt;/a&gt; command line option and the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;PYTHONDONTWRITEBYTECODE&lt;/code&gt;&lt;/a&gt; environment variable, but you can set it yourself to control bytecode file generation.</source>
          <target state="translated">이것이 사실이라면, 파이썬은 소스 모듈을 가져올 때 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 쓰려고하지 않습니다 . 이 값은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id1&quot;&gt; &lt;code&gt;-B&lt;/code&gt; &lt;/a&gt; 명령 행 옵션 및 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;PYTHONDONTWRITEBYTECODE&lt;/code&gt; &lt;/a&gt; 환경 변수 에 따라 초기에 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 로 설정되지만 바이트 코드 파일 생성을 제어하도록 직접 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bd48090fe0de6b291f7c4b9445251f4d4d19a92" translate="yes" xml:space="preserve">
          <source>If this is true, Python won&amp;rsquo;t try to write &lt;code&gt;.pyc&lt;/code&gt; files on the import of source modules. This value is initially set to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; depending on the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id1&quot;&gt;&lt;code&gt;-B&lt;/code&gt;&lt;/a&gt; command line option and the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE&quot; id=&quot;index-6&quot;&gt;&lt;code&gt;PYTHONDONTWRITEBYTECODE&lt;/code&gt;&lt;/a&gt; environment variable, but you can set it yourself to control bytecode file generation.</source>
          <target state="translated">이것이 사실이라면, 파이썬은 소스 모듈을 가져올 때 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 쓰려고하지 않을 것 입니다. 이 값은 처음 에 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id1&quot;&gt; &lt;code&gt;-B&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션 및 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE&quot; id=&quot;index-6&quot;&gt; &lt;code&gt;PYTHONDONTWRITEBYTECODE&lt;/code&gt; &lt;/a&gt; 환경 변수 에 따라 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 로 설정되지만 바이트 코드 파일 생성을 제어하도록 직접 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0dd1aeea5c5afb047695d1317c4d638f1f777fa" translate="yes" xml:space="preserve">
          <source>If this keyword argument is specified along with &lt;em&gt;filename&lt;/em&gt;, its value is used when the FileHandler is created, and thus used when opening the output file.</source>
          <target state="translated">이 키워드 인수를 &lt;em&gt;filename&lt;/em&gt; 과 함께 지정 하면 FileHandler 생성시 해당 값이 사용되므로 출력 파일을 열 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27123f72ebcf16d16ff750ae37510194e2bb8114" translate="yes" xml:space="preserve">
          <source>If this keyword argument is specified along with &lt;em&gt;filename&lt;/em&gt;, its value is used when the FileHandler is created, and thus used when opening the output file. If not specified, the value &amp;lsquo;backslashreplace&amp;rsquo; is used. Note that if &lt;code&gt;None&lt;/code&gt; is specified, it will be passed as such to func:&lt;code&gt;open&lt;/code&gt;, which means that it will be treated the same as passing &amp;lsquo;errors&amp;rsquo;.</source>
          <target state="translated">이 키워드 인수를 &lt;em&gt;filename&lt;/em&gt; 과 함께 지정 하면 FileHandler 생성시 해당 값이 사용되므로 출력 파일을 열 때 사용됩니다. 지정하지 않으면 'backslashreplace'값이 사용됩니다. 경우 유의 &lt;code&gt;None&lt;/code&gt; 지정되어 있지 않은, 그것은 그러한 FUNC로 전달한다 : &lt;code&gt;open&lt;/code&gt; , 그것은 '에러'를 전달하는 것과 동일하게 처리 될 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="3314650337b2349372ab978feed37d7432cf9791" translate="yes" xml:space="preserve">
          <source>If this keyword argument is specified as true, any existing handlers attached to the root logger are removed and closed, before carrying out the configuration as specified by the other arguments.</source>
          <target state="translated">이 키워드 인수가 true로 지정된 경우, 다른 인수로 지정된 구성을 수행하기 전에 루트 로거에 연결된 기존 핸들러가 제거되고 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="11e62c76d42fa37b48327413f77512cf4b5df592" translate="yes" xml:space="preserve">
          <source>If this method is used when the associated process is using a pipe or queue then the pipe or queue is liable to become corrupted and may become unusable by other process. Similarly, if the process has acquired a lock or semaphore etc. then terminating it is liable to cause other processes to deadlock.</source>
          <target state="translated">연관된 프로세스가 파이프 또는 큐를 사용할 때이 방법을 사용하면 파이프 또는 큐가 손상되어 다른 프로세스에서 사용하지 못하게 될 수 있습니다. 마찬가지로 프로세스가 잠금 또는 세마포어 등을 획득 한 경우 종료하면 다른 프로세스가 교착 상태에 빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40b84b7c2b8cd75da3b54cede5c5b30cfe17179e" translate="yes" xml:space="preserve">
          <source>If true, load cookies lazily from disk. This attribute should not be assigned to. This is only a hint, since this only affects performance, not behaviour (unless the cookies on disk are changing). A &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; object may ignore it. None of the &lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt;&lt;code&gt;FileCookieJar&lt;/code&gt;&lt;/a&gt; classes included in the standard library lazily loads cookies.</source>
          <target state="translated">참이면 디스크에서 쿠키를 느리게로드하십시오. 이 속성은 할당하지 않아야합니다. 이것은 힌트 일뿐입니다 (디스크의 쿠키가 변경되지 않는 한), 동작에만 영향을 미치지 않기 때문입니다. &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; 의&lt;/a&gt; 객체는 그것을 무시할 수 있습니다. 의 없음 &lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt; &lt;code&gt;FileCookieJar&lt;/code&gt; 의&lt;/a&gt; 표준 라이브러리 느리게로드 쿠키에 포함 된 클래스.</target>
        </trans-unit>
        <trans-unit id="4b776e3e6964e37b47588161e44e80da43328cd0" translate="yes" xml:space="preserve">
          <source>If true, request that the &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; instance downgrade &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; cookies (ie. cookies received in a &lt;em&gt;Set-Cookie&lt;/em&gt; header with a version cookie-attribute of 1) to Netscape cookies by setting the version attribute of the &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; instance to 0. The default value is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, in which case RFC 2109 cookies are downgraded if and only if &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; handling is turned off. Therefore, RFC 2109 cookies are downgraded by default.</source>
          <target state="translated">만약 사실, 요청 &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; 의&lt;/a&gt; 인스턴스 다운 그레이드 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;RFC 2109 개&lt;/strong&gt;&lt;/a&gt; 쿠키 (예. 쿠키는 수신 &lt;em&gt;설정 - 쿠키&lt;/em&gt; 의 버전 속성을 설정하여 넷스케이프 쿠키 1의 버전 쿠키 속성 헤더) &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 0 기본 값으로 인스턴스를 는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이며,이 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 처리가 해제 된 경우에만 RFC 2109 쿠키가 다운 그레이드됩니다 . 따라서 RFC 2109 쿠키는 기본적으로 다운 그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="ae1121f9e45a9703c97a6bf40a561f0b607ea007" translate="yes" xml:space="preserve">
          <source>If turtleshape is a polygon, outline and interior of that polygon is drawn with the newly set colors.</source>
          <target state="translated">turtleshape가 다각형 인 경우 해당 다각형의 외곽선과 내부가 새로 설정된 색상으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="6b992dbf815e5a48ca08b90300fa3a4771a7068e" translate="yes" xml:space="preserve">
          <source>If turtleshape is a polygon, the interior of that polygon is drawn with the newly set fillcolor.</source>
          <target state="translated">turtleshape가 다각형 인 경우 해당 다각형의 내부는 새로 설정된 채우기 색상으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="be2827a5012b6740877e0b7b0e62c1a742812bf7" translate="yes" xml:space="preserve">
          <source>If turtleshape is a polygon, the outline of that polygon is drawn with the newly set pencolor.</source>
          <target state="translated">turtleshape가 다각형 인 경우 해당 다각형의 외곽선은 새로 설정된 펜 색상으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="0c29d653e6b038e2fe7684142d34103dcd03b42e" translate="yes" xml:space="preserve">
          <source>If two &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;Row&lt;/code&gt;&lt;/a&gt; objects have exactly the same columns and their members are equal, they compare equal.</source>
          <target state="translated">두 개의 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;Row&lt;/code&gt; &lt;/a&gt; 객체가 정확히 동일한 열을 가지고 있고 해당 멤버가 같으면 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="afa6f3422eefaa81266da99523269e7f496b8eab" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;.pyc&lt;/code&gt; files with different optimization level have the same content, use hard links to consolidate duplicate files.</source>
          <target state="translated">최적화 수준이 다른 두 &lt;code&gt;.pyc&lt;/code&gt; 파일의 내용이 동일한 경우 하드 링크를 사용하여 중복 파일을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="260d0a1b06a2d521034b375df46c28e25cc4e075" translate="yes" xml:space="preserve">
          <source>If used, this function should be called before &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; or newterm are called. When &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the values of lines and columns specified in the terminfo database will be used, even if environment variables &lt;code id=&quot;index-5&quot;&gt;LINES&lt;/code&gt; and &lt;code id=&quot;index-6&quot;&gt;COLUMNS&lt;/code&gt; (used by default) are set, or if curses is running in a window (in which case default behavior would be to use the window size if &lt;code id=&quot;index-7&quot;&gt;LINES&lt;/code&gt; and &lt;code id=&quot;index-8&quot;&gt;COLUMNS&lt;/code&gt; are not set).</source>
          <target state="translated">사용되는 경우,이 함수는 &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 또는 newterm이 호출 되기 전에 호출되어야합니다 . 때 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 선과 terminfo 데이터베이스에서 지정된 열의 값은 환경 변수의 경우에도 사용됩니다 &lt;code id=&quot;index-5&quot;&gt;LINES&lt;/code&gt; 과 &lt;code id=&quot;index-6&quot;&gt;COLUMNS&lt;/code&gt; (이 경우 기본 동작 것이다 (기본적으로 사용)을 설정, 또는 저주 경우 윈도우에서 실행 &lt;code id=&quot;index-7&quot;&gt;LINES&lt;/code&gt; 및 &lt;code id=&quot;index-8&quot;&gt;COLUMNS&lt;/code&gt; 가 설정되지 않은 경우 창 크기를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b09a2a72ca9eebcfaf2f7a111fffa10693a0be54" translate="yes" xml:space="preserve">
          <source>If using this module as part of a multi-processed application (using, for example the &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;concurrent.futures#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; modules), be aware that OpenSSL&amp;rsquo;s internal random number generator does not properly handle forked processes. Applications must change the PRNG state of the parent process if they use any SSL feature with &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt;. Any successful call of &lt;a href=&quot;#ssl.RAND_add&quot;&gt;&lt;code&gt;RAND_add()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.RAND_bytes&quot;&gt;&lt;code&gt;RAND_bytes()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.RAND_pseudo_bytes&quot;&gt;&lt;code&gt;RAND_pseudo_bytes()&lt;/code&gt;&lt;/a&gt; is sufficient.</source>
          <target state="translated">다중 처리 응용 프로그램의 일부로이 모듈을 사용하는 경우 (예 : &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;concurrent.futures#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt; 모듈 사용) OpenSSL의 내부 난수 생성기가 분기 프로세스를 제대로 처리하지 못합니다. 애플리케이션이 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt; 와 함께 SSL 기능을 사용하는 경우 상위 프로세스의 PRNG 상태를 변경해야합니다 . &lt;a href=&quot;#ssl.RAND_add&quot;&gt; &lt;code&gt;RAND_add()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.RAND_bytes&quot;&gt; &lt;code&gt;RAND_bytes()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.RAND_pseudo_bytes&quot;&gt; &lt;code&gt;RAND_pseudo_bytes()&lt;/code&gt; &lt;/a&gt; 호출 이 충분합니다.</target>
        </trans-unit>
        <trans-unit id="40cadaadf40f8d88630127c112a5dbe1fa546685" translate="yes" xml:space="preserve">
          <source>If we make the decimal place and everything after it optional, not all groups might participate in the match. These groups will default to &lt;code&gt;None&lt;/code&gt; unless the &lt;em&gt;default&lt;/em&gt; argument is given:</source>
          <target state="translated">소수점 이하 자릿수와 그 이후의 모든 항목을 선택 사항으로 지정하면 모든 그룹이 일치하는 것은 아닙니다. &lt;em&gt;기본&lt;/em&gt; 인수가 제공 되지 않으면 이러한 그룹은 기본적으로 &lt;code&gt;None&lt;/code&gt; 으로 설정됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21252e699b38c9bde015d527adf98063ea9f956c" translate="yes" xml:space="preserve">
          <source>If we were sent the message from the last example, here is one way we could process it:</source>
          <target state="translated">마지막 예에서 메시지를 보냈다면 다음과 같이 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6bfdd750da38ffcee31dea60ae619912d24791e2" translate="yes" xml:space="preserve">
          <source>If window is currently managed by the notebook but hidden, it is restored to its previous position.</source>
          <target state="translated">노트북이 현재 창을 관리하지만 숨겨져있는 경우 창은 이전 위치로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="aec5c8d5afc40ab554ad46b385c383363932d7b7" translate="yes" xml:space="preserve">
          <source>If wrapping a shared library with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;, it &lt;em&gt;may&lt;/em&gt; be better to determine the shared library name at development time, and hardcode that into the wrapper module instead of using &lt;code&gt;find_library()&lt;/code&gt; to locate the library at runtime.</source>
          <target state="translated">와 공유 라이브러리 포장하면 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; ,이 &lt;em&gt;수&lt;/em&gt; 대신 사용하는 래퍼 모듈에 공유 라이브러리 개발시 이름 및 하드 코드를 결정하는 것이 더 &lt;code&gt;find_library()&lt;/code&gt; 런타임 라이브러리를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f6e263b3d734f898bddb0b90497009b949e688c7" translate="yes" xml:space="preserve">
          <source>If you (or your students) want to use &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; with online help in your native language, you have to translate the docstrings and save the resulting file as e.g. &lt;code&gt;turtle_docstringdict_german.py&lt;/code&gt;.</source>
          <target state="translated">귀하 (또는 학생)가 모국어로 온라인 도움말을 통해 &lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 을 사용 하려면 문서 문자열을 번역하고 결과 파일을 다음과 같이 저장해야합니다 . &lt;code&gt;turtle_docstringdict_german.py&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="681001f9dedd39553c496bc8278d37c4dfe3445e" translate="yes" xml:space="preserve">
          <source>If you access a method (a function defined in a class namespace) through an instance, you get a special object: a &lt;em&gt;bound method&lt;/em&gt; (also called &lt;em&gt;instance method&lt;/em&gt;) object. When called, it will add the &lt;code&gt;self&lt;/code&gt; argument to the argument list. Bound methods have two special read-only attributes: &lt;code&gt;m.__self__&lt;/code&gt; is the object on which the method operates, and &lt;code&gt;m.__func__&lt;/code&gt; is the function implementing the method. Calling &lt;code&gt;m(arg-1, arg-2, ..., arg-n)&lt;/code&gt; is completely equivalent to calling &lt;code&gt;m.__func__(m.__self__, arg-1, arg-2, ...,
arg-n)&lt;/code&gt;.</source>
          <target state="translated">인스턴스를 통해 메서드 (클래스 네임 스페이스에 정의 된 함수)에 액세스하면 &lt;em&gt;바인딩 된 메서드&lt;/em&gt; ( &lt;em&gt;인스턴스 메서드&lt;/em&gt; 라고도 함 ) 개체 라는 특수한 개체가 생성됩니다. 호출되면 &lt;code&gt;self&lt;/code&gt; 인수를 인수 목록에 추가 합니다. 바운드 메소드에는 두 가지 특수 읽기 전용 속성이 있습니다. &lt;code&gt;m.__self__&lt;/code&gt; 는 메소드가 작동하는 오브젝트이고 &lt;code&gt;m.__func__&lt;/code&gt; 는 메소드를 구현하는 함수입니다. 호출 &lt;code&gt;m(arg-1, arg-2, ..., arg-n)&lt;/code&gt; 호출 완전히 동등 &lt;code&gt;m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a1f07de56da7ccfad9978d85c56532e9c3232e2" translate="yes" xml:space="preserve">
          <source>If you are dynamically importing a module that was created since the interpreter began execution (e.g., created a Python source file), you may need to call &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt;&lt;code&gt;invalidate_caches()&lt;/code&gt;&lt;/a&gt; in order for the new module to be noticed by the import system.</source>
          <target state="translated">인터프리터가 실행을 시작한 이후 생성 된 모듈 (예 : Python 소스 파일 생성)을 동적으로 가져 오는 경우 가져 오기 시스템에서 새 모듈을 알 수 있도록 &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt; &lt;code&gt;invalidate_caches()&lt;/code&gt; &lt;/a&gt; 를 호출해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4f0de1719448ed4a63c40279ef044d3f941a85" translate="yes" xml:space="preserve">
          <source>If you are going to create a server that provides SSL-encrypted connection services, you will need to acquire a certificate for that service. There are many ways of acquiring appropriate certificates, such as buying one from a certification authority. Another common practice is to generate a self-signed certificate. The simplest way to do this is with the OpenSSL package, using something like the following:</source>
          <target state="translated">SSL 암호화 연결 서비스를 제공하는 서버를 만들려면 해당 서비스에 대한 인증서를 얻어야합니다. 인증 기관에서 인증서를 구입하는 등 적절한 인증서를 얻는 방법에는 여러 가지가 있습니다. 다른 일반적인 방법은 자체 서명 된 인증서를 생성하는 것입니다. 이를 수행하는 가장 간단한 방법은 다음과 같은 방법을 사용하여 OpenSSL 패키지를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="48d6cd7b9afb257bc9891717d33d65b967870ac6" translate="yes" xml:space="preserve">
          <source>If you are going to require validation of the other side of the connection&amp;rsquo;s certificate, you need to provide a &amp;ldquo;CA certs&amp;rdquo; file, filled with the certificate chains for each issuer you are willing to trust. Again, this file just contains these chains concatenated together. For validation, Python will use the first chain it finds in the file which matches. The platform&amp;rsquo;s certificates file can be used by calling &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt;, this is done automatically with &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결 인증서의 다른쪽에 대한 유효성 검사가 필요한 경우 신뢰할 수있는 각 발급자에 대한 인증서 체인으로 채워진 &quot;CA 인증서&quot;파일을 제공해야합니다. 다시,이 파일에는이 체인들이 함께 연결되어 있습니다. 유효성 검사를 위해 Python은 파일에서 일치하는 첫 번째 체인을 사용합니다. 플랫폼의 인증서 파일은 &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 를 호출하여 사용할 수 있으며 &lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 하여 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f73a6f10ffa7b443163f14e92196bc1fc4490c7" translate="yes" xml:space="preserve">
          <source>If you are implementing a CGI-based handler of your own, you probably want to use this routine instead of just copying values out of &lt;code&gt;os.environ&lt;/code&gt; directly.</source>
          <target state="translated">CGI 기반 핸들러를 직접 구현하는 경우 &lt;code&gt;os.environ&lt;/code&gt; 에서 직접 값을 복사하는 대신이 루틴을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="7b970e3329e89a382ded0086b19b66d215dd892f" translate="yes" xml:space="preserve">
          <source>If you are implementing asynchronous signal handlers using the &lt;a href=&quot;signal#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module, you may not be able to use logging from within such handlers. This is because lock implementations in the &lt;a href=&quot;threading#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; module are not always re-entrant, and so cannot be invoked from such signal handlers.</source>
          <target state="translated">&lt;a href=&quot;signal#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 비동기 신호 핸들러를 구현하는 경우 해당 핸들러 내에서 로깅을 사용하지 못할 수 있습니다. &lt;a href=&quot;threading#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈의 잠금 구현 이 항상 재진입되는 것은 아니므로 이러한 신호 처리기에서 호출 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4f3cb106b921f87d2d40c7d80ff67464e95e3f8e" translate="yes" xml:space="preserve">
          <source>If you are localizing your application, you can install the &lt;code&gt;_()&lt;/code&gt; function globally into the built-in namespace, usually in the main driver file of your application. This will let all your application-specific files just use &lt;code&gt;_('...')&lt;/code&gt; without having to explicitly install it in each file.</source>
          <target state="translated">응용 프로그램을 지역화하는 경우 일반적으로 응용 프로그램의 기본 드라이버 파일에서 기본 제공 네임 스페이스에 &lt;code&gt;_()&lt;/code&gt; 함수를 설치할 수 있습니다 . 이렇게하면 모든 응용 프로그램 별 파일 이 각 파일에 명시 적으로 설치하지 않고도 &lt;code&gt;_('...')&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5e00d28ce108672fa04f99996f53e40842cac4" translate="yes" xml:space="preserve">
          <source>If you are localizing your module, you must take care not to make global changes, e.g. to the built-in namespace. You should not use the GNU &lt;strong&gt;gettext&lt;/strong&gt; API but instead the class-based API.</source>
          <target state="translated">모듈을 지역화하는 경우 내장 네임 스페이스와 같이 전역 적으로 변경되지 않도록주의해야합니다. GNU &lt;strong&gt;gettext&lt;/strong&gt; API 대신 클래스 기반 API를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="11373b731524ebbb3396ed6f424ed35b172c4f94" translate="yes" xml:space="preserve">
          <source>If you are running an entropy-gathering daemon (EGD) somewhere, and &lt;em&gt;path&lt;/em&gt; is the pathname of a socket connection open to it, this will read 256 bytes of randomness from the socket, and add it to the SSL pseudo-random number generator to increase the security of generated secret keys. This is typically only necessary on systems without better sources of randomness.</source>
          <target state="translated">엔트로피 수집 데몬 (EGD)을 어딘가에서 실행 중이고 &lt;em&gt;경로&lt;/em&gt; 가 열려있는 소켓 연결의 경로 이름 인 경우 소켓에서 256 바이트의 임의성을 읽고 SSL 의사 난수 생성기에 추가합니다. 생성 된 비밀 키의 보안을 강화하십시오. 이것은 일반적으로 더 나은 무작위 소스가없는 시스템에서만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5d915c3ac798b1162027d4b78ee74eb32aecf245" translate="yes" xml:space="preserve">
          <source>If you are shipping a Windows executable as described above, you either need to ensure that your users have &lt;code&gt;python3.dll&lt;/code&gt; on their PATH (which is not the default behaviour of the installer) or you should bundle your application with the embedded distribution.</source>
          <target state="translated">위에서 설명한대로 Windows 실행 파일을 제공하는 경우 사용자가 PATH에 &lt;code&gt;python3.dll&lt;/code&gt; 이 있는지 (설치 프로그램의 기본 동작이 아님) 확인해야하거나 응용 프로그램을 포함 된 배포와 함께 번들로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3c30a5d84ebc01f28c65df6e216a65d2921455f" translate="yes" xml:space="preserve">
          <source>If you are thinking of defining your own levels, please see the section on &lt;a href=&quot;https://docs.python.org/3.8/howto/logging.html#custom-levels&quot;&gt;Custom Levels&lt;/a&gt;.</source>
          <target state="translated">자신의 레벨을 정의 할 생각이라면 &lt;a href=&quot;https://docs.python.org/3.8/howto/logging.html#custom-levels&quot;&gt;사용자 정의 레벨&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0213022b07a4316b98d4138edf72e870b144d96a" translate="yes" xml:space="preserve">
          <source>If you are thinking of defining your own levels, please see the section on &lt;a href=&quot;https://docs.python.org/3.9/howto/logging.html#custom-levels&quot;&gt;Custom Levels&lt;/a&gt;.</source>
          <target state="translated">자신 만의 레벨을 정의 할 생각이라면 &lt;a href=&quot;https://docs.python.org/3.9/howto/logging.html#custom-levels&quot;&gt;Custom Levels&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49e3cbf5ea7b5f0ea71d8bc500fc226c950f1779" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; to create a mock for you then it will be returned by the call to &lt;code&gt;patcher.start&lt;/code&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 가 호출에 의해 반환 될 것이다 당신을위한 모의를 만들 수 &lt;code&gt;patcher.start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="364049631376a2a1d8911fd5401507c7f5516ee6" translate="yes" xml:space="preserve">
          <source>If you are using code that you know will raise a warning, such as a deprecated function, but do not want to see the warning (even when warnings have been explicitly configured via the command line), then it is possible to suppress the warning using the &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; context manager:</source>
          <target state="translated">더 이상 사용되지 않는 기능과 같이 경고를 발생시키는 코드를 사용하고 있지만 경고를 표시하지 않으려는 경우 (명령 줄을 통해 경고가 명시 적으로 구성된 경우에도) 사용하여 경고를 표시하지 않을 수 있습니다 &lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; 의&lt;/a&gt; 컨텍스트 매니저 :</target>
        </trans-unit>
        <trans-unit id="0c3d77e1b4bf3414b19d6e3647400caf29838bae" translate="yes" xml:space="preserve">
          <source>If you are using {}-formatting (&lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt;), you can use &lt;code&gt;{attrname}&lt;/code&gt; as the placeholder in the format string. If you are using $-formatting (&lt;a href=&quot;string#string.Template&quot;&gt;&lt;code&gt;string.Template&lt;/code&gt;&lt;/a&gt;), use the form &lt;code&gt;${attrname}&lt;/code&gt;. In both cases, of course, replace &lt;code&gt;attrname&lt;/code&gt; with the actual attribute name you want to use.</source>
          <target state="translated">{} &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; ( str.format () )를 사용 하는 경우 형식 문자열에서 &lt;code&gt;{attrname}&lt;/code&gt; 을 자리 표시 자로 사용할 수 있습니다 . $ -formatting ( &lt;a href=&quot;string#string.Template&quot;&gt; &lt;code&gt;string.Template&lt;/code&gt; &lt;/a&gt; )을 사용하는 경우 &lt;code&gt;${attrname}&lt;/code&gt; 형식을 사용하십시오 . 두 경우 모두 &lt;code&gt;attrname&lt;/code&gt; 을 사용하려는 실제 속성 이름 으로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="b6c36be2e20c5d0cd71ba05a7b714e1c1aa79df2" translate="yes" xml:space="preserve">
          <source>If you attach a handler to a logger &lt;em&gt;and&lt;/em&gt; one or more of its ancestors, it may emit the same record multiple times. In general, you should not need to attach a handler to more than one logger - if you just attach it to the appropriate logger which is highest in the logger hierarchy, then it will see all events logged by all descendant loggers, provided that their propagate setting is left set to &lt;code&gt;True&lt;/code&gt;. A common scenario is to attach handlers only to the root logger, and to let propagation take care of the rest.</source>
          <target state="translated">처리기를 로거 &lt;em&gt;와&lt;/em&gt; 하나 이상의 조상에 첨부 하면 동일한 레코드를 여러 번 방출 할 수 있습니다. 일반적으로 처리기를 둘 이상의 로거에 첨부 할 필요는 없습니다. 로거 계층 구조에서 가장 높은 적절한 로거에 연결하면 전파되는 경우 모든 하위 로거가 기록한 모든 이벤트가 표시됩니다. 설정은 &lt;code&gt;True&lt;/code&gt; 로 설정되어 있습니다. 일반적인 시나리오는 처리기를 루트 로거에만 연결하고 전파가 나머지를 처리하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71db1cfc049ed9436b58c3258dd2abae66bed7a0" translate="yes" xml:space="preserve">
          <source>If you call getpass from within IDLE, the input may be done in the terminal you launched IDLE from rather than the idle window itself.</source>
          <target state="translated">IDLE 내에서 getpass를 호출하면 유휴 창 자체가 아닌 IDLE을 시작한 터미널에서 입력이 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcfe31f0c3025ba1247b84cd55bce06307c9aaab" translate="yes" xml:space="preserve">
          <source>If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; has been set up with a format string which expects &amp;lsquo;clientip&amp;rsquo; and &amp;lsquo;user&amp;rsquo; in the attribute dictionary of the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt;. If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the &lt;em&gt;extra&lt;/em&gt; dictionary with these keys.</source>
          <target state="translated">기록 된 메시지에 이러한 속성을 사용하도록 선택한 경우 약간의주의가 필요합니다. 위의 예에서, 예를 들어, &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 의 속성 사전에서 'clientip'및 'user'를 예상하는 형식 문자열로 설정되었습니다 . 누락 된 경우 문자열 형식화 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서이 경우 항상 이러한 키로 &lt;em&gt;추가&lt;/em&gt; 사전 을 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9a9e4560c049a5fff3d7922f2065fe9c4f0bab32" translate="yes" xml:space="preserve">
          <source>If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; has been set up with a format string which expects &amp;lsquo;clientip&amp;rsquo; and &amp;lsquo;user&amp;rsquo; in the attribute dictionary of the LogRecord. If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the &lt;em&gt;extra&lt;/em&gt; dictionary with these keys.</source>
          <target state="translated">기록 된 메시지에 이러한 속성을 사용하도록 선택한 경우 약간의주의가 필요합니다. 예를 들어, 위의 예에서 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 는 LogRecord의 속성 사전에 'clientip'및 'user'가 필요한 형식 문자열로 설정되었습니다. 누락 된 경우 문자열 형식화 예외가 발생하기 때문에 메시지가 기록되지 않습니다. 따라서이 경우 항상 이러한 키로 &lt;em&gt;추가&lt;/em&gt; 사전 을 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c553bc4df8103396b1cf2c4eb7ef7300e63b8315" translate="yes" xml:space="preserve">
          <source>If you code or decode textfiles on non-Macintosh platforms they will still use the old Macintosh newline convention (carriage-return as end of line).</source>
          <target state="translated">매킨토시가 아닌 플랫폼에서 텍스트 파일을 코딩하거나 디코딩하는 경우 여전히 기존 Macintosh 줄 바꿈 규칙 (캐리지 리턴 행 끝)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d1ed81961b6cb7496a0e0f060cff06cad3d1812" translate="yes" xml:space="preserve">
          <source>If you continue a line via backslashing in an interactive session, or for any other reason use a backslash, you should use a raw docstring, which will preserve your backslashes exactly as you type them:</source>
          <target state="translated">대화식 세션에서 백 슬래시를 통해 줄을 계속하거나 다른 이유로 백 슬래시를 사용하는 경우 원시 문서 문자열을 사용해야합니다. 이렇게하면 입력 한대로 백 슬래시가 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5cac94944ad97618e4be13390591255007102a1f" translate="yes" xml:space="preserve">
          <source>If you create a finalizer object in a daemonic thread just as the program exits then there is the possibility that the finalizer does not get called at exit. However, in a daemonic thread &lt;a href=&quot;atexit#atexit.register&quot;&gt;&lt;code&gt;atexit.register()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;try: ... finally: ...&lt;/code&gt; and &lt;code&gt;with: ...&lt;/code&gt; do not guarantee that cleanup occurs either.</source>
          <target state="translated">프로그램이 종료 될 때 데몬 스레드에서 종료 자 오브젝트를 작성하면 종료시에 종료자가 호출되지 않을 가능성이 있습니다. 그러나 &lt;a href=&quot;atexit#atexit.register&quot;&gt; &lt;code&gt;atexit.register()&lt;/code&gt; &lt;/a&gt; 스레드 atexit.register () 에서 다음을 &lt;code&gt;try: ... finally: ...&lt;/code&gt; 및 &lt;code&gt;with: ...&lt;/code&gt; 는 정리도 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a460562d42a2a11f6a379108a05dfc43f47c1591" translate="yes" xml:space="preserve">
          <source>If you define the &lt;code&gt;WINDOWS&lt;/code&gt; preprocessor symbol, this will generate a GUI executable, and without it, a console executable.</source>
          <target state="translated">&lt;code&gt;WINDOWS&lt;/code&gt; 전 처리기 기호 를 정의하면 GUI 실행 파일과 콘솔 실행 파일없이 GUI 실행 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8d268659c0afbd91ab53443b6a751cff765c3b" translate="yes" xml:space="preserve">
          <source>If you do not want that behavior, preprocess the &lt;em&gt;url&lt;/em&gt; with &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt;&lt;code&gt;urlsplit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.parse.urlunsplit&quot;&gt;&lt;code&gt;urlunsplit()&lt;/code&gt;&lt;/a&gt;, removing possible &lt;em&gt;scheme&lt;/em&gt; and &lt;em&gt;netloc&lt;/em&gt; parts.</source>
          <target state="translated">이 동작을 원하지 않으면 &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt; &lt;code&gt;urlsplit()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.parse.urlunsplit&quot;&gt; &lt;code&gt;urlunsplit()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; URL&lt;/em&gt; 을 사전 처리하여 가능한 &lt;em&gt;구성표&lt;/em&gt; 와 &lt;em&gt;netloc&lt;/em&gt; 부분을 제거하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="75f973cadf33dbb5346b31c20f9455a09e62a539" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t know whether a &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; call is required, it probably isn&amp;rsquo;t.</source>
          <target state="translated">&lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 호출이 필요한지 여부를 모르면 필요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e329f1a76521b4e0c106f18d644a53b002a016b" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like the ACW popping up unbidden, simply make the delay longer or disable the extension.</source>
          <target state="translated">ACW 팝업이 마음에 들지 않으면 지연 시간을 늘리거나 확장 프로그램을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="07407a9c866063255f749a7211d292d84fbd66bb" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want a newline termination, you can set the handler instance&amp;rsquo;s &lt;code&gt;terminator&lt;/code&gt; attribute to the empty string.</source>
          <target state="translated">줄 바꿈 종료를 원하지 않는 경우 핸들러 인스턴스의 &lt;code&gt;terminator&lt;/code&gt; 속성을 빈 문자열로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0b378bb20bf0aa3247056c249ea998b15eb65e8" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to store the instance&amp;rsquo;s data in the &lt;code&gt;_as_parameter_&lt;/code&gt; instance variable, you could define a &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; which makes the attribute available on request.</source>
          <target state="translated">&lt;code&gt;_as_parameter_&lt;/code&gt; 인스턴스 변수에 인스턴스 데이터를 저장하지 않으려는 경우 요청시 속성을 사용할 수 있는 &lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a8d040851b0915051f326bd15d54a88ae21e65f" translate="yes" xml:space="preserve">
          <source>If you find that when certain older clients or servers attempt to connect with a &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; created by this function that they get an error stating &amp;ldquo;Protocol or cipher suite mismatch&amp;rdquo;, it may be that they only support SSL3.0 which this function excludes using the &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt;&lt;code&gt;OP_NO_SSLv3&lt;/code&gt;&lt;/a&gt;. SSL3.0 is widely considered to be &lt;a href=&quot;https://en.wikipedia.org/wiki/POODLE&quot;&gt;completely broken&lt;/a&gt;. If you still wish to continue to use this function but still allow SSL 3.0 connections you can re-enable them using:</source>
          <target state="translated">특정 구형 클라이언트 또는 서버 가이 기능으로 생성 된 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 와 연결을 시도 할 때 &quot;프로토콜 또는 암호 제품군 불일치&quot;라는 오류가 발생하면 SSL3.0 만 지원할 수 있습니다. &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt; &lt;code&gt;OP_NO_SSLv3&lt;/code&gt; &lt;/a&gt; . SSL3.0은 &lt;a href=&quot;https://en.wikipedia.org/wiki/POODLE&quot;&gt;완전히 고장난&lt;/a&gt; 것으로 널리 알려져 있습니다 . 여전히이 기능을 계속 사용하지만 여전히 SSL 3.0 연결을 허용하려면 다음을 사용하여 다시 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9aa74952f83bd4d51d51d4e83cebc44b0b2fe0" translate="yes" xml:space="preserve">
          <source>If you give your &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; subclass extra methods, like the &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; class above, those methods will show up in a &lt;a href=&quot;functions#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; of the member, but not of the class:</source>
          <target state="translated">위 의 &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; 클래스 와 같이 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 서브 클래스에 추가 메소드 를 제공하면 해당 메소드는 멤버 의 &lt;a href=&quot;functions#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 에 표시 되지만 클래스에는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddea48c736e63a88242d988d2f93ca78d7b3b84d" translate="yes" xml:space="preserve">
          <source>If you have XML in a string, you can use the &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt;&lt;code&gt;parseString()&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">문자열에 XML이있는 경우 &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt; &lt;code&gt;parseString()&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68b99e8b222c2278454b1cadc38d91ffc4b68997" translate="yes" xml:space="preserve">
          <source>If you have XML in a string, you can use the &lt;a href=&quot;#xml.dom.pulldom.parseString&quot;&gt;&lt;code&gt;parseString()&lt;/code&gt;&lt;/a&gt; function instead:</source>
          <target state="translated">문자열에 XML이있는 경우 &lt;a href=&quot;#xml.dom.pulldom.parseString&quot;&gt; &lt;code&gt;parseString()&lt;/code&gt; &lt;/a&gt; 함수를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e75dc8b8eb57f89ef2cc0c8f2d61866415c62ce9" translate="yes" xml:space="preserve">
          <source>If you have a choice, you are better off choosing a smaller constant, and then your results will &amp;ldquo;less often&amp;rdquo; show up as negative in profile statistics.</source>
          <target state="translated">선택 사항이 있으면 더 작은 상수를 선택하는 것이 좋습니다. 그러면 결과가 프로파일 통계에서 &quot;덜 자주&quot;부정으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="08f422ccd0761694976f4b7f344ccca267ef692c" translate="yes" xml:space="preserve">
          <source>If you have a package installed globally and attempt test discovery on a different copy of the package then the import &lt;em&gt;could&lt;/em&gt; happen from the wrong place. If this happens test discovery will warn you and exit.</source>
          <target state="translated">패키지가 전체적으로 설치되어 있고 다른 패키지 사본에서 테스트 발견을 시도 하면 잘못된 위치에서 가져 오기 &lt;em&gt;가&lt;/em&gt; 발생할 &lt;em&gt;수&lt;/em&gt; 있습니다. 이 경우 테스트 발견이 경고하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="fdc90a074f4d5efa53ede11d8bcd3da1d1900c9c" translate="yes" xml:space="preserve">
          <source>If you have advanced security requirements, fine-tuning of the ciphers enabled when negotiating a SSL session is possible through the &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt;&lt;/a&gt; method. Starting from Python 3.2.3, the ssl module disables certain weak ciphers by default, but you may want to further restrict the cipher choice. Be sure to read OpenSSL&amp;rsquo;s documentation about the &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;cipher list format&lt;/a&gt;. If you want to check which ciphers are enabled by a given cipher list, use &lt;a href=&quot;#ssl.SSLContext.get_ciphers&quot;&gt;&lt;code&gt;SSLContext.get_ciphers()&lt;/code&gt;&lt;/a&gt; or the &lt;code&gt;openssl ciphers&lt;/code&gt; command on your system.</source>
          <target state="translated">고급 보안 요구 사항이있는 경우 &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 SSL 세션을 협상 할 때 활성화 된 암호를 미세 조정할 수 있습니다 . Python 3.2.3부터 ssl 모듈은 기본적으로 특정 취약한 암호를 비활성화하지만 암호 선택을 추가로 제한 할 수 있습니다. &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT&quot;&gt;암호 목록 형식&lt;/a&gt; 에 대한 OpenSSL 설명서를 읽으십시오 . 주어진 암호 목록으로 활성화 된 암호를 확인 &lt;code&gt;openssl ciphers&lt;/code&gt; 시스템에서 &lt;a href=&quot;#ssl.SSLContext.get_ciphers&quot;&gt; &lt;code&gt;SSLContext.get_ciphers()&lt;/code&gt; &lt;/a&gt; 또는 openssl ciphers 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f1e86f5dd0e423a473b0f05f43d4240f3be40b1e" translate="yes" xml:space="preserve">
          <source>If you have already calculated the mean of your data, you can pass it as the optional second argument &lt;em&gt;mu&lt;/em&gt; to avoid recalculation:</source>
          <target state="translated">데이터의 평균을 이미 계산 한 경우 재 계산을 피하기 위해 선택적인 두 번째 인수 &lt;em&gt;mu&lt;/em&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f65249585348639b163a15c90fb125aadfb0a99" translate="yes" xml:space="preserve">
          <source>If you have already calculated the mean of your data, you can pass it as the optional second argument &lt;em&gt;xbar&lt;/em&gt; to avoid recalculation:</source>
          <target state="translated">데이터의 평균을 이미 계산 한 경우 재 계산을 피하기 위해 선택적인 두 번째 인수 &lt;em&gt;xbar&lt;/em&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b5f4691daf2771d8fbe481e68889a589550470c" translate="yes" xml:space="preserve">
          <source>If you have an appropriate entry in your &lt;code&gt;turtle.cfg&lt;/code&gt; file this dictionary will be read in at import time and will replace the original English docstrings.</source>
          <target state="translated">&lt;code&gt;turtle.cfg&lt;/code&gt; 파일 에 적절한 항목이 있으면 이 사전을 가져올 때 읽히고 원래 영어 문서 문자열을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0a1e2776fdb2c280f99d04fa6d3f9aadbbdd2668" translate="yes" xml:space="preserve">
          <source>If you have an enum member and need its &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;value&lt;/code&gt;:</source>
          <target state="translated">열거 형 멤버가 있고 &lt;code&gt;name&lt;/code&gt; 이나 &lt;code&gt;value&lt;/code&gt; 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="adddc6c47cf6a214332d2bba1e6dcbb1cf7609c4" translate="yes" xml:space="preserve">
          <source>If you have carried out a lot of deletions and would like to shrink the space used by the &lt;code&gt;gdbm&lt;/code&gt; file, this routine will reorganize the database. &lt;code&gt;gdbm&lt;/code&gt; objects will not shorten the length of a database file except by using this reorganization; otherwise, deleted file space will be kept and reused as new (key, value) pairs are added.</source>
          <target state="translated">많은 삭제를 수행했으며 &lt;code&gt;gdbm&lt;/code&gt; 파일이 사용하는 공간을 줄이려면 이 루틴이 데이터베이스를 재구성합니다. &lt;code&gt;gdbm&lt;/code&gt; 객체는이 재구성을 사용하지 않는 한 데이터베이스 파일의 길이를 줄이지 않습니다. 그렇지 않으면 삭제 된 파일 공간이 유지되고 새 (키, 값) 쌍이 추가 될 때 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3941a6c86792842a0db1694694d8d40f3510d0d" translate="yes" xml:space="preserve">
          <source>If you have defined your own classes which you pass to function calls, you have to implement a &lt;code&gt;from_param()&lt;/code&gt; class method for them to be able to use them in the &lt;code&gt;argtypes&lt;/code&gt; sequence. The &lt;code&gt;from_param()&lt;/code&gt; class method receives the Python object passed to the function call, it should do a typecheck or whatever is needed to make sure this object is acceptable, and then return the object itself, its &lt;code&gt;_as_parameter_&lt;/code&gt; attribute, or whatever you want to pass as the C function argument in this case. Again, the result should be an integer, string, bytes, a &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; instance, or an object with an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute.</source>
          <target state="translated">함수 호출에 전달할 자체 클래스를 정의한 경우 해당 &lt;code&gt;from_param()&lt;/code&gt; &lt;code&gt;argtypes&lt;/code&gt; 시퀀스 에서 사용할 수 있도록 from_param () 클래스 메소드 를 구현해야합니다 . &lt;code&gt;from_param()&lt;/code&gt; 클래스 메소드는이 유형 체킹을 수행해야합니다, 함수 호출에 전달 된 파이썬 객체를 수신하거나 확인이 객체가 허용되어 있는지 확인하고 개체 자체, 그것의 반환에 필요한 무엇이든 &lt;code&gt;_as_parameter_&lt;/code&gt; 의 당신이 전달하려는 어떤 속성, 또는 이 경우 C 함수 인수로. 다시, 결과는 정수, 문자열, 바이트, &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 &lt;code&gt;_as_parameter_&lt;/code&gt; 속성을 가진 객체 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="c7ba5f87f67362e164e00c45234b25b88116bc45" translate="yes" xml:space="preserve">
          <source>If you have positional arguments that must begin with &lt;code&gt;-&lt;/code&gt; and don&amp;rsquo;t look like negative numbers, you can insert the pseudo-argument &lt;code&gt;'--'&lt;/code&gt; which tells &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; that everything after that is a positional argument:</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 로 시작해야하는 위치 인수가 있고 음수로 보이지 않으면 의사 인수 &lt;code&gt;'--'&lt;/code&gt; 를 삽입하면 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 에게 그 이후의 모든 것이 위치 인수임을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ad6fc06b4f04b51136dd86e77cdf44c2345475" translate="yes" xml:space="preserve">
          <source>If you instantiate any of these types, note that signatures may vary between Python versions.</source>
          <target state="translated">이러한 유형을 인스턴스화하는 경우 서명은 Python 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ee2c99f3c1ce008b2482f9a4bd039eac988eb85" translate="yes" xml:space="preserve">
          <source>If you merely want to attach a time zone object &lt;em&gt;tz&lt;/em&gt; to a datetime &lt;em&gt;dt&lt;/em&gt; without adjustment of date and time data, use &lt;code&gt;dt.replace(tzinfo=tz)&lt;/code&gt;. If you merely want to remove the time zone object from an aware datetime &lt;em&gt;dt&lt;/em&gt; without conversion of date and time data, use &lt;code&gt;dt.replace(tzinfo=None)&lt;/code&gt;.</source>
          <target state="translated">날짜 및 시간 데이터를 조정하지 않고 시간대 오브젝트 &lt;em&gt;tz&lt;/em&gt; 를 날짜 / 시간 &lt;em&gt;dt&lt;/em&gt; 에 첨부하려는 경우 &lt;code&gt;dt.replace(tzinfo=tz)&lt;/code&gt; . 날짜 및 시간 데이터를 변환하지 않고 인식 가능한 날짜 시간 &lt;em&gt;dt&lt;/em&gt; 에서 시간대 오브젝트를 제거하려는 경우 &lt;code&gt;dt.replace(tzinfo=None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6c75c360131321b14d956646dcffde70eca5a7" translate="yes" xml:space="preserve">
          <source>If you need a fully populated element, look for &amp;ldquo;end&amp;rdquo; events instead.</source>
          <target state="translated">완전히 채워진 요소가 필요한 경우 대신 &quot;종료&quot;이벤트를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="86368d19f69c93150072272046943f1484ff2526" translate="yes" xml:space="preserve">
          <source>If you need to find out if a module can be imported without actually doing the import, then you should use &lt;a href=&quot;#importlib.util.find_spec&quot;&gt;&lt;code&gt;importlib.util.find_spec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">실제로 가져 오기를 수행하지 않고 모듈을 가져올 수 있는지 확인해야하는 경우 &lt;a href=&quot;#importlib.util.find_spec&quot;&gt; &lt;code&gt;importlib.util.find_spec()&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4101124fa4b09fc6cc1ef68bc64b034b218ec7e6" translate="yes" xml:space="preserve">
          <source>If you need to free memory, for example, allocated by an extension module with a call to the &lt;code&gt;free(void *)&lt;/code&gt;, it is important that you use the function in the same library that allocated the memory.</source>
          <target state="translated">예를 들어, &lt;code&gt;free(void *)&lt;/code&gt; 호출하여 확장 모듈에 의해 할당 된 메모리를 비워야하는 경우 메모리를 할당 한 동일한 라이브러리에서 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ca61f6332d6d58306dfe4cd895fbd3ec252e9fa" translate="yes" xml:space="preserve">
          <source>If you need to know if a class is an instance of a dataclass (and not a dataclass itself), then add a further check for &lt;code&gt;not
isinstance(obj, type)&lt;/code&gt;:</source>
          <target state="translated">클래스가 데이터 클래스 자체가 아닌 데이터 클래스의 인스턴스인지 알아야하는 경우 &lt;code&gt;not isinstance(obj, type)&lt;/code&gt; 여부에 대한 추가 검사를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9fbb0aa423003d7733fbd8694a32a308d63c2747" translate="yes" xml:space="preserve">
          <source>If you need to load modules from a directory which is not on Python&amp;rsquo;s default module search path, you can change the path in your script, before importing other modules. For example:</source>
          <target state="translated">Python의 기본 모듈 검색 경로에없는 디렉토리에서 모듈을로드해야하는 경우 다른 모듈을 가져 오기 전에 스크립트에서 경로를 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cf32b7cc15737ca5c3f1bc7291a3230ef00b4ed" translate="yes" xml:space="preserve">
          <source>If you need to make more significant changes to rotation processing, you can override the methods.</source>
          <target state="translated">회전 처리를보다 크게 변경해야하는 경우 메서드를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d96003b130e0abd7634352c365ff1181febdd21c" translate="yes" xml:space="preserve">
          <source>If you need to modify the environment for the child use the &lt;em&gt;env&lt;/em&gt; parameter rather than doing it in a &lt;em&gt;preexec_fn&lt;/em&gt;. The &lt;em&gt;start_new_session&lt;/em&gt; parameter can take the place of a previously common use of &lt;em&gt;preexec_fn&lt;/em&gt; to call os.setsid() in the child.</source>
          <target state="translated">하위 환경을 수정해야하는 경우 , &lt;em&gt;preexec_fn&lt;/em&gt; 에서 &lt;em&gt;env&lt;/em&gt; 매개 변수를 사용하지 말고 &lt;em&gt;env&lt;/em&gt; 매개 변수를 사용하십시오 . &lt;em&gt;start_new_session의&lt;/em&gt; 매개 변수의 이전에 일반적인 사용의 장소 걸릴 수 &lt;em&gt;preexec_fn을&lt;/em&gt; 아이에 () os.setsid 전화.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f304fd08cfd78b8854b1fd29f66f112cd5c13e1e" translate="yes" xml:space="preserve">
          <source>If you need to set the locale directory, you can pass it into the &lt;a href=&quot;#gettext.install&quot;&gt;&lt;code&gt;install()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">로케일 디렉토리를 설정해야하는 경우 &lt;a href=&quot;#gettext.install&quot;&gt; &lt;code&gt;install()&lt;/code&gt; &lt;/a&gt; 함수 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="989b83d5f423a04c98cf18328ded12c8c1f9993b" translate="yes" xml:space="preserve">
          <source>If you pass a relative pathname, don&amp;rsquo;t change the current working directory between resumptions of &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; never changes the current directory, and assumes that its caller doesn&amp;rsquo;t either.</source>
          <target state="translated">상대 경로 이름을 전달하면 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 재개간에 현재 작업 디렉토리를 변경하지 마십시오 . &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 는 현재 디렉토리를 변경하지 않으며 호출자도 마찬가지라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="14e992d9d4752d16d4f2db4c0441e7739cd4616d" translate="yes" xml:space="preserve">
          <source>If you pass in a file-like object, the wave object will not close it when its &lt;code&gt;close()&lt;/code&gt; method is called; it is the caller&amp;rsquo;s responsibility to close the file object.</source>
          <target state="translated">파일과 같은 객체를 전달하면, &lt;code&gt;close()&lt;/code&gt; 메소드가 호출 될 때 웨이브 객체가이를 닫지 않습니다 . 파일 객체를 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="bce6fbed23eb5dcd1301360b71b6c428b6101471" translate="yes" xml:space="preserve">
          <source>If you pass in a function it will be called with same arguments as the mock and unless the function returns the &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; singleton the call to the mock will then return whatever the function returns. If the function returns &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; then the mock will return its normal value (from the &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt;&lt;code&gt;return_value&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수를 전달하면 mock과 동일한 인수로 호출되며 함수가 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 싱글 톤을 반환하지 않으면 mock에 대한 호출은 함수가 반환하는 모든 것을 반환합니다. 함수가 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 를 반환 하면 모의는 정상 값을 반환합니다 ( &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt; &lt;code&gt;return_value&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a5bcec43963bc6522bf0a067657c871d04e72c94" translate="yes" xml:space="preserve">
          <source>If you pass in an iterable, it is used to retrieve an iterator which must yield a value on every call. This value can either be an exception instance to be raised, or a value to be returned from the call to the mock (&lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; handling is identical to the function case).</source>
          <target state="translated">iterable을 전달하면 모든 호출에서 값을 산출해야하는 반복자를 검색하는 데 사용됩니다. 이 값은 예외 인스턴스가 발생하거나 모의 호출에서 반환되는 값일 수 있습니다 ( &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 처리는 함수 경우와 동일).</target>
        </trans-unit>
        <trans-unit id="e8f98dd86ae9edd376ec292daf25469e857090bc" translate="yes" xml:space="preserve">
          <source>If you prefer to tune security settings yourself, you might create a context from scratch (but beware that you might not get the settings right):</source>
          <target state="translated">보안 설정을 직접 조정하려면 컨텍스트를 처음부터 새로 작성해야합니다 (그러나 설정이 올바르지 않을 수 있음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="13d9f70eafdbcb60562762894f8800d86df24ae3" translate="yes" xml:space="preserve">
          <source>If you ran the process with &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt;, stdout and stderr will be combined in this attribute, and &lt;a href=&quot;#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt; 으로 프로세스를 실행 한 경우 stdout 및 stderr이이 속성에 결합되고 &lt;a href=&quot;#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="097c1b21b4dc383068accbc4c009da7628ba1b98" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;example.py&lt;/code&gt; directly from the command line, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; works its magic:</source>
          <target state="translated">명령 행에서 &lt;code&gt;example.py&lt;/code&gt; 를 직접 실행하면 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 그 마법을 작동 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4f231c383bc8b650abcdc023f68a52b9b627363e" translate="yes" xml:space="preserve">
          <source>If you set e.g. &lt;code&gt;language = italian&lt;/code&gt; the docstringdict &lt;code&gt;turtle_docstringdict_italian.py&lt;/code&gt; will be loaded at import time (if present on the import path, e.g. in the same directory as &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;language = italian&lt;/code&gt; 을 설정 하면 docstringdict &lt;code&gt;turtle_docstringdict_italian.py&lt;/code&gt; 는 가져 오기시에로드됩니다 (예 : 가져 오기 경로에있는 경우 (예 : &lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; ))&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f9ca74752ebe3e1cde63708838074a0ef64b8ab" translate="yes" xml:space="preserve">
          <source>If you simply want to import a module (potentially within a package) by name, use &lt;a href=&quot;importlib#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이름으로 모듈 (잠재적으로 패키지 내)을 가져 오려면 &lt;a href=&quot;importlib#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadedf4eaab1c80ba2f6a6ef7e45a206594d656a" translate="yes" xml:space="preserve">
          <source>If you somehow know the actual population mean &amp;mu; you should pass it to the &lt;a href=&quot;#statistics.pvariance&quot;&gt;&lt;code&gt;pvariance()&lt;/code&gt;&lt;/a&gt; function as the &lt;em&gt;mu&lt;/em&gt; parameter to get the variance of a sample.</source>
          <target state="translated">실제 모집단 평균 &amp;mu;를 어떻게 든 알고 있다면이를 &lt;a href=&quot;#statistics.pvariance&quot;&gt; &lt;code&gt;pvariance()&lt;/code&gt; &lt;/a&gt; 함수에 &lt;em&gt;mu&lt;/em&gt; 매개 변수로 전달하여 표본의 분산을 구해야합니다.</target>
        </trans-unit>
        <trans-unit id="6158aab4724beaceaa6e79b29d9be8382f2e23f9" translate="yes" xml:space="preserve">
          <source>If you somehow know the true population mean &amp;mu;, you may use this function to calculate the variance of a sample, giving the known population mean as the second argument. Provided the data points are a random sample of the population, the result will be an unbiased estimate of the population variance.</source>
          <target state="translated">실제 모집단 평균 &amp;mu;를 어떻게 든 알고 있다면이 함수를 사용하여 표본의 분산을 계산하여 알려진 모집단 평균을 두 번째 인수로 지정할 수 있습니다. 데이터 점이 모집단의 랜덤 표본 인 경우 결과는 모집단 분산의 편견 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="c10de555c4449d7964f6af5647d563052cabd068" translate="yes" xml:space="preserve">
          <source>If you supply the start directory as a package name rather than a path to a directory then discover assumes that whichever location it imports from is the location you intended, so you will not get the warning.</source>
          <target state="translated">디렉토리에 대한 경로가 아닌 패키지 이름으로 시작 디렉토리를 제공하는 경우, 감지 할 디렉토리가 가져 오는 위치가 의도 한 위치라고 가정하므로 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc2a6c7429466d8bb8a989fdc7ce4cc694cd926" translate="yes" xml:space="preserve">
          <source>If you suspect that there may be a problem in importing the &lt;a href=&quot;cgitb#module-cgitb&quot;&gt;&lt;code&gt;cgitb&lt;/code&gt;&lt;/a&gt; module, you can use an even more robust approach (which only uses built-in modules):</source>
          <target state="translated">&lt;a href=&quot;cgitb#module-cgitb&quot;&gt; &lt;code&gt;cgitb&lt;/code&gt; &lt;/a&gt; 모듈 을 가져 오는 데 문제가 있다고 생각되면 보다 강력한 접근 방식 (내장 모듈 만 사용)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50de709429c8c96a2fb6b6fdf0e8b44acd7d7e0a" translate="yes" xml:space="preserve">
          <source>If you use &amp;ldquo;/usr/bin/env python&amp;rdquo; (or other forms of the &amp;ldquo;python&amp;rdquo; command, such as &amp;ldquo;/usr/bin/python&amp;rdquo;), you need to consider that your users may have either Python 2 or Python 3 as their default, and write your code to work under both versions.</source>
          <target state="translated">&quot;/ usr / bin / env python&quot;(또는 &quot;/ usr / bin / python&quot;과 같은 다른 형태의 &quot;python&quot;명령)을 사용하는 경우 사용자에게 Python 2 또는 Python 3이있을 수 있음을 고려해야합니다 기본값으로 사용하고 두 버전에서 작동하도록 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3327948dd8642cd268b3754e1a2f4b14a2babf7c" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;#multiprocessing.JoinableQueue&quot;&gt;&lt;code&gt;JoinableQueue&lt;/code&gt;&lt;/a&gt; then you &lt;strong&gt;must&lt;/strong&gt; call &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;JoinableQueue.task_done()&lt;/code&gt;&lt;/a&gt; for each task removed from the queue or else the semaphore used to count the number of unfinished tasks may eventually overflow, raising an exception.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.JoinableQueue&quot;&gt; &lt;code&gt;JoinableQueue&lt;/code&gt; &lt;/a&gt; 를 사용하는 경우 대기열에서 제거 된 각 작업에 대해 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;JoinableQueue.task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 &lt;strong&gt;해야합니다.&lt;/strong&gt; 그렇지 않으면 완료되지 않은 작업 수를 계산하는 데 사용되는 세마포어가 오버플로되어 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f4f2a66699a6ccb9a802c6a128aa2a5c76c7e61" translate="yes" xml:space="preserve">
          <source>If you use &lt;em&gt;editline&lt;/em&gt;/&lt;code&gt;libedit&lt;/code&gt; readline emulation on macOS, the initialization file located in your home directory is named &lt;code&gt;.editrc&lt;/code&gt;. For example, the following content in &lt;code&gt;~/.editrc&lt;/code&gt; will turn ON &lt;em&gt;vi&lt;/em&gt; keybindings and TAB completion:</source>
          <target state="translated">macOS에서 &lt;em&gt;editline&lt;/em&gt; / &lt;code&gt;libedit&lt;/code&gt; readline 에뮬레이션 을 사용하는 경우 홈 디렉토리에있는 초기화 파일의 이름은 &lt;code&gt;.editrc&lt;/code&gt; 입니다. 예를 들어,에서 다음과 같은 내용 &lt;code&gt;~/.editrc&lt;/code&gt; 가 ON으로 바뀝니다 &lt;em&gt;VI&lt;/em&gt; 키 바인딩 및 TAB 완료 :</target>
        </trans-unit>
        <trans-unit id="c3d4a93e13f71d80556de33a53d4ec361fe070d9" translate="yes" xml:space="preserve">
          <source>If you use &lt;em&gt;spec&lt;/em&gt; or &lt;em&gt;spec_set&lt;/em&gt; and &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is replacing a &lt;em&gt;class&lt;/em&gt;, then the return value of the created mock will have the same spec.</source>
          <target state="translated">&lt;em&gt;spec&lt;/em&gt; 또는 &lt;em&gt;spec_set&lt;/em&gt; 을 사용 하고 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;class를&lt;/em&gt; 바꾸면 작성된 모의 반환 값은 동일한 스펙을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="514f9487f7b2350c961e01f947173c311579e162" translate="yes" xml:space="preserve">
          <source>If you use a hostname in the &lt;em&gt;host&lt;/em&gt; portion of IPv4/v6 socket address, the program may show a nondeterministic behavior, as Python uses the first address returned from the DNS resolution. The socket address will be resolved differently into an actual IPv4/v6 address, depending on the results from DNS resolution and/or the host configuration. For deterministic behavior use a numeric address in &lt;em&gt;host&lt;/em&gt; portion.</source>
          <target state="translated">IPv4 / v6 소켓 주소 의 &lt;em&gt;호스트&lt;/em&gt; 부분 에서 &lt;em&gt;호스트&lt;/em&gt; 이름을 사용하는 경우 Python에서 DNS 확인에서 반환 된 첫 번째 주소를 사용하므로 프로그램에 비 결정적 동작이 표시 될 수 있습니다. 소켓 주소는 DNS 확인 결과 및 / 또는 호스트 구성 결과에 따라 실제 IPv4 / v6 주소로 다르게 해석됩니다. 결정적인 동작을 위해서는 &lt;em&gt;호스트&lt;/em&gt; 부분에 숫자 주소를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="96ea7b1cf88562cf80e633c2b1c94203e479e327" translate="yes" xml:space="preserve">
          <source>If you use an explicit version, for example &amp;ldquo;/usr/bin/env python3&amp;rdquo; your application will not work for users who do not have that version. (This may be what you want if you have not made your code Python 2 compatible).</source>
          <target state="translated">&quot;/ usr / bin / env python3&quot;과 같은 명시 적 버전을 사용하는 경우 해당 버전이없는 사용자에게는 응용 프로그램이 작동하지 않습니다. (이 코드를 Python 2 호환으로 만들지 않은 경우 원하는 것일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="6997de2e41b96b52ebe4782063e52556ff05a848" translate="yes" xml:space="preserve">
          <source>If you use the &amp;lsquo;silent&amp;rsquo; command in the command list, the usual message about stopping at a breakpoint is not printed. This may be desirable for breakpoints that are to print a specific message and then continue. If none of the other commands print anything, you see no sign that the breakpoint was reached.</source>
          <target state="translated">명령 목록에서 'silent'명령을 사용하면 중단 점에서 중지하는 데 대한 일반적인 메시지가 인쇄되지 않습니다. 특정 메시지를 인쇄 한 다음 계속해야하는 중단 점에 바람직 할 수 있습니다. 다른 명령으로 아무것도 인쇄하지 않으면 중단 점에 도달했다는 신호가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f69dd2dd959b985277dcf16e4c5303ee3dde0861" translate="yes" xml:space="preserve">
          <source>If you use the &lt;em&gt;spec&lt;/em&gt; keyword argument to create a mock then attempting to set a magic method that isn&amp;rsquo;t in the spec will raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;em&gt;사양&lt;/em&gt; 모의를 만들 키워드 인수를 다음 올릴 사양에없는 마법의 방법을 설정하려고 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="353ad31e4d774964063f5b58ea1776698ab8f303" translate="yes" xml:space="preserve">
          <source>If you use the &lt;em&gt;spec&lt;/em&gt; or &lt;em&gt;spec_set&lt;/em&gt; arguments then &lt;em&gt;only&lt;/em&gt; magic methods that exist in the spec will be created.</source>
          <target state="translated">&lt;em&gt;spec&lt;/em&gt; 또는 &lt;em&gt;spec_set&lt;/em&gt; 인수를 사용하면 &lt;em&gt;스펙&lt;/em&gt; 에 존재하는 마술 메소드 &lt;em&gt;만&lt;/em&gt; 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3be1784a6b9e18d186acdce6908f38010e51c9ef" translate="yes" xml:space="preserve">
          <source>If you use the ADPCM coder to build network packets and you want your protocol to be stateless (i.e. to be able to tolerate packet loss) you should not only transmit the data but also the state. Note that you should send the &lt;em&gt;initial&lt;/em&gt; state (the one you passed to &lt;a href=&quot;#audioop.lin2adpcm&quot;&gt;&lt;code&gt;lin2adpcm()&lt;/code&gt;&lt;/a&gt;) along to the decoder, not the final state (as returned by the coder). If you want to use &lt;a href=&quot;struct#struct.Struct&quot;&gt;&lt;code&gt;struct.Struct&lt;/code&gt;&lt;/a&gt; to store the state in binary you can code the first element (the predicted value) in 16 bits and the second (the delta index) in 8.</source>
          <target state="translated">ADPCM 코더를 사용하여 네트워크 패킷을 작성하고 프로토콜이 상태 비 저장 (즉, 패킷 손실을 허용 할 수 있도록)을 원하면 데이터뿐만 아니라 상태도 전송해야합니다. 당신이 보내는 것을 참고 &lt;em&gt;초기&lt;/em&gt; (당신이 전달 된 하나의 상태 &lt;a href=&quot;#audioop.lin2adpcm&quot;&gt; &lt;code&gt;lin2adpcm()&lt;/code&gt; &lt;/a&gt; ) 디코더,하지 (코더에 의해 반환) 최종 상태에 따라. 사용할 경우 &lt;a href=&quot;struct#struct.Struct&quot;&gt; &lt;code&gt;struct.Struct&lt;/code&gt; 을&lt;/a&gt; 이진 상태를 저장하는 경우 16 비트의 첫 번째 요소 (예측치)와 8 번째 (델타 인덱스)를 부호화 할 수있다.</target>
        </trans-unit>
        <trans-unit id="9c83d7f1f379ed7a6cf04574d6c921d79a111100" translate="yes" xml:space="preserve">
          <source>If you use this technique you must ensure that the patching is &amp;ldquo;undone&amp;rdquo; by calling &lt;code&gt;stop&lt;/code&gt;. This can be fiddlier than you might think, because if an exception is raised in the &lt;code&gt;setUp&lt;/code&gt; then &lt;code&gt;tearDown&lt;/code&gt; is not called. &lt;a href=&quot;unittest#unittest.TestCase.addCleanup&quot;&gt;&lt;code&gt;unittest.TestCase.addCleanup()&lt;/code&gt;&lt;/a&gt; makes this easier:</source>
          <target state="translated">이 기술을 사용하는 경우 &lt;code&gt;stop&lt;/code&gt; 을 호출하여 패치가 &quot;실행 취소&quot;되었는지 확인해야합니다 . 예외가 제기되는 경우 때문에, 당신이 생각하는 것보다 fiddlier 수 있습니다 &lt;code&gt;setUp&lt;/code&gt; 다음 &lt;code&gt;tearDown&lt;/code&gt; 호출되지 않습니다. &lt;a href=&quot;unittest#unittest.TestCase.addCleanup&quot;&gt; &lt;code&gt;unittest.TestCase.addCleanup()&lt;/code&gt; &lt;/a&gt; 은 이것을 쉽게 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="75bf0749f0dd727a13fcc6a835a82d9cd272d1fc" translate="yes" xml:space="preserve">
          <source>If you want &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; to create mocks for you, then you can use &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; as the value. If you use &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; as a decorator then the created mocks are passed into the decorated function by keyword.</source>
          <target state="translated">당신이 원하는 경우 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 당신을위한 모의 객체를 생성하기를, 당신은 사용할 수있는 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; 값으로. 당신이 사용하는 경우 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 데코레이터로 다음 생성 된 모의 객체는 키워드로 장식 된 함수에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6a385ee3f431c0cf8aa5476eab766bc532450fe5" translate="yes" xml:space="preserve">
          <source>If you want a given &lt;em&gt;stdin&lt;/em&gt; to be used, make sure to set the instance&amp;rsquo;s &lt;a href=&quot;#cmd.Cmd.use_rawinput&quot;&gt;&lt;code&gt;use_rawinput&lt;/code&gt;&lt;/a&gt; attribute to &lt;code&gt;False&lt;/code&gt;, otherwise &lt;em&gt;stdin&lt;/em&gt; will be ignored.</source>
          <target state="translated">지정된 &lt;em&gt;stdin&lt;/em&gt; 을 사용하려면 인스턴스의 &lt;a href=&quot;#cmd.Cmd.use_rawinput&quot;&gt; &lt;code&gt;use_rawinput&lt;/code&gt; &lt;/a&gt; 속성을 &lt;code&gt;False&lt;/code&gt; 로 설정해야합니다 . 그렇지 않으면 &lt;em&gt;stdin&lt;/em&gt; 이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bcf54413bb963aa019597f5acad81401f292e6" translate="yes" xml:space="preserve">
          <source>If you want cross-platform overwriting of the destination, use &lt;a href=&quot;#os.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대상을 크로스 플랫폼으로 덮어 쓰려면 &lt;a href=&quot;#os.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a129089344fee48b88396b82f4d19b77ca7fc4d" translate="yes" xml:space="preserve">
          <source>If you want more functionality, you&amp;rsquo;re going to have to read the manual, or guess what the following functions do:</source>
          <target state="translated">더 많은 기능을 원하면 매뉴얼을 읽거나 다음 기능이 무엇인지 추측해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ae975db4dc6412041430b1daafaa6c1c0e31b5d" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;setUpClass&lt;/code&gt; and &lt;code&gt;tearDownClass&lt;/code&gt; on base classes called then you must call up to them yourself. The implementations in &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; are empty.</source>
          <target state="translated">호출 된 기본 클래스 에서 &lt;code&gt;setUpClass&lt;/code&gt; 및 &lt;code&gt;tearDownClass&lt;/code&gt; 를 원하는 경우 직접 호출해야합니다. &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 의 구현 이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fc69a19f6a319eafed02a83645ae1ec1683cb6c" translate="yes" xml:space="preserve">
          <source>If you want the adler32 or crc32 hash functions, they are available in the &lt;a href=&quot;zlib#module-zlib&quot;&gt;&lt;code&gt;zlib&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">adler32 또는 crc32 해시 함수를 원하는 경우 &lt;a href=&quot;zlib#module-zlib&quot;&gt; &lt;code&gt;zlib&lt;/code&gt; &lt;/a&gt; 모듈 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cc2b2701ce617852e01ad2fdbb4d98e0e062510" translate="yes" xml:space="preserve">
          <source>If you want the mock to still return the default return value (a new mock), or any set return value, then there are two ways of doing this. Either return &lt;code&gt;mock.return_value&lt;/code&gt; from inside &lt;code&gt;side_effect&lt;/code&gt;, or return &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">mock이 여전히 기본 반환 값 (새로운 mock) 또는 설정된 반환 값을 반환하도록하려면 두 가지 방법이 있습니다. 어느 반환 &lt;code&gt;mock.return_value&lt;/code&gt; 내부에서 &lt;code&gt;side_effect&lt;/code&gt; , 또는 반환 &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c2e7b29010c2bd4bd3a7b2186800720ade7653a7" translate="yes" xml:space="preserve">
          <source>If you want to access enum members by &lt;em&gt;name&lt;/em&gt;, use item access:</source>
          <target state="translated">&lt;em&gt;name으로&lt;/em&gt; 열거 형 멤버에 액세스하려면 항목 액세스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c2d72cb023b23999d092f07ff8849d8edf000d1" translate="yes" xml:space="preserve">
          <source>If you want to avoid the &lt;code&gt;ord(&quot;x&quot;)&lt;/code&gt; calls above, you can set the &lt;code&gt;argtypes&lt;/code&gt; attribute, and the second argument will be converted from a single character Python bytes object into a C char:</source>
          <target state="translated">위의 &lt;code&gt;ord(&quot;x&quot;)&lt;/code&gt; 호출 을 피하려면 &lt;code&gt;argtypes&lt;/code&gt; 속성을 설정 하면 두 번째 인수가 단일 문자 Python bytes 객체에서 C 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="279c29c89aa9656f84b48678016178fbd67cb71c" translate="yes" xml:space="preserve">
          <source>If you want to change how current time is determined (for example, to force use of wall-clock time or elapsed process time), pass the timing function you want to the &lt;code&gt;Profile&lt;/code&gt; class constructor:</source>
          <target state="translated">현재 시간을 결정하는 방법을 변경하려면 (예 : 벽시계 시간 또는 경과 된 프로세스 시간 사용) &lt;code&gt;Profile&lt;/code&gt; 클래스 생성자 에게 원하는 타이밍 함수를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="73a589407368c78ec530e2f941e80cc64760ae2f" translate="yes" xml:space="preserve">
          <source>If you want to clear any previously installed progress handler, call the method with &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;handler&lt;/em&gt;.</source>
          <target state="translated">당신이 이전에 설치된 진행 핸들러를 취소하려는 경우와 메서드를 호출 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;em&gt;처리기를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b85687d6933b3a0fe36fbb7a49d525fedab74695" translate="yes" xml:space="preserve">
          <source>If you want to convert an integer number to an uppercase or lower hexadecimal string with prefix or not, you can use either of the following ways:</source>
          <target state="translated">정수를 접두사를 사용하여 대문자 또는 하위 16 진 문자열로 변환하려면 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="555dbff41f37109f588fa5abd198ada8e8af5c33" translate="yes" xml:space="preserve">
          <source>If you want to convert an integer number to octal string either with prefix &amp;ldquo;0o&amp;rdquo; or not, you can use either of the following ways.</source>
          <target state="translated">접두사&amp;ldquo;0o&amp;rdquo;를 사용하여 정수를 8 진수 문자열로 변환하려는 경우 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7e395a436c737fb4f983babcb85c37f7ffba2a" translate="yes" xml:space="preserve">
          <source>If you want to create a memory-mapping for a writable, buffered file, you should &lt;a href=&quot;io#io.IOBase.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; the file first. This is necessary to ensure that local modifications to the buffers are actually available to the mapping.</source>
          <target state="translated">쓰기 가능하고 버퍼링 된 파일에 대한 메모리 매핑을 만들려면 먼저 파일을 &lt;a href=&quot;io#io.IOBase.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 해야합니다. 이는 버퍼에 대한 로컬 수정이 실제로 맵핑에 사용 가능하도록하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8c96548f19f99190ded12d511ae463febe2b5258" translate="yes" xml:space="preserve">
          <source>If you want to create a new ZIP archive, specify its name after the &lt;a href=&quot;#cmdoption-zipfile-c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option and then list the filename(s) that should be included:</source>
          <target state="translated">새 ZIP 아카이브를 작성하려면 &lt;a href=&quot;#cmdoption-zipfile-c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 옵션 뒤에 이름을 지정한 다음 포함해야하는 파일 이름을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="b106ae412fab326b87e70a6ef024d49bf607babb" translate="yes" xml:space="preserve">
          <source>If you want to create a new tar archive, specify its name after the &lt;a href=&quot;#cmdoption-tarfile-c&quot;&gt;&lt;code&gt;-c&lt;/code&gt;&lt;/a&gt; option and then list the filename(s) that should be included:</source>
          <target state="translated">새 tar 아카이브를 작성하려면 &lt;a href=&quot;#cmdoption-tarfile-c&quot;&gt; &lt;code&gt;-c&lt;/code&gt; &lt;/a&gt; 옵션 뒤에 이름을 지정한 다음 포함해야하는 파일 이름을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="7c1a46617f45e12138983a57722199d3eb708a28" translate="yes" xml:space="preserve">
          <source>If you want to extract a ZIP archive into the specified directory, use the &lt;a href=&quot;#cmdoption-zipfile-e&quot;&gt;&lt;code&gt;-e&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">ZIP 아카이브를 지정된 디렉토리로 추출하려면 &lt;a href=&quot;#cmdoption-zipfile-e&quot;&gt; &lt;code&gt;-e&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="700b384e128d1fbde8cf4400e885f3cf8732d78d" translate="yes" xml:space="preserve">
          <source>If you want to extract a tar archive into the current directory, use the &lt;a href=&quot;#cmdoption-tarfile-e&quot;&gt;&lt;code&gt;-e&lt;/code&gt;&lt;/a&gt; option:</source>
          <target state="translated">tar 아카이브를 현재 디렉토리로 추출하려면 &lt;a href=&quot;#cmdoption-tarfile-e&quot;&gt; &lt;code&gt;-e&lt;/code&gt; &lt;/a&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="58588189cff4519d00d0897d652e2f735d514b04" translate="yes" xml:space="preserve">
          <source>If you want to include non-ASCII characters in your email headers, say in the &lt;em&gt;Subject&lt;/em&gt; or &lt;em&gt;To&lt;/em&gt; fields, you should use the &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; class and assign the field in the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; object to an instance of &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; instead of using a string for the header value. Import the &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; class from the &lt;a href=&quot;#module-email.header&quot;&gt;&lt;code&gt;email.header&lt;/code&gt;&lt;/a&gt; module. For example:</source>
          <target state="translated">&lt;em&gt;제목&lt;/em&gt; 또는받는 &lt;em&gt;사람&lt;/em&gt; 필드 와 같이 전자 메일 헤더에 ASCII가 아닌 문자를 포함 시키 &lt;em&gt;려면 &lt;/em&gt;&lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 클래스 를 사용하고 헤더 값에 문자열을 사용하는 대신 &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 의 인스턴스에 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체 의 필드를 할당해야합니다 . &lt;a href=&quot;#module-email.header&quot;&gt; &lt;code&gt;email.header&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 클래스를 가져 오십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24ec3c78c55c3f145a14ab40bbeb1ab84cc85d19" translate="yes" xml:space="preserve">
          <source>If you want to keep the frame around (for example to print a traceback later), you can also break reference cycles by using the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame.clear&quot;&gt;&lt;code&gt;frame.clear()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">프레임을 유지하려면 (예 : 나중에 역 추적 인쇄) &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame.clear&quot;&gt; &lt;code&gt;frame.clear()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 참조주기를 중단 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f475512fa10ce12ef3e23d2a5ca9d598d54ca1d9" translate="yes" xml:space="preserve">
          <source>If you want to keep the frame around (for example to print a traceback later), you can also break reference cycles by using the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#frame.clear&quot;&gt;&lt;code&gt;frame.clear()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">프레임을 유지하려는 경우 (예 : 나중에 트레이스 백을 인쇄하기 위해) &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#frame.clear&quot;&gt; &lt;code&gt;frame.clear()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 참조주기를 끊을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6549b472b422a2e03ce43ff8ed3f5196f818e1c" translate="yes" xml:space="preserve">
          <source>If you want to know how to change the first sequence into the second, use &lt;code&gt;get_opcodes()&lt;/code&gt;:</source>
          <target state="translated">첫 번째 시퀀스를 두 번째 시퀀스로 변경하는 방법을 알고 싶다면 &lt;code&gt;get_opcodes()&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd6b6c79b6bb6752c1926957d748425869a9d94e" translate="yes" xml:space="preserve">
          <source>If you want to locate a match anywhere in &lt;em&gt;string&lt;/em&gt;, use &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; instead (see also &lt;a href=&quot;#search-vs-match&quot;&gt;search() vs. match()&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;string&lt;/em&gt; 어디에서나 일치하는 위치를 찾으려면 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 &lt;a href=&quot;#search-vs-match&quot;&gt;(search () vs. match () 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="90b7dc5b7c7d64eb5dcf8c64af54da317f615167" translate="yes" xml:space="preserve">
          <source>If you want to locate a match anywhere in &lt;em&gt;string&lt;/em&gt;, use &lt;a href=&quot;#re.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; instead (see also &lt;a href=&quot;#search-vs-match&quot;&gt;search() vs. match()&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;string&lt;/em&gt; 어디에서나 일치하는 위치를 찾으려면 &lt;a href=&quot;#re.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 &lt;a href=&quot;#search-vs-match&quot;&gt;(search () vs. match () 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7691cb3a9d42f9132cc69c1d67bf2035399d4696" translate="yes" xml:space="preserve">
          <source>If you want to make the hex string easier to read, you can specify a single character separator &lt;em&gt;sep&lt;/em&gt; parameter to include in the output. By default between each byte. A second optional &lt;em&gt;bytes_per_sep&lt;/em&gt; parameter controls the spacing. Positive values calculate the separator position from the right, negative values from the left.</source>
          <target state="translated">16 진 문자열을 더 읽기 쉽게 하려면 출력에 포함 할 단일 문자 분리기 &lt;em&gt;sep&lt;/em&gt; 매개 변수를 지정할 수 있습니다 . 기본적으로 각 바이트 사이. 두 번째 선택적 &lt;em&gt;bytes_per_sep&lt;/em&gt; 매개 변수는 간격을 제어합니다. 양수 값은 오른쪽에서 분리 자 위치를 계산하고 왼쪽에서 음수 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7f82f6a50d02c1f8accc0d99988bbd66002ab317" translate="yes" xml:space="preserve">
          <source>If you want to manipulate Windows paths on a Unix machine (or vice versa). You cannot instantiate a &lt;a href=&quot;#pathlib.WindowsPath&quot;&gt;&lt;code&gt;WindowsPath&lt;/code&gt;&lt;/a&gt; when running on Unix, but you can instantiate &lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt;&lt;code&gt;PureWindowsPath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix 머신에서 Windows 경로를 조작하려는 경우 (또는 그 반대). 당신은 인스턴스화 할 수 없습니다 &lt;a href=&quot;#pathlib.WindowsPath&quot;&gt; &lt;code&gt;WindowsPath&lt;/code&gt; 를&lt;/a&gt; 유닉스에서 실행하는 경우,하지만 당신은 인스턴스화 할 수 있습니다 &lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt; &lt;code&gt;PureWindowsPath&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7de6afd3109312dd2620f94a9fb410828a34c7" translate="yes" xml:space="preserve">
          <source>If you want to parse Python code into its AST representation, see &lt;a href=&quot;ast#ast.parse&quot;&gt;&lt;code&gt;ast.parse()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 코드를 AST 표현으로 구문 분석하려면 &lt;a href=&quot;ast#ast.parse&quot;&gt; &lt;code&gt;ast.parse()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8826f07288ab3dad612019804c049ce5ddd0e19a" translate="yes" xml:space="preserve">
          <source>If you want to perform multiple patches then you can simply stack up the decorators.</source>
          <target state="translated">여러 패치를 수행하려면 데코레이터를 간단히 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f79361e9cfffc79417f13f6a383a9717a273aa3" translate="yes" xml:space="preserve">
          <source>If you want to reflect the turtle its state, you have to use &lt;code&gt;resizemode =
auto&lt;/code&gt;.</source>
          <target state="translated">거북이의 상태를 반영하려면 &lt;code&gt;resizemode = auto&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f28c7d51ec7d8d10c742281de629eb006ff45c11" translate="yes" xml:space="preserve">
          <source>If you want to send configurations to the listener which don&amp;rsquo;t disable existing loggers, you will need to use a JSON format for the configuration, which will use &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; for configuration. This method allows you to specify &lt;code&gt;disable_existing_loggers&lt;/code&gt; as &lt;code&gt;False&lt;/code&gt; in the configuration you send.</source>
          <target state="translated">기존 로거를 비활성화하지 않는 리스너로 구성을 보내려면 구성에 JSON 형식을 사용해야하며 구성에 &lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 를 사용합니다. 이 방법을 사용 하면 전송하는 구성에서 &lt;code&gt;disable_existing_loggers&lt;/code&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ebc31a3f94e9849595d45e456c192050750c4e3" translate="yes" xml:space="preserve">
          <source>If you want to specify a subject line which is record-dependent, override this method.</source>
          <target state="translated">레코드 종속적 인 제목 줄을 지정하려면이 방법을 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="745b19cebcf113a8d5f26626ff17bb861b6e043f" translate="yes" xml:space="preserve">
          <source>If you want to use a different configuration which better reflects the features of this module or which better fits to your needs, e.g. for use in a classroom, you can prepare a configuration file &lt;code&gt;turtle.cfg&lt;/code&gt; which will be read at import time and modify the configuration according to its settings.</source>
          <target state="translated">이 모듈의 기능을 더 잘 반영하거나 강의실에서 사용하기 위해 필요에 더 잘 맞는 다른 구성을 사용하려는 경우 가져 오기시에 읽히고 수정할 구성 파일 &lt;code&gt;turtle.cfg&lt;/code&gt; 를 준비 할 수 있습니다 . 설정에 따라 구성.</target>
        </trans-unit>
        <trans-unit id="6b8dc840c342df51fe5ce8af14007a99dd5c3a47" translate="yes" xml:space="preserve">
          <source>If you want to use a different prefix for your test, you can inform the patchers of the different prefix by setting &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt;. For more details about how to change the value of see &lt;a href=&quot;#test-prefix&quot;&gt;TEST_PREFIX&lt;/a&gt;.</source>
          <target state="translated">테스트에 다른 접두사를 사용하려면 patch.TEST_PREFIX를 설정하여 패치 프로그램에 다른 접두사를 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 있습니다. 값을 변경하는 방법에 대한 자세한 내용은 &lt;a href=&quot;#test-prefix&quot;&gt;TEST_PREFIX&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fad4732a998a9e23ea176b65c3a718c625cdcc4" translate="yes" xml:space="preserve">
          <source>If you want to use no fillcolor (i.e. make the turtle transparent), you have to write &lt;code&gt;fillcolor = &quot;&quot;&lt;/code&gt; (but all nonempty strings must not have quotes in the cfg-file).</source>
          <target state="translated">fillcolor를 사용하지 않으려면 (즉, 거북이를 투명하게 만들려면) &lt;code&gt;fillcolor = &quot;&quot;&lt;/code&gt; 를 작성 해야합니다 (그러나 비어 있지 않은 모든 문자열은 cfg 파일에 따옴표가 없어야합니다).</target>
        </trans-unit>
        <trans-unit id="0f8f3a435f429e1cd523ef833f8de0aef1f31607" translate="yes" xml:space="preserve">
          <source>If you want to walk an arbitrary filesystem path upwards, it is recommended to first call &lt;a href=&quot;#pathlib.Path.resolve&quot;&gt;&lt;code&gt;Path.resolve()&lt;/code&gt;&lt;/a&gt; so as to resolve symlinks and eliminate &lt;code&gt;&amp;ldquo;..&amp;rdquo;&lt;/code&gt; components.</source>
          <target state="translated">임의의 파일 시스템 경로를 위쪽으로 걸어가려면 먼저 &lt;a href=&quot;#pathlib.Path.resolve&quot;&gt; &lt;code&gt;Path.resolve()&lt;/code&gt; &lt;/a&gt; 호출 하여 심볼릭 링크를 해결하고 &lt;code&gt;&amp;ldquo;..&amp;rdquo;&lt;/code&gt; 구성 요소를 제거 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="70ac8ffb536e6d85123fe960473989eb7a059ddc" translate="yes" xml:space="preserve">
          <source>If you were looking to see what functions were looping a lot, and taking a lot of time, you would do:</source>
          <target state="translated">어떤 함수가 많이 루핑되고 많은 시간이 걸리는지 알고 싶다면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="acf8d273366df0fb10eec018a0ee0ccd5949445d" translate="yes" xml:space="preserve">
          <source>If you wondered what functions called the above functions, you could now (&lt;code&gt;p&lt;/code&gt; is still sorted according to the last criteria) do:</source>
          <target state="translated">위의 함수라고 불리는 함수가 무엇인지 궁금하다면, 이제 &lt;code&gt;p&lt;/code&gt; 는 마지막 기준에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a0bf217f357783caa209594b9bcd75c3ce805fda" translate="yes" xml:space="preserve">
          <source>If you write a file-like object and implement your own caching, you can make it fork-safe by storing the pid whenever you append to the cache, and discarding the cache when the pid changes. For example:</source>
          <target state="translated">파일과 같은 객체를 작성하고 자체 캐싱을 구현하는 경우 캐시에 추가 할 때마다 pid를 저장하고 pid가 변경 될 때 캐시를 삭제하여 포크로 안전하게 만들 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe0eb8d599c47b7f3926f4416144dc29d275eb9e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn&amp;rsquo;t recognized by Python&amp;rsquo;s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it&amp;rsquo;s highly recommended that you use raw strings for all but the simplest expressions.</source>
          <target state="translated">원시 문자열을 사용하여 패턴을 표현하지 않는 경우 Python은 문자열 리터럴에서 이스케이프 시퀀스로 백 슬래시도 사용한다는 점을 기억하십시오. 파이썬의 파서가 이스케이프 시퀀스를 인식하지 못하면 백 슬래시와 그 뒤의 문자가 결과 문자열에 포함됩니다. 그러나 파이썬이 결과 시퀀스를 인식하면 백 슬래시를 두 번 반복해야합니다. 이것은 복잡하고 이해하기 어렵 기 때문에 가장 간단한 표현식을 제외하고는 원시 문자열을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="63ba1bb5f63d28b0a2652e45a8f7caac7c895c2a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only interested in where the sequences match, &lt;code&gt;get_matching_blocks()&lt;/code&gt; is handy:</source>
          <target state="translated">시퀀스가 일치하는 위치에만 관심이 있다면 &lt;code&gt;get_matching_blocks()&lt;/code&gt; 가 편리합니다.</target>
        </trans-unit>
        <trans-unit id="f936f48bc81e3933728945057465fe8b1eaf71cf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting with a buffered Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;, first do &lt;code&gt;f.flush()&lt;/code&gt;, and then do &lt;code&gt;os.fsync(f.fileno())&lt;/code&gt;, to ensure that all internal buffers associated with &lt;em&gt;f&lt;/em&gt; are written to disk.</source>
          <target state="translated">버퍼링 된 Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;f로&lt;/em&gt; 시작하는 경우 먼저 &lt;code&gt;f.flush()&lt;/code&gt; 를 수행 한 다음 &lt;code&gt;os.fsync(f.fileno())&lt;/code&gt; 를 수행 하여 &lt;em&gt;f&lt;/em&gt; 와 연관된 모든 내부 버퍼 가 디스크에 기록되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="d778b78bee2934d35641a5cafddaed1a351d977e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting with a buffered Python &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;, first do &lt;code&gt;f.flush()&lt;/code&gt;, and then do &lt;code&gt;os.fsync(f.fileno())&lt;/code&gt;, to ensure that all internal buffers associated with &lt;em&gt;f&lt;/em&gt; are written to disk.</source>
          <target state="translated">버퍼링 된 Python &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;f로&lt;/em&gt; 시작하는 경우 먼저 &lt;code&gt;f.flush()&lt;/code&gt; 를 수행 한 다음 &lt;code&gt;os.fsync(f.fileno())&lt;/code&gt; 를 수행 하여 &lt;em&gt;f&lt;/em&gt; 와 관련된 모든 내부 버퍼 가 디스크에 기록되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c32e5e3d701ca2fc3b2aabba2d5788af273dfeb3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve never used this module before or just aren&amp;rsquo;t sure which class is right for your task, &lt;a href=&quot;#pathlib.Path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; is most likely what you need. It instantiates a &lt;a href=&quot;#concrete-paths&quot;&gt;concrete path&lt;/a&gt; for the platform the code is running on.</source>
          <target state="translated">이전에이 모듈을 사용한 적이 없거나 어떤 클래스가 작업에 적합한 지 확실하지 않은 경우 &lt;a href=&quot;#pathlib.Path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 가 가장 필요할 것입니다. 코드가 실행되는 플랫폼의 &lt;a href=&quot;#concrete-paths&quot;&gt;구체적인 경로&lt;/a&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="f33f0fe74a1d8aa8c68e244e2bc5362d95964bbf" translate="yes" xml:space="preserve">
          <source>If your application depends on a package that includes a C extension, that package cannot be run from a zip file (this is an OS limitation, as executable code must be present in the filesystem for the OS loader to load it). In this case, you can exclude that dependency from the zipfile, and either require your users to have it installed, or ship it alongside your zipfile and add code to your &lt;code&gt;__main__.py&lt;/code&gt; to include the directory containing the unzipped module in &lt;code&gt;sys.path&lt;/code&gt;. In this case, you will need to make sure to ship appropriate binaries for your target architecture(s) (and potentially pick the correct version to add to &lt;code&gt;sys.path&lt;/code&gt; at runtime, based on the user&amp;rsquo;s machine).</source>
          <target state="translated">응용 프로그램이 C 확장을 포함하는 패키지에 의존하는 경우 해당 패키지는 zip 파일에서 실행할 수 없습니다 (OS 로더가로드 할 수 있도록 파일 시스템에 실행 코드가 있어야하므로 OS 제한 사항 임). 이 경우 zip 파일에서 해당 종속성을 제외하고 사용자가 파일을 설치하도록 요구하거나 zip 파일과 함께 제공하고 &lt;code&gt;__main__.py&lt;/code&gt; 에 코드를 추가 하여 &lt;code&gt;sys.path&lt;/code&gt; 에 압축 해제 된 모듈을 포함하는 디렉토리를 포함시킬 수 있습니다. 이 경우 대상 아키텍처에 적합한 바이너리를 제공해야합니다 (그리고 사용자 컴퓨터를 기반으로 런타임 에 &lt;code&gt;sys.path&lt;/code&gt; 에 추가 할 올바른 버전을 선택해야합니다 ).</target>
        </trans-unit>
        <trans-unit id="2a11020c14c0b00c5484221191c5a40664dd44bf" translate="yes" xml:space="preserve">
          <source>If your application doesn&amp;rsquo;t care whether the parameter was encoded as in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;, you can collapse the parameter value by calling &lt;a href=&quot;email.utils#email.utils.collapse_rfc2231_value&quot;&gt;&lt;code&gt;email.utils.collapse_rfc2231_value()&lt;/code&gt;&lt;/a&gt;, passing in the return value from &lt;a href=&quot;#email.message.Message.get_param&quot;&gt;&lt;code&gt;get_param()&lt;/code&gt;&lt;/a&gt;. This will return a suitably decoded Unicode string when the value is a tuple, or the original string unquoted if it isn&amp;rsquo;t. For example:</source>
          <target state="translated">응용 프로그램이 매개 변수에로 인코딩되었는지 여부를 상관하지 않는 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; , 당신이 호출하여 매개 변수 값을 축소 할 수 있습니다 &lt;a href=&quot;email.utils#email.utils.collapse_rfc2231_value&quot;&gt; &lt;code&gt;email.utils.collapse_rfc2231_value()&lt;/code&gt; &lt;/a&gt; 에서 반환 값을 전달 &lt;a href=&quot;#email.message.Message.get_param&quot;&gt; &lt;code&gt;get_param()&lt;/code&gt; &lt;/a&gt; . 값이 튜플 일 때 적절하게 디코딩 된 유니 코드 문자열을 반환하거나 그렇지 않은 경우 원래 문자열을 따옴표로 묶지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7027931b44d28707bd4c664ebc8956c5af833c14" translate="yes" xml:space="preserve">
          <source>If your application needs specific settings, you should create a &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; and apply the settings yourself.</source>
          <target state="translated">애플리케이션에 특정 설정이 필요한 경우 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; 를&lt;/a&gt; 작성 하고 설정을 직접 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5edf794d03c4b2ffd7486fd7e128bf5e002387d1" translate="yes" xml:space="preserve">
          <source>If your generator will only yield values, set the &lt;code&gt;SendType&lt;/code&gt; and &lt;code&gt;ReturnType&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">생성기가 값만 산출하는 경우 &lt;code&gt;SendType&lt;/code&gt; 및 &lt;code&gt;ReturnType&lt;/code&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a6fc9f504fb9ac47a5e232ec8b3e5d967c1d094" translate="yes" xml:space="preserve">
          <source>If your generator will only yield values, set the &lt;code&gt;SendType&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">생성기가 값만 산출하는 경우 &lt;code&gt;SendType&lt;/code&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae8a1702501d5b127615e973ca97f9e761c7eb59" translate="yes" xml:space="preserve">
          <source>If your operating system supports the &lt;code&gt;select()&lt;/code&gt; system call in its I/O library (and nearly all do), then you can use it to juggle multiple communication channels at once; doing other work while your I/O is taking place in the &amp;ldquo;background.&amp;rdquo; Although this strategy can seem strange and complex, especially at first, it is in many ways easier to understand and control than multi-threaded programming. The &lt;a href=&quot;#module-asyncore&quot;&gt;&lt;code&gt;asyncore&lt;/code&gt;&lt;/a&gt; module solves many of the difficult problems for you, making the task of building sophisticated high-performance network servers and clients a snap. For &amp;ldquo;conversational&amp;rdquo; applications and protocols the companion &lt;a href=&quot;asynchat#module-asynchat&quot;&gt;&lt;code&gt;asynchat&lt;/code&gt;&lt;/a&gt; module is invaluable.</source>
          <target state="translated">운영 체제가 I / O 라이브러리에서 &lt;code&gt;select()&lt;/code&gt; 시스템 호출을 지원하는 경우 (그리고 거의 모든 경우) 여러 통신 채널을 한 번에 저글링하는 데 사용할 수 있습니다. &quot;배경&quot;에서 I / O가 진행되는 동안 다른 작업을 수행합니다. 이 전략은 특히 처음에는 이상하고 복잡해 보이지만 여러 스레드 프로그래밍보다 이해하고 제어하는 ​​것이 더 쉽습니다. &lt;a href=&quot;#module-asyncore&quot;&gt; &lt;code&gt;asyncore&lt;/code&gt; 의&lt;/a&gt; 모듈은 정교한 고성능 네트워크 서버와 클라이언트에게 스냅을 구축하는 작업을, 당신을 위해 어려운 많은 문제를 해결합니다. &quot;대화식&quot;애플리케이션 및 프로토콜의 경우 동반자 &lt;a href=&quot;asynchat#module-asynchat&quot;&gt; &lt;code&gt;asynchat&lt;/code&gt; &lt;/a&gt; 모듈은 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="955a544f9e1d26fd1d26d80d1022f0327fd7582e" translate="yes" xml:space="preserve">
          <source>If your program needs to support many languages at the same time, you may want to create multiple translation instances and then switch between them explicitly, like so:</source>
          <target state="translated">프로그램이 동시에 여러 언어를 지원해야하는 경우 여러 번역 인스턴스를 만든 다음 다음과 같이 명시 적으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93490801dea0da95308cb5a5318fbdcbabcfcf7b" translate="yes" xml:space="preserve">
          <source>If your script does not have any syntax errors, try adding &lt;code&gt;import cgitb;
cgitb.enable()&lt;/code&gt; to the top of the script.</source>
          <target state="translated">스크립트에 구문 오류가 없으면 &lt;code&gt;import cgitb; cgitb.enable()&lt;/code&gt; 추가하십시오 . cgitb.enable () 을 스크립트 상단으로</target>
        </trans-unit>
        <trans-unit id="f31cb37df73b3125c3f57c9d809d3e1ed793e729" translate="yes" xml:space="preserve">
          <source>If your server supports the command, &lt;a href=&quot;#ftplib.FTP.mlsd&quot;&gt;&lt;code&gt;mlsd()&lt;/code&gt;&lt;/a&gt; offers a better API.</source>
          <target state="translated">서버가 명령을 지원하면 &lt;a href=&quot;#ftplib.FTP.mlsd&quot;&gt; &lt;code&gt;mlsd()&lt;/code&gt; &lt;/a&gt; 가 더 나은 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cbbc5ab274a4717efc6cc381b10937fbe7d77265" translate="yes" xml:space="preserve">
          <source>If zero or more characters at the &lt;em&gt;beginning&lt;/em&gt; of &lt;em&gt;string&lt;/em&gt; match this regular expression, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 의 &lt;em&gt;시작 부분&lt;/em&gt; 에 0 개 이상의 문자 가이 정규식과 일치하면 해당하는 &lt;a href=&quot;#match-objects&quot;&gt;일치 오브젝트를&lt;/a&gt; 리턴하십시오 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b4350db35f3b9bbabeaa05f2baf19f9fc617cb2" translate="yes" xml:space="preserve">
          <source>If zero or more characters at the beginning of &lt;em&gt;string&lt;/em&gt; match the regular expression &lt;em&gt;pattern&lt;/em&gt;, return a corresponding &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt;. Return &lt;code&gt;None&lt;/code&gt; if the string does not match the pattern; note that this is different from a zero-length match.</source>
          <target state="translated">&lt;em&gt;문자열&lt;/em&gt; 의 시작 부분에 0 개 이상의 문자가 정규식 &lt;em&gt;패턴 &lt;/em&gt;&lt;a href=&quot;#match-objects&quot;&gt;과 일치&lt;/a&gt; 하면 해당하는 일치 객체를 반환 합니다 . 돌아 오지 &lt;code&gt;None&lt;/code&gt; 문자열이 패턴과 일치하지 않는 경우, 이것은 길이가 0 인 일치와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="092f14f1f8cb7d25b3e6d70dcd0a46d04a6819c6" translate="yes" xml:space="preserve">
          <source>If, that is, we ignore the effects of Relativity</source>
          <target state="translated">만약 우리가 상대성의 영향을 무시한다면</target>
        </trans-unit>
        <trans-unit id="2fa5b809a29b75e222e19a786786494e855b9b8b" translate="yes" xml:space="preserve">
          <source>If, when coding a module for general use, you need a locale independent version of an operation that is affected by the locale (such as certain formats used with &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt;), you will have to find a way to do it without using the standard library routine. Even better is convincing yourself that using locale settings is okay. Only as a last resort should you document that your module is not compatible with non-&lt;code&gt;C&lt;/code&gt; locale settings.</source>
          <target state="translated">일반적인 용도로 모듈을 코딩 할 때 로케일의 영향을받는 로케일 독립적 인 버전의 작업이 필요한 경우 (예 : &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 과 함께 사용되는 특정 형식 ), 표준 라이브러리 루틴을 사용합니다. 로케일 설정을 사용하는 것이 좋습니다. 최후의 수단으로 만 모듈이 &lt;code&gt;C&lt;/code&gt; 이외의 로케일 설정 과 호환되지 않는다는 것을 문서화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9964433f6a0266bdf9fa6725a19e41fef8b37330" translate="yes" xml:space="preserve">
          <source>If/how &lt;em&gt;atTime&lt;/em&gt; is used</source>
          <target state="translated">&lt;em&gt;at&lt;/em&gt; / how &lt;em&gt;atTime&lt;/em&gt; 이 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="1c210c82683143a51cb6e3ad028c9f8883a010ad" translate="yes" xml:space="preserve">
          <source>Ignore all modules and packages in the named directory and subdirectories. The argument can be a list of directories separated by &lt;a href=&quot;os#os.pathsep&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">명명 된 디렉토리 및 하위 디렉토리에있는 모든 모듈과 패키지를 무시하십시오. 인수는 &lt;a href=&quot;os#os.pathsep&quot;&gt; &lt;code&gt;os.pathsep&lt;/code&gt; 로&lt;/a&gt; 구분 된 디렉토리 목록 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fce84b920d19c50aa58d91da2a36c60b8c2de65" translate="yes" xml:space="preserve">
          <source>Ignore cookies in Set-Cookie: headers that have names starting with &lt;code&gt;'$'&lt;/code&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;'$'&lt;/code&gt; 로 시작하는 Set-Cookie : 헤더의 쿠키는 무시하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2855bf1eb59ace3c404c75993cf42a4581a04c3" translate="yes" xml:space="preserve">
          <source>Ignore each of the given module names and its submodules (if it is a package). The argument can be a list of names separated by a comma.</source>
          <target state="translated">주어진 각 모듈 이름과 하위 모듈 (패키지 인 경우)을 무시하십시오. 인수는 쉼표로 구분 된 이름 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d22e72dfca7f1eccbdaea639b681b1107c6155b3" translate="yes" xml:space="preserve">
          <source>Ignore symlinks pointing outside the given directory.</source>
          <target state="translated">주어진 디렉토리 외부를 가리키는 심볼릭 링크는 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="930fbf8a76be290144b9247e218920a109183ddb" translate="yes" xml:space="preserve">
          <source>Ignore the malformed data and continue without further notice. Implemented in &lt;a href=&quot;#codecs.ignore_errors&quot;&gt;&lt;code&gt;ignore_errors()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잘못된 데이터는 무시하고 추가 통지없이 계속 진행하십시오. &lt;a href=&quot;#codecs.ignore_errors&quot;&gt; &lt;code&gt;ignore_errors()&lt;/code&gt; &lt;/a&gt; 에서 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="78fee1435d74666b84850cd5e82c18229351da5d" translate="yes" xml:space="preserve">
          <source>Ignored</source>
          <target state="translated">Ignored</target>
        </trans-unit>
        <trans-unit id="b30440d1e9dd87dae90b9f8d3aaae5ca500551e0" translate="yes" xml:space="preserve">
          <source>Ignored by the default warning filters, except in the &lt;code&gt;__main__&lt;/code&gt; module (&lt;a href=&quot;https://www.python.org/dev/peps/pep-0565&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;PEP 565&lt;/strong&gt;&lt;/a&gt;). Enabling the &lt;a href=&quot;devmode#devmode&quot;&gt;Python Development Mode&lt;/a&gt; shows this warning.</source>
          <target state="translated">&lt;code&gt;__main__&lt;/code&gt; 모듈 ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-0565&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;PEP 565&lt;/strong&gt;&lt;/a&gt; )을 제외하고 기본 경고 필터에 의해 무시됩니다 . &lt;a href=&quot;devmode#devmode&quot;&gt;Python 개발 모드를&lt;/a&gt; 활성화하면 이 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e4a51ffc3d539875d40be96f2779ae79c4c16a61" translate="yes" xml:space="preserve">
          <source>Ignored by the default warning filters. Enabling the &lt;a href=&quot;devmode#devmode&quot;&gt;Python Development Mode&lt;/a&gt; shows this warning.</source>
          <target state="translated">기본 경고 필터에서 무시됩니다. &lt;a href=&quot;devmode#devmode&quot;&gt;Python 개발 모드를&lt;/a&gt; 활성화하면 이 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e65bb4eca2d3c71529c96890a4b735eb7dafeac" translate="yes" xml:space="preserve">
          <source>Ignored.</source>
          <target state="translated">Ignored.</target>
        </trans-unit>
        <trans-unit id="b90e620c5d88940bfdd404823e410652bfa5a956" translate="yes" xml:space="preserve">
          <source>Ignoring the timeout feature, calling this method is roughly equivalent to writing:</source>
          <target state="translated">시간 초과 기능을 무시하고이 메소드를 호출하는 것은 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">잘못된 바이트 시퀀스</target>
        </trans-unit>
        <trans-unit id="50fbe4bdce881188b73937ba1a6e17e22e879c8e" translate="yes" xml:space="preserve">
          <source>Illegal instruction.</source>
          <target state="translated">불법 지시.</target>
        </trans-unit>
        <trans-unit id="3176fdb344f7026fb9cd9da003d83547cd35fc12" translate="yes" xml:space="preserve">
          <source>Illegal seek</source>
          <target state="translated">불법 탐색</target>
        </trans-unit>
        <trans-unit id="e221fe5a3e6f4ff124e28b73d70e7afa9ab3f313" translate="yes" xml:space="preserve">
          <source>Image Types</source>
          <target state="translated">이미지 타입</target>
        </trans-unit>
        <trans-unit id="c177d6ae70be09c0df8491f4bb934a1ebcbac143" translate="yes" xml:space="preserve">
          <source>Image format</source>
          <target state="translated">이미지 형식</target>
        </trans-unit>
        <trans-unit id="42de00097c89c82d17336b2d87ec32e4f21480ff" translate="yes" xml:space="preserve">
          <source>Image shapes &lt;em&gt;do not&lt;/em&gt; rotate when turning the turtle, so they do not display the heading of the turtle!</source>
          <target state="translated">거북이를 돌릴 때 이미지 모양 &lt;em&gt;이&lt;/em&gt; 회전 &lt;em&gt;하지 않으므로&lt;/em&gt; 거북이 방향을 표시하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="70b3cbc7767df833fa045e36e82910b275002110" translate="yes" xml:space="preserve">
          <source>Images of different formats can be created through the corresponding subclass of &lt;code&gt;tkinter.Image&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tkinter.Image&lt;/code&gt; 의 해당 서브 클래스를 통해 다른 형식의 이미지를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a13a369729af2332fed8dda8e39f614910984143" translate="yes" xml:space="preserve">
          <source>Imagine a robotic turtle starting at (0, 0) in the x-y plane. After an &lt;code&gt;import turtle&lt;/code&gt;, give it the command &lt;code&gt;turtle.forward(15)&lt;/code&gt;, and it moves (on-screen!) 15 pixels in the direction it is facing, drawing a line as it moves. Give it the command &lt;code&gt;turtle.right(25)&lt;/code&gt;, and it rotates in-place 25 degrees clockwise.</source>
          <target state="translated">xy 비행기에서 (0, 0)에서 시작하는 로봇 거북이를 상상해보십시오. &lt;code&gt;import turtle&lt;/code&gt; 후, &lt;code&gt;turtle.forward(15)&lt;/code&gt; 명령을 내리면 , 화면을 향한 방향으로 15 픽셀 움직여서 화면에 움직이는 선을 그립니다. &lt;code&gt;turtle.right(25)&lt;/code&gt; 명령을 내리면 시계 방향으로 25도 회전합니다.</target>
        </trans-unit>
        <trans-unit id="687db08c82f3ad0c17cb55a8e0f53abf69ca4195" translate="yes" xml:space="preserve">
          <source>Imagine we have a project that we want to test with the following structure:</source>
          <target state="translated">다음 구조로 테스트하려는 프로젝트가 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="40c36dcfc5b7dc5aaaaa183a438e2f62f6e25008" translate="yes" xml:space="preserve">
          <source>Immediately stop playing or recording and return the device to a state where it can accept commands. The OSS documentation recommends closing and re-opening the device after calling &lt;a href=&quot;#ossaudiodev.oss_audio_device.reset&quot;&gt;&lt;code&gt;reset()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">즉시 재생 또는 녹음을 중지하고 장치를 명령을 받아 들일 수있는 상태로 되돌립니다. OSS 문서는 &lt;a href=&quot;#ossaudiodev.oss_audio_device.reset&quot;&gt; &lt;code&gt;reset()&lt;/code&gt; &lt;/a&gt; 을 호출 한 후 장치를 닫았다가 다시 열 것을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="80cb7526f8f17d0e625c37d38a71d1b8b176c45b" translate="yes" xml:space="preserve">
          <source>Immediately unwinds the callback stack, invoking callbacks in the reverse order of registration. For any context managers and exit callbacks registered, the arguments passed in will indicate that no exception occurred.</source>
          <target state="translated">콜백 스택을 즉시 풀고 등록 순서와 반대로 콜백을 호출합니다. 컨텍스트 관리자 및 엑시트 콜백이 등록 된 경우 전달 된 인수는 예외가 발생하지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="42e8811b32cc14bd73ca1c7cf254e434ca1c4be2" translate="yes" xml:space="preserve">
          <source>Immutable Sequence Types</source>
          <target state="translated">불변 시퀀스 타입</target>
        </trans-unit>
        <trans-unit id="7d364b632538803974da1c9485bc7401ef2fd2eb" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 프로토콜을 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="876c8f17da52cca0c2c72876d566383804f060a0" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://tools.ietf.org/html/rfc3490.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 3490&lt;/strong&gt;&lt;/a&gt;, see also &lt;a href=&quot;#module-encodings.idna&quot;&gt;&lt;code&gt;encodings.idna&lt;/code&gt;&lt;/a&gt;. Only &lt;code&gt;errors='strict'&lt;/code&gt; is supported.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3490.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 3490을&lt;/strong&gt;&lt;/a&gt; 구현 하십시오 ( &lt;a href=&quot;#module-encodings.idna&quot;&gt; &lt;code&gt;encodings.idna&lt;/code&gt; &lt;/a&gt; 참조) . 만 &lt;code&gt;errors='strict'&lt;/code&gt; 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4dbe2ee30f05a84b86d098b6ad21ef61bde254e0" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;https://tools.ietf.org/html/rfc3492.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 3492&lt;/strong&gt;&lt;/a&gt;. Stateful codecs are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3492.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 3492를&lt;/strong&gt;&lt;/a&gt; 구현하십시오 . 상태 저장 코덱은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb9ce8751f48a6114c443a4bb2aac9cb2915809a" translate="yes" xml:space="preserve">
          <source>Implement Netscape protocol.</source>
          <target state="translated">Netscape 프로토콜을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed133685773097940d3cf663208ebc50eb17709" translate="yes" xml:space="preserve">
          <source>Implement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; that was passed to vformat. The set of unused args can be calculated from these parameters. &lt;a href=&quot;#string.Formatter.check_unused_args&quot;&gt;&lt;code&gt;check_unused_args()&lt;/code&gt;&lt;/a&gt; is assumed to raise an exception if the check fails.</source>
          <target state="translated">원하는 경우 사용하지 않는 인수 검사를 구현하십시오. 이 함수의 인수가 실제로 (라는 인수 위치 인수 정수 및 문자열) 형식 문자열에 언급 된 모든 인자 키 세트, 및에 대한 참조 &lt;em&gt;인수&lt;/em&gt; 및 &lt;em&gt;kwargs로&lt;/em&gt; vformat에 전달 하였다. 사용되지 않은 인수 세트는이 매개 변수에서 계산할 수 있습니다. &lt;a href=&quot;#string.Formatter.check_unused_args&quot;&gt; &lt;code&gt;check_unused_args()&lt;/code&gt; &lt;/a&gt; 는 검사가 실패하면 예외를 발생시키는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fd8c27461faf491446b966e22536bdd5517a900e" translate="yes" xml:space="preserve">
          <source>Implement this method in a subclass such that it returns a serializable object for &lt;em&gt;o&lt;/em&gt;, or calls the base implementation (to raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">서브 클래스에서이 메소드를 구현하여 &lt;em&gt;o&lt;/em&gt; 에 대한 직렬화 가능 오브젝트를 리턴 하거나 기본 구현을 호출하여 ( &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 발생&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6372052045f8af6340009762eb4a097bf006bc91" translate="yes" xml:space="preserve">
          <source>Implementation Limitations</source>
          <target state="translated">구현 한계</target>
        </trans-unit>
        <trans-unit id="a928eb642e8d69164143d07e134772861cb6056c" translate="yes" xml:space="preserve">
          <source>Implementation note: Some of the mixin methods, such as &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__reversed__&quot;&gt;&lt;code&gt;__reversed__()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;index()&lt;/code&gt;, make repeated calls to the underlying &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; method. Consequently, if &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; is implemented with constant access speed, the mixin methods will have linear performance; however, if the underlying method is linear (as it would be with a linked list), the mixins will have quadratic performance and will likely need to be overridden.</source>
          <target state="translated">구현 참고 사항 : &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__reversed__&quot;&gt; &lt;code&gt;__reversed__()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;index()&lt;/code&gt; 와 같은 일부 믹스 인 메소드 는 기본 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 메소드 를 반복적으로 호출합니다 . 결과적으로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 이 일정한 액세스 속도로 구현되면 mixin 메소드는 선형 성능을 갖습니다. 그러나 기본 방법이 선형 인 경우 (링크 된 목록과 마찬가지로) 믹스 인은 2 차 성능을 가지며 재정의해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cbceb2272fc90a9136eaf0b5779494a174c66fa" translate="yes" xml:space="preserve">
          <source>Implementation note: Some of the mixin methods, such as &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__reversed__&quot;&gt;&lt;code&gt;__reversed__()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;index()&lt;/code&gt;, make repeated calls to the underlying &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; method. Consequently, if &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; is implemented with constant access speed, the mixin methods will have linear performance; however, if the underlying method is linear (as it would be with a linked list), the mixins will have quadratic performance and will likely need to be overridden.</source>
          <target state="translated">구현 참고 사항 : &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__reversed__&quot;&gt; &lt;code&gt;__reversed__()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;index()&lt;/code&gt; 와 같은 일부 믹스 인 메서드 는 기본 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 메서드 를 반복적으로 호출합니다 . 결과적으로 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 이 일정한 액세스 속도로 구현되면 mixin 메서드는 선형 성능을 갖습니다. 그러나 기본 방법이 선형 인 경우 (연결된 목록에서와 같이) 믹스 인은 2 차 성능을 가지며 재정의해야 할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="602e467a96a4864b3e865c151d6768f89e1f6c9a" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;Loader.exec_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현 &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;Loader.exec_module()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b24035207ed54bd400485a1684e18bf3533d78a" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;a href=&quot;#importlib.abc.Loader.load_module&quot;&gt;&lt;code&gt;Loader.load_module()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구현 &lt;a href=&quot;#importlib.abc.Loader.load_module&quot;&gt; &lt;code&gt;Loader.load_module()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20977e3c93bce44f3af2c831893e3343efa9bf7c" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;process_message&lt;/code&gt; should use the &lt;code&gt;**kwargs&lt;/code&gt; signature to accept arbitrary keyword arguments, since future feature enhancements may add keys to the kwargs dictionary.</source>
          <target state="translated">향후의 기능 향상으로 kwargs 사전에 키가 추가 될 수 있으므로 &lt;code&gt;process_message&lt;/code&gt; 구현 에서는 &lt;code&gt;**kwargs&lt;/code&gt; 서명을 사용하여 임의의 키워드 인수를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d8b1b41137285f8c4de39c176a278d9f49ddf2e" translate="yes" xml:space="preserve">
          <source>Implementing the arithmetic operations</source>
          <target state="translated">산술 연산 구현</target>
        </trans-unit>
        <trans-unit id="ca6c4d83cb31522562758f2caae6de20eb026979" translate="yes" xml:space="preserve">
          <source>Implementors should be careful to make equal numbers equal and hash them to the same values. This may be subtle if there are two different extensions of the real numbers. For example, &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; as follows:</source>
          <target state="translated">구현자는 동일한 숫자를 동일하게 만들고 동일한 값으로 해시하도록주의해야합니다. 실수의 두 가지 다른 확장이있는 경우 미묘 할 수 있습니다. 예를 들어 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt; 은 다음과 같이 &lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt; 를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="d903524c1ea6aa12c931b0a6c641b3778b3888a8" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;PUSH(get_awaitable(TOS.__anext__()))&lt;/code&gt;. See &lt;code&gt;GET_AWAITABLE&lt;/code&gt; for details about &lt;code&gt;get_awaitable&lt;/code&gt;</source>
          <target state="translated">구현은 &lt;code&gt;PUSH(get_awaitable(TOS.__anext__()))&lt;/code&gt; . &lt;code&gt;GET_AWAITABLE&lt;/code&gt; 대한 자세한 내용은 &lt;code&gt;get_awaitable&lt;/code&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3cb421f905057ea14812c7d7b55740f7dcb3aa14" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = +TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = +TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="9f8030dd288cf838d962bc81cf0b1e710e59dab6" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = -TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = -TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="23caf167f55ab86f7acf8ef10a08029547ccae56" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS.__aiter__()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS.__aiter__()&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6804ffbe6ca6db0446550f606e8c3b827c72019d" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1ccd836db2748a42cdb6568840d6b34ab7680997" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="98b212dadbaf80fff0c651d73234d968ff6d57ff" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a92a967387ba75f1c824f8c282c1b389323c1c12" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="fe06b1264a086dd70cc373eb95043d5b61c0bdec" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e7727e8610b32769f888b796569df51894a6e1a4" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a68a686d5d97ef25da29ba50188cfe812c2b160c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="0b7f98171174dff07ba4794fcfc188a2b547babd" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e03d1b043f5b83ce06f326b9be67568ba2593f09" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="54632e771c9265cca4e71a87f0788919f6c1a468" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b4ff4094536277707470df447fbf4ac881111c43" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="70062ec736c872ff9695663f40f72ab315ef9ddf" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="ed9a0b5ebb7afed19c96ac5e2a783c31cb5f2376" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt; 구현 | TOS .</target>
        </trans-unit>
        <trans-unit id="a435cd9e0a8ca34e1604fda39f5b0f09b410d773" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = TOS1[TOS]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = TOS1[TOS]&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="a55222ca989584dee87037902ae61c754d1433ea" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = get_awaitable(TOS)&lt;/code&gt;, where &lt;code&gt;get_awaitable(o)&lt;/code&gt; returns &lt;code&gt;o&lt;/code&gt; if &lt;code&gt;o&lt;/code&gt; is a coroutine object or a generator object with the CO_ITERABLE_COROUTINE flag, or resolves &lt;code&gt;o.__await__&lt;/code&gt;.</source>
          <target state="translated">이물질 &lt;code&gt;TOS = get_awaitable(TOS)&lt;/code&gt; , 여기서 &lt;code&gt;get_awaitable(o)&lt;/code&gt; 복귀 &lt;code&gt;o&lt;/code&gt; 경우 &lt;code&gt;o&lt;/code&gt; 코 루틴 개체 또는 CO_ITERABLE_COROUTINE 플래그 생성기 개체 또는 리졸이다 &lt;code&gt;o.__await__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e24956a48bbfdcc09d0cf754f3dad5634e36ef6" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = iter(TOS)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = iter(TOS)&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7127e3da317dbd834e1c9fa4d150709b0595c38c" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = not TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = not TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6aefd62fa0df0b5ae152afef20eb6a2be7bc7fe1" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS = ~TOS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS = ~TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4f729d424456b44dfd8d226e0748fec98a45f659" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS.name = TOS1&lt;/code&gt;, where &lt;em&gt;namei&lt;/em&gt; is the index of name in &lt;code&gt;co_names&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS.name = TOS1&lt;/code&gt; 구현합니다 . 여기서 &lt;em&gt;namei&lt;/em&gt; 는 &lt;code&gt;co_names&lt;/code&gt; 의 이름 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="f7674022864a24bfc63ce8ce10c8db53e65eff9f" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;TOS1[TOS] = TOS2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TOS1[TOS] = TOS2&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="47c788dc833478a625bb744ec09e58aea9fc10d4" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;del TOS.name&lt;/code&gt;, using &lt;em&gt;namei&lt;/em&gt; as index into &lt;code&gt;co_names&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;namei&lt;/em&gt; 를 &lt;code&gt;co_names&lt;/code&gt; 의 색인으로 사용하여 &lt;code&gt;del TOS.name&lt;/code&gt; 을 구현 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab97a7e60a0b065d453ed23af196b35ed6d71cfd" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;del TOS1[TOS]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;del TOS1[TOS]&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c6cb3ef10de23ff06b085fdd4bd8df8cca8edb2e" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;del name&lt;/code&gt;, where &lt;em&gt;namei&lt;/em&gt; is the index into &lt;code&gt;co_names&lt;/code&gt; attribute of the code object.</source>
          <target state="translated">&lt;code&gt;del name&lt;/code&gt; 을 구현합니다 . 여기서 &lt;em&gt;namei&lt;/em&gt; 는 코드 객체의 &lt;code&gt;co_names&lt;/code&gt; 속성에 대한 색인 입니다.</target>
        </trans-unit>
        <trans-unit id="0e9bf63b19593d04613e29b26ddb368205c21880" translate="yes" xml:space="preserve">
          <source>Implements &lt;code&gt;name = TOS&lt;/code&gt;. &lt;em&gt;namei&lt;/em&gt; is the index of &lt;em&gt;name&lt;/em&gt; in the attribute &lt;code&gt;co_names&lt;/code&gt; of the code object. The compiler tries to use &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt;&lt;code&gt;STORE_FAST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#opcode-STORE_GLOBAL&quot;&gt;&lt;code&gt;STORE_GLOBAL&lt;/code&gt;&lt;/a&gt; if possible.</source>
          <target state="translated">&lt;code&gt;name = TOS&lt;/code&gt; 구현합니다 . &lt;em&gt;namei&lt;/em&gt; 는 코드 객체의 &lt;code&gt;co_names&lt;/code&gt; 속성에있는 &lt;em&gt;이름&lt;/em&gt; 의 색인입니다 . 컴파일러는 가능하면 &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt; &lt;code&gt;STORE_FAST&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#opcode-STORE_GLOBAL&quot;&gt; &lt;code&gt;STORE_GLOBAL&lt;/code&gt; &lt;/a&gt; 을 사용하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="3bb12d25ddb30f12352643b960eb58634dcff262" translate="yes" xml:space="preserve">
          <source>Implements a mutex lock for asyncio tasks. Not thread-safe.</source>
          <target state="translated">비동기 작업을위한 뮤텍스 잠금을 구현합니다. 스레드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f127d7511ab821d90fc0d9e0415de725710e1c0e" translate="yes" xml:space="preserve">
          <source>Implements assignment with a starred target: Unpacks an iterable in TOS into individual values, where the total number of values can be smaller than the number of items in the iterable: one of the new values will be a list of all leftover items.</source>
          <target state="translated">별표로 표시된 대상으로 할당을 구현합니다. TOS에서 반복 가능한 항목을 개별 값으로 압축 해제합니다. 여기서 총 값 수는 반복 가능한 항목 수보다 작을 수 있습니다. 새 값 중 하나는 남은 모든 항목의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ad8c71c60917e28ec70cc6e72ac5aba785cd2533" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt;.</source>
          <target state="translated">전체 &lt;code&gt;TOS = TOS1 % TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="34a2e00a28f9e41709e5a409debe9f70047ccfa5" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 &amp;amp; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="58c41048e48b098a8662937aa13eba0fb458de61" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 &amp;gt;&amp;gt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="fa04e754a31d6027a7f4daa4b4fdd702965038b1" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 &amp;lt;&amp;lt; TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="1ee8bdd10bfb59d1de1b7233652a10a6aebf648c" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 * TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="239c416c5552e24e40b0c3f5a8da8834a4549b9c" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt;.</source>
          <target state="translated">현재 위치 &lt;code&gt;TOS = TOS1 ** TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b92e466e855a22dcee87a299d9f506bd0bd45e91" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 + TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e4a87fbd97f23bdda16b8cf5fe0fe1fd3bb5bef6" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 - TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6b26e08c65cff3d8460f7b64f132529ac3dc22be" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 / TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="44d86e1dd26553b877ecf8c640b2c2b6832071f1" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 위치에 &lt;code&gt;TOS = TOS1 // TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b416ab2beeb3c3d6516c059eeb07d58936d0e6df" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 @ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="e9962e5508639fbb25594a1f43d3b5f76b2afc27" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt;.</source>
          <target state="translated">적절한 &lt;code&gt;TOS = TOS1 ^ TOS&lt;/code&gt; 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="3896caff55805b902dd285f3c899f9096710e046" translate="yes" xml:space="preserve">
          <source>Implements in-place &lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt;.</source>
          <target state="translated">내부 구현 &lt;code&gt;TOS = TOS1 | TOS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85bad2fb59570e2a5eef60329848ed4622403300" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'backslashreplace'&lt;/code&gt; error handling (for &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): malformed data is replaced by a backslashed escape sequence.</source>
          <target state="translated">&lt;code&gt;'backslashreplace'&lt;/code&gt; 대체 ' 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 에만 해당). 잘못된 형식의 데이터는 백 슬래시 이스케이프 시퀀스로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="3972f7d57316db3c0510f582bfb45840e982174e" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'backslashreplace'&lt;/code&gt; error handling (for &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): malformed data is replaced by a backslashed escape sequence.</source>
          <target state="translated">&lt;code&gt;'backslashreplace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 전용) : 잘못된 형식의 데이터는 백 슬래시 이스케이프 시퀀스로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c10a6bbb7422a691823579f3081bab9b0e71d9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'ignore'&lt;/code&gt; error handling: malformed data is ignored and encoding or decoding is continued without further notice.</source>
          <target state="translated">&lt;code&gt;'ignore'&lt;/code&gt; 오류 처리를 구현합니다 . 잘못된 형식의 데이터는 무시되고 추가 통지없이 인코딩 또는 디코딩이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d23f24683ac08882aaa07d91874ed6ef4c6dd2" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'namereplace'&lt;/code&gt; error handling (for encoding with &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): the unencodable character is replaced by a &lt;code&gt;\N{...}&lt;/code&gt; escape sequence.</source>
          <target state="translated">&lt;code&gt;'namereplace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩으로 인코딩하는&lt;/a&gt; 경우에만 해당). 불가피한 문자는 &lt;code&gt;\N{...}&lt;/code&gt; 이스케이프 시퀀스 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="146edfb679a3a850e62b2106533b0b8a80465bec" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'namereplace'&lt;/code&gt; error handling (for encoding with &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): the unencodable character is replaced by a &lt;code&gt;\N{...}&lt;/code&gt; escape sequence.</source>
          <target state="translated">&lt;code&gt;'namereplace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;텍스트&lt;/a&gt; 인코딩을 사용한 인코딩 에만 해당) : 인코딩 할 수없는 문자는 &lt;code&gt;\N{...}&lt;/code&gt; 이스케이프 시퀀스 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="663edbb12a782a964e38e6f015a8ae61e59c5cb6" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'replace'&lt;/code&gt; error handling (for &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): substitutes &lt;code&gt;'?'&lt;/code&gt; for encoding errors (to be encoded by the codec), and &lt;code&gt;'\ufffd'&lt;/code&gt; (the Unicode replacement character) for decoding errors.</source>
          <target state="translated">&lt;code&gt;'replace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 에만 해당) : &lt;code&gt;'?'&lt;/code&gt; 대체 인코딩 오류 (코덱으로 인코딩) 및 오류 디코딩을위한 &lt;code&gt;'\ufffd'&lt;/code&gt; (유니 코드 대체 문자)</target>
        </trans-unit>
        <trans-unit id="ecc4389e49af9fb077022493ee402ac0f38b7c02" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'replace'&lt;/code&gt; error handling (for &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): substitutes &lt;code&gt;'?'&lt;/code&gt; for encoding errors (to be encoded by the codec), and &lt;code&gt;'\ufffd'&lt;/code&gt; (the Unicode replacement character) for decoding errors.</source>
          <target state="translated">&lt;code&gt;'replace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 전용) : &lt;code&gt;'?'&lt;/code&gt; 를 대체합니다. 인코딩 오류 (코덱으로 인코딩 됨) 및 디코딩 오류의 경우 &lt;code&gt;'\ufffd'&lt;/code&gt; (유니 코드 대체 문자).</target>
        </trans-unit>
        <trans-unit id="a478a6a191e85196bdcece7d24cdbeb8b90bb3e4" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'strict'&lt;/code&gt; error handling: each encoding or decoding error raises a &lt;a href=&quot;exceptions#UnicodeError&quot;&gt;&lt;code&gt;UnicodeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;'strict'&lt;/code&gt; 오류 처리를 구현합니다 . 각 인코딩 또는 디코딩 오류는 &lt;a href=&quot;exceptions#UnicodeError&quot;&gt; &lt;code&gt;UnicodeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="45e09434edbbb004dd6529a8c664f47c18ec9c8a" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'xmlcharrefreplace'&lt;/code&gt; error handling (for encoding with &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): the unencodable character is replaced by an appropriate XML character reference.</source>
          <target state="translated">&lt;code&gt;'xmlcharrefreplace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-encoding&quot;&gt;텍스트 인코딩&lt;/a&gt; 만 사용 하여 인코딩하는 경우). 허용 할 수없는 문자는 적절한 XML 문자 참조로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="1fa3a0d7eb90310b93b3485af23ace408575d97f" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;'xmlcharrefreplace'&lt;/code&gt; error handling (for encoding with &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;text encodings&lt;/a&gt; only): the unencodable character is replaced by an appropriate XML character reference.</source>
          <target state="translated">&lt;code&gt;'xmlcharrefreplace'&lt;/code&gt; 오류 처리를 구현합니다 ( &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-encoding&quot;&gt;텍스트&lt;/a&gt; 인코딩을 사용한 인코딩 에만 해당) : 인코딩 할 수없는 문자는 적절한 XML 문자 참조로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="4589678f737340f266ad3c03c880cd6693ba765b" translate="yes" xml:space="preserve">
          <source>Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with &lt;a href=&quot;#opcode-POP_TOP&quot;&gt;&lt;code&gt;POP_TOP&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">대화식 모드에 대한 표현식 명령문을 구현합니다. 스택에서 TOS가 제거되어 인쇄됩니다. 비 대화식 모드에서 표현식 문은 &lt;a href=&quot;#opcode-POP_TOP&quot;&gt; &lt;code&gt;POP_TOP&lt;/code&gt; &lt;/a&gt; 으로 종료됩니다 . .</target>
        </trans-unit>
        <trans-unit id="431d2662e4cf482dbbd51ee873a2bf4d4dbe506a" translate="yes" xml:space="preserve">
          <source>Implements the standard rules for accepting and returning cookies.</source>
          <target state="translated">쿠키 수락 및 반환에 대한 표준 규칙을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="357be719dc69e352146cd9351979e2f88b18aa53" translate="yes" xml:space="preserve">
          <source>Implicit namespace packages</source>
          <target state="translated">암시 적 네임 스페이스 패키지</target>
        </trans-unit>
        <trans-unit id="3d1027d5bfea0f5b907c45a2719ba20af2951bac" translate="yes" xml:space="preserve">
          <source>Implicitly via the declared type</source>
          <target state="translated">선언 된 형식을 통해 암시 적으로</target>
        </trans-unit>
        <trans-unit id="87b9fc3f346510b76b17999f7a146e2b1534c297" translate="yes" xml:space="preserve">
          <source>Implied by a read event on a listening socket</source>
          <target state="translated">청취 소켓의 read 이벤트에 의해 암시됩니다</target>
        </trans-unit>
        <trans-unit id="4698e1d5e35f008f6196e32547364bf825c475dc" translate="yes" xml:space="preserve">
          <source>Implied by a read event with no data available</source>
          <target state="translated">사용 가능한 데이터가없는 읽기 이벤트에 의해 암시 됨</target>
        </trans-unit>
        <trans-unit id="21611d57f0838ec535115caab52079c6fc745f43" translate="yes" xml:space="preserve">
          <source>Implied by the first read or write event</source>
          <target state="translated">첫 번째 읽기 또는 쓰기 이벤트에 의해 암시</target>
        </trans-unit>
        <trans-unit id="da96b428d292acbbe72df9e50d4e769cb28b7b27" translate="yes" xml:space="preserve">
          <source>Import &lt;em&gt;module&lt;/em&gt; if necessary and return the object called &lt;em&gt;name&lt;/em&gt; from it, where the &lt;em&gt;module&lt;/em&gt; and &lt;em&gt;name&lt;/em&gt; arguments are &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects. Note, unlike its name suggests, &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt;&lt;code&gt;find_class()&lt;/code&gt;&lt;/a&gt; is also used for finding functions.</source>
          <target state="translated">필요한 경우 &lt;em&gt;모듈을&lt;/em&gt; 가져 와서 &lt;em&gt;name&lt;/em&gt; 이라는 객체를 반환합니다 . 여기서 &lt;em&gt;module&lt;/em&gt; 및 &lt;em&gt;name&lt;/em&gt; 인수는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체입니다. 이름에서 알 수 있듯이 &lt;a href=&quot;#pickle.Unpickler.find_class&quot;&gt; &lt;code&gt;find_class()&lt;/code&gt; &lt;/a&gt; 는 함수를 찾는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b52818d6d21a3617010654286ad1530ac0e14b13" translate="yes" xml:space="preserve">
          <source>Import a module. The &lt;em&gt;name&lt;/em&gt; argument specifies what module to import in absolute or relative terms (e.g. either &lt;code&gt;pkg.mod&lt;/code&gt; or &lt;code&gt;..mod&lt;/code&gt;). If the name is specified in relative terms, then the &lt;em&gt;package&lt;/em&gt; argument must be set to the name of the package which is to act as the anchor for resolving the package name (e.g. &lt;code&gt;import_module('..mod', 'pkg.subpkg')&lt;/code&gt; will import &lt;code&gt;pkg.mod&lt;/code&gt;).</source>
          <target state="translated">모듈을 가져옵니다. &lt;em&gt;이름&lt;/em&gt; 인수를 지정 절대 또는 상대 측면에서 수입에 어떤 모듈 (예를 들어, 하나 &lt;code&gt;pkg.mod&lt;/code&gt; 또는 &lt;code&gt;..mod&lt;/code&gt; ). 이름이 상대적인 용어로 지정된 경우 &lt;em&gt;패키지&lt;/em&gt; 인수는 패키지 이름을 해결하기위한 앵커 역할을하는 패키지 이름으로 설정해야합니다 (예 : &lt;code&gt;import_module('..mod', 'pkg.subpkg')&lt;/code&gt; &lt;code&gt;pkg.mod&lt;/code&gt; 를 가져옵니다 .)</target>
        </trans-unit>
        <trans-unit id="509eb07f39761a76413d728e8002d91cab5669f9" translate="yes" xml:space="preserve">
          <source>Import as few modules as possible and do it as soon as possible. This minimizes external dependencies of tests and also minimizes possible anomalous behavior from side-effects of importing a module.</source>
          <target state="translated">가능한 적은 수의 모듈을 가져 와서 최대한 빨리 수행하십시오. 이는 테스트의 외부 종속성을 최소화하고 모듈 가져 오기의 부작용으로 인한 비정상적인 동작을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="ebf453241874ae9140f1c4fba4572af23be16d96" translate="yes" xml:space="preserve">
          <source>Import itself is implemented in Python code, making it possible to expose most of the import machinery through importlib. The following helps illustrate the various APIs that importlib exposes by providing an approximate implementation of &lt;a href=&quot;#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt; (Python 3.4 and newer for the importlib usage, Python 3.6 and newer for other parts of the code).</source>
          <target state="translated">가져 오기 자체는 Python 코드로 구현되므로 importlib를 통해 대부분의 가져 오기 기계를 노출 할 수 있습니다. 다음은 &lt;a href=&quot;#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt; 의 대략적인 구현을 제공하여 importlib가 노출하는 다양한 API를 보여줍니다. .</target>
        </trans-unit>
        <trans-unit id="eb7d80557274b41c25be1de7f2b2a9c69daa9de1" translate="yes" xml:space="preserve">
          <source>Import on Case-Insensitive Platforms</source>
          <target state="translated">대소 문자를 구분하지 않는 플랫폼에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="51a0d1e201d38ceab71bb750a252b512b10de5c2" translate="yes" xml:space="preserve">
          <source>Import resolution and custom importers</source>
          <target state="translated">수입 해결 및 맞춤형 수입업자</target>
        </trans-unit>
        <trans-unit id="b46dda0f3af0f364b45aca902f93a2030e1d6cf0" translate="yes" xml:space="preserve">
          <source>Import resolution, by default, uses the builtin &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function to do its importing. You may want to replace this with your own importing mechanism: if so, you can replace the &lt;code&gt;importer&lt;/code&gt; attribute of the &lt;code&gt;DictConfigurator&lt;/code&gt; or its superclass, the &lt;code&gt;BaseConfigurator&lt;/code&gt; class. However, you need to be careful because of the way functions are accessed from classes via descriptors. If you are using a Python callable to do your imports, and you want to define it at class level rather than instance level, you need to wrap it with &lt;a href=&quot;functions#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">가져 오기 해상도는 기본적으로 내장 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 가져 오기를 수행합니다. 이를 자신의 가져 오기 메커니즘으로 바꾸고 싶을 수 있습니다. 그렇다면 &lt;code&gt;DictConfigurator&lt;/code&gt; 또는 해당 수퍼 클래스 인 &lt;code&gt;BaseConfigurator&lt;/code&gt; 클래스 의 &lt;code&gt;importer&lt;/code&gt; 속성을 바꿀 수 있습니다 . 그러나 디스크립터를 통해 클래스에서 함수에 액세스하는 방식 때문에주의해야합니다. 가져 오기를 수행하기 위해 호출 가능한 Python을 사용하고 인스턴스 레벨이 아닌 클래스 레벨에서 정의하려는 경우 &lt;a href=&quot;functions#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt; 로 랩핑해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed9b8c2261e65d838380f42dc0d920d3b56a2dfe" translate="yes" xml:space="preserve">
          <source>Import this class from the &lt;a href=&quot;#module-email.charset&quot;&gt;&lt;code&gt;email.charset&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#module-email.charset&quot;&gt; &lt;code&gt;email.charset&lt;/code&gt; &lt;/a&gt; 모듈 에서이 클래스를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="d88d4c76f774a45881449d93cfdd576af021e9ee" translate="yes" xml:space="preserve">
          <source>ImportWarning</source>
          <target state="translated">ImportWarning</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="fe0f554fef6d8bbe2bada744a7a99611cdfdc416" translate="yes" xml:space="preserve">
          <source>Importing Modules</source>
          <target state="translated">모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="7d7d20fec55d874b61e9a23d4848e2fe11f9ac1d" translate="yes" xml:space="preserve">
          <source>Importing a source file directly</source>
          <target state="translated">소스 파일을 직접 가져 오기</target>
        </trans-unit>
        <trans-unit id="c638d5fe75ce243c593fb88053ccdfc251f4221c" translate="yes" xml:space="preserve">
          <source>Importing programmatically</source>
          <target state="translated">프로그래밍 방식으로 가져 오기</target>
        </trans-unit>
        <trans-unit id="da4b6fd661f8f0ff59c6e77bf0660d2518b7404d" translate="yes" xml:space="preserve">
          <source>Importing the main class:</source>
          <target state="translated">메인 클래스 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="1ab6816ef80ddd057eefbe256b51f340873b1f96" translate="yes" xml:space="preserve">
          <source>Importing this module will append site-specific paths to the module search path and add a few builtins, unless &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; was used. In that case, this module can be safely imported with no automatic modifications to the module search path or additions to the builtins. To explicitly trigger the usual site-specific additions, call the &lt;a href=&quot;#site.main&quot;&gt;&lt;code&gt;site.main()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 모듈을 가져 오면 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 를 사용 하지 않는 한 사이트 별 경로를 모듈 검색 경로에 추가하고 몇 가지 내장을 추가합니다 . 이 경우이 모듈은 모듈 검색 경로를 자동으로 수정하거나 내장을 추가하지 않고도 안전하게 가져올 수 있습니다. 일반적인 사이트 별 추가를 명시 적으로 트리거하려면 &lt;a href=&quot;#site.main&quot;&gt; &lt;code&gt;site.main()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="6952e83bb227bfc12f4069d649cedd8e49d9af47" translate="yes" xml:space="preserve">
          <source>Importing this module will append site-specific paths to the module search path and add a few builtins, unless &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; was used. In that case, this module can be safely imported with no automatic modifications to the module search path or additions to the builtins. To explicitly trigger the usual site-specific additions, call the &lt;a href=&quot;#site.main&quot;&gt;&lt;code&gt;site.main()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 모듈을 가져 오면 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 를 사용 하지 않는 한 사이트 별 경로가 모듈 검색 경로에 추가되고 몇 가지 내장 기능이 추가 됩니다. 이 경우 모듈 검색 경로를 자동으로 수정하거나 내장 기능을 추가하지 않고도이 모듈을 안전하게 가져올 수 있습니다. 일반적인 사이트 특정 추가를 명시 적으로 트리거하려면 &lt;a href=&quot;#site.main&quot;&gt; &lt;code&gt;site.main()&lt;/code&gt; &lt;/a&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="e42328ac01cd03a47978f064c93b392caf3861f0" translate="yes" xml:space="preserve">
          <source>Imports</source>
          <target state="translated">Imports</target>
        </trans-unit>
        <trans-unit id="f16b4231e3d6ba6a1713c3f5cbbd7c9a26c500c5" translate="yes" xml:space="preserve">
          <source>Imports the module &lt;code&gt;co_names[namei]&lt;/code&gt;. TOS and TOS1 are popped and provide the &lt;em&gt;fromlist&lt;/em&gt; and &lt;em&gt;level&lt;/em&gt; arguments of &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt;. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt;&lt;code&gt;STORE_FAST&lt;/code&gt;&lt;/a&gt; instruction modifies the namespace.</source>
          <target state="translated">&lt;code&gt;co_names[namei]&lt;/code&gt; 모듈을 가져옵니다 . TOS 및 TOS1이 팝업되고 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;fromlist&lt;/em&gt; 및 &lt;em&gt;level&lt;/em&gt; 인수를 제공합니다 . 모듈 객체가 스택으로 푸시됩니다. 현재 네임 스페이스는 영향을받지 않습니다. 올바른 가져 오기 명령문의 경우 후속 &lt;a href=&quot;#opcode-STORE_FAST&quot;&gt; &lt;code&gt;STORE_FAST&lt;/code&gt; &lt;/a&gt; 명령이 네임 스페이스를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="3a067f8e863950831516af1d650bd9d3d58d9c6c" translate="yes" xml:space="preserve">
          <source>Imports: Multi-Line and Absolute/Relative</source>
          <target state="translated">수입품 : 다중 라인 및 절대 / 상대</target>
        </trans-unit>
        <trans-unit id="e34afa4c6c43fdf304519c4cf65d27d88a721571" translate="yes" xml:space="preserve">
          <source>Improved Compatibility with Shells</source>
          <target state="translated">쉘과의 호환성 향상</target>
        </trans-unit>
        <trans-unit id="089354fe34004fc9de595d32a05e79153d2c456c" translate="yes" xml:space="preserve">
          <source>In 3.8, the two primary ways DLLs are loaded now explicitly override the process-wide behavior to ensure consistency. See the &lt;a href=&quot;https://docs.python.org/3.8/whatsnew/3.8.html#bpo-36085-whatsnew&quot;&gt;porting notes&lt;/a&gt; for information on updating libraries.</source>
          <target state="translated">3.8에서는 DLL이로드되는 두 가지 기본 방법이 일관성을 보장하기 위해 프로세스 전체 동작을 명시 적으로 무시합니다. 라이브러리 업데이트에 대한 정보 는 &lt;a href=&quot;https://docs.python.org/3.8/whatsnew/3.8.html#bpo-36085-whatsnew&quot;&gt;포팅 노트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7add8af49918249d99a966a65f5a983db6ab28fa" translate="yes" xml:space="preserve">
          <source>In 3.8, the two primary ways DLLs are loaded now explicitly override the process-wide behavior to ensure consistency. See the &lt;a href=&quot;https://docs.python.org/3.9/whatsnew/3.8.html#bpo-36085-whatsnew&quot;&gt;porting notes&lt;/a&gt; for information on updating libraries.</source>
          <target state="translated">3.8에서 DLL을로드하는 두 가지 기본 방법은 일관성을 보장하기 위해 프로세스 전체 동작을 명시 적으로 재정의합니다. 라이브러리 업데이트에 대한 정보 는 &lt;a href=&quot;https://docs.python.org/3.9/whatsnew/3.8.html#bpo-36085-whatsnew&quot;&gt;이식 참고 사항&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09b2f076615a334a17aaf9a55dfdf31ef870f1d5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt;, this is the same as &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에서는 &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; , 이것과 동일 &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b38fe556a6e29923e6bee3656f92a012825b5239" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt;, this is the same as &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt;&lt;code&gt;readinto()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 에서는 readinto &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt; &lt;code&gt;readinto()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="cb4f5fa376dc3e2057a73ea4e8efbb45b9541ac5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;, processes are spawned by creating a &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object and then calling its &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; follows the API of &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt;. A trivial example of a multiprocess program is</source>
          <target state="translated">에서 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 프로세스가 만들어 양산하는 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 오브젝트를 다음의 호출 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메소드를. &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 의 API를 따릅니다 . 다중 프로세스 프로그램의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a41975f414337b4161e766ea1a36bb88654c31c4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;, an unstructured header is a run of arbitrary text in the ASCII character set. &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt;, however, has an &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; compatible mechanism for encoding non-ASCII text as ASCII characters within a header value. When a &lt;em&gt;value&lt;/em&gt; containing encoded words is passed to the constructor, the &lt;code&gt;UnstructuredHeader&lt;/code&gt; parser converts such encoded words into unicode, following the &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; rules for unstructured text. The parser uses heuristics to attempt to decode certain non-compliant encoded words. Defects are registered in such cases, as well as defects for issues such as invalid characters within the encoded words or the non-encoded text.</source>
          <target state="translated">에서 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; , 구조화되지 않은 헤더는 ASCII 문자 세트에서 임의의 텍스트의 실행이다. 그러나 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 에는 비 ASCII 텍스트를 헤더 값 내에서 ASCII 문자로 인코딩하기위한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 호환 메커니즘이 있습니다. 때 &lt;em&gt;값&lt;/em&gt; 인코딩 된 단어를 포함하는 상기 생성자로 전달되는 상기 &lt;code&gt;UnstructuredHeader&lt;/code&gt; 의 파서는 다음에 이러한 인코딩 된 유니 단어 변환 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 비정형 텍스트 규칙. 파서는 휴리스틱을 사용하여 특정 비 호환 인코딩 단어를 디코딩하려고 시도합니다. 이러한 경우 결함은 물론 인코딩 된 단어 내의 유효하지 않은 문자 또는 인코딩되지 않은 텍스트와 같은 문제의 결함도 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="6551877af47b9396e87eaa7a777f7c956f3407a3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;[0, 1]&lt;/code&gt;. Used to disambiguate wall times during a repeated interval. (A repeated interval occurs when clocks are rolled back at the end of daylight saving time or when the UTC offset for the current zone is decreased for political reasons.) The value 0 (1) represents the earlier (later) of the two moments with the same wall time representation.</source>
          <target state="translated">에서는 &lt;code&gt;[0, 1]&lt;/code&gt; . 반복되는 간격 동안 벽 시간을 명확하게하는 데 사용됩니다. (일광 절약 시간이 끝날 때 시계가 롤백되거나 정치적 이유로 현재 영역의 UTC 오프셋이 감소하면 반복되는 간격이 발생합니다.) 값 0 (1)은 동일한 월 시간 표현.</target>
        </trans-unit>
        <trans-unit id="93133f5ae9ab6ab0577f712c1e104727b3ae2cfc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(1000000)&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;range(1000000)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0618520a9a19fea1f2fc3b1e38952ba554e40a73" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(24)&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;range(24)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e20d8913c951c136cbfa4ba9fbeb279dcb3126a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(60)&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;range(60)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="edc259786c7b74fe3206daa43e1739b00d2659a2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;strftime()&lt;/code&gt;, &lt;code&gt;%Z&lt;/code&gt; is replaced by an empty string if &lt;code&gt;tzname()&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;; otherwise &lt;code&gt;%Z&lt;/code&gt; is replaced by the returned value, which must be a string.</source>
          <target state="translated">에서 &lt;code&gt;strftime()&lt;/code&gt; , &lt;code&gt;%Z&lt;/code&gt; 경우 빈 문자열로 대체됩니다 &lt;code&gt;tzname()&lt;/code&gt; 반환 &lt;code&gt;None&lt;/code&gt; ; 그렇지 않으면 &lt;code&gt;%Z&lt;/code&gt; 는 반환 된 값으로 대체되며 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="80cddb7b7e3874d06e76f8eb562205fbd3b77d3e" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;blocking mode&lt;/em&gt;, operations block until complete or the system returns an error (such as connection timed out).</source>
          <target state="translated">에서는 &lt;em&gt;블록 모드&lt;/em&gt; , 작업이 완료 될 때까지 차단 또는 시스템 에러 (접속 시간 초과 등) 리턴한다.</target>
        </trans-unit>
        <trans-unit id="6d6a9efba04a47d4781b6de1610f6fe37834e4f6" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;non-blocking mode&lt;/em&gt;, operations fail (with an error that is unfortunately system-dependent) if they cannot be completed immediately: functions from the &lt;a href=&quot;select#module-select&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; can be used to know when and whether a socket is available for reading or writing.</source>
          <target state="translated">에서 &lt;em&gt;비 차단 모드&lt;/em&gt; 로부터 기능 : 작업은 즉시 완료 할 수없는 경우 (불행하게도 시스템에 의존 오류가) 실패 &lt;a href=&quot;select#module-select&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 소켓이 읽거나 쓰기 위해 사용할 수있는 경우인지 알고하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1de600e7748b1b2c637dacf9c402ecc59c2e3930" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;timeout mode&lt;/em&gt;, operations fail if they cannot be completed within the timeout specified for the socket (they raise a &lt;a href=&quot;#socket.timeout&quot;&gt;&lt;code&gt;timeout&lt;/code&gt;&lt;/a&gt; exception) or if the system returns an error.</source>
          <target state="translated">에서 &lt;em&gt;시간 제한 모드&lt;/em&gt; 가 소켓 (그들이 제기에 대해 지정된 제한 시간 내에 완료 할 수없는 경우, 작업이 실패 &lt;a href=&quot;#socket.timeout&quot;&gt; &lt;code&gt;timeout&lt;/code&gt; &lt;/a&gt; 예외) 또는 시스템 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93e4a4e56d6d1e50756bb9c6e4bc1bc4ccb5eed5" translate="yes" xml:space="preserve">
          <source>In BLAKE2 the salt is processed as a one-time input to the hash function during initialization, rather than as an input to each compression function.</source>
          <target state="translated">BLAKE2에서 솔트는 각 압축 함수에 대한 입력이 아니라 초기화 중에 해시 함수에 대한 일회성 입력으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9c7d0b0868fac88a221721ed400ce1bb944f7db5" translate="yes" xml:space="preserve">
          <source>In Babyl mailboxes, the headers of a message are not stored contiguously with the body of the message. To generate a file-like representation, the headers and body are copied together into an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; instance, which has an API identical to that of a file. As a result, the file-like object is truly independent of the underlying mailbox but does not save memory compared to a string representation.</source>
          <target state="translated">Babyl 메일 함에서 메시지 헤더는 메시지 본문과 연속적으로 저장되지 않습니다. 파일과 같은 표현을 생성하기 위해 헤더와 본문이 &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 인스턴스에 함께 복사되며 파일과 동일한 API를 갖습니다. 결과적으로 파일과 같은 개체는 기본 사서함과 독립적이지만 문자열 표현에 비해 메모리를 절약하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="a441fd784df981e42da3513e4f1b407c066fa595" translate="yes" xml:space="preserve">
          <source>In Boolean contexts, a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object is always considered to be true.</source>
          <target state="translated">부울 컨텍스트에서 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체는 항상 참으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3c9b44f6dcf172af2afd8e8696bebf4c5016d825" translate="yes" xml:space="preserve">
          <source>In Boolean contexts, a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object is considered to be true if and only if it isn&amp;rsquo;t equal to &lt;code&gt;timedelta(0)&lt;/code&gt;.</source>
          <target state="translated">부울 컨텍스트에서 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체는 &lt;code&gt;timedelta(0)&lt;/code&gt; 과 같지 않은 경우에만 true로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f761eb1aa256d436b20321c9c6e424dc4749847" translate="yes" xml:space="preserve">
          <source>In Boolean contexts, all &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; objects are considered to be true.</source>
          <target state="translated">부울 컨텍스트에서 모든 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 개체는 true로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4133c1559bb69d3748ad119bc549a3b63e788a0f" translate="yes" xml:space="preserve">
          <source>In CPython, generator-based coroutines (generators decorated with &lt;a href=&quot;types#types.coroutine&quot;&gt;&lt;code&gt;types.coroutine()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt;&lt;code&gt;asyncio.coroutine()&lt;/code&gt;&lt;/a&gt;) are &lt;em&gt;awaitables&lt;/em&gt;, even though they do not have an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt;&lt;code&gt;__await__()&lt;/code&gt;&lt;/a&gt; method. Using &lt;code&gt;isinstance(gencoro, Awaitable)&lt;/code&gt; for them will return &lt;code&gt;False&lt;/code&gt;. Use &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; to detect them.</source>
          <target state="translated">CPython에있어서, 발전기 계 코 루틴 (장식 발전기 &lt;a href=&quot;types#types.coroutine&quot;&gt; &lt;code&gt;types.coroutine()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt; &lt;code&gt;asyncio.coroutine()&lt;/code&gt; &lt;/a&gt; )이다 &lt;em&gt;awaitables&lt;/em&gt; 그들이 갖고 있지 않더라도 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt; &lt;code&gt;__await__()&lt;/code&gt; &lt;/a&gt; 방법. 그들을 위해 &lt;code&gt;isinstance(gencoro, Awaitable)&lt;/code&gt; 를 사용하면 &lt;code&gt;False&lt;/code&gt; 가 반환 됩니다. &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 감지 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cae09edf26f6e37b7e750f76e28a3e8c3c44cf6" translate="yes" xml:space="preserve">
          <source>In CPython, generator-based coroutines (generators decorated with &lt;a href=&quot;types#types.coroutine&quot;&gt;&lt;code&gt;types.coroutine()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt;&lt;code&gt;asyncio.coroutine()&lt;/code&gt;&lt;/a&gt;) are &lt;em&gt;awaitables&lt;/em&gt;, even though they do not have an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt;&lt;code&gt;__await__()&lt;/code&gt;&lt;/a&gt; method. Using &lt;code&gt;isinstance(gencoro, Coroutine)&lt;/code&gt; for them will return &lt;code&gt;False&lt;/code&gt;. Use &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; to detect them.</source>
          <target state="translated">CPython에있어서, 발전기 계 코 루틴 (장식 발전기 &lt;a href=&quot;types#types.coroutine&quot;&gt; &lt;code&gt;types.coroutine()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt; &lt;code&gt;asyncio.coroutine()&lt;/code&gt; &lt;/a&gt; )이다 &lt;em&gt;awaitables&lt;/em&gt; 그들이 갖고 있지 않더라도 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__await__&quot;&gt; &lt;code&gt;__await__()&lt;/code&gt; &lt;/a&gt; 방법. 그들을 위해 &lt;code&gt;isinstance(gencoro, Coroutine)&lt;/code&gt; 를 사용하면 &lt;code&gt;False&lt;/code&gt; 가 반환 됩니다. &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 감지 하십시오 .</target>
        </trans-unit>
        <trans-unit id="56d54f98bb66071bd6c7b1eeeb243fafda3cb1f7" translate="yes" xml:space="preserve">
          <source>In CPython, generator-based coroutines (generators decorated with &lt;a href=&quot;types#types.coroutine&quot;&gt;&lt;code&gt;types.coroutine()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt;&lt;code&gt;asyncio.coroutine()&lt;/code&gt;&lt;/a&gt;) are &lt;em&gt;awaitables&lt;/em&gt;, even though they do not have an &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__await__&quot;&gt;&lt;code&gt;__await__()&lt;/code&gt;&lt;/a&gt; method. Using &lt;code&gt;isinstance(gencoro, Awaitable)&lt;/code&gt; for them will return &lt;code&gt;False&lt;/code&gt;. Use &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; to detect them.</source>
          <target state="translated">CPython에있어서, 발전기 계 코 루틴 (장식 발전기 &lt;a href=&quot;types#types.coroutine&quot;&gt; &lt;code&gt;types.coroutine()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt; &lt;code&gt;asyncio.coroutine()&lt;/code&gt; &lt;/a&gt; )이다 &lt;em&gt;awaitables&lt;/em&gt; 그들이 갖고 있지 않더라도 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__await__&quot;&gt; &lt;code&gt;__await__()&lt;/code&gt; &lt;/a&gt; 방법. &lt;code&gt;isinstance(gencoro, Awaitable)&lt;/code&gt; 를 사용하면 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 이를 감지 하려면 &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a3453678e2ae192dfd7aeaddc930dd47bdbabb5" translate="yes" xml:space="preserve">
          <source>In CPython, generator-based coroutines (generators decorated with &lt;a href=&quot;types#types.coroutine&quot;&gt;&lt;code&gt;types.coroutine()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt;&lt;code&gt;asyncio.coroutine()&lt;/code&gt;&lt;/a&gt;) are &lt;em&gt;awaitables&lt;/em&gt;, even though they do not have an &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__await__&quot;&gt;&lt;code&gt;__await__()&lt;/code&gt;&lt;/a&gt; method. Using &lt;code&gt;isinstance(gencoro, Coroutine)&lt;/code&gt; for them will return &lt;code&gt;False&lt;/code&gt;. Use &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; to detect them.</source>
          <target state="translated">CPython에있어서, 발전기 계 코 루틴 (장식 발전기 &lt;a href=&quot;types#types.coroutine&quot;&gt; &lt;code&gt;types.coroutine()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-task#asyncio.coroutine&quot;&gt; &lt;code&gt;asyncio.coroutine()&lt;/code&gt; &lt;/a&gt; )이다 &lt;em&gt;awaitables&lt;/em&gt; 그들이 갖고 있지 않더라도 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__await__&quot;&gt; &lt;code&gt;__await__()&lt;/code&gt; &lt;/a&gt; 방법. &lt;code&gt;isinstance(gencoro, Coroutine)&lt;/code&gt; 을 사용하면 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 이를 감지 하려면 &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="631366628298d4582a6ee037a9362b871c3234a2" translate="yes" xml:space="preserve">
          <source>In Python 2 code the &lt;code&gt;_order_&lt;/code&gt; attribute is necessary as definition order is lost before it can be recorded.</source>
          <target state="translated">Python 2 코드에서 &lt;code&gt;_order_&lt;/code&gt; 속성은 정의 순서가 기록되기 전에 유실되므로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3bc7f7458422d2effbdbed743271c2b54fbb7402" translate="yes" xml:space="preserve">
          <source>In Python, all exceptions must be instances of a class that derives from &lt;a href=&quot;#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;. In a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement with an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; clause that mentions a particular class, that clause also handles any exception classes derived from that class (but not exception classes from which &lt;em&gt;it&lt;/em&gt; is derived). Two exception classes that are not related via subclassing are never equivalent, even if they have the same name.</source>
          <target state="translated">Python에서 모든 예외는 &lt;a href=&quot;#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 에서 파생 된 클래스의 인스턴스 여야합니다 . A의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 에 문 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; 특정 클래스를 언급 절, 그 조항은 그 클래스 (있는하지만 예외 클래스에서 파생 된 예외 클래스 처리 &lt;em&gt;가&lt;/em&gt; 파생됩니다). 서브 클래 싱을 통해 관련되지 않은 두 개의 예외 클래스는 이름이 같더라도 절대 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0436c697fe5d187310c263a3a2c639d554d1677c" translate="yes" xml:space="preserve">
          <source>In Python, all exceptions must be instances of a class that derives from &lt;a href=&quot;#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;. In a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement with an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; clause that mentions a particular class, that clause also handles any exception classes derived from that class (but not exception classes from which &lt;em&gt;it&lt;/em&gt; is derived). Two exception classes that are not related via subclassing are never equivalent, even if they have the same name.</source>
          <target state="translated">Python에서 모든 예외는 &lt;a href=&quot;#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 에서 파생 된 클래스의 인스턴스 여야합니다 . A의 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 에 문 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; 특정 클래스를 언급 절, 그 조항은 그 클래스 (있는하지만 예외 클래스에서 파생 된 예외 클래스 처리 &lt;em&gt;가&lt;/em&gt; 파생됩니다). 서브 클래 싱을 통해 관련되지 않은 두 개의 예외 클래스는 이름이 같더라도 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0e22094af023753a3f8645474baf7875adb216c" translate="yes" xml:space="preserve">
          <source>In Python, file names, command line arguments, and environment variables are represented using the string type. On some systems, decoding these strings to and from bytes is necessary before passing them to the operating system. Python uses the file system encoding to perform this conversion (see &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Python에서 파일 이름, 명령 행 인수 및 환경 변수는 문자열 유형을 사용하여 표시됩니다. 일부 시스템에서는 이러한 문자열을 운영 체제로 전달하기 전에 바이트와의 디코딩이 필요합니다. Python은 파일 시스템 인코딩을 사용하여이 변환을 수행합니다 ( &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4a265e5614bc913aa2b5d3df9ffa283db482f3d1" translate="yes" xml:space="preserve">
          <source>In Python, since there is an interpreter active during execution, the presence of instrumented code is not required in order to do deterministic profiling. Python automatically provides a &lt;em&gt;hook&lt;/em&gt; (optional callback) for each event. In addition, the interpreted nature of Python tends to add so much overhead to execution, that deterministic profiling tends to only add small processing overhead in typical applications. The result is that deterministic profiling is not that expensive, yet provides extensive run time statistics about the execution of a Python program.</source>
          <target state="translated">Python에서는 실행 중에 활성 인터프리터가 있으므로 결정적 프로파일 링을 수행하기 위해 인스트루먼트 된 코드가 필요하지 않습니다. 파이썬은 자동으로 각 이벤트에 대한 &lt;em&gt;후크&lt;/em&gt; (선택적 콜백)를 제공합니다 . 또한, 파이썬의 해석 된 특성은 실행에 너무 많은 오버 헤드를 추가하는 경향이 있으며, 결정적 프로파일 링은 일반적인 애플리케이션에서 작은 처리 오버 헤드 만 추가하는 경향이 있습니다. 결과적으로 결정 론적 프로파일 링은 그다지 비싸지 않지만 파이썬 프로그램의 실행에 대한 광범위한 런타임 통계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5d2c2a794123158f78bff5ac03b8fc94de396956" translate="yes" xml:space="preserve">
          <source>In Shell, the accessible functions depends on what modules have been imported into the user process, including those imported by Idle itself, and which definitions have been run, all since the last restart.</source>
          <target state="translated">Shell에서 액세스 가능한 기능은 Idle 자체에서 가져온 모듈을 포함하여 사용자 프로세스로 가져온 모듈과 마지막 다시 시작 이후에 실행 된 정의에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="07ba9e60148d18758b640f6ed814832833d34be7" translate="yes" xml:space="preserve">
          <source>In Tk, there is a utility command, &lt;code&gt;wm&lt;/code&gt;, for interacting with the window manager. Options to the &lt;code&gt;wm&lt;/code&gt; command allow you to control things like titles, placement, icon bitmaps, and the like. In &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt;, these commands have been implemented as methods on the &lt;code&gt;Wm&lt;/code&gt; class. Toplevel widgets are subclassed from the &lt;code&gt;Wm&lt;/code&gt; class, and so can call the &lt;code&gt;Wm&lt;/code&gt; methods directly.</source>
          <target state="translated">Tk에는 &lt;code&gt;wm&lt;/code&gt; 이라는 유틸리티 명령이 있습니다. 에는 창 관리자와 상호 작용하기위한 이 있습니다. &lt;code&gt;wm&lt;/code&gt; 명령 옵션을 사용하면 제목, 배치, 아이콘 비트 맵 등과 같은 항목을 제어 할 수 있습니다. 에서 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; ,이 명령은 메소드로 구현 된 &lt;code&gt;Wm&lt;/code&gt; 클래스입니다. 최상위 레벨 위젯은 &lt;code&gt;Wm&lt;/code&gt; 클래스 에서 서브 클래스 되므로 &lt;code&gt;Wm&lt;/code&gt; 메소드를 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4bf65333e7dc9c2da7ca99bbab91025e00bf167" translate="yes" xml:space="preserve">
          <source>In Tk, to perform an action on a widget, use the widget name as a command, and follow it with an action name, possibly with arguments (options). In Tkinter, you call methods on the class instance to invoke actions on the widget. The actions (methods) that a given widget can perform are listed in &lt;code&gt;tkinter/__init__.py&lt;/code&gt;.</source>
          <target state="translated">Tk에서 위젯에 대한 조치를 수행하려면 위젯 이름을 명령으로 사용하고 조치 이름을 인수 (옵션)와 함께 사용하십시오. Tkinter에서는 클래스 인스턴스에서 메소드를 호출하여 위젯에서 조치를 호출합니다. 주어진 위젯이 수행 할 수있는 조치 (방법)는 &lt;code&gt;tkinter/__init__.py&lt;/code&gt; 에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b35e4b6aee318c8476142aafce45b3919ab5f7" translate="yes" xml:space="preserve">
          <source>In a mailcap file, the &amp;ldquo;test&amp;rdquo; field can optionally be specified to test some external condition (such as the machine architecture, or the window system in use) to determine whether or not the mailcap line applies. &lt;a href=&quot;#mailcap.findmatch&quot;&gt;&lt;code&gt;findmatch()&lt;/code&gt;&lt;/a&gt; will automatically check such conditions and skip the entry if the check fails.</source>
          <target state="translated">메일 캡 파일에서 &quot;테스트&quot;필드를 선택하여 메일 캡 라인이 적용되는지 여부를 결정하기 위해 일부 외부 조건 (예 : 머신 아키텍처 또는 사용중인 윈도우 시스템)을 테스트 할 수 있습니다. &lt;a href=&quot;#mailcap.findmatch&quot;&gt; &lt;code&gt;findmatch()&lt;/code&gt; &lt;/a&gt; 는 이러한 조건을 자동으로 확인하고 확인에 실패하면 항목을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="dff27fd73d9cbfd83fc3861e07e29a5ce9fa9b2c" translate="yes" xml:space="preserve">
          <source>In a model generated from bytes, any header values that (in contravention of the RFCs) contain non-ASCII bytes will, when retrieved through this interface, be represented as &lt;a href=&quot;email.header#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; objects with a charset of &lt;code&gt;unknown-8bit&lt;/code&gt;.</source>
          <target state="translated">바이트에서 생성 된 모델에서, RFC와 충돌하여 비 ASCII 바이트를 포함하는 헤더 값은이 인터페이스를 통해 검색 될 때 &lt;code&gt;unknown-8bit&lt;/code&gt; 의 문자 세트를 가진 &lt;a href=&quot;email.header#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 오브젝트 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bcdf824d25e196bd0265599e5fc259b9d7a7343d" translate="yes" xml:space="preserve">
          <source>In a multithreaded process, use caution to avoid leaking handles that are marked inheritable when combining this feature with concurrent calls to other process creation functions that inherit all handles such as &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt;. This also applies to standard handle redirection, which temporarily creates inheritable handles.</source>
          <target state="translated">멀티 스레드 프로세스에서는이 기능을 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 과 같은 모든 핸들을 상속하는 다른 프로세스 작성 함수에 대한 동시 호출과 결합 할 때 상속 가능으로 표시된 핸들이 새지 않도록주의하십시오 . 이것은 상속 가능한 핸들을 일시적으로 생성하는 표준 핸들 리디렉션에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="29450dfd4c15b79ba3d022659c17515b216a2723" translate="yes" xml:space="preserve">
          <source>In a script, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will typically be called with no arguments, and the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; will automatically determine the command-line arguments from &lt;a href=&quot;sys#sys.argv&quot;&gt;&lt;code&gt;sys.argv&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스크립트에서 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 일반적으로 인수없이 호출되며&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;sys#sys.argv&quot;&gt; &lt;code&gt;sys.argv&lt;/code&gt; &lt;/a&gt; 에서 명령 줄 인수를 자동으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b3bcc045679addb686c190d0e988b9e965c3a92d" translate="yes" xml:space="preserve">
          <source>In a script, typical usage is something like this:</source>
          <target state="translated">스크립트에서 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2b64a4d09137b4b9dd59b9330a2c7d91bb6320b" translate="yes" xml:space="preserve">
          <source>In a word, heaps are useful memory structures to know. I use them in a few applications, and I think it is good to keep a &amp;lsquo;heap&amp;rsquo; module around. :-)</source>
          <target state="translated">한마디로, 힙은 알아야 할 유용한 메모리 구조입니다. 나는 몇 가지 응용 프로그램에서 사용하며 '힙'모듈을 유지하는 것이 좋습니다. :-)</target>
        </trans-unit>
        <trans-unit id="9f2f0f5240c4f2006c555b058d4decb08fc35f55" translate="yes" xml:space="preserve">
          <source>In accordance with the standard, the &lt;a href=&quot;#module-decimal&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; module provides two ready to use standard contexts, &lt;a href=&quot;#decimal.BasicContext&quot;&gt;&lt;code&gt;BasicContext&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decimal.ExtendedContext&quot;&gt;&lt;code&gt;ExtendedContext&lt;/code&gt;&lt;/a&gt;. The former is especially useful for debugging because many of the traps are enabled:</source>
          <target state="translated">표준에 따라 &lt;a href=&quot;#module-decimal&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;a href=&quot;#decimal.BasicContext&quot;&gt; &lt;code&gt;BasicContext&lt;/code&gt; &lt;/a&gt; 와 BasicContext 및&lt;a href=&quot;#decimal.ExtendedContext&quot;&gt; &lt;code&gt;ExtendedContext&lt;/code&gt; 라는&lt;/a&gt;. 전자는 많은 트랩이 활성화되어 있기 때문에 디버깅에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d46ae7189ab259286c168e0b80b2fd3235fd9aed" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;, &lt;code&gt;'base64_codec'&lt;/code&gt; also accepts ASCII-only instances of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; for decoding</source>
          <target state="translated">뿐만 아니라 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;code&gt;'base64_codec'&lt;/code&gt; 도의 ASCII 전용 인스턴스를 받아 들인다&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 디코딩을</target>
        </trans-unit>
        <trans-unit id="f45bed92bb166b8633bf88c26503575048712087" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;, &lt;code&gt;'base64_codec'&lt;/code&gt; also accepts ASCII-only instances of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; for decoding</source>
          <target state="translated">뿐만 아니라 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;code&gt;'base64_codec'&lt;/code&gt; 도의 ASCII 전용 인스턴스 받아 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 디코딩을</target>
        </trans-unit>
        <trans-unit id="a7b20715c6c20497ac319a68d7016a8f75ae620e" translate="yes" xml:space="preserve">
          <source>In addition to being more CPU-intensive, compression with higher presets also requires much more memory (and produces output that needs more memory to decompress). With preset &lt;code&gt;9&lt;/code&gt; for example, the overhead for an &lt;a href=&quot;#lzma.LZMACompressor&quot;&gt;&lt;code&gt;LZMACompressor&lt;/code&gt;&lt;/a&gt; object can be as high as 800 MiB. For this reason, it is generally best to stick with the default preset.</source>
          <target state="translated">CPU를 많이 사용하는 것 외에도 사전 설정이 높은 압축에는 훨씬 더 많은 메모리가 필요하며 압축을 풀기 위해 더 많은 메모리가 필요한 출력이 생성됩니다. 예를 들어 사전 설정 &lt;code&gt;9&lt;/code&gt; 를 사용 하면&lt;a href=&quot;#lzma.LZMACompressor&quot;&gt; &lt;code&gt;LZMACompressor&lt;/code&gt; &lt;/a&gt; 객체 800MiB에이를 수 있습니다. 따라서 일반적으로 기본 사전 설정을 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="62f40ff2f60f38cdc6a391277467f1c0b2fc7189" translate="yes" xml:space="preserve">
          <source>In addition to enabling the debug mode, consider also:</source>
          <target state="translated">디버그 모드를 활성화하는 것 외에도 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9b6341c25f3405f85d37bcad24b0b303303d029c" translate="yes" xml:space="preserve">
          <source>In addition to implementing the methods above, implementations of the &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; interface must also supply the following attributes, indicating which protocols should be used, and how. All of these attributes may be assigned to.</source>
          <target state="translated">위의 방법을 구현하는 것 외에도 &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; 의&lt;/a&gt; 구현 인터페이스의 사용해야 할 프로토콜과 방법을 나타내는 다음 속성을 제공해야합니다. 이러한 모든 속성이 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b8600bc88afada2a15d07e3d3b860294a40b1a7" translate="yes" xml:space="preserve">
          <source>In addition to many functions described in the &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module documentation, &lt;a href=&quot;#module-posix&quot;&gt;&lt;code&gt;posix&lt;/code&gt;&lt;/a&gt; defines the following data item:</source>
          <target state="translated">&lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈 설명서에 설명 된 많은 기능 외에도&lt;a href=&quot;#module-posix&quot;&gt; &lt;code&gt;posix&lt;/code&gt; &lt;/a&gt; 는 다음 데이터 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ea70a6e7df22f6334f5444417337936e1629f2a1" translate="yes" xml:space="preserve">
          <source>In addition to method lookups, &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; also works for attribute lookups. One possible use case for this is calling &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;descriptors&lt;/a&gt; in a parent or sibling class.</source>
          <target state="translated">메소드 조회 외에도 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 는 속성 조회에도 작동합니다. 이에 대한 가능한 사용 사례는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;디스크립터를&lt;/a&gt; 호출하는 것입니다. 는 부모 또는 형제 클래스에서 를 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1965ac98680dc2ab968a88603f1f60f2040d74b" translate="yes" xml:space="preserve">
          <source>In addition to method lookups, &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; also works for attribute lookups. One possible use case for this is calling &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-descriptor&quot;&gt;descriptors&lt;/a&gt; in a parent or sibling class.</source>
          <target state="translated">메서드 조회 외에도 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 는 속성 조회에도 작동합니다. 이에 대한 한 가지 가능한 사용 사례 는 부모 또는 형제 클래스에서 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-descriptor&quot;&gt;설명자를&lt;/a&gt; 호출 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dcad6a5eb6d0ad37696a20f7d2411fda996f3b45" translate="yes" xml:space="preserve">
          <source>In addition to size-limiting tools, the module also provides a decorator for detecting recursive calls to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt; and substituting a placeholder string instead.</source>
          <target state="translated">크기 제한 도구 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 모듈은 __repr __ ()에 대한 재귀 호출을 감지하기위한 데코레이터를 제공합니다. 하고 대신 자리 표시 자 문자열을 대체 .</target>
        </trans-unit>
        <trans-unit id="e17c10a55d72817f47e5bcb96cd1072311145fea" translate="yes" xml:space="preserve">
          <source>In addition to size-limiting tools, the module also provides a decorator for detecting recursive calls to &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt; and substituting a placeholder string instead.</source>
          <target state="translated">크기 제한 도구 외에도 모듈은 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 대한 재귀 호출을 감지 하고 대신 자리 표시 자 문자열을 대체하는 데코레이터도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8d830c6765c9dc0300fe6b5cbc2b3e8460866e69" translate="yes" xml:space="preserve">
          <source>In addition to supporting the methods and operations of mappings, &lt;a href=&quot;#collections.UserDict&quot;&gt;&lt;code&gt;UserDict&lt;/code&gt;&lt;/a&gt; instances provide the following attribute:</source>
          <target state="translated">&lt;a href=&quot;#collections.UserDict&quot;&gt; &lt;code&gt;UserDict&lt;/code&gt; &lt;/a&gt; 매핑 방법 및 작업을 지원할뿐만 아니라 인스턴스 다음과 같은 특성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8807f211b2460760255a1709766f0a3137c6dab" translate="yes" xml:space="preserve">
          <source>In addition to supporting the methods and operations of mutable sequences, &lt;a href=&quot;#collections.UserList&quot;&gt;&lt;code&gt;UserList&lt;/code&gt;&lt;/a&gt; instances provide the following attribute:</source>
          <target state="translated">&lt;a href=&quot;#collections.UserList&quot;&gt; &lt;code&gt;UserList&lt;/code&gt; &lt;/a&gt; 는 가변 시퀀스의 방법과 작동을 지원할뿐만 아니라 인스턴스 다음과 같은 특성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04aa2e8b62d41221e69b20a54dc36f3e6372ea8e" translate="yes" xml:space="preserve">
          <source>In addition to supporting the methods and operations of strings, &lt;a href=&quot;#collections.UserString&quot;&gt;&lt;code&gt;UserString&lt;/code&gt;&lt;/a&gt; instances provide the following attribute:</source>
          <target state="translated">문자열의 메소드 및 조작을 지원하는 것 외에도 &lt;a href=&quot;#collections.UserString&quot;&gt; &lt;code&gt;UserString&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2cf43345efe70766c6640171cc92f01b4817ca97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt; API, &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; objects also support the following attributes and methods:</source>
          <target state="translated">&lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; API 외에도 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체는 다음과 같은 속성 및 메서드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3537cce0770809bd80cddc6370639f4675c1c292" translate="yes" xml:space="preserve">
          <source>In addition to the Tk interface module, &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; includes a number of Python modules, &lt;code&gt;tkinter.constants&lt;/code&gt; being one of the most important. Importing &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; will automatically import &lt;code&gt;tkinter.constants&lt;/code&gt;, so, usually, to use Tkinter all you need is a simple import statement:</source>
          <target state="translated">Tk 인터페이스 모듈 외에도 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 에는 많은 Python 모듈이 포함되어 있으며 &lt;code&gt;tkinter.constants&lt;/code&gt; 가 가장 중요합니다. 가져 오기 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 자동으로 가져옵니다 &lt;code&gt;tkinter.constants&lt;/code&gt; 을 , 그래서, 일반적으로, 당신이 필요로하는 모든 간단한 import 문이다 Tkinter를 사용하기 :</target>
        </trans-unit>
        <trans-unit id="9690476654ee5a2736c4ceafa04629e93b08060a" translate="yes" xml:space="preserve">
          <source>In addition to the above methods, the &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; must also inherit all other methods and attributes from the underlying stream.</source>
          <target state="translated">위의 방법 외에도 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 는 기본 스트림에서 다른 모든 메소드 및 속성을 상속해야합니다.</target>
        </trans-unit>
        <trans-unit id="222314dc286fea8c88b16cc332dcefcec6c56990" translate="yes" xml:space="preserve">
          <source>In addition to the above methods, the &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; must also inherit all other methods and attributes from the underlying stream.</source>
          <target state="translated">위의 메소드 외에도 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 는 기본 스트림에서 다른 모든 메소드 및 속성을 상속해야합니다.</target>
        </trans-unit>
        <trans-unit id="1720f463c1df0d0fe9311a603541746810b18c89" translate="yes" xml:space="preserve">
          <source>In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except &lt;code&gt;'n'&lt;/code&gt; and &lt;code&gt;None&lt;/code&gt;). When doing so, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float()&lt;/code&gt;&lt;/a&gt; is used to convert the integer to a floating point number before formatting.</source>
          <target state="translated">위의 프리젠 테이션 유형 외에도 정수는 아래에 나열된 부동 소수점 프리젠 테이션 유형으로 형식화 될 수 있습니다 ( &lt;code&gt;'n'&lt;/code&gt; 및 &lt;code&gt;None&lt;/code&gt; 제외) . 그렇게 할 때, &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float()&lt;/code&gt; &lt;/a&gt; 는 포맷하기 전에 정수를 부동 소수점 숫자로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa4995b269e79140bbd715d66781cc2d6ced577" translate="yes" xml:space="preserve">
          <source>In addition to the above, &lt;a href=&quot;#logging.LoggerAdapter&quot;&gt;&lt;code&gt;LoggerAdapter&lt;/code&gt;&lt;/a&gt; supports the following methods of &lt;a href=&quot;#logging.Logger&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;#logging.Logger.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.warning&quot;&gt;&lt;code&gt;warning()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.error&quot;&gt;&lt;code&gt;error()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.exception&quot;&gt;&lt;code&gt;exception()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.critical&quot;&gt;&lt;code&gt;critical()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.log&quot;&gt;&lt;code&gt;log()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.isEnabledFor&quot;&gt;&lt;code&gt;isEnabledFor()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt;&lt;code&gt;getEffectiveLevel()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt;&lt;code&gt;setLevel()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#logging.Logger.hasHandlers&quot;&gt;&lt;code&gt;hasHandlers()&lt;/code&gt;&lt;/a&gt;. These methods have the same signatures as their counterparts in &lt;a href=&quot;#logging.Logger&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;, so you can use the two types of instances interchangeably.</source>
          <target state="translated">위의 이외에도 &lt;a href=&quot;#logging.LoggerAdapter&quot;&gt; &lt;code&gt;LoggerAdapter&lt;/code&gt; &lt;/a&gt; 는 다음 &lt;a href=&quot;#logging.Logger&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 메소드를 지원합니다 . &lt;a href=&quot;#logging.Logger.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.info&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.warning&quot;&gt; &lt;code&gt;warning()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.error&quot;&gt; &lt;code&gt;error()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.exception&quot;&gt; &lt;code&gt;exception()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.critical&quot;&gt; &lt;code&gt;critical()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.log&quot;&gt; &lt;code&gt;log()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.isEnabledFor&quot;&gt; &lt;code&gt;isEnabledFor()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt; &lt;code&gt;getEffectiveLevel()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt; &lt;code&gt;setLevel()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#logging.Logger.hasHandlers&quot;&gt; &lt;code&gt;hasHandlers()&lt;/code&gt; &lt;/a&gt; . 이러한 메소드는 &lt;a href=&quot;#logging.Logger&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 의&lt;/a&gt; 해당 메소드와 동일한 서명을 가지므로 두 가지 유형의 인스턴스를 상호 교환하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d50c1e6c07de1acc4db99246c84c882aabeeb1c" translate="yes" xml:space="preserve">
          <source>In addition to the above, deques support iteration, pickling, &lt;code&gt;len(d)&lt;/code&gt;, &lt;code&gt;reversed(d)&lt;/code&gt;, &lt;code&gt;copy.copy(d)&lt;/code&gt;, &lt;code&gt;copy.deepcopy(d)&lt;/code&gt;, membership testing with the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; operator, and subscript references such as &lt;code&gt;d[0]&lt;/code&gt; to access the first element. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access, use lists instead.</source>
          <target state="translated">위의 외에도 deques는 반복, 피클 링, &lt;code&gt;len(d)&lt;/code&gt; , &lt;code&gt;reversed(d)&lt;/code&gt; , &lt;code&gt;copy.copy(d)&lt;/code&gt; , &lt;code&gt;copy.deepcopy(d)&lt;/code&gt; ,&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 연산자를및 &lt;code&gt;d[0]&lt;/code&gt; 을 눌러 첫 번째 요소에 액세스하십시오. 인덱스 된 액세스는 양쪽 끝에 O (1)이지만 중간에 O (n)까지 느려집니다. 빠른 임의 액세스를 위해서는 대신 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ce85ce1fe4acf8b50a9a8f4381ff0d9e65beb534" translate="yes" xml:space="preserve">
          <source>In addition to the above, deques support iteration, pickling, &lt;code&gt;len(d)&lt;/code&gt;, &lt;code&gt;reversed(d)&lt;/code&gt;, &lt;code&gt;copy.copy(d)&lt;/code&gt;, &lt;code&gt;copy.deepcopy(d)&lt;/code&gt;, membership testing with the &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; operator, and subscript references such as &lt;code&gt;d[0]&lt;/code&gt; to access the first element. Indexed access is O(1) at both ends but slows to O(n) in the middle. For fast random access, use lists instead.</source>
          <target state="translated">위의 것 외에도 deques는 iteration, pickling, &lt;code&gt;len(d)&lt;/code&gt; , &lt;code&gt;reversed(d)&lt;/code&gt; , &lt;code&gt;copy.copy(d)&lt;/code&gt; , &lt;code&gt;copy.deepcopy(d)&lt;/code&gt; , &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 연산자를 사용한 멤버십 테스트 및 &lt;code&gt;d[0]&lt;/code&gt; 와 같은 첨자 참조를 지원합니다 . 0] 첫 번째 요소에 액세스합니다. 인덱스 액세스는 양쪽 끝에서 O (1)이지만 중간에서 O (n)으로 느려집니다. 빠른 임의 액세스를 위해 대신 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ebaf021a38f23d1b3be305231ce1cfa6bc43bf01" translate="yes" xml:space="preserve">
          <source>In addition to the attributes and methods from &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.FileIO&quot;&gt;&lt;code&gt;FileIO&lt;/code&gt;&lt;/a&gt; provides the following data attributes:</source>
          <target state="translated">의 속성과 메소드 외에도 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#io.FileIO&quot;&gt; &lt;code&gt;FileIO&lt;/code&gt; &lt;/a&gt; 다음과 같은 데이터 속성을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="14586c995a780d78561f97624099b8e4ec9b4105" translate="yes" xml:space="preserve">
          <source>In addition to the attributes and methods from &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; provides the following methods:</source>
          <target state="translated">&lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 의 속성 및 메소드 외에도 , &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; 외에도&lt;/a&gt; 다음과 같은 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="52fd5a33b320649b6f1060489177810635c6ea92" translate="yes" xml:space="preserve">
          <source>In addition to the classes described above, there are a number of module-level functions.</source>
          <target state="translated">위에서 설명한 클래스 외에도 많은 모듈 수준 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1112b3c989ed862bdeb0f82d3c1bc4efa761003" translate="yes" xml:space="preserve">
          <source>In addition to the dictionary-like methods, &lt;code&gt;gdbm&lt;/code&gt; objects have the following methods:</source>
          <target state="translated">사전과 같은 방법 외에도 &lt;code&gt;gdbm&lt;/code&gt; 객체는 다음과 같은 메소드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6226060e492ea216f0e7f78ce7856fca0eebffd1" translate="yes" xml:space="preserve">
          <source>In addition to the dictionary-like methods, &lt;code&gt;ndbm&lt;/code&gt; objects provide the following method:</source>
          <target state="translated">사전과 같은 방법 외에도 &lt;code&gt;ndbm&lt;/code&gt; 객체는 다음과 같은 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cea61bcebf3b4dd67f209d89e9e334cbef2a059e" translate="yes" xml:space="preserve">
          <source>In addition to the environment functions above, the &lt;a href=&quot;#module-wsgiref.util&quot;&gt;&lt;code&gt;wsgiref.util&lt;/code&gt;&lt;/a&gt; module also provides these miscellaneous utilities:</source>
          <target state="translated">위의 환경 기능 외에도 &lt;a href=&quot;#module-wsgiref.util&quot;&gt; &lt;code&gt;wsgiref.util&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기타 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="858dce34107f4186993a5996db613388f2631800" translate="yes" xml:space="preserve">
          <source>In addition to the examples below, more examples are given in &lt;a href=&quot;https://docs.python.org/3.8/howto/urllib2.html#urllib-howto&quot;&gt;HOWTO Fetch Internet Resources Using The urllib Package&lt;/a&gt;.</source>
          <target state="translated">아래 예 외에도 더 많은 예가 나와 있습니다. &lt;a href=&quot;https://docs.python.org/3.8/howto/urllib2.html#urllib-howto&quot;&gt; urllib 패키지를 사용하여 인터넷 리소스를 가져&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5073ea358d6afe8999722a058dc8df468ab48cd" translate="yes" xml:space="preserve">
          <source>In addition to the examples below, more examples are given in &lt;a href=&quot;https://docs.python.org/3.9/howto/urllib2.html#urllib-howto&quot;&gt;HOWTO Fetch Internet Resources Using The urllib Package&lt;/a&gt;.</source>
          <target state="translated">아래 예제 외에도 &lt;a href=&quot;https://docs.python.org/3.9/howto/urllib2.html#urllib-howto&quot;&gt;urllib 패키지를 사용하여 인터넷 리소스를 가져&lt;/a&gt; 오는 방법에 더 많은 예제가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b096e1520c7229739493907c163d5aa90e2c7fd3" translate="yes" xml:space="preserve">
          <source>In addition to the features required to implement the &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; interface, this class allows you to block and allow domains from setting and receiving cookies. There are also some strictness switches that allow you to tighten up the rather loose Netscape protocol rules a little bit (at the cost of blocking some benign cookies).</source>
          <target state="translated">구현하는 데 필요한 기능 외에도 &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 인터페이스 클래스를 사용하면 도메인이 쿠키를 설정 및 수신하지 못하도록 차단하고 허용 할 수 있습니다. 또한 다소 느슨한 Netscape 프로토콜 규칙을 약간 강화할 수있는 일부 엄격 성 스위치가 있습니다 (일부 양성 쿠키를 차단하는 비용으로).</target>
        </trans-unit>
        <trans-unit id="1dc8d82427b096c43fc2e7d5213bd591f0d85590" translate="yes" xml:space="preserve">
          <source>In addition to the literal forms, bytes objects can be created in a number of other ways:</source>
          <target state="translated">리터럴 형식 외에도 bytes 객체는 여러 가지 다른 방법으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c64e42d0dab883c69e970748044e9e77b97cb7a8" translate="yes" xml:space="preserve">
          <source>In addition to the methods inherited from tuples, named tuples support three additional methods and two attributes. To prevent conflicts with field names, the method and attribute names start with an underscore.</source>
          <target state="translated">튜플에서 상속 된 메서드 외에도 명명 된 튜플은 세 가지 추가 메서드와 두 가지 특성을 지원합니다. 필드 이름과의 충돌을 방지하기 위해 메소드와 속성 이름은 밑줄로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e2f6ddf1bf12cf34152fec328d39c9d8ce0a989d" translate="yes" xml:space="preserve">
          <source>In addition to the methods provided by the &lt;a href=&quot;collections.abc#collections.abc.MutableMapping&quot;&gt;&lt;code&gt;collections.abc.MutableMapping&lt;/code&gt;&lt;/a&gt; class, &lt;code&gt;dumbdbm&lt;/code&gt; objects provide the following methods:</source>
          <target state="translated">&lt;a href=&quot;collections.abc#collections.abc.MutableMapping&quot;&gt; &lt;code&gt;collections.abc.MutableMapping&lt;/code&gt; &lt;/a&gt; 클래스 &lt;code&gt;dumbdbm&lt;/code&gt; 에서 제공하는 메소드 외에도 오브젝트는 다음 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49c9b324d276aba55bfa28551beee12479bf0531" translate="yes" xml:space="preserve">
          <source>In addition to the operations listed above, &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; objects support certain additions and subtractions with &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; objects (see below).</source>
          <target state="translated">위에 나열된 작업 외에도 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체는 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 와 함께 특정 덧셈과 뺄셈을 지원 합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8c4c56f4ca00cb6b6be40eba948fd85089f6ade4" translate="yes" xml:space="preserve">
          <source>In addition to the settable attributes listed above that apply to all policies, this policy adds the following additional attributes:</source>
          <target state="translated">모든 정책에 적용되는 위에 나열된 설정 가능 속성 외에도이 정책은 다음과 같은 추가 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7d6fe1a1b1f7fcd5eef30c9780f9e8758b294753" translate="yes" xml:space="preserve">
          <source>In addition to the standard library, there is a growing collection of several thousand components (from individual programs and modules to packages and entire application development frameworks), available from the &lt;a href=&quot;https://pypi.org&quot;&gt;Python Package Index&lt;/a&gt;.</source>
          <target state="translated">표준 라이브러리 외에도 &lt;a href=&quot;https://pypi.org&quot;&gt;Python Package Index&lt;/a&gt; 에서 사용할 수있는 수천 개의 구성 요소 (개별 프로그램 및 모듈에서 패키지 및 전체 응용 프로그램 개발 프레임 워크) 컬렉션이 증가하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37b1282f5319fc90d1ae0fbf402438654f72c8b7" translate="yes" xml:space="preserve">
          <source>In addition to the standard numeric properties, decimal floating point objects also have a number of specialized methods:</source>
          <target state="translated">십진 부동 소수점 객체에는 표준 숫자 속성 외에도 여러 가지 특수한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="20844ff85a7de274374759963a07f03ca0ec2fa4" translate="yes" xml:space="preserve">
          <source>In addition to the three supplied contexts, new contexts can be created with the &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">세 공급 상황에 더하여, 새로운 컨텍스트가 생성 될 수와 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 생성자를 .</target>
        </trans-unit>
        <trans-unit id="032befaca731d1da6b9f55a3d41598ab32bb42d3" translate="yes" xml:space="preserve">
          <source>In addition to the two signed zeros which are distinct yet equal, there are various representations of zero with differing precisions yet equivalent in value. This takes a bit of getting used to. For an eye accustomed to normalized floating point representations, it is not immediately obvious that the following calculation returns a value equal to zero:</source>
          <target state="translated">서로 다르지만 동일한 두 개의 부호있는 0 외에도 정밀도는 다르지만 값은 동일한 0의 다양한 표현이 있습니다. 익숙해지는 데 약간의 시간이 걸립니다. 정규화 된 부동 소수점 표현에 익숙한 눈의 경우 다음 계산에서 0과 같은 값을 반환한다는 것은 분명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="470a6fd8b7a670e99e5471d463edd75a822561e0" translate="yes" xml:space="preserve">
          <source>In addition to the usual mapping methods, ordered dictionaries also support reverse iteration using &lt;a href=&quot;functions#reversed&quot;&gt;&lt;code&gt;reversed()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적인 매핑 방법 외에도 정렬 된 사전은 &lt;a href=&quot;functions#reversed&quot;&gt; &lt;code&gt;reversed()&lt;/code&gt; &lt;/a&gt; 사용하여 역 반복을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="1f6056a668fa6b597cd5e06fbb9eab25b2a47143" translate="yes" xml:space="preserve">
          <source>In addition to their mapping interface and formatting features, &lt;a href=&quot;#wsgiref.headers.Headers&quot;&gt;&lt;code&gt;Headers&lt;/code&gt;&lt;/a&gt; objects also have the following methods for querying and adding multi-valued headers, and for adding headers with MIME parameters:</source>
          <target state="translated">매핑 인터페이스 및 서식 기능 외에도 &lt;a href=&quot;#wsgiref.headers.Headers&quot;&gt; &lt;code&gt;Headers&lt;/code&gt; &lt;/a&gt; 객체에는 다중 값 헤더를 쿼리 및 추가하고 MIME 매개 변수를 사용하여 헤더를 추가하는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37effc66593dde7858807d6c481046b5424a851" translate="yes" xml:space="preserve">
          <source>In addition to these classes, &lt;a href=&quot;#module-xml.sax&quot;&gt;&lt;code&gt;xml.sax&lt;/code&gt;&lt;/a&gt; provides the following exception classes.</source>
          <target state="translated">이러한 클래스 외에도 &lt;a href=&quot;#module-xml.sax&quot;&gt; &lt;code&gt;xml.sax&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 예외 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3c5fc990cbc73c12c0b40300fad7df5e7ee287cd" translate="yes" xml:space="preserve">
          <source>In addition to these classes, &lt;a href=&quot;#module-xml.sax.handler&quot;&gt;&lt;code&gt;xml.sax.handler&lt;/code&gt;&lt;/a&gt; provides symbolic constants for the feature and property names.</source>
          <target state="translated">이러한 클래스 외에도 &lt;a href=&quot;#module-xml.sax.handler&quot;&gt; &lt;code&gt;xml.sax.handler&lt;/code&gt; &lt;/a&gt; 는 기능 및 속성 이름에 대한 기호 상수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="398bda298534a149091a837cc6c784d269a2e413" translate="yes" xml:space="preserve">
          <source>In addition to these methods, lock objects can also be used via the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, e.g.:</source>
          <target state="translated">이러한 방법 외에도 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 통해 잠금 객체를 사용할 수도 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="59b4fba6609849f4bb2b33444f99b785fc17caf1" translate="yes" xml:space="preserve">
          <source>In addition to these methods, lock objects can also be used via the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, e.g.:</source>
          <target state="translated">이러한 메서드 외에도 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 통해 잠금 개체를 사용할 수도 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="324d7520dd2db34f14989622298b9a50942c0a6b" translate="yes" xml:space="preserve">
          <source>In addition to these two forms, there are two additional normal forms based on compatibility equivalence. In Unicode, certain characters are supported which normally would be unified with other characters. For example, U+2160 (ROMAN NUMERAL ONE) is really the same thing as U+0049 (LATIN CAPITAL LETTER I). However, it is supported in Unicode for compatibility with existing character sets (e.g. gb2312).</source>
          <target state="translated">이 두 가지 형식 외에도 호환성 동등성에 따라 두 가지 추가 일반 형식이 있습니다. 유니 코드에서는 일반적으로 다른 문자와 통합되는 특정 문자가 지원됩니다. 예를 들어 U + 2160 (ROMAN NUMERAL ONE)은 실제로 U + 0049 (라틴 대문자 L)와 동일합니다. 그러나 기존 문자 세트와의 호환성을 위해 유니 코드로 지원됩니다 (예 : gb2312).</target>
        </trans-unit>
        <trans-unit id="9e0c6060f180bd1be434b002c3a8e1bb629b28ba" translate="yes" xml:space="preserve">
          <source>In addition to those of &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; can have one more attribute:</source>
          <target state="translated">(IPLA) 외에 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 는&lt;/a&gt; 하나 개 이상의 속성을 가질 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="58b602fd4657546b90e8bec1feb16284ddd90bfc" translate="yes" xml:space="preserve">
          <source>In addition you can pass &lt;code&gt;spec=True&lt;/code&gt; or &lt;code&gt;spec_set=True&lt;/code&gt;, which causes patch to pass in the object being mocked as the spec/spec_set object.</source>
          <target state="translated">또한 &lt;code&gt;spec=True&lt;/code&gt; 또는 &lt;code&gt;spec_set=True&lt;/code&gt; 를 전달하면 spec / spec_set 객체로 조롱되는 객체에 패치가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1538a099b36c536517432c89a4b9de9737c1b154" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;#module-tkinter.tix&quot;&gt;&lt;code&gt;tkinter.tix&lt;/code&gt;&lt;/a&gt; augments &lt;a href=&quot;tkinter#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; by providing:</source>
          <target state="translated">또한 &lt;a href=&quot;#module-tkinter.tix&quot;&gt; &lt;code&gt;tkinter.tix&lt;/code&gt; &lt;/a&gt; 는 다음 을 제공 하여 &lt;a href=&quot;tkinter#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 를 보강 합니다.</target>
        </trans-unit>
        <trans-unit id="ad37a6225b74614726b479be7666d6240684d671" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; contains a base &lt;code&gt;Node&lt;/code&gt; class and the DOM exception classes. The &lt;code&gt;Node&lt;/code&gt; class provided by this module does not implement any of the methods or attributes defined by the DOM specification; concrete DOM implementations must provide those. The &lt;code&gt;Node&lt;/code&gt; class provided as part of this module does provide the constants used for the &lt;code&gt;nodeType&lt;/code&gt; attribute on concrete &lt;code&gt;Node&lt;/code&gt; objects; they are located within the class rather than at the module level to conform with the DOM specifications.</source>
          <target state="translated">또한 &lt;a href=&quot;#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt; 에는 기본 &lt;code&gt;Node&lt;/code&gt; 클래스와 DOM 예외 클래스가 포함됩니다. &lt;code&gt;Node&lt;/code&gt; 이 모듈에서 제공하는 클래스는 DOM 사양에 의해 정의 된 메소드 나 속성 중 하나를 구현하지 않습니다; 구체적인 DOM 구현은이를 제공해야합니다. &lt;code&gt;Node&lt;/code&gt; 사용되는 상수 제공 않고이 모듈의 일부로서 제공하는 클래스 &lt;code&gt;nodeType&lt;/code&gt; 콘크리트 특성 &lt;code&gt;Node&lt;/code&gt; 객체; 그것들은 DOM 스펙을 준수하기 위해 모듈 레벨이 아닌 클래스 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d44ab30dfa1f3ce24fbe120b70c25d4d0b4cc1" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;#venv.EnvBuilder&quot;&gt;&lt;code&gt;EnvBuilder&lt;/code&gt;&lt;/a&gt; provides this utility method that can be called from &lt;a href=&quot;#venv.EnvBuilder.setup_scripts&quot;&gt;&lt;code&gt;setup_scripts()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#venv.EnvBuilder.post_setup&quot;&gt;&lt;code&gt;post_setup()&lt;/code&gt;&lt;/a&gt; in subclasses to assist in installing custom scripts into the virtual environment.</source>
          <target state="translated">또한 &lt;a href=&quot;#venv.EnvBuilder&quot;&gt; &lt;code&gt;EnvBuilder&lt;/code&gt; &lt;/a&gt; 는 서브 클래스의 &lt;a href=&quot;#venv.EnvBuilder.setup_scripts&quot;&gt; &lt;code&gt;setup_scripts()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#venv.EnvBuilder.post_setup&quot;&gt; &lt;code&gt;post_setup()&lt;/code&gt; &lt;/a&gt; 에서 호출 할 수있는이 유틸리티 메소드를 제공 하여 사용자 정의 스크립트를 가상 환경에 설치하는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="8d5378207c9afa23bfe1afa0e6e3ef8b7515d910" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;Tk&lt;/code&gt; also loads a startup file if it is present. Note that the Tk file is loaded unconditionally. This additional file is &lt;code&gt;.Idle.py&lt;/code&gt; and is looked for in the user&amp;rsquo;s home directory. Statements in this file will be executed in the Tk namespace, so this file is not useful for importing functions to be used from IDLE&amp;rsquo;s Python shell.</source>
          <target state="translated">또한 &lt;code&gt;Tk&lt;/code&gt; 는 시작 파일이 있으면로드합니다. Tk 파일은 무조건로드됩니다. 이 추가 파일은 &lt;code&gt;.Idle.py&lt;/code&gt; 이며 사용자의 홈 디렉토리에서 찾습니다 . 이 파일의 명령문은 Tk 네임 스페이스에서 실행되므로이 ​​파일은 IDLE의 Python 셸에서 사용할 함수를 가져 오는 데 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="714413f1caa3214664dffb1034eb3924cd14e3f3" translate="yes" xml:space="preserve">
          <source>In addition, a custom &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt;&lt;code&gt;TreeBuilder&lt;/code&gt;&lt;/a&gt; object can provide the following methods:</source>
          <target state="translated">또한 사용자 정의 &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt; &lt;code&gt;TreeBuilder&lt;/code&gt; &lt;/a&gt; 객체는 다음과 같은 메소드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffffc9f25603a24b2ca6858559ed5b2e495ca947" translate="yes" xml:space="preserve">
          <source>In addition, each channel delegates or extends many of the socket methods. Most of these are nearly identical to their socket partners.</source>
          <target state="translated">또한 각 채널은 많은 소켓 메소드를 위임하거나 확장합니다. 이들 대부분은 소켓 파트너와 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="83b47f7b397cc2558e44945a3d76d7c85179444e" translate="yes" xml:space="preserve">
          <source>In addition, enabling &lt;a href=&quot;tracemalloc#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; shows the line where the file was opened:</source>
          <target state="translated">또한 &lt;a href=&quot;tracemalloc#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; 을&lt;/a&gt; 활성화 하면 파일이 열린 행이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c412f65e105df43e1227481dd3222239a0aaaa6f" translate="yes" xml:space="preserve">
          <source>In addition, every data type that can be packed with a &lt;a href=&quot;#xdrlib.Packer&quot;&gt;&lt;code&gt;Packer&lt;/code&gt;&lt;/a&gt;, can be unpacked with an &lt;a href=&quot;#xdrlib.Unpacker&quot;&gt;&lt;code&gt;Unpacker&lt;/code&gt;&lt;/a&gt;. Unpacking methods are of the form &lt;code&gt;unpack_type()&lt;/code&gt;, and take no arguments. They return the unpacked object.</source>
          <target state="translated">또한 &lt;a href=&quot;#xdrlib.Packer&quot;&gt; &lt;code&gt;Packer&lt;/code&gt; &lt;/a&gt; 로 압축 할 수있는 모든 데이터 유형 은 &lt;a href=&quot;#xdrlib.Unpacker&quot;&gt; &lt;code&gt;Unpacker&lt;/code&gt; &lt;/a&gt; 로 압축 해제 할 수 있습니다 . &lt;code&gt;unpack_type()&lt;/code&gt; 패킹 메소드는 unpack_type () 형식 이며 인수를 사용하지 않습니다. 포장이 풀린 물건을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="7ba3a9a49cc3e12a995a955c9b502b49ba170e63" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;M.__test__&lt;/code&gt; exists and &amp;ldquo;is true&amp;rdquo;, it must be a dict, and each entry maps a (string) name to a function object, class object, or string. Function and class object docstrings found from &lt;code&gt;M.__test__&lt;/code&gt; are searched, and strings are treated as if they were docstrings. In output, a key &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M.__test__&lt;/code&gt; appears with name</source>
          <target state="translated">또한 &lt;code&gt;M.__test__&lt;/code&gt; 가 존재하고 &quot;true&quot;인 경우 dict 여야하며 각 항목은 (문자열) 이름을 함수 객체, 클래스 객체 또는 문자열에 매핑합니다. &lt;code&gt;M.__test__&lt;/code&gt; 에서 찾은 함수 및 클래스 객체 docstring 이 검색되고 문자열은 마치 docstring 인 것처럼 처리됩니다. 출력 에서 &lt;code&gt;M.__test__&lt;/code&gt; 의 키 &lt;code&gt;K&lt;/code&gt; 가 이름과 함께 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7c4f27b629e481e3b68eabacd3944479c69ebbb1" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;'func_type'&lt;/code&gt;, the input syntax is modified to correspond to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;signature type comments&amp;rdquo;, e.g. &lt;code&gt;(str, int) -&amp;gt; List[str]&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;'func_type'&lt;/code&gt; 인 경우 입력 구문은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;서명 유형 주석&amp;rdquo; 에 해당하도록 수정됩니다 &lt;code&gt;(str, int) -&amp;gt; List[str]&lt;/code&gt; 예 : (str, int)-&amp;gt; List [str]) .</target>
        </trans-unit>
        <trans-unit id="30c6bed1ea7380108e2ca8ee55afe3a1b3931b43" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; are the exact same type and one of list, tuple, dict, set, frozenset or str or any type that a subclass registers with &lt;a href=&quot;#unittest.TestCase.addTypeEqualityFunc&quot;&gt;&lt;code&gt;addTypeEqualityFunc()&lt;/code&gt;&lt;/a&gt; the type-specific equality function will be called in order to generate a more useful default error message (see also the &lt;a href=&quot;#type-specific-methods&quot;&gt;list of type-specific methods&lt;/a&gt;).</source>
          <target state="translated">또한 &lt;em&gt;첫 번째&lt;/em&gt; 와 &lt;em&gt;두 번째&lt;/em&gt; 가 정확히 동일한 유형이고 list, tuple, dict, set, frozenset 또는 str 또는 &lt;a href=&quot;#unittest.TestCase.addTypeEqualityFunc&quot;&gt; &lt;code&gt;addTypeEqualityFunc()&lt;/code&gt; &lt;/a&gt; 를 사용하여 서브 클래스가 등록하는 모든 유형 중 하나 인 경우 유형별 동등성 함수가 생성됩니다. 보다 유용한 기본 오류 메시지 ( &lt;a href=&quot;#type-specific-methods&quot;&gt;유형별 메소드 목록&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="0e854c4d4c93154cb656dd7533a63f2e464a95d5" translate="yes" xml:space="preserve">
          <source>In addition, if a function argument is explicitly declared to be a pointer type (such as &lt;code&gt;POINTER(c_int)&lt;/code&gt;) in &lt;code&gt;argtypes&lt;/code&gt;, an object of the pointed type (&lt;code&gt;c_int&lt;/code&gt; in this case) can be passed to the function. ctypes will apply the required &lt;a href=&quot;#ctypes.byref&quot;&gt;&lt;code&gt;byref()&lt;/code&gt;&lt;/a&gt; conversion in this case automatically.</source>
          <target state="translated">또한 함수 인수가 &lt;code&gt;argtypes&lt;/code&gt; 에서 포인터 유형 (예 : &lt;code&gt;POINTER(c_int)&lt;/code&gt; ) 으로 명시 적으로 선언 된 경우 지정된 유형의 객체 ( 이 경우 &lt;code&gt;c_int&lt;/code&gt; )가 함수에 전달 될 수 있습니다. 이 경우 ctypes는 필수 &lt;a href=&quot;#ctypes.byref&quot;&gt; &lt;code&gt;byref()&lt;/code&gt; &lt;/a&gt; 변환을 자동으로 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="be2d0ea0907cf041df70ca4f4e655493e7b46100" translate="yes" xml:space="preserve">
          <source>In addition, if proxy settings are detected (for example, when a &lt;code&gt;*_proxy&lt;/code&gt; environment variable like &lt;code id=&quot;index-0&quot;&gt;http_proxy&lt;/code&gt; is set), &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt;&lt;code&gt;ProxyHandler&lt;/code&gt;&lt;/a&gt; is default installed and makes sure the requests are handled through the proxy.</source>
          <target state="translated">또한 프록시 설정이 감지되면 (예 : &lt;code id=&quot;index-0&quot;&gt;http_proxy&lt;/code&gt; 와 같은 &lt;code&gt;*_proxy&lt;/code&gt; 환경 변수 가 설정된 경우) &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt; &lt;code&gt;ProxyHandler&lt;/code&gt; &lt;/a&gt; 가 기본적으로 설치되고 프록시를 통해 요청이 처리되도록합니다.</target>
        </trans-unit>
        <trans-unit id="7b6bed6910e60de13a0aa73a3eceff08d688367d" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;a href=&quot;#string.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; defines a number of methods that are intended to be replaced by subclasses:</source>
          <target state="translated">또한 &lt;a href=&quot;#string.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 는 서브 클래스로 대체 할 여러 메소드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c9ff53ab4ada69f7c64d6901e8e9786692449da2" translate="yes" xml:space="preserve">
          <source>In addition, the Python DOM interface requires that some additional support is provided to allow &lt;code&gt;NodeList&lt;/code&gt; objects to be used as Python sequences. All &lt;code&gt;NodeList&lt;/code&gt; implementations must include support for &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt;&lt;code&gt;__len__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;; this allows iteration over the &lt;code&gt;NodeList&lt;/code&gt; in &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; statements and proper support for the &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; built-in function.</source>
          <target state="translated">또한 Python DOM 인터페이스에는 &lt;code&gt;NodeList&lt;/code&gt; 객체를 Python 시퀀스로 사용할 수 있도록 몇 가지 추가 지원이 제공 되어야합니다. 모든 &lt;code&gt;NodeList&lt;/code&gt; 구현에는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt; &lt;code&gt;__len__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 대한 지원이 포함되어야합니다 . 이것은 &lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 내장 함수 에 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 명령문 및 적절한 지원을 위해 &lt;code&gt;NodeList&lt;/code&gt; in 을 반복 할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="b6d37d6e1400b9af0d3c9c888ffe6df3d77fcdda" translate="yes" xml:space="preserve">
          <source>In addition, the Python DOM interface requires that some additional support is provided to allow &lt;code&gt;NodeList&lt;/code&gt; objects to be used as Python sequences. All &lt;code&gt;NodeList&lt;/code&gt; implementations must include support for &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__len__&quot;&gt;&lt;code&gt;__len__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;; this allows iteration over the &lt;code&gt;NodeList&lt;/code&gt; in &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; statements and proper support for the &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; built-in function.</source>
          <target state="translated">또한 Python DOM 인터페이스는 &lt;code&gt;NodeList&lt;/code&gt; 개체를 Python 시퀀스로 사용할 수 있도록 몇 가지 추가 지원이 제공 되어야합니다. 모든 &lt;code&gt;NodeList&lt;/code&gt; 구현에는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__len__&quot;&gt; &lt;code&gt;__len__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 대한 지원이 포함되어야합니다 . 이는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 문 에서 &lt;code&gt;NodeList&lt;/code&gt; 를 반복 하고 &lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 내장 함수에 대한 적절한 지원을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="d01bd464654d85025080875761ac5e61133f11b9" translate="yes" xml:space="preserve">
          <source>In addition, the following constants are defined:</source>
          <target state="translated">또한 다음 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b6828d60770f39f7550e18f2180b31c38e1ba2b8" translate="yes" xml:space="preserve">
          <source>In addition, the following error handler is specific to the given codecs:</source>
          <target state="translated">또한 다음 오류 처리기는 지정된 코덱에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a7d6c3e3ae1f40f0b841f0ae9fa2ce8b4b2c827e" translate="yes" xml:space="preserve">
          <source>In addition, the following methods unpack strings, bytes, and opaque data:</source>
          <target state="translated">또한 다음 메소드는 문자열, 바이트 및 불투명 한 데이터의 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="8f79591ef67ae18b0ee2f6ad572507855d4aebe8" translate="yes" xml:space="preserve">
          <source>In addition, the module exposes the following constant:</source>
          <target state="translated">또한 모듈은 다음 상수를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="7202589f315636dd521931132570107c0e2975e5" translate="yes" xml:space="preserve">
          <source>In addition, the module implements a &amp;ldquo;simple&amp;rdquo;</source>
          <target state="translated">또한 모듈은 &quot;간단한&quot;구현</target>
        </trans-unit>
        <trans-unit id="65768f8c8e36ecf98d8bfdf5c170282437244a45" translate="yes" xml:space="preserve">
          <source>In addition, the replacements using &lt;a href=&quot;#subprocess.check_output&quot;&gt;&lt;code&gt;check_output()&lt;/code&gt;&lt;/a&gt; will fail with a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt; if the requested operation produces a non-zero return code. The output is still available as the &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt; attribute of the raised exception.</source>
          <target state="translated">또한, 요청 된 조작이 0이 아닌 리턴 코드를 생성하면 &lt;a href=&quot;#subprocess.check_output&quot;&gt; &lt;code&gt;check_output()&lt;/code&gt; &lt;/a&gt; 을 사용한 대체 는 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; &lt;/a&gt; 와 함께 실패 합니다. 출력은 여전히 발생한 예외 의 &lt;a href=&quot;#subprocess.CalledProcessError.output&quot;&gt; &lt;code&gt;output&lt;/code&gt; &lt;/a&gt; 속성으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="24d6f5e76f333b5e2721aafc94f1e5f93dcadd61" translate="yes" xml:space="preserve">
          <source>In addition, those methods can raise &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; if the underlying raw stream is in non-blocking mode and cannot take or give enough data; unlike their &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; counterparts, they will never return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">또한 기본 원시 스트림이 비 블로킹 모드에 있고 충분한 데이터를 가져 오거나 제공 할 수없는 경우 이러한 메소드는 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 를&lt;/a&gt; 발생시킬 수 있습니다. &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;None&lt;/code&gt; 을 반환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0c8203792cc7837023ccc2f6c27be6b401948da" translate="yes" xml:space="preserve">
          <source>In all but the last case, behaviour is as for the &lt;a href=&quot;#fcntl.fcntl&quot;&gt;&lt;code&gt;fcntl()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">마지막 경우를 제외하고는 동작은 &lt;a href=&quot;#fcntl.fcntl&quot;&gt; &lt;code&gt;fcntl()&lt;/code&gt; &lt;/a&gt; 함수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="692d29dfab8ab67219a17ecaca49c353f09b7b11" translate="yes" xml:space="preserve">
          <source>In all cases, if the optional parts are omitted, the code is executed in the current scope. If only &lt;em&gt;globals&lt;/em&gt; is provided, it must be a dictionary (and not a subclass of dictionary), which will be used for both the global and the local variables. If &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; are given, they are used for the global and local variables, respectively. If provided, &lt;em&gt;locals&lt;/em&gt; can be any mapping object. Remember that at module level, globals and locals are the same dictionary. If exec gets two separate objects as &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt;, the code will be executed as if it were embedded in a class definition.</source>
          <target state="translated">모든 경우에 선택적 부분을 생략하면 현재 범위에서 코드가 실행됩니다. &lt;em&gt;전역 변수&lt;/em&gt; 만 제공되는 경우 사전 (하위 클래스의 하위 클래스 아님)이어야하며 전역 및 로컬 변수에 모두 사용됩니다. &lt;em&gt;전역 변수&lt;/em&gt; 와 &lt;em&gt;지역 &lt;/em&gt;&lt;em&gt;변수&lt;/em&gt; 가 제공 되면 &lt;em&gt;전역 변수&lt;/em&gt; 와 지역 변수에 각각 사용됩니다. 제공되는 경우 &lt;em&gt;로컬&lt;/em&gt; 은 모든 매핑 객체 일 수 있습니다. 모듈 수준에서 전역과 지역은 같은 사전입니다. exec가 &lt;em&gt;globals&lt;/em&gt; 및 &lt;em&gt;locals&lt;/em&gt; 로 두 개의 개별 객체를 얻는 경우 코드는 마치 클래스 정의에 포함 된 것처럼 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4ce297ce9195276151aae56fb9d8405d81d59aba" translate="yes" xml:space="preserve">
          <source>In an editor, import statements have no effect until one runs the file. One might want to run a file after writing import statements, after adding function definitions, or after opening an existing file.</source>
          <target state="translated">편집기에서 import 문은 파일을 실행할 때까지 효과가 없습니다. import 문을 작성한 후, 함수 정의를 추가 한 후 또는 기존 파일을 연 후 파일을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e125a1f4b01ec045b13c222789290bf79d3655aa" translate="yes" xml:space="preserve">
          <source>In an editor, import statements have no effect until one runs the file. One might want to run a file after writing the import statements at the top, or immediately run an existing file before editing.</source>
          <target state="translated">편집기에서 import 문은 파일을 실행할 때까지 적용되지 않습니다. 맨 위에 import 문을 작성한 후 파일을 실행하거나 편집하기 전에 기존 파일을 즉시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7585fd505655ba1d8efec7b44c9872a4847511d0" translate="yes" xml:space="preserve">
          <source>In any case, the parameter value (either the returned string, or the &lt;code&gt;VALUE&lt;/code&gt; item in the 3-tuple) is always unquoted, unless &lt;em&gt;unquote&lt;/em&gt; is set to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">어쨌든 &lt;em&gt;unquote&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 로 설정되어 있지 않으면 매개 변수 값 (반환 된 문자열 또는 3 튜플 의 &lt;code&gt;VALUE&lt;/code&gt; 항목)이 항상 인용되지 않습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ea5e474a620a942ee44b6caa68731405ccc53b7" translate="yes" xml:space="preserve">
          <source>In asyncio, child processes are created with &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">asyncio에서 하위 프로세스는 &lt;a href=&quot;asyncio-subprocess#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9c6189bdb6109a3314f3a6fa2e8324565b928c" translate="yes" xml:space="preserve">
          <source>In calls to &lt;a href=&quot;#time.mktime&quot;&gt;&lt;code&gt;mktime()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tm_isdst&lt;/code&gt; may be set to 1 when daylight savings time is in effect, and 0 when it is not. A value of -1 indicates that this is not known, and will usually result in the correct state being filled in.</source>
          <target state="translated">호출에 &lt;a href=&quot;#time.mktime&quot;&gt; &lt;code&gt;mktime()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;tm_isdst&lt;/code&gt; 는 그렇지 않은 경우 일광 절약 시간이 적용되는 경우에 1로 설정하고, 0 수있다. -1 값은 알 수 없음을 나타내며 일반적으로 올바른 상태가 채워집니다.</target>
        </trans-unit>
        <trans-unit id="1319e988c1be1fbecde5f67e0f759a6ee96a90b4" translate="yes" xml:space="preserve">
          <source>In case just an immediate sorting of the nodes in the graph is required and no parallelism is involved, the convenience method &lt;a href=&quot;#graphlib.TopologicalSorter.static_order&quot;&gt;&lt;code&gt;TopologicalSorter.static_order()&lt;/code&gt;&lt;/a&gt; can be used directly:</source>
          <target state="translated">그래프에서 노드의 즉각적인 정렬이 필요하고 병렬 처리가 관련되지 않은 경우 편리한 메서드 &lt;a href=&quot;#graphlib.TopologicalSorter.static_order&quot;&gt; &lt;code&gt;TopologicalSorter.static_order()&lt;/code&gt; &lt;/a&gt; 를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc48b1dca0b1da787a928b9dd93dc589bfde5754" translate="yes" xml:space="preserve">
          <source>In cases when only the library handle is available rather than the object, accessing a function raises an auditing event &lt;code&gt;ctypes.dlsym/handle&lt;/code&gt; with arguments &lt;code&gt;handle&lt;/code&gt; (the raw library handle) and &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">오브젝트가 아닌 라이브러리 핸들 만 사용 가능한 경우, 함수에 액세스하면 인수 &lt;code&gt;handle&lt;/code&gt; (원시 라이브러리 핸들) 및 &lt;code&gt;name&lt;/code&gt; 과 함께 감사 이벤트 &lt;code&gt;ctypes.dlsym/handle&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="30db5ca10a27995819aa59775e12a2ebd80f3013" translate="yes" xml:space="preserve">
          <source>In cases where canonical output is not applicable but a specific attribute order is still desirable on output, code should aim for creating the attributes directly in the desired order, to avoid perceptual mismatches for readers of the code. In cases where this is difficult to achieve, a recipe like the following can be applied prior to serialisation to enforce an order independently from the Element creation:</source>
          <target state="translated">표준 출력이 적용되지 않지만 출력에서 ​​특정 속성 순서가 여전히 바람직한 경우, 코드는 코드 판독기에 대한 지각 불일치를 피하기 위해 원하는 순서로 속성을 직접 작성하는 것을 목표로해야합니다. 이를 달성하기 어려운 경우, 요소 생성과 독립적으로 주문을 시행하기 위해 직렬화 전에 다음과 같은 레시피를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a76a269c9a0813ca8158d4ca521d20cd58a501b" translate="yes" xml:space="preserve">
          <source>In config parsers, values can span multiple lines as long as they are indented more than the key that holds them. By default parsers also let empty lines to be parts of values. At the same time, keys can be arbitrarily indented themselves to improve readability. In consequence, when configuration files get big and complex, it is easy for the user to lose track of the file structure. Take for instance:</source>
          <target state="translated">구성 파서에서는 값을 보유하는 키보다 들여 쓰기 만하면 값이 여러 줄에 걸쳐있을 수 있습니다. 기본적으로 파서는 빈 줄이 값의 일부가되도록합니다. 동시에 가독성을 높이기 위해 키를 임의로 들여 쓸 수 있습니다. 결과적으로 구성 파일이 커지고 복잡해지면 사용자가 파일 구조를 쉽게 잃을 수 있습니다. 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="4474384d258039b476c26e51f3dc73c8e1621318" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;NewType&lt;/code&gt; declares one type to be a &lt;em&gt;subtype&lt;/em&gt; of another. Doing &lt;code&gt;Derived = NewType('Derived', Original)&lt;/code&gt; will make the static type checker treat &lt;code&gt;Derived&lt;/code&gt; as a &lt;em&gt;subclass&lt;/em&gt; of &lt;code&gt;Original&lt;/code&gt;, which means a value of type &lt;code&gt;Original&lt;/code&gt; cannot be used in places where a value of type &lt;code&gt;Derived&lt;/code&gt; is expected. This is useful when you want to prevent logic errors with minimal runtime cost.</source>
          <target state="translated">반대로 &lt;code&gt;NewType&lt;/code&gt; 은 한 유형을 다른 &lt;em&gt;유형&lt;/em&gt; 의 &lt;em&gt;하위&lt;/em&gt; 유형으로 선언합니다 . 하고 &lt;code&gt;Derived = NewType('Derived', Original)&lt;/code&gt; 정적 형 검사 치료하게됩니다 &lt;code&gt;Derived&lt;/code&gt; A와 &lt;em&gt;서브 클래스&lt;/em&gt; 의 &lt;code&gt;Original&lt;/code&gt; 형식의 값 의미, &lt;code&gt;Original&lt;/code&gt; 유형의 값 장소에서 사용할 수 없습니다 &lt;code&gt;Derived&lt;/code&gt; 예상된다. 이는 최소한의 런타임 비용으로 논리 오류를 방지하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="808194d88f87f062e3f917a77c2fd08a648ff57f" translate="yes" xml:space="preserve">
          <source>In debug builds, the list of default warning filters is empty.</source>
          <target state="translated">디버그 빌드에서 기본 경고 필터 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acc6dc48ce98dfe1787544928804d1351131ed2d" translate="yes" xml:space="preserve">
          <source>In developing fixed-point applications, it is convenient to define functions to handle the &lt;code&gt;quantize()&lt;/code&gt; step:</source>
          <target state="translated">고정 소수점 애플리케이션을 개발할 때, &lt;code&gt;quantize()&lt;/code&gt; 단계 를 처리하는 함수를 정의하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="c77a995d67e443f20620e90b24b791b5af7d08e6" translate="yes" xml:space="preserve">
          <source>In earlier versions, the terminator was hardcoded as &lt;code&gt;'\n'&lt;/code&gt;.</source>
          <target state="translated">이전 버전에서 종결자는 &lt;code&gt;'\n'&lt;/code&gt; 으로 하드 코딩되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c977d792bc856342f19c64cada581050dd1e4694" translate="yes" xml:space="preserve">
          <source>In either case, the exception itself is always shown after any chained exceptions so that the final line of the traceback always shows the last exception that was raised.</source>
          <target state="translated">어느 경우 든 예외 자체는 항상 체인 예외 뒤에 표시되므로 역 추적의 마지막 행에는 항상 마지막으로 발생한 예외가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="22384914a04d22b7049ea2fa018ad8b0c6e7dc2b" translate="yes" xml:space="preserve">
          <source>In either case, when producing an &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant header using &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; rules, the string will be encoded using the output codec of the charset. If the string cannot be encoded using the output codec, a UnicodeError will be raised.</source>
          <target state="translated">두 경우 모두 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 규칙을 사용하여 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 호환 헤더를 생성 할 때 문자열은 문자셋의 출력 코덱을 사용하여 인코딩됩니다. 출력 코덱을 사용하여 문자열을 인코딩 할 수 없으면 UnicodeError가 발생합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="245fefefdc72a1779e932cbff8e651714d2e5fec" translate="yes" xml:space="preserve">
          <source>In emergencies this method will discard any data held in the input and/or output buffers and the producer queue.</source>
          <target state="translated">응급 상황에서이 방법은 입력 및 / 또는 출력 버퍼와 생산자 대기열에 보관 된 모든 데이터를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="965c8af21ae4828757fda71d55deb0166d6df2fd" translate="yes" xml:space="preserve">
          <source>In essence, a Condition object combines the functionality of an &lt;a href=&quot;#asyncio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; and a &lt;a href=&quot;#asyncio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;. It is possible to have multiple Condition objects share one Lock, which allows coordinating exclusive access to a shared resource between different tasks interested in particular states of that shared resource.</source>
          <target state="translated">본질적으로 Condition 객체는 &lt;a href=&quot;#asyncio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 기능 과 &lt;a href=&quot;#asyncio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 기능을 결합합니다 . 여러 조건 개체가 하나의 잠금을 공유하도록하는 것이 가능하며,이를 통해 해당 공유 리소스의 특정 상태에 관심이있는 다른 작업간에 공유 리소스에 대한 독점 액세스를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab7997c363058025f4902dd79fa90e9d4f7cc8a" translate="yes" xml:space="preserve">
          <source>In fact, the above algorithm is first tried for methods named &lt;code&gt;default_open()&lt;/code&gt;. If all such methods return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the algorithm is repeated for methods named like &lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt;. If all such methods return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the algorithm is repeated for methods named &lt;code&gt;unknown_open()&lt;/code&gt;.</source>
          <target state="translated">사실 위의 알고리즘은 먼저 &lt;code&gt;default_open()&lt;/code&gt; 이라는 메서드에 대해 시도됩니다 . 이러한 모든 메소드가 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 리턴하면 &lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt; 과 같은 메소드에 대해 알고리즘이 반복됩니다 . 이러한 모든 메소드가 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; 을&lt;/a&gt; 리턴 하면 &lt;code&gt;unknown_open()&lt;/code&gt; 이라는 메소드에 대해 알고리즘이 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a31e0e92af099e0fc4c6092b67160da2329774b" translate="yes" xml:space="preserve">
          <source>In general (and especially on systems without overallocation), it is recommended to estimate even tighter bounds and set the &lt;a href=&quot;#decimal.Inexact&quot;&gt;&lt;code&gt;Inexact&lt;/code&gt;&lt;/a&gt; trap if all calculations are expected to be exact.</source>
          <target state="translated">일반적으로 (특히 초과 할당이없는 시스템에서) 모든 계산이 정확할 것으로 예상되는 경우 더 엄격한 경계를 추정하고 &lt;a href=&quot;#decimal.Inexact&quot;&gt; &lt;code&gt;Inexact&lt;/code&gt; &lt;/a&gt; 트랩을 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="26db7d03f5d7b2f8484e83cc9df341e5fcb76c6d" translate="yes" xml:space="preserve">
          <source>In general, &lt;em&gt;t1&lt;/em&gt; * i == &lt;em&gt;t1&lt;/em&gt; * (i-1) + &lt;em&gt;t1&lt;/em&gt; is true. (1)</source>
          <target state="translated">일반적으로 &lt;em&gt;t1&lt;/em&gt; * i == &lt;em&gt;t1&lt;/em&gt; * (i-1) + &lt;em&gt;t1&lt;/em&gt; 은 true입니다. (1)</target>
        </trans-unit>
        <trans-unit id="0506d07a792bdf1420c6f5ee2d8683b4bb973f20" translate="yes" xml:space="preserve">
          <source>In general, it should be the case that &lt;a href=&quot;#http.cookies.BaseCookie.value_encode&quot;&gt;&lt;code&gt;value_encode()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.cookies.BaseCookie.value_decode&quot;&gt;&lt;code&gt;value_decode()&lt;/code&gt;&lt;/a&gt; are inverses on the range of &lt;em&gt;value_decode&lt;/em&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#http.cookies.BaseCookie.value_encode&quot;&gt; &lt;code&gt;value_encode()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#http.cookies.BaseCookie.value_decode&quot;&gt; &lt;code&gt;value_decode()&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;value_decode&lt;/em&gt; 범위에서 &lt;em&gt;반대 인 경우&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df0b5cf5765724139c03b2e68725a9a7fc0cadf5" translate="yes" xml:space="preserve">
          <source>In general, protocol implementations that use transport-based APIs such as &lt;a href=&quot;#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt; are faster than implementations that work with sockets directly. However, there are some use cases when performance is not critical, and working with &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; objects directly is more convenient.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; 와 같은 전송 기반 API를 사용하는 프로토콜 구현은 소켓에서 직접 작동하는 구현보다 빠릅니다. 그러나 성능이 중요하지 않은 경우가 있으며 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 객체를 직접 사용하는 것이 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="20cd72495b8797b1b45d990ccd4902f5c5f42a41" translate="yes" xml:space="preserve">
          <source>In general, the &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module assumes that flags like &lt;code&gt;-f&lt;/code&gt; and &lt;code&gt;--bar&lt;/code&gt; indicate &lt;em&gt;optional&lt;/em&gt; arguments, which can always be omitted at the command line. To make an option &lt;em&gt;required&lt;/em&gt;, &lt;code&gt;True&lt;/code&gt; can be specified for the &lt;code&gt;required=&lt;/code&gt; keyword argument to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;code&gt;-f&lt;/code&gt; 및 &lt;code&gt;--bar&lt;/code&gt; 와 같은 플래그 가 &lt;em&gt;선택적&lt;/em&gt; 인수를 나타내며 명령 행에서 항상 생략 할 수 있다고 가정합니다 . 옵션하려면 &lt;em&gt;필요를&lt;/em&gt; , &lt;code&gt;True&lt;/code&gt; 을 지정할 수 있습니다 &lt;code&gt;required=&lt;/code&gt; 키워드 인수 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c4db8812f85eaab112b76e9bb72d0ea809a10832" translate="yes" xml:space="preserve">
          <source>In general, the LRU cache should only be used when you want to reuse previously computed values. Accordingly, it doesn&amp;rsquo;t make sense to cache functions with side-effects, functions that need to create distinct mutable objects on each call, or impure functions such as time() or random().</source>
          <target state="translated">일반적으로 LRU 캐시는 이전에 계산 된 값을 재사용하려는 경우에만 사용해야합니다. 따라서 부작용이있는 함수, 각 호출마다 고유 한 가변 객체를 작성해야하는 함수, time () 또는 random ()과 같은 불순한 함수를 캐시하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0855957cf96cc591654edbae97ba73e1a179c2a2" translate="yes" xml:space="preserve">
          <source>In general, this function should be preferred over &lt;a href=&quot;os#os.getlogin&quot;&gt;&lt;code&gt;os.getlogin()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로이 함수는 &lt;a href=&quot;os#os.getlogin&quot;&gt; &lt;code&gt;os.getlogin()&lt;/code&gt; &lt;/a&gt; 보다 선호되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="440426040cf7cbfc6d96c968361e3b6f6f71b8cf" translate="yes" xml:space="preserve">
          <source>In general, user code should try not to depend on a specific ordering of attributes, given that the &lt;a href=&quot;https://www.w3.org/TR/xml-infoset/&quot;&gt;XML Information Set&lt;/a&gt; explicitly excludes the attribute order from conveying information. Code should be prepared to deal with any ordering on input. In cases where deterministic XML output is required, e.g. for cryptographic signing or test data sets, canonical serialisation is available with the &lt;a href=&quot;#xml.etree.ElementTree.canonicalize&quot;&gt;&lt;code&gt;canonicalize()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;https://www.w3.org/TR/xml-infoset/&quot;&gt;XML 정보 세트가 정보&lt;/a&gt; 전달에서 속성 순서를 명시 적으로 제외하는 경우 사용자 코드는 특정 속성 순서에 의존하지 않아야합니다. 입력에 대한 모든 주문을 처리 할 수 ​​있도록 코드를 준비해야합니다. 암호화 서명 또는 테스트 데이터 세트와 같이 결정 론적 XML 출력이 필요한 경우 &lt;a href=&quot;#xml.etree.ElementTree.canonicalize&quot;&gt; &lt;code&gt;canonicalize()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 표준 직렬화를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8e833685e558fad9e6d2aed4b5edd8ed53ab53a" translate="yes" xml:space="preserve">
          <source>In general, you can pack any of the most common XDR data types by calling the appropriate &lt;code&gt;pack_type()&lt;/code&gt; method. Each method takes a single argument, the value to pack. The following simple data type packing methods are supported: &lt;code&gt;pack_uint()&lt;/code&gt;, &lt;code&gt;pack_int()&lt;/code&gt;, &lt;code&gt;pack_enum()&lt;/code&gt;, &lt;code&gt;pack_bool()&lt;/code&gt;, &lt;code&gt;pack_uhyper()&lt;/code&gt;, and &lt;code&gt;pack_hyper()&lt;/code&gt;.</source>
          <target state="translated">일반적으로 적절한 &lt;code&gt;pack_type()&lt;/code&gt; 메소드를 호출하여 가장 일반적인 XDR 데이터 유형을 압축 할 수 있습니다 . 각 메소드는 팩킹 할 값인 단일 인수를 사용합니다. &lt;code&gt;pack_uint()&lt;/code&gt; , &lt;code&gt;pack_int()&lt;/code&gt; , &lt;code&gt;pack_enum()&lt;/code&gt; , &lt;code&gt;pack_bool()&lt;/code&gt; , &lt;code&gt;pack_uhyper()&lt;/code&gt; 및 &lt;code&gt;pack_hyper()&lt;/code&gt; 와 같은 간단한 데이터 유형 패킹 방법이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="7051fb77a6d138d8bb42933ac13b4fab45cc061e" translate="yes" xml:space="preserve">
          <source>In general, you will want to use the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package&amp;rsquo;s features to construct an email message, which you can then send via &lt;a href=&quot;#smtplib.SMTP.send_message&quot;&gt;&lt;code&gt;send_message()&lt;/code&gt;&lt;/a&gt;; see &lt;a href=&quot;email.examples#email-examples&quot;&gt;email: Examples&lt;/a&gt;.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지의 기능 을 사용하여 전자 메일 메시지를 &lt;a href=&quot;#smtplib.SMTP.send_message&quot;&gt; &lt;code&gt;send_message()&lt;/code&gt; &lt;/a&gt; 다음 send_message () 를 통해 보낼 수 있습니다 . &lt;a href=&quot;email.examples#email-examples&quot;&gt;이메일 : 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="840dd19adeba7204bf237688be99f304d742eb60" translate="yes" xml:space="preserve">
          <source>In its basic form, &lt;a href=&quot;#module-pprint&quot;&gt;&lt;code&gt;pprint()&lt;/code&gt;&lt;/a&gt; shows the whole object:</source>
          <target state="translated">기본 형식으로 &lt;a href=&quot;#module-pprint&quot;&gt; &lt;code&gt;pprint()&lt;/code&gt; &lt;/a&gt; 는 전체 객체를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="70cdc658f4f5ab332fd8069815a9324e25e35d83" translate="yes" xml:space="preserve">
          <source>In less formal terms, the replacement field can start with a &lt;em&gt;field_name&lt;/em&gt; that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The &lt;em&gt;field_name&lt;/em&gt; is optionally followed by a &lt;em&gt;conversion&lt;/em&gt; field, which is preceded by an exclamation point &lt;code&gt;'!'&lt;/code&gt;, and a &lt;em&gt;format_spec&lt;/em&gt;, which is preceded by a colon &lt;code&gt;':'&lt;/code&gt;. These specify a non-default format for the replacement value.</source>
          <target state="translated">덜 공식적인 용어로 대체 필드는 값을 바꾸고 대체 필드 대신 출력에 삽입 할 오브젝트를 지정 하는 &lt;em&gt;field_name으로&lt;/em&gt; 시작할 수 있습니다 . &lt;em&gt;FIELD_NAME은&lt;/em&gt; 임의로 이어진다 &lt;em&gt;변환&lt;/em&gt; 느낌표가 선행 필드, &lt;code&gt;'!'&lt;/code&gt; , 및 &lt;em&gt;format_spec&lt;/em&gt; 은 콜론 &lt;code&gt;':'&lt;/code&gt; 앞에옵니다 . 대체 값에 기본이 아닌 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="207eed5cab33c7fd44f50216fdcd9b7ae0089e35" translate="yes" xml:space="preserve">
          <source>In less ideal cases, applications can be checked for use of deprecated interfaces by passing &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-Wd&lt;/code&gt;&lt;/a&gt; to the Python interpreter (this is shorthand for &lt;code&gt;-W default&lt;/code&gt;) or setting &lt;code&gt;PYTHONWARNINGS=default&lt;/code&gt; in the environment. This enables default handling for all warnings, including those that are ignored by default. To change what action is taken for encountered warnings you can change what argument is passed to &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;-W error&lt;/code&gt;). See the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; flag for more details on what is possible.</source>
          <target state="translated">덜 이상적인 경우, &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-Wd&lt;/code&gt; &lt;/a&gt; 를 Python 인터프리터 에 전달 하거나 ( &lt;code&gt;-W default&lt;/code&gt; 의 약자 ) 환경에서 &lt;code&gt;PYTHONWARNINGS=default&lt;/code&gt; 를 설정 하여 더 이상 사용되지 않는 인터페이스의 사용 여부를 애플리케이션에서 확인할 수 있습니다 . 이를 통해 기본적으로 무시되는 경고를 포함하여 모든 경고에 대한 기본 처리가 가능합니다. 발생한 경고에 대해 수행 할 조치를 변경하려면 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 에&lt;/a&gt; 전달되는 인수를 변경하십시오 (예 : &lt;code&gt;-W error&lt;/code&gt; ). 가능한 것에 대한 자세한 내용 은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 플래그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5deeb99b968c8e414257704717db80af0082601c" translate="yes" xml:space="preserve">
          <source>In less ideal cases, applications can be checked for use of deprecated interfaces by passing &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-Wd&lt;/code&gt;&lt;/a&gt; to the Python interpreter (this is shorthand for &lt;code&gt;-W default&lt;/code&gt;) or setting &lt;code&gt;PYTHONWARNINGS=default&lt;/code&gt; in the environment. This enables default handling for all warnings, including those that are ignored by default. To change what action is taken for encountered warnings you can change what argument is passed to &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;-W error&lt;/code&gt;). See the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; flag for more details on what is possible.</source>
          <target state="translated">이상적이지 않은 경우에는 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-Wd&lt;/code&gt; &lt;/a&gt; 를 Python 인터프리터 에 전달 하거나 ( &lt;code&gt;-W default&lt;/code&gt; 의 약칭 ) 환경에서 &lt;code&gt;PYTHONWARNINGS=default&lt;/code&gt; 를 설정 하여 응용 프로그램에서 더 이상 사용되지 않는 인터페이스를 사용하는지 확인할 수 있습니다 . 이렇게하면 기본적으로 무시되는 경고를 포함하여 모든 경고에 대한 기본 처리가 활성화됩니다. 발생한 경고에 대해 수행되는 작업을 변경하려면 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; 에&lt;/a&gt; 전달되는 인수를 변경할 수 있습니다 (예 : &lt;code&gt;-W error&lt;/code&gt; ). 가능한 사항에 대한 자세한 내용 은 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 플래그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="534991bf3a76b961bedcef085ae867583416a5d2" translate="yes" xml:space="preserve">
          <source>In many cases you will just be able to add &lt;code&gt;autospec=True&lt;/code&gt; to your existing &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; calls and then be protected against bugs due to typos and api changes.</source>
          <target state="translated">대부분의 경우 기존 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 호출 에 &lt;code&gt;autospec=True&lt;/code&gt; 를 추가 한 다음 오타 및 API 변경으로 인한 버그로부터 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8b6f5d72094bed2a418a171229c3a3461791a6" translate="yes" xml:space="preserve">
          <source>In many use-cases one doesn&amp;rsquo;t care what the actual value of an enumeration is. There are several ways to define this type of simple enumeration:</source>
          <target state="translated">많은 유스 케이스에서 열거의 실제 값이 무엇인지 신경 쓰지 않습니다. 이 유형의 간단한 열거를 정의하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="683dda921eb9dde69c65282fd8a1442adc4883df" translate="yes" xml:space="preserve">
          <source>In most cases a copy-and-paste of an interactive console session works fine, but doctest isn&amp;rsquo;t trying to do an exact emulation of any specific Python shell.</source>
          <target state="translated">대부분의 경우 대화 형 콘솔 세션의 복사하여 붙여 넣기는 잘 작동하지만 doctest는 특정 Python 셸을 정확하게 에뮬레이션하려고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c95379866d99798cdc6b44f569e45b47b03caff" translate="yes" xml:space="preserve">
          <source>In most cases, end users of Python shouldn&amp;rsquo;t need to invoke this module directly (as &lt;code&gt;pip&lt;/code&gt; should be bootstrapped by default), but it may be needed if installing &lt;code&gt;pip&lt;/code&gt; was skipped when installing Python (or when creating a virtual environment) or after explicitly uninstalling &lt;code&gt;pip&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 Python 최종 사용자는이 모듈을 직접 호출 할 필요는 없지만 ( &lt;code&gt;pip&lt;/code&gt; 는 기본적으로 부트 스트랩되어야 함) Python을 설치할 때 (또는 가상 환경을 만들 때) 또는 이후에 &lt;code&gt;pip&lt;/code&gt; 설치 를 건너 뛴 경우 필요할 수 있습니다. &lt;code&gt;pip&lt;/code&gt; 를 명시 적으로 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="976b8e0f0142bf68fb963efdbb1f64f443c3a2d4" translate="yes" xml:space="preserve">
          <source>In most cases, no additional code is needed to make instances picklable. By default, pickle will retrieve the class and the attributes of an instance via introspection. When a class instance is unpickled, its &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method is usually &lt;em&gt;not&lt;/em&gt; invoked. The default behaviour first creates an uninitialized instance and then restores the saved attributes. The following code shows an implementation of this behaviour:</source>
          <target state="translated">대부분의 경우 인스턴스를 선택 가능하게하기 위해 추가 코드가 필요하지 않습니다. 기본적으로 pickle은 내부 검사를 통해 인스턴스의 클래스 및 속성을 검색합니다. 클래스 인스턴스가 선택 해제되면 일반적으로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 &lt;em&gt;되지 않습니다&lt;/em&gt; . 기본 동작은 먼저 초기화되지 않은 인스턴스를 생성 한 다음 저장된 속성을 복원합니다. 다음 코드는이 동작의 구현을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cabb038d56d4da17821816a55c6f8a5a0d8697d5" translate="yes" xml:space="preserve">
          <source>In most cases, no additional code is needed to make instances picklable. By default, pickle will retrieve the class and the attributes of an instance via introspection. When a class instance is unpickled, its &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method is usually &lt;em&gt;not&lt;/em&gt; invoked. The default behaviour first creates an uninitialized instance and then restores the saved attributes. The following code shows an implementation of this behaviour:</source>
          <target state="translated">대부분의 경우 인스턴스를 피클 가능하게 만드는 데 추가 코드가 필요하지 않습니다. 기본적으로 pickle은 인트로 스펙 션을 통해 인스턴스의 클래스와 속성을 검색합니다. 클래스 인스턴스가 피클 해제되면 일반적으로 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메서드가 호출 &lt;em&gt;되지 않습니다&lt;/em&gt; . 기본 동작은 먼저 초기화되지 않은 인스턴스를 만든 다음 저장된 속성을 복원합니다. 다음 코드는이 동작의 구현을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4529cbb146eb6065739aafbd505c95e547aa3ac8" translate="yes" xml:space="preserve">
          <source>In most coding situations, strings are translated where they are coded. Occasionally however, you need to mark strings for translation, but defer actual translation until later. A classic example is:</source>
          <target state="translated">대부분의 코딩 상황에서 문자열은 코딩 된 위치에서 변환됩니다. 그러나 때때로 번역을 위해 문자열을 표시해야하지만 나중에 실제 번역을 연기해야합니다. 전형적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c31666ba6595f7dfef709e3c800c98df8b264362" translate="yes" xml:space="preserve">
          <source>In most of the cases the syntax is similar to the old &lt;code&gt;%&lt;/code&gt;-formatting, with the addition of the &lt;code&gt;{}&lt;/code&gt; and with &lt;code&gt;:&lt;/code&gt; used instead of &lt;code&gt;%&lt;/code&gt;. For example, &lt;code&gt;'%03.2f'&lt;/code&gt; can be translated to &lt;code&gt;'{:03.2f}'&lt;/code&gt;.</source>
          <target state="translated">대부분의 경우 구문은 &lt;code&gt;{}&lt;/code&gt; 을 추가 하고 &lt;code&gt;%&lt;/code&gt; 대신 &lt;code&gt;:&lt;/code&gt; 을 사용 하여 이전 &lt;code&gt;%&lt;/code&gt; 형식화 와 유사합니다 . 예를 들어 &lt;code&gt;'%03.2f'&lt;/code&gt; 는 &lt;code&gt;'{:03.2f}'&lt;/code&gt; 로 변환 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1d67672f1befe30b1ea6b9c0e813f8ca041dc72" translate="yes" xml:space="preserve">
          <source>In most situations, however, there&amp;rsquo;s only one form control with a particular name in a form and then you expect and need only one value associated with this name. So you write a script containing for example this code:</source>
          <target state="translated">그러나 대부분의 상황에서는 양식에 특정 이름을 가진 양식 컨트롤이 하나뿐이므로이 이름과 관련된 값은 하나만 필요합니다. 따라서 다음 코드를 포함하는 스크립트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="183e56009447f48c5edb38c8e56a603f6df422c3" translate="yes" xml:space="preserve">
          <source>In most typical applications, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will take care of formatting and printing any usage or error messages. However, several formatting methods are available:</source>
          <target state="translated">대부분의 일반적인 응용 프로그램에서 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 사용 또는 오류 메시지의 형식을 지정하고 인쇄합니다. 그러나 몇 가지 형식 지정 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6110d599bf96dfc74514b0a56521412fa449261" translate="yes" xml:space="preserve">
          <source>In normal operation it should not be necessary to call this method explicitly. It is used to implement other methods and may be useful for testing private extensions.</source>
          <target state="translated">정상적인 작동에서는이 메소드를 명시 적으로 호출 할 필요가 없습니다. 다른 메소드를 구현하는 데 사용되며 개인용 확장을 테스트하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8321d4dc57900cf19439382b3532766a68fb010" translate="yes" xml:space="preserve">
          <source>In normal operation it should not be necessary to call this method explicitly. It will be implicitly called by the &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;sendmail()&lt;/code&gt;&lt;/a&gt; when necessary.</source>
          <target state="translated">정상적인 작동에서는이 메소드를 명시 적으로 호출 할 필요가 없습니다. 필요한 경우 &lt;a href=&quot;#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;sendmail()&lt;/code&gt; &lt;/a&gt; 의해 암시 적으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="a16e8babf22923c28939e3500c17a67bb3cff77f" translate="yes" xml:space="preserve">
          <source>In order for a class to define its own copy implementation, it can define special methods &lt;code&gt;__copy__()&lt;/code&gt; and &lt;code&gt;__deepcopy__()&lt;/code&gt;. The former is called to implement the shallow copy operation; no additional arguments are passed. The latter is called to implement the deep copy operation; it is passed one argument, the &lt;code&gt;memo&lt;/code&gt; dictionary. If the &lt;code&gt;__deepcopy__()&lt;/code&gt; implementation needs to make a deep copy of a component, it should call the &lt;a href=&quot;#copy.deepcopy&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt; function with the component as first argument and the memo dictionary as second argument.</source>
          <target state="translated">클래스가 자체의 복사 구현을 정의하기 위해 특수 메소드 &lt;code&gt;__copy__()&lt;/code&gt; 및 &lt;code&gt;__deepcopy__()&lt;/code&gt; 정의 할 수 있습니다 . 전자는 얕은 복사 작업을 구현하기 위해 호출됩니다. 추가 인수는 전달되지 않습니다. 후자는 깊은 복사 작업을 구현하기 위해 호출됩니다. &lt;code&gt;memo&lt;/code&gt; 사전 이라는 하나의 인수가 전달 됩니다. 는 IF &lt;code&gt;__deepcopy__()&lt;/code&gt; 구현 필요 구성 요소의 전체 복사본을 만들기 위해, 그것은 호출해야 &lt;a href=&quot;#copy.deepcopy&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; &lt;/a&gt; 첫번째 인자와 두번째 인자로 메모 사전과 같은 구성 요소와 기능을.</target>
        </trans-unit>
        <trans-unit id="2e949fa3a8f8fff7c3917f737f8813ee6973dfb5" translate="yes" xml:space="preserve">
          <source>In order to correctly interoperate with the abstract base class machinery, the descriptor must identify itself as abstract using &lt;code&gt;__isabstractmethod__&lt;/code&gt;. In general, this attribute should be &lt;code&gt;True&lt;/code&gt; if any of the methods used to compose the descriptor are abstract. For example, Python&amp;rsquo;s built-in &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; does the equivalent of:</source>
          <target state="translated">추상 기본 클래스 기계와 올바르게 상호 작용하려면 설명 &lt;code&gt;__isabstractmethod__&lt;/code&gt; 사용하여 추상으로 식별해야합니다 . 디스크립터를 구성하는 데 사용 된 메소드가 추상적이면 이 속성은 일반적으로 &lt;code&gt;True&lt;/code&gt; 여야합니다 . 예를 들어 Python의 내장 &lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c467fc7d115d441ac819d2c9cc479eaeade84679" translate="yes" xml:space="preserve">
          <source>In order to find objects and their documentation, &lt;a href=&quot;#module-pydoc&quot;&gt;&lt;code&gt;pydoc&lt;/code&gt;&lt;/a&gt; imports the module(s) to be documented. Therefore, any code on module level will be executed on that occasion. Use an &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; guard to only execute code when a file is invoked as a script and not just imported.</source>
          <target state="translated">&lt;a href=&quot;#module-pydoc&quot;&gt; &lt;code&gt;pydoc&lt;/code&gt; &lt;/a&gt; 은 객체와 문서를 찾기 위해 문서화 할 모듈을 가져옵니다. 따라서 모듈 수준의 모든 코드가 해당 시점에 실행됩니다. 사용 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 파일을 바로 가져올 스크립트로 호출하고 있지 않을 때 가드는 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="397d9ba9a94e1a39ad054c3d3560e0518f095dd9" translate="yes" xml:space="preserve">
          <source>In order to prepare your code for I18N, you need to look at all the strings in your files. Any string that needs to be translated should be marked by wrapping it in &lt;code&gt;_('...')&lt;/code&gt; &amp;mdash; that is, a call to the function &lt;code&gt;_()&lt;/code&gt;. For example:</source>
          <target state="translated">I18N에 대한 코드를 준비하려면 파일의 모든 문자열을 확인해야합니다. 번역해야 할 문자열은 &lt;code&gt;_('...')&lt;/code&gt; 로 묶어서 표시해야합니다. 즉, &lt;code&gt;_()&lt;/code&gt; 함수를 호출합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a53010fccc6cd571ec768b9ab052d773d9305f6" translate="yes" xml:space="preserve">
          <source>In order to preserve backwards compatibility, enum values are also present in the &lt;a href=&quot;http.client#module-http.client&quot;&gt;&lt;code&gt;http.client&lt;/code&gt;&lt;/a&gt; module in the form of constants. The enum name is equal to the constant name (i.e. &lt;code&gt;http.HTTPStatus.OK&lt;/code&gt; is also available as &lt;code&gt;http.client.OK&lt;/code&gt;).</source>
          <target state="translated">이전 버전과의 호환성을 유지하기 위해 열거 형 값도 상수 형식으로 &lt;a href=&quot;http.client#module-http.client&quot;&gt; &lt;code&gt;http.client&lt;/code&gt; &lt;/a&gt; 모듈에 있습니다. 상기 ENUM 이름 상수 이름과 동일하다 (즉 &lt;code&gt;http.HTTPStatus.OK&lt;/code&gt; 이 또한 가능 &lt;code&gt;http.client.OK&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="481a2a420e5dd7f44eee0da58267e4d5486f1e6a" translate="yes" xml:space="preserve">
          <source>In order to stop comparison from falling back to the default scheme of comparing object addresses, datetime comparison normally raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the other comparand isn&amp;rsquo;t also a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object. However, &lt;code&gt;NotImplemented&lt;/code&gt; is returned instead if the other comparand has a &lt;code&gt;timetuple()&lt;/code&gt; attribute. This hook gives other kinds of date objects a chance at implementing mixed-type comparison. If not, when a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object is compared to an object of a different type, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised unless the comparison is &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. The latter cases return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">비교가 객체 주소를 비교하는 기본 체계로 넘어가는 것을 막기 위해, 다른 비교가 또한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 가 아닌 경우 datetime 비교는 일반적으로 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다 . 그러나 &lt;code&gt;NotImplemented&lt;/code&gt; 는 다른 간 비교가 아니라 가지고 있다면 반환 &lt;code&gt;timetuple()&lt;/code&gt; 속성. 이 후크는 다른 종류의 날짜 개체에 혼합 형식 비교를 구현할 수있는 기회를 제공합니다. 그렇지 않으면 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체를 다른 유형의 객체와 비교할 때 비교가 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 가 아니면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 후자의 경우 각각 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="07c225cf30fe4108ef791e90675347d57b8d70e1" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;date1 &amp;lt; date2&lt;/code&gt; if and only if &lt;code&gt;date1.toordinal() &amp;lt;
date2.toordinal()&lt;/code&gt;. Date comparison raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the other comparand isn&amp;rsquo;t also a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; object. However, &lt;code&gt;NotImplemented&lt;/code&gt; is returned instead if the other comparand has a &lt;code&gt;timetuple()&lt;/code&gt; attribute. This hook gives other kinds of date objects a chance at implementing mixed-type comparison. If not, when a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; object is compared to an object of a different type, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised unless the comparison is &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. The latter cases return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">즉, &lt;code&gt;date1 &amp;lt; date2&lt;/code&gt; if and only if &lt;code&gt;date1.toordinal() &amp;lt; date2.toordinal()&lt;/code&gt; 입니다. 다른 비교 자가 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 개체 가 아닌 경우 날짜 비교에서 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 가&lt;/a&gt; 발생 합니다. 그러나 &lt;code&gt;NotImplemented&lt;/code&gt; 는 다른 간 비교가 아니라 가지고 있다면 반환 &lt;code&gt;timetuple()&lt;/code&gt; 속성. 이 후크는 다른 종류의 날짜 개체에 혼합 형식 비교를 구현할 수있는 기회를 제공합니다. 그렇지 않으면 &lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 객체를 다른 유형의 객체와 비교할 때 비교가 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 가 아니면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 후자의 경우 각각 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e300da15620669a3f28958bece86c7a1fd76bbb5" translate="yes" xml:space="preserve">
          <source>In particular, &lt;a href=&quot;#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; should be used in preference to the default pseudo-random number generator in the &lt;a href=&quot;random#module-random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; module, which is designed for modelling and simulation, not security or cryptography.</source>
          <target state="translated">특히, 보안 또는 암호화가 아닌 모델링 및 시뮬레이션을 위해 설계된 &lt;a href=&quot;random#module-random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 모듈 의 기본 의사 난수 생성기보다 &lt;a href=&quot;#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 이 우선적으로 사용되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2c07f61ca6c800f6888e2710a82a85e90f50bcc3" translate="yes" xml:space="preserve">
          <source>In particular, &lt;a href=&quot;#textwrap.fill&quot;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/a&gt; accepts exactly the same keyword arguments as &lt;a href=&quot;#textwrap.wrap&quot;&gt;&lt;code&gt;wrap()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;#textwrap.fill&quot;&gt; &lt;code&gt;fill()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#textwrap.wrap&quot;&gt; &lt;code&gt;wrap()&lt;/code&gt; &lt;/a&gt; 과 정확히 동일한 키워드 인수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="1fa9bd11ecdf21c870d5be8de14f439777d27d8a" translate="yes" xml:space="preserve">
          <source>In particularly, &lt;a href=&quot;#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; should be used in preference to the default pseudo-random number generator in the &lt;a href=&quot;random#module-random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; module, which is designed for modelling and simulation, not security or cryptography.</source>
          <target state="translated">특히, 보안 또는 암호화가 아닌 모델링 및 시뮬레이션을 위해 설계된 &lt;a href=&quot;random#module-random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 모듈 의 기본 의사 난수 생성기에 우선하여 &lt;a href=&quot;#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bed46a3402b9eb2783c1eff866fc79b96a61f33e" translate="yes" xml:space="preserve">
          <source>In previous versions &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; did not start the manager&amp;rsquo;s server process if it was not already started.</source>
          <target state="translated">이전 버전에서 &lt;a href=&quot;stdtypes#contextmanager.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 는 아직 시작되지 않은 경우 관리자의 서버 프로세스를 시작하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="24635c5fed7456cbfad369f24972f6f06dd072a4" translate="yes" xml:space="preserve">
          <source>In protocols 2 and newer, classes that implements the &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt;&lt;code&gt;__getnewargs_ex__()&lt;/code&gt;&lt;/a&gt; method can dictate the values passed to the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method upon unpickling. The method must return a pair &lt;code&gt;(args, kwargs)&lt;/code&gt; where &lt;em&gt;args&lt;/em&gt; is a tuple of positional arguments and &lt;em&gt;kwargs&lt;/em&gt; a dictionary of named arguments for constructing the object. Those will be passed to the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method upon unpickling.</source>
          <target state="translated">프로토콜 2 이상에서 &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt; &lt;code&gt;__getnewargs_ex__()&lt;/code&gt; &lt;/a&gt; 메소드 를 구현하는 클래스는 피클 링 해제시 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메소드에 전달 된 값을 지시 할 수 있습니다 . 이 메소드는 쌍 &lt;code&gt;(args, kwargs)&lt;/code&gt; 리턴해야합니다. 여기서 &lt;em&gt;args&lt;/em&gt; 는 위치 인수의 튜플이고 오브젝트를 구성하기 위해 명명 된 인수의 사전을 &lt;em&gt;kwargs&lt;/em&gt; 합니다. 언 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메소드 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2d2d2615a8545e55e8010e6c482ce85ea1d3a7d" translate="yes" xml:space="preserve">
          <source>In protocols 2 and newer, classes that implements the &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt;&lt;code&gt;__getnewargs_ex__()&lt;/code&gt;&lt;/a&gt; method can dictate the values passed to the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method upon unpickling. The method must return a pair &lt;code&gt;(args, kwargs)&lt;/code&gt; where &lt;em&gt;args&lt;/em&gt; is a tuple of positional arguments and &lt;em&gt;kwargs&lt;/em&gt; a dictionary of named arguments for constructing the object. Those will be passed to the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method upon unpickling.</source>
          <target state="translated">프로토콜 2 이상에서 &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt; &lt;code&gt;__getnewargs_ex__()&lt;/code&gt; &lt;/a&gt; 메서드 를 구현하는 클래스는 피클 링 해제시 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메서드에 전달되는 값을 지시 할 수 있습니다 . 메서드는 쌍 &lt;code&gt;(args, kwargs)&lt;/code&gt; 반환해야합니다. 여기서 &lt;em&gt;args&lt;/em&gt; 는 위치 인수의 튜플이고 객체를 구성하기 위해 명명 된 인수의 사전을 &lt;em&gt;kwargs&lt;/em&gt; 합니다. 그것들은 언 피클 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메소드 로 전달 될 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6463b988a254956fa89396a7c22c32f2fa351eb6" translate="yes" xml:space="preserve">
          <source>In regular release builds, the default warning filter has the following entries (in order of precedence):</source>
          <target state="translated">정식 릴리스 빌드에서 기본 경고 필터에는 다음과 같은 항목이 있습니다 (우선 순위).</target>
        </trans-unit>
        <trans-unit id="197d3ed98970db4c06270429cf9d72971fdb552f" translate="yes" xml:space="preserve">
          <source>In server mode, a client certificate request is sent to the client. The client may either ignore the request or send a certificate in order perform TLS client cert authentication. If the client chooses to send a certificate, it is verified. Any verification error immediately aborts the TLS handshake.</source>
          <target state="translated">서버 모드에서 클라이언트 인증서 요청이 클라이언트로 전송됩니다. 클라이언트는 TLS 클라이언트 인증서 인증을 수행하기 위해 요청을 무시하거나 인증서를 보낼 수 있습니다. 클라이언트가 인증서를 보내도록 선택하면 확인됩니다. 확인 오류가 있으면 TLS 핸드 셰이크가 즉시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="784d3051d9c6418372556580d85a0525b4b27c71" translate="yes" xml:space="preserve">
          <source>In server mode, if you want to authenticate your clients using the SSL layer (rather than using a higher-level authentication mechanism), you&amp;rsquo;ll also have to specify &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and similarly check the client certificate.</source>
          <target state="translated">서버 모드에서 상위 수준의 인증 메커니즘을 사용하지 않고 SSL 계층을 사용하여 클라이언트를 인증하려는 경우 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 를 지정 하고 마찬가지로 클라이언트 인증서를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fcdfdefb8a40ad8a9c6f3c87a3f6215890319ef" translate="yes" xml:space="preserve">
          <source>In server mode, no certificate is requested from the client, so the client does not send any for client cert authentication.</source>
          <target state="translated">서버 모드에서는 클라이언트에서 인증서를 요청하지 않으므로 클라이언트는 클라이언트 인증서 인증을 위해 아무 것도 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2aaa992863bbf78157aa977a683358ca504509cc" translate="yes" xml:space="preserve">
          <source>In short, those are: a conversion to &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;math#math.trunc&quot;&gt;&lt;code&gt;math.trunc()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;math#math.floor&quot;&gt;&lt;code&gt;math.floor()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;math#math.ceil&quot;&gt;&lt;code&gt;math.ceil()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#divmod&quot;&gt;&lt;code&gt;divmod()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">간단히 말하면 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;math#math.trunc&quot;&gt; &lt;code&gt;math.trunc()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;math#math.floor&quot;&gt; &lt;code&gt;math.floor()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;math#math.ceil&quot;&gt; &lt;code&gt;math.ceil()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#divmod&quot;&gt; &lt;code&gt;divmod()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31dcfc591206e9e4f3d38c565f3b33cf822b6daf" translate="yes" xml:space="preserve">
          <source>In single threaded environments, it is preferable to not use this context at all. Instead, simply create contexts explicitly as described below.</source>
          <target state="translated">단일 스레드 환경에서는이 컨텍스트를 전혀 사용하지 않는 것이 좋습니다. 대신 아래에 설명 된대로 컨텍스트를 명시 적으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="828ef2d26cdb8bf2d36789116eed3ec4cdddbe9d" translate="yes" xml:space="preserve">
          <source>In some audio formats, such as .WAV files, 16, 24 and 32 bit samples are signed, but 8 bit samples are unsigned. So when converting to 8 bit wide samples for these formats, you need to also add 128 to the result:</source>
          <target state="translated">.WAV 파일과 같은 일부 오디오 형식에서는 16, 24 및 32 비트 샘플이 서명되지만 8 비트 샘플은 서명되지 않습니다. 따라서 이러한 형식의 8 비트 폭 샘플로 변환 할 때 결과에 ​​128을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="b38f289e088de73aef52f5145e4194895bf3fc55" translate="yes" xml:space="preserve">
          <source>In some cases, it is desirable not to parse an input source at once, but to feed chunks of the document as they get available. Note that the reader will normally not read the entire file, but read it in chunks as well; still &lt;code&gt;parse()&lt;/code&gt; won&amp;rsquo;t return until the entire document is processed. So these interfaces should be used if the blocking behaviour of &lt;code&gt;parse()&lt;/code&gt; is not desirable.</source>
          <target state="translated">경우에 따라 입력 소스를 한 번에 구문 분석하지 않고 사용 가능한 문서 청크를 공급하는 것이 바람직합니다. 독자는 일반적으로 전체 파일을 읽지 않고 덩어리로 읽습니다. 여전히 전체 문서가 처리 될 때까지 &lt;code&gt;parse()&lt;/code&gt; 가 반환되지 않습니다. 따라서 &lt;code&gt;parse()&lt;/code&gt; 의 블로킹 동작이 바람직하지 않은 경우 이러한 인터페이스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4d666daec390d8674c0e643958a689e1dd07bc25" translate="yes" xml:space="preserve">
          <source>In some cases, it may be appropriate to process part of a request synchronously, but to finish processing in a forked child depending on the request data. This can be implemented by using a synchronous server and doing an explicit fork in the request handler class &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt;&lt;code&gt;handle()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우에 따라 요청의 일부를 동 기적으로 처리하는 것이 좋지만 요청 데이터에 따라 분기 된 하위에서 처리를 완료하는 것이 적절할 수 있습니다. 이는 동기 서버를 사용하고 요청 핸들러 클래스 &lt;a href=&quot;#socketserver.BaseRequestHandler.handle&quot;&gt; &lt;code&gt;handle()&lt;/code&gt; &lt;/a&gt; 메소드 에서 명시 적 포크를 수행하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0c333efd73cd8e595b6e8b60656420e48337e96" translate="yes" xml:space="preserve">
          <source>In some cases, the existing tests may have been written using the &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; module. If so, &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; provides a &lt;code&gt;DocTestSuite&lt;/code&gt; class that can automatically build &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; instances from the existing &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt;-based tests.</source>
          <target state="translated">경우에 따라 기존 테스트가 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 작성되었을 수 있습니다 . 그렇다면 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 기존 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 기반 테스트 에서 &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스를 자동으로 빌드 할 수 있는 &lt;code&gt;DocTestSuite&lt;/code&gt; 클래스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="13ca056dd65f97d35e7322d84682a7bdc64b0f33" translate="yes" xml:space="preserve">
          <source>In some contexts, the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module is used to transfer massive amounts of data. Therefore, it can be important to minimize the number of memory copies, to preserve performance and resource consumption. However, normal operation of the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module, as it transforms a graph-like structure of objects into a sequential stream of bytes, intrinsically involves copying data to and from the pickle stream.</source>
          <target state="translated">일부 상황에서 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 대량의 데이터를 전송하는 데 사용됩니다. 따라서 성능 및 자원 소비를 유지하기 위해 메모리 사본 수를 최소화하는 것이 중요 할 수 있습니다. 그러나 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈 의 정상적인 작동은 그래프와 같은 객체 구조를 순차적 인 바이트 스트림으로 변환하기 때문에 본질적으로 피클 스트림과 데이터를 복사하는 작업을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="762bcb14ce3c58747a56f114dd90a102eeed2096" translate="yes" xml:space="preserve">
          <source>In string-type &lt;em&gt;repl&lt;/em&gt; arguments, in addition to the character escapes and backreferences described above, &lt;code&gt;\g&amp;lt;name&amp;gt;&lt;/code&gt; will use the substring matched by the group named &lt;code&gt;name&lt;/code&gt;, as defined by the &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; syntax. &lt;code&gt;\g&amp;lt;number&amp;gt;&lt;/code&gt; uses the corresponding group number; &lt;code&gt;\g&amp;lt;2&amp;gt;&lt;/code&gt; is therefore equivalent to &lt;code&gt;\2&lt;/code&gt;, but isn&amp;rsquo;t ambiguous in a replacement such as &lt;code&gt;\g&amp;lt;2&amp;gt;0&lt;/code&gt;. &lt;code&gt;\20&lt;/code&gt; would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character &lt;code&gt;'0'&lt;/code&gt;. The backreference &lt;code&gt;\g&amp;lt;0&amp;gt;&lt;/code&gt; substitutes in the entire substring matched by the RE.</source>
          <target state="translated">문자열 유형의 &lt;em&gt;repl&lt;/em&gt; 인수에서 위에 설명 된 문자 이스케이프 및 역 참조 외에도 &lt;code&gt;\g&amp;lt;name&amp;gt;&lt;/code&gt; 은 &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; 구문에 정의 된대로 &lt;code&gt;name&lt;/code&gt; 이라는 그룹과 일치하는 하위 문자열을 사용 합니다. &lt;code&gt;\g&amp;lt;number&amp;gt;&lt;/code&gt; 는 해당 그룹 번호를 사용합니다. 따라서 &lt;code&gt;\g&amp;lt;2&amp;gt;&lt;/code&gt; 는 &lt;code&gt;\2&lt;/code&gt; 와 동일 하지만 &lt;code&gt;\g&amp;lt;2&amp;gt;0&lt;/code&gt; 과 같은 대체에서는 모호하지 않습니다 . &lt;code&gt;\20&lt;/code&gt; 은 그룹 2에 대한 참조가 아니라 리터럴 문자 &lt;code&gt;'0'&lt;/code&gt; 이 아닌 그룹 20에 대한 참조로 해석됩니다 . 역 참조 &lt;code&gt;\g&amp;lt;0&amp;gt;&lt;/code&gt; 은 RE와 일치하는 전체 하위 문자열을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="91032350df9be823abddd9974a0ded34862f00b1" translate="yes" xml:space="preserve">
          <source>In the Python DOM API, accessor functions are not required. If provided, they should take the form defined by the Python IDL mapping, but these methods are considered unnecessary since the attributes are accessible directly from Python. &amp;ldquo;Set&amp;rdquo; accessors should never be provided for &lt;code&gt;readonly&lt;/code&gt; attributes.</source>
          <target state="translated">Python DOM API에서는 접근 자 함수가 필요하지 않습니다. 제공되는 경우 Python IDL 맵핑으로 정의 된 양식을 가져야하지만 속성은 Python에서 직접 액세스 할 수 있으므로 이러한 메소드는 불필요한 것으로 간주됩니다. &lt;code&gt;readonly&lt;/code&gt; 속성에 대해서는 &quot;Set&quot;접근자를 제공해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e4271bc7aa921a4604f70acbcc32e5e1ad1a872" translate="yes" xml:space="preserve">
          <source>In the Python use of certificates, a client or server can use a certificate to prove who they are. The other side of a network connection can also be required to produce a certificate, and that certificate can be validated to the satisfaction of the client or server that requires such validation. The connection attempt can be set to raise an exception if the validation fails. Validation is done automatically, by the underlying OpenSSL framework; the application need not concern itself with its mechanics. But the application does usually need to provide sets of certificates to allow this process to take place.</source>
          <target state="translated">Python에서 인증서를 사용할 때 클라이언트 또는 서버는 인증서를 사용하여 인증서를 사용할 수 있습니다. 네트워크 연결의 다른 쪽에서도 인증서를 생성해야 할 수 있으며 해당 유효성 검사가 필요한 클라이언트 나 서버가 만족할 수 있도록 해당 인증서의 유효성을 검사 할 수 있습니다. 유효성 검사에 실패하면 연결 시도에서 예외가 발생하도록 설정할 수 있습니다. 검증은 기본 OpenSSL 프레임 워크에 의해 자동으로 수행됩니다. 응용 프로그램 자체의 메커니즘과 관련이있을 필요는 없습니다. 그러나 응용 프로그램은 일반적으로이 프로세스를 수행 할 수 있도록 인증서 세트를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="54b6896bea707355902a22e27a3a48a322ff4f93" translate="yes" xml:space="preserve">
          <source>In the UTF-8 mode, the encoding is &lt;code&gt;utf-8&lt;/code&gt; on any platform.</source>
          <target state="translated">UTF-8 모드에서 인코딩은 모든 플랫폼에서 &lt;code&gt;utf-8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cee2bffb2eb3a640bd33edd4c2273abf15d7944e" translate="yes" xml:space="preserve">
          <source>In the case of a &lt;em&gt;MandatoryRelease&lt;/em&gt; that has not yet occurred, &lt;em&gt;MandatoryRelease&lt;/em&gt; predicts the release in which the feature will become part of the language.</source>
          <target state="translated">아직 발생하지 않은 &lt;em&gt;MandatoryRelease&lt;/em&gt; 의 경우 &lt;em&gt;MandatoryRelease&lt;/em&gt; 는 기능이 언어의 일부가 될 릴리스를 예측합니다.</target>
        </trans-unit>
        <trans-unit id="b18036aece5d58aa31914b030641e2dd49980e5c" translate="yes" xml:space="preserve">
          <source>In the case of {}-formatting, you can specify formatting flags by placing them after the attribute name, separated from it with a colon. For example: a placeholder of &lt;code&gt;{msecs:03d}&lt;/code&gt; would format a millisecond value of &lt;code&gt;4&lt;/code&gt; as &lt;code&gt;004&lt;/code&gt;. Refer to the &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; documentation for full details on the options available to you.</source>
          <target state="translated">{} 형식화의 경우 속성 이름 뒤에 콜론으로 구분하여 배치하여 형식화 플래그를 지정할 수 있습니다. 예를 들어 자리 표시 자 &lt;code&gt;{msecs:03d}&lt;/code&gt; 는 밀리 초 값 &lt;code&gt;4&lt;/code&gt; 를 &lt;code&gt;004&lt;/code&gt; 형식으로 지정합니다 . 사용 가능한 옵션에 대한 자세한 내용 은 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de630fdc03f685b1b1a89c3374aa3f0cc3e42c5" translate="yes" xml:space="preserve">
          <source>In the case where the metadata file listing files (RECORD or SOURCES.txt) is missing, &lt;code&gt;files()&lt;/code&gt; will return &lt;code&gt;None&lt;/code&gt;. The caller may wish to wrap calls to &lt;code&gt;files()&lt;/code&gt; in &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable&quot;&gt;always_iterable&lt;/a&gt; or otherwise guard against this condition if the target distribution is not known to have the metadata present.</source>
          <target state="translated">메타 데이터 파일 목록 파일 (RECORD 또는 SOURCES.txt)이 누락 된 경우 &lt;code&gt;files()&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다. 호출자는 &lt;a href=&quot;https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable&quot;&gt;always_iterable&lt;/a&gt; 에서 &lt;code&gt;files()&lt;/code&gt; 에 대한 호출을 랩핑 하거나 대상 배포에 메타 데이터가없는 것으로 알려진 경우이 조건을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1e2dbd142a208749274bd7580c8ed640f3d885" translate="yes" xml:space="preserve">
          <source>In the default Task implementation, the name will be visible in the &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; output of a task object.</source>
          <target state="translated">기본 작업 구현에서 이름은 작업 객체 의 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 출력에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="535fa5a6ec217819ca7ba659179db533e7a167c0" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; with &lt;em&gt;interpolation&lt;/em&gt; set to &lt;code&gt;BasicInterpolation()&lt;/code&gt; would resolve &lt;code&gt;%(home_dir)s&lt;/code&gt; to the value of &lt;code&gt;home_dir&lt;/code&gt; (&lt;code&gt;/Users&lt;/code&gt; in this case). &lt;code&gt;%(my_dir)s&lt;/code&gt; in effect would resolve to &lt;code&gt;/Users/lumberjack&lt;/code&gt;. All interpolations are done on demand so keys used in the chain of references do not have to be specified in any specific order in the configuration file.</source>
          <target state="translated">위의 예제 에서 &lt;em&gt;보간&lt;/em&gt; 이 &lt;code&gt;BasicInterpolation()&lt;/code&gt; 설정된 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;%(home_dir)s&lt;/code&gt; 를 &lt;code&gt;home_dir&lt;/code&gt; ( 이 경우 &lt;code&gt;/Users&lt;/code&gt; ) 값으로 해석 합니다. &lt;code&gt;%(my_dir)s&lt;/code&gt; 는 실제로 &lt;code&gt;/Users/lumberjack&lt;/code&gt; 로 해석됩니다 . 모든 보간은 요청시 수행되므로 참조 체인에 사용 된 키를 구성 파일에서 특정 순서로 지정할 필요는 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5236764c8f4f33c47eb89b309f5c121471d4faba" translate="yes" xml:space="preserve">
          <source>In the final archive, &lt;code&gt;please_add.txt&lt;/code&gt; should be included, but &lt;code&gt;do_not_add.txt&lt;/code&gt; should not. Therefore we use the following:</source>
          <target state="translated">최종 아카이브에는 &lt;code&gt;please_add.txt&lt;/code&gt; 가 포함 되어야 하지만 &lt;code&gt;do_not_add.txt&lt;/code&gt; 는 포함되지 않아야합니다. 따라서 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6d863919b7beef0b7bffcfd48a2859d814cc5049" translate="yes" xml:space="preserve">
          <source>In the first approach, we read the data out of the fd&amp;rsquo;s buffer, and the byte values give you the signal numbers. This is simple, but in rare cases it can run into a problem: generally the fd will have a limited amount of buffer space, and if too many signals arrive too quickly, then the buffer may become full, and some signals may be lost. If you use this approach, then you should set &lt;code&gt;warn_on_full_buffer=True&lt;/code&gt;, which will at least cause a warning to be printed to stderr when signals are lost.</source>
          <target state="translated">첫 번째 방법에서는 fd의 버퍼에서 데이터를 읽으며 바이트 값은 신호 번호를 제공합니다. 이것은 간단하지만 드문 경우지만 문제가 될 수 있습니다. 일반적으로 fd에는 제한된 버퍼 공간이 있으며 너무 많은 신호가 너무 빨리 도착하면 버퍼가 가득 차서 일부 신호가 손실 될 수 있습니다. 이 방법을 사용하는 경우 &lt;code&gt;warn_on_full_buffer=True&lt;/code&gt; 를 설정해야합니다 .이 경우 신호가 손실 될 때 최소한 stderr에 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="b1f405b7b60dec7ef0ccbbabf3d071abe0435edb" translate="yes" xml:space="preserve">
          <source>In the following &lt;a href=&quot;https://docs.python.org/3.8/_downloads/6b45dc135219d1404be49d606589a11d/tzinfo_examples.py&quot;&gt;&lt;code&gt;tzinfo_examples.py&lt;/code&gt;&lt;/a&gt; file there are some examples of &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; classes:</source>
          <target state="translated">다음 &lt;a href=&quot;https://docs.python.org/3.8/_downloads/6b45dc135219d1404be49d606589a11d/tzinfo_examples.py&quot;&gt; &lt;code&gt;tzinfo_examples.py&lt;/code&gt; &lt;/a&gt; 파일에는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 클래스의 몇 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54874ff53863bf6a4f06c4b54eda59c0a2820a8" translate="yes" xml:space="preserve">
          <source>In the following &lt;a href=&quot;https://docs.python.org/3.9/_downloads/6b45dc135219d1404be49d606589a11d/tzinfo_examples.py&quot;&gt;&lt;code&gt;tzinfo_examples.py&lt;/code&gt;&lt;/a&gt; file there are some examples of &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; classes:</source>
          <target state="translated">다음 &lt;a href=&quot;https://docs.python.org/3.9/_downloads/6b45dc135219d1404be49d606589a11d/tzinfo_examples.py&quot;&gt; &lt;code&gt;tzinfo_examples.py&lt;/code&gt; &lt;/a&gt; 파일에는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 클래스의 몇 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ff95d881b0899b985ba27eea20bbabb5d0f7f41" translate="yes" xml:space="preserve">
          <source>In the following documentation the argument list for functions is given. Methods, of course, have the additional first argument &lt;em&gt;self&lt;/em&gt; which is omitted here.</source>
          <target state="translated">다음 문서에는 함수의 인수 목록이 제공됩니다. 물론 메소드에는 추가 첫 번째 인수 &lt;em&gt;self&lt;/em&gt; 가 있으며 여기서는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="ccfb56fcc1d858991309ad5c738b0606a30bbfb4" translate="yes" xml:space="preserve">
          <source>In the following example we&amp;rsquo;re going to intentionally cause a &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt;&lt;code&gt;Fault&lt;/code&gt;&lt;/a&gt; by returning a complex type object. The server code:</source>
          <target state="translated">다음 예제에서는 복잡한 유형의 객체를 반환 하여 의도적으로 &lt;a href=&quot;#xmlrpc.client.Fault&quot;&gt; &lt;code&gt;Fault&lt;/code&gt; &lt;/a&gt; 을 발생 시킵니다. 서버 코드 :</target>
        </trans-unit>
        <trans-unit id="e2223ff4a598cefedbdd585097e57edaf62fd136" translate="yes" xml:space="preserve">
          <source>In the following example we&amp;rsquo;re going to intentionally cause a &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt;&lt;code&gt;ProtocolError&lt;/code&gt;&lt;/a&gt; by providing an invalid URI:</source>
          <target state="translated">다음 예제에서는 잘못된 URI를 제공하여 의도적으로 &lt;a href=&quot;#xmlrpc.client.ProtocolError&quot;&gt; &lt;code&gt;ProtocolError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="1b98fb6821e17d529d323fbb51fcfeba5d9f117e" translate="yes" xml:space="preserve">
          <source>In the following example, the data are rounded, so that each value represents the midpoint of data classes, e.g. 1 is the midpoint of the class 0.5&amp;ndash;1.5, 2 is the midpoint of 1.5&amp;ndash;2.5, 3 is the midpoint of 2.5&amp;ndash;3.5, etc. With the data given, the middle value falls somewhere in the class 3.5&amp;ndash;4.5, and interpolation is used to estimate it:</source>
          <target state="translated">다음 예에서 데이터는 반올림되므로 각 값은 데이터 클래스의 중간 점을 나타냅니다. 예를 들어 1은 클래스 0.5&amp;ndash;1.5의 중간 점, 2는 1.5&amp;ndash;2.5의 중간 점, 3은 2.5&amp;ndash;3.5의 중간 점입니다 주어진 데이터에서 중간 값은 3.5&amp;ndash;4.5 클래스 어딘가에 속하며 보간은이를 추정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="533603ba0650e5f7228aa22ac8ec4f95a8bd54f1" translate="yes" xml:space="preserve">
          <source>In the following example, we are sending a data-stream to the stdin of a CGI and reading the data it returns to us. Note that this example will only work when the Python installation supports SSL.</source>
          <target state="translated">다음 예에서는 CGI의 stdin에 데이터 스트림을 전송하고 반환되는 데이터를 읽습니다. 이 예제는 Python 설치가 SSL을 지원하는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1fa008487812ea35726b9061adefa221aa756af2" translate="yes" xml:space="preserve">
          <source>In the following examples, we assume that the relevant functions have already been imported from the &lt;a href=&quot;#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다음 예에서는 관련 기능을 &lt;a href=&quot;#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈 에서 이미 가져 왔다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8f9fe91e9abf59bd1adbaa56c89770d56c827a8d" translate="yes" xml:space="preserve">
          <source>In the following, &lt;em&gt;events&lt;/em&gt; is a bitwise mask indicating which I/O events should be waited for on a given file object. It can be a combination of the modules constants below:</source>
          <target state="translated">다음에서 &lt;em&gt;이벤트&lt;/em&gt; 는 주어진 파일 객체에서 대기해야 할 I / O 이벤트를 나타내는 비트 단위 마스크입니다. 아래 모듈 상수의 조합이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed55c5626284f0ef492f74cae3ebfc7bd5bdeb3" translate="yes" xml:space="preserve">
          <source>In the following, the term &lt;em&gt;referent&lt;/em&gt; means the object which is referred to by a weak reference.</source>
          <target state="translated">이하에서, &lt;em&gt;지시 대상&lt;/em&gt; 이라는 용어 는 약한 참조로 지칭되는 &lt;em&gt;대상을&lt;/em&gt; 의미한다.</target>
        </trans-unit>
        <trans-unit id="26053a87fbd2fcc58b5429c7f78fea5394e32809" translate="yes" xml:space="preserve">
          <source>In the function &lt;code&gt;greeting&lt;/code&gt;, the argument &lt;code&gt;name&lt;/code&gt; is expected to be of type &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and the return type &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;. Subtypes are accepted as arguments.</source>
          <target state="translated">함수 &lt;code&gt;greeting&lt;/code&gt; 에서 인수 &lt;code&gt;name&lt;/code&gt; 은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 유형 이고 반환 유형은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 입니다. 하위 유형은 인수로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="58b661df5e22d9142f3da0d96532be500b1aac4f" translate="yes" xml:space="preserve">
          <source>In the general case, the steps required to perform the sorting of a given graph are as follows:</source>
          <target state="translated">일반적으로 주어진 그래프의 정렬을 수행하는 데 필요한 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e8ac6b1e58da82a23a5cbc8050342436b8ca25b0" translate="yes" xml:space="preserve">
          <source>In the ideal case, the code will have a suitable test suite, and the test runner will take care of implicitly enabling all warnings when running tests (the test runner provided by the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; module does this).</source>
          <target state="translated">이상적인 경우 코드에 적합한 테스트 스위트가 있으며 테스트 러너는 테스트를 실행할 때 모든 경고를 암시 적으로 활성화합니다 ( &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 모듈에서 제공하는 테스트 러너 가이를 수행함 ).</target>
        </trans-unit>
        <trans-unit id="eaf314b605ee1e93c7ef662a0fcaed6c7faecc98" translate="yes" xml:space="preserve">
          <source>In the next example (simple implementation of &lt;a href=&quot;shutil#shutil.rmtree&quot;&gt;&lt;code&gt;shutil.rmtree()&lt;/code&gt;&lt;/a&gt;), walking the tree bottom-up is essential, &lt;a href=&quot;#os.rmdir&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t allow deleting a directory before the directory is empty:</source>
          <target state="translated">다음 예제 ( &lt;a href=&quot;shutil#shutil.rmtree&quot;&gt; &lt;code&gt;shutil.rmtree()&lt;/code&gt; &lt;/a&gt; 의 간단한 구현 )에서 트리를 위로 걷는 것은 필수적이며, &lt;a href=&quot;#os.rmdir&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt; 은 디렉토리가 비어 있기 전에 디렉토리를 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="274c72518f8a919afc6da55f424febbdf2ea74bb" translate="yes" xml:space="preserve">
          <source>In the next example, walking the tree bottom-up is essential: &lt;a href=&quot;#os.rmdir&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t allow deleting a directory before the directory is empty:</source>
          <target state="translated">다음 예제에서는 트리를 상향식으로 걷는 것이 필수적입니다. &lt;a href=&quot;#os.rmdir&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt; 은 디렉토리가 비어 있기 전에 디렉토리를 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="17c1ee7708d83a788fb54edf47914b0f5328b88f" translate="yes" xml:space="preserve">
          <source>In the option list above, &amp;ldquo;a set&amp;rdquo; refers to any collection or iterable of strings, no ordering is expected.</source>
          <target state="translated">위의 옵션 목록에서 &quot;집합&quot;은 문자열의 모음 또는 반복 가능한 항목을 나타내며 순서는 없습니다.</target>
        </trans-unit>
        <trans-unit id="54385cf5bdff670b83f3d300aefcf33fbb344d3c" translate="yes" xml:space="preserve">
          <source>In the previous section, you learned to write following code anytime you expected a user to post more than one value under one name:</source>
          <target state="translated">이전 섹션에서는 사용자가 하나의 이름으로 둘 이상의 값을 게시 할 것으로 예상 될 때마다 다음 코드를 작성하는 방법을 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="233a7a8805657d96bca6651321789f9af3a538c2" translate="yes" xml:space="preserve">
          <source>In the second approach, we use the wakeup fd &lt;em&gt;only&lt;/em&gt; for wakeups, and ignore the actual byte values. In this case, all we care about is whether the fd&amp;rsquo;s buffer is empty or non-empty; a full buffer doesn&amp;rsquo;t indicate a problem at all. If you use this approach, then you should set &lt;code&gt;warn_on_full_buffer=False&lt;/code&gt;, so that your users are not confused by spurious warning messages.</source>
          <target state="translated">두 번째 방법에서는 wakeup fd를 wakeup &lt;em&gt;에만&lt;/em&gt; 사용 하고 실제 바이트 값은 무시합니다. 이 경우, 우리가 신경 쓰는 것은 fd의 버퍼가 비어 있는지 비어 있지 않은지입니다. 가득 찬 버퍼는 전혀 문제를 나타내지 않습니다. 이 방법을 사용하는 경우 사용자가 잘못된 경고 메시지로 혼동되지 않도록 &lt;code&gt;warn_on_full_buffer=False&lt;/code&gt; 를 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a8aa6122f62e104f1eaf23b08163261f3b40a9ba" translate="yes" xml:space="preserve">
          <source>In the second form, the caller makes the division point clear through the provision of a single colon: the dotted name to the left of the colon is a package to be imported, and the dotted name to the right is the object hierarchy within that package. Only one import is needed in this form. If it ends with the colon, then a module object is returned.</source>
          <target state="translated">두 번째 형식에서 호출자는 단일 콜론 제공을 통해 구분 지점을 명확하게합니다. 콜론 왼쪽의 점선 이름은 가져올 패키지이고 오른쪽의 점선 이름은 해당 패키지 내의 개체 계층입니다. . 이 양식에서는 하나의 가져 오기만 필요합니다. 콜론으로 끝나면 모듈 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="89bc0401466a52c7fb4e1247c6f71a447d41beff" translate="yes" xml:space="preserve">
          <source>In the serializer, the &lt;em&gt;allow_nan&lt;/em&gt; parameter can be used to alter this behavior. In the deserializer, the &lt;em&gt;parse_constant&lt;/em&gt; parameter can be used to alter this behavior.</source>
          <target state="translated">시리얼 라이저에서 &lt;em&gt;allow_nan&lt;/em&gt; 매개 변수를 사용하여이 동작을 변경할 수 있습니다. deserializer에서 &lt;em&gt;parse_constant&lt;/em&gt; 매개 변수를 사용하여이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38626b257d0d2b41bc10b255929643d1d13e8835" translate="yes" xml:space="preserve">
          <source>In the simple case then, you need only add the following bit of code to the main driver file of your application:</source>
          <target state="translated">간단한 경우 응용 프로그램의 기본 드라이버 파일에 다음 코드 만 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="cf29865f18bcaf9638d0168c8132a6142805a764" translate="yes" xml:space="preserve">
          <source>In the table &lt;em&gt;s&lt;/em&gt; is an instance of a mutable sequence type, &lt;em&gt;t&lt;/em&gt; is any iterable object and &lt;em&gt;x&lt;/em&gt; is an arbitrary object that meets any type and value restrictions imposed by &lt;em&gt;s&lt;/em&gt; (for example, &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; only accepts integers that meet the value restriction &lt;code&gt;0 &amp;lt;= x &amp;lt;= 255&lt;/code&gt;).</source>
          <target state="translated">표에서 &lt;em&gt;s&lt;/em&gt; 는 변경 가능한 시퀀스 유형의 인스턴스이고, &lt;em&gt;t&lt;/em&gt; 는 반복 가능한 객체이고 &lt;em&gt;x&lt;/em&gt; 는 &lt;em&gt;s&lt;/em&gt; 에 의해 부과 된 모든 유형 및 값 제한을 충족시키는 임의의 객체입니다 (예 : &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 는 값 제한 &lt;code&gt;0 &amp;lt;= x &amp;lt;= 255&lt;/code&gt; 을 만족하는 정수만 허용 함). x &amp;lt;= 255 ).</target>
        </trans-unit>
        <trans-unit id="bd508f1ee529ccf68344f530644e56df47707298" translate="yes" xml:space="preserve">
          <source>In the tree above, each cell &lt;em&gt;k&lt;/em&gt; is topping &lt;code&gt;2*k+1&lt;/code&gt; and &lt;code&gt;2*k+2&lt;/code&gt;. In a usual binary tournament we see in sports, each cell is the winner over the two cells it tops, and we can trace the winner down the tree to see all opponents s/he had. However, in many computer applications of such tournaments, we do not need to trace the history of a winner. To be more memory efficient, when a winner is promoted, we try to replace it by something else at a lower level, and the rule becomes that a cell and the two cells it tops contain three different items, but the top cell &amp;ldquo;wins&amp;rdquo; over the two topped cells.</source>
          <target state="translated">위의 트리에서 각 셀 &lt;em&gt;k&lt;/em&gt; 는 &lt;code&gt;2*k+1&lt;/code&gt; 및 &lt;code&gt;2*k+2&lt;/code&gt; 를 토핑 합니다. 우리가 스포츠에서 볼 수있는 일반적인 이진 토너먼트에서, 각 셀은 맨 위에있는 두 개의 셀보다 승자가되며 트리에서 우승자를 추적하여 모든 상대를 볼 수 있습니다. 그러나 이러한 토너먼트의 많은 컴퓨터 응용 프로그램에서 우승자의 이력을 추적 할 필요는 없습니다. 메모리 효율성을 높이기 위해 승자가 승격되면 하위 레벨에서 다른 것으로 대체하려고 시도합니다. 규칙은 셀과 셀의 두 셀에 서로 다른 세 개의 항목이 포함되지만 최상위 셀은 &quot;승리합니다&quot; 두 개의 상단 셀 위에.</target>
        </trans-unit>
        <trans-unit id="1defc52a5fe9f0a43f30bd5d3e26fbc4e063c451" translate="yes" xml:space="preserve">
          <source>In the typical usage of a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; object, the &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method is invoked by a &lt;code&gt;TestRunner&lt;/code&gt; rather than by the end-user test harness.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 객체 의 일반적인 사용법 에서 &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메서드는 최종 사용자 테스트 하니스가 아닌 &lt;code&gt;TestRunner&lt;/code&gt; 에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e430d29f738b72ec9b1e05af5395066734b68a2" translate="yes" xml:space="preserve">
          <source>In these tuples, &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt;, &lt;em&gt;proto&lt;/em&gt; are all integers and are meant to be passed to the &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; function. &lt;em&gt;canonname&lt;/em&gt; will be a string representing the canonical name of the &lt;em&gt;host&lt;/em&gt; if &lt;code&gt;AI_CANONNAME&lt;/code&gt; is part of the &lt;em&gt;flags&lt;/em&gt; argument; else &lt;em&gt;canonname&lt;/em&gt; will be empty. &lt;em&gt;sockaddr&lt;/em&gt; is a tuple describing a socket address, whose format depends on the returned &lt;em&gt;family&lt;/em&gt; (a &lt;code&gt;(address, port)&lt;/code&gt; 2-tuple for &lt;a href=&quot;#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;(address, port, flow info, scope id)&lt;/code&gt; 4-tuple for &lt;a href=&quot;#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;), and is meant to be passed to the &lt;a href=&quot;#socket.socket.connect&quot;&gt;&lt;code&gt;socket.connect()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 튜플에서 &lt;em&gt;family&lt;/em&gt; , &lt;em&gt;type&lt;/em&gt; , &lt;em&gt;proto&lt;/em&gt; 는 모두 정수이며 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 함수에 전달됩니다 . &lt;em&gt;AI_CANONNAME&lt;/em&gt; 이 &lt;em&gt;flags&lt;/em&gt; 인수의 일부인 경우 &lt;code&gt;AI_CANONNAME&lt;/code&gt; 은 &lt;em&gt;호스트&lt;/em&gt; 의 표준 이름을 나타내는 문자열입니다 . 그렇지 않으면 &lt;em&gt;캐논 이름&lt;/em&gt; 이 비어 있습니다. &lt;em&gt;SOCKADDR는&lt;/em&gt; 포맷이 반환에 따라 소켓 주소를 기술하는 튜플 인 &lt;em&gt;가족&lt;/em&gt; (a &lt;code&gt;(address, port)&lt;/code&gt; 2 튜플 &lt;a href=&quot;#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;(address, port, flow info, scope id)&lt;/code&gt; 4 튜플 &lt;a href=&quot;#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; &lt;/a&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;)이며 &lt;a href=&quot;#socket.socket.connect&quot;&gt; &lt;code&gt;socket.connect()&lt;/code&gt; &lt;/a&gt; 메소드 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e88e0c7696c45209bd288d5a08d4350de9a5c69" translate="yes" xml:space="preserve">
          <source>In these tuples, &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt;, &lt;em&gt;proto&lt;/em&gt; are all integers and are meant to be passed to the &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; function. &lt;em&gt;canonname&lt;/em&gt; will be a string representing the canonical name of the &lt;em&gt;host&lt;/em&gt; if &lt;code&gt;AI_CANONNAME&lt;/code&gt; is part of the &lt;em&gt;flags&lt;/em&gt; argument; else &lt;em&gt;canonname&lt;/em&gt; will be empty. &lt;em&gt;sockaddr&lt;/em&gt; is a tuple describing a socket address, whose format depends on the returned &lt;em&gt;family&lt;/em&gt; (a &lt;code&gt;(address, port)&lt;/code&gt; 2-tuple for &lt;a href=&quot;#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;(address, port, flowinfo, scope_id)&lt;/code&gt; 4-tuple for &lt;a href=&quot;#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;), and is meant to be passed to the &lt;a href=&quot;#socket.socket.connect&quot;&gt;&lt;code&gt;socket.connect()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 튜플에서 &lt;em&gt;family&lt;/em&gt; , &lt;em&gt;type&lt;/em&gt; , &lt;em&gt;proto&lt;/em&gt; 는 모두 정수이며 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 함수에 전달됩니다 . &lt;em&gt;canonname&lt;/em&gt; 은 &lt;code&gt;AI_CANONNAME&lt;/code&gt; 이 &lt;em&gt;flags&lt;/em&gt; 인수의 일부인 경우 &lt;em&gt;호스트&lt;/em&gt; 의 정식 이름을 나타내는 문자열입니다 . 그렇지 않으면 &lt;em&gt;canonname&lt;/em&gt; 이 비어 있습니다. &lt;em&gt;SOCKADDR은&lt;/em&gt; 포맷에 따라 반환 소켓 주소 기술하는 튜플 인 &lt;em&gt;가족&lt;/em&gt; (a &lt;code&gt;(address, port)&lt;/code&gt; 2 튜플 &lt;a href=&quot;#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;(address, port, flowinfo, scope_id)&lt;/code&gt; 4 튜플 &lt;a href=&quot;#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; 을&lt;/a&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;)이며 &lt;a href=&quot;#socket.socket.connect&quot;&gt; &lt;code&gt;socket.connect()&lt;/code&gt; &lt;/a&gt; 메서드에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f03f8295d4401efbee1454b689f377054911af8" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;MyDict&lt;/code&gt; has a single parameter, &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;MyDict&lt;/code&gt; 에는 단일 매개 변수 &lt;code&gt;T&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cbbe287f089dc8f706ae99f0052a682074dcad2" translate="yes" xml:space="preserve">
          <source>In this case all warnings are caught and no errors are raised.</source>
          <target state="translated">이 경우 모든 경고가 발생하고 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c62940c22ee32d3fd980aa25414be64f0948aab" translate="yes" xml:space="preserve">
          <source>In this case if either warning was not raised, or some other warning was raised, &lt;a href=&quot;#test.support.check_warnings&quot;&gt;&lt;code&gt;check_warnings()&lt;/code&gt;&lt;/a&gt; would raise an error.</source>
          <target state="translated">이 경우 경고가 발생하지 않거나 다른 경고가 발생하면 &lt;a href=&quot;#test.support.check_warnings&quot;&gt; &lt;code&gt;check_warnings()&lt;/code&gt; &lt;/a&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb0757ca7b63d5e5a2bcaf0b7ed3ffc59abc635d" translate="yes" xml:space="preserve">
          <source>In this case no &lt;code&gt;*&lt;/code&gt; specifiers may occur in a format (since they require a sequential parameter list).</source>
          <target state="translated">이 경우 &lt;code&gt;*&lt;/code&gt; 지정자는 형식으로 발생할 수 없습니다 (순차 매개 변수 목록이 필요하므로).</target>
        </trans-unit>
        <trans-unit id="c4457d16ba5e9b6c681760e973da7e71471b05ca" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;#dataclasses.fields&quot;&gt;&lt;code&gt;fields()&lt;/code&gt;&lt;/a&gt; will return &lt;a href=&quot;#dataclasses.Field&quot;&gt;&lt;code&gt;Field&lt;/code&gt;&lt;/a&gt; objects for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, but not for &lt;code&gt;database&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;a href=&quot;#dataclasses.fields&quot;&gt; &lt;code&gt;fields()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 에 대한 &lt;a href=&quot;#dataclasses.Field&quot;&gt; &lt;code&gt;Field&lt;/code&gt; &lt;/a&gt; 객체를 반환 하지만 &lt;code&gt;database&lt;/code&gt; 에 대해서는 반환 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="79e6ea472a32e4246827af3631820637ed0278c5" translate="yes" xml:space="preserve">
          <source>In this case, you are marking translatable strings with the function &lt;code&gt;N_()&lt;/code&gt;, which won&amp;rsquo;t conflict with any definition of &lt;code&gt;_()&lt;/code&gt;. However, you will need to teach your message extraction program to look for translatable strings marked with &lt;code&gt;N_()&lt;/code&gt;. &lt;strong&gt;xgettext&lt;/strong&gt;, &lt;strong&gt;pygettext&lt;/strong&gt;, &lt;code&gt;pybabel extract&lt;/code&gt;, and &lt;strong&gt;xpot&lt;/strong&gt; all support this through the use of the &lt;code&gt;-k&lt;/code&gt; command-line switch. The choice of &lt;code&gt;N_()&lt;/code&gt; here is totally arbitrary; it could have just as easily been &lt;code&gt;MarkThisStringForTranslation()&lt;/code&gt;.</source>
          <target state="translated">이 경우 번역 가능한 문자열을 &lt;code&gt;N_()&lt;/code&gt; 함수로 표시하면 &lt;code&gt;_()&lt;/code&gt; 의 정의와 충돌하지 않습니다 . 그러나 &lt;code&gt;N_()&lt;/code&gt; 으로 표시된 번역 가능한 문자열을 찾도록 메시지 추출 프로그램을 가르쳐야합니다 . &lt;strong&gt;xgettext&lt;/strong&gt; , &lt;strong&gt;pygettext&lt;/strong&gt; , &lt;code&gt;pybabel extract&lt;/code&gt; 및 &lt;strong&gt;xpot은&lt;/strong&gt; 모두 &lt;code&gt;-k&lt;/code&gt; 명령 줄 스위치를 사용하여이를 지원합니다 . 여기서 &lt;code&gt;N_()&lt;/code&gt; 의 선택 은 완전히 임의적입니다. &lt;code&gt;MarkThisStringForTranslation()&lt;/code&gt; 처럼 쉽게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08bfb79410a7dd7df492ec826030edd1454851bb" translate="yes" xml:space="preserve">
          <source>In this documentation the term &amp;ldquo;coroutine&amp;rdquo; can be used for two closely related concepts:</source>
          <target state="translated">이 문서에서 &quot;코 루틴&quot;이라는 용어는 두 가지 밀접한 관련 개념에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdbd41293f905fe5e804f0cde22491ea56d4aad3" translate="yes" xml:space="preserve">
          <source>In this example we monkey patch &lt;code&gt;method&lt;/code&gt; to return &lt;code&gt;sentinel.some_object&lt;/code&gt;:</source>
          <target state="translated">이 예제에서 우리는 &lt;code&gt;sentinel.some_object&lt;/code&gt; 를 반환하는 패치 &lt;code&gt;method&lt;/code&gt; 을 원숭이 로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="0cb1f4c4966c211b894b9eddb03c77f1514eec4f" translate="yes" xml:space="preserve">
          <source>In this example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be included in the added &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method, which will be defined as:</source>
          <target state="translated">이 예제에서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 추가 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메소드에 포함되며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="fda6bd28cc033b50a0b8814524b1219024bf6ae2" translate="yes" xml:space="preserve">
          <source>In this example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will be included in the added &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method, which will be defined as:</source>
          <target state="translated">이 예제에서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 추가 된 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메서드에 포함되며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c864378a7365c48cdd1ee95b362aa30d2db7c6fa" translate="yes" xml:space="preserve">
          <source>In this example, similar to the &lt;a href=&quot;#shutil-archiving-example&quot;&gt;one above&lt;/a&gt;, we show how to use &lt;a href=&quot;#shutil.make_archive&quot;&gt;&lt;code&gt;make_archive()&lt;/code&gt;&lt;/a&gt;, but this time with the usage of &lt;em&gt;base_dir&lt;/em&gt;. We now have the following directory structure:</source>
          <target state="translated">이 예에서와 유사한 &lt;a href=&quot;#shutil-archiving-example&quot;&gt;위에 하나&lt;/a&gt; , 우리는 사용하는 방법을 보여줍니다 &lt;a href=&quot;#shutil.make_archive&quot;&gt; &lt;code&gt;make_archive()&lt;/code&gt; &lt;/a&gt; 만의 사용이 시간 &lt;em&gt;BASE_DIR&lt;/em&gt; . 이제 다음과 같은 디렉토리 구조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b3d5cd546b56dd82f8608e853a7baf739475096" translate="yes" xml:space="preserve">
          <source>In this example, the string &lt;code&gt;'writing a log message'&lt;/code&gt; is marked as a candidate for translation, while the strings &lt;code&gt;'mylog.txt'&lt;/code&gt; and &lt;code&gt;'w'&lt;/code&gt; are not.</source>
          <target state="translated">이 예에서 문자열 &lt;code&gt;'writing a log message'&lt;/code&gt; 은 번역 후보로 표시되지만 문자열 &lt;code&gt;'mylog.txt'&lt;/code&gt; 및 &lt;code&gt;'w'&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7def4d1e263f8bcd184ca5ff886690b3b0a0295" translate="yes" xml:space="preserve">
          <source>In this example, the unpickler imports the &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt; function and then apply the string argument &amp;ldquo;echo hello world&amp;rdquo;. Although this example is inoffensive, it is not difficult to imagine one that could damage your system.</source>
          <target state="translated">이 예제에서 unpickler는 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 함수를 가져온 다음 문자열 인수 &quot;echo hello world&quot;를 적용합니다. 이 예제는 공격적이지 않지만 시스템을 손상시킬 수있는 것을 상상하기는 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e522fd7d7c94512496913a1631fcf4f5c248305d" translate="yes" xml:space="preserve">
          <source>In this example, we create a gzip&amp;rsquo;ed tar-file archive containing all files found in the &lt;code&gt;.ssh&lt;/code&gt; directory of the user:</source>
          <target state="translated">이 예에서는 사용자 의 &lt;code&gt;.ssh&lt;/code&gt; 디렉토리에있는 모든 파일을 포함하는 gzip의 tar 파일 아카이브를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6ad2b90f1a4c574c3b7216fa3f340a8bbed08661" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll use the following helper function to display match objects a little more gracefully:</source>
          <target state="translated">이 예에서는 다음 도우미 함수를 사용하여 일치 객체를 조금 더 우아하게 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ba2da0e1a0b23d485c22fd691fbc6b825bea722c" translate="yes" xml:space="preserve">
          <source>In this module, shared memory refers to &amp;ldquo;System V style&amp;rdquo; shared memory blocks (though is not necessarily implemented explicitly as such) and does not refer to &amp;ldquo;distributed shared memory&amp;rdquo;. This style of shared memory permits distinct processes to potentially read and write to a common (or shared) region of volatile memory. Processes are conventionally limited to only have access to their own process memory space but shared memory permits the sharing of data between processes, avoiding the need to instead send messages between processes containing that data. Sharing data directly via memory can provide significant performance benefits compared to sharing data via disk or socket or other communications requiring the serialization/deserialization and copying of data.</source>
          <target state="translated">이 모듈에서 공유 메모리는 &quot;System V 스타일&quot;공유 메모리 블록을 나타내며 (반드시 명시 적으로 구현할 필요는 없지만) &quot;분산 공유 메모리&quot;를 나타내지 않습니다. 이 스타일의 공유 메모리는 개별 프로세스가 휘발성 메모리의 공통 (또는 공유) 영역을 읽고 쓸 수 있도록합니다. 프로세스는 일반적으로 자신의 프로세스 메모리 공간에만 액세스 할 수 있도록 제한되지만 공유 메모리는 프로세스간에 데이터를 공유 할 수 있으므로 해당 데이터를 포함하는 프로세스간에 메시지를 대신 보낼 필요가 없습니다. 메모리를 통해 직접 데이터를 공유하면 디스크 또는 소켓을 통해 데이터를 공유하거나 데이터의 직렬화 / 직렬화 및 복사가 필요한 다른 통신과 비교할 때 상당한 성능 이점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3672efb81510d5a09d403c05abc447f604c84f" translate="yes" xml:space="preserve">
          <source>In this section, &amp;ldquo;a becomes b&amp;rdquo; means that b can be used as a replacement for a.</source>
          <target state="translated">이 섹션에서 &quot;a가 b가 됨&quot;은 b가 a의 대체품으로 사용될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="21e480a14f4cd9a1149fed8cca6a4c7d111a42ea" translate="yes" xml:space="preserve">
          <source>In this section, &amp;lsquo;C&amp;rsquo; refers to the</source>
          <target state="translated">이 섹션에서 'C'는</target>
        </trans-unit>
        <trans-unit id="876936e3c1b8574b0dd98372c0c2aa05d7cc3d86" translate="yes" xml:space="preserve">
          <source>In this section, we describe the general mechanisms available to you to define, customize, and control how class instances are pickled and unpickled.</source>
          <target state="translated">이 섹션에서는 클래스 인스턴스의 피클 링 및 피클 링 해제 방법을 정의, 사용자 정의 및 제어하는 ​​데 사용할 수있는 일반적인 메커니즘에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="609a689db13972f91eaeffe399356954f6e29a03" translate="yes" xml:space="preserve">
          <source>In those examples, note that when an in-place method is called, the computation and assignment are performed in two separate steps. The in-place functions listed below only do the first step, calling the in-place method. The second step, assignment, is not handled.</source>
          <target state="translated">이러한 예에서, 내부 메소드가 호출되면 계산 및 지정이 두 개의 개별 단계로 수행됩니다. 아래 나열된 인플레 이스 함수는 인플레 이스 메소드를 호출하는 첫 번째 단계 만 수행합니다. 두 번째 단계 인 할당은 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3e67f78459f05a24ed8968a34d4f51980839f13" translate="yes" xml:space="preserve">
          <source>In traditional Unix the field &lt;code&gt;pw_passwd&lt;/code&gt; usually contains a password encrypted with a DES derived algorithm (see module &lt;a href=&quot;crypt#module-crypt&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt;). However most modern unices use a so-called &lt;em&gt;shadow password&lt;/em&gt; system. On those unices the &lt;em&gt;pw_passwd&lt;/em&gt; field only contains an asterisk (&lt;code&gt;'*'&lt;/code&gt;) or the letter &lt;code&gt;'x'&lt;/code&gt; where the encrypted password is stored in a file &lt;code&gt;/etc/shadow&lt;/code&gt; which is not world readable. Whether the &lt;em&gt;pw_passwd&lt;/em&gt; field contains anything useful is system-dependent. If available, the &lt;a href=&quot;spwd#module-spwd&quot;&gt;&lt;code&gt;spwd&lt;/code&gt;&lt;/a&gt; module should be used where access to the encrypted password is required.</source>
          <target state="translated">전통적인 유닉스에서 &lt;code&gt;pw_passwd&lt;/code&gt; 필드 는 일반적으로 DES 파생 알고리즘으로 암호화 된 비밀번호를 포함합니다 (모듈 &lt;a href=&quot;crypt#module-crypt&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt; 참조 ). 그러나 대부분의 현대 유니 세서는 소위 &lt;em&gt;섀도 패스워드&lt;/em&gt; 시스템을 사용합니다. 이 &lt;em&gt;유니 세스&lt;/em&gt; 에서 &lt;em&gt;pw_passwd&lt;/em&gt; 필드에는 별표 ( &lt;code&gt;'*'&lt;/code&gt; ) 또는 암호화 된 비밀번호가 &lt;code&gt;/etc/shadow&lt;/code&gt; 파일 ( 세계에서 읽을 수없는 파일)에 저장된 &lt;code&gt;'x'&lt;/code&gt; 문자 만 포함 됩니다 . &lt;em&gt;pw_passwd&lt;/em&gt; 필드에 유용한 것이 포함되어 있는지 여부 는 시스템에 따라 다릅니다. 사용 가능한 경우 암호화 된 비밀번호에 액세스해야하는 경우 &lt;a href=&quot;spwd#module-spwd&quot;&gt; &lt;code&gt;spwd&lt;/code&gt; &lt;/a&gt; 모듈을 사용해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4db947ef6cd05225fe3e644d287ef1d201b7690c" translate="yes" xml:space="preserve">
          <source>In-memory binary streams are also available as &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">메모리 내 이진 스트림은 &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 객체 로도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6cfcf9ff1be78ddbf5f88cac85851468eeaa139" translate="yes" xml:space="preserve">
          <source>In-memory streams</source>
          <target state="translated">인 메모리 스트림</target>
        </trans-unit>
        <trans-unit id="f1e0a688070a40f2e2db3ffb57db4a1558ede0ec" translate="yes" xml:space="preserve">
          <source>In-memory text streams are also available as &lt;a href=&quot;#io.StringIO&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">인 메모리 텍스트 스트림은 &lt;a href=&quot;#io.StringIO&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; 객체 로도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="62f47cd6536074a736c1c116ad6886a50b7748af" translate="yes" xml:space="preserve">
          <source>In-place Operators</source>
          <target state="translated">내부 연산자</target>
        </trans-unit>
        <trans-unit id="8fde0e675981692ca7b1da663a1cf0845aae8f30" translate="yes" xml:space="preserve">
          <source>In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.</source>
          <target state="translated">인플레 이스 작업은 TOS 및 TOS1을 제거하고 스택에서 결과를 다시 푸시한다는 점에서 이진 작업과 같습니다. 그러나 TOS1이이를 지원하면 작업이 제자리에서 수행되며 결과 TOS는 발생할 수 있습니다. 원래 TOS1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8af4b79f6c3a07f98f4ba1fb79d2c37561daffe3" translate="yes" xml:space="preserve">
          <source>Inability to resolve to an internal or external object.</source>
          <target state="translated">내부 또는 외부 개체를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="feb4a11c090061a50eb132ad1c6939bdf6f2540a" translate="yes" xml:space="preserve">
          <source>Include attributes such as line numbers and column offsets.</source>
          <target state="translated">줄 번호 및 열 오프셋과 같은 속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1a6c755eb982a2f54a4da7973c3f73c77717a36d" translate="yes" xml:space="preserve">
          <source>Incomplete Types</source>
          <target state="translated">불완전한 유형</target>
        </trans-unit>
        <trans-unit id="e6fd210ecfa24de959ef25c81cb5be14a187e9d4" translate="yes" xml:space="preserve">
          <source>Increment the line number and end line number of each node in the tree starting at &lt;em&gt;node&lt;/em&gt; by &lt;em&gt;n&lt;/em&gt;. This is useful to &amp;ldquo;move code&amp;rdquo; to a different location in a file.</source>
          <target state="translated">시작 트리 내의 각 노드의 라인 수 및 종료 라인 수를 증가 &lt;em&gt;노드&lt;/em&gt; 가 &lt;em&gt;N을&lt;/em&gt; . 이것은 파일의 다른 위치로 &quot;코드를 이동&quot;하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fc380757d8f1313c5e79738a01b95f0245ea2bcd" translate="yes" xml:space="preserve">
          <source>Incremental (de)compression</source>
          <target state="translated">증분 (de) 압축</target>
        </trans-unit>
        <trans-unit id="c0e4d91a0ac93c5179d6274198eca54354c0112e" translate="yes" xml:space="preserve">
          <source>Incremental Configuration</source>
          <target state="translated">증분 구성</target>
        </trans-unit>
        <trans-unit id="714de6e8dcb31cacd8f82e698735cc996d909c17" translate="yes" xml:space="preserve">
          <source>Incremental Encoding and Decoding</source>
          <target state="translated">증분 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="a70d136600a290d7d648bcefe4f894034d7a33c9" translate="yes" xml:space="preserve">
          <source>Incremental compression:</source>
          <target state="translated">증분 압축 :</target>
        </trans-unit>
        <trans-unit id="a7f4a498ec26fd59fab8b07468072d9f25dbafa4" translate="yes" xml:space="preserve">
          <source>Incremental encoder and decoder classes or factory functions. These have to provide the interface defined by the base classes &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt;&lt;code&gt;IncrementalEncoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt;&lt;code&gt;IncrementalDecoder&lt;/code&gt;&lt;/a&gt;, respectively. Incremental codecs can maintain state.</source>
          <target state="translated">증분 형 엔코더 및 디코더 클래스 또는 팩토리 기능. 이들은 각각 기본 클래스 &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt; &lt;code&gt;IncrementalEncoder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt; &lt;code&gt;IncrementalDecoder&lt;/code&gt; 에&lt;/a&gt; 의해 정의 된 인터페이스를 제공해야합니다 . 증분 코덱은 상태를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc78b0aec9ec9307500e4e82c03e65603530f3f" translate="yes" xml:space="preserve">
          <source>IncrementalDecoder Objects</source>
          <target state="translated">IncrementalDecoder 객체</target>
        </trans-unit>
        <trans-unit id="eda65be020f7ce434c41db14bb91b12c39b505b4" translate="yes" xml:space="preserve">
          <source>IncrementalEncoder Objects</source>
          <target state="translated">IncrementalEncoder 객체</target>
        </trans-unit>
        <trans-unit id="4807b06d3e0ef5d4c1c771970fa1c0c8a1d5ba1f" translate="yes" xml:space="preserve">
          <source>IncrementalParser Objects</source>
          <target state="translated">IncrementalParser 객체</target>
        </trans-unit>
        <trans-unit id="f757e0a955188780b83c7c9c785807ad53aaa78c" translate="yes" xml:space="preserve">
          <source>Increments bytecode counter by &lt;em&gt;delta&lt;/em&gt;.</source>
          <target state="translated">바이트 코드 카운터를 &lt;em&gt;델타&lt;/em&gt; 단위로 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="9f38f8487043353879d3ca62212ab364189a37fc" translate="yes" xml:space="preserve">
          <source>Increments the progress bar&amp;rsquo;s value by &lt;em&gt;amount&lt;/em&gt;.</source>
          <target state="translated">진행률 표시 줄의 값을 &lt;em&gt;amount&lt;/em&gt; 단위로 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="bc9cdd48c3b4bc260e24e340e9220a7006377fb5" translate="yes" xml:space="preserve">
          <source>Indent Region</source>
          <target state="translated">들여 쓰기 지역</target>
        </trans-unit>
        <trans-unit id="ba2fcfc71d761c5016af09f688576fdc3dc2595c" translate="yes" xml:space="preserve">
          <source>Indentation of nodes in AST (number of spaces).</source>
          <target state="translated">AST에서 노드 들여 쓰기 (공백 수).</target>
        </trans-unit>
        <trans-unit id="fb4844c6e4e3fdb04af9405295e30a7c41ae4efc" translate="yes" xml:space="preserve">
          <source>IndentationError</source>
          <target state="translated">IndentationError</target>
        </trans-unit>
        <trans-unit id="3cd6cb1c3ba0aa8ae172917a71df16fc02b82ac0" translate="yes" xml:space="preserve">
          <source>Independent of its category, each concrete stream object will also have various capabilities: it can be read-only, write-only, or read-write. It can also allow arbitrary random access (seeking forwards or backwards to any location), or only sequential access (for example in the case of a socket or pipe).</source>
          <target state="translated">범주와 상관없이 각 콘크리트 스트림 개체에는 다양한 기능이 있습니다. 읽기 전용, 쓰기 전용 또는 읽기 / 쓰기가 가능합니다. 또한 임의의 임의 액세스 (모든 위치로 앞뒤로 탐색) 또는 순차적 액세스 (예 : 소켓 또는 파이프의 경우) 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="383b324a3291b51f1e54ef9c0d763010fbc5e171" translate="yes" xml:space="preserve">
          <source>IndexError</source>
          <target state="translated">IndexError</target>
        </trans-unit>
        <trans-unit id="04f77b5a53e8914ea949c0d3dbe59ff927176c3a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment</source>
          <target state="translated">인덱스 할당</target>
        </trans-unit>
        <trans-unit id="181136c2e116ea448074c254b778be7e9dec6c9a" translate="yes" xml:space="preserve">
          <source>Indexed Deletion</source>
          <target state="translated">인덱스 삭제</target>
        </trans-unit>
        <trans-unit id="6dabd048a18ebfcff9a07def85323d4996693e98" translate="yes" xml:space="preserve">
          <source>Indexed databases of objects; uses &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인덱스 된 객체 데이터베이스; &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; 을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="6face659f95ee23785ce3d17089bd3d63183d57c" translate="yes" xml:space="preserve">
          <source>Indicate that a formerly enqueued task is complete.</source>
          <target state="translated">이전에 대기중인 작업이 완료되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9433ffdce775eecb1add8a4a73f1d9fde76ac24a" translate="yes" xml:space="preserve">
          <source>Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each &lt;a href=&quot;#queue.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; used to fetch a task, a subsequent call to &lt;a href=&quot;#queue.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; tells the queue that the processing on the task is complete.</source>
          <target state="translated">이전에 대기중인 작업이 완료되었음을 나타냅니다. 큐 소비자 스레드에서 사용합니다. 태스크를 페치하는 데 사용 된 각 &lt;a href=&quot;#queue.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 에 대해 후속 &lt;a href=&quot;#queue.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출 은 태스크 처리가 완료되었음을 큐에 알립니다.</target>
        </trans-unit>
        <trans-unit id="ccfdc69dc0a7d14a2b1d58743e040b3b8aaf8ad5" translate="yes" xml:space="preserve">
          <source>Indicate that a formerly enqueued task is complete. Used by queue consumers. For each &lt;a href=&quot;#multiprocessing.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; used to fetch a task, a subsequent call to &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; tells the queue that the processing on the task is complete.</source>
          <target state="translated">이전에 대기중인 작업이 완료되었음을 나타냅니다. 큐 소비자가 사용합니다. 태스크를 페치하는 데 사용 된 각 &lt;a href=&quot;#multiprocessing.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; 에 대해 후속 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출 은 태스크 처리가 완료되었음을 큐에 알립니다.</target>
        </trans-unit>
        <trans-unit id="4ca6309605e634742c386580b3f395d337f036d3" translate="yes" xml:space="preserve">
          <source>Indicate that no more data will be put on this queue by the current process. The background thread will quit once it has flushed all buffered data to the pipe. This is called automatically when the queue is garbage collected.</source>
          <target state="translated">현재 프로세스에서이 큐에 더 이상 데이터를 넣지 않음을 나타냅니다. 버퍼링 된 모든 데이터를 파이프로 플러시하면 백그라운드 스레드가 종료됩니다. 큐가 가비지 수집 될 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="254811cd35f7a531bb479a6926167434a7f0d4ff" translate="yes" xml:space="preserve">
          <source>Indicate that the &lt;em&gt;num&lt;/em&gt; screen lines, starting at line &lt;em&gt;beg&lt;/em&gt;, are corrupted and should be completely redrawn on the next &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">행 &lt;em&gt;beg&lt;/em&gt; 에서 시작 하는 &lt;em&gt;num&lt;/em&gt; 화면 행 이 손상되었으며 다음 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 호출 에서 완전히 다시 그려야 함을 나타냅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f187f4b63c4e285d79b6d0cf7c7d659b0be99d5" translate="yes" xml:space="preserve">
          <source>Indicates if a message of severity &lt;em&gt;level&lt;/em&gt; would be processed by this logger. This method checks first the module-level level set by &lt;code&gt;logging.disable(level)&lt;/code&gt; and then the logger&amp;rsquo;s effective level as determined by &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt;&lt;code&gt;getEffectiveLevel()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 로거가 심각도 &lt;em&gt;수준&lt;/em&gt; 의 메시지를 처리 할지 여부를 나타냅니다 . 이 메소드는 먼저 &lt;code&gt;logging.disable(level)&lt;/code&gt; 의해 설정된 모듈 레벨 레벨을 확인한 다음 &lt;a href=&quot;#logging.Logger.getEffectiveLevel&quot;&gt; &lt;code&gt;getEffectiveLevel()&lt;/code&gt; &lt;/a&gt; 의해 결정된 로거의 유효 레벨을 점검합니다 .</target>
        </trans-unit>
        <trans-unit id="c5c853728e2e1fe3705b4dcef5fcbee47c970151" translate="yes" xml:space="preserve">
          <source>Indicates that an application on 64-bit Windows should operate on the 32-bit registry view.</source>
          <target state="translated">64 비트 Windows의 응용 프로그램이 32 비트 레지스트리보기에서 작동해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be2a690bd039486d70a78d040e16e00e5454af4b" translate="yes" xml:space="preserve">
          <source>Indicates that an application on 64-bit Windows should operate on the 64-bit registry view.</source>
          <target state="translated">64 비트 Windows의 응용 프로그램이 64 비트 레지스트리보기에서 작동해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44029812f3a615dab4b941a3d7aa5ae966773df5" translate="yes" xml:space="preserve">
          <source>Indicates that an operation was requested that does not make sense. If not trapped, returns &lt;code&gt;NaN&lt;/code&gt;. Possible causes include:</source>
          <target state="translated">의미가없는 작업이 요청되었음을 나타냅니다. 갇히지 않으면 &lt;code&gt;NaN&lt;/code&gt; 을 반환 합니다. 가능한 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e5e3976df705a424101261da27cd2fde9d3de10" translate="yes" xml:space="preserve">
          <source>Indicates that rounding occurred and the result is not exact.</source>
          <target state="translated">반올림이 발생했으며 결과가 정확하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cc981c0e44e076ce06474425971fe7b0ad7144fe" translate="yes" xml:space="preserve">
          <source>Indicates the effective level for this logger. If a value other than &lt;code&gt;NOTSET&lt;/code&gt; has been set using &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt;&lt;code&gt;setLevel()&lt;/code&gt;&lt;/a&gt;, it is returned. Otherwise, the hierarchy is traversed towards the root until a value other than &lt;code&gt;NOTSET&lt;/code&gt; is found, and that value is returned. The value returned is an integer, typically one of &lt;code&gt;logging.DEBUG&lt;/code&gt;, &lt;code&gt;logging.INFO&lt;/code&gt; etc.</source>
          <target state="translated">이 로거의 유효 레벨을 나타냅니다. &lt;code&gt;NOTSET&lt;/code&gt; 이외의 값 이 &lt;a href=&quot;#logging.Logger.setLevel&quot;&gt; &lt;code&gt;setLevel()&lt;/code&gt; &lt;/a&gt; 사용하여 설정 되면 값 이 리턴됩니다. 그렇지 않으면 &lt;code&gt;NOTSET&lt;/code&gt; 이외의 값을 찾을 때까지 계층 구조가 루트쪽으로 이동하여 해당 값이 반환됩니다. 반환되는 값은 정수입니다. 일반적으로 &lt;code&gt;logging.DEBUG&lt;/code&gt; , &lt;code&gt;logging.INFO&lt;/code&gt; 등 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="c05b1808b79cd233f656fe2bcfce9be7819d7036" translate="yes" xml:space="preserve">
          <source>Indicates the exponent is larger than &lt;code&gt;Emax&lt;/code&gt; after rounding has occurred. If not trapped, the result depends on the rounding mode, either pulling inward to the largest representable finite number or rounding outward to &lt;code&gt;Infinity&lt;/code&gt;. In either case, &lt;a href=&quot;#decimal.Inexact&quot;&gt;&lt;code&gt;Inexact&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decimal.Rounded&quot;&gt;&lt;code&gt;Rounded&lt;/code&gt;&lt;/a&gt; are also signaled.</source>
          <target state="translated">반올림이 발생한 후 지수가 &lt;code&gt;Emax&lt;/code&gt; 보다 큼을 나타냅니다 . 갇히지 않으면 결과는 반올림 모드에 따라 달라집니다. 표현 가능한 최대 유한 수로 안쪽으로 당기거나 &lt;code&gt;Infinity&lt;/code&gt; 바깥쪽으로 반올림 합니다. 두 경우 모두 &lt;a href=&quot;#decimal.Inexact&quot;&gt; &lt;code&gt;Inexact&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.Rounded&quot;&gt; &lt;code&gt;Rounded&lt;/code&gt; &lt;/a&gt; 도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f77f7a5be2f4f6bec024a7ca688eadb9d8cde39" translate="yes" xml:space="preserve">
          <source>Indicates the fastest compression method (less compression).</source>
          <target state="translated">가장 빠른 압축 방법을 나타냅니다 (낮은 압축).</target>
        </trans-unit>
        <trans-unit id="d526feb8426100dd5e8960080eb37e1f6c7c0e18" translate="yes" xml:space="preserve">
          <source>Indicates the format that the module uses. Version 0 is the historical format, version 1 shares interned strings and version 2 uses a binary format for floating point numbers. Version 3 adds support for object instancing and recursion. The current version is 4.</source>
          <target state="translated">모듈이 사용하는 형식을 나타냅니다. 버전 0은 기록 형식이며, 버전 1은 내부 문자열을 공유하며 버전 2는 부동 소수점 숫자에 이진 형식을 사용합니다. 버전 3은 객체 인스 턴싱 및 재귀에 대한 지원을 추가합니다. 현재 버전은 4입니다.</target>
        </trans-unit>
        <trans-unit id="f9f6bc8bf59e204af2bcdfb956cb28921fb1424b" translate="yes" xml:space="preserve">
          <source>Indicates the slowest compression method (best compression).</source>
          <target state="translated">가장 느린 압축 방법을 나타냅니다 (최상의 압축).</target>
        </trans-unit>
        <trans-unit id="aac4c15b0b527f0bc39db2750782e41d6353de23" translate="yes" xml:space="preserve">
          <source>Indicates unpack completion. Raises an &lt;a href=&quot;#xdrlib.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; exception if all of the data has not been unpacked.</source>
          <target state="translated">포장 풀기 완료를 나타냅니다. 발생시킵니다 &lt;a href=&quot;#xdrlib.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 모든 데이터가 압축 해제되지 않은 경우 예외.</target>
        </trans-unit>
        <trans-unit id="a7b874949185225675d995e483ef8e34af9b6cac" translate="yes" xml:space="preserve">
          <source>Indicates when to change to and back from DST. The format of the start and end dates are one of the following:</source>
          <target state="translated">DST와의 교환시기를 나타냅니다. 시작 날짜와 종료 날짜의 형식은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9f62777df7523c5650cedcd6ae329dd3027c6d33" translate="yes" xml:space="preserve">
          <source>Indicates whether the current platform and implementation provides a symlink attack resistant version of &lt;a href=&quot;#shutil.rmtree&quot;&gt;&lt;code&gt;rmtree()&lt;/code&gt;&lt;/a&gt;. Currently this is only true for platforms supporting fd-based directory access functions.</source>
          <target state="translated">현재 플랫폼 및 구현에서 &lt;a href=&quot;#shutil.rmtree&quot;&gt; &lt;code&gt;rmtree()&lt;/code&gt; &lt;/a&gt; 공격 방지 버전의 rmtree ()를 제공하는지 여부를 나타냅니다 . 현재 이것은 fd 기반 디렉토리 액세스 기능을 지원하는 플랫폼에서만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3de1857c33236705a23bac0cbecb919c2388633f" translate="yes" xml:space="preserve">
          <source>Indicates whether the named &lt;em&gt;section&lt;/em&gt; is present in the configuration. The &lt;em&gt;default section&lt;/em&gt; is not acknowledged.</source>
          <target state="translated">명명 된 &lt;em&gt;섹션&lt;/em&gt; 이 구성에 있는지 여부를 나타냅니다 . &lt;em&gt;기본 부분은&lt;/em&gt; 인정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74f019ba984a0205ae5ca7d205233a0d659108ee" translate="yes" xml:space="preserve">
          <source>Individual flags should have values that are powers of two (1, 2, 4, 8, &amp;hellip;), while combinations of flags won&amp;rsquo;t:</source>
          <target state="translated">개별 플래그는 2의 거듭 제곱 (1, 2, 4, 8,&amp;hellip;) 값을 가져야하지만 플래그 조합은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb56100c551a80a406351b1238fb04cd7a795a80" translate="yes" xml:space="preserve">
          <source>Individual traps are set using the dictionary in the &lt;code&gt;traps&lt;/code&gt; field of a context:</source>
          <target state="translated">개별 트랩은 컨텍스트 의 &lt;code&gt;traps&lt;/code&gt; 필드 에서 사전을 사용하여 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d7a2f3db28391fcf21d52da3f6b53e0db11323d" translate="yes" xml:space="preserve">
          <source>Individual warnings filters are specified as a sequence of fields separated by colons:</source>
          <target state="translated">개별 경고 필터는 콜론으로 구분 된 일련의 필드로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="11d6c70d3b61eb2adec653bae13969c8702afd21" translate="yes" xml:space="preserve">
          <source>Infinite and NaN Number Values</source>
          <target state="translated">무한 및 NaN 숫자 값</target>
        </trans-unit>
        <trans-unit id="fdae9d30d05df13f4736716cf3012faf5a343e86" translate="yes" xml:space="preserve">
          <source>Infinite and NaN number values are accepted and output;</source>
          <target state="translated">무한 및 NaN 숫자 값이 허용되고 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="208f6a4e901648e152bff0d37fcf84f2558c7fa3" translate="yes" xml:space="preserve">
          <source>Infinities can be constructed directly with: &lt;code&gt;Decimal('Infinity')&lt;/code&gt;. Also, they can arise from dividing by zero when the &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt; signal is not trapped. Likewise, when the &lt;a href=&quot;#decimal.Overflow&quot;&gt;&lt;code&gt;Overflow&lt;/code&gt;&lt;/a&gt; signal is not trapped, infinity can result from rounding beyond the limits of the largest representable number.</source>
          <target state="translated">&lt;code&gt;Decimal('Infinity')&lt;/code&gt; 직접 구성 할 수 있습니다 . 또한 &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; &lt;/a&gt; 신호가 트랩되지 않은 경우 0으로 나누면 발생할 수 있습니다 . 마찬가지로, &lt;a href=&quot;#decimal.Overflow&quot;&gt; &lt;code&gt;Overflow&lt;/code&gt; &lt;/a&gt; 신호가 트래핑되지 않으면 최대 표현 가능한 수의 한계를 초과하는 반올림으로 인해 무한대가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5b789236efcc14059ac13c746c6bf63a446511" translate="yes" xml:space="preserve">
          <source>Info-ZIP Home Page</source>
          <target state="translated">Info-ZIP 홈페이지</target>
        </trans-unit>
        <trans-unit id="f1a9ffafc271a884fe1c56d1e91026a9afac1d59" translate="yes" xml:space="preserve">
          <source>Information about how the &lt;a href=&quot;#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module can be used to replace these modules and functions can be found in the following sections.</source>
          <target state="translated">&lt;a href=&quot;#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 이러한 모듈 및 기능을 대체 하는 방법에 대한 정보 는 다음 섹션에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73dc9ae5bb811ec4a81b13ac14f9d0600c74bdc0" translate="yes" xml:space="preserve">
          <source>Information about the Info-ZIP project&amp;rsquo;s ZIP archive programs and development libraries.</source>
          <target state="translated">Info-ZIP 프로젝트의 ZIP 보관 프로그램 및 개발 라이브러리에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="5dca2a23bec2c3f3823dba848b63caa3ddd34f46" translate="yes" xml:space="preserve">
          <source>Information about the declarations needed to process a document.</source>
          <target state="translated">문서를 처리하는 데 필요한 선언에 대한 정보</target>
        </trans-unit>
        <trans-unit id="37721dc7ffd07b44f936ed4938598a4206ad258c" translate="yes" xml:space="preserve">
          <source>Information about the notations and entities declared by a document (including the external subset if the parser uses it and can provide the information) is available from a &lt;code&gt;DocumentType&lt;/code&gt; object. The &lt;code&gt;DocumentType&lt;/code&gt; for a document is available from the &lt;code&gt;Document&lt;/code&gt; object&amp;rsquo;s &lt;code&gt;doctype&lt;/code&gt; attribute; if there is no &lt;code&gt;DOCTYPE&lt;/code&gt; declaration for the document, the document&amp;rsquo;s &lt;code&gt;doctype&lt;/code&gt; attribute will be set to &lt;code&gt;None&lt;/code&gt; instead of an instance of this interface.</source>
          <target state="translated">문서에 의해 선언 된 표기법 및 엔티티에 대한 정보 (구문 파서가 사용하고 정보를 제공 할 수있는 경우 외부 서브 세트 포함)는 &lt;code&gt;DocumentType&lt;/code&gt; 객체 에서 사용할 수 있습니다 . &lt;code&gt;DocumentType&lt;/code&gt; 의 DocumentType 은 &lt;code&gt;Document&lt;/code&gt; 객체의 &lt;code&gt;doctype&lt;/code&gt; 속성 에서 사용할 수 있습니다 . 문서에 대한 &lt;code&gt;DOCTYPE&lt;/code&gt; 선언 이없는 경우이 인터페이스의 인스턴스 대신 문서의 &lt;code&gt;doctype&lt;/code&gt; 속성이 &lt;code&gt;None&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cce32b3d49301f675170423df0e3a5fe42a9f458" translate="yes" xml:space="preserve">
          <source>Information about the version of the zlib library in use is available through the following constants:</source>
          <target state="translated">사용중인 zlib 라이브러리 버전에 대한 정보는 다음 상수를 통해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc195259320a72e072f4ede32b54adf6cc49ee6" translate="yes" xml:space="preserve">
          <source>Informs the logging system to perform an orderly shutdown by flushing and closing all handlers. This should be called at application exit and no further use of the logging system should be made after this call.</source>
          <target state="translated">모든 핸들러를 플러시하고 닫아서 로깅 시스템에 순차적으로 종료하도록 지시합니다. 애플리케이션 종료시 호출해야하며이 호출 후에는 로깅 시스템을 더 이상 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="8c3b7e7bdfb6a623a8eb23a0493ea3c67706b89d" translate="yes" xml:space="preserve">
          <source>Inheritance of File Descriptors</source>
          <target state="translated">파일 디스크립터의 상속</target>
        </trans-unit>
        <trans-unit id="6bce323c70ebeda273b76b4deb2d56162be0c2e0" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Mapping&quot;&gt;&lt;code&gt;Mapping&lt;/code&gt;&lt;/a&gt; methods and &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;popitem&lt;/code&gt;, &lt;code&gt;clear&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, and &lt;code&gt;setdefault&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Mapping&quot;&gt; &lt;code&gt;Mapping&lt;/code&gt; &lt;/a&gt; 메소드 및 &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;popitem&lt;/code&gt; , &lt;code&gt;clear&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;setdefault&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06211f7ed37f2fb2fd3d0b096255e56986486d8f" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; methods</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="6c8ee095532c52fa04b5b2f4774ee70078537885" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt; methods and &lt;code&gt;append&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, and &lt;code&gt;__iadd__&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt; 메소드 및 &lt;code&gt;append&lt;/code&gt; , &lt;code&gt;reverse&lt;/code&gt; , &lt;code&gt;extend&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 및 &lt;code&gt;__iadd__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d51fda0d61054bbf60003067c334dea455e6a456" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#collections.abc.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; methods and &lt;code&gt;clear&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;__ior__&lt;/code&gt;, &lt;code&gt;__iand__&lt;/code&gt;, &lt;code&gt;__ixor__&lt;/code&gt;, and &lt;code&gt;__isub__&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#collections.abc.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 메서드 및 &lt;code&gt;clear&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;__ior__&lt;/code&gt; , &lt;code&gt;__iand__&lt;/code&gt; , &lt;code&gt;__ixor__&lt;/code&gt; 및 &lt;code&gt;__isub__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="379c6401d036c1fd4201479a5a98fa61950fb477" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; methods, &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, and &lt;code&gt;newlines&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 메서드, &lt;code&gt;encoding&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; 및 줄 &lt;code&gt;newlines&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f9245eee96edcd8825a2046422c07072497cf0f" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; methods, &lt;code&gt;read&lt;/code&gt;, and &lt;code&gt;readall&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 메서드, &lt;code&gt;read&lt;/code&gt; 및 &lt;code&gt;readall&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a95bfb8966052c1a0ceee8247e352fac2cbbb068" translate="yes" xml:space="preserve">
          <source>Inherited &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt; methods, &lt;code&gt;readinto&lt;/code&gt;, and &lt;code&gt;readinto1&lt;/code&gt;</source>
          <target state="translated">상속 된 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; 메서드 &lt;code&gt;readinto&lt;/code&gt; 및 &lt;code&gt;readinto1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2f86a0622771a4fe382df1bdcb5afbbe667c715" translate="yes" xml:space="preserve">
          <source>Inherits</source>
          <target state="translated">Inherits</target>
        </trans-unit>
        <trans-unit id="b22e7705af8c8d03aae22d1b8adde6a0eccc1637" translate="yes" xml:space="preserve">
          <source>Inherits from</source>
          <target state="translated">에서 상속</target>
        </trans-unit>
        <trans-unit id="2bc75738f31d4cad0d4af9bafd60101443b8a470" translate="yes" xml:space="preserve">
          <source>Init file</source>
          <target state="translated">초기화 파일</target>
        </trans-unit>
        <trans-unit id="a84f9ff878eec42e40bd18840ce1e8b26a925aef" translate="yes" xml:space="preserve">
          <source>Init-only variables</source>
          <target state="translated">초기화 전용 변수</target>
        </trans-unit>
        <trans-unit id="f5d6a89f24c042aeeed4c674d462173e914e969f" translate="yes" xml:space="preserve">
          <source>Init-only variables without default values, if any exist, must be specified on the call to &lt;a href=&quot;#dataclasses.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt; so that they can be passed to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;__post_init__()&lt;/code&gt;.</source>
          <target state="translated">기본값이없는 초기화 전용 변수 &lt;a href=&quot;#dataclasses.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;__post_init__()&lt;/code&gt; 로 전달 될 수 있도록 replace () 호출에 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="00d9484a203c55d062115756023f903da303882a" translate="yes" xml:space="preserve">
          <source>Init-only variables without default values, if any exist, must be specified on the call to &lt;a href=&quot;#dataclasses.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt; so that they can be passed to &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;__post_init__()&lt;/code&gt;.</source>
          <target state="translated">Init-only variables without default values, if any exist, must be specified on the call to &lt;a href=&quot;#dataclasses.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; so that they can be passed to &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;__post_init__()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae7812ad31389ab36e054e9b5c81ee4355c0c33" translate="yes" xml:space="preserve">
          <source>Initial turtle heading</source>
          <target state="translated">초기 거북이 제목</target>
        </trans-unit>
        <trans-unit id="9c053c5a31de248a3fe3887d73e022ca74699147" translate="yes" xml:space="preserve">
          <source>Initialize curses and call another callable object, &lt;em&gt;func&lt;/em&gt;, which should be the rest of your curses-using application. If the application raises an exception, this function will restore the terminal to a sane state before re-raising the exception and generating a traceback. The callable object &lt;em&gt;func&lt;/em&gt; is then passed the main window &amp;lsquo;stdscr&amp;rsquo; as its first argument, followed by any other arguments passed to &lt;code&gt;wrapper()&lt;/code&gt;. Before calling &lt;em&gt;func&lt;/em&gt;, &lt;code&gt;wrapper()&lt;/code&gt; turns on cbreak mode, turns off echo, enables the terminal keypad, and initializes colors if the terminal has color support. On exit (whether normally or by exception) it restores cooked mode, turns on echo, and disables the terminal keypad.</source>
          <target state="translated">저주를 초기화하고 호출 가능한 다른 응용 프로그램 인 &lt;em&gt;func를&lt;/em&gt; 호출 하십시오. 응용 프로그램에서 예외가 발생하면이 기능은 예외를 다시 발생시키고 역 추적을 생성하기 전에 터미널을 정상 상태로 복원합니다. 호출 가능한 객체 &lt;em&gt;func&lt;/em&gt; 는 주 창 'stdscr'을 첫 번째 인수로 전달한 다음 &lt;code&gt;wrapper()&lt;/code&gt; 전달 된 다른 인수를 전달합니다 . 호출하기 전에 &lt;em&gt;FUNC&lt;/em&gt; , &lt;code&gt;wrapper()&lt;/code&gt; CBREAK 모드에 대한 회전은, 에코 오프 회전은, 터미널 키패드를 가능하게하고, 터미널 색상 지원이있는 경우 색상을 초기화한다. 종료시 (정상 또는 예외 여부에 관계없이) 쿠킹 모드를 복원하고 에코를 켜고 터미널 키패드를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3c39102c3fa06222a5c163727b0377eb39a67e1f" translate="yes" xml:space="preserve">
          <source>Initialize the internal data structures. If given, &lt;em&gt;files&lt;/em&gt; must be a sequence of file names which should be used to augment the default type map. If omitted, the file names to use are taken from &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt;&lt;code&gt;knownfiles&lt;/code&gt;&lt;/a&gt;; on Windows, the current registry settings are loaded. Each file named in &lt;em&gt;files&lt;/em&gt; or &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt;&lt;code&gt;knownfiles&lt;/code&gt;&lt;/a&gt; takes precedence over those named before it. Calling &lt;a href=&quot;#mimetypes.init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/a&gt; repeatedly is allowed.</source>
          <target state="translated">내부 데이터 구조를 초기화하십시오. 주어진 경우, &lt;em&gt;파일&lt;/em&gt; 은 기본 유형 맵을 기능 보강하는 데 사용해야하는 일련의 파일 이름이어야합니다. 생략하면 사용할 파일 이름은 &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt; &lt;code&gt;knownfiles&lt;/code&gt; &lt;/a&gt; 파일에서 가져옵니다 . Windows에서는 현재 레지스트리 설정이로드됩니다. &lt;em&gt;파일&lt;/em&gt; 또는 &lt;a href=&quot;#mimetypes.knownfiles&quot;&gt; &lt;code&gt;knownfiles&lt;/code&gt; &lt;/a&gt; 파일로 명명 된 각 파일은 이전에 명명 된 &lt;em&gt;파일&lt;/em&gt; 보다 우선합니다. &lt;a href=&quot;#mimetypes.init&quot;&gt; &lt;code&gt;init()&lt;/code&gt; &lt;/a&gt; 반복해서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67a777e10b60c9589ca15590b09a5cec97aaa843" translate="yes" xml:space="preserve">
          <source>Initialize the library. Return a &lt;a href=&quot;#curses-window-objects&quot;&gt;window&lt;/a&gt; object which represents the whole screen.</source>
          <target state="translated">라이브러리를 초기화하십시오. 전체 화면을 나타내는 &lt;a href=&quot;#curses-window-objects&quot;&gt;창&lt;/a&gt; 개체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="48428a849fbd7ccb672616c8d11dd86f3867404a" translate="yes" xml:space="preserve">
          <source>Initialize the random number generator.</source>
          <target state="translated">난수 생성기를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="70995d6f7eecb673c201a63dd47d29c6584b9166" translate="yes" xml:space="preserve">
          <source>Initialize the terminal. &lt;em&gt;term&lt;/em&gt; is a string giving the terminal name, or &lt;code&gt;None&lt;/code&gt;; if omitted or &lt;code&gt;None&lt;/code&gt;, the value of the &lt;code id=&quot;index-1&quot;&gt;TERM&lt;/code&gt; environment variable will be used. &lt;em&gt;fd&lt;/em&gt; is the file descriptor to which any initialization sequences will be sent; if not supplied or &lt;code&gt;-1&lt;/code&gt;, the file descriptor for &lt;code&gt;sys.stdout&lt;/code&gt; will be used.</source>
          <target state="translated">터미널을 초기화하십시오. &lt;em&gt;term&lt;/em&gt; 은 터미널 이름을 나타내는 문자열이거나 &lt;code&gt;None&lt;/code&gt; 입니다 . 생략되거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;code id=&quot;index-1&quot;&gt;TERM&lt;/code&gt; 환경 변수 의 값 이 사용됩니다. &lt;em&gt;fd&lt;/em&gt; 는 초기화 시퀀스가 ​​전송 될 파일 &lt;em&gt;디스크립터&lt;/em&gt; 입니다. 제공되지 않거나 &lt;code&gt;-1&lt;/code&gt; 이면 &lt;code&gt;sys.stdout&lt;/code&gt; 의 파일 디스크립터 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab79211166494a5373743e60ba9599daf58a2af2" translate="yes" xml:space="preserve">
          <source>Initializers of the correct type can also be specified:</source>
          <target state="translated">올바른 유형의 이니셜 라이저도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc9f180e9eb479c565d2e3c4fd6ce05ca9e580e" translate="yes" xml:space="preserve">
          <source>Initializes a thread lock which can be used to serialize access to underlying I/O functionality which may not be threadsafe.</source>
          <target state="translated">스레드 안전하지 않을 수있는 기본 I / O 기능에 대한 액세스를 직렬화하는 데 사용할 수있는 스레드 잠금을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3852a908d7c934410ea309c7ea1ea46af8743103" translate="yes" xml:space="preserve">
          <source>Initializes instance of &lt;a href=&quot;#difflib.HtmlDiff&quot;&gt;&lt;code&gt;HtmlDiff&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#difflib.HtmlDiff&quot;&gt; &lt;code&gt;HtmlDiff&lt;/code&gt; &lt;/a&gt; 인스턴스를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="f5885aef6f5096d972360ad2af443e94000e495a" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;a href=&quot;#logging.Handler&quot;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt; instance by setting its level, setting the list of filters to the empty list and creating a lock (using &lt;a href=&quot;#logging.Handler.createLock&quot;&gt;&lt;code&gt;createLock()&lt;/code&gt;&lt;/a&gt;) for serializing access to an I/O mechanism.</source>
          <target state="translated">레벨을 설정하고 필터 목록을 빈 목록 으로 설정하고 I / O 메커니즘에 대한 액세스를 직렬화하기위한 잠금을 작성 ( &lt;a href=&quot;#logging.Handler.createLock&quot;&gt; &lt;code&gt;createLock()&lt;/code&gt; &lt;/a&gt; ) 하여 &lt;a href=&quot;#logging.Handler&quot;&gt; &lt;code&gt;Handler&lt;/code&gt; &lt;/a&gt; 인스턴스를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="891e93a281cdc0ae8bd4cb4966bc1555092cc9eb" translate="yes" xml:space="preserve">
          <source>Initializes the given module object in accordance with &lt;a href=&quot;https://www.python.org/dev/peps/pep-0489&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 489&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0489&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 489&lt;/strong&gt;&lt;/a&gt; 에 따라 지정된 모듈 객체를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="76391f6bbc3769470e5c6904d1885bcf07a8f838" translate="yes" xml:space="preserve">
          <source>Initializes the handler with a buffer of the specified capacity. Here, &lt;em&gt;capacity&lt;/em&gt; means the number of logging records buffered.</source>
          <target state="translated">지정된 용량의 버퍼로 핸들러를 초기화합니다. 여기서 &lt;em&gt;capacity&lt;/em&gt; 는 버퍼링 된 로깅 레코드 수를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6a4659852d66e1b08bbacb99cd059b9b5779e858" translate="yes" xml:space="preserve">
          <source>Initially &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; defined Python static type system as using &lt;em&gt;nominal subtyping&lt;/em&gt;. This means that a class &lt;code&gt;A&lt;/code&gt; is allowed where a class &lt;code&gt;B&lt;/code&gt; is expected if and only if &lt;code&gt;A&lt;/code&gt; is a subclass of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">처음에 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 484는&lt;/strong&gt;&lt;/a&gt;&lt;em&gt; 공칭 서브&lt;/em&gt; 타이핑을 사용하여 Python 정적 유형 시스템을 정의했습니다 . 이 수단은 클래스 것을 &lt;code&gt;A&lt;/code&gt; 를 클래스 허용 여기서 &lt;code&gt;B&lt;/code&gt; 는 경우에만, 예상 &lt;code&gt;A&lt;/code&gt; 는 의 서브 &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651e55be975986e7fd15535125aa6f9af6b714d3" translate="yes" xml:space="preserve">
          <source>Initially, when a program is started, the locale is the &lt;code&gt;C&lt;/code&gt; locale, no matter what the user&amp;rsquo;s preferred locale is. There is one exception: the &lt;a href=&quot;#locale.LC_CTYPE&quot;&gt;&lt;code&gt;LC_CTYPE&lt;/code&gt;&lt;/a&gt; category is changed at startup to set the current locale encoding to the user&amp;rsquo;s preferred locale encoding. The program must explicitly say that it wants the user&amp;rsquo;s preferred locale settings for other categories by calling &lt;code&gt;setlocale(LC_ALL, '')&lt;/code&gt;.</source>
          <target state="translated">처음에 프로그램이 시작되면 사용자가 선호하는 로캘이 무엇이든 로캘은 &lt;code&gt;C&lt;/code&gt; 로캘입니다. 한 가지 예외가 있습니다. &lt;a href=&quot;#locale.LC_CTYPE&quot;&gt; &lt;code&gt;LC_CTYPE&lt;/code&gt; &lt;/a&gt; 범주는 시작시 현재 로캘 인코딩을 사용자가 선호하는 로캘 인코딩으로 설정하도록 변경됩니다. 프로그램은 &lt;code&gt;setlocale(LC_ALL, '')&lt;/code&gt; 을 호출하여 다른 카테고리에 대해 사용자가 선호하는 로케일 설정을 원한다고 명시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b6d8ad6283ed79c07a911360e0d9b48d60fca9b3" translate="yes" xml:space="preserve">
          <source>Initiate a transfer over the data connection. If the transfer is active, send an &lt;code&gt;EPRT&lt;/code&gt; or &lt;code&gt;PORT&lt;/code&gt; command and the transfer command specified by &lt;em&gt;cmd&lt;/em&gt;, and accept the connection. If the server is passive, send an &lt;code&gt;EPSV&lt;/code&gt; or &lt;code&gt;PASV&lt;/code&gt; command, connect to it, and start the transfer command. Either way, return the socket for the connection.</source>
          <target state="translated">데이터 연결을 통한 전송을 시작하십시오. 전송이 활성화 된 경우 &lt;code&gt;EPRT&lt;/code&gt; 또는 &lt;code&gt;PORT&lt;/code&gt; 명령과 &lt;em&gt;cmd로&lt;/em&gt; 지정된 전송 명령을 전송 하고 연결을 수락하십시오. 서버가 수동 인 경우 &lt;code&gt;EPSV&lt;/code&gt; 또는 &lt;code&gt;PASV&lt;/code&gt; 명령을 전송하고 연결 한 후 전송 명령을 시작하십시오. 어느 쪽이든 연결 소켓을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="a3b934f82fa9691663fe5cc49e6c91ec415ce86a" translate="yes" xml:space="preserve">
          <source>Inode number.</source>
          <target state="translated">아이 노드 번호.</target>
        </trans-unit>
        <trans-unit id="61f3e06ef66f729eb248fc28dbd015725fbd26d3" translate="yes" xml:space="preserve">
          <source>Inode protection mode.</source>
          <target state="translated">아이 노드 보호 모드.</target>
        </trans-unit>
        <trans-unit id="abc398c151cedbf682a4e32b5fe1f87a91547da5" translate="yes" xml:space="preserve">
          <source>Input methods</source>
          <target state="translated">입력 방법</target>
        </trans-unit>
        <trans-unit id="3bac6667a1606f6aae5b9d31130c86a61ea3e529" translate="yes" xml:space="preserve">
          <source>Input parameter which defaults to the integer zero.</source>
          <target state="translated">기본값은 정수 0입니다.</target>
        </trans-unit>
        <trans-unit id="f0dadaeaa1a0521f244cb0c7817109df239c4e4a" translate="yes" xml:space="preserve">
          <source>Input/ouput</source>
          <target state="translated">Input/ouput</target>
        </trans-unit>
        <trans-unit id="cfb6ac42c15bfc315aef836b57bb90c22f4f147f" translate="yes" xml:space="preserve">
          <source>InputSource Objects</source>
          <target state="translated">입력 소스 객체</target>
        </trans-unit>
        <trans-unit id="98cceba3103286deb746764afbe409454e752550" translate="yes" xml:space="preserve">
          <source>Inputs as in &lt;a href=&quot;#turtle.pencolor&quot;&gt;&lt;code&gt;pencolor()&lt;/code&gt;&lt;/a&gt;, set both, fillcolor and pencolor, to the given value.</source>
          <target state="translated">&lt;a href=&quot;#turtle.pencolor&quot;&gt; &lt;code&gt;pencolor()&lt;/code&gt; &lt;/a&gt; 에서와 같이 입력하고 fillcolor와 pencolor를 모두 주어진 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="5c6157626eaa443a7d46529cadb0898d243cf4bf" translate="yes" xml:space="preserve">
          <source>Insert ## in front of selected lines.</source>
          <target state="translated">선택한 줄 앞에 ##을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="771d3a8e81fd09fb95d718f0e07e3c3ed54b1cb1" translate="yes" xml:space="preserve">
          <source>Insert &lt;em&gt;nlines&lt;/em&gt; lines into the specified window above the current line. The &lt;em&gt;nlines&lt;/em&gt; bottom lines are lost. For negative &lt;em&gt;nlines&lt;/em&gt;, delete &lt;em&gt;nlines&lt;/em&gt; lines starting with the one under the cursor, and move the remaining lines up. The bottom &lt;em&gt;nlines&lt;/em&gt; lines are cleared. The current cursor position remains the same.</source>
          <target state="translated">&lt;em&gt;nlines&lt;/em&gt; 행을 현재 행 위의 지정된 창에 삽입하십시오 . &lt;em&gt;NLINES&lt;/em&gt; 수익성이 손실됩니다. 음수 &lt;em&gt;nlines의&lt;/em&gt; 경우 커서 아래에있는 것으로 시작하여 &lt;em&gt;nlines&lt;/em&gt; 행을 삭제 하고 나머지 행을 위로 이동하십시오. 하단 &lt;em&gt;NLINES&lt;/em&gt; 라인은 삭제됩니다. 현재 커서 위치는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab25aba32579e4cbe82e3445dbc2750c5f19e2d" translate="yes" xml:space="preserve">
          <source>Insert &lt;em&gt;x&lt;/em&gt; in &lt;em&gt;a&lt;/em&gt; in sorted order. This is equivalent to &lt;code&gt;a.insert(bisect.bisect_left(a, x, lo, hi), x)&lt;/code&gt; assuming that &lt;em&gt;a&lt;/em&gt; is already sorted. Keep in mind that the O(log n) search is dominated by the slow O(n) insertion step.</source>
          <target state="translated">삽입 &lt;em&gt;X&lt;/em&gt; 에 정렬 된 순서. 이것은 &lt;em&gt;a&lt;/em&gt; 가 이미 정렬되어 있다고 가정하면 &lt;code&gt;a.insert(bisect.bisect_left(a, x, lo, hi), x)&lt;/code&gt; . O (log n) 검색은 느린 O (n) 삽입 단계에 의해 지배됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ffe19f9b53fcc062222865d04ee695208ba7423" translate="yes" xml:space="preserve">
          <source>Insert &lt;em&gt;x&lt;/em&gt; into the deque at position &lt;em&gt;i&lt;/em&gt;.</source>
          <target state="translated">위치 &lt;em&gt;i&lt;/em&gt; 의 데크에 &lt;em&gt;x&lt;/em&gt; 를 삽입하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e69d0858508dfc3e6620fa59f50ef0662785e9c6" translate="yes" xml:space="preserve">
          <source>Insert CGI variables for the current request into the &lt;code&gt;environ&lt;/code&gt; attribute.</source>
          <target state="translated">현재 요청에 대한 CGI 변수를 &lt;code&gt;environ&lt;/code&gt; 속성에 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="11cf289408f544e7431d78ef915fdb066ede3d6a" translate="yes" xml:space="preserve">
          <source>Insert a blank line at cursor location.</source>
          <target state="translated">커서 위치에 빈 줄을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="428b27b44b5679a5100cbb0f2b51ce75dd8a5bf2" translate="yes" xml:space="preserve">
          <source>Insert a blank line under the cursor. All following lines are moved down by one line.</source>
          <target state="translated">커서 아래에 빈 줄을 삽입하십시오. 다음 줄은 모두 한 줄 아래로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8cc41d420c2a48fb3dbe04ee4c88fa790360f745" translate="yes" xml:space="preserve">
          <source>Insert a character string (as many characters as will fit on the line) before the character under the cursor, up to &lt;em&gt;n&lt;/em&gt; characters. If &lt;em&gt;n&lt;/em&gt; is zero or negative, the entire string is inserted. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to &lt;em&gt;y&lt;/em&gt;, &lt;em&gt;x&lt;/em&gt;, if specified).</source>
          <target state="translated">커서 아래의 문자 앞에 최대 &lt;em&gt;n&lt;/em&gt; 자 까지 문자열을 입력하십시오 (행에 맞는 문자 수). 경우 &lt;em&gt;n이&lt;/em&gt; 제로 또는 네거티브 전체 문자열을 삽입한다. 커서 오른쪽의 모든 문자가 오른쪽으로 이동하고 줄의 가장 오른쪽 문자가 손실됩니다. 커서 위치는 변경되지 않습니다 ( 지정된 경우 &lt;em&gt;y&lt;/em&gt; , &lt;em&gt;x로&lt;/em&gt; 이동 한 후 ).</target>
        </trans-unit>
        <trans-unit id="52ef5c0b09949330d13e4bb951c2c108148e5ec6" translate="yes" xml:space="preserve">
          <source>Insert a character string (as many characters as will fit on the line) before the character under the cursor. All characters to the right of the cursor are shifted right, with the rightmost characters on the line being lost. The cursor position does not change (after moving to &lt;em&gt;y&lt;/em&gt;, &lt;em&gt;x&lt;/em&gt;, if specified).</source>
          <target state="translated">커서 아래의 문자 앞에 문자 문자열 (행에 맞는 문자 수)을 삽입하십시오. 커서 오른쪽의 모든 문자가 오른쪽으로 이동하고 줄의 가장 오른쪽 문자가 손실됩니다. 커서 위치는 변경되지 않습니다 ( 지정된 경우 &lt;em&gt;y&lt;/em&gt; , &lt;em&gt;x로&lt;/em&gt; 이동 한 후 ).</target>
        </trans-unit>
        <trans-unit id="2cd230c1b957b61fbeafaadd6ef3bd7966d963f4" translate="yes" xml:space="preserve">
          <source>Insert a new child node before an existing child. It must be the case that &lt;em&gt;refChild&lt;/em&gt; is a child of this node; if not, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. &lt;em&gt;newChild&lt;/em&gt; is returned. If &lt;em&gt;refChild&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, it inserts &lt;em&gt;newChild&lt;/em&gt; at the end of the children&amp;rsquo;s list.</source>
          <target state="translated">기존 자식 앞에 새 자식 노드를 삽입하십시오. &lt;em&gt;refChild&lt;/em&gt; 가이 노드의 자식 인 경우 여야 합니다. 그렇지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;em&gt;newChild&lt;/em&gt; 가 반환됩니다. 경우 &lt;em&gt;refChild의가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 그것은 삽입 &lt;em&gt;를 newChild를&lt;/em&gt; 아이들의 목록의 끝에서.</target>
        </trans-unit>
        <trans-unit id="dbbded73e99c71141ac74230b61b365295b11341" translate="yes" xml:space="preserve">
          <source>Insert a new item with value &lt;em&gt;x&lt;/em&gt; in the array before position &lt;em&gt;i&lt;/em&gt;. Negative values are treated as being relative to the end of the array.</source>
          <target state="translated">위치 &lt;em&gt;i&lt;/em&gt; 앞에 배열에 값이 &lt;em&gt;x 인&lt;/em&gt; 새 항목을 삽입하십시오 . 음수 값은 배열의 끝을 기준으로 처리됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6442b4677754abf24013415cfc0b02328c37bf8d" translate="yes" xml:space="preserve">
          <source>Insert a simple entry into the list of &lt;a href=&quot;#warning-filter&quot;&gt;warnings filter specifications&lt;/a&gt;. The meaning of the function parameters is as for &lt;a href=&quot;#warnings.filterwarnings&quot;&gt;&lt;code&gt;filterwarnings()&lt;/code&gt;&lt;/a&gt;, but regular expressions are not needed as the filter inserted always matches any message in any module as long as the category and line number match.</source>
          <target state="translated">&lt;a href=&quot;#warning-filter&quot;&gt;경고 필터 사양&lt;/a&gt; 목록에 간단한 항목을 삽입하십시오 . 함수 매개 변수의 의미는 &lt;a href=&quot;#warnings.filterwarnings&quot;&gt; &lt;code&gt;filterwarnings()&lt;/code&gt; &lt;/a&gt; 와 같지만 삽입 된 필터는 범주 및 줄 번호가 일치하는 한 모듈의 모든 메시지와 항상 일치하므로 정규식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be8c8abeab9182b5ad4c0936ac5747b095eb532b" translate="yes" xml:space="preserve">
          <source>Insert an &lt;em&gt;ms&lt;/em&gt; millisecond pause in output.</source>
          <target state="translated">출력에 &lt;em&gt;ms&lt;/em&gt; 밀리 초 일시 중지를 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="73267e5ac5110513448a2a6d6f16738aaf106dd8" translate="yes" xml:space="preserve">
          <source>Insert an entry into the list of &lt;a href=&quot;#warning-filter&quot;&gt;warnings filter specifications&lt;/a&gt;. The entry is inserted at the front by default; if &lt;em&gt;append&lt;/em&gt; is true, it is inserted at the end. This checks the types of the arguments, compiles the &lt;em&gt;message&lt;/em&gt; and &lt;em&gt;module&lt;/em&gt; regular expressions, and inserts them as a tuple in the list of warnings filters. Entries closer to the front of the list override entries later in the list, if both match a particular warning. Omitted arguments default to a value that matches everything.</source>
          <target state="translated">&lt;a href=&quot;#warning-filter&quot;&gt;경고 필터 사양&lt;/a&gt; 목록에 항목을 삽입하십시오 . 항목은 기본적으로 앞에 삽입됩니다. 경우 &lt;em&gt;APPEND는&lt;/em&gt; 사실, 그것은 마지막에 삽입됩니다. 인수의 유형을 확인하고 &lt;em&gt;메시지&lt;/em&gt; 및 &lt;em&gt;모듈&lt;/em&gt; 정규식을 컴파일 한 후 경고 필터 목록에 튜플로 삽입합니다. 목록 앞쪽에 더 가까운 항목은 둘 다 특정 경고와 일치하면 목록의 뒷부분에있는 항목보다 우선합니다. 생략 된 인수의 기본값은 모든 항목과 일치하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="ff80a5974b23d77a5c2b2ad834261e49b5ed7b09" translate="yes" xml:space="preserve">
          <source>Insert char or enter insert mode</source>
          <target state="translated">문자 삽입 또는 삽입 모드로 들어가기</target>
        </trans-unit>
        <trans-unit id="e1b4dd9343d0aec1500078fcc20dfa87ecdaec8c" translate="yes" xml:space="preserve">
          <source>Insert contents of the system-wide clipboard into the current window.</source>
          <target state="translated">시스템 전체 클립 보드의 내용을 현재 창에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="1d9d9fcb3881a1a7b2f39fbd44148815f8ffb775" translate="yes" xml:space="preserve">
          <source>Insert line</source>
          <target state="translated">라인 삽입</target>
        </trans-unit>
        <trans-unit id="85b1c3bfc9615f38c45334ce27a2c3874f427470" translate="yes" xml:space="preserve">
          <source>Insert text into the line buffer at the cursor position. This calls &lt;code&gt;rl_insert_text()&lt;/code&gt; in the underlying library, but ignores the return value.</source>
          <target state="translated">커서 위치에서 라인 버퍼에 텍스트를 삽입하십시오. 기본 라이브러리에서 &lt;code&gt;rl_insert_text()&lt;/code&gt; 를 호출 하지만 반환 값은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="321a83365ddb728f137f24e4d0374b111b7a89d6" translate="yes" xml:space="preserve">
          <source>Inserts &lt;em&gt;subelement&lt;/em&gt; at the given position in this element. Raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;subelement&lt;/em&gt; is not an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 요소의 지정된 위치에 &lt;em&gt;하위 요소&lt;/em&gt; 를 삽입합니다 . 발생시킵니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 경우 &lt;em&gt;하위 요소가&lt;/em&gt; 없는 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07136851031cb8faca3df628c368a5d3f07c5e9a" translate="yes" xml:space="preserve">
          <source>Inserts a pane at the specified position.</source>
          <target state="translated">지정된 위치에 구획을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ba601e0ab0345ba7e2ea9c966cfb362c3e4da835" translate="yes" xml:space="preserve">
          <source>Inspect area below mouse for target objects while drag is performed.</source>
          <target state="translated">Inspect area below mouse for target objects while drag is performed.</target>
        </trans-unit>
        <trans-unit id="603a69de2ef615fc4774dc5a531b0478d24bd0ba" translate="yes" xml:space="preserve">
          <source>Install a timer that calls &lt;em&gt;fun&lt;/em&gt; after &lt;em&gt;t&lt;/em&gt; milliseconds.</source>
          <target state="translated">&lt;em&gt;t&lt;/em&gt; 밀리 초 후에 &lt;em&gt;재미있게&lt;/em&gt; 호출되는 타이머를 설치하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d804377ba7463dd5b6eaba5ccaaad14a63c4069" translate="yes" xml:space="preserve">
          <source>Install all of your application&amp;rsquo;s dependencies into the &lt;code&gt;myapp&lt;/code&gt; directory, using pip:</source>
          <target state="translated">pip를 사용하여 모든 애플리케이션의 종속성을 &lt;code&gt;myapp&lt;/code&gt; 디렉토리에 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="520b157afbe331621bce1a360a6f018e0e187fbb" translate="yes" xml:space="preserve">
          <source>Install an &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt; instance as the default global opener. Installing an opener is only necessary if you want urlopen to use that opener; otherwise, simply call &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt;&lt;code&gt;OpenerDirector.open()&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt;. The code does not check for a real &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt;, and any class with the appropriate interface will work.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; &lt;/a&gt; 인스턴스를 기본 글로벌 오프너로 설치하십시오 . 오프너 설치는 urlopen이 해당 오프너를 사용하도록하려는 경우에만 필요합니다. 그렇지 않으면 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt; &lt;code&gt;OpenerDirector.open()&lt;/code&gt; &lt;/a&gt; 호출 하십시오 . 코드는 실제 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; 를&lt;/a&gt; 확인하지 않으며 적절한 인터페이스를 가진 클래스가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="964c4c7deeb02bca66bce575984f247809b17ee8" translate="yes" xml:space="preserve">
          <source>Install debug hooks on memory allocators to check for:</source>
          <target state="translated">Install debug hooks on memory allocators to check for:</target>
        </trans-unit>
        <trans-unit id="37e330f724f7fcf65d8b68bd41b82aaa46b9f715" translate="yes" xml:space="preserve">
          <source>Install the control-c handler. When a &lt;a href=&quot;signal#signal.SIGINT&quot;&gt;&lt;code&gt;signal.SIGINT&lt;/code&gt;&lt;/a&gt; is received (usually in response to the user pressing control-c) all registered results have &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; called.</source>
          <target state="translated">Install the control-c handler. When a &lt;a href=&quot;signal#signal.SIGINT&quot;&gt; &lt;code&gt;signal.SIGINT&lt;/code&gt; &lt;/a&gt; is received (usually in response to the user pressing control-c) all registered results have &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; called.</target>
        </trans-unit>
        <trans-unit id="455b086ac3298a91870a87090996554bb11b3083" translate="yes" xml:space="preserve">
          <source>Install the control-c handler. When a &lt;code&gt;signal.SIGINT&lt;/code&gt; is received (usually in response to the user pressing control-c) all registered results have &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; called.</source>
          <target state="translated">control-c 핸들러를 설치하십시오. &lt;code&gt;signal.SIGINT&lt;/code&gt; 가 수신 되면 (보통 control-c를 누르는 사용자에 대한 응답으로) 등록 된 모든 결과에는 &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9844ff0d9d22475c61112c01b5f0c916b24483" translate="yes" xml:space="preserve">
          <source>Installation paths</source>
          <target state="translated">설치 경로</target>
        </trans-unit>
        <trans-unit id="e23f8bdbda721b9cbed1f844f7307a95d9b58116" translate="yes" xml:space="preserve">
          <source>Installing Python Modules</source>
          <target state="translated">파이썬 모듈 설치</target>
        </trans-unit>
        <trans-unit id="a5aa044edf2a4b23b0600882b63f3573a49708ee" translate="yes" xml:space="preserve">
          <source>Installing Python Modules (Legacy version)</source>
          <target state="translated">Python 모듈 설치 (레거시 버전)</target>
        </trans-unit>
        <trans-unit id="71e27cbe55c7ee739cd8deca3e2c0f21cd96ea3e" translate="yes" xml:space="preserve">
          <source>Installing your CGI script on a Unix system</source>
          <target state="translated">유닉스 시스템에 CGI 스크립트 설치</target>
        </trans-unit>
        <trans-unit id="c1d91ffedb22549df648586a28db755e96527174" translate="yes" xml:space="preserve">
          <source>Installs activation scripts appropriate to the platform into the virtual environment.</source>
          <target state="translated">플랫폼에 적합한 활성화 스크립트를 가상 환경에 설치합니다.</target>
        </trans-unit>
        <trans-unit id="02d9da332f931b3a6a11cc4f1b01fd46bbfd85c7" translate="yes" xml:space="preserve">
          <source>Instance attributes (read-only):</source>
          <target state="translated">인스턴스 속성 (읽기 전용) :</target>
        </trans-unit>
        <trans-unit id="cef505a4b9b67a0b31ca83b3b269c5533fa33c8d" translate="yes" xml:space="preserve">
          <source>Instance method</source>
          <target state="translated">인스턴스 방법</target>
        </trans-unit>
        <trans-unit id="7a3c19110538625e1e983c1581301c5d59f09ead" translate="yes" xml:space="preserve">
          <source>Instance methods:</source>
          <target state="translated">인스턴스 메소드 :</target>
        </trans-unit>
        <trans-unit id="f5e5a85bed7028b78978acbd1aaddcd815f1c067" translate="yes" xml:space="preserve">
          <source>Instance of the &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; class intended to be shared. If no customization of the &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; is needed, this instance can be used instead of repeatedly creating new instances.</source>
          <target state="translated">공유하려는 &lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스입니다 . &lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; 를&lt;/a&gt; 사용자 정의 할 필요가 없는 경우 새 인스턴스를 반복해서 작성하는 대신이 인스턴스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66006b01de7b00fd125d534c85307c7025d31754" translate="yes" xml:space="preserve">
          <source>Instances are a context manager that raises &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt;&lt;code&gt;ResourceDenied&lt;/code&gt;&lt;/a&gt; if the specified exception type is raised. Any keyword arguments are treated as attribute/value pairs to be compared against any exception raised within the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. Only if all pairs match properly against attributes on the exception is &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt;&lt;code&gt;ResourceDenied&lt;/code&gt;&lt;/a&gt; raised.</source>
          <target state="translated">인스턴스는 지정된 예외 유형이 발생 하면 &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt; &lt;code&gt;ResourceDenied&lt;/code&gt; 를&lt;/a&gt; 발생 시키는 컨텍스트 관리자입니다 . 키워드 인수는 속성 / 값 쌍으로 처리되어 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 발생한 예외와 비교 됩니다. 모든 쌍이 예외의 속성과 올바르게 일치하는 경우에만 &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt; &lt;code&gt;ResourceDenied&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b2ca9758b0f12ce392282b3b02b3fb6078d315a" translate="yes" xml:space="preserve">
          <source>Instances are a context manager that raises &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt;&lt;code&gt;ResourceDenied&lt;/code&gt;&lt;/a&gt; if the specified exception type is raised. Any keyword arguments are treated as attribute/value pairs to be compared against any exception raised within the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. Only if all pairs match properly against attributes on the exception is &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt;&lt;code&gt;ResourceDenied&lt;/code&gt;&lt;/a&gt; raised.</source>
          <target state="translated">Instances are a context manager that raises &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt; &lt;code&gt;ResourceDenied&lt;/code&gt; &lt;/a&gt; if the specified exception type is raised. Any keyword arguments are treated as attribute/value pairs to be compared against any exception raised within the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; statement. Only if all pairs match properly against attributes on the exception is &lt;a href=&quot;#test.support.ResourceDenied&quot;&gt; &lt;code&gt;ResourceDenied&lt;/code&gt; &lt;/a&gt; raised.</target>
        </trans-unit>
        <trans-unit id="7c702b9ba47b1a29abe7f9b14424131410786fc9" translate="yes" xml:space="preserve">
          <source>Instances are created in the usual way, by calling the class:</source>
          <target state="translated">인스턴스는 클래스를 호출하여 일반적인 방식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e36624384482780c99f8cf1e80e08d4dbffcccda" translate="yes" xml:space="preserve">
          <source>Instances are replaced with an appropriate value for Enum members.</source>
          <target state="translated">인스턴스는 Enum 멤버에 적절한 값으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="678f569c8a49c3e89e6407c01796479ffad36db3" translate="yes" xml:space="preserve">
          <source>Instances are replaced with an appropriate value for Enum members. By default, the initial value starts at 1.</source>
          <target state="translated">Instances are replaced with an appropriate value for Enum members. By default, the initial value starts at 1.</target>
        </trans-unit>
        <trans-unit id="977046f0ab67d4d0e4e35706464d8171ca16252f" translate="yes" xml:space="preserve">
          <source>Instances have a single attribute:</source>
          <target state="translated">인스턴스에는 단일 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4676b1bcc4624e7da45d7a5ff8eacd0bf3c33c" translate="yes" xml:space="preserve">
          <source>Instances have one method in addition to those of &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">인스턴스에는 &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; &lt;/a&gt; 객체 에 추가하여 한 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9356878128c51826b54b444b3b3d1f7304b466d9" translate="yes" xml:space="preserve">
          <source>Instances have the following methods and attributes:</source>
          <target state="translated">인스턴스에는 다음과 같은 메서드와 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4836c2b7b89edcfc83e32a7e01ec4c9ebbb5e79a" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; subclasses have some public instance variables:</source>
          <target state="translated">&lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 서브 클래스의 인스턴스 에는 몇 가지 공용 인스턴스 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fbdb8f7a773261c049a9a5c3586d5acb9eee33" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt;&lt;code&gt;FileCookieJar&lt;/code&gt;&lt;/a&gt; raise this exception on failure to load cookies from a file. &lt;a href=&quot;#http.cookiejar.LoadError&quot;&gt;&lt;code&gt;LoadError&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.FileCookieJar&quot;&gt; &lt;code&gt;FileCookieJar&lt;/code&gt; &lt;/a&gt; 인스턴스는 파일에서 쿠키를로드하지 못하면이 예외를 발생시킵니다. &lt;a href=&quot;#http.cookiejar.LoadError&quot;&gt; &lt;code&gt;LoadError&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0c3af14ce90e18c0cd86060643d0a376c7566d62" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#netrc.netrc&quot;&gt;&lt;code&gt;netrc&lt;/code&gt;&lt;/a&gt; have public instance variables:</source>
          <target state="translated">&lt;a href=&quot;#netrc.netrc&quot;&gt; &lt;code&gt;netrc&lt;/code&gt; &lt;/a&gt; 인스턴스 에는 공개 인스턴스 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e3aee8ff0d6c01108a6a06292032304f1239fb" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#poplib.POP3_SSL&quot;&gt;&lt;code&gt;POP3_SSL&lt;/code&gt;&lt;/a&gt; have no additional methods. The interface of this subclass is identical to its parent.</source>
          <target state="translated">&lt;a href=&quot;#poplib.POP3_SSL&quot;&gt; &lt;code&gt;POP3_SSL&lt;/code&gt; &lt;/a&gt; 인스턴스 에는 추가 방법이 없습니다. 이 서브 클래스의 인터페이스는 부모와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6a270da5a938701cf4bfb5b00e63f7b889296e57" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; provide the following operations:</source>
          <target state="translated">&lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="99ef98d14b1f3f5f16c5b4358f8ece80d4b0bb22" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; are compared to instances of &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; based on their members. For example, &lt;code&gt;set('abc') == frozenset('abc')&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt; and so does &lt;code&gt;set('abc') in set([frozenset('abc')])&lt;/code&gt;.</source>
          <target state="translated">의 인스턴스 &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 의 경우에 비교 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 자신의 회원을 기반으로. 예를 들어 &lt;code&gt;set('abc') == frozenset('abc')&lt;/code&gt; 는 &lt;code&gt;True&lt;/code&gt; 를 반환 하므로 &lt;code&gt;set('abc') in set([frozenset('abc')])&lt;/code&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="5bad8405386be273c519f37d5de7d1af43fd2371" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; subclasses have some public instance variables which either control lexical analysis or can be used for debugging:</source>
          <target state="translated">&lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 서브 클래스의 인스턴스에는 어휘 분석을 제어하거나 디버깅에 사용할 수있는 공용 인스턴스 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a114067119bf39dea4018ea438842b0e1df5bc4" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; must be created using the &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6232c7c11311e2dbaabeb35f7f01aef1268d5f26" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#statistics.NormalDist&quot;&gt;&lt;code&gt;NormalDist&lt;/code&gt;&lt;/a&gt; support addition, subtraction, multiplication and division by a constant. These operations are used for translation and scaling. For example:</source>
          <target state="translated">&lt;a href=&quot;#statistics.NormalDist&quot;&gt; &lt;code&gt;NormalDist&lt;/code&gt; &lt;/a&gt; 인스턴스는 덧셈, 뺄셈, 곱셈 및 나누기를 상수로 지원합니다. 이러한 작업은 변환 및 확장에 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4fca6b7030888ac58e9781d764d833f2fa42ad1" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#xml.sax.xmlreader.IncrementalParser&quot;&gt;&lt;code&gt;IncrementalParser&lt;/code&gt;&lt;/a&gt; offer the following additional methods:</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.IncrementalParser&quot;&gt; &lt;code&gt;IncrementalParser&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음과 같은 추가 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c9c13ace643e3c6e869ce828dec5a9ec44914c1b" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;#xml.sax.xmlreader.Locator&quot;&gt;&lt;code&gt;Locator&lt;/code&gt;&lt;/a&gt; provide these methods:</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.Locator&quot;&gt; &lt;code&gt;Locator&lt;/code&gt; &lt;/a&gt; 인스턴스는 다음 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="804f8454e9538af6b77807d86e343f3fb23e2b60" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;ast.expr&lt;/code&gt; and &lt;code&gt;ast.stmt&lt;/code&gt; subclasses have &lt;a href=&quot;#ast.AST.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ast.AST.col_offset&quot;&gt;&lt;code&gt;col_offset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ast.AST.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ast.AST.col_offset&quot;&gt;&lt;code&gt;col_offset&lt;/code&gt;&lt;/a&gt; attributes. The &lt;a href=&quot;#ast.AST.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ast.AST.end_lineno&quot;&gt;&lt;code&gt;end_lineno&lt;/code&gt;&lt;/a&gt; are the first and last line numbers of source text span (1-indexed so the first line is line 1) and the &lt;a href=&quot;#ast.AST.col_offset&quot;&gt;&lt;code&gt;col_offset&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ast.AST.end_col_offset&quot;&gt;&lt;code&gt;end_col_offset&lt;/code&gt;&lt;/a&gt; are the corresponding UTF-8 byte offsets of the first and last tokens that generated the node. The UTF-8 offset is recorded because the parser uses UTF-8 internally.</source>
          <target state="translated">&lt;code&gt;ast.expr&lt;/code&gt; 및 &lt;code&gt;ast.stmt&lt;/code&gt; 서브 클래스의 인스턴스 에는 &lt;a href=&quot;#ast.AST.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ast.AST.col_offset&quot;&gt; &lt;code&gt;col_offset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ast.AST.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ast.AST.col_offset&quot;&gt; &lt;code&gt;col_offset&lt;/code&gt; &lt;/a&gt; 속성이 있습니다. &lt;a href=&quot;#ast.AST.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ast.AST.end_lineno&quot;&gt; &lt;code&gt;end_lineno&lt;/code&gt; 는&lt;/a&gt; 원본 텍스트 범위 (첫 번째 행은 행 1 정도로 1 인덱스)과의 처음과 마지막 라인 숫자 &lt;a href=&quot;#ast.AST.col_offset&quot;&gt; &lt;code&gt;col_offset&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ast.AST.end_col_offset&quot;&gt; &lt;code&gt;end_col_offset&lt;/code&gt; &lt;/a&gt; 상기 노드를 생성하는 첫 번째 및 마지막 토큰 UTF-8 바이트 오프셋을 대응되는 . 파서는 UTF-8을 내부적으로 사용하기 때문에 UTF-8 오프셋이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="5d95f68c80ce0e510ee590b3846279063b4a2aa5" translate="yes" xml:space="preserve">
          <source>Instances of Action (or return value of any callable to the &lt;code&gt;action&lt;/code&gt; parameter) should have attributes &amp;ldquo;dest&amp;rdquo;, &amp;ldquo;option_strings&amp;rdquo;, &amp;ldquo;default&amp;rdquo;, &amp;ldquo;type&amp;rdquo;, &amp;ldquo;required&amp;rdquo;, &amp;ldquo;help&amp;rdquo;, etc. defined. The easiest way to ensure these attributes are defined is to call &lt;code&gt;Action.__init__&lt;/code&gt;.</source>
          <target state="translated">작업 인스턴스 (또는 &lt;code&gt;action&lt;/code&gt; 매개 변수 에 대한 호출 가능한 값 반환 )에는 &quot;dest&quot;, &quot;option_strings&quot;, &quot;default&quot;, &quot;type&quot;, &quot;required&quot;, &quot;help&quot;등의 속성이 정의되어 있어야합니다. 이러한 속성을 정의하는 가장 쉬운 방법은 &lt;code&gt;Action.__init__&lt;/code&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8d188b0cbbecd67a4203389ad78cd336997dc157" translate="yes" xml:space="preserve">
          <source>Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt; (in general, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; are sufficient, if you want the conventional meanings of the comparison operators).</source>
          <target state="translated">방법의 충분한 클래스가 정의하지 않는 한 클래스의 인스턴스는, 같은 클래스의 다른 인스턴스 또는 개체의 다른 유형에 대한 주문 할 수없는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; (일반적으로 , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 이면 충분합니다 (비교 연산자의 일반적인 의미를 원한다면).</target>
        </trans-unit>
        <trans-unit id="0ae71dda80f08a0ad9d6529fa485e3bf580f7096" translate="yes" xml:space="preserve">
          <source>Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt; (in general, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; are sufficient, if you want the conventional meanings of the comparison operators).</source>
          <target state="translated">Instances of a class cannot be ordered with respect to other instances of the same class, or other types of object, unless the class defines enough of the methods &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; (in general, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; are sufficient, if you want the conventional meanings of the comparison operators).</target>
        </trans-unit>
        <trans-unit id="6b5dcf1058b351c38261d04ca320dda4b3f25f2d" translate="yes" xml:space="preserve">
          <source>Instances of class &lt;code&gt;_Feature&lt;/code&gt; have two corresponding methods, &lt;code&gt;getOptionalRelease()&lt;/code&gt; and &lt;code&gt;getMandatoryRelease()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_Feature&lt;/code&gt; 클래스의 인스턴스에는 &lt;code&gt;getOptionalRelease()&lt;/code&gt; 및 &lt;code&gt;getMandatoryRelease()&lt;/code&gt; 두 가지 해당 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6c634a0edffb9d61a7365311bea34ffe79ec57" translate="yes" xml:space="preserve">
          <source>Instances of foreign functions are also C compatible data types; they represent C function pointers.</source>
          <target state="translated">외부 함수의 인스턴스도 C 호환 데이터 유형입니다. 그것들은 C 함수 포인터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a8afbcc19adfe2bbe9b22c2815e4299724822e37" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; class have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9546d42fe8710c49b46e747a53a869881a8867" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; class represent the logical test units in the &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; universe. This class is intended to be used as a base class, with specific tests being implemented by concrete subclasses. This class implements the interface needed by the test runner to allow it to drive the tests, and methods that the test code can use to check for and report various kinds of failure.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스는 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 유니버스 의 논리적 테스트 단위를 나타냅니다 . 이 클래스는 구체적인 서브 클래스에 의해 구현되는 특정 테스트와 함께 기본 클래스로 사용됩니다. 이 클래스는 테스트 실행에 필요한 인터페이스를 구현하여 테스트를 수행하고 테스트 코드가 다양한 종류의 오류를 확인하고보고하는 데 사용할 수있는 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c68784d7b74127503c1abd5f3c46123eaca45a23" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; class are returned by the &lt;a href=&quot;#zipfile.ZipFile.getinfo&quot;&gt;&lt;code&gt;getinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#zipfile.ZipFile.infolist&quot;&gt;&lt;code&gt;infolist()&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; objects. Each object stores information about a single member of the ZIP archive.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스는 &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; &lt;/a&gt; 객체 의 &lt;a href=&quot;#zipfile.ZipFile.getinfo&quot;&gt; &lt;code&gt;getinfo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#zipfile.ZipFile.infolist&quot;&gt; &lt;code&gt;infolist()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 반환됩니다 . 각 오브젝트는 ZIP 아카이브의 단일 멤버에 대한 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="7bcb1ef59d54b0ecd47451fa339ebb50def36131" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;DatagramTransport&lt;/em&gt; class are returned from the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_datagram_endpoint&quot;&gt;&lt;code&gt;loop.create_datagram_endpoint()&lt;/code&gt;&lt;/a&gt; event loop method.</source>
          <target state="translated">&lt;em&gt;DatagramTransport&lt;/em&gt; 클래스의 인스턴스는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_datagram_endpoint&quot;&gt; &lt;code&gt;loop.create_datagram_endpoint()&lt;/code&gt; &lt;/a&gt; 이벤트 루프 메서드 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="586088455e5044d9a461dfedd040a8e305fa706e" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;ReadTransport&lt;/em&gt; class are returned from the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt;&lt;code&gt;loop.connect_read_pipe()&lt;/code&gt;&lt;/a&gt; event loop method and are also used by subprocess-related methods like &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 인스턴스 &lt;em&gt;ReadTransport의&lt;/em&gt; 클래스에서 반환 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_read_pipe&quot;&gt; &lt;code&gt;loop.connect_read_pipe()&lt;/code&gt; &lt;/a&gt; 이벤트 루프 방법과도 같은 구성 프로세스 관련 메소드에 의해 사용된다 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c1f936b1157bd672393e5f1fcb46b2dc8e3cf90" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;SubprocessTransport&lt;/em&gt; class are returned from event loop methods &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_shell&quot;&gt;&lt;code&gt;loop.subprocess_shell()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;SubprocessTransport&lt;/em&gt; 클래스의 인스턴스는 이벤트 루프 메서드 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_shell&quot;&gt; &lt;code&gt;loop.subprocess_shell()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 에서 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="67256cc8f2e8e404f6172497df055c8737b58bdb" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;Transport&lt;/em&gt; class are returned from or used by event loop methods like &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_connection&quot;&gt;&lt;code&gt;loop.create_unix_connection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.loop.sendfile&quot;&gt;&lt;code&gt;loop.sendfile()&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">&lt;em&gt;Transport&lt;/em&gt; 클래스의 인스턴스는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_unix_connection&quot;&gt; &lt;code&gt;loop.create_unix_connection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.loop.sendfile&quot;&gt; &lt;code&gt;loop.sendfile()&lt;/code&gt; &lt;/a&gt; 등과 같은 이벤트 루프 메소드에서 리턴되거나 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5fb2b433087bffe30f4818f8930283b1d33a135" translate="yes" xml:space="preserve">
          <source>Instances of the &lt;em&gt;WriteTransport&lt;/em&gt; class are returned from the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;loop.connect_write_pipe()&lt;/code&gt;&lt;/a&gt; event loop method and are also used by subprocess-related methods like &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 인스턴스 &lt;em&gt;WriteTransport의&lt;/em&gt; 클래스에서 반환 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;loop.connect_write_pipe()&lt;/code&gt; &lt;/a&gt; 이벤트 루프 방법과도 같은 구성 프로세스 관련 메소드에 의해 사용된다 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cbaede1df11dc6a6a6c405d9432098c3bd45c5c" translate="yes" xml:space="preserve">
          <source>Instances of these classes have no public methods. Functions exported by the shared library can be accessed as attributes or by index. Please note that accessing the function through an attribute caches the result and therefore accessing it repeatedly returns the same object each time. On the other hand, accessing it through an index returns a new object each time:</source>
          <target state="translated">이 클래스의 인스턴스에는 공개 메소드가 없습니다. 공유 라이브러리에서 내 보낸 함수는 속성 또는 인덱스로 액세스 할 수 있습니다. 속성을 통해 함수에 액세스하면 결과가 캐시되므로 반복적으로 액세스하면 매번 같은 객체가 반복적으로 반환됩니다. 반면에 인덱스를 통해 액세스하면 매번 새 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1a4d2d21f791021b6819e5841a2fccc5056ea44a" translate="yes" xml:space="preserve">
          <source>Instances of this class behave like &lt;a href=&quot;#ctypes.CDLL&quot;&gt;&lt;code&gt;CDLL&lt;/code&gt;&lt;/a&gt; instances, except that the Python GIL is &lt;em&gt;not&lt;/em&gt; released during the function call, and after the function execution the Python error flag is checked. If the error flag is set, a Python exception is raised.</source>
          <target state="translated">이 클래스의 인스턴스 는 함수 호출 중에 Python GIL이 해제 &lt;em&gt;되지 않고&lt;/em&gt; 함수 실행 후 Python 오류 플래그가 확인 된다는 점을 제외하고 &lt;a href=&quot;#ctypes.CDLL&quot;&gt; &lt;code&gt;CDLL&lt;/code&gt; &lt;/a&gt; 인스턴스 처럼 작동합니다 . 오류 플래그가 설정되면 Python 예외가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0b4eb84d866c4aa98cf000e08ff3a6c3d081018" translate="yes" xml:space="preserve">
          <source>Instances of this class can be used as both a context manager:</source>
          <target state="translated">이 클래스의 인스턴스는 컨텍스트 관리자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f609df77c7087014c66efc5131badef500e89bea" translate="yes" xml:space="preserve">
          <source>Instances of this class have &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt;&lt;code&gt;__call__()&lt;/code&gt;&lt;/a&gt; methods identical in signature to &lt;a href=&quot;#codeop.compile_command&quot;&gt;&lt;code&gt;compile_command()&lt;/code&gt;&lt;/a&gt;; the difference is that if the instance compiles program text containing a &lt;code&gt;__future__&lt;/code&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</source>
          <target state="translated">이 클래스의 인스턴스는 서명에서 &lt;a href=&quot;#codeop.compile_command&quot;&gt; &lt;code&gt;compile_command()&lt;/code&gt; &lt;/a&gt; 와 동일한 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt; &lt;code&gt;__call__()&lt;/code&gt; &lt;/a&gt; 메소드를 갖습니다 . 차이점은 인스턴스가 &lt;code&gt;__future__&lt;/code&gt; 문이 포함 된 프로그램 텍스트를 컴파일하는 경우 해당 인스턴스 는 실행중인 명령문을 사용하여 모든 후속 프로그램 텍스트를 '기억'하고 컴파일한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="925a0c7a76a57e11d3f263578f0021165d4947c0" translate="yes" xml:space="preserve">
          <source>Instances of this class have &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt;&lt;code&gt;__call__()&lt;/code&gt;&lt;/a&gt; methods identical in signature to the built-in function &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, but with the difference that if the instance compiles program text containing a &lt;a href=&quot;__future__#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</source>
          <target state="translated">이 클래스의 인스턴스는 내장 함수 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 과 동일한 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__call__&quot;&gt; &lt;code&gt;__call__()&lt;/code&gt; &lt;/a&gt; 메소드를 갖지만 인스턴스가 &lt;a href=&quot;__future__#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; 문을 포함하는 프로그램 텍스트를 컴파일 할 경우 인스턴스는 '기억'되고 다음 프로그램을 사용하여 모든 후속 프로그램 텍스트를 컴파일합니다. 성명서.</target>
        </trans-unit>
        <trans-unit id="c02f8932c379c69e1ca59cd35ffe68b14cc70934" translate="yes" xml:space="preserve">
          <source>Instances of this class have &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__call__&quot;&gt;&lt;code&gt;__call__()&lt;/code&gt;&lt;/a&gt; methods identical in signature to &lt;a href=&quot;#codeop.compile_command&quot;&gt;&lt;code&gt;compile_command()&lt;/code&gt;&lt;/a&gt;; the difference is that if the instance compiles program text containing a &lt;code&gt;__future__&lt;/code&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</source>
          <target state="translated">Instances of this class have &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__call__&quot;&gt; &lt;code&gt;__call__()&lt;/code&gt; &lt;/a&gt; methods identical in signature to &lt;a href=&quot;#codeop.compile_command&quot;&gt; &lt;code&gt;compile_command()&lt;/code&gt; &lt;/a&gt;; the difference is that if the instance compiles program text containing a &lt;code&gt;__future__&lt;/code&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</target>
        </trans-unit>
        <trans-unit id="ddd73e7c79938ba23bc1108f706bd345af9af765" translate="yes" xml:space="preserve">
          <source>Instances of this class have &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__call__&quot;&gt;&lt;code&gt;__call__()&lt;/code&gt;&lt;/a&gt; methods identical in signature to the built-in function &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, but with the difference that if the instance compiles program text containing a &lt;a href=&quot;__future__#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</source>
          <target state="translated">Instances of this class have &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__call__&quot;&gt; &lt;code&gt;__call__()&lt;/code&gt; &lt;/a&gt; methods identical in signature to the built-in function &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt;, but with the difference that if the instance compiles program text containing a &lt;a href=&quot;__future__#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; statement, the instance &amp;lsquo;remembers&amp;rsquo; and compiles all subsequent program texts with the statement in force.</target>
        </trans-unit>
        <trans-unit id="3cea02a40f1382d313c478a7d347bf77afc22680" translate="yes" xml:space="preserve">
          <source>Instances of this class have attributes &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;lineno&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;text&lt;/code&gt; for easier access to the details. &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; of the exception instance returns only the message.</source>
          <target state="translated">이 클래스의 인스턴스 에는 세부 정보에 쉽게 액세스 할 수 있도록 &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;lineno&lt;/code&gt; , &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;text&lt;/code&gt; 속성이 있습니다 . 예외 인스턴스의 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 은 메시지 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9552998fad2e04265127b613f40d80668c89fe3" translate="yes" xml:space="preserve">
          <source>Instances of this class represent loaded shared libraries. Functions in these libraries use the standard C calling convention, and are assumed to return &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타냅니다. 이 라이브러리의 함수는 표준 C 호출 규칙을 사용하며 &lt;code&gt;int&lt;/code&gt; 를 리턴하는 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1092250393de1231514a87858fe06d28af28725a" translate="yes" xml:space="preserve">
          <source>Instant User&amp;rsquo;s Manual</source>
          <target state="translated">인스턴트 사용자 설명서</target>
        </trans-unit>
        <trans-unit id="574cb265821ad17477fe1f76be69bb3a65511224" translate="yes" xml:space="preserve">
          <source>Instantiate a socket from data obtained from the &lt;a href=&quot;#socket.socket.share&quot;&gt;&lt;code&gt;socket.share()&lt;/code&gt;&lt;/a&gt; method. The socket is assumed to be in blocking mode.</source>
          <target state="translated">&lt;a href=&quot;#socket.socket.share&quot;&gt; &lt;code&gt;socket.share()&lt;/code&gt; &lt;/a&gt; 메소드 에서 얻은 데이터에서 소켓을 인스턴스화하십시오 . 소켓은 차단 모드에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6cc2c38c57dd41a65fc68bb18ba93a896f33546b" translate="yes" xml:space="preserve">
          <source>Instantiate the bytes object &lt;em&gt;str&lt;/em&gt; with the supplied parameters, where &lt;em&gt;str&lt;/em&gt; should be a parameterized string obtained from the terminfo database. E.g. &lt;code&gt;tparm(tigetstr(&quot;cup&quot;), 5, 3)&lt;/code&gt; could result in &lt;code&gt;b'\033[6;4H'&lt;/code&gt;, the exact result depending on terminal type.</source>
          <target state="translated">제공된 매개 변수를 사용 하여 바이트 오브젝트 &lt;em&gt;str&lt;/em&gt; 을 인스턴스화하십시오 . 여기서 &lt;em&gt;str&lt;/em&gt; 은 terminfo 데이터베이스에서 얻은 매개 변수화 된 문자열이어야합니다. 예를 들어 &lt;code&gt;tparm(tigetstr(&quot;cup&quot;), 5, 3)&lt;/code&gt; 은 터미널 유형에 따라 정확한 결과 인 &lt;code&gt;b'\033[6;4H'&lt;/code&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be1f69e0247ba6c30dc81d6522ec5b9dfbbb54e4" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;autospec=True&lt;/code&gt; you can pass &lt;code&gt;autospec=some_object&lt;/code&gt; to use an arbitrary object as the spec instead of the one being replaced.</source>
          <target state="translated">&lt;code&gt;autospec=some_object&lt;/code&gt; &lt;code&gt;autospec=True&lt;/code&gt; 대신 autospec = some_object 를 전달 하여 대체되는 스펙 대신 임의의 오브젝트를 스펙으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5c2e9f6e6835a11ba9448dc7766ab78368e93af" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;parser.readfp(fp)&lt;/code&gt; use &lt;code&gt;parser.read_file(readline_generator(fp))&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;parser.readfp(fp)&lt;/code&gt; 를 사용 &lt;code&gt;parser.read_file(readline_generator(fp))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3335f1cb058452ae970d6a5f6d030ab421d2b7a5" translate="yes" xml:space="preserve">
          <source>Instead of passing &lt;code&gt;True&lt;/code&gt; as the value for the punctuation_chars parameter, you can pass a string with specific characters, which will be used to determine which characters constitute punctuation. For example:</source>
          <target state="translated">punctuation_chars 매개 변수의 값으로 &lt;code&gt;True&lt;/code&gt; 를 전달하는 대신 특정 문자가 포함 된 문자열을 전달하면 문장 부호를 구성하는 문자를 결정하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfe94486b315d1f59be6456fc99c6885002b55bd" translate="yes" xml:space="preserve">
          <source>Instead of printing the output at the end of the profile run, you can save the results to a file by specifying a filename to the &lt;code&gt;run()&lt;/code&gt; function:</source>
          <target state="translated">프로파일 실행이 끝날 때 출력을 인쇄하는 대신 &lt;code&gt;run()&lt;/code&gt; 함수에 파일 이름을 지정하여 결과를 파일에 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6962965673ba6e30d7da60e2b13234969e6aa223" translate="yes" xml:space="preserve">
          <source>Instead of reading the profile data from a file, a &lt;code&gt;cProfile.Profile&lt;/code&gt; or &lt;a href=&quot;#profile.Profile&quot;&gt;&lt;code&gt;profile.Profile&lt;/code&gt;&lt;/a&gt; object can be used as the profile data source.</source>
          <target state="translated">파일에서 프로파일 데이터를 읽는 대신 &lt;code&gt;cProfile.Profile&lt;/code&gt; 또는 &lt;a href=&quot;#profile.Profile&quot;&gt; &lt;code&gt;profile.Profile&lt;/code&gt; &lt;/a&gt; 오브젝트를 프로파일 데이터 소스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ab3ecc1e0fcedf8c861d9c035dc31010b7ed532" translate="yes" xml:space="preserve">
          <source>Instead of waiting, or after a box is closed, open a completion box immediately with Show Completions on the Edit menu. The default hot key is</source>
          <target state="translated">Instead of waiting, or after a box is closed, open a completion box immediately with Show Completions on the Edit menu. The default hot key is</target>
        </trans-unit>
        <trans-unit id="84f3292cd4df9827802ae460d7bf0d817b1c06d4" translate="yes" xml:space="preserve">
          <source>Instead one should protect the &amp;ldquo;entry point&amp;rdquo; of the program by using &lt;code&gt;if
__name__ == '__main__':&lt;/code&gt; as follows:</source>
          <target state="translated">대신 다음과 같이 &lt;code&gt;if __name__ == '__main__':&lt;/code&gt; 을 사용하여 프로그램의&amp;ldquo;입력 지점&amp;rdquo;을 보호해야 합니다.</target>
        </trans-unit>
        <trans-unit id="96d5f6e166357195ec9d7a25ec7a7cc3761d5193" translate="yes" xml:space="preserve">
          <source>Instead, it is better to search a list of precomputed keys to find the index of the record in question:</source>
          <target state="translated">대신 미리 계산 된 키 목록을 검색하여 해당 레코드의 색인을 찾는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0c218a2e12a68573c0a6efe87b144bd67b29216" translate="yes" xml:space="preserve">
          <source>Instead, use the DB-API&amp;rsquo;s parameter substitution. Put &lt;code&gt;?&lt;/code&gt; as a placeholder wherever you want to use a value, and then provide a tuple of values as the second argument to the cursor&amp;rsquo;s &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt;&lt;code&gt;execute()&lt;/code&gt;&lt;/a&gt; method. (Other database modules may use a different placeholder, such as &lt;code&gt;%s&lt;/code&gt; or &lt;code&gt;:1&lt;/code&gt;.) For example:</source>
          <target state="translated">대신 DB-API의 매개 변수 대체를 사용하십시오. 넣어 &lt;code&gt;?&lt;/code&gt; 값을 사용하려는 위치마다 자리 표시 자로 사용하고 커서의 &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt; &lt;code&gt;execute()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 두 번째 인수로 값의 튜플을 제공하십시오 . (다른 데이터베이스 모듈은 &lt;code&gt;%s&lt;/code&gt; 또는 &lt;code&gt;:1&lt;/code&gt; 과 같은 다른 자리 표시자를 사용할 수 있습니다 .) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c639969c05d984ea055d9d4f757063936b210288" translate="yes" xml:space="preserve">
          <source>Instructions for non-Unix systems will vary; check your HTTP server&amp;rsquo;s documentation (it will usually have a section on CGI scripts).</source>
          <target state="translated">비 유닉스 시스템에 대한 지침은 다양합니다. HTTP 서버 설명서를 확인하십시오 (일반적으로 CGI 스크립트에 대한 섹션이 있음).</target>
        </trans-unit>
        <trans-unit id="1442021d1e6e277098afc29be0d45b6f7adc68dc" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.reader&quot;&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/a&gt; to perform no special processing of quote characters.</source>
          <target state="translated">에 지시 &lt;a href=&quot;#csv.reader&quot;&gt; &lt;code&gt;reader&lt;/code&gt; &lt;/a&gt; 인용 문자의 특별한 처리를 수행 없습니다.</target>
        </trans-unit>
        <trans-unit id="047e505fbfb736e9c1925bb8f8dfaa7c490f8277" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to never quote fields. When the current &lt;em&gt;delimiter&lt;/em&gt; occurs in output data it is preceded by the current &lt;em&gt;escapechar&lt;/em&gt; character. If &lt;em&gt;escapechar&lt;/em&gt; is not set, the writer will raise &lt;a href=&quot;#csv.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; if any characters that require escaping are encountered.</source>
          <target state="translated">&lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 객체가 필드를 인용하지 않도록 지시 합니다. 출력 데이터에서 현재 &lt;em&gt;분리 문자&lt;/em&gt; 가 발생하면 현재 &lt;em&gt;이스케이프&lt;/em&gt; 문자 가 앞에옵니다 . 경우 &lt;em&gt;escapechar가&lt;/em&gt; 설정되어 있지 않은, 작가는 올릴 것이다 &lt;a href=&quot;#csv.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 탈출이 필요한 모든 문자가 발생하는 경우.</target>
        </trans-unit>
        <trans-unit id="1b10705ce857dbeced06f0e80b06d1258b1c3559" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to only quote those fields which contain special characters such as &lt;em&gt;delimiter&lt;/em&gt;, &lt;em&gt;quotechar&lt;/em&gt; or any of the characters in &lt;em&gt;lineterminator&lt;/em&gt;.</source>
          <target state="translated">에 지시 &lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 단지 같은 특수 문자를 포함하는 필드를 인용 객체를 &lt;em&gt;구분&lt;/em&gt; , &lt;em&gt;quotechar&lt;/em&gt; 또는 문자의 &lt;em&gt;lineterminator을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a28899561f1860e0cebbdf8e6feef81d417287ee" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to quote all fields.</source>
          <target state="translated">&lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 객체가 모든 필드를 인용하도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="0e13df308f51e63d2ca55d3485fd8b7d669b80d7" translate="yes" xml:space="preserve">
          <source>Instructs &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects to quote all non-numeric fields.</source>
          <target state="translated">숫자가 아닌 모든 필드를 인용하도록 &lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 객체에 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="68a9f1416c044b9eb3ae50c77e7087fc5bdcfec6" translate="yes" xml:space="preserve">
          <source>Instructs the reader to convert all non-quoted fields to type &lt;em&gt;float&lt;/em&gt;.</source>
          <target state="translated">인용되지 않은 모든 필드를 &lt;em&gt;float&lt;/em&gt; 유형으로 변환하도록 리더에 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="9f9ac0fbc7f32aa66d8b0df0a6752da89865807f" translate="yes" xml:space="preserve">
          <source>IntEnum</source>
          <target state="translated">IntEnum</target>
        </trans-unit>
        <trans-unit id="a7dcebc39b9a6200e72e040ddb4b56fbab680190" translate="yes" xml:space="preserve">
          <source>IntFlag</source>
          <target state="translated">IntFlag</target>
        </trans-unit>
        <trans-unit id="32597b26633647b2d319add4525291d5919eb5f2" translate="yes" xml:space="preserve">
          <source>Integer expiry date in seconds since epoch, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. See also the &lt;a href=&quot;#http.cookiejar.Cookie.is_expired&quot;&gt;&lt;code&gt;is_expired()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">시대, 또는 이후 초 정수 유효 기간 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#http.cookiejar.Cookie.is_expired&quot;&gt; &lt;code&gt;is_expired()&lt;/code&gt; &lt;/a&gt; 메소드 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="370fb883669c7c619884fcfa764167a7b1ba29d8" translate="yes" xml:space="preserve">
          <source>Integer or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. Netscape cookies have &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; 0. &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; cookies have a &lt;code&gt;version&lt;/code&gt; cookie-attribute of 1. However, note that &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; may &amp;lsquo;downgrade&amp;rsquo; RFC 2109 cookies to Netscape cookies, in which case &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; is 0.</source>
          <target state="translated">정수 또는 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; . Netscape 쿠키는 &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 0입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 쿠키는 &lt;code&gt;version&lt;/code&gt; 쿠키 속성이 1입니다. 그러나 &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; 는 RFC 2109 쿠키를 Netscape 쿠키로 '다운 그레이드'할 수 있으며,이 경우 &lt;a href=&quot;#http.cookiejar.Cookie.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b2586bd79fe20fc085091ee4c039323ab91a2931" translate="yes" xml:space="preserve">
          <source>Integer specifying the handle of the Python DLL.</source>
          <target state="translated">파이썬 DLL의 핸들을 지정하는 정수.</target>
        </trans-unit>
        <trans-unit id="4be890d08d451686a7899dac00d8db91fbaa5012" translate="yes" xml:space="preserve">
          <source>Integer value to control debugging output. The initialize value is taken from the module variable &lt;code&gt;Debug&lt;/code&gt;. Values greater than three trace each command.</source>
          <target state="translated">디버깅 출력을 제어하기위한 정수 값입니다. 초기화 값은 모듈 변수 &lt;code&gt;Debug&lt;/code&gt; 에서 가져옵니다 . 3보다 큰 값은 각 명령을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="0af14c05371406c3bfd30e44309da86d10408fca" translate="yes" xml:space="preserve">
          <source>Integers can be added to or subtracted from address objects. Some examples:</source>
          <target state="translated">주소 개체에 정수를 더하거나 뺄 수 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="d6ab8a868612d7d4c1a82a75ee51d447ac3ad36d" translate="yes" xml:space="preserve">
          <source>Integration with the warnings module</source>
          <target state="translated">경고 모듈과 통합</target>
        </trans-unit>
        <trans-unit id="542505ecbda45c153abc5ccd78db35ec4f174034" translate="yes" xml:space="preserve">
          <source>Interact with process:</source>
          <target state="translated">프로세스와 상호 작용 :</target>
        </trans-unit>
        <trans-unit id="80be62166e7de013309afd54472bc1797dd47e7f" translate="yes" xml:space="preserve">
          <source>Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate and set the &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; attribute. The optional &lt;em&gt;input&lt;/em&gt; argument should be data to be sent to the child process, or &lt;code&gt;None&lt;/code&gt;, if no data should be sent to the child. If streams were opened in text mode, &lt;em&gt;input&lt;/em&gt; must be a string. Otherwise, it must be bytes.</source>
          <target state="translated">Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate and set the &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; attribute. The optional &lt;em&gt;input&lt;/em&gt; argument should be data to be sent to the child process, or &lt;code&gt;None&lt;/code&gt; , if no data should be sent to the child. If streams were opened in text mode, &lt;em&gt;input&lt;/em&gt; must be a string. Otherwise, it must be bytes.</target>
        </trans-unit>
        <trans-unit id="a7b5cc2308bf821e6cd84802cf3b9067390dca9f" translate="yes" xml:space="preserve">
          <source>Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate. The optional &lt;em&gt;input&lt;/em&gt; argument should be data to be sent to the child process, or &lt;code&gt;None&lt;/code&gt;, if no data should be sent to the child. If streams were opened in text mode, &lt;em&gt;input&lt;/em&gt; must be a string. Otherwise, it must be bytes.</source>
          <target state="translated">프로세스와 상호 작용 : stdin에 데이터를 보냅니다. 파일 끝에 도달 할 때까지 stdout 및 stderr에서 데이터를 읽습니다. 프로세스가 종료 될 때까지 기다리십시오. 선택적 &lt;em&gt;입력&lt;/em&gt; 인수는 자식 프로세스로 전송 될 데이터이거나 자식으로 데이터를 보내지 않아야하는 경우 &lt;code&gt;None&lt;/code&gt; 이어야합니다. 스트림이 텍스트 모드에서 열린 경우 &lt;em&gt;입력&lt;/em&gt; 은 문자열이어야합니다. 그렇지 않으면 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="c32c2296489969b7635662c3bc8e006192df7595" translate="yes" xml:space="preserve">
          <source>Interacting with Subprocesses</source>
          <target state="translated">서브 프로세스와 상호 작용</target>
        </trans-unit>
        <trans-unit id="0fa8e4485c2202467e61698e8d5ba21575b8a864" translate="yes" xml:space="preserve">
          <source>Interaction function, emulates a very dumb Telnet client.</source>
          <target state="translated">상호 작용 기능은 매우 멍청한 Telnet 클라이언트를 에뮬레이트합니다.</target>
        </trans-unit>
        <trans-unit id="ecb2b41b88adb0386e2e88e0cb9c56f459a0f7eb" translate="yes" xml:space="preserve">
          <source>Interactive Console Objects</source>
          <target state="translated">대화식 콘솔 객체</target>
        </trans-unit>
        <trans-unit id="3cfa87a88446a39b489c704cac79d06af1b86206" translate="yes" xml:space="preserve">
          <source>Interactive Interpreter Objects</source>
          <target state="translated">대화 형 인터프리터 객체</target>
        </trans-unit>
        <trans-unit id="2cadb5b7ff0248d2b78142447a263943598198ad" translate="yes" xml:space="preserve">
          <source>Interesting examples</source>
          <target state="translated">흥미로운 예</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="8f852726c2cf35cbc0da9c364c92d16e46188ec0" translate="yes" xml:space="preserve">
          <source>Interface for a sequence of nodes.</source>
          <target state="translated">일련의 노드를위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="1c4db4b0abc2834a17fec9e2358468e1c7283350" translate="yes" xml:space="preserve">
          <source>Interface for associating a SAX event with a document location. A locator object will return valid results only during calls to DocumentHandler methods; at any other time, the results are unpredictable. If information is not available, methods may return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">SAX 이벤트를 문서 위치에 관련시키기위한 인터페이스입니다. 로케이터 객체는 DocumentHandler 메서드를 호출하는 동안에 만 유효한 결과를 반환합니다. 다른 경우에는 결과를 예측할 수 없습니다. 정보가없는 경우 메소드는 &lt;code&gt;None&lt;/code&gt; 을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5aa34ab8218f9e4e220f7344dabd8786a5fdb30e" translate="yes" xml:space="preserve">
          <source>Interface objects</source>
          <target state="translated">인터페이스 객체</target>
        </trans-unit>
        <trans-unit id="8815c1714243ec8fd3c5703aaa179285d61a547d" translate="yes" xml:space="preserve">
          <source>Interface objects are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;, so they can be used as keys in dictionaries.</source>
          <target state="translated">인터페이스 객체는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;해시 가능&lt;/a&gt; 하므로 사전에서 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="029ae727719c0190c4fc3e6c2815b79437cef934" translate="yes" xml:space="preserve">
          <source>Interface objects are &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;, so they can be used as keys in dictionaries.</source>
          <target state="translated">Interface objects are &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;, so they can be used as keys in dictionaries.</target>
        </trans-unit>
        <trans-unit id="f2972dba464e3ec39c3f8d844bc8f4665db76466" translate="yes" xml:space="preserve">
          <source>Interface objects can be compared with the usual set of logical operators.</source>
          <target state="translated">인터페이스 객체는 일반적인 논리 연산자 세트와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5af8df7a7a4069a4a7e8da32faa2198a5bc0ef82" translate="yes" xml:space="preserve">
          <source>Interface objects support some operators. Unless stated otherwise, operators can only be applied between compatible objects (i.e. IPv4 with IPv4, IPv6 with IPv6).</source>
          <target state="translated">인터페이스 객체는 일부 연산자를 지원합니다. 달리 명시하지 않는 한, 연산자는 호환 가능한 개체 (예 : IPv4를 사용하는 IPv4, IPv6을 사용하는 IPv6) 사이에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="009aeb4117871f36b8d07dbea81e88efde3f84c2" translate="yes" xml:space="preserve">
          <source>Interface representing a bidirectional transport, such as a TCP connection.</source>
          <target state="translated">TCP 연결과 같은 양방향 전송을 나타내는 인터페이스</target>
        </trans-unit>
        <trans-unit id="bae0f7875489c70ff870e51bf1acd5af5cd84f7f" translate="yes" xml:space="preserve">
          <source>Interface summary:</source>
          <target state="translated">인터페이스 요약 :</target>
        </trans-unit>
        <trans-unit id="0d7c663f31a9f2ac91921862b41886ab434c27c9" translate="yes" xml:space="preserve">
          <source>Interface to the scheduler</source>
          <target state="translated">스케줄러에 대한 인터페이스</target>
        </trans-unit>
        <trans-unit id="e3596470b1be1228bdbe04e547e2ae1f770f41b2" translate="yes" xml:space="preserve">
          <source>Interface to the underlying implementation.</source>
          <target state="translated">기본 구현에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="fb0b9bed2c76a555927ef2712dd54850772edaa0" translate="yes" xml:space="preserve">
          <source>Interface used by the parser to present error and warning messages to the application. The methods of this object control whether errors are immediately converted to exceptions or are handled in some other way.</source>
          <target state="translated">응용 프로그램에 오류 및 경고 메시지를 표시하기 위해 파서에서 사용하는 인터페이스입니다. 이 객체의 메소드는 오류가 즉시 예외로 변환되는지 또는 다른 방식으로 처리되는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7e3a30fb53d88d0640de6d5babfe7057584ac5ad" translate="yes" xml:space="preserve">
          <source>Interfaces are accessed through instance objects. Applications should not instantiate the classes themselves; they should use the creator functions available on the &lt;code&gt;Document&lt;/code&gt; object. Derived interfaces support all operations (and attributes) from the base interfaces, plus any new operations.</source>
          <target state="translated">인터페이스는 인스턴스 객체를 통해 액세스됩니다. 응용 프로그램은 클래스 자체를 인스턴스화해서는 안됩니다. &lt;code&gt;Document&lt;/code&gt; 객체 에서 사용 가능한 작성자 기능을 사용해야 합니다. 파생 인터페이스는 기본 인터페이스의 모든 작업 (및 특성)과 새로운 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="70e0c022e8ef3548815e6ce09157b2f9fed238ce" translate="yes" xml:space="preserve">
          <source>Intermixed parsing</source>
          <target state="translated">혼합 파싱</target>
        </trans-unit>
        <trans-unit id="9881c711f8b7d79a62e6a62f87a03b1baa3849a7" translate="yes" xml:space="preserve">
          <source>Internal Objects</source>
          <target state="translated">내부 객체</target>
        </trans-unit>
        <trans-unit id="a047b417e339277c6847b0fd6036b5d0c0ae1549" translate="yes" xml:space="preserve">
          <source>Internal attributes.</source>
          <target state="translated">내부 속성.</target>
        </trans-unit>
        <trans-unit id="8846061f5d538bb327da6a9444390ad20122717a" translate="yes" xml:space="preserve">
          <source>Internally, function creates a &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; with protocol &lt;em&gt;ssl_version&lt;/em&gt; and &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt;&lt;code&gt;SSLContext.options&lt;/code&gt;&lt;/a&gt; set to &lt;em&gt;cert_reqs&lt;/em&gt;. If parameters &lt;em&gt;keyfile&lt;/em&gt;, &lt;em&gt;certfile&lt;/em&gt;, &lt;em&gt;ca_certs&lt;/em&gt; or &lt;em&gt;ciphers&lt;/em&gt; are set, then the values are passed to &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt;&lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt;&lt;code&gt;SSLContext.load_verify_locations()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로 생성 함수 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 프로토콜과 &lt;em&gt;ssl_version&lt;/em&gt; 및 &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt; &lt;code&gt;SSLContext.options&lt;/code&gt; &lt;/a&gt; 설정 &lt;em&gt;cert_reqs를&lt;/em&gt; . &lt;em&gt;keyfile&lt;/em&gt; , &lt;em&gt;certfile&lt;/em&gt; , &lt;em&gt;ca_certs&lt;/em&gt; 또는 &lt;em&gt;ciphers&lt;/em&gt; 매개 변수 가 설정되면 값이 &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt; &lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.SSLContext.load_verify_locations&quot;&gt; &lt;code&gt;SSLContext.load_verify_locations()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="580ada3f664fbd8faa4d39879e7b77c24136608a" translate="yes" xml:space="preserve">
          <source>Internally, those three types of queues use locks to temporarily block competing threads; however, they are not designed to handle reentrancy within a thread.</source>
          <target state="translated">내부적으로이 세 가지 유형의 큐는 잠금을 사용하여 경쟁 스레드를 일시적으로 차단합니다. 그러나 스레드 내에서 재진입을 처리하도록 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="28d5848a333b0a47913fe57a73d442ce4518c08c" translate="yes" xml:space="preserve">
          <source>International Atomic Time</source>
          <target state="translated">International Atomic Time</target>
        </trans-unit>
        <trans-unit id="0acc2a482d5d44565ff4ebc0b9139b2dc39c506b" translate="yes" xml:space="preserve">
          <source>International currency symbol.</source>
          <target state="translated">국제 통화 기호.</target>
        </trans-unit>
        <trans-unit id="3b755f7b857b999860755840e5f0964f6b120c4d" translate="yes" xml:space="preserve">
          <source>Internationalization</source>
          <target state="translated">Internationalization</target>
        </trans-unit>
        <trans-unit id="54c981b9e80576e421c708ac83d965bd9c4c3152" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) refers to the operation by which a program is made aware of multiple languages. Localization (L10N) refers to the adaptation of your program, once internationalized, to the local language and cultural habits. In order to provide multilingual messages for your Python programs, you need to take the following steps:</source>
          <target state="translated">국제화 (I18N)는 프로그램이 여러 언어를 인식하도록하는 작업을 말합니다. 현지화 (L10N)는 국제화 된 프로그램이 현지 언어 및 문화적 습관에 적응 한 것을 말합니다. Python 프로그램에 다국어 메시지를 제공하려면 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="75170006f623fbe183bf840cf6119bbd14972198" translate="yes" xml:space="preserve">
          <source>Internationalization services. The locale setting affects the interpretation of many format specifiers in &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">국제화 서비스. 로케일 설정은 &lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 의 많은 형식 지정자의 해석에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="230139ad0ce1adb0b931fe547c69c78a03a243e2" translate="yes" xml:space="preserve">
          <source>Internationalizing your programs and modules</source>
          <target state="translated">프로그램 및 모듈 국제화</target>
        </trans-unit>
        <trans-unit id="d790826b4ae3ed725698ee4ed89c70a28abd95d5" translate="yes" xml:space="preserve">
          <source>Interned strings are not immortal; you must keep a reference to the return value of &lt;a href=&quot;#sys.intern&quot;&gt;&lt;code&gt;intern()&lt;/code&gt;&lt;/a&gt; around to benefit from it.</source>
          <target state="translated">억지로 묶인 줄은 불멸의 것이 아닙니다. 이점을 얻으려면 &lt;a href=&quot;#sys.intern&quot;&gt; &lt;code&gt;intern()&lt;/code&gt; &lt;/a&gt; 의 반환 값에 대한 참조를 유지해야 합니다.</target>
        </trans-unit>
        <trans-unit id="66c06c11d179e39c42e5e800f99b57865822cf68" translate="yes" xml:space="preserve">
          <source>Internet</source>
          <target state="translated">Internet</target>
        </trans-unit>
        <trans-unit id="8f1678405b5bf8f7b3c9be250ba0b2b4566bc2af" translate="yes" xml:space="preserve">
          <source>Internet Data</source>
          <target state="translated">인터넷 데이터</target>
        </trans-unit>
        <trans-unit id="c1aebf7c813f788884574a6f7046f553aa035ab6" translate="yes" xml:space="preserve">
          <source>Internet Data Handling</source>
          <target state="translated">인터넷 데이터 처리</target>
        </trans-unit>
        <trans-unit id="efedd1f6d18388871beb5b8937b0af027d8bf044" translate="yes" xml:space="preserve">
          <source>Internet Protocols and Support</source>
          <target state="translated">인터넷 프로토콜 및 지원</target>
        </trans-unit>
        <trans-unit id="57c33a7c8b9764293298d03366937218c60d2a49" translate="yes" xml:space="preserve">
          <source>Interpolation behaviour may be customized by providing a custom handler through the &lt;em&gt;interpolation&lt;/em&gt; argument. &lt;code&gt;None&lt;/code&gt; can be used to turn off interpolation completely, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; provides a more advanced variant inspired by &lt;code&gt;zc.buildout&lt;/code&gt;. More on the subject in the &lt;a href=&quot;#interpolation-of-values&quot;&gt;dedicated documentation section&lt;/a&gt;.</source>
          <target state="translated">보간 동작은 &lt;em&gt;보간&lt;/em&gt; 인수를 통해 사용자 지정 처리기를 제공하여 사용자 지정할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 완전히 보간을 해제 사용할 수 없습니다, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; 에서 영감을 고급 변형 제공 &lt;code&gt;zc.buildout&lt;/code&gt; 을 . 더 자세한 내용은 &lt;a href=&quot;#interpolation-of-values&quot;&gt;전용 문서 섹션을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f615e3d514dcbd13ad91a79d1d845b1973ce635" translate="yes" xml:space="preserve">
          <source>Interpolation behaviour may be customized by providing a custom handler through the &lt;em&gt;interpolation&lt;/em&gt; argument. &lt;code&gt;None&lt;/code&gt; can be used to turn off interpolation completely, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; provides a more advanced variant inspired by &lt;code&gt;zc.buildout&lt;/code&gt;. More on the subject in the &lt;a href=&quot;#interpolation-of-values&quot;&gt;dedicated documentation section&lt;/a&gt;. &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt;&lt;code&gt;RawConfigParser&lt;/code&gt;&lt;/a&gt; has a default value of &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">보간 동작은 &lt;em&gt;보간&lt;/em&gt; 인수를 통해 사용자 지정 처리기를 제공하여 사용자 지정할 수 있습니다 . &lt;code&gt;None&lt;/code&gt; 완전히 보간을 해제 사용할 수 없습니다, &lt;code&gt;ExtendedInterpolation()&lt;/code&gt; 에서 영감을 고급 변형 제공 &lt;code&gt;zc.buildout&lt;/code&gt; 을 . 더 자세한 내용은 &lt;a href=&quot;#interpolation-of-values&quot;&gt;전용 문서 섹션을 참조하십시오&lt;/a&gt; . &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt; &lt;code&gt;RawConfigParser&lt;/code&gt; &lt;/a&gt; 의 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bd2b15bb1774a577513ecc617124a7b368669881" translate="yes" xml:space="preserve">
          <source>Interpolation of values</source>
          <target state="translated">값의 보간</target>
        </trans-unit>
        <trans-unit id="d568ce51e6576d8c0979772561e24281b364cfad" translate="yes" xml:space="preserve">
          <source>Interpret the argument as though it had been typed in response to the prompt. This may be overridden, but should not normally need to be; see the &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt;&lt;code&gt;precmd()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#cmd.Cmd.postcmd&quot;&gt;&lt;code&gt;postcmd()&lt;/code&gt;&lt;/a&gt; methods for useful execution hooks. The return value is a flag indicating whether interpretation of commands by the interpreter should stop. If there is a &lt;code&gt;do_*()&lt;/code&gt; method for the command &lt;em&gt;str&lt;/em&gt;, the return value of that method is returned, otherwise the return value from the &lt;a href=&quot;#cmd.Cmd.default&quot;&gt;&lt;code&gt;default()&lt;/code&gt;&lt;/a&gt; method is returned.</source>
          <target state="translated">프롬프트에 대한 응답으로 입력 한 것처럼 인수를 해석하십시오. 재정의 될 수도 있지만 일반적으로 그럴 필요는 없습니다. 유용한 실행 후크에 대해서는 &lt;a href=&quot;#cmd.Cmd.precmd&quot;&gt; &lt;code&gt;precmd()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cmd.Cmd.postcmd&quot;&gt; &lt;code&gt;postcmd()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 . 리턴 값은 인터프리터의 명령 해석이 중지되어야하는지 여부를 나타내는 플래그입니다. &lt;em&gt;str&lt;/em&gt; 명령에 &lt;code&gt;do_*()&lt;/code&gt; 메소드 가있는 경우 해당 메소드의 리턴 값이 리턴되고, 그렇지 않으면 &lt;a href=&quot;#cmd.Cmd.default&quot;&gt; &lt;code&gt;default()&lt;/code&gt; &lt;/a&gt; 메소드 의 리턴 값 이 리턴됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d3c148819e9e54cd74c9c94b3ef056e575eee05" translate="yes" xml:space="preserve">
          <source>Interpreters</source>
          <target state="translated">Interpreters</target>
        </trans-unit>
        <trans-unit id="46d6db31f6f2547122e3f17c21631f666601ba12" translate="yes" xml:space="preserve">
          <source>Interrupt Execution</source>
          <target state="translated">인터럽트 실행</target>
        </trans-unit>
        <trans-unit id="d4033f48de0ba4899aed36c08fc403f168f4ea15" translate="yes" xml:space="preserve">
          <source>Interrupt from keyboard (CTRL + BREAK).</source>
          <target state="translated">Interrupt from keyboard (CTRL + BREAK).</target>
        </trans-unit>
        <trans-unit id="18cbfdace7f8635278d0d4b9c5ba72e6d4fce84c" translate="yes" xml:space="preserve">
          <source>Interrupt from keyboard (CTRL + C).</source>
          <target state="translated">Interrupt from keyboard (CTRL + C).</target>
        </trans-unit>
        <trans-unit id="8815302accf46070d40572381df17ae0b24087f8" translate="yes" xml:space="preserve">
          <source>Interrupted system call should be restarted</source>
          <target state="translated">중단 된 시스템 호출을 다시 시작해야합니다</target>
        </trans-unit>
        <trans-unit id="b06a3395105be1465d6b1697af03d4431eac6c71" translate="yes" xml:space="preserve">
          <source>Interrupted system call.</source>
          <target state="translated">시스템 호출이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="09dc03559a67ff5107d10fad944393ea3f877c07" translate="yes" xml:space="preserve">
          <source>InterruptedError</source>
          <target state="translated">InterruptedError</target>
        </trans-unit>
        <trans-unit id="0943ef2ada12e3e7dc287b50717ddb75bc6da8ed" translate="yes" xml:space="preserve">
          <source>Interruption</source>
          <target state="translated">Interruption</target>
        </trans-unit>
        <trans-unit id="4e36c74154decbcc22ec9de613c329458fb47795" translate="yes" xml:space="preserve">
          <source>Interruption during the decompression, such as pressing control-C or killing the decompression process may result in incomplete decompression of the archive.</source>
          <target state="translated">control-C를 누르거나 압축 해제 프로세스를 종료하는 등 압축 해제 중 중단으로 인해 아카이브 압축이 풀릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c071214f97d5c4afff6973aa5aa8c312d9737c" translate="yes" xml:space="preserve">
          <source>Intro from the Apache HTTP Server documentation</source>
          <target state="translated">Apache HTTP Server 문서에서 소개</target>
        </trans-unit>
        <trans-unit id="74f37218ef8634d6f18ddbe27efca22ced57c811" translate="yes" xml:space="preserve">
          <source>Introduced the &lt;code&gt;__prepare__&lt;/code&gt; namespace hook</source>
          <target state="translated">&lt;code&gt;__prepare__&lt;/code&gt; 네임 스페이스 후크를 도입했습니다</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="12b2799a6c697d71c79a7458b9ff32a936f76a1a" translate="yes" xml:space="preserve">
          <source>Introduction to the profilers</source>
          <target state="translated">프로파일 러 소개</target>
        </trans-unit>
        <trans-unit id="0047e79057a6dadcd1958b908f6296f6079753b9" translate="yes" xml:space="preserve">
          <source>Introspecting callables with the Signature object</source>
          <target state="translated">Signature 객체를 사용하여 콜 러블 검사</target>
        </trans-unit>
        <trans-unit id="b3b4d20d3dfe4ef78d0bf43a93aa7f57bae176c5" translate="yes" xml:space="preserve">
          <source>Introspection</source>
          <target state="translated">Introspection</target>
        </trans-unit>
        <trans-unit id="1c6c69ff716037a9df5d099d2d192521b1e9a13d" translate="yes" xml:space="preserve">
          <source>Introspection helpers</source>
          <target state="translated">Introspection helpers</target>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="translated">잘못된 인수</target>
        </trans-unit>
        <trans-unit id="f8d3e8e47ede7d1e1d63b90adac4163f137f5fbd" translate="yes" xml:space="preserve">
          <source>Invalid arguments</source>
          <target state="translated">잘못된 인수</target>
        </trans-unit>
        <trans-unit id="0659862d18cc2aab0d2c79d54ece0b588cefda81" translate="yes" xml:space="preserve">
          <source>Invalid exchange</source>
          <target state="translated">잘못된 교환</target>
        </trans-unit>
        <trans-unit id="b7ebb17aae68fc96bde7bec88689e59f80c276a6" translate="yes" xml:space="preserve">
          <source>Invalid internal state of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 의 내부 상태가 잘못되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e5a79f3df5c8af3ba8a7813c333e1a6a9466a6b5" translate="yes" xml:space="preserve">
          <source>Invalid request code</source>
          <target state="translated">잘못된 요청 코드</target>
        </trans-unit>
        <trans-unit id="921238b4baa4c7c3a24c3d63e0e9afc770fd916a" translate="yes" xml:space="preserve">
          <source>Invalid request descriptor</source>
          <target state="translated">잘못된 요청 설명자</target>
        </trans-unit>
        <trans-unit id="ac9eda2543c0cdfa22d49b3ce87554f9fa67c95e" translate="yes" xml:space="preserve">
          <source>Invalid request: descriptor not open</source>
          <target state="translated">잘못된 요청 : 설명자가 열리지 않습니다</target>
        </trans-unit>
        <trans-unit id="6684b6eeddecb3f9f1296f418af07f2108c4ba7a" translate="yes" xml:space="preserve">
          <source>Invalid slot</source>
          <target state="translated">유효하지 않은 슬롯</target>
        </trans-unit>
        <trans-unit id="ac39f10f2b107f4005a05fd5034e22c350ce91cd" translate="yes" xml:space="preserve">
          <source>Invalidate the internal caches of finders stored at &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt;. If a finder implements &lt;code&gt;invalidate_caches()&lt;/code&gt; then it will be called to perform the invalidation. This function should be called if any modules are created/installed while your program is running to guarantee all finders will notice the new module&amp;rsquo;s existence.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; 에&lt;/a&gt; 저장된 파인더의 내부 캐시를 무효화하십시오 . 파인더가 &lt;code&gt;invalidate_caches()&lt;/code&gt; 를 구현 하면 무효화를 수행하기 위해 호출됩니다. 모든 파인더가 새로운 모듈의 존재를 알 수 있도록 프로그램이 실행되는 동안 모듈이 작성 / 설치된 경우이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba67563ea1b90363b3f3e36d5c60e13c4df6670d" translate="yes" xml:space="preserve">
          <source>Invert all the digits in &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;x의&lt;/em&gt; 모든 자리수를 &lt;em&gt;뒤집습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fd084280a98a8cc9427a473124b409ada9c6b2a3" translate="yes" xml:space="preserve">
          <source>Invisible or blank mode</source>
          <target state="translated">보이지 않거나 공백 모드</target>
        </trans-unit>
        <trans-unit id="3bf010a72c53420609032016c83dfcf503ce6948" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt;&lt;code&gt;ZipFile.open()&lt;/code&gt;&lt;/a&gt; on the current path. Accepts the same arguments as &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt;&lt;code&gt;ZipFile.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 경로에서 &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt; &lt;code&gt;ZipFile.open()&lt;/code&gt; &lt;/a&gt; 을 호출 하십시오. &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt; &lt;code&gt;ZipFile.open()&lt;/code&gt; &lt;/a&gt; 과 동일한 인수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="e1b5816db7fc9e3046813d2dcfcddbfc9f951064" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt;&lt;code&gt;ZipFile.open()&lt;/code&gt;&lt;/a&gt; on the current path. Allows opening for read or write, text or binary through supported modes: &amp;lsquo;r&amp;rsquo;, &amp;lsquo;w&amp;rsquo;, &amp;lsquo;rb&amp;rsquo;, &amp;lsquo;wb&amp;rsquo;. Positional and keyword arguments are passed through to &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; when opened as text and ignored otherwise. &lt;code&gt;pwd&lt;/code&gt; is the &lt;code&gt;pwd&lt;/code&gt; parameter to &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt;&lt;code&gt;ZipFile.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Invoke &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt; &lt;code&gt;ZipFile.open()&lt;/code&gt; &lt;/a&gt; on the current path. Allows opening for read or write, text or binary through supported modes: &amp;lsquo;r&amp;rsquo;, &amp;lsquo;w&amp;rsquo;, &amp;lsquo;rb&amp;rsquo;, &amp;lsquo;wb&amp;rsquo;. Positional and keyword arguments are passed through to &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; when opened as text and ignored otherwise. &lt;code&gt;pwd&lt;/code&gt; is the &lt;code&gt;pwd&lt;/code&gt; parameter to &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt; &lt;code&gt;ZipFile.open()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="423894e2a4eefe4fc84b32affe9b7e263601406b" translate="yes" xml:space="preserve">
          <source>Invoke a callback &lt;em&gt;after&lt;/em&gt; the given time.</source>
          <target state="translated">주어진 시간 &lt;em&gt;후에&lt;/em&gt; 콜백 &lt;em&gt;을&lt;/em&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d5c67cd19bdfed187292858862c10f228bb5045" translate="yes" xml:space="preserve">
          <source>Invoke a callback &lt;em&gt;at&lt;/em&gt; the given time.</source>
          <target state="translated">주어진 시간에 콜백 &lt;em&gt;을&lt;/em&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="76c3be08bb7afa5e12d91ae6bbae4d9ceb1bf847" translate="yes" xml:space="preserve">
          <source>Invoke a callback soon.</source>
          <target state="translated">콜백을 곧 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="02465213be1ac7e5af0e05eec89ae1f987088775" translate="yes" xml:space="preserve">
          <source>Invoke the built-in help system. (This function is intended for interactive use.) If no argument is given, the interactive help system starts on the interpreter console. If the argument is a string, then the string is looked up as the name of a module, function, class, method, keyword, or documentation topic, and a help page is printed on the console. If the argument is any other kind of object, a help page on the object is generated.</source>
          <target state="translated">내장 된 도움말 시스템을 호출하십시오. (이 기능은 대화식으로 사용하기위한 것입니다.) 인수가 없으면 대화식 도움말 시스템이 인터프리터 콘솔에서 시작됩니다. 인수가 문자열 인 경우 문자열은 모듈, 함수, 클래스, 메소드, 키워드 또는 문서 주제의 이름으로 조회되며 도움말 페이지가 콘솔에 인쇄됩니다. 인수가 다른 종류의 객체 인 경우 객체의 도움말 페이지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6844b46c8699594aabdbedb9cb340a297a5875b2" translate="yes" xml:space="preserve">
          <source>Invoked as a script, the &lt;a href=&quot;#module-pstats&quot;&gt;&lt;code&gt;pstats&lt;/code&gt;&lt;/a&gt; module is a statistics browser for reading and examining profile dumps. It has a simple line-oriented interface (implemented using &lt;a href=&quot;cmd#module-cmd&quot;&gt;&lt;code&gt;cmd&lt;/code&gt;&lt;/a&gt;) and interactive help.</source>
          <target state="translated">스크립트로 호출 된 &lt;a href=&quot;#module-pstats&quot;&gt; &lt;code&gt;pstats&lt;/code&gt; &lt;/a&gt; 모듈은 프로파일 덤프를 읽고 검사하기위한 통계 브라우저입니다. 간단한 라인 지향 인터페이스 ( &lt;a href=&quot;cmd#module-cmd&quot;&gt; &lt;code&gt;cmd&lt;/code&gt; 를&lt;/a&gt; 사용하여 구현 됨 )와 대화식 도움말이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bd2a50918821ef3e207e7ae794bd6f6284c7b2f" translate="yes" xml:space="preserve">
          <source>Invoking &amp;lsquo;Show Completions&amp;rsquo;, or hitting</source>
          <target state="translated">Invoking &amp;lsquo;Show Completions&amp;rsquo;, or hitting</target>
        </trans-unit>
        <trans-unit id="50ee2ea09ca943e50fb0b3c932a9cca14117e8c5" translate="yes" xml:space="preserve">
          <source>Invoking this function may change the semantics of datetimes using &lt;code&gt;ZoneInfo&lt;/code&gt; in surprising ways; this modifies process-wide global state and thus may have wide-ranging effects. Only use it if you know that you need to.</source>
          <target state="translated">Invoking this function may change the semantics of datetimes using &lt;code&gt;ZoneInfo&lt;/code&gt; in surprising ways; this modifies process-wide global state and thus may have wide-ranging effects. Only use it if you know that you need to.</target>
        </trans-unit>
        <trans-unit id="726a8b660b71615a82f862249de26d56cd18e129" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;True&lt;/code&gt; if the stream is closed.</source>
          <target state="translated">가 &lt;code&gt;True&lt;/code&gt; 스트림이 닫혀있는 경우.</target>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="translated">디렉토리인가</target>
        </trans-unit>
        <trans-unit id="b9271431abbe409f3af4140e02d0f15a9328cd88" translate="yes" xml:space="preserve">
          <source>Is a generic constructor that takes the string &lt;em&gt;name&lt;/em&gt; of the desired algorithm as its first parameter. It also exists to allow access to the above listed hashes as well as any other algorithms that your OpenSSL library may offer. The named constructors are much faster than &lt;a href=&quot;#hashlib.new&quot;&gt;&lt;code&gt;new()&lt;/code&gt;&lt;/a&gt; and should be preferred.</source>
          <target state="translated">원하는 알고리즘 의 문자열 &lt;em&gt;이름&lt;/em&gt; 을 첫 번째 매개 변수로 사용 하는 일반 생성자입니다 . 또한 위에 나열된 해시와 OpenSSL 라이브러리가 제공 할 수있는 다른 알고리즘에 액세스 할 수 있습니다. 명명 된 생성자는 &lt;a href=&quot;#hashlib.new&quot;&gt; &lt;code&gt;new()&lt;/code&gt; &lt;/a&gt; 보다 훨씬 빠르 므로 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="0bf5e0f29c754cc24aba94217c9a03a8d1bd88d7" translate="yes" xml:space="preserve">
          <source>Is a named type file</source>
          <target state="translated">명명 된 형식 파일입니다</target>
        </trans-unit>
        <trans-unit id="bee2b08fdf889353624d0f8c23e090efd5200001" translate="yes" xml:space="preserve">
          <source>Is called after the &lt;code&gt;end()&lt;/code&gt; callback of an element that declared a namespace prefix mapping, with the name of the &lt;em&gt;prefix&lt;/em&gt; that went out of scope.</source>
          <target state="translated">범위를 벗어난 &lt;em&gt;접두사&lt;/em&gt; 이름으로 네임 스페이스 접두사 매핑을 선언 한 요소 의 &lt;code&gt;end()&lt;/code&gt; 콜백 후에 호출 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="30d2df16b87401fece6e95883b5b9ea7ed5ee83b" translate="yes" xml:space="preserve">
          <source>Is called whenever the parser encounters a new namespace declaration, before the &lt;code&gt;start()&lt;/code&gt; callback for the opening element that defines it. &lt;em&gt;prefix&lt;/em&gt; is &lt;code&gt;''&lt;/code&gt; for the default namespace and the declared namespace prefix name otherwise. &lt;em&gt;uri&lt;/em&gt; is the namespace URI.</source>
          <target state="translated">파서가 새 네임 스페이스 선언을 발견 할 때마다 이를 정의하는 여는 요소에 대한 &lt;code&gt;start()&lt;/code&gt; 콜백 전에 호출됩니다. &lt;em&gt;접두사&lt;/em&gt; 는 기본 네임 스페이스의 경우 &lt;code&gt;''&lt;/code&gt; 이고 선언 된 네임 스페이스 접 두부 이름의 경우 '' 입니다. &lt;em&gt;uri&lt;/em&gt; 는 네임 스페이스 URI입니다.</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="faccc474f96ec465b21b84d73c34160d716e3f91" translate="yes" xml:space="preserve">
          <source>Is raised by &lt;a href=&quot;#tarfile.TarInfo.frombuf&quot;&gt;&lt;code&gt;TarInfo.frombuf()&lt;/code&gt;&lt;/a&gt; if the buffer it gets is invalid.</source>
          <target state="translated">버퍼가 유효하지 않은 경우 &lt;a href=&quot;#tarfile.TarInfo.frombuf&quot;&gt; &lt;code&gt;TarInfo.frombuf()&lt;/code&gt; &lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="18a7000c3669054a5c3429b5bca7b29f3a62b417" translate="yes" xml:space="preserve">
          <source>Is raised for &lt;em&gt;non-fatal&lt;/em&gt; errors when using &lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt;&lt;code&gt;TarFile.extract()&lt;/code&gt;&lt;/a&gt;, but only if &lt;code&gt;TarFile.errorlevel&lt;/code&gt;&lt;code&gt;== 2&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt; &lt;code&gt;TarFile.extract()&lt;/code&gt; &lt;/a&gt; 사용할 때 &lt;em&gt;치명적이지 않은&lt;/em&gt; 오류 가 발생 하지만 &lt;code&gt;TarFile.errorlevel&lt;/code&gt; &lt;code&gt;== 2&lt;/code&gt; 경우에만 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="18715da6dd78d77038e6918bcd213c664251a25c" translate="yes" xml:space="preserve">
          <source>Is raised for the limitations that are typical for stream-like &lt;a href=&quot;#tarfile.TarFile&quot;&gt;&lt;code&gt;TarFile&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">스트림과 같은 &lt;a href=&quot;#tarfile.TarFile&quot;&gt; &lt;code&gt;TarFile&lt;/code&gt; &lt;/a&gt; 객체에 일반적인 제한 사항으로 인해 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b4dfe73679ab1a5e17ff73652a8048ca83d1123c" translate="yes" xml:space="preserve">
          <source>Is raised when a compression method is not supported or when the data cannot be decoded properly.</source>
          <target state="translated">압축 방법이 지원되지 않거나 데이터를 올바르게 디코딩 할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c229c84cdb83be81adf3d14e2f27db1ff9323b8" translate="yes" xml:space="preserve">
          <source>Is raised when a tar archive is opened, that either cannot be handled by the &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module or is somehow invalid.</source>
          <target state="translated">tar 아카이브가 열릴 때 발생합니다. tar 아카이브는 &lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈 로 처리 할 수 ​​없거나 어떤 식 으로든 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d9f275d0e44d3c8f374404212109840194aa96b" translate="yes" xml:space="preserve">
          <source>Is the specified record to be logged? Returns zero for no, nonzero for yes. If deemed appropriate, the record may be modified in-place by this method.</source>
          <target state="translated">지정된 레코드가 기록됩니까? 아니요는 0을, 예는 0이 아닌 값을 반환합니다. 적절하다고 판단되면이 방법으로 레코드를 제자리에서 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8d1927814fec93e6de191ddf4a54f49e0a8a5f4" translate="yes" xml:space="preserve">
          <source>IsADirectoryError</source>
          <target state="translated">IsADirectoryError</target>
        </trans-unit>
        <trans-unit id="5aaeb6752e0a30b5836a9fdc9113966711e2d7a5" translate="yes" xml:space="preserve">
          <source>Issue a warning, or maybe ignore it or raise an exception. The &lt;em&gt;category&lt;/em&gt; argument, if given, must be a &lt;a href=&quot;#warning-categories&quot;&gt;warning category class&lt;/a&gt;; it defaults to &lt;a href=&quot;exceptions#UserWarning&quot;&gt;&lt;code&gt;UserWarning&lt;/code&gt;&lt;/a&gt;. Alternatively, &lt;em&gt;message&lt;/em&gt; can be a &lt;a href=&quot;exceptions#Warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; instance, in which case &lt;em&gt;category&lt;/em&gt; will be ignored and &lt;code&gt;message.__class__&lt;/code&gt; will be used. In this case, the message text will be &lt;code&gt;str(message)&lt;/code&gt;. This function raises an exception if the particular warning issued is changed into an error by the &lt;a href=&quot;#warning-filter&quot;&gt;warnings filter&lt;/a&gt;. The &lt;em&gt;stacklevel&lt;/em&gt; argument can be used by wrapper functions written in Python, like this:</source>
          <target state="translated">경고를 발행하거나 무시하거나 예외를 발생시킬 수 있습니다. &lt;em&gt;카테고리&lt;/em&gt; 인수는, 주어진 경우이어야 &lt;a href=&quot;#warning-categories&quot;&gt;경고 카테고리 클래스&lt;/a&gt; ; 기본값은 &lt;a href=&quot;exceptions#UserWarning&quot;&gt; &lt;code&gt;UserWarning&lt;/code&gt; &lt;/a&gt; 입니다. 또는 &lt;em&gt;message&lt;/em&gt; 는 &lt;a href=&quot;exceptions#Warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; 인스턴스 일 수 &lt;code&gt;message.__class__&lt;/code&gt; 경우 &lt;em&gt;category&lt;/em&gt; 는 무시되고 message .__ class__ 가 사용됩니다. 이 경우 메시지 텍스트는 &lt;code&gt;str(message)&lt;/code&gt; 입니다. &lt;a href=&quot;#warning-filter&quot;&gt;경고 필터에&lt;/a&gt; 의해 발행 된 특정 경고가 오류로 변경되면이 기능은 예외를 발생시킵니다 . &lt;em&gt;stacklevel의&lt;/em&gt; 인수는이 같은 파이썬으로 작성된 래퍼 함수, 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2acc379f1d9efba7c573cb292f79779105a94baa" translate="yes" xml:space="preserve">
          <source>Issue an &lt;code&gt;SMTP&lt;/code&gt;&lt;code&gt;AUTH&lt;/code&gt; command for the specified authentication &lt;em&gt;mechanism&lt;/em&gt;, and handle the challenge response via &lt;em&gt;authobject&lt;/em&gt;.</source>
          <target state="translated">문제 &lt;code&gt;SMTP&lt;/code&gt; &lt;code&gt;AUTH&lt;/code&gt; 의 지정된 인증 용 명령 &lt;em&gt;기구&lt;/em&gt; , 비아 도전 응답 처리 &lt;em&gt;authobject를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="131d53be7d06b29d352aeb037a9507988702c57d" translate="yes" xml:space="preserve">
          <source>Issue with file descriptors</source>
          <target state="translated">파일 디스크립터 관련 문제</target>
        </trans-unit>
        <trans-unit id="e46c8a5eede1acdf3c821975f3ebca0b3fba6963" translate="yes" xml:space="preserve">
          <source>It also defines names for some object types that are used by the standard Python interpreter, but not exposed as builtins like &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; are.</source>
          <target state="translated">또한 표준 Python 인터프리터가 사용하지만 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 같은 내장으로 노출되지 않는 일부 객체 유형의 이름을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="03d0fa505bb145a8b508318b5166e2f593fc8b4f" translate="yes" xml:space="preserve">
          <source>It also has children nodes over which we can iterate:</source>
          <target state="translated">또한 우리가 반복 할 수있는 자식 노드가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ba93dd24e6158dc460f6e66524c0fca4f667b666" translate="yes" xml:space="preserve">
          <source>It also looks for &lt;code&gt;*.pkg&lt;/code&gt; files beginning where &lt;code&gt;*&lt;/code&gt; matches the &lt;em&gt;name&lt;/em&gt; argument. This feature is similar to &lt;code&gt;*.pth&lt;/code&gt; files (see the &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module for more information), except that it doesn&amp;rsquo;t special-case lines starting with &lt;code&gt;import&lt;/code&gt;. A &lt;code&gt;*.pkg&lt;/code&gt; file is trusted at face value: apart from checking for duplicates, all entries found in a &lt;code&gt;*.pkg&lt;/code&gt; file are added to the path, regardless of whether they exist on the filesystem. (This is a feature.)</source>
          <target state="translated">또한 &lt;code&gt;*&lt;/code&gt; 가 &lt;em&gt;name&lt;/em&gt; 인수 와 일치하는 &lt;code&gt;*.pkg&lt;/code&gt; 파일을 찾습니다 . 이 기능은 &lt;code&gt;import&lt;/code&gt; 로 시작하는 특수한 경우가 아니라는 점을 제외하고 &lt;code&gt;*.pth&lt;/code&gt; 파일 과 유사 합니다 (자세한 내용은 &lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 모듈 참조 ) . &lt;code&gt;*.pkg&lt;/code&gt; 파일은 액면 그대로 신뢰 : 떨어져 중복 검사에서 모든 항목이 발견 &lt;code&gt;*.pkg&lt;/code&gt; 관계없이 파일 시스템에 존재하는지 여부의 경로에 추가되는 파일입니다. (이것은 기능입니다.)&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac049eee8e098efbf97dcda725fb4ce89501bd33" translate="yes" xml:space="preserve">
          <source>It also supports certain of Python&amp;rsquo;s built-in operators through &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">또한 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt; &lt;code&gt;__ne__()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 특정 Python 내장 연산자를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="72eb8ad6cd37cb5f52e4a1a044e775d59251623a" translate="yes" xml:space="preserve">
          <source>It also supports certain of Python&amp;rsquo;s built-in operators through &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">It also supports certain of Python&amp;rsquo;s built-in operators through &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ne__&quot;&gt; &lt;code&gt;__ne__()&lt;/code&gt; &lt;/a&gt; methods.</target>
        </trans-unit>
        <trans-unit id="b08324cda6eda4c504aa9a823d617b47aa532d2d" translate="yes" xml:space="preserve">
          <source>It also supports certain of Python&amp;rsquo;s built-in operators through rich comparison and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">또한 풍부한 비교 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 메소드를 통해 특정 Python 내장 연산자를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="842ed03a56a6f506cf11d486992609fafd42c6d4" translate="yes" xml:space="preserve">
          <source>It also supports certain of Python&amp;rsquo;s built-in operators through rich comparison and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">It also supports certain of Python&amp;rsquo;s built-in operators through rich comparison and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; methods.</target>
        </trans-unit>
        <trans-unit id="1186ed492c366eaa388b29b3083c0e6d09f9e556" translate="yes" xml:space="preserve">
          <source>It also understands &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, and &lt;code&gt;-Infinity&lt;/code&gt; as their corresponding &lt;code&gt;float&lt;/code&gt; values, which is outside the JSON spec.</source>
          <target state="translated">또한 &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;Infinity&lt;/code&gt; 및 &lt;code&gt;-Infinity&lt;/code&gt; 를 해당하는 &lt;code&gt;float&lt;/code&gt; 값 으로 이해 합니다. 이는 JSON 사양 외부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="94b40a001adb648db1d34b0c19e9d0480830df9e" translate="yes" xml:space="preserve">
          <source>It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W default&lt;/code&gt;&lt;/a&gt; command line option is used.</source>
          <target state="translated">It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W default&lt;/code&gt; &lt;/a&gt; command line option is used.</target>
        </trans-unit>
        <trans-unit id="d97d143e1ed5833a5ffae18d0d146c9b4a3160c8" translate="yes" xml:space="preserve">
          <source>It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt;&lt;/a&gt; environment variable is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt; &lt;/a&gt; environment variable is set to &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a74741be2e55387e02182ff501814cbceadec398" translate="yes" xml:space="preserve">
          <source>It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONMALLOC&quot; id=&quot;index-2&quot;&gt;&lt;code&gt;PYTHONMALLOC&lt;/code&gt;&lt;/a&gt; environment variable is set to &lt;code&gt;debug&lt;/code&gt;.</source>
          <target state="translated">It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONMALLOC&quot; id=&quot;index-2&quot;&gt; &lt;code&gt;PYTHONMALLOC&lt;/code&gt; &lt;/a&gt; environment variable is set to &lt;code&gt;debug&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3223643d116973b3df651fdfb1a63a8fda9e729e" translate="yes" xml:space="preserve">
          <source>It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X faulthandler&lt;/code&gt;&lt;/a&gt; command line option is used or if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONFAULTHANDLER&quot; id=&quot;index-4&quot;&gt;&lt;code&gt;PYTHONFAULTHANDLER&lt;/code&gt;&lt;/a&gt; environment variable is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">It behaves as if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X faulthandler&lt;/code&gt; &lt;/a&gt; command line option is used or if the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONFAULTHANDLER&quot; id=&quot;index-4&quot;&gt; &lt;code&gt;PYTHONFAULTHANDLER&lt;/code&gt; &lt;/a&gt; environment variable is set to &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aec1493a57b4d7fa45bea1b3298210ad9be4bf5b" translate="yes" xml:space="preserve">
          <source>It can also be used to restore the actual files to known working file objects in case they have been overwritten with a broken object. However, the preferred way to do this is to explicitly save the previous stream before replacing it, and restore the saved object.</source>
          <target state="translated">또한 손상된 파일로 덮어 쓴 경우 실제 파일을 알려진 작업 파일 객체로 복원하는 데 사용할 수 있습니다. 그러나이를 수행하기 위해 선호되는 방법은 이전 스트림을 교체하기 전에 명시 적으로 저장하고 저장된 오브젝트를 복원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8de172274d40b1578d3c4b46f50eae9a471e5a68" translate="yes" xml:space="preserve">
          <source>It can be 16 bits or 32 bits depending on the platform.</source>
          <target state="translated">It can be 16 bits or 32 bits depending on the platform.</target>
        </trans-unit>
        <trans-unit id="79cab5b41999a73bfdfbaad2711310f0344a5211" translate="yes" xml:space="preserve">
          <source>It can be enabled using the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X dev&lt;/code&gt;&lt;/a&gt; command line option or by setting the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONDEVMODE&quot; id=&quot;index-0&quot;&gt;&lt;code&gt;PYTHONDEVMODE&lt;/code&gt;&lt;/a&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">It can be enabled using the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X dev&lt;/code&gt; &lt;/a&gt; command line option or by setting the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONDEVMODE&quot; id=&quot;index-0&quot;&gt; &lt;code&gt;PYTHONDEVMODE&lt;/code&gt; &lt;/a&gt; environment variable to &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e025bf37372974d8506acabf4c6c27f0517393" translate="yes" xml:space="preserve">
          <source>It cannot be caught, blocked, or ignored.</source>
          <target state="translated">It cannot be caught, blocked, or ignored.</target>
        </trans-unit>
        <trans-unit id="60f3acc604f0bf942399f638a855b169564bcc7f" translate="yes" xml:space="preserve">
          <source>It defines a &lt;a href=&quot;#selectors.BaseSelector&quot;&gt;&lt;code&gt;BaseSelector&lt;/code&gt;&lt;/a&gt; abstract base class, along with several concrete implementations (&lt;a href=&quot;#selectors.KqueueSelector&quot;&gt;&lt;code&gt;KqueueSelector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#selectors.EpollSelector&quot;&gt;&lt;code&gt;EpollSelector&lt;/code&gt;&lt;/a&gt;&amp;hellip;), that can be used to wait for I/O readiness notification on multiple file objects. In the following, &amp;ldquo;file object&amp;rdquo; refers to any object with a &lt;code&gt;fileno()&lt;/code&gt; method, or a raw file descriptor. See &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">여러 파일 객체에서 I / O 준비 알림을 기다리는 데 사용할 수있는 몇 가지 구체적인 구현 ( &lt;a href=&quot;#selectors.KqueueSelector&quot;&gt; &lt;code&gt;KqueueSelector&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#selectors.EpollSelector&quot;&gt; &lt;code&gt;EpollSelector&lt;/code&gt; &lt;/a&gt; &amp;hellip;) 과 함께 &lt;a href=&quot;#selectors.BaseSelector&quot;&gt; &lt;code&gt;BaseSelector&lt;/code&gt; &lt;/a&gt; 추상 기본 클래스를 정의 합니다. 다음에서 &quot;파일 개체&quot;는 &lt;code&gt;fileno()&lt;/code&gt; 메서드 또는 원시 파일 설명자를 가진 모든 개체를 나타냅니다 . &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f27f526ef94f520ad493a876be3577831360f945" translate="yes" xml:space="preserve">
          <source>It defines a &lt;a href=&quot;#selectors.BaseSelector&quot;&gt;&lt;code&gt;BaseSelector&lt;/code&gt;&lt;/a&gt; abstract base class, along with several concrete implementations (&lt;a href=&quot;#selectors.KqueueSelector&quot;&gt;&lt;code&gt;KqueueSelector&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#selectors.EpollSelector&quot;&gt;&lt;code&gt;EpollSelector&lt;/code&gt;&lt;/a&gt;&amp;hellip;), that can be used to wait for I/O readiness notification on multiple file objects. In the following, &amp;ldquo;file object&amp;rdquo; refers to any object with a &lt;code&gt;fileno()&lt;/code&gt; method, or a raw file descriptor. See &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">It defines a &lt;a href=&quot;#selectors.BaseSelector&quot;&gt; &lt;code&gt;BaseSelector&lt;/code&gt; &lt;/a&gt; abstract base class, along with several concrete implementations (&lt;a href=&quot;#selectors.KqueueSelector&quot;&gt; &lt;code&gt;KqueueSelector&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#selectors.EpollSelector&quot;&gt; &lt;code&gt;EpollSelector&lt;/code&gt; &lt;/a&gt;&amp;hellip;), that can be used to wait for I/O readiness notification on multiple file objects. In the following, &amp;ldquo;file object&amp;rdquo; refers to any object with a &lt;code&gt;fileno()&lt;/code&gt; method, or a raw file descriptor. See &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a86490549662868112f136678359ce261e7fbf4a" translate="yes" xml:space="preserve">
          <source>It defines the following items:</source>
          <target state="translated">다음 항목을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="86cf8e626a8b6c0e4daf5e5c5001af4e595a1aaf" translate="yes" xml:space="preserve">
          <source>It detects the encoding from the presence of a UTF-8 BOM or an encoding cookie as specified in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0263&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 263&lt;/strong&gt;&lt;/a&gt;. If both a BOM and a cookie are present, but disagree, a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; will be raised. Note that if the BOM is found, &lt;code&gt;'utf-8-sig'&lt;/code&gt; will be returned as an encoding.</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0263&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 263에&lt;/strong&gt;&lt;/a&gt; 지정된 UTF-8 BOM 또는 인코딩 쿠키가있는 경우 인코딩을 감지합니다 . BOM과 쿠키가 모두 존재하지만 동의하지 않으면 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. BOM이 발견되면 &lt;code&gt;'utf-8-sig'&lt;/code&gt; 가 인코딩으로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6d7e8dc33830431ce4274e88f610528d52ec30" translate="yes" xml:space="preserve">
          <source>It extends the existing &lt;em&gt;ustar&lt;/em&gt; format with extra headers for information that cannot be stored otherwise. There are two flavours of pax headers: Extended headers only affect the subsequent file header, global headers are valid for the complete archive and affect all following files. All the data in a pax header is encoded in &lt;em&gt;UTF-8&lt;/em&gt; for portability reasons.</source>
          <target state="translated">다른 방법으로 저장할 수없는 정보를 위해 추가 헤더를 사용 하여 기존 &lt;em&gt;ustar&lt;/em&gt; 형식을 확장합니다 . pax 헤더에는 두 가지 종류가 있습니다. 확장 헤더는 후속 파일 헤더에만 영향을 미치며 전역 헤더는 전체 아카이브에 유효하며 다음 파일 모두에 영향을 미칩니다. pax 헤더의 모든 데이터는 이식성의 이유로 &lt;em&gt;UTF-8&lt;/em&gt; 로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ffd7e38afe55390aae7754992e18f89ae1644e1" translate="yes" xml:space="preserve">
          <source>It has no other methods besides the ones inherited from &lt;code&gt;ttk.Widget&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttk.Widget&lt;/code&gt; 에서 상속 된 메소드 외에 다른 메소드는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0951e90496403cdeaa51c98298faafd64552fecb" translate="yes" xml:space="preserve">
          <source>It has one attribute, &lt;code&gt;data&lt;/code&gt;, that can be used to retrieve the Python bytes object stored in it.</source>
          <target state="translated">여기에는 하나의 속성 &lt;code&gt;data&lt;/code&gt; 가 있으며 여기에 저장된 Python bytes 객체를 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3780db06a7fc7e80db01f0dc24e060618d78221a" translate="yes" xml:space="preserve">
          <source>It has one attribute, &lt;code&gt;data&lt;/code&gt;, which can be used to retrieve the int value of the UID. &lt;code&gt;data&lt;/code&gt; must be in the range &lt;code&gt;0 &amp;lt;= data &amp;lt; 2**64&lt;/code&gt;.</source>
          <target state="translated">UID의 int 값을 검색하는 데 사용할 수있는 &lt;code&gt;data&lt;/code&gt; 속성이 하나 있습니다. &lt;code&gt;data&lt;/code&gt; 는 &lt;code&gt;0 &amp;lt;= data &amp;lt; 2**64&lt;/code&gt; 범위에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="23306eadb9dad4ad03f07be8c0a83f188ab18bb4" translate="yes" xml:space="preserve">
          <source>It is a simplified &lt;a href=&quot;#multiprocessing.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; type, very close to a locked &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잠긴 &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; 매우 가까운 단순화 된 &lt;a href=&quot;#multiprocessing.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="5ae066ca641a4bc8990133345ec5ed5570fe1167" translate="yes" xml:space="preserve">
          <source>It is advisable to use the &lt;a href=&quot;#nntplib.decode_header&quot;&gt;&lt;code&gt;decode_header()&lt;/code&gt;&lt;/a&gt; function on header values when they may contain non-ASCII characters:</source>
          <target state="translated">ASCII가 아닌 문자를 포함 할 수있는 헤더 값에 &lt;a href=&quot;#nntplib.decode_header&quot;&gt; &lt;code&gt;decode_header()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="753d5be67d0389392a814b65b9ab13072b3bc426" translate="yes" xml:space="preserve">
          <source>It is allowable for many weak references to be constructed for the same object. Callbacks registered for each weak reference will be called from the most recently registered callback to the oldest registered callback.</source>
          <target state="translated">동일한 객체에 대해 많은 약한 참조를 구성 할 수 있습니다. 각 약한 참조에 대해 등록 된 콜백은 가장 최근에 등록 된 콜백에서 가장 오래된 등록 된 콜백으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c594fee7fb081acf751161f581d98f6ddeb8a51f" translate="yes" xml:space="preserve">
          <source>It is also legal to pass strings as parameters; these should be keys in &lt;code&gt;sys.modules&lt;/code&gt;. Each associated module will be scanned by &lt;code&gt;unittest.TestLoader.loadTestsFromModule()&lt;/code&gt;. This is usually seen in the following &lt;code&gt;test_main()&lt;/code&gt; function:</source>
          <target state="translated">문자열을 매개 변수로 전달하는 것도 합법적입니다. 이것들은 &lt;code&gt;sys.modules&lt;/code&gt; 의 키 여야합니다 . 연관된 각 모듈은 &lt;code&gt;unittest.TestLoader.loadTestsFromModule()&lt;/code&gt; 의해 스캔됩니다 . 일반적으로 다음 &lt;code&gt;test_main()&lt;/code&gt; 함수 에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9198580629b375ecb6cd20a7e7294c4ca6e5fd99" translate="yes" xml:space="preserve">
          <source>It is also possible to achieve the same result without using the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; approach.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;컨텍스트 관리자&lt;/a&gt; 접근 방식 을 사용하지 않고도 동일한 결과를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a898afa2992cd8e912c575a2536dec4453ed7a3c" translate="yes" xml:space="preserve">
          <source>It is also possible to achieve the same result without using the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; approach.</source>
          <target state="translated">It is also possible to achieve the same result without using the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; approach.</target>
        </trans-unit>
        <trans-unit id="a1255f8f5c1717c7558bffa794a4d3503ba88bf1" translate="yes" xml:space="preserve">
          <source>It is also possible to check the production of exceptions, warnings, and log messages using the following methods:</source>
          <target state="translated">다음 방법을 사용하여 예외, 경고 및 로그 메시지의 생성을 점검 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfda1e856e7a541fee3a382fde7564093efe53b2" translate="yes" xml:space="preserve">
          <source>It is also possible to create temporary directories; see the &lt;a href=&quot;tempfile#module-tempfile&quot;&gt;&lt;code&gt;tempfile&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile.mkdtemp()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">임시 디렉토리를 작성할 수도 있습니다. &lt;a href=&quot;tempfile#module-tempfile&quot;&gt; &lt;code&gt;tempfile&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6422bf6800c39267f0e3ec0b62764a762df242b2" translate="yes" xml:space="preserve">
          <source>It is also possible to name the combinations:</source>
          <target state="translated">조합의 이름을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="798d456bd66adc337600fb619c61f4bd509b080b" translate="yes" xml:space="preserve">
          <source>It is also possible to stop all patches which have been started by using &lt;a href=&quot;#unittest.mock.patch.stopall&quot;&gt;&lt;code&gt;patch.stopall()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch.stopall&quot;&gt; &lt;code&gt;patch.stopall()&lt;/code&gt; &lt;/a&gt; 을 사용하여 시작된 모든 패치를 중지 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc27f258f5c82cae432552d9efba051f52376ec" translate="yes" xml:space="preserve">
          <source>It is also possible to use a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; as a file for both reading and writing. For strings &lt;a href=&quot;#io.StringIO&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; can be used like a file opened in text mode. &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt; can be used like a file opened in binary mode. Both provide full read-write capabilities with random access.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like 객체&lt;/a&gt; 를 읽고 쓸 수있는 파일 로 사용할 수도 있습니다 . 문자열의 경우 &lt;a href=&quot;#io.StringIO&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; 는 텍스트 모드에서 열린 파일처럼 사용할 수 있습니다. &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 는 바이너리 모드로 열린 파일처럼 사용할 수 있습니다. 둘 다 임의 액세스와 함께 전체 읽기 / 쓰기 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c2f64b3927e28c8bd9e49f0275fac190fac8e34d" translate="yes" xml:space="preserve">
          <source>It is also possible to use a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; as a file for both reading and writing. For strings &lt;a href=&quot;#io.StringIO&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; can be used like a file opened in text mode. &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt; can be used like a file opened in binary mode. Both provide full read-write capabilities with random access.</source>
          <target state="translated">It is also possible to use a &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; as a file for both reading and writing. For strings &lt;a href=&quot;#io.StringIO&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; can be used like a file opened in text mode. &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; can be used like a file opened in binary mode. Both provide full read-write capabilities with random access.</target>
        </trans-unit>
        <trans-unit id="58451ee77d03223f613fe1da224a8696f7ed0741" translate="yes" xml:space="preserve">
          <source>It is also possible to use indexes different from 0, but you must know what you&amp;rsquo;re doing, just as in C: You can access or change arbitrary memory locations. Generally you only use this feature if you receive a pointer from a C function, and you &lt;em&gt;know&lt;/em&gt; that the pointer actually points to an array instead of a single item.</source>
          <target state="translated">0과 다른 인덱스를 사용하는 것도 가능하지만 C에서와 같이 수행중인 작업을 알아야합니다. 임의의 메모리 위치에 액세스하거나 변경할 수 있습니다. 일반적으로 당신이 C 함수에서 포인터를받을 경우에만이 기능을 사용하여, 당신은 &lt;em&gt;알고&lt;/em&gt; 포인터가 실제로 배열 대신에 단일 항목을 가리키는 것이다.</target>
        </trans-unit>
        <trans-unit id="7f8863324723aab745603c612674ad8820136acc" translate="yes" xml:space="preserve">
          <source>It is an error for &lt;code&gt;changes&lt;/code&gt; to contain any fields that are defined as having &lt;code&gt;init=False&lt;/code&gt;. A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised in this case.</source>
          <target state="translated">&lt;code&gt;init=False&lt;/code&gt; 로 정의 된 필드 를 &lt;code&gt;changes&lt;/code&gt; 에 포함 시키는 것은 오류입니다 . &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 이 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c40beea80b192f98b4ef0d6e82a60946f7b0973f" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;em&gt;buffer_callback&lt;/em&gt; is not None and &lt;em&gt;protocol&lt;/em&gt; is None or smaller than 5.</source>
          <target state="translated">&lt;em&gt;buffer_callback&lt;/em&gt; 이 None이 아니고 &lt;em&gt;protocol&lt;/em&gt; 이 None이거나 5보다 작은 경우 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="400a0f3110c595609b6c3b419668f8a9a2d9e88b" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;em&gt;themename&lt;/em&gt; already exists. If &lt;em&gt;parent&lt;/em&gt; is specified, the new theme will inherit styles, elements and layouts from the parent theme. If &lt;em&gt;settings&lt;/em&gt; are present they are expected to have the same syntax used for &lt;a href=&quot;#tkinter.ttk.Style.theme_settings&quot;&gt;&lt;code&gt;theme_settings()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;테마 이름이&lt;/em&gt; 이미 존재 하면 오류 입니다. 경우 &lt;em&gt;부모가&lt;/em&gt; 지정되면, 새로운 테마는 부모 테마의 스타일 요소와 레이아웃을 상속합니다. &lt;em&gt;설정&lt;/em&gt; 이 존재 하면 &lt;a href=&quot;#tkinter.ttk.Style.theme_settings&quot;&gt; &lt;code&gt;theme_settings()&lt;/code&gt; &lt;/a&gt; 와 동일한 구문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3cc9474ae763da1597037edc834b029615b066bd" translate="yes" xml:space="preserve">
          <source>It is an error to specify tuples for both &lt;em&gt;times&lt;/em&gt; and &lt;em&gt;ns&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;times&lt;/em&gt; 와 &lt;em&gt;ns에&lt;/em&gt; 대해 튜플을 지정하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="4b49de4f66d59503ff78e81f00969dd43035654c" translate="yes" xml:space="preserve">
          <source>It is assumed that &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; is a sequence. Items of &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; that are not strings referring to existing directories are ignored. Unicode items on &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; that cause errors when used as filenames may cause this function to raise an exception (in line with &lt;a href=&quot;os.path#os.path.isdir&quot;&gt;&lt;code&gt;os.path.isdir()&lt;/code&gt;&lt;/a&gt; behavior).</source>
          <target state="translated">&lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;/a&gt; 는 시퀀스 라고 가정합니다 . 기존 디렉토리를 참조하는 문자열이 아닌 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 의&lt;/a&gt; 항목 은 무시됩니다. 파일 이름으로 사용될 때 오류를 발생시키는 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 의&lt;/a&gt; 유니 코드 항목은 이 함수로 인해 예외가 발생할 수 있습니다 ( &lt;a href=&quot;os.path#os.path.isdir&quot;&gt; &lt;code&gt;os.path.isdir()&lt;/code&gt; &lt;/a&gt; 동작에 따라).</target>
        </trans-unit>
        <trans-unit id="0198f7955aa686bfda71617994f6d44009f39351" translate="yes" xml:space="preserve">
          <source>It is difficult to provide complete flexibility for incremental configuration. For example, because objects such as filters and formatters are anonymous, once a configuration is set up, it is not possible to refer to such anonymous objects when augmenting a configuration.</source>
          <target state="translated">증분 구성을위한 완전한 유연성을 제공하기는 어렵습니다. 예를 들어 필터 및 포맷터와 같은 개체는 익명이므로 구성이 설정되면 구성을 보강 할 때 이러한 익명 개체를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c9831b435206f2d98bf30605d962090f4a4c0bb" translate="yes" xml:space="preserve">
          <source>It is equal to &lt;code&gt;&quot;lib&quot;&lt;/code&gt; on most platforms. On Fedora and SuSE, it is equal to &lt;code&gt;&quot;lib64&quot;&lt;/code&gt; on 64-bit platforms which gives the following &lt;code&gt;sys.path&lt;/code&gt; paths (where &lt;code&gt;X.Y&lt;/code&gt; is the Python &lt;code&gt;major.minor&lt;/code&gt; version):</source>
          <target state="translated">It is equal to &lt;code&gt;&quot;lib&quot;&lt;/code&gt; on most platforms. On Fedora and SuSE, it is equal to &lt;code&gt;&quot;lib64&quot;&lt;/code&gt; on 64-bit platforms which gives the following &lt;code&gt;sys.path&lt;/code&gt; paths (where &lt;code&gt;X.Y&lt;/code&gt; is the Python &lt;code&gt;major.minor&lt;/code&gt; version):</target>
        </trans-unit>
        <trans-unit id="e876d5b634ed2ac0febedb41255584db8cd5eec6" translate="yes" xml:space="preserve">
          <source>It is expected that &lt;em&gt;name&lt;/em&gt; will be a string in one of the following formats, where W is shorthand for a valid Python identifier and dot stands for a literal period in these pseudo-regexes:</source>
          <target state="translated">It is expected that &lt;em&gt;name&lt;/em&gt; will be a string in one of the following formats, where W is shorthand for a valid Python identifier and dot stands for a literal period in these pseudo-regexes:</target>
        </trans-unit>
        <trans-unit id="0b8d428b0665acaca4a8a5c4e599c5757fb9e58f" translate="yes" xml:space="preserve">
          <source>It is for historical reasons that &lt;em&gt;dirname&lt;/em&gt; is named as such rather than &lt;em&gt;path&lt;/em&gt;.</source>
          <target state="translated">역사적인 이유로 &lt;em&gt;dirname&lt;/em&gt; 이 &lt;em&gt;path가&lt;/em&gt; 아닌 이름으로 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8aa1103190ac27a640efe27d8f90def24b585ee7" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to call &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; in some library routine, since as a side effect it affects the entire program. Saving and restoring it is almost as bad: it is expensive and affects other threads that happen to run before the settings have been restored.</source>
          <target state="translated">일반적으로 일부 라이브러리 루틴에서 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것은 좋지 않습니다 . 부작용으로 전체 프로그램에 영향을 미치기 때문입니다. 저장 및 복원은 거의 나쁩니다. 비용이 많이 들고 설정이 복원되기 전에 실행되는 다른 스레드에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="99fa0df2b3316d6bf82c33997b4364c06d01242a" translate="yes" xml:space="preserve">
          <source>It is generally not very useful to reload built-in or dynamically loaded modules. Reloading &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; and other key modules is not recommended. In many cases extension modules are not designed to be initialized more than once, and may fail in arbitrary ways when reloaded.</source>
          <target state="translated">일반적으로 내장 또는 동적으로로드 된 모듈을 다시로드하는 것은 그리 유용하지 않습니다. &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 및 기타 주요 모듈을 다시로드 하지 않는 것이 좋습니다. 대부분의 경우 확장 모듈은 두 번 이상 초기화되도록 설계되지 않았으며 다시로드 할 때 임의의 방식으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb0ca349a42e3b12e5d41231c5073aad2d937d17" translate="yes" xml:space="preserve">
          <source>It is illegal to move an item under one of its descendants. If &lt;em&gt;index&lt;/em&gt; is less than or equal to zero, &lt;em&gt;item&lt;/em&gt; is moved to the beginning; if greater than or equal to the number of children, it is moved to the end. If &lt;em&gt;item&lt;/em&gt; was detached it is reattached.</source>
          <target state="translated">하위 항목 중 하나로 항목을 이동하는 것은 불법입니다. 경우 &lt;em&gt;인덱스&lt;/em&gt; 보다 작거나 0 인, &lt;em&gt;제품의&lt;/em&gt; 선두로 이동한다; 자식 수보다 크거나 같은 경우 끝으로 이동합니다. 경우 &lt;em&gt;항목을&lt;/em&gt; 분리했다가 다시 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="95714223e048e09765010a9f06704454985fe259" translate="yes" xml:space="preserve">
          <source>It is important to ensure that &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; do not own any references to &lt;em&gt;obj&lt;/em&gt;, either directly or indirectly, since otherwise &lt;em&gt;obj&lt;/em&gt; will never be garbage collected. In particular, &lt;em&gt;func&lt;/em&gt; should not be a bound method of &lt;em&gt;obj&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;func&lt;/em&gt; , &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;kwargs&lt;/em&gt; 가 직접 또는 간접적으로 &lt;em&gt;obj에&lt;/em&gt; 대한 참조를 소유하지 않는 것이 중요합니다. 그렇지 않으면 &lt;em&gt;obj&lt;/em&gt; 가비지 수집되지 않습니다. 특히 &lt;em&gt;func&lt;/em&gt; 은 &lt;em&gt;obj&lt;/em&gt; 의 바인딩 된 메소드가 아니어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb8f43a85dd413c6cde8de7ffa05ec877b1e553b" translate="yes" xml:space="preserve">
          <source>It is important to note that modules in the &lt;a href=&quot;#module-xml&quot;&gt;&lt;code&gt;xml&lt;/code&gt;&lt;/a&gt; package require that there be at least one SAX-compliant XML parser available. The Expat parser is included with Python, so the &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; module will always be available.</source>
          <target state="translated">&lt;a href=&quot;#module-xml&quot;&gt; &lt;code&gt;xml&lt;/code&gt; &lt;/a&gt; 패키지의 모듈 에는 사용 가능한 SAX 호환 XML 파서가 하나 이상 있어야합니다. Expat 구문 분석기는 Python에 포함되어 있으므로 &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; &lt;/a&gt; 모듈을 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c82506febe72f22188b7f00df4e1ec93e22d7a" translate="yes" xml:space="preserve">
          <source>It is important to note that most regular expression operations are available as module-level functions and methods on &lt;a href=&quot;#re-objects&quot;&gt;compiled regular expressions&lt;/a&gt;. The functions are shortcuts that don&amp;rsquo;t require you to compile a regex object first, but miss some fine-tuning parameters.</source>
          <target state="translated">대부분의 정규 표현식 작업은 &lt;a href=&quot;#re-objects&quot;&gt;컴파일 된 정규 표현식&lt;/a&gt; 에서 모듈 수준 함수 및 메서드로 사용할 수 있습니다 . 함수는 먼저 정규식 객체를 컴파일 할 필요는 없지만 일부 미세 조정 매개 변수를 놓치는 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="624e6ff33f7bfbc731179c57fb95772ca83eb019" translate="yes" xml:space="preserve">
          <source>It is limited to 100 frames and 100 threads.</source>
          <target state="translated">100 개의 프레임과 100 개의 스레드로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="2865105771b6160f23eac9cb92cba66e1d8cd1a0" translate="yes" xml:space="preserve">
          <source>It is long enough to reduce the risk of test failure on the slowest Python buildbots. It should not be used to mark a test as failed if the test takes &amp;ldquo;too long&amp;rdquo;. The timeout value depends on the regrtest &lt;code&gt;--timeout&lt;/code&gt; command line option.</source>
          <target state="translated">It is long enough to reduce the risk of test failure on the slowest Python buildbots. It should not be used to mark a test as failed if the test takes &amp;ldquo;too long&amp;rdquo;. The timeout value depends on the regrtest &lt;code&gt;--timeout&lt;/code&gt; command line option.</target>
        </trans-unit>
        <trans-unit id="4093ccc8e1fc34ca326724ab26e7be0883220a09" translate="yes" xml:space="preserve">
          <source>It is meant to be used for functions that may accept any kind of string without allowing different kinds of strings to mix. For example:</source>
          <target state="translated">다른 종류의 문자열을 섞지 않고 모든 종류의 문자열을 받아 들일 수있는 함수에 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cb324071c8468030d58c64739521f9f962b39e8" translate="yes" xml:space="preserve">
          <source>It is not necessary to call &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; to change a key. Registry changes are flushed to disk by the registry using its lazy flusher. Registry changes are also flushed to disk at system shutdown. Unlike &lt;a href=&quot;#winreg.CloseKey&quot;&gt;&lt;code&gt;CloseKey()&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; method returns only when all the data has been written to the registry. An application should only call &lt;a href=&quot;#winreg.FlushKey&quot;&gt;&lt;code&gt;FlushKey()&lt;/code&gt;&lt;/a&gt; if it requires absolute certainty that registry changes are on disk.</source>
          <target state="translated">키를 변경하기 위해 &lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 를 호출 할 필요는 없습니다 . 레지스트리 변경은 지연 플러 셔를 사용하여 레지스트리에 의해 디스크로 플러시됩니다. 시스템 종료시 레지스트리 변경 사항도 디스크로 플러시됩니다. 달리 &lt;a href=&quot;#winreg.CloseKey&quot;&gt; &lt;code&gt;CloseKey()&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 모든 데이터가 레지스트리에 기록 된 유일한 방법 돌아갑니다. 레지스트리 변경 사항이 디스크에 있는지 확실하게 요구할 경우 응용 프로그램은 &lt;a href=&quot;#winreg.FlushKey&quot;&gt; &lt;code&gt;FlushKey()&lt;/code&gt; &lt;/a&gt; 만 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cda47d8387a594b66517d4092e4e115ad892fbe9" translate="yes" xml:space="preserve">
          <source>It is not possible to change the encoding or newline if some data has already been read from the stream. On the other hand, changing encoding after write is possible.</source>
          <target state="translated">스트림에서 일부 데이터를 이미 읽은 경우 인코딩 또는 줄 바꿈을 변경할 수 없습니다. 한편, 기록 후의 인코딩 변경이 가능하다.</target>
        </trans-unit>
        <trans-unit id="d740e3156e0552c31a2af22e49ad436d6f79d68d" translate="yes" xml:space="preserve">
          <source>It is not possible to create truly immutable Python objects. However, by passing &lt;code&gt;frozen=True&lt;/code&gt; to the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator you can emulate immutability. In that case, dataclasses will add &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;__setattr__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delattr__&quot;&gt;&lt;code&gt;__delattr__()&lt;/code&gt;&lt;/a&gt; methods to the class. These methods will raise a &lt;a href=&quot;#dataclasses.FrozenInstanceError&quot;&gt;&lt;code&gt;FrozenInstanceError&lt;/code&gt;&lt;/a&gt; when invoked.</source>
          <target state="translated">불변의 파이썬 객체를 생성하는 것은 불가능합니다. 그러나 &lt;code&gt;frozen=True&lt;/code&gt; 를 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 데코레이터에 전달하면 불변성을 에뮬레이션 할 수 있습니다. 이 경우 데이터 클래스는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;__setattr__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delattr__&quot;&gt; &lt;code&gt;__delattr__()&lt;/code&gt; &lt;/a&gt; 메서드를 클래스에 추가합니다. 이 메소드는 호출 될 때 &lt;a href=&quot;#dataclasses.FrozenInstanceError&quot;&gt; &lt;code&gt;FrozenInstanceError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8ac77add23b717e9d3af735f69af402dbc3a7c9b" translate="yes" xml:space="preserve">
          <source>It is not possible to create truly immutable Python objects. However, by passing &lt;code&gt;frozen=True&lt;/code&gt; to the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator you can emulate immutability. In that case, dataclasses will add &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;__setattr__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__delattr__&quot;&gt;&lt;code&gt;__delattr__()&lt;/code&gt;&lt;/a&gt; methods to the class. These methods will raise a &lt;a href=&quot;#dataclasses.FrozenInstanceError&quot;&gt;&lt;code&gt;FrozenInstanceError&lt;/code&gt;&lt;/a&gt; when invoked.</source>
          <target state="translated">It is not possible to create truly immutable Python objects. However, by passing &lt;code&gt;frozen=True&lt;/code&gt; to the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; decorator you can emulate immutability. In that case, dataclasses will add &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;__setattr__()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__delattr__&quot;&gt; &lt;code&gt;__delattr__()&lt;/code&gt; &lt;/a&gt; methods to the class. These methods will raise a &lt;a href=&quot;#dataclasses.FrozenInstanceError&quot;&gt; &lt;code&gt;FrozenInstanceError&lt;/code&gt; &lt;/a&gt; when invoked.</target>
        </trans-unit>
        <trans-unit id="55c8b8a4e69ed2aef84c5a02c66e3da2e510e6b7" translate="yes" xml:space="preserve">
          <source>It is not possible to interrupt the &lt;code&gt;acquire()&lt;/code&gt; method on a lock &amp;mdash; the &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exception will happen after the lock has been acquired.</source>
          <target state="translated">잠금 에서는 &lt;code&gt;acquire()&lt;/code&gt; 메소드 를 중단 할 수 없습니다 . 잠금이 획득 된 후 &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="24ff4ffa82b2b892ee254ff767fd50df824c9ec4" translate="yes" xml:space="preserve">
          <source>It is not recommended to instantiate &lt;em&gt;StreamReader&lt;/em&gt; objects directly; use &lt;a href=&quot;#asyncio.open_connection&quot;&gt;&lt;code&gt;open_connection()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.start_server&quot;&gt;&lt;code&gt;start_server()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;em&gt;StreamReader&lt;/em&gt; 객체를 직접 인스턴스화하지 않는 것이 좋습니다 . 사용 &lt;a href=&quot;#asyncio.open_connection&quot;&gt; &lt;code&gt;open_connection()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.start_server&quot;&gt; &lt;code&gt;start_server()&lt;/code&gt; &lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="9c8eb1dc59babd5bb45a6542412c6c2dbef60bec" translate="yes" xml:space="preserve">
          <source>It is not recommended to instantiate &lt;em&gt;StreamWriter&lt;/em&gt; objects directly; use &lt;a href=&quot;#asyncio.open_connection&quot;&gt;&lt;code&gt;open_connection()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.start_server&quot;&gt;&lt;code&gt;start_server()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;em&gt;StreamWriter&lt;/em&gt; 객체를 직접 인스턴스화하지 않는 것이 좋습니다 . 사용 &lt;a href=&quot;#asyncio.open_connection&quot;&gt; &lt;code&gt;open_connection()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.start_server&quot;&gt; &lt;code&gt;start_server()&lt;/code&gt; &lt;/a&gt; 대신합니다.</target>
        </trans-unit>
        <trans-unit id="f7c86d9042354a4a12010ffbf2e6c79a46e63619" translate="yes" xml:space="preserve">
          <source>It is occasionally desirable to catch exceptions from an &lt;code&gt;__enter__&lt;/code&gt; method implementation, &lt;em&gt;without&lt;/em&gt; inadvertently catching exceptions from the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement body or the context manager&amp;rsquo;s &lt;code&gt;__exit__&lt;/code&gt; method. By using &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; the steps in the context management protocol can be separated slightly in order to allow this:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 본문 또는 컨텍스트 관리자의 &lt;code&gt;__exit__&lt;/code&gt; 메소드 에서 실수로 예외를 catch &lt;em&gt;하지 않고 &lt;/em&gt; &lt;code&gt;__enter__&lt;/code&gt; 메소드 구현 에서 예외를 포착하는 것이 때때로 바람직합니다 . &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 을 사용 하여 컨텍스트 관리 프로토콜의 단계를 약간 분리하여이를 허용 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e25f46cefd68c273b90476861ac7cb60e39c31cc" translate="yes" xml:space="preserve">
          <source>It is occasionally desirable to catch exceptions from an &lt;code&gt;__enter__&lt;/code&gt; method implementation, &lt;em&gt;without&lt;/em&gt; inadvertently catching exceptions from the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement body or the context manager&amp;rsquo;s &lt;code&gt;__exit__&lt;/code&gt; method. By using &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; the steps in the context management protocol can be separated slightly in order to allow this:</source>
          <target state="translated">It is occasionally desirable to catch exceptions from an &lt;code&gt;__enter__&lt;/code&gt; method implementation, &lt;em&gt;without&lt;/em&gt; inadvertently catching exceptions from the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; statement body or the context manager&amp;rsquo;s &lt;code&gt;__exit__&lt;/code&gt; method. By using &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; the steps in the context management protocol can be separated slightly in order to allow this:</target>
        </trans-unit>
        <trans-unit id="17abe925d75df3e6434e095da340d7b3d585efbb" translate="yes" xml:space="preserve">
          <source>It is possible (but not likely) that the parser stops parsing with a successful outcome before reaching the end of the source; in this case, trailing symbols may be ignored instead of causing an error. For example, a backslash followed by two newlines may be followed by arbitrary garbage. This will be fixed once the API for the parser is better.</source>
          <target state="translated">파서가 소스의 끝에 도달하기 전에 성공적인 결과로 파싱을 중지하는 것이 가능하지만 (아마도) 가능하지는 않습니다. 이 경우 오류를 발생시키는 대신 후행 기호가 무시 될 수 있습니다. 예를 들어, 백 슬래시 다음에 두 줄 바꿈 뒤에 임의 가비지가 올 수 있습니다. 파서의 API가 더 좋으면 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d4dc91e3e444d1207eacfb1b8c9b7d64f669d0" translate="yes" xml:space="preserve">
          <source>It is possible that you want to use a different prefix for your tests. You can inform the patchers of the different prefix by setting &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt;:</source>
          <target state="translated">테스트에 다른 접두사를 사용하고 싶을 수도 있습니다. 당신은 설정에 의해 다른 접두사의 구혈 알릴 수 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="e82dbe871f90899f7a19bde1d2a710623cd64537" translate="yes" xml:space="preserve">
          <source>It is possible to add a node with no dependencies (&lt;em&gt;predecessors&lt;/em&gt; is not provided) or to provide a dependency twice. If a node that has not been provided before is included among &lt;em&gt;predecessors&lt;/em&gt; it will be automatically added to the graph with no predecessors of its own.</source>
          <target state="translated">It is possible to add a node with no dependencies (&lt;em&gt;predecessors&lt;/em&gt; is not provided) or to provide a dependency twice. If a node that has not been provided before is included among &lt;em&gt;predecessors&lt;/em&gt; it will be automatically added to the graph with no predecessors of its own.</target>
        </trans-unit>
        <trans-unit id="b78bc02a5d38d5ce034759672aa988ab58493d7c" translate="yes" xml:space="preserve">
          <source>It is possible to assign a callable Python object that is not a ctypes type, in this case the function is assumed to return a C &lt;code&gt;int&lt;/code&gt;, and the callable will be called with this integer, allowing further processing or error checking. Using this is deprecated, for more flexible post processing or error checking use a ctypes data type as &lt;a href=&quot;#ctypes._FuncPtr.restype&quot;&gt;&lt;code&gt;restype&lt;/code&gt;&lt;/a&gt; and assign a callable to the &lt;a href=&quot;#ctypes._FuncPtr.errcheck&quot;&gt;&lt;code&gt;errcheck&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">ctypes 유형이 아닌 호출 가능한 Python 객체를 할당 할 수 있습니다.이 경우 함수는 C &lt;code&gt;int&lt;/code&gt; 를 리턴하는 것으로 가정 되며이 정수 로 호출 가능 객체가 호출되어 추가 처리 또는 오류 검사가 가능합니다. 더 유연한 사후 처리 또는 오류 검사를 위해 ctypes 데이터 유형을 &lt;a href=&quot;#ctypes._FuncPtr.restype&quot;&gt; &lt;code&gt;restype&lt;/code&gt; 으로 사용&lt;/a&gt; 하고 호출 가능을 &lt;a href=&quot;#ctypes._FuncPtr.errcheck&quot;&gt; &lt;code&gt;errcheck&lt;/code&gt; &lt;/a&gt; 속성에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a0369df82e65498d9a61cbbea72fb5715a7cfcd6" translate="yes" xml:space="preserve">
          <source>It is possible to construct malicious pickle data which will &lt;strong&gt;execute arbitrary code during unpickling&lt;/strong&gt;. Never unpickle data that could have come from an untrusted source, or that could have been tampered with.</source>
          <target state="translated">&lt;strong&gt;unpickling 동안 임의의 코드&lt;/strong&gt; 를 &lt;strong&gt;실행&lt;/strong&gt; 하는 악성 pickle 데이터를 구성 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 신뢰할 수없는 출처에서 가져 왔거나 변조되었을 수있는 데이터는 절대로 피클 링하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6ffefb08180256f54248ce087946347d3dc7ebe6" translate="yes" xml:space="preserve">
          <source>It is possible to crash the Python interpreter when loading a database with a sufficiently large/complex entry due to stack depth limitations in Python&amp;rsquo;s AST compiler.</source>
          <target state="translated">Python의 AST 컴파일러의 스택 깊이 제한으로 인해 충분히 크거나 복잡한 항목이있는 데이터베이스를로드 할 때 Python 인터프리터가 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e9b153eb1d2d572d629baf0a1dcd8a08f67d846" translate="yes" xml:space="preserve">
          <source>It is possible to crash the Python interpreter with a sufficiently large/complex string due to stack depth limitations in Python&amp;rsquo;s AST compiler.</source>
          <target state="translated">파이썬 AST 컴파일러의 스택 깊이 제한으로 인해 파이썬 인터프리터가 충분히 크거나 복잡한 문자열로 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="667abe8e68a549284d45ff70fd062fc2cf5fac92" translate="yes" xml:space="preserve">
          <source>It is possible to crash the Python interpreter with a sufficiently large/complex string when compiling to an AST object due to stack depth limitations in Python&amp;rsquo;s AST compiler.</source>
          <target state="translated">Python의 AST 컴파일러의 스택 깊이 제한으로 인해 AST 객체로 컴파일 할 때 충분히 큰 / 복잡한 문자열로 Python 인터프리터가 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f5b20068a1b037beccc1359b62759b16ab15b78" translate="yes" xml:space="preserve">
          <source>It is possible to create shared objects using shared memory which can be inherited by child processes.</source>
          <target state="translated">자식 프로세스가 상속 할 수있는 공유 메모리를 사용하여 공유 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5f47167a007557bb807d93cb531c2ebd09d5d5" translate="yes" xml:space="preserve">
          <source>It is possible to create structures and unions containing bit fields. Bit fields are only possible for integer fields, the bit width is specified as the third item in the &lt;code&gt;_fields_&lt;/code&gt; tuples:</source>
          <target state="translated">비트 필드를 포함하는 구조체와 공용체를 만들 수 있습니다. 비트 필드는 정수 필드에만 가능하며 비트 너비는 &lt;code&gt;_fields_&lt;/code&gt; 튜플 에서 세 번째 항목으로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="db8a275af694f0dd377aeb7a61522ec616a0f705" translate="yes" xml:space="preserve">
          <source>It is possible to declare the return type of a callable without specifying the call signature by substituting a literal ellipsis for the list of arguments in the type hint: &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt;.</source>
          <target state="translated">유형 힌트의 인수 목록에 리터럴 줄임표를 대입하여 Call signature &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; 호출하여 호출 서명을 지정하지 않고 호출 가능의 리턴 유형을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66dbfac9c9ecbf0f3ba234b858bf45197be29989" translate="yes" xml:space="preserve">
          <source>It is possible to define sub-subclasses of structure types, they inherit the fields of the base class plus the &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; defined in the sub-subclass, if any.</source>
          <target state="translated">구조 유형 의 서브 서브 클래스를 정의 할 수 있으며, 서브 클래스에 정의 된 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 와 기본 클래스의 필드를 상속합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="52e02a5e8d810a438d07f3c505bb28740bdb60d9" translate="yes" xml:space="preserve">
          <source>It is possible to define sub-subclasses of structures, they inherit the fields of the base class. If the subclass definition has a separate &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; variable, the fields specified in this are appended to the fields of the base class.</source>
          <target state="translated">구조의 하위 서브 클래스를 정의 할 수 있으며 기본 클래스의 필드를 상속합니다. 서브 클래스 정의에 별도의 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 변수 가 있으면 여기에 지정된 필드가 기본 클래스의 필드에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="479dec54822844d5952dff407e0c75c4abf7dfbc" translate="yes" xml:space="preserve">
          <source>It is possible to define the &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; class variable &lt;em&gt;after&lt;/em&gt; the class statement that defines the Structure subclass, this allows creating data types that directly or indirectly reference themselves:</source>
          <target state="translated">그것은 정의 할 수있다 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; 의&lt;/a&gt; 클래스 변수 &lt;em&gt;후에&lt;/em&gt; 구조 서브 클래스를 정의하는 문장이 직접 또는 간접적으로 자신을 참조 데이터 타입을 만들 수있게 :</target>
        </trans-unit>
        <trans-unit id="41dc430c996cb5dba1d5b954f315a11cad50c234" translate="yes" xml:space="preserve">
          <source>It is possible to modify how Enum members are pickled/unpickled by defining &lt;a href=&quot;pickle#object.__reduce_ex__&quot;&gt;&lt;code&gt;__reduce_ex__()&lt;/code&gt;&lt;/a&gt; in the enumeration class.</source>
          <target state="translated">열거 클래스에서 &lt;a href=&quot;pickle#object.__reduce_ex__&quot;&gt; &lt;code&gt;__reduce_ex__()&lt;/code&gt; &lt;/a&gt; 를 정의하여 열거 멤버를 선택 / 선택 해제하는 방법을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c6a93b23d9d0ef75736ca0a792ff0ce4b6aa42c" translate="yes" xml:space="preserve">
          <source>It is possible to provide a setup statement that is executed only once at the beginning:</source>
          <target state="translated">처음에 한 번만 실행되는 설정 명령문을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aaa2207bb2559e1c452bea74e3b02c4226e1a08" translate="yes" xml:space="preserve">
          <source>It is possible to run a manager server on one machine and have clients use it from other machines (assuming that the firewalls involved allow it).</source>
          <target state="translated">한 시스템에서 관리자 서버를 실행하고 클라이언트가 다른 시스템에서 사용하도록 할 수 있습니다 (관련 방화벽이 허용한다고 가정).</target>
        </trans-unit>
        <trans-unit id="57b2132f9f4ecae5672296c54e7165dcd43d470b" translate="yes" xml:space="preserve">
          <source>It is possible to specify the required argument types of functions exported from DLLs by setting the &lt;code&gt;argtypes&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;argtypes&lt;/code&gt; 속성 을 설정하여 DLL에서 내 보낸 함수의 필수 인수 유형을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="870efee18a65f0470db8320acfa65e0397dea3dc" translate="yes" xml:space="preserve">
          <source>It is preferred that tests that use the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; module follow a few guidelines. One is to name the test module by starting it with &lt;code&gt;test_&lt;/code&gt; and end it with the name of the module being tested. The test methods in the test module should start with &lt;code&gt;test_&lt;/code&gt; and end with a description of what the method is testing. This is needed so that the methods are recognized by the test driver as test methods. Also, no documentation string for the method should be included. A comment (such as &lt;code&gt;# Tests function returns only True or False&lt;/code&gt;) should be used to provide documentation for test methods. This is done because documentation strings get printed out if they exist and thus what test is being run is not stated.</source>
          <target state="translated">&lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 테스트 는 몇 가지 지침을 따르는 것이 좋습니다. 하나는 &lt;code&gt;test_&lt;/code&gt; 로 시작하여 테스트 모듈의 이름을 지정하고 테스트중인 모듈 의 이름으로 종료하는 것입니다. 테스트 모듈의 테스트 메소드는 &lt;code&gt;test_&lt;/code&gt; 로 시작하여 테스트중인 메소드에 대한 설명으로 끝나야합니다. 이는 메소드가 테스트 드라이버에 의해 테스트 메소드로 인식되도록하기 위해 필요합니다. 또한 메소드에 대한 문서 문자열을 포함하지 않아야합니다. 테스트 메소드에 대한 문서를 제공하려면 주석 (예 : &lt;code&gt;# Tests function returns only True or False&lt;/code&gt; )을 사용해야합니다. 이것은 문서화 문자열이 존재하는 경우 인쇄되어 실행중인 테스트가 명시되지 않았기 때문에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4437dd782d3aa5f4d33ce55912438ab2de9ddb49" translate="yes" xml:space="preserve">
          <source>It is probably best to stick to using queues or pipes for communication between processes rather than using the lower level synchronization primitives.</source>
          <target state="translated">하위 레벨 동기화 기본 요소를 사용하는 대신 프로세스 간 통신에 큐 또는 파이프를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3513dd531e92db2dd18418ab9200aa8630263c69" translate="yes" xml:space="preserve">
          <source>It is recommended that you use TestCase implementations to group tests together according to the features they test. &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; provides a mechanism for this: the &lt;em&gt;test suite&lt;/em&gt;, represented by &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; class. In most cases, calling &lt;a href=&quot;#unittest.main&quot;&gt;&lt;code&gt;unittest.main()&lt;/code&gt;&lt;/a&gt; will do the right thing and collect all the module&amp;rsquo;s test cases for you and execute them.</source>
          <target state="translated">TestCase 구현을 사용하여 테스트하는 기능에 따라 테스트를 그룹화하는 것이 좋습니다. &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 클래스로 표시되는 &lt;em&gt;테스트 스위트를&lt;/em&gt; 위한 메커니즘을 제공합니다 . 대부분의 경우 &lt;a href=&quot;#unittest.main&quot;&gt; &lt;code&gt;unittest.main()&lt;/code&gt; &lt;/a&gt; 을 호출 하면 올바른 작업을 수행하고 모든 모듈의 테스트 사례를 수집하여 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7ee962c8bcd7baffe9ba130a3118c335c829f4d0" translate="yes" xml:space="preserve">
          <source>It is responsible for calling all the cleanup functions added by &lt;a href=&quot;#unittest.TestCase.addCleanup&quot;&gt;&lt;code&gt;addCleanup()&lt;/code&gt;&lt;/a&gt;. If you need cleanup functions to be called &lt;em&gt;prior&lt;/em&gt; to &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt;&lt;code&gt;tearDown()&lt;/code&gt;&lt;/a&gt; then you can call &lt;a href=&quot;#unittest.TestCase.doCleanups&quot;&gt;&lt;code&gt;doCleanups()&lt;/code&gt;&lt;/a&gt; yourself.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.addCleanup&quot;&gt; &lt;code&gt;addCleanup()&lt;/code&gt; &lt;/a&gt; 에 의해 추가 된 모든 정리 함수를 호출합니다 . &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt; &lt;code&gt;tearDown()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 이전&lt;/em&gt; 에 정리 함수를 호출 &lt;a href=&quot;#unittest.TestCase.doCleanups&quot;&gt; &lt;code&gt;doCleanups()&lt;/code&gt; &lt;/a&gt; 직접 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66da881a51744abc2d365ae7a19e8866de644b04" translate="yes" xml:space="preserve">
          <source>It is responsible for calling all the cleanup functions added by &lt;code&gt;addCleanupClass()&lt;/code&gt;. If you need cleanup functions to be called &lt;em&gt;prior&lt;/em&gt; to &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt;&lt;code&gt;tearDownClass()&lt;/code&gt;&lt;/a&gt; then you can call &lt;code&gt;doCleanupsClass()&lt;/code&gt; yourself.</source>
          <target state="translated">&lt;code&gt;addCleanupClass()&lt;/code&gt; 에 의해 추가 된 모든 정리 함수를 호출합니다 . &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt; &lt;code&gt;tearDownClass()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 이전&lt;/em&gt; 에 정리 함수를 호출 &lt;code&gt;doCleanupsClass()&lt;/code&gt; 직접 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44bfa96d5424e117886453b18001094b089f64bd" translate="yes" xml:space="preserve">
          <source>It is responsible for calling all the cleanup functions added by &lt;code&gt;addCleanupModule()&lt;/code&gt;. If you need cleanup functions to be called &lt;em&gt;prior&lt;/em&gt; to &lt;code&gt;tearDownModule()&lt;/code&gt; then you can call &lt;a href=&quot;#unittest.doModuleCleanups&quot;&gt;&lt;code&gt;doModuleCleanups()&lt;/code&gt;&lt;/a&gt; yourself.</source>
          <target state="translated">&lt;code&gt;addCleanupModule()&lt;/code&gt; 에 의해 추가 된 모든 정리 함수를 호출합니다 . &lt;code&gt;tearDownModule()&lt;/code&gt; &lt;em&gt;이전&lt;/em&gt; 에 정리 함수를 호출 &lt;a href=&quot;#unittest.doModuleCleanups&quot;&gt; &lt;code&gt;doModuleCleanups()&lt;/code&gt; &lt;/a&gt; 직접 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40d076e54c14795bf1009ae955624fb9ee075980" translate="yes" xml:space="preserve">
          <source>It is set for &lt;code&gt;SELECT&lt;/code&gt; statements without any matching rows as well.</source>
          <target state="translated">일치하는 행이없는 &lt;code&gt;SELECT&lt;/code&gt; 문에도 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4892c14dd8e03e95f7b9a46c2b927e82c3de81e" translate="yes" xml:space="preserve">
          <source>It is similar to &lt;a href=&quot;#opcode-END_FINALLY&quot;&gt;&lt;code&gt;END_FINALLY&lt;/code&gt;&lt;/a&gt;, but doesn&amp;rsquo;t change the bytecode counter nor raise an exception. Used for implementing &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#break&quot;&gt;&lt;code&gt;break&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#continue&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#opcode-END_FINALLY&quot;&gt; &lt;code&gt;END_FINALLY&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 바이트 코드 카운터를 변경하거나 예외를 발생시키지 않습니다. 구현에 사용 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#break&quot;&gt; &lt;code&gt;break&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#continue&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 블록.</target>
        </trans-unit>
        <trans-unit id="42d9754d1dda336bfe25a9c6e63c2992d8307a7e" translate="yes" xml:space="preserve">
          <source>It is straightforward to create an ordered dictionary variant that remembers the order the keys were &lt;em&gt;last&lt;/em&gt; inserted. If a new entry overwrites an existing entry, the original insertion position is changed and moved to the end:</source>
          <target state="translated">키가 &lt;em&gt;마지막으로&lt;/em&gt; 삽입 된 순서를 기억하는 정렬 된 사전 변형을 작성하는 것은 간단합니다 . 새 항목이 기존 항목을 덮어 쓰면 원래 삽입 위치가 변경되고 끝으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b290678be018032e40bcd30baa36d13bcef66f17" translate="yes" xml:space="preserve">
          <source>It is the application&amp;rsquo;s responsibility to ensure that all whitespace and special characters are quoted appropriately to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;shell injection&lt;/a&gt; vulnerabilities. The &lt;a href=&quot;shlex#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; function can be used to properly escape whitespace and special characters in strings that are going to be used to construct shell commands.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;쉘 삽입&lt;/a&gt; 취약점 을 피하기 위해 모든 공백과 특수 문자가 적절하게 인용되도록하는 것은 응용 프로그램의 책임 입니다. &lt;a href=&quot;shlex#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 기능이 제대로 구조 쉘 명령에 사용하려고하는 문자열의 공백 및 특수 문자를 이스케이프하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83308bc4ef3c9f055207277d114b19f86e753316" translate="yes" xml:space="preserve">
          <source>It is the application&amp;rsquo;s responsibility to ensure that all whitespace and special characters are quoted appropriately to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;shell injection&lt;/a&gt; vulnerabilities. The &lt;a href=&quot;shlex#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; function can be used to properly escape whitespace and special shell characters in strings that are going to be used to construct shell commands.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Shell_injection#Shell_injection&quot;&gt;쉘 삽입&lt;/a&gt; 취약점 을 피하기 위해 모든 공백과 특수 문자가 적절하게 인용되도록하는 것은 응용 프로그램의 책임 입니다. &lt;a href=&quot;shlex#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 기능이 제대로 구조 쉘 명령에 사용하려고하는 문자열의 공백 및 특수 쉘 문자를 이스케이프하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba77524bde6cf6c11d179f96eb65e17908025854" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ellipsis&lt;/code&gt; 또는 &lt;code&gt;...&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c82f78122d7edace8ca573121d93f7a6333cafc" translate="yes" xml:space="preserve">
          <source>It is written as &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 으로 기록됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
